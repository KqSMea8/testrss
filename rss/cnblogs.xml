<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>LNMP环境搭建记录（源码方式） - cfYu</title>
<link>http://www.cnblogs.com/cfYu/p/9446392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cfYu/p/9446392.html</guid>
<description>

&lt;p&gt;　　LNMP指的是在Linux下用PHP+MYSQL+NGIX搭建网站的环境。&lt;/p&gt;
&lt;p&gt;　　Nginx是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。Nginx不仅可以作为web服务器,也可以作为负载均衡器。&lt;/p&gt;
&lt;p&gt;　　MySQL是一款开源免费的数据软件,MySQL是一个小型关系型数据库管理系统，其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，许多中小型网站为了降低网站总体拥有成本而选择了MySQL作为网站数据库.&lt;/p&gt;
&lt;p&gt;　　PHP，是英文超级文本预处理语言Hypertext Preprocessor的缩写。PHP 是一种 HTML 内嵌式的语言，是一种在服务器端执行的嵌入HTML文档的脚本语言，其源码是由C语言写成的，故风格也与C语言类似，被广泛的运用于搭建中小型网站。&lt;/p&gt;
&lt;p&gt;　　下面就记录一下LNMP环境的搭建过程，题主的Linux环境是CentOs虚拟镜像。&lt;/p&gt;
&lt;p&gt;【Nginx安装】&lt;/p&gt;
&lt;p&gt;　　目前最新的Nginx稳定版本是1.14.0，网址为http://nginx.org/en/download.html，可直接在Windows下载好再rz上传到Linux下，也可直接用wget方式下载，下面列出的下载方式是后者。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
cd /usr/src          #一般将源码放在此目录下&lt;br/&gt;wget http://nginx.org/download/nginx-1.14.0.tar.gz  #安装
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714223002501-837374191.png&quot; alt=&quot;&quot;/&gt;
&lt;pre&gt;
注意：nginx的安装依赖zlib-devel pcre-devel openssl-devel 这几个包，故我们在安装nginx前需先安装这几个包，以免安装过程中出错。&lt;br/&gt;yum -y install zlib-devel pcre-devel openssl-devel
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714223217603-2091895186.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;........&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714223248389-506580107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　一般源码安装分为4个步骤，&lt;code&gt;解压&lt;/code&gt;(tar命令)&lt;code&gt;预编译&lt;/code&gt;(执行源码包下的configure),&lt;code&gt;编译&lt;/code&gt;(make),&lt;code&gt;编译安装&lt;/code&gt;(make install) 。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解压&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
tar -zxvf nginx-1.14.0.tar.gz   #这里解释下加压参数,z代表gzip(也就是后面的.gz文件)x代表加压,v表示显示详细信息,-f使用档案文件或设备(必选参数)
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714224019549-1595800094.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　2. 预编译&lt;/p&gt;
&lt;p&gt;　　我们进行预编译的时候,一般会带上一些参数,已达到我们想要安装的效果,比如启用某个功能,禁用某个功能:&lt;/p&gt;
&lt;p&gt;进入源码包目录进行预编译:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
cd nginx-1.14.0
 ./configure --prefix=/data/webserver/nginx\   # 指定安装目录为/usr/local/nginx
--with-openssl=/usr/include/openssl\  # 启用ssl
--with-pcre\                          # 启用正规表达式
--with-http_stub_status_module        # 安装可以查看nginx状态的程序
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714224857822-1586981247.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;  　　　　　　　　　　　　　　　　　　　　 ......　　&lt;/p&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714224943285-1650036164.png&quot; alt=&quot;&quot;/&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　 3、编译&lt;/p&gt;
&lt;p&gt;　　./configure指执行当前目录下的&lt;code&gt;configure&lt;/code&gt;文件，预编译完成后我们就可以进行编译和安装:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
make   #编译
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714225251322-1636757799.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;.　　　　　　　　　　　　　　　　　　　　　　　　....&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714225213639-213436079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;4、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
make install #安装
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714225443363-623934608.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　....　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714225543233-1043304364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　　安装完成后我们可以到相应的目录查看安装的文件: &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
ls /data/webserver/nginx
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714225755073-1429485523.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　  接着就可以启动nginx了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
/data/webserver/nginx/sbin/nginx   #启动nginx

/data/webserver/nginx/sbin/nginx -s stop #停止nginx

/data/webserver/nginx/sbin/nginx -s relaod #重启nginx
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714230205392-286123091.png&quot; alt=&quot;&quot;/&gt;   &lt;/div&gt;
&lt;p&gt; #由图可知nginx已启动  &lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
netstat -antlp ¦ grep 80  #nginx占用TCP的80端口由图也可知nginx已启动
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180714230419127-1314900223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【MySQL安装】　　&lt;/p&gt;
&lt;p&gt;　　至此，nginx已安装启动完毕，接着我们来安装MySQL，类似的，我们依旧需要先安装MySQL的依赖包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715180405377-1523738788.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　.......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715180441351-1134196740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　接着我们下载源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715181022036-1420285760.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　.......&lt;/p&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715182009780-859134596.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　创建mysql用户:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
 groupadd mysql
 useradd -r -g mysql -s /bin/false mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建安装目录和数据目录:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mkdir -p /usr/local/mysql
mkdir -p /data/mysql
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715182518743-390512802.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　解压源码包:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
 tar -zxf mysql-boost-8.0.11.tar.gz -C /usr/local
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715182459103-2074969769.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　编译&amp;amp;安装:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
cd /usr/local/mysql-8.0.11
cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql &lt;br/&gt;-DMYSQL_DATADIR=/usr/local/mysql/data &lt;br/&gt;-DSYSCONFDIR=/etc &lt;br/&gt;-DMYSQL_TCP_PORT=3306 &lt;br/&gt;-DWITH_BOOST=/usr/local/mysql-8.0.11/boost 
make  &amp;amp;&amp;amp; make install
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180715212527682-127166384.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　安装成功后我们可启动mysql：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
cd /usr/local/mysql&lt;br/&gt;bin/mysqld_safe --user=mysql 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动成功，连接mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
bin/mysql -uroot -p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时要求输入连接密码，比较旧的版本的mysql安装时默认密码为空，但该5.7之后的版本有默认的密码，由于我们不知道，因此关闭mysql服务后（可直接查询进程根据进程号kill掉或/etc/init.d/mysql stop ），改用跳过密码的方式重新开启mysql服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
bin/mysqld_safe --user=mysql &amp;amp; skip-grant-tables
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重新连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
bin/mysql -uroot 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　连接成功后修改密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
mysql&amp;gt; UPDATE user SET Password=PASSWORD('newpassword') where USER='root';&lt;br/&gt;mysql&amp;gt; FLUSH PRIVILEGES; &lt;strong&gt;#必须刷新权限才能生效
&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时重启mysql服务，便可以账号密码方式连接mysql。&lt;/p&gt;

&lt;p&gt;　　关于mysql安装时的一些常见错误，可参考https://typecodes.com/web/solvemysqlcompileerror.html或http://www.voidcn.com/article/p-avqyeoec-sz.html，在源码编译安装mysql的时候，踩了很多的坑，参考的博文写的非常详细，感谢~&lt;/p&gt;

&lt;p&gt;【PHP安装】&lt;/p&gt;
&lt;p&gt;　　先安装php依赖包，否则在编译安装php7的过程当中会出现各种报错，安装完成后即可进入下一个环节。&lt;/p&gt;
&lt;p&gt;　　安装扩展包并更新系统内核：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
yum install epel-release -y
yum update
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装php依赖组件（包含Nginx依赖），前面nginx以及mysql安装过的可以忽略，也可以直接复制运行，会跳过已安装的依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
yum -y install wget vim pcre pcre-devel openssl openssl-devel libicu-devel gcc gcc-c++ autoconf libjpeg libjpeg-devel &lt;br/&gt;libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel &lt;br/&gt;ncurses ncurses-devel curl curl-devel krb5-devel libidn libidn-devel openldap openldap-devel nss_ldap jemalloc-devel &lt;br/&gt;cmake boost-devel bison automake libevent libevent-devel gd gd-devel libtool* libmcrypt libmcrypt-devel mcrypt mhash &lt;br/&gt;libxslt libxslt-devel readline readline-devel gmp gmp-devel libcurl libcurl-devel openjpeg-devel
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180718230207138-1279870710.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　　　　　　　　　　　........&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180718230228923-1724755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt; 　　创建用户和组，并下载php安装包解压：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
cd /tmp
groupadd www
useradd -g www www
wget http://cn2.php.net/distributions/php-7.2.0.tar.gz
tar xvf php-7.2.1.tar.gz
cd php-7.2.0
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180718230510554-593695890.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　设置变量并开始源码编译：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
cp -frp /usr/lib64/libldap* /usr/lib/
./configure --prefix=/data/webserver/php \
--with-config-file-path=/data/webserver/php/etc \
--enable-fpm \
--with-fpm-user=www \
--with-fpm-group=www \
--enable-mysqlnd \
--with-mysqli=mysqlnd \
--with-pdo-mysql=mysqlnd \
--enable-mysqlnd-compression-support \
--with-iconv-dir \
--with-freetype-dir \
--with-jpeg-dir \
--with-png-dir \
--with-zlib \
--with-libxml-dir \
--enable-xml \
--disable-rpath \
--enable-bcmath \
--enable-shmop \
--enable-sysvsem \
--enable-inline-optimization \
--with-curl \
--enable-mbregex \
--enable-mbstring \
--enable-intl \
--with-mcrypt \
--with-libmbfl \
--enable-ftp \
--with-gd \
--enable-gd-jis-conv \
--enable-gd-native-ttf \
--with-openssl \
--with-mhash \
--enable-pcntl \
--enable-sockets \
--with-xmlrpc \
--enable-zip \
--enable-soap \
--with-gettext \
--disable-fileinfo \
--enable-opcache \
--with-pear \
--enable-maintainer-zts \
--with-ldap=shared \
--without-gdbm \
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180718230956914-265733756.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　开始安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
make -j 4 &amp;amp;&amp;amp; make install
&lt;/pre&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1268416/201807/1268416-20180718232707554-445794035.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;　　 完成安装后配置php.ini文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
cp php.ini-development /data/webserver/php/etc/php.ini
cp /data/webserver/php/etc/php-fpm.conf.default /data/webserver/php/etc/php-fpm.conf
cp /data/webserver/php/etc/php-fpm.d/www.conf.default /data/webserver/php/etc/php-fpm.d/www.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改 php.ini 相关参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
vim /data/webserver/php/etc/php.ini

expose_php = Off
short_open_tag = ON
max_execution_time = 300
max_input_time = 300
memory_limit = 128M
post_max_size = 32M
date.timezone = Asia/Shanghai
mbstring.func_overload=2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重启PHP，至此LNMP环境已搭建完成。&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 15:26:00 +0000</pubDate>
<dc:creator>cfYu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cfYu/p/9446392.html</dc:identifier>
</item>
<item>
<title>Java之枚举类 - 大凌轩</title>
<link>http://www.cnblogs.com/dalingxuan/p/9446088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dalingxuan/p/9446088.html</guid>
<description>&lt;p&gt;有时候，变量的取值只在一个有限的集合内。&lt;/p&gt;
&lt;p&gt;例如：pizza的大小只有小、中、大和超大这四种尺寸。当然，可以将这些尺寸分别编码为1、2、3、4或者S、M、L、X。但这样存在着一定的隐患。在变量中很有可能保存的是一个错误的值（如0和m）。&lt;/p&gt;
&lt;p&gt;针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。例如，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，可以声明这种类型的变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Size s = Size.MEDIUM;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Size类型的变量只能存储到这个类型声明中给定的某个枚举值，或者null值，null表示这个变量没有设置任何值。&lt;/p&gt;


&lt;p&gt;下面是他的完整代码加运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package enums;

import java.util.Scanner;

/**
 * 详解请看：Java核心技术(原书第十版)p188-189
 * @author 大凌轩
 *
 */
public class EnumTest {

        public static void main(String[] args) {
                Scanner in=new Scanner(System.in);
                System.out.print(&quot;Enter a size:(SMALL,MEDIUM,LARGE,EXTRA_LARGE)&quot;);
                String input=in.next().toUpperCase();          //这里解释下此处toUpperCase方法，就是将你键盘输入的字母格式化为大写，下面有运行图
                Size size=Enum.valueOf(Size.class, input);
                System.out.println(&quot;size=&quot;+size);
                System.out.println(&quot;abbreviation=&quot;+size.getAbbreviation());
                if(size==Size.EXTRA_LARGE)
                        System.out.println(&quot;Good job--you paid attention to the _.&quot;);
        }
}

enum Size{
        SMALL(&quot;S&quot;),MEDIUM(&quot;M&quot;),LAREG(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;);
        
        private Size(String abbreviation){this.abbreviation=abbreviation;}
        public String getAbbreviation(){return abbreviation;}
        
        private String abbreviation;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1377966/201808/1377966-20180808222321068-1768466021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 下面为了自己以后方便理解，对其进行详细解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public enum Size{SMALL,MEDIUM,LARGE,EXTRA_LARGE};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，这个声明定义的类型是一个类，它刚好有四个实例，在此尽量不要构造新对象。&lt;/p&gt;
&lt;p&gt;因此，在比较两个枚举类型的值时，永远不要调用equals，而直接使用“= =”就可以了。&lt;/p&gt;
&lt;p&gt;如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用。小面是一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public enum Size{
        SMALL(&quot;S&quot;),MEDIUM(&quot;M&quot;),LARGE(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;);
                
        private String abbreviation;

        private Size(String abbreviation){this.abbreviation=abbreviation;}
        public String getAbbreviation(){return abbreviation;}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的枚举类型都是Enum类的子类。它们继承了这个类的许多方法。其中最有用的一个是toString，这个方法能够返回枚举常量名。例如，Size.SMALL.toString()将返回字符串“SMALL”。&lt;/p&gt;
&lt;p&gt;toString的逆方法是静态方法valueOf。例如，语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Size s = Enum.valueOf(Size.class,&quot;SMALL&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将s设置成Size.SMALL。&lt;/p&gt;
&lt;p&gt;每个枚举类型都有一个静态的values方法，它将返回一个包含全部枚举值的数组。例如，如下调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Size[] values = Size.values();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回包含元素Size.SMALL,Size.MEDIUM,Size.LARGE,Size.EXTRA_LARGE的数组。&lt;/p&gt;
&lt;p&gt;ordinal方法返回enum声明中枚举常量的位置，位置从0开始计数。例如：Size.MEDIUM.ordinal()返回1。&lt;/p&gt;

&lt;p&gt;代码其实是最能体现出知识内容的载体，上面的解释其实起不到太大的作用，你读懂了代码，也就知道个八九不离十了。&lt;/p&gt;
&lt;p&gt;以上是我看《Core Java Volume I-Fundamentals》第十版的笔记&lt;/p&gt;
&lt;p&gt;关于枚举的实现细节和原理也可参考《ThinkingInJava》第四版：http://blog.lichengwu.cn/java/2011/09/26/the-usage-of-enum-in-java/&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>大凌轩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dalingxuan/p/9446088.html</dc:identifier>
</item>
<item>
<title>如何为Java中的窗口（JFrame）添加颜色 - lsy&amp;zx</title>
<link>http://www.cnblogs.com/lsy-zx/p/9446337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy-zx/p/9446337.html</guid>
<description>&lt;p&gt;最近一些学习Java的小伙伴，向我请教了一些关于Java图形化界面的问题，以下就是我对Java图形化界面的一些总结。&lt;br/&gt;一：为何J Frame无法显示添加的颜色&lt;/p&gt;
&lt;p&gt;public class Login extends JFrame{&lt;br/&gt;public Login(){&lt;br/&gt;this.setLayout(null);&lt;br/&gt;this.setBounds(600, 200, 200, 300);&lt;br/&gt;this.setVisible(true);&lt;br/&gt;this.setBackground(Color.yellow); //为窗体设置颜色&lt;br/&gt;this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    new Login();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;效果图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327679/201808/1327679-20180808233523138-776793779.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为何会出现这样的问题呢？&lt;br/&gt;其实是因为,JFrame在你直接调用这个方法后，你的确设置了背景颜色，而你看到的却不是直接的JFrame或者Frame，而是JFrame.getContentPane().而JFrame上的contentPane默认是Color.WHITE(白色)的，所以，无论你对JFrame或者Frame怎么设置背景颜色，你看到的都只是contentPane.不能够显示出你所设置的颜色（可以去了解一下图形化界面的知识）&lt;br/&gt;解决这个问题的办法：&lt;br/&gt;（1)在完成初始化，调用getContentPane()方法得到一个contentPane容器，然后将其设置为不可见，即setVisible(false)。这样，你就可以看到真正的JFrame了。&lt;br/&gt;最重要的上代码：this.getContentPane().setVisible(false);//得到contentPane容器，设置为不可见&lt;br/&gt;（2）既让默认是白色，那就直接改变contentPane的颜色就行了嘛，不直接对JFrame进行操作。&lt;br/&gt;话不多说上代码：this.getContentPane().setBackground(Color.yellow);//设置contentPane为黄色&lt;br/&gt;（3）最最常用的方法就是直接给JFrame添加一个JLabel(标签)或者JPanel(面板)，直接设置面板或者标签的颜色就行了嘛。&lt;br/&gt;话不多来个例子：&lt;br/&gt;public class Login extends JFrame{&lt;br/&gt;JPanel pan;&lt;br/&gt;public Login(){&lt;br/&gt;this.setLayout(null);&lt;br/&gt;this.setBounds(400, 200, 400, 500);&lt;br/&gt;this.setVisible(true);&lt;br/&gt;this.setBackground(Color.yellow);&lt;br/&gt;init();&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;}
public void init() {
    pan = new JPanel();
    pan.setLayout(null);
    pan.setVisible(true);
    pan.setBounds(0,0,400,500);
    pan.setBackground(Color.red);
    this.add(pan);
    
} 
public static void main(String[] args) {
    new Login();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;添加改变后的效果图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327679/201808/1327679-20180808233540484-1858080040.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 15:08:00 +0000</pubDate>
<dc:creator>lsy&amp;amp;zx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy-zx/p/9446337.html</dc:identifier>
</item>
<item>
<title>如何优雅地过滤敏感词 - 不才黄某</title>
<link>http://www.cnblogs.com/hzjjames/p/text_filter.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hzjjames/p/text_filter.html</guid>
<description>&lt;p&gt;敏感词过滤功能在很多地方都会用到，理论上在Web应用中，只要涉及用户输入的地方，都需要进行文本校验，如：XSS校验、SQL注入检验、敏感词过滤等。今天着重讲讲如何优雅高效地实现敏感词过滤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏感词过滤方案一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先讲讲笔者在上家公司是如何实现敏感词过滤的。当时毕竟还年轻，所以使用的是最简单的过滤方案。简单来说就是对于要进行检测的文本，遍历所有敏感词，逐个检测输入的文本中是否含有指定的敏感词。这种方式是最简单的敏感词过滤方案了，实现起来不难，示例代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        Set&lt;/span&gt;&amp;lt;String&amp;gt;  sensitiveWords=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        sensitiveWords.add(&lt;/span&gt;&quot;shit&quot;&lt;span&gt;);
        sensitiveWords.add(&lt;/span&gt;&quot;傻逼&quot;&lt;span&gt;);
        sensitiveWords.add(&lt;/span&gt;&quot;笨蛋&quot;&lt;span&gt;);
        String text&lt;/span&gt;=&quot;你是傻逼啊&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String sensitiveWord:sensitiveWords){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(text.contains(sensitiveWord)){
                System.out.println(&lt;/span&gt;&quot;输入的文本存在敏感词。——&quot;+&lt;span&gt;sensitiveWord);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码十分简单，也确实能够满足要求。但是这个方案有一个很大的问题是，随着敏感词数量的增多，敏感词检测的时间会呈线性增长。由于之前的项目的敏感词数量只有几十个，所以使用这种方案不会存在太大的性能问题。但是如果项目中有成千上万个敏感词，使用这种方案就会很耗CPU了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏感词过滤方案二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在网上查了下敏感词过滤方案，找到了一种名为DFA的算法，即Deterministic Finite Automaton算法，翻译成中文就是确定有穷自动机算法。它的基本思想是基于状态转移来检索敏感词，只需要扫描一次待检测文本，就能对所有敏感词进行检测，所以效率比方案一高不少。&lt;/p&gt;
&lt;p&gt;假设我们有以下5个敏感词需要检测：傻逼、傻子、傻大个、坏蛋、坏人。那么我们可以先把敏感词中有相同前缀的词组合成一个树形结构，不同前缀的词分属不同树形分支，以上述5个敏感词为例，可以初始化成如下2棵树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447337/201808/1447337-20180808230947710-420201104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447337/201808/1447337-20180808231025613-622095016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;把敏感词组成成树形结构有什么好处呢？最大的好处就是可以减少检索次数，我们只需要遍历一次待检测文本，然后在敏感词库中检索出有没有该字符对应的子树就行了，如果没有相应的子树，说明当前检测的字符不在敏感词库中，则直接跳过继续检测下一个字符；如果有相应的子树，则接着检查下一个字符是不是前一个字符对应的子树的子节点，这样迭代下去，就能找出待检测文本中是否包含敏感词了。&lt;/p&gt;
&lt;p&gt;我们以文本“你是不是傻逼”为例，我们依次检测每个字符，因为前4个字符都不在敏感词库里，找不到相应的子树，所以直接跳过。当检测到“傻”字时，发现敏感词库中有相应的子树，我们把他记为tree-1，接着再搜索下一个字符“逼”是不是子树tree-1的子节点，发现恰好是，接下来再判断“逼”这个字符是不是叶子节点，如果是，则说明匹配到了一个敏感词了，在这里“逼”这个字符刚好是tree-1的叶子节点，所以成功检索到了敏感词：“傻逼”。大家发现了没有，在我们的搜索过程中，我们只需要扫描一次被检测文本就行了，而且对于被检测文本中不存在的敏感词，如这个例子中的“坏蛋”和“坏人”，我们完全不会扫描到，因此相比方案一效率大大提升了。&lt;/p&gt;
&lt;p&gt;在Java中，我们可以用HashMap来存储上述的树形结构，还是以上述敏感词为例，我们把每个敏感词字符串拆散成字符，再存储到HashMap中，可以这样存：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;傻&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;逼&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isEnd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isEnd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;大&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isEnd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先将每个词的第一个字符作为key，value则是另一个HashMap，value对应的HashMap的key为第二个字符，如果还有第三个字符，则存储到以第二个字符为key的value中，当然这个value还是一个HashMap，以此类推下去，直到最后一个字符，当然最后一个字符对应的value也是HashMap，只不过这个HashMap只需要存储一个结束标志就行了，像上述的例子中，我们就存了一个{&quot;isEnd&quot;,&quot;Y&quot;}的HashMap，来表示这个value对应的key是敏感词的最后一个字符。&lt;/p&gt;
&lt;p&gt;同理，“坏人”和“坏蛋”这2个敏感词也是按这样的方式存储起来，这里就不罗列出来了。&lt;/p&gt;
&lt;p&gt;用HashMap存储有什么好处呢？我们知道HashMap在理想情况下可以以O(1)的时间复杂度进行查询，所以我们在遍历待检测字符串的过程中，可以以O(1)的时间复杂度检索出当前字符是否在敏感词库中，效率比方案一提升太多了。&lt;/p&gt;
&lt;p&gt;接下来上代码。&lt;/p&gt;
&lt;p&gt;首先是初始化敏感词库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;private&lt;/span&gt; Map&amp;lt;Object,Object&amp;gt;&lt;span&gt; sensitiveWordsMap;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String END_FLAG=&quot;end&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initSensitiveWordsMap(Set&amp;lt;String&amp;gt;&lt;span&gt; sensitiveWords){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sensitiveWords==&lt;span&gt;null&lt;/span&gt;||&lt;span&gt;sensitiveWords.isEmpty()){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Senditive words must not be empty!&quot;&lt;span&gt;);
        }
        sensitiveWordsMap&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;(sensitiveWords.size());
        String currentWord;
        Map&lt;/span&gt;&amp;lt;Object,Object&amp;gt;&lt;span&gt; currentMap;
        Map&lt;/span&gt;&amp;lt;Object,Object&amp;gt;&lt;span&gt; subMap;
        Iterator&lt;/span&gt;&amp;lt;String&amp;gt; iterator =&lt;span&gt; sensitiveWords.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()){
            currentWord&lt;/span&gt;=&lt;span&gt;iterator.next();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(currentWord==&lt;span&gt;null&lt;/span&gt;||currentWord.trim().length()&amp;lt;2){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;敏感词长度必须大于等于2&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            currentMap&lt;/span&gt;=&lt;span&gt;sensitiveWordsMap;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;currentWord.length();i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;currentWord.charAt(i);
                subMap&lt;/span&gt;=(Map&amp;lt;Object, Object&amp;gt;&lt;span&gt;) currentMap.get(c);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(subMap==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    subMap&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
                    currentMap.put(c,subMap);
                    currentMap&lt;/span&gt;=&lt;span&gt;subMap;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    currentMap&lt;/span&gt;=&lt;span&gt; subMap;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i==currentWord.length()-1&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是最后一个字符，则put一个结束标志，这里只需要保存key就行了，value为null可以节省空间。
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是最后一个字符，则不需要存这个结束标志，同样也是为了节省空间。&lt;/span&gt;
                    currentMap.put(END_FLAG,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码的逻辑上面已经说过了，就是循环敏感词集合，将他们放到HashMap中，这里不再赘述。&lt;/p&gt;
&lt;p&gt;接下来是敏感词的扫描：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; MatchType {

    MIN_MATCH(&lt;/span&gt;&quot;最小匹配规则&quot;),MAX_MATCH(&quot;最大匹配规则&quot;&lt;span&gt;);

    String desc;

    MatchType(String desc) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
    }
}

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; getSensitiveWords(String text,MatchType matchType){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(text==&lt;span&gt;null&lt;/span&gt;||text.trim().length()==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;The input text must not be empty.&quot;&lt;span&gt;);
        }
        Set&lt;/span&gt;&amp;lt;String&amp;gt; sensitiveWords=&lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;text.length();i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sensitiveWordLength =&lt;span&gt; getSensitiveWordLength(text, i, matchType);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sensitiveWordLength&amp;gt;0&lt;span&gt;){
                String sensitiveWord &lt;/span&gt;= text.substring(i, i +&lt;span&gt; sensitiveWordLength);
                sensitiveWords.add(sensitiveWord);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(matchType==&lt;span&gt;MatchType.MIN_MATCH){
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                i&lt;/span&gt;=i+sensitiveWordLength-1&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sensitiveWords;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getSensitiveWordLength(String text,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; startIndex,MatchType matchType){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(text==&lt;span&gt;null&lt;/span&gt;||text.trim().length()==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;The input text must not be empty.&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; currentChar;
        Map&lt;/span&gt;&amp;lt;Object,Object&amp;gt; currentMap=&lt;span&gt;sensitiveWordsMap;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; wordLength=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; endFlag=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=startIndex;i&amp;lt;text.length();i++&lt;span&gt;){
            currentChar&lt;/span&gt;=&lt;span&gt;text.charAt(i);
            Map&lt;/span&gt;&amp;lt;Object,Object&amp;gt; subMap=(Map&amp;lt;Object,Object&amp;gt;&lt;span&gt;) currentMap.get(currentChar);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(subMap==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                wordLength&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(subMap.containsKey(END_FLAG)){
                    endFlag&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(matchType==&lt;span&gt;MatchType.MIN_MATCH){
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        currentMap&lt;/span&gt;=&lt;span&gt;subMap;
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    currentMap&lt;/span&gt;=&lt;span&gt;subMap;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;endFlag){
            wordLength&lt;/span&gt;=0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wordLength;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，MatchType表示匹配规则，有时候我们只需要找到一个敏感词就可以了，有时候则需要知道待检测文本中到底包含多少个敏感词，前者对应的是最小匹配原则，后者则是最大匹配原则。&lt;/p&gt;
&lt;p&gt;getSensitiveWordLength方法的作用是根据给定的待检测文本及起始下标，还有匹配规则，计算出待检测文本中的敏感词长度，如果不存在，则返回0，存在则返回匹配到的敏感词长度。&lt;/p&gt;
&lt;p&gt;getSensitiveWords方法则是扫描一遍待检测文本，逐个检测每个字符是否在敏感词库中，然后将检测到的敏感词截取出来放到集合中返回给客户端。&lt;/p&gt;
&lt;p&gt;最后写个测试用例测一下：&lt;/p&gt;
&lt;p&gt;   public static void main(String[] args) {        Set&amp;lt;String&amp;gt; sensitiveWords=new HashSet&amp;lt;&amp;gt;();        sensitiveWords.add(&quot;你是傻逼&quot;);        sensitiveWords.add(&quot;你是傻逼啊&quot;);        sensitiveWords.add(&quot;你是坏蛋&quot;);        sensitiveWords.add(&quot;你个大笨蛋&quot;);        sensitiveWords.add(&quot;我去年买了个表&quot;);        sensitiveWords.add(&quot;shit&quot;);        TextFilter textFilter=new TextFilter();        textFilter.initSensitiveWordsMap(sensitiveWords);        String text=&quot;你你你你是傻逼啊你，说你呢，你个大笨蛋。&quot;;        System.out.println(textFilter.getSensitiveWords(text,MatchType.MAX_MATCH));    }&lt;/p&gt;
&lt;p&gt;结果输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-backh=&quot;76&quot; data-backw=&quot;558&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l7HrRPkQWsphP5DVqxYuouuS5Ipg0DYlhUlicQeqkLFCfhBQdCCmJmM60fPmBcCpRkPqicufxibicSVicA/0?wx_fmt=png&quot; data-ratio=&quot;0.13623595505617977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XA3sPCPib1l7HrRPkQWsphP5DVqxYuouuS5Ipg0DYlhUlicQeqkLFCfhBQdCCmJmM60fPmBcCpRkPqicufxibicSVicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们成功地过滤出了敏感词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏感词过滤方案三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方案二在性能上已经可以满足需求了，但是却很容易被破解，比如说，我在待检测文本中的敏感词中间加个空格，就可以成功绕过了。要解决这个问题也不难，有一个简单的方法是初始化一个无效字符库，比如：空格、*、#、@等字符，然后在检测文本前，先将待检测文本中的无效字符去除，这样的话被检测字符就不存在这些无效字符了，因此还是可以继续用方案二进行过滤。只要被检测文本不要太长，那么我们只要在方案二的基础上再多扫描一次被检测文本去除无效字符就行了，这个性能损耗也还是可以接受的。&lt;/p&gt;
&lt;p&gt;如果敏感词是英文，则还要考虑大小写的问题。有一个比较简单的解决方案是在初始化敏感词时，将敏感词都以小写形式存储。同时，在检测文本时，也统一将待检测文本转化为小写，这样就能解决大小写的问题了。&lt;/p&gt;
&lt;p&gt;比较棘手的是中文跟拼音混合的情况，比如“傻逼”这个敏感词，可以通过“sha逼”这种中文跟拼音混合的方式轻松绕过，对于这种情况我目前还没想到比较好的解决方案，有想法的读者可以在评论区留言。&lt;/p&gt;
&lt;p&gt;完整代码：https://github.com/hzjjames/TextFilter&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 15:07:00 +0000</pubDate>
<dc:creator>不才黄某</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hzjjames/p/text_filter.html</dc:identifier>
</item>
<item>
<title>js的视频和音频采集 - Mr.苏</title>
<link>http://www.cnblogs.com/suyuanli/p/9446275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suyuanli/p/9446275.html</guid>
<description>&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;今天要写的，不是大家平时会用到的东西。因为兼容性实在不行，只是为了说明下前端原来还能干这些事。&lt;br/&gt;大家能想象前端是能将摄像头和麦克风的视频流和音频流提取出来，再为所欲为的么。或者说我想把我canvas画板的内容录制成一个视频，这些看似js应该做不到的事情，其实都是可以做到的，不过兼容性不好。我在这里都是以chrome浏览器举的例子。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这里先把用到的api列一下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 这里是打开摄像头和麦克设备（会返回一个Promise对象）
navigator.mediaDevices.getUserMedia({
  audio: true,
  video: true
}).then(stream =&amp;gt; {
  console.log(stream) // 放回音视频流
}).catch(err =&amp;gt; {
  console.log(err)  // 错误回调
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们成功打开了摄像头和麦克风，并获取到视频流。那接下来就是要把流呈现到交互界面中了。&lt;/p&gt;
&lt;h5 id=&quot;二展示视频&quot;&gt;二、展示视频&lt;/h5&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;video id=&quot;video&quot; width=&quot;500&quot; height=&quot;500&quot; autoplay&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
  var video = document.getElementById('video')
  navigator.mediaDevices.getUserMedia({
    audio: true,
    video: true
  }).then(stream =&amp;gt; {
    // 这里就要用到srcObject属性了，可以直接播放流资源
    video.srcObject = stream
  }).catch(err =&amp;gt; {
    console.log(err)  // 错误回调
  })
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下图：&lt;br/&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1533654380000-225.gif&quot; title=&quot;视频采集图1&quot; alt=&quot;视频采集图1&quot;/&gt;&lt;br/&gt;到这里为止我们已经成功的将我们的摄像头在页面展示了。下一步就是如何将采集视频，并下载视频文件。&lt;/p&gt;
&lt;h2 id=&quot;从摄像头采集视频&quot;&gt;2、从摄像头采集视频&lt;/h2&gt;
&lt;p&gt;这里用到的是MediaRecorder对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个新的MediaRecorder对象,返回一个MediaStream 对象用来进行录制操作,支持配置项配置容器的MIME type (例如&quot;video/webm&quot; or &quot;video/mp4&quot;)或者音频的码率视频码率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MediaRecorder接收两个参数第一个是stream音视频流，第二个是option配置参数。下面我们可以把上面摄像头获取的流加入MediaRecorder中。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var video = document.getElementById('video')
navigator.mediaDevices.getUserMedia({
  audio: true,
  video: true
}).then(stream =&amp;gt; {
  // 这里就要用到srcObject属性了，可以直接播放流资源
  video.srcObject = stream
  var mediaRecorder = new MediaRecorder(stream, {
    audioBitsPerSecond : 128000,  // 音频码率
    videoBitsPerSecond : 100000,  // 视频码率
    mimeType : 'video/webm;codecs=h264' // 编码格式
  })
}).catch(err =&amp;gt; {
  console.log(err)  // 错误回调
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面我们创建了MediaRecorder的实例mediaRecorder。接下来就是控制mediaRecorder的开始采集和停止采集的方法了。&lt;br/&gt;MediaRecorder提供了一些方法和事件供我们使用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;MediaRecorder.start(): 开始录制媒体,这个方法调用时可以通过给timeslice参数设置一个毫秒值,如果设置这个毫秒值,那么录制的媒体会按照你设置的值进行分割成一个个单独的区块, 而不是以默认的方式录制一个非常大的整块内容.&lt;/li&gt;
&lt;li&gt;MediaRecorder.stop(): 停止录制. 同时触发dataavailable事件,返回一个存储Blob内容的录制数据.之后不再记录&lt;/li&gt;
&lt;li&gt;ondataavailable事件： MediaRecorder.stop触发该事件，该事件可用于获取记录的媒体（Blob在事件的data属性中可用作对象）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 这里我们增加两个按钮控制采集的开始和结束
var start = document.getElementById('start')
var stop = document.getElementById('stop')
var video = document.getElementById('video')
navigator.mediaDevices.getUserMedia({
  audio: true,
  video: true
}).then(stream =&amp;gt; {
  // 这里就要用到srcObject属性了，可以直接播放流资源
  video.srcObject = stream
  var mediaRecorder = new MediaRecorder(stream, {
    audioBitsPerSecond : 128000,  // 音频码率
    videoBitsPerSecond : 100000,  // 视频码率
    mimeType : 'video/webm;codecs=h264' // 编码格式
  })
  // 开始采集
  start.onclick = function () {
    mediaRecorder.start()
    console.log('开始采集')
  }
  // 停止采集
  stop.onclick = function () {
    mediaRecorder.stop()
    console.log('停止采集')
  }
  // 事件
  mediaRecorder.ondataavailable = function (e) {
    console.log(e)
    // 下载视频
    var blob = new Blob([e.data], { 'type' : 'video/mp4' })
    let a = document.createElement('a')
    a.href = URL.createObjectURL(blob)
    a.download = `test.mp4`
    a.click()
  }
}).catch(err =&amp;gt; {
  console.log(err)  // 错误回调
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，现在执行一波操作；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1533705229000-598.jpg&quot; title=&quot;视频采集图2&quot; alt=&quot;视频采集图2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看到结束采集后ondataavailable事件返回的数据中有一个Blob对象，这就是视频资源了，再接下来我们就可以通过URL.createObjectURL()方法将Blob为url下载到本地了。视频的采集到下载就结束了，很简单粗暴。&lt;br/&gt;上面是视频采集下载的例子，如果只要音频采集的，同样道理的设置“mimeType”就好了。这里我就不举例了。下面我在介绍将canvas录制为一个视频文件&lt;/p&gt;
&lt;h2 id=&quot;canvas输出视频流&quot;&gt;2、canvas输出视频流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这里用到的是captureStream方法，将canvas输出流，再用video展现，或者用MediaRecorder采集资源也是可以的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;// 这里就闲话少说直接上重点了因为和上面视频采集的是一样的道理的。
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
  &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;canvas width=&quot;500&quot; height=&quot;500&quot; id=&quot;canvas&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
  &amp;lt;video id=&quot;video&quot; width=&quot;500&quot; height=&quot;500&quot; autoplay&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
  var video = document.getElementById('video')
  var canvas = document.getElementById('canvas')
  var stream = $canvas.captureStream(); // 这里获取canvas流对象
  // 接下来你先为所欲为都可以了，可以参考上面的我就不写了。
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我再贴一个gif(这是结合我上次写的canvas事件的demo结合这次视频采集的结合)传送门（&lt;a href=&quot;https://www.cnblogs.com/suyuanli/p/9212994.html&quot; target=&quot;_blank&quot;&gt;Canvas事件绑定&lt;/a&gt;）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;希望大家可以实现下面的效果，其实还可以在canvas视频里插入背景音乐什么的，这些都比较简单。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://p0639a4mt.bkt.clouddn.com/1533739642000-286.gif&quot; title=&quot;视频采集图3&quot; alt=&quot;视频采集图3&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 14:56:00 +0000</pubDate>
<dc:creator>Mr.苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suyuanli/p/9446275.html</dc:identifier>
</item>
<item>
<title>排序算法之--快速排序(及优化测试亿级100_000_000用时) - symkmk123</title>
<link>http://www.cnblogs.com/symkmk123/p/9442129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/symkmk123/p/9442129.html</guid>
<description>&lt;h2&gt;该方法的基本思想是：&lt;/h2&gt;
&lt;p&gt;1．先从数列中取出一个数作为基准数。&lt;/p&gt;
&lt;p&gt;2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。&lt;/p&gt;
&lt;p&gt;3．再对左右区间重复第二步，直到各区间只有一个数。&lt;/p&gt;
&lt;p&gt;挖坑填数+分治法：&lt;/p&gt;
&lt;h2&gt;对挖坑填数进行总结&lt;/h2&gt;
&lt;p&gt;1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。&lt;/p&gt;
&lt;p&gt;2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。&lt;/p&gt;
&lt;p&gt;3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。&lt;/p&gt;
&lt;p&gt;4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。&lt;/p&gt;

&lt;h2&gt;第一版快排（数据100_000_00级的）：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 //&lt;/span&gt;&lt;span&gt;1．先从数列中取出一个数作为基准数。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3．再对左右区间重复第二步，直到各区间只有一个数。&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Quicksort(&lt;span&gt;int&lt;/span&gt; [] arr,&lt;span&gt;int&lt;/span&gt; left,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; right)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr.length&amp;lt;=1 || arr==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(left&amp;lt;&lt;span&gt;right)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid=&lt;span&gt;getmid(arr,left,right);
            Quicksort(arr,left,mid&lt;/span&gt;-1&lt;span&gt;);
            Quicksort(arr,mid&lt;/span&gt;+1&lt;span&gt;,right);
        }

    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getmid(&lt;span&gt;int&lt;/span&gt; [] arr,&lt;span&gt;int&lt;/span&gt; left,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; right)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[left];
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (left&amp;lt;&lt;span&gt;right)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从右往左
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最左边小于第一个数&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (left&amp;lt;right &amp;amp;&amp;amp; arr[right]&amp;gt;=&lt;span&gt;temp)
            {
                right&lt;/span&gt;--&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将最右边比基准数小的数移到左边&lt;/span&gt;
            arr[left]=&lt;span&gt;arr[right];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从左往右
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最右边大于第一个数&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (left&amp;lt;right &amp;amp;&amp;amp;arr[left]&amp;lt;&lt;span&gt;temp)
            {
                left&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将最左边比基准数大的移到右边&lt;/span&gt;
            arr[right]=&lt;span&gt;arr[left];

        }
        arr[left]&lt;/span&gt;=temp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基准元素归位&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; left;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[]arg)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int [] ints =new int[]{12 ,9 ,8  ,1,2,7  , 1 , 2  ,3   , 6 };&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] ints=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[100_000_00];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ints.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机产生数据&lt;/span&gt;
            ints[i]=(&lt;span&gt;int&lt;/span&gt;)(Math.random()*1000+1&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;程序运行时间：start&quot; +  &quot;ms&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;show(ints);&lt;/span&gt;
        Quicksort(ints,0,ints.length-1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;show(ints);&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; endTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;
        System.out.println(&lt;/span&gt;&quot;程序运行时间：&quot; + (endTime - startTime) + &quot;ms&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出程序运行时间&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;  show(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; [] ints)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;ints.length;i++&lt;span&gt;)
        {
            System.out.print(ints[i]&lt;/span&gt;+&quot;  &quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;用时：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201698/201808/1201698-20180808221245070-830253418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果把数据加成100_000_000亿级的，会出现栈溢出！！&lt;/p&gt;
&lt;p&gt; 分析：&lt;/p&gt;
&lt;p&gt;第一版只是一般书上的快速排序，如果出现大量重复数据，在左右移动过程中就会浪费不少次数，所以，我们要在加一个变量限制。&lt;/p&gt;
&lt;h2&gt;第二版：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; swap(   &lt;span&gt;int&lt;/span&gt; [] arr, &lt;span&gt;int&lt;/span&gt; low,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)
      {
          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp=&lt;span&gt;arr[low];
          arr[low]&lt;/span&gt;=&lt;span&gt;arr[high];
          arr[high]&lt;/span&gt;=temp;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据交换&lt;/span&gt;
&lt;span&gt;      }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; Qsortplus(   &lt;span&gt;int&lt;/span&gt; [] arr, &lt;span&gt;int&lt;/span&gt; low,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; high)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(low &amp;lt;&lt;span&gt;  high)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lt=&lt;span&gt;low;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; gt=high;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;左边，右边&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; i=low+1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始循环位置&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; temp=arr[low];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存第一个数据&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;(i&amp;lt;=gt)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环夹逼&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i]&amp;lt;temp) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小于&lt;/span&gt;
&lt;span&gt;                {
                    swap(arr, lt,i);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动&lt;/span&gt;
                    lt++&lt;span&gt;;
                    i&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt;(arr[i]&amp;gt;temp)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大于&lt;/span&gt;
&lt;span&gt;                {
                    swap(arr,i,gt);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动&lt;/span&gt;
                    gt--&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    i&lt;/span&gt;++&lt;span&gt;;
                }
            }
            Qsortplus(   arr, low,lt&lt;/span&gt;-1&lt;span&gt;); 
            Qsortplus(    arr, gt&lt;/span&gt;+1,high);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分段&lt;/span&gt;
&lt;span&gt;        }

    }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; show(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] args) 
     {
         
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;args.length;i++&lt;span&gt;)
         {
             System.out.print(args[i]&lt;/span&gt;+&quot; &quot;&lt;span&gt;);
         }
           System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
     }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) 
    {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; int [] arr=new int[]{4,1,2,9,4,6,4,2,4,3,4,1,7,4,7,4,7,7};&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] arr=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[100_000_00];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;arr.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机产生数据&lt;/span&gt;
            arr[i]=(&lt;span&gt;int&lt;/span&gt;)(Math.random()*1000+1&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间&lt;/span&gt;
        Qsortplus(    arr,0,arr.length-1&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; show(arr) ;&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; endTime = System.currentTimeMillis();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;
        System.out.println(&lt;/span&gt;&quot;程序运行时间：&quot; + (endTime - startTime) + &quot;ms&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出程序运行时间&lt;/span&gt;
&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;用时：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201698/201808/1201698-20180808221813377-1340508099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;测试亿级100_000_000用时：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1201698/201808/1201698-20180808221912172-912429675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哈哈 感觉好神奇&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/MOBIN/p/4681369.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/MOBIN/p/4681369.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/morewindows/article/details/6684558&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/morewindows/article/details/6684558&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 08 Aug 2018 14:29:00 +0000</pubDate>
<dc:creator>symkmk123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/symkmk123/p/9442129.html</dc:identifier>
</item>
<item>
<title>[源码分析]Java1.8中StringJoiner的使用以及源码分析 - GoldArowana</title>
<link>http://www.cnblogs.com/noKing/p/java_source_StringJoiner.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noKing/p/java_source_StringJoiner.html</guid>
<description>&lt;h2&gt;[源码分析]StringJoiner的使用以及源码分析&lt;/h2&gt;
&lt;p&gt;StringJoiner是Java里1.8新增的类, 或许有一部分人没有接触过. 所以本文将从使用例子入手, 分析StringJoiner的源码. &lt;/p&gt;
&lt;p&gt;基本好的同学, 其实只要把这段例子自己运行一下, 自己看看源码就可以了. 因为我觉得这个类挺简单的. 没必要看我下面的废话....&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(&quot;--&quot;, &quot;[[[_&quot;, &quot;_]]]&quot;);
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());

        System.out.println(&quot;******************(1)********************&quot;);

        joiner.add(&quot;1&quot;);
        joiner.add(&quot;2&quot;);
        joiner.add(&quot;3&quot;);
        joiner.add(&quot;4&quot;);
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());

        System.out.println(&quot;******************(2)********************&quot;);

        StringJoiner joiner2 = new StringJoiner(&quot;...&quot;);
        System.out.println(&quot;toString: &quot; + joiner2.toString());
        System.out.println(&quot;length: &quot; + joiner2.length());

        System.out.println(&quot;******************(3)********************&quot;);

        joiner2.add(&quot;a&quot;);
        joiner2.add(&quot;b&quot;);
        joiner2.add(&quot;c&quot;);
        System.out.println(&quot;toString: &quot; + joiner2.toString());
        System.out.println(&quot;length: &quot; + joiner2.length());

        System.out.println(&quot;******************(4)********************&quot;);

        joiner.merge(joiner2);
        System.out.println(&quot;toString: &quot; + joiner.toString());

        System.out.println(&quot;******************(5)********************&quot;);

        StringJoiner joiner3 = new StringJoiner(&quot;==&quot;, &quot;qianzhui&quot;, &quot;houzhui&quot;);
        joiner3.add(&quot;壹&quot;);
        joiner3.add(&quot;贰&quot;);
        joiner3.add(&quot;叁&quot;);

        joiner.merge(joiner3);
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());

        System.out.println(&quot;******************(6)********************&quot;);
        joiner.merge(joiner); // joiner.merge(this)
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
toString: [[[__]]]
length: 8
******************(1)********************
toString: [[[_1--2--3--4_]]]
length: 18
******************(2)********************
toString: 
length: 0
******************(3)********************
toString: a...b...c
length: 9
******************(4)********************
toString: [[[_1--2--3--4--a...b...c_]]]
******************(5)********************
toString: [[[_1--2--3--4--a...b...c--壹==贰==叁_]]]
length: 38
******************(6)********************
toString: [[[_1--2--3--4--a...b...c--壹==贰==叁--1--2--3--4--a...b...c--壹==贰==叁_]]]
length: 70
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面的例子看懂的同学, 其实没必要往下看下去了....下面的几个例子就当是我自己做了个总结吧.&lt;/p&gt;
&lt;h3&gt;例1&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest2 {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(&quot;--&quot;, &quot;[[[_ &quot;, &quot;_]]]&quot;);
        System.out.println(joiner.toString());
        System.out.println(joiner.length());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果如下:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808112008696-167496238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个构造器要传入三个参数. 第一个是`分隔符` , 第二个是`前缀` , 第三个是 `后缀`. 现在不明白也没有关系, 下面待会儿会详细介绍.&lt;/p&gt;
&lt;p&gt;咱们先把这个构造器对应的源码看了吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808105117782-1155640801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先是判断非空. 然后就开始赋值了. emptyValue被赋值为了prefix+suffix . 这段代码就是这么简单... 其中:&lt;/p&gt;
&lt;p&gt;1. prefix 是前缀.            (待会儿再讲)&lt;/p&gt;
&lt;p&gt;2. delimiter 是分隔符     (待会儿再讲)&lt;/p&gt;
&lt;p&gt;3. suffix 是后缀             (待会儿再讲)&lt;/p&gt;
&lt;p&gt;4. emptyValue是本类的`空值`. 空值准确来说应该是null, 但StringJoiner类把emptyValue来当空值来处理. (马上就讲)&lt;/p&gt;
&lt;p&gt;构造器看完了, 咱们再看看toString方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808105851012-433108283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为目前的代码里, 没有对value进行过赋值操作, 所以value肯定是null. 所以会执行第一个if. &lt;/p&gt;
&lt;p&gt;也就是说真正的值value为空的时候, 就会返回本类默认的空值emptyValue. (大家有没有现在应该知道emptyValue的作用了吧)&lt;/p&gt;
&lt;p&gt;toString就先分析这一小段if, 剩下的后面再讲. 接下来咱们看看length()方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808110312414-1331827359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;value非空的时候, 长度就是value的长度+后缀的长度.(前缀呢? 前缀去哪儿了? 为什么不单独再加上前缀的长度呢? 带着这个疑惑往下看) .&lt;/p&gt;
&lt;p&gt;value为空的时候, 长度就是emptyValue的长度.&lt;/p&gt;
&lt;h3&gt;例2&lt;/h3&gt;
&lt;p&gt;咱们往StringJoiner添加 &quot;1&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest2 {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(&quot;--&quot;, &quot;[[[_&quot;, &quot;_]]]&quot;);
        joiner.add(&quot;1&quot;);
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808111759595-45302143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个时候, 或许大家对`前缀` `后缀` 有些理解了吧. (还没理解也无所谓, 往下看)&lt;/p&gt;
&lt;p&gt;咱们看看add方法的源码吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808111110589-1083554272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过append方法, 将咱们传入的&quot;1&quot;添加到了末尾. 那么prepareBuilder()方法返回的是什么呢?看看源码吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808111319665-801598372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咱们调用add(&quot;1&quot;)的时候, value为空. 所以会执行else语句. 在这里新实例化了一个StringBuilder. 然后StringBuilder先追加了`前缀`.  (if语句先不讲, 等执行到了再讲)&lt;/p&gt;
&lt;p&gt;所以此时prepareBuilder方法返回的value实际上就是前缀: &quot;[[[_&quot;&lt;/p&gt;
&lt;p&gt;回到add方法, 刚才咱们说了add方法即时在prepareBuilder返回的值后面追加了&quot;1&quot;而已.&lt;/p&gt;
&lt;p&gt;所以执行完add方法之后, value就等于 &quot;[[[_1&quot;    所以value里就已经包含了前缀了. 所以length方法里&quot;为什么不单独再计算前缀的长度呢?&quot; 因为value里面就已经包含前缀了.&lt;/p&gt;
&lt;p&gt;咱们再看看toString方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808114513518-2113744257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次value非空. 所以执行这里else语句:&lt;/p&gt;
&lt;p&gt;如果suffix等于空字符串, 那么就返回value.&lt;/p&gt;
&lt;p&gt;如果suffix不等于空字符串, 那么就返回value+后缀.&lt;/p&gt;
&lt;p&gt;再看看length()方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808115229191-1963927696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;value不为空, 所以返回的值是 value的长度+后缀的长度.&lt;/p&gt;
&lt;h3&gt;例3&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest2 {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(&quot;--&quot;, &quot;[[[_&quot;, &quot;_]]]&quot;);
        joiner.add(&quot;1&quot;);
        joiner.add(&quot;2&quot;);
        joiner.add(&quot;3&quot;);
        joiner.add(&quot;4&quot;);
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808120022192-2653004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; add(&quot;1&quot;)和上一小节的执行流程一样. 这回看看add(&quot;2&quot;);的执行流程吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808115835113-102465022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于前面add(&quot;1&quot;)执行完了, 所以导致value已经不是null了. 所以这里会执行prepareBuilder方法里的if语句. 在value后直接追加一个delimiter分隔符. 然后返回这个value.&lt;/p&gt;
&lt;p&gt;然后再add方法里, 把&quot;2&quot;追加到value后面.&lt;/p&gt;
&lt;h3&gt;例4&lt;/h3&gt;
&lt;p&gt;咱们发现add方法最后返回的是this.所以上面一小节的示例代码可以写成这样:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest2 {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(&quot;--&quot;, &quot;[[[_&quot;, &quot;_]]]&quot;);
        joiner.add(&quot;1&quot;).add(&quot;2&quot;).add(&quot;3&quot;).add(&quot;4&quot;);
        System.out.println(&quot;toString: &quot; + joiner.toString());
        System.out.println(&quot;length: &quot; + joiner.length());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 例5&lt;/h3&gt;
&lt;p&gt;StringJoiner还有一个构造器, 只需传入分隔符:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest2 {
    public static void main(String[] args) {
        StringJoiner joiner2 = new StringJoiner(&quot;...&quot;);
        System.out.println(&quot;toString: &quot; + joiner2.toString());
        System.out.println(&quot;length: &quot; + joiner2.length());
        System.out.println(&quot;**************************************&quot;);
        joiner2.add(&quot;a&quot;);
        joiner2.add(&quot;b&quot;);
        joiner2.add(&quot;c&quot;);
        System.out.println(&quot;toString: &quot; + joiner2.toString());
        System.out.println(&quot;length: &quot; + joiner2.length());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808220044349-187558788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构造器源码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808215940024-798320530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 就是只指定了分割符, 把前缀和后缀都指定为了空字符串.&lt;/p&gt;
&lt;h3&gt; 例6&lt;/h3&gt;
&lt;p&gt;接下来咱们看看merge方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringJoinerTest2 {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(&quot;--&quot;, &quot;[[[_&quot;, &quot;_]]]&quot;);
        joiner.add(&quot;1&quot;).add(&quot;2&quot;).add(&quot;3&quot;).add(&quot;4&quot;);

        StringJoiner joiner2 = new StringJoiner(&quot;...&quot;);
        joiner2.add(&quot;a&quot;).add(&quot;b&quot;).add(&quot;c&quot;);

        joiner.merge(joiner2);
        System.out.println(joiner.toString());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输出结果如下: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808220812648-833119939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;merge的源代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201808/1251417-20180808221607616-383460160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咱们看到了用append方法进行了字符串追加. (append的时候刨除去了other.value 的前缀).&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;1. prepareBuilder方法在value为空的时候, 给value加上前缀.&lt;/p&gt;
&lt;p&gt;2. prepareBuilder方法在value非空的时候, 给value加上分隔符.&lt;/p&gt;
&lt;p&gt;3. 很多方法都不能传入null为参数. 因为用Objects.requireNonNul方法限定了.&lt;/p&gt;
&lt;p&gt;4. 前缀是包含在value里的. 而后缀部分是toString的时候才会被临时添加到value里.&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 14:28:00 +0000</pubDate>
<dc:creator>GoldArowana</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noKing/p/java_source_StringJoiner.html</dc:identifier>
</item>
<item>
<title>Java线程实现与安全 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9446060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9446060.html</guid>
<description>&lt;p&gt;1. 线程的实现&lt;/p&gt;
&lt;p&gt;　　线程的三种实现方式&lt;/p&gt;
&lt;p&gt;　　Java线程的实现与调度　　&lt;/p&gt;
&lt;p&gt;2. 线程安全&lt;/p&gt;
&lt;p&gt;　　Java的五种共享数据&lt;/p&gt;
&lt;p&gt;　　保证线程安全的三种方式&lt;/p&gt;

&lt;hr/&gt;

&lt;blockquote readability=&quot;11.542857142857&quot;&gt;
&lt;p&gt;本篇博文主要是是在Java内存模型的基础上介绍Java线程更多的内部细节，但不是简单的代码举例，更多的是一些理论概念，可以说是对自己的一种理论知识的补充&lt;/p&gt;
&lt;p&gt;注：建议先了解Java的内存模型，再理解本篇博文效果更佳。具体可以看我的总结的关于&lt;a href=&quot;https://www.cnblogs.com/jian0110/p/9351281.html&quot; target=&quot;_blank&quot;&gt;Java内存模型&lt;/a&gt;的博文&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要参考《深入理解JVM》中高效并发编程部分&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;h2&gt;&lt;span&gt;1、线程的三种实现方式　&lt;/span&gt;　&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;首先并发并不是我们通常我们认为的必须依靠线程才能实现，但是在&lt;span&gt;Java中并发的实现是离不开线程的&lt;/span&gt;，线程的主要实现有三种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（1）&lt;strong&gt;&lt;span&gt;使用内核线程（&lt;/span&gt;Kernel Thread&lt;span&gt;，&lt;/span&gt;&lt;span&gt;KLT&lt;/span&gt;&lt;span&gt;）实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接由&lt;/span&gt;OS（操作系统）&lt;span&gt;内核（&lt;/span&gt;&lt;span&gt;Kernel&lt;/span&gt;&lt;span&gt;）支持的线程，&lt;/span&gt;&lt;span&gt;程序中一般不会使用内核线程，而是会使用&lt;span&gt;内核线程的高级接口，即轻量级进程（&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Light Weight Process&lt;span&gt;，&lt;/span&gt;&lt;span&gt;LWP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，也就是通常意义上的线程&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;每个轻量级线程与内核线程之间&lt;/span&gt;1:1&lt;/span&gt;&lt;span&gt;&lt;span&gt;的关系称之为一对一的线程模型&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　优点：每个&lt;/span&gt;LWP&lt;span&gt;是一个&lt;/span&gt;&lt;span&gt;独立调度单元，即使阻塞了，也不会影响整个进程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　缺点：&lt;/span&gt;&lt;span&gt;需要在&lt;/span&gt;User Mode&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Kernel Mode&lt;/span&gt;&lt;span&gt;中来回切换，系统调用代价比较高&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;span&gt;由于内核线程的支持会&lt;/span&gt;&lt;span&gt;消耗一定的内核资源&lt;/span&gt;&lt;span&gt;，因此一个系统支持轻量级进程的&lt;/span&gt;&lt;span&gt;数量是有限的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（2）&lt;strong&gt;&lt;span&gt;使用用户线程实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　广义上来说，&lt;/span&gt;&lt;span&gt;&lt;span&gt;一个线程只要不是内核线程就可以认为是用户线程&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;User Thread&lt;span&gt;，&lt;/span&gt;&lt;span&gt;UT&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;）&lt;/span&gt;，但其实现仍然建立在内核之上；狭义上来说，&lt;/span&gt;&lt;span&gt;就是&lt;/span&gt;UT&lt;span&gt;是指完全建立在用户空间的线程库上，&lt;/span&gt;&lt;span&gt;Kernel&lt;/span&gt;&lt;span&gt;完全不能感到线程的实现&lt;/span&gt;，&lt;span&gt;线程的所有操作完全在&lt;/span&gt;&lt;span&gt;&lt;span&gt;User Mode&lt;/span&gt;中完成，不需要内核帮助&lt;/span&gt;（部分高性能数据库中的多线程就是UT实现的）&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　缺点：所有的线程都需要用户程序自己处理，以至于“阻塞如何解决”等问题很难解决，甚至无法实现。所以&lt;span&gt;现在Java等语言中已经抛弃使用用户线程&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优点：不需要内核支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（3）&lt;strong&gt;&lt;span&gt;使用用户线程加轻量级进程混合实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　内核线程与用户线程一起使用的实现方式，而&lt;/span&gt;OS&lt;span&gt;提供支持的轻量级进程则是作为用户线程与内核线程之间的桥梁。&lt;/span&gt;UT&lt;span&gt;与&lt;/span&gt;&lt;span&gt;LWP&lt;/span&gt;&lt;span&gt;的数量比是不定的，是&lt;/span&gt;&lt;span&gt;M:N&lt;/span&gt;&lt;span&gt;的关系（许多&lt;/span&gt;&lt;span&gt;Unix&lt;/span&gt;&lt;span&gt;系列的&lt;/span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;span&gt;都提供&lt;/span&gt;&lt;span&gt;M:N&lt;/span&gt;&lt;span&gt;的线程模型）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2、Java线程的实现与调度&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;（1）Java线程的实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;OS&lt;span&gt;支持怎样的线程模型，都是由&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;的线程怎么映射决定的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Sun JDK&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;Windows&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;span&gt;都是使用一对一的线程模型实现（一条&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;线程映射到一条轻量级进程之中）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Solaris&lt;span&gt;平台中，同时支持一对一与多对多的线程模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;（2）Java线程调度：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　是指系统内部为线程分配处理使用权的过程，主要调度分为两种，&lt;span&gt;分别是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;协同式线程调度和抢占式线程调度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1）&lt;span&gt;&lt;span&gt;协同式调度&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;线程执行时间由线程本身控制，线程工作结束后主动通知系统切换到另一个线程去。&lt;/span&gt;　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　① &lt;span&gt;缺点：线程执行时间不可控，切换时间不可预知。如果一直不告诉系统切换线程，那么程序就一直阻塞在那里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　② &lt;span&gt;优点：实现简单，由于是先把线程任务完成再切换，所以切换操作对线程自己是可知的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　2）&lt;span&gt;&lt;span&gt;抢占式调度&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;线程执行时间由系统来分配，切换不由线程本身决定，&lt;/span&gt;Java&lt;span&gt;使用就是抢占式调度。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;并且可以分配优先级（&lt;/span&gt;Java&lt;span&gt;线程中设置了&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;中级别），但并不是靠谱的（优先级可能会在&lt;/span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;span&gt;中被改变），&lt;/span&gt;&lt;span&gt;这是因为线程调度最终被映射到&lt;/span&gt;OS&lt;span&gt;上，由&lt;/span&gt;&lt;span&gt;OS&lt;/span&gt;&lt;span&gt;说了算，所以不见得与&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;线程的优先级一一对应&lt;/span&gt;&lt;span&gt;（事实上&lt;/span&gt;Windows&lt;span&gt;有&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;中，&lt;/span&gt;&lt;span&gt;Solairs&lt;/span&gt;&lt;span&gt;中有&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;次方）&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、Java中五种共享数据&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　（1）&lt;strong&gt;&lt;span&gt;不可变&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;典型的&lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt;&lt;span&gt;修饰&lt;/span&gt;是不可变的（在构造器结束之后），还有&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;&lt;span&gt;对象以及枚举类型&lt;/span&gt;这些本身不可变的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（2）&lt;strong&gt;&lt;span&gt;绝对线程安全&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：不管运行时环境如何，&lt;span&gt;调用者都不需要任何额外的同步措施&lt;/span&gt;（通常需要很大甚至不切实际的代价），在&lt;/span&gt;Java API&lt;span&gt;中很多线程安全的类大多数都不是绝对线程安全&lt;/span&gt;&lt;span&gt;，比如&lt;/span&gt;&lt;span&gt;java.util.Vector&lt;/span&gt;&lt;span&gt;&lt;span&gt;是一个线程安全容器&lt;/span&gt;，它的很多方法（&lt;/span&gt;&lt;span&gt;get()&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;add()&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;size()&lt;/span&gt;&lt;span&gt;）方法都是被&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;修饰，但是&lt;span&gt;并不代表调用它的时候就不需要同步手段了&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（3）&lt;strong&gt;&lt;span&gt;相对线程安全：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;就是&lt;span&gt;我们通常说的线程安全，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Java API&lt;span&gt;中很多这样的例子，比如&lt;/span&gt;&lt;span&gt;HashTable&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Vector&lt;/span&gt;&lt;span&gt;等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（4）&lt;strong&gt;&lt;span&gt;线程兼容：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;就是我们&lt;span&gt;通常说的线程不安全的&lt;/span&gt;，需要额外的同步措施才能保证并发环境下安全使用，&lt;span&gt;比如&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ArrayList&lt;span&gt;和&lt;/span&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　（5）&lt;strong&gt;&lt;span&gt;线程对立：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;不管采用何种手段，都无法在多线程环境中并发使用。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2、线程安全的实现方法&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;（1）互斥同步（Mutual Exclision &amp;amp; Synchronization）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;同步：保证同一时刻共享数据被一个线程（在使用信号量的时候也可以是一些线程）使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　互斥：互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥手段。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1）&lt;span&gt;Java中最常用的互斥同步手段就是synchronized关键字&lt;/span&gt;，synchronized关键字经过编译后会在&lt;span&gt;代码块前后生成monitorenter（锁计数器加1）与monitorexit（锁计数器减1）字节码指令&lt;/span&gt;，而这两个指令需要一个引用类型参数指明要锁定和解锁的对象，也就是synchronized(object/Object.class)传入的对象参数，如果没有参数指定，那就看synchronized修饰的是实例方法还是类方法，去取对应的对象实例与Class对象作为锁对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;Java线程要映射到OS原生线程上，也就是需要从用户态转为核心（系统）态，这个转换可能消耗的时间会很长，尽管VM对synchronized做了一些优化，但还是一种重量级的操作。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2）&lt;span&gt;另一个就是java.util.concurrent包下的重入锁（ReentrantLock）&lt;/span&gt;，与synchronized相似，都具有线程重入（后面会介绍重入概念）特性，但是ReentrantLock有三个主要的不同于synchronized的功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　等待可中断&lt;/span&gt;：持有锁长时间不释放，等待的线程可以选择先放弃等待，改做其他事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　可实现公平锁&lt;/span&gt;：多个线程等待同一个锁时，是按照时间先后顺序依次获得锁，相反非公平锁任何一个线程都有机会获得锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;span&gt;锁绑定多个条件&lt;/span&gt;：是指ReentrantLock对象可以同时绑定多个Condition对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　&lt;span&gt;JDK 1.6之后synchronized与ReentrantLock性能上基本持平，但是VM在未来改进中更倾向于synchronized，所以在大部分情况下优先考虑synchronized。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）非阻塞同步&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;1)“悲观”并发策略------非阻塞同步概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;互斥同步主要问题或者说是影响性能的问题是线程阻塞与唤醒问题，它是一种&lt;/span&gt;&lt;span&gt;“悲观”并发策略&lt;/span&gt;：总是会认为自己不去做相应的同步措施，无论共享数据是否存在竞争它都会去加锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　而相反有一种“乐观”并发策略，也就是先操作，如果没有其他线程使用共享数据，那操作就算是成功了，但是&lt;span&gt;如果共享数据被使用，那么&lt;/span&gt;&lt;span&gt;就会一直不断尝试，直到获得锁使用到共享数据为止&lt;/span&gt;（这是最常用的策略），这样的话就&lt;span&gt;线程就根本不需要挂起。&lt;/span&gt;&lt;span&gt;这就是非阻塞同步（Non-Blocking Synchronization）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　使用“乐观”并发策略需要&lt;span&gt;操作和冲突检测两个步骤具有原子性&lt;/span&gt;，&lt;span&gt;而这个原子性只能靠硬件完成&lt;/span&gt;，保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成。常用的指令有：&lt;span&gt;测试并设置（Test-and-Set）、获取并增加（Fetch-and-Increment）、交换（Swap）、比较并交换（Compare-and-Swap，CAS）、加载链接/条件储存（Load-Linked/Store-Conditional，LL/SC）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2）CAS介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;有三个操作数，分别是内存位置&lt;/span&gt;V&lt;span&gt;，旧的预期值&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;和新值&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt;&lt;span&gt;指令执行时，当且仅当&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;符合旧预期值&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;时，处理器用新值&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;更新&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;的值，否则不更新，但是都会返回&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;的旧值，&lt;span&gt;整个过程都是一个原子过程&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201808/1352849-20180808212415813-335752979.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;之前我在Java内存模型博文中介绍&lt;a href=&quot;https://www.cnblogs.com/jian0110/p/9351281.html&quot; target=&quot;_blank&quot;&gt;volatile关键字的在高并发下并非安全的例子&lt;/a&gt;中，最后的结果并不是我们想要的结果，但是&lt;span&gt;在java.util.concurrent整数原子类( 如AtomicInteger)中，compareAndSet()与getAndIncrement()方法使用了Unsafe类的CAS操作&lt;/span&gt;。&lt;span&gt;现在我们将int换成AtomicInteger&lt;/span&gt;，结果都是我们所期待的10000&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cas;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * Atomic 变量自增运算测试
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lijian
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CASDemo {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_NUM = 10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程数目&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; AWAIT_TIME = 5*1000;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待时间&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger race = &lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; increase() { race.incrementAndGet(); }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         ExecutorService exe =&lt;span&gt; Executors.newFixedThreadPool(THREAD_NUM);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; THREAD_NUM; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             exe.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; 1000; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        increase();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测ExecutorService线程池任务结束并且是否关闭：一般结合shutdown与awaitTermination共同使用
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;shutdown停止接收新的任务并且等待已经提交的任务&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        exe.shutdown();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;awaitTermination等待超时设置，监控ExecutorService是否关闭&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;exe.awaitTermination(AWAIT_TIME, TimeUnit.SECONDS)) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 System.out.println(&quot;线程池没有关闭&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        System.out.println(race);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过观察&lt;/span&gt;incrementAndGet()&lt;span&gt;方法源码我们发现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAndIncrement() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(;;){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; current =&lt;span&gt; get();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; next = current+1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(compareAndSet(current, next)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
        }
     }               
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;for(;;)&lt;span&gt;循环不断尝试将当前&lt;/span&gt;&lt;span&gt;current&lt;/span&gt;&lt;span&gt;加&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;后的新值（&lt;/span&gt;&lt;span&gt;mext&lt;/span&gt;&lt;span&gt;）赋值（&lt;/span&gt;&lt;span&gt;compareAndSet&lt;/span&gt;&lt;span&gt;）给自己，如果失败的话就重新循环尝试，值到成功为止返回&lt;/span&gt;&lt;span&gt;current&lt;/span&gt;&lt;span&gt;值。&lt;/span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3）CAS&lt;span&gt;的&lt;/span&gt;&lt;span&gt;ABA&lt;/span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这是&lt;/span&gt;CAS&lt;span&gt;的一个逻辑漏洞，比如&lt;/span&gt;&lt;span&gt;V&lt;/span&gt;&lt;span&gt;值在第一次读取的时候是&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;值，即没有被改变过，这时候正要准备赋值，但是&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;的值真没有被改变过吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　答案是不一定的，&lt;/span&gt;&lt;span&gt;因为在检测&lt;/span&gt;A&lt;span&gt;值这个过程中&lt;/span&gt;&lt;span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;的值可能被改为&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;最后又改回&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，而&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt;&lt;span&gt;机制就认为它没有被改变过，这也就是&lt;/span&gt;&lt;span&gt;ABA&lt;/span&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt;，解决这个问题就是&lt;/span&gt;&lt;span&gt;&lt;span&gt;增加版本控制变量&lt;/span&gt;，&lt;/span&gt;&lt;span&gt;但是&lt;span&gt;大部分情况下&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ABA&lt;span&gt;问题不会影响程序并发的正确性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）无同步方案&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;&lt;span&gt;“要保障线程安全，必须采用相应的同步措施”这句话实际上是不成立的，因为有些本身就是线程安全的，它可能不涉及共享数据自然就不需要任何同步措施保证正确性。&lt;/span&gt;主要有两类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　1）可重入代码（&lt;/span&gt;Reentrant Code&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　也就是经常所说的纯代码（&lt;/span&gt;Pure Code&lt;span&gt;），&lt;span&gt;可以在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;任何时刻中断它，之后转入其他的程序（当然也包括自身的&lt;/span&gt;&lt;span&gt;recursion&lt;/span&gt;&lt;span&gt;）。最后返回到原程序中而不会发生任何的错误&lt;/span&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;即&lt;/span&gt;“&lt;span&gt;&lt;span&gt;所有可重入的代码都是线程安全的，而所有线程安全的代码都是可重入的&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　其主要特征是以下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　① &lt;span&gt;&lt;span&gt;不依赖存储在堆（堆中对象是共享的）上的数据和公用的系统资源（方法区中可以共享的数据。比如：&lt;/span&gt;static&lt;span&gt;修饰的变量，类的可以相关共享的数据）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　② &lt;span&gt;用到的状态由参数形式传入；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　③ &lt;span&gt;不调用任何非可重入的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　即可以以这样的原则来判断：&lt;/span&gt;&lt;span&gt;我们如果能预测一个方法的返回结果并且方法本身是可预测的，那么输入相同的数据，都会得到相应我们所期待的结果，就满足了可重入性的要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　2）线程本地存储（&lt;/span&gt;Thread Lock Storage&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;如果一段代码中所需要的数据必须与其他代码共享，那么能保证将这些共享数据放到同一个可见线程内，那么无须同步也能保证线程之间不存在竞争关系。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在&lt;/span&gt;Java&lt;span&gt;中如果一个变量要被多线程访问，可以使用&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;关键字修饰保证可见性，&lt;span&gt;如果一个变量要被某个线程共享，可以通过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;java.lang.ThreadLocal&lt;/span&gt;&lt;span&gt;&lt;span&gt;类实现本地存储的功能&lt;/span&gt;。每个线程&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;对象都有一个&lt;/span&gt;&lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;（&lt;span&gt;key-value,&lt;/span&gt;&lt;/span&gt; &lt;span&gt;ThreadLocalHashCode-LocalValue&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;&lt;span&gt;就是当前线程&lt;/span&gt;&lt;span&gt;ThreadLocalMap&lt;/span&gt;&lt;span&gt;的入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;&lt;span&gt;注：这里只是简单了解概念，实际上ThreadLocal部分的知识尤为重要！之后会抽时间细细研究。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 14:19:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9446060.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--15 几何着色器初探 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9429881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9429881.html</guid>
<description>&lt;p&gt;从这一部分开始，感觉就像是踏入了无人深空一样，在之前初学DX11的时候，这部分内容都是基本上跳过的，现在打算重新认真地把它给拾回来。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先用一张图来回顾一下渲染管线的各个阶段，目前为止我们接触的着色器有顶点着色器和像素着色器，而接触到的渲染管线阶段有：输入装配阶段、顶点着色阶段、光栅化阶段、像素着色阶段、输出合并阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180805203259072-78808112.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，几何着色器是我们在将顶点送入光栅化阶段之前，可以操作顶点的最后一个阶段。它同样也允许我们编写自己的着色器代码。几何着色器可以做如下事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;让程序自动决定如何在渲染管线中插入/移除几何体；&lt;/li&gt;
&lt;li&gt;通过流输出阶段将顶点信息再次传递到顶点缓冲区；&lt;/li&gt;
&lt;li&gt;改变图元类型（如输入点图元，输出三角形图元）；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但它也有缺点，几何着色器输出的顶点数据很可能是有较多重复的，从流输出拿回到顶点缓冲区的话会占用较多的内存空间。它本身无法输出索引数组。&lt;/p&gt;
&lt;p&gt;几何着色阶段会收到一系列代表输入几何体类型的顶点，然后我们可以自由选择其中的这些顶点信息，然后交给流输出对象重新解释成新的原始类型（或者不变），传递给流输出阶段或者是光栅化阶段。而几何着色器仅能够接受来自输入装配阶段提供的顶点信息，对每个顶点进行处理，无法自行决定增减顶点。&lt;/p&gt;
&lt;p&gt;注意：离开几何着色器的顶点如果要传递给光栅化阶段，需要包含有转换到齐次裁剪坐标系的坐标信息(语义为&lt;code&gt;SV_POSITION&lt;/code&gt;的&lt;code&gt;float4&lt;/code&gt;向量)&lt;/p&gt;

&lt;h2 id=&quot;从一个看似没什么用的几何着色器代码入手&quot;&gt;从一个看似没什么用的几何着色器代码入手&lt;/h2&gt;
&lt;p&gt;若我们直接从VS项目新建一个几何着色器文件，则可以看到下面的代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct GSOutput
{
    float4 pos : SV_POSITION;
};

[maxvertexcount(3)]
void main(
    triangle float4 input[3] : SV_POSITION, 
    inout TriangleStream&amp;lt; GSOutput &amp;gt; output
)
{
    for (uint i = 0; i &amp;lt; 3; i++)
    {
        GSOutput element;
        element.pos = input[i];
        output.Append(element);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps. 可能有些人会对void main的写法表示不爽，比如说我。不过这不是C语言的主函数......&lt;/p&gt;
&lt;p&gt;若在输入装配阶段指定使用TriangleList图元的话，初步观察该代码，实际上你可以发现其实该着色器只是把输入的顶点按原样输出给流输出对象，即跟什么都没做（咸鱼）有什么区别。。不过从这份代码里面就已经包含了几何着色器所特有的绝大部分语法了。&lt;/p&gt;
&lt;p&gt;首先，几何着色器是根据图元类型来进行调用的，若使用的是TriangleList，则每一个三角形的三个顶点都会作为输入，触发几何着色器的调用。这样一个TriangleList解释的30个顶点会触发10次调用。&lt;/p&gt;
&lt;p&gt;对于几何着色器，我们必须要指定它每次调用所允许输出的最大顶点数目。我们可以使用属性语法来强行修改着色器行为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[maxvertexcount(N)]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里&lt;code&gt;N&lt;/code&gt;就是每次调用允许产出的最大顶点数目，然后最终输出的顶点数目不会超过&lt;code&gt;N&lt;/code&gt;的值。&lt;code&gt;maxvertexcount&lt;/code&gt;的值应当尽可能的小。&lt;/p&gt;
&lt;p&gt;关于性能上的表现，我根据龙书提供的引用找到了对应的说明文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.download.nvidia.com/GPU_Programming_Guide/GPU_Programming_Guide_G80.pdf&quot;&gt;NVIDIA08&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然是10年前的文档，这里说到：在GeForce 8800 GTX，一个几何着色器的调用在输出1到20个标量的时候可以达到最大运行性能表现，但是当我们指定最大允许输出标量的数目在27到40个时，性能仅达到峰值的50%。比如说，如果顶点的声明如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct V0
{
    float3 pos : POSITION;
    float2 tex : TEXCOORD;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里每个顶点就已经包含了5个标量了，如果以它作为输出类型，则&lt;code&gt;maxvertexcount&lt;/code&gt;为4的时候就可以达到理论上的峰值性能（20个标量）。&lt;/p&gt;
&lt;p&gt;但如果顶点类型中还包含有&lt;code&gt;float3&lt;/code&gt;类型的法向量，每个顶点就额外包含了3个标量，这样在&lt;code&gt;maxvertexcount&lt;/code&gt;为4的时候就输出了32个标量，只有50%的峰值性能表现。&lt;/p&gt;
&lt;p&gt;这份文档已经将近10年了，对于那时候的显卡来说使用几何着色器可能不是一个很好的选择，不过当初的显卡也早已不能和现在的显卡相提并论了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;maxvertexcount&lt;/code&gt;的值应当设置到尽可能小的值，因为它将直接决定几何着色器的运行效率。&lt;/li&gt;
&lt;li&gt;几何着色器的每次调用最多只能处理1024个标量，对于只包含4D位置向量的顶点来说也只能处理256个顶点。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;在HLSL编译器里，如果设置的&lt;code&gt;maxvertexcount&lt;/code&gt;过大，会直接收到编译错误：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806192145098-1956370002.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后代码中的&lt;code&gt;triangle&lt;/code&gt;是用于指定输入的图元类型，具体支持的关键字如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;point&lt;/td&gt;
&lt;td&gt;Point list&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;line&lt;/td&gt;
&lt;td&gt;Line list or line strip&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;triangle&lt;/td&gt;
&lt;td&gt;Triangle list or triangle strip&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;lineadj&lt;/td&gt;
&lt;td&gt;Line list with adjacency or line strip with adjacency&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;triangleadj&lt;/td&gt;
&lt;td&gt;Triangle list with adjacency or triangle strip with adjacency&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;具体的图元类型可以到第2章回顾：&lt;a href=&quot;https://www.cnblogs.com/X-Jun/p/9031959.html&quot;&gt;点击此处&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而参数类型可以是用户自定义的结构体类型，或者是向量(float4)类型。从顶点着色器传过来的顶点至少会包含一个表示齐次裁剪坐标的向量。&lt;/p&gt;
&lt;p&gt;参数名&lt;code&gt;inupt&lt;/code&gt;实际上用户是可以任意指定的。&lt;/p&gt;
&lt;p&gt;对于该输入参数的元素数目，取决于前面声明的图元类型：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;point&lt;/td&gt;
&lt;td&gt;[1] 每次只能处理1个顶点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;line&lt;/td&gt;
&lt;td&gt;[2] 一个线段必须包含2个顶点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;triangle&lt;/td&gt;
&lt;td&gt;[3] 一个三角形需要3个顶点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;lineadj&lt;/td&gt;
&lt;td&gt;[4] 一个邻接线段需要4个顶点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;triangleadj&lt;/td&gt;
&lt;td&gt;[6] 一个邻接三角形需要6个顶点&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;而第二个参数必须是一个流输出对象，而且需要被指定为&lt;code&gt;inout&lt;/code&gt;可读写类型。可以看到，它是一个类模板，模板的形参指定要输出的类型。流输出对象有如下三种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;PointStream&lt;/td&gt;
&lt;td&gt;一系列点的图元&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;LineStream&lt;/td&gt;
&lt;td&gt;一系列线段的图元&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TriangleStream&lt;/td&gt;
&lt;td&gt;一系列三角形的图元&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;流输出对象都具有下面两种方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Append&lt;/td&gt;
&lt;td&gt;向指定的流输出对象添加一个输出的数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;RestartStrip&lt;/td&gt;
&lt;td&gt;在以线段或者三角形作为图元的时候，默认是以strip的形式输出的，&lt;br/&gt;如果我们不希望下一个输出的顶点与之前的顶点构成新图元，则需要&lt;br/&gt;调用此方法来重新开始新的strip。若希望输出的图元类型也保持和原&lt;br/&gt;来一样的TriangleList，则需要每调用3次Append方法后就调用一次&lt;br/&gt;RestartStrip。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所谓的删除顶点，实际上就是不将该顶点传递给流输出对象&lt;/li&gt;
&lt;li&gt;若传入的顶点中多余的部分无法构成对应的图元，则抛弃掉这些多余的顶点&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;在开始前，先放出&lt;code&gt;Basic.fx&lt;/code&gt;文件的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;LightHelper.hlsli&quot;

cbuffer CBChangesEveryFrame : register(b0)
{
    row_major matrix gWorld;
    row_major matrix gWorldInvTranspose;
}

cbuffer CBChangesOnResize : register(b1)
{
    row_major matrix gProj;
}

cbuffer CBNeverChange : register(b2)
{
    DirectionalLight gDirLight;
    Material gMaterial;
    row_major matrix gView;
    float3 gEyePosW;
    float gCylinderHeight;
}


struct VertexPosColor
{
    float3 PosL : POSITION;
    float4 Color : COLOR;
};

struct VertexPosHColor
{
    float4 PosH : SV_POSITION;
    float4 Color : COLOR;
};


struct VertexPosNormalColor
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float4 Color : COLOR;
};

struct VertexPosHWNormalColor
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION;
    float3 NormalW : NORMAL;
    float4 Color : COLOR;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战1-将一个三角形分割成三个三角形&quot;&gt;实战1: 将一个三角形分割成三个三角形&lt;/h2&gt;
&lt;p&gt;现在我们的目标是把一个三角形分裂成三个三角形：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180808204508906-886184113.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这也为以后实现分形做为基础。建议读者可以先自行尝试编写着色器代码再来对比。在编写好着色器代码后，&lt;br/&gt;要给渲染管线绑定好一切所需的资源才能够看到效果。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Triangle_VS.hlsl&lt;/code&gt;, &lt;code&gt;Triangle_GS.hlsl&lt;/code&gt;和&lt;code&gt;Triangle_PS.hlsl&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Triangle_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHColor VS(VertexPosColor pIn)
{
    row_major matrix worldViewProj = mul(mul(gWorld, gView), gProj);
    VertexPosHColor pOut;
    pOut.Color = pIn.Color;
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    return pOut;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Triangle_GS.hlsl
#include &quot;Basic.fx&quot;

[maxvertexcount(9)]
void GS(triangle VertexPosHColor input[3], inout TriangleStream&amp;lt;VertexPosHColor&amp;gt; output)
{
    //
    // 将一个三角形分裂成三个三角形，即没有v3v4v5的三角形
    //       v1
    //       /\
    //      /  \
    //   v3/____\v4
    //    /\xxxx/\
    //   /  \xx/  \
    //  /____\/____\
    // v0    v5    v2


    VertexPosHColor vertexes[6];
    int i;
    [unroll]
    for (i = 0; i &amp;lt; 3; ++i)
    {
        vertexes[i] = input[i];
        vertexes[i + 3].Color = (input[i].Color + input[(i + 1) % 3].Color) / 2.0f;
        vertexes[i + 3].PosH = (input[i].PosH + input[(i + 1) % 3].PosH) / 2.0f;
    }

    [unroll]
    for (i = 0; i &amp;lt; 3; ++i)
    {
        output.Append(vertexes[i]);
        output.Append(vertexes[3 + i]);
        output.Append(vertexes[(i + 2) % 3 + 3]);
        output.RestartStrip();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Triangle_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHColor pIn) : SV_Target
{
    return pIn.Color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里输入和输出的图元类型都是一致的，但无论什么情况都一定要注意设置好&lt;code&gt;maxvertexcount&lt;/code&gt;的值，这里固定一个三角形的三个顶点输出9个顶点(构成三个三角形)，并且每3次&lt;code&gt;Append&lt;/code&gt;就需要调用1次&lt;code&gt;RestartStrip&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;实战2-通过圆线构造圆柱体侧面&quot;&gt;实战2: 通过圆线构造圆柱体侧面&lt;/h2&gt;
&lt;p&gt;已知图元类型为LineStrip，现在有一系列连续的顶点构成圆线（近似圆弧的连续折线），构造出圆柱体的侧面。即输入图元类型为线段，输出一个矩形（两个三角形）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180808205822537-1877161667.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;思路: 光有顶点位置还不足以构造出圆柱体侧面，因为无法确定圆柱往哪个方向延伸。所以我们还需要对每个顶点引入所在圆柱侧面的法向量，通过叉乘就可以确定上方向/下方向并进行延伸了。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码-1&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cylinder_VS.hlsl&lt;/code&gt;, &lt;code&gt;Cylinder_GS.hlsl&lt;/code&gt;和&lt;code&gt;Cylinder_PS.hlsl&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Cylinder_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHWNormalColor VS(VertexPosNormalColor pIn)
{
    VertexPosHWNormalColor pOut;
    row_major matrix viewProj = mul(gView, gProj);
    pOut.PosW = mul(float4(pIn.PosL, 1.0f), gWorld).xyz;
    pOut.PosH = mul(float4(pOut.PosW, 1.0f), viewProj);
    pOut.NormalW = mul(pIn.NormalL, (float3x3)gWorldInvTranspose);
    pOut.Color = pIn.Color;
    return pOut;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Cylinder_GS.hlsl
#include &quot;Basic.fx&quot;

// 一个v0v1线段输出6个三角形顶点
[maxvertexcount(6)]
void GS(line VertexPosHWNormalColor input[2], inout TriangleStream&amp;lt;VertexPosHWNormalColor&amp;gt; output)
{
    // *****************************
    // 要求圆线框是顺时针的，然后自底向上构造圆柱侧面           
    //   --&amp;gt;      v2____v3
    //  ______     |\   |
    // /      \    | \  |
    // \______/    |  \ |
    //   &amp;lt;--       |___\|
    //           v1(i1) v0(i0)

    float3 upDir = normalize(cross(input[0].NormalW, (input[1].PosW - input[0].PosW)));
    VertexPosHWNormalColor v2, v3;
    
    matrix viewProj = mul(gView, gProj);


    v2.PosW = input[1].PosW + upDir * gCylinderHeight;
    v2.PosH = mul(float4(v2.PosW, 1.0f), viewProj);
    v2.NormalW = input[1].NormalW;
    v2.Color = input[1].Color;

    v3.PosW = input[0].PosW + upDir * gCylinderHeight;
    v3.PosH = mul(float4(v3.PosW, 1.0f), viewProj);
    v3.NormalW = input[0].NormalW;
    v3.Color = input[0].Color;

    output.Append(input[0]);
    output.Append(input[1]);
    output.Append(v2);
    output.RestartStrip();

    output.Append(v2);
    output.Append(v3);
    output.Append(input[0]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Cylinder_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHWNormalColor pIn) : SV_Target
{
    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 顶点指向眼睛的向量
    float3 toEyeW = normalize(gEyePosW - pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);

    // 只计算方向光
    ComputeDirectionalLight(gMaterial, gDirLight, pIn.NormalW, toEyeW, ambient, diffuse, spec);

    return pIn.Color * (ambient + diffuse) + spec;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战3-画出顶点的法向量&quot;&gt;实战3: 画出顶点的法向量&lt;/h2&gt;
&lt;p&gt;画出顶点的法向量可以帮助你进行调试，排查法向量是否出现了问题。这时候图元的类型为PointList，需要通过几何着色器输出一个线段(两个顶点)。由于顶点中包含法向量，剩下的就是要自行决定法向量的长度。&lt;/p&gt;
&lt;p&gt;下图的法向量长度为0.5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180808210947538-382005993.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码-2&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Normal_VS.hlsl&lt;/code&gt;, &lt;code&gt;Normal_GS.hlsl&lt;/code&gt;和&lt;code&gt;Normal_PS.hlsl&lt;/code&gt;的实现如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Normal_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHWNormalColor VS(VertexPosNormalColor pIn)
{
    VertexPosHWNormalColor pOut;
    row_major matrix viewProj = mul(gView, gProj);
    pOut.PosW = mul(float4(pIn.PosL, 1.0f), gWorld).xyz;
    pOut.PosH = mul(float4(pOut.PosW, 1.0f), viewProj);
    pOut.NormalW = mul(pIn.NormalL, (float3x3) gWorldInvTranspose);
    pOut.Color = pIn.Color;
    return pOut;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Normal_GS.hlsl
#include &quot;Basic.fx&quot;

[maxvertexcount(2)]
void GS(point VertexPosHWNormalColor input[1], inout LineStream&amp;lt;VertexPosHWNormalColor&amp;gt; output)
{
    matrix viewProj = mul(gView, gProj);
    

    VertexPosHWNormalColor v;

    // 防止深度值资源争夺
    v.PosW = input[0].PosW + input[0].NormalW * 0.01f;
    v.NormalW = input[0].NormalW;
    v.PosH = mul(float4(v.PosW, 1.0f), viewProj);
    v.Color = input[0].Color;
    output.Append(v);

    v.PosW = v.PosW + input[0].NormalW * 0.5f;
    v.PosH = mul(float4(v.PosW, 1.0f), viewProj);

    output.Append(v);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Normal_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHWNormalColor pIn) : SV_TARGET
{
    return pIn.Color;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;basicfx.h的变化&quot;&gt;BasicFX.h的变化&lt;/h2&gt;
&lt;p&gt;常量缓冲区和&lt;code&gt;BasicFX&lt;/code&gt;类的变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#ifndef BASICFX_H
#define BASICFX_H

#include &amp;lt;wrl/client.h&amp;gt;
#include &amp;lt;d3d11_1.h&amp;gt;
#include &amp;lt;d3dcompiler.h&amp;gt;
#include &amp;lt;directxmath.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &quot;LightHelper.h&quot;
#include &quot;RenderStates.h&quot;
#include &quot;Vertex.h&quot;

// 由于常量缓冲区的创建需要是16字节的倍数，该函数可以返回合适的字节大小
inline UINT Align16Bytes(UINT size)
{
    return (size + 15) &amp;amp; (UINT)(-16);
}

struct CBChangesEveryFrame
{
    DirectX::XMMATRIX world;
    DirectX::XMMATRIX worldInvTranspose;
};

struct CBChangesOnResize
{
    DirectX::XMMATRIX proj;
};

struct CBNeverChange
{
    DirectionalLight dirLight;
    Material material;
    DirectX::XMMATRIX view;
    DirectX::XMFLOAT3 eyePos;
    float cylinderHeight;
};

class BasicFX
{
public:
    // 使用模板别名(C++11)简化类型名
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    // 初始化Basix.fx所需资源并初始化光栅化状态
    bool InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device);
    // 是否已经初始化
    bool IsInit() const;

    template &amp;lt;class T&amp;gt;
    void UpdateConstantBuffer(const T&amp;amp; cbuffer);

    // 绘制三角形分裂
    void SetRenderSplitedTriangle();
    // 绘制无上下盖的圆柱体
    void SetRenderCylinderNoCap();
    // 绘制所有顶点的法向量
    void SetRenderNormal();


private:
    // objFileNameInOut为编译好的着色器二进制文件(.*so)，若有指定则优先寻找该文件并读取
    // hlslFileName为着色器代码，若未找到着色器二进制文件则编译着色器代码
    // 编译成功后，若指定了objFileNameInOut，则保存编译好的着色器二进制信息到该文件
    // ppBlobOut输出着色器二进制信息
    HRESULT CreateShaderFromFile(const WCHAR* objFileNameInOut, const WCHAR* hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob** ppBlobOut);

private:
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mTriangleVS;                 
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mTrianglePS;                  
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mTriangleGS;               
    
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mCylinderVS;                 
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mCylinderPS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mCylinderGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mNormalVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mNormalPS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mNormalGS;

    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosColorLayout;        // VertexPosColor输入布局
    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosNormalColorLayout;  // VertexPosNormalColor输入布局

    ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; md3dImmediateContext;       // 设备上下文

    std::vector&amp;lt;ComPtr&amp;lt;ID3D11Buffer&amp;gt;&amp;gt; mConstantBuffers;     // 常量缓冲区
};

#endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicinitall方法&quot;&gt;Basic::InitAll方法&lt;/h3&gt;
&lt;p&gt;现在需要初始化一堆着色器、输入布局和常量缓冲区，并绑定常量缓冲区到默认渲染管线：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool BasicFX::InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device)
{
    if (!device)
        return false;

    ComPtr&amp;lt;ID3DBlob&amp;gt; blob;

    // 创建顶点着色器和顶点布局
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_VS.vso&quot;, L&quot;HLSL\\Triangle_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTriangleVS.GetAddressOf()));
    HR(device-&amp;gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout),
        blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), mVertexPosColorLayout.GetAddressOf()));

    HR(CreateShaderFromFile(L&quot;HLSL\\Cylinder_VS.vso&quot;, L&quot;HLSL\\Cylinder_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mCylinderVS.GetAddressOf()));
    HR(device-&amp;gt;CreateInputLayout(VertexPosNormalColor::inputLayout, ARRAYSIZE(VertexPosNormalColor::inputLayout),
        blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), mVertexPosNormalColorLayout.GetAddressOf()));

    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_VS.vso&quot;, L&quot;HLSL\\Normal_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalVS.GetAddressOf()));

    // 创建像素着色器
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_PS.pso&quot;, L&quot;HLSL\\Triangle_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTrianglePS.GetAddressOf()));

    HR(CreateShaderFromFile(L&quot;HLSL\\Cylinder_PS.pso&quot;, L&quot;HLSL\\Cylinder_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mCylinderPS.GetAddressOf()));

    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_PS.pso&quot;, L&quot;HLSL\\Normal_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalPS.GetAddressOf()));

    // 创建几何着色器
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_GS.gso&quot;, L&quot;HLSL\\Triangle_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTriangleGS.GetAddressOf()));

    HR(CreateShaderFromFile(L&quot;HLSL\\Cylinder_GS.gso&quot;, L&quot;HLSL\\Cylinder_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mCylinderGS.GetAddressOf()));

    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_GS.gso&quot;, L&quot;HLSL\\Normal_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalGS.GetAddressOf()));


    RenderStates::InitAll(device);
    device-&amp;gt;GetImmediateContext(md3dImmediateContext.GetAddressOf());

    // ******************
    // 设置常量缓冲区描述
    mConstantBuffers.assign(3, nullptr);
    D3D11_BUFFER_DESC cbd;
    ZeroMemory(&amp;amp;cbd, sizeof(cbd));
    cbd.Usage = D3D11_USAGE_DEFAULT;
    cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    cbd.CPUAccessFlags = 0;

    cbd.ByteWidth = Align16Bytes(sizeof(CBChangesEveryFrame));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[0].GetAddressOf()));
    cbd.ByteWidth = Align16Bytes(sizeof(CBChangesOnResize));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[1].GetAddressOf()));
    cbd.ByteWidth = Align16Bytes(sizeof(CBNeverChange));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[2].GetAddressOf()));

    // 预先绑定各自所需的缓冲区
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;PSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicsetrendersplitedtriangle方法--渲染分裂的三角形&quot;&gt;Basic::SetRenderSplitedTriangle方法--渲染分裂的三角形&lt;/h3&gt;
&lt;p&gt;该方法处理的是图元TriangleList。因为后续的方法处理的图元不同，在调用开始就得设置回正确的图元。也请确保输入装配阶段提供好需要分裂的三角形顶点。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedTriangle()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mTriangleVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mTriangleGS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mTrianglePS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicsetrendercylindernocap方法--渲染圆柱侧面&quot;&gt;Basic::SetRenderCylinderNoCap方法--渲染圆柱侧面&lt;/h3&gt;
&lt;p&gt;该方法处理的是图元LineStrip，确保输入的一系列顶点和法向量能够在同一平面上。若提供的顶点集合按顺时针排布，则会自底向上构建出圆柱体，反之则是自顶向下构建。&lt;/p&gt;
&lt;p&gt;这里需要关闭背面裁剪，因为我们也可以看到圆柱体的内部。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderCylinderNoCap()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosNormalColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mCylinderVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mCylinderGS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mCylinderPS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicsetrendernormal方法--渲染法向量&quot;&gt;Basic::SetRenderNormal方法--渲染法向量&lt;/h3&gt;
&lt;p&gt;该方法处理的图元是PointList，确保输入的顶点要包含法向量。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderNormal()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosNormalColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mNormalVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mNormalGS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mNormalPS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameapp类的变化&quot;&gt;GameApp类的变化&lt;/h2&gt;
&lt;p&gt;该项目包含上面三种实战内容，需要用户去指定当前播放的模式。&lt;/p&gt;
&lt;p&gt;首先声明部分变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class GameApp : public D3DApp
{
public:
    enum class Mode { SplitedTriangle, CylinderNoCap, CylinderNoCapWithNormal };
    
public:
    GameApp(HINSTANCE hInstance);
    ~GameApp();

    bool Init();
    void OnResize();
    void UpdateScene(float dt);
    void DrawScene();

private:
    bool InitResource();

    void ResetTriangle();
    void ResetRoundWire();



private:
    
    ComPtr&amp;lt;ID2D1SolidColorBrush&amp;gt; mColorBrush;               // 单色笔刷
    ComPtr&amp;lt;IDWriteFont&amp;gt; mFont;                              // 字体
    ComPtr&amp;lt;IDWriteTextFormat&amp;gt; mTextFormat;                  // 文本格式

    ComPtr&amp;lt;ID3D11Buffer&amp;gt; mVertexBuffer;                     // 顶点集合
    int mVertexCount;                                       // 顶点数目
    Mode mShowMode;                                         // 当前显示模式

    BasicFX mBasicFX;                                       // Basic特效管理类

    CBChangesEveryFrame mCBChangeEveryFrame;                // 该缓冲区存放每帧更新的变量
    CBChangesOnResize mCBOnReSize;                          // 该缓冲区存放仅在窗口大小变化时更新的变量
    CBNeverChange mCBNeverChange;                           // 该缓冲区存放不会再进行修改的变量
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresettriangle方法--重设为三角形顶点&quot;&gt;GameApp::ResetTriangle方法--重设为三角形顶点&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetTriangle()
{
    // ******************
    // 初始化三角形
    // 设置三角形顶点
    VertexPosColor vertices[] =
    {
        { XMFLOAT3(-1.0f * 3, -0.866f * 3, 0.0f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f) },
        { XMFLOAT3(0.0f * 3, 0.866f * 3, 0.0f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT3(1.0f * 3, -0.866f * 3, 0.0f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) }
    };
    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffer.ReleaseAndGetAddressOf()));
    // 三角形顶点数
    mVertexCount = 3;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetroundwire方法--重设圆线&quot;&gt;GameApp::ResetRoundWire方法--重设圆线&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
void GameApp::ResetRoundWire()
{
    // ******************
    // 初始化圆线
    // 设置圆边上各顶点
    // 必须要按顺时针设置
    // 由于要形成闭环，起始点需要使用2次
    //  ______
    // /      \
    // \______/
    //
    VertexPosNormalColor vertices[41];
    for (int i = 0; i &amp;lt; 40; ++i)
    {
        vertices[i].pos = XMFLOAT3(cosf(XM_PI / 20 * i), -1.0f, -sinf(XM_PI / 20 * i));
        vertices[i].normal = XMFLOAT3(cosf(XM_PI / 20 * i), 0.0f, -sinf(XM_PI / 20 * i));
        vertices[i].color = XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f);
    }
    vertices[40] = vertices[0];

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffer.ReleaseAndGetAddressOf()));
    // 线框顶点数
    mVertexCount = 41;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappupdatescene方法变化&quot;&gt;GameApp::UpdateScene方法变化&lt;/h3&gt;
&lt;p&gt;每次切换需要记得重新设置顶点缓冲区，重新将顶点集绑定到输入，并重设渲染类型。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::UpdateScene(float dt)
{

    // 更新鼠标事件，获取相对偏移量
    Mouse::State mouseState = mMouse-&amp;gt;GetState();
    Mouse::State lastMouseState = mMouseTracker.GetLastState();
    mMouseTracker.Update(mouseState);

    Keyboard::State keyState = mKeyboard-&amp;gt;GetState();
    mKeyboardTracker.Update(keyState);

    // 更新每帧变化的值
    if (mShowMode == Mode::SplitedTriangle)
    {
        mCBChangeEveryFrame.worldInvTranspose = mCBChangeEveryFrame.world = XMMatrixIdentity();
    }
    else
    {
        static float phi = 0.0f, theta = 0.0f;
        phi += 0.0001f, theta += 0.00015f;
        mCBChangeEveryFrame.world = XMMatrixRotationX(phi) * XMMatrixRotationY(theta);
        mCBChangeEveryFrame.worldInvTranspose = XMMatrixTranspose(XMMatrixInverse(nullptr, mCBChangeEveryFrame.world));
    }
    mBasicFX.UpdateConstantBuffer(mCBChangeEveryFrame);


    // 切换显示模式
    if (mKeyboardTracker.IsKeyPressed(Keyboard::D1))
    {
        mShowMode = Mode::SplitedTriangle;
        ResetTriangle();
        // 输入装配阶段的顶点缓冲区设置
        UINT stride = sizeof(VertexPosColor);       // 跨越字节数
        UINT offset = 0;                            // 起始偏移量
        md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, mVertexBuffer.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);
        mBasicFX.SetRenderSplitedTriangle();
    }
    else if (mKeyboardTracker.IsKeyPressed(Keyboard::D2))
    {
        mShowMode = Mode::CylinderNoCap;
        ResetRoundWire();
        // 输入装配阶段的顶点缓冲区设置
        UINT stride = sizeof(VertexPosNormalColor);     // 跨越字节数
        UINT offset = 0;                                // 起始偏移量
        md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, mVertexBuffer.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);
        mBasicFX.SetRenderCylinderNoCap();
    }

    // 显示法向量
    if (mKeyboardTracker.IsKeyPressed(Keyboard::Q))
    {
        if (mShowMode == Mode::CylinderNoCap)
            mShowMode = Mode::CylinderNoCapWithNormal;
        else if (mShowMode == Mode::CylinderNoCapWithNormal)
            mShowMode = Mode::CylinderNoCap;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappdrawscene的变化&quot;&gt;GameApp::DrawScene的变化&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::DrawScene()
{
    assert(md3dImmediateContext);
    assert(mSwapChain);

    md3dImmediateContext-&amp;gt;ClearRenderTargetView(mRenderTargetView.Get(), reinterpret_cast&amp;lt;const float*&amp;gt;(&amp;amp;Colors::Black));
    md3dImmediateContext-&amp;gt;ClearDepthStencilView(mDepthStencilView.Get(), D3D11_CLEAR_DEPTH | D3D11_CLEAR_STENCIL, 1.0f, 0);

    md3dImmediateContext-&amp;gt;Draw(mVertexCount, 0);
    // 绘制法向量，绘制完后记得归位
    if (mShowMode == Mode::CylinderNoCapWithNormal)
    {
        mBasicFX.SetRenderNormal();
        md3dImmediateContext-&amp;gt;Draw(mVertexCount, 0);
        mBasicFX.SetRenderCylinderNoCap();
    }


    //
    // 绘制Direct2D部分
    //
    md2dRenderTarget-&amp;gt;BeginDraw();
    std::wstring text = L&quot;切换类型：1-分裂的三角形 2-圆线构造柱面\n&quot;
        &quot;当前模式: &quot;;
    if (mShowMode == Mode::SplitedTriangle)
        text += L&quot;分裂的三角形&quot;;
    else if (mShowMode == Mode::CylinderNoCap)
        text += L&quot;圆线构造柱面(Q-显示圆线的法向量)&quot;;
    else
        text += L&quot;圆线构造柱面(Q-隐藏圆线的法向量)&quot;;
    md2dRenderTarget-&amp;gt;DrawTextW(text.c_str(), (UINT32)text.length(), mTextFormat.Get(),
        D2D1_RECT_F{ 0.0f, 0.0f, 500.0f, 60.0f }, mColorBrush.Get());
    HR(md2dRenderTarget-&amp;gt;EndDraw());

    HR(mSwapChain-&amp;gt;Present(0, 0));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180808214140597-971901454.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Aug 2018 14:12:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9429881.html</dc:identifier>
</item>
<item>
<title>Java同步—Callable与Future - Kepler-DR</title>
<link>http://www.cnblogs.com/Fill/p/9445908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fill/p/9445908.html</guid>
<description>&lt;h2 id=&quot;runnablefuturecallable的区别&quot;&gt;Runnable、Future、Callable的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Runnable&lt;/strong&gt;我们都用过，因为开启一个新的线程的时候，需要传递一个Runnable接口作为执行对象，这个接口里面只包含一个run方法，无参数，无返回值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Runnable {
    public abstract void run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;strong&gt;Callable&lt;/strong&gt;和Runnable类似，但是&lt;strong&gt;有返回值&lt;/strong&gt;。Callable里面只有一个方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Callable&amp;lt;V&amp;gt; {
    V call() throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想要使用&lt;strong&gt;Callable&lt;/strong&gt;接口需要配合&lt;strong&gt;ExecutorService&lt;/strong&gt;对象(关于ExecutorService类的介绍我们会放到下一篇线程池的讲解中)，&lt;strong&gt;ExecutorService&lt;/strong&gt;类中有两个&lt;strong&gt;submit&lt;/strong&gt;方法，一个用来提交&lt;strong&gt;Runnable&lt;/strong&gt;对象，一个用来提交&lt;strong&gt;Callable&lt;/strong&gt;对象。&lt;/p&gt;
&lt;p&gt;我们可以来看一下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {
  @NotNull &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(@NotNull Callable&amp;lt;T&amp;gt; task);
  @NotNull &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(@NotNull Runnable task,T result);
  @NotNull Future&amp;lt;?&amp;gt; submit(@NotNull Runnable task)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现，这些方法都是返回一个Future的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt;保存异步计算的结果，可以启动一个计算，将Future对象交给某个线程，然后就可以不用管它了，然后等待结果计算好即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;
 
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt;的主要作用就是对具体的&lt;strong&gt;Runnable&lt;/strong&gt;或者&lt;strong&gt;Callable&lt;/strong&gt;任务的执行结果进行取消、查询是否完成、获取结果。&lt;/p&gt;
&lt;p&gt;如果选择使用get方法获取任务执行的结果，会产生阻塞，直到计算完成。&lt;/p&gt;
&lt;p&gt;带参数的get方法用于指定一个时间长度，如果在这个时间长度内，结果还是没有被计算完成的话，会直接返回Null。&lt;/p&gt;
&lt;p&gt;举个例子,用&lt;strong&gt;Future&lt;/strong&gt;获取&lt;strong&gt;Callable&lt;/strong&gt;接口运行的接口:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
    ExecutorService executor = Executors.newCachedThreadPool();
    Future&amp;lt;Integer&amp;gt; result = executor.submit(new Callable&amp;lt;Integer&amp;gt;() {
        @Override
        public Integer call() throws Exception {
            System.out.println(&quot;The sub thread is executing the task...&quot;);
            Thread.sleep(3000);
            int sum = 0;
            for (int i = 0; i &amp;lt; 100; i++)
                sum += i;
            return sum;
        }
    });
    executor.shutdown();//shutdown调用后，不可以再submit新的task，已经submit的将继续执行。

    try {
        Thread.sleep(1000);//主线程等待1秒
    } catch (InterruptedException e1) {
        e1.printStackTrace();
    }

    System.out.println(&quot;The main thread is executing the task...&quot;);

    try {
        System.out.println(&quot;The result of sub task calculated is &quot; + result.get());
    } catch (Exception e) {
        e.printStackTrace();
    }

    System.out.println(&quot;All task have been finished!&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;The sub thread is executing the task...
The main thread is executing the task...
The result of sub task calculated is 4950
All task have been finished!

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;futuretask接口&quot;&gt;FutureTask接口&lt;/h2&gt;
&lt;p&gt;三个接口都介绍完了，这时候我们得说一个有趣的东西，也就是我们的重头菜:&lt;strong&gt;FutureTask&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先不介绍它是什么，让我们直接来看看它的定义:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，我们发现它实现了一个&lt;strong&gt;RunnableFuture&lt;/strong&gt;接口，这个接口是什么呢？我们再来看一下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧，原来&lt;strong&gt;RunnableFuture&lt;/strong&gt;既实现了&lt;strong&gt;Runnable&lt;/strong&gt;又实现了&lt;strong&gt;Future&lt;/strong&gt;，这名字真好理解...&lt;/p&gt;
&lt;p&gt;那&lt;strong&gt;FutureTask&lt;/strong&gt;又实现了&lt;strong&gt;RunnableFuture&lt;/strong&gt;接口，So，&lt;strong&gt;Runnable&lt;/strong&gt;接口既能够被作为线程接收的&lt;strong&gt;Runnable&lt;/strong&gt;对象被运行，也能够作为&lt;strong&gt;Future&lt;/strong&gt;对象接收&lt;strong&gt;Callable&lt;/strong&gt;对象的返回值。&lt;/p&gt;
&lt;p&gt;我们来看一下，FutureTask的两个构造方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {
    public FutureTask(Callable&amp;lt;V&amp;gt; callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }

    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;strong&gt;FutureTask&lt;/strong&gt;接口获取&lt;strong&gt;Callable&lt;/strong&gt;的数据&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newCachedThreadPool();
        //创建FutureTask接口对象，并接受一个Callable参数
        FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(new Callable&amp;lt;Integer&amp;gt;() {
            @Override
            public Integer call() throws Exception {
                System.out.println(&quot;The sub thread is executing the task...&quot;);
                Thread.sleep(3000);
                int sum = 0;
                for (int i = 0; i &amp;lt; 100; i++)
                    sum += i;
                return sum;
            }
        });
        executor.submit(futureTask);//提交要运行的任务
        executor.shutdown();//shutdown调用后，不可以再submit新的task，已经submit的将继续执行。

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }

        System.out.println(&quot;The main thread is executing the task...&quot;);

        try {
            System.out.println(&quot;The result of sub task calculated is &quot; + futureTask.get());
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(&quot;All task have been finished!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果一样:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;The sub thread is executing the task...
The main thread is executing the task...
The result of sub task calculated is 4950
All task have been finished!

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 08 Aug 2018 13:49:00 +0000</pubDate>
<dc:creator>Kepler-DR</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fill/p/9445908.html</dc:identifier>
</item>
</channel>
</rss>