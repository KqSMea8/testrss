<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>css画三角形以及实现带三角的阴影效果 - 小飞侠flyA</title>
<link>http://www.cnblogs.com/ljzy/p/9302536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljzy/p/9302536.html</guid>
<description>&lt;p&gt;&lt;strong&gt;先上图看效果&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436826/201807/1436826-20180712233637800-506095040.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.三角形怎么画&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436826/201807/1436826-20180712233651209-571706168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过控制四周边框实现,想要红色区域三角形的就设置其他三边颜色设置为&lt;strong&gt;transparent&lt;/strong&gt;,想要什么什么三角形就其他边设置为透明颜色即可.&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436826/201807/1436826-20180712233715224-656169130.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.三角形画好后,利用伪类,定位实现带三角对话框效果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436826/201807/1436826-20180712233752927-144494900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.实现阴影效果,因为三角形视觉看上去是三角形,但其实是矩形,直接给加box-shadow实现不了三角形的,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;:再加一个伪类,设置他的颜色为阴影的颜色,然后利用定位差覆盖实现阴影效果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1436826/201807/1436826-20180712233743105-22250841.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>小飞侠flyA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljzy/p/9302536.html</dc:identifier>
</item>
<item>
<title>有关搜索方法的学习过程 - Hakold</title>
<link>http://www.cnblogs.com/hakold/p/9302474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hakold/p/9302474.html</guid>
<description>&lt;p&gt;最近看到一些有关学习如何更高效得去搜索的视频和文章&lt;/p&gt;
&lt;p&gt;因此从中得出了一点小小的心得，记录下来，方便以后学习的过程中去运用这些方法来更高效得去搜索和学习。&lt;/p&gt;
&lt;p&gt;如何去高效搜索？&lt;/p&gt;
&lt;p&gt;其实其中有很多方法，但是重要的是，如何去提高自己的搜索思路。&lt;/p&gt;
&lt;p&gt;这个过程其实就是将问题简化、分类的过程。&lt;/p&gt;
&lt;p&gt;在生活中，我们会遇到许多问题，在时间不充足的时候，思考问题并且找到解决方法可能往往是不实际的，运用现有的资源去最快找到解决思路，能够大大的提高我们日常的工作、学习效率，虽然这可能会弱化独立思考能力，但从效率上来说是可取的，并且学习别人的方法也能够去丰富自己的思考方法。&lt;/p&gt;
&lt;p&gt;因此高效的搜索想要的资讯，是高效的有效途径。&lt;/p&gt;
&lt;p&gt;现有的许多搜索引擎，如百度、谷歌、必应等。&lt;/p&gt;
&lt;p&gt;但在国内，搜索方法可能会没那么多。但是，要在日常高效搜索还是可以的。&lt;/p&gt;
&lt;p&gt;实际上用起来可能会比百度更舒服的搜索还有很多&lt;/p&gt;
&lt;p&gt;我个人搜索时可能会用到&lt;/p&gt;
&lt;p&gt;如：&lt;span&gt;搜索微信http://weixin.sogou.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712224617927-751063912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;搜狗知乎http://zhihu.sogou.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712224657172-2125794554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;甚至有一些导航网站包含了很多搜索方法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：大数据导航http://www.ittime.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712224743522-1512342665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是有一个好的搜索引擎是完全不够的。我们要去精炼自己想要搜索的东西。&lt;/p&gt;
&lt;p&gt;举个小例子，假如我遇到了一个问题是&lt;span&gt;“删除进入系统前出现的系统选项（win7 win8 win10选项）”&lt;/span&gt;。这样描述其实是模糊的。&lt;/p&gt;
&lt;p&gt;那么如果我们把以上描述放入搜索栏去搜索会出现什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712230342836-123833841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;起码，6个标题中，有几个是错误的。但是，其中的这些标题，我们可以获取一些关键字去方便我们进一步搜索。例如&lt;span&gt;“开机选项”“开机引导”&lt;/span&gt;等&lt;/p&gt;
&lt;p&gt;那么如果我们把需要搜索的问题，去把问题提炼一下，把关键字划出来去搜索，&lt;span&gt;“删除其他开机选项”“删除其他开机引导”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712230931040-864685123.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712230944110-1587120465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果出来，基本上都是能够去参考的标题了。&lt;/p&gt;

&lt;p&gt;除了将问题提炼，其实还有一些搜索技巧，搜索指令去辅助我们搜索的。&lt;/p&gt;

&lt;p&gt;举几个简单的例子吧&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;搜索有关文件类型的时候在搜索中添加 “filetype:”的命令 如搜索有关python的pdf文件时可以“python书籍 filetype:pdf”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712231526426-1217536320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;搜索的内容限定网站中的时候在搜索中添加&quot;site:&quot;命令 如在知乎中搜索有关煮饭的关键内容时可以这样搜索“煮饭 site:zhihu.com”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712231609677-133424801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;搜索特定时间的关键词信息时可以添加时间命令“20xx..20xx” 如搜索mongodb在2017到2018年的内容时可以这样搜索“mongodb 2017..2018”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712231914240-176860208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;搜索关键词限定在标题中的时候，如搜索标题含有liunx的内容时可以这样搜索“intitle:linux”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712231935035-666791162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果想要搜索的结果中不包含某些东西的时候，应当在搜索中加入“- 关键词”，如搜索的内容中不想含推广内容那么搜索时可以这样搜索“超级课堂 -推广 -广告”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;做个对比吧&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712232023218-1453053491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1434972/201807/1434972-20180712232039955-2014550546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 以上是最近对于高效搜索的一些小笔记与心得。希望在这里与大家分享一下能够帮助到各位。&lt;/p&gt;

</description>
<pubDate>Thu, 12 Jul 2018 15:32:00 +0000</pubDate>
<dc:creator>Hakold</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hakold/p/9302474.html</dc:identifier>
</item>
<item>
<title>《从Paxos到Zookeeper：分布式一致性原理与实践》第一章读书笔记 - 武培轩</title>
<link>http://www.cnblogs.com/wupeixuan/p/9302496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wupeixuan/p/9302496.html</guid>
<description>&lt;p&gt;第一章主要介绍了计算机系统从集中式向分布式系统演变过程中面临的挑战，并简要介绍了ACID、CAP和BASE等经典分布式理论，主要包含以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集中式的特点&lt;/li&gt;
&lt;li&gt;分布式的特点&lt;/li&gt;
&lt;li&gt;分布式环境的各种问题&lt;/li&gt;
&lt;li&gt;ACID&lt;/li&gt;
&lt;li&gt;分布式事务&lt;/li&gt;
&lt;li&gt;CAP和BASE理论&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;集中式的特点：部署结构简单（因为基于底层性能卓越的大型主机，不需考虑对服务多个节点的部署，也就不用考虑多个节点之间分布式协调问题）&lt;/p&gt;
&lt;p&gt;分布式的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布性&lt;/li&gt;
&lt;li&gt;对等性&lt;/li&gt;
&lt;li&gt;并发性&lt;/li&gt;
&lt;li&gt;缺乏全局时钟&lt;/li&gt;
&lt;li&gt;故障总是会发生&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分布式环境的各种问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通信异常：主要是因为网络本身的不可靠性&lt;/li&gt;
&lt;li&gt;网络分区：当网络发生异常时，导致部分节点之间的网络延时不断增大，最终导致部分节点可以通信，而另一部分节点不能。&lt;/li&gt;
&lt;li&gt;三态（成功、失败与超时）&lt;/li&gt;
&lt;li&gt;节点故障：组成分布式系统的服务器节点出现宕机或“僵死”现象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，狭义上的事务特指数据库事务。&lt;/p&gt;
&lt;p&gt;事务有四个特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称为事务的ACID特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子性（Atomicity）：必须是一个原子的操作序列单元，只允许出现两种状态之一（全部成功执行，全部不执行）。&lt;/li&gt;
&lt;li&gt;一致性（Consistency）：不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库必须处于一致性状态。&lt;/li&gt;
&lt;li&gt;隔离性（Isolation）：相互隔离的，一个事务的执行不能被其他事务干扰。&lt;/li&gt;
&lt;li&gt;持久性（Durability）：也称为永久性，一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来保证持久性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;事务四种隔离级别有未授权读取、授权读取、可重复读取和串行化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;未授权读取（READ UNCOMMITTED）：也称为读未提交，允许脏读取。&lt;/li&gt;
&lt;li&gt;授权读取（READ COMMITTED）：也称为读已提交，允许不可重复读取。&lt;/li&gt;
&lt;li&gt;可重复读取（REPEATABLE READ）：禁止了不可重复读取和脏读取，但是有可能出现幻影数据（指同样的事务操作，在前后两个两个时间段内执行对同一个数据项的读取，可能出现不一致的结果）。&lt;/li&gt;
&lt;li&gt;串行化（SERIALIXABLE）：要求所有事务串行执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四种隔离级别的对比&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;未授权读取&lt;/td&gt;
&lt;td&gt;存在&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;授权读取&lt;/td&gt;
&lt;td&gt;不存在&lt;/td&gt;
&lt;td&gt;不可以&lt;/td&gt;
&lt;td&gt;存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;可重复读取&lt;/td&gt;
&lt;td&gt;不存在&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;不存在&lt;/td&gt;
&lt;td&gt;可以&lt;/td&gt;
&lt;td&gt;不存在&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;事务隔离级别越高，就越能保证数据的完整性和一致性，但对并发性能的影响也越大。优先考虑将数据库的隔离级别设置为授权读取，能够避免脏读同时保证较好并发性能，会导致不可重复读、虚读和第二类丢失更新等并发问题，在可能出现这类问题的场合中，应主动采用悲观锁和乐观锁进行事务控制。&lt;/p&gt;
&lt;p&gt;分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。也可以被定义为一种嵌套型的事务，同时也具有了ACID事务特性。&lt;/p&gt;
&lt;p&gt;CAP理论：一个分布式系统不可能同时满足一致性、可用性和分区容错性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一致性：数据在多个副本之间是否能够保持一致的特性。&lt;/li&gt;
&lt;li&gt;可用性：系统提供的服务必须一致处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。&lt;/li&gt;
&lt;li&gt;分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从CAP定理看出，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个需求。对于一个分布式系统，分区容错性是一个最基本的需求。&lt;/p&gt;
&lt;p&gt;BASE理论：是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基本可用：分布式系统在出现不可预知故障的时候，允许损失部分可用性。&lt;/li&gt;
&lt;li&gt;弱状态：也称软状态，允许系统在不同节点的数据副本之间进行数据同步存在延时。&lt;/li&gt;
&lt;li&gt;最终一致性：系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终一致性存在以下五类变种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因果一致性&lt;/li&gt;
&lt;li&gt;读己之所写&lt;/li&gt;
&lt;li&gt;会话一致性&lt;/li&gt;
&lt;li&gt;单调读一致性&lt;/li&gt;
&lt;li&gt;单调写一致性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总得来说BASE理论面向的是大型高可用可扩展的分布式系统，完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获取可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。实际分布式场景中，ACID特性和BASE理论会结合在一起。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 15:31:00 +0000</pubDate>
<dc:creator>武培轩</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wupeixuan/p/9302496.html</dc:identifier>
</item>
<item>
<title>轻量级的同步机制——volatile语义详解(可见性保证+禁止指令重排) - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9302398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9302398.html</guid>
<description>&lt;h2 id=&quot;关于volatile&quot;&gt;1.关于volatile&lt;/h2&gt;
&lt;p&gt;volatile是java语言中的关键字,用来修饰会被多线程访问的共享变量,是JVM提供的轻量级的同步机制,相比同步代码块或者重入锁有更好的性能。它主要有两重语义，一是保证多个线程对共享变量访问的可见性，二防止指令重排序。&lt;/p&gt;
&lt;h2 id=&quot;语义一内存可见性&quot;&gt;2.语义一:内存可见性&lt;/h2&gt;
&lt;h4 id=&quot;一个例子&quot;&gt;2.1 一个例子&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class TestVolatile {

    public static void main(String[] args) throws InterruptedException {

        ThreadDemo threadDemo = new ThreadDemo();
        new Thread(threadDemo).start();
        threadDemo.flag = false;
        System.out.println(&quot;已将flag置为&quot; + threadDemo.flag);

    }

    static class ThreadDemo implements Runnable {

        boolean flag = true;

        @Override
        public void run() {
            System.out.println(&quot;Flag=&quot; + flag);
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你多次执行代码时,有一定几率会出现这种结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180712230054322-728358775.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在主线程将子线程实例的flag置为false后,子线程中的flag竟然还是true。这是怎么回事？这就是多线程的内存可见性问题。对于一个没有volatile修饰的的共享变量,当一个线程对其进行了修改，另一线程并不一定能马上看见这个被修改后的值。为什么会出现这种情况呢？这就要从java的内存模型谈起。&lt;/p&gt;
&lt;h4 id=&quot;java的内存模型jmm&quot;&gt;2.2 java的内存模型(JMM)&lt;/h4&gt;
&lt;p&gt;java的内存模型定义了线程和主内存之间的抽象关系,它的内容主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主要由多线程共享的主内存和各线程私有的工作内存组成(工作内存是个抽象概念，并不真实存在，是对缓冲区，cpu寄存器等的抽象)&lt;/li&gt;
&lt;li&gt;变量都存储于主内存中，但是线程的工作内存中保存着要使用的变量在主内存中的副本。&lt;/li&gt;
&lt;li&gt;线程对变量的操作必须在工作内存中进行，不同的线程无法直接访问对方的工作内存，相互通信必须经过主内存。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程,主内存，工作内存三者的交互关系如图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180712230135885-1862739893.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看看JMM模型会给我们在多线程环境下的读写带来什么样的问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个线程(记为A)对共享变量进行修改时,修改的并不是主内存中的变量，而是该线程对应的工作内存中该变量的一个副本。&lt;/li&gt;
&lt;li&gt;当主内存中的变量值已经被修改,另一个线程读取的却还是自己工作内存中的旧值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时就出现了共享变量在多线程环境下的可见性问题。如果把线程的工作内存当作主内存的缓存，这个问题的本质就在于如何解决缓存失效问题。那么JMM中是如何解决可见性问题的?这就不得不提到happens-before规则。&lt;/p&gt;
&lt;h4 id=&quot;happens-before规则&quot;&gt;2.3 happens-before规则&lt;/h4&gt;
&lt;p&gt;happens-before规则又叫先行发生规则。它定义了java内存模型中两项操作的偏序关系,更确切的说，它定义了操作可见性之间的偏序关系。比如A操作 happens-before B操作，并不意味这A操作一定在B操作之前,而是A操作的影响能被操作B观察到，这个影响包括改变了内存中共享变量的值，发送消息等。那么JMM定义了哪些happens-before规则？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.程序顺序规则:一个线程中的每个操作，happens-before于该线程中的任意后续操作。&lt;/li&gt;
&lt;li&gt;2.监视器锁规则：对于一个锁的解锁，happens-before于随后对这个锁的加锁。&lt;/li&gt;
&lt;li&gt;3.volatile变量规则：对于一个volatile 变量的写，happens-before于任意后续对这个volatile变量的读。&lt;br/&gt;这里对于我们而言重要的是第三点。即对于一个volatile变量，写操作happens-before于读操作，也就是说，一个线程对volatile变量做了修改，另一个线程能马上读到这个被修改后的值。&lt;br/&gt;这样就能解决共享变量在多线程环境下的可见性问题了。结合JMM模型，我们可以继续探讨下volatile是如何做到这点的。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;volatile解决内存可见性问题的原理&quot;&gt;2.4 volatile解决内存可见性问题的原理&lt;/h4&gt;
&lt;p&gt;当一个变量被修饰为volatile后，对其的读写就会显得比较特别&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1.写一个volatile变量时，JMM首先修改工作内存中的变量值,并刷新到主内存中&lt;br/&gt;如图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180712230158371-809348209.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.读一个变量时，JMM会把该线程对应的本地内存置为无效，并从主内存中读取共享变量。&lt;br/&gt;如图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180712230226086-1378253783.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对volatile变量的读写,可以说都是直接对主内存进行的操作，这样虽然会牺牲一些性能，但是解决了“缓存一致性问题”，使得变量的在多线程间的可见行得到了很好的保证。&lt;/p&gt;
&lt;h2 id=&quot;语义二禁止指令重排&quot;&gt;3. 语义二：禁止指令重排&lt;/h2&gt;
&lt;h4 id=&quot;为什么会有指令重排&quot;&gt;3.1 为什么会有指令重排&lt;/h4&gt;
&lt;p&gt;为了优化程序性能,编译器和处理器会对java编译后的字节码和机器指令进行重排序，通俗的说代码的执行顺序和我们在程序中定义的顺序会有些不同,只要不改变单线程环境下的执行结果就行。但是在多线程环境下，这么做却可能出现并发问题。比如下面的例子。&lt;/p&gt;
&lt;h4 id=&quot;线程不安全的双重检查单例模式&quot;&gt;3.2 线程不安全的双重检查单例模式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180712230300767-602827704.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行这段代码我们可能会得到一个匪夷所思的结果:我们获得的单例对象是未初始化的。为什么会出现这种情况？因为指令重排。首先要明确一点，同步代码块中的代码也是能够被指令重排的。然后来看问题的关键&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; INSTANCE = new Singleton();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然在代码中只有一行,编译出的字节码指令可以用如下三行表示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.为对象分配内存空间&lt;/li&gt;
&lt;li&gt;2.初始化对象&lt;/li&gt;
&lt;li&gt;3.将INSTANCE变量指向刚分配的内存地址&lt;br/&gt;由于步骤2,3交换不会改变单线程环境下的执行结果，故而这种重排序是被允许的。也就是我们在初始化对象之前就把INSTANCE变量指向了该对象。而如果这时另一个线程刚好执行到代码所示的2处&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;if (INSTANCE == null)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这时候有意思的事情就发生了:虽然INSTANCE指向了一个未被初始化的对象,但是它确实不为null了,所以这个判断会返回false,之后它将return一个未被初始化的单例对象！整个过程的执行流程如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180712230342126-1077711263.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于重排序是编译器和CPU自动进行的，那么有什么办法能禁止这种重排序操作吗？很简单,给&lt;br/&gt;INSTANCE变量加个volatile关键字就行,这样编译器就会根据一定的规则禁止对volatile变量的读写操作重排序了。而编译出的字节码，也会在合适的地方插入内存屏障,比如volatile写操作之前和之后会分别插入一个StoreStore屏障和StoreLoad屏障，禁止CPU对指令的重排序越过这些屏障。&lt;/p&gt;
&lt;h2 id=&quot;volatile的其他特性&quot;&gt;4. volatile的其他特性&lt;/h2&gt;
&lt;p&gt;对volatile变量的读写具有原子性，但是其他操作并不一定具有原子性，一个简单的例子就是i++。由于该操作并不具有原子性，故而即使该变量被volatile修饰，多线程环境下也不能保证线程安全。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;5.总结&lt;/h2&gt;
&lt;p&gt;volatile是jvm提供的轻量级同步工具。被volatile修饰的共享变量在多线程环境下可以获得可见行保证。其次它还能禁止指令重排。由于对volatile的写-读与锁的释放-获取具有相同的内存语义，故某些时候可以代替锁来获得更好的性能。但是和锁不一样，它不能保证任何时候都是线程安全的。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 15:13:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9302398.html</dc:identifier>
</item>
<item>
<title>【原创】分布式之数据库和缓存双写一致性方案解析(三) - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9302316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9302316.html</guid>
<description>&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;博主本来觉得，&lt;a href=&quot;https://www.cnblogs.com/rjzheng/p/9041659.html&quot;&gt;《分布式之数据库和缓存双写一致性方案解析》&lt;/a&gt;，一文已经十分清晰。然而这一两天，有人在微信上私聊我，觉得应该要采用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;先删缓存，再更新数据库，再删缓存&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一方案作为缓存更新策略，而不是先更新数据库，再删缓存。并且搬出了两篇大佬的文章，&lt;a href=&quot;https://mp.weixin.qq.com/s/7IgtwzGC0i7Qh9iTk99Bww&quot;&gt;《Cache Aside Pattern》&lt;/a&gt;，&lt;a href=&quot;https://mp.weixin.qq.com/s/gYQvP69sao8U0azuNRMG1w&quot;&gt;《缓存与数据库不一致，咋办？》&lt;/a&gt;，希望博主能加以说明。因为问的人太多了，所以才有了这篇文章的诞生。&lt;/p&gt;
&lt;h2 id=&quot;正文-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;在开始这篇文章之前，我们先自己思考一下以下两个更新策略&lt;/p&gt;
&lt;h3 id=&quot;方案一&quot;&gt;方案一&lt;/h3&gt;
&lt;p&gt;(1)删缓存&lt;br/&gt;(2)更数据库&lt;br/&gt;(3)删缓存&lt;/p&gt;
&lt;h3 id=&quot;方案二&quot;&gt;方案二&lt;/h3&gt;
&lt;p&gt;(1)更数据库&lt;br/&gt;(2)删缓存&lt;/p&gt;
&lt;p&gt;大家看下面的文章前，自己先思考一下，&lt;strong&gt;方案一的步骤(1)有没有存在的必要？&lt;/strong&gt;&lt;br/&gt;先上一个&lt;strong&gt;结论&lt;/strong&gt;:方案二存在的缺点，方案一全部存在，且方案一比方案二多一个步骤，所以应该选方案二。&lt;/p&gt;
&lt;p&gt;下面，针对&lt;a href=&quot;https://mp.weixin.qq.com/s/7IgtwzGC0i7Qh9iTk99Bww&quot;&gt;《Cache Aside Pattern》&lt;/a&gt;，&lt;a href=&quot;https://mp.weixin.qq.com/s/gYQvP69sao8U0azuNRMG1w&quot;&gt;《缓存与数据库不一致，咋办？》&lt;/a&gt;这两篇文章提出的论点，提出小小的质疑。这两篇文章认为方案二不行的原因，主要有以下两点&lt;br/&gt;&lt;strong&gt;(1)方案二在步骤(2)，出现删缓存失败的情况下，会出现数据不一致的情形，如下图所示&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_cache1.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;strong&gt;(2)方案二存在下面的主从同步，导致cache不一致问题，如下图所示&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_cache2.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;大致流程就是，线程A写，线程B读，会有以下流程出现&lt;br/&gt;(1)缓存刚好失效&lt;br/&gt;(2)线程A写入master数据库，slave还没同步&lt;br/&gt;(3)线程B发现缓存失效，去slave读到旧值&lt;br/&gt;(4)线程A删除缓存&lt;br/&gt;(5)线程B把旧值放入缓存&lt;/p&gt;
&lt;p&gt;然而大家发现了么，这两篇文章提出的反对意见，在该文作者自己所提出的方案一里头也是存在的？&lt;br/&gt;&lt;strong&gt;(1)针对删缓存失败问题&lt;/strong&gt;&lt;br/&gt;方案一的步骤(3)也会可能出现删除缓存失败问题，可是作者没有加以详细说明。&lt;br/&gt;&lt;strong&gt;(2)针对数据不一致问题&lt;/strong&gt;&lt;br/&gt;线程A写，线程B读，会有以下流程出现&lt;br/&gt;(1)线程A删除缓存&lt;br/&gt;(2)线程A写入master数据库，slave还没同步&lt;br/&gt;(3)线程B发现缓存失效，去slave读到旧值&lt;br/&gt;(4)线程A删除缓存&lt;br/&gt;(5)线程B把旧值放入缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综上所述&lt;/strong&gt;，我们应该选择方案二，而不是方案一。方案二存在的缺点，方案一全部存在，且方案一步骤上多了一步，增加了不稳定因素。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;该文章只是纠正了一下目前流传的观点的正确性，并没有针对任何人。技术的世界，只论技术。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 15:01:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9302316.html</dc:identifier>
</item>
<item>
<title>编程语言吐槽之Java与C - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9302366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9302366.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201807/672506-20180712225344562-471072543.jpg&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;包含各种偏见和武断，请谨慎阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么在学校学习的C，拿到企业生产中不起作用？&lt;/p&gt;
&lt;p&gt;而为什么企业级的程序员，依然对C/C++无法掌控？在算法各方面不够精湛？&lt;/p&gt;
&lt;p&gt;根本原因还是应用场景的不同。企业级的开发，主要是为了能够快速出活，能够快速将业务需求转换为可执行的代码，立马部署上线开始工作。这就需要Java这样的重型机枪。在这里，重点是能够快速地做出一个“转换”，把复杂的business model快速转换为代码的“表达能力”。&lt;/p&gt;
&lt;p&gt;而C/C++所解决的问题，其实更多的是底层，也就是为上面的“快速构建”和“客户需求的转换能力”，提供底层库的支持。所以，它的视角和范围，根本不是去关心如何表述客户的业务需求，它也不擅长去表述业务需求关系。&lt;/p&gt;
&lt;p&gt;它真正擅长的是表述计算机的运转关系！所以在这个层级，你的算法各方面就开始有了用武之地。因为在这个层次上，你的优化、算法的效率，都和计算机如何运转息息相关。例如：你的代码如何被加载进内存，在CPU内又是如何调用相应的指令集，内存分配上又会经历哪些过程，这一个个的环节都关乎你想要去追求的效率。&lt;/p&gt;
&lt;p&gt;另一方面，高层语言和底层语言又是相互结合的：上层的Java这些确实善于描述business model，但是，没有底层库的支撑，它的表述无异于一纸空文。&lt;/p&gt;
&lt;p&gt;而下层的库，如果没有上层的语法糖和high level的抽象，就不得不一直局限在计算机无尽的运转细节里，永远无法跳出来，为经济生产、为解放生产力、发展生产力的现实用途服务。&lt;/p&gt;
&lt;p&gt;所以，回到最初那个问题，为什么你学校学习的C那些在企业级生产中不管用？因为它的适用范围是为了解决计算机底层的问题。而企业级应用的高级程序员，他擅长的其实是快速准确地把现实的客户诉求，转换为可工作的代码，并能够掌控大规模的代码量，这是他的核心竞争力。但他其实少有关注底层的实现，少有去关心如何配合计算机的机械性地运作方式。&lt;/p&gt;
&lt;p&gt;基于此，很多人对语言的评价是极其不中肯的。&lt;/p&gt;
&lt;p&gt;有的人说，Java真是简单，傻瓜式的语言，没啥意思。可这就完全搞错了重点，简单易学，正是能够快速表达客户需求的一个大前提。而精髓呢？精髓是看你如何运用这个工具，一方面能够精准地表述出实际的业务模型，另一方面是看你能够用这个工具，能够如何巧妙地组织各个模块，使得它们能够具备扩展性、可重用性，从而能够应对快速变化需求的挑战。&lt;/p&gt;
&lt;p&gt;另一部分人说，C太不安全了、没法做好的异常、没法做精准的泛型、更无法做漂亮的继承。可是，C的应用范围就是底层啊。这里提到的一堆面向对象的理念，其实是现实世界的运作思维模式，但这个不是计算机机械式的思考方式。机械式的思考模式，就是汇编、就是语句跳转、就是内存分配。在这个体系里，其重点就是为higher level制造工具，为你设想的那些面向对象的思维概念制造工具。&lt;/p&gt;
&lt;p&gt;这就好比是，你拿到的是一块原木，你非得去抱怨，它怎么不长成圆盘形，为什么不长成方形，为什么不长成螺丝帽的形状，这都不能用好吧？！这TM不废话么！你的工作不就是对这些天然的原木做工，把它们制作成可以供其它生产环节使用的工具么。&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484377&amp;amp;idx=1&amp;amp;sn=0143c4416d973797727c157059baac0f&amp;amp;chksm=ec20e465db576d73b69c0a01d4bfc3334e1a00b70b3d4b24c795b600ecea86ee911616803e40&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;减法 、认知、核心&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484369&amp;amp;idx=1&amp;amp;sn=6fc425fbe63969f2107a592502d18554&amp;amp;chksm=ec20e46ddb576d7b5cb44a78d21fdc01c46d85921620ca1bb5089579f78d33bb7cc719dba3c5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;一次艰难debug的反思&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484365&amp;amp;idx=1&amp;amp;sn=3368e2043b1500a5684b0122075db079&amp;amp;chksm=ec20e471db576d670a3f325182a0e063888b83f1ef67a6e6775ce5587e2363e3125646606f0d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;J2EE导论 | 疑惑篇&lt;/a&gt;》&lt;/p&gt;


&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201807/672506-20180712225542948-2081604010.jpg&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;257&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201807/672506-20180712225653943-174210863.png&quot; alt=&quot;&quot; width=&quot;380&quot; height=&quot;234&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 14:58:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9302366.html</dc:identifier>
</item>
<item>
<title>自动扫雷 python - chestnut_egg</title>
<link>http://www.cnblogs.com/chestnut-egg/p/9302238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chestnut-egg/p/9302238.html</guid>
<description>&lt;h3&gt;自动扫雷一般分为两种，一种是读取内存数据，而另一种是通过分析图片获得数据，并通过模拟鼠标操作，这里我用的是第二种方式。&lt;/h3&gt;


&lt;h2&gt;1.扫雷游戏&lt;/h2&gt;
&lt;p&gt;我是win10，没有默认的扫雷，所以去扫雷网下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.saolei.net/BBS/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1283237/201807/1283237-20180712215614193-1371702350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.python 3&lt;/h2&gt;
&lt;p&gt;我的版本是 python 3.6.1&lt;/p&gt;
&lt;h2&gt;3.python的第三方库&lt;/h2&gt;
&lt;p&gt;win32api,win32gui,win32con,Pillow,numpy,opencv&lt;br/&gt;可通过 pip install --upgrade SomePackage 来进行安装&lt;br/&gt;&lt;span&gt;注意：&lt;/span&gt;有的版本是下载pywin32，但是有的要把pywin32升级到最高并自动下载了pypiwin32，具体情况每个python版本可能都略有不同&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我给出我的第三方库和版本仅供参考&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1283237/201807/1283237-20180712220654370-1015066856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;1.找到游戏窗口与坐标&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#扫雷游戏窗口
class_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TMain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
title_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Minesweeper Arbiter &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
hwnd &lt;/span&gt;=&lt;span&gt; win32gui.FindWindow(class_name, title_name)

#窗口坐标
left &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
top &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
right &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
bottom &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt;&lt;span&gt; hwnd:
    print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;找到窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    left, top, right, bottom &lt;/span&gt;=&lt;span&gt; win32gui.GetWindowRect(hwnd)
    #win32gui.SetForegroundWindow(hwnd)
    print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;窗口坐标：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    print(str(left)&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;+str(right)+&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;+str(top)+&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;+&lt;span&gt;str(bottom))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未找到窗口&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.锁定并抓取雷区图像&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#锁定雷区坐标&lt;br/&gt;#去除周围功能按钮以及多余的界面&lt;br/&gt;#具体的像素值是通过QQ的截图来判断的
left &lt;/span&gt;+= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;
top &lt;/span&gt;+= &lt;span&gt;101&lt;/span&gt;&lt;span&gt;
right &lt;/span&gt;-= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;
bottom &lt;/span&gt;-= &lt;span&gt;42&lt;/span&gt;&lt;span&gt;

#抓取雷区图像
rect &lt;/span&gt;=&lt;span&gt; (left, top, right, bottom)
img &lt;/span&gt;= ImageGrab.grab().crop(rect)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;3.各图像的RGBA值&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;179&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#数字1-8 周围雷数&lt;span&gt;
#0&lt;span&gt; 未被打开
#ed&lt;span&gt; 被打开 空白
#hongqi 红旗&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
#boom 普通雷&lt;br/&gt;#boom_red 踩中的雷
&lt;/pre&gt;
&lt;pre&gt;
rgba_ed = [(&lt;span&gt;225&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_hongqi &lt;/span&gt;= [(&lt;span&gt;54&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;)), (&lt;span&gt;17&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)), (&lt;span&gt;109&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;54&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;22&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))]
rgba_0 &lt;/span&gt;= [(&lt;span&gt;54&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;)), (&lt;span&gt;148&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;54&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_1 &lt;/span&gt;= [(&lt;span&gt;185&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;40&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;))]
rgba_2 &lt;/span&gt;= [(&lt;span&gt;160&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;65&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))]
rgba_3 &lt;/span&gt;= [(&lt;span&gt;62&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)), (&lt;span&gt;163&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_4 &lt;/span&gt;= [(&lt;span&gt;169&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;56&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_5 &lt;/span&gt;= [(&lt;span&gt;70&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)), (&lt;span&gt;155&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_6 &lt;/span&gt;= [(&lt;span&gt;153&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;72&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_8 &lt;/span&gt;= [(&lt;span&gt;149&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;107&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;))]
rgba_boom &lt;/span&gt;= [(&lt;span&gt;4&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;)), (&lt;span&gt;144&lt;/span&gt;, (&lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;, &lt;span&gt;192&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;77&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))]
rgba_boom_red &lt;/span&gt;= [(&lt;span&gt;4&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;)), (&lt;span&gt;144&lt;/span&gt;, (&lt;span&gt;255&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)), (&lt;span&gt;31&lt;/span&gt;, (&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;)), (&lt;span&gt;77&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))]
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.扫描雷区图像保存至一个二维数组map&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#扫描雷区图像
def showmap():
    img &lt;/span&gt;=&lt;span&gt; ImageGrab.grab().crop(rect)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(blocks_y):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(blocks_x):
            this_image &lt;/span&gt;= img.crop((x * block_width, y * block_height, (x + &lt;span&gt;1&lt;/span&gt;) * block_width, (y + &lt;span&gt;1&lt;/span&gt;) *&lt;span&gt; block_height))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; this_image.getcolors() ==&lt;span&gt; rgba_0:
                map[y][x] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_1:
                map[y][x] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_2:
                map[y][x] &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_3:
                map[y][x] &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_4:
                map[y][x] &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_5:
                map[y][x] &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_6:
                map[y][x] &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_8:
                map[y][x] &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_ed:
                map[y][x] &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;==&lt;span&gt; rgba_hongqi:
                map[y][x] &lt;/span&gt;= -&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
            elif this_image.getcolors() &lt;/span&gt;== rgba_boom or this_image.getcolors() ==&lt;span&gt; rgba_boom_red:
                &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; gameover
                gameover &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;
                #sys.exit(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无法识别图像&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;坐标&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                print((y,x))
                print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;颜色&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                print(this_image.getcolors())
                sys.exit(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    #print(map)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.扫雷算法&lt;/h2&gt;
&lt;p&gt;这里我采用的最基础的算法&lt;/p&gt;
&lt;p&gt;1.首先点出一个点&lt;/p&gt;
&lt;p&gt;2.扫描所有数字，如果周围空白+插旗==数字，则空白均有雷，右键点击空白插旗&lt;/p&gt;
&lt;p&gt;3.扫描所有数字，如果周围插旗==数字，则空白均没有雷，左键点击空白&lt;/p&gt;
&lt;p&gt;4.循环2、3，如果没有符合条件的，则随机点击一个白块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#插旗
def banner():
    showmap()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(blocks_y):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(blocks_x):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;lt;= map[y][x] and map[y][x] &amp;lt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:
                boom_number &lt;/span&gt;=&lt;span&gt; map[y][x]&lt;/span&gt;&lt;span&gt;
                block_white &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
                block_qi &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; yy &lt;span&gt;in&lt;/span&gt; range(y-&lt;span&gt;1&lt;/span&gt;,y+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; xx &lt;span&gt;in&lt;/span&gt; range(x-&lt;span&gt;1&lt;/span&gt;,x+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;lt;= yy and &lt;span&gt;0&lt;/span&gt; &amp;lt;= xx and yy &amp;lt; blocks_y and xx &amp;lt;&lt;span&gt; blocks_x:
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not (yy == y and xx ==&lt;span&gt; x):&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; map[yy][xx] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
                                    block_white &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                                elif map[yy][xx] &lt;/span&gt;== -&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:
                                    block_qi &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; boom_number == block_white +&lt;span&gt; block_qi:&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; yy &lt;span&gt;in&lt;/span&gt; range(y - &lt;span&gt;1&lt;/span&gt;, y + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; xx &lt;span&gt;in&lt;/span&gt; range(x - &lt;span&gt;1&lt;/span&gt;, x + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;lt;= yy and &lt;span&gt;0&lt;/span&gt; &amp;lt;= xx and yy &amp;lt; blocks_y and xx &amp;lt;&lt;span&gt; blocks_x:
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not (yy == y and xx ==&lt;span&gt; x):
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; map[yy][xx] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;
                                        win32api.SetCursorPos([left&lt;/span&gt;+xx*block_width, top+yy*&lt;span&gt;block_height])&lt;/span&gt;&lt;span&gt;
                                        win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                                        win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                                        showmap()

#点击白块
def dig():
    showmap()
    iscluck &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(blocks_y):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(blocks_x):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &amp;lt;= map[y][x] and map[y][x] &amp;lt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;:
                boom_number &lt;/span&gt;=&lt;span&gt; map[y][x]&lt;/span&gt;&lt;span&gt;
                block_white &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
                block_qi &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; yy &lt;span&gt;in&lt;/span&gt; range(y - &lt;span&gt;1&lt;/span&gt;, y + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; xx &lt;span&gt;in&lt;/span&gt; range(x - &lt;span&gt;1&lt;/span&gt;, x + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;lt;= yy and &lt;span&gt;0&lt;/span&gt; &amp;lt;= xx and yy &amp;lt; blocks_y and xx &amp;lt;&lt;span&gt; blocks_x:
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not (yy == y and xx ==&lt;span&gt; x):
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; map[yy][xx] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
                                    block_white &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                                elif map[yy][xx] &lt;/span&gt;== -&lt;span&gt;4&lt;/span&gt;&lt;span&gt;:
                                    block_qi &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; boom_number == block_qi and block_white &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; yy &lt;span&gt;in&lt;/span&gt; range(y - &lt;span&gt;1&lt;/span&gt;, y + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; xx &lt;span&gt;in&lt;/span&gt; range(x - &lt;span&gt;1&lt;/span&gt;, x + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;):
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &amp;lt;= yy and &lt;span&gt;0&lt;/span&gt; &amp;lt;= xx and yy &amp;lt; blocks_y and xx &amp;lt;&lt;span&gt; blocks_x:
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; not(yy == y and xx ==&lt;span&gt; x):
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; map[yy][xx] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;
                                        win32api.SetCursorPos([left &lt;/span&gt;+ xx * block_width, top + yy *&lt;span&gt; block_height])&lt;/span&gt;&lt;span&gt;
                                        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                                        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                                        iscluck &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; iscluck == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
        luck()

#随机点击
def luck():
    fl &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(fl):
        random_x &lt;/span&gt;= random.randint(&lt;span&gt;0&lt;/span&gt;, blocks_x - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        random_y &lt;/span&gt;= random.randint(&lt;span&gt;0&lt;/span&gt;, blocks_y - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(map[random_y][random_x] == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;span&gt;
            win32api.SetCursorPos([left &lt;/span&gt;+ random_x * block_width, top + random_y *&lt;span&gt; block_height])
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            fl &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
def gogo():&lt;br/&gt;win32api.SetCursorPos([left, top])&lt;br/&gt;win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)&lt;br/&gt;win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)&lt;br/&gt;showmap()&lt;br/&gt;global gameover&lt;br/&gt;while(1):&lt;br/&gt;if(gameover == 0):&lt;br/&gt;banner()&lt;br/&gt;banner()&lt;br/&gt;dig()&lt;br/&gt;else:&lt;br/&gt;gameover = 0&lt;br/&gt;win32api.keybd_event(113, 0, 0, 0)&lt;br/&gt;win32api.SetCursorPos([left, top])&lt;br/&gt;win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)&lt;br/&gt;win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)&lt;br/&gt;showmap()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;这个算法在初级和中级通过率都不错，但是在高级成功率惨不忍睹，主要是没有考虑逻辑组合以及白块是雷的概率问题，可以对这两个点进行改进，提高成功率&lt;/h3&gt;
</description>
<pubDate>Thu, 12 Jul 2018 14:27:00 +0000</pubDate>
<dc:creator>chestnut_egg</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chestnut-egg/p/9302238.html</dc:identifier>
</item>
<item>
<title>极限编程核心价值：简单（Simplicity） - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/9302227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/9302227.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在编写 ASP.NET Core 项目时，深感项目设计的无力感，在软件设计方面我还有很长的路要走。我一直以来都把代码当作一种艺术的存在，认为自己是个“艺术家”，其实就是个“三脚猫”。软件开发方式不精，设计模式半生不熟，自以为懂得很多，其实狗屁不是，实在不好意思说我学过软件工程，因此我打算静下心来从头开始学习。微软的 ASP.NET Core 文档给了一些很好的参考资料，我打算把他们都整理翻译出来，就先从软件开发方式开始，开发方式算是软件诞生的储备知识吧。而在敏捷开发中，极限编程算是小团队开发方式中比较有名的。&lt;/p&gt;
&lt;p&gt;在翻译中带着学习开发方法和专业词汇的目的，使得整个过程并不枯燥，反倒有些许乐趣。翻译中最困难的其实不是词汇障碍，因为这种国外的入门文章也都是给国外菜鸟看的，反倒是如何把文章翻译的不生硬倒让我很头疼，毕竟不是专业的，有些就是英语一看就是那个意思，翻译成汉语就很别扭。还有部分文章给了名人名言，这才是最难的，读起来像石头一样硬的名句，不用想了，我翻译的，那种非常优美的，也别想了，能百度到的。如果你有什么建议的话，请留言告诉我。&lt;/p&gt;
&lt;p&gt;极限编程系列翻译的部分不会按顺序发布，等全部翻译完了弄个目录就行了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;原文：&lt;a href=&quot;https://deviq.com/simplicity&quot; class=&quot;uri&quot;&gt;https://deviq.com/simplicity&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zhangyue.xin/Articles/Content/47&quot;&gt;极限编程核心价值：简单（Simplicity）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhangyue.xin/Articles/Content/48&quot;&gt;极限编程核心价值：沟通（Communication）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhangyue.xin/Articles/Content/49&quot;&gt;极限编程核心价值：反馈（Feedback）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhangyue.xin/Articles/Content/53&quot;&gt;极限编程核心价值：尊重（Respect）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhangyue.xin/Articles/Content/54&quot;&gt;极限编程核心价值：勇气（Courage）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;简单simplicity&quot;&gt;简单（Simplicity）&lt;/h2&gt;
&lt;p&gt;简单（Simplicity）是极限编程（Extreme Programming，XP）的核心价值之一。它为许多极限编程，敏捷（Agile）开发的原则和实践提供了指导和基础。&lt;/p&gt;
&lt;blockquote readability=&quot;13.490066225166&quot;&gt;
&lt;p&gt;我们会做需要和要求的事情，但不会更多。这将最大化迄今为止所做的投资创造的价值。我们将采取简单的步骤来实现我们的目标，并减轻失败的发生。我们将创造我们引以为傲的东西，并长期保持合理的成本。&lt;/p&gt;
&lt;p&gt;We will do what is needed and asked for, but no more. This will maximize the value created for the investment made to date. We will take small simple steps to our goal and mitigate failures as they happen. We will create something we are proud of and maintain it long term for reasonable costs.&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;来自 &lt;a href=&quot;http://www.extremeprogramming.org/values.html&quot;&gt;ExtremeProgramming.org&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一个精益原则（Lean Principles）是消除浪费（Eliminate Waste）。在软件开发中，浪费的一个来源是不必要的代码或功能。通过在软件中保持简单（Simplicity），我们减少了我们需要去设计、编码、测试和维护中的非核心代码和功能的数量。我们应该努力确保我们的代码遵循简单的设计原则，以便将来易于更新。&lt;/p&gt;
&lt;h2 id=&quot;语录&quot;&gt;语录&lt;/h2&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;“简单是复杂的最高境界。” —— 达·芬奇&lt;/p&gt;
&lt;p&gt;“Simplicity is the ultimate sophistication.” – Leonardo da Vinci&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;“任何事情都应该尽可能做到简单，但不要过于简单。” —— 阿尔伯特·爱因斯坦&lt;/p&gt;
&lt;p&gt;“Everything should be made as simple as possible, but not simpler.” – Albert Einstein&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;“无论是性格、方式还是作风，事实上对于所有事物而言，简单是最为可贵的。” —— 亨利·沃兹沃斯·朗费罗&lt;/p&gt;
&lt;p&gt;“In character, in manner, in style, in all things, the supreme excellence is simplicity.” – Henry Wadsworth Longfellow&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;“这一直是我的一个座右铭 —— 集中和简单。简单，可以比实现复杂的东西更难。你必须花很多力气去让你的思维变得简单、有条理。但最终它的价值非常大，因为一旦你到达了那一步，你就可以撼动山脉了。” —— 史蒂夫·乔布斯&lt;/p&gt;
&lt;p&gt;“That’s been one of my mantras — focus and simplicity. Simple can be harder than complex: You have to work hard to get your thinking clean to make it simple. But it’s worth it in the end because once you get there, you can move mountains.” – Steve Jobs&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;“完美境地，非冗杂，而不遗。” —— 安东尼·德·圣-埃克苏佩里&lt;/p&gt;
&lt;p&gt;“Perfection (in design) is achieved not when there is nothing more to add, but rather when there is nothing more to take away.” – Antoine de Saint-Exupéry&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;“傻瓜忽视复杂性；实用主义者忍受它；专家回避它；天才去除它。” —— 艾伦·佩利&lt;/p&gt;
&lt;p&gt;“Fools ignore complexity; pragmatists suffer it; experts avoid it; geniuses remove it.” – Alan Perlis&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;“简单并不先于复杂性，而是跟随它。” —— 艾伦·佩利&lt;/p&gt;
&lt;p&gt;“Simplicity does not precede complexity, but follows it.” – Alan Perlis&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 12 Jul 2018 14:26:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggaoxing/p/9302227.html</dc:identifier>
</item>
<item>
<title>分块——优雅的暴力 - 苏卿念</title>
<link>http://www.cnblogs.com/cn-suqingnian/p/9302143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cn-suqingnian/p/9302143.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;　　首先，我们来考虑这样一个模型：有一段连续的序列a[1]~a[n]，然后现在我们需要执行几类操作：&lt;/p&gt;
&lt;p&gt;出题人：&lt;strong&gt;  求出其中一段区间的和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;智商180的某宝宝：哎呀，你怎么这么傻，直接记录这个序列的前缀和不就得了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712210727336-1355857736.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　记录a[1]~a[i]的和为sum[i]，然后显然有sum[i+1]=sum[i]+a[i+1]，我们要求a[l]~a[r]就直接sum[r]-sum[l-1]呗。&lt;/p&gt;
&lt;p&gt;出题人：&lt;strong&gt;区间加上某个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于某宝宝是大佬，两分钟后：我会一种叫线段树的东西(一种树形结构，可以维护区间求和和单点修改的优秀数据结构)！！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712211200759-547039340.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出题人：&lt;strong&gt;查询一段区间上有多少个数&amp;lt;k (k&amp;gt;0且给定)    &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某宝宝：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712211442715-48119911.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出题人：&lt;strong&gt;对了，忘了告诉你了，k每次都不一样，还有，极其的多。另外，为了防止装*不让写平衡树(另一种能干很多事情的优秀数据结构)+线段树，占用空间不能超过****Mb&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某宝宝:&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712211800464-663167172.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面就分享一个菜鸟也能懂得算法：分块&lt;/p&gt;
&lt;p&gt;分块，顾名思义，就是把一段序列分成一小块一小块得来处理，维护。&lt;/p&gt;
&lt;p&gt;我们把一段当成一个整体，只记录维护整体的有关信息，就是分块。&lt;/p&gt;
&lt;p&gt;首先，对于前言说得那道题，很朴素的做法就是：&lt;/p&gt;
&lt;p&gt;　　1.从询问区间的l到r扫过去，每回加上扫到的值，即$ans=\sum^{r}_{i=l} a[i]$ &lt;/p&gt;
&lt;p&gt;　　2.直接把$a[i]$重新赋值不就得了 a[i]=newa[i];&lt;/p&gt;
&lt;p&gt;　　3.从询问区间的l到r扫过去,每回遇到&amp;lt;k的位置，答案+1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712212552708-239308784.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，这种做法很傻是不是？&lt;/p&gt;
&lt;p&gt;但是，分块就是在这个基础上暴力优化的！！！&lt;/p&gt;
&lt;p&gt;假设我们总共的序列长度为n，然后我们把它切成$\sqrt{n}$块，然后把每一块里的东西当成一个整体来看，&lt;/p&gt;
&lt;p&gt;现在解释几个本文用到的术语：&lt;/p&gt;
&lt;p&gt;完整块：被操作区间完全覆盖的块&lt;/p&gt;
&lt;p&gt;不完整块：操作区间不完全覆盖的块&lt;/p&gt;
&lt;p&gt;然后我们先看看怎么得出答案：&lt;/p&gt;
&lt;p&gt;　　1.对于完整的块，我们希望有个东西能直接找出这整个块的和，于是&lt;strong&gt;每个块要维护这个块的所有元素的和。   &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　  .对于不完整块，因为元素比较少(最多有  总数n /  块数 = $\sqrt{n}$ 个) 这时候当n=1000000的时候最多有1000个，对比一下，我们可以直接暴力扫这个小块统计答案，&lt;/p&gt;
&lt;p&gt;　　  .小技巧：如果这个不完整块被覆盖的长度&amp;gt;块维护的长度的一半，何不用这个块的和-没有被覆盖的元素的值呢？&lt;/p&gt;
&lt;p&gt;　　2.这里，我们换种思路，&lt;strong&gt;记录一个lazy   &lt;/strong&gt;标记(为什么用lazy，因为我很懒),表示整个块被加上过多少了，&lt;/p&gt;
&lt;p&gt;　　  .对于完整块，我们直接lazy+=加上的数x,块内的和ans+=x*元素个数(因为每个元素都被加上了x)&lt;/p&gt;
&lt;p&gt;　　  .对于不完整块，直接暴力修改就好了，顺便可以把lazy标记清了。&lt;/p&gt;
&lt;p&gt;　　3.哎呀，这个有点难度啊,&lt;/p&gt;
&lt;p&gt;　　  .要在每个完整块内寻找小于一个值的元素数，&lt;/p&gt;
&lt;p&gt;　　   显然我们不得不要求块内元素是&lt;strong&gt;有序的&lt;/strong&gt;，这样就能用二分(快速在一个有序的序列里查询的一个算法),对块内查询。&lt;/p&gt;
&lt;p&gt;　　  .不完整的块暴力就好&lt;/p&gt;
&lt;p&gt;　　  .这样的话需要提前对每块里面的元素做一遍排序就好.&lt;/p&gt;
&lt;p&gt;　　  .但是当有修改的话，因为整个块同时加上(减去)一个数，每个数的相对大小是不会变的，但是如果是不完全块就会改变，这样的话，还是因为元素个数小，重新新排一下不就得了?&lt;/p&gt;

&lt;p&gt;然后，这道题就用了一种看似高大上的方法做完了……比之前傻傻的暴力是不是好看很多呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712215020021-1721166349.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在很多地方，我们可以运用到分块的思想，化零为整，把维护每个数的值变成维护一些整体的值，&lt;/p&gt;
&lt;p&gt;一个很常见的例子就是：为什么班主任要给班里分组？因为他可不想收作业或者回执的时候一个一个收啊qwq交给组长然后组长在交给老师多好啊qwq&lt;/p&gt;
&lt;p&gt;这样，我们就不用一个一个的找了qwq&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1397637/201807/1397637-20180712215520522-1686359934.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就讲完基础了。&lt;/p&gt;
&lt;p&gt;稍稍进阶：&lt;/p&gt;
&lt;p&gt;其实，每一块可以维护的不止上面说的那几种东西，我们可以维护当前区间最大公约数是多少，最大异或和是多少……&lt;/p&gt;
&lt;p&gt;客观的来说，分块是可以维护很多的，只要想出来怎么预处理，对于有修改的模型怎么维护，统计答案的时候怎么累加就行。&lt;/p&gt;
&lt;p&gt;希望对大家有所帮助。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 14:04:00 +0000</pubDate>
<dc:creator>苏卿念</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cn-suqingnian/p/9302143.html</dc:identifier>
</item>
<item>
<title>Javascript的事件模型和Promise实现 - 远方无风</title>
<link>http://www.cnblogs.com/bill-shooting/p/9301817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bill-shooting/p/9301817.html</guid>
<description>&lt;p data-anchor-id=&quot;1hru&quot;&gt;&lt;span&gt;&lt;strong&gt;1. Javascript的运行时模型——事件循环 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;JS的运行时是个单线程的运行时，它不像其他编程语言，比如C++，Java，C#这些可以进行多线程操作的语言。当它执行一个函数时，它只会一条路走到黑，不会在当前函数结束之前去调用其他的函数（除非当前函数主动调用其他函数）。它也不用担心会有其他线程打扰它，因为它的运行时只有一个线程。如果你还记得一些计算机原理的话，这种运行时只有一个栈，设计起来相当的简单。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;5yjk&quot;&gt;&lt;span&gt;一条路走到黑的设计很棒，因为它足够简单，但是又是谁决定哪个函数从开始进入栈内执行呢？答案是JS的运行时还有一个事件等待队列与栈搭配，每当运行栈为空时（也就是当前函数运行结束），JS的运行时就从当前的事件队列中取出一个消息处理，执行与这个消息相关联的函数。这种行为可以用以下代码来说明：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (eventQueue.waitForMessage()) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     let event =&lt;span&gt; eventQueue.pop();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     let handler =&lt;span&gt; event.handler;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     handler();                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行事件关联的函数&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     context.scheduler.schedule();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;让调度器处理一下其他事务&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了运行栈和事件队列之后，我们的Javascript运行时已经初具雏形。不过Javascript中的变量都是对象，它们的大小通常很大，可不是一个小小的栈能放下的，如果我们熟悉C++，就会知道一般在C++中我们只在栈中存储基本类型（int, bool等）和指针，而指针所指的位置是内存堆中的一个地址，这也是JS的对象的存储地点。下面这张图可以形象地解释一下JS运行时的模型。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;JS内存模型&quot; src=&quot;https://developer.mozilla.org/files/4617/default.svg&quot; alt=&quot;&quot; width=&quot;294&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;

&lt;p data-anchor-id=&quot;q0e1&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 事件循环模型的优点和缺点 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;先说优点&lt;/strong&gt;。除了实现上的简单，Javascript的最大优点就是&lt;strong&gt;完全异步，永不阻塞&lt;/strong&gt;。这句话可能有点令人迷糊，一个单线程的运行时怎么完全异步，永不阻塞？实际上虽然&lt;strong&gt;JS运行时单线程，但是浏览器是个多进程多线程的环境&lt;/strong&gt;，这一个点在后端也一样，虽然Node是个单线程JS运行时，但是后端还有其他进程和线程配合Node一起完成响应操作。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;tvvr&quot;&gt;&lt;span&gt;以浏览器打开IndexedDB为例，当你执行&lt;span&gt;&lt;code&gt;indexedDB.open()&lt;/code&gt;&lt;/span&gt;的之后，当前的Javascript运行栈就结束了，JS可以处理其他事件的关联函数，所以JS不会阻塞。那原来的open操作交给谁了呢？浏览器会调用其他线程接管这个打开数据库的过程，当返回时，浏览器会在JS运行时的事件队列中添加一个&lt;span&gt;&lt;code&gt;打开成功&lt;/code&gt;&lt;/span&gt;或者&lt;span&gt;&lt;code&gt;打开失败&lt;/code&gt;&lt;/span&gt;的事件，同时将你当时添加的回调函数关联到事件。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;v81o&quot;&gt;&lt;span&gt;&lt;strong&gt;再说缺点&lt;/strong&gt;。我们都知道JS的调用函数只会一条路走到黑，而且没有正常的方法能打断这一过程，如果这一路恰好比较长（比如进行了大量的数学运算），就会使JS进入一种类阻塞的状态，页面会无法响应。等等！刚说JS永不阻塞，这里怎么又冒出一个类阻塞呢？这时因为我们所说的阻塞一般都是指IO阻塞，也就是CPU等IO结束的过程，这种情况在JS中可以永远不会发生（注意这里是可以，不是一定，某些IO操作是有同步的API可以调用的）。所谓类阻塞状态呢，就是在执行CPU密集型任务，这是一种不可避免的过程。那为什么这种情况下页面会没有响应呢？这时因为浏览器虽然会把事件放入事件队列里，但是由于前一个函数还没执行完，页面响应事件关联的函数得不到执行，自然页面会表现出不响应的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;v81o&quot;&gt; &lt;/p&gt;
&lt;p data-anchor-id=&quot;v81o&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3. Promise的实现 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Promise是JS处理回调的一种方式，也是利用JS的事件循环模型的一个编程范式包装，也是ES7中&lt;code&gt;await&lt;/code&gt; &lt;code&gt;async&lt;/code&gt;的基础。&lt;strong&gt;如果说回调是对JS事件模型最直接最拙劣的实现的话，Promise至少给回调加了件衣服，使它不再那么难看。但本质上讲，Promise还是描述JS事件循环模型的一种工具&lt;/strong&gt;。下面给个例子来说明它和JS事件模型的联系。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let getUrlAsync = (url) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     let promise = &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         const xhr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         xhr.open('GET'&lt;span&gt;, url);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         xhr.onload = () =&amp;gt;&lt;span&gt; resolve(xhr.responseText);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         xhr.onerror = () =&amp;gt;&lt;span&gt; reject(xhr.statusText);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; getUrlAsync('http://exaple.com/text/11111'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     .then(res =&amp;gt;&lt;span&gt; console.log(res))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     .&lt;span&gt;catch&lt;/span&gt;(error =&amp;gt; console.log(error));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当调用&lt;span&gt;&lt;code&gt;getUrlAsync&lt;/code&gt;&lt;/span&gt;时，JS运行时做以下事情： &lt;br/&gt;1. 会创建一个&lt;span&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/span&gt;对象，此时还是在&lt;span&gt;&lt;code&gt;getUrlAsync&lt;/code&gt;&lt;/span&gt;的栈帧里； &lt;br/&gt;2. 然后创建一个&lt;span&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/span&gt;对象，此时还是在&lt;span&gt;&lt;code&gt;getUrlAsync&lt;/code&gt;&lt;/span&gt;的栈帧里； &lt;br/&gt;3. 调用&lt;span&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/span&gt;的&lt;span&gt;&lt;code&gt;open&lt;/code&gt;&lt;/span&gt;方法，此时浏览器其他线程接管open过程，JS无需等待open结束； &lt;br/&gt;4. 给&lt;span&gt;&lt;code&gt;xhr&lt;/code&gt;&lt;/span&gt;的&lt;span&gt;&lt;code&gt;onload&lt;/code&gt;&lt;/span&gt;事件关联一个处理函数(委托），注意此时该事件并没有进入事件队列； &lt;br/&gt;5. 给&lt;span&gt;&lt;code&gt;xhr&lt;/code&gt;&lt;/span&gt;的&lt;span&gt;&lt;code&gt;onerror&lt;/code&gt;&lt;/span&gt;事件关联一个处理函数(委托），同样此时该事件没有进入运行时的事件队列； &lt;br/&gt;6. 传入&lt;span&gt;&lt;code&gt;res =&amp;gt; console.log(res)&lt;/code&gt;&lt;/span&gt;来具体化第4步中的委托； &lt;br/&gt;7. 传入&lt;span&gt;&lt;code&gt;error =&amp;gt; console.log(error)&lt;/code&gt;&lt;/span&gt;来具体化第5部中的委托，&lt;strong&gt;此时当前的运行栈就退出了，运行时将处理其他事件&lt;/strong&gt;。 &lt;br/&gt;在某一个时刻，浏览器控制的open方法返回，它&lt;strong&gt;会在JS运行时的事件队列中添加一个事件&lt;/strong&gt;，比如&lt;span&gt;&lt;code&gt;onload&lt;/code&gt;&lt;/span&gt; &lt;br/&gt;8. JS运行时循环到&lt;span&gt;&lt;code&gt;onload&lt;/code&gt;&lt;/span&gt;事件，并找到它的关联处理函数，在这个例子中就是&lt;span&gt;res =&amp;gt; console.log(res)&lt;/span&gt;，并运行这个函数。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;最后吐槽一个博客园，还不支持Markdown吗？默认编辑器真的好难用。。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Jul 2018 12:50:00 +0000</pubDate>
<dc:creator>远方无风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bill-shooting/p/9301817.html</dc:identifier>
</item>
</channel>
</rss>