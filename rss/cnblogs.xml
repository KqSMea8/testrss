<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>weakSelf 和 strongSelf - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/8018883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/8018883.html</guid>
<description>&lt;p&gt;最近在看SDWebImage源码，碰到一些比较绕的问题，理解了很久，然后在网上查了些的资料，才算是有了一些理解。在此记录一下。&lt;/p&gt;
&lt;p&gt;源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/575661/201712/575661-20171210235248786-335503058.png&quot; alt=&quot;&quot; width=&quot;1116&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;

&lt;p&gt;block会copy要在block中使用的实变量，而copy会是变量的retainCount + 1，如若在不注意很容易造成循环引用。而所谓的循环引用的本质就是，两个对象相互引用，从而造成对象不能正常的dealloc。所以解决的办法就是让引用的一方是weak的，这样就使得相互引用的闭环被打破，能够正常的dealloc了。&lt;/p&gt;

&lt;p&gt;1）weakSelf的使用：&lt;/p&gt;
&lt;p&gt;Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。 &lt;/p&gt;
&lt;p&gt;上图的代码中，backgroundTaskId是当前这个类的一个属性，在backgroundTaskId初始化的这个方法中，有一个block回调，在这个block的实现中访问需要访问Self，为了避免造成循环引用，此处给当前的Self取了个别名，并用__weak来修饰，目的是告诉编译器，此处是弱引用，不要retain 当前的这个类，也就是所谓的self。&lt;/p&gt;
&lt;p&gt;2）为什么会出现strongSelf？&lt;/p&gt;
&lt;p&gt;Apple 官方文档有讲到，如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。&lt;/p&gt;
&lt;p&gt;clang给出的实例代码：&lt;/p&gt;

&lt;p&gt;    __weak __typeof__(self) weakSelf = self;&lt;/p&gt;
&lt;p&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{&lt;/p&gt;
&lt;p&gt;        [weakSelf doSomething];&lt;/p&gt;
&lt;p&gt;    });&lt;/p&gt;
&lt;p&gt; clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：&lt;/p&gt;
&lt;p&gt;    __weak __typeof__(self) weakSelf = self;&lt;/p&gt;
&lt;p&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{&lt;/p&gt;
&lt;p&gt;        [weakSelf doSomething];&lt;/p&gt;
&lt;p&gt;        [weakSelf doOtherThing];&lt;/p&gt;
&lt;p&gt;    });&lt;/p&gt;

&lt;p&gt; 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，&lt;/p&gt;
&lt;p&gt; 于是，strongSelf 就派上用场了：&lt;/p&gt;
&lt;p&gt;    __weak __typeof__(self) weakSelf = self;&lt;/p&gt;
&lt;p&gt;    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{&lt;/p&gt;
&lt;p&gt;        __strong __typeof(self) strongSelf = weakSelf;&lt;/p&gt;
&lt;p&gt;        [strongSelf doSomething];&lt;/p&gt;
&lt;p&gt;        [strongSelf doOtherThing];&lt;/p&gt;
&lt;p&gt;    });&lt;/p&gt;
&lt;p&gt;   __strong 确保strongSelf在block中不会被释放。&lt;/p&gt;

&lt;p&gt;所以就能理解SDWebImage中的那段代码，block在实现的过程中会对wself进行一次强引用，是为了防止在block还未执行完毕，wself在其他线程中被释放，使得wself为nil。&lt;/p&gt;

&lt;p&gt; 简单的做个小结：&lt;/p&gt;
&lt;p&gt; 1、在使用block时，如果block内部需要访问self的方法、属性、或者实例变量应当使用weakSelf&lt;/p&gt;
&lt;p&gt; 2、如果在block内需要多次访问self，则需要使用strongSelf&lt;/p&gt;
&lt;p&gt; 3、如果在block内部存在多线程环境访问self，则需要使用strongSelf&lt;/p&gt;
&lt;p&gt; 4、block本身不存在多线程之分，block执行是否是多线程，取决于当前的持有者是否是以多线程的方式来调用它。&lt;/p&gt;


&lt;p&gt;clang的文档链接&lt;/p&gt;
&lt;p&gt;https://github.com/CoderBeta/clang-user-manual&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/bbmb_mb/article/details/50470802&lt;/p&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:54:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/8018883.html</dc:identifier>
</item>
<item>
<title>缓存与ABP Redis Cache - 安于生</title>
<link>http://www.cnblogs.com/anyushengcms/p/8013201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyushengcms/p/8013201.html</guid>
<description>&lt;h2 id=&quot;为什么要用缓存&quot;&gt;为什么要用缓存&lt;/h2&gt;
&lt;p&gt;为什么要用缓存呢，说缓存之前先说使用缓存的优点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;减少寄宿服务器的往返调用（round-trips）。&lt;/li&gt;
&lt;li&gt;如果缓存在客户端或是代理，将减少对服务器的请求，减少带宽。&lt;/li&gt;
&lt;li&gt;减少对数据库服务器的往返调用（round-trips）。&lt;/li&gt;
&lt;li&gt;当内容缓存在web服务器，能够减轻对数据库的请求。&lt;/li&gt;
&lt;li&gt;减少网络带宽。&lt;/li&gt;
&lt;li&gt;避免了重新生成可重用内容的时耗。&lt;/li&gt;
&lt;li&gt;提高性能&lt;/li&gt;
&lt;li&gt;因为缓存减少了round-trips, network traffic（网络带宽），并避免- 了生成可重用内容的时耗，所以对性能有巨大的提高。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;传统的缓存方式&quot;&gt;传统的缓存方式&lt;/h2&gt;
&lt;p&gt;传统的缓存方式如下面这张图&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-94809e618d9bc9f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;之前我们处理方式处理起来也很简单&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面输出缓存，直接在 ASP.NET中页面缓存的使用OutputCache 在aspx页的顶部加这样一句即可：&lt;br/&gt;&lt;code&gt;&amp;lt;%@ OutputCache Duration=&quot;60&quot; VaryByParam=&quot;none&quot; %&amp;gt;&lt;/code&gt;&lt;br/&gt;Duration 表示缓存的时间秒，必选，否则报错。&lt;/li&gt;
&lt;li&gt;第二种方式&lt;br/&gt;&lt;code&gt;if (this.Cache[&quot;Keys&quot;] == null) { this.Cache.Insert(&quot;Keys&quot;, List, null, DateTime.Now.AddHours(2), TimeSpan.Zero); }&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里是检查缓存中Keys是否存在，如果不存在，则写入一个新的值List.还有其他的一些使用方法。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-fc031fecdbf5b173.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面两种方式显然不在现在使用范畴,也不在我想说的范畴之内。，年代貌似有点久远，不用webform基本用不到。现在我们更多是的使用MVC。&lt;br/&gt;我们想说的是MVC输出缓存。&lt;/p&gt;
&lt;h2 id=&quot;mvc缓存&quot;&gt;MVC缓存&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;输出缓存&lt;/strong&gt;：&lt;code&gt;Outputcache&lt;/code&gt; ,分为Action输出缓存和Controller输出缓存。使用的场景包括某个页面的数据更新不是很频繁，不需要每次都从数据库区查询。缓存起来从内存中读取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据缓存&lt;/strong&gt;：是相对于全局的。任何地方需要调用的时候都可以去调用。使用的场景包括权限管理这种模块的。每个角色对于菜单的访问都是固定的，所以有必要将角色，权限，菜单这种数据做一个全局的数据缓存。修改时再做缓存的更新。&lt;/p&gt;
&lt;p&gt;输出缓存和数据缓存区别：打个比方输出缓存就像是“局部变量”，数据缓存就像是全局变量（只是个比喻）。&lt;/p&gt;
&lt;p&gt;Controller输出缓存和 Action缓存使用方式是一样的，就是Controller 或Action上打[OutPutCache]特性标签。但是他们之间又是有区别的。&lt;/p&gt;
&lt;p&gt;一、控制器缓存&lt;/p&gt;
&lt;p&gt;Control缓存的作用域是整个控制器，所以在这个控制器下的所有Action都会被缓存起来。Control缓存的粒度比较粗，应用也比较少些。&lt;br/&gt;&lt;code&gt;[OutputCache(Duration = 10)] public class HomeController : Controller { public ActionResult Index() { ViewBag.CurrentTime = DateTime.Now; return View(); } }&lt;/code&gt;&lt;br/&gt;二、Action缓存&lt;br/&gt;将[OutPutCache]特性标签打在Action上，这样，只有加缓存的Action才会有缓存，其他的Action是没有的。&lt;/p&gt;
&lt;h2 id=&quot;outputcache特性常用的属性参数&quot;&gt;Outputcache特性常用的属性参数&lt;/h2&gt;
&lt;h2 id=&quot;输出缓存cacheprofile使用配置文件设置缓存&quot;&gt;输出缓存CacheProfile使用配置文件设置缓存&lt;/h2&gt;
&lt;p&gt;举例其中的CacheProfile，这种方式便于统一配置，当然也可以设置参数duration、location 、varybyparam等。我们需要在system.web 节点下加入这些&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!---CacheProfile配置文件中设置缓存--&amp;gt; &amp;lt;caching&amp;gt; &amp;lt;outputCacheSettings&amp;gt; &amp;lt;outputCacheProfiles&amp;gt; &amp;lt;add name=&quot;TestConfigCache&quot; duration=&quot;20&quot; location=&quot;Any&quot; enabled=&quot;true&quot;/&amp;gt; &amp;lt;/outputCacheProfiles&amp;gt; &amp;lt;/outputCacheSettings&amp;gt; &amp;lt;/caching&amp;gt; &amp;lt;!---CacheProfile配置文件中设置缓存end--&amp;gt;&lt;/code&gt;&lt;br/&gt;其实作用和效果还是一样，无非就是方便点，统一的配置参数都直接写webconfig文件里面。其实也可以Controller中写。&lt;br/&gt;配置好了之后我们直接在控制器调用相应的名字的&lt;code&gt;OutputCache&lt;/code&gt;特性标签即可。&lt;br/&gt;&lt;code&gt;[OutputCache(CacheProfile= &quot;TestConfigCache&quot;)] public ActionResult Index() { ViewBag.CurrentTime = DateTime.Now; return View(); }&lt;/code&gt;&lt;br/&gt;更多的方式，需要下去再研究下。&lt;/p&gt;
&lt;h2 id=&quot;abp中使用icachemanager进行缓存管理&quot;&gt;ABP中使用ICacheManager进行缓存管理&lt;/h2&gt;
&lt;p&gt;ABP中有两种cache的实现方式：&lt;code&gt;MemroyCache&lt;/code&gt; 和&lt;code&gt;RedisCache&lt;/code&gt;，两者都继承至ICache接口（准确说是&lt;code&gt;CacheBase&lt;/code&gt;抽象类）。ABP核心模块封装了&lt;code&gt;MemroyCache&lt;/code&gt;来实现ABP中的默认缓存功能。 &lt;code&gt;Abp.RedisCache&lt;/code&gt;这个模块封装&lt;code&gt;RedisCache&lt;/code&gt;来实现缓存（通过&lt;code&gt;StackExchange.Redis&lt;/code&gt;这个类库访问redis）。&lt;/p&gt;
&lt;p&gt;ABP给出了一个抽象缓存基类。并在内部使用了该抽象基类。使用 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.caching.memorycache(v=vs.110).aspx?f=255&amp;amp;MSPPError=-2147217396&quot;&gt;MemoryCache&lt;/a&gt; 来实现了该抽象基类。它能够被任何其它的缓存类来扩展。&lt;a href=&quot;https://www.nuget.org/packages/Abp.RedisCache&quot;&gt;Abp.RedisCache&lt;/a&gt; 包就扩展了该缓存基类。&lt;br/&gt;ABP对外提供了一个缓存接口ICacheMananger。我们通过构造函数注入这个接口来获取缓存。示例如下：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-9d998b535cf0c7c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，我们注入了 ICacheManager接口，s并且获取了一个名称为ControllerCache的缓存。首先我们先对ControllerCache进行清除，然后存入缓存，缓存的名字是大小写敏感的，那就是&quot;ControllerCache&quot;和&quot;CONTROLLERCACHE&quot;取得的缓存内容是不同的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：GetCache方法 千万不要在你的构造函数中使用GetCache方法。如果类不是一个单例对象那么该缓存可能会被dispose掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;icache&quot;&gt;ICache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ICacheManager.GetCache&lt;/code&gt;方法返回了一个&lt;code&gt;ICache&lt;/code&gt;对象。每一个缓存都是基于名称单例存在的。只有首次访问时才会被创建，以后你每次用相同的名称去获取的缓存都是相同的。所以我们可以在不同的类中使用相同的名称来共享相同的缓存。&lt;/p&gt;
&lt;p&gt;在示例代码中，我们简单的使用了&lt;code&gt;ICache.Get&lt;/code&gt;方法，它有两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;key : 要获取的缓存项的唯一标识符&lt;/li&gt;
&lt;li&gt;factory：如果根据给定的key获取到的缓存项为空，那么factory将会创建一个标识符为key的缓存，并且返回该缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ICache接口还有其它方法，如前面&lt;code&gt;Clear()&lt;/code&gt;,&lt;code&gt;Get()&lt;/code&gt;,&lt;code&gt;GetOrDefault&lt;/code&gt;，&lt;code&gt;Set&lt;/code&gt;，&lt;code&gt;Remove&lt;/code&gt;和&lt;code&gt;Clear&lt;/code&gt;。当然也有这些方法的异步(async)版本。如下图，我就懒得写了。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-1c3f6f1a4ad73ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;itypedcache&quot;&gt;ITypedCache&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ICache&lt;/code&gt; 接口用key(字符串类型)来获取缓存value(object类型)。&lt;code&gt;ITypedCache&lt;/code&gt; 为&lt;code&gt;ICahe&lt;/code&gt;提供了一个 类型安全 的包装；为了使类型安全转换(&lt;code&gt;ICache&lt;/code&gt;到&lt;code&gt;ITypedCache&lt;/code&gt;)，我们可以用扩展方法 &lt;code&gt;AsTyped&lt;/code&gt;，而不需要写其它强制类型转换的代码，如下所示：&lt;br/&gt;&lt;code&gt;ITypedCache&amp;lt;int, Item&amp;gt; myCache = _cacheManager.GetCache(&quot;MyCache&quot;).AsTyped&amp;lt;int, Item&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;configuration&quot;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;缓存的过期时间默认是60分钟。它是变化的。如果你在60分钟内没有使用该缓存，该缓存会被自动的移除。如果你想改变所有的缓存或者指定的缓存来的默认过期时间，你可以这样做，实现如下：&lt;br/&gt;&lt;code&gt;//对所有缓存的配置 Configuration.Caching.ConfigureAll(cache =&amp;gt; { cache.DefaultSlidingExpireTime = TimeSpan.FromHours(2); });&lt;/code&gt;&lt;br/&gt;&lt;code&gt;//对指定缓存的配置 Configuration.Caching.Configure(&quot;MyCache&quot;, cache =&amp;gt; { cache.DefaultSlidingExpireTime = TimeSpan.FromHours(8); });&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这段代码你应该放在模块(module)的 &lt;code&gt;PreInitialize&lt;/code&gt; 方法中。如上所示：&lt;code&gt;MyCache&lt;/code&gt;将会在8小时后过期，而其他的缓存将在2小时后过期。&lt;/p&gt;
&lt;p&gt;这些配置将会在首次创建缓存的时候生效。配置不仅仅局限于&lt;code&gt;DefaultSlidingExpireTime&lt;/code&gt;，你可以利用&lt;code&gt;ICache&lt;/code&gt;接口中的属性获取方法来自由的配置并且初始化它们。&lt;/p&gt;
&lt;h2 id=&quot;entity-caching&quot;&gt;Entity Caching&lt;/h2&gt;
&lt;p&gt;ABP的缓存系统是以通用为目的，它有一个 &lt;code&gt;EntityCache&lt;/code&gt; 基类，如果你需要的话，这个基类可以帮助你缓存实体。使用这个基类，我们可以通过ID取得实体，并且我们通过ID来缓存实体，这样以后就不需要频繁的查询数据库去取得实体。假设我们有个&lt;code&gt;Person&lt;/code&gt;实体，像下面一样：&lt;br/&gt;&lt;code&gt;public class Person : Entity { public string Name { get; set; } public int Age { get; set; } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且，假设我们通过该实体的Id，需要频繁调用取得Person实体的Name。首先，我们应该创建一个类来存储 cache items：&lt;br/&gt;&lt;code&gt;[AutoMapFrom(typeof(Person))] public class PersonCacheItem { public string Name { get; set; } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们 不应该直接存储实体到缓存中 因为缓存的时候需要序列化缓存对象而实体可能不能被序列化(尤其是实体的导航属性)。这就是为什么我们定义了一个简单的像DTO的类来存储数据到缓存中。我们添加了 AutoMapFrom 特性，这是因为我们想使用 AutoMapper 来自动的转换 Person 实体为 PersonCacheItem 对象。如果我们不使用 AutoMapper，那么我们应该重写 EntityCache 类的 MapToCacheItem 方法手动转换/映射它。&lt;/p&gt;
&lt;p&gt;然而这不是必须的，我们可能想定义一个接口为缓存类：&lt;br/&gt;&lt;code&gt;public interface IPersonCache : IEntityCache&amp;lt;PersonCacheItem&amp;gt; { }&lt;/code&gt;&lt;br/&gt;最后，我们可以创建缓存类来缓存Person实体：&lt;br/&gt;&lt;code&gt;public class PersonCache : EntityCache&amp;lt;Person, PersonCacheItem&amp;gt;, IPersonCache, ITransientDependency { public PersonCache(ICacheManager cacheManager, IRepository&amp;lt;Person&amp;gt; repository) : base(cacheManager, repository) { } }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就OK了，我们的person缓存已经准备好可以使用了。缓存类可以使瞬时(如同这个例子)或者是单例。这不是说缓存数据是瞬态的。在你的应用程序中它一直是全局缓存并且是线程安全的。&lt;/p&gt;
&lt;p&gt;现在，无论在什么地方我们需要取得Person的Name，我们可以通过Person的Id从缓存中取得它。如下所示：&lt;br/&gt;&lt;code&gt;public class MyPersonService : ITransientDependency { private readonly IPersonCache _personCache; public MyPersonService(IPersonCache personCache) { _personCache = personCache; } public string GetPersonNameById(int id) { return _personCache[id].Name; //alternative: _personCache.Get(id).Name; } }&lt;/code&gt;&lt;br/&gt;我们很容易的&lt;a href=&quot;https://github.com/Jimmey-Jiang/AbpDocument2Chinese/blob/master/Markdown/Abp/2.1ABP%E5%85%AC%E5%85%B1%E7%BB%93%E6%9E%84-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.md&quot;&gt;注入&lt;/a&gt; &lt;strong&gt;IPersonCache&lt;/strong&gt; 接口，通过该接口取得缓存项和Name属性。&lt;/p&gt;
&lt;p&gt;那么EntityCache是怎么工作的？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在首次调用的时候我们通过仓储从数据库中取得实体。那么随后的调用都是从缓存中取得。&lt;/li&gt;
&lt;li&gt;如果实体被更新或者删除，它会自动的无效实体。因此，它会在下次调用的时候重新从数据库中检索数据。&lt;/li&gt;
&lt;li&gt;使用 IObjectMapper 接口来映射实体到缓存项。IObjectMapper 接口在 AutoMapper 中被实现。所以，如果你使用了自动映射，那么就需要 AutoMapper模块。你可以重写 MapToCacheItem 方法手动映射它到缓存项。&lt;/li&gt;
&lt;li&gt;使用缓存类的FullName作为缓存的Name，你可以通过传入的缓存名到基类的构造函数来改变它。&lt;/li&gt;
&lt;li&gt;它是线程安全的。&lt;br/&gt;如果你有更复杂的缓存需求，那么你需要扩展 EntityCache 类或者创建你自己的解决方案。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;redis-cache-集成&quot;&gt;Redis Cache 集成&lt;/h2&gt;
&lt;p&gt;Redis是什么，Redis是一个开源的使用ANSI &lt;a href=&quot;https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80&quot;&gt;C语言&lt;/a&gt;编写、支持网络、可基于内存亦可持久化的日志型、Key-Value&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93&quot;&gt;数据库&lt;/a&gt;，并提供多种语言的API。它可以用作数据库、缓存和消息中间件。它支持多种类型的数据结构，如字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）与范围查询、bitmaps、hyperloglogs和地理空间（geospatial）索引半径查询。&lt;br/&gt;Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。&lt;br/&gt;Redis 与其他 key - value 缓存产品有以下三个&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;br/&gt;&lt;strong&gt;Redis 优势&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。&lt;/li&gt;
&lt;li&gt;丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。&lt;/li&gt;
&lt;li&gt;原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。&lt;/li&gt;
&lt;li&gt;丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。&lt;/li&gt;
&lt;li&gt;多实用工具 - Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）&lt;strong&gt;首先，我们前往&lt;a href=&quot;https://github.com/dmajkic/redis/downloads&quot; class=&quot;uri&quot;&gt;https://github.com/dmajkic/redis/downloads&lt;/a&gt;下载安装包&lt;/strong&gt;，直接下一步下一步就可以了。&lt;br/&gt;然后打开安装的地址就可以看到如下的文件：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-bb672bfdc3a1dbbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;（2）&lt;strong&gt;然后启动Redis服务&lt;/strong&gt;，我们cmd到安装目录下，然后输入命令&lt;code&gt;redis-server.exe redis.windows.conf&lt;/code&gt;&lt;br/&gt;就会看到下面的画面证明我们启动服务成功。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-c08fa2adb3d9a6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;abp默认Cache Mananger是使用&lt;strong&gt;in-memory&lt;/strong&gt;来缓存。所以，这可能会成为一个问题，如果有多个并发的Web服务运行在同一个应用中。在这种情况下，你可能想要一个分布式/中央缓存服务器。那么，你可以使用Redis来作为你的缓存服务。&lt;br/&gt;首先，你需要安装&lt;br/&gt;&lt;a href=&quot;https://www.nuget.org/packages/Abp.RedisCache&quot;&gt;Abp.RedisCache&lt;/a&gt;nuget package 到你的项目中(你可以安装它到你的Web项目)。这里我遇到一个错误。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-9d128c0f1e80f119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;开始的时候我搞了半天不知道为什么会出现这个莫名其妙的错误，后来才发现，原来我引入Abp.RedisCache版本和abp版本不一致。才导致的这个错误，比如你abp是3.1.1，那么你的Abp.RedisCache最好也是对应的版本，最好的话把abp和Abp.RedisCache都升级到最新版本，就不会有错误了。&lt;br/&gt;然后我们看看Abp.Runtime.Caching.Redis;依赖项以及之间的关系。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-02c5a475aaffef48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;然后在ABPCMSWebModule配置一下。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-0eb9dbaab4daadbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;ABPCMSApplicationModule中引入。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f1dee7e6b8449297.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;Web.config中配置&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f832c254c21d0490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;你也可以添加配置到appSettings来设置Redis数据库的Id。如：&lt;br/&gt;&lt;code&gt;&amp;lt;add key=&quot;Abp.Redis.Cache.DatabaseId&quot; value=&quot;2&quot;/&amp;gt;&lt;/code&gt;&lt;br/&gt;在同一个服务器上使用不同的数据库Id是非常有用的这可以创建不同的Key Spaces(隔离缓存)。&lt;br/&gt;&lt;strong&gt;UseRedis&lt;/strong&gt;有一个重载方法，你可以通过这个方法来传入配置参数，这可以覆盖掉配置文件中的配置。关于Redis的其他配置可以查看&lt;a href=&quot;http://redis.io/documentation&quot;&gt;Redis文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在下面UserList打下断点调试进去。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-0456a4de85eb5d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;看到效果如下图，证明我们AbpRedisCache引入成功。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-820a6a011df84d9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;当然为了更好的进行可视化操作，我建议使用跨平台开源Redis DB管理工具（Redis Desktop Manager）地址：&lt;a href=&quot;https://redisdesktop.com/download&quot; class=&quot;uri&quot;&gt;https://redisdesktop.com/download&lt;/a&gt;&lt;br/&gt;下载下来直接下一步下一步安装即可。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-2bf0952b0458d913.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;然后运行项目，然后我们在看下Redis Desktop Manager工具，效果如下图：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-7ec00b2177bb8bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;使用可视化工具很方便&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建连接，输入redis主机host，端口号port，再起个生动形象，简明达意的别名。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;该工具支持根据筛选条件查询key，add new key，reload等。&lt;/li&gt;
&lt;li&gt;支持常用redis操作，针对目标key执行rename，delete，addrow，reload value操作。&lt;/li&gt;
&lt;li&gt;命令控制台操作 ！大家感兴趣可以自己玩一下。&lt;br/&gt;另外关于实体修改后自动更新缓存的实现远离可以参考&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/loyldg/p/using-redis-in-abp-2.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/loyldg/p/using-redis-in-abp-2.html&lt;/a&gt;&lt;br/&gt;这个文章。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sun, 10 Dec 2017 15:54:00 +0000</pubDate>
<dc:creator>安于生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyushengcms/p/8013201.html</dc:identifier>
</item>
<item>
<title>QT之TCP通信 - 菜头大大</title>
<link>http://www.cnblogs.com/wurenzhong/p/8018862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wurenzhong/p/8018862.html</guid>
<description>&lt;p&gt;&lt;span&gt;QT中可以通过TCP协议让服务器和客户端之间行通信。所以下面我就围绕服务器和客户端来写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是我么写服务器和客户端的具体流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A、服务器：&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;1.创建QTcpServer对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         2.启动服务器（监听）调用成员方法listen（QHostAddress::Any,端口号）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         3.当有客户端链接时候会发送newConnection信号，触发槽函数接受链接（得到一个与客户端通信的套接字QTcpSocket）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         4.QTcpsocket发送数据用成员方法write，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         5.读数据当客户端有数据来，QTcpSocket对象就会发送readyRead信号，关联槽函数读取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;B、客户端&lt;/span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;1.创建QTcpSocket对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        2.链接服务器connectToHost(QHostAddress(&quot;ip&quot;),端口号)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        3.QTcpsocket发送数据用成员方法write，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        4.读数据当对方有数据来，QTcpSocket对象就会发送readyRead信号，关联槽函数读取数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;我们需要调用到的头文件有两个&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#include &amp;lt;QTcpServer&amp;gt;  &lt;span&gt;
#include &lt;/span&gt;&amp;lt;QTcpSocket&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们先要在工程文件中加入network&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
QT       += core gui network
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面我们来看看服务器程序步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、初始化服务器server对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mServer = &lt;span&gt;new&lt;/span&gt; QTcpServer();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、启动监听服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  mServer-&amp;gt;listen(QHostAddress::Any,&lt;span&gt;9988&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9988为端口号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、当有客户端链接时候会发送newConnection信号，触发槽函数接受链接（得到一个与客户端通信的套接字QTcpSocket）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 connect(mServer,SIGNAL(newConnection()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(new_client()));
 mSocket &lt;/span&gt;= mServer-&amp;gt;nextPendingConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与客户端通信的套接字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、发送数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 mSocket-&amp;gt;write(msg.toUtf8());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、读数据当客户端有数据来，QTcpSocket对象就会发送readyRead信号，关联槽函数读取数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;,SLOT(read_client_data()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、连接多个客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以实现同时读取多个客户端发送过来的消息&lt;/span&gt;
 QTcpSocket *obj = (QTcpSocket*)sender();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7、检测掉线&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;,SLOT(client_dis())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测掉线信号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是服务器的实现的具体代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcpserver.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_tcpserver.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QDebug&amp;gt;
&lt;span&gt; 4&lt;/span&gt; TcpServer::TcpServer(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::TcpServer)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化服务器server对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     mServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpServer();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联客户端连接信号newConnection&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     connect(mServer,SIGNAL(newConnection()),&lt;span&gt;this&lt;/span&gt;,SLOT(new_client())); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接客户端
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器监听&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     mServer-&amp;gt;listen(QHostAddress::Any,&lt;span&gt;9988&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; TcpServer::~&lt;span&gt;TcpServer()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::new_client()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     qDebug()&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新客户段连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     mSocket = mServer-&amp;gt;nextPendingConnection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与客户端通信的套接字
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联接收客户端数据信号readyRead信号（客户端有数据就会发readyRead信号）&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(read_client_data()));
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测掉线信号&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_dis()));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::read_client_data()
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以实现同时读取多个客户端发送过来的消息&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     QTcpSocket *obj = (QTcpSocket*&lt;span&gt;)sender();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     QString msg = obj-&amp;gt;&lt;span&gt;readAll();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     qDebug()&amp;lt;&amp;lt;&lt;span&gt;msg;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpServer::client_dis()
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;      QTcpSocket *obj = (QTcpSocket*)sender();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;掉线对象&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;      qDebug()&amp;lt;&amp;lt;obj-&amp;gt;peerAddress().toString();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印出掉线对象的ip&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;说完服务器那我们继续来看看客户端是怎么实现的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、创建QTcpSocket对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 mSocket = &lt;span&gt;new&lt;/span&gt; QTcpSocket();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、链接服务器connectToHost(QHostAddress(&quot;ip&quot;),端口号)，连接服务器ip和端口号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 mSocket-&amp;gt;connectToHost(ui-&amp;gt;ipEdit-&amp;gt;text(),ui-&amp;gt;portEdit-&amp;gt;text().toInt()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ui-&amp;gt;ipEdit-&amp;gt;text()：ip，ui-&amp;gt;portEdit-&amp;gt;text().toInt()：端口号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、发送数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取发送信息编辑框内容&lt;/span&gt;
QString msg = ui-&amp;gt;sendEdit-&amp;gt;&lt;span&gt;toPlainText();
mSocket&lt;/span&gt;-&amp;gt;write(msg.toUtf8());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转编码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、检测链接成功信号关联槽函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(connected()),&lt;span&gt;this&lt;/span&gt;,SLOT(connect_suc()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、检测掉线信号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;,SLOT(client_dis()));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、服务器和客户端关闭都可以使用close&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
 mSocket-&amp;gt;close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是客户端实现的具体代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcpclient.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_tcpclient.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;QDebug&amp;gt;
&lt;span&gt; 4&lt;/span&gt; TcpClient::TcpClient(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::TcpClient)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化套接字对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     mSocket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpSocket();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联数据信号&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(read_data()));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; TcpClient::~&lt;span&gt;TcpClient()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::read_data()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     QString msg = mSocket-&amp;gt;&lt;span&gt;readAll();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     qDebug()&amp;lt;&amp;lt;&lt;span&gt;msg;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::on_btn_connectServer_clicked()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测链接成功信号关联槽函数&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     connect(mSocket,SIGNAL(connected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(connect_suc()));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测掉线信号&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_dis()));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接服务器，设置ip和端口号&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     mSocket-&amp;gt;connectToHost(ui-&amp;gt;ipEdit-&amp;gt;text(),ui-&amp;gt;portEdit-&amp;gt;&lt;span&gt;text().toInt());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::on_btn_send_clicked()
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取发送信息编辑框内容&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     QString msg = ui-&amp;gt;sendEdit-&amp;gt;&lt;span&gt;toPlainText();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     mSocket-&amp;gt;write(msg.toUtf8());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转编码&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::connect_suc()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     ui-&amp;gt;btn_connectServer-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果连接成功则连接按钮不能按下&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpClient::client_dis()
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     ui-&amp;gt;btn_connectServer-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果连接没有成功则连接按钮还可以按下&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是服务器和客户端分开两个文件夹写的程序，在这里我也实现了服务器和客户端写在同一个文件中&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;p&gt;头文件：tcpapp.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_98d670cb-e935-41bc-b191-7062e00db424&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_98d670cb-e935-41bc-b191-7062e00db424&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_98d670cb-e935-41bc-b191-7062e00db424&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef TCPAPP_H
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; TCPAPP_H
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;QMainWindow&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;QTcpServer&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;QTcpSocket&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;QHostAddress&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;QFile&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;QTimer&amp;gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;QMessageBox&amp;gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Ui {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TcpApp;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TcpApp : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; QMainWindow
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    Q_OBJECT
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;explicit&lt;/span&gt; TcpApp(QWidget *parent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     ~&lt;span&gt;TcpApp();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; slots:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_severRB_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为服务器&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_clientRB_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为客户端&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_StartBt_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器或链接客户端&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_closeBt_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭服务器或断开客户端&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_onlineUserList_doubleClicked(&lt;span&gt;const&lt;/span&gt; QModelIndex &amp;amp;index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择给哪个客户端发送数据&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_autoCB_clicked(&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;checked&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择自动发送还是手动发送&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; on_sendMsgBt_clicked();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送信息
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; accept_connect();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与newconnection信号关联&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; recv_data(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收数据&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt; auto_time_send();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器定时发送数据&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt; client_disconnect();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联掉线信号&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt; connect_suc();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测客户端连接成功信号&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_clearRcvBt_clicked();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;      &lt;span&gt;void&lt;/span&gt;&lt;span&gt; on_clearSendBt_clicked();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     Ui::TcpApp *&lt;span&gt;ui;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     QTimer *mTimer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时发送数据&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     QTcpServer *&lt;span&gt;mServer;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     QTcpSocket *&lt;span&gt;mSocket;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     QVector&amp;lt;QTcpSocket*&amp;gt; clients; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储所有在线客户端（容器）&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isServer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标志位,true为服务器，false为客户端
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存接收和发送数据的字节数&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    quint64 recvSize;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    quint64 sendSize;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    qint16 onNum;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isCheckServer;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否选择了服务器&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; isCheckClient;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否选择了客户端&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TCPAPP_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;源文件：tcpapp.cpp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;&lt;img id=&quot;code_img_closed_f01ca2ee-5653-472a-a2e2-a19cdd17a552&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f01ca2ee-5653-472a-a2e2-a19cdd17a552&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f01ca2ee-5653-472a-a2e2-a19cdd17a552&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcpapp.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ui_tcpapp.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; TcpApp::TcpApp(QWidget *&lt;span&gt;parent) :
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    QMainWindow(parent),
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     ui(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Ui::TcpApp),
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     onNum(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     ui-&amp;gt;setupUi(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     recvSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     sendSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     mTimer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTimer();
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     connect(mTimer,SIGNAL(timeout()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(auto_time_send()));
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; TcpApp::~&lt;span&gt;TcpApp()
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ui;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;与newconnection信号关联&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::accept_connect()
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     mSocket = mServer-&amp;gt;nextPendingConnection(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回与客户端连接通信的套接字
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联接收数据信号&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(recv_data()));
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联掉线信号&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_disconnect()));
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上线用户添加到客户列表容器&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    clients.append(mSocket);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把用户添加到界面列表中&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     QString ip = mSocket-&amp;gt;peerAddress().toString().remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;::ffff:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除客户端中多余的字符&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     ui-&amp;gt;onlineUserList-&amp;gt;&lt;span&gt;addItem(ip);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在线数量添加&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     onNum++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     ui-&amp;gt;onlineUserCount-&amp;gt;setText(QString::number(onNum));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示在线数&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收数据&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  TcpApp::recv_data()
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;       QTcpSocket *obj = (QTcpSocket*&lt;span&gt;)sender();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取发送数据端的IP&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;       QString ip = obj-&amp;gt;&lt;span&gt;peerAddress().toString();
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;       ip.remove(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;::ffff:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;       QString msg = obj-&amp;gt;&lt;span&gt;readAll();
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;       ui-&amp;gt;receiveList-&amp;gt;addItem(ip+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+msg);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示接收到的数据&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;       recvSize += msg.size();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计接收到的数据的字节数&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;       ui-&amp;gt;receiveNumLabel-&amp;gt;&lt;span&gt;setText(QString::number(recvSize));
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::client_disconnect()
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     QTcpSocket *obj = (QTcpSocket*)sender();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取掉线对象&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isServer)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; row = clients.indexOf(obj);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到掉线对象的内容所在的行&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         QListWidgetItem *item = ui-&amp;gt;onlineUserList-&amp;gt;takeItem(row);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从界面列表中去除找到的一行内容&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         clients.remove(row);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从容器中删除对象
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;掉线时删除在线数量&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         onNum--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         ui-&amp;gt;onlineUserCount-&amp;gt;&lt;span&gt;setText(QString::number(onNum));
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开连接的时候重新启用开始按钮&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端连接成功&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::connect_suc()
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接成功则禁用开始按钮&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时器定时发送数据&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::auto_time_send()
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     quint64 len = mSocket-&amp;gt;write(ui-&amp;gt;sendMsgEdit-&amp;gt;&lt;span&gt;toPlainText().toUtf8());
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(len &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         sendSize += len;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计发送的字节数&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;         ui-&amp;gt;sendNumLabel-&amp;gt;setText(QString::number(sendSize));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把发送的字节数显示到sendNumLabel上&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为服务器&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_severRB_clicked()
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckServer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isServer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取本地ip显示在IpEdit中&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;    ui-&amp;gt;IpEdit-&amp;gt;&lt;span&gt;setText(QHostAddress(QHostAddress::LocalHost).toString());
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;    ui-&amp;gt;IpEdit-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭ip输入编辑器&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;    &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckClient = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择作为客户端&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_clientRB_clicked()
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckClient = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isServer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     ui-&amp;gt;IpEdit-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开ip输入编辑器&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;isCheckServer = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器或者链接服务器&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_StartBt_clicked()
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isServer) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         mServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpServer();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联新客户端链接信号&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;         connect(mServer,SIGNAL(newConnection()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(accept_connect()));
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;         mServer-&amp;gt;listen(QHostAddress::Any,ui-&amp;gt;PortEdit-&amp;gt;text().toInt());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动服务器监听&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始按钮禁用&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isServer == &lt;span&gt;false&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;         mSocket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QTcpSocket();
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测链接成功信号&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;         connect(mSocket,SIGNAL(connected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(connect_suc()));
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置服务器的 ip和端口号&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;         mSocket-&amp;gt;connectToHost(ui-&amp;gt;IpEdit-&amp;gt;text(),ui-&amp;gt;PortEdit-&amp;gt;&lt;span&gt;text().toInt());
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联接收数据信号&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;         connect(mSocket,SIGNAL(readyRead()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(recv_data()));
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关联掉线信号&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;         connect(mSocket,SIGNAL(disconnected()),&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,SLOT(client_disconnect()));
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isCheckServer == &lt;span&gt;false&lt;/span&gt; &amp;amp;&amp;amp; isCheckClient == &lt;span&gt;false&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果两个都没选择&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请选择服务器或者客户端&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isCheckServer)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择了服务器&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;PortEdit-&amp;gt;text().isEmpty() || ui-&amp;gt;PortEdit-&amp;gt;text() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;            QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;            ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isCheckClient)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择了客户端&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;IpEdit-&amp;gt;text().isEmpty() || ui-&amp;gt;IpEdit-&amp;gt;text() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入ip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; || ui-&amp;gt;IpEdit-&amp;gt;text() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入ip和端口号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;             ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭服务器或者断开&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_closeBt_clicked()
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(isServer)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;clients.count();i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;              clients.at(i)-&amp;gt;close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭所有客户端&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭所有服务器之后开始按钮才能启用&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;         mServer-&amp;gt;&lt;span&gt;close();
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         mSocket-&amp;gt;close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭客户端&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;         ui-&amp;gt;StartBt-&amp;gt;setEnabled(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启用开始按钮&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; 
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双击选择要发送的客户端&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TcpApp::on_onlineUserList_doubleClicked(&lt;span&gt;const&lt;/span&gt; QModelIndex &amp;amp;&lt;span&gt;index)
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;     mSocket =&lt;span&gt; clients.at(index.row());
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; 
&lt;span&gt;201&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动发送数据&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TcpApp::on_autoCB_clicked(&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;checked&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;checked&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; 
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ui-&amp;gt;autoTimeEdit-&amp;gt;text().toInt() &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;             QMessageBox::warning(&lt;span&gt;this&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入时间值ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             ui-&amp;gt;autoCB-&amp;gt;setChecked(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把按钮重新置于没选中的状态&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;         mTimer-&amp;gt;start(ui-&amp;gt;autoTimeEdit-&amp;gt;text().toInt());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动定时器&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         mTimer-&amp;gt;stop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止定时器&lt;/span&gt;
&lt;span&gt;218&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; 
&lt;span&gt;222&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动发送数据&lt;/span&gt;
&lt;span&gt;223&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_sendMsgBt_clicked()
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;    auto_time_send();
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; 
&lt;span&gt;227&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空接收区&lt;/span&gt;
&lt;span&gt;230&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_clearRcvBt_clicked()
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;     ui-&amp;gt;receiveNumLabel-&amp;gt;&lt;span&gt;clear();
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;recvSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     ui-&amp;gt;receiveNumLabel-&amp;gt;&lt;span&gt;setText(QString::number(recvSize));
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空发送区&lt;/span&gt;
&lt;span&gt;238&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TcpApp::on_clearSendBt_clicked()
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;     ui-&amp;gt;sendNumLabel-&amp;gt;&lt;span&gt;clear();
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;sendSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;     ui-&amp;gt;sendNumLabel-&amp;gt;&lt;span&gt;setText(QString::number(sendSize));
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;界面文件tcpapp.ui如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1206191/201712/1206191-20171210234326786-1985944821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;此外这里还使用到了容器，在这里讲讲容器的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、定义容器对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
QVector&amp;lt;QTcpSocket*&amp;gt; clients; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储所有在线客户端（容器）&lt;/span&gt;
&lt;span&gt;  解释：QTcpSocke  容器的类型
       clients  容器名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、往容器中添加成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上线用户添加到客户列表容器&lt;/span&gt;
 clients.append(mSocket); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、寻找某个成员在容器中位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;int&lt;/span&gt; row = clients.indexOf(obj);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到掉线对象的内容所在的行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、从容器中删除车成员&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  clients.remove(row);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从容器中删除成员&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:47:00 +0000</pubDate>
<dc:creator>菜头大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wurenzhong/p/8018862.html</dc:identifier>
</item>
<item>
<title>Ajax的工作原理 - 毕竟我那么帅</title>
<link>http://www.cnblogs.com/luoyong-14/p/8018854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luoyong-14/p/8018854.html</guid>
<description>&lt;p&gt;在聊到Ajax的时候，需要大家清楚的是·Ajax是什么。AJax也叫Asynchronous JavaScript and XML，即异步的JavaScript 和XML。其次需要清楚的Ajax并不是一门新的语言或技术，而是JavaScript ，css,Dom,xml等多种已有的技术的组合，可以实现客户端的异步请求的操作从而实现在不刷新页面的情况下与服务器端进行数据层间的数据交互，减少了用户的等待时间，减轻了服务器端和带宽的负担，例如Google地图和百度地图中都有用到Ajax&lt;/p&gt;&lt;p&gt;在传统的web应用模式中，每发送一次http请求到web服务器端，经过处理后，返回的是一个html+css的格式|&lt;br/&gt;使用了Ajax应用模式中，页面中用户的操作将通过Ajax引擎与服务器端进行通信，经web服务器端处理后返回的是一个html+字符串数据，就是说通过回调函数返回的data是一个字符串，这个字符串可以是json格式也可以是其他格式，取决于你定义的是什么&lt;/p&gt;&lt;p&gt;使用Ajax的优点：&lt;/p&gt;
&lt;p&gt;1,首先是降低网络的流量，因为是局部刷新&lt;br/&gt;2，把一部分原本是有服务器承担的工作转移到客户端，利用客户端闲置的资源进行一个处理，减轻了服务器和带宽的负担，节约了空间和成本&lt;/p&gt;
&lt;p&gt;3，使用Ajax可以实现局部刷新的效果而不是页面刷新，这样的话就将服务器的角色由传输内容变成传输数据，而这个传输的数据的格式可以是xml格式，也可以是纯文本格式、&lt;/p&gt;
&lt;p&gt;4，通过Ajax的核心对象XMLHttpRequest发送请求来进行客户端和服务端之间的一个交互，通过XMLHttprequest发送请求后，通过javascript来操作DOM从而更新页面中的数据&lt;/p&gt;
&lt;p&gt;使用Ajax的缺点：&lt;/p&gt;
&lt;p&gt;1，通过XMLhttpRequesth函数来获取数据，在使用Ajax进行跨域请求的时候会出现跨域的安全问题，当然在后面可以通过jsonp来解决浏览器同源策略问题，但是在没有jsonp的时候会存在这样的问题&lt;/p&gt;
&lt;p&gt;2，由于ajax是通过javascript来操作dom，进行对页面中的数据进行一个更新的，这样一来的话就会导致javascript过多，不易于维护&lt;/p&gt;
&lt;p&gt;3,给搜索引擎带来困难&lt;br/&gt;4，aj&lt;span lang=&quot;EN-US&quot;&gt;ax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、&lt;span lang=&quot;EN-US&quot;&gt;SQL注入攻击和基于&lt;span lang=&quot;EN-US&quot;&gt;credentials的安全漏洞等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;安全问题：&lt;br/&gt;当web应用程序运行javascript脚本的时候，用户允许任何人编写的javascript代码运行在自己的计算机上，这就为移动代码自动跨域网络来运行提供了方便条件，为了解决这潜在的问题，浏览器厂商都会提供一个sandbox(沙箱)，沙箱是一个只能访问很少计算机资源的密闭环境，从而使得ajax应用不能读取或写入本地文件系统，从而提高了客户端的javascript安全性&lt;br/&gt;客户端调用远程资源的一个安全问题：&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;虽然javascript允许客户端完成部分服务器端的工作，并且可以通过javascript来检查用户的权限，但是通过客户端脚本来控制权限并不可取，一些解密高手可以很轻松的绕开javascript权限检查直接访问业务逻辑组件，从而给网站带来安全的问题，通常情况下，在ajax应用中，所有的ajax请求都应该发送到控制器，有控制器来判断调用者是否有访问资源的权限&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;性能问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;尽量使用局部变量而不使用全局变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;优化for循环&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;尽量少使用eval()方法，每次使用eval（）都会消耗大量的时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;尽量减少“”。“”号操作符的使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;浏览器兼容问题：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;readstatus：&lt;/p&gt;
&lt;p&gt;0：未初始化，也就是没有调用open方法&lt;/p&gt;
&lt;p&gt;1：正在加载&lt;/p&gt;
&lt;p&gt;2，已加载&lt;/p&gt;
&lt;p&gt;3，交互中&lt;/p&gt;
&lt;p&gt;4，已完成”&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于同步和异步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。&lt;/p&gt;
&lt;p&gt;具体来说，异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。一个最明显的例子就是计算机键盘和主机的通信，按下一个键的同时向主机发送一个8比特位的ASCII代 码，键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。这是一个典型的异步传输过程。异步传输存在 一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说 话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号。步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。&lt;/p&gt;
&lt;p&gt;同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。&lt;/p&gt;
&lt;p&gt;　　数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。&lt;/p&gt;
&lt;p&gt;　　帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。&lt;/p&gt;
&lt;p&gt;　　同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。&lt;/p&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:45:00 +0000</pubDate>
<dc:creator>毕竟我那么帅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luoyong-14/p/8018854.html</dc:identifier>
</item>
<item>
<title>Python3.6_安装numpy - 小摔</title>
<link>http://www.cnblogs.com/sstzero/p/8018837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sstzero/p/8018837.html</guid>
<description>&lt;p&gt;刚刚编辑了一次，但是犯了新手都会犯的没保存的错误，第二次编辑可能略有粗糙，如有问题欢迎指正&lt;/p&gt;
&lt;p&gt;想用Python 画图，但是我的是vs自动安装的因此缺少许多必要的库，在安装的过程中也是遇到了诸多问题，下面就介绍一下这些库的安装。&lt;/p&gt;
&lt;p&gt;下面四个是vs推荐我安装的库。&lt;/p&gt;
&lt;p&gt;1. Download a dataset (using &lt;strong&gt;pandas&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;2. Process the numeric data (using &lt;strong&gt;numpy&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;3. Train and evaluate learners (using &lt;strong&gt;scikit-learn&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;4. Plot and compare results (using &lt;strong&gt;matplotlib&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;首先在安装之前请先确保环境变量已经配置：包括python.exe和pip.exe&lt;/p&gt;
&lt;p&gt;环境变量配置方式：电脑-属性-高级系统设置-高级-环境变量-系统变量-Path。如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1269654/201712/1269654-20171210233657396-1097380449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.安装numpy&lt;/p&gt;
&lt;p&gt;2.1安装包的下载官方地址 https://pypi.python.org/pypi/numpy&lt;/p&gt;
&lt;p&gt;请在“Py Version”这个栏目选择适合自己版本的，我选的cp36(我用的Python3.6)&lt;/p&gt;
&lt;p&gt;再选择合适自己系统的，我的系统是Windows 64的&lt;/p&gt;
&lt;p&gt;2.2安装包的安装//高亮部分为安装包的名称&lt;/p&gt;
&lt;p&gt;在cmd命令窗口输入：//我的安装包放在D盘根目录下&lt;/p&gt;
&lt;p&gt;（1）       D:&lt;/p&gt;
&lt;p&gt;（2）       pip install numpy-1.13.3-cp36-none-win_amd64.whl&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1269654/201712/1269654-20171210233732693-517216569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;p&gt;(1)千万选择适合自己系统的安装包，否则会报如下错误：…is not a supported wheel on this platform.&lt;/p&gt;
&lt;p&gt;(2)不要修改下载下来的安装包的名称，否则会报如下错误... is not a valid wheel filename.&lt;/p&gt;

</description>
<pubDate>Sun, 10 Dec 2017 15:41:00 +0000</pubDate>
<dc:creator>小摔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sstzero/p/8018837.html</dc:identifier>
</item>
<item>
<title>计算机网络初探（ip协议） - 何必诗债换酒钱</title>
<link>http://www.cnblogs.com/backwords/p/7944780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/backwords/p/7944780.html</guid>
<description>&lt;p&gt;粗读了两遍计算机网络（谢希仁），对于计算计算机网络算是有了一个初步的了解，所以打算写一篇文章（希望是教程）进行巩固（主要围绕IP协议）。&lt;/p&gt;
&lt;h2&gt;         局域网&lt;/h2&gt;
&lt;p&gt;             因特网的产生和广泛使用极大地改变了我们的生活，但对于不了解当中技术细节的人来说，因特网的工作是透明的，即我们不知道在每次点击一个链接，发送一个文件，或者进行联机游戏时计算机的软硬件背后，无数线缆，电磁波，甚至卫星是怎样将我们的数据运送到另一台计算机上，而我们能感受到的只有毫秒间的数据收发和一个世界范围内的网络互联。&lt;/p&gt;
&lt;p&gt;             首先，从比较原始的地方开始讲起，当我们有许多的计算机并且想要通过一种方法实现所有计算机之间的互联从而实现数据交换，最为简单的方法是什么？我们可以这样，为每一台计算机分配一个唯一标识符（mac地址）来定位他，然后将所有打算接入网络的计算机用导线连接起来，这样就非常简单且原始的实现的物理层次上的互联。那么他们之间该如何进行通信呢（暂不考虑对接受到的数据的解读）？&lt;/p&gt;
&lt;p&gt;参考下图：图一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209212842493-1989196882.png&quot; alt=&quot;&quot; width=&quot;211&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如H1试图与H2进行通信，首先H1细心的将自己想要表达的东西打包好，注明收到消息的计算机的标识符，然后将这份数据包裹发送到线路中，由于这份包裹只有目的计算机的地址，他不知道目的计算机的具体位置，所以只好采用最笨的方法，一个一个的问：“你的地址是***吗”，例如当H3收到了这份包裹，但是却发现他不是发给自己的，就不予理睬，而包裹只能问下一个，直到他遇到了H2，H2发现这份包裹注明的目的地址是自己的地址，于是收下并打开他。这样便完成了一次H1到H2的通信。这种收发数据的方式被称为轮询，即每次发送一个数据包裹都需要询问每个计算机，直到找到目的主机。（事实上这是一个只通过集线器连接的局域网）&lt;/p&gt;
&lt;p&gt;　　　　这种方法构建的网络似乎也不赖，计算机之间可以正常通信，那么可以考虑继续将更多的计算机加入进来了。但是在这之前，我们会发现这种网络有个小毛病，就是每次网络上只能有一份包裹在传输，如果有第二个包裹也发送到网络中，二者就会发生碰撞，从而造成混乱。怎么解决这种情况呢？方法就是谦让。谦让体现在每当有一台计算机试图发送一个数据包裹时，先检测当前网络状态，如果网络中没有任何人在通信，即网络所有线路都是空闲的，那么自己便将数据包裹发送出去，而一旦发现有人在通信，即网络线路上有数据包裹正在跑来跑去，那么自己就先等着，等一会在检测一次网络线路是否空闲。然而在这里还有另一个问题，就是存在两台计算机同时发送数据包裹或是因为网络固有的时延而没有检测到网络线路上有包裹而导致他们都发送了包裹到网络上，那么碰撞必然发生，而解决方法则是一旦发生碰撞，那么两份包裹都丢弃，然后两台计算机各自沉默一个随机的时间之后再次检测网络线路选择是否发送。二者通过各自等待一个随机的时间，很好的避免了二者的再次碰撞。（CSMA/CD协议）&lt;/p&gt;
&lt;p&gt;　　　　解决了碰撞的问题。那么可以继续我们的主题，将更多的计算机加入进来！随着更多的计算机的加入，网络规模也越来越大，在较大规模下的网络中。我们当前的网络有个很致命的问题，那就是刚刚讨论过的谦让。在很小型的网络中由于这种谦让所带来的延迟是可以忽略不计的，但是一但网络规模大起来，比如几百台甚至上千台计算机构成的网络，每当有一台计算机在通信时，其他所有的计算机都要等待他通信结束后才能发送自己的包裹，这种延迟是不能被接受的。这时便不得不引入一种新的设备来将这种这个碰撞范围进行限制，这种设备就是网桥（一种专用计算机）。&lt;/p&gt;
&lt;p&gt;如图：图二&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209215008493-1861403985.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网桥将一个原本为一个整体的网络划分为一个一个的子网络并将他们连接起来，这样做最大的优点便是将碰撞范围很好的控制在一个个小型的子网络中。&lt;/p&gt;
&lt;p&gt;同时呢，在网桥中储存并维护一张由标识符组成的查找表，对应于不同的线路接口，&lt;/p&gt;
&lt;p&gt;如图：图三&lt;/p&gt;
&lt;p&gt;（假装有图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209214209306-1330936815.png&quot; alt=&quot;&quot; width=&quot;223&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每当有一台计算机试图与某一台计算机进行数据交换（通信）时，便将数据报包裹注明目的计算机的标识符，在本子网进行广播，如果目的主机不在本子网，则通过专用线路递交给网桥，而后网桥通过查找转发表找到与该标识符匹配的计算机，将这份数据通过连接到这台计算机的线路发送给他。（只通过网桥连接的局域网）&lt;/p&gt;
&lt;p&gt;　　　　上述的模型在小型的网络中也许会工作的很好，但是现实是我们有几十亿台地理分布在世界各地的计算机，显然之前的模型完全不能使用，因为这种策略本质上仍是简单的线性查找，查找过程和对数据包裹的运送将耗费极大的时间和资源。这时候，一些优秀的算法思想便可以被应用起来了。行之有效的方法是分治，而这种算法的实现就是IP协议。&lt;/p&gt;
&lt;h2&gt;          IP协议下的分组转发&lt;/h2&gt;
&lt;p&gt;　　　　我们先撇开技术方面的内容，来想这样一个问题——如何在中国找到某个美女并要到她的联系方式。因为每个人在世界上都是独一无二的，比较笨的方法就是，从当前所在地开始逢人便问，你是那个美女吗（她的个人信息就是独一无二的标识符），问遍整个中国，直到找到这个人，成功得到了她的电话。&lt;/p&gt;
&lt;p&gt;这种方法是按照美女的全球唯一标识符（长相，年龄，血型，基因型等信息的组合体）来确定她，很浪漫的方式，但却非常低效且不现实。&lt;/p&gt;
&lt;p&gt;　　　　那么接下来就是另一种方法，根据她的地址信息来定位她。比如她的地址是辽宁省-沈阳市-长滩县-张家村-2-22号-户主之女-美女，那么首先我们应该最先得知的是要到辽宁省去，所以第一次选择我们就排除了中国80%的地方，下一条信息是沈阳市，我们又排除了辽宁省的70%的地方，之后在定位到长滩县，张家村，到了这里搜索范围已经很小了，我们得知美女住2-22号，按照住户序号的分配规律（按块分配，有序）我们仍可以很快定位到2-22这家住户，但是我们发现，户主有12个女儿，我们已经没有任何信息可以帮助我们将户主女儿们划分开了，所以只能一个一个的询问，通过匹配长相，年龄，血型，基因型等信息的组合体（即唯一标识符）来定位到美女，所幸搜索范围只有12个，很快我们就找到了美女。&lt;/p&gt;
&lt;p&gt;过程如图：图四&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171209221428759-2096488745.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　下面回到技术方面，我们的计算机同美女一样，在因特网中它也必须只有一个唯一标识符，而这个标识符是生产我们计算机网卡时网卡制造商写在其中的，叫做mac地址，是一个48为二进制数，具有全球唯一性。mac地址才是最终我们能将美女从12个相似的美女中将她选出来的关键。之前说过单纯使用mac地址的索引来实现通信是一件非常不明智的事，而且不同的主机（计算机，路由器等都可称为主机）在系统，软硬件上的差异性将会使得这种方法更为不可靠。那么，IP协议是如何实现IP数据报（相似之前的数据包裹，即将要发送的数据按照Ip协议的规则打包后的数据包）在全球范围内的高效分组转发并屏蔽了诸多的差异性呢？其实从找美女的第二个例子我们应该能够看出IP协议转发的思想了。 &lt;/p&gt;
&lt;p&gt;　　　　首先简单介绍下IP地址的长相：204.79.197.200；它是一个32位二进制数，通常通过每8位进行一次划分，为了表示方便通常将每8位二进制数表示为十进制。我们可以认为第一段204即对应于地理位置“市”，相应的，79对应于“县”，197对应于“村”，200对应于户主的某个女儿。其中前三者被称为网络地址，代表主机所属的区域，最后一个8位是已经无法再划分的主机号，每个拥有主机号的主机都是一个不同的个体（户主的12个女儿）。&lt;/p&gt;
&lt;p&gt;这种划分方式称为划分子网（分类别编址），即将一个本来很大的相似的群体划分为不同层次，在这里将网络地址划分为A类，B类，C类。在我们给出的这个IP地址中，A类地址：204.0.0.0，B类地址：204.79.0.0，C类地址：204.79.197.0；能看出A类地址所能包含的主机数量最大，B类次之，C类最小。前者可以包含若干个后者。那么当我要找到主机号为200的主机时就很简单了，首先找到网络地址为204.0.0.0的网络，第一步我们排除了大部分的网络，而后找到网络地址为204.79.0.0的网络（其实可以认为204.79.0.0是204.0.0.0网络下的一台主机），然后是网络204.79.197.0，这时发现网络已经没有再进行划分了，所以在该网络进行广播，遍历所有的主机号，找到主机号为200的目的主机。&lt;/p&gt;
&lt;p&gt;如图：图五&lt;br/&gt;（假装有图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1131119/201712/1131119-20171210231159630-1564807320.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　更进一步考虑，我们有必要每次都去查看一个人所在地范围最大的地址吗？通信的发起者同接受者一样，也是位于某个村子的某个门牌号里的某人，也许他要发送信息的目的对象就是本村的人（同一局域网内），这时还要去查看他是哪个省，哪个市吗？显然没必要。在这里我们一定要理解一点，那就是计算机始终是存在于整个网络的边缘或者说网络的终端，中心区域为连接在一起的互联网。这就像我们每个人的住所一样，都是存在于国-省-市-县-村-号的模型的门牌号中这个最底层中，上面各层都是人为抽象出来的。所以当某个局域网内的主机试图向因特网中的某台主机（IP:200.78.132.44)通信时，首先判断目的主机是否和自己在一个局域网中，如果是，那么直接将IP数据报根据主机号（44）发送给目的主机（12个女儿找美女的过程），路由器（转发IP数据报的专用计算机）都不必经过，这很大程度上的节省了互联网的线路资源，同时也提高了通信的速度。&lt;/p&gt;
&lt;p&gt;这里不得不简要介绍一下路由器。路由器是一台用于转发IP数据报文的专用计算机，他有若干个端口，每个端口有一个网络地址，代表不同的网络并连接到他们。同时路由器也有自己的IP地址和mac地址，标识他作为一个主机本身在网络中的位置。当IP数据报在互联网上传输时，每台路由器都根据其IP地址作为独立的主机被定位。路由器会维护一张路由表，包含了他连接的子网络。比如有一份IP报文IP地址为172.43.50.15，此时这份报文到达路由器H1，H1查找自己的路由表，发现自己所连接的各个子网的网络地址没有匹配报文网络地址的端口，但是他发现H2所连接的子网有匹配的端口，于是他将IP数据报转发给H2，此时H2查找转发表，发现自己连接的子网有个地址为172.43.50.0的匹配项，于是便将这个报文从这个端口发送出去到达该子网络，由于这是一个简单的局域网，所以路由器将IP数据报的IP地址转换为目的主机的mac地址，情况转化为在局域网中根据mac地址查找主机（12女儿选美女）。&lt;/p&gt;
&lt;p&gt;                回到正题，如果目的主机不在本局域网，那么便将数据报转交给本局域网的连接到互联网的路由器（路由器可以被认为是一台主机，此时他连接到发出数据报的网络的端口的IP地址是204.79.197.0）。这台路由器首先判断IP数据报的目的网络地址是否在本网络中(可以认为路由器之间又组成了一个局域网，这块网络的网络地址为200.79.0.0。197是当前路由器一个端口的主机号，不过这个主机号代表的是一个网络而不是一个主机）。如果数据报的网络地址（200.78.132.0）就是由这一层路由器组成的网络，那么我们先将每台路由器都看做单独的主机，并假想这是一个由路由器组成的局域网，那么当一个路由器向另一个主机发送数据报时，首先IP地址被转换成mac地址并在当前局域网内广播（12女儿找美女），当找到目的路由器后，路由器查找转发表，如果有匹配的网络地址，则将数据报发送至该网络，重复上述过程，直到数据报被运输到局域网进行广播，找到主机数据传输结束。如果某层网络没有匹配项，则通过连接更大的网络的路由逐层向上传递至更高的网络（范围更大），直至有匹配的网络地址，而后在向下传递。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权所有，未经允许，禁止转载。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 15:25:00 +0000</pubDate>
<dc:creator>何必诗债换酒钱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/backwords/p/7944780.html</dc:identifier>
</item>
<item>
<title>谈谈换行 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/8017127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/8017127.html</guid>
<description>&lt;p&gt;前几天表弟突然打电话给我说，经过四个月的学习Java，最近拿到了几个offer，不知道选哪家。一问，有老虎证券，摩拜单车，搜狐和滴滴。薪水都是2w+，年薪30万左右。其实这些都蛮不错，最后决定选择了滴滴。&lt;/p&gt;
&lt;p&gt;说实话我蛮惊讶的，表弟是北航研究生，毕业两年一直做物联网婴儿方面的创业项目，但因种种原因项目没有继续下去，于是决定找工作。早之前和我聊，说想干程序员，觉得程序员工资高，那时我已有辞职的打算，他笑着说，简直像围城啊，我都想进来，你却要出去。我说，没办法路不一样。他本专业是机械自动化，还有机械设计方面的设计专利。没想到这么快就拿到了这么好的offer。他的简历写的是两年工作经验，且只写了一个项目经验，还是学习java时自己做的一个系统，面试滴滴的时候有好些问题也没有回答上来，但就是过了。&lt;/p&gt;
&lt;h3&gt;选择比努力重要&lt;/h3&gt;
&lt;p&gt;其实如果让一个工作几年的程序员去换一种语言，也许很多人就像让他取个丑媳妇一样难为情。过去的沉默成本让他难以抉择。我之前也考虑过要不要学习下java。当时我内心的想法（借口）就是我干嘛要学一个差不多的后端语言呢，其实现在想来，这是两种很不同的语言，结构、用法是相似，但生态（市场）完全不同。打开51job，选择java开发工程师，再选2-3w的范围，拉出来有6页，而别的语言有的只有一页，这说明两点，一个是前者需求大，二个是达到高薪相对于别的语言容易。从投资的角度说，在成本和风险差不多的情况下，当然是选回报率更高的产品。所以表弟就毫不犹豫的选择了java，现在看来也很正确。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;代价&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我想成本有两个，一个是入行成本，一个是沉默成本。四个月的学习时间，只是一个基本的学习成本。其实换做是我们，给你四个月时间，专门去学习一门语言，如果有其他语言的基础，你可能还不要这么多时间就能上手，因为编程的路子是通的，所以编程的入行成本不高，外行人完全可以自学了入门，周遭都有好些半路来做程序员的，未来肯定有全民编程的时候。区别最大的成本在于告别过去，重新开始。表弟创业结束，对机械兴趣也不大，四个月的学习就当是抛砖引玉。但像我自己，9月底离开上海，现在和一群90后一起正准备期末考试，之前6年的编程经验只能业余耍耍，对未来的工作暂时没有什么帮助，培训一年之后还要实习一年，我的入行成本和沉默成本都比较大，但考虑到长远的未来，也是做出了换行的决定。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;起点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在过去的成本中，学历几乎是每个HR眼中的硬通货。大家都见过能力很强但学历不怎么样的人，但人性就是以人的过去判断人，除非你现场证明给他们看，如果有这样的机会的话。像一些能力证书也是很通用的；其实我们在一些商业书籍中经常看到一个人从一个行业转到另一个行业，被委以重任。因为人家之前的成绩很漂亮。所以，不单是学历，就在当前的领域里做出好的成绩，比如在知名的企业、参与过知名的项目、很擅长某些领域，对未来的换行没准也是有帮助的。HR往人群中一扫，先入眼的，自然是那些站的高点的人。同样是基于经验，新行业的内部人士的引荐也可以提高你的起点。 &lt;/p&gt;

&lt;p&gt;总的说来，过去的已经是既定的，学历出生难以改变。不管考虑不考虑换行，把当前的工作做好都是正确的。对一件事有兴趣不妨花点精力入门学习一下，花不了多少精力，不要老是背负这过去的沉默成本，没准就是未来橄榄枝的必要条件。以上并不是鼓励大家去学java，只是由自己换行和表弟换行想到的一些。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 15:11:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/8017127.html</dc:identifier>
</item>
<item>
<title>前端自动化测试漫长路之——Selenium初探 - Young Dreamer</title>
<link>http://www.cnblogs.com/wmhuang/p/8011815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmhuang/p/8011815.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;最近想解决前端开发或测试中的两个问题：一是界面UI的布局适配，能否在测试的过程中，通过命令操作真机打开相应页面然后截屏，通过对图片识别分类，发现有问题的图片，然后及时修复；二是页面性能分析，很多时候页面只能在指定的Webview中使用，能否直接通过命令打开指定的页面，分析页面在真实APP中的性能，并生成报告。这两个问题的前提就是通过命令直接操作手机App，带着问题找线索，于是我就结识了&lt;code&gt;Selenium&lt;/code&gt;，下面将结合实例和大家分享一下。&lt;/p&gt;
&lt;h2 id=&quot;selenium是什么&quot;&gt;Selenium是什么？&lt;/h2&gt;
&lt;p&gt;先看一下&lt;a href=&quot;http://www.seleniumhq.org/&quot;&gt;官网&lt;/a&gt;的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Selenium automates browsers. That's it! What you do with that power is entirely up to you. Primarily, it is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should!) be automated as well.&lt;br/&gt;Selenium has the support of some of the largest browser vendors who have taken (or are taking) steps to make Selenium a native part of their browser. It is also the core technology in countless other browser automation tools, APIs and frameworks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的话我们可以知道3个点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;利用Selenium可以自动化操作浏览器，来实现web程序的自动化测试；&lt;/li&gt;
&lt;li&gt;Selenium是一个综合性的项目，提供了提供了不同语言版本的类库和工具，来支持浏览器的自动化；&lt;/li&gt;
&lt;li&gt;主流浏览器基于W3C规定的的Web Driver规范，提供了相应的Web Driver，而标准的主要技术支持来源于Selenium项目。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一图胜千言，Selenium在自动化测试中扮演的角色如下图所示：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/605230/201712/605230-20171210224525177-1069517099.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;selenium如何用&quot;&gt;Selenium如何用？&lt;/h2&gt;
&lt;p&gt;我们的诉求是通过脚本控制本地和手机上的浏览器，甚至APP中的Webview，Selenuim正好提供了WebDriver API供我们使用。从上面可以知道Selenium支持多种语言，如python、go、javascript等，对于前端而言，首选当然是javascript。以下是相关的操作步骤：&lt;/p&gt;
&lt;h3 id=&quot;环境准备&quot;&gt;环境准备&lt;/h3&gt;
&lt;p&gt;该环节主要是两步：&lt;/p&gt;
&lt;ol readability=&quot;0.47341772151899&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在项目中下载selenium-webdriver&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install selenium-webdriver --save&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.86875&quot;&gt;
&lt;p&gt;下载浏览器提供的WebDriver，并将该命令文件放置在系统变量PATH下&lt;br/&gt;我使用的是chrome的&lt;a href=&quot;https://sites.google.com/a/chromium.org/chromedriver/&quot;&gt;WebDriver&lt;/a&gt;，针对不同的chrome版本，需要下载不同版本的WebDriver，否则程序会报错。网上有好心人已经整理出了chrome的WebDriver与chrome的版本映射表，可以&lt;a href=&quot;http://blog.csdn.net/huilan_same/article/details/51896672&quot;&gt;点击查看&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;代码编写&quot;&gt;代码编写&lt;/h3&gt;
&lt;p&gt;selenium-webdriver的说明文档相当的赞，在selenium-webdriver包的目录下有几个文件：chrome.js、edge.js、ie.js、phantom.js等，这些都是selenium-webdriver针对不同的浏览器的webdriver的调用做了封装，打开chrome.js，在文件的开头有详细的文档说明。&lt;br/&gt;chrome.js中提到了3种使用场景：分别是Headless Chrome、Customizing the ChromeDriver Server、Working with Android。而我需要的场景就是Working with Android。&lt;br/&gt;实例代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; chrome &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'selenium-webdriver/chrome'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;Builder&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'selenium-webdriver'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; driver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Builder&lt;/span&gt;()
          .&lt;span class=&quot;at&quot;&gt;forBrowser&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'chrome'&lt;/span&gt;)
          .&lt;span class=&quot;at&quot;&gt;setChromeOptions&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;chrome&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Options&lt;/span&gt;()
              .&lt;span class=&quot;at&quot;&gt;androidPackage&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'com.example'&lt;/span&gt;)
              .&lt;span class=&quot;at&quot;&gt;androidActivity&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'com.example.Activity'&lt;/span&gt;))
          .&lt;span class=&quot;at&quot;&gt;build&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中需要要点就是指定要操作的浏览器类型、APP包的名字、android程序的Activity名字。一般webview的内核都是基于webkit的，指定浏览器类型为chrome即可，APP的包名和Activity名字可以通过命令工具aapt获取，关于aapt的详细介绍可以参考&lt;a href=&quot;http://www.jianshu.com/p/8d691b6bf8b4&quot;&gt;这篇博客&lt;/a&gt;。&lt;br/&gt;通过以上两步，就可以通过node执行相应的js文件，实现通过命令来控制APP了，这里是几个我测试的demo，供大家&lt;a href=&quot;https://github.com/huangwenming/learning-notes/tree/master/automateBrowser&quot;&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;selenium-webdriver运行原理&quot;&gt;selenium-webdriver运行原理&lt;/h2&gt;
&lt;p&gt;上面的操作涉及到了两个核心，即浏览器提供的webdriver和浏览器（chrome/chromium）。selenium-webdriver的作用就是利用webdriver将浏览器启动起来，并实现一系列自动操作。但究竟webdriver和浏览器是怎样一个协同关系呢，从chrome.js文件的注释中可以找到一些线索。&lt;/p&gt;
&lt;blockquote readability=&quot;9.6153846153846&quot;&gt;
&lt;p&gt;By default, every Chrome session will use a single driver service, which is started the first time a &lt;a href=&quot;mailto:%7B@link&quot;&gt;{@link&lt;/a&gt; Driver} instance is created and terminated when this process exits. The default service will inherit its environment from the current process and direct all output to /dev/null. You may obtain a handle to this default service using &lt;a href=&quot;mailto:%7B@link&quot;&gt;{@link&lt;/a&gt; #getDefaultService getDefaultService()} and change its configuration with &lt;a href=&quot;mailto:%7B@link&quot;&gt;{@link&lt;/a&gt; #setDefaultService setDefaultService()}.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面可以知道，selenium-webdriver先通过webdriver启动了一个driver service，该service又启动chrome，分别起在不同的端口。&lt;br/&gt;通过查阅资料，可以知道driver service在开启chrome的同时，为chrome安装了一个&lt;code&gt;Chrome Automation Extension&lt;/code&gt;扩展程序，该扩展程序的描述是：&lt;code&gt;Exposes extension APIs for automating Chrome&lt;/code&gt;，通过查看其源码，可以看到launchApp、getWindowInfo等函数，主要是提供了一些操作chrome的相关方法。&lt;br/&gt;一图胜千言，selenium-webdriver的工作原理如下图所示，该图来源于&lt;a href=&quot;https://kkboxsqa.wordpress.com/2015/03/20/chromedriver-under-the-hood/&quot;&gt;网络&lt;/a&gt;：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/605230/201712/605230-20171210224759365-956970653.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips：&lt;/strong&gt;&lt;br/&gt;上面知道了driver service与chrome之间的关系，知道默认情况下driver service的生命周期和测试的Chrome session是同步的，意味着每次测试都需要开启一个driver service，如果频繁的开启和关闭service，势必会造成资源浪费。&lt;br/&gt;针对这个情况，官方的描述是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The ChromeDriver class starts the ChromeDriver server process at creation and terminates it when quit is called. This can waste a significant amount of time for large test suites where a ChromeDriver instance is created per test.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方针对该情况提出了两个解决办法：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;Start the ChromeDriver server separately before running your tests, and connect to it using the Remote WebDriver.&lt;br/&gt;即测试之前先单独启动driver server，然后使用Remote WebDriver连接上driver server所在的端口。官方提供了一个python的示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; selenium &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; webdriver
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; selenium.webdriver.chrome.service &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; service
service &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; service.Service(&lt;span class=&quot;st&quot;&gt;'/path/to/chromedriver'&lt;/span&gt;)
service.start()
capabilities &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'chrome.binary'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'/path/to/custom/chrome'&lt;/span&gt;}
driver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; webdriver.Remote(service.service_url, capabilities)
driver.get(&lt;span class=&quot;st&quot;&gt;'http://www.google.com/xhtml'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
time.sleep(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# Let the user actually see something!&lt;/span&gt;
driver.quit()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;Use the ChromeDriverService. This is available for most languages and allows you to start/stop the ChromeDriver server yourself.&lt;br/&gt;可自己创建一个driver，同时为这个driver指定相应的service。这样不仅可以为driver提供个性化的服务（如log日志），还可以控制service的生命周期。&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; chrome &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'selenium-webdriver/chrome'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; service &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;chrome&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ServiceBuilder&lt;/span&gt;()
.&lt;span class=&quot;at&quot;&gt;loggingTo&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/my/log/file.txt'&lt;/span&gt;)
.&lt;span class=&quot;at&quot;&gt;enableVerboseLogging&lt;/span&gt;()
.&lt;span class=&quot;at&quot;&gt;build&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; options &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;chrome&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Options&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// configure browser options ...&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; driver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;chrome&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;Driver&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createSession&lt;/span&gt;(options&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; service)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;前端自动化测试的道路是漫长的，对selenium的挖掘才刚刚开始。本文并没有解决引言中提到的两个问题，selenium-webdriver只是解决了第一步，即通过命令行来操作app，后面将继续学习，继续总结分享。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 15:02:00 +0000</pubDate>
<dc:creator>Young Dreamer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmhuang/p/8011815.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 Canvas 的 3D 碰撞检测 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8018626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8018626.html</guid>
<description>&lt;p&gt;这是公司大神写的一个放官网上给用户学习的例子，我一开始真的不知道这是在干嘛，就只是将三个形状图元组合在一起，然后可以同时旋转、放大缩小这个三个图形，点击“Animate”就能让中间的那一个图元单独绕着某一个点旋转，表单最上方的“Axis”真的完全不知道拿来干嘛用的，觉得好累赘，而且是官网的 Demo，也没有解释。。。所以我今天得任务就是完全剖析这个例子！&lt;img src=&quot;http://static.blog.csdn.net/xheditor/xheditor_emot/default/struggle.gif&quot; alt=&quot;奋斗&quot; data-cke-saved-src=&quot;http://static.blog.csdn.net/xheditor/xheditor_emot/default/struggle.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文例子：&lt;a href=&quot;http://www.hightopo.cn/demo/3drotate/3d-rotate.html&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;http://www.hightopo.cn/demo/3drotate/3d-rotate.html&quot;&gt;http://www.hightopo.cn/demo/3drotate/3d-rotate.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先让我们来看下这个案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201710/591709-20171020095805459-315445261.png&quot; alt=&quot;&quot; width=&quot;887&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看看如何操作这个 3d 交互模型，可以直接滑动“Rotation”的滑动条，你会看到 3d 和左下角的 2d 上的图元都会旋转，接着点击“Axis”中的任意一个值，然后点击“Animate”，你会看到中间这个图元会旋转，同时滑动“Range”的滑动条，这是控制你旋转的幅度的，如果你调到“0”，那么就不会旋转，调到“30”就会旋转30度，以此类推。接着调整“Reset”你会发现，不是完全刷新这个界面，而是局部刷新两边的圆柱，根据这两个圆柱与中间节点之间的关联而重置的。&lt;/p&gt;
&lt;p&gt;左下角的是整个 3d 场景内的俯视图，这样我们可以非常直观地看清图元的移动方向和位置。&lt;/p&gt;
&lt;p&gt;可能你会好奇这个是怎么俯视图是怎么放上去的？如果 3d 中的图元变化，这个俯视图中的图元也会跟着变化么？如何把右上角的 form 表单和左下角的视图又是怎么放的？如何只移动 3d 二把这两个固定在这边？或者你可能还有别的问题，在这里我会尽量清楚地解答，实在找不到答案可以去官网 &lt;a href=&quot;http://www.hightopo.cn/&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;http://www.hightopo.cn/&quot;&gt;HT for Web&lt;/a&gt; 查找你的问题。&lt;/p&gt;
&lt;p&gt;好了，基础就是先布局，布 3d 场景，HT 在提供方法方面算是非常细致的了，平时我们生成网格可能就要花费一段时间，又是基础代码，新手开发人员都能很快上手呢~短短几行代码就能创建一个 3d 场景，简直太快。。。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
dm = new&lt;span&gt; ht.DataModel();
g3d = new&lt;span&gt; ht.graph3d.Graph3dView(dm);
g3d.setGridVisible(true);//设置网格可视
g3d.setGridSize(m);//设置网格大小
g3d.setGridGap(w);//设置网格间距
g3d.setEye([-200, 150, 200]);//设置camera位置
g3d.getView().className = 'main'&lt;span&gt;;
document.body.appendChild(g3d.getView());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 HT 默认将所有组件都设置了 style “position:absolute”，所以当我们初始化这个组件之后，一定要在 style 中写上位置，并且将这个组件添加进你想要添加进的标签中，这个例子中，form 表单、2d 组件和3d 组件都互不依附，所以我们直接将这三个都添加进 body 中即可，还有一点值得注意的，所有 &lt;a href=&quot;http://www.hightopo.cn/&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;http://www.hightopo.cn/&quot;&gt;HT&lt;/a&gt; 组件的最根层都是一个 div，是通过组件的 getView() 函数获得的。所以我们如果要添加进 HTML 标签中，肯定也要是 HTML 标签才行。&lt;/p&gt;
&lt;p&gt;然后再界面的右上角放上 form 表单，放到右上角就直接设置 style 中的“top”“bottom”“left”“right”即可，2d 图同理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
formPane = new&lt;span&gt; ht.widget.FormPane();
formPane.setLabelAlign('right'&lt;span&gt;);
formPane.getView().className = 'formpane'&lt;span&gt;;
document.body.appendChild(formPane.getView());
formPane.addRow(['Rotation:'&lt;span&gt;, {
    id: 'rotation'&lt;span&gt;,
    slider: {
        min: -180&lt;span&gt;,
        max: 180&lt;span&gt;,
        value: 0&lt;span&gt;,
        step: 1&lt;span&gt;,
        onValueChanged: function&lt;span&gt;(e){
            node.setRotation(this.getValue() * Math.PI / 180&lt;span&gt;);
        }
    }
}], [60, 0.1]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为这个例子的 form 表单中的行数和内容比较多，所以我这边就只取了一个 form 表单自定义行的例子。这边的“id”只是为了能快速查找到这个元素，slider 是 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;HT form 表单&lt;/a&gt;自定义的一个方法，滑动条功能，设置了该属性后 HT 将根据属性值自动构建 ht.widger.Slider 对象，具体参数可以参考 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 表单手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;至于左下角的 2d 俯视图，这是通过跟 3d 共享同一个 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/core/datamodel/ht-datamodel-guide.html&quot; target=&quot;_blank&quot;&gt;dataModel&lt;/a&gt; 数据模型，只要我们绘制好了图形，然后添加进 dataModel 中去，不管是什么组件，只要调用了这个 dataModel 的都可以拥有dataModel 中的所有数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
g2d = new&lt;span&gt; ht.graph.GraphView(dm);
g2d.getView().className = 'g2d'&lt;span&gt;;
g2d.setEditable(true&lt;span&gt;);
document.body.appendChild(g2d.getView());
ht.Default.callLater(g2d.fitContent, g2d, [true, 50, true]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ht.Default.callLater(func, scope, args, delay) 获取全局下一个编号，其中 func 指的是回调函数，scope 指的是函数域，args 指的是函数参数列表，delay 则是延迟时间（毫秒）。这个函数可以在页面打开时回调 g2d.fitContent 函数，这个函数的作用域仅在 g2d 中，参数列表是 fitContent(anim, padding, notZoomIn) 函数的参数，这三个参数分别代表“是否使用动画”，“缩放后图元区域与拓扑边缘的距离”，以及“是否将最小缩放值限定为 1”。&lt;/p&gt;
&lt;p&gt;接着将 3d 中的图元添加进去，这里我不截取全部代码，只取一个比较特别的有趣的图元，中间外层的透明图元：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
shape = new&lt;span&gt; ht.Shape();
shape.s({
    'all.reverse.cull': true&lt;span&gt;,
    'all.color': 'rgba(0, 255, 0, 0.5)'&lt;span&gt;,
    'all.transparent': true&lt;span&gt;
});
shape.setThickness(2&lt;span&gt;);
dm.add(shape);
var resetShape = function&lt;span&gt;() {
    var cs = node.getCorners(10, 10&lt;span&gt;);
    cs.push(cs[0&lt;span&gt;]);
    shape.setPoints(cs);
    g3d.setBoundaries(ht.Default.toBoundaries(cs));
};
resetShape();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中有比较有趣的几点：&lt;/p&gt;
&lt;p&gt;1. 这边用了 node.getCorners() 这个方法，这个是获取四个点，对于 2d 来说就是左上、右上、右下、左下四个点；对于 3d 来说就是直接获取底面的四个“左上、右上、右下、左下”点，这个我反应了好一会儿才反应过来。。。并以这四个点为基础作为 shape 的 points。&lt;/p&gt;
&lt;p&gt;2. 这边还用了 setBoundaries(boundaries) 函数,借用 ht.Default.toBoundaries 函数来将不符合 setBoundaries 函数参数的格式转换成它需要的参数格式。虽然我认为这一行在这个例子中没有什么作用，但是还是让我好好学习了一把碰撞测试。&lt;/p&gt;
&lt;p&gt;我们在碰撞测试的时候经常要设置 g3d.setNear 函数，我实在没搞懂这个函数是拿来干嘛的，结果这个例子让我注意到，如果“我”的视线的近端截面位置也就是 setNear(1)，那么我能看到的就是比表面跟进 1 的距离，这个函数默认设置为 10，就算我们不设置这个值我们也能在 3d 中看到图元的内部去，刚刚我们介绍的 getCorners() 函数，其实它还有两个参数 xpadding 和 ypadding，分别代表“水平方向 padding”“垂直方向 padding”，也就是说，在我们获取四个角的同时，我们还能设置这四个角和边之间的 padding。只要将这个值设置得比 setNear 设置的大，我们就不会看到 3d 图元的内部中去了。&lt;/p&gt;
&lt;p&gt;我们还注意到似乎是“废代码”的一行： cs.push(cs[0])。这个完全不是废代码啊，帮了很大忙呢！在 HT 中，用 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/core/shape/ht-shape-guide.html&quot; target=&quot;_blank&quot;&gt;ht.Shape&lt;/a&gt; 创建的图元，只要你不手动设置绘制关闭，那么就会停留在你最终绘制的位置，所以我把最后的一个点又和第一个点连起来，那么就是一个封闭的图形了，否则你会看到后面缺了一部分，像这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201710/591709-20171020100817677-1071597255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在其他文章中也提到过 HT 封装了一些很方便的方法和事件，比如 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/core/datamodel/ht-datamodel-guide.html#ref_datamodel&quot; target=&quot;_blank&quot;&gt;dataModel#md&lt;/a&gt;，监听数据的属性的变化，这边我们用了 md 方法来判断只有中间这个 node 能够绕着一个点旋转，具体参考 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/core/datamodel/ht-datamodel-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 数据模型手册&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
dm.md(function&lt;span&gt;(e){
    if(e.data ===&lt;span&gt; node){
        if(e.property === 'rotation'&lt;span&gt;){
            formPane.v('rotation', 180 / Math.PI *&lt;span&gt; e.newValue);
        }
        resetShape();
    }
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这边我想要说一下“绕着一个点旋转”的功能，这边没有用我们自定义的 anchor 锚点，但是功能类似，通过获取 form 表单上选择的“left、right、front、back”来设置旋转中心点，&lt;a href=&quot;http://www.hightopo.cn/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;HT 中 form 表单&lt;/a&gt;通过 getValue(id) 简写成 v(id) 根据 id 获取对应 item 元素值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;formPane.addRow([
    {
         button: {
             label: 'Animate'&lt;span&gt;,
             onClicked: function&lt;span&gt;(){
                 var dx = 0&lt;span&gt;,
                 dy = 0&lt;span&gt;,
                 range = formPane.v('range') * Math.PI / 180&lt;span&gt;;
                 if(formPane.v('left'&lt;span&gt;)){
                     dx = -node.getWidth()/2;
&lt;span&gt;                 }
                 if(formPane.v('right'&lt;span&gt;)){
                     dx = node.getWidth()/2;
&lt;span&gt;                 }
                 if(formPane.v('back'&lt;span&gt;)){
                     dy = -node.getHeight()/2;
&lt;span&gt;                 }
                 if(formPane.v('front'&lt;span&gt;)){
                     dy = node.getHeight()/2;
&lt;span&gt;                 }
                 animate(node, range, dx, dy);
             }
         }
     },
     {
         button: {
             label: 'Reset'&lt;span&gt;,
             onClicked: function&lt;span&gt;(){
                 node.setRotation(0&lt;span&gt;);
             }
         }
     }
], [0.1, 0.1]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到这边你还是没懂？快去我们官网上从 &lt;a href=&quot;http://www.hightopo.cn/guide/guide/core/beginners/ht-beginners-guide.html&quot; target=&quot;_blank&quot;&gt;beginners&lt;/a&gt; 重头开始学习吧！&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 14:51:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8018626.html</dc:identifier>
</item>
<item>
<title>MLR算法[Paper笔记] - rongyux</title>
<link>http://www.cnblogs.com/rongyux/p/8018493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rongyux/p/8018493.html</guid>
<description>&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    MLR算法是alibaba在2012年提出并使用的广告点击率预估模型，2017年发表出来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    如下图，LR不能拟合非线性数据，MLR可以拟合非线性数据，因为划分-训练模式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221525599-546956448.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;讨论，非线性拟合能力：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    数据划分规则如下公式，特征分片数m=1时，退化为LR；上图MLR中m=4。m越大，模型的拟合能力越强，一般m=12。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221547974-1959132092.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;133&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;基础知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    优化方法：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    1）剃度下降：&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221613521-533402495.png&quot; alt=&quot;&quot; width=&quot;137&quot; height=&quot;19&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;span&gt;大小：一阶导数，方向：导数负方向。由目标函数的泰勒一阶展开式求得&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    2）牛顿法：&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221636646-491790021.png&quot; alt=&quot;&quot; width=&quot;134&quot; height=&quot;19&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　大小：一阶导数，方向：－海信矩阵的逆。由目标函数的泰勒二阶展开式求&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    3）拟牛顿法(LBFGS)：牛顿方向通过约等替换，每个样本保存下面三个参数：delta x ，delta剃度 和p：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221645990-178460106.png&quot; alt=&quot;&quot; width=&quot;261&quot; height=&quot;73&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    增量替换，计算牛顿方向D&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221701333-1654644344.png&quot; alt=&quot;&quot; width=&quot;280&quot; height=&quot;256&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    LBFGS方法通过一阶导数中值定理，避免了计算海信矩阵（复杂度太大）。但是L1范数不能求导，所以需要OWLQN方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    4）OWLQN：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    (1)次梯度定义如下，&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221719255-1368949812.png&quot; alt=&quot;&quot; width=&quot;274&quot; height=&quot;65&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;   (2)不可导点取左or右次梯度，如下 &lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221730068-1248592061.png&quot; alt=&quot;&quot; width=&quot;238&quot; height=&quot;99&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    直观解释，当你打算用左偏导时，说明是在负象限，因此要加上一个负值，使得更新之后参数更往负象限前进，这样就避免了跨象限；当打算用右偏导数时，说明在正象限，一次要加上一个正值，使得更新之后参数更往正象限前进，从而避免跨象限；否则，只能直接设置subgradient为0。  &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;   (3)象限搜索line search：&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221744740-1502350922.png&quot; alt=&quot;&quot; width=&quot;204&quot; height=&quot;65&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    x不在0点时，line search在x_i所在象限搜索；如果模型参数在0点，就要在(2)次梯度约束的象限内进行line search.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;MLR算法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221758958-1683207791.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;351&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;算法公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;0计算边界下降方向d：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221820708-1688785842.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;1计算梯度大小：theta在0处不可导，取sign符号函数dij。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221833193-575301969.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;2计算最终下降方向p：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221845818-1256214325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;3象限内梯度下降，同OWLQN，line search：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221858240-1082187416.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;paper介绍，MLR与LBFGS有三点不同：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;1）OWLQN需要计算次梯度，MLR需要计算方向导数；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;2）计算最终下降方向p时，MLR也要进行象限约束；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;3）象限搜索line search，与OWLQN相似。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;分布式框架实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;分布式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221917286-954550960.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;User特征共享&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221930880-796759332.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;    个人理解是为了加快运算速度，具体特征划分如下所示。其中，c是用户特征，nc是非用户特征。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210221942505-2083395803.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;实验结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;span&gt;实验截图略，具体图表可以查看参考&lt;/span&gt;paper&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/751250/201712/751250-20171210222000958-28028334.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;纵坐标是内存使用率，特征共享技巧使速度提高了三倍。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;参考&lt;/span&gt;paper：Learning Piece-wise Linear Models from Large Scale Data for Ad Click Prediction&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Dec 2017 14:22:00 +0000</pubDate>
<dc:creator>rongyux</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rongyux/p/8018493.html</dc:identifier>
</item>
</channel>
</rss>