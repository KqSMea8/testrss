<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>线程池 BlockingQueue synchronized - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8319183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8319183.html</guid>
<description>&lt;p&gt;本章从线程池到阻塞队列BlockingQueue。从BlockingQueue到synchronized 和 volatile关键字。用wait，notify线程之间的通讯实现BlockingQueue队列。将这些零碎的知识整合在一起。如下图所示，都是本章知识点。之所以写这篇博客，是因为前段时间看了一篇关于&quot;一名3年工作经验的程序员应该具备的技能&quot;文章，倍受打击。&lt;/p&gt;
&lt;p&gt;学习流程图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/806956/201801/806956-20180120151328678-189155379.png&quot; alt=&quot;学习流程图&quot;/&gt;&lt;br/&gt;技术：Executors，BlockingQueue，synchronized，volatile，wait，notify&lt;br/&gt;说明：文章学习思路：线程池----&amp;gt;队列----&amp;gt;关键字----&amp;gt;死锁----&amp;gt;线程池实战&lt;br/&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/ThreadBase&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/ThreadBase&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程池&quot;&gt;线程池&lt;/h2&gt;
&lt;p&gt;线程池，顾名思义存放线程的池子，可以类比数据库的连接池。因为频繁地创建和销毁线程会给服务器带来很大的压力。若能将创建的线程不再销毁而是存放在池中等待下一个任务使用，可以不仅减少了创建和销毁线程所用的时间，提高了性能，同时还减轻了服务器的压力。&lt;/p&gt;
&lt;h3 id=&quot;线程池的使用&quot;&gt;线程池的使用&lt;/h3&gt;
&lt;p&gt;初始化线程池有五个核心参数，分别是 &lt;strong&gt;corePoolSize&lt;/strong&gt;, &lt;strong&gt;maximumPoolSize&lt;/strong&gt;, &lt;strong&gt;keepAliveTime&lt;/strong&gt;, &lt;strong&gt;unit&lt;/strong&gt;, &lt;strong&gt;workQueue&lt;/strong&gt;。还有两个默认参数 threadFactory, handler&lt;br/&gt;&lt;strong&gt;corePoolSize&lt;/strong&gt;：线程池初始核心线程数。初始化线程池的时候，池内是没有线程，只有在执行任务的时会创建线程。&lt;br/&gt;&lt;strong&gt;maximumPoolSize&lt;/strong&gt;：线程池允许存在的最大线程数。若超过该数字，默认提示&lt;code&gt;RejectedExecutionException&lt;/code&gt;异常&lt;br/&gt;&lt;strong&gt;keepAliveTime&lt;/strong&gt;：当前线程数大于核心线程时，该参数生效，其目的是终止多余的空闲线程等待新任务的最长时间。即指定时间内将还未接收任务的线程销毁。&lt;br/&gt;&lt;strong&gt;unit&lt;/strong&gt;：keepAliveTime 的时间单位&lt;br/&gt;&lt;strong&gt;workQueue&lt;/strong&gt;：缓存任务的的队列，一般采用LinkedBlockingQueue。&lt;br/&gt;&lt;strong&gt;threadFactory&lt;/strong&gt;：执行程序创建新线程时使用的工厂，一般采用默认值。&lt;br/&gt;&lt;strong&gt;handler&lt;/strong&gt;：超出线程范围和队列容量而使执行被阻塞时所使用的处理程序，一般采用默认值。&lt;/p&gt;
&lt;h3 id=&quot;线程池工作流程&quot;&gt;线程池工作流程&lt;/h3&gt;
&lt;p&gt;开始，游泳馆来了一名学员，于是馆主安排一个教练负责培训这名学员；&lt;br/&gt;然后，游泳馆来了六名学员，可馆主只招了五名教练，于是有一名学员被安排到休息室等待；&lt;br/&gt;后来，游泳馆来了十六名学员，休息室已经满了，馆主核算了开支，预计最多可招十名教练；&lt;br/&gt;最后，游泳馆只来了十名学员，馆主对教练说，如果半天内接不到学员的教练就可以走了；&lt;br/&gt;结果，游泳馆没有学员，关闭了。&lt;br/&gt;在接收任务前，线程池内是没有线程。只有当任务来了才开始新建线程。当任务数大于核心线程数时，任务进入队列中等待。若队列满了，则线程池新增线程直到最大线程数。再超过则会执行拒绝策略。&lt;/p&gt;
&lt;h3 id=&quot;线程池的三种关闭&quot;&gt;线程池的三种关闭&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;shutdown&lt;/strong&gt;： 线程池不再接收任务，等待线程池中所有任务完成后，关闭线程池。&lt;strong&gt;常用&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;shutdownNow&lt;/strong&gt;： 线程池不再接收任务，忽略队列中的任务，尝试中断正在执行的任务，返回未执行任务列表，关闭线程池。&lt;strong&gt;慎用&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;awaitTermination&lt;/strong&gt;： 线程池可以继续接收任务，当任务都完成后，或者超过设置的时间后，关闭线程池。方法是阻塞的，&lt;strong&gt;考虑使用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程池的种类&quot;&gt;线程池的种类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1 newSingleThreadExecutor() 单线程线程池&lt;/strong&gt;&lt;br/&gt;初始线程数和允许最大线程数都是一，keepAliveTime 也就失效了，队列是无界阻塞队列。该线程池的主要作用是负责缓存任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 newFixedThreadPool(n) 固定大小线程池&lt;/strong&gt;&lt;br/&gt;初始线程数和允许最大线程数相同，且大小自定义，keepAliveTime 也就失效了，队列是无界阻塞队列。符合大部分业务要求，常用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 newCachedThreadPool() 无缓存无界线程池&lt;/strong&gt;&lt;br/&gt;初始线程数为零，最大线程数为无穷大，keepAliveTime 60秒类终止空闲线程，队列是无缓存无界队列。适合任务数不多的场景，慎用。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ArrayBlockingQueue;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ExecutorService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.Executors;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ThreadPoolExecutor;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 线程池&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 优势，类比数据库的连接池&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 1. 频繁的创建和销毁线程会给服务器带来很大的压力&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 2. 若创建的线程不销毁而是留在线程池中等待下次使用，则会很大地提高效率也减轻了服务器的压力&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 三种workQueue策略&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 直接提交 SynchronousQueue&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 无界队列 LinkedBlockingQueue&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 有界队列 ArrayBlockingQueue&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 四种拒绝策略&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * AbortPolicy : JDK默认，超出 MAXIMUM_POOL_SIZE 放弃任务抛异常 RejectedExecutionException&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * CallerRunsPolicy : 尝试直接调用被拒绝的任务，若线程池被关闭，则丢弃任务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * DiscardOldestPolicy : 放弃队列最前面的任务，然后重新尝试执被拒绝的任务。若线程池被关闭，则丢弃任务&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * DiscardPolicy : 放弃不能执行的任务但不抛异常&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ThreadPoolExecutorStu {
    
    &lt;span class=&quot;co&quot;&gt;// 线程池中初始线程个数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Integer CORE_POOL_SIZE = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 线程池中允许的最大线程数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Integer MAXIMUM_POOL_SIZE = &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 当线程数大于初始线程时。终止多余的空闲线程等待新任务的最长时间&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Long KEEP_ALIVE_TIME = 10L;
    &lt;span class=&quot;co&quot;&gt;// 任务缓存队列 ，即线程数大于初始线程数时先进入队列中等待，此数字可以稍微设置大点，避免线程数超过最大线程数时报错。或者直接用无界队列&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt; WORK_QUEUE = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        Long start = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * ITDragonThreadPoolExecutor 耗时 1503&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * ITDragonFixedThreadPool 耗时 505&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * ITDragonSingleThreadExecutor 语法问题报错，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * ITDragonCachedThreadPool 耗时506&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 推荐使用自定义线程池，或newFixedThreadPool(n)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        ThreadPoolExecutor threadPoolExecutor = &lt;span class=&quot;fu&quot;&gt;ITDragonThreadPoolExecutor&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;; i++) {   &lt;span class=&quot;co&quot;&gt;// 执行8个任务，若超过MAXIMUM_POOL_SIZE则会报错 RejectedExecutionException&lt;/span&gt;
            MyRunnableTest myRunnable = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyRunnableTest&lt;/span&gt;(i);
            threadPoolExecutor.&lt;span class=&quot;fu&quot;&gt;execute&lt;/span&gt;(myRunnable);
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;线程池中现在的线程数目是：&quot;&lt;/span&gt;+threadPoolExecutor.&lt;span class=&quot;fu&quot;&gt;getPoolSize&lt;/span&gt;()+&lt;span class=&quot;st&quot;&gt;&quot;,  队列中正在等待执行的任务数量为：&quot;&lt;/span&gt;+  
                    threadPoolExecutor.&lt;span class=&quot;fu&quot;&gt;getQueue&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());
        }
        &lt;span class=&quot;co&quot;&gt;// 关掉线程池 ，并不会立即停止(停止接收外部的submit任务，等待内部任务完成后才停止)，推荐使用。 与之对应的是shutdownNow，不推荐使用&lt;/span&gt;
        threadPoolExecutor.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 阻塞等待30秒关掉线程池，返回true表示已经关闭。和shutdown不同，它可以接收外部任务，并且还阻塞。这里为了方便统计时间，所以选择阻塞等待关闭。&lt;/span&gt;
            threadPoolExecutor.&lt;span class=&quot;fu&quot;&gt;awaitTermination&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;耗时 : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - start));
    }
    
    &lt;span class=&quot;co&quot;&gt;// 自定义线程池，开发推荐使用&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ThreadPoolExecutor &lt;span class=&quot;fu&quot;&gt;ITDragonThreadPoolExecutor&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// 构建一个，初始线程数量为3，最大线程数据为8，等待时间10分钟 ，队列长度为5 的线程池&lt;/span&gt;
        ThreadPoolExecutor threadPoolExecutor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(
                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MINUTES&lt;/span&gt;, WORK_QUEUE);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; threadPoolExecutor;
    }
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 固定大小线程池&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * corePoolSize初始线程数和maximumPoolSize最大线程数一样，keepAliveTime参数不起作用，workQueue用的是无界阻塞队列&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ThreadPoolExecutor &lt;span class=&quot;fu&quot;&gt;ITDragonFixedThreadPool&lt;/span&gt;() {
        ExecutorService executor = Executors.&lt;span class=&quot;fu&quot;&gt;newFixedThreadPool&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;);
        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; threadPoolExecutor;
    }
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 单线程线程池&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 等价与Executors.newFixedThreadPool(1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ThreadPoolExecutor &lt;span class=&quot;fu&quot;&gt;ITDragonSingleThreadExecutor&lt;/span&gt;() {
        ExecutorService executor = Executors.&lt;span class=&quot;fu&quot;&gt;newSingleThreadExecutor&lt;/span&gt;();
        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; threadPoolExecutor;
    }
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 无界线程池&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * corePoolSize 初始线程数为零&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * maximumPoolSize 最大线程数无穷大&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * keepAliveTime 60秒类将没有被用到的线程终止&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * workQueue SynchronousQueue 队列，无容量，来任务就直接新增线程&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 不推荐使用&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ThreadPoolExecutor &lt;span class=&quot;fu&quot;&gt;ITDragonCachedThreadPool&lt;/span&gt;() {
        ExecutorService executor = Executors.&lt;span class=&quot;fu&quot;&gt;newCachedThreadPool&lt;/span&gt;();
        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; threadPoolExecutor;
    }
    
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyRunnableTest &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Integer num;    &lt;span class=&quot;co&quot;&gt;// 正在执行的任务数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyRunnableTest&lt;/span&gt;(Integer num) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;num&lt;/span&gt; = num;
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;正在执行的MyRunnable &quot;&lt;/span&gt; + num);
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;// 模拟执行事务需要耗时&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyRunnable &quot;&lt;/span&gt; + num + &lt;span class=&quot;st&quot;&gt;&quot;执行完毕&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;队列&quot;&gt;队列&lt;/h2&gt;
&lt;p&gt;队列，是一种数据结构。大部分的队列都是以FIFO（先进先出）的方式对各个元素进行排序的（PriorityBlockingQueue是根据优先级排序的）。队列的头移除元素，队列的末尾插入元素。插入的元素建议不能为null。Queue主要分两类，一类是高性能队列 ConcurrentLinkedQueue；一类是阻塞队列 BlockingQueue。本章重点介绍BlockingQueue&lt;/p&gt;
&lt;h3 id=&quot;concurrentlinkedqueue&quot;&gt;ConcurrentLinkedQueue&lt;/h3&gt;
&lt;p&gt;ConcurrentLinkedQueue性能好于BlockingQueue。是基于链接节点的无界限线程安全队列。该队列的元素遵循先进先出的原则。不允许null元素。&lt;/p&gt;
&lt;h3 id=&quot;blockingqueue&quot;&gt;BlockingQueue&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;： 基于数组的阻塞队列，在内部维护了一个定长数组，以便缓存队列中的数据对象。并没有实现读写分离，也就意味着生产和消费不能完全并行。是一个有界队列&lt;br/&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;：基于列表的阻塞队列，在内部维护了一个数据缓冲队列（由一个链表构成），实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作的完全并行运行。是一个无界队列，&lt;br/&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;： 没有缓冲的队列，生存者生产的数据直接会被消费者获取并消费。若没有数据就直接调用出栈方法则会报错。&lt;/p&gt;
&lt;p&gt;三种队列使用场景&lt;br/&gt;newFixedThreadPool 线程池采用的队列是LinkedBlockingQueue。其优点是无界可缓存，内部实现读写分离，并发的处理能力高于ArrayBlockingQueue&lt;br/&gt;newCachedThreadPool 线程池采用的队列是SynchronousQueue。其优点就是无缓存，接收到的任务均可直接处理，再次强调，慎用！&lt;br/&gt;并发量不大，服务器性能较好，可以考虑使用SynchronousQueue。&lt;br/&gt;并发量较大，服务器性能较好，可以考虑使用LinkedBlockingQueue。&lt;br/&gt;并发量很大，服务器性能无法满足，可以考虑使用ArrayBlockingQueue。系统的稳定最重要。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ArrayBlockingQueue;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ConcurrentLinkedQueue;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.LinkedBlockingQueue;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.SynchronousQueue;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.junit.Test;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 阻塞队列&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * ArrayBlockingQueue        ：有界&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * LinkedBlockingQueue       ：无界&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * SynchronousQueue          ：无缓冲直接用&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 非阻塞队列&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * ConcurrentLinkedQueue     ：高性能&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonQueue {
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * ArrayBlockingQueue : 基于数组的阻塞队列实现，在内部维护了一个定长数组，以便缓存队列中的数据对象。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 内部没有实现读写分离，生产和消费不能完全并行，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 长度是需要定义的，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 可以指定先进先出或者先进后出，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 是一个有界队列。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonArrayBlockingQueue&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {  
        ArrayBlockingQueue&amp;lt;String&amp;gt; array = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;String&amp;gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 可以尝试 队列长度由3改到5  &lt;/span&gt;
        array.&lt;span class=&quot;fu&quot;&gt;offer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;offer 插入数据方法---成功返回true 否则返回false&quot;&lt;/span&gt;);  
        array.&lt;span class=&quot;fu&quot;&gt;offer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;offer 3秒后插入数据方法&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;);  
        array.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;put 插入数据方法---但超出队列长度则阻塞等待，没有返回值&quot;&lt;/span&gt;);  
        array.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;add 插入数据方法---但超出队列长度则提示 java.lang.IllegalStateException&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//  java.lang.IllegalStateException: Queue full  &lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(array);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(array.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;还剩元素 : &quot;&lt;/span&gt; + array);   &lt;span class=&quot;co&quot;&gt;// 从头部取出元素，并从队列里删除，若队列为null则一直等待&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(array.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;还剩元素 : &quot;&lt;/span&gt; + array);   &lt;span class=&quot;co&quot;&gt;// 从头部取出元素，并从队列里删除，执行poll 后 元素减少一个&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(array.&lt;span class=&quot;fu&quot;&gt;peek&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;还剩元素 : &quot;&lt;/span&gt; + array);   &lt;span class=&quot;co&quot;&gt;// 从头部取出元素，执行peek 不移除元素&lt;/span&gt;
    }
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * LinkedBlockingQueue：基于列表的阻塞队列，在内部维护了一个数据缓冲队列（该队列由一个链表构成）。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 其内部实现采用读写分离锁，能高效的处理并发数据，生产者和消费者操作的完全并行运行&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 可以不指定长度，&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 是一个无界队列。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonLinkedBlockingQueue&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        LinkedBlockingQueue&amp;lt;String&amp;gt; queue = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;String&amp;gt;();
        queue.&lt;span class=&quot;fu&quot;&gt;offer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;1.无界队列&quot;&lt;/span&gt;);
        queue.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2.语法和ArrayBlockingQueue差不多&quot;&lt;/span&gt;);
        queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;3.实现采用读写分离&quot;&lt;/span&gt;);
        List&amp;lt;String&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;返回截取的长度 : &quot;&lt;/span&gt; + queue.&lt;span class=&quot;fu&quot;&gt;drainTo&lt;/span&gt;(list, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;list : &quot;&lt;/span&gt; + list);
    }
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * SynchronousQueue：没有缓冲的队列，生存者生产的数据直接会被消费者获取并消费。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonSynchronousQueue&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; SynchronousQueue&amp;lt;String&amp;gt; queue = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;String&amp;gt;();
        Thread thread1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;take , 在没有取到值之前一直处理阻塞  : &quot;&lt;/span&gt; + queue.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;());
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                }
            }
        });
        thread1.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        Thread thread2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                queue.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;进值!!!&quot;&lt;/span&gt;);
            }
        });
        thread2.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();    
    }

    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * ConcurrentLinkedQueue：是一个适合高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，性能好于BlockingQueue。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 它是一个基于链接节点的无界限线程安全队列。该队列的元素遵循先进先出的原则。头是最先加入的，尾是最后加入的，不允许null元素。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 无阻塞队列，没有 put 和 take 方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonConcurrentLinkedQueue&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        ConcurrentLinkedQueue&amp;lt;String&amp;gt; queue = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentLinkedQueue&amp;lt;String&amp;gt;();  
        queue.&lt;span class=&quot;fu&quot;&gt;offer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;1.高性能无阻塞&quot;&lt;/span&gt;);
        queue.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2.无界队列&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(queue);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(queue.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;  : &quot;&lt;/span&gt; + queue);   &lt;span class=&quot;co&quot;&gt;// 从头部取出元素，并从队列里删除，执行poll 后 元素减少一个&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(queue.&lt;span class=&quot;fu&quot;&gt;peek&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;  : &quot;&lt;/span&gt; + queue);   &lt;span class=&quot;co&quot;&gt;// 从头部取出元素，执行peek 不移除元素&lt;/span&gt;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;关键字&quot;&gt;关键字&lt;/h2&gt;
&lt;p&gt;关键字是为了线程安全服务的，哪什么是线程安全呢？&lt;strong&gt;当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的&lt;/strong&gt;。&lt;br/&gt;线程安全的两个特性：&lt;strong&gt;原子性&lt;/strong&gt;和&lt;strong&gt;可见性&lt;/strong&gt;。synchronized 同步，原子性。volatile 可见性。wait，notify 负责多个线程之间的通信。&lt;/p&gt;
&lt;h3 id=&quot;synchronized&quot;&gt;synchronized&lt;/h3&gt;
&lt;p&gt;synchronized 可以在任意对象及方法上加锁，而加锁的这段代码称为&quot;互斥区&quot;或&quot;临界区&quot;，若一个线程想要执行synchronized修饰的代码块，首先要&lt;br/&gt;step1 尝试获得锁&lt;br/&gt;step2 如果拿到锁，执行synchronized代码体内容&lt;br/&gt;step3 如果拿不到锁，这个线程就会不断的尝试获得这把锁，直到拿到为止，而且是多个线程同时去竞争这把锁。&lt;br/&gt;注*（线程多了也就是会出现锁竞争的问题，多个线程执行的顺序是按照CPU分配的先后顺序而定的，而并非代码执行的先后顺序）&lt;/p&gt;
&lt;p&gt;synchronized 可以修饰方法，修饰代码块，这些都是对象锁。若和static一起使用，则升级为类锁。&lt;br/&gt;synchronized 锁是可以重入的，当一个线程得到了一个对象的锁后，再次请求此对象时是可以再次得到该对象的锁。锁重入的机制，也支持在父子类继承的场景。&lt;br/&gt;synchronized 同步异步，一个线程得到了一个对象的锁后，其他线程是可以执行非加锁的方法(异步)。但是不能执行其他加锁的方法(同步)。&lt;br/&gt;synchronized 锁异常，当一个线程执行的代码出现异常时，其所持有的锁会自动释放。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * synchronized 关键字，可以修饰方法，也可以修饰代码块。建议采用后者，通过减小锁的粒度，以提高系统性能。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * synchronized 关键字，如果以字符串作为锁，请注意String常量池的缓存功能和字符串改变后锁是否的情况。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * synchronized 锁重入，当一个线程得到了一个对象的锁后，再次请求此对象时是可以再次得到该对象的锁。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * synchronized 同异步，一个线程获得锁后，另外一个线程可以执行非synchronized修饰的方法，这是异步。若另外一个线程执行任何synchronized修饰的方法则需要等待，这是同步&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * synchronized 类锁，用static + synchronized 修饰则表示对整个类进行加锁&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonSynchronized {
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;thisLock&lt;/span&gt; () {  &lt;span class=&quot;co&quot;&gt;// 对象锁  &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;) {  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;this 对象锁!&quot;&lt;/span&gt;);  
        }  
    }  
      
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;classLock&lt;/span&gt; () {  &lt;span class=&quot;co&quot;&gt;// 类锁  &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (ITDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;) {  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;class 类锁!&quot;&lt;/span&gt;);  
        }  
    }  
      
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object lock = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object();  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;objectLock&lt;/span&gt; () {  &lt;span class=&quot;co&quot;&gt;// 任何对象锁  &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;object 任何对象锁!&quot;&lt;/span&gt;);  
        }  
    }  
      
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;stringLock&lt;/span&gt; () {  &lt;span class=&quot;co&quot;&gt;// 字符串锁，注意String常量池的缓存功能  &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;string&quot;&lt;/span&gt;) { &lt;span class=&quot;co&quot;&gt;// 用 new String(&quot;string&quot;)  t4 和 t5 同时进入。用string t4完成后，t5在开始&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; i++) {  
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;thread : &quot;&lt;/span&gt; + Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; stringLock !&quot;&lt;/span&gt;);  
                    Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;);       
                }  
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {  
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
            }  
        }  
    }  
      
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String strLock = &lt;span class=&quot;st&quot;&gt;&quot;lock&quot;&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// 字符串锁改变  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;changeStrLock&lt;/span&gt; () {  
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (strLock) {  
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;thread : &quot;&lt;/span&gt; + Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; changeLock start !&quot;&lt;/span&gt;);  
                strLock = &lt;span class=&quot;st&quot;&gt;&quot;changeLock&quot;&lt;/span&gt;;  
                Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;);  
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;thread : &quot;&lt;/span&gt; + Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; changeLock end !&quot;&lt;/span&gt;);  
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {  
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
            }  
        }  
    }  
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;method1&lt;/span&gt;() {  &lt;span class=&quot;co&quot;&gt;// 锁重入&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;^^^^^^^^^^^^^^^^^^^^ method1&quot;&lt;/span&gt;);  
        &lt;span class=&quot;fu&quot;&gt;method2&lt;/span&gt;();  
    }  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;method2&lt;/span&gt;() {  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;-------------------- method2&quot;&lt;/span&gt;);  
        &lt;span class=&quot;fu&quot;&gt;method3&lt;/span&gt;();  
    }  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;method3&lt;/span&gt;() {  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;******************** method3&quot;&lt;/span&gt;);  
    }  
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;syncMethod&lt;/span&gt;() {  
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; synchronized method!&quot;&lt;/span&gt;);  
            Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);  
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {  
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
        }  
    }  
      
    &lt;span class=&quot;co&quot;&gt;// 若次方法也加上了synchronized，就必须等待t1线程执行完后，t2才能调用，两个synchronized块之间具有互斥性，synchronized块获得的是一个对象锁，锁定的是整个对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;asyncMethod&lt;/span&gt;() {  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; asynchronized method!&quot;&lt;/span&gt;);  
    } 
      
    &lt;span class=&quot;co&quot;&gt;// static + synchronized 修饰则表示类锁，打印的结果是thread1线程先执行完，然后在执行thread2线程。若没有被static修饰，则thread1和 thread2几乎同时执行，同时结束&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;classLock&lt;/span&gt;(String args) {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(args + &lt;span class=&quot;st&quot;&gt;&quot;start......&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(args + &lt;span class=&quot;st&quot;&gt;&quot;end......&quot;&lt;/span&gt;);
    }
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {  
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ITDragonSynchronized itDragonSynchronized = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonSynchronized&lt;/span&gt;();  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------------------- synchronized 代码块加锁 -------------------------&quot;&lt;/span&gt;);
        Thread thread1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;thisLock&lt;/span&gt;();  
            }  
        });  
        Thread thread2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;classLock&lt;/span&gt;();  
            }  
        });  
        Thread thread3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;objectLock&lt;/span&gt;();  
            }  
        });  
        thread1.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
        thread2.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
        thread3.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------------------- synchronized 字符串加锁 -------------------------&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 如果字符串锁，用new String(&quot;string&quot;) t4，t5线程是可以获取锁的，如果直接使用&quot;string&quot; ，若锁不释放，t5线程一直处理等待中  &lt;/span&gt;
        Thread thread4 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;stringLock&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t4&quot;&lt;/span&gt;);  
        Thread thread5 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;stringLock&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t5&quot;&lt;/span&gt;);  
        thread4.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
        thread5.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
          
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------------------- synchronized 字符串变锁 -------------------------&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 字符串变了，锁也会改变，导致t7线程在t6线程未结束后变开始执行,但一个对象的属性变了，不影响这个对象的锁。  &lt;/span&gt;
        Thread thread6 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;changeStrLock&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t6&quot;&lt;/span&gt;);  
        Thread thread7 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;changeStrLock&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t7&quot;&lt;/span&gt;);  
        thread6.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
        thread7.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(); 
        
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------------------- synchronized 锁重入 -------------------------&quot;&lt;/span&gt;);
        Thread thread8 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;method1&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t8&quot;&lt;/span&gt;);  
        thread8.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(); 
        Thread thread9 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                SunClass sunClass = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SunClass&lt;/span&gt;();  
                sunClass.&lt;span class=&quot;fu&quot;&gt;sunMethod&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t9&quot;&lt;/span&gt;);  
        thread9.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(); 
        
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------------------- synchronized 同步异步 -------------------------&quot;&lt;/span&gt;);
        Thread thread10 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;syncMethod&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t10&quot;&lt;/span&gt;);  
        Thread thread11 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                itDragonSynchronized.&lt;span class=&quot;fu&quot;&gt;asyncMethod&lt;/span&gt;();  
            }  
        }, &lt;span class=&quot;st&quot;&gt;&quot;t11&quot;&lt;/span&gt;);  
        thread10.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(); 
        thread11.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;(); 
        
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------------------- synchronized 同步异步 -------------------------&quot;&lt;/span&gt;);
        ITDragonSynchronized classLock1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonSynchronized&lt;/span&gt;();
        ITDragonSynchronized classLock2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonSynchronized&lt;/span&gt;();
        Thread thread12 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                classLock1.&lt;span class=&quot;fu&quot;&gt;classLock&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classLock1&quot;&lt;/span&gt;);
            }
        });
        thread12.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        Thread thread13 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                classLock2.&lt;span class=&quot;fu&quot;&gt;classLock&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classLock2&quot;&lt;/span&gt;);
            }
        });
        thread13.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
    }  
    
    &lt;span class=&quot;co&quot;&gt;// 有父子继承关系的类，如果都使用了synchronized 关键字，也是线程安全的。  &lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FatherClass {  
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fatherMethod&lt;/span&gt;(){  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;#################### fatherMethod&quot;&lt;/span&gt;);  
        }  
    }  
      
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SunClass &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; FatherClass{  
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sunMethod&lt;/span&gt;() {  
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;@@@@@@@@@@@@@@@@@@@@ sunMethod&quot;&lt;/span&gt;);  
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;fatherMethod&lt;/span&gt;();
        }  
    }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;volatile&quot;&gt;volatile&lt;/h3&gt;
&lt;p&gt;volatile 关键字虽然不具备synchronized关键字的原子性（同步）但其主要作用就是使变量在多个线程中可见。也就是可见性。&lt;br/&gt;用法很简单，直接用来修饰变量。因为其不具备原子性，可以用Atomic类代替。美中不足的是多个Atomic类也不具备原子性，所以还需要synchronized来修饰。&lt;br/&gt;volatile 关键字工作原理&lt;br/&gt;每个线程都有自己的工作内存，如果线程需要用到一个变量的时，会从主内存拷贝一份到自己的工作内存中。从而提高了效率。每次执行完线程后再将变量从工作内存同步回主内存中。&lt;br/&gt;这样就存在一个问题，变量在不同线程中可能存在不同的值。如果用volatile 关键字修饰变量，则会让线程的执行引擎直接从主内存中获取值。&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/806956/201801/806956-20180120151052881-1306198561.png&quot; alt=&quot;volatile关键字&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.atomic.AtomicInteger;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * volatile 关键字主要作用就是使变量在多个线程中可见。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * volatile 关键字不具备原子性，但Atomic类是具备原子性和可见性。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 美中不足的是多个Atomic类不具备原子性，还是需要synchronized 关键字帮忙。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonVolatile{
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; flag = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count;   
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; AtomicInteger atomicCount = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 加 static 是为了避免每次实例化对象时初始值为零&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;//  测试volatile 关键字的可见性&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;volatileMethod&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;thread start !&quot;&lt;/span&gt;);  
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (flag) {  &lt;span class=&quot;co&quot;&gt;// 如果flag为true则一直处于阻塞中，&lt;/span&gt;
        }  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;thread end !&quot;&lt;/span&gt;);
    }
    
    &lt;span class=&quot;co&quot;&gt;//  验证volatile 关键字不具备原子性&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;volatileCountMethod&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {
            &lt;span class=&quot;co&quot;&gt;// 第一个线程还未将count加到10的时候，就可能被另一个线程开始修改。可能会导致最后一次打印的值不是1000&lt;/span&gt;
            count++ ;   
        }  
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; count;
    }
    
    &lt;span class=&quot;co&quot;&gt;//  验证Atomic类具有原子性&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;atomicCountMethod&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {  
            atomicCount.&lt;span class=&quot;fu&quot;&gt;incrementAndGet&lt;/span&gt;();  
        }  
        &lt;span class=&quot;co&quot;&gt;// 若最后一次打印为1000则表示具备原子性，中间打印的信息可能是受println延迟影响。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; atomicCount.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();&lt;span class=&quot;co&quot;&gt;// 若最后一次打印为1000则表示具备原子性&lt;/span&gt;
    }
    
    &lt;span class=&quot;co&quot;&gt;// 验证多个 Atomic类操作不具备原子性，加synchronized关键字修饰即可&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;multiAtomicMethod&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        atomicCount.&lt;span class=&quot;fu&quot;&gt;addAndGet&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        atomicCount.&lt;span class=&quot;fu&quot;&gt;addAndGet&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);
        atomicCount.&lt;span class=&quot;fu&quot;&gt;addAndGet&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;);
        atomicCount.&lt;span class=&quot;fu&quot;&gt;addAndGet&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;); 
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; atomicCount.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;//若具备原子性，则返回的结果一定都是10的倍数，需多次运行才能看到结果&lt;/span&gt;
    }
  
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * volatile 关键字可见性原因&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 这里有两个线程  ：一个是main的主线程，一个是thread的子线程&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * jdk线程工作流程    ：为了提高效率，每个线程都有一个工作内存，将主内存的变量拷贝一份到工作内存中。线程的执行引擎就直接从工作内存中获取变量。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * So 问题来了      ：thread线程用的是自己的工作内存，主线程将变量修改后，thread线程不知道。这就是数据不可见的问题。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 解决方法     ：变量用volatile 关键字修饰后，线程的执行引擎就直接从主内存中获取变量。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException {  
&lt;span class=&quot;co&quot;&gt;//      测试volatile 关键字的可见性&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;/*ITDragonVolatile itDragonVolatile = new ITDragonVolatile();  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        Thread thread = new Thread(itDragonVolatile);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        thread.start();&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        Thread.sleep(1000);  // 等线程启动了，再设置值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        itDragonVolatile.setFlag(false);  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        System.out.println(&quot;flag : &quot; + itDragonVolatile.isFlag());*/&lt;/span&gt;  
        
&lt;span class=&quot;co&quot;&gt;//      验证volatile 关键字不具备原子性 和 Atomic类具有原子性&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ITDragonVolatile itDragonVolatile = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonVolatile&lt;/span&gt;();
        List&amp;lt;Thread&amp;gt; threads = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Thread&amp;gt;();
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;; i++) {
            threads.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                    &lt;span class=&quot;co&quot;&gt;// 中间打印的信息可能是受println延迟影响，请看最后一次打印的结果&lt;/span&gt;
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(itDragonVolatile.&lt;span class=&quot;fu&quot;&gt;multiAtomicMethod&lt;/span&gt;());
                }
            }));
        }
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(Thread thread : threads){
            thread.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        }
    }  
      
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isFlag&lt;/span&gt;() {  
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; flag;  
    }  
  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setFlag&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; flag) {  
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;flag&lt;/span&gt; = flag;  
    }  

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;waitnotify&quot;&gt;wait，notify&lt;/h3&gt;
&lt;p&gt;使用 wait/ notify 方法实现线程间的通信，模拟BlockingQueue队列。有两点需要注意：&lt;br/&gt;1）wait 和 notify 必须要配合 synchronized 关键字使用&lt;br/&gt;2）wait方法是释放锁的， notify方法不释放锁。&lt;br/&gt;线程通信概念：线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理，就不能成为一个整体，线程之间的通信就成为整体的必用方法之一。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.util.LinkedList;&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.atomic.AtomicInteger;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * synchronized 可以在任意对象及方法上加锁，而加锁的这段代码称为&quot;互斥区&quot;或&quot;临界区&quot;，一般给代码块加锁，通过减小锁的粒度从而提高性能。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Atomic* 是为了弥补volatile关键字不具备原子性的问题。虽然一个Atomic*对象是具备原子性的，但不能确保多个Atomic*对象也具备原子性。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * volatile 关键字不具备synchronized关键字的原子性其主要作用就是使变量在多个线程中可见。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * wait / notify&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * wait() 使线程阻塞运行，notify() 随机唤醒等待队列中等待同一共享资源的一个线程继续运行，notifyAll() 唤醒所有等待队列中等待同一共享资源的线程继续运行。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 1）wait 和 notify 必须要配合 synchronized 关键字使用&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 2）wait方法是释放锁的， notify方法不释放锁&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonMyQueue {
    
    &lt;span class=&quot;co&quot;&gt;//1 需要一个承装元素的集合   &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; LinkedList&amp;lt;Object&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;Object&amp;gt;();  
    &lt;span class=&quot;co&quot;&gt;//2 需要一个计数器 AtomicInteger (保证原子性和可见性)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; AtomicInteger count = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; AtomicInteger(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);  
    &lt;span class=&quot;co&quot;&gt;//3 需要制定上限和下限  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Integer minSize = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Integer maxSize ;  
      
    &lt;span class=&quot;co&quot;&gt;//4 构造方法  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonMyQueue&lt;/span&gt;(Integer size){  
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;maxSize&lt;/span&gt; = size;  
    }  
      
    &lt;span class=&quot;co&quot;&gt;//5 初始化一个对象 用于加锁  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object lock = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object();  
      
    &lt;span class=&quot;co&quot;&gt;//put(anObject): 把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断，直到BlockingQueue里面有空间再继续.  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(Object obj){  
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {  
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(count.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;() == &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;maxSize&lt;/span&gt;){  
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                    lock.&lt;span class=&quot;fu&quot;&gt;wait&lt;/span&gt;();        &lt;span class=&quot;co&quot;&gt;// 当Queue没有空间时，线程被阻塞 ，这里为了区分，命名为wait1&lt;/span&gt;
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {  
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
                }  
            }  
            list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(obj);              &lt;span class=&quot;co&quot;&gt;//1 加入元素  &lt;/span&gt;
            count.&lt;span class=&quot;fu&quot;&gt;incrementAndGet&lt;/span&gt;();    &lt;span class=&quot;co&quot;&gt;//2 计数器累加  &lt;/span&gt;
            lock.&lt;span class=&quot;fu&quot;&gt;notify&lt;/span&gt;();              &lt;span class=&quot;co&quot;&gt;//3 新增元素后，通知另外一个线程wait2，队列多了一个元素，可以做移除操作了。 &lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;新加入的元素为: &quot;&lt;/span&gt; + obj);  
        }  
    }  
      
    &lt;span class=&quot;co&quot;&gt;//take: 取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入.  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;(){  
        Object ret = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (lock) {  
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(count.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;() == &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;minSize&lt;/span&gt;){  
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {  
                    lock.&lt;span class=&quot;fu&quot;&gt;wait&lt;/span&gt;();        &lt;span class=&quot;co&quot;&gt;// 当Queue没有值时，线程被阻塞 ，这里为了区分，命名为wait2&lt;/span&gt;
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {  
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();  
                }  
            }  
            ret = list.&lt;span class=&quot;fu&quot;&gt;removeFirst&lt;/span&gt;();   &lt;span class=&quot;co&quot;&gt;//1 做移除元素操作  &lt;/span&gt;
            count.&lt;span class=&quot;fu&quot;&gt;decrementAndGet&lt;/span&gt;();    &lt;span class=&quot;co&quot;&gt;//2 计数器递减  &lt;/span&gt;
            lock.&lt;span class=&quot;fu&quot;&gt;notify&lt;/span&gt;();              &lt;span class=&quot;co&quot;&gt;//3 移除元素后，唤醒另外一个线程wait1，队列少元素了，可以再添加操作了  &lt;/span&gt;
        }  
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ret;  
    }  
      
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getSize&lt;/span&gt;(){  
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;count&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();  
    }  
      
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{  
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ITDragonMyQueue queue = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonMyQueue&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);  
        queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;);  
        queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;b&quot;&lt;/span&gt;);  
        queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;c&quot;&lt;/span&gt;);  
        queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;d&quot;&lt;/span&gt;);  
        queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;e&quot;&lt;/span&gt;);  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;当前容器的长度: &quot;&lt;/span&gt; + queue.&lt;span class=&quot;fu&quot;&gt;getSize&lt;/span&gt;());  
        Thread thread1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;);  
                queue.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;g&quot;&lt;/span&gt;);  
            }  
        },&lt;span class=&quot;st&quot;&gt;&quot;thread1&quot;&lt;/span&gt;);  
        Thread thread2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {  
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {  
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;移除的元素为:&quot;&lt;/span&gt; + queue.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;());  &lt;span class=&quot;co&quot;&gt;// 移除一个元素后再进一个，而并非同时移除两个，进入两个元素。&lt;/span&gt;
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;移除的元素为:&quot;&lt;/span&gt; + queue.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;());  
            }  
        },&lt;span class=&quot;st&quot;&gt;&quot;thread2&quot;&lt;/span&gt;);  
        thread1.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
        thread2.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();  
    }  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;死锁&quot;&gt;死锁&lt;/h2&gt;
&lt;p&gt;死锁是一个很糟糕的情况，锁迟迟不能解开，其他线程只能一直处于等待阻塞状态。比如线程A拥有锁一，却还想要锁二。线程B拥有锁二，却还想要锁一。两个线程互不相让，两个线程将永远等待。&lt;br/&gt;排查：&lt;br/&gt;第一步：控制台输入jps用于获得当前JVM进程的pid&lt;br/&gt;第二步：jstack pid 用于打印堆栈信息&lt;br/&gt;第三步：解读，&quot;Thread-1&quot; 是线程的名字，prio 是线程的优先级，tid 是线程id， nid 是本地线程id， waiting to lock 等待去获取的锁，locked 自己拥有的锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Thread-1&quot; #11 prio=5 os_prio=0 tid=0x0000000055ff1800 nid=0x1bd4 waiting for monitor entry [0x0000000056e2e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.itdragon.keyword.ITDragonDeadLock.rightLeft(ITDragonDeadLock.java:37)
        - waiting to lock &amp;lt;0x00000000ecfdf9d0&amp;gt; (a java.lang.Object)
        - locked &amp;lt;0x00000000ecfdf9e0&amp;gt; (a java.lang.Object)
        at com.itdragon.keyword.ITDragonDeadLock$2.run(ITDragonDeadLock.java:54)
        at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 死锁: 线程A拥有锁一，却还想要锁二。线程B拥有锁二，却还想要锁一。两个线程互不相让，两个线程将永远等待。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 避免: 在设计阶段，了解锁的先后顺序，减少锁的交互数量。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 排查: &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 第一步：控制台输入 jps 用于获得当前JVM进程的pid&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 第二步：jstack pid 用于打印堆栈信息 &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &quot;Thread-1&quot; #11 prio=5 os_prio=0 tid=0x0000000055ff1800 nid=0x1bd4 waiting for monitor entry [0x0000000056e2e000]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * - waiting to lock &amp;lt;0x00000000ecfdf9d0&amp;gt; - locked &amp;lt;0x00000000ecfdf9e0&amp;gt; &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &quot;Thread-0&quot; #10 prio=5 os_prio=0 tid=0x0000000055ff0800 nid=0x1b14 waiting for monitor entry [0x0000000056c7f000]&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * - waiting to lock &amp;lt;0x00000000ecfdf9e0&amp;gt; - locked &amp;lt;0x00000000ecfdf9d0&amp;gt; &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 可以看出，两个线程持有的锁都是对方想要得到的锁(得不到的永远在骚动)，而且最后一行也打印了 Found 1 deadlock.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonDeadLock {
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object left = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object();
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object right = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object();
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;leftRight&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (left) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 模拟持有锁的过程&lt;/span&gt;
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
            &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (right) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;leftRight end!&quot;&lt;/span&gt;);
            }
        }
    }
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;rightLeft&lt;/span&gt;(){
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (right) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 模拟持有锁的过程&lt;/span&gt;
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
            &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (left) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;rightLeft end!&quot;&lt;/span&gt;);
            }
        }
    }
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        ITDragonDeadLock itDragonDeadLock = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ITDragonDeadLock&lt;/span&gt;();
        Thread thread1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                itDragonDeadLock.&lt;span class=&quot;fu&quot;&gt;leftRight&lt;/span&gt;();
            }
        });
        thread1.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        Thread thread2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
            &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
                itDragonDeadLock.&lt;span class=&quot;fu&quot;&gt;rightLeft&lt;/span&gt;();
            }
        });
        thread2.&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;多线程案例&quot;&gt;多线程案例&lt;/h2&gt;
&lt;p&gt;若有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.io.File;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Arrays;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.Callable;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.CompletionService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ExecutorCompletionService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.ExecutorService;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.Executors;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 若有Thread1、Thread2、Thread3、Thread4四条线程分别统计C、D、E、F四个盘的大小，所有线程都统计完毕交给Thread5线程去做汇总，应当如何实现？&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 思考：汇总，说明要把四个线程的结果返回给第五个线程，若要线程有返回值，推荐使用callable。Thread和Runnable都没返回值&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ITDragonThreads {  
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {  
        &lt;span class=&quot;co&quot;&gt;// 无缓冲无界线程池&lt;/span&gt;
        ExecutorService executor = Executors.&lt;span class=&quot;fu&quot;&gt;newFixedThreadPool&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;); 
        &lt;span class=&quot;co&quot;&gt;// 相对ExecutorService，CompletionService可以更精确和简便地完成异步任务的执行&lt;/span&gt;
        CompletionService&amp;lt;Long&amp;gt; completion = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ExecutorCompletionService&amp;lt;Long&amp;gt;(executor);  
        CountWorker countWorker = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;  
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;; i++) { &lt;span class=&quot;co&quot;&gt;// 四个线程负责统计&lt;/span&gt;
            countWorker = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CountWorker&lt;/span&gt;(i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;);  
            completion.&lt;span class=&quot;fu&quot;&gt;submit&lt;/span&gt;(countWorker);  
        }  
        &lt;span class=&quot;co&quot;&gt;// 关闭线程池&lt;/span&gt;
        executor.&lt;span class=&quot;fu&quot;&gt;shutdown&lt;/span&gt;();  
        &lt;span class=&quot;co&quot;&gt;// 主线程相当于第五个线程，用于汇总数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; total = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;  
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;; i++) { 
            total += completion.&lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(); 
        }  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(total / &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; +&lt;span class=&quot;st&quot;&gt;&quot;G&quot;&lt;/span&gt;);  
    }  
}  
  
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CountWorker &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Callable&amp;lt;Long&amp;gt;{  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Integer type;  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CountWorker&lt;/span&gt;() {
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CountWorker&lt;/span&gt;(Integer type) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;type&lt;/span&gt; = type;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;  
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Long &lt;span class=&quot;fu&quot;&gt;call&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {  
        ArrayList&amp;lt;String&amp;gt; paths = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(Arrays.&lt;span class=&quot;fu&quot;&gt;asList&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;c:&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;d:&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;e:&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;f:&quot;&lt;/span&gt;));
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;countDiskSpace&lt;/span&gt;(paths.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(type - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));  
    }  
    
    &lt;span class=&quot;co&quot;&gt;// 统计磁盘大小&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Long &lt;span class=&quot;fu&quot;&gt;countDiskSpace&lt;/span&gt; (String path) {  
        File file = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; File(path);  
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; totalSpace = file.&lt;span class=&quot;fu&quot;&gt;getTotalSpace&lt;/span&gt;();  
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(path + &lt;span class=&quot;st&quot;&gt;&quot; 总空间大小 : &quot;&lt;/span&gt; + totalSpace / &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; / &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&quot;G&quot;&lt;/span&gt;);  
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; totalSpace;
    }  
}  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;查考面试题&quot;&gt;查考面试题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1 常见创建线程的方式和其优缺点&lt;/strong&gt;&lt;br/&gt;（1）继承Thread类 （2）实现Runnable接口&lt;br/&gt;优缺点：实现一个接口比继承一个类要灵活，减少程序之间的耦合度。缺点就是代码多了一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 start()方法和run()方法的区别&lt;/strong&gt;&lt;br/&gt;start方法可以启动线程，而run方法只是thread的一个普通方法调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 多线程的作用&lt;/strong&gt;&lt;br/&gt;（1）发挥多核CPU的优势，提高CPU的利用率（2）防止阻塞，提高效率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4 什么是线程安全&lt;/strong&gt;&lt;br/&gt;当多个线程访问某一个类（对象或方法）时，这个对象始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5 线程安全级别&lt;/strong&gt;&lt;br/&gt;（1）不可变（2）绝对线程安全（3）相对线程安全（4）线程非安全&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6 如何在两个线程之间共享数据&lt;/strong&gt;&lt;br/&gt;线程之间数据共享，其实可以理解为线程之间的通信，可以用wait/notify/notifyAll 进行等待和唤醒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7 用线程池的好处&lt;/strong&gt;&lt;br/&gt;避免频繁地创建和销毁线程，达到线程对象的重用，提高性能，减轻服务器压力。使用线程池还可以根据项目灵活地控制并发的数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8 sleep方法和wait方法有什么区别&lt;/strong&gt;&lt;br/&gt;sleep方法和wait方法都可以用来放弃CPU一定的时间，sleep是thread的方法，不会释放锁。wait是object的方法，会释放锁。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 线程池核心参数有 初始核心线程数，线程池运行最大线程数，空闲线程存活时间，时间单位，任务队列。&lt;br/&gt;2 队列是一种数据结构，主要有两类 阻塞队列BlockingQueue，和非阻塞高性能队列ConcurrentLinkedQueue。&lt;br/&gt;3 线程安全的两个特性，原子性和可见性。synchronized 关键字具备原子性。volatile 关键字具备可见性。&lt;br/&gt;4 单个Atomic类具备原子性和可见性，多个Atomic类不具备原子性，需要synchronized 关键字修饰。&lt;br/&gt;5 两个线程持有的锁都是对方想要得到的锁时容易出现死锁的情况，从设计上尽量减少锁的交互。&lt;/p&gt;
&lt;p&gt;本章到这里就结束了，涉及的知识点比较多，请参考流程图来学习。如有什么问题可以指出。喜欢的朋友可以点个&quot;推荐&quot;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 07:30:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8319183.html</dc:identifier>
</item>
<item>
<title>【机器学习】SKlearn + XGBoost  预测 Titanic 乘客幸存 - Jreey</title>
<link>http://www.cnblogs.com/JreeyQi/p/8320708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JreeyQi/p/8320708.html</guid>
<description>&lt;p&gt;Titanic 数据集是从 kaggle下载的，下载地址：&lt;a title=&quot;https://www.kaggle.com/c/titanic/data&quot; href=&quot;https://www.kaggle.com/c/titanic/data&quot; target=&quot;_blank&quot;&gt;https://www.kaggle.com/c/titanic/data&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据一共又3个文件，分别是：train.csv,test.csv,&lt;span class=&quot;file-preview__item-filename&quot;&gt;gender_submission.csv&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;先把需要视同的库导入：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import os
import datetime
import &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt;&lt;span&gt;
import numpy &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; np
import pandas &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; pd
import xgboost &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; xgb
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sklearn.model_selection import train_test_split
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sklearn.preprocessing import Imputer, scale
import matplotlib.pyplot &lt;/span&gt;&lt;span&gt;as&lt;/span&gt; plt
&lt;/pre&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;np.random.seed(19260817) # 设置一下种子，看一下博客园有没有能看懂的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;不管是做机器学习，还是深度学习，还是其他的先&lt;span class=&quot;file-preview__item-filename&quot;&gt;确定是 &lt;span&gt;&lt;strong&gt;分类问题还是回归问题，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;当然这两个可以互相转换的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;，然后拿到数据第一步肯定是先观察数据，数据是否又缺失，乱码等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;这个看一下就知道是否存活，存活是1，否则 0 ，那么就是&lt;strong&gt;分类&lt;/strong&gt; ！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;1，观察下数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;先观察一下数据，使用pandas读取数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;descclassname&quot;&gt;DataFrame.&lt;/code&gt;&lt;code class=&quot;descname&quot;&gt;head&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;(&lt;em&gt;n=5&lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;)：head 方法默认取5行数据，你可以自己随便传参数，我只去10行观察下看下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    pd_train = pd.read_csv('./data/titanic/train.csv')
    pd_test = pd.read_csv('./data/titanic/test.csv')
    pd_gender = pd.read_csv('./data/titanic/gender_submission.csv')
    print(pd_train.shape, pd_test.shape)
    print(pd_train.head(10))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;&lt;span&gt;根据观察可以看到，数据有数值类型，也有字符类型，数值类型我们称作连续变量，字符类型我们称作分类变量，连续变量是不用转换的，而分类变量是需要转成连续变量的，否则，无法运算。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;还可以看到有些数据是缺失的，这部分缺失值我们也需要处理，填充或者删除&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;2，特征工程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;　根据第一步&lt;/span&gt;观察到的结果，我们对数据做处理。&lt;/p&gt;
&lt;p&gt;　　1）将性别 Sex 列，做数值转换处理，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 性别 将性别字段Sex中的值 female用0，male用1代替,类型 int&lt;/span&gt;
    pd_train[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = pd_train[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].map({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;}).astype(int)
    pd_test[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = pd_test[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].map({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1}).astype(int)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2） 将分类变量转换位连续变量。我们使用 sklearn 库下面的 &lt;strong&gt;LabelEncoder()&lt;/strong&gt; 来处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将类型变量转换位连续变量&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; f &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pd_train.columns:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pd_train[f].dtype == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            label &lt;/span&gt;=&lt;span&gt; LabelEncoder()
            label.fit(list(pd_train[f].values))
            pd_train[f] &lt;/span&gt;=&lt;span&gt; label.transform(list(pd_train[f].values))

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; f &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pd_test.columns:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pd_test[f].dtype == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            label &lt;/span&gt;=&lt;span&gt; LabelEncoder()
            label.fit(list(pd_test[f].values))
            pd_test[f] &lt;/span&gt;= label.transform(list(pd_test[f].values))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3）统计缺失的列那些，观察缺失值有多少，再决定是删除，还是填充，如果某列值的缺失严重，那就没必要填充了，直接删除。&lt;/p&gt;
&lt;p&gt;　　     我们采用填充的方式，使用 &lt;strong&gt;&lt;span class=&quot;reference internal&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Imputer&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;reference internal&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;类来处理缺失值，&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;span class=&quot;reference internal&quot;&gt;&lt;code class=&quot;xref py py-class docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;这个类&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;提供了估算缺失值的基本策略，使用缺失值所在的行/列中的平均值、中位数或者众数来填充。这个类也支持不同的缺失值编码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计缺失的列&lt;/span&gt;
    na_train = pd_train.isnull().sum().sort_values(ascending=&lt;span&gt;False)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(na_train)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用均值填充缺失值&lt;/span&gt;
    train_data=&lt;span&gt; pd_train.values
    imput &lt;/span&gt;= Imputer(missing_values=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strategy=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, axis=&lt;span&gt;0)
    imput &lt;/span&gt;=&lt;span&gt; imput.fit(train_data)
    train_data &lt;/span&gt;=&lt;span&gt; imput.fit_transform(train_data)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用均值填充缺失值&lt;/span&gt;
    test_data=&lt;span&gt; pd_test.values
    imput &lt;/span&gt;= Imputer(missing_values=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NaN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, strategy=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, axis=&lt;span&gt;0)
    imput &lt;/span&gt;=&lt;span&gt; imput.fit(test_data)
    test_data &lt;/span&gt;= imput.fit_transform(test_data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;3，训练&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;　　经过对特征的处理，我们可以训练模型可，我使用了三个模型分别是，&lt;/span&gt;&lt;span&gt;LogisticRegression，RandomForest，XGBClassifier&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;监督学习的模型都一样，必须拟合（fit）两个矩阵（数组）， 训练样本的矩阵 X，大小为 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;[n_samples, &lt;span class=&quot;pre&quot;&gt;n_features]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;，和 训练样本目标值（标签）的数组 Y，大小为 &lt;code class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;[n_samples]&lt;/span&gt;&lt;/code&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　1）&lt;span&gt;LogisticRegression ：逻辑回归，虽然名字叫回归，但是个分类模型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train_logreistic():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    逻辑回归
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    X_train, X_test, y_train, y_test &lt;/span&gt;=&lt;span&gt; load_data()

    model &lt;/span&gt;= LogisticRegression(penalty=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    model.fit(X_train, y_train)
    y_pred &lt;/span&gt;=&lt;span&gt; model.predict(X_test)
    rfc_rate, rmse &lt;/span&gt;=&lt;span&gt; calc_accuracy(y_pred, y_test)
    total &lt;/span&gt;=&lt;span&gt; total_survival(y_pred)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogisticRegression acc_rate：{0:.4f},RMS:{1:.4f},存活：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format( rfc_rate, rmse, total))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rfc_rate, rmse, total
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　2）&lt;span&gt;RandomForest&lt;/span&gt;：随机森林，基于树的模型，通过在分类器构造过程中引入随机性来创建一组不同的分类器。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train_randomForster():

    X_train, X_test, y_train, y_test &lt;/span&gt;=&lt;span&gt; load_data()
    model &lt;/span&gt;= RandomForestClassifier(n_estimators=300,max_depth=12,random_state=7&lt;span&gt;)
    model.fit(X_train,y_train)
    y_pred &lt;/span&gt;=&lt;span&gt; model.predict(X_test)
    rfc_rate, rmse &lt;/span&gt;=&lt;span&gt; calc_accuracy(y_pred, y_test)
    total &lt;/span&gt;=&lt;span&gt; total_survival(y_pred)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RandomForestClassifier acc_rate：{0:.4f},RMS:{1:.4f},存活：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(rfc_rate, rmse, total))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; rfc_rate, rmse, total
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　3）&lt;span&gt;XGBClassifier ：大规模并行boosted tree的工具,它是目前最快最好的开源boosted tree工具包,比常见的工具包快10倍以上，kaggle 比赛的神器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train_XGBoost():

    X_train, X_test, y_train, y_test &lt;/span&gt;=&lt;span&gt; load_data()
    model &lt;/span&gt;= xgb.XGBClassifier(max_delta_step=6, learning_rate=0.1, n_estimators=100, objective=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;binary:logistic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,silent&lt;/span&gt;=&lt;span&gt;True)
    eval_data &lt;/span&gt;=&lt;span&gt; [(X_test, y_test)]
    model.fit(X_train, y_train, eval_set&lt;/span&gt;=eval_data, early_stopping_rounds=30&lt;span&gt;)
    y_pred &lt;/span&gt;=&lt;span&gt; model.predict(X_test)
    rfc_rate, rmse &lt;/span&gt;=&lt;span&gt; calc_accuracy(y_pred, y_test)
    total &lt;/span&gt;=&lt;span&gt; total_survival(y_pred)
&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XGBClassifier acc_rate：{0:.4f},RMS:{1:.4f},存活：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(rfc_rate, rmse, total))&lt;span&gt;
    &lt;span&gt;return&lt;span&gt; rfc_rate, rmse, total&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;4，预测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;　　&lt;span&gt;model.predict(X_test)&lt;/span&gt; 都在里面写了，我就不说了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　三个模型最后的结果：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; train():
    
    lg_rate, lg_rmse, lg_total &lt;/span&gt;=&lt;span&gt; train_logreistic()
    rf_rate, rf_rmse, rf_total &lt;/span&gt;=&lt;span&gt; train_randomForster()
    xg_rate, xg_rmse, xg_total &lt;/span&gt;=&lt;span&gt; train_XGBoost()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogisticRegression acc_rate：{0:.4f},RMS:{1:.4f},存活：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format( lg_rate, lg_rmse, lg_total))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RandomForestClassifier acc_rate：{0:.4f},RMS:{1:.4f},存活：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(rf_rate, rf_rmse, rf_total))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XGBClassifier acc_rate：{0:.4f},RMS:{1:.4f},存活：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(xg_rate, xg_rmse, xg_total))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
XGBClassifier acc_rate：80.4469,RMS:0.4422,存活：56&lt;span&gt;
LogisticRegression acc_rate：&lt;/span&gt;74.8603,RMS:0.5014,存活：60&lt;span&gt;
RandomForestClassifier acc_rate：&lt;/span&gt;82.6816,RMS:0.4162,存活：54&lt;span&gt;
XGBClassifier acc_rate：&lt;/span&gt;80.4469,RMS:0.4422,存活：56
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，至于怎么调参，网格搜索我就不写了，简单的分析就完成了。。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;1) http://xgboost.readthedocs.io/en/latest/&lt;/p&gt;
&lt;p&gt;2) http://scikit-learn.org/stable/&lt;/p&gt;
&lt;p&gt;3) https://www.kaggle.com/&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;file-preview__item-filename&quot;&gt;源码地址：&lt;a title=&quot;使用机器学习分析 titanic 数据集 &quot; href=&quot;https://github.com/jarvisqi/machine_learning/blob/master/ml_xgboost/titanic.py&quot; target=&quot;_blank&quot;&gt;https://github.com/jarvisqi/machine_learning/blob/master/ml_xgboost/titanic.py&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jan 2018 06:32:00 +0000</pubDate>
<dc:creator>Jreey</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JreeyQi/p/8320708.html</dc:identifier>
</item>
<item>
<title>vue.js之数据传递和数据分发slot - 哈哈^^</title>
<link>http://www.cnblogs.com/15fj/p/8320467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/15fj/p/8320467.html</guid>
<description>&lt;p&gt;一、组件间的数据传递&lt;/p&gt;
&lt;p&gt;　　1.父组件获取子组件的数据　　&lt;/p&gt;
&lt;p&gt;　　　　*子组件把自己的数据，发送到父级&lt;/p&gt;
&lt;p&gt;　　　　*vm.$emit(事件名,数据);&lt;/p&gt;
&lt;p&gt;　　　　*v-on: @&lt;/p&gt;
&lt;p&gt;　　示例用法：当点击send按钮的时候，“111”变成“我是子组件的数据”&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;父级获取子级的数据&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;bower_components/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aaa&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是父级 -&amp;gt; {{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    //自动调用get方法，@child-msg和下面的this.$emit('child-msg',this.a)相对应
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bbb &lt;/span&gt;&lt;span&gt;@child-msg&lt;/span&gt;&lt;span&gt;=&quot;get&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bbb&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;子组件-&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;send&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;=&quot;send&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            a:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        components:{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
                data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                        msg:&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;,
                        msg2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是父组件的数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    }
                },
                template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                methods:{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的msg实际上就是子组件传递给父组件的数据&lt;/span&gt;
&lt;span&gt;                    get:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(msg){
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msg&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;msg;
                    }
                },
                components:{
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
                        data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                                a:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是子组件的数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                            }
                        },
                        template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        methods:{
                            send:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$emit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child-msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a);
                            }
                        }
                    }
                }
            }
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　2、子组件获取父组件的数据&lt;/p&gt;
&lt;p&gt;　　　　　在调用子组件：&lt;br/&gt;　　　　　　　　&amp;lt;bbb :m=&quot;数据&quot;&amp;gt;&amp;lt;/bbb&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　子组件之内:&lt;br/&gt;　　　　　　　　props:['m','myMsg']&lt;/p&gt;
&lt;p&gt;　　　　　　　　props:{&lt;br/&gt;　　　　　　　　'm':String,&lt;br/&gt;　　　　　　　　'myMsg':Number&lt;br/&gt;　　　　　　　　}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;自己获取父级的数据&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;bower_components/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{a}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {{msg}}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aa&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;11111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bbb &lt;/span&gt;&lt;span&gt;:mmm&lt;/span&gt;&lt;span&gt;=&quot;msg2&quot;&lt;/span&gt;&lt;span&gt; :my-msg&lt;/span&gt;&lt;span&gt;=&quot;msg&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            a:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        components:{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
                data:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                        msg:&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;,
                        msg2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我是父组件的数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    }
                },
                template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#aa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                components:{
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
                        props:{
                            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mmm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:String,
                            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myMsg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:Number
                        },
                        template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;h3&amp;gt;我是bbb组件-&amp;gt;{{mmm}} &amp;lt;br&amp;gt; {{myMsg}}&amp;lt;/h3&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                    }
                }
            }
        }
    });

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1202490/201801/1202490-20180120120413553-157499830.png&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;109&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 二、内容分发：&lt;/p&gt;
&lt;p&gt;　　Vue.js提供了一种混合父组件内容与子组件自己模版的方式:slot，用来占一个位置&lt;/p&gt;
&lt;p&gt; 　　1、基本用法　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slot保留原来的位置&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;bower_components/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2222&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3333&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aaa&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxxx&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是默认的情况&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;welcome vue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            a:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        components:{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
                template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }
        }
    });

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　运行结果：ul标签里面的内容没有被覆盖，如果不使用slot,ul标签里的内容将会被覆盖&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1202490/201801/1202490-20180120123947053-2127745860.png&quot; alt=&quot;&quot; width=&quot;74&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、slot的name属性　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slot中name属性的使用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;bower_components/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;=&quot;ul-slot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;　　　　//这里slot的名字要与下面slot中name属性相对应&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2222&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3333&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ol &lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;=&quot;ol-slot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;　　　　//用法同上&lt;/span&gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;111&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;222&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;333&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ol&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aaa&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;　　&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxxx&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ol-slot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是默认的情况&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;　　　　　　//设置name属性，给slot命名&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;welcome vue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;slot &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ul-slot&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是默认的情况2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;slot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; vm&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data:{
            a:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        components:{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:{
                template:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            }
        }
    });

&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1202490/201801/1202490-20180120124401162-1622728226.png&quot; alt=&quot;&quot; width=&quot;77&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jan 2018 04:57:00 +0000</pubDate>
<dc:creator>哈哈^^</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/15fj/p/8320467.html</dc:identifier>
</item>
<item>
<title>Spring--AOP(面向切面)编程 - ccy00808</title>
<link>http://www.cnblogs.com/tidas809/p/8320367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tidas809/p/8320367.html</guid>
<description>&lt;h4 id=&quot;aop&quot;&gt;&lt;strong&gt;AOP&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;切面就像一把菜刀，将Java处理业务流程进行分割，在分割处添加特定的业务处理。主要应用于声明事务、安全和缓存。在本文中，主要介绍两种切面的实现方法--Java配置和XML配置。&lt;/p&gt;
&lt;h4 id=&quot;java配置&quot;&gt;&lt;strong&gt;Java配置&lt;/strong&gt;&lt;/h4&gt;
&lt;ul readability=&quot;31.161497326203&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建Java类&lt;/strong&gt;&lt;br/&gt;创建一个Music的Java类，用于声明切点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Music {

public void perform(int num){
    System.out.println(&quot;music&quot;);
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5.7094017094017&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建切面&lt;/strong&gt;&lt;br/&gt;创建Aop Java类，并声明为切面。&lt;a href=&quot;mailto:声明为切面使用注解@aspect&quot;&gt;声明为切面使用注解@Aspect&lt;/a&gt;，同时，切面必须是一个Bean。同时，声明一个切点，避免创建通知的时候重复使用过长的表达式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Aspect
public class Aop {

@Pointcut(&quot;execution(** com.tidas.spring.fourth.aopjavaconfig.Music.*(..))&quot;)
public void performer(){}

@Before(&quot;performer()&quot;)
public void beforee(){
    System.out.println(&quot;before&quot;);
}

@After(&quot;performer()&quot;)
public void afterr(){
    System.out.println(&quot;after&quot;);
}

@AfterReturning(&quot;performer()&quot;)
public void afterReturning(){
    System.out.println(&quot;afterreturning&quot;);
}

@AfterThrowing(&quot;performer()&quot;)
public void throwingg(){
    System.out.println(&quot;throwing&quot;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1.3679653679654&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建Java配置类&lt;/strong&gt;&lt;br/&gt;创建JavaConfiguration 类，创建Bean工厂，&lt;a href=&quot;mailto:在这里需要使用@enableaspectautoproxy注解启动spring切面功能&quot;&gt;在这里需要使用@EnableAspectAutoProxy注解启动Spring切面功能&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class JavaConfiguration {
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建测试类&lt;/strong&gt;&lt;br/&gt;创建Main测试类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=JavaConfiguration.class)
public class Main {
@Autowired
private Music music;
@Test
public void test(){
    music.perform(3);
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;为通知传递参数&lt;/strong&gt;&lt;br/&gt;希望将声明为切点方法中的参数传递到通知当中其，则需要在声明切点的使用指明args参数，在Java中使用&amp;amp;&amp;amp; 在xml中使用and，下面是创建为通知传递参数的切面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*@Pointcut(&quot;execution(** com.tidas.spring.fourth.aopjavaconfig.Music.perform(int)) &amp;amp;&amp;amp; args(number)&quot;)
public void performer(int number){}
@Before(&quot;performer(number)&quot;)
public void beforee(int number){
    System.out.println(&quot;before&quot; + number);
}
@After(&quot;performer(number)&quot;)
public void afterr(int number){
    System.out.println(&quot;after&quot; + number+2);
}
@AfterReturning(&quot;performer(number)&quot;)
public void afterReturning(int number){
    System.out.println(&quot;afterreturning&quot; + number+1);
}
@AfterThrowing(&quot;performer(number)&quot;)
public void throwingg(int number){
    System.out.println(&quot;throwing&quot; + number +3);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5.6153846153846&quot;&gt;
&lt;p&gt;另外，&lt;a href=&quot;mailto:还可以使用@around穿件环绕通知&quot;&gt;还可以使用@Around穿件环绕通知&lt;/a&gt;，被声明为环绕通知的方法需要包含参数ProceedingJoinPoint，通过ProceedingJoinPoint.proceed()来区分前置 通知和后置通知，通过try...catch来获取异常通知&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
@Aspect
public class AopSecond {
@Pointcut(&quot;execution(** com.tidas.spring.fourth.aopjavaconfig.Music.perform(..))&quot;)
public void performer(){}

@Around(&quot;performer()&quot;)
public void per(ProceedingJoinPoint jb){
    try{
        System.out.println(&quot;beforeer&quot;);
        jb.proceed();
        System.out.println(&quot;afterr&quot;);
    }catch(Throwable eThrowable){
        System.out.println(&quot;exception&quot;);
    }
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;xml中配置切面&quot;&gt;&lt;strong&gt;XML中配置切面&lt;/strong&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建Java类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class AopXml {
public void performA(){
    System.out.println(&quot;performA&quot;);
}
public void performB(){
    System.out.println(&quot;performB&quot;);
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;创建切面类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class AopConfug {
public void beforee(){
    System.out.println(&quot;before&quot;);
}
public void afterr(){
    System.out.println(&quot;after&quot;);
}
public void aroundd(ProceedingJoinPoint pb) throws Throwable{
    System.out.println(&quot;beforeeee&quot;);
    pb.proceed();
    System.out.println(&quot;afterrrr&quot;);
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;创建xml配置文件，其中需要添加&lt;code&gt;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;&lt;/code&gt; 和&lt;code&gt;http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&lt;/code&gt;，来支持component-scan，同时，还需要配置&lt;code&gt;&amp;lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&amp;gt;&lt;/code&gt;支持自动注入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
  xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;
&amp;lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&amp;gt;
&amp;lt;context:component-scan base-package=&quot;com.tidas.spring.fourth.aopxml&quot;/&amp;gt;
&amp;lt;!-- 无参数 --&amp;gt;
&amp;lt;aop:config&amp;gt;
&amp;lt;aop:aspect ref=&quot;aopConfug&quot;&amp;gt;
    &amp;lt;aop:pointcut expression=&quot;execution(** com.tidas.spring.fourth.aopxml.AopXml.*(..))&quot; id=&quot;aopxmll&quot;/&amp;gt;
    &amp;lt;!-- 执行AopXml中的任何方法，都会通知切面 --&amp;gt;
    &amp;lt;aop:before pointcut-ref = &quot;aopxmll&quot; method=&quot;beforee&quot;/&amp;gt;

    &amp;lt;aop:after pointcut-ref = &quot;aopxmll&quot; method=&quot;afterr&quot;/&amp;gt;

    &amp;lt;aop:around pointcut-ref = &quot;aopxmll&quot; method=&quot;aroundd&quot;/&amp;gt;
    &amp;lt;!-- 对于环绕通知，其实在xml中声明和其它通知声明一样，没有参数，而参数还是在具体的方法中就好 --&amp;gt;
&amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;为通知传递参数&lt;br/&gt;创建带参数的通知&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//有参数
/*public void beforee(int number){
    System.out.println(&quot;number:&quot; + number);
}*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建带参数的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//有参数
public void perform(int number){
    System.out.println(&quot;perform2&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切面和切点的配置，在xml中使用and连接args参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;aop:config&amp;gt;
&amp;lt;aop:aspect ref=&quot;aopConfug&quot;&amp;gt;
    &amp;lt;aop:pointcut expression=&quot;execution(** com.tidas.spring.fourth.aopxml.AopXml.*(int)) and args(number)&quot; id=&quot;aopxmll&quot;/&amp;gt;

    &amp;lt;aop:before pointcut-ref = &quot;aopxmll&quot; method=&quot;beforee&quot;/&amp;gt;
&amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过切面为java引入新的功能&quot;&gt;&lt;strong&gt;通过切面为Java引入新的功能&lt;/strong&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 20 Jan 2018 04:33:00 +0000</pubDate>
<dc:creator>ccy00808</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tidas809/p/8320367.html</dc:identifier>
</item>
<item>
<title>.net的retrofit--WebApiClient底层篇 - jiulang</title>
<link>http://www.cnblogs.com/kewei/p/8320247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kewei/p/8320247.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本篇文章的内容是&lt;a href=&quot;https://github.com/xljiulang/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;底层说明，也是WebApiClient系列接近尾声的一篇文章，如果你没有阅读过之前的的相关文章，可能会觉得本文章的内容断层，WebApiClient系列文章索引：&lt;/p&gt;
&lt;h2 id=&quot;库简介&quot;&gt;库简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xljiulang/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;是开源在github上的一个httpClient客户端库，内部基于HttpClient开发，是一个只需要定义c#接口(interface)，并打上相关特性，即可异步调用http-api的框架 ，支持.net framework4.5+、netcoreapp2.0和netstandard2.0。&lt;br/&gt;&lt;a href=&quot;https://github.com/xljiulang/WebApiClient&quot;&gt;WebApiClient&lt;/a&gt;是我2017年看到java的retrofit库之后，决心给.net打造的一款面向切面的httpclient客户端库，在开发过程中陆续发现.net下也有一些HttpClient包装库，WebApiClient库虽然是后起，却有其它库所没有很多优秀特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原生的支持面向切面编程；&lt;/li&gt;
&lt;li&gt;内置丰富的特性，支持自定义特性；&lt;/li&gt;
&lt;li&gt;灵活和Filter、GlobalFilter和IParameterable；&lt;/li&gt;
&lt;li&gt;功能强大的序列化工具；&lt;/li&gt;
&lt;li&gt;与外部HttpClientHandler无缝衔接；&lt;/li&gt;
&lt;li&gt;独一无二的请求异常条件重试功能和异常处理链式语法功能&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;httprequestmessage简说&quot;&gt;1. HttpRequestMessage简说&lt;/h2&gt;
&lt;p&gt;System.Net.Http.HttpRequestMessage表示一个请求消息，一般而言它包含一个完整的请求数据，主要由请求头和请求体组成，对于Post、Delete、Put等请求，其Content属性包含提交的数据体内容。&lt;/p&gt;
&lt;p&gt;WebApiClient的ApiActionContex对象有个RequestMessage对象，是派生于HttpRequestMessage，同时实现了多个Addxxx方法用于给其属性Content对象添加数据内容。&lt;/p&gt;
&lt;h2 id=&quot;httpclienthandler简说&quot;&gt;2. HttpClientHandler简说&lt;/h2&gt;
&lt;p&gt;System.Net.Http.HttpClientHandler是一个与tcp层相关的对象，负责与远程服务器进行tcp连接，将HttpRequestMessage转换为http请求包发送给服务端，并等待服务端的响应。(以上这段话是我瞎说，仅供讨论）一般的网络相关配置的证书、代理和认证等在都在这里可以配置。&lt;/p&gt;
&lt;h2 id=&quot;httpclient简说&quot;&gt;3. HttpClient简说&lt;/h2&gt;
&lt;p&gt;System.Net.Http.HttpClient必须与HttpClientHandler关联才能使用，一个HttpRequestMessage经过HttpClient之后，HttpClient的一些默认配置会影响到它，比如默认请求头等。HttpClient是使用关联的HttpClientHandler将HttpRequestMessage发送出去，也就是说，完全可以跳过HttpClient而使用HttpClientHandler来发送请求，方法是写一个类，继承于HttpClientHandler并公开一个方法，调用基类的SendAsync方法就可以发送请求。&lt;/p&gt;
&lt;h2 id=&quot;webapiclient库的httpclient配置&quot;&gt;4. WebApiClient库的HttpClient配置&lt;/h2&gt;
&lt;p&gt;WebApiClient库是对HttpClient的封装，所有的配置项在HttpApiConfig对象， 实例化HttpApiConfig对象时有个构造器可以传入IHttpClient的实例，而IHttpClient是对System.Net.Http.HttpClient的一个包装接口定义，WebApiClient.Defaults.HttpClient是对IHttpClient接口的一个实现，才下代码是WebApiCient与System.Net.Http.HttpClient的一个衔接：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IHttpClient client = new WebApiClient.Defaults.HttpClient();
var config = new WebApiClient.HttpApiConfig(client);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ihttpclient接口&quot;&gt;5. IHttpClient接口&lt;/h2&gt;
&lt;h3 id=&quot;ihttpclient的接口定义&quot;&gt;5.1 IHttpClient的接口定义&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 定义HttpClient的接口
/// &amp;lt;/summary&amp;gt;
public interface IHttpClient : IDisposable
{
    /// &amp;lt;summary&amp;gt;
    /// 获取关联的Http处理对象
    /// &amp;lt;/summary&amp;gt;
    HttpClientHandler Handler { get; }

    /// &amp;lt;summary&amp;gt;
    /// 获取默认的请求头管理对象
    /// &amp;lt;/summary&amp;gt;
    HttpRequestHeaders DefaultRequestHeaders { get; }

    /// &amp;lt;summary&amp;gt;
    /// 异步发送请求
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;request&quot;&amp;gt;请求消息&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpApiRequestMessage request);
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ihttpclient的接口意图&quot;&gt;5.2 IHttpClient的接口意图&lt;/h3&gt;
&lt;p&gt;IHttpClient接口意图将System.Net.Http.HttpClient实例和System.Net.Http.HttpClientHandler实例进行组合封装，隐藏底层的一些细节，同时描述了HttpClient和HttpClientHandler不可分割的关系，其默认实现对象WebApiClient.Defaults.HttpClient将System.Net.Http.HttpClient难用的几个功能也封装了一次：比如设置Cookie和设置代理等。&lt;/p&gt;
&lt;h3 id=&quot;更换webapiclient.defaults.httpclient关联的httpclienthandler&quot;&gt;5.3 更换WebApiClient.Defaults.HttpClient关联的HttpClientHandler&lt;/h3&gt;
&lt;p&gt;一般而言，HttpClient没有多少扩展的价值，但HttpClientHandler就有很多扩展空间，其中System.Net.Http.WebRequestHandler也派生于HttpClientHandler，多了很一些配置的属性，很多时候，需要替换WebApiClient.Defaults.HttpClient的HttpClientHandler就可以，而不用从头实现IHttpClient接口，以下方式可以替换HttpClientHandler：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class MyHttpClient : WebApiClient.Defaults.HttpClient
{
    protected override HttpClientHandler CreateHttpClientHandler()
    {
        // or return your handler
        return new WebRequestHandler();
    }
} 

var config = new HttpApiConfig(new MyHttpClient());
var myWebApi = HttpApiClient.Create(config);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是外部的HttpClientHandler实例，可以使用如下方式关联：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var client = new WebApiClient.Defaults.HttpClient(handler);
var config = new HttpApiConfig(client);
var myWebApi = HttpApiClient.Create(config);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展jsonformatter&quot;&gt;6. 扩展JsonFormatter&lt;/h2&gt;
&lt;p&gt;WebApiClient.Defaults.JsonFormatter使用了json.net，每次序列化或反序列化时都会创建JsonSerializerSettings，可以派生WebApiClient.Defaults.JsonFormatter返回自定义的JsonSerializerSettings：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class MyJsonFormatter : WebApiClient.Defaults.JsonFormatter
{
    protected override JsonSerializerSettings CreateSerializerSettings()
    {
        return new JsonSerializerSettings
        {
            // your setting
        };
    }
}


var config = new HttpApiConfig
{
    JsonFormatter = new MyJsonFormatter()
};
var myWebApi = HttpApiClient.Create(config);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展webapiclient.defaults.keyvalueformatter&quot;&gt;7. 扩展WebApiClient.Defaults.KeyValueFormatter&lt;/h2&gt;
&lt;p&gt;KeyValueFormatter基于Middleware思想，内部由多个转换器相连组成，随着转换器的增加，支持的类型也更多，KeyValueFormatter默认支持序列化以下类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、常用简单类型及其空类型(byte、int、short、long、doublue、flout、string、decimal、DateTime、Guid、enum、Version和Uri)&lt;/li&gt;
&lt;li&gt;2、支持IEnumerable递归拆解，默认最多16层&lt;/li&gt;
&lt;li&gt;3、KeyValuePair&amp;lt;,&amp;gt;的任意泛型&lt;/li&gt;
&lt;li&gt;4、多属性模型的第一层属性拆解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你需要支持更多的类型，需要派生KeyValueFormatter增加功能:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class MyKeValueFormatter : WebApiClient.Defaults.KeyValueFormatter
{
    protected override IEnumerable&amp;lt;ConverterBase&amp;gt; GetConverters()
    {
        // 在原有转换器之前插入DynamicObjectConverter
        var addin = new[] { new DynamicObjectConverter() };
        return addin.Concat(base.GetConverters());
    }
}

/// &amp;lt;summary&amp;gt;
/// 表示动态类型转换器
/// &amp;lt;/summary&amp;gt;
class DynamicObjectConverter : ConverterBase
{
    /// &amp;lt;summary&amp;gt;
    /// 执行转换
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;context&quot;&amp;gt;转换上下文&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public override IEnumerable&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt; Invoke(ConvertContext context)
    {
        var dynamicObject = context.Data as DynamicObject;
        if (dynamicObject != null)
        {
            return from name in dynamicObject.GetDynamicMemberNames()
                   let value = this.GetValue(dynamicObject, name)
                   let ctx = new ConvertContext(name, value, context.Depths, context.Options)
                   select ctx.ToKeyValuePair();
        }

        return this.Next.Invoke(context);
    }

    /// &amp;lt;summary&amp;gt;
    /// 获取动态类型的值
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;dynamicObject&quot;&amp;gt;实例&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;name&quot;&amp;gt;名称&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private object GetValue(DynamicObject dynamicObject, string name)
    {
        object value;
        var binder = new MemberBinder(name);
        dynamicObject.TryGetMember(binder, out value);
        return value;
    }

    /// &amp;lt;summary&amp;gt;
    /// 表示成员值的获取绑定
    /// &amp;lt;/summary&amp;gt;
    private class MemberBinder : GetMemberBinder
    {
        /// &amp;lt;summary&amp;gt;
        /// 键的信息获取绑定
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;键名&amp;lt;/param&amp;gt;
        public MemberBinder(string key)
            : base(key, false)
        {
        }

        /// &amp;lt;summary&amp;gt;
        /// 在派生类中重写时，如果无法绑定目标动态对象，则执行动态获取成员操作的绑定
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;target&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;errorSuggestion&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
        {
            throw new NotImplementedException();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Jan 2018 04:09:00 +0000</pubDate>
<dc:creator>jiulang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kewei/p/8320247.html</dc:identifier>
</item>
<item>
<title>WPF: WpfWindowToolkit 一个窗口操作库的介绍 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/WpfWindowToolkit_Intro.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/WpfWindowToolkit_Intro.html</guid>
<description>&lt;p&gt;在 &lt;span lang=&quot;EN-US&quot;&gt;XAML 应用的开发过程中，使用 &lt;span lang=&quot;EN-US&quot;&gt;MVVM 框架能够极大地提高软件的可测试性、可维护性。&lt;span lang=&quot;EN-US&quot;&gt;MVVM 的核心思想是关注点分离，使得业务逻辑从 &lt;span lang=&quot;EN-US&quot;&gt;View 中分离出来到 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 以及 &lt;span lang=&quot;EN-US&quot;&gt;Model 中，从逻辑上来讲，这也是业务逻辑应该处的位置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体来说，借助于数据绑定 (Data Binding) 以及命令 (Command) 等这些&lt;span lang=&quot;EN-US&quot;&gt;XAML 平台自身所提供的机制，使得 &lt;span lang=&quot;EN-US&quot;&gt;MVVM 在 &lt;span lang=&quot;EN-US&quot;&gt;XAML 平台上很容易实现。但是，如果你对 &lt;span lang=&quot;EN-US&quot;&gt;XAML 应用开发以及 &lt;span lang=&quot;EN-US&quot;&gt;MVVM 的使用有一定的经验，你会发现，单纯 &lt;span lang=&quot;EN-US&quot;&gt;MVVM 本身并不能解决所有问题，比如页面导航、弹出对话框、窗口操作等，这时就需要结合一些与它相关的技术，如消息、行为、服务以及依赖注入等。这个原因是 &lt;span lang=&quot;EN-US&quot;&gt;MVVM 主要针对的是 &lt;span lang=&quot;EN-US&quot;&gt;View 的内容，而不是 &lt;span lang=&quot;EN-US&quot;&gt;View 本身的操作或其它别的东西，所以像弹出窗口或者页面导航之类的操作就需要上述技术的配合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;更具体一点，在 &lt;span lang=&quot;EN-US&quot;&gt;WPF 应用的开发过程中，很多时候我们需要打开和关闭窗口。要以“&lt;span lang=&quot;EN-US&quot;&gt;MVVM方式”来实现，就不容易。当然，我们可以使用消息来解决这个问题。不过，如果过多地使用消息，也会使代码难以维护并且增加调试的难度。&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文主要通过分享一个类库来解决这一问题：&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://github.com/imnbwd/WpfWindowToolkit&quot; target=&quot;_blank&quot;&gt;WpfWindowToolkit&lt;/a&gt;&lt;/strong&gt;，就如名称所示，它是针对窗口的一些操作类的集合&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/676860/201801/676860-20180120100151490-511731457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;一、基本介绍&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;从介绍里，我们可以看出，它可以解决窗口的打开与关闭，以及在窗口间传递参数和返回值等类的问题，而实现这一切都不需要我们在 &lt;span lang=&quot;EN-US&quot;&gt;View 的 &lt;span lang=&quot;EN-US&quot;&gt;CodeBehind 中写任何代码，也不需要借助于消息，所需要作的修改仅在 &lt;span lang=&quot;EN-US&quot;&gt;XAML 代码和 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 中，从而遵循了 &lt;span lang=&quot;EN-US&quot;&gt;MVVM 的原则并达到了其目的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从 &lt;span lang=&quot;EN-US&quot;&gt;Github (&lt;a href=&quot;http://github.com/imnbwd/WpfWindowToolkit&quot; target=&quot;_blank&quot;&gt;http://github.com/imnbwd/WpfWindowToolkit&lt;/a&gt;)下载到源码后，其中有 &lt;span lang=&quot;EN-US&quot;&gt;Demo，通过这个 &lt;span lang=&quot;EN-US&quot;&gt;Demo 我们可以了解它是如何使用的。在以下的内容里，我们先简单对它有些了解，更为具体的内容则可以看它的源码和 &lt;span lang=&quot;EN-US&quot;&gt;Demo。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、安装&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;要在项目中使用它，可以从 &lt;span lang=&quot;EN-US&quot;&gt;Nuget 上下载，或者直接使用命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
InstallPackage WpfWindowToolkit
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;三、如何使用&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;1. 打开窗口&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;有两种方式：使用附加属性或行为。&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;在使用时，需要先添加命名空间：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;    xmlns:behaviors=&quot;clr-namespace:PraiseHim.Rejoice.WpfWindowToolkit.Behaviors;assembly=WpfWindowToolkit&quot;
    xmlns:helpers=&quot;clr-namespace:PraiseHim.Rejoice.WpfWindowToolkit.Helpers;assembly=WpfWindowToolk&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;附加属性：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;btn1&quot;&lt;/span&gt;&lt;span&gt;
        helpers:WindowHelper.OpenWindowType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type local:Window1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        Content&lt;/span&gt;&lt;span&gt;=&quot;Open window using Window Helper&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;行为：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;btn5&quot;&lt;/span&gt;&lt;span&gt;
        Margin&lt;/span&gt;&lt;span&gt;=&quot;0,5,0,0&quot;&lt;/span&gt;&lt;span&gt;
        Content&lt;/span&gt;&lt;span&gt;=&quot;Open window with parameter using action&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i:Interaction.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i:EventTrigger &lt;/span&gt;&lt;span&gt;EventName&lt;/span&gt;&lt;span&gt;=&quot;Click&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;behaviors:OpenWindowAction &lt;/span&gt;&lt;span&gt;Parameter&lt;/span&gt;&lt;span&gt;=&quot;WPF (action)&quot;&lt;/span&gt;&lt;span&gt; WindowType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type local:Window1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt; 
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i:EventTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i:Interaction.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，它们都是通过将要打开的窗口的类型(Type) 指定给 WindowType 属性。&lt;/p&gt;
&lt;h3&gt;2. 打开窗口时传递参数&lt;/h3&gt;
&lt;p&gt;要在打开窗口的同时，向其 ViewModel 传递参数，也很简单。同上面一样，只需要再为 &lt;span lang=&quot;EN-US&quot;&gt;Parameter 属性赋值即可，这个 &lt;span lang=&quot;EN-US&quot;&gt;Parameter 可以绑定到当前窗口的 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 的成员上，因此，可以将任何类型的数据传递给要打开的窗口。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来，则是需要注意的，要对被打开的窗口的 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 作一些修改：使它继承 &lt;span lang=&quot;EN-US&quot;&gt;ViewModelBaseData&amp;lt;T&amp;gt;，这里的 &lt;span lang=&quot;EN-US&quot;&gt;T 就是所传递参数的类型。然后，通过 &lt;span lang=&quot;EN-US&quot;&gt;InternalData 属性即可得到传递过来的参数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;behaviors:OpenWindowAction &lt;/span&gt;&lt;span&gt;Parameter&lt;/span&gt;&lt;span&gt;=&quot;WPF (action)&quot;&lt;/span&gt;&lt;span&gt; WindowType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type local:Window1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Window1ViewModel : ViewModelBaseData&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
    {   
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; InternalData { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        ...
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在打开窗口时，还有一种复杂的方式，同时也会给使用者更灵活的控制。方法是，当前窗口继承 &lt;span lang=&quot;EN-US&quot;&gt;ViewModelBaseEx 类，然后调用它的 &lt;span lang=&quot;EN-US&quot;&gt;ShowWindow 方法。在此，再不详述，具体可以参考 &lt;span lang=&quot;EN-US&quot;&gt;Github 上的说明文档。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;3. 从被打开的窗口中返回值&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当关闭打开的窗口，要实现这个目的，也需要两步，首先，第一个窗口（要打开其它窗口的那个窗口）的 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 需要继承 &lt;span lang=&quot;EN-US&quot;&gt;ViewModelBaseEx，或 &lt;span lang=&quot;EN-US&quot;&gt;ViewModelBaseEx&amp;lt;T&amp;gt; 类，然后使用 &lt;span lang=&quot;EN-US&quot;&gt;ShowWindow(OpenWindowInfo, Action&amp;lt;TReturnValue&amp;gt;) 方法来打开窗口，其中第二个参数是一个带参数的 &lt;span lang=&quot;EN-US&quot;&gt;Action，这里的参数就是返回值，在这个 &lt;span lang=&quot;EN-US&quot;&gt;Action 中，我们就可以处理返回值 。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ReturnValueMainWindowViewModel : ViewModelBaseEx&amp;lt;Friend&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ShowFriendSelectionWindow()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ShowWindow(&lt;span&gt;new&lt;/span&gt; OpenWindowInfo { WindowType = &lt;span&gt;typeof&lt;/span&gt;(ReturnValueTestWindow) }, friend =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (friend != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;You have selected this friend: {friend.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No friend has been selected&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步，被打开的窗口的 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel，需要实现 &lt;span lang=&quot;EN-US&quot;&gt;IWindowReturnValue&amp;lt;T&amp;gt; 接口，这个接口包含 &lt;span lang=&quot;EN-US&quot;&gt;ReturnValue 属性，我们只要为它赋值就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ReturnValueTestWindowViewModel : BindableBase, IWindowReturnValue&amp;lt;Friend&amp;gt;&lt;span&gt;
    {
        ...
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetReturnValue() 
        {
            ReturnValue &lt;/span&gt;=&lt;span&gt; SelectedFriend;
        }
        ...
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;4. 关闭窗口&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在 View 中关闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要关闭窗口，可以使用 &lt;span lang=&quot;EN-US&quot;&gt;CloseWindowAction，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;=&quot;Close the current window with confirmation&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i:Interaction.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i:EventTrigger &lt;/span&gt;&lt;span&gt;EventName&lt;/span&gt;&lt;span&gt;=&quot;Click&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;behaviors:CloseWindowAction &lt;/span&gt;&lt;span&gt;ClosingCheckFunc&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding CheckBeforeCloseWindow}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i:EventTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i:Interaction.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它提供一个属性 &lt;span lang=&quot;EN-US&quot;&gt;ClosingCheckFunc，可以绑定到一个返回布尔值的函数，如果此函数返回 &lt;span lang=&quot;EN-US&quot;&gt;true，则关闭，否则，则不关闭。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;strong&gt;处理 Window.Closing 事件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除此以外，在窗口被关闭时，它也提供对 &lt;span lang=&quot;EN-US&quot;&gt;Window 的 &lt;span lang=&quot;EN-US&quot;&gt;Closing 事件的支持，通常我们可能会在这个事件处理中来询问是否关闭窗口。要这么做，只要为当前窗口添加一个行为即可，如下：&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i:Interaction.Behaviors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;behaviors:ClosingWindowBehavior &lt;/span&gt;&lt;span&gt;ClosingCheckFunc&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding CheckBeforeCloseWindow}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i:Interaction.Behaviors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而其中的 &lt;span lang=&quot;EN-US&quot;&gt;ClosingCheckFunc 属性所指向的方法则是我们在 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 中添加的判断逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;在 ViewModel 中关闭窗口&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外，它也支持在 &lt;span lang=&quot;EN-US&quot;&gt;ViewModel 的中来关闭当前窗口，首先，为窗口添加行为：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;i:Interaction.Behaviors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;behavior:EnableWindowCloseBehavior &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;i:Interaction.Behaviors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，&lt;span lang=&quot;EN-US&quot;&gt;ViewModel 需要实现 &lt;span lang=&quot;EN-US&quot;&gt;IClosable 接口，它包含一个 &lt;span lang=&quot;EN-US&quot;&gt;Action，名为&lt;span lang=&quot;EN-US&quot;&gt;CloseAction 并在合适的位置调用 &lt;span lang=&quot;EN-US&quot;&gt;CloseAction 即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CloseTestViewModel : BindableBase, IClosable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action CloseWindow { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        ...
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   CloseWindow?.Invoke();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; or just CloseWindow();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 总结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了 WPF 窗口操作库——WpfWindowToolkit 的使用，它完全支持 MVVM，能够解决窗口的打开、关闭、窗口间的传值与返回值等问题。如果你正在开发 WPF 应用，并且采用了 MVVM 模式，不妨试一个这个库。要想多了解，可以到 Github 上下载其源码。&lt;/p&gt;
&lt;p&gt;如果什么问题或建议，欢迎随时交流。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 03:32:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/WpfWindowToolkit_Intro.html</dc:identifier>
</item>
<item>
<title>CountDownLatch源码解析 - 不懂是非</title>
<link>http://www.cnblogs.com/qm-article/p/8320177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qm-article/p/8320177.html</guid>
<description>&lt;p&gt;　　　　　　&lt;span&gt;CountDownLatch是在jdk1.5被引入的，它主要是通过一个计数器来实现的，当在初始化该类的构造函数时，会事先传入一个状态值，之后在执行await方法后，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在这个状态值为0之前，当前线程(指的是调用await的线程)会一直等待。它内部使用了AQS来实现的，且是共享锁，具体怎么实现，待会看看它的实现原理。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　　　它的应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　一般在于在执行当前线程之前，要完成n个线程的任务，才能执行当前线程。这种场景适合用countdownLatch。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;span&gt;　　先来看看该类的构造，如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/900767/201801/900767-20180120095540459-1521765100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;如图，红色框选中的是该类的一个内部类，该内部类实现了抽象类AQS，具体锁的获取和释放是由该内部类实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　由上图知countdownLatch只有一个构造函数，&lt;/span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  　　&lt;span&gt;public&lt;/span&gt; CountDownLatch(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (count &amp;lt; 0) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;count &amp;lt; 0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sync = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sync(count);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　　　很明显，它有一个参数，这个参数，被用在哪里呢，请看下面&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　　　　Sync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            setState(count);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　　　　这个参数最终用在了状态值上，由此可猜测，这个状态值决定这锁什么时候释放。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　　　　　&lt;/span&gt;1、内部类Sync&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Sync &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractQueuedSynchronizer {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 4982264981922014374L&lt;span&gt;;

        Sync(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
            setState(count);//设置状态值的大小
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getState();//获取状态值
        }
　　　　//当状态值为0才返回1，否则返回-1，也用来判断线程是否拥有该锁，值大于0，不拥有，小于0，则拥有
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (getState() == 0) ? 1 : -1&lt;span&gt;;
        }
　　　　　//对状态值进行操作，每一次成功，则状态值-1，&lt;br/&gt;　　　　　//也知道只有状态值为1，然后再执行该方法，才会返回true，否则其它情况全是返回false
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decrement count; signal when transition to zero&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {//这个无限循环是为了保证在进行有其他线程也在操作状态值，导致失败之后就不操作了
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nextc = c-1&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(c, nextc))//对状态值递减，若有其他线程也在操作，则可通过for的无限循环来保证一定能递减成功
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextc == 0&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;该类重写了AQS的tryAcquireShared(int)和tryReleaseShared(int)两个方法，　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面来看看这个CountDownLatch类常用的方法&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　　　&lt;/span&gt;　2、await()方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; await() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         sync.acquireSharedInterruptibly(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            doAcquireSharedInterruptibly(arg);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;在调用await方法时，再用sync去调用AQS的内部方法acquireSharedInterruptibly(因为sync类没重写该方法)，会先判断当前线程是否被中断(中断一般是由外部条件引起的)，若中断直接抛出异常，否则，获取通过&lt;/span&gt;&lt;span&gt;tryAcquireShared方法来判断当前线程是否拥有该共享锁，当值小于0，则拥有，大于0，则不拥有，继续下一步，若有锁，则再执行doAcquireSharedInterruptibly方法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAcquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.SHARED);//对当前线程进行一个包装，同时也初始化了等待队列，即head-&amp;gt;node-&amp;gt;...-&amp;gt;tail
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();//获取该node节点的前一个节点，一般首次调用时，该前一个节点就是head节点。
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);//再次获取锁的状态，
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {//若状态值为0，则进入
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                        setHeadAndPropagate(node, r);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                         failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }&lt;br/&gt;　//shouldParakAfterFailedAcquire方法主要是针对node节点的状态进行操作，若为signal，则挂起，若为0或PROPAGATE，则转换成signal，为cancelled，则放弃，寻找前一个不是该状态值的节点
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    parkAndCheckInterrupt())//挂起线程
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)//若failed为true，一般是出现了异常，或者线程被中断
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                cancelAcquire(node);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　　　从上述分析来看，只有当状态值为0的时候，才会调用&lt;/span&gt;&lt;span&gt;setHeadAndPropagate(node,int)方法，否则会无限等待，当前线程也会被挂起，该方法源码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
        Node h &lt;/span&gt;=&lt;span&gt; head; 
        setHead(node);//将node节点设置为头结点，对比前面的doAcquireSharedInterruptibly方法，也就是头结点的下一个节点,且该节点的状态为shared
      　　//对propagate值，头结点和状态，进行判断
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; 0 || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0 ||&lt;span&gt;
            (h &lt;/span&gt;= head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0&lt;span&gt;) {
            Node s &lt;/span&gt;=&lt;span&gt; node.next;//获取node节点的下一个节点
    　　　　　//对node节点的下一个节点进行判断，是否为null，和状态值是否为shared
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
　　　　　　　　　　//该方法作用为了释放当前锁，即线程阻塞
                doReleaseShared();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　&lt;span&gt;上面说的是执行await方法后，发生的一系列操作，也知道了只有当状态值为0，才会使线程通行，下面来看一看怎么使状态值为0的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　&lt;/span&gt;3、countDown方法&lt;/h2&gt;
&lt;p&gt;　　　　&lt;span&gt;在调用tryReleaseShared方法，每调用一次，state值就会减一，但除了某个时刻当state值减一后恰好为0，才会返回true，否则返回false，为0时刻，也表明锁被其它线程给释放了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countDown() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         sync.releaseShared(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 　　　　　//尝试获取锁的状态
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            doReleaseShared();//此时，状态值已经为0，执行doReleasseShared方法，
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　&lt;span&gt;也许会有人有疑问，说，为什么在执行await方法后的一些类操作中，也执行了doReleaseShared方法，这岂不是要释放两次？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;span&gt;其实不然，主要是怕doAcquireSharedInterruptibly方法执行后，由于某种原因，当前线程为挂起（即阻塞了），不再执行了，这时只有通过releaseShared方法来唤醒线程，下面看看doReleaseShared方法的实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            Node h &lt;/span&gt;=&lt;span&gt; head;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {//若头结点状态为signal，则进入，头结点初始化时的状态值为0
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))//若交换失败，则终止此步操作，继续下一轮循环
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases&lt;/span&gt;
&lt;span&gt;                    unparkSuccessor(h);//这是释放锁的关键
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == 0 &amp;amp;&amp;amp;
                         !compareAndSetWaitStatus(h, 0&lt;span&gt;, Node.PROPAGATE))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若head节点被改变了，则继续循环，否则，跳出循环&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　unparkSuccessor(node)分析如下，该方法作用是为了释放node节点的后一个节点中的线程，在这里，node节点就是head节点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
      
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; node.waitStatus;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;)
            compareAndSetWaitStatus(node, ws, &lt;/span&gt;0&lt;span&gt;);

       
        Node s &lt;/span&gt;=&lt;span&gt; node.next;&lt;br/&gt;　　　　　　//下一个节点为null或状态值为cancelled，
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
            s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　　　//由后往前搜索，节点状态值小于或等于0的节点(即状态值不是cancelled值),搜索到的结果一定是最靠近node节点的，且状态值&amp;lt;=0.&lt;br/&gt;　　　　　　　　//至于为什么不从前往后搜索，原因不太清楚！！！&lt;br/&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;)
                    s &lt;/span&gt;=&lt;span&gt; t;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            LockSupport.unpark(s.thread);//释放
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;　　　　countdownLatch&lt;/span&gt;&lt;span&gt;在初始化构造函数时，会先将参数设置为状态state值，&lt;/span&gt;&lt;span&gt;之后执行await方法后，会进行这一系列的步骤&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　1、将shared和当前线程包装成一个node节点，(在第一次调用还会初始化等待队列)在队列中，有这样的队列 head-&amp;gt;node,其中node就是被包装成share的节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、之后在doAcquireSharedInterruptibly方法中，执行了shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法， 若顺利，则head节点的状态值会变为signal，并且当前线程会通过执行park方法进行挂起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　3、在方法tryReleaseShared中，会一直操作state值，使之减1，一直到state的值,减为0时，在这之前，当前线程一直会被阻塞。当为0时，会执行&lt;/span&gt;&lt;span&gt;doReleaseShared方法 对当前线程执行unparkSuccessor方法，进行放行。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　以上就是我对countdownLatch类的理解，若有不足之处，还望指正！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 03:26:00 +0000</pubDate>
<dc:creator>不懂是非</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qm-article/p/8320177.html</dc:identifier>
</item>
<item>
<title>迟到的2017年终总结与2018目标规划 - 萌萌丶小魔王</title>
<link>http://www.cnblogs.com/xiaomowang/p/8320057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaomowang/p/8320057.html</guid>
<description>&lt;p&gt;就在2018年的1月1日，我就麻烦不断，一直处理到昨天才算消停。这一晃，新的一年1月份已快到结尾了。由于个人原因，好几个月没来园子里逛逛了，博客也有一段时间没有更新了。&lt;/p&gt;
&lt;p&gt;下面，来总结一下我的2017年，并规划一下2018年。&lt;/p&gt;
&lt;p&gt;首先，总结一下2017年的情况，记得我写过一篇&lt;a title=&quot;2017年目标与规划&quot; href=&quot;http://www.cnblogs.com/xiaomowang/p/6349450.html&quot; target=&quot;_blank&quot;&gt;2017年目标与规划&lt;/a&gt;，其中，定下了目标与规划：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标1&lt;/strong&gt;，坚持写博文：完成《设计模式系列》博文的编写，完成对《深入浅出MVC系列》博文的编写 &lt;/p&gt;
&lt;p&gt;这个目标基本完成了，大家可以看到我的博文中《设计模式系列》已经完成  《深入浅出MVC系列》也基本完成，就是坚持写博文稍微欠缺一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标2&lt;/strong&gt;，锻炼身体 从80Kg减到63Kg，减少撸管次数&lt;/p&gt;
&lt;p&gt;此目标失败，目前体重为70Kg，撸管次数已经下降到每周3次左右&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标3&lt;/strong&gt;，技能修炼 设计模式的运用，对Web方向的技能达到精通的程度，读两本技能书籍&lt;/p&gt;
&lt;p&gt;此目标基本完成 由于在实际项目中，不能为了设计模式而设计模式，所以设计模式运用这一块进步不是很大，但Web方向的技能可谓是飞速增长。读两本技能书籍完成，我读的是《大话设计模式》、《深入浅出MVC》这两本书已读完。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标4&lt;/strong&gt;，精神物质存款50K&lt;/p&gt;
&lt;p&gt;此目标已经完成，嘿嘿&lt;/p&gt;
&lt;p&gt;总结2017年这一年，当初顶下的目标与规划已经基本完成，总体来看没有留下什么遗憾，对此，我略感欣慰。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;下面，对2018年定一下目标与规划。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、坚持写博文：&lt;/p&gt;
&lt;p&gt;1、EF 系列博文  2、MVC博文补充 &lt;/p&gt;
&lt;p&gt;二、自己的项目&lt;/p&gt;
&lt;p&gt;在这一年，将启动一个自己的项目玩玩（玩大的）。&lt;/p&gt;
&lt;p&gt;三、读书&lt;/p&gt;
&lt;p&gt;读两本关于技能的书籍，可以重复，毕竟重复阅读可以增加印象，理解更深。&lt;/p&gt;
&lt;p&gt;四、锻炼身体&lt;/p&gt;
&lt;p&gt;1、每天10个俯卧撑（可酌情增加），2、目前体重为70Kg，减到63Kg&lt;/p&gt;
&lt;p&gt;五、物质&lt;/p&gt;
&lt;p&gt;1、存款达到100K&lt;/p&gt;
&lt;p&gt;以上就是对2018年的总结与规划，努力吧，骚年。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;      &lt;strong&gt; 纵，一世苍凉&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        风吹散了记忆，不言寂寞，不诉离殇。轻轻，剪一枚清月，挂于云水之上。不惊动夜的沉寂，不打捞暮色的薄凉。请许我，斟一怀月色，在一朵莲的姿态里安放。饮一瓣馨香，煨暖，所有的沧桑。&lt;br/&gt;        指尖流年，逐波了那些浮华的过往。倚着岁月的恬淡，透明的心事，碾墨西窗。一笔素净，一笔清幽，淡描荷妆。不勾勒，细雨串起的珠帘，点缀过绝世的芬芳。不晕染，兰桡划过的涟漪，千里柔波荡漾。蝶儿翻飞的旧梦，就留给定格了的那些时光。&lt;br/&gt;纵，岁月褪去了一袭嫣然，却洗不去素韵清扬。不言超然出尘，不是孤芳自赏。只留一把风骨，与宁静相守，与彼岸相望。&lt;br/&gt;        我知道，未来的梦，还在沧海中流浪。将思绪化作一叶舟，寻找彼岸的方向。尽管，我的眼里，有你触摸不到的忧伤，&lt;br/&gt;不愿，片片凋零，生疼你的凝望。我的眉梢，不锁忧伤，不锁惆怅。就让，恬静的一幽梦，裹住我纯白的念想。只要你看到我无悔的执着和无畏的坚强。&lt;br/&gt;        幽婉的哀叹，是你穿透现实的向往。没有什么可以阻挡，世间对美好的畅想。最初的回眸浅笑，一定暖了你脚步的苍茫。期盼飞入袅袅的音韵，跋山涉水，漫过所有的苍凉，采集了朝霞和夕阳，作月色的霓裳，与云水执手相望。不远处，谁将春天的歌谣，轻轻吟唱......&lt;br/&gt;        走过琐碎的光阴，我依然伫立静水一方。任西风吹皱的倒影，衬着蒹葭苍苍。不叹息，莲华的刹那，不幽怨，年华染了风霜。我将飘落的花瓣，研成一笔丹青，点缀你的诗行。躺在流年的墨迹中，永远为你，默默绽放。&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jan 2018 02:44:00 +0000</pubDate>
<dc:creator>萌萌丶小魔王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaomowang/p/8320057.html</dc:identifier>
</item>
<item>
<title>网络基础知识--子网划分 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8302473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8302473.html</guid>
<description>&lt;h2&gt;　　 一：网络设备及其架构介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117130813740-482016640.png&quot; alt=&quot;&quot; width=&quot;679&quot; height=&quot;526&quot;/&gt;&lt;/p&gt;
&lt;p&gt;计算机网络发展过程&lt;/p&gt;
&lt;p&gt;计算机与通信的融合过程就是计算机网络的发展过程，利用通信线路把位于不同的点上的多个计算机系统相互连接起来便形成了计算机网络，在网络中，通过功能完善的网络软件的管理，可以共享某些软件，硬件和数据资源。&lt;/p&gt;
&lt;p&gt;计算机网络是计算机技术与通讯技术紧密结合的产物，计算机网络的发展过程经历了三个阶段：具有通信功能的单机系统，具有通信功能的多机系统和计算机网络。&lt;/p&gt;
&lt;p&gt;面向终端分布的计算机系统&lt;/p&gt;
&lt;p&gt;计算机--终端系统是把多台远程终端设备，通过公用电话网链接到一台中央计算机所构成的面向终端分布的计算机系统，就解决远程信息收集，计算和处理。计算机--终端系统提供了计算机通信的许多基本技术，而这种系统本身也成为以后发展的计算机网络组成部分。因此，这种终端联机系统也称为面向终端分布的计算机通信网，也有人称他为第一代的计算机网络。&lt;/p&gt;
&lt;p&gt;分组交换数据网&lt;/p&gt;
&lt;p&gt;由于计算机的数据是突发式和间歇性的出现在传输线路上，因此传统的电路交换技术不适合计算机数据的传输。在整个占线期间，真正传送数据的时间往往不到10%甚至只有1%，所以他对线路的利用率很低，不过他的优点是实时性比较好。&lt;/p&gt;
&lt;p&gt;局域网（LAN）的发展&lt;/p&gt;
&lt;p&gt;局域网有三种基本的拓扑结构，分别是总线型，环形和星型。市场提供的三种实用的传输介质是双绞线，同铢电缆和光纤，无线传输介质的无限LAN也正在受到重视。&lt;/p&gt;
&lt;h2&gt;二，ip地址的定义和分类&lt;/h2&gt;
&lt;h3&gt;2.1定义&lt;/h3&gt;
&lt;p&gt;ip地址是唯一标识网络上的计算机，ip是由一个32位的0,1字符串组成。网络中的每个路由或者主机都会拥有一个独一无二的ip地址。用于区分用户。&lt;/p&gt;
&lt;p&gt;根据tcp／ip协议，连接在internet上的每个设备都必须有一个ip地址，他是一个32位二进制数，也可以用点分十进制表示，每八位一组，用一个十进制表示即0～255，每组用&quot;.&quot;分隔开，例如172.16.45.10&lt;/p&gt;
&lt;p&gt;ip地址表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117212752131-132130429.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2 ip分类&lt;/h3&gt;
&lt;p&gt;32比特的ip地址被分为两个部分：&lt;/p&gt;
&lt;p&gt;          ————网络号（NetWork ID ， NID）&lt;/p&gt;
&lt;p&gt;         ————主机号（Host ID，HID）&lt;/p&gt;
&lt;p&gt;IPv4定义了5类ip地址，分别为A，B，C，D，E类地址。&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;A类地址：&lt;br/&gt;A类地址前1段网络号，后3段主机号，并且第一位必须为0：&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;网络位&lt;/th&gt;
&lt;th&gt;24位主机号&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;XXX XXXX&lt;/td&gt;
&lt;td&gt;XXXX XXXX XXXX XXXX XXXX XXXX&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最小值-&amp;gt;&lt;/td&gt;
&lt;td&gt;0 000 0001 (1)&lt;/td&gt;
&lt;td&gt;全0不取&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最大值-&amp;gt;&lt;/td&gt;
&lt;td&gt;0 111 1110 (126)&lt;/td&gt;
&lt;td&gt;全1不取&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;B类地址：&lt;br/&gt;B类地址前2段网络号，后2段主机号，&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;网络位&lt;/th&gt;
&lt;th&gt;16位主机号&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;XX XXXX XXXX XXXX&lt;/td&gt;
&lt;td&gt;XXXX XXXX XXXX XXXX&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最小值-&amp;gt;&lt;/td&gt;
&lt;td&gt;10 00 0000 (128)&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最大值-&amp;gt;&lt;/td&gt;
&lt;td&gt;10 11 1111 (191)&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;C类地址：&lt;br/&gt;C类地址前3段网络号，后1段主机号，&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;网络位&lt;/th&gt;
&lt;th&gt;8位主机号&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;X XXXX XXXX XXXX XXXX XXXX&lt;/td&gt;
&lt;td&gt;XXXX XXXX&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最小值-&amp;gt;&lt;/td&gt;
&lt;td&gt;110 0 0000 (192)&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最大值-&amp;gt;&lt;/td&gt;
&lt;td&gt;110 1 1111 (223)&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;D类地址：&lt;br/&gt;D类地址主要作为组播地址存在。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;网络位&lt;/th&gt;
&lt;th&gt; &lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1110&lt;/td&gt;
&lt;td&gt;XXXX XXXX XXXX XXXX XXXX XXXX XXXX&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最小值-&amp;gt;&lt;/td&gt;
&lt;td&gt;1110 0000 (224)&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;第一位域最大值-&amp;gt;&lt;/td&gt;
&lt;td&gt;1110 1111 (239)&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;E类地址：&lt;br/&gt;E类地址主要用于实验：&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;标志位&lt;/th&gt;
&lt;th&gt;网络位&lt;/th&gt;
&lt;th&gt; &lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;ol&gt;&lt;li&gt;1111 0&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;td&gt;
&lt;ol&gt;&lt;li&gt;XXX XXXX XXXX XXXX XXXX XXXX XXXX&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;ol&gt;&lt;li&gt;第一位域最小值-&amp;gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;td&gt;
&lt;ol&gt;&lt;li&gt;1111 0 000 (240)&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;ol&gt;&lt;li&gt;第一位域最大值-&amp;gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;td&gt;
&lt;ol&gt;&lt;li&gt;1111 0 111 (247)&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;将ip地址中的网络位和主机位固定下来后，ip地址被分成了不同的积累：A类，B类，C类，D类，E类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117212839615-372307517.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117213148584-457502837.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3特殊ip地址&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;网络地址：用于表示网络本身，具有正常的网络号部分，而主机号部分全部为0的ip地址称之为网络地址，如172.16.45.0就是一个B类网络地址&lt;/li&gt;
&lt;li&gt;广播地址：用于向网络中的所有的设备进行广播。具有正常的网络号部分，而主机号部分全为1(即255)的ip地址称之为广播地址，如172.16.45.255就是一个B类的网络地址&lt;/li&gt;
&lt;li&gt;有限广播地址：指的是32位全位1(即255.255.255.255)的ip地址，用于本网广播&lt;/li&gt;
&lt;li&gt;回送地址：网络地址不能以十进制的127作为开头，在地址中数字127保留给系统作为诊断用，称为欢送地址，如127.0.0.1用于回路测试&lt;/li&gt;
&lt;li&gt;私有地址：只能在局域网内使用，不能在internet上使用的ip地址称为私有ip地址，私有ip地址有：
&lt;ol&gt;&lt;li&gt;10.0.0.0～10.255.255.255，表示一个A类地址&lt;/li&gt;
&lt;li&gt;172.16.0.0~172.31.255.255,表示16个B类地址&lt;/li&gt;
&lt;li&gt;192.168.0.0～192.168.255.255，表示256个C类地址&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;0.0.0.0:指已经不是真正意义上的ip地址，它表示的是所有不清楚主机和目的网络，这里的不清楚指的是在本机路由表里没有特定条目指明如何到达&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;2.4子网掩码&lt;/h3&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.523076923077&quot;&gt;           RFC 950定义了子网掩码的使用，子网掩码是一个32位的2进制数，其对应&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80&quot; target=&quot;_blank&quot;&gt;网络地址&lt;/a&gt;的所有位置都为1，对应于&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80&quot; target=&quot;_blank&quot;&gt;主机地址&lt;/a&gt;的所有位置都为0。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;11.616&quot;&gt;           由此可知，A类网络的默认&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;子网掩码&lt;/a&gt;是255.0.0.0，B类网络的默认子网掩码是255.255.0.0，C类网络的默认子网掩码是255.255.255.0。将子网掩码和IP地址按位进行逻辑“与”运算，得到IP地址的网络地址，剩下的部分就是主机地址，从而区分出任意IP地址中的网络地址和主机地址。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.9473684210526&quot;&gt;           子网掩码常用&lt;a href=&quot;https://baike.baidu.com/item/%E7%82%B9%E5%88%86%E5%8D%81%E8%BF%9B%E5%88%B6&quot; target=&quot;_blank&quot;&gt;点分十进制&lt;/a&gt;表示，我们还可以用CIDR的&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%89%8D%E7%BC%80&quot; target=&quot;_blank&quot;&gt;网络前缀&lt;/a&gt;法表示掩码，即“/；”。如138.96.0.0/16表示B类网络138.96.0.0的&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;子网掩码&lt;/a&gt;为255.255.0.0。&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;子网掩码用于识别ip地址中的网络地址和主机地址。&lt;/li&gt;
&lt;li&gt;子网掩码也是32位二进制数字，在子网掩码中，对应于网络地址部分全用1表示，主机部分全用0表示 &lt;/li&gt;
&lt;li&gt;还可以用网络前缀表示子网掩码，即&quot;／&amp;lt;网络地址位数&amp;gt;&quot;，如172.16.45.0/24表示B类网络172.16.45.0的子网掩码为255.255.255.0&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117213852349-462938485.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.5 ip地址申请&lt;/h3&gt;
&lt;p&gt;https://www.processon.com/mindmap/57fdad47e4b08d4fe9b3d7e2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117214016787-1882425620.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.6  IP判断&lt;/h3&gt;

&lt;div class=&quot;para&quot; readability=&quot;10.292857142857&quot;&gt;         例如，有两台&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&quot; target=&quot;_blank&quot;&gt;主机&lt;/a&gt;，主机一的IP地址为222.21.160.6，子网掩码为255.255.255.192，主机二的IP地址为222.21.160.73，子网掩码为255.255.255.192。现在主机一要给主机二发送数据，先要判断两个主机是否在&lt;a href=&quot;https://baike.baidu.com/item/%E5%90%8C%E4%B8%80%E7%BD%91%E6%AE%B5&quot; target=&quot;_blank&quot;&gt;同一网段&lt;/a&gt;。&lt;/div&gt;
&lt;p&gt;        主机一&lt;/p&gt;
&lt;p&gt;222.21.160.6即：11011110.00010101.10100000.00000110&lt;/p&gt;
&lt;p&gt;255.255.255.192即：11111111.11111111.11111111.11000000&lt;/p&gt;
&lt;p&gt;按位逻辑与运算结果为：11011110.00010101.10100000.00000000&lt;/p&gt;

&lt;p&gt;        主机二&lt;/p&gt;
&lt;p&gt;222.21.160.73 即：11011110.00010101.10100000.01001001&lt;/p&gt;
&lt;p&gt;255.255.255.192即：11111111.11111111.11111111.11000000&lt;/p&gt;
&lt;p&gt;按位逻辑与运算结果为：11011110.00010101.10100000.01000000&lt;/p&gt;

&lt;p&gt;             C类地址判断前三位是否相同，即可确定2个IP地址是否在同一网段内，但本例中的222.21.160.6与222.21.160.73不在同一网段，因为这两个C类IP地址已经做了子网划分就不能只判断前三位是否相同就确认这两个IP是否在同一网段。其中222.21.160.6在222.21.160.1-222.21.160.62 段，222.21.160.73在222.21.160.65-222.21.160.126 段，所以不在同一网段&lt;sup&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;/sup&gt;  ，如果要通信需要通过路由器转发。&lt;/p&gt;

&lt;h2&gt;三，子网划分&lt;/h2&gt;
&lt;h3&gt;3.1子网划分概念&lt;/h3&gt;
&lt;p&gt;            子网划分定义：Internet组织机构定义了五种IP地址，有A、B、C三类地址。A类网络有126个，每个A类网络可能有16777214台&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&quot; target=&quot;_blank&quot;&gt;主机&lt;/a&gt;，它们处于同一&lt;a href=&quot;https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9F%9F&quot; target=&quot;_blank&quot;&gt;广播域&lt;/a&gt;。而在同一广播域中有这么多节点是不可能的，网络会因为广播通信而饱和，结果造成16777214个地址大部分没有分配出去。可以把基于每类的IP网络进一步分成更小的网络，每个子网由&lt;a href=&quot;https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8&quot; target=&quot;_blank&quot;&gt;路由器&lt;/a&gt;界定并分配一个新的子网&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80&quot; target=&quot;_blank&quot;&gt;网络地址&lt;/a&gt;,子网地址是借用基于每类的网络地址的主机部分创建的。划分子网后，通过使用&lt;a href=&quot;https://baike.baidu.com/item/%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;掩码&lt;/a&gt;，把子网隐藏起来，使得从外部看网络没有变化，这就是&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;子网掩码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;          当我们对一个网络进行子网划分时，基本上就是将它分成小的&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C&quot; target=&quot;_blank&quot;&gt;网络&lt;/a&gt;。比如，当一组IP地址指定给一个公司时，公司可能将该网络“分割成”小的网络，每个部门一个。这样，技术部门和管理部门都可以有属于它们的小网络。通过划分子网，我们可以按照我们的需要将网络分割成小网络。这样也有助于降低流量和隐藏网络的复杂性。&lt;/p&gt;
&lt;p&gt;          子网划分是通过借用ip地址的若干位主机位来充当子网地址的从而将原来的网络分为若干个彼此隔离的子网实现的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117214150506-638807042.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;arp协议通过ip地址获取目标主机的mac地址这一过程使用的是广播的方式，这个广播地址就是通过子网地址于子网掩码计算而来的，只有计算出的这一子网内的主机才能收到这个arp广播包&lt;/li&gt;
&lt;li&gt;子网划分与vlan都可以做到隔离广播域，只是子网划分是三层隔离，二vlan是二层&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117214911803-953615890.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;190&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 C类子网划分&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117215023459-1762756045.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           子网划分是通过借用IP地址的若干位主机位来充当子网地址从而将原网络划分为若干子网而实现的。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;17.172413793103&quot;&gt;            划分子网时，随着子网地址借用主机位数的增多，子网的数目随之增加，而每个子网中的可用主机数逐渐减少。以C类网络为例，原有8位主机位，2的8次方即256个&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80&quot; target=&quot;_blank&quot;&gt;主机地址&lt;/a&gt;，默认&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;子网掩码&lt;/a&gt;255.255.255.0。借用1位&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&quot; target=&quot;_blank&quot;&gt;主机&lt;/a&gt;位，产生2个子网，每个子网有126个主机地址；借用2位主机位，产生4个子网，每个子网有62个主机地址……每个网中，第一个IP地址（即主机部分全部为0的IP）和最后一个IP（即主机部分全部为1的IP）不能分配给主机使用，所以每个子网的可用IP地址数为总IP地址数量减2；根据子网ID借用的主机位数，我们可以计算出划分的子网数、&lt;a href=&quot;https://baike.baidu.com/item/%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;掩码&lt;/a&gt;、每个子网主机数，列表如下：&lt;/div&gt;
&lt;p&gt;          ① 划分子网数 ② 子网位数 ③子网掩码（二进制） ④ 子网掩码（十进制） ⑤ 每个子网主机数&lt;/p&gt;
&lt;p&gt;          ① 1～2 ② 1 ③ 11111111.11111111.11111111.10000000 ④ 255.255.255.128 ⑤ 126&lt;/p&gt;
&lt;p&gt;　　   ① 3～4 ② 2 ③ 11111111.11111111.11111111.11000000 ④ 255.255.255.192 ⑤ 62&lt;/p&gt;
&lt;p&gt;　　   ① 5～8 ② 3 ③ 11111111.11111111.11111111.11100000 ④ 255.255.255.224 ⑤ 30&lt;/p&gt;
&lt;p&gt;　　   ① 9～16 ② 4 ③ 11111111.11111111.11111111.11110000 ④ 255.255.255.240 ⑤ 14&lt;/p&gt;
&lt;p&gt;　　   ① 17～32 ② 5 ③ 11111111.11111111.11111111.11111000 ④ 255.255.255.248 ⑤ 6&lt;/p&gt;
&lt;p&gt;　　   ① 33～64 ② 6 ③ 11111111.11111111.11111111.11111100 ④ 255.255.255.252 ⑤ 2&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;12.012658227848&quot;&gt;          如上表所示的C类网络中，若子网占用7位主机位时，主机位只剩一位，无论设为0还是1，都意味着主机位是全0或全1。由于主机位全0表示本网络，全1留作&lt;a href=&quot;https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9C%B0%E5%9D%80&quot; target=&quot;_blank&quot;&gt;广播地址&lt;/a&gt;，这时子网实际没有可用&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80&quot; target=&quot;_blank&quot;&gt;主机地址&lt;/a&gt;，所以主机位至少应保留2位。&lt;/div&gt;
&lt;h3&gt;3.3子网划分步骤&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;确定要划分的子网数以及每个子网的主机数&lt;/li&gt;
&lt;li&gt;求出子网数目对应的二进制的位数N及主机数目对应的二进制数的位数M&lt;/li&gt;
&lt;li&gt;对该ip地址的原子网掩码，将其主机地址部分的前N位置1(其余全部置0)或后M位置0(其余全置1)即得出该ip地址划分子网后的子网掩码&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.4子网划分案例&lt;/h3&gt;
&lt;h4&gt;案例一&lt;/h4&gt;
&lt;p&gt;给C类网络211.168.10.0划分5个子网&lt;/p&gt;
&lt;p&gt;2**2-2&amp;lt;5&amp;lt;2**3-2所以需要3位网络号，主机号为8-3=5&lt;/p&gt;
&lt;p&gt;子网掩码为255.255.255.224&lt;/p&gt;
&lt;p&gt;每个子网可容纳2**5-2=30台主机&lt;/p&gt;
&lt;h4&gt;案例二&lt;/h4&gt;
&lt;p&gt;     　　对B类网络135.41.0.0/16需要划分为20个能容纳200台主机的网络（即：子网）。因为16&amp;lt;20&amp;lt;32，即：2的4次方&amp;lt;20&amp;lt;2的5次方，所以，子网位只须占用5位主机位就可划分成32个子网，可以满足划分成20个子网的要求。B类网络的默认子网掩码是255.255.0.0，转换为二进制为11111111.11111111.00000000.00000000。现在子网又占用了5位主机位，根据&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;子网掩码&lt;/a&gt;的定义，划分子网后的子网掩码应该为11111111.11111111.11111000.00000000，转换为十进制应该为255.255.248.0。现在我们再来看一看每个子网的主机数。子网中可用&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA&quot; target=&quot;_blank&quot;&gt;主机&lt;/a&gt;位还有11位，2的11次方=2048，去掉主机位全0和全1的情况，还有2046个主机ID可以分配，而子网能容纳200台主机就能满足需求，按照上述方式划分子网，每个子网能容纳的主机数目远大于需求的主机数目，造成了IP地址资源的浪费。为了更有效地利用资源，我们也可以根据子网所需主机数来划分子网。还以上例来说，128&amp;lt;200&amp;lt;256，即2^7&amp;lt;200&amp;lt;2^8，也就是说，在B类网络的16位主机位中，保留8位主机位，其它的16－8=8位当成子网位，可以将B类网络135. 41.0.0划分成256（2^8）个能容纳256－1－1=254台（去掉全0全1情况）主机的子网。此时的&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81&quot; target=&quot;_blank&quot;&gt;子网掩码&lt;/a&gt;为11111111.11111111.11111111.00000000，转换为十进制为255.255.255.0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226410/201801/1226410-20180117215316209-1300414167.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3.5划分子网注意事项&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在子网划分时不仅需要考虑目前需要，还应该了解将来需要多说子网和主机。子网掩码使用较多的主机位，可以得到更多子网，节约了ip地址资源，若将来需要更多的子网时，不用再重新分配ip地址，但每个子网的主机数量有限；反之，子网掩码使用较少的主机位，每个子网的主机数允许有更大的增长，但可用子网数有限&lt;/li&gt;
&lt;li&gt;一般来说，一个网络中的节点数太多，网络会因为广播通信而饱和，所以网络中的主机数量的增长是有限的，也就是说，在条件允许的情况下，应将更多的主机位用于子网位&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;3.6为什么要子网划分&lt;/h3&gt;
&lt;p&gt;Internet组织机构定义了五种IP地址，用于主机的有A、B、C三类地址。其中A类网络有126个，每个A类网络可能有16，777，214台主机，它们处于同一广播域。而在同一广播域中有这么多结点是不可能的，网络会因为广播通信而饱和，结果造成16，777，214个地址大部分没有分配出去，形成了浪费。而另一方面，随着互连网应用的不断扩大，IP地址资源越来越少。为了实现更小的广播域并更好地利用主机地址中的每一位，可以把基于类的IP网络进一步分成更小的网络，每个子网由路由器界定并分配一个新的子网网络地址,子网地址是借用基于类的网络地址的主机部分创建的。划分子网后，通过使用掩码，把子网隐藏起来，使得从外部看网络没有变化，这就是子网掩码。&lt;/p&gt;
&lt;p&gt;很简单的说   就是，一个公司不可能使用254个公网地址，A公司想用6个地址，B公司也想用6个地址，如果把这两个公司的地址都放在一个大网段里面，这两个公司的地址就能够直接互通&lt;/p&gt;
&lt;h3&gt;3.7子网划分优点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;减少网络流量&lt;/li&gt;
&lt;li&gt;提高网络性能&lt;/li&gt;
&lt;li&gt;简化管理&lt;/li&gt;
&lt;li&gt;易于扩大地理范围 &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;参考内容：百度百科，http://www.cnblogs.com/linhaifeng/articles/5951486.html&lt;/p&gt;
&lt;p&gt;写在这里的目的是巩固老师上课的内容，为了自己方便复习。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 02:24:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8302473.html</dc:identifier>
</item>
<item>
<title>JAVA实用案例之文件导出（JasperReport踩坑实录） - 小卖铺的老爷爷</title>
<link>http://www.cnblogs.com/laoyeye/p/7707149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoyeye/p/7707149.html</guid>
<description>&lt;p&gt;&lt;span&gt;想想来新公司也快五个月了，恍惚一瞬间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;翻了翻博客，因为太忙，也有将近五个多月没认真总结过了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正好趁着今天老婆出门团建的机会，记录下最近这段时间遇到的大坑-JasperReport。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;六月份的时候写过一篇利用poi文件导入导出的小Demo，&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/laoyeye/p/6938889.html&quot;&gt;JAVA实用案例之文件导入导出（POI方式）&lt;/a&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然简单，但是企业应用的原理基本上也就是这样，只不过是封装的更好些，不像我之前写的那样每个Cell都需要定义，其实poi的方式也是我目前最推崇的方式之一了。主要原因是jxl不支持xlsx，JasperReport坑又太大，哎。下面进入正题，来介绍下今天的猪脚JasperReport或者叫它ireport亦或jasperstudio，当然后面两个是它的可视化工具。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这货其实在国内用户也不少，是个国外的产品，而且可以说在JAVA报表领域应用是相当的广泛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我当初刚刚接触这个报表的时候还是相当的喜欢的，最主要的是它的可视化工具，真的是让我欲罢不能，竟然可以通过简单画图的方式来设计JAVA报表。说起画图就是可以通过可视化的工具，让我们可视化的设计报表模板，并且它支持输出的文件格式很广泛，包括EXCEL、WORD、PDF、HTML、XML、CSV等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看起来是不是很强大，一次设计，多次复用。当然强大得的东西，往往都有两面性，这不就被我遇到了，折磨了我相当长的时间，后文会详细描述的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前面我说，JasperReport或者叫它ireport或jasperstudio，其实这是不准确的。二弟ireport、三弟jasperstudio其实是jasper的辅助视觉设计工具，你不用它也能设计jasper报表，多写点XML白。5.5之前这个工具叫ireport，5.5之后随着三弟jasperstudio的出生，ireport就被完全替代了，其实这两个工具基本上是一样的，一奶同胞。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的工作流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①首先Jasper会获取需要输出的格式信息的xml文件，然后从xml文件中编译出.jasper类型的文件，然后这个jasper文件可以在我们的应用程序中被加载生成最终的报表。有没有很熟悉的感觉，是的，这一点和java很像，都需要编译一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图，就是ireport的操作界面，jasperstudio类似，就不贴了，大家可以自行百度下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1075594/201710/1075594-20171021223712740-748841623.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图每种类型的band简单介绍一下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(1)&lt;strong&gt;Title band&lt;/strong&gt;:title段只在整个报表的第一页的最上面部分显示，除了第一页以外，不管报表中共有多少个页面也不会再出现Title band中的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(2)&lt;strong&gt;pageHeader Band&lt;/strong&gt;：顾名思义，pageHeader 段中的内容将会在整个报表中的每一个页面&lt;/span&gt;&lt;span&gt;中都会出现，显示在位置在页面的上部，如果是报表的第一页，pageHeader 中的内容将显示在&lt;/span&gt;&lt;span&gt;Title Band下面，除了第一页以外的其他所有页面中pageHeader中的内容将在显示在页面的最上端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(3)&lt;strong&gt;pageFooter Band&lt;/strong&gt;：显示在所在页面的最下端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(4)&lt;strong&gt;lastPageFooter Band&lt;/strong&gt;：显示在最后一页的最下端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(5)&lt;strong&gt;Detail Band&lt;/strong&gt;：报表内容段，在这个Band 中设计报表中需要重复出现的内容，Detail 段&lt;/span&gt;&lt;span&gt;中的内容每页都会出现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(6)&lt;strong&gt;columnHeader Band&lt;/strong&gt;：针对Detail Band的表头段，一般情况下在这个段中画报表的表&lt;/span&gt;&lt;span&gt;头。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(7)&lt;strong&gt;columnFooter Band&lt;/strong&gt;:针对Detail Band的表尾段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(8)&lt;strong&gt;Summary Band&lt;/strong&gt;:表格的合计段，出现在整个报表的最后一页中的Detail band 的后面，一般用来统计报表中某一个或某几个字段的合计值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面就是可视化的工具的全部，其实怎么用很简单，上手摸索下就会了，既然是踩坑实录，这个自然不是重点，不说了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;这是我总结的步骤，可能描述的不是很准确，大家凑合下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①设计模板，生成JRXML文件，↑↑上面的可视化工具设计你所需要的模板样式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②编译模板，JRXML编译成Jasper文件，就像java中的.java和.class文件一样，程序中运行的需要是*.jasper的二进制文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这一步可以直接用ireport编译生成.jasper，当然也可以在运行时通过jasper程序编译。但是建议如果在程序中编译的话，jasper版本最好和ireport或者jasperstudio的版本一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③执行报表（数据填充到报表）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、 加载模板生成Jasperreport对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、利用JasperFillManager，生成JasperPrint对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④最后利用JRXlsxExporter导出类，将报表导出或者展示&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;加载模板&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;既然我们已经利用可视化工具生成了.jasper或者.jrxml文件了，自然是需要让程序加载它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加载的代码，返回jasperport对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt; (urlPath.endsWith(&quot;.jrxml&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;compile jrxml to jasper&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                InputStream is &lt;/span&gt;=&lt;span&gt; url.openStream();
                jasperReport &lt;/span&gt;=&lt;span&gt; JasperCompileManager.compileReport(is);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;Load jasper error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JRException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;The jrxml template transform to jasper file error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                log.error(e);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseException(e.getMessage());
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (urlPath.endsWith(&quot;.jasper&quot;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                InputStream is &lt;/span&gt;=&lt;span&gt; url.openStream();
                jasperReport &lt;/span&gt;=&lt;span&gt; (JasperReport) JRLoader.loadObject(is);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;Load jasper error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JRException e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;The jrxml template file error&quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                log.error(e);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseException(e.getMessage());
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BaseException(&quot;Invalid file!&quot;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;获取报表中的数据源&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里我采用javabean的方式获取&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　　　　　JRDataSource dataSource = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fieldValues != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; fieldValues.size() &amp;gt; 0&lt;span&gt;) {
                dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JRBeanCollectionDataSource(fieldValues);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                dataSource &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JREmptyDataSource();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;fieldValues 为数据库中获取的pojo集合。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;执行报表填充&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;得到jasperprint对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Map&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
jasperPrint &lt;/span&gt;= JasperFillManager.fillReport(jasperReport, parameterValue, dataSource);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;最后我们利用JRXlsxExporter导出报表&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这个也是需要配置参数最多的一个地方&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
baos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
exporter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JRXlsxExporter();
exporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);
exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, baos);&lt;br/&gt;exporter.exportReport();&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完成，数据已经写入输出流中了，怎么输出自己决定，是不是比其他方式代码简介很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确实在代码书写中JasperReport有着无法比拟的优势，各种api已经封装好。但是可能是恰恰做的太多，问题也不少。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1、两行前的空白&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你使用上面的代码导出EXCEL的话，你会发现Excel的背景是白色，没了Excel一个个的小格子，这是因为jasper默认背景为白色，这样在导出其他格式时也好做到兼容，当然当我们导出EXCEL并不需要。只需要加上下面两行就可以解决。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除两行之前的空白  &lt;/span&gt;
&lt;span&gt;            exporter.setParameter(JRXlsExporterParameter.IS_REMOVE_EMPTY_SPACE_BETWEEN_ROWS,Boolean.TRUE); 
            exporter.setParameter(JRXlsExporterParameter.IS_REMOVE_EMPTY_SPACE_BETWEEN_COLUMNS,Boolean.TRUE); 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Excel表格的背景颜色为默认的白色  &lt;/span&gt;
            exporter.setParameter(JRXlsExporterParameter.IS_WHITE_PAGE_BACKGROUND,Boolean.FALSE);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、数据量很大，title多次写入&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你一个Sheet数据很多，可能会遇到表头多次打印的情况，这种情况下，你需要加上高度设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Field pageHeight = JRBaseReport.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getDeclaredField(
                    &lt;/span&gt;&quot;pageHeight&quot;&lt;span&gt;);
            pageHeight.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            pageHeight.setInt(jasperReport, Integer.MAX_VALUE);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、Cell的类型的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有时候我们导出的Excel报表，需要使用Excel的函数计算，如果全都是文本格式，自然计算不了，这种情况下，我们需要使用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动选择格式&lt;/span&gt;
 exporter.setParameter(JRXlsExporterParameter.IS_DETECT_CELL_TYPE, Boolean.TRUE);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;切记，在报表设计时，Field字段选择正确的类型。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4、多Sheet的问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我上面那个简单的例子，只是一个文件中包含一个Sheet页，假如我们的需求是一个文件导出多个Sheet怎么办，别急，这个Japser早已为我们想到了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要将上文中导出步骤换成下面这个样子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
baos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
exporter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JRXlsxExporter();
exporter.setParameter(JRExporterParameter.JASPER_PRINT_LIST, listJasperPrint);
exporter.setParameter(JRExporterParameter.OUTPUT_STREAM, baos);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为true，即可在一个excel中，每个单独的jasper对象放入到一个sheet页中&lt;/span&gt;
&lt;span&gt;exporter.setParameter(JRXlsExporterParameter.IS_ONE_PAGE_PER_SHEET,Boolean.TRUE);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;JRExporterParameter.JASPER_PRINT_LIST，传入一个listJasperPrint的集合，每个JasperPrint即一个Sheet页。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;&lt;span&gt;5、Linux下启动不报错，但是无法导出报表&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;其实这个问题也困扰了我很久，后来在大佬的帮助下才想起来问题所在，因为它抛出的根本不是个Exception，而是Error。我看到网上也有同学问这个问题，所以贴出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以用throwable捕获，就可以得到错误信息，报错：java.lang.InternalError: Can't connect to X11 window server using ':0.0' as&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法：修改tomcat/bin/catalina.sh 加JAVA_OPTS=&quot;$JAVA_OPTS  -Djava.awt.headless=true&quot;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6、大数据内存溢出和内存泄露问题！！&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里需要说一下，&lt;/span&gt;&lt;span&gt;EXCEL 03和07版的区别，03版我记得好像是只支持65532行吧，而07版之后就大的多了，具体数字我忘了，反正不是一个数量级的。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;JRXlsxExporter支持导出xlsx文件，&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;JRXlsExporter则是xls的文件，很好辨认，导出的工具和excel的格式一样。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后是内存溢出和内存泄露问题，这个我相信玩JAVA的朋友基本上都遇到过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于内存溢出最通常的解决办法便是增大容器的内存，增加tomcat的内存大小，方法大家可以百度，有很多，不重复造轮子了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里提醒下，如果你使用的是tomcat的话，windows安装版，解压缩版和Linux版的配置方式都是不同的，需要注意下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我需要介绍的是JasperReport的方式，其实JasperReport是对大数据有解决方案的，在很早期的版本便推出了，JRFileVirtualizer的仿真器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个东西是做啥用的呢，其实它会根据你设置的参数，将数据写到硬盘的临时文件上，这样解决了填充报表时内存占用过大溢出的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前JasperReport有3个仿真器，都是用来解决这个问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①JRFileVirtualizer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②JRSwapFileVirtualizer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③JRGzipVirtualizer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这三个仿真器又有什么区别呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是推出最早的JRFileVirtualizer，我在测试时，当导出30W左右的数据，就会报内存溢出，后来加上这个后就可以正常导出了。这个仿真器会把每一个对象生成一个临时文件存放在硬盘上解决内存占用的问题，但是因为产生的临时文件较多，无形中增加了文件创建和删除的内存消耗，所以并不是很推荐。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写多个文件&lt;/span&gt;
 JRFileVirtualizer virtualizer = &lt;span&gt;new&lt;/span&gt; JRFileVirtualizer(2&lt;span&gt;, catchPath);
 Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
 parameterValue.put(JRParameter.REPORT_VIRTUALIZER, virtualizer);&lt;br/&gt;virtualizer.setReadOnly(true);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;catchPath为文件缓存路径，必须真实存在，否则会报错。&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;然后是JRSwapFileVirtualizer，这个是为了解决JRFileVirtualizer的问题而推出的。这个仿真器，只会创建一个临时文件，每个对象会占这个文件的一部分，所以就减少的文件创建和删除的内存消耗，其实这个也不是特别推荐。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写单个文件&lt;/span&gt;
RSwapFile arquivoSwap = &lt;span&gt;new&lt;/span&gt; JRSwapFile(catchPath, 4096, 25&lt;span&gt;);
JRAbstractLRUVirtualizer virtualizer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; JRSwapFileVirtualizer(2, arquivoSwap, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;
Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
parameterValue.put(JRParameter.REPORT_VIRTUALIZER, virtualizer);&lt;br/&gt;virtualizer.setReadOnly(true);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后是JRGzipVirtualizer这个，看到Gzip，不知道你是否有联系到压缩这个词汇。没错，这个仿真器就是使用一种特殊的压缩算法，可以将内存占用压缩到二十分之一还是十分之一来着，总之很神奇。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
JRAbstractLRUVirtualizer virtualizer = &lt;span&gt;new&lt;/span&gt; JRGzipVirtualizer(2&lt;span&gt;);
Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; parameterValue = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
parameterValue.put(JRParameter.REPORT_VIRTUALIZER, virtualizer);
jasperPrint &lt;/span&gt;= JasperFillManager.fillReport(jasperReport, parameterValue, dataSource);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说了这么多，总之就是三种仿真器解决内存溢出问题，我也看了很多博客里面写利用JRFileVirtualizer，解决内存大数据问题。然后我在这里想说，&lt;span&gt;我最最最不推荐使用JRFileVirtualizer仿真器，因为它不仅创建文件消耗大，还有个很严重的BUG，内存泄露！！！&lt;/span&gt;还有JRSwapFileVirtualizer也有这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，需要说明的是不使用仿真器，也会有内存泄露的问题，当你导出报表后，dump出堆栈信息，会发现net.sf.jasperreports.engine.fill.JRTemplatePrintText类的实例特别多，无法回收，无法回收！！！并且最新版的japserreport 6.x依旧存在这个问题，在jasper的社区和Stack Overflow存在很多这样的问题，而没有解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里推荐JRGzipVirtualizer仿真器，虽然依旧存在泄露问题，但是因为独特的压缩算法，已经将内存泄露问题控制在很小的范围里了，算是一种缓解的方案吧，大概泄露的内存占用缓解了九成以上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说，我现在已经放弃这种方案了，写出来也是为了后来的兄弟少走弯路。撸了一个POI的工具类,接下来准备把所有的报表改成POI导出的方式，话说POI的大数据方案还是挺不错的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发路上的坑，写的不是太好还请见谅。转载还请注明出处：小卖铺的老爷爷 &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: JAVA实用案例之文件导出（JasperReport踩坑实录）&quot; href=&quot;http://www.cnblogs.com/laoyeye/p/7707149.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/laoyeye/p/7707149.html&lt;/a&gt; &lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jan 2018 16:21:00 +0000</pubDate>
<dc:creator>小卖铺的老爷爷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoyeye/p/7707149.html</dc:identifier>
</item>
</channel>
</rss>