<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>javascript设计模式——迭代器模式 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8030802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8030802.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。迭代器模式是一种相对简单的模式，简单到很多时候都不认为它是一种设计模式。本文将详细介绍迭代器模式&lt;/p&gt;

&lt;h3&gt;迭代器实现&lt;/h3&gt;
&lt;p&gt;　　迭代器模式无非就是循环访问聚合对象中的各个元素。比如jQuery中的$.each函数，其中回调函数中的参数i为当前索引，n为当前元素，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
$.each( [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;], function( i, n ){
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;当前下标为： &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt; i );
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;当前值为:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; n );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在来自己实现一个each函数，each函数接受2个参数，第一个为被循环的数组，第二个为循环中的每一步后将被触发的回调函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; each =&lt;span&gt; function( ary, callback ){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, l = ary.length; i &amp;lt; l; i++&lt;span&gt; ){
        callback.call( ary[i], i, ary[ i ] ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把下标和元素当作参数传给callback 函数&lt;/span&gt;
&lt;span&gt;    }
};

each( [ &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ], function( i, n ){
    alert ( [ i, n ] );
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;迭代器分类&lt;/h3&gt;
&lt;p&gt;　　迭代器可以分为内部迭代器和外部迭代器，它们有各自的适用场景&lt;/p&gt;
&lt;p&gt;【内部迭代器】&lt;/p&gt;
&lt;p&gt;　　刚刚编写的each函数属于内部迭代器，each函数的内部已经定义好了迭代规则，它完全接手整个迭代过程，外部只需要一次初始调用&lt;/p&gt;
&lt;p&gt;　　内部迭代器在调用的时候非常方便，外界不用关心迭代器内部的实现，跟迭代器的交互也仅仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，上面的each函数就无法同时迭代2个数组了&lt;/p&gt;
&lt;p&gt;　　比如现在有个需求，要判断2个数组里元素的值是否完全相等，如果不改写each函数本身的代码，能够入手的地方似乎只剩下each的回调函数了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; compare =&lt;span&gt; function( ary1, ary2 ){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ary1.length !==&lt;span&gt; ary2.length ){
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error ( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ary1 和ary2 不相等&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
    }
    each( ary1, function( i, n ){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( n !==&lt;span&gt; ary2[ i ] ){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error ( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ary1 和ary2 不相等&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
    });
    alert ( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ary1 和ary2 相等&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
compare( [ &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt; ], [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt; ] ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; throw new Error ( 'ary1 和ary2 不相等' );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【外部迭代器】&lt;/p&gt;
&lt;p&gt;　　外部迭代器必须显式地请求迭代下一个元素。外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，可以手工控制迭代的过程或者顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Iterator =&lt;span&gt; function( obj ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; current = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; next =&lt;span&gt; function(){
        current &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isDone =&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; current &amp;gt;=&lt;span&gt; obj.length;
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getCurrItem =&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj[ current ];
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        next: next,
        isDone: isDone,
        getCurrItem: getCurrItem
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面来改写compare函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; compare =&lt;span&gt; function( iterator1, iterator2 ){
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( !iterator1.isDone() &amp;amp;&amp;amp; !&lt;span&gt;iterator2.isDone() ){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( iterator1.getCurrItem() !==&lt;span&gt; iterator2.getCurrItem() ){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error ( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iterator1 和iterator2 不相等&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
        iterator1.next();
        iterator2.next();
    }
    alert ( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iterator1 和iterator2 相等&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iterator1 = Iterator( [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ] );
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iterator2 = Iterator( [ &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt; ] );
compare( iterator1, iterator2 ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：iterator1 和iterator2 相等&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　外部迭代器虽然调用方式相对复杂，但它的适用面更广，也能满足更多变的需求。内部迭代器和外部迭代器在实际生产中没有优劣之分，究竟使用哪个要根据需求场景而定&lt;/p&gt;

&lt;h3&gt;迭代类数组&lt;/h3&gt;
&lt;p&gt;　　迭代器模式不仅可以迭代数组，还可以迭代一些类数组的对象。比如arguments、{&quot;0&quot;:'a',&quot;1&quot;:'b'}等。无论是内部迭代器还是外部迭代器，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那它就可以被迭代&lt;/p&gt;
&lt;p&gt;　　在javascript中，for in语句可以用来迭代普通字面量对象的属性。jQuery中提供了$.each函数来封装各种迭代行为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
$.each =&lt;span&gt; function( obj, callback ) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; value,
    i &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    length &lt;/span&gt;=&lt;span&gt; obj.length,
    isArray &lt;/span&gt;=&lt;span&gt; isArraylike( obj );
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( isArray ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代类数组&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; ( ; i &amp;lt; length; i++&lt;span&gt; ) {
            value &lt;/span&gt;=&lt;span&gt; callback.call( obj[ i ], i, obj[ i ] );
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( value === &lt;span&gt;false&lt;/span&gt;&lt;span&gt; ) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( i &lt;span&gt;in&lt;/span&gt; obj ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代object 对象&lt;/span&gt;
            value =&lt;span&gt; callback.call( obj[ i ], i, obj[ i ] );
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( value === &lt;span&gt;false&lt;/span&gt;&lt;span&gt; ) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;倒序迭代器&lt;/h3&gt;
&lt;p&gt;　　迭代器模式提供了循环访问一个聚合对象中每个元素的方法，但它没有规定以顺序、倒序还是中序来循环遍历聚合对象&lt;/p&gt;
&lt;p&gt;　　下面实现一个倒序访问的迭代器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; reverseEach =&lt;span&gt; function( ary, callback ){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; l = ary.length - &lt;span&gt;1&lt;/span&gt;; l &amp;gt;= &lt;span&gt;0&lt;/span&gt;; l--&lt;span&gt; ){
        callback( l, ary[ l ] );
    }
};

reverseEach( [ &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt; ], function( i, n ){
    console.log( n ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分别输出：2, 1 ,0&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;中止迭代器&lt;/h3&gt;
&lt;p&gt;　　迭代器可以像普通for循环中的break一样，提供一种跳出循环的方法。在jQuery的each函数里有这样一句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(value===&lt;span&gt;false&lt;/span&gt;&lt;span&gt;){
  &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这句代码的意思是，约定如果回调函数的执行结果返回false，则提前终止循环。下面把之前的each函数改写一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; each =&lt;span&gt; function( ary, callback ){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, l = ary.length; i &amp;lt; l; i++&lt;span&gt; ){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( callback( i, ary[ i ] ) === &lt;span&gt;false&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; callback 的执行结果返回false，提前终止迭代&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
};

each( [ &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ], function( i, n ){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( n &amp;gt; &lt;span&gt;3&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; n 大于3 的时候终止循环&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    console.log( n ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分别输出：1, 2, 3&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;文件上传&lt;/h3&gt;
&lt;p&gt;　　下面是一段关于文件上传的代码，目的是根据不同的浏览器获取相应的上传组件对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getUploadObj =&lt;span&gt; function(){ 
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ActiveXObject(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TXFTNActiveX.FTNUpload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IE 上传控件&lt;/span&gt;
  }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( supportFlash() ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; supportFlash 函数未提供&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;object type=&quot;application/x-shockwave-flash&quot;&amp;gt;&amp;lt;/object&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt; $( str ).appendTo( $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) );
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;input name=&quot;file&quot; type=&quot;file&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表单上传&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; $( str ).appendTo( $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) );
    }
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在不同的浏览器环境下，选择的上传方式是不一样的。因为使用浏览器的上传控件进行上传速度快，可以暂停和续传，所以首先会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了&lt;/p&gt;
&lt;p&gt;　　上面的代码为了得到一个upload对象，getUploadObj函数里面充斥了try，catch以及if条件分支。缺点显而易见，很难阅读，且严重违反开闭原则。在开发和调试过程中，需要来回切换不同的上传方式，如果增加了一些另外的上传方式，比如，HTML5上传，这时唯一的办法是继续往getUploadObj函数里增加条件分支&lt;/p&gt;
&lt;p&gt;　　目前一共有3种可能的上传方式，但不知道目前正在使用的浏览器支持哪几种。把每种获取upload对象的方法都封装在各自的函数里，然后使用一个迭代器，迭代获取这些upload对象，直到获取到一个可用的为止&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getActiveUploadObj =&lt;span&gt; function(){ 
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ActiveXObject( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TXFTNActiveX.FTNUpload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; );    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IE 上传控件&lt;/span&gt;
  }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(e){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getFlashUploadObj =&lt;span&gt; function(){
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( supportFlash() ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; supportFlash 函数未提供&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;object type=&quot;application/x-shockwave-flash&quot;&amp;gt;&amp;lt;/object&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $( str ).appendTo( $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) );
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getFormUpladObj =&lt;span&gt; function(){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;input name=&quot;file&quot; type=&quot;file&quot; class=&quot;ui-file&quot;/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表单上传&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; $( str ).appendTo( $(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) );
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在getActiveUploadObj、getFlashUploadObj、getFormUpladObj这3个函数中都有同一个约定：如果该函数里面的upload对象是可用的，则让函数返回该对象，反之返回false，提示迭代器继续往后面进行迭代&lt;/p&gt;
&lt;p&gt;　　所以我们的迭代器只需进行下面这两步工作：1、提供一个可以被迭代的方法，使得getActiveUploadObj，getFlashUploadObj以及getFlashUploadObj依照优先级被循环迭代；2、如果正在被迭代的函数返回一个对象，则表示找到了正确的upload对象，反之如果该函数返回false，则让迭代器继续工作&lt;/p&gt;
&lt;p&gt;　　迭代器代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; iteratorUploadObj =&lt;span&gt; function(){
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, fn; fn = arguments[ i++&lt;span&gt; ]; ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uploadObj =&lt;span&gt; fn();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( uploadObj !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt; ){ 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uploadObj;
    }
  }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uploadObj = iteratorUploadObj( getActiveUploadObj, getFlashUploadObj, getFormUpladObj );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重构代码之后，获取不同上传对象的方法被隔离在各自的函数里互不干扰，try、catch和if分支不再纠缠在一起，使得可以很方便地的维护和扩展代码。比如，给上传项目增加了Webkit控件上传和HTML5上传，要做的仅仅是下面一些工作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; getWebkitUploadObj=&lt;span&gt;function(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体代码略&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getHtml5UploadObj=&lt;span&gt;function(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体代码略&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　依照优先级把它们添加进迭代器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; uploadObj=iteratorUploadObj(getActiveUploadObj,getWebkitUploadObj,getFlashUploadObj,getHtml5UploadObj,getFormUpladObj);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 13 Dec 2017 22:19:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8030802.html</dc:identifier>
</item>
<item>
<title>C/C++筛选法算素数 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/8035784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/8035784.html</guid>
<description>&lt;h2 id=&quot;什么是求素数&quot;&gt;什么是求素数&lt;/h2&gt;
&lt;p&gt;）i在2到n-1之间任取一个数,如果n能被整除则不是素数，否则就是素数&lt;/p&gt;
&lt;h3 id=&quot;普通枚举法&quot;&gt;普通枚举法:&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;

bool isPlain(int x){
    if(x&amp;lt;2) return false;
    else{
        for(int i=2;i&amp;lt;x;i++)
        {
            if(!(x%i))
                return false;
        }
    }
    return true;
}

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    int cot=0;
    for(int j=0;j&amp;lt;n;j++){
        if(isPlain(j)){
           cout&amp;lt;&amp;lt;j&amp;lt;&amp;lt;((++cot%7==0)?&quot;\n&quot;:&quot;\t&quot;);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;筛选法&quot;&gt;筛选法:&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;原始版本:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstring&amp;gt;
using namespace std;


int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    bool* ans=new bool[n];
    memset(ans,true,sizeof(bool)*n);//
    ans[0]=false;
    ans[1]=false;
    for(int i=2;i&amp;lt;n;i++){
        if(ans[i]){
            for(int j=i*2;j&amp;lt;n;j+=i){//倍数取整
                ans[j]=false;
            }
        }
    }
    int col = 0;
    for(int i=0;i&amp;lt;n;i++){
        if(ans[i]){
            cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; &quot;;
        }
    }
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;改进版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;bitset&amp;gt;
using namespace std;

int main()
{
    int n;
    cin&amp;gt;&amp;gt;n;
    bitset&amp;lt;100000&amp;gt; ans;
    ans.set(0);
    ans.set(1);
    for(int j=2; j&amp;lt;=sqrt(n); j++)
    {
        for(int i=2*j; i &amp;lt; n; i+=j)
        {
            ans.set(i);
        }
    }
    int cot=0;
    for(int i=0; i&amp;lt;n; i++)
    {
        if(ans[i]!=1)
        {
            cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;((++cot%7==0)?&quot;\n&quot;:&quot;\t&quot;);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 13 Dec 2017 18:34:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/8035784.html</dc:identifier>
</item>
<item>
<title>C++反汇编第五讲,认识多重继承,菱形继承的内存结构,以及反汇编中的表现形式. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8035783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8035783.html</guid>
<description>&lt;p&gt;目录:&lt;/p&gt;
&lt;p&gt;　　1.多重继承在内存中的表现形式&lt;/p&gt;
&lt;p&gt;　　　　多重继承在汇编中的表现形式&lt;/p&gt;
&lt;p&gt;　　2.菱形继承&lt;/p&gt;
&lt;p&gt;　　　　普通的菱形继承&lt;/p&gt;
&lt;p&gt;　　　　虚继承&lt;/p&gt;
&lt;p&gt;　　　　汇编中的表现形式&lt;/p&gt;
&lt;h2&gt;一丶多重继承在内存中的表现形式&lt;/h2&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father1
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Father1(){}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空构造&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; ~Father1(){} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空析构&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Player(){}  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;玩耍的函数&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; m_price;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;金钱&lt;/span&gt;
&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father2
{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Father2(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Father2(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetMoney(){}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置金钱&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_Money;
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt; Father1, &lt;span&gt;public&lt;/span&gt; Father2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承两个父类&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Child(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Child(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Eat(){}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;吃的函数&lt;/span&gt;
&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    Child  MyChild;　　//只需要注意这里,以及继承两个父类的地方
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过main函数我们得知,我们生成了一个孩子类的对象.此时按照C/C++的规范,应该先从&lt;strong&gt;左往右依次构造父类1,父类2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时的情况和我们昨天所讲的单继承里面,包含一个成员是一样的.但是有不同之处&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在子类自身构造中会复写两次虚表.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.在父类2指向子类的时候,会产生三木目运算的表达式.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2.观看反汇编中的表现形式.&lt;/h3&gt;
&lt;p&gt;1.main函数下,构造位置处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214011534597-480596328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.自身构造函数内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214011616691-1391506751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看出,自身构造中会产生如上代码,首先&lt;/p&gt;
&lt;p&gt;1.先构造父类各自的虚表,相当于一开始父类1有父类1的虚表,父类2有父类2的虚表&lt;/p&gt;
&lt;p&gt;2.然后自身构造的时候,分别对其自己的父类的虚表进行复写行为.通过这一点,可以简单的断定子类有两个父类.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release下的反汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214011942176-1989084449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Release下,因为我们的父类都是空的,所以直接优化了.&lt;/p&gt;
&lt;p&gt;但是我们会发现有一个三木运算符的反汇编代码&lt;/p&gt;
&lt;p&gt;neg eax&lt;/p&gt;
&lt;p&gt;sbb eax,eax&lt;/p&gt;
&lt;p&gt;lea ecx,[this] //获得this指针,简写了&lt;/p&gt;
&lt;p&gt;and eax,ecx&lt;/p&gt;
&lt;p&gt;这个是一个无分支三目运算的反汇编代码,在讲解C语言的反汇编的时候已经讲解过了,但为什么会出现这个.&lt;/p&gt;
&lt;p&gt;首先&lt;/p&gt;
&lt;p&gt;如果我们代码写成  father2  *p2 = &amp;amp;ch; 是没有问题的是把,  父类指针,指向了子类, 因为father2在内存中需要加便宜,所以直接加便偏移即可.&lt;/p&gt;
&lt;p&gt;但是此时问题来了.如果我们写成&lt;/p&gt;
&lt;p&gt;　　　　　　　　father2 *p2 = NULL;&lt;/p&gt;
&lt;p&gt;　　　　　　　　p2 = &amp;amp;ch;  怎么办,此时还要不要加偏移了?&lt;/p&gt;
&lt;p&gt;所以产生了一个三木运算的表达式&lt;/p&gt;
&lt;p&gt;　　　　　　　　p2 ? NULL  : NULL : p2 + offset;  在经过编译器的一优化,所以变成了上面的代码.&lt;/p&gt;
&lt;p&gt;如果不懂father *p2 = &amp;amp;ch,那要从内存角度看了.首先看Debug下的反汇编.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214012549488-210328427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的father2构造的位置是在内存+8的位置进行构造的,所以此时你如果father2的指针指向子类,那么需要+8对不对,所以如果先给NULL,就不用+8了.所以产生了三木运算符.&lt;/p&gt;
&lt;h3&gt;三丶内存结构图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214012953332-168297107.png&quot; alt=&quot;&quot;/&gt;构造父类1,构造父类2之后的内存结构图,最后子类自己的构造中需要复写两个父类自己的虚表.而且自己扩展的虚函数会放在父类1的虚表中.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　1.识别双父类的时候,看自己的构造中是否进行了两次虚表复写行为,(多个父类则多次构造父类,多次复写父类虚表行为)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　2.识别指针的三目运算,父类指针指向子类对象的时候,会产生三目运算表达式    例如:  p2 = &amp;amp;child;  p2有可能会有==NULL的情况下,如果不等于NULL,那么自己需要+offset进行指向,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以产生了三目表达式,  p2 ? NULL ; NULL ,p2 + offset;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　   3.析构中也会进行两个父类析构,然后重新填写虚表的行为.(和构造相反)&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;二丶菱形继承&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1.普通的菱形继承讲解&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　普通的菱形继承,为什么说普通的.请看高级代码&lt;/p&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; CGrandFather      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新添加的爷爷类&lt;/span&gt;
&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    CGrandFather(){}
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;CGrandFather(){}
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dance(){}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随便写的虚函数&lt;br/&gt;　　int m_int&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Father1 : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CGrandFather
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Father1(){}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;空构造&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; ~Father1(){} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空析构&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Player(){}  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;玩耍的函数&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; m_price;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;金钱&lt;/span&gt;
&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Father2: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CGrandFather
{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Father2(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Father2(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetMoney(){}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置金钱&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m_Money;
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Child : &lt;span&gt;public&lt;/span&gt; Father1, &lt;span&gt;public&lt;/span&gt; Father2 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承两个父类&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Child(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; ~&lt;span&gt;Child(){}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Eat(){}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;吃的函数&lt;/span&gt;
&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    Child  MyChild;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面我们可以得出一个逻辑图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214014237332-2091746719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单其实反汇编那种不是这样的.&lt;/p&gt;
&lt;p&gt;从反汇编和内存中可以看出,每一个父类都有一个自己的爷爷类.而且每个父类构造爷爷类的时候,都会填写爷爷类的虚表,并且在自己的构造中对其复写(重写)&lt;/p&gt;
&lt;p&gt;所以形成了下面这样的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214014812676-2038638133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们修改我们的高级代码.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    Child  MyChild;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MyChild.m_int = 1;　　　　　　　　//重点是这句&lt;/span&gt;
    MyChild.Father1::m_int = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们调用爷爷类中的m_int的时候会出现错误,因为不明确,因为通过上图我们得出,每个父类都有自己的爷爷类,这时候你访问m_int,需要指明那个父类的,&lt;/p&gt;
&lt;p&gt;而且你修改父类1的m_int不会影响父类2的m_int.造成了数据冗余的设计.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.从反汇编的角度下看&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1.main函数下构造的位置&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214015440941-1367413473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.自身构造内部&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214015523879-381176615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构造内部同样进行两次父类先构造的情况,最后复写两个父类的虚表&lt;/p&gt;
&lt;p&gt;3.父类1的构造内部&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214015629394-1752663465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父类1的构造内部又构造爷爷类,爷爷类在自身位置填写虚表,完了之后父类1又复写了.&lt;/p&gt;
&lt;p&gt;父类2同上.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;得出结论:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.菱形继承的时候,会有三次改虚表的动作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　构造爷爷类的时候修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　构造完爷爷类之后父类修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　构造完父类之后孩子类修改.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.每个父类都会构造自己的父类.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release下的反汇编表现形式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214020008519-301797173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是一样,Release下会有优化.指针+不加偏移产生的无分支三目运算.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三丶虚继承.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;通过第普通的菱形继承,我们得出了每一个父类都会有一个父类(爷爷类)然后产生了相同的数据,且数据不明确必须指明调用,所以C++为了解决这种问题,出了一个虚继承.&lt;/p&gt;
&lt;p&gt;直接贴上来内存结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214020410535-939424261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人说,为什么爷爷类会放在下面.而不是上面,视编译器而定,也可以放在上面.为什么放在上面说来话长,不符合此博客的篇幅.&lt;/p&gt;
&lt;p&gt;提示一句:把自己当做编译器.&lt;/p&gt;
&lt;p&gt;　　　根据构造的时候先父类构造我们得出了.&lt;/p&gt;
&lt;p&gt;首先爷爷类会先构造,但是此时有一个问题,我们要怎么知道爷爷类在哪里.所以这个时候就需要进行记录了.&lt;/p&gt;
&lt;p&gt;然后我们上面的内存结构变为了下面这样.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214020945066-1539097602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个父类记录一下爷爷类的偏移即可.这个偏移是编译器填写的.&lt;/p&gt;
&lt;p&gt;新的问题:&lt;/p&gt;
&lt;p&gt;　　我们怎么知道爷爷类是在下面还是在上面&lt;/p&gt;
&lt;p&gt;所以这个偏移是一个结构体的地址,指向了一个2个成员的结构体,结构体+0的偏移是向上的偏移.+4的位置是向下的偏移,我们的父类+上这个偏移就能找到爷爷类了.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;看其反汇编代码:&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.main函数下的构造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214021609082-1711488158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看出一个特征,push 1了,为什么?&lt;/p&gt;
&lt;p&gt;因为要判断是否构造爷爷类,填写爷爷类的虚表,所以push 1,而当父类构造的时候,爷爷类就不要构造了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.构造内部.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171214021914863-379043777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.首先和参数进行比较,判断是否为1, 相等就跳转,不相等就指向,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.因为条件没有跳转,所以编译器首先给父类填写偏移.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.如果跳转了,可以看到push 0.然后调用父类构造,其内部一样的判断是否构造爷爷类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.最后构造爷爷类.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;识别这个很简单了.&lt;/p&gt;
&lt;p&gt;1.看是否构造&lt;/p&gt;
&lt;p&gt;2.找偏移,也就是编译器填写偏移的位置,通过偏移的位置加上父类当前位置看一下是不是爷爷类的位置&lt;/p&gt;
&lt;p&gt;3.会有两次写虚表的行为,一个是自身改,一个是基类改&lt;/p&gt;
&lt;p&gt;4.总共会修改三处虚表,两个父类,一个祖先类的虚表.&lt;/p&gt;



</description>
<pubDate>Wed, 13 Dec 2017 18:25:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8035783.html</dc:identifier>
</item>
<item>
<title>用Python删除本地目录下某一时间点之前创建的所有文件 - 木木卡卡西</title>
<link>http://www.cnblogs.com/iderek/p/8035757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iderek/p/8035757.html</guid>
<description>&lt;p&gt;因为工作原因，需要定期清理某个文件夹下面创建时间超过1年的所有文件，所以今天集中学习了一下Python对于本地文件及文件夹的操作。网上 &lt;a href=&quot;http://blog.csdn.net/w122079514/article/details/16864403&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt; 简明扼要地整理出最常见的os方法，抄袭如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;os.listdir(dirname)：列出dirname下的目录和文件&lt;/li&gt;
&lt;li&gt;os.getcwd()：获得当前工作目录&lt;/li&gt;
&lt;li&gt;os.curdir:返回当前目录（'.')&lt;/li&gt;
&lt;li&gt;os.chdir(dirname):改变工作目录到dirname&lt;/li&gt;
&lt;li&gt;os.path.isdir(name):判断name是不是一个目录，name不是目录就返回false&lt;/li&gt;
&lt;li&gt;os.path.isfile(name):判断name是不是一个文件，不存在name也返回false&lt;/li&gt;
&lt;li&gt;os.path.exists(name):判断是否存在文件或目录name&lt;/li&gt;
&lt;li&gt;os.path.getsize(name):获得文件大小，如果name是目录返回0L&lt;/li&gt;
&lt;li&gt;os.path.abspath(name):获得绝对路径&lt;/li&gt;
&lt;li&gt;os.path.normpath(path):规范path字符串形式&lt;/li&gt;
&lt;li&gt;os.path.split(name):分割文件名与目录（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）&lt;/li&gt;
&lt;li&gt;os.path.splitext():分离文件名与扩展名&lt;/li&gt;
&lt;li&gt;os.path.join(path,name):连接目录与文件名或目录&lt;/li&gt;
&lt;li&gt;os.path.basename(path):返回文件名&lt;/li&gt;
&lt;li&gt;os.path.dirname(path):返回文件路径&lt;/li&gt;
&lt;li&gt;os.remove(dir) #dir为要删除的文件夹或者文件路径&lt;/li&gt;
&lt;li&gt;os.rmdir(path) #path要删除的目录的路径。需要说明的是，使用os.rmdir删除的目录必须为空目录，否则函数出错。&lt;/li&gt;
&lt;li&gt;os.path.getmtime(name) ＃获取文件的修改时间&lt;/li&gt;
&lt;li&gt;os.stat(path).st_mtime＃获取文件的修改时间&lt;/li&gt;
&lt;li&gt;os.stat(path).st_ctime #获取文件修改时间&lt;/li&gt;
&lt;li&gt;os.path.getctime(name)#获取文件的创建时间&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;于是我照着这些方法，费半天劲，终于写出了“清理某路径下所有文件及文件夹”的方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; dirToBeEmptied = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\_Data\Python\os&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要清空的文件夹&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; ds = list(os.walk(dirToBeEmptied)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获得所有文件夹的信息列表&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; dsr = ds[::-1] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;反转该列表，从最底层的文件夹开始清算&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt; dsr: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历该列表&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(d) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印出列表项，观察规律&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; d[2] != []: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果该路径下有文件&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; d[2]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先将文件清理干净&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            os.remove(os.path.join(d[0], x))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt; dsr: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;再次遍历该列表&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; d[1] != []: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果该路径下有子文件夹&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt; d[1]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将子文件夹清理干净&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             os.rmdir(os.path.join(d[0], y))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以这么麻烦，是因为 os.rmdir() 有个毛病，只能删除“空”文件夹。所以只能从最底层的文件夹开始清理，一级一级往上，才能清干净。&lt;/p&gt;
&lt;p&gt;后来想想，应该有更简便的方法，因为清空文件夹是很常见的动作。查了Python官方文档，发现了os以外的另一个模块：&lt;a href=&quot;https://docs.python.org/3/library/shutil.html&quot; target=&quot;_blank&quot;&gt;shutil&lt;/a&gt;（高级文件操作），竟然有 shutil.rmtree() 的方法，不仅是清空，直接连文件夹都一起删掉，太凶残了！&lt;/p&gt;
&lt;p&gt;为了“仅仅清空”，我搭配使用 shutil 模块重写了代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; shutil, os
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; os.chdir(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d:\_data\python\os&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进入要清空的目录&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; ds = list(os.listdir()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获得该目录下所有文件或文件夹列表&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt; ds: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历该列表&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; os.path.isfile(d): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果列表项是文件&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         os.remove(d) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;直接删除&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果不是文件，肯定是文件夹&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;         shutil.rmtree(d) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;也直接删除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这下可就简洁多了。&lt;/p&gt;
&lt;p&gt;不过，清空一时爽，但已经偏离我原来的目的了：我只是想删除过期的文件，但文件夹和所有子文件夹都得留着啊。倒也不难，最开始的代码中，第1次遍历列表就是只删文件、不删文件夹。只要再加个判断语句，判断出文件是否过期，就能达到目的了。&lt;/p&gt;
&lt;p&gt;我要删除的文件，实际上是做镜像备份时，将已从主机删除或更改的文件暂时保存下来，以备恢复之用。这些文件久了会越来越占空间，因此设定为1年过期。这些文件有一个特点，就是只会被复制过来一次，且不会有任何修改，因此只需要判断其创建日期就可以。&lt;/p&gt;
&lt;p&gt;想着是容易，但万万没想到，Python对时间的处理这么复杂！涉及到两个模块：&lt;a href=&quot;https://docs.python.org/3/library/datetime.html&quot; target=&quot;_blank&quot;&gt;datetime&lt;/a&gt; 和 &lt;a href=&quot;https://docs.python.org/3/library/time.html&quot; target=&quot;_blank&quot;&gt;time&lt;/a&gt;。有时间必须重头系统学习一下，但这里，我只关心现在需要的几个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;datetime.datetime.now() #获取当前时间，返回值的格式类似 datetime.datetime(2017, 12, 14, 1, 29, 24, 406538)&lt;/li&gt;
&lt;li&gt;datetime.timedelta() #设定两个时间之间的间隔，用于时间计算，可以设置的单位包括：(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)，默认都为0&lt;/li&gt;
&lt;li&gt;os.path.getctime() #获取文件的创建时间，返回值的格式为一个巨大的浮点数，为1970年1月1日到这个创建时间所历经的秒数&lt;/li&gt;
&lt;li&gt;datetime.datetime.fromtimestamp() #将os.path.getctime() 转换为跟datetime.datetime.now()一样的格式，以进行比较计算&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;弄清楚上面这些乱七八糟的之后，就可以写代码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os, datetime
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; dirToBeEmptied = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\_Data\Python\os&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要清空的文件夹&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; ds = list(os.walk(dirToBeEmptied)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获得所有文件夹的信息列表&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; delta = datetime.timedelta(days=365) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设定365天前的文件为过期&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; now = datetime.datetime.now() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取当前时间&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; d &lt;span&gt;in&lt;/span&gt; ds: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历该列表&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     os.chdir(d[0]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;进入本级路径，防止找不到文件而报错&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; d[2] != []: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果该路径下有文件&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; d[2]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历这些文件&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             ctime = datetime.datetime.fromtimestamp(os.path.getctime(x)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取文件创建时间&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ctime &amp;lt; (now-delta): &lt;span&gt;#&lt;/span&gt;&lt;span&gt;若创建于delta天前&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 os.remove(x) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;则删掉&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;呼~~~~~~~~~&lt;/p&gt;
&lt;p&gt;真够复杂的！不知道有没有简便一点的办法……&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 17:38:00 +0000</pubDate>
<dc:creator>木木卡卡西</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iderek/p/8035757.html</dc:identifier>
</item>
<item>
<title>使用nginx代理跨域，使用nginx代理bing的每日一图 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/nginx-proxy-bing-as-cors.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/nginx-proxy-bing-as-cors.html</guid>
<description>&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;800&quot; height=&quot;400&quot; src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1513194622828&amp;amp;di=90acc1e7bf66cfae227b0f4ae7ffe101&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fstatic.codeceo.com%2Fimages%2F2016%2F03%2F231629qzlzebd9e7xxpnfx.png&quot;/&gt;&lt;/div&gt;

&lt;p&gt;自从搞清楚了跨域原理后一直自鸣得意，感觉跨域没啥问题了。而事实上对关于跨域的几个header的理解也有限，但那又如何，我能做到跨域就行了。今天想把博客背景图改成bing的每日一图，发现遇到跨域问题。首先想到的就是自己写一个web，请求bing，然后传出结果，把自己的接口允许跨域。确实做到了，但是。我找了一台阿里云服务器，我安装了java，我编写了一个基于dropwizard的webservice。我需要写脚本去部署，确保系统稳定，挂了自动重启。我要写一堆的java代码来完成这件事。忽然想到nginx，于是一发不可收拾。&lt;/p&gt;

&lt;p&gt;参阅http://blog.rmiao.top/install-nginx-on-centos/&lt;/p&gt;
&lt;p&gt;找到配置文件&lt;code&gt;/usr/local/nginx/nginx.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;location ^~/proxy/bing/ {
    add_header 'Access-Control-Allow-Origin' 'http://localhost:8088';
    add_header 'Cache-Control' 'public, max-age=604800';

    add_header 'Access-Control-Allow-Credentials' 'true';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';

    rewrite ^/proxy/bing/(.*)$ /$1 break;
    proxy_pass https://cn.bing.com/; 
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;http://101.200.218.760/proxy/bing/HPImageArchive.aspx?format=js&amp;amp;idx=0&amp;amp;n=1

代理对象为：
https://cn.bing.com/HPImageArchive.aspx?format=js&amp;amp;idx=0&amp;amp;n=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是最简单的实现方案，但缺点是只能指定一个域名跨域。&lt;/p&gt;

&lt;p&gt;不要想用逗号隔开，这个不行，浏览器不允许。那么只能自己判断比较后插入一个合适的值。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;server {
    listen       80;
    server_name  localhost;

    #charset koi8-r;

    #access_log  logs/host.access.log  main;

    location / {
        root   html;
        index  index.html index.htm;
    }

    location ^~/proxy/bing/ {

        set $cors &quot;local&quot;;

        if ( $http_referer ~* &quot;(https?://www\.cnblogs\.com/woshimrf[^\s]*)|(https?://api.rmiao.top[^\s]*)|(https?://blog.rmiao.top[^\s]*)|(http://localhost[^\s]*)&quot; ) {
            set $cors &quot;allow&quot;;
        }

        if ( $request_method = &quot;OPTIONS&quot; ) {
            set $cors &quot;${cors}options&quot;;
        }

        if ( $cors = &quot;allowoptions&quot; ) {
            add_header 'Access-Control-Allow-Origin' &quot;$http_origin&quot;;
            add_header 'Access-Control-Allow-Credentials' &quot;true&quot;;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, DELETE';
            add_header 'Access-Control-Allow-Headers' 'reqid, nid, host, x-real-ip, x-forwarded-ip, event-type, event-id, accept, content-type';
            add_header 'Access-Control-Max-Age' 2592000;
            add_header 'Content-Length' 0;
            add_header 'Content-Type' 'text/plain, charset=utf-8';
            
            # indicate successful return with no content
            return 204;
        }
        
        if ($cors = &quot;allow&quot;) {
            rewrite ^/proxy/bing/(.*)$ /pub_cors/$1 last;
        }

        if ($cors = &quot;local&quot;) {
            return 403;
        }

    }

    location ^~/pub_cors/ {
        internal;
        # Tells the browser this origin may make cross-origin requests
        add_header 'Access-Control-Allow-Origin' &quot;$http_origin&quot;;
        # in a preflight response, tells browser the subsequent actual request can include user credentials (e.g., cookies)
        add_header 'Access-Control-Allow-Credentials' &quot;true&quot;;
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, DELETE';
        add_header 'Access-Control-Allow-Headers' 'reqid, nid, host, x-real-ip, x-forwarded-ip, event-type, event-id, accept, content-type';
        add_header 'Access-Control-Max-Age' 2592000;
        add_header 'Cache-Control' &quot;public, max-age=604800&quot;;

        rewrite ^/pub_cors/(.*)$ /$1 break;
        proxy_pass https://cn.bing.com/; 
    }

    #error_page  404              /404.html;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   html;
    }



}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;语法要点就不推测了。后面有机会认真学习下。不过，这里还是可以有几个语法参考的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置变量 &lt;code&gt;set $cors &quot;local&quot;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正则表达式 &lt;code&gt;location ^~/proxy/bing/ {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取request的refer &lt;code&gt;$http_referer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取request的method &lt;code&gt;$request_method&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取request的origin &lt;code&gt;$http_origin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变量的读取，包裹在引号里也可以， &lt;code&gt;add_header 'Access-Control-Allow-Origin' &quot;$http_origin&quot;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变量的读取，可以用大括号包裹， &lt;code&gt;set $cors &quot;${cors}options&quot;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;if 里的判断可以用正则， &lt;code&gt;~*&lt;/code&gt; 表示不区分大小写，匹配正则, 取反&lt;code&gt;!~*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 区分大小写，匹配正则， 取反 &lt;code&gt;!~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加一个header， &lt;code&gt;add_header 'Access-Control-Max-Age' 2592000;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置option的预检请求为204&lt;/li&gt;
&lt;li&gt;跳转， &lt;code&gt;rewrite ^/proxy/bing/(.*)$ /pub_cors/$1 last;&lt;/code&gt;, 分3部分，第一部分是正则，是匹配当前location的url的正则。 第二部分是映射的值，在第二部分里可以使用&lt;code&gt;$1&lt;/code&gt;来获得匹配第一个括号匹配的内容。&lt;/li&gt;
&lt;li&gt;if 里的判断可以用等号, &lt;code&gt;if ($cors = &quot;allow&quot;) {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internal;&lt;/code&gt;是不是只能内部访问？&lt;/li&gt;
&lt;li&gt;对于这种代理，尤其是bing这个，完全可以缓存掉。 &lt;code&gt;add_header 'Cache-Control' &quot;public, max-age=604800&quot;;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy_pass https://cn.bing.com/;&lt;/code&gt; 代理host，看样子下一步请求的host就是它，对于&lt;code&gt;rewrite ^/pub_cors/(.*)$ /$1 break;&lt;/code&gt;则是把匹配的&lt;code&gt;$1&lt;/code&gt;拼接到host之后。即，完成了转发操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;确实比自己写Java web来做转发的好。&lt;/p&gt;
&lt;h2 id=&quot;todo-研究nginx-配置文件的语法&quot;&gt;TODO 研究Nginx 配置文件的语法&lt;/h2&gt;
&lt;p&gt;上面的编写过程都是猜测出来的，没有看官方文档。英语不好就是不愿意看官网。后面有机会再研究具体语法。不过短期应该不会，很少用到nginx。到用到的时候再说吧。&lt;/p&gt;
&lt;h2 id=&quot;todo-正则表达式学习&quot;&gt;TODO 正则表达式学习&lt;/h2&gt;
&lt;p&gt;虽然看了很多变正则表达式，但仅仅会写一个简单的基础模型。nginx里的配置让我看到了正则表达式的强大。什么时候深入学习一下呢？只能放到todo list里了，短期没时间规划。&lt;/p&gt;

&lt;p&gt;了解到怎么返回405：&lt;/p&gt;
&lt;p&gt;照抄写的跨域方案：&lt;/p&gt;
&lt;p&gt;最先看到的解决方案，虽然不合适：&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 17:16:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/nginx-proxy-bing-as-cors.html</dc:identifier>
</item>
<item>
<title>状态模式（State） - 张三疯_1998</title>
<link>http://www.cnblogs.com/zhh19981104/p/8035691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhh19981104/p/8035691.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【序言】：由于直接贴代码相关的关键字不能智能提示，代码看着很是不方便。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现在就在概念中用贴图片进行演示，在实战案例中还是以贴代码的形式出现。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、概念：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。【DP】&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　状态模式的主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;吧状态的判断逻辑转移到表示不同状态的一系列当中，可以把复杂的判断逻辑简化。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;当然如果这个状态的判断很简单，那么就没必要用“状态模式”了，千万注意不要为了设计模式而去用设计模式。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、通俗的概念理解：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;就是为了消除庞大的条件分支语句。当一个对象的行为取决于他的状态，并且他必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、状态模式类图;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171213215438722-1064108885.jpg&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;218&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、对概念的理解和针对类图进行代码的翻译;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171213223226082-1970433284.jpg&quot; alt=&quot;&quot; width=&quot;791&quot; height=&quot;502&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171213223306004-876049068.jpg&quot; alt=&quot;&quot; width=&quot;788&quot; height=&quot;509&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171213223343332-1506952550.jpg&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 结果显示;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265195/201712/1265195-20171213223445051-1507354240.jpg&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;364&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、接下啦就是对概念进行实例的操作了，概念记得再熟，也不如实战一把，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那我这里就是以程序员的加班来进行案例的解释了，对一天的工作时间与下班来进行一个状态的切换。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;using System;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using System.Collections.Generic;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using System.Linq;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using System.Text;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using System.Threading.Tasks;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;namespace Test_02&lt;/span&gt;&lt;br/&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    //抽象的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public abstract class State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public abstract void WriteProgram(Work work);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    //上午的工作状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public class ForenoonState : State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public override void WriteProgram(Work work)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            if (work.Hour &amp;lt; 12)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                Console.WriteLine(&quot;当前时间：&quot; + work.Hour + &quot;点，上午工作，精神还行&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            else  //否则，超过12点进行状态的切换&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.SetState(new NoonState());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.WriteProgram();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    //中午的工作状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public class NoonState : State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public override void WriteProgram(Work work)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            if (work.Hour &amp;lt; 13)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                Console.WriteLine(&quot;当前时间：&quot; + work.Hour + &quot;点，中午，饿了，犯困&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            else //转到下午的工作状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.SetState(new AfternoonState());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.WriteProgram();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    public class AfternoonState : State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public override void WriteProgram(Work work)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            if (work.Hour &amp;lt; 17)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                Console.WriteLine(&quot;当前时间：&quot; + work.Hour + &quot;点，下午状态还不错，继续努力&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            else//否则，转为傍晚的工作状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.SetState(new EveningState());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.WriteProgram();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    //晚间工作状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public class EveningState : State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public override void WriteProgram(Work work)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            if (work.Finish == true)      //当工作完成了，则转入下班的装态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.SetState(new RestState());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                work.WriteProgram();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                if (work.Hour &amp;lt; 21)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    Console.WriteLine(&quot;当前时间：&quot; + work.Hour + &quot;点，加班哦，疲累至极&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                else                //当时间超过21点则转入睡觉的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    work.SetState(new SleepState());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    work.WriteProgram();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    //睡眠状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public class SleepState : State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public override void WriteProgram(Work work)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            Console.WriteLine(&quot;当前时间：&quot; + work.Hour + &quot;点，已经撑不住了，睡着了&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    //下班休息状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public class RestState : State&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public override void WriteProgram(Work work)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            Console.WriteLine(&quot;当前时间：&quot; + work.Hour + &quot;点，下吧回家休息了&quot;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    //工作类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    public class Work&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        private State current;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        public Work()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            current = new ForenoonState();//工作的初始状态为上午工作状太，9点开始工作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        private double hour;    //属性，状态切换的依据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        public double Hour&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            get { return hour; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            set&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                hour = value;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        private bool finish = false;        //任务完成标志，是否能下班的标志&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        public bool Finish&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            get { return finish; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            set { finish = value; }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        public void SetState(State state)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            current = state;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        public void WriteProgram()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            current.WriteProgram(this);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    class Program&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        static void Main(string[] args)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            Work work = new Work();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            work.Hour = 19;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            work.WriteProgram();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            Console.ReadKey();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;七、总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;em&gt;&lt;span&gt;当一个对象的行为取决于他的状态，并且他必须在运行时刻根据状态改变他的行为时，就可以考虑使用状态模式了，&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;例如可以在角色的AI切换的时候使用，在游戏界面的登录界面以及其他界面的切换中使用，&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;八：扩充：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;在写代码的时候，一定要避免在一个类中的方法过于太长了的情况发生，看起来也是不太爽的是吧！&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;                         　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2017-12-14 00:27:06&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 16:28:00 +0000</pubDate>
<dc:creator>张三疯_1998</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhh19981104/p/8035691.html</dc:identifier>
</item>
<item>
<title>CDH集群搭建部署 - wangkeustc</title>
<link>http://www.cnblogs.com/wangkeustc/p/8035602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangkeustc/p/8035602.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;硬件准备&quot;&gt;1. 硬件准备&lt;/h2&gt;
&lt;p&gt;    使用了五台机器，其中两台8c16g,三台4c8g。一台4c8g用于搭建cmServer和NFS服务端，另外4台作为cloudera-manager agent部署CDH集群。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10.2.223.237&lt;/td&gt;
&lt;td&gt;cmServer NFS server&lt;/td&gt;
&lt;td&gt;v-xstest-849-171208-cdh-1.hx&lt;/td&gt;
&lt;td&gt;4c8g200g&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;10.2.223.239&lt;/td&gt;
&lt;td&gt;Namenode,resouceManager,Hbase Master等&lt;/td&gt;
&lt;td&gt;v-xstest-855-171208-cdh2-1.novalocal&lt;/td&gt;
&lt;td&gt;8c16g200g&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;10.2.223.242&lt;/td&gt;
&lt;td&gt;SecondaryNamenode,hive,hue等&lt;/td&gt;
&lt;td&gt;v-xstest-856-171208-cdh2-2.novalocal&lt;/td&gt;
&lt;td&gt;8c16g200g&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;10.2.223.224&lt;/td&gt;
&lt;td&gt;Datanode,regionServer,nodeManager等&lt;/td&gt;
&lt;td&gt;v-xstest-850-171208-cdh-2.novalocal&lt;/td&gt;
&lt;td&gt;4c8g200g&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;10.2.223.197&lt;/td&gt;
&lt;td&gt;Datanode,regionServer,nodeManager等&lt;/td&gt;
&lt;td&gt;v-xstest-851-171208-cdh-3.novalocal&lt;/td&gt;
&lt;td&gt;4c8g200g&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;h2 id=&quot;nfs搭建&quot;&gt;2. NFS搭建&lt;/h2&gt;
&lt;h3 id=&quot;nfs简介&quot;&gt;2.1 NFS简介&lt;/h3&gt;
&lt;p&gt;    NFS 就是 Network FileSystem 的缩写，最早之前是由sun 这家公司所发展出来的。 它最大的功能就是可以透过网络，让不同的机器、不同的操作系统、可以彼此分享个别的档案 (share files)。所以，你也可以简单的将他看做是一个文件服务器 (file server) 呢！这个 NFS 服务器可以让你的 PC 来将网络远程的 NFS 服务器分享的目录，挂载到本地端的机器当中， 在本地端的机器看起来，那个远程主机的目录就好像是自己的一个磁盘分区槽一样 (partition)！使用上面相当的便利！&lt;/p&gt;
&lt;h3 id=&quot;安装nfs&quot;&gt;2.2 安装NFS&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;查看系统是否已经安装NFS&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;rpm -qa | grep nfs
rpm -qa | grep rpcbind&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;yum安装NFS&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install nfs-utils rpcbind&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;nfs服务端配置&quot;&gt;2.3 NFS服务端配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在NFS服务端上创建共享目录/opt/share并设置权限&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/share
chmod 666 /opt/share&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;编辑/etc/exports文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;vim /etc/exports
/opt/share *(rw,no_root_squash,no_all_squash,sync)

配置生效命令:
exportfs -r&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;参数说明:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;参数值    内容说明
rw　　ro    该目录分享的权限是可擦写 (read-write) 或只读 (read-only)，但最终能不能读写，还是与文件系统的 rwx 及身份有关。

sync　　async    sync 代表数据会同步写入到内存与硬盘中，async 则代表数据会先暂存于内存当中，而非直接写入硬盘！

no_root_squash　　root_squash    客户端使用 NFS 文件系统的账号若为 root 时，系统该如何判断这个账号的身份？预设的情况下，客户端 root 的身份会由 root_squash 的设定压缩成 nfsnobody， 如此对服务器的系统会较有保障。但如果你想要开放客户端使用 root 身份来操作服务器的文件系统，那么这里就得要开 no_root_squash 才行！

all_squash    不论登入 NFS 的使用者身份为何， 他的身份都会被压缩成为匿名用户，通常也就是 nobody(nfsnobody) 啦！

anonuid　　anongid    anon 意指 anonymous (匿名者) 前面关于 *_squash 提到的匿名用户的 UID 设定值，通常为 nobody(nfsnobody)，但是你可以自行设定这个 UID 的值！当然，这个 UID 必需要存在于你的 /etc/passwd 当中！ anonuid 指的是 UID 而 anongid 则是群组的 GID 啰。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动服务&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;service rpcbind start
service nfs start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nfs客户端配置&quot;&gt;2.4 NFS客户端配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;安装以及启动同上&lt;/li&gt;
&lt;li&gt;客户端设置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/share
showmount -e 10.2.223.237
mount -t nfs 10.2.223.237:/opt/share /opt/share -o proto=tcp -o nolock&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;ssh免密登录&quot;&gt;3. SSH免密登录&lt;/h2&gt;
&lt;h3 id=&quot;实现方法&quot;&gt;3.1 实现方法&lt;/h3&gt;
&lt;p&gt;    要实现多台机器相互之间免密登录，只需要将每台机器ssh-keygen生成的公钥(id_rsa.pub)写到一个文件authorized_keys,然后将这个文件复制到每台机器的~/.ssh/authorized_keys，这样就可以互通了。&lt;/p&gt;
&lt;h3 id=&quot;具体步骤&quot;&gt;3.2 具体步骤&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;hosts文件编辑，注意一定要保持与每台机器hostname一致,将hosts文件写到/opt/share/ssh，便于同步
每台机器执行 ssh-keygen -t rsa  -f ~/.ssh/id_rsa，连续回车两次
将每台机器的id\_rsa.pub写到/opt/share/ssh/authorized\_keys
每台机器执行/opt/share/ssh/sync\_config.sh,保持hosts,authorized\_keys一致
sync\_config.sh:
#!/bin/bash
rm -f /etc/hosts
cp /opt/share/ssh/hosts /etc/hosts
rm -f /root/.ssh/authorized_keys
cp /opt/share/ssh/authorized_keys /root/.ssh/authorized_keys&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;安装cloudera-manager-server和agent&quot;&gt;4. 安装Cloudera Manager Server和Agent&lt;/h2&gt;
&lt;p&gt;    使用cm5.4.1 el6版本，el5会有python版本问题，el6内置的python2.6.&lt;/p&gt;
&lt;h3 id=&quot;资源下载&quot;&gt;4.1 资源下载&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cm安装包:http://archive.cloudera.com/cm5/cm/5/cloudera-manager-el6-cm5.4.1_x86_64.tar.gz 
cm资源包(parcel):http://archive.cloudera.com/cdh5/parcels/5.4.1/CDH-5.4.1-1.cdh5.4.1.p0.6-el6.parcel
其他:http://archive.cloudera.com/cdh5/parcels/5.4.1/CDH-5.4.1-1.cdh5.4.1.p0.6-el6.parcel.sha1
http://archive.cloudera.com/cdh5/parcels/5.4.1/manifest.json
另外需要准备mysql-jdbc jar包，这个从maven仓库找一个就行，我用的是:mysql-connector-java-5.1.34.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上面下载资源上传到NFS目录/opt/share/cdh,mysql-connector-java-5.1.34.jar放到/opt/share&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;4.2 安装&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解压:所有机器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/cloudera-manager
tar xvzf share/cloudera-manager*.tar.gz -C /opt/cloudera-manager&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;添加用户:所有机器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;useradd --system --home=/opt/cloudera-manager/cm-5.4.1/run/cloudera-scm-server/ --no-create-home --shell=/bin/false --comment &quot;Cloudera SCM User&quot; cloudera-scm&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改cloudera-scm-agent config.ini:所有机器&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;vim /opt/cloudera-manager/cm-5.4.1/etc/cloudera-scm-agent/config.ini
修改server.host=10.2.223.237  #即cloudera manager Server地址&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;数据库初始化:仅需要 cloudera manager server 执行&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cp /opt/share/mysql-connector-java-5.1.34.jar /opt/cloudera-manager/cm-5.4.1/share/cmf/lib
 /opt/cloudera-manager/cm-5.4.1/share/cmf/schema/scm_prepare_database.sh mysql cm_new -h 10.2.222.25 -ubigdata -p'bigdata123'  --scm-host 10.2.223.237 bigdata bigdata123 --force
 注释:cm_new  数据库名称，自己填写  -h -u -p连接数据库配置，如果没有mysql需要自己搭建 ，--scm-host 后面bigdata bigdata123这两个是需要连接的数据库配置，而不是网上的scm  scm scm
 注2:这个命令执行主要是创建数据库，并且在/opt/cloudera-manager/cm-5.4.1/etc/cloudera-scm-server/db.properties生成数据库配置，如果配置成功就OK了，可以忽略其他报错&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建parcel-repo文件夹:cloudera manager server,注意文件夹名字不要写错，这个与后面CM配置页面里面设置对应，也可以修改，建议默认值保持一致&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/cloudera/parcel-repo
cp /opt/share/cdh/CDH-5.4.1-1.cdh5.4.1.p0.6-el6.parcel.sha1 /opt/cloudera/parcel-repo/CDH-5.4.1-1.cdh5.4.1.p0.6-el6.parcel.sha #注意修改名称sha1  sha
cp /opt/share/cdh/manifest.json /opt/cloudera/parcel-repo
chown cloudera-scm:cloudera-scm -R /opt/cloudera/parcel-repo/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建parcels文件夹:cloudera manager agent&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mkdir -p /opt/cloudera/parcels
chown cloudera-scm:cloudera-scm /opt/cloudera/parcels&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动服务&quot;&gt;4.3 启动服务&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Manager Server:/opt/cloudera-manager/cm-5.4.1/etc/init.d/cloudera-scm-server start&lt;/li&gt;
&lt;li&gt;Agent : /opt/cloudera-manager/cm-5.4.1/etc/init.d/cloudera-scm-agent start&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;cdh配置安装&quot;&gt;5. CDH配置安装&lt;/h2&gt;
&lt;p&gt;    登录配置页面10.2.223.237:7180 默认账号秘密: admin admin&lt;br/&gt;由于本人安装时候没有一个个页面截图，具体大家第一次进入之后就可以看到，傻瓜式操作。&lt;/p&gt;
&lt;h3 id=&quot;导航安装&quot;&gt;5.1 导航安装&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;登录进入以后，选择免费版，进入为CDH集群指定安装主机页面后，如果配置安装正确，所有agent机器都会出现在当前管理的主机，如果没有，则启动错误或者config.ini配置错误。检查启动日志，修改错误后，删除4.2中创建的数据库并且重新执行数据库初始化，重启服务&lt;/li&gt;
&lt;li&gt;进入群集安装页面，会让你选择CDH版本，勾选&lt;strong&gt;使用parcel建议&lt;/strong&gt; 以及&lt;strong&gt;CDH-5.4.1-1.cdh5.4.1.p0.6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;进入群集设置，选择需要安装的服务,建议自定义服务，安装你需要的相关服务即可&lt;/li&gt;
&lt;li&gt;接下来是集群分配各节点角色：这块最好不要按照默认配置的来，相关的服务最好可以合理分配一下，比如我的两台8c16g就用来安装Namenode ,resourceManger,hbase master,sendcondary namenode,hive以及hue等。同时，自己手动分配的时候，也会对集群相关服务更了解，后面安装出错的时候更容易找到日志定位问题&lt;/li&gt;
&lt;li&gt;配置hive/oozie/active monitor数据库：需要提前创建好&lt;/li&gt;
&lt;li&gt;安装服务：各个服务按顺序安装，中间出错的时候请在对应的机器上找到相关的日志，服务的日志都是在/opt/cloudera-manager/cm-5.4.1/run/cloudera-scm-agent/process/，在里面找该服务相关的文件夹，进入之后就可以找到日志文件了。修复问题后，点击重试，会从最近失败的服务开始重新安装，直到所以安装完成就行了。&lt;/li&gt;
&lt;li&gt;如果没有安装结束就退出，没有关系，&lt;a href=&quot;http://10.2.223.237:7180/cmf/hardware/hosts&quot; class=&quot;uri&quot;&gt;http://10.2.223.237:7180/cmf/hardware/hosts&lt;/a&gt; 这个是主机管理页面，可以看每台机器上还有哪些机器没有启动服务，手动启动也可以的&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;服务配置修改&quot;&gt;5.2 服务配置修改&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;修改集群显示名称：默认Cluster 1，直接修改初始化数据库脚本的数据库名.clusters表，修改display_name&lt;/li&gt;
&lt;li&gt;其他服务配置:比如hdfs,hbase等，直接在群集选项中选择该服务，进入以后点击配置就可以了&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;相关错误以及心得&quot;&gt;6. 相关错误以及心得&lt;/h2&gt;
&lt;h3 id=&quot;常见错误&quot;&gt;6.1 常见错误&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;scm_prepare_database.sh执行报错&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;之前我也是参考网上的执行命令，但是没人解释最后三个scm scm  scm是什么意思，具体在4.2中我已经强调了，只要后面数据库创建成功并且对应的db.properties文件配置没错就行了&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置hive/oozie数据库出错&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;要提前创建数据库，并且安装服务的机器上在/opt/cloudera-manager/cm-5.4.1/share/cmf/lib有mysql-connector jar包&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;仅完成1个步骤。首个失败：主机bigdata-cdh-client(id=2)上的客户端配置(id=1)已使用1退出，而预期值为0&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;在安装服务界面，执行失败时，点击查看详细信息，会给出这样类似的错误信息。查看/opt/cloudera-manager/cm-5.4.1/run/cloudera-scm-agent/process目录下相关日志。
发现上面这个错误信息是由于JAVA_HOME问题，启动脚本中，JAVA_HOME并不是根据环境变量来获取，而是在它列举的几个目录下寻找，所以只要把你的java路径ln -s过去就行，比如我的  ln -s /opt/jdk/jdk1.7-7u80/ /usr/java/jdk1.7&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;hive metastore server启动失败 Caused by: org.datanucleus.store.rdbms.connectionpool.DatastoreDriverNotFoundException: The specified datastore driver (&quot;com.mysql.jdbc.Driver&quot;) was not found in the CLASSPATH&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;将mysql-connectorxxx.jar拷贝到/opt/cloudera/parcels/CDH-5.4.1-1.cdh5.4.1.p0.6/lib/hive/lib下，只需要拷贝hive metastore server这台就行了&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;urlopen error [Errno -2] Name or service not known&amp;gt; - agent197&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我之前为了识别方便，修改了hosts和机器的hostname，但是在我们的DNS服务器中仍无法修改,可以通过nslookup  ip 查看比如nslookup 10.2.223.237,发现这个里面的name仍然是修改hostname之前的。
所以建议不要轻易修改hostname，在配置的hosts中也要保持与hostname一致&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;安装向导页面创建hive metastore数据库表出错:org.apache.hive.beeline.HiveSchemaHelper.getConnectionToMetastore(HiveSchemaHelper.java:79&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cp /opt/share/mysql-connector-java-5.1.34.jar  /opt/cloudera/parcels/CDH-5.4.1-1.cdh5.4.1.p0.6/lib/hadoop/lib)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;oozie创建数据库表失败,没有com.mysql.jdbc.driver&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cp /opt/share/mysql-connector-java-5.1.34.jar  /opt/cloudera/parcels/CDH-5.4.1-1.cdh5.4.1.p0.6/lib/oozie/libtools&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;oozie服务启动失败:stdout.log中也是没有com.mysql.jdbc.driver&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;首先，删除oozie数据库并重新创建  
然后cp /opt/share/mysql-connector-java-5.1.34.jar  /opt/cloudera/parcels/CDH-5.4.1-1.cdh5.4.1.p0.6/lib/hadoop/lib&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;建议心得&quot;&gt;6.2 建议&amp;amp;心得&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;请一定先搭建好NFS，而不是通过大量的scp节省人力。&lt;/li&gt;
&lt;li&gt;cm是一个帮助你安装hadoop生态的管理工具，类似ambari，但是需要了解并修改每个服务的基本配置&lt;/li&gt;
&lt;li&gt;在安装服务过程中一定要找日志，只有日志才会告诉你具体的问题&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 13 Dec 2017 15:56:00 +0000</pubDate>
<dc:creator>wangkeustc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangkeustc/p/8035602.html</dc:identifier>
</item>
<item>
<title>5、C#基础 - C#的值类型 - MrBug</title>
<link>http://www.cnblogs.com/mrbug/p/8030341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrbug/p/8030341.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、C#的值类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存储在栈里 &lt;/li&gt;
&lt;li&gt;基于值类型的变量直接包含值（值类型存储实际值）。 将一个值类型变量赋给另一个值类型变量时，将复制包含的值。 这与引用类型变量的赋值不同，引用类型变量的赋值只复制对对象的引用，而不复制对象本身。&lt;/li&gt;
&lt;li&gt;所有的值类型均隐式派生自 System.ValueType。&lt;/li&gt;
&lt;li&gt;与引用类型不同，不能从值类型派生出新的类型。 但与引用类型相同的是，结构也可以实现接口。&lt;/li&gt;
&lt;li&gt;与引用类型不同，值类型无法包含 null 值。 但是，可以为 null 的类型 功能允许值类型分配给 null。&lt;/li&gt;
&lt;li&gt;每种值类型均有一个隐式的默认构造函数来初始化该类型的默认值。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;introduction&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span id=&quot;mt1&quot; class=&quot;sentence&quot; data-guid=&quot;5507285c051d9ec063f6aaf1b56dd800&quot; data-source=&quot;The value types consist of two main categories:&quot;&gt;值类型分为两类： struct（ &lt;span id=&quot;mt2&quot; class=&quot;sentence&quot; data-guid=&quot;5a8d55c70c1f3dcbee2f791cd477d649&quot; data-source=&quot;Structs&quot;&gt;结构&lt;/span&gt; ）、 enum（&lt;span id=&quot;mt3&quot; class=&quot;sentence&quot; data-guid=&quot;5d4d047c0c2c2d415d43bb476b2d73d8&quot; data-source=&quot;Enumerations&quot;&gt;枚举&lt;/span&gt; ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;mt4&quot; class=&quot;sentence&quot; data-guid=&quot;2c5347e6adb54c527e458b9562119840&quot; data-source=&quot;Structs fall into these categories:&quot;&gt;&lt;span id=&quot;mt1&quot; class=&quot;sentence&quot; data-guid=&quot;5507285c051d9ec063f6aaf1b56dd800&quot; data-source=&quot;The value types consist of two main categories:&quot;&gt;struct（ &lt;span id=&quot;mt2&quot; class=&quot;sentence&quot; data-guid=&quot;5a8d55c70c1f3dcbee2f791cd477d649&quot; data-source=&quot;Structs&quot;&gt;结构 ）&lt;/span&gt;&lt;/span&gt;分为以下几类：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;下表列出了 C# 中内置类型中可用的值类型：&lt;/p&gt;
&lt;table class=&quot;reference notranslate&quot;&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;范围&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;bool&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;布尔值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;True 或 False&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;False&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;byte&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8 位无符号整数&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0 到 255&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;char&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;16 位 Unicode 字符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;U +0000 到 U +ffff&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;'\0'&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;decimal&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;128 位精确的十进制值，28-29 有效位数&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(-7.9 x 10&lt;sup&gt;28&lt;/sup&gt; 到 7.9 x 10&lt;sup&gt;28&lt;/sup&gt;) / 10&lt;sup&gt;0 到 28&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0.0M&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;double&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;64 位双精度浮点型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;(+/-)5.0 x 10&lt;sup&gt;-324&lt;/sup&gt; 到 (+/-)1.7 x 10&lt;sup&gt;308&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0.0D&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;float&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;32 位单精度浮点型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-3.4 x 10&lt;sup&gt;38&lt;/sup&gt; 到 + 3.4 x 10&lt;sup&gt;38&lt;/sup&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0.0F&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt;int&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;32 位有符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-2,147,483,648 到 2,147,483,647&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td&gt;&lt;span&gt;long&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;64 位有符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-923,372,036,854,775,808 到 9,223,372,036,854,775,807&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0L&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;sbyte&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8 位有符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-128 到 127&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;short&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;16 位有符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-32,768 到 32,767&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;uint&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;32 位无符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0 到 4,294,967,295&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt;ulong&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;64 位无符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0 到 18,446,744,073,709,551,615&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;ushort&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;16 位无符号整数类型&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0 到 65,535&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;实际上是简单类型，所有的简单类型（C# 语言的组成部分）均为 .NET Framework 系统类型的别名。 例如，int 是 System.Int32 的别名。可使用文字初始化简单类型。 例如，“A”是 char 类型的文字，而 2001 是 int 类型的文字。如需得到一个类型或一个变量在特定平台上的准确尺寸，可以使用 sizeof 方法。表达式 sizeof(type) 产生以字节为单位存储对象或类型的存储尺寸。下面举例获取任何机器上 int 类型的存储尺寸：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; DataTypeApplication
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;          Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Size of int: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         Console.ReadLine();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当上面的代码被编译和执行时，它会产生下列结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Size of &lt;span&gt;int&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2、 C# 的 struct &lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;struct（结构）通常用作一小组相关变量的容器，在 C# 中它使得一个单一变量可以存储各种数据类型的相关数据。struct 关键字用于创建结构体，可以按照如下的方式声明 Person结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Person
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;6 &lt;/span&gt;};  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的程序演示了结构的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50.5&quot;&gt;
&lt;pre readability=&quot;22&quot;&gt;
using System;&lt;p&gt;namespace MyStruct&lt;br/&gt;{&lt;br/&gt;struct Person&lt;br/&gt;{&lt;br/&gt;public string name;&lt;br/&gt;public int age;&lt;br/&gt;public string sex;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Program&lt;br/&gt;{&lt;br/&gt;static void Main(string[] args)&lt;br/&gt;{&lt;br/&gt;Person person1;&lt;br/&gt;person1.name = &quot;张三&quot;;&lt;br/&gt;person1.age = 18;&lt;br/&gt;person1.sex = &quot;男&quot;;&lt;/p&gt;&lt;p&gt;Person person2;&lt;br/&gt;person2.name = &quot;李四&quot;;&lt;br/&gt;person2.age = 20;&lt;br/&gt;person2.sex = &quot;男&quot;;&lt;/p&gt;&lt;p&gt;//输出 person1 的信息&lt;br/&gt;Console.WriteLine(&quot;person1 姓名:{0}&quot;, person1.name);&lt;br/&gt;Console.WriteLine(&quot;person1 性别:{0}&quot;, person1.sex);&lt;br/&gt;Console.WriteLine(&quot;person1 年龄:{0}&quot;, person1.age);&lt;/p&gt;&lt;p&gt;//输出 person2 的信息&lt;br/&gt;Console.WriteLine(&quot;person2 姓名:{0}&quot;, person2.name);&lt;br/&gt;Console.WriteLine(&quot;person2 性别:{0}&quot;, person2.sex);&lt;br/&gt;Console.WriteLine(&quot;person2 年龄:{0}&quot;, person2.age);&lt;/p&gt;&lt;p&gt;Console.Read();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当上面的代码被编译和执行时，它会产生下列结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;person1 姓名:张三
person1 性别:男
person1 年龄:&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;
person2 姓名:李四
person3 性别:男
person4 年龄:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结构与类具有许多相同的语法，但结构比类受到的限制更多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结构可带有方法、字段、索引、属性、运算符方法和事件。&lt;/li&gt;
&lt;li&gt;结构不能声明默认构造函数（没有参数的构造函数）或终结器。&lt;/li&gt;
&lt;li&gt;结构可以声明具有参数的构造函数。&lt;/li&gt;
&lt;li&gt;一个结构无法继承自另一个结构或类，并且它不能为类的基类。&lt;/li&gt;
&lt;li&gt;结构可实现一个或多个接口。&lt;/li&gt;
&lt;li&gt;结构成员不能指定为 abstract、virtual 或 protected。&lt;/li&gt;
&lt;li&gt;与类不同，无需使用 new 运算符即可对结构进行实例化。&lt;/li&gt;
&lt;li&gt;如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多提一下：可将结构类型强制转换为接口类型，这将导致“装箱”操作，以将结构包装在托管堆上的引用类型对象内。 当将值类型传递到接受 Object 作为输入参数的方法时，将发生装箱操作。详细的会在后面装箱和取消装箱说明。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C# 的 enum&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;枚举类型（也称为枚举）为定义一组可以赋给变量的命名整数常量提供了一种有效的方法。 例如，假设您必须定义一个变量，该变量的值表示一周中的一天。 该变量只能存储七个有意义的值。 若要定义这些值，可以使用枚举类型。枚举类型是使用 enum 关键字声明的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Days { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday };
&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt; Months : &lt;span&gt;byte&lt;/span&gt; { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;默认情况下，枚举中每个元素的基础类型是 int。 可以使用冒号指定另一种整数值类型，如前面的示例所示。准许使用的类型有 byte、sbyte、short、ushort、int、uint、long 或 ulong。&lt;/p&gt;

&lt;p&gt;通常情况下，最好是在命名空间内直接定义枚举，以便该命名空间中的所有类都能够同样方便地访问它。 但是，还可以将枚举嵌套在类或结构中。&lt;br/&gt;默认情况下，第一个枚举数的值为 0，后面每个枚举数的值依次递增 1。 例如，下面的枚举，Sat 是 0，Sun 是 1，Mon 是 2 等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;enum&lt;/span&gt; Days {Sat, Sun, Mon, Tue, Wed, Thu, Fri};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如下面的示例所示枚举数可用初始值来重写默认值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;enum&lt;/span&gt; Days {Sat=&lt;span&gt;1&lt;/span&gt;, Sun, Mon, Tue, Wed, Thu, Fri};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span id=&quot;mt7&quot; class=&quot;sentence&quot; data-guid=&quot;ef7ff83fb2be337aab5b0755485c49dc&quot; data-source=&quot;In this enumeration, the sequence of elements is forced to start from &amp;lt;span class=&amp;quot;code&amp;quot;&amp;gt;1 instead of &amp;lt;span class=&amp;quot;code&amp;quot;&amp;gt;0.&quot;&gt;在此枚举中，强制元素序列从&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;code&quot;&gt;1&lt;span class=&quot;Apple-converted-space&quot;&gt; 而不是&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;code&quot;&gt;0&lt;span class=&quot;Apple-converted-space&quot;&gt; 开始。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span id=&quot;mt8&quot; class=&quot;sentence SentenceHover&quot; data-guid=&quot;4ff46a7176564e328e622c1201130df6&quot; data-source=&quot;However, including a constant that has the value of 0 is recommended.&quot;&gt;但是，一般建议这样使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;注，枚举数的名称中不能包含空白。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;040696c9ddc6b6a900c6ee08802db372&quot; data-source=&quot;It is possible to assign any arbitrary integer value to &amp;lt;span class=&amp;quot;code&amp;quot;&amp;gt;meetingDay.&quot;&gt;如果变量 meetingDay 的类型为 Days，则只能将 Days 定义的某个值赋给它（无需显式强制转换）。 如果会议日期更改，可以将 Days 中的新值赋给 meetingDay：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Days meetingDay =&lt;span&gt; Days.Monday;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
meetingDay = Days.Friday;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span id=&quot;mt19&quot; class=&quot;sentence&quot; data-guid=&quot;040696c9ddc6b6a900c6ee08802db372&quot; data-source=&quot;It is possible to assign any arbitrary integer value to &amp;lt;span class=&amp;quot;code&amp;quot;&amp;gt;meetingDay.&quot;&gt;可以将任意整数值赋给&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;code&quot;&gt;meetingDay。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span id=&quot;mt20&quot; class=&quot;sentence&quot; data-guid=&quot;c0856c8b66b2564c91ccc551d8efef60&quot; data-source=&quot;For example, this line of code does not produce an error: &amp;lt;span class=&amp;quot;code&amp;quot;&amp;gt;meetingDay = (Days) 42.&quot;&gt;例如，代码行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;code&quot;&gt;meetingDay = (Days) 42&lt;span class=&quot;Apple-converted-space&quot;&gt; 不会产生错误。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span id=&quot;mt21&quot; class=&quot;sentence&quot; data-guid=&quot;fe84e67e7ee8d22d643a4658b72fe690&quot; data-source=&quot;However, you should not do this because the implicit expectation is that an enum variable will only hold one of the values defined by the enum.&quot;&gt;但也不应该这样做，因为默认约定的是枚举变量只容纳枚举定义的值之一。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span id=&quot;mt22&quot; class=&quot;sentence&quot; data-guid=&quot;97259a278f159effa773d84ef46efebe&quot; data-source=&quot;To assign an arbitrary value to a variable of an enumeration type is to introduce a high risk for errors.&quot;&gt;将任意值赋给枚举类型的变量很有可能会导致错误。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;下面的实例演示了枚举变量的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MyEnum
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Days { Sun, Mon, tue, Wed, thu, Fri, Sat };
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; WeekdayStart = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)Days.Mon;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; WeekdayEnd = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)Days.Fri;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Monday: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeekdayStart);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Friday: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WeekdayEnd);
            
            Console.Read();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当上面的代码被编译和执行时，它会产生下列结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Monday: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Friday: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目源码下载：https://pan.baidu.com/s/1miOPAdU&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 15:49:00 +0000</pubDate>
<dc:creator>MrBug</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mrbug/p/8030341.html</dc:identifier>
</item>
<item>
<title>Python的Web应用框架--Django - 姚红</title>
<link>http://www.cnblogs.com/yaohong/p/8035543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaohong/p/8035543.html</guid>
<description>&lt;h2&gt;一：简介&lt;/h2&gt;
&lt;p&gt;     python的web框架有很多，个人查了一下，有Django、Pylons、 Tornado、Bottle和Flask等，其中使用人数最多的是Django，而我学习Django也是因为openstack中使用的是django框架。&lt;/p&gt;
&lt;p&gt;     Django是一个开放源代码的Web应用框架，由Python写成，采用了MVC的软件设计模式，即模型M，视图V和控制器C。&lt;/p&gt;
&lt;h2&gt;二：安装&lt;/h2&gt;
&lt;p&gt;由于Django2.0以后便不再支持python2.x，所以在安装时一定要注意。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.1.Python3.x+Django2.x&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;span class=&quot;pln&quot;&gt;python&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;setuptools&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install python-setuptools
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;下载Django安装包&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
easy_install django
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;2.2.Python2.x+Django1.x&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;span class=&quot;pln&quot;&gt;python&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;setuptools&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install python-setuptools
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;下载Django安装包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载源码包：&lt;a class=&quot;reference external&quot; href=&quot;https://www.djangoproject.com/download/&quot;&gt;https://www.djangoproject.com/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171211223247337-455226552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击历史版本中的1.11版本下载。&lt;/p&gt;
&lt;p&gt;输入以下命令并安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tar xzvf Django-&lt;span&gt;X.Y.tar.gz    # 解压下载包
cd Django-&lt;span&gt;X.Y                 # 进入 Django 目录
python setup.py install       # 执行安装命令&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3检验&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@solar django]# python
Python 2.7.3 (default, May 15 2014, 14:49:08&lt;span&gt;)
[GCC 4.8.0&lt;span&gt;] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for&lt;span&gt; more information.
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; import django
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; django.VERSION
(1, 6, 5, 'final', 0&lt;span&gt;)
&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三：创建第一个项目&lt;/h2&gt;
&lt;h3&gt;3.1创建并浏览器展示&lt;/h3&gt;
&lt;p&gt;这里要学会使用django-admin.py管理工具，来创建。&lt;/p&gt;
&lt;p&gt;创建项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
django-admin.py  startproject  HelloWord
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入项目，查看目录结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# cd HelloWorld/&lt;span&gt;
[root@localhost HelloWorld]# tree
.
├── HelloWorld          --------项目的容器
│   ├── __init__.py     --------一个空文件，告诉 Python 该目录是一个 Python 包
│   ├── settings.py     --------该djiango项目的设置、配置
│   ├── urls.py         --------该djiango项目的URL声明，一份由djiango驱动的网站“目录”
│   └── wsgi.py         --------一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。
└── manage.py           --------一个非常实用的管理工具，可以实现与django的各种交互

1 directory, 5&lt;span&gt; files
[root@localhost HelloWorld]# &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动服务器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python manage.py runserver 0.0.0.0:8000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再在浏览器中输入服务器IP:8000 &lt;/p&gt;
&lt;p&gt;此时要注意：&lt;/p&gt;
&lt;p&gt;1：关闭防火墙，&lt;/p&gt;
&lt;p&gt;2：如果出现“&lt;a href=&quot;http://blog.csdn.net/u011630575/article/details/73522090&quot;&gt;dango error：DisallowedHost: Invalid HTTP_HOST header: ''. You may need to add u'' to ALLOWED_HOST&lt;/a&gt;”错误，就修改settings.py文件中&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;ALLOWED_HOSTS = [‘*‘]  ＃在这里请求的host添加了*&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171212151856629-1922101210.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3.2修改视图内容&lt;/h3&gt;
&lt;p&gt;1.在HelloWorld/HelloWorld目录中创建一个新文件 view.py 文件，并输入代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
from&lt;span&gt; django.http import HttpResponse
 
def hello(request):
    return HttpResponse(&quot;Hello world ! &quot;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.在 urls.py 文件中注释原来的代码，添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
from&lt;span&gt; django.conf.urls import url

from&lt;span&gt; . import view

urlpatterns =&lt;span&gt; [
    url(r'^$'&lt;span&gt;, view.hello),
]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后启动django，访问浏览器出现如下内容&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171212151817629-1576829961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3修改URL&lt;/h3&gt;
&lt;p&gt; 修改urls.py代码，在其中添加如下红色类似字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
from&lt;span&gt; django.conf.urls import url

from&lt;span&gt; . import view

urlpatterns =&lt;span&gt; [
    url(r'^yaohong$'&lt;span&gt;, view.hello),
]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后启动django服务&lt;/p&gt;
&lt;p&gt;再输入原来的服务器IP:8000会出现如下报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171212152951566-353271005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为需要再在端口号后面加入刚刚添加的字符,如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171212153100191-1823229463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四：模板&lt;/h2&gt;
&lt;h3&gt; 4.1实现模板数据分离&lt;/h3&gt;
&lt;h4 class=&quot;example&quot;&gt;1.创建模板文件&lt;/h4&gt;
&lt;p class=&quot;example&quot;&gt;在HelloWorld下创建创建templates文件夹再在文件夹下创建hello.html，HelloWorld/templates/hello.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon HelloWorld]# tree
.
├── db.sqlite3
├── HelloWorld
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── settings.py
│   ├── settings.pyc
│   ├── urls.py
│   ├── urls.pyc
│   ├── view.py
│   ├── view.pyc
│   ├── wsgi.py
│   └── wsgi.pyc
├── manage.py
└── templates
    └── hello.html

2 directories, 13 files&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在hello.html中添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;lt;h1&amp;gt;{{ hello }}&amp;lt;/h1&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.在settings.py中配置模板路径&lt;/h4&gt;
&lt;p&gt;修改 TEMPLATES 中的 DIRS 为 &lt;strong&gt;[BASE_DIR+&quot;/templates&quot;,]&lt;/strong&gt;，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
TEMPLATES =&lt;span&gt; [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates'&lt;span&gt;,
        'DIRS'&lt;span&gt;: [],
        'DIRS': [BASE_DIR+&quot;/templates&quot;&lt;span&gt;,],
        'APP_DIRS'&lt;span&gt;: True,
        'OPTIONS'&lt;span&gt;: {
            'context_processors'&lt;span&gt;: [
                'django.template.context_processors.debug'&lt;span&gt;,
                'django.template.context_processors.request'&lt;span&gt;,
                'django.contrib.auth.context_processors.auth'&lt;span&gt;,
                'django.contrib.messages.context_processors.messages'&lt;span&gt;,
            ],
        },
    },
]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.在 view.py中想模板提交数据&lt;/h4&gt;
&lt;p&gt;在view.py中加入如下代码，其中“hello”为模板中的变量，“Hello Word! my name is yaohong”为提交的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
from&lt;span&gt; django.shortcuts import render

def hello(request):
    context          =&lt;span&gt; {}
    context['hello'] = 'Hello World! my name is yaohong'
    return render(request, 'hello.html', context)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.启动服务器&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python manage.py runserver 0.0.0.0:8000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在浏览器中输入地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171212165139801-365360097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.2Django模板标签&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;if/else 标签&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% if condition1 %&lt;span&gt;}
   ... display 1&lt;span&gt;
{% elif condition2 %&lt;span&gt;}
   ... display 2&lt;span&gt;
{% else %&lt;span&gt;}
   ... display 3&lt;span&gt;
{% endif %}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;for 标签&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% for athlete in athlete_list %&lt;span&gt;}
    &amp;lt;h1&amp;gt;{{ athlete.name }}&amp;lt;/h1&amp;gt;
    &amp;lt;ul&amp;gt;&lt;span&gt;
    {% for sport in athlete.sports_played %&lt;span&gt;}
        &amp;lt;li&amp;gt;{{ sport }}&amp;lt;/li&amp;gt;&lt;span&gt;
    {% endfor %&lt;span&gt;}
    &amp;lt;/ul&amp;gt;&lt;span&gt;
{% endfor %}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ifequal/ifnotequal 标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{% ifequal %} 标签比较两个值，当他们相等时，显示在 {% ifequal %} 和 {% endifequal %} 之中所有的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{% ifequal user currentuser %&lt;span&gt;}
    &amp;lt;h1&amp;gt;Welcome!&amp;lt;/h1&amp;gt;&lt;span&gt;
{% endifequal %}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注释标签&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{# 这是一个注释 #}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#{{ name }} 变量被过滤器 lower 处理后，文档大写转换文本为小写
{{ name|lower }}&lt;br/&gt;#将第一个元素并将其转化为大写。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;span class=&quot;pun&quot;&gt;{{&lt;span class=&quot;pln&quot;&gt; my_list&lt;span class=&quot;pun&quot;&gt;|&lt;span class=&quot;pln&quot;&gt;first&lt;span class=&quot;pun&quot;&gt;|&lt;span class=&quot;pln&quot;&gt;upper &lt;span class=&quot;pun&quot;&gt;}}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;include 标签&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
{% include &quot;nav.html&quot; %}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;模板继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 首先新建一个要被继承的文件，这里命名为base.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;继承的学习&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;我是继承过来的!!!&amp;lt;/p&amp;gt;&lt;span&gt;
    {% block mainbody %&lt;span&gt;}
       &amp;lt;p&amp;gt;original&amp;lt;/p&amp;gt;&lt;span&gt;
    {% endblock %&lt;span&gt;}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 再在hello.html继承base.html页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{% extends &quot;base.html&quot; %&lt;span&gt;}
&amp;lt;h1&amp;gt;{{ hello }}&amp;lt;/h1&amp;gt;&lt;span&gt;

{% block mainbody %}&amp;lt;p&amp;gt;继承了 base.html 文件&amp;lt;/p&amp;gt;&lt;span&gt;
{% endblock %}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171212205809426-134683729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五：模型&lt;/h2&gt;
&lt;h3&gt;5.1安装mysql &lt;/h3&gt;
&lt;p&gt;首先检查系统是否自带或者我们已经安装mysql，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rpm -qa | grep mysql
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;安装并启动mysql：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
#非centos7版本
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum install mysql
yum install mysql-&lt;span&gt;server
yum install mysql-&lt;span&gt;devel&lt;br/&gt;&lt;span class=&quot;pln&quot;&gt;service mysqld start&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
#centos7版本执行如下
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
yum install mariadb-server mariadb&lt;/pre&gt;
&lt;pre class=&quot;prettyprint prettyprinted&quot;&gt;
&lt;span class=&quot;pln&quot;&gt;systemctl start mariadb  &lt;span class=&quot;com&quot;&gt;#启动MariaDB&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;com&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;com&quot;&gt;&lt;span class=&quot;pln&quot;&gt;
systemctl enable mariadb  &lt;span class=&quot;com&quot;&gt;#设置开机启动&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;验证安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行下面语句会看到版本信息，如果没有任何输出，表示mysql没有安装成功&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mysqladmin --version
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;设置用户&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更改root密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqladmin -u root password &quot;new_password&quot;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;设置test用户密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 mysql -u root -&lt;span&gt;p
&amp;gt;GRANT ALL PRIVILEGES ON test.* TO 'test'@'localhost'&lt;span&gt; \
    IDENTIFIED BY 'test123'&lt;span&gt;;
&amp;gt;GRANT ALL PRIVILEGES ON test.* TO 'test'@'%'&lt;span&gt; \
    IDENTIFIED BY 'test123';&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5.2修改相应配置&lt;/h3&gt;
&lt;h4&gt;1.数据库配置&lt;/h4&gt;
&lt;p&gt;在HelloWorld/HelloWorld/settings.py下修改DATABASES{}如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
DATABASES =&lt;span&gt; {
    'default'&lt;span&gt;: {
        'ENGINE': 'django.db.backends.mysql'&lt;span&gt;, 
        'NAME': 'test'&lt;span&gt;,
        'USER': 'test'&lt;span&gt;,
        'PASSWORD': 'test123'&lt;span&gt;,
        'HOST':'localhost'&lt;span&gt;,
        'PORT':'3306'&lt;span&gt;,
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.定义模型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;创建APP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入HelloWorld文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
django-admin.py startapp TestModel
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;创建完成后目录如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@localhost HelloWorld]# tree
.
├── db.sqlite3
├── HelloWorld
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── settings.py
│   ├── settings.pyc
│   ├── testdb.py
│   ├── testdb.pyc
│   ├── urls.py
│   ├── urls.pyc
│   ├── view.py
│   ├── view.pyc
│   ├── wsgi.py
│   └── wsgi.pyc
├── manage.py
├── templates
│   ├── base&lt;span&gt;.html
│   └── hello.html
└── TestModel
    ├── admin.py
    ├── admin.pyc
    ├── apps.py
    ├── __init__.py
    ├── __init__.pyc
    ├── migrations
    │   ├── 0001_initial.py
    │   ├── 0001_initial.pyc
    │   ├── __init__.py
    │   └── __init__.pyc
    ├── models.py
    ├── models.pyc
    ├── tests.py
    └── views.py

4 directories, 29 files&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;修改HelloWorld/TestModel/models.py：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# models.py
from&lt;span&gt; django.db import models
 
class&lt;span&gt; Test(models.Model):
    name = models.CharField(max_length=20)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;修改settings.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; (
    'django.contrib.admin'&lt;span&gt;,
    'django.contrib.auth'&lt;span&gt;,
    'django.contrib.contenttypes'&lt;span&gt;,
    'django.contrib.sessions'&lt;span&gt;,
    'django.contrib.messages'&lt;span&gt;,
    'django.contrib.staticfiles'&lt;span&gt;,
    'TestModel'&lt;span&gt;,               # 添加此项
)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;执行下列命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ python manage.py migrate   # 创建表结构

$ python manage.py makemigrations TestModel  # 让 Django 知道我们在我们的模型有一些变更
$ python manage.py migrate TestModel   # 创建表结构&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;数据库操作&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;example&quot;&gt;修改HelloWorld/HelloWorld/urls.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
from django.conf.urls import *
from&lt;span&gt; . import view,testdb
 
urlpatterns =&lt;span&gt; [
    url(r'^hello$'&lt;span&gt;, view.hello),
    url(r'^testdb$'&lt;span&gt;, testdb.testdb),
]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;example&quot;&gt;创建HelloWorld/HelloWorld/testdb.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# -*- coding: utf-8 -*-
 
from&lt;span&gt; django.http import HttpResponse
 
from&lt;span&gt; TestModel.models import Test
 
# 数据库操作
def testdb(request):
    test1 = Test(name='runoob'&lt;span&gt;)
    test1.save()
    return HttpResponse(&quot;&amp;lt;p&amp;gt;数据添加成功！&amp;lt;/p&amp;gt;&quot;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在浏览器中输入IP:8000/testdb&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1024482/201712/1024482-20171213155206097-687141715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 13 Dec 2017 15:39:00 +0000</pubDate>
<dc:creator>姚红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaohong/p/8035543.html</dc:identifier>
</item>
<item>
<title>Hibernate框架入门 - 风之之</title>
<link>http://www.cnblogs.com/fzz9/p/8035007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fzz9/p/8035007.html</guid>
<description>&lt;h2&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本文主&lt;span&gt;要&lt;/span&gt;介绍hibernate的入门，主要包括以下内容：hibernate介绍、hibernate环境搭建、hibernate简单测试、测试涉及的api详解。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、hibernate介绍&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;JDBC是Java操作数据库的工具，我们可以使用jdbc来书写并执行sql语句来操作数据库，对于普通的业务，jdbc工具是完全可以胜任的，但但当任务复杂，特别是数据库中表格很多的时候，jdbc就会显得力不从心，代码复用率低且sql语句容易出错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Hibernate框架从jdbc面向过程操作数据库的过程转变为面向对象来操作数据库。其原理是&lt;span&gt;ORM编程&lt;/span&gt;，即Object Relational Mapping(&lt;span&gt;对象关系映射&lt;/span&gt;)。每一个数据库表对应一个实体类，这个实体类通过映射关系来操作这个数据库表，映射可以理解为平常我们所说的函数，如y=f(x);y是数据库中的表，x是实体类，f(x)即映射关系，我们通过操作x可以改变y值，同样的操作实体类便可以达到操作数据库的目的，这就是通过&lt;span&gt;面向对象方式来操作数据库&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、hibernate环境搭建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;hibernate的环境搭建包括以下部分：1、导入运行环境需要的jar包；2、创建数据库表和对应的实体类；&lt;/span&gt;&lt;span&gt;&lt;span&gt;3、&lt;/span&gt;编写表和实体之间的映射关系（也叫orm元数据）；4、编写主配置文件hibernate.cfg.xml&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、导包&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;搜索下载压缩包：hibernate-release-5.0.7.Final.zip就可以找到相应的jar包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213212626613-2011815452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：不要忘了导入数据库驱动包（这里我使用的是mysql数据库），所以还需导入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213212922019-1697258394.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2、创建数据库表和实体类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里假设我们创建了&lt;span&gt;user表&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (
`uid` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
`uname` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;32&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`uid`)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213214111926-1204570631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体类：&lt;span&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; domain;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long uid;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String uname;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getUid() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUid(Long uid) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.uid =&lt;span&gt; uid;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUname() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; uname;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUname(String uname) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.uname =&lt;span&gt; uname;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User [uid=&quot; + uid + &quot;, uname=&quot; + uname + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3、编写表和实体之间的映射关系（orm元数据）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）导入dtd约束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hibernate框架使用的是xml文件作为配置文件，所以在编写xml文件之前需要先导入dtd约束（该约束文件也在上面使用到的压缩包里）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213214906035-1707225665.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导入方式：eclipse--&amp;gt;Preferences--&amp;gt;xml--&amp;gt;XML Catalog--&amp;gt;add&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213215217347-1079022967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213215636582-1895953954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213215754879-277452380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个文件都添加完成后你的eclipse中有了这个dtd约束了，如果你的eclipse已经有了该dtd约束上面的步骤就可以忽略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）配置映射关系:User.hbm.xml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般该文件的命名格式为（当然你可以随意命名）：类名.hbm.xml。且放在和该实体类同一个目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; xml简写版：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE hibernate-mapping PUBLIC 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hibernate-mapping &lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;=&quot;domain&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; table&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;generator &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;native&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;generator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;uname&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;uname&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;hibernate-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;xml注释版：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6909c3be-4eb1-41b7-845b-87677a6caf33&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6909c3be-4eb1-41b7-845b-87677a6caf33&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6909c3be-4eb1-41b7-845b-87677a6caf33&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 1、导入dtd约束 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE hibernate-mapping PUBLIC 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 2、ORM元数据：配置表与实体对象的关系（映射关系） &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hibernate-mapping &lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;=&quot;domain&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        2.1 class元素: 配置实体与表的对应关系的
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            name: 完整类名
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            table:数据库表名
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; table&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; id元素:配置主键映射的属性
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                name: 填写主键对应属性名
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                        每个类型有三种填法: java类型|hibernate类型|数据库类型
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                not-null(可选):配置该属性(列)是否不能为空. 默认值:false
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;          &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;uid&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; generator:主键生成策略(明天讲) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;generator &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;native&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;generator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 2.2property元素:除id之外的普通属性映射
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                name: 填写属性名
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                column(可选): 填写列名
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                        每个类型有三种填法: java类型|hibernate类型|数据库类型
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                not-null(可选):配置该属性(列)是否不能为空. 默认值:false
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;          &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;uname&quot;&lt;/span&gt;&lt;span&gt; column&lt;/span&gt;&lt;span&gt;=&quot;uname&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;hibernate-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4、编写主配置文件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;主配置文件一般是整体环境的配置一些数据库操作设置。主要分为：1、必要配置：数据库驱动等配置；2、可选配置；3、引入orm元数据：指定要操作的关系映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般主配置文件都以hibernate.xfg.xml来命名（这样我们在使用时可以直接使用无参方法调用，比较方便）。且需要将文件放到src目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hebernate.cfg.xml简写版:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE hibernate-configuration PUBLIC
    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hibernate-configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;session-factory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 
        #hibernate.dialect org.hibernate.dialect.MySQLDialect
        #hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect
        #hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect
        #hibernate.connection.driver_class com.mysql.jdbc.Driver
        #hibernate.connection.url jdbc:mysql:///test
        #hibernate.connection.username gavin
        #hibernate.connection.password
        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:mysql:///hibernate&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;root&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;password&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/property&amp;gt;
        
        &amp;lt;property name=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.format_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
        
        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/property&amp;gt;

        &amp;lt;mapping resource=&quot;domain/User.hbm.xml&quot; /&amp;gt;
        
    &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;hebernate.cfg.xml&lt;/span&gt;注释版：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c524b511-0350-4d5f-bcbf-c33875dcbd22&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c524b511-0350-4d5f-bcbf-c33875dcbd22&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c524b511-0350-4d5f-bcbf-c33875dcbd22&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE hibernate-configuration PUBLIC
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hibernate-configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;session-factory&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        #hibernate.dialect org.hibernate.dialect.MySQLDialect
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        #hibernate.dialect org.hibernate.dialect.MySQLInnoDBDialect
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        #hibernate.dialect org.hibernate.dialect.MySQLMyISAMDialect
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        #hibernate.connection.driver_class com.mysql.jdbc.Driver
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        #hibernate.connection.url jdbc:mysql:///test
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        #hibernate.connection.username gavin
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        #hibernate.connection.password
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:mysql:///hibernate&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;root&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;password&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.show_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.format_sql&quot;&amp;gt;true&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/property&amp;gt;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        &amp;lt;mapping resource=&quot;domain/User.hbm.xml&quot; /&amp;gt;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    &amp;lt;/session-factory&amp;gt;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;&amp;lt;/hibernate-configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到这里我们的hibernate环境就搭建完成了，刚开始感觉很多，用多了其实就很可以很快copy这些文件然后改改就o了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、hibernate简单测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 1)Demo测试类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.Session;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.SessionFactory;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.Transaction;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.cfg.Configuration;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; domain.User;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用hibernate框架，通过操作User对象往user表中插入一条数据。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser(){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作涉及的核心类&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         Configuration config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration().configure();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         SessionFactory factory =&lt;span&gt; config.buildSessionFactory();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Session session =&lt;span&gt; factory.openSession();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Transaction tx =&lt;span&gt; session.beginTransaction();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;操作User
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------------------&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         user.setUid(1l&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         user.setUname(&quot;张三&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         
&lt;span&gt;28&lt;/span&gt;         session.save(user);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-----------------------
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭资源&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        tx.commit();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        session.close();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        factory.close();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）执行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213230205238-1894599819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250367/201712/1250367-20171213230229691-1118392126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、测试涉及的api详解&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 创建,调用空参构造&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Configuration conf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration().configure();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 根据配置信息,创建 SessionFactory对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; SessionFactory sf =&lt;span&gt; conf.buildSessionFactory();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3 获得session&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; Session session =&lt;span&gt; sf.openSession();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4 session获得操作事务的Transaction对象
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得操作事务的tx对象&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; Transaction tx =&lt;span&gt; session.getTransaction();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;tx.begin();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启事务并获得操作事务的tx对象(建议使用)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; Transaction tx2 =&lt;span&gt; session.beginTransaction();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;----------------------------------------------
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 获得要修改的对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;User u = session.get(User.&lt;span&gt;class&lt;/span&gt;, 1l&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 调用delete删除对象&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;session.delete(u);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;----------------------------------------------&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; tx2.commit();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交事务&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; session.close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; sf.close();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除了虚线//-----------------之间的操作部分，上下两部分一般都是固定不变的。所以我们可以使用工具类进行抽取，以提高代码复用率：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HibernateUtils:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; utils;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.HibernateException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.Session;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.SessionFactory;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.cfg.Configuration;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HibernateUtils {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 会话工厂，以单例方式管理&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SessionFactory sessionFactory;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ThreadLocal存储session&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;Session&amp;gt; session = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Session&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以单例方式管理sessionFactory&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             sessionFactory = &lt;span&gt;new&lt;/span&gt; Configuration().configure(&quot;hibernate.cfg.xml&quot;&lt;span&gt;).buildSessionFactory();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (HibernateException e) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HibernateException(&quot;初始化会话工厂失败！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到一个单例的会话工厂&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SessionFactory getSessionFactory(){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sessionFactory;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取一个新session&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Session openSession(){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sessionFactory.openSession();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;  
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Session getCurrentSession() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; HibernateException {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sessionFactory.getCurrentSession(); 
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; closeSession() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; HibernateException {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        sessionFactory.getCurrentSession().close();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 13 Dec 2017 15:22:00 +0000</pubDate>
<dc:creator>风之之</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fzz9/p/8035007.html</dc:identifier>
</item>
</channel>
</rss>