<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Apollo 5 教你怎么把自己的配置放到 Spring 环境中 - 莫那-鲁道</title>
<link>http://www.cnblogs.com/stateis0/p/9286772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stateis0/p/9286772.html</guid>
<description>&lt;p&gt;目录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;处理方案&lt;/li&gt;
&lt;li&gt;简单例子&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;有的时候，你可能需要在 Spring 环境中放入一些配置，但这些配置无法写死在配置文件中，只能运行时放入。那么，这个时候该怎么办呢？&lt;/p&gt;
&lt;p&gt;Apollo 就是搞配置的，那么自然会遇到这个问题，他是如何处理的呢？&lt;/p&gt;
&lt;h2 id=&quot;处理方案&quot;&gt;处理方案&lt;/h2&gt;
&lt;p&gt;首先要知道 Spring 环境中，一个配置的数据结构是什么？&lt;/p&gt;
&lt;p&gt;是抽象类 &lt;code&gt;PropertySource&amp;lt;T&amp;gt;&lt;/code&gt;， 内部是个 key value 结构。这个 T 可以是任意类型，取决于子类的设计。&lt;/p&gt;
&lt;p&gt;子类可以通过重写 getProperty 抽象方法获取配置。&lt;/p&gt;
&lt;p&gt;Spring 自身的 org.springframework.core.env.MapPropertySource 就重写了这个方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MapPropertySource extends EnumerablePropertySource&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; {

    public MapPropertySource(String name, Map&amp;lt;String, Object&amp;gt; source) {
        super(name, source);
    }


    @Override
    public Object getProperty(String name) {
        return this.source.get(name);
    }

    @Override
    public boolean containsProperty(String name) {
        return this.source.containsKey(name);
    }

    @Override
    public String[] getPropertyNames() {
        return StringUtils.toStringArray(this.source.keySet());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，他的泛型是 Map，getProperty 方法则是从 Map 中获取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apollo 就直接利用了这个类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-e67471ed5a73e2b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个不同的子类，不同的刷新逻辑。我们暂时不关心他们的不同。&lt;/p&gt;
&lt;p&gt;这两个类都会被 RefreshableConfig 组合，添加到 Spring 的环境中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.core.env.ConfigurableEnvironment;

public abstract class RefreshableConfig {

  @Autowired
  private ConfigurableEnvironment environment; // Spring 环境

  @PostConstruct
  public void setup() {
  // 省略代码
    for (RefreshablePropertySource propertySource : propertySources) {
      propertySource.refresh();
      // 注意：成功刷新后，放到 Spring 的环境中
      environment.getPropertySources().addLast(propertySource);
    }
  // 省略代码&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当从 Spring 的环境中获取配置的时候，具体代码是下面这样的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; T getProperty(String key, Class&amp;lt;T&amp;gt; targetValueType, boolean resolveNestedPlaceholders) {
        for (PropertySource&amp;lt;?&amp;gt; propertySource : this.propertySources) {
            // 注意：这里调用的就是 propertySource.getProperty 方法，子类刚刚重写的方法
            Object value = propertySource.getProperty(key);
             // 省略无关代码........
            return convertValueIfNecessary(value, targetValueType);
        }
        return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring 维护了一个 PropertySource 的集合，这个结合是有顺序的，也就是说，排在最前面的优先级最高（遍历从下标 0 开始）。&lt;/p&gt;
&lt;p&gt;而用户可以在 PropertySource 里，维护一个配置字典（Map），这样，就类似 2 维数组的这样一个数据结构。&lt;/p&gt;
&lt;p&gt;所以，配置是可以重名的，重名时，以最前面的 PropertySource 中的配置为准。所以，Spring 留给了几个 API：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;addFirst(PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;li&gt;addLast(PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;li&gt;addBefore(String relativePropertySourceName, PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;li&gt;addAfter(String relativePropertySourceName, PropertySource&amp;lt;?&amp;gt; propertySource)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从名字可以看出，通过这些 API，我们可以将 propertySource 插入到我们指定的地方。从而可以手动控制配置的优先级。&lt;/p&gt;
&lt;p&gt;Spring 中有个现成的 CompositePropertySource 类，内部聚合了一个 PropertySource Set 集合，当 getProperty(String name) 的时候，就会遍历这个集合，然后调用这个 propertySource 的 getProperty(name) 方法。相当于 3 维数组。&lt;/p&gt;
&lt;p&gt;大概的设计是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-bf02da7a86e22149.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个环境中，有多个 PS（PropertySource 简称），每个 PS 可以直接包含配置，也可以再包装一层 PS。&lt;/p&gt;
&lt;h2 id=&quot;简单例子&quot;&gt;简单例子&lt;/h2&gt;
&lt;p&gt;我们这里有个简单的例子，需求：&lt;br/&gt;程序里有个配置，但不能写死在配置文件中，只能在程序启动过程中进行配置，然后注入到 Spring 环境中，让 Spring 在之后的 IOC 中，可以正常的使用这些配置。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class DemoApplication {

  @Value(&quot;${timeout:1}&quot;)
  String timeout;


  public static void main(String[] args) throws InterruptedException {
    ApplicationContext c = SpringApplication.run(DemoApplication.class, args);
    for (; ; ) {
      Thread.sleep(1000);
      System.out.println(c.getBean(DemoApplication.class).timeout);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;application.properties 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;timeout=100&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，我们在 bean 中定义了一个属性 timeout， 并在本地配置文件中写入了一个 100 的值，也在表达式中给了一个默认值 1。&lt;/p&gt;
&lt;p&gt;那么现在打印出来的就是配置文件中的值：100.&lt;/p&gt;
&lt;p&gt;但是，这不是我们想要的结果，所以需要修改代码。&lt;/p&gt;
&lt;p&gt;我们加入一个类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
class Test implements EnvironmentAware, BeanFactoryPostProcessor {

  @Override
  public void setEnvironment(Environment environment) {
    ((ConfigurableEnvironment) environment).getPropertySources()
        // 这里是 addFirst,优先级高于 application.properties 配置
        .addFirst(new PropertySource&amp;lt;String&amp;gt;(&quot;timeoutConfig&quot;, &quot;12345&quot;) {
          // 重点
          @Override
          public Object getProperty(String s) {
            if (s.equals(&quot;timeout&quot;)) {//
              return source;// 返回构造方法中的 source :12345
            }
            return null;
          }
        });
  }

  @Override
  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
      throws BeansException {
    // NOP
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行之后，结果：12345&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2018-07-02 15:26:54.315  INFO 43393 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2018-07-02 15:26:54.327  INFO 43393 --- [           main] com.example.demo.DemoApplication         : Started DemoApplication in 0.991 seconds (JVM running for 1.49)
12345
12345&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么加入了这个类，就能够代替配置文件中的属性呢？解释一下这个类的作用。&lt;/p&gt;
&lt;p&gt;我们要做的事情就是在 Spring 的环境中，插入自定义的 PS 对象，以便容器获取的时候，能够通过 getProperty 方法获取对应的配置。&lt;/p&gt;
&lt;p&gt;所以，我们要拿到 Spring 环境对象，还需要创建一个 PS 对象，并重写 getProperty 方法，同时，注意：自己的 PS 配置优先级需要高于容器配置文件的优先级，保险起见，放在第一位。&lt;/p&gt;
&lt;p&gt;PS 构造方法的第一个参数没什么用，就是一个标识符，第二个参数就是 source，可以定义为任何类型，String，Map，都可以，我们这里简单期间，就是一个 String，直接返回这个值，如果是 Map，就调用 Map 的 get 方法。&lt;/p&gt;
&lt;p&gt;为什么要实现 BeanFactoryPostProcessor 接口呢？ 实现 BeanFactoryPostProcessor 接口的目的是让该 Bean 的加载时机提前，高于目标 Bean 的初始化。否则，目标 Bean 中的 timeout 属性都注入结束了，后面的操作就没有意义了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;说白了，就是不想写配置文件！！！&lt;/p&gt;
&lt;p&gt;而且也不想改老项目的代码，老项目即使在删除配置文件的情况下，依然能够使用配置中心！&lt;/p&gt;
&lt;p&gt;这就需要熟悉 Spring 的配置加载逻辑和属性获取逻辑。&lt;/p&gt;
&lt;p&gt;现在，我们知道，只需要拿到 Spirng 的环境对象，并向环境中添加自定义的 PS 对象，重写 PS 的 getProperty 方法，即可获取配置（注意优先级）。&lt;/p&gt;
&lt;p&gt;还需要注意加载这个配置的 bean 的优先级也要很高，通常实现 BeanFactoryPostProcessor 接口就足够了，如果还不够，就需要做一些特殊操作。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:52:00 +0000</pubDate>
<dc:creator>莫那-鲁道</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stateis0/p/9286772.html</dc:identifier>
</item>
<item>
<title>JS ES6的变量的结构赋值 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9286745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9286745.html</guid>
<description>&lt;p&gt;变量的结构赋值用户很多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、交换变量的值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let x = 1&lt;span&gt;;
let y &lt;/span&gt;= 2&lt;span&gt;;
[x,y] &lt;/span&gt;= [y,x]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码交换变量x和变量y的值，这样的写法不仅简洁，易读，语义非常清晰&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、从函数返回多个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数只能返回一个值，如果要返回多个值，只能讲他们放在数组或者对象里返回。了解&lt;strong&gt;解构赋值&lt;/strong&gt;，取值这些值非常方便&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个数组&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [1,2,3&lt;span&gt;];
}
let [a,b,c] &lt;/span&gt;= example();&lt;br/&gt;[a,b,c];   //[1,2,3]
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回一个对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        foo:&lt;/span&gt;1&lt;span&gt;,
        bar:&lt;/span&gt;2&lt;span&gt;
    };
}
let {foo,bar} &lt;/span&gt;= example();&lt;br/&gt;foo;   //1&lt;br/&gt;bar;   //2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3、函数参数的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解构赋值可以方便的讲一组参数与变量名对应起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是一组有次序的值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f([x,y,z]){
    console.log(x,y,z);
}
f([&lt;/span&gt;1,2,3]);  //1,2,3
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数是一组无次序的值&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func({x,y,z}){
    console.log(x,y,z);
}
func({z:&lt;/span&gt;3,y:2,x:1}); //1,2,3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4、提取JSON数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解构赋值对提取JSON对象中的数据尤其有用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
let jsonData =&lt;span&gt; {
    id:&lt;/span&gt;42&lt;span&gt;,
    status:&lt;/span&gt;&quot;OK&quot;&lt;span&gt;,
    data:[&lt;/span&gt;123,456&lt;span&gt;]             
} ;
let {id,status,data:number} &lt;/span&gt;=&lt;span&gt; jsonData;
console.log(id,status,number);   //42 &quot;OK&quot; (2) [123, 456]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、函数参数的默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;、、、&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、遍历Map结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何部署了Iterator接口的对象都可以使用for... of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值获取名和键值就非常方便。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Map();
map.set(&lt;/span&gt;'first','hello'&lt;span&gt;);
map.set(&lt;/span&gt;'second','world'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key,value] of map){
    console.log(key,value);
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;//first hello&lt;br/&gt;//second world&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果只想获取键名，或者只想获取键值，可以这样写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键名&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [key] of map){
    console.log(key);
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;//first&lt;br/&gt;//second&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取键值&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let [,value] of map){
    console.log(value);
}&lt;br/&gt;//hello&lt;br/&gt;//world&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;7、输入模块的指定方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加载模块时，往往需要指定输入的方法。解构赋值使得输入语句非常清晰。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const {a,b} = require('source-map');
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 09 Jul 2018 15:41:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9286745.html</dc:identifier>
</item>
<item>
<title>Python学习：14.Python面向对象（一） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9286742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9286742.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、面向对象简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Python设计之初，就是一门面向对象的语言，在Python中一切皆对象，而且在Python中创建一个对象也很简单，今天我们就来学习一下Python的面向对象的知识。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、两种编程方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在C#、Java中，只能使用面向对象编程，在Ruby、Python中可以使用函数编程以及面向对象进行编程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch(backend):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_record(backend,record):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
fetch(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.oldboy.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
add_record(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;www.oldboy.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,xxxxx)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Oldboy:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;类，用来封装几个函数&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; fetch(self,backend):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;self是python内部传的，用户我们传值时&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;        &lt;span&gt;#传的&lt;/span&gt;&lt;span&gt;第一个参数直接给backend&lt;/span&gt;
     
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_record(self,backend,record):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Oldboy()
obj.fetch()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205099/201807/1205099-20180709200514517-283087359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　函数在类的外面就叫做函数，在类的里面就叫做方法，面向对象的情况下想要执行函数时需要根据这个类创建一个对象,通过对象访问函数。&lt;/p&gt;
&lt;p&gt;　　一般函数式编程的函数为模块的成员，而面向对象编程，类是模块的成员，函数是类的成员。&lt;/p&gt;
&lt;p&gt;　　面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。对象是特征和技能的结合，其中特征和技能分别对应对象的数据属性和方法属性。 &lt;br/&gt;优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 &lt;br/&gt;缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、面向对象深度解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.关于self的解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1205099/201807/1205099-20180709201156848-1228144941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.封装&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Oldboy:

　　&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.backend)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为参数self传的值为对象obj1，所以可以用self代替obj1&lt;/span&gt;
 
　　&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_record(self,record):
    　　&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
obj1 &lt;/span&gt;=&lt;span&gt; Oldboy()
obj1.backend &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个参数，和obj1一起被存入内存&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;封装的非主流的方式&lt;/span&gt;
obj1.fetch()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;由于backend和obj1一起存入内存，所以不用再吧backend传过去，直接&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在函数里用self.backend使用&lt;/span&gt;
&lt;span&gt;
obj2 &lt;/span&gt;=&lt;span&gt; Oldboy()
obj2.backend &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ALEXSEL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
obj2.fetch()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里也显示出了self的作用，self可以标识对象，由于给两个对象传入的参数输不同，调用类的方法的时候，输出的内容就不同，这就是self的功能。&lt;/p&gt;
&lt;p&gt;应用：&lt;br/&gt;当有几个函数要传的参数相同时，封装比较简便&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.构造方法__init__&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当使用类创建对象的时候（obj = Foo()），默认执行__init__方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, bk):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#这个self为创建的对象，创建对象时默认执行__init__&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#所以可把需要多次传的参数在这里创建，代替上面那个&lt;/span&gt;
        self.name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;#非主流的方法&lt;/span&gt;
        self.favor =&lt;span&gt; bk
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.favor)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象，实例，并将“xxx”封装到对象里&lt;/span&gt;
obj1 = Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象时，类里就会执行__init__方法（函数），这个xxx就传入到__init__的bk参数中&lt;/span&gt;
obj2 = Foo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


输出结果：
init
xxx
init
sss&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用场景：当同一类型的的方法具有相同的参数时，直接封装到对象即可。&lt;br/&gt;使用场景：把类当成模板，创建多个对象（对象内封装的数据可以不一样）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;四、上手练习&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;针对刚才了解的知识，我们进行一个简单的练习，输出同样的结果下，不同的两种写法，熟悉类中方法和属性的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写法一：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; activity:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age,gender):
        self.FlyAnAeroplane &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:s},{:s},{:s},去开飞机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name,age,gender)
        self.GoToSchool &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:s},{:s},{:s},去学校&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name,age,gender)
        self.Farm &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{:s},{:s},{:s},去种田&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(name,age,gender)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; FlyAnAeroplane_one(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.FlyAnAeroplane)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; GoToSchool_one(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.GoToSchool)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; Farm_one(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.Farm)


obj &lt;/span&gt;= activity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj.FlyAnAeroplane_one()
obj.GoToSchool_one()
obj.Farm_one()
obj2 &lt;/span&gt;= activity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
obj2.FlyAnAeroplane_one()
obj2.GoToSchool_one()
obj2.Farm_one()


输出结果：
alexsel,&lt;/span&gt;10&lt;span&gt;,男,去开飞机
alexsel,&lt;/span&gt;10&lt;span&gt;,男,去学校
alexsel,&lt;/span&gt;10&lt;span&gt;,男,去种田
eric,&lt;/span&gt;60&lt;span&gt;,男,去开飞机
eric,&lt;/span&gt;60&lt;span&gt;,男,去学校
eric,&lt;/span&gt;60,男,去种田
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;写法二：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.age &lt;/span&gt;=&lt;span&gt; age
        self.gender &lt;/span&gt;=&lt;span&gt; gender

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; kaifeiji(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s,%s岁,%s,去开飞机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age, self.gender))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; quxuexiao(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s,%s岁,%s,去学校&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age, self.gender))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; quzhongtian(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s,%s岁,%s,去种田&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (self.name, self.age, self.gender))


alexsel &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
alexsel.kaifeiji()
alexsel.quxuexiao()
alexsel.quzhongtian()

eric &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;eric&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 90, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
eric.kaifeiji()
eric.quxuexiao()
eric.quzhongtian()


输出结果：
alexsel,10岁,男,去开飞机
alexsel,10岁,男,去学校
alexsel,10岁,男,去种田
eric,90岁,男,去开飞机
eric,90岁,男,去学校
eric,90岁,男,去种田&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;五、项目练习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在写这个项目之前，我们首先学习一下pickel模块。&lt;/p&gt;
&lt;p&gt;pickle可以将任何数据类型序列化，pickle只能在python中使用，pickle模块用于将内存中的python对象序列化成字节流，并可以写入任何类似文件对象中；它也可以根据序列化的字节流进行反序列化，将字节流还原为内存中的对象。&lt;/p&gt;
&lt;p&gt;pickle使用dump方法将内存对象序列化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt; pickle

li &lt;/span&gt;= list(range(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
dbfile &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pickle_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)    #必须以2进制打开文件，否则pickle无法将对象序列化只文件
pickle.dump(li, dbfile)
dbfile.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码即将list对象li序列化至文件“pickle_list&quot;中，下次再次运行时，可以通过pickle的load方法恢复list对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle

dbfile &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pickle_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
li &lt;/span&gt;=&lt;span&gt; pickle.load(dbfile)
dbfile.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开始项目练习&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age,weight):
        self.Name &lt;/span&gt;=&lt;span&gt; name
        self.Age &lt;/span&gt;=&lt;span&gt; age
        self.Weight &lt;/span&gt;=&lt;span&gt; weight

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        self.Weight &lt;/span&gt;= self.Weight + 2   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次吃饭，体重加1&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fitness(self):
        self.Weight &lt;/span&gt;= self.Weight - 1   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次健身，体重减1&lt;/span&gt;
&lt;span&gt;


xiaoming &lt;/span&gt;= pickle.load(open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fitnessgame.obb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; xiaoming:            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断是否有小明这个对象，没有创建小明对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(xiaoming.Weight)
    xiaoming.fitness()
    xiaoming.fitness()
    xiaoming.fitness()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(xiaoming.Weight)
    pickle.dump(xiaoming,open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fitnessgame.obb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    xiaoming  &lt;/span&gt;= Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小明&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10岁&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,200&lt;span&gt;)
    xiaoming.fitness()
    xiaoming.eat()
    xiaoming.eat()
    xiaoming.eat()
    xiaoming.eat()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(xiaoming.Weight)
    pickle.dump(xiaoming,open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fitnessgame.obb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;明天我们接着讲面向对象，明天继续讲面向对象中的继承。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:39:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9286742.html</dc:identifier>
</item>
<item>
<title>干了这杯Java之HashMap - 阿克西斯教成员污米饭</title>
<link>http://www.cnblogs.com/imeng/p/9286737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imeng/p/9286737.html</guid>
<description>&lt;p&gt;类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HashMap&amp;lt;K,V&amp;gt; extends AbstractMap&amp;lt;K,V&amp;gt;
    implements Map&amp;lt;K,V&amp;gt;, Cloneable, Serializable&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;继承自AbstractMap 实现了Map,Cloneable,Serializable接口&lt;/li&gt;
&lt;li&gt;可以被序列化&lt;/li&gt;
&lt;li&gt;可以被Clone&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//默认初始容量为16
static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16
//最大容量
static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30
//默认扩容因子
static final float DEFAULT_LOAD_FACTOR = 0.75f
//红黑树转链表的阀值
static final int TREEIFY_THRESHOLD = 8;
//链表转红黑树阀值
static final int UNTREEIFY_THRESHOLD = 6;
//存储方式由链表转成红黑树的容量的最小阈值
static final int MIN_TREEIFY_CAPACITY = 64;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;new HashMap&amp;lt;&amp;gt;()的时候，会进入HashMap(int initialCapacity, float loadFactor)方法&lt;/li&gt;
&lt;li&gt;initialCapacity为0xB&lt;/li&gt;
&lt;li&gt;loadFactor默认为0.75&lt;/li&gt;
&lt;li&gt;第一步判断initialCapacity的值是不是小于0或大于1 &amp;lt;&amp;lt; 30,第二步判断loadFactor是不是大于0和是否为浮点数,第三步设置实例的loadFactor为0.75,第四步设置容量为16&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tableSizeFor&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//返回大于或等于cap且为2的幂的数值
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 1;
    n |= n &amp;gt;&amp;gt;&amp;gt; 2;
    n |= n &amp;gt;&amp;gt;&amp;gt; 4;
    n |= n &amp;gt;&amp;gt;&amp;gt; 8;
    n |= n &amp;gt;&amp;gt;&amp;gt; 16;
    return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;cap-1:如果cap不减去1,cap=2的幂时,结果为cap的2倍,不符合预期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;hash方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;hashCode的高位16bit与低16bit参与异或运算&lt;/li&gt;
&lt;li&gt;null放在第0位&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Node对象&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;/pre&gt;
&lt;p&gt;put方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        //扩容,第一次扩容长度16
        n = (tab = resize()).length;
    //(n - 1) &amp;amp; hash的长度必定在0-n之间 
    //(n - 1) &amp;amp; hash等于hash % n,与运算比取模快
    //n - 1的2进制为01111...,N为2的次方
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        //hash和equals或=相同时,替换
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)//节点为树节点的时候,在红黑树上添加
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            //链表
            for (int binCount = 0; ; ++binCount) {
                //添加在链表末尾
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    //当binCount&amp;gt;=7的时候转换为红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //已经存在
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                //下一个对象
                p = e;
            }
        }
        //已经存在key
        if (e != null) {
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    //扩容
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;取模 x % 2^n == x &amp;amp; (2^n - 1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扩容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final Node&amp;lt;K,V&amp;gt;[] resize() {
    Node&amp;lt;K,V&amp;gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &amp;gt; 0) {
        if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                 oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
    }
    else if (oldThr &amp;gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        for (int j = 0; j &amp;lt; oldCap; ++j) {
            Node&amp;lt;K,V&amp;gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp;amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                    Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                    Node&amp;lt;K,V&amp;gt; next;
                    do {
                        next = e.next;
                        if ((e.hash &amp;amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 09 Jul 2018 15:37:00 +0000</pubDate>
<dc:creator>阿克西斯教成员污米饭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imeng/p/9286737.html</dc:identifier>
</item>
<item>
<title>idea中新增package总是嵌套的解决方法 - 求知若渴&amp;虚怀若愚</title>
<link>http://www.cnblogs.com/codething/p/9286734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codething/p/9286734.html</guid>
<description>&lt;p&gt;在idea中创建package,为了方便会将com.xx.xx作为一个package,下面添加对应的子package。比如service，config等。但是当我创建是总是会嵌套在下面变成了com.xx.xx.config。解决的办法就是创建好com.xx.xx向这个新建好的空的package中添加一个文件。然后再创建子package时就不会出现上面的情况了。原因对对于空的package下面新建新的package时idea会默认折叠起来，导致会显示为嵌套的格式。起始idea中也提供了一个默认的packageinfo.java对象,可以在创建好package后放在里面占个位置.&lt;img src=&quot;https://images2018.cnblogs.com/blog/820933/201807/820933-20180709233540177-1576615463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:36:00 +0000</pubDate>
<dc:creator>求知若渴&amp;amp;虚怀若愚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codething/p/9286734.html</dc:identifier>
</item>
<item>
<title>吴恩达《深度学习》第一门课（4）深层神经网络 - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9286683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9286683.html</guid>
<description>&lt;h2&gt;4.1深层神经网络&lt;/h2&gt;
&lt;p&gt;（1）到底是深层还是浅层是一个相对的概念，不必太纠结，以下是一个四层的深度神经网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709220041863-1779583270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）一些符号定义：&lt;/p&gt;
&lt;p&gt;a&lt;sup&gt;[0]&lt;/sup&gt;=x（输入层也叫做第0层）&lt;/p&gt;
&lt;p&gt;L=4：表示网络的层数&lt;/p&gt;
&lt;p&gt;g:表示激活函数&lt;/p&gt;
&lt;p&gt;第l层输出用a&lt;sup&gt;[l]&lt;/sup&gt;，最终的输出用a&lt;sup&gt;[L]&lt;/sup&gt;表示&lt;/p&gt;
&lt;p&gt;n&lt;sup&gt;[1]&lt;/sup&gt;=5:表示第一层有五个神经元，第l层神经元个数用n&lt;sup&gt;[l]&lt;/sup&gt;表示&lt;/p&gt;
&lt;h2&gt;4.2前向传播和反向传播&lt;/h2&gt;
&lt;p&gt;（1）前向传播：输入a&lt;sup&gt;[l-1]&lt;/sup&gt;,输出是a&lt;sup&gt;[l]&lt;/sup&gt;,缓存为z&lt;sup&gt;[l]&lt;/sup&gt;，步骤如下：（&lt;em&gt;&lt;strong&gt;下面第一个式子应该是a&lt;sup&gt;[l-1]&lt;/sup&gt;&lt;/strong&gt;&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709221723941-1360753037.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709221742075-1016722684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;向量化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709221801895-988702678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709221813683-1148104221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）反向传播:输入da&lt;sup&gt;[l]&lt;/sup&gt;,输出da&lt;sup&gt;[l-1]&lt;/sup&gt;,dw&lt;sup&gt;[l]&lt;/sup&gt;,db&lt;sup&gt;[l]&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709223234350-197089327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）&lt;span&gt;da&lt;sup&gt;[l-1]&lt;/sup&gt;=w&lt;sup&gt;[l]T&lt;/sup&gt;·dz&lt;sup&gt;[l]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由第四个式子带入到第一各式子中得&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709223552155-1374791395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;向量化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709223624768-68693909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （3）总结：第一层可能是Relu激活函数，第二层为另一个Relu函数，第三层可能是sigmoid函数（如果做二分类的话），输出值为a[L],用来计算损失，这样就可以以向后迭代进行反向传播就到来求dw[3],db[3],dw[2],db[2],dw[1],db[1].在计算的时候，缓存会把z[1]z[2]z[3]传递过来，然后回传da[2],da[1],可以用来计算da[0],但是不会使用它。整个过程如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709223757025-590583269.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.3深层网络的前向传播&lt;/h2&gt;
&lt;p&gt;（1）前向传播归纳为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709224638991-1251696106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;向量化实现过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709224706646-464123654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.4核对矩阵的维数&lt;/h2&gt;
&lt;p&gt;（1）w的维度是（下一层的维数，上一层的维数），即w&lt;sup&gt;[l]&lt;/sup&gt;:(n&lt;sup&gt;[l]&lt;/sup&gt;,n&lt;sup&gt;[l-1]&lt;/sup&gt;)&lt;/p&gt;
&lt;p&gt;（2）b的维度时（下一层的维数，1）&lt;/p&gt;
&lt;p&gt;（3）z&lt;sup&gt;[l]&lt;/sup&gt;,a&lt;sup&gt;[l]&lt;/sup&gt;:(n&lt;sup&gt;[l]&lt;/sup&gt;,1)&lt;/p&gt;
&lt;p&gt;（4）dw&lt;sup&gt;[l]&lt;/sup&gt;和w&lt;sup&gt;[l]&lt;/sup&gt;维度相同，db&lt;sup&gt;[l]&lt;/sup&gt;和b&lt;sup&gt;[l]&lt;/sup&gt;维度相同，且w,b向量化维度不变，但z,a以及x的维度会向量化后发生改变。&lt;/p&gt;
&lt;p&gt;向量化后：&lt;/p&gt;
&lt;p&gt;Z&lt;sup&gt;[l]&lt;/sup&gt;:(n&lt;sup&gt;[l]&lt;/sup&gt;,m)，A&lt;sup&gt;[l]&lt;/sup&gt;同Z&lt;sup&gt;[l]&lt;/sup&gt;&lt;/p&gt;
&lt;h2&gt;4.5为什么使用深层表示&lt;/h2&gt;
&lt;p&gt;增加网络的深度比广度更有效。&lt;/p&gt;
&lt;h2&gt;4.6搭建神经网络块&lt;/h2&gt;
&lt;p&gt;（1）针对一层的正向和反向传播：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709231012942-159215239.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）整个过程示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709231050941-1573375448.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.7参数VS超参数&lt;/h2&gt;
&lt;p&gt;（1）W，b是参数&lt;/p&gt;
&lt;p&gt;（2）学习率、迭代次数、层数、每层的单元数、momentum、mini batch size、regularization perameters等能影响W、b的都称为超参数，超参数的选择需要不断尝试和靠经验，以及一些策略。&lt;/p&gt;
&lt;h2&gt;4.8深度学习和大脑的关联性&lt;/h2&gt;
&lt;p&gt;深度学习和大脑其实没什么直接关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180709224629885-1061785492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:19:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9286683.html</dc:identifier>
</item>
<item>
<title>基于 websocket 实现的 im 实时通讯案例 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/9286645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/9286645.html</guid>
<description>&lt;p&gt;分享利用 redis 订阅与发布特性，巧妙的现实高性能im系统。为表诚意，先贴源码地址：https://github.com/2881099/im&lt;/p&gt;
&lt;p&gt;下载源码后的运行方法：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;运行环境：.NETCore 2.1 + redis-server 2.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.887417218543&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/kellynic/Redis-x64-2.8.2402.zip&quot; rel=&quot;nofollow&quot;&gt;下载Redis-x64-2.8.2402.zip&lt;/a&gt;，点击 start.bat 运行；或者修改 imServer、web 下面 appsettings.json redis 配置，指向可用的redis-server&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3.2407407407407&quot;&gt;
&lt;p&gt;cd imServer &amp;amp;&amp;amp; dotnet run --urls=&quot;&lt;a href=&quot;http://0.0.0.0:6001/&quot; rel=&quot;nofollow&quot;&gt;http://0.0.0.0:6001&lt;/a&gt;&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3.0612244897959&quot;&gt;
&lt;p&gt;cd web &amp;amp;&amp;amp; dotnet run --urls=&quot;&lt;a href=&quot;http://0.0.0.0:5555/&quot; rel=&quot;nofollow&quot;&gt;http://0.0.0.0:5555&lt;/a&gt;&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3.5&quot;&gt;
&lt;p&gt;打开多个浏览器，访问 &lt;a href=&quot;http://127.0.0.1:5555/&quot; rel=&quot;nofollow&quot;&gt;http://127.0.0.1:5555&lt;/a&gt; 发送群消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/31407/201807/31407-20180709230911687-816083149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;socket选型&lt;/h3&gt;
&lt;p&gt;最二的办法是浏览器端使用websocket，其他端socket，这么混乱的设计最终将非常难维护。&lt;/p&gt;
&lt;p&gt;所以强烈建议所有端都使用websocket协议，adorid/ios/h5/小程序全部支持websocket客户端。&lt;/p&gt;
&lt;h3&gt;业务与通讯协议&lt;/h3&gt;
&lt;p&gt;im系统一般涉及【我的好友】、【我的群】、【历史消息】等等。。&lt;/p&gt;
&lt;p&gt;那么，imServer与业务方(web)该保持何种关系呢？&lt;/p&gt;
&lt;p&gt;用户A向好友B发送消息，分析一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要判断B是否为A好友；&lt;/li&gt;
&lt;li&gt;需要判断A是否有权限；&lt;/li&gt;
&lt;li&gt;等等。。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;诸如此类业务判断会很复杂，我们试想一下，如果使用imServer做业务协议，它是不是会变成巨无霸难以维护。&lt;/p&gt;
&lt;p&gt;又假如获取历史记录，难道客户端要先websocket.send('gethistory')，再在onmessage里定位回调处理？&lt;/p&gt;
&lt;p&gt;这样做十分之二。。。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;咱这样设计，所有用户的主动行为走业务方(web)，imServer只负责即时消息推送。什么意思？&lt;/p&gt;
&lt;p&gt;用户A向好友B发送消息：客户端请求业务方(web)接口，由业务方(web)后端向imServer发起推送请求，imServer收到指令后，向前端用户B的websocket发送数据，用户B收到了消息。&lt;/p&gt;
&lt;p&gt;获取历史消息：客户端请求业务方(web)接口，返回json(历史消息)&lt;/p&gt;
&lt;p&gt;回执：用户A如何知道消息发送状态（成功或失败或不在线）？imServer端向用户B发送消息时，把状态以消息的方式推给用户A即可（按上面的逻辑），具体请看源码吧。。。&lt;/p&gt;
&lt;h3&gt;web通知imServer性能优化&lt;/h3&gt;
&lt;p&gt;采用消息队列，redis的发布订阅最为轻量。&lt;/p&gt;
&lt;h3&gt;实现多节点部署&lt;/h3&gt;
&lt;p&gt;单个imServer实例支持多少websocket连接，几百个没问题吧，好。。。&lt;/p&gt;
&lt;p&gt;如果系统在线用户有1万人，怎么办？？？&lt;/p&gt;
&lt;p&gt;可以根据id的hash分区，比如部署4个imServer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;imServer1 订阅 redisChanne1&lt;/li&gt;
&lt;li&gt;imServer2 订阅 redisChanne2&lt;/li&gt;
&lt;li&gt;imServer3 订阅 redisChanne3&lt;/li&gt;
&lt;li&gt;imServer4 订阅 redisChanne4&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;业务方(web)端根据接收方的id的hash分区算法，定位到对应的redisChannel，这样publish就可以将消息定位到相应的imServer了&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 15:11:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/9286645.html</dc:identifier>
</item>
<item>
<title>聊聊Java 8 Lambda 表达式 - 浮云骑士LIN</title>
<link>http://www.cnblogs.com/linlinismine/p/9283532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linlinismine/p/9283532.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    早在2014年oracle发布了jdk 8,在里面增加了lambda模块。于是java程序员们又多了一种新的编程方式：函数式编程，也就是lambda表达式。我自己用lambda表达式也差不多快4年了，但在工作中却鲜有看到同事使用这种编程方式，即使有些使用了，但感觉好像对其特性也不是很了解。我看了一上网上的资料也不少，自己整理了一下顺便写下一些自己的看法，希望我的分享能带给别人一些帮助。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    &lt;span&gt;函数式编程基本概念入门&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;   什么是函数式编程 &lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;   函数式编程（&lt;span class=&quot;LangWithName&quot;&gt;英语：&lt;span lang=&quot;en&quot;&gt;functional programming）或称函数程序设计，又称泛函编程，是一种&lt;a class=&quot;mw-redirect&quot; title=&quot;编程典范&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%B7%A8%E7%A8%8B%E5%85%B8%E7%AF%84&quot;&gt;编程典范&lt;/a&gt;，它将电脑运算视为&lt;a class=&quot;mw-redirect&quot; title=&quot;数学&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8&quot;&gt;数学&lt;/a&gt;上的&lt;a class=&quot;mw-redirect&quot; title=&quot;函数 (数学)&quot; href=&quot;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E6%95%B0%E5%AD%A6)&quot;&gt;函数&lt;/a&gt;计算，并且避免使用&lt;a class=&quot;new&quot; title=&quot;程序状态（页面不存在）&quot; href=&quot;https://zh.wikipedia.org/w/index.php?title=%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;程序状态&lt;/a&gt;以及&lt;a title=&quot;不可变对象&quot; href=&quot;https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6&quot;&gt;易变对象&lt;/a&gt;。函数编程语言最重要的基础是&lt;a title=&quot;Λ演算&quot; href=&quot;https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97&quot;&gt;λ演算&lt;/a&gt;（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起&lt;a title=&quot;指令式编程&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B&quot;&gt;指令式编程&lt;/a&gt;，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;这是维基百科给出的定义。从这个我们知道函数式编程是相对于&lt;a title=&quot;指令式编程&quot; href=&quot;https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B&quot;&gt;指令式编程&lt;/a&gt;的一种&lt;a class=&quot;mw-redirect&quot; title=&quot;编程典范&quot; href=&quot;https://zh.wikipedia.org/wiki/%E7%B7%A8%E7%A8%8B%E5%85%B8%E7%AF%84&quot;&gt;编程典范&lt;/a&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;，并且对而言具有一些优点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;  函数式编程的特性与优缺点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;      &lt;strong&gt;特性&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;LangWithName&quot;&gt;&lt;span lang=&quot;en&quot;&gt;      1、函数是&quot;第一等公民&quot;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;         什么是&quot;第一等公民&quot;？所谓&quot;第一等公民&quot;（first class），指的是函数与其他数据类型一样，处于平等地位，它不仅拥有一切传统函数的使用方式（声明和调用），可以赋值给其他变量（赋值），也可以作为参数，传入另一个函数（传参），或者作为别的函数的返回值（返回）。函数可以作为参数进行传递，意味我们可以把行为&quot;参数化&quot;，处理逻辑可以从外部传入，这样程序就可以设计得更灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     2、没有&quot;副作用&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     所谓&quot;副作用&quot;（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    3、引用透明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或&quot;状态&quot;，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。这里强调了一点&quot;输入&quot;不变则&quot;输出&quot;也不变，就像数学函数里面的f(x),只要输入的x一样那得到的结果也肯定定是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      优点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1、代码简洁，开发快速。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。Paul Graham在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。如果程序员每天所写的代码行数基本相同，这就意味着，&quot;C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。&quot;当然，这样的对比故意夸大了差异，但是&quot;在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。&quot; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2. 接近自然语言，易于理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       函数式编程的自由度很高，可以写出很接近自然语言的代码。以java为例把学生以性别分组：&lt;/p&gt;
&lt;p&gt;       没用labmda表达式：       &lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Map&amp;lt;String,List&amp;lt;Student&amp;gt;&amp;gt; studentsMap = new HashMap&amp;lt;&amp;gt;();
        for(Student student : students){
            List&amp;lt;Student&amp;gt; studentList = studentsMap.getOrDefault(student.getSex(), new ArrayList&amp;lt;&amp;gt;());
            studentList.add(student);
            studentsMap.put(student.getSex(),studentList);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用了lambda表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        Map&amp;lt;String,List&amp;lt;Student&amp;gt;&amp;gt; studentsMap = students.stream().collect(Collectors.groupingBy(Student::getSex));
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;       这基本就是自然语言的表达了，大家应该一眼就能明白它的意思吧。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      3. 更方便的代码管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      4. 易于&quot;并发编程&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      函数式编程不需要考虑&quot;死锁&quot;（deadlock），因为它不修改变量，所以根本不存在&quot;锁&quot;线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署&quot;并发编程&quot;（concurrency）。&lt;/p&gt;
&lt;p&gt;     请看下面的代码：&lt;/p&gt;
&lt;p&gt;     var s1 = Op1();&lt;/p&gt;
&lt;p&gt;     var s2 = Op2();&lt;/p&gt;
&lt;p&gt;     var s3 = concat(s1, s2);&lt;/p&gt;
&lt;p&gt;     由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      5. 代码的热升级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;   &lt;/strong&gt;  函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。&lt;a href=&quot;https://baike.baidu.com/item/Erlang&quot; target=&quot;_blank&quot;&gt;Erlang&lt;/a&gt;语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     1、函数式编程常被认为严重耗费在CPU和存储器资源。主因有二：&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;11.854166666667&quot;&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.1369863013699&quot;&gt;    惰性求值亦为语言如&lt;a href=&quot;https://baike.baidu.com/item/Haskell&quot; target=&quot;_blank&quot;&gt;Haskell&lt;/a&gt;增加了额外的管理工作。&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2、语言学习曲线陡峭，难度高&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;    函数式语言对开发者的要求比较高，学习曲线比较陡，而且很容易因为其灵活的语法控制不好程序的结构。&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;para&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     介绍完函数式编程的概念和优缺点之后，下面让我们来进入java8 lambda的编程世界~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      Lambda表达式的组成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;span&gt; java 8 中Lambda 表达式由三个部分组成：第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&amp;gt;；第三部分为方法体，可以是表达式和代码块。语法如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       1、方法体为表达式，该表达式的值作为返回值返回。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
(parameters) -&amp;gt; expression
(int a,int b) -&amp;gt; return a + b; //求和
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;       2、方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
(parameters) -&amp;gt; { statements; }
(int a) -&amp;gt; {System.out.println(&quot;a = &quot; + a);} //打印，无返回值
(int a) -&amp;gt; {return a * a;} //求平方
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      Lambda表达式的底层实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;   &lt;span&gt;  java 8 内部Lambda 表达式的实现方式在本质是以匿名内部类的形式的实现的，看下面代码。代码中我们定义了一个叫binaryOperator的Lambda表达式，看返回值它是一个IntBinaryOperator实例。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
IntBinaryOperator binaryOperator = (int a, int b) -&amp;gt; {
    return a + b;
};
int result = binaryOperator.applyAsInt(1, 2);
System.out.println(&quot;result = &quot; + result); //3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　   &lt;span&gt;我们再看一下IntBinaryOperator的定义 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
@FunctionalInterface
public interface IntBinaryOperator {
    /**
     * Applies this operator to the given operands.
     * @param left the first operand
     * @param right the second operand
     * @return the operator result
     */
    int applyAsInt(int left, int right);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;     &lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;   &lt;/span&gt;  &lt;span&gt;我们得知IntBinaryOperator是一个接口并且上面有一个@FunctionalInterface的注解，@FunctionalInterface标注了这是一个函数式接口，所以我们知道了(int &lt;span&gt;a, int b) -&amp;gt; {return a + b;}返回的一个IntBinaryOperator的匿名实现类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;&lt;strong&gt;   Lambda表达式的函数式接口 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;   上面提到了函数式接口，那这是一个什么样的概念呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      函数式接口(Functional Interface)是Java 8对一类特殊类型的接口的称呼。这类接口只定义了唯一的抽象方法的接口（除了隐含的Object对象的公共方法，因此最开始也就做SAM类型的接口（Single Abstract Method）。定义函数式接口的原因是在Java Lambda的实现中,开发组不想再为Lambda表达式单独定义一种特殊的Structural函数类型,称之为箭头类型（arrow type,依然想采用Java既有的类型(class, interface, method等).原因是增加一个结构化的函数类型会增加函数类型的复杂性，破坏既有的Java类型，并对成千上万的Java类库造成严重的影响。权衡利弊,因此最终还是利用SAM 接口作为 Lambda表达式的目标类型.另外对于函数式接口来说@FunctionalInterface并不是必须的,只要接口中只定义了唯一的抽象方法的接口那它就是一个实质上的函数式接口,就可以用来实现Lambda表达式。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;       在java 8中已经为我们定义了很多常用的函数式接口它们都放在java.util.function包下面,一般有以下常用的四大核心接口：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;       &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数式接口&lt;/th&gt;
&lt;th&gt;参数类型&lt;/th&gt;
&lt;th&gt;返回类型&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;Consumer&amp;lt;T&amp;gt;(消费型接口)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;void&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;对类型为T的对象应用操作。void accept(T t)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;Supplier&amp;lt;T&amp;gt;(供给型接口)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;无&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;返回类型为T的对象。 T get();&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;Function&amp;lt;T, R&amp;gt;(函数型接口)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;R&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;对类型为T的对象应用操作并返回R类型的对象。R apply(T t);&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;Predicate&amp;lt;T&amp;gt;(断言型接口)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;确定类型为T的对象是否满足约束。boolean test(T t);&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    Lambda表达式的应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;     1、&lt;/span&gt;使用() -&amp;gt; {} 替代匿名类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 Thread t1 = new Thread(new Runnable() {
              @Override
              public void run() {
                  System.out.println(&quot;no use lambda&quot;);
              }
          });
         
Thread t2 = new Thread(() -&amp;gt; System.out.println(&quot;use lambda&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们看到相对而言Lambda表达式要比匿名类要优雅简洁很多~。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     2、以流水线的方式处理数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        List&amp;lt;Integer&amp;gt; integers = Arrays.asList(4, 5, 6,1, 2, 3,7, 8,8,9,10);

        List&amp;lt;Integer&amp;gt; evens = integers.stream().filter(i -&amp;gt; i % 2 == 0)
                .collect(Collectors.toList()); //过滤出偶数列表 [4,6,8,8,10]&lt;br/&gt;List&amp;lt;Integer&amp;gt; sortIntegers = integers.stream().sorted()
                .limit(5).collect(Collectors.toList());//排序并且提取出前5个元素 [1,2,3,4,5]

        List&amp;lt;Integer&amp;gt; squareList = integers.stream().map(i -&amp;gt; i * i).collect(Collectors.toList());//转成平方列表
        
        int sum = integers.stream().mapToInt(Integer::intValue).sum();//求和

        Set&amp;lt;Integer&amp;gt; integersSet = integers.stream().collect(Collectors.toSet());//转成其它数据结构比如set

        Map&amp;lt;Boolean, List&amp;lt;Integer&amp;gt;&amp;gt; listMap = integers.stream().collect(Collectors.groupingBy(i -&amp;gt; i % 2 == 0)); //根据奇偶性分组

        List&amp;lt;Integer&amp;gt; list = integers.stream().filter(i -&amp;gt; i % 2 == 0).map(i -&amp;gt; i * i).distinct().collect(Collectors.toList());//复合操作
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　借助stream api和Lambda表达式，以住需要定义多个变量，编写数十行甚至数百行的代码的集合操作，现在都基本简化成了可以在一行之内完成~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      3、更简单的数据并行处理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
        List&amp;lt;Integer&amp;gt; squareList = integers.stream().parallel().map(i -&amp;gt; i * i).collect(Collectors.toList());//转成平方列表
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　   数据并行处理，只需要在原来的基础上加一个parallel()就可以开启~。顺便提一下这里parallel()开启的底层并行框架是fork/join,默认的并行数是Ncpu个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      4、用内部迭代取代外部迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       外部迭代：描述怎么干，代码里嵌套2个以上的for循环的都比较难读懂；只能顺序处理List中的元素；&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
List features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;, &quot;Date and Time API&quot;);
for (String feature : features) {
    System.out.println(feature); //外部迭代
}

List features = Arrays.asList(&quot;Lambdas&quot;, &quot;Default Method&quot;, &quot;Stream API&quot;,
 &quot;Date and Time API&quot;);
features.stream.forEach(n -&amp;gt; System.out.println(n)); //内部迭代
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;       5、重构现有臃肿代码，更高的开发效率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt; 在Lambda表达式出现之前，我们的处理逻辑只能是以命令式编程的方式来实现，需要大量的代码去编写程序的每一步操作，定义非常多的变量，代码量和工作量都相对的巨大。如果用Lambda表达式我们看到以往数十行甚至上百行的代码都可以浓缩成几行甚至一行代码。这样处理逻辑就会相对简单，开发效率可以得到明显提高，维护工作也相对容易。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;       Lambda表达式中的Stream&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        在java 8 中 Stream 不是集合元素，它不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。&lt;/p&gt;
&lt;p&gt;        Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。&lt;/p&gt;
&lt;p&gt;        Stream可以有限的也可以是无限的，流的构造方式有很多可以从常用的Collection(List,Array,Set and so on...),文件，甚至函数....&lt;/p&gt;
&lt;p&gt;      由值创建流：&lt;/p&gt;
&lt;p&gt;               Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;Java 8 &quot;, &quot;Lambdas &quot;, &quot;In &quot;, &quot;Action&quot;);&lt;/p&gt;
&lt;p&gt;       由数组创建流： &lt;/p&gt;
&lt;p&gt;               int[] numbers = {2, 3, 5, 7, 11, 13}; int sum = Arrays.stream(numbers).sum();&lt;span class=&quot;s1&quot;&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 127&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;36.734131736527&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;76.943113772455&quot;&gt;
&lt;p&gt;       由文件创建流&lt;/p&gt;
&lt;p&gt;               Stream&amp;lt;String&amp;gt; lines =Files.lines(Paths.get(&quot;data.txt&quot;), Charset.defaultCharset())&lt;/p&gt;
&lt;p&gt;       上面的这些Stream都是有限的，我们可以用函数来创建一个无限Stream&lt;/p&gt;
&lt;p&gt;               Stream.iterate(0, n -&amp;gt; n + 2).forEach(System.out::println);&lt;/p&gt;
&lt;p&gt;        Stream也很懒惰，它只会在你真正需要数据的时候才会把数据给传给你，在你不需要时它一个数据都不会产生。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;       Lambda表达式的Best Practice&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        1、保持Lambda表达式简短和一目了然&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
values.stream()
  .mapToInt(e -&amp;gt; {     
    int sum = 0;
    for(int i = 1; i &amp;lt;= e; i++) {
      if(e % i == 0) {
        sum += i;
      }
    }   
    return sum;
  })
  .sum());  //代码复杂难懂　
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
values.stream()
  .mapToInt(e -&amp;gt; sumOfFactors(e))
  .sum() //代码简洁一目了然
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　长长的Lambda表达式通常是危险的，因为代码越长越难以读懂，意图看起来也不明，并且代码也难以复用，测试难度也大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      2、使用&lt;em&gt;@FunctionalInterface&lt;/em&gt; 注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         如果你确定了某个interface是用于Lambda表达式，请一定要加上&lt;em&gt;@FunctionalInterface，&lt;/em&gt;表明你的意图&lt;em&gt;。&lt;/em&gt;不然将来说不定某个不知情的家伙比如你旁边的好基友，在这个interface上面加了另外一个抽像方法时，你的代码就悲剧了。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;  3、优先使用&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html&quot;&gt;java.util.function&lt;/a&gt;包下面的函数式接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;    &lt;strong&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html&quot;&gt;java.util.function&lt;/a&gt; &lt;/strong&gt;这个包下面提供了大量的功能性接口，可以满足大多数开发人员为lambda表达式和方法引用提供目标类型的需求。每个接口都是通用的和抽象的，使它们易于适应几乎任何lambda表达式。开发人员应该在创建新的功能接口之前研究这个包，避免重复定义接口。另外一点就是，里面的接口不会被别人修改~。&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;4、不要在Lambda表达中执行有&quot;副作用&quot;的操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &quot;&lt;/strong&gt;副作用&quot;是严重违背函数式编程的设计原则，在工作中我经常看到有人在forEach操作里面操作外面的某个List或者设置某个Map这其实是不对的。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;  5、不要把Lambda表达式和匿名内部类同等对待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;         &lt;/strong&gt;虽然我们可以用匿名内部类来实现Lambda表达式，也可以用Lambda表达式来替换内部类，但并不代表这两者是等价的。这两者在某一个重要概念是不同的：this指代的上下文是不一样的。当您使用内部类时，它将创建一个新的范围。通过实例化具有相同名称的新局部变量，可以从封闭范围覆盖局部变量。您还可以在内部类中使用这个关键字作为它实例的引用。但是，lambda表达式可以使用封闭范围。您不能在lambda的主体内覆盖范围内的变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private String value = &quot;Enclosing scope value&quot;;

public String scopeExperiment() {
    Foo fooIC = new Foo() {
        String value = &quot;Inner class value&quot;;
 
        @Override
        public String method(String string) {
            return this.value;
        }
    };
    String resultIC = fooIC.method(&quot;&quot;);
 
    Foo fooLambda = parameter -&amp;gt; {
        String value = &quot;Lambda value&quot;;
        return this.value;
    };
    String resultLambda = fooLambda.method(&quot;&quot;);
 
    return &quot;Results: resultIC = &quot; + resultIC + 
      &quot;, resultLambda = &quot; + resultLambda;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 运行上面这段代码我们将到 resultIC = &quot;Inner class value&quot;，resultLambda = &quot;Enclosing scope value&quot;。也就是说在匿名内部类中this指的是自身的引用，在Lambda表达式中this指的是外部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       6、多使用方法引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在Lambda表达式中 a -&amp;gt; a.toLowerCase()和String::toLowerCase都能起到相同的作用，但两者相比，后者通常可读性更高并且代码会简短。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       7、尽量避免在Lambda的方法体中使用{}代码块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;优先使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Foo foo = parameter -&amp;gt; buildString(parameter);
private String buildString(String parameter) {
    String result = &quot;Something &quot; + parameter;
    //many lines of code
    return result;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　    而不是&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Foo foo = parameter -&amp;gt; { String result = &quot;Something &quot; + parameter; 
    //many lines of code 
    return result; 
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　8、不要盲目的开启并行流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       Lambda的并行流虽好，但也要注意使用场景。如果平常的业务处理比如过滤，提取数据，没有涉及特别大的数据和耗时操作，则真的不需要开启并行流。我在工作中看到有些人一个只有几十个元素的列表的过滤操作也开启了并行流，其实这样做会更慢。因为多行线程的开启和同步这些花费的时间往往比你真实的处理时间要多很多。但一些耗时的操作比如I/O访问，DB查询，远程调用，这些如果可以并行的话，则开启并行流是可提升很大性能的。因为并行流的底层原理是fork/join，如果你的数据分块不是很好切分，也不建议开启并行流。举个例子ArrayList的Stream可以开启并行流，而LinkedList则不建议，因为LinkedList每次做数据切分要遍历整个链表，这本身就已经很浪费性能，而ArrayList则不会。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 09 Jul 2018 14:21:00 +0000</pubDate>
<dc:creator>浮云骑士LIN</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linlinismine/p/9283532.html</dc:identifier>
</item>
<item>
<title>SpirngBoot之整合Swagger2 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/9286391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/9286391.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;swagger,中文“拽”的意思。它是一个功能强大的api框架，它的集成非常简单，不仅提供了在线文档的查阅，&lt;br/&gt;而且还提供了在线文档的测试。另外swagger很容易构建restful风格的api。&lt;/p&gt;
&lt;h2 id=&quot;一swagger概述&quot;&gt;一、Swagger概述&lt;/h2&gt;
&lt;p&gt;Swagger是一组围绕OpenAPI规范构建的开源工具，可帮助设计、构建、记录和使用REST API。&lt;br/&gt;简单说下，它的出现就是为了方便进行测试后台的restful形式的接口，实现动态的更新，当我们在后台的接口&lt;br/&gt;修改了后，swagger可以实现自动的更新，而不需要认为的维护这个接口进行测试。&lt;/p&gt;
&lt;h2 id=&quot;二swagger常用注解&quot;&gt;二、Swagger常用注解&lt;/h2&gt;
&lt;p&gt;swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Api：修饰整个类，描述Controller的作用&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;@ApiOperation：描述一个类的一个方法，或者说一个接口&lt;/li&gt;
&lt;li&gt;@ApiParam：单个参数描述&lt;/li&gt;
&lt;li&gt;@ApiModel：用对象来接收参数&lt;/li&gt;
&lt;li&gt;@ApiProperty：用对象接收参数时，描述对象的一个字段&lt;/li&gt;
&lt;li&gt;@ApiResponse：HTTP响应其中1个描述&lt;/li&gt;
&lt;li&gt;@ApiResponses：HTTP响应整体描述&lt;/li&gt;
&lt;li&gt;@ApiIgnore：使用该注解忽略这个API&lt;/li&gt;
&lt;li&gt;@ApiError ：发生错误返回的信息&lt;/li&gt;
&lt;li&gt;@ApiParamImplicitL：一个请求参数&lt;/li&gt;
&lt;li&gt;@ApiParamsImplicit 多个请求参数&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三springboot整合swagger&quot;&gt;三、SpringBoot整合Swagger&lt;/h2&gt;
&lt;h3 id=&quot;添加依赖&quot;&gt;3.1 添加依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;添加swaggerconfiguration&quot;&gt;3.2 添加SwaggerConfiguration&lt;/h3&gt;
&lt;p&gt;通过@Configuration注解，表明它是一个配置类，@EnableSwagger2开启swagger2。&lt;br/&gt;apiINfo()配置一些基本的信息。apis()指定扫描的包会生成文档。&lt;br/&gt;再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会&lt;br/&gt;展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来&lt;br/&gt;展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容&lt;br/&gt;（除了被@ApiIgnore指定的请求）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.lance.learn.springbootswagger.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * @author lance(ZYH)
 * @function Swagger启动配置类
 * @date 2018-07-09 21:24
 */
@Configuration
@EnableSwagger2
public class SwaggerConfiguration {

    /**
     * swagger2的配置文件，这里可以配置swagger2的一些基本的内容，比如扫描的包等等
     * @return
     */
    @Bean
    public Docket createRestfulApi(){
        return new Docket(DocumentationType.SWAGGER_2)
                .pathMapping(&quot;/&quot;)
                .select()
                .apis(RequestHandlerSelectors.basePackage(&quot;com.lance.learn.springbootswagger.controller&quot;))  //暴露接口地址的包路径
                .paths(PathSelectors.any())
                .build();
    }

    /**
     * 构建 api文档的详细信息函数,注意这里的注解引用的是哪个
     * @return
     */
    private ApiInfo apiInfo(){
        return new ApiInfoBuilder()
                //页面标题
                .title(&quot;Spring Boot 测试使用 Swagger2 构建RESTful API&quot;)
                //创建人
                .contact(new Contact(&quot;LanveToBigData&quot;, &quot;http://www.cnblogs.com/zhangyinhua/&quot;, &quot;917484312@qq.com&quot;))
                //版本号
                .version(&quot;1.0&quot;)
                //描述
                .description(&quot;API 描述&quot;)
                .build();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;controller文档内容&quot;&gt;3.3 Controller文档内容&lt;/h3&gt;
&lt;p&gt;描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。&lt;br/&gt;如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam&lt;br/&gt;注解来给参数增加说明。&lt;br/&gt;1）实例一&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.lance.learn.springbootswagger.controller;

import com.lance.learn.springbootswagger.bean.Book;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;
import springfox.documentation.annotations.ApiIgnore;

import java.util.*;

/**
 * @author lance(ZYH)
 * @function
 * @date 2018-07-09 21:39
 */
@RestController
@RequestMapping(value = &quot;/bookcurd&quot;)
public class BookController {
    Map&amp;lt;Long, Book&amp;gt; books = Collections.synchronizedMap(new HashMap&amp;lt;Long, Book&amp;gt;());

    @ApiOperation(value=&quot;获取图书列表&quot;, notes=&quot;获取图书列表&quot;)
    @RequestMapping(value={&quot;&quot;}, method= RequestMethod.GET)
    public List&amp;lt;Book&amp;gt; getBook() {
        List&amp;lt;Book&amp;gt; book = new ArrayList&amp;lt;&amp;gt;(books.values());
        return book;
    }

    @ApiOperation(value=&quot;创建图书&quot;, notes=&quot;创建图书&quot;)
    @ApiImplicitParam(name = &quot;book&quot;, value = &quot;图书详细实体&quot;, required = true, dataType = &quot;Book&quot;)
    @RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)
    public String postBook(@RequestBody Book book) {
        books.put(book.getId(), book);
        return &quot;success&quot;;
    }
    @ApiOperation(value=&quot;获图书细信息&quot;, notes=&quot;根据url的id来获取详细信息&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;ID&quot;, required = true, dataType = &quot;Long&quot;,paramType = &quot;path&quot;)
    @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.GET)
    public Book getBook(@PathVariable Long id) {
        return books.get(id);
    }

    @ApiOperation(value=&quot;更新信息&quot;, notes=&quot;根据url的id来指定更新图书信息&quot;)
    @ApiImplicitParams({
            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;图书ID&quot;, required = true, dataType = &quot;Long&quot;,paramType = &quot;path&quot;),
            @ApiImplicitParam(name = &quot;book&quot;, value = &quot;图书实体book&quot;, required = true, dataType = &quot;Book&quot;)
    })
    @RequestMapping(value=&quot;/{id}&quot;, method= RequestMethod.PUT)
    public String putUser(@PathVariable Long id, @RequestBody Book book) {
        Book book1 = books.get(id);
        book1.setName(book.getName());
        book1.setPrice(book.getPrice());
        books.put(id, book1);
        return &quot;success&quot;;
    }
    @ApiOperation(value=&quot;删除图书&quot;, notes=&quot;根据url的id来指定删除图书&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;图书ID&quot;, required = true, dataType = &quot;Long&quot;,paramType = &quot;path&quot;)
    @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.DELETE)
    public String deleteUser(@PathVariable Long id) {
        books.remove(id);
        return &quot;success&quot;;
    }

    @ApiIgnore//使用该注解忽略这个API
    @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET)
    public String  jsonTest() {
        return &quot; hi you!&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）实例二&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.lance.learn.springbootswagger.controller;

import com.lance.learn.springbootswagger.bean.User;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.springframework.web.bind.annotation.*;

import java.util.*;

/**
 * @author lance(ZYH)
 * @function
 * @date 2018-07-09 22:00
 */

@RestController
@RequestMapping(value=&quot;/users&quot;)
public class UserDetailController {
    static Map&amp;lt;Long, User&amp;gt; users = Collections.synchronizedMap(new HashMap&amp;lt;Long, User&amp;gt;());

    @ApiOperation(value=&quot;获取用户列表&quot;, notes=&quot;&quot;)
    @RequestMapping(value={&quot;&quot;}, method= RequestMethod.GET)
    public List&amp;lt;User&amp;gt; getUserList() {
        List&amp;lt;User&amp;gt; r = new ArrayList&amp;lt;User&amp;gt;(users.values());
        return r;
    }

    @ApiOperation(value=&quot;创建用户&quot;, notes=&quot;根据User对象创建用户&quot;)
    @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
    @RequestMapping(value=&quot;&quot;, method=RequestMethod.POST)
    public String postUser(@RequestBody User user) {
        users.put(user.getId(), user);
        return &quot;success&quot;;
    }

    @ApiOperation(value=&quot;获取用户详细信息&quot;, notes=&quot;根据url的id来获取用户详细信息&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)
    @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.GET)
    public User getUser(@PathVariable Long id) {
        return users.get(id);
    }

    @ApiOperation(value=&quot;更新用户详细信息&quot;, notes=&quot;根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息&quot;)
    @ApiImplicitParams({
            @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;),
            @ApiImplicitParam(name = &quot;user&quot;, value = &quot;用户详细实体user&quot;, required = true, dataType = &quot;User&quot;)
    })
    @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.PUT)
    public String putUser(@PathVariable Long id, @RequestBody User user) {
        User u = new User();
        users.put(id, u);
        return &quot;success&quot;;
    }

    @ApiOperation(value=&quot;删除用户&quot;, notes=&quot;根据url的id来指定删除对象&quot;)
    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;用户ID&quot;, required = true, dataType = &quot;Long&quot;)
    @RequestMapping(value=&quot;/{id}&quot;, method=RequestMethod.DELETE)
    public String deleteUser(@PathVariable Long id) {
        users.remove(id);
        return &quot;success&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;web界面查看&quot;&gt;3.4 web界面查看&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/EqIH7J2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四项目代码地址&quot;&gt;四、项目代码地址&lt;/h2&gt;
&lt;p&gt;https://github.com/LanceToBigData/SpringBootLearning/tree/develop/SpringBoot-Swagger&lt;/p&gt;
</description>
<pubDate>Mon, 09 Jul 2018 14:10:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/9286391.html</dc:identifier>
</item>
<item>
<title>【原创】CA证书申请+IIS配置HTTPS+默认访问https路径 - BruceLee1123</title>
<link>http://www.cnblogs.com/lichunting/p/9274422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lichunting/p/9274422.html</guid>
<description>&lt;p&gt;&lt;span&gt;一．CA证书申请&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;(一). 新StartSSL注册帐号&lt;/h2&gt;
&lt;p&gt;    1．    StartSSL官网&lt;/p&gt;
&lt;blockquote readability=&quot;1.875&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;官方网站：&lt;a href=&quot;https://www.startssl.com/&quot;&gt;https://www.startssl.com/&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;    2．    进入到StartSSL后，直接点击注册账号,然后进入邮箱注册页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180706163421130-1306840228.png&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180706163738691-661403354.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;337&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180706163751530-239351208.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;334&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    3．    点击发送验证码，进入如下页面，从邮箱中获取验证码，并在下图中填写到指定位置，点击Sign Up。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709091306053-1667997405.png&quot; alt=&quot;&quot; width=&quot;736&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    4．    成功验证了邮箱地址后，StartSSL会自动往你的浏览器中安装唯一一个属于自己管理StartSSL的个人证书。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709091404987-1648105550.png&quot; alt=&quot;&quot; width=&quot;733&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5．    在浏览器中查看SSL证书，可以看到该个人管理SSL证书是有有效期的。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709091610550-56185210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    6．    点击该证书安装成功页面的Login Now按钮或者返回到StartSSL网站，点击“Login”然后就可以使用个人证书登录了。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709091827150-532193693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7．    这是StartSSL的用户控制中心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709091910957-1049495450.png&quot; alt=&quot;&quot; width=&quot;739&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;(二). 申请StartSSL免费SSL&lt;/h2&gt;
&lt;p&gt;    1．    进入到StartSSL用户管理中心，然后找到免费SSL证书的申请页面。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709105902869-1000365982.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    2．    在此之前首先先验证一个使用这个证书的域名, 会把验证码发送到域名注册邮箱里，点击Validations Wizard，并选中第一个，点击Continue。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110351485-1487227582.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    3．    输入要验证的域名点击Continue。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110401324-755900351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   4．    选择一个该域名下的管理邮箱，发送验证码，并输入获取的验证码，验证域名。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110501527-892882213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    5．    域名验证完成后，会在用户管理中心页面右侧域名验证显示已经验证的域名。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110512215-1117668955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110517730-1777138179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    6．    进入到StartSSL用户管理中心，然后找到免费SSL证书的申请页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110529704-1276380355.png&quot; alt=&quot;&quot; width=&quot;751&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7．    点击进入如下页面，并输入需要获取证书的域名，这里写的是二级域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110545894-383832807.png&quot; alt=&quot;&quot; width=&quot;744&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8．    然后填写证书签名请求，如下图所示。这时需要到部署https的服务器上的的IIS中填写 证书签名请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110559913-391616538.png&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9．    登录服务器，打开IIS，在IIS根目录上右侧有个服务器证书, 点击后打开。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110612443-359274692.png&quot; alt=&quot;&quot; width=&quot;685&quot; height=&quot;654&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    10．   点击右侧 创建证书申请。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110621175-284185680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110638205-1511399144.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;     11．   点击下一步，加密提供程序和位长选择如图所示的两个。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110649613-36778672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     12．   选择桌面的位置，创建一个名为key.txt的文件。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110659302-358961089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     13．   点击完成，会在桌面生成 证书签名请求 字符串，将该文件中的内容复制到步骤8中的CSR填写框中。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110714830-357557628.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    14．   点击Submit，将会生成证书，可以点击&lt;span&gt;here&lt;/span&gt;位置下载生成的证书。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110727483-2010327163.png&quot; alt=&quot;&quot; width=&quot;723&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110738573-2145841972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;(三). StartSSL免费SSL下载使用 &lt;/h2&gt;
&lt;p&gt;        1．    以下是StartSSL免费SSL的Tool Box，有几个非常有用的功能，一个是证书列表，解密密钥、生成PKCS#12文件。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110749696-1357866735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       2．    点击Tool Box下的Certificate List菜单可以查看申请的证书列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110801068-1403890665.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;301&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 3．    点击Retrieve，也可下载生成的证书。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110811406-133279060.png&quot; alt=&quot;&quot; width=&quot;752&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    4．    下载下来的StartSSL免费SSL证书包，里面有四个包，分别对应不同的Web环境：Apache、Nginx、Windows IIS和其它。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110824218-181654534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;(一). 完成证书申请，导入证书&lt;/h2&gt;
&lt;p&gt;    1．    登录服务器，打开IIS，在IIS根目录上右侧有个服务器证书, 点击后打开，点击完成证书申请。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110835781-539977307.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;    2．    将下载下来的证书中，IIS压缩包里的证书拷贝到服务器桌名，并在此指定带有域名名称的证书文件点击确定。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110844633-1314317995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    3．    点击确定，即可在列表最后中查看导入的证书信息。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709110857929-1582208038.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;136&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    4．    右键单击查看，即可查看证书的相关信息，证书颁发给申请时填写的域名，并且可以看到 您有一个与该证书对应的私钥。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111031814-1354494249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    5．    至此，证书导入成功。&lt;/p&gt;
&lt;h2&gt;(二). 部署Https网站&lt;/h2&gt;
&lt;p&gt;    1．    在IIS主页，右键网站菜单，添加网站。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111049594-11933731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    2．    点击确定，启动网站，并查看网站是否发布成功。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111059452-1635410798.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    3．    为该网站绑定证书，以使用https。找到我们需要部署的网站，在服务器网站栏里，点击绑定。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111111391-259314664.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;465&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    4．    然后我们点添加，添加选择https，默认为443端口，并选择刚才导入的证书点击确定。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111119545-1950568496.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111134919-1776283977.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;    5．    如下图所示，则绑定完成。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111143702-629133948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111156433-975408772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    6．    如果添加成功之后。打开对应的那个网站，找到SSL服务器证书，你会发现有一个证书（启用选项会可选，之前是灰色的）。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111214007-1863895506.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;625&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111225382-208813524.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;201&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;    7．    然后使用https协议访问该网站域名，https协议显示为绿色，至此https网站部署成功。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111234323-1208527752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;【注意】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;A. &lt;/strong&gt; &lt;strong&gt;：在配置https的服务器的Windows防火墙上允许443（绑定https时默认为443端口）的端口的访问。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;B. &lt;/strong&gt; &lt;strong&gt;配置https网站时，443端口不可占用。&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;

&lt;h2&gt;(一). IIS安装URL重写模块&lt;/h2&gt;
&lt;p&gt;    1．    IIS7.5下载地址。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;中文32位：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;http://download.microsoft.com/download/4/9/C/49CD28DB-4AA6-4A51-9437-AA001221F606/rewrite_x86_zh-CN.msi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文64位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://download.microsoft.com/download/4/E/7/4E7ECE9A-DF55-4F90-A354-B497072BDE0A/rewrite_x64_zh-CN.msi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://www.iis.net/downloads/microsoft/url-rewrite&lt;/p&gt;
&lt;p&gt;    2．    安装IIS7.5 URL重写组件。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111252723-1762159068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111301335-405851282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    3．    下载安装完成之后会发现我们的IIS界面多了个URL重写的组件。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111314232-1571810040.png&quot; alt=&quot;&quot; width=&quot;665&quot; height=&quot;596&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    4．  &lt;/strong&gt; &lt;strong&gt;注意：URL重写唯一就是能够实现全站http跳转https。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在部署之前，请检查网站根目录是否有web.config文件，如有，请先备份这里的web.config文件，因为以下的配置可能会和web.config里面跳转冲突，个人建议是直接删除处理，毕竟旧的不去新的不来，哈哈哈（建议先备份）。&lt;/p&gt;
&lt;h2&gt;(二). IIS编辑入站规则&lt;/h2&gt;
&lt;p&gt;    1．    双击URL重写打开，点击添加规则。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111341691-244101834.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;    2．    名称填写Redirect to https，使用正规表达式，模式填写 （.*）。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111356195-923074308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    3．    然后接下来选择添加条件。第一个填{HTTPS} 与模式匹配 ^OFF$ ，第二个填{HTTPS_HOST} 与模式不匹配 ^(localhost)。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111404961-1862039748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111438116-1186437228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111447997-235125015.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;    4．    操作类型选择重定向，然后选择属性为https://{HTTP_HOST}/{R:1} 重定向类型选择303。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111457660-992656859.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;    5．    最后一步，检查下点保存即可。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111508894-328357056.png&quot; alt=&quot;&quot; width=&quot;713&quot; height=&quot;724&quot;/&gt; &lt;/p&gt;
&lt;p&gt;    6．    然后，我们使用浏览器访问网站，直接输入xxx.xxx.com或者&lt;a href=&quot;http://xx.xxx.com/&quot;&gt;http://xx.xxx.com&lt;/a&gt;或者&lt;a href=&quot;https://xxx.xxx.com/&quot;&gt;https://xxx.xxx.com&lt;/a&gt;都是访问的&lt;a href=&quot;https://xxx.xxx.com/&quot;&gt;https://xxx.xxx.com&lt;/a&gt;，这表示配置URL重写成功。&lt;/p&gt;
&lt;p&gt;    7．    web.config中对应的配置。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111521309-1820374760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/597599/201807/597599-20180709111647374-1977712688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 09 Jul 2018 13:30:00 +0000</pubDate>
<dc:creator>BruceLee1123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lichunting/p/9274422.html</dc:identifier>
</item>
</channel>
</rss>