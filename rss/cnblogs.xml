<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>编写优雅代码的最佳实践 - 木可大大</title>
<link>http://www.cnblogs.com/neal-ke/p/8897832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neal-ke/p/8897832.html</guid>
<description>&lt;p&gt;Robert Martin曾说过&quot;在代码阅读中说脏话的频率是衡量代码质量额唯一标准&quot;。同时，代码的写法应当使别人理解它所需的时间最小化，也就是说我们写的代码是给人看的而不是给机器看的。那么，如何编写优雅代码呢？可以从思想层面和具体技巧层面来优化代码，思想层面指的是遵循面向对象设计原则，本期介绍的是具体技巧。&lt;/p&gt;
&lt;h2&gt;1. 代码总是越短越好吗？&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token function&quot;&gt;assert&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!&lt;span class=&quot;token punctuation&quot;&gt;(bucket &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token function&quot;&gt;findBucket&lt;span class=&quot;token punctuation&quot;&gt;(key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token operator&quot;&gt;|| &lt;span class=&quot;token operator&quot;&gt;!bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;isOccupied&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;上面这行代码虽然比较短，但是难以阅读。为了更好地阅读，我们做如下修改：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
bucket &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token function&quot;&gt;findBucket&lt;span class=&quot;token punctuation&quot;&gt;(key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;span class=&quot;token punctuation&quot;&gt;(bucket &lt;span class=&quot;token operator&quot;&gt;!= &lt;span class=&quot;token keyword&quot;&gt;null&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token function&quot;&gt;assert&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;isOccupied&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;减少代码行数是一个好目标，但是让阅读代码的事件最小化是个更好的目标。&lt;/p&gt;
&lt;h2&gt;2. 给重要语句添加注释&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;

&lt;/pre&gt;
&lt;p&gt;上面这行代码如果没有添加注释，我们根本不知道是什么意思，但是有了这行注释，我们就知道通过移位操作来提升性能。&lt;/p&gt;
&lt;h2&gt;3. tmp的使用&lt;/h2&gt;
&lt;p&gt;tmp是我们经常用的，譬如说两个变量置换，都已变成约定俗成了。&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
tmp &lt;span class=&quot;token operator&quot;&gt;= right&lt;span class=&quot;token punctuation&quot;&gt;;
right &lt;span class=&quot;token operator&quot;&gt;= left&lt;span class=&quot;token punctuation&quot;&gt;;
left &lt;span class=&quot;token operator&quot;&gt;= tmp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
String tmp &lt;span class=&quot;token operator&quot;&gt;= user&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;getName&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
tmp &lt;span class=&quot;token operator&quot;&gt;+= &lt;span class=&quot;token string&quot;&gt;&quot; &quot; &lt;span class=&quot;token operator&quot;&gt;+ user&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;getPhoneNumber&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
tmp &lt;span class=&quot;token operator&quot;&gt;+= &lt;span class=&quot;token string&quot;&gt;&quot; &quot; &lt;span class=&quot;token operator&quot;&gt;+ user&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;getEmail&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
template&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token keyword&quot;&gt;set&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token string&quot;&gt;&quot;user_info&quot;&lt;span class=&quot;token punctuation&quot;&gt;,tmp&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;4.&lt;code&gt;i，j，k，iter，it&lt;/code&gt;：只用做索引或者循环迭代&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;i，j，k，iter，it&lt;/code&gt;被用做索引或者循环迭代已成为业界规范了（i是index的缩写），例如：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;span class=&quot;token punctuation&quot;&gt;(int i&lt;span class=&quot;token operator&quot;&gt;=&lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;;i&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;span class=&quot;token number&quot;&gt;100&lt;span class=&quot;token punctuation&quot;&gt;;i&lt;span class=&quot;token operator&quot;&gt;++&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;span class=&quot;token punctuation&quot;&gt;(int j&lt;span class=&quot;token operator&quot;&gt;=&lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;;j&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;span class=&quot;token number&quot;&gt;100&lt;span class=&quot;token punctuation&quot;&gt;;j&lt;span class=&quot;token operator&quot;&gt;++&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;span class=&quot;token operator&quot;&gt;...&lt;span class=&quot;token operator&quot;&gt;...
  &lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}

Iterator&lt;span class=&quot;token operator&quot;&gt;&amp;lt;String&lt;span class=&quot;token operator&quot;&gt;&amp;gt; iter &lt;span class=&quot;token operator&quot;&gt;= list&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;iterator&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;span class=&quot;token punctuation&quot;&gt;(iter&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;hasNext&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
  &lt;span class=&quot;token operator&quot;&gt;...&lt;span class=&quot;token operator&quot;&gt;...
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们在其他地方使用i，j，k，那么就会增加阅读者的时间。&lt;/p&gt;
&lt;h2&gt;5. 附带重要属性&lt;/h2&gt;
&lt;p&gt;我们把命名当做一种注释的方式，让它承载更多的信息！&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/f62278ukvc.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;6. 名字需要多长？&lt;/h2&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;在小的作用域中使用简短的名字&lt;/li&gt;
&lt;li&gt;在作用域大的可以使用长名字&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;span class=&quot;token punctuation&quot;&gt;(debug&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
  Map&lt;span class=&quot;token operator&quot;&gt;&amp;lt;String&lt;span class=&quot;token punctuation&quot;&gt;,Integer&lt;span class=&quot;token operator&quot;&gt;&amp;gt; m &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token keyword&quot;&gt;new &lt;span class=&quot;token class-name&quot;&gt;HashMap&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;span class=&quot;token operator&quot;&gt;&amp;gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
  &lt;span class=&quot;token function&quot;&gt;lookUpNamesNumbers&lt;span class=&quot;token punctuation&quot;&gt;(m&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
  &lt;span class=&quot;token function&quot;&gt;print&lt;span class=&quot;token punctuation&quot;&gt;(m&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;7. 不要使用容易误解的名字&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
results &lt;span class=&quot;token operator&quot;&gt;= Database&lt;span class=&quot;token punctuation&quot;&gt;.all_objects&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token string&quot;&gt;&quot;year&amp;lt;=2011&quot;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;上面这行代码结果现在包含哪些信息？filter是把年份小于等于2011年的数据过滤掉？还是保留？&lt;/p&gt;
&lt;h2&gt;8. 推荐用min和max来表示极限&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
MAX_ITEMS_IN_CART &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token number&quot;&gt;10&lt;span class=&quot;token punctuation&quot;&gt;;

&lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(shoppingCart&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;numOfItems&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token operator&quot;&gt;&amp;gt; MAX_ITEMS_IN_CART&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;span class=&quot;token function&quot;&gt;error&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token string&quot;&gt;&quot;Too many items in cart&quot;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;9. 推荐用begin和end来表示包含/排除范围&lt;/h2&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/15qd5x5x9y.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;begin表示包含，end表示排除，在Java中典型的例子就是String.substring()&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
String s &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token string&quot;&gt;&quot;Hello world&quot;&lt;span class=&quot;token punctuation&quot;&gt;;

s&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;substring&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;span class=&quot;token number&quot;&gt;5&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;span class=&quot;token operator&quot;&gt;-&lt;span class=&quot;token operator&quot;&gt;&amp;gt; &lt;span class=&quot;token string&quot;&gt;&quot;llo&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;10.与使用者的期望相匹配&lt;/h2&gt;
&lt;p&gt;一般来说，getter方法就是获取一个字段的值，用户期待的是轻量级的方法，如果你要是在其中做了太多的计算，就应该考虑改名。&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public double &lt;span class=&quot;token function&quot;&gt;getMeanPrice&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;11.不要为那些从代码本身就能快速推断的事实写注释&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public  &lt;span class=&quot;token keyword&quot;&gt;class &lt;span class=&quot;token class-name&quot;&gt;Account &lt;span class=&quot;token punctuation&quot;&gt;{  

   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;12. 不要给不好的名字加注释--应该把名字改好&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;

&lt;/pre&gt;
&lt;p&gt;乍一看我们会误认为这是一个删除注册表的函数，可是注释里澄清它不就改动真正的注册表。因此，我们可以用一个更加自我说明的名字，例如：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;releaseRegistryHandle&lt;span class=&quot;token punctuation&quot;&gt;(registryKey key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;13.为代码中的瑕疵写注释&lt;/h2&gt;
&lt;p&gt;// TODO:采用更快算法或者当代码没有完成时 // TODO(dustin):处理除JPEG以外的图像格式&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/qwlx9fpl1n.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;14.为常量写注释&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;

&lt;/pre&gt;
&lt;h2&gt;15. 站在读者的角度写注释&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
struct Recoder &lt;span class=&quot;token punctuation&quot;&gt;{
    vector&lt;span class=&quot;token operator&quot;&gt;&amp;lt;float&lt;span class=&quot;token operator&quot;&gt;&amp;gt; data&lt;span class=&quot;token punctuation&quot;&gt;;
    &lt;span class=&quot;token operator&quot;&gt;...
    &lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;clear&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;如果有一个好的注释可以解答读者的疑问，将上述进行如下修改：强制Vector真正地把内存归还给内存分配器，详情请查阅STL swap trick。&lt;/p&gt;
&lt;h2&gt;16. 公布可能的陷阱&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;sendMail&lt;span class=&quot;token punctuation&quot;&gt;(String to&lt;span class=&quot;token punctuation&quot;&gt;,String subject&lt;span class=&quot;token punctuation&quot;&gt;,String body&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数由于需要调用外部服务器发送邮件，可能会很耗时，有可能导致使用者的线程挂起。需要将这段描述放到注释中。&lt;/p&gt;
&lt;h2&gt;17. 条件语句中参数的顺序&lt;/h2&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/8vsfe553ua.png?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;一般原则：将变量放在左边，常量放在右边。更宽泛地说，将比较稳定的变量放在右边，变化较大的放在左边。如 if ( length &amp;gt;= 10) 而不是 if ( 10 &amp;lt;= length)。但是，在非“大小”比较的情况下，上面的原则似乎不起作用，例如验证一个请求参数是否为某个特定值：&lt;code&gt;if ( request.getParameterValue(&quot;name&quot;)).equals(&quot;Brandon&quot;))&lt;/code&gt;,此时将常量&quot;Brandon&quot;可以避免出现空指针的情况（上行的参数没有name或者值为空）。&lt;/p&gt;
&lt;h2&gt;18. if/else语句块的顺序&lt;/h2&gt;
&lt;p&gt;if/else书写规范：首先处理正逻辑而不是负逻辑，例如 if(ok)，而不是if(!ok)；其次处理掉简单的情况，这有利于让if和else处理代码在同一个屏幕内可见。&lt;/p&gt;
&lt;h2&gt;19. 通过提早返回减少嵌套&lt;/h2&gt;
&lt;p&gt;使用提前返回的机制，可以把函数的嵌套层级变浅。举个栗子，没有使用提前返回的代码：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;static bool &lt;span class=&quot;token function&quot;&gt;checkUserAuthority&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
        &lt;span class=&quot;token punctuation&quot;&gt;{
            bool a&lt;span class=&quot;token punctuation&quot;&gt;, b&lt;span class=&quot;token punctuation&quot;&gt;, c&lt;span class=&quot;token punctuation&quot;&gt;, d&lt;span class=&quot;token punctuation&quot;&gt;, e&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(a&lt;span class=&quot;token punctuation&quot;&gt;)
            &lt;span class=&quot;token punctuation&quot;&gt;{
                &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(b&lt;span class=&quot;token punctuation&quot;&gt;)
                &lt;span class=&quot;token punctuation&quot;&gt;{
                    &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(c&lt;span class=&quot;token punctuation&quot;&gt;)
                    &lt;span class=&quot;token punctuation&quot;&gt;{
                        &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(d&lt;span class=&quot;token punctuation&quot;&gt;)
                        &lt;span class=&quot;token punctuation&quot;&gt;{
                            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(e&lt;span class=&quot;token punctuation&quot;&gt;)
                            &lt;span class=&quot;token punctuation&quot;&gt;{
                                &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;true&lt;span class=&quot;token punctuation&quot;&gt;;
                            &lt;span class=&quot;token punctuation&quot;&gt;}
                        &lt;span class=&quot;token punctuation&quot;&gt;}
                    &lt;span class=&quot;token punctuation&quot;&gt;}
                &lt;span class=&quot;token punctuation&quot;&gt;}
            &lt;span class=&quot;token punctuation&quot;&gt;}

            &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;使用了提前返回的代码：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;static bool &lt;span class=&quot;token function&quot;&gt;checkUserAuthority&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
        &lt;span class=&quot;token punctuation&quot;&gt;{
            bool a&lt;span class=&quot;token punctuation&quot;&gt;, b&lt;span class=&quot;token punctuation&quot;&gt;, c&lt;span class=&quot;token punctuation&quot;&gt;, d&lt;span class=&quot;token punctuation&quot;&gt;, e&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!a&lt;span class=&quot;token punctuation&quot;&gt;)
                &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!b&lt;span class=&quot;token punctuation&quot;&gt;)
                &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!c&lt;span class=&quot;token punctuation&quot;&gt;)
                &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!d&lt;span class=&quot;token punctuation&quot;&gt;)
                &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;if &lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token operator&quot;&gt;!e&lt;span class=&quot;token punctuation&quot;&gt;)
                &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;

            &lt;span class=&quot;token keyword&quot;&gt;return &lt;span class=&quot;token boolean&quot;&gt;true&lt;span class=&quot;token punctuation&quot;&gt;;
       
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;20. 通过 &quot;总结变量&quot; 增加可读性&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;span class=&quot;token punctuation&quot;&gt;(request&lt;span class=&quot;token punctuation&quot;&gt;.user&lt;span class=&quot;token punctuation&quot;&gt;.id &lt;span class=&quot;token operator&quot;&gt;== document&lt;span class=&quot;token punctuation&quot;&gt;.owner_id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;通过观察，我们提取一个变量&lt;code&gt;final boolean user_owns_document=(request.user.id == document.owner_id)&lt;/code&gt;，接着代码就可以修改成：&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;span class=&quot;token punctuation&quot;&gt;(user_owns_document&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;21. 减少控制流变量&lt;/h2&gt;
&lt;p&gt;在while、for等循环语句中，我们通常使用自定义的bool变量，来控制流转。&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
boolean done &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;以我们的经验，&quot;控制流变量&quot; 可以通过优化程序结构、逻辑来消除。&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;22. 缩小变量的作用域&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
    int i &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token number&quot;&gt;7&lt;span class=&quot;token punctuation&quot;&gt;;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;span class=&quot;token punctuation&quot;&gt;(someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;23. 不要为了共享而把变量设置为类的字段&lt;/h2&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public &lt;span class=&quot;token keyword&quot;&gt;class &lt;span class=&quot;token class-name&quot;&gt;LargeClass&lt;span class=&quot;token punctuation&quot;&gt;{
    String s&lt;span class=&quot;token punctuation&quot;&gt;;
    &lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;method1&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
        s &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token operator&quot;&gt;...
        &lt;span class=&quot;token function&quot;&gt;method2&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
    &lt;span class=&quot;token punctuation&quot;&gt;}
    &lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;method2&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;通过参数传递来实现数据共享&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public &lt;span class=&quot;token keyword&quot;&gt;class &lt;span class=&quot;token class-name&quot;&gt;LargeClass&lt;span class=&quot;token punctuation&quot;&gt;{
    &lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;method1&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
        String s &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token operator&quot;&gt;...
        &lt;span class=&quot;token function&quot;&gt;method2&lt;span class=&quot;token punctuation&quot;&gt;(s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;;
    &lt;span class=&quot;token punctuation&quot;&gt;}
    &lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;method2&lt;span class=&quot;token punctuation&quot;&gt;(String s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
        &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;24. 不要把所有变量都定义在开头&lt;/h2&gt;
&lt;p&gt;把所有变量定义在开头是C语言的风格，面向对象语言习惯将变量定义在离它开始使用的地方。&lt;/p&gt;
&lt;pre class=&quot;prism-token token language-javascript&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public &lt;span class=&quot;token keyword&quot;&gt;void &lt;span class=&quot;token function&quot;&gt;foo&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;{
  boolean debug &lt;span class=&quot;token operator&quot;&gt;= &lt;span class=&quot;token boolean&quot;&gt;false&lt;span class=&quot;token punctuation&quot;&gt;;
  String&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;] pvs&lt;span class=&quot;token punctuation&quot;&gt;;
  String pn&lt;span class=&quot;token punctuation&quot;&gt;;
  String pv&lt;span class=&quot;token punctuation&quot;&gt;;
  &lt;span class=&quot;token operator&quot;&gt;...
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;除了上述建议之外，我们还可以参考阿里Java规范，关注微信号：&quot;木可大大&quot;，发送&quot;阿里Java规范&quot;即可获得相关资料。&lt;/p&gt;

</description>
<pubDate>Fri, 20 Apr 2018 23:41:00 +0000</pubDate>
<dc:creator>木可大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neal-ke/p/8897832.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构08（链表02-双向链表） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8886941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8886941.html</guid>
<description>&lt;p&gt;　　其实无论在任何语言中，一种数据结构往往会有很多的延伸和变种以应对不同场景的需要。其实前面我们所学过的栈和队列也是可以用链表来实现的。有兴趣的小伙伴可以自己尝试着去实现以下。&lt;/p&gt;
&lt;p&gt;　　有点跑题了...，我们还是说回链表，在基础链表之外，还有双向链表和循环链表和双向循环链表。这篇文章会详细的介绍一下双向链表，但是不会详细的去讲解循环链表。因为其实真的没有太大的区别。链表和循环链表的唯一的区别在于，&lt;strong&gt;最后一个元素指向下一个元素的指针不是null，而是head。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　其实循环链表只能从头到尾的循环，而双向循环链表可以两个方向循环，想怎么玩怎么玩。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;嗯...又跑题了，我们还是来说双向链表吧。&lt;/p&gt;
&lt;p&gt;　　顾名思义...双向链表就是....双向链表！额...开个玩笑...咱们进入正题吧....&lt;/p&gt;
&lt;p&gt;　　其实简单说双向链表与链表的区别就在于，双向链表不仅仅有一个指向下一个节点元素的指针，还同时拥有一个指向上一个节点元素的指针。前后都可以链接，故，称之为双向链表。&lt;/p&gt;
&lt;p&gt;　　那么既然是双向的指针，所以我们的代码需要新增一些东西。&lt;/p&gt;
&lt;p&gt;　　由于双向链表内的一些方法与链表无异，所以这里只说明一下那些区别明显有重要意义的地方。不再贴上所有的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; DoublyLinkedList() {
  let Node &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (element) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.element =&lt;span&gt; element;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在双向链表中，这里多了个指向前一个节点元素的指针prev&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.prev = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }

  let length &lt;/span&gt;= 0&lt;span&gt;;
  let head &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同样的这里多了一个保存链表最后一项节点的引用变量，为什么要加这个变量？&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为是双向链表，普通链表只能从头到尾的迭代各节点元素，一方面是因为普通链表中只有一个存储头部节点元素的head变量。&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是双向链表可以从尾部开始迭代，这就是tail的意义。&lt;/span&gt;
  let tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这就是双向链表的类的变动（不包括其中的方法），我们可以看到只是多了node节点元素中prev（前一个）节点元素的指针，还有tail变量对尾部节点元素的引用。&lt;/p&gt;
&lt;p&gt;　　那么下面我们来看看insert方法的变化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们来看看双向链表中insert方法,普通链表中，我们只需要控制next指针就可以了，但是在双向链表中，在控制next指针的同时，我们还要控制prev指针&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.insert = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (position,element) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在普通链表中在任意位置添加元素有两种情况，一个是添加到头部，另外一个是除了头部以外的其他位置，&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在双向链表中除了这两种情况，还多了一种，添加在链表尾部&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;(position &amp;gt;= 0 &amp;amp;&amp;amp; position &amp;lt;=&lt;span&gt; length) {
    let node &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(element);
    let current &lt;/span&gt;=&lt;span&gt; head;
    let previous;
    let index &lt;/span&gt;= 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到头部的情况&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(position === 0&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里，如果head为null，也就是说该链表是没有任何节点元素的情况，那么加入的这个节点元素在链表中是唯一的&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以，head引用为node，tail的引用也为node&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;head) {
        head &lt;/span&gt;=&lt;span&gt; node;
        tail &lt;/span&gt;=&lt;span&gt; node;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么如果，head不为null，说明链表中存在至少一个元素。&lt;/span&gt;
      } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于current就是head，那么要插入节点元素的话只要把node的next指针指向current，就说明我们在current前面插入了该节点元素。&lt;/span&gt;
        node.next =&lt;span&gt; current;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为是双向列表，我们还要给current.prev一个指向。&lt;/span&gt;
        current.prev =&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么既然我们在current前面插入了元素，这里也就要改变head的引用，变为我们插入的node&lt;/span&gt;
        head =&lt;span&gt; node;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果我们想要插入尾部的情况&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(position ===&lt;span&gt; length) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里稍微有趣一点，这里我们要在尾部加入元素，不用像普通链表那样迭代到最后一项再操作。&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们只需要把current直接置为tail的引用就可以了，方便快捷&lt;/span&gt;
      current =&lt;span&gt; tail;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么我们已经拿到了最后一项节点元素的引用并且设置为了current。&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们只需要把current（tail）的next指向node节点元素，并且把node的prev只想current。&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实就是说，current节点的next指针不再是null了，因为我们在它的后面增加了一个“插入元素”，所以它的next指针为node&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;而此时node的prev指针也就理所当然的指向了current。&lt;/span&gt;
      current.next =&lt;span&gt; node;
      node.prev &lt;/span&gt;=&lt;span&gt; current;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入元素完成，但是我们此时的tail其实是current不是node，所以更改一下tail的引用。&lt;/span&gt;
      tail =&lt;span&gt; node;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index++ &amp;lt;&lt;span&gt; position) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依次往后移动...不多说&lt;/span&gt;
        previous =&lt;span&gt; current;
        current &lt;/span&gt;=&lt;span&gt; current.next;
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在移动到需要插入节点元素的位置时。&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们要插入在current的前面，自然就会有下面的结果了&lt;/span&gt;
      node.next =&lt;span&gt; current;
      previous.next &lt;/span&gt;=&lt;span&gt; node;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是我们由于是双向链表，我们不仅仅要修改next指针，还要修改prev指针&lt;/span&gt;
      current.prev =&lt;span&gt; node;
      node.prev &lt;/span&gt;=&lt;span&gt; previous;
    }
    length&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实insert方法在双向链表中，只是多了一种尾部情况的判断以及prev指针的改变，注释已经说的很详细了，不多说废话，我们继续看看removeAt方法在双向链表中的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.removeAt = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (position) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(position &amp;gt; -1 &amp;amp;&amp;amp; position &amp;lt;&lt;span&gt; length) {
    let current &lt;/span&gt;= head,previous,index = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(position === 0&lt;span&gt;) {
      head &lt;/span&gt;=&lt;span&gt; current.next;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(length === 1&lt;span&gt;) {
        tail &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        head.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(position === length - 1&lt;span&gt;) {
      current &lt;/span&gt;=&lt;span&gt; tail;
      tail &lt;/span&gt;=&lt;span&gt; current.prev;
      tail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(index++ &amp;lt;&lt;span&gt; position) {
        previous &lt;/span&gt;=&lt;span&gt; current;
        current &lt;/span&gt;=&lt;span&gt; current.next;
      }

      previous.next &lt;/span&gt;=&lt;span&gt; current.next;
      current.next.prev &lt;/span&gt;=&lt;span&gt; previous;
    }

    length &lt;/span&gt;--&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current.element;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是双向链表的removeAt方法，我不想解释了，因为我觉得如果你认真的阅读了这两篇文章，这个方法你绝对可以看懂了。如果你还是看不懂，请&lt;strong&gt;从头再来&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;　　这里我们就基本介绍完了双向链表...等等...不是还有其它的方法么？怎么不说了？&lt;/p&gt;
&lt;p&gt;　　insert可以在任意位置插入元素，removeAt可以在任意位置移除元素，想要实现其它方法就不难了吧。。。。。再说下去也是重复前面说过的内容了。实在无须如此....&lt;/p&gt;
&lt;p&gt;　　那么我们对于链表的了解就告一段落，下一篇文章我们一起来看看集合这个东东。感觉会比链表好玩一些。嗯...对，跟数学中的集合有关系。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Apr 2018 16:32:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8886941.html</dc:identifier>
</item>
<item>
<title>[python]使用django快速生成自己的博客小站，含详细部署方法 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/8894821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/8894821.html</guid>
<description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是之前经常听到的一句笑谈。因为新公司很多业务是用的python语言，所以这几天也一直在学习python的一些东西。&lt;/p&gt;
&lt;p&gt;作为一个之前一直java后端的开发人员，对比java最大的感受如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法简洁优美&lt;/li&gt;
&lt;li&gt;开发效率高&lt;/li&gt;
&lt;li&gt;支持类库强大&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这仅仅是我一家之言。从我接触python到现在也就一个星期时间，我用了两天时间自己搭建了一个建议博客小站，哈哈，想想还是挺有成就感的。&lt;/p&gt;
&lt;h4&gt;资源&lt;/h4&gt;
&lt;p&gt;因为前天购买了一个域名，所以昨天也是加班加点把一个简易的博客小站部署到了线上去。&lt;/p&gt;
&lt;p&gt;我自己的博客小站域名为：www.floweroman.com&lt;br/&gt;因为我自己的网名：'一枝花算不算浪漫', 而floweroman=flower romantic。 哈哈，这都是自己yy的，但是程序员还是应该保持点骚气。&lt;/p&gt;
&lt;p&gt;这里也特别感谢&lt;a href=&quot;https://www.zmrenwu.com/post/2/&quot;&gt;追梦人物&lt;/a&gt;的系列博客，给我的帮助很多。&lt;/p&gt;
&lt;p&gt;本人博客源码git：&lt;a href=&quot;https://github.com/barrywangmeng/blogProject.git&quot;&gt;https://github.com/barrywangmeng/blogProject.git&lt;/a&gt;&lt;br/&gt;后期我会一步步完善博客的内容，使得它真正可看可用。&lt;/p&gt;
&lt;h4&gt;教程&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;代码&lt;br/&gt;上面资源中已经发出了教程以及我自己的源码，感兴趣的朋友可以自行查看，这里不做重点赘述。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;域名购买&lt;br/&gt;当我们项目写完的时候我们当然是要挑选一个自己满意的域名。&lt;br/&gt;这里不建议从国内一些网站上购买域名(我一个同事在国内一家网站上购买的域名，最近被GA打电话要求去备案)，所以我们直接从外国网站上买，避免一些不必要的麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里推荐网址：&lt;a href=&quot;https://www.namesilo.com/&quot;&gt;https://www.namesilo.com/&lt;/a&gt;&lt;br/&gt;如下图：&lt;img src=&quot;https://i.loli.net/2018/04/20/5ada056b2e4ff.png&quot; alt=&quot;1.png&quot;/&gt;&lt;br/&gt;这个网站是可以支持支付宝的，基本很多域名都是$8.9 一年。当然还有其他国外的域名网站可以购买，大家可以自行搜索。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务器购买&lt;br/&gt;本打算购买国外服务器的，以后还可以搭梯子之类的。&lt;br/&gt;但是前一段时间阿里和腾讯云都有做活动，10元每月的价格实在心动，所以这次就在腾讯云注册了服务器。(特别说明：腾讯云注册服务器后可送一个星期的体验时间)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;购买的服务器推荐系统为：Ubuntu 64位&lt;/p&gt;
&lt;p&gt;腾讯云地址：&lt;a href=&quot;https://cloud.tencent.com/&quot;&gt;https://cloud.tencent.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以点击后面的登陆或者用第三方的xshell等登陆自己的服务器：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/04/20/5ada08f758c39.png&quot; alt=&quot;4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务器和域名均购买完成后，我们将域名映射到我们自己的ip上：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/04/20/5ada0c38ec470.png&quot; alt=&quot;3.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码部署&lt;br/&gt;这里才是今天要讲的重点：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、 github仓库&lt;br/&gt;把整个django项目上传到github，方便把代码拉到服务器（你也可以使用xftp软件）&lt;/p&gt;
&lt;p&gt;二、创建新用户&lt;br/&gt;一般不建议在root用户下进行配置，我们可以创建一个新用户，xshell连接远程服务器，输入命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo useradd -m -s /bin/bash wangmeng #创建新用户 wangmeng替换为你自己的用户名，下面一样&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo usermod -a -G sudo wangmeng #把新用户加入超级权限组&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo passwd wangmeng #为新用户设置密码&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;su - wangmeng #切换到新用户&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们看到@前面已经是wangmeng开头了，说明新用户已经创建好了:&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://i.loli.net/2018/04/20/5ada0b5971593.png&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、安装软件&lt;br/&gt;首先，更新一下服务器的包安装工具&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo apt-get update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get upgrade&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下一步安装主要用的的软件，nginx、git和创建虚拟环境的virtualenv:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install git python3 python3-pip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo pip3 install virtualenv&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;nginx安装完就会自动启动，这时你到浏览器输入域名或者ip就能看到nginx的欢迎界面：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/04/20/5ada0c872820f.png&quot; alt=&quot;4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四、上传代码到服务器&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;mkdir -p ~/sites/www.wangmeng.com&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;打开目录&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;cd ~/sites/www.wangmeng.com&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们的代码要在虚拟环境里运行，所以先创建虚拟环境&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;virtualenv --python=python3 env #env是虚拟环境名字，没必要和这里的一样&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;运行完以后执行 ls 命令，发现多了一个env文件夹，这就是我们要的虚拟环境目录:&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://i.loli.net/2018/04/21/5ada0f7c49244.png&quot; alt=&quot;5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五、拉取git代码&lt;br/&gt;下一步要把代码从github拉到服务器，git工具我们之前已经安装好了，执行命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;git clone https://github.com/barrywangmeng/blogProject.git&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;六、安装依赖&lt;br/&gt;现在代码已经成功放到服务器里了&lt;br/&gt;安装其他依赖&lt;br/&gt;首先&lt;strong&gt;进入虚拟环境&lt;/strong&gt;，在虚拟环境下打开django项目目录，由requirements.txt安装依赖。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;source env/bin/activate #进入虚拟环境&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd blogProject #进入项目目录&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install -r requirements.txt #安装依赖&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;七、后续操作&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;python manage.py collectstatic&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成数据库文件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;python manage.py migrate&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;创建超级用户(后台管理使用)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;python manage.py createsuperuser&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;配置nginx&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;deactivate #退出虚拟环境&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd /etc/nginx/sites-enabled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo rm -f default #删除默认配置文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd /etc/nginx/sites-available&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo rm -f default #删除默认配置文件&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;设置配置文件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo vim myblog.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;输入如下代码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;server {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;charset utf-8;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen 80;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server_name www.floweroman.com;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location /static {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alias /home/wangmeng/sites/www.floweroman.com/blogProject/static;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location /media {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alias /home/wangmeng/sites/www.floweroman.com/blogProject/media;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location / {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy_set_header Host $host;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;proxy_pass http://unix:/tmp/www.floweroman.com.socket;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;按ESC退出编辑，继续输入:wq，保存并退出文件&lt;/p&gt;
&lt;p&gt;八、激活网站&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo ln -s /etc/nginx/sites-available/myblog.conf /etc/nginx/sites-enabled/myblog.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;测试配置语法问题:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo service nginx configtest&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;重启nginx服务器:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sudo service nginx restart&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用gunicorn&lt;br/&gt;进入&lt;strong&gt;虚拟环境下&lt;/strong&gt;的blogProject(存放代码的目录)网站目录&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;cd /home/wangmeng/sites/www.wangmeng.com/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source env/bin/activate&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/04/21/5ada12ad479ed.png&quot; alt=&quot;6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装gunicorn:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;pip install gunicorn&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用gunicorn启动服务器进程:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;cd blogProject #先进入代码目录&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gunicorn --bind unix:/tmp/www.wangmeng.com.socket blogProject.wsgi:application #启动gunicorn&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;自动启动gunicorn:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;gunicorn --bind unix:/tmp/www.wangmeng.com.socket blogProject.wsgi:application&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，到了这里已经大功告成了！访问www.floweroman.com即可出现我们的博客首页了。&lt;/p&gt;
&lt;p&gt;大家如果有什么问题都可以问我。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Apr 2018 16:26:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-meng/p/8894821.html</dc:identifier>
</item>
<item>
<title>以太坊如何估计计算gas？ - 以太坊开发</title>
<link>http://www.cnblogs.com/helloworld2018/p/8894194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helloworld2018/p/8894194.html</guid>
<description>&lt;p class=&quot;BlogContent clearfix&quot;&gt;以太坊如何估计估算计算gas？Etherscan上transaction info中有个gas used by txn，结果跟remix给的结果以及geth中getTransactionReceipt的gasUsed给的结果都会是一致的，可以直接用geth或是remix模拟估算gas cost。&lt;/p&gt;
&lt;p&gt;之前一直没把这个问题搞清楚，所以干脆做个试验看一下．&lt;/p&gt;
&lt;p&gt;remix浏览器下方有个可执行的log页面，可以detail以及debug，非常方便。&lt;/p&gt;
&lt;p data-bjh-caption-id=&quot;cap-86316998&quot; data-bjh-caption-text=&quot;&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/845255/201804/845255-20180421001235562-1267289862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有gas cost的地方有两个地方，transaction cost以及 execution cost，這两个有什么不同呢？可以參考一下他们的&lt;a href=&quot;https://github.com/ethereum/browser-solidity/blob/1f574be113fc90c95541125d9f26d188a1bae2aa/src/universal-dapp.js#L343&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;简单说一下： transaction cost指的是将交易送至ethereum blockchain所耗费的cost，是基于data size的大小，部署合约时就是基于合约內容的大小． execution cost指的是虚拟机(VM)执行所需的cost，而在部署合约时，会去执行建構子以及一些初始化的工作．&lt;/p&gt;
&lt;p&gt;在这里做一个简单的合约试验：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;contract Test {

bytes32 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; tmp;

function test(

bytes32 input,

&lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; num

)

constant returns (bytes32){

bytes32 result &lt;/span&gt;=&lt;span&gt; input;

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++&lt;span&gt;) {

result &lt;/span&gt;=&lt;span&gt; sha3(result);

}

}

function &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(bytes32 input, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; num) {

tmp &lt;/span&gt;=&lt;span&gt; test(input, num);

} }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果直接呼叫constant function的话，因为是由本身节点去计算不会更改到区块链上的值，是不会消耗gas的，但是如果是由一个一般合约(非constant function call)去呼叫一个constant function的話，因为让矿工来计算constant function，所以会消耗gas．&lt;/p&gt;
&lt;p&gt;上面的简单合约中，我让test函数对第一个bytes32参数做sha3，第二个uint参数代表做几次loop，我分別对set函数和test函数带入10以及1000的参数，結果如下．&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set(“&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x63d7db5ce060b288ecf5390594d5969bc1a206ceeb24df31cffcc8876df5e44b”, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;10)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;transaction &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;30628execution&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;6988&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;set(“&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x63d7db5ce060b288ecf5390594d5969bc1a206ceeb24df31cffcc8876df5e44b”, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1000)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;transaction &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;196022&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;execution &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;172318&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;test(“&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x63d7db5ce060b288ecf5390594d5969bc1a206ceeb24df31cffcc8876df5e44b”, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;10)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;transaction &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;25663 (&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;only applies &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;when called &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;by a contract)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;execution &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;2023 (&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;only applies &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;when called &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;by a contract)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;test(“&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x63d7db5ce060b288ecf5390594d5969bc1a206ceeb24df31cffcc8876df5e44b”, &lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1000)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;transaction &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;191057(&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;only applies &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;when called &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;by a contract)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;hljs sql&quot;&gt;execution &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost:&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;167353(&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;cost &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;only applies &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;when called &lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;by a contract)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ps:用transaction cost减去execution cost的话1, 3得到23640，2, 4得到23704&lt;/p&gt;
&lt;p&gt;大致上就是这样一个过程．发现参数设定成1000时，也会造成transaction cost的提高．(初步猜想加上ps的计算：transaction cost中是已经包含了execution cost，一并计算在最后要支付给miner的fee，因为每个相减结果都差不多)&lt;/p&gt;
&lt;p&gt;另外geth的estimateGas的之所以会不太准确是因为一些不确定性的operator操作会不同，比如说，在一个contract中，若是blockhash的尾数是奇数，他就去执行会消耗大量gas的合约，反之则去执行hello world合约，所以他的gas cost很大的情况下是一半一半．&lt;/p&gt;
&lt;p&gt;所以永远要记得设定一个合理的gas limit来防止自己遭受恶意攻击．&lt;/p&gt;
&lt;p&gt;另外建议可以参考traceTransaction指令，可以看每一個opcode的gas cost． 为了要确认矿工处理transaction的情况，在ropsten testnet上做个简单的试验．首先在ropsten faucet上拿一点儿ether来玩，然后在metamask上送出交易，因为ropsten是模拟pow的环境，所以我相信应该会是正确的数字．&lt;/p&gt;
&lt;p&gt;重要的话再说一次结论：Etherscan上transaction info中有个gas used by txn，结果跟remix给的结果以及geth中getTransactionReceipt的gasUsed给的结果都会是一致的，以后可以直接用geth或是remix模拟估算gas cost．&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://t.cn/RmeEwxJ&quot; target=&quot;_blank&quot;&gt;以太坊DApp开发实战入门&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Apr 2018 16:10:00 +0000</pubDate>
<dc:creator>以太坊开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/helloworld2018/p/8894194.html</dc:identifier>
</item>
<item>
<title>浅谈SSRF漏洞 - Dgg大哥哥</title>
<link>http://www.cnblogs.com/dggsec/p/8894170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dggsec/p/8894170.html</guid>
<description>&lt;p&gt;&lt;span&gt;SSRF漏洞是如何产生的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有&lt;span&gt;可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面的话说的有点抽象，然后说一下我的理解（可能有理解错误的地方，希望大佬能留言告知一下）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 首先，我们要对目标网站的架构了解，脑子了要有一个架构图。比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正常用户访问网站的流程是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入A网站URL --&amp;gt; 发送请求 --&amp;gt; A服务器接受请求（没有过滤），并处理 --&amp;gt;返回用户响应&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【那网站有个请求是www.baidu,com/xxx.php?image=URL】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么产生SSRF漏洞的环节在哪里呢？&lt;span&gt;安全的网站应接收请求后，检测请求的合法性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产生的原因：服务器端的验证并没有对其请求获取图片的参数（image=）做出严格的过滤以及限制，导致A网站可以从其他服务器的获取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;www.baidu.com/xxx.php?image=www.abc.com/1.jpg&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们将www.abd.com/1.jpg换为与该服务器相连的内网服务器地址会产生什么效果呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果存在该内网地址就会返回1xx 2xx 之类的状态码，不存在就会其他的状态码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;终极简析: SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后&lt;strong&gt;&lt;span&gt;服务器以他的身份来访问其他服务器的资源&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SSRF漏洞的寻找（漏洞常见出没位置）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：个人觉得所有调外部资源的参数都有可能存在ssrf漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）分享：通过URL地址分享网页内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）转码服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）在线翻译&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）图片加载与下载：通过URL地址加载或下载图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）图片、文章收藏功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6）未公开的api实现以及其他调用URL的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7）从URL关键字中寻找&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;span&gt;　　&lt;/span&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;share&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;wap&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;url&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;link&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;src&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;source&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;target&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;u&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;3g&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;display&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;sourceURl&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;imageURL&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;xml plain&quot;&gt;domain&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SSRF漏洞的验证方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）因为SSRF漏洞是让服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的，从而来判断是否存在SSRF漏洞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 www.baidu.com/xxx.php?image=（地址）的就可能存在SSRF漏洞&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Apr 2018 15:33:00 +0000</pubDate>
<dc:creator>Dgg大哥哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dggsec/p/8894170.html</dc:identifier>
</item>
<item>
<title>Tesseract Ocr文字识别 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/8894145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/8894145.html</guid>
<description>&lt;p&gt;&lt;span&gt;Tesseract的OCR引擎最先由HP实验室于1985年开始研发，至1995年时已经成为OCR业内最准确的三款识别引擎之一。2005年，Tesseract由美国内华达州信息技术研究所获得，并求诸于Google对Tesseract进行改进、消除Bug、优化工作。Tesseract目前已作为开源项目发布在Google Project.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行环境：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;windows10 + python 3.6 + tesseract 4.0.0-beta.1&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;先看效果： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/172074/201804/172074-20180420232500317-1866617382.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/172074/201804/172074-20180420232525684-1100592059.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;448&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、安装python模块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;pip3 install pytesseract&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、安装tesseract orc&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;a href=&quot;https://github.com/UB-Mannheim/tesseract/wiki&quot;&gt;https://github.com/UB-Mannheim/tesseract/wiki&lt;/a&gt; 点击“tesseract-ocr-w64-setup-v4.0.0-beta.1.20180414.exe”下载安装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：安装的时候选中中文包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本人安装目录：C:\Users\Administrator\AppData\Local\Tesseract-OCR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用命令，查看版本号和支持语言：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;cd C:\Users\Administrator\AppData\Local\Tesseract-OCR tesseract -v tesseract --list-langs　　#查看Tesseract-OCR支持语言&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、配置tesseract运行文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C:\Python36\Lib\site-packages\pytesseract\pytesseract.py 找到文件：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;tesseract_cmd = 'tesseract'&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;修改为：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;tesseract_cmd = 'C:/Program Files (x86)/Tesseract-OCR/tesseract.exe'&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、代码识别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;from PIL import Image
import pytesseract

path = &quot;img\\text-img.png&quot;

text = pytesseract.image_to_string(Image.open(path), lang='chi_sim')
print(text)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;作为非常优秀的Ocr识别库，tesseract当然可以训练自己的数据模型，从而达到为我所用目的，后续文字会介绍如果训练自己的文字识别库。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Apr 2018 15:27:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/8894145.html</dc:identifier>
</item>
<item>
<title>11_Python的列表推导式_Python编程之路 - susmote</title>
<link>http://www.cnblogs.com/susmote/p/8894052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/susmote/p/8894052.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://www.susmote.com/zb_users/upload/2018/03/201803282155419945522.jpg&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一节我们结束了有关python的方法相关内容&lt;/p&gt;

&lt;h3&gt;这一节我们先来学习python的列表推导式&lt;/h3&gt;
&lt;p&gt;之前跟大家说过range方法的使用，在这里我就不做过多的解释了，如忘记了，请翻阅之前的介绍&lt;/p&gt;
&lt;p&gt;列表推导式，是Python内置的一种极其强大的生成list的表达式&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;如果要生成一个list [1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] 可以用 range(1 , 9)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [1]: list(range(1, 9))
Out[1]: [1, 2, 3, 4, 5, 6, 7, 8]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;非常简单操作，相信大家一定都会&lt;/p&gt;
&lt;p&gt;但我们要讲的并不是这个&lt;/p&gt;

&lt;h4&gt;所谓的列表推导式，就是指的轻量级的循环创建列表：&lt;/h4&gt;
&lt;p&gt;比如像下面的两个式子&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [2]: a = [i for  i in range(1,10)]

In [3]: a
Out[3]: [1, 2, 3, 4, 5, 6, 7, 8, 9]

In [4]: b = [10 for i in range(1, 10)]

In [5]: b
Out[5]: [10, 10, 10, 10, 10, 10, 10, 10, 10]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　批量生成了两个列表，第一个是一个有顺序的从1到9的列表，第二个是生成了9个相同的数字10&lt;/p&gt;
&lt;p&gt;简单讲一下这个列表推导式是怎么定义的&lt;/p&gt;
&lt;p&gt;首先忽略推导式中的第一个字符，也就是 i 和 10 ，看后面的一段语句，很显然，是一个循环语句，之前讲过循环语句的，这里不详细解释了&lt;/p&gt;
&lt;p&gt;然后再来观察最前面的字符，也就是列表中的元素，循环过的每一个都被作为列表的元素，如果你前面的字符是一个常数的话，那么就只需要考虑循环的次数，而不需要考虑循环的值&lt;/p&gt;

&lt;p&gt;接下来，我们继续来加强这个列表推导式的应用&lt;/p&gt;
&lt;h4&gt;通过判断语句筛选列表元素&lt;/h4&gt;
&lt;p&gt;比如下面这段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [6]: list_if = [i for i in range(1, 10) if i%2 == 0]

In [7]: list_if
Out[7]: [2, 4, 6, 8]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们在里面加了判断条件，以获取给定循环范围内的所有的偶数&lt;/p&gt;
&lt;p&gt;也就是说你可以在循环语句后面在加判断语句&lt;/p&gt;


&lt;p&gt;这个还不能算是入门，接下来我们继续来加强列表推导式的应用&lt;/p&gt;
&lt;h4&gt;多个for循环&lt;/h4&gt;
&lt;p&gt;2个for循环&lt;/p&gt;
&lt;p&gt;使用两个for循环语句，以获取二维列表&lt;/p&gt;
&lt;p&gt;代码如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;68&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [8]: muti_for_list = [(i ,j) for i in range(1, 5) for j in range (6, 10)]

In [9]: muti_for_list
Out[9]:
[(1, 6),
 (1, 7),
 (1, 8),
 (1, 9),
 (2, 6),
 (2, 7),
 (2, 8),
 (2, 9),
 (3, 6),
 (3, 7),
 (3, 8),
 (3, 9),
 (4, 6),
 (4, 7),
 (4, 8),
 (4, 9)]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个列表推导式在一些算法领域会有涉及，我们通过连续写两个for循环语句，然后在开始以一个（i, j）作为获取的对象，在这里要注意以下，他是按照顺序执行的&lt;/p&gt;

&lt;p&gt;三个for循环&lt;/p&gt;
&lt;p&gt;获取三维数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [10]: muti_for_list = [(x, y, z) for x in range(2) for y in range (2) for z in range(2)]

In [11]: muti_for_list
Out[11]:
[(0, 0, 0),
 (0, 0, 1),
 (0, 1, 0),
 (0, 1, 1),
 (1, 0, 0),
 (1, 0, 1),
 (1, 1, 0),
 (1, 1, 1)]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;原理基本和二维数组的生成差不多，所以就不做过多解释了&lt;/p&gt;


&lt;h4&gt;在多维数组中使用判断语句&lt;/h4&gt;
&lt;p&gt;虽然我们在前面已经讲了多维数组的创建，但为了加强这个的复杂度，我们继续加一些条件&lt;/p&gt;
&lt;p&gt;获取三维数组中每行组中元素都一样的数组 类似于下面这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
[(1, 1, 1),
 (2, 2, 2),
 (3, 3, 3)]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们通过代码来实现这个功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;65&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [12]: common_list = [(x, y, z) for x in range(10) for y in range (10) for z in range(10) if x == y and y == z]

In [13]: common_list
Out[13]:
[(0, 0, 0),
 (1, 1, 1),
 (2, 2, 2),
 (3, 3, 3),
 (4, 4, 4),
 (5, 5, 5),
 (6, 6, 6),
 (7, 7, 7),
 (8, 8, 8),
 (9, 9, 9)]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个并不难实现，无非就是加个判断条件&lt;/p&gt;

&lt;p&gt;列表推导式，就讲到这里，他还有很多种其他的用法，希望大家，自己去挖掘，去探索&lt;/p&gt;

&lt;p&gt;特克斯博客官网 www.susmote.com&lt;/p&gt;

</description>
<pubDate>Fri, 20 Apr 2018 15:01:00 +0000</pubDate>
<dc:creator>susmote</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/susmote/p/8894052.html</dc:identifier>
</item>
<item>
<title>进程间通信——管道 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/8886378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/8886378.html</guid>
<description>&lt;p&gt;&lt;span&gt;进程间通信方式主要分为 &lt;strong&gt;管道、SystemV IPC、 POSIX IPC&lt;/strong&gt;三大类，管道作为进程间通信的一大重要方式，平时应用当中十分广泛。于是这里就先简单整理了一些关于管道的用法和注意事项。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;匿名管道&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;管道是UNIX中最古老的进程间通信形式。通常将一个进程连接到另一个进程的一个数据流称为一个 “管道”。&lt;strong&gt;它本质上其实就是内核的一块缓存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道的限制：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;*&lt;/strong&gt;&lt;/span&gt; 大小有限制（一般是65536）&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;*&lt;/span&gt;半双工 （数据只能向一个方向流动）&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　&lt;span&gt;*&lt;/span&gt;&lt;/strong&gt;在有亲缘关系的进程间使用（父进程创建一个管道，两个子进程通过管道进行通信也行）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何创建管道？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　使用 &lt;span&gt;&lt;strong&gt;int pipe(int fds[2])&lt;/strong&gt;&lt;/span&gt; 函数创建一个无名管道     &lt;span&gt;//fds[0]代表读； fds[1] 代表写  ； 函数成功返回0， 错误返回错误代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 比如来创建一个管道来用于父子进程间通信：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cb47ee71-a012-488b-9890-aca71e39249d')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_cb47ee71-a012-488b-9890-aca71e39249d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cb47ee71-a012-488b-9890-aca71e39249d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cb47ee71-a012-488b-9890-aca71e39249d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cb47ee71-a012-488b-9890-aca71e39249d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父子进程间通信&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; fds[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个无名管道&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(pipe(fds) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;make pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     pid_t pid =&lt;span&gt; fork();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程写&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         close(fds[&lt;span&gt;0&lt;/span&gt;]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭读
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;sleep(1);&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         write(fds[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;change world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         close(fds[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父进程读&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         close(fds[&lt;span&gt;1&lt;/span&gt;]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭写&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; buf [&lt;span&gt;100&lt;/span&gt;] =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; r = read(fds[&lt;span&gt;0&lt;/span&gt;], buf, &lt;span&gt;100&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回读取的字节数&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r= %d, buf=%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, r, buf);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         close(fds[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; }过关到
&lt;/pre&gt;&lt;/div&gt;
管道实现父子进程通信&lt;/div&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180419233459662-1808035708.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 再来分析分析 &lt;strong&gt;ls -l | wc -l &lt;/strong&gt; 这种采用了管道的命令，&lt;span&gt;&lt;span&gt;假定子进程实现ls，父进程实现wc。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ls命令正常执行将结果集写出到stdout，但dup后，现在会写入管道的写端；wc –l 正常应该从stdin读取数据，dup后会从管道的fd[0]读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;


&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fds[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    if(pipe(fds) &amp;lt; 0){&lt;br/&gt;　　　　perror(&quot;make pipe&quot;);exit(1);&lt;br/&gt;};

    pid_t pid &lt;/span&gt;=&lt;span&gt; fork();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pid == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程写进管道 执行ls -l&lt;/span&gt;
        close(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        close(fds[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
        dup(fds[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);   &lt;span&gt; //让stdout指向fds[1]指向的file表&lt;/span&gt;
        execlp(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NULL);   &lt;span&gt;//实现将ls -l的结果写入管道&lt;/span&gt;&lt;/span&gt;
        close(fds[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }   
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父进程从管道读 执行wc -l&lt;/span&gt;
        close(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        close(fds[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
        dup(fds[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);   &lt;span&gt;//让stdin指向fds[0]指向file表&lt;/span&gt;
        close(fds[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]); &lt;/span&gt;
        execlp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, NULL);  &lt;span&gt;//从管道接收数据，执行wc -l命令&lt;/span&gt;
        exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180420203518205-529075886.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;336&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;不能让父进程执行 ls -l ,子进程执行 wc -l&lt;/strong&gt; 。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;这是因为程序的子进程将stdin重定向给管道，父进程执行ls -l 的结果集将通过管道写给子进程。若父进程在子进程打印wc的结果到屏幕之前被shell调用wait回收，shell就会先输出$提示符，最后&lt;span&gt;&lt;span&gt;程序都执行结束，shell还在阻塞等待用户输入。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（1） 读管道：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 1.管道中有数据，read返回实际读到的字节数。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　 2.管道中无数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;①管道写端被全部关闭，read返回0 (好像读到文件结尾)&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　② 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据抵达，此时会让出cpu资源)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（2） 写管道：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 管道&lt;strong&gt;读端全部&lt;/strong&gt;被关闭， 进程异常终止 (操作系统发出SIGPIPE信号)&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 管道&lt;strong&gt;读端没有&lt;/strong&gt;全部关闭：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　①管道已满，write阻塞。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　②管道未满，write将数据写入，并返回实际写入的字节数。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;命名管道&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/897073&quot; target=&quot;_blank&quot; data-lemmaid=&quot;897073&quot;&gt;数据通信&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;不同于匿名管道的是：&lt;/strong&gt;命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时&lt;strong&gt;给它指定一个名字&lt;/strong&gt;，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器来进程通信。使通过网络传输数据并不比同一计算机上两进程之间通信更困难，不过如果要同时和多个进程通信它就力不从心了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何创建？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;int mkfifo(const char* pathname, mode_t mod) &lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5f2a7e89-cf36-488c-871f-2e49566f4507')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5f2a7e89-cf36-488c-871f-2e49566f4507&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5f2a7e89-cf36-488c-871f-2e49566f4507&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5f2a7e89-cf36-488c-871f-2e49566f4507',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5f2a7e89-cf36-488c-871f-2e49566f4507&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命名管道创建&lt;/span&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;fcntl.h&amp;gt;


&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mkfifo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fifo_pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0777&lt;/span&gt;) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 
    {   
        perror(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;make pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }   
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;创建&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;read.c&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('56fbca63-807f-4e22-81ef-dba42b8f23fe')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_56fbca63-807f-4e22-81ef-dba42b8f23fe&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56fbca63-807f-4e22-81ef-dba42b8f23fe&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('56fbca63-807f-4e22-81ef-dba42b8f23fe',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56fbca63-807f-4e22-81ef-dba42b8f23fe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;fcntl.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fd; 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;80&lt;/span&gt;&lt;span&gt;];
    fd &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fifo_pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_RDONLY);

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {   
        read(fd, buf, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(buf)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读到buf里&lt;/span&gt;
        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf);
        sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }   
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;read.c&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;write.c&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('575e77da-d5d7-4f78-b607-eefc095146c9')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_575e77da-d5d7-4f78-b607-eefc095146c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_575e77da-d5d7-4f78-b607-eefc095146c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('575e77da-d5d7-4f78-b607-eefc095146c9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_575e77da-d5d7-4f78-b607-eefc095146c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;1&lt;/span&gt; #include&amp;lt;sys/types.h&amp;gt;
  &lt;span&gt;2&lt;/span&gt; #include&amp;lt;sys/stat.h&amp;gt;
  &lt;span&gt;3&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
  &lt;span&gt;4&lt;/span&gt; #include&amp;lt;unistd.h&amp;gt;
  &lt;span&gt;5&lt;/span&gt; #include&amp;lt;fcntl.h&amp;gt;
  &lt;span&gt;6&lt;/span&gt; 
  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; fd;
 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; s[]=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am from write.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     fd=open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fifo_pipe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, O_WRONLY);
 &lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
 &lt;span&gt;13&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
 &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;     {
 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         write(fd, s, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(s));
 &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;&lt;span&gt;     }
 &lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
 &lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;~     
&lt;/pre&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;write.c&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;

&lt;p&gt;           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180420220318408-382317959.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;一旦建立起联系，删掉管道名称文件进程间的通信也不会出现问题。&lt;/p&gt;

</description>
<pubDate>Fri, 20 Apr 2018 14:04:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/8886378.html</dc:identifier>
</item>
<item>
<title>python3+dlib人脸识别及情绪分析 - Andrew_qian</title>
<link>http://www.cnblogs.com/qsyll0916/p/8893790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qsyll0916/p/8893790.html</guid>
<description>&lt;h3&gt;一、介绍&lt;/h3&gt;
&lt;p&gt;我想做的是基于人脸识别的表情（情绪）分析。看到网上也是有很多的开源库提供使用，为开发提供了很大的方便。我选择目前用的比较多的dlib库进行人脸识别与特征标定。使用python也缩短了开发周期。&lt;/p&gt;
&lt;p&gt;官网对于dlib的介绍是：&lt;span&gt;Dlib包含广泛的机器学习算法。&lt;/span&gt;&lt;span&gt;所有的设计都是高度模块化的，快速执行，并且通过一个干净而现代的C ++ API，使用起来非常简单。&lt;/span&gt;&lt;span&gt;它用于各种应用，包括机器人技术，嵌入式设备，手机和大型高性能计算环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然应用都比较高大上，但是自己在PC上做个情绪分析的小软件还是挺有意思的。&lt;/p&gt;
&lt;p&gt;按照自己的想法与思路设计识别方式。目前也比较火的keras好像就是根据嘴型的变化作为情绪分析的一个指标。&lt;/p&gt;
&lt;p&gt;而我的想法是利用嘴的张开比例，眼睛的睁开程度，眉毛的倾斜角度作为情绪分析的三个指标。但是由于人与人长相的差异较大，五官的也是千差万别，再加上我的计算方法也比较简单。所以识别效率并不是很高。&lt;/p&gt;
&lt;p&gt;识别规则：&lt;/p&gt;
&lt;p&gt;1、嘴巴张开距离占面部识别框宽度的比例越大，说明情绪越激动，可能是非常开心，也可能是极度愤怒。&lt;/p&gt;
&lt;p&gt;2、眉毛上扬，17-21 或者 22-26 号特征点距离面部识别框顶部与识别框高度的比值越小，说明眉毛上扬越厉害，可表示惊讶、开心。眉毛的倾斜角度，开心时眉毛一般是上扬，愤怒时皱眉，同时眉毛下压的比较厉害。&lt;/p&gt;
&lt;p&gt;3、眯眼睛，人在开怀大笑的时候会不自觉的眯起眼睛，愤怒或者惊讶的时候会瞪大眼睛。&lt;/p&gt;
&lt;p&gt;系统缺点：不能捕捉细微表情的变化，只能大致的判断出人的情绪，开心、愤怒、惊讶、自然。&lt;/p&gt;
&lt;p&gt;系统优点：结构简单，易于上手。&lt;/p&gt;
&lt;p&gt;应用领域：微笑抓拍，捕捉瞬间的美好、缓解儿童自闭症、交互式游戏开发。&lt;/p&gt;
&lt;p&gt;由于人感情的复杂性，这些表情确实不能完完全全的代表一个人内心深处的情绪波动，如要提高判断的准确性，则需要心率检测、语音处理等综合评价。&lt;/p&gt;
&lt;h3&gt;二、开发环境搭建：&lt;/h3&gt;
&lt;p&gt;1、安装VS2015，因为最新版的dlib-19.10需要这个版本的vscode&lt;/p&gt;
&lt;p&gt;2、安装opencv（whl方式安装）：&lt;br/&gt;从pythonlibs下载需要的版本whl文件，比如（opencv_python?3.3.0+contrib?cp36?cp36m?win_amd64.whl）&lt;br/&gt;然后在本地使用pip install 安装。 注意文件位置下安装(如：C:\download\xxx.whl)&lt;/p&gt;
&lt;p&gt;3、安装dlib（whl方式安装）：&lt;br/&gt;在这里下载dlib的各种版本的whl文件，然后在根目录下打开cmd直接安装即可。&lt;br/&gt;但是为了学习使用dlib中的各种python实例程序，还是需要下载一个dlib的压缩包。&lt;br/&gt;直接访问dlib官网即可下载：http://dlib.net/ml.html&lt;/p&gt;
&lt;p&gt;dlib各种版本的whl文件：https://pypi.python.org/simple/dlib/&lt;/p&gt;
&lt;p&gt;4、如果想要使用人脸模型特征标定的话，还需要一个人脸面部形状预测器，这个可以通过自己的照片进行训练，也可以使用dlib作者给出的一个训练好的预测器：         &lt;/p&gt;
&lt;p&gt;点击下载：&lt;a href=&quot;http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2&quot; target=&quot;_blank&quot;&gt;http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;三、实施思路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1083998/201804/1083998-20180420203322068-1100749396.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;728&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四、具体步骤&lt;/h3&gt;
&lt;p&gt;首先是利用dlib进行人脸识别：)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; dlib
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; skimage &lt;span&gt;import&lt;/span&gt;&lt;span&gt; io

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用特征提取器get_frontal_face_detector&lt;/span&gt;
detector =&lt;span&gt; dlib.get_frontal_face_detector()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; dlib的68点模型，使用作者训练好的特征预测器&lt;/span&gt;
predictor = dlib.shape_predictor(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shape_predictor_68_face_landmarks.dat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图片所在路径&lt;/span&gt;
img = io.imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成dlib的图像窗口&lt;/span&gt;
win =&lt;span&gt; dlib.image_window()
win.clear_overlay()
win.set_image(img)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特征提取器的实例化&lt;/span&gt;
dets = detector(img, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人脸数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(dets))
&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; k, d &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(dets):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, k+1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;个人脸d的坐标：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, d.left(),
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, d.right(),
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, d.top(),
              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bottom:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, d.bottom())

        width &lt;/span&gt;= d.right() -&lt;span&gt; d.left()
        heigth &lt;/span&gt;= d.bottom() -&lt;span&gt; d.top()

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;人脸面积为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(width*heigth))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后实例化一个 shape_predictor 对象，使用dlib作者训练好人脸特征检测器，进行人脸的特征点标定。&lt;/p&gt;
&lt;p&gt;标定的时候使用opencv的circle方法，在特征点的坐标上面添加水印，内容就是特征点的序号和位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用预测器预测&lt;/span&gt;
        shape =&lt;span&gt; predictor(img, d)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标出68个点的位置&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(68&lt;span&gt;):
            cv2.circle(img, (shape.part(i).x, shape.part(i).y), &lt;/span&gt;4, (0, 255, 0), -1, 8&lt;span&gt;)
            cv2.putText(img, str(i), (shape.part(i).x, shape.part(i).y), cv2.FONT_HERSHEY_SIMPLEX, &lt;/span&gt;0.5, (255, 255, 255&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 显示一下处理的图片，然后销毁窗口&lt;/span&gt;
        cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;face&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, img)
        cv2.waitKey(0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，68个特征点的信息就获取到了，下面就需要跟根据这个68个特征点的坐标信息，进行综合 计算，作为每个表情的判断指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1083998/201804/1083998-20180420212212767-106464481.png&quot; alt=&quot;&quot; width=&quot;280&quot; height=&quot;255&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上面说到的我的判断指标，先计算嘴巴的张开比例，由于人离摄像头距离的远近，导致人脸识别框的大小不一，故选择比例来作为判断指标。&lt;/p&gt;
&lt;p&gt;在选择指标的标准数值之前，先对多个开心的人脸照片进行分析。计算开心时的嘴巴张卡比例的平均。&lt;/p&gt;
&lt;p&gt;下面是截取对人眉毛的数据处理方法，对左边眉毛上面的5个特征点进行线性拟合，拟合出一个一次函数直线，用拟合直线的斜率近似代表眉毛的倾斜程度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 眉毛&lt;/span&gt;
                    brow_sum = 0    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 高度之和&lt;/span&gt;
                    frown_sum = 0   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两边眉毛距离之和&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(17,21&lt;span&gt;):
                        brow_sum&lt;/span&gt;+=  (shape.part(j).y - d.top()) + (shape.part(j+5).y-&lt;span&gt; d.top())
                        frown_sum&lt;/span&gt;+= shape.part(j+5).x -&lt;span&gt; shape.part(j).x
                        line_brow_x.append(shape.part(j).x)
                        line_brow_y.append(shape.part(j).y)

                    self.excel_brow_hight.append(round((brow_sum&lt;/span&gt;/10)/self.face_width,3&lt;span&gt;))
                    self.excel_brow_width.append(round((frown_sum&lt;/span&gt;/5)/self.face_width,3&lt;span&gt;))
                    brow_hight[0]&lt;/span&gt;+= (brow_sum/10)/self.face_width       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 眉毛高度占比&lt;/span&gt;
                    brow_width[0]+= (frown_sum/5)/self.face_width       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 眉毛距离占比&lt;/span&gt;

                    tempx =&lt;span&gt; np.array(line_brow_x)
                    tempy &lt;/span&gt;=&lt;span&gt; np.array(line_brow_y)
                    z1 &lt;/span&gt;= np.polyfit(tempx, tempy, 1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拟合成一次直线&lt;/span&gt;
                    self.brow_k = -round(z1[0], 3)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 拟合出曲线的斜率和实际眉毛的倾斜方向是相反的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我计算了25个人脸的开心表情的嘴巴张开比例、嘴巴宽度、眼睛张开程度、眉毛倾斜程度，导入excel表格生成折线图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1083998/201804/1083998-20180420213618715-618078594.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;553&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过折线图能很明显的看出什么参数可以使用，什么参数的可信度不高，什么参数在那个范围内可以作为一个指标。&lt;/p&gt;
&lt;p&gt;同样的方法，计算人愤怒、惊讶、自然时的数据折线图。&lt;/p&gt;
&lt;p&gt;通过对多个不同表情数据的分析，得出每个指标的参考值，可以写出简单的表情分类标准：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分情况讨论&lt;/span&gt;
                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 张嘴，可能是开心或者惊讶&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; round(mouth_higth &amp;gt;= 0.03&lt;span&gt;):
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; eye_hight &amp;gt;= 0.056&lt;span&gt;:
                                cv2.putText(im_rd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amazing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (d.left(), d.bottom() + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.8&lt;span&gt;,
                                            (0, 0, &lt;/span&gt;255), 2, 4&lt;span&gt;)
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                                cv2.putText(im_rd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;happy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (d.left(), d.bottom() + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.8&lt;span&gt;,
                                            (0, 0, &lt;/span&gt;255), 2, 4&lt;span&gt;)

                        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有张嘴，可能是正常和生气&lt;/span&gt;
                        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.brow_k &amp;lt;= -0.3&lt;span&gt;:
                                cv2.putText(im_rd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;angry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (d.left(), d.bottom() + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.8&lt;span&gt;,
                                            (0, 0, &lt;/span&gt;255), 2, 4&lt;span&gt;)
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                                cv2.putText(im_rd, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (d.left(), d.bottom() + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.8&lt;span&gt;,
                                            (0, 0, &lt;/span&gt;255), 2, 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、实际运行效果：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1083998/201804/1083998-20180420214721143-1184410116.jpg&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;识别之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1083998/201804/1083998-20180420214736402-1918085480.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;完整项目代码：&lt;a href=&quot;https://gitee.com/Andrew_Qian/face/blob/master/from_video.py&quot; target=&quot;_blank&quot;&gt;https://gitee.com/Andrew_Qian/face/blob/master/from_video.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p class=&quot;csdn_top&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/tMb8Z9Vdm66wH68VX1/article/details/79102425&quot; target=&quot;_blank&quot;&gt;8种方法用Python实现线性回归，为你解析最高效选择&lt;/a&gt;；&lt;/p&gt;
&lt;p class=&quot;csdn_top&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/AdaminXie/p/8472743.html&quot; target=&quot;_blank&quot;&gt;利用python开发，借助Dlib库捕获摄像头中的人脸，进行实时人脸68个特征点标定；&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/news/43358/49-face-detection-api&quot; target=&quot;_blank&quot;&gt;49 款人脸检测/识别的API、库和软件&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Apr 2018 13:51:00 +0000</pubDate>
<dc:creator>Andrew_qian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qsyll0916/p/8893790.html</dc:identifier>
</item>
<item>
<title>webpack模块化管理和打包工具 - Winner.王</title>
<link>http://www.cnblogs.com/winner-one/p/8893625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/winner-one/p/8893625.html</guid>
<description>&lt;p&gt;&lt;span&gt;Webpack简介&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;webpack是当下最热门的前端资源模块化管理和打包工具。&lt;span&gt;它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;需要的时候再异步加载。通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;loader&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;模块系统的演进&amp;lt;script&amp;gt;标签&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script src=&quot;module1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;module2.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;libraryA.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;module3.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;window&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 对象中，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;不同模块的接口调用都是一个作用域中，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;a href=&quot;http://yuilibrary.com/&quot;&gt;YUI&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 库。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;这种原始的加载方式暴露了一些显而易见的弊端：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局作用域下容易造成变量冲突&lt;/li&gt;
&lt;li&gt;文件只能按照&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的书写顺序进行加载&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;开发人员必须主观解决模块和代码库的依赖关系&lt;/li&gt;
&lt;li&gt;在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;CommonJS规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;CommonJS 规范是为了解决 JavaScript 的作用域问题而定义的模块形式，可以使每个模块它自身的命名空间中执行。该规范的主要内容是，模块必须通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;module.exports&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 导出对外的变量&lt;/span&gt;&lt;/span&gt;或接口，通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;require()&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 来导入其他模块的输出到当前模块作用域中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;一个直观的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// moduleA.js
module.exports = function( value ){
    return value * 2;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; moduleB.js&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; multiplyBy2 = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./moduleA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = multiplyBy2(&lt;span&gt;4&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;AMD规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AMD（异步模块定义）是为浏览器环境设计的，因为 CommonJS 模块系统是同步加载的，当前浏览器环境还没有准备好同步加载模块的条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模块通过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;define&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 函数定义在闭包中，格式如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
define(id?: String, dependencies?: String[], factory: Function|Object);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是模块的名字，它是可选的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;factory&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值。&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一些用例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个名为&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;myModule&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的模块，它依赖&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;jQuery&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 模块：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-js&quot;&gt;define('myModule', ['jquery'], function($) {
    // $ 是 jquery 模块的输出
    $('body').text('hello world');&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-js&quot;&gt;}); // 使用 require(['myModule'], function(myModule) {});&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：在 webpack 中，模块名只有局部作用域，在 Require.js 中模块名是全局作用域，可以在全局引用。&lt;/p&gt;
&lt;p&gt;定义一个没有&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;id&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 值的匿名模块，通常作为应用的启动函数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
define(['jquery'], function($) {
    $('body').text('hello world');
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;AMD&lt;/span&gt;&lt;span&gt;也采用require()语句加载模块，但不同于CommonJS,他要求两个参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个参数[module]，是一个数组，里面的成员就是要加载的模块； 第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前，主要有两个Javascript库实现了AMD规范：&lt;strong&gt;&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&quot;https://github.com/cujojs/curl&quot;&gt;curl.js&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
　require(['math'], function (math) {
　　　　math.add(2, 3);
　　});
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;1203&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 什么是 Webpack&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;Webpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;1440302&quot;&gt;&lt;span&gt;Webpack 的特点&lt;/span&gt;&lt;/h3&gt;
&lt;h3 id=&quot;1440303&quot;&gt;代码拆分&lt;/h3&gt;
&lt;h3 id=&quot;1440304&quot;&gt;Loader&lt;/h3&gt;
&lt;h3 id=&quot;1440305&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;智能解析&lt;/span&gt;&lt;/h3&gt;
&lt;h3 id=&quot;1440306&quot;&gt;插件系统&lt;/h3&gt;
&lt;h3 id=&quot;1440307&quot;&gt;快速运行&lt;/h3&gt;
&lt;h2 id=&quot;1204&quot;&gt;&lt;span&gt;webpack基本使用&lt;/span&gt;&lt;/h2&gt;
&lt;div&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;创建项目根目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm init 或 npm init -y&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局安装&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install webpack -g&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;局部安装,在项目目录下安装&lt;/p&gt;
&lt;blockquote readability=&quot;7.5&quot;&gt;
&lt;p&gt;npm install webpack --save-dev&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;--save: 将安装的包的信息保存在package中&lt;br/&gt;--dev:开发版本,只是项目构建的时候使用,项目构建完成后并不依赖的文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果使用web开发工具,单独安装&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;npm install webpack-dev-server --save-dev&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;h3 id=&quot;1440402&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 基本使用&lt;/span&gt;&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先创建一个静态页面 index.html 和一个 JS 入口文件 entry.js：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- index.html --&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建entry.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// entry.js  : 在页面中打印出一句话
document.write('It works.')
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后编译 entry.js并打包到 bundle.js文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 使用npm命令  
webpack entry.js bundle.js
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1440403&quot;&gt;&lt;span&gt;使用模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1.创建模块module.js,在内部导出内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-js&quot;&gt;module.exports = 'It works from module.js'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在entry.js中使用自定义的模块&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-js&quot;&gt;//entry.js
document.write('It works.')
document.write(require('./module.js')) // 添加模块
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1440404&quot;&gt;&lt;span&gt;加载css模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1.安装css-loader&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install css-loader style-loader --save-dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.创建css文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//style.css
body { background: yellow; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.修改 entry.js：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;require(&quot;!style-loader!css-loader!./style.css&quot;) // 载入 style.css
document.write('It works.')
document.write(require('./module.js'))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1440405&quot;&gt;&lt;span&gt;创建配置文件webpack.config.js&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1.创建文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var webpack = require('webpack')

module.exports = {
  entry: './entry.js',
  output: {
    path: __dirname,
    filename: 'bundle.js'
  },
  module: {
    loaders: [
        //同时简化 entry.js 中的 style.css 加载方式：require('./style.css')
      {test: /\.css$/, loader: 'style-loader!css-loader'}
    ]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.修改 entry.js 中的 style.css 加载方式：require('./style.css')&lt;/p&gt;
&lt;p&gt;3.运行webpack&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在命令行页面直接输入webpack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1440406&quot;&gt;&lt;span&gt;插件使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1.插件安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//添加注释的插件
npm install --save-devbannerplugin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.配置文件的书写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var webpack = require('webpack')

module.exports = {
    entry: './entry.js',
    output: {
        path: __dirname,
        filename: 'bundle.js'
    },
    module: {
        loaders: [
            //同时简化 entry.js 中的 style.css 加载方式：require('./style.css')
            {
                test: /\.css$/,
                loader: 'style-loader!css-loader'
            }
        ],
        plugins: [
            //添加注释的插件
            new webpack.BannerPlugin('This file is created by zhaoda')
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.运行webpack&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 可以在bundle.js的头部看到注释信息
/*! This file is created by zhaoda */
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1440407&quot;&gt;&lt;span&gt;开发环境&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;webpack 

--progress : 显示编译的进度

--colors ：　带颜色显示，美化输出

--watch　：　开启监视器，不用每次变化后都手动编译
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;1728160701&quot;&gt;12.4.7.1. webpack-dev-server&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启服务,以监听模式自动运行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.安装包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install webpack-dev-server -g --save-dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.启动服务&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实时监控页面并自动刷新&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;webpack-dev-server --progress --colors
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1440408&quot;&gt;&lt;span&gt; 自动编译&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1.安装插件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install --save-dev html-webpack-plugin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.在配置文件中导入包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var htmlWebpackPlugin = require('html-webpack-plugin')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.在配置文件中使用插件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;plugins: [
        //添加注释的插件
        new webpack.BannerPlugin('This file is created by zhaoda'),
        //自动编译
        new htmlWebpackPlugin({
            title: &quot;index&quot;,
            filename: 'index.html', //在内存中生成的网页的名称
            template: './index.html' //生成网页名称的依据
        })
    ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.运行项目&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;webpack--save-dev&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Fri, 20 Apr 2018 13:00:00 +0000</pubDate>
<dc:creator>Winner.王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/winner-one/p/8893625.html</dc:identifier>
</item>
</channel>
</rss>