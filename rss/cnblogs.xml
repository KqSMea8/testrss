<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>shim 和 polyfill - yunser_blog</title>
<link>http://www.cnblogs.com/yunser/p/7629281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunser/p/7629281.html</guid>
<description>&lt;p&gt;在前端，有两个词经常被提及：shim 和 polyfill。最近在翻译文章时又遇到了 polyfill 这个词，准备把这两个概念理清楚。&lt;/p&gt;
&lt;p&gt;关于 JavaScript 的兼容性问题，通常有不同的解决方案。&lt;/p&gt;
&lt;p&gt;举个例子，旧版本的 IE 不支持标准的 XMLHttpRequest，但支持自家的 ActiveXObject 方法，对此有以下两种解决方案。&lt;/p&gt;
&lt;p&gt;jQuery 的做法是，把两种方法封装成 &lt;code&gt;$.ajax&lt;/code&gt; 函数。使用时，只要熟悉 &lt;code&gt;$.ajax&lt;/code&gt; 方法就可以了，不用考虑浏览器的兼容问题。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 伪代码&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;ajax&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(url) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (isIE) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;XMLHttpRequest&lt;/span&gt;(url)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;ActiveXObject&lt;/span&gt;(url)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一种方法是，判断浏览器是否支持 XMLHttpRequest，如果不支持，就用 ActiveXObject 实现一个功能跟 XMLHttpRequest 完全一样的函数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 伪代码&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;XMLHttpRequest) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    XMLHttpRequest &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(url) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;ActiveXObject&lt;/span&gt;(url)
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方法看似没什么太大的不同，都能解决跨浏览器的兼容问题。但如果你仔细思考，就会发现，这两种方法代表着两种不同思维方式。后者明显的思想更加先进。&lt;/p&gt;
&lt;p&gt;我们来看看这两种做法有什么不同。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;jQuery 没有遵循标准，这带来了一个学习成本的问题，我们需要学习这个函数的使用方法；而后者在使用上和标准 API 没什么不同，不存在学习成本。&lt;/li&gt;
&lt;li&gt;如果某天我们不需要兼容旧 IE 了，后者只要移除兼容代码就可以了，不用改动代码；而前者显然没有这个优势，需要重构代码。遵循标准的代码在维护性方面明显更好。&lt;/li&gt;
&lt;li&gt;后者还有个好处是，可以按需加载，只在旧浏览器上加载兼容代码。&lt;/li&gt;
&lt;li&gt;标准的代码在可移植性方面也更具优势。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们再来看看 shim 和 polyfill 的概念。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;shim 是一个库,它将一个新的 API 引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;polyfill 是 shim 的一种，它的 API 是遵循标准的。polyfill 的做法通常是：先检查浏览器是否支持某个标准 API，如果不支持，就使用旧的技术对浏览器做兼容处理，这样就可以在旧的浏览器上使用新的标准 API。&lt;/p&gt;
&lt;p&gt;但在实际情况下，我们一般说 shim，会特指它的 API 不是遵循标准的，与 polyfill 对立。&lt;/p&gt;
&lt;p&gt;上面介绍的两种方法，前者是 shim，而后者是 polyfill。polyfill 的设计理念更值得去推崇。&lt;/p&gt;
&lt;p&gt;理解了概念后，polyfill 的思想就能指导我们如何去设计 API。&lt;/p&gt;
&lt;p&gt;比如说，旧浏览器不支持 ES6 的 &lt;code&gt;Array.prototype.find&lt;/code&gt; 方法，我们想要在项目中使用 &lt;code&gt;Array.prototype.find&lt;/code&gt;，只要 polyfill 就行了，而不是封装一个新的方法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 应该这么做&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;find&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 而不是这么做&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;arrayFind&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;find&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，很多新的 API 的兼容性问题，网上已经有成熟的 polyfill 方案了，不必重复造轮子。&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 07:33:00 +0000</pubDate>
<dc:creator>yunser_blog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunser/p/7629281.html</dc:identifier>
</item>
<item>
<title>【Spring】高级装配 - leesf</title>
<link>http://www.cnblogs.com/leesf456/p/7629225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leesf456/p/7629225.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前面讲解了&lt;code&gt;bean&lt;/code&gt;的核心装配技术，其可应付很多中装配情况，但&lt;code&gt;Spring&lt;/code&gt;提供了高级装配技术，以此实现更为高级的&lt;code&gt;bean&lt;/code&gt;装配功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;高级装配&quot;&gt;高级装配&lt;/h2&gt;
&lt;h3 id=&quot;配置profile-bean&quot;&gt;配置profile bean&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;将所有不同&lt;code&gt;bean&lt;/code&gt;定义放置在一个或多个&lt;code&gt;profile&lt;/code&gt;中，在将应用部署到每个环境时，要确保对应的&lt;code&gt;profile&lt;/code&gt;处于&lt;code&gt;激活&lt;/code&gt;状态。如配置了如下数据源，并使用&lt;code&gt;profile&lt;/code&gt;注解定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;javaconfig配置profile&quot;&gt;JavaConfig配置profile&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;开发环境中的数据源配置&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package com.hust.grid.leesf.ch3;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.activation.DataSource;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Profile;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuratoin&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Profile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;dev&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DevelopmentProfileConcifg {
    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;(destroyMethod = &lt;span class=&quot;st&quot;&gt;&quot;shutdown&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DataSource &lt;span class=&quot;fu&quot;&gt;embeddedDataSource&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EmbeddedDatabaseBuilder&lt;/span&gt;()
            .&lt;span class=&quot;fu&quot;&gt;setType&lt;/span&gt;(EmbeddedDatabaseType.&lt;span class=&quot;fu&quot;&gt;H2&lt;/span&gt;)
            .&lt;span class=&quot;fu&quot;&gt;addScript&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classpath:schema.sql&quot;&lt;/span&gt;)
            .&lt;span class=&quot;fu&quot;&gt;addScript&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classpath:test-data.sql&quot;&lt;/span&gt;)
            .&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();
    }   
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;生产环境下的数据源配置&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package com.hust.grid.leesf.ch3;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.sql.DataSource;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Profile;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jndi.JndiObjectFactoryBean;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductionProfileConfig {
 
  &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;@Profile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;prod&quot;&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DataSource &lt;span class=&quot;fu&quot;&gt;jndiDataSource&lt;/span&gt;() {
    JndiObjectFactoryBean jndiObjectFactoryBean = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JndiObjectFactoryBean&lt;/span&gt;();
    jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;setJndiName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc/myDS&quot;&lt;/span&gt;);
    jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;setResourceRef&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
    jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;setProxyInterface&lt;/span&gt;(javax.&lt;span class=&quot;fu&quot;&gt;sql&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DataSource&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (DataSource) jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;getObject&lt;/span&gt;();
  }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;只有在&lt;code&gt;prod profile&lt;/code&gt;激活时，才会创建对应的&lt;code&gt;bean&lt;/code&gt;。在&lt;code&gt;Spring 3.1&lt;/code&gt;之前只能在类级别上使用&lt;code&gt;@Profile&lt;/code&gt;注解，从&lt;code&gt;Spring 3.2&lt;/code&gt;之后，可以从方法级别上使用&lt;code&gt;@Profile&lt;/code&gt;注解，与&lt;code&gt;@Bean&lt;/code&gt;注解一起使用，上述放在两个不同配置类可以转化为两个方法放在同一个配置类中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package com.hust.grid.leesf.ch3;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import javax.sql.DataSource;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Bean;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Configuration;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Profile;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.jndi.JndiObjectFactoryBean;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DataSourceConfig {
  
  &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;(destroyMethod = &lt;span class=&quot;st&quot;&gt;&quot;shutdown&quot;&lt;/span&gt;)
  &lt;span class=&quot;fu&quot;&gt;@Profile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;dev&quot;&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DataSource &lt;span class=&quot;fu&quot;&gt;embeddedDataSource&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EmbeddedDatabaseBuilder&lt;/span&gt;()
        .&lt;span class=&quot;fu&quot;&gt;setType&lt;/span&gt;(EmbeddedDatabaseType.&lt;span class=&quot;fu&quot;&gt;H2&lt;/span&gt;)
        .&lt;span class=&quot;fu&quot;&gt;addScript&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classpath:schema.sql&quot;&lt;/span&gt;)
        .&lt;span class=&quot;fu&quot;&gt;addScript&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classpath:test-data.sql&quot;&lt;/span&gt;)
        .&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();
  }

  &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;@Profile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;prod&quot;&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; DataSource &lt;span class=&quot;fu&quot;&gt;jndiDataSource&lt;/span&gt;() {
    JndiObjectFactoryBean jndiObjectFactoryBean = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JndiObjectFactoryBean&lt;/span&gt;();
    jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;setJndiName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc/myDS&quot;&lt;/span&gt;);
    jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;setResourceRef&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
    jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;setProxyInterface&lt;/span&gt;(javax.&lt;span class=&quot;fu&quot;&gt;sql&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DataSource&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (DataSource) jndiObjectFactoryBean.&lt;span class=&quot;fu&quot;&gt;getObject&lt;/span&gt;();
  }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：尽管配置类中配置了不同的&lt;code&gt;Profile&lt;/code&gt;，但只有规定的&lt;code&gt;profile&lt;/code&gt;激活时，对应的&lt;code&gt;bean&lt;/code&gt;才会被激活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;xml配置profile&quot;&gt;XML配置profile&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:jdbc=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/jdbc&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  xmlns:jee=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/jee&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:p=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jee&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jee/spring-jee.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jdbc&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/beans&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  profile=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dev&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;&amp;lt;jdbc:embedded-database&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;jdbc:script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:schema.sql&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;jdbc:script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:test-data.sql&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/jdbc:embedded-database&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;或者使用&lt;code&gt;beans&lt;/code&gt;元素定义多个&lt;code&gt;profile&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:jdbc=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/jdbc&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  xmlns:jee=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/jee&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:p=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;  xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jee&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jee/spring-jee.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jdbc&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/beans&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; profile=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dev&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;jdbc:embedded-database&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;jdbc:script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:schema.sql&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;jdbc:script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:test-data.sql&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/jdbc:embedded-database&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; profile=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;qa&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          destory-method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;close&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          p:url=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc:h2:tcp://dbserver/~/test&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          p:driverClassName=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.h2.Driver&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          p:username=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sa&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          p:password=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          p:initialSize=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;20&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;          p:maxActive=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
  
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; profile=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;prod&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;jee:jndi-lookup&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      jndi-name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc/myDatabase&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      resource-ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      proxy-interface=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;javax.sql.DataSource&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;三个&lt;code&gt;bean&lt;/code&gt;的&lt;code&gt;ID&lt;/code&gt;都是&lt;code&gt;dataSource&lt;/code&gt;，在运行时会动态创建一个&lt;code&gt;bean&lt;/code&gt;，这取决激活的哪个&lt;code&gt;profile&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;激活profile&quot;&gt;激活profile&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;依赖&lt;code&gt;spring.profiles.active&lt;/code&gt;和&lt;code&gt;spring.profiles.default&lt;/code&gt;两个属性确定哪个&lt;code&gt;profile&lt;/code&gt;处于激活状态，如果设置了&lt;code&gt;spring.profiles.active&lt;/code&gt;，那么其值用于确定哪个&lt;code&gt;profile&lt;/code&gt;是激活状态，如果未设置，则查找&lt;code&gt;spring.profiles.defaults&lt;/code&gt;的值；如果均未设置，则没有激活的&lt;code&gt;profile&lt;/code&gt;，只会创建那些没有定义在&lt;code&gt;profile&lt;/code&gt;中的&lt;code&gt;bean&lt;/code&gt;。如下是在&lt;code&gt;web.xml&lt;/code&gt;中设置&lt;code&gt;spring.profiles.default&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;web-app&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; version=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2.5&quot;&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;context-param&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;spring.profiles.default&lt;span class=&quot;kw&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;dev&lt;span class=&quot;kw&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/context-param&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;spring.profiles.default&lt;span class=&quot;kw&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;dev&lt;span class=&quot;kw&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;提供了&lt;code&gt;@ActiveProfiles&lt;/code&gt;注解启用&lt;code&gt;profile&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Runwith&lt;/span&gt;(SpringJUnit4ClassRunner.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;@ContextConfiguration&lt;/span&gt;(classes={PersistenceTestConfig.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;})
&lt;span class=&quot;fu&quot;&gt;@ActiveProfiles&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;dev&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; PersistenceTest {
    ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;条件化的bean&quot;&gt;条件化的bean&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;code&gt;@Conditional&lt;/code&gt;注解，如果给定条件计算结果为&lt;code&gt;true&lt;/code&gt;，那么创建&lt;code&gt;bean&lt;/code&gt;，否则不创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Condition&lt;/span&gt;(MagicExistsCondition.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; MagicBean &lt;span class=&quot;fu&quot;&gt;magicBean&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MagicBean&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;MagicExistsCondition&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package com.hust.grid.leesf.ch3;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.Condition;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.annotation.ConditionContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.core.type.AnnotatedTypeMetadata;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.ClassUtils;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MagicExistsCondition &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Condition {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;matches&lt;/span&gt;(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Environment env = context.&lt;span class=&quot;fu&quot;&gt;getEnvironment&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; env.&lt;span class=&quot;fu&quot;&gt;containsProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;magic&quot;&lt;/span&gt;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;处理自动装配的歧义性&quot;&gt;处理自动装配的歧义性&lt;/h3&gt;
&lt;p&gt;如下代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDessert&lt;/span&gt;(Dessert dessert) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dessert&lt;/span&gt; = dessert;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;Dessert&lt;/code&gt;为一个接口，其有多个子类。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Cake &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Dessert {}

&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Cookies &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Dessert {}

&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; IceCream &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Dessert {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;此时，会发现不止一个&lt;code&gt;bean&lt;/code&gt;可以匹配，&lt;code&gt;Spring&lt;/code&gt;会抛出异常，可以将某个&lt;code&gt;bean&lt;/code&gt;设置为首选的&lt;code&gt;bean&lt;/code&gt;或使用限定符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;标识首选bean&quot;&gt;标识首选bean&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用&lt;code&gt;Primary&lt;/code&gt;注解标识首选bean。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Primary&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; IceCream &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Dessert {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者使用xml配置首选bean&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;iceCream&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.dessertteater.IceCream&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      primary=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果配置多个首选&lt;code&gt;bean&lt;/code&gt;，那么也将无法工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;限定自动装配的bean&quot;&gt;限定自动装配的bean&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用&lt;code&gt;@Qualifier&lt;/code&gt;注解进行限定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Qualifier&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;iceCream&quot;&lt;/span&gt;)
pulbic &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDessert&lt;/span&gt;(Dessert dessert) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dessert&lt;/span&gt; = dessert;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;创建自定义限定符&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以为&lt;code&gt;bean&lt;/code&gt;设置自己的限定符，而不依赖将&lt;code&gt;bean ID&lt;/code&gt;作为限定符，在&lt;code&gt;bean&lt;/code&gt;的声明上使用&lt;code&gt;@Qualifier&lt;/code&gt;注解，其可以与&lt;code&gt;@Component&lt;/code&gt;组合使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Qualifier&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;cold&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; IceCream &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Dessert {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，使用如下。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Qualifier&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;cold&quot;&lt;/span&gt;)
pulbic &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDessert&lt;/span&gt;(Dessert dessert) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dessert&lt;/span&gt; = dessert;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;使用自定义的限定符注解&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果多个&lt;code&gt;bean&lt;/code&gt;都具备相同特性的话，那么也会出现问题，无法确定唯一&lt;code&gt;bean&lt;/code&gt;，如定义&lt;code&gt;@Cold&lt;/code&gt;注解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Target&lt;/span&gt;({ElementType.&lt;span class=&quot;fu&quot;&gt;CONSTRUCTOR&lt;/span&gt;, ElementType.&lt;span class=&quot;fu&quot;&gt;FIELD&lt;/span&gt;,
            ElementType.&lt;span class=&quot;fu&quot;&gt;METHOD&lt;/span&gt;, ElementType.&lt;span class=&quot;fu&quot;&gt;TYPE&lt;/span&gt;})
&lt;span class=&quot;fu&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.&lt;span class=&quot;fu&quot;&gt;RUNTIME&lt;/span&gt;)
#Qualifier
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;@interface&lt;/span&gt; Cold {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以使用如下注解进行定义&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Cold&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Creamy&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; IceCream &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Dessert {} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过自定义注解后，然后可以通过多个注解的组合确定唯一一个符合条件的&lt;code&gt;bean&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Cold&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Creamy&lt;/span&gt;
pulbic &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setDessert&lt;/span&gt;(Dessert dessert) {
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dessert&lt;/span&gt; = dessert;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;bean的作用域&quot;&gt;bean的作用域&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;默认情况下，&lt;code&gt;Spring&lt;/code&gt;上下文中所有&lt;code&gt;bean&lt;/code&gt;都是作为以单例形式创建的。但有时候需要多个不同的&lt;code&gt;bean&lt;/code&gt;实例，&lt;code&gt;Spring&lt;/code&gt;定义了多种作用域，包括：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;单例，整个应用中，只创建一个&lt;code&gt;bean&lt;/code&gt;实例。&lt;/li&gt;
&lt;li&gt;原型，每次注入或者通过&lt;code&gt;Spring&lt;/code&gt;应用上下文获取时，都会创建一个新的&lt;code&gt;bean&lt;/code&gt;实例。&lt;/li&gt;
&lt;li&gt;会话，在&lt;code&gt;Web&lt;/code&gt;应用中，为每个会话创建一个&lt;code&gt;bean&lt;/code&gt;实例。&lt;/li&gt;
&lt;li&gt;请求，在&lt;code&gt;Web&lt;/code&gt;应用中，为每个请求创建一个&lt;code&gt;bean&lt;/code&gt;实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用&lt;code&gt;@Scope&lt;/code&gt;注解确定&lt;code&gt;bean&lt;/code&gt;的作用域，如将如下&lt;code&gt;bean&lt;/code&gt;声明为原型。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Scope&lt;/span&gt;(ConfigurableBeanFactory.&lt;span class=&quot;fu&quot;&gt;SCOPE_PROTOTYPE&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; NotePad {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当使用xml文件配置时如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;notepad&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.hust.grid.leesf.Notepad&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      scope=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;prototype&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;使用会话和请求作用域&quot;&gt;使用会话和请求作用域&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在&lt;code&gt;Web&lt;/code&gt;应用中，可能需要实例化在会话和请求范围内共享的&lt;code&gt;bean&lt;/code&gt;，如电商网站，需要会话作用域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@Scope&lt;/span&gt;(
    value=WebApplicationContext.&lt;span class=&quot;fu&quot;&gt;SCOPE_SESSION&lt;/span&gt;,
    proxyMode=ScopedProxyMode.&lt;span class=&quot;fu&quot;&gt;INTERFACES&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ShoppingCart &lt;span class=&quot;fu&quot;&gt;cart&lt;/span&gt;() {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要将&lt;code&gt;ShoppingCart bean&lt;/code&gt;注入到单例&lt;code&gt;StoreService bean&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; StoreService {
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setShoppingCart&lt;/span&gt;(ShoppingCart shoppingCart) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;shoppingCart&lt;/span&gt; = shoppingCart;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;此时，由于&lt;code&gt;ShoppingCart&lt;/code&gt;是会话作用域，直到某个用户创建了会话后，才会出现&lt;code&gt;ShoppingCart&lt;/code&gt;实例，并且&lt;code&gt;Spring&lt;/code&gt;会注入一个代理至&lt;code&gt;StoreService&lt;/code&gt;中，这个代理与&lt;code&gt;ShoppingCart&lt;/code&gt;有相同的方法，当处理时需要将调用委托给会话作用域内真正的&lt;code&gt;ShoppingCart&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在xml中声明作用域代理&quot;&gt;在XML中声明作用域代理&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要使用&lt;code&gt;Spring aop&lt;/code&gt;命名空间的新元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cart&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.hust.grid.leesf.ShoppingCart&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      scope=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;session&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;aop:scoped-proxy&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上述情况会使用&lt;code&gt;CGLib&lt;/code&gt;创建目标类的代理，但也可将&lt;code&gt;proxy-target-class&lt;/code&gt;属性设置为&lt;code&gt;false&lt;/code&gt;，进而要求它生成基于接口的代理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cart&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.hust.grid.leesf.ShoppingCart&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;      scope=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;session&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;aop:scoped-proxy&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; proxy-target-class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为使用&lt;code&gt;&amp;lt;aop:scoped-proxy&amp;gt;&lt;/code&gt;元素，需要在XML中声明&lt;code&gt;spring-aop.xsd&lt;/code&gt;命名空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;运行时值注入&quot;&gt;运行时值注入&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不使用硬编码注入，想让值在运行时确定，&lt;code&gt;Spring&lt;/code&gt;提供了如下两种方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;属性占位符&lt;/li&gt;
&lt;li&gt;Spring表达式语言&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注入外部的值&quot;&gt;注入外部的值&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;声明属性源并通过&lt;code&gt;Spring&lt;/code&gt;的&lt;code&gt;Environment&lt;/code&gt;来检索属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
...
&lt;span class=&quot;fu&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@PropertySource&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;classpath:/com/hust/gird/leesf/app.properties&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ExpressiveConfig {
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    Environment env;
    
    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BlankDisc &lt;span class=&quot;fu&quot;&gt;disc&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BlankDisc&lt;/span&gt;(
            env.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;disc.title&quot;&lt;/span&gt;),
            env.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;disc.artist&quot;&lt;/span&gt;));
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过在&lt;code&gt;app.properties&lt;/code&gt;中配置对应的属性完成注入。还可使用占位符完成注入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BlankDisc&lt;/span&gt;(
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${disc.title}&quot;&lt;/span&gt;) String title,
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${disc.artist}&quot;&lt;/span&gt;) String artist) {
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;title&lt;/span&gt; = title; 
  &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;artist&lt;/span&gt; = artist;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为使用占位符，需要配置&lt;code&gt;PropertySourcesPlaceholderConfigurer&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; PropertySourcesPlaceholderConfigurer &lt;span class=&quot;fu&quot;&gt;placeholderConfigurer&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;PropertySourcesPlaceholderConfigurer&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;或者在XML配置文件中使用&lt;code&gt;&amp;lt;context:property-placeholder /&amp;gt;&lt;/code&gt;，这样会生成一个&lt;code&gt;PropertySourcesPlaceholderConfigurer&lt;/code&gt;的&lt;code&gt;bean&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇学习了更为高级的装配技巧，如&lt;code&gt;Spring profile&lt;/code&gt;，还有条件化装配&lt;code&gt;bean&lt;/code&gt;，以及&lt;code&gt;bean&lt;/code&gt;的作用域等等。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 05 Oct 2017 07:08:00 +0000</pubDate>
<dc:creator>leesf</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leesf456/p/7629225.html</dc:identifier>
</item>
<item>
<title>electron入门心得 - 不止前端</title>
<link>http://www.cnblogs.com/buzhiqianduan/p/7620099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buzhiqianduan/p/7620099.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前端开发桌面程序这个概念已经出现有一段时间了，这项技术也已经走向成熟，Github上nw和光electron的star就差不多有10w颗星了，github也衍生出了很多开源的桌面项目俨然成了一个热门项目。既然这么热，那就一个字：学。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要帮助js基础比较薄弱，又没有接触过electron的同学更好的学习electron，文中有什么不足之处或者错误，欢迎指出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-74024ea32b3e3fcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;electron&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;electron-安装&quot;&gt;electron 安装&lt;/h2&gt;
&lt;p&gt;npm命令安装electron库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install electron --save-dev --save-exact&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://github.com/electron/electron&quot;&gt;electron官方Github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何快速上手electron&quot;&gt;如何快速上手electron&lt;/h2&gt;
&lt;p&gt;刚接触一个新东西，难免一头雾水，如果多看一点相关的文章势必会有一个方向感，去更好的上手新东西。上手electron，官方提供了一个非常好的快速上手实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/electron/electron-quick-start
cd electron-quick-start
npm install
npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个仓库给我们初始化了一个electron项目，结构非常纯净，克隆下来你就可以直接改造成自己的项目。&lt;/p&gt;
&lt;h2 id=&quot;electron-api&quot;&gt;electron API&lt;/h2&gt;
&lt;p&gt;官方api（英文） &lt;a href=&quot;https://electron.atom.io/docs/&quot;&gt;官方docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译API（版本有偏差）&lt;a href=&quot;https://www.w3cschool.cn/electronmanual/&quot;&gt;翻译版docs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;国内也有翻译版的API文档，但是不能保证是最新的，使用时一定要看好自己的版本和翻译版。使用翻译版API。同时可以看看官方的更新日志，看看有什么新功能。官方社区有很多有用的工具，开始学习欠务必了解，涉及到项目开发调试和项目构建。这里推荐一个仓库，这个仓库收录了一些比较常用的API，克隆后跑起来你就可以快速查看这些常用API&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/fuchao2012/zh-cn-Electron-API-Demos
 cd zh-cn-Electron-API-Demos
 npm install
 npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;electron项目和web项目的区别&quot;&gt;electron项目和web项目的区别&lt;/h2&gt;
&lt;p&gt;electron核心我们可以分成2个部分，主进程和渲染进程。主进程连接着操作系统和渲染进程，可以把她看做页面和计算机沟通的桥梁。渲染进程就是我们所熟悉前端环境了。只是载体改变了，从浏览器变成了window。传统的web环境我们是不能对用户的系统就行操作的。而electron相当于node环境，我们可以在项目里使用所有的node api 。&lt;/p&gt;
&lt;p&gt;简单理解：&lt;br/&gt;给web项目套上一个node环境的壳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-7739aa2716b4d03d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目结构&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;相比web项目，桌面项目多了一个进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目迁移&quot;&gt;项目迁移&lt;/h2&gt;
&lt;p&gt;如果要迁移项目到web端，就需要把项目中的electron提供的API和node的API完全剥离出来，只能遗留web的代码，比如 node fs模块，electron提供ipc 模块，都需要剥离。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你一开始就打算双端程序，在开始写代码时应该对web代码和elecctron的代码进行分离，以便后期的迁移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目开发打包工具&quot;&gt;项目开发打包工具&lt;/h2&gt;
&lt;p&gt;这里推荐devtron 和 electron-builder 2个开发工具，配置简单，功能强大。这里不详细介绍工具的使用。官方都有非常好的文档。&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;http://www.cnblogs.com/buzhiqianduan/p/7620099.html&quot;&gt;devtron&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://github.com/electron-userland/electron-builder&quot;&gt;electron-builder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;社区还有很多好用的工具，可以自行查阅，选择使用。&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://electron.atom.io/community/&quot;&gt;community&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps： electron打包的时候需要下载一个版本库，速度会非常慢，可以通过淘宝镜像源解决&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;就是在你的命令前加ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/及空格

$ ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron/ npm run build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-139fe7596e20afeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;打包问题&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Electron介绍差不多就到这里，框架有了。然而一大堆配置头都晕了，从0-1非常困难，我们不妨从1到0，可以先找个模版做个小demo感受一下electron的魅力，在做项目中学习electron。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://github.com/chentsulin/electron-react-boilerplate&quot;&gt;react模版&lt;/a&gt;     &lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://github.com/SimulatedGREG/electron-vue&quot;&gt;vue模版&lt;/a&gt;     &lt;/p&gt;
&lt;h2 id=&quot;electron-vue经验分享&quot;&gt;electron-vue经验分享&lt;/h2&gt;
&lt;p&gt;官方文档中作者提供了很多对开发有用的东西，我推荐学习的同学都通读一遍&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://simulatedgreg.gitbooks.io/electron-vue/content/cn/getting_started.html&quot;&gt;electron-vue文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;electron-vue，作者为我们封装好了一个基于vue框架的脚手架，包括electron所有基本的开发构建工具 和vue配套的请求，路由以及vuex等插件。&lt;br/&gt;通过脚手架我们可以直接进入开发阶段，开发的同时，去了解electron的工作机制，之后再开始深入去理解她更深层次的代码逻辑。 先走形，再走心。&lt;/p&gt;
&lt;h3 id=&quot;不迁移项目就可以打包双版本的可行方案&quot;&gt;不迁移项目就可以打包双版本的可行方案&lt;/h3&gt;
&lt;p&gt;作者并未提供web开发的支持，但是提供了非常好的web打包支持。&lt;br/&gt;只要写好逻辑我们可以不用迁移项目就可以打包桌面项目和web项目。&lt;/p&gt;
&lt;p&gt;process.env.IS_WEB是暴露的一个全局变量，我们可以在渲染进程中获取，项目在electron环境下，返回false。否则为true。于此，我们可以通过设置她的值来达到web dev的效果，也可以处理不同环境的不同逻辑，一些示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-cae045ed68c41067.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-e8f7f6ac49fdf050.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-a48751e6cf2d88e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;示例3&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;打开新窗口的最佳做法&quot;&gt;打开新窗口的“最佳”做法&lt;/h3&gt;
&lt;p&gt;因为是webpack配置，入口只有index.html ，所以打开新窗口，一般会再配置一个入口。其实还有一种更佳的做法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 主进程 定义好监听事件 
ipc.on('newPage', function(e) {
    const modalPath = process.env.NODE_ENV === 'development'
        ? 'http://localhost:9080/#/newPage'
        : `file://${__dirname}/index.html#newPage`
    let win = new BrowserWindow({
        width: 1024,
        height: 724,
        webPreferences: {
            webSecurity: false
        }
    })
    win.on('close', function() {
        win = null
    })
    win.loadURL(modalPath)

})

&amp;gt;&amp;gt;&amp;gt; router/index.js   定义路由
// import 你的新页面  .vue 文件
 {
            path: '/newPage',
            name: 'newPage',
            component: newPage,  
        }

》》》配置完成 任意进程调用ipc.send('newPage')   完美解决
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;页面之间的数据共享问题&quot;&gt;页面之间的数据共享问题&lt;/h3&gt;
&lt;p&gt;electron项目可以通过本地数据库去做一个数据存储，这样你就可以在任何需要的地方调用这份数据。我的做法：&lt;/p&gt;
&lt;p&gt;1.首先选择一个 本地数据库插件 ，我用的 &lt;a href=&quot;https://github.com/louischatriot/nedb#creatingloading-a-database&quot;&gt;nedb&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 新建db.js
import Datastore from 'nedb'
import path from 'path'
import { remote } from 'electron'

const db = {
    tableData: new Datastore({filename: path.join(remote.app.getPath('userData'), '/tableData.db')}),
    chartData: new Datastore({filename: path.join(remote.app.getPath('userData'), '/chartData.db')}),
    cfgData: new Datastore({filename: path.join(remote.app.getPath('userData'), '/cfgData.db')}),
}

export default {
    db
}

&amp;gt;&amp;gt;&amp;gt;&amp;gt;  引入数据库
/**
 *  本地数据库导入
 *  web模式注释该代码
 */
import db from '../db'
Vue.prototype.$db = db.db

&amp;gt;&amp;gt;&amp;gt;&amp;gt; 任意页面调用数据库
  this.$db.chartData.loadDatabase();
  this.$db.chartData.find({},  (err, docs)=&amp;gt; {
//                            console.log(docs);
                            if(docs &amp;amp;&amp;amp; docs.length &amp;gt; 0){
                                this.totalOptionList = docs;
                            }
                        });&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;根据自己的习惯选择数据库，我自己对mongodb数据库比较熟悉，所以采用了nedb。语法糖类似，基本直接拿来就能用，不需要再次学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;最后说一些可以帮助你更好学习electron的基础知识：&lt;/p&gt;
&lt;p&gt;webpack： 最强构建工具，没有之一，了解webpack，你才能更好编写项目配置。&lt;/p&gt;
&lt;p&gt;node： electron是搭载谷歌v8内核的高性能的node环境 ，所有node能用的东西，我们都能用。是不是很酸爽？&lt;/p&gt;
&lt;p&gt;奉上一个demo项目，简单的相册程序。还有一个项目涉及公司，代码就不好上了，只能分享经验。&lt;/p&gt;
&lt;p&gt;传送门: &lt;a href=&quot;https://github.com/xu455255849/Electron-manka&quot;&gt;相册Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得本文对你有所帮助，就star一下吧～大传送之术！ &lt;a href=&quot;https://github.com/xu455255849/myBlog&quot;&gt;我的博客Github&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 06:25:00 +0000</pubDate>
<dc:creator>不止前端</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buzhiqianduan/p/7620099.html</dc:identifier>
</item>
<item>
<title>Vuforia开发完全指南（四）--- Image Target - PowerFlame</title>
<link>http://www.cnblogs.com/powerflame/p/7629138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powerflame/p/7629138.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;在Vuforia提供的SDK中，最简单、也是最常见的AR功能就是Image Target---图像识别。你只需提供一张可识别的图片，将图片移到设备的摄像头下，设备上就能出现之前已经集成进去的虚拟场景，而且可以根据ARCamera的不同模式，让图片和虚拟场景的叠加现象有所不同。这篇文章详细讲解了Vuforia中基于Image Target的AR产品开发流程，学完之后你就能开发出一个基于图片的AR App。&lt;/p&gt;
&lt;h2 id=&quot;演示demo&quot;&gt;演示Demo&lt;/h2&gt;
&lt;p&gt;这是笔者做的一个简单的冰与火之歌的AR Demo，基于Vuforia Image Target。&lt;br/&gt;&lt;a href=&quot;https://v.qq.com/x/page/k0557z1x02n.html&quot;&gt;点击观看&lt;/a&gt;&lt;br/&gt;视频地址：&lt;a href=&quot;https://v.qq.com/x/page/k0557z1x02n.html&quot; class=&quot;uri&quot;&gt;https://v.qq.com/x/page/k0557z1x02n.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;工欲善其事，必先利其器。首先我们要做的是准备好工具，这里采用Unity作为开发工具，演示在iOS设备上，因此还需要Mac系统和Xcode。进行开发的第一步就是要下载Vuforia的SDK，登上Vuforia官网进入开发者平台下载Unity的SDK包，完成之后将package导入到Unity中。然后就要登录License Manager和Target Manager创建App的license，以及上传需要扫描的图片。关于License Manager和Target Manager，已经在之前的教程中详细讲过了，可以参考一下。&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/powerflame/p/7596473.html&quot;&gt;Vuforia开发完全指南（三）---License Manager和Target Manager详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是在License Manager中创建license key，然后进入Target Manger创建Database，上传需要扫描的图片。这里在点击Add Target之后选择的类型是Device，然后输入相关参数。上传成功后就可以下载图片SDK，导入到Unity中。&lt;/p&gt;
&lt;h2 id=&quot;功能开发&quot;&gt;功能开发&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;打开Unity工程，在Project面板中找到Vuforia文件夹，将其Prefabs文件夹中的ARCamera拖到Unity场景中，之后删掉场景中之前默认的Camera。&lt;/li&gt;
&lt;li&gt;将Prefabs文件夹中的ImageTarget拖到场景中，这个是Vuforia用来专门进行图像识别的工具。&lt;br/&gt;&lt;img src=&quot;http://ouvsr6js4.bkt.clouddn.com/vuforia-4-1.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击场景中的ARCamera，在其选项面板中点击“Open Vuforia configuration”，将之前创建的license key复制到“App License Key”输入框中。然后在下面的Datasets中，勾选住之前创建的database以及其“Activate”选项，将database激活。&lt;/li&gt;
&lt;li&gt;点击场景中的ImageTarget，在其选项面板的“Image Target Behaviour”组件中，在Database和Image Target选中对应的名字。&lt;/li&gt;
&lt;li&gt;将想要展现的3D模型拖入到场景中，并将其作为ImageTarget的子物体。这样，已经完成了最简单的AR图像识别，如果你现在编译工程在设备上运行，将识别图放到摄像头取景范围内，模型就能出来了，并随着识别图的位置改变而改变。但是如果想要加入更多的交互功能，就要用代码来控制。&lt;/li&gt;
&lt;li&gt;点击场景中的ImageTarget，在其属性面板中可以看到已经挂了一个脚本“Default Trackable Event Handler”，在这个脚本里我们就能对AR场景中的物体进行控制，当图片被成功识别时做什么，当图片消失时又会做什么。&lt;br/&gt;&lt;img src=&quot;http://ouvsr6js4.bkt.clouddn.com/vuforia-4-2.png&quot;/&gt;&lt;br/&gt;在这个脚本中需要关注两个函数：OnTrackingFound()和OnTrackingLost()函数。其中OnTrackingFound会在图片被识别后调用，OnTrackingLost会在被识别的图片从摄像头取景范围内消失后调用。这两个函数的定义如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;        private void OnTrackingFound()
        {
            Renderer[] rendererComponents = GetComponentsInChildren&amp;lt;Renderer&amp;gt;(true);
            Collider[] colliderComponents = GetComponentsInChildren&amp;lt;Collider&amp;gt;(true);

            // Enable rendering:
            foreach (Renderer component in rendererComponents)
            {
                component.enabled = true;
            }

            // Enable colliders:
            foreach (Collider component in colliderComponents)
            {
                component.enabled = true;
            }

            Debug.Log(&quot;Trackable &quot; + mTrackableBehaviour.TrackableName + &quot; found&quot;);
        }


        private void OnTrackingLost()
        {
            Renderer[] rendererComponents = GetComponentsInChildren&amp;lt;Renderer&amp;gt;(true);
            Collider[] colliderComponents = GetComponentsInChildren&amp;lt;Collider&amp;gt;(true);

            // Disable rendering:
            foreach (Renderer component in rendererComponents)
            {
                component.enabled = false;
            }

            // Disable colliders:
            foreach (Collider component in colliderComponents)
            {
                component.enabled = false;
            }

            Debug.Log(&quot;Trackable &quot; + mTrackableBehaviour.TrackableName + &quot; lost&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个函数的最后都有一行Debug.Log的打印，里面有mTrackableBehaviour.TrackableName这个变量。这个变量就是之前在Target Manager中上传图片后，导入到图片SDK的图片名字。还记得在上传图片时需要输入的那个名字字符串么？mTrackableBehaviour.TrackableName这个变量就和那个名字字符串是一样的，因此我们可以在代码中利用这个变量来判断是哪张图片被识别，继而控制场景中的物体。&lt;/p&gt;
&lt;p&gt;在这个例子中，笔者在场景中加了一个红龙Dragon的模型，还加了一个附带几个按钮的Canvas，用来控制这个红龙的动作。在Default Trackable Event Handler脚本中，将Dragon和Canvas声明为public变量，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public GameObject dragon;
public GameObject canvas;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将场景中的Dragon和Canvas拖入到脚本中的物体框。然后在OnTrackingFound()函数中添加当图像被识&lt;br/&gt;别后，对Dragon和Canvas的控制代码，这里只是简单的让两者出现，注意这里对图片的名字进行了判断，虽说工程中只有这一张图片，但是当需要识别多张图片时，就必须通过ImageTarget中的图像名称来判断识别出的是哪张图片。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (mTrackableBehaviour.TrackableName == &quot;Dragon&quot;)
{
    dragon.SetActive(true);
    canvas.SetActive(true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，在OnTrackingLost()函数中通过对mTrackableBehaviour.TrackableName的判断，来让Dragon和Canvas消失。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (mTrackableBehaviour.TrackableName == &quot;Dragon&quot;)
{
    dragon.SetActive(false);
    canvas.SetActive(false);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Canvas中对Dragon控制的按钮脚本代码就不贴出来了，大家可以通过自己的需求加上很多酷炫和实用的功能。&lt;/p&gt;
&lt;p&gt;当代码检查无误后，就能编译工程，拷进设备进行AR体验了。大家可以看到使用Vuforia的Image Target功能，无需很复杂的代码就能做出非常酷炫的AR程序。&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 06:16:00 +0000</pubDate>
<dc:creator>PowerFlame</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/powerflame/p/7629138.html</dc:identifier>
</item>
<item>
<title>AngularJS 路由精分 - 吃鱼大神-孙立政</title>
<link>http://www.cnblogs.com/sunlizheng/p/7629116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunlizheng/p/7629116.html</guid>
<description>&lt;h3 id=&quot;1涉及到的服务与指令&quot;&gt;① 涉及到的服务与指令&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;$routeProvider 用来定义路由表，我们会用到里面的when和otherwise两个方法。&lt;/li&gt;
&lt;li&gt;$routeParams 用来保存地址栏中的参数，也提供了通配某类地址的能力。&lt;/li&gt;
&lt;li&gt;$location 用来分析处理url。&lt;/li&gt;
&lt;li&gt;$ng-view 用来指定加载模板视图的区域。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2locationpath详解&quot;&gt;② $location.path()详解&lt;/h3&gt;
&lt;p&gt;如果没有参数，返回当前路径，即#号后的内容；也可以传入字符串，将当前路径修改为字符串的内容，并触发路由变化。 &lt;br/&gt;假设当前url：&lt;span&gt;http://localhost:63342/RouteDemo/index.html#/&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//返回'/'
$location.path(); 
//将当前url修改为:http://localhost:63342/RouteDemo/index.html#/music
$locaiton.path('/music'); 
//返回'/music'
$locaiton.path();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;3when及otherwise详解&quot;&gt;③ when及otherwise详解&lt;/h3&gt;
&lt;p&gt;when方法能够接收两个参数，第一个参数是路由路径，这个路径会与$location.path()的值进行匹配，如果没有任何一个when方法匹配到，那么将会执行otherwise方法。第二个参数是配置对象，它的六个属性分别是controller,template,templateUrl,resolve,redirectTo,reloadOnSearch。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;controller &lt;br/&gt;该属性值可以是一个字符串，也可以是一个函数。如果是字符型，则会搜索相应的控制器，如果是函数，那么该函数代表控制器(可以用controllerAs为控制器命名或起别名）。控制器会与路由所创建的作用域关联在一起，并且转到该路径时都会执行一次控制器中的内容。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次路径变为/music触发路由变化时都会执行一次控制器中的内容&lt;/span&gt;
app.config(['$routeProvider',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($routeProvide) {
    $routeProvide.when(&lt;/span&gt;'/music'{templateUrl:&quot;myMusic.html&quot;,controller:&quot;myController&quot;&lt;span&gt;})           
}]);
app.controller(&lt;/span&gt;'myController',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($scope) {
    console.log(&lt;/span&gt;&quot;123&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;controllerAs &lt;br/&gt;给controller属性值代表的控制器起个别名，以便之后引用。&lt;/li&gt;
&lt;li&gt;template &lt;br/&gt;值是一个字符串，代表一个Html模板，AngularJS会拿该模板来渲染。&lt;/li&gt;
&lt;li&gt;templateUrl &lt;br/&gt;值是一个字符串，代表一个存着Html模板的路径，AngularJS会拿该路径下的Html模板来渲染。&lt;/li&gt;
&lt;li&gt;resolve &lt;br/&gt;值是一个对象，该对象属性名是可以注入到控制器的依赖，属性值可包含下列内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有当resolve对象里所有promise对象执行完毕后才会注入到控制器，此时才会发生路由变化，因此可以解决页面闪烁问题（加载页面后才获取到数据去更新视图）。我们来看看对比，下面这个例子控制器注入的a是自定义的myService服务，注入的b则是从服务器端获取到的数据。 &lt;br/&gt;test.html代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是测试界面 {{ name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-repeat&lt;/span&gt;&lt;span&gt;=&quot;name in list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ name }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;ng-href&lt;/span&gt;&lt;span&gt;=&quot;#/test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngRoute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
        app.value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        app.config([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$routeProvider&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($routeProvide) {
            $routeProvide
                .when(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{templateUrl:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    controller:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($scope,a,b) {
                        $scope.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;a;
                        $scope.list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; b.data;
                    },
                    resolve:{
                        a:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        b:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($http,$timeout) {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; promise &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;  $timeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; $http.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:3000/person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise;
                    }
            }});
        }]);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果直接在控制器而不是resolve中请求，则index.html代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;ng-href&lt;/span&gt;&lt;span&gt;=&quot;#/test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngRoute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
        app.value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        app.config([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$routeProvider&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($routeProvide) {
            $routeProvide
                    .when(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{templateUrl:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    controller:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($scope,$http,$timeout,a) {
                        $scope.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;a;
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; promise &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;  $timeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; $http.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:3000/person&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        },&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
                        promise.then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(response) {
                            $scope.list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; response.data;
                        });
                    },
                    resolve:{
                        a:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    }});
        }]);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两者效果如下，可以看到写在控制器中的代码不仅需要自己处理逻辑（控制器不推荐写太复杂的逻辑）从promise的success function中取得repsonse参数，而且页面加载不一致，服务器获取的数据在获得后才加载，而在resolve中写，只有等promise执行完毕后才会跳转，然后同步加载整个页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205843/201710/1205843-20171005140523208-996901116.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;- redirectTo &lt;br/&gt;值是一个字符串或一个函数，该属性写在otherwise中，代表着在when中找不到相应路径时的重定向。如果是字符串，路径会被替换成该值，如果是函数，它有三个参数，第一个是当前路径的路由参数，第二个是当前路径，第三个当前Url的查询串，路径会被替换成该函数的返回值，替换后都会触发路由变化。 &lt;br/&gt;- reloadOnSearch &lt;br/&gt;值是一个布尔值，为true的时候$location.search()发生变化时就会重新加载路由，location.search是从当前URL的?号开始（包括?号）的字符串。&lt;/p&gt;
&lt;h3 id=&quot;4routeparams&quot;&gt;④ $routeParams&lt;/h3&gt;
&lt;p&gt;我们可以在路由参数的前面加上:号，AngularJS会把它解析出来并传递给$routeParams。 &lt;br/&gt;　　下面的例子中我们将123456传给value，AngularJS把其解析出来，在$routeParams中添加一个名为value的键，值为123456，我们可以将该服务注入到控制器中使用。 &lt;br/&gt;　　test.html代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;我是测试界面 {{ display }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;ng-href&lt;/span&gt;&lt;span&gt;=&quot;#/test/123456&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;测试&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ng-view&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ngRoute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
        app.config([&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$routeProvider&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($routeProvide) {
            $routeProvide
                .when(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/:value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{templateUrl:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    controller:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;($scope,$routeParams) {
                        $scope.display &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $routeParams.value;
                }});
        }]);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205843/201710/1205843-20171005140511052-786015888.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;5路由事件&quot;&gt;⑤ 路由事件&lt;/h3&gt;

&lt;p&gt;$route服务在路由过程中的每个阶段都会触发不同的事件，可以为这些事件设置监听器并做出响应。路由事件都是系统自动从$rootScope广播下去的，我们最好的做法是在$rootScope中监听，而最佳设置的地方就是run方法，可以保证不会漏掉任何路由变化。 &lt;br/&gt;　　下面是四种不同的路由事件。&lt;/p&gt;

</description>
<pubDate>Thu, 05 Oct 2017 06:14:00 +0000</pubDate>
<dc:creator>吃鱼大神-孙立政</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunlizheng/p/7629116.html</dc:identifier>
</item>
<item>
<title>JavaWeb（一）Servlet中的ServletConfig与ServletContext - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7629099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7629099.html</guid>
<description>
&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;　　前面我介绍了一下什么是servlet，它的生命周期，执行过程和它的原理。这里我们做一个简单的回顾！&lt;/p&gt;
&lt;p&gt;　　什么是Servlet？&lt;/p&gt;
&lt;p&gt;　　servlet 是&lt;span&gt;运行在 Web 服务器中的小型 Java 程序&lt;/span&gt;（即：服务器端的小应用程序）。servlet &lt;span&gt;通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　执行过程：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005110745521-1496380199.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　生命周期：　　&lt;/p&gt;
&lt;p&gt;　　　　实例化--&amp;gt;初始化--&amp;gt;服务-&amp;gt;销毁&lt;br/&gt;　　　　出生：（实例化--&amp;gt;初始化）第一次访问Servlet就出生（默认情况下）&lt;br/&gt;　　　　活着：（服务）应用活着，servlet就活着&lt;br/&gt;　　　　死亡：（销毁）应用卸载了servlet就销毁。&lt;/p&gt;
&lt;p&gt;　　如何让servlet在服务器启动时就创建：&lt;/p&gt;
&lt;p&gt;　　　　在web.xml中的servlet标签里面配置一个load-on-startup来设置&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005111622083-1230970393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们要说的是Servlet的四个类：&lt;/p&gt;
&lt;p&gt;　　ServletConfig对象，ServletContext对象、request对象，response对象&lt;/p&gt;
&lt;p&gt;从图中我们可以知道这几个对象之间的联系！&lt;/p&gt;

&lt;h2&gt;1.1、获取ServletConfig对象&lt;/h2&gt;
&lt;p&gt;　　1）使用初始化方法获得一个ServletConfig对象&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005112514224-1921035089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）通过继承父类（GenericServlet）的方法得到一个ServletConfig对象　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ServletConfig config = &lt;span&gt;this&lt;/span&gt;.getServletConfig();
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2、ServletConfig对象作用&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005112833849-1981242425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1）getServletName();  //获取servlet的名称，也就是我们在web.xml中配置的servlet-name&lt;/p&gt;
&lt;p&gt;　　2）getServletContext(); //获取ServletContext对象，该对象的作用看下面讲解&lt;/p&gt;
&lt;p&gt;　　3）getInitParameter(String); //获取在servlet中初始化参数的值。这里&lt;span&gt;注意与全局初始化参数的区分。这个获取的只是在该servlet下的初始化参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005113142599-855194468.png&quot; alt=&quot;&quot; width=&quot;627&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）getInitParameterNames(); //获取在Servlet中&lt;span&gt;所有初始化参数的名字，也就是key值，可以通过key值，来找到各个初始化参数的value值&lt;/span&gt;。注意返回的是枚举类型&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005113339880-224486853.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　在Servlet类中&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005122202943-1265024262.png&quot; alt=&quot;&quot; width=&quot;865&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　结果&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005122306833-934924471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：在上面我们所分析的源码过程中，我们就知道，其实可以&lt;span&gt;不用先获得ServletConfig，然后在获取其各种参数，可以直接使用其方法&lt;/span&gt;，比如上面我们用的ServletConfig().getServletName();&lt;/p&gt;
&lt;p&gt;　　　　　　可以直接&lt;span&gt;写成getServletName();而不用在先获取ServletConfig();了，原因就是在GenericServlet中，已经帮我们获取了这些数据，我们只需要直接拿就行&lt;/span&gt;。　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　String value = &lt;span&gt;this&lt;/span&gt;.getInitParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wolf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); 
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.1、获取ServletContext对象&lt;/h2&gt;
&lt;p&gt;　　1）getServletContext();&lt;/p&gt;
&lt;p&gt;　　2）getServletConfig().getServletContext();&lt;/p&gt;
&lt;p&gt;　　这两种获取方式的区别就跟上面的解释一样，第一种是直接拿，&lt;span&gt;在GenericServlet中已经帮我们用getServletConfig().getServletContext();拿到了ServletContext&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　我们只需要直接获取就行了，第二种就相当于我们自己在获取一遍，两种读是一样的。&lt;/p&gt;
&lt;h2&gt;2.2、ServletContext对象作用&lt;/h2&gt;
&lt;p&gt;　　tomcat为每个web项目都&lt;span&gt;创建一个ServletContext实例&lt;/span&gt;，tomcat在启动时创建，服务器关闭时销毁，在一个web项目中&lt;span&gt;共享数据，管理web项目资源，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为整个web配置公共信息等&lt;/span&gt;，通俗点讲，就是&lt;span&gt;一个web项目，就存在一个ServletContext实例，每个Servlet读可以访问到它&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　1）web项目中共享数据&lt;/p&gt;
&lt;p&gt;　　　　在一定范围内（当前应用），使多个Servlet共享数据&lt;/p&gt;
&lt;p&gt;　　　　getAttribute(String name)、setAttribute(String name, Object obj)、removeAttribute(String name)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005124713536-1635414455.png&quot; alt=&quot;&quot; width=&quot;459&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.1）setAttribute(String name, Object obj) 在&lt;span&gt;web项目范围内存放内容，以便让在web项目中所有的servlet读能访问到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.2）getAttribute(String name) 通过指定名称获得内容&lt;/p&gt;
&lt;p&gt;　　　　1.3）removeAttribute(String name) 通过指定名称移除内容 &lt;/p&gt;
&lt;p&gt;　　　　实例：&lt;/p&gt;
&lt;p&gt;　　　　　　我们在Servlet_demo_0010中写：　　　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　this&lt;/span&gt;.getServletContext().setAttribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　然后我们在Servlet_demo_0020中看能不能获取到：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005123956005-563567662.png&quot; alt=&quot;&quot; width=&quot;777&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　得到了adc&lt;/p&gt;
&lt;p&gt;　　2）获取全局配置信息&lt;/p&gt;
&lt;p&gt;　　　　整个web项目初始化参数 （这个就是全局初始化参数，每个Servlet中都能获取到该初始化值）&lt;/p&gt;
&lt;p&gt;　　　　2.1）getInitPatameter(String name)　　//通过指定名称获取初始化值&lt;/p&gt;
&lt;p&gt;　　　　2.2）getInitParameterNames()　　//获得枚举类型&lt;/p&gt;
&lt;p&gt;　　　　web.xml 配置 整个web项目的初始化&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005125042833-2103872882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005125232115-1490482393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005125313708-2146002746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）获取web项目资源&lt;/p&gt;
&lt;p&gt;　　　　3.1）获取web项目下指定资源的路径：getServletContext().getRealPath(&quot;/WEB-INF/web.xml&quot;)&lt;/p&gt;
&lt;p&gt;　　　　　　String  getRealPath(String path);//根据&lt;span&gt;资源名称得到资源的绝对路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005132220521-1588413525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005132156911-1454450096.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　应用：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005134430349-1475040936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005134554880-844164277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.2）获取web项目下指定资源的内容，返回的是字节输入流。InputStream getResourceAsStream(java.lang.String path)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005132349208-693827660.png&quot; alt=&quot;&quot; width=&quot;872&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结果的一部分：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005132906802-1464568423.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;161&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.3）getResourcePaths(java.lang.String path)  指定路径下的所有内容。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005133549365-1678180528.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005133749865-1961325071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.4）实现servlet的转发&lt;/p&gt;
&lt;p&gt;　　　　　　 RequestDispatcher  getRequestDispatcher(String path) ;//参数表示要跳转到哪去&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171005134731177-1690822187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 05 Oct 2017 05:53:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7629099.html</dc:identifier>
</item>
<item>
<title>Docker入门之四搭建私有仓库 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/7629054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/7629054.html</guid>
<description>&lt;p&gt;前面学习了下镜像和容器，今天来学习下仓库，来搭建本地私有仓库。当然可以使用远程的共有的仓库，但在企业中有的还是放在本地，所以需要搭建私有仓库。&lt;/p&gt;
&lt;p&gt;一、搭建仓库&lt;/p&gt;
&lt;p&gt;可以在容器中run一个仓库镜像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 docker run -d -p &lt;span&gt;5000&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt; -v /opt/data/registry:/tmp/registry registry
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171005125406490-1781868118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以使用docker ps查看容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171005125557536-182164451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、给待上传镜像设置tag&lt;/p&gt;
&lt;p&gt;下面给busybox设置tag，然后可以看到images中有该tag的image。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker tag busybox &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/busyboxdocker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171005125741130-586120885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、上传到仓库&lt;/p&gt;
&lt;p&gt;使用push将镜像上传到仓库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker push  &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;5000&lt;/span&gt;/busyboxdocker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171005125954583-1590270247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四、安全问题&lt;/p&gt;
&lt;p&gt;其实上传到仓库是要求用https的，只是这里我设置了下docker 的Daemon。不然是不能提交的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171005130143583-1272061036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/733213/201710/733213-20171005130643349-2009669590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 05:07:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/7629054.html</dc:identifier>
</item>
<item>
<title>UI自动化测试（四）AutoIT工具使用和robot对象模拟键盘按键操作 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/7629039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/7629039.html</guid>
<description>&lt;p&gt;AutoIt 目前最新是v3版本，这是一个使用类似BASIC脚本语言的免费软件，它设计用于Windows GUI(图形用户界面)中进行自动化操作。它利用模拟键盘按键，鼠标移动和窗口/控件的组合来实现自动化任务。而这是其它语言不可能做到或无可靠方法实现的(例如VBScript和SendKeys)。&lt;/p&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;p&gt;使用AutoIT下的工具去定位页面外的元素属性值，其次再利用AutoIT下的工具编写合适的脚本，然后将脚本编译成可执行文件，最后在自动化实现时，直接调用此脚本实现文件的上传、下载等操作。&lt;/p&gt;
&lt;p&gt;备注：定位元素、编写脚本和编译，需要借助AutoIT提供的工具，但是脚本编译成可执行文件后，可以直接使用。&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;https://www.autoitscript.com/site/autoit/downloads/&quot; target=&quot;_blank&quot;&gt;https://www.autoitscript.com/site/autoit/downloads/&lt;/a&gt;&lt;a href=&quot;https://www.autoitscript.com/site/autoit/&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开网页，点击如下图所示按钮，即可下载：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005115302911-186052898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AutoIT的安装&lt;/p&gt;
&lt;p&gt;安装很简单，一路默认路径就好，安装成功后，在开始菜单可看到如下图所示界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005115435146-1879830415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.AutoIT Window Info用来识别Windows控件，根据识别的控件信息编写脚本；x86为32位&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.SciTE Script Editor用来写脚本，并保存为au3格式&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3.Complie Script to .exe， 将刚编写的脚本，编译成可执行文件；&lt;/p&gt;
&lt;p&gt;4.编译后在java代码中中调用&lt;/p&gt;
&lt;p&gt;想必介绍到这，或多或少有所了解了，对AutoIT工具下的功能点也清楚了，Run Script是运行脚本的，我们是要到java代码中调用，所以此处就略过了。&lt;/p&gt;

&lt;p&gt;接下来就用一个实例来讲解下AutoIT工具的具体使用，实例功能是：把百度首页中的百度图片另存为到本地或任意磁盘&lt;/p&gt;
&lt;p&gt;在做这个事情的时候，我们要知道，步骤是先要选中图片，并右击，选择另存为，然后输入文件名以及保存的位置，最后点击保存。人工操作鼠标很简单，但现在是要使用代码来实现该功能，可细化分为三步，如下：&lt;/p&gt;
&lt;p&gt;1.使用Selenium功能弹出右键菜单&lt;/p&gt;
&lt;p&gt;2.利用robot选择相关菜单&lt;/p&gt;
&lt;p&gt;3.调用AutoIT实现另存为操作&lt;/p&gt;
&lt;p&gt;4.到java代码中调用&lt;/p&gt;
&lt;p&gt;实现第一步，在浏览器中定位到图片元素，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
WebElement img = driver.findElement(By.cssSelector(&quot;div#lg img&quot;&lt;span&gt;));
Actions action &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions(driver);
action.contextClick().perform();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现第二步，模拟键盘操作，鼠标移到另存为处，使用robot对象，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Robot robot = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Robot();
robot.keyPress(KeyEvent.VK_DOWN);
Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
robot.keyPress(KeyEvent.VK_DOWN);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;VK_DWON是&lt;/span&gt;操作按钮向下按一下的意思，因为另存为在右键菜单中的第二行，所以需要向下按两下实现&lt;/p&gt;
&lt;p&gt;实现上述两步代码后，会弹出如下所示框，让输入文件名以及保存路径，该对话框已经是页面外的元素了，使用普通的定位时定不到了，所以就需要使用AutoIT工具来实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005121158568-360058785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现第三步，操作如下：&lt;/p&gt;
&lt;p&gt;①打开autoit工具包下的AutoIT Window Info（x64）工具，版本按自己电脑系统来，界面如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005121500677-1722172068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.1鼠标点中Finder Tool并拖动到输入文件名处，操作如下所示，得到下图结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005121549286-2078677723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2重复上述定位步骤，定位保存按钮，结果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005121644443-866174299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②元素定位到了，接下来就是使用AutoIT工具包下的SciTE Script Editor写脚本，并保存为au3格式，注意：此工具中；表注释&lt;/p&gt;
&lt;p&gt;根据定位到的参数值，写如下脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
ControlFocus(&quot;另存为&quot;, &quot;&quot;,&quot;Edit1&quot;&lt;span&gt;)
WinWait(&lt;/span&gt;&quot;[CLASS:#32770]&quot;,&quot;&quot;,10&lt;span&gt;)&lt;br/&gt;;文件路径
ControlSetText(&lt;/span&gt;&quot;另存为&quot;, &quot;&quot;, &quot;Edit1&quot;, &quot;d:\baidu.png&quot;&lt;span&gt;)
Sleep(&lt;/span&gt;2000&lt;span&gt;)
ControlClick(&lt;/span&gt;&quot;另存为&quot;, &quot;&quot;,&quot;Button2&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;代码解释：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第一行：ControlFocus ( &quot;title&quot;, &quot;窗口文本&quot;, controlID) 设置输入焦点到指定窗口的某个控件上；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第二行：WinWait ( &quot;title题&quot; , &quot;窗口文本&quot; , 超时时间 ) 暂停脚本的执行直至指定窗口存在（出现） 为止；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第三行：；表注释&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第四行：ControlSetText ( &quot;title&quot;, &quot;窗口文本&quot;, controlID, &quot;新文本&quot; ) 修改指定控件的文本；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第五行：Sleep ( 延迟 ) 使脚本暂停指定时间段；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第六行：ControlClick ( &quot;title&quot;, &quot;窗口文本&quot;, 控件ID , 按钮 , 点击次数 ) 向指定控件发送鼠标点击命令；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;其中， title即AutoIt Window Info识别出的Title字段， controlID即AutoItWindow Info识别出的Class和Instance的拼接， 如上图拼接后的结果应为：Button2。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;③使用AutoIT工具包下的Complie Script to .exe工具把刚编写的脚本编译成可执行文件，操作如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005122219365-2123020081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行上步骤后，会出现baidu.exe可执行文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;第四步，到java代码中调用该可执行文件，操作代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Runtime.getRuntime().exec(&quot;d:/baidu.exe&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行java代码，在定义的路径下会看到已保存的百度图片，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171005122556177-1159846985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体代码实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.AWTException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.Robot;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.event.KeyEvent;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.interactions.Actions;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test_demo_autoit {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         driver.get(&quot;https://www.baidu.com/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         WebElement move = driver.findElement(By.cssSelector(&quot;div#lg img&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         Actions action = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions(driver);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        action.contextClick(move).perform();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         Robot robot = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Robot();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        robot.keyPress(KeyEvent.VK_DOWN);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        robot.keyPress(KeyEvent.VK_DOWN);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        robot.keyPress(KeyEvent.VK_ENTER);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         
&lt;span&gt;32&lt;/span&gt;         Runtime.getRuntime().exec(&quot;d:/baidu.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt;         
&lt;span&gt;35&lt;/span&gt;         
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将百度首页中的图片另存为还有一个实现方法，不用robot对象，直接在AutoIT编写脚本中发送个V，因为选择另存为和按V是一样的作用，AutoIT编写脚本代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
send(&quot;v&quot;&lt;span&gt;)
Sleep(&lt;/span&gt;1000&lt;span&gt;)
ControlFocus(&lt;/span&gt;&quot;另存为&quot;, &quot;&quot;,&quot;Edit1&quot;&lt;span&gt;)
WinWait(&lt;/span&gt;&quot;[CLASS:#32770]&quot;,&quot;&quot;,10&lt;span&gt;)
ControlSetText(&lt;/span&gt;&quot;另存为&quot;, &quot;&quot;, &quot;Edit1&quot;, &quot;d:\baidu.png&quot;&lt;span&gt;)
Sleep(&lt;/span&gt;2000&lt;span&gt;)
ControlClick(&lt;/span&gt;&quot;另存为&quot;, &quot;&quot;,&quot;Button2&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在java代码中实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.interactions.Actions;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_autoit1 {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         driver.get(&quot;https://www.baidu.com/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         WebElement move = driver.findElement(By.cssSelector(&quot;div#lg img&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Actions action = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Actions(driver);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        action.contextClick(move).perform();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Runtime.getRuntime().exec(&quot;d:/baidu.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在禅道中上传附件，从实例一中已明白整个操作过程，因而在该实例中便只介绍下页面外元素定位以及java代码实现。&lt;/p&gt;
&lt;p&gt;页面外元素定位，编写脚本代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
ControlFocus(&quot;打开&quot;, &quot;&quot;,&quot;Edit1&quot;&lt;span&gt;)
WinWait(&lt;/span&gt;&quot;[CLASS:#32770]&quot;,&quot;&quot;,10&lt;span&gt;)
ControlSetText(&lt;/span&gt;&quot;打开&quot;, &quot;&quot;, &quot;Edit1&quot;, &quot;F:\new\UI\测试.pdf&quot;&lt;span&gt;)
Sleep(&lt;/span&gt;2000&lt;span&gt;)
ControlClick(&lt;/span&gt;&quot;打开&quot;, &quot;&quot;,&quot;Button1&quot;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;java代码实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_au {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         driver.get(&quot;http://127.0.0.1/zentao/my/&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         driver.findElement(By.id(&quot;account&quot;)).sendKeys(&quot;admin&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         driver.findElement(By.name(&quot;password&quot;)).sendKeys(&quot;123456&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击登录&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         driver.findElement(By.xpath(&quot;//button[@id='submit']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         Thread.sleep(2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击测试&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         driver.findElement(By.linkText(&quot;测试&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击Bug&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         driver.findElement(By.linkText(&quot;Bug&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击提交Bug&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         driver.findElement(By.xpath(&quot;//a[@href='/zentao/bug-create-5-0-moduleID=0.html']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用AutoIT工具&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         Runtime.getRuntime().exec(&quot;d:/chandao/chandao.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         Thread.sleep(5000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，使用AutoIT工具时进行自动化脚本运行时，要把杀毒软件关掉，不然会影响，误判是病毒&lt;/p&gt;

&lt;p&gt;在前一篇中说到的键盘事件，是使用Actions类，但实现效果不明显，所以用Robot类，创建robot对象来实现，效果很好，话不多说，直接上代码。&lt;/p&gt;
&lt;p&gt;代码实现如下，仅供参考：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.Robot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.event.KeyEvent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_robot_mouse {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         WebElement ctr1=driver.findElement(By.cssSelector(&quot;#kw&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         ctr1.sendKeys(&quot;12306&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下ctrl+F4&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         Robot robot = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Robot();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        robot.keyPress(KeyEvent.VK_ALT);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        robot.keyPress(KeyEvent.VK_F4);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        robot.keyRelease(KeyEvent.VK_ALT);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按下ctrl+shift+delete&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         Robot robot1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Robot();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        robot1.keyPress(KeyEvent.VK_CONTROL);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        robot1.keyPress(KeyEvent.VK_SHIFT);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        robot1.keyPress(KeyEvent.VK_DELETE);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        robot1.keyRelease(KeyEvent.VK_CONTROL);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        robot1.keyRelease(KeyEvent.VK_SHIFT);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         robot1.keyRelease(KeyEvent.VK_DELETE);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;delete键可不释放，但ctrl+shift键必须释放&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;键盘事件实现时，需要值得注意的是，ctrl，shift、alt键需要释放，不然会影响后者操作。&lt;/p&gt;
&lt;p&gt;按下操作的关键字是keyPress()，按键释放关键字是keyRelease()&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;23.41935483871&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。转载请注明出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 05 Oct 2017 04:48:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hong-fithing/p/7629039.html</dc:identifier>
</item>
<item>
<title>Java常用异常整理 - 工程师-搁浅</title>
<link>http://www.cnblogs.com/aishangJava/p/7628941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aishangJava/p/7628941.html</guid>
<description>&lt;p&gt;填坑，整理下Java的常用异常。正确使用异常在实际编码中非常重要，但面试中的意义相对较小，因为对异常的理解和应用很难通过几句话或几行代码考查出来，不过我们至少应答出三点：异常类的继承关系、常用异常类、常用异常类的使用场景，下文将围绕这三点介绍。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://oh4pp6966.bkt.clouddn.com/static/images/Java%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BC%82%E5%B8%B8%E6%95%B4%E7%90%86/java_exception.png&quot; alt=&quot;java_exception&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java中，所有异常都继承自Throwable类（一个完整可用的类）。整体上分为Error、Exception两个大类，Exception大类又分为UncheckedException（继承于RuntimeException）和CheckedException（继承于Exception，但不继承于RuntimeException）。&lt;/p&gt;
&lt;p&gt;为了帮助理解，我在每个类别下都给出了两个常用子类，如Error包括OutOfMemoryError、AssertionError等；UncheckedException包括NullPointerException、IllegalArgumentException；CheckedException包括IOException、InterruptedException。面试画异常类的继承关系时，要求能清楚的说明几个类别并分类别举几个常用的异常类。&lt;/p&gt;

&lt;p&gt;下面分类别扩充一下常用的异常类，字典序排序：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;常用异常类&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Error&lt;/td&gt;
&lt;td&gt;AssertionError、OutOfMemoryError、StackOverflowError&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;UncheckedException&lt;/td&gt;
&lt;td&gt;AlreadyBoundException、ClassCastException、ConcurrentModificationException、IllegalArgumentException、IllegalStateException、IndexOutOfBoundsException、JSONException、NullPointerException、SecurityException、UnsupportedOperationException&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;CheckedException&lt;/td&gt;
&lt;td&gt;ClassNotFoundException、CloneNotSupportedException、FileAlreadyExistsException、FileNotFoundException、InterruptedException、IOException、SQLException、TimeoutException、UnknownHostException&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;需要着重理解的是UncheckedException。&lt;/p&gt;
&lt;p&gt;上述异常类都是很常见的，但其中几个异常类设计的不好，需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConcurrentModificationException：实现“快速失败”的机制，但实际上，“快速失败”机制本身仍然无法保证并发环境下安全性，参考源码|从源码分析非线程安全集合类的不安全迭代器。因此，虽然该异常很常见，不要去依赖它。&lt;/li&gt;
&lt;li&gt;JSONException：常见于json字符串解析失败的情况，但遮蔽了大量的失败细节，往往很难根据该异常作出处理。如果项目中大量使用json，建议使用第三方的json解析库，如gson等。&lt;/li&gt;
&lt;li&gt;UnsupportedOperationException：这是一种编码上的恶性妥协，经常在抽象类的成员方法中被用户主动抛出，表示该方法还未实现等，但由于是UncheckedException，运行期才能够发现，完全无益于编码期间的安全性。自己编码时尽量不要使用。&lt;/li&gt;
&lt;li&gt;SQLException：与JSONException原因相似，但其遮蔽的失败细节范围更广。同时，SQLException还是一个CheckedException，在不能解决问题的情况下，又使代码变的臃肿不堪。建议同。如果做Java Web开发，热门的ORM库都能解决上述问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用异常还是有点多，下面分别讲解上述三个类别的使用场景，并在每个类别中选一个例子进行讲解。&lt;/p&gt;
&lt;h2 id=&quot;Error&quot;&gt;Error&lt;/h2&gt;
&lt;p&gt;Error通常描述了系统级的错误，并且程序猿无法主动处理——当然，系统级错误也有可能由代码间接导致，这不在我们的讨论范围内。发生系统级错误的时候，系统环境已经不健康了，因此，Error不强制捕获或声明，也就是不强制处理，一般情况下只需要把异常信息记录下来（如果能记下当时的系统快照更好）。&lt;/p&gt;
&lt;h3 id=&quot;OutOfMemoryError&quot;&gt;OutOfMemoryError&lt;/h3&gt;
&lt;p&gt;当可用内存不足时，会由JVM抛出OutOfMemoryError。一般由三种原因导致：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;堆设置过小，不满足正常的内存需求&lt;/li&gt;
&lt;li&gt;代码中存在内存泄露，占用了大量内存而不能被回收&lt;/li&gt;
&lt;li&gt;选择的GC算法与某些极端的应用场景不匹配，内存碎片过多，没有足够大的连续空间分配给对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM抛出OutOfMemoryError前，会尝试进行一次Full GC，如果GC后可用内存还是不足，才会抛出OutOfMemoryError。因此，这时程序猿必然无法主动处理这一问题，只能等程序崩溃后再去查证原因。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;查证OutOfMemoryError的技巧足以单开一篇文章了，本文不作深入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;UncheckedException&quot;&gt;UncheckedException&lt;/h2&gt;
&lt;p&gt;严格来说，Error也可以被划归UncheckedException，但我们更习惯用UncheckedException描述运行期发生，通常由于代码问题直接引起的程序相关的错误，并且程序猿无法主动处理。注意区分，&lt;em&gt;系统级错误都应该用Error描述&lt;/em&gt;。UncheckedException发生的大部分情况是代码写挫了，因此，UncheckedException也不强制捕获或声明，也就是不强制处理，一般情况下记下日志即可。&lt;/p&gt;
&lt;p&gt;不同的是，如果可能，要保证UncheckedException是可控的（在异常被动抛出前检查并主动抛出）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JSONException就是不可控的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;NullPointerException&quot;&gt;NullPointerException&lt;/h3&gt;
&lt;p&gt;NullPointerException是最常见的UncheckedException。如果在一个空指针上引用方法或变量等，则运行期会抛出NullPointerException。空指针让程序变的不可控：如果任由空指针在程序运行期随意传递、使用，我们将无法确定程序的行为，也无法确定捕获NullPointerException时程序所处的状态。&lt;/p&gt;
&lt;p&gt;解决这一问题的方法很简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽早检查并主动抛出异常&lt;/li&gt;
&lt;li&gt;单独、提前处理边界条件&lt;/li&gt;
&lt;li&gt;尽量不使用null表示状态，特别是在集合中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前两条原则通用于大部分UncheckedException，可参考String#toLowerCase()的例子。第三条原则需要在代码的健壮与简洁之间做出权衡，有限保证简洁清晰，需要健壮再去健壮。&lt;/p&gt;
&lt;h2 id=&quot;CheckedException&quot;&gt;CheckedException&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;猴子对CheckedException的理解不到位，如果各位有更好的理解希望能交流一下。以下讲猴子“不到位”的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CheckedException描述了外部环境导致的不太严重的错误，程序猿应该主动处理。注意与系统级错误区分，系统级错误通常是不可恢复的。因此，CheckedException强制捕获或声明，程序猿必须处理。记录日志，包装后再次抛出，在方法签名中声明，是三种最常见的做法。&lt;/p&gt;
&lt;p&gt;同UncheckedException一样，CheckedException也要保证是可控的。对CheckedException的可控性要求更高，不仅要主动检查，还要在捕获到异常时，作出合适的处理。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不过，猴子认为大量CheckedException的存在就是个错误。比如FileAlreadyExistsException，更应该由用户主动检查发现，而不应该依赖于异常。对于可以处理的异常，本质上相当于控制流问题，用异常去表达反而让控制流变模糊。不过有时候猴子写小项目，也会为了简化代码，直接将相关异常声明在方法签名中，并一路声明干到main方法。恩，everything is a trade-off。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;IOException&quot;&gt;IOException&lt;/h3&gt;
&lt;p&gt;产生IOException的原因非常多，但很多时候我们并不关心细节原因，因为文件系统是一个不太可控的因素，这时我们可以以IOException为粒度处理；某些需要关心细节的异常情况，则应使用IOException的子类，以分情况处理。&lt;/p&gt;
&lt;p&gt;前面总结的FileAlreadyExistsException、FileNotFoundException、UnknownHostException等，都是IOException的子类。这三种异常恰好都是可以处理的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;挖坑，InterruptedException也相当重要，后面要专门写一篇来整理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实际的编码工作中，我们应正确的使用异常表达代码设计，并尽可能使用JDK提供的异常类。JDK内置了非常多的异常类，我们只需要掌握一些常用的异常类，然后举一反三。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java学习交流QQ群：589809992  禁止闲聊，非喜勿进！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 05 Oct 2017 03:20:00 +0000</pubDate>
<dc:creator>工程师-搁浅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aishangJava/p/7628941.html</dc:identifier>
</item>
<item>
<title>深入理解计算机系统（3.7）------过程（函数的调用原理） - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7625917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7625917.html</guid>
<description>&lt;p&gt;　　上篇博客我们讲解了计算机汇编语言是如何实现循环结构的。本篇博客我们将介绍汇编语言中过程的实现方式。&lt;/p&gt;
&lt;p&gt;　　过程在高级语言中也称为函数，方法。一个过程的调用包括将数据（以过程参数和返回值的形式）和控制从代码的一部分传递到另一部分。此外，它还必须在进入时为过程的局部变量分配空间，并在退出时释放空间。大多数机器，包括我们一直讲的 IA32，只提供转移控制到过程和从过程中转移出控制这种简单指令。数据传递和局部变量的分配释放都是通过操纵程序栈来实现。&lt;/p&gt;
&lt;p&gt;　　合理的构建方法并调用，能大大增加代码的复用性，也能使代码结构更加清晰，接下来我们就来详细的介绍。&lt;/p&gt;

&lt;h3&gt;1、栈帧结构&lt;/h3&gt;
&lt;p&gt;　　IA32 程序用程序栈来支持过程调用。机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈（stack frame）。&lt;/p&gt;
&lt;p&gt;　　帧栈可以认为是程序栈的一段，它有两个端点，一个标识着起始地址，一个标识着结束地址，而这两个地址，则分别存储在固定的寄存器当中，即起始地址存在%ebp寄存器当中，结束地址存在%esp寄存器当中。也就是说寄存器 %ebp 为帧指针，寄存器 %esp 为栈指针。&lt;/p&gt;
&lt;p&gt;　　当程序执行时，栈指针可以移动，因此大多数信息的访问都是相对于帧指针的。&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004212252458-1823584759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个图基本上已经包括了程序栈的构成，它由一系列栈帧构成，这些栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。各位需要知道的是，每一个栈帧都建立在调用者的下方（也就是地址递减的方向），当被调用者执行完毕时，这一段栈帧会被释放。还有一点很重要的是，%ebp和%esp的值指示着栈帧的两端，而栈指针会在运行时移动，所以大部分时候，在访问存储器的时候会基于帧指针访问，因为在一直移动的栈指针无法根据偏移量准确的定位一个存储器位置。&lt;/p&gt;
&lt;p&gt;　　还有一点比较重要的内容，就是栈帧当中内存的分配和释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。这个理解起来很简单，因为在栈指针向下移动以后（也就是变小了），帧指针和栈指针中间的区域会变长，这就是给栈帧分配了更多的内存。相反，如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。需要注意的是，上面的一切内容，都基于一个前提，那就是帧指针在过程调用当中是不会移动的。&lt;/p&gt;

&lt;h3&gt;2、过程的实现&lt;/h3&gt;
&lt;p&gt;　　过程的实现主要就是在于数据如何在调用者和被调用者之间传递，以及在被调用者当中局部变量内存的分配以及释放。&lt;/p&gt;
&lt;p&gt;　　而过程实现当中，参数传递以及局部变量内存的分配和释放都是通过以上介绍的栈帧来实现的，大部分情况下，我们认为过程调用当中做了以下几个操作。&lt;/p&gt;
&lt;p&gt;　　①、备份原来的帧指针，调整当前的帧指针到栈指针的位置，这个过程就是我们经常看到的如下两句汇编代码做的事情。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
pushl   %ebp
movl    %esp, %ebp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　②、建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存，这一步一般是经过下面这样的汇编代码处理的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
subl    $16,%esp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　③、备份被调用者保存的寄存器当中的值，如果有值的话，备份的方式就是压入栈顶。因此会采用如下的汇编代码处理。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
pushl    %ebx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　④、使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。&lt;/p&gt;
&lt;p&gt;　　⑤、恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。因此在恢复时，大多数会使用pop指令，但也并非一定如此。&lt;/p&gt;
&lt;p&gt;　　⑥、释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理（也可能是addl）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
movl    %ebp,%esp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　⑦、恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。因为栈指针已经在第六步调整好了，因此此时只需要将备份的原帧指针弹出到%ebp即可。类似的汇编代码如下。　　&lt;/p&gt;

&lt;p&gt;　　⑧、弹出返回地址，跳出当前过程，继续执行调用者的代码。此时会将栈顶的返回地址弹出到PC，然后程序将按照弹出的返回地址继续执行。这个过程一般使用ret指令完成。&lt;/p&gt;
&lt;p&gt;　　过程的实现大概就是以上八个步骤组成的，不过这些步骤并不都是必须的（大部分时候，开启编译器的优化会优化掉很多步骤），而且第6和第7步有时会使用leave指令代替。下面会详细讲解这些步骤。&lt;/p&gt;

&lt;h3&gt;3、过程调用和返回指令&lt;/h3&gt;
&lt;p&gt;　　下图是支持过程调用和返回的指令：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004214820318-1784094535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　①、call指令：call 指令有一个目标，即指明被调用过程起始的指令地址。直接调用的目标可以是一个标号，间接调用的目标是 * 后面跟一个操作符。它一共做两件事，第一件是将返回地址（也就是call指令执行时PC的值）压入栈顶，第二件是将程序跳转到当前调用的方法的起始地址。第一件事是为了为过程的返回做准备，而第二件事则是真正的指令跳转。&lt;/p&gt;
&lt;p&gt;　　②、leave指令：它也是一共做两件事，第一件是将栈指针指向帧指针，第二件是弹出备份的原帧指针到%ebp。第一件事是为了释放当前栈帧，第二件事是为了恢复调用者的栈帧。&lt;/p&gt;
&lt;p&gt;　　③、ret指令：它同样也是做两件事，第一件是将栈顶的返回地址弹出到PC，第二件事则是按照PC此时指示的指令地址继续执行程序。这两件事其实也可以认为是一件事，因为第二件事是系统自己保证的，系统总是按照PC的指令地址执行程序。&lt;/p&gt;
&lt;p&gt;　　可以看出，除了call指令之外，leave和ret指令都与上面8个步骤有些不可分割的关系。call指令没有在8个步骤当中体现，是因为它发生在进入过程之前，因此在第1步发生的时候，call指令往往已经被执行了，并且已经为ret指令准备好了返回地址。&lt;/p&gt;

&lt;h3&gt;4、寄存器使用惯例&lt;/h3&gt;
&lt;p&gt;　　程序寄存器组是唯一能够被所有过程共享的资源。虽然在给定时刻只能有一个过程是活动的，但是我们必须保证当一个过程（调用者）调用另一个过程（被调用者）时，被调用者不会覆盖某个调用者稍后会使用的寄存器的值。为此必须采用一组统一的寄存器使用惯例，所有的过程都必须遵守，包括程序库的过程。&lt;/p&gt;
&lt;p&gt;　　假如没有这些规矩，比如在调用一个过程时，无论是调用者还是被调用者，都可能更新寄存器的值。假设调用者在%edx中存了一个整数值100，而被调用者也使用这个寄存器，并更新成了1000，于是悲剧就发生了。当过程调用完毕返回后，调用者再使用%edx的时候，值已经从100变成了1000，这几乎必将导致程序会错误的执行下去。所以便有如下规矩：&lt;/p&gt;
&lt;p&gt;　　在 IA32 中，寄存器%eax，%edx和%ecx被划分为调用者保存寄存器。当过程 P 调用 Q 时，Q可以覆盖这些寄存器，而不会破坏 P 所需的数据。&lt;/p&gt;
&lt;p&gt;　　寄存器%ebx,%esi和%edi被划分为被调用者保存寄存器。这里 Q 必须在覆盖这些寄存器的值之前，先把他们保存到栈中，并在返回前恢复它们，因为 P（或某个更高层次的过程）可能会在今后的计算中需要这些值。上面所说的过程实现的8个步骤中第三步便是如此。&lt;/p&gt;
&lt;p&gt;　　考虑如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int P(int x)
{
    int y = x*x;
    int z = Q(y);      
    return y+z;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　过程 P 在调用 Q 之前会先计算 y 的值，而且它必须保证 y 的值在 Q 返回后是可用的。这里有两种方法实现：&lt;/p&gt;
&lt;p&gt;　　①、可以在调用 Q 之前，将 y 的值保存在自己的帧栈中；当 Q 返回时，过程 P 就可以从栈中取出y 的值。换句话说就是调用者 P 自己保存这个值。&lt;/p&gt;
&lt;p&gt;　　②、可以将 y 保存在被调用者保存寄存器中。如果 Q ,或者其它 Q 调用的程序想使用这个寄存器，它必须将这个寄存器的值保存在帧栈中，并在返回前恢复该值。换句话说就是被调用者保存这个值。当 Q 返回到 P 时，y 的值会在被调用者保存寄存器中，或者是因为寄存器根本就没有改变，或者是因为它被保存并恢复了。&lt;/p&gt;
&lt;p&gt;　　这两种方法在 IA32 中是都采用的。&lt;/p&gt;

&lt;h3&gt;5、过程实例&lt;/h3&gt;
&lt;p&gt;　　考虑如下代码 function.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;

int add(int a,int b){
   register int c = a + b; 
   return c;
}

int main(){
   int a = 100;
   int b = 101;
   int c = add(a,b);
   return c;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　相信上面的代码没有什么难度，在 main过程中调用 add过程。我们通过如下指令编译成汇编代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
gcc -O0 -S function.c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了完整的展现那8个步骤，因此给变量c加了register关键字修饰，这将会将c送入寄存器，从而更改被调用者保存寄存器，就会导致步骤3的发生。以下是main函数以及add函数各自的栈帧情况:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004233435427-664289286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004233740068-1271960986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　上面的汇编代码是我们没有使用优化级别编译出来的，所以完整的呈现了前面所讲的8个步骤。这里我们需要注意两点：&lt;/p&gt;
&lt;p&gt;　　①、add函数会将返回结果存入%eax（前提是返回值可以使用整数来表示），在main函数中，call指令之后，默认将%eax作为返回结果来使用。&lt;/p&gt;
&lt;p&gt;　　②、所有函数（包括main函数）都必须有第1步和第6、7、8步，这是必须的4步。我们的栈指针和帧指针有固定的大小关系，即栈指针永远小于等于帧指针，当二者相等时，当前栈帧被认为没有分配内存空间。&lt;/p&gt;

&lt;h3&gt;5、递归过程&lt;/h3&gt;
&lt;p&gt;　　前面我们讲的都是一个过程能调用其它的过程，但是其实一个过程也能调用自己本身的，也就是递归调用。因为每个调用在栈中都有它自己的私人空间，多个未完成调用的局部变量不会互相影响，此外，栈的原则也提供了适当的策略，当过程被调用时分布局部存储空间，当过程执行完毕返回时释放存储空间。&lt;/p&gt;
&lt;p&gt;　　下面是一段求 n 的阶乘的递归调用代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int rfact(int n){
    int result;
    if(n&amp;lt;=1){
        result = 1;
    }else{
        result = n * rfact(n-1);
    }
    return result;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们还是用 -O0 -S 来编译得到汇编代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171005101108677-1753780847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的汇编代码，当用参数 n 来调用时，首先代码 2~5 行会创建一个帧栈，其中包含 %ebp 的旧值、保存的被调用者保存的寄存器 %ebx 的值，以及当递归调用自身的时候保存参数的四个字节。&lt;/p&gt;
&lt;p&gt;　　如下图所示，它用寄存器 %ebx 来保存过程参数 n 的值（第 6 行代码）。它将寄存器 %ebx 中的返回值设置为 1，预期 n&amp;lt;=1 的情况，它就会跳转到完成代码。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201710/1120165-20171005101556255-140999339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　对于递归的情况，计算 n-1，将这个值存储在栈上，然后调用函数自身（第10~12行），在代码的完成部分，我们可以假设：&lt;/p&gt;
&lt;p&gt;　　①、寄存器%eax保存这（n-1）!的值&lt;/p&gt;
&lt;p&gt;　　②、被调用保存寄存器%ebx保存着参数n&lt;/p&gt;
&lt;p&gt;　　因此将这两个值相乘（第 13 行）得到该函数的返回值。对于终止条件和递归调用，代码都会继续到完成部分（第15~17行），恢复栈和被调用者保存寄存器，然后在返回。&lt;/p&gt;
&lt;p&gt;　　所以我们看到递归调用一个函数本身与调用其它函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己的私有状态信息（保存的返回值、栈指针和被调用者保存寄存器的值）存储。如果需要，它还可以提供局部变量的存储。分配和释放的栈规则很自然的就与函数调用——返回的顺序匹配。&lt;/p&gt;

&lt;h3&gt;6、总结&lt;/h3&gt;
&lt;p&gt;　　本章对于函数的汇编实现做了详细的讲解，主要是栈规则的机制，帮我们解决了数据如何在调用者和被调用者之间传递，以及在被调用者当中局部变量内存的分配以及释放。那么下篇博客我们将介绍数组的分配和访问，我们知道比如Java语言中的集合很多都是在数组的基础上实现的。弄懂下一章的内容后，你会对定长数组与不定长数组（集合）有更深刻的了解。&lt;/p&gt;
</description>
<pubDate>Thu, 05 Oct 2017 03:16:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7625917.html</dc:identifier>
</item>
</channel>
</rss>