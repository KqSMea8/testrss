<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python学习：17.Python面向对象（四、属性（特性），成员修饰符，类的特殊成员） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9383838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9383838.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;一、属性（特性）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;普通方法去执行的时候，后面需要加括号，特性方法执行的时候和静态字段一样不需要不需要加括号.&lt;/p&gt;
&lt;p&gt;特性方法不和字段同名.&lt;/p&gt;
&lt;p&gt;特性方法不能传参数.&lt;/p&gt;
&lt;p&gt;在我们定义数据库字段类的时候,往往需要对其中的类属性做一些限制,一般用get和set方法来写,那在python中,我们该怎么做能够少写代码,又能优雅的实现想要的限制,减少错误的发生呢,这时候就需要我们的@property.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;获取特性&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特性，将方法的执行方式变为和字段一样&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s gd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ret1 &lt;/span&gt;=&lt;span&gt; obj.start()
ret2 &lt;/span&gt;=&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.name)


输出结果：
alexsel gd
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;设置特性&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;设置特性方法的时候，所需要加的装饰器名字规则是，你所设置特性方法名字点setter（例如：@end.setter）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 普通方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s sb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 特性，将方法的执行方式变为和字段一样&lt;/span&gt;
&lt;span&gt;    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self):
        temp &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s gd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;self.name
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果需要使用设置特性的的方法，就需要这个点前面名字和所要设置特性的方法同名，就像这里的end&lt;/span&gt;
&lt;span&gt;    @end.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; end(self,value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(value)
        self.name &lt;/span&gt;=&lt;span&gt; value

obj &lt;/span&gt;= Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取特性,获取特性的时候，拿到的是@Property的返回值&lt;/span&gt;
ret2 =&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret2)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置特性，设置特性的时候，会执行@end.setter下面的方法，这个'aaa'就传递给value&lt;/span&gt;
obj.end = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ret1 &lt;/span&gt;=&lt;span&gt; obj.end
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret1)


输出结果：
alexsel gd
aaa
aaa gd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个特性在python中不是特别常用，因为我们一般可以使用普通的方法代替特性方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、成员修饰符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;首先介绍‘__’，这个在命名之前添加就会变成私有的，只有在类的内部才能访问。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;命名的时候前面添加__，只有在类的内部才能访问，在外部无法访问&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__book&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;&lt;span&gt;)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj.book)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(obj.__book) #这种无法拿到字段&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在外部也无法调用类私有方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;obj.__end()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;通过内部方法调用拿到字段&lt;/span&gt;
&lt;span&gt;obj.start()


输出结果：
alexsel
book
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;私有的属性只有自己可以访问，当某个类继承这个类之后，也无法访问父类的私有属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__book&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;&lt;span&gt;)
        self.&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;()


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar(Foo):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(self.&lt;span&gt;__name&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子类继承父类，也无法调用父类的私有属性&lt;/span&gt;
&lt;span&gt;

obj &lt;/span&gt;=&lt;span&gt; Bar()
obj.start()

输出结果：
报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;静态方法也是如此&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
obj.start()


输出结果：
add&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;python成员修饰符有两种，一种是共有的，一种是私有的，共有的都可以访问，私有的只有自己可以访问，或者在外部间接访问。&lt;/p&gt;
&lt;p&gt;但是还有一种强行访问私有属性的方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(obj._Foo__book)


输出结果：
book&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然可以使用，但是不推荐这种使用方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;三、类的特殊成员&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.call&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;__call__()&lt;/code&gt;的作用是使实例能够像函数一样被调用，同时不影响实例本身的生命周期（&lt;code&gt;__call__()&lt;/code&gt;不影响一个实例的构造和析构）。&lt;/p&gt;
&lt;p&gt; __call__ 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;( Foo:      &lt;span&gt;def&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
r &lt;/span&gt;=&lt;span&gt; Foo()
r()
r &lt;/span&gt;= Foo()()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加第一个括号执行__init__，执行完__init__,获取到一个对象，对象加一个括号就是执行__call__，拿到返回值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r)


输出结果：
init
call
init
call
&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类后面添加括号执行__init__方法，对象后面加括号执行__call__方法。&lt;/p&gt;
&lt;h3&gt;2.getitem，setitem，delitem&lt;/h3&gt;
&lt;p&gt;用于索引操作，如字典。以上分别表示获取、设置、删除数据。&lt;/p&gt;
&lt;p&gt;首先得实例是字典类型的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, item):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(item)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, key, value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key,value)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, key):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key)

r &lt;/span&gt;=&lt;span&gt; Foo()
r() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用__call__方法&lt;/span&gt;
r[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用中括号传参数的时候，默认使用过的是__getitem__方法&lt;/span&gt;
r[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = 123&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里的xxx传给__setiem__的key，123传给__setitem__的value。&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; r[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除的时候，调用的是__delitem__方法&lt;/span&gt;
&lt;span&gt;

输出结果：
init
call
k1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是切片类型的操作，在切片操作的时候，在2.x版本中，执行的是__getslice_，__setslice__,delslice__方法，在3.x中的版本执行的是还是__getitem__，__setitem__，__delitem__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;(self, item):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(item,type(item),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__getitem__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__setitem__&lt;/span&gt;&lt;span&gt;(self, key, value):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key,value)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__delitem__&lt;/span&gt;&lt;span&gt;(self, key):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(key)

r &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用切片的时候，在2.x版本中，调用的是__getslice__方法，在3.x中调用的是__getitem__方法。&lt;/span&gt;
r[1:3&lt;span&gt;]
r[&lt;/span&gt;1:3] = [11,22,33] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里执行__setitem__方法&lt;/span&gt;
&lt;span&gt;del&lt;/span&gt; r[1:3]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在这里执行__delitem__方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 3.dict&lt;/h3&gt;
&lt;p&gt;dict是用来存储对象属性的一个字典，其键为属性名，值为属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    我是一个注释
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

    book &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;__book&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
        Foo.&lt;/span&gt;&lt;span&gt;__add&lt;/span&gt;() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内部调用私有静态方法&lt;/span&gt;


    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__end&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add&lt;/span&gt;&lt;span&gt;():
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj.&lt;span&gt;__dict__&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取对象里面所有字段&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Foo.&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;)

输出结果：
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function Foo.&lt;span&gt;__init__&lt;/span&gt; at 0x00000000027CF950&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__dict__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; objects&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function Foo.start at 0x00000000027EBB70&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;staticmethod object at 0x00000000027B6390&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__weakref__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;attribute &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__weakref__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; objects&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_Foo__end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &amp;lt;function Foo.&lt;span&gt;__end&lt;/span&gt; at 0x00000000027EBBF8&amp;gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__doc__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n    我是一个注释\n    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__module__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.__iter__&lt;/h3&gt;
&lt;p&gt;类的迭代器可以使用for循环迭代类。&lt;/p&gt;
&lt;p&gt;如果创建的对象可以被迭代，在类的内部就执行了__iter__方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; 1
        &lt;span&gt;yield&lt;/span&gt; 2
        &lt;span&gt;yield&lt;/span&gt; 3
        &lt;span&gt;yield&lt;/span&gt; 4&lt;span&gt;


obj &lt;/span&gt;=&lt;span&gt; Foo()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果执行for对象时，自动会执行对象的iter方法&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)



输出结果：
&lt;/span&gt;1
2
3
4
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 28 Jul 2018 15:13:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9383838.html</dc:identifier>
</item>
<item>
<title>深入理解JavaScript的事件循环（Event Loop） - -渔人码头-</title>
<link>http://www.cnblogs.com/imwtr/p/9383695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imwtr/p/9383695.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、什么是事件循环&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;JS的代码执行是基于一种事件循环的机制，之所以称作事件循环，MDN给出的解释为&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为它经常被用于类似如下的方式来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (queue.waitForMessage()) {
  queue.processNextMessage();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果当前没有任何消息&lt;code&gt;queue.waitForMessage&lt;/code&gt; 会等待同步消息到达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以把它当成一种程序结构的模型，处理的方案。更详细的描述可以查看 &lt;a href=&quot;https://segmentfault.com/a/1190000010622146&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而JS的运行环境主要有两个：&lt;strong&gt;浏览器&lt;/strong&gt;、&lt;strong&gt;Node&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在两个环境下的Event Loop实现是不一样的，在浏览器中基于 &lt;a href=&quot;https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops&quot; target=&quot;_blank&quot;&gt;规范&lt;/a&gt; 来实现，不同浏览器可能有小小区别。在Node中基于 &lt;a href=&quot;http://libuv.org/&quot; target=&quot;_blank&quot;&gt;libuv&lt;/a&gt; 这个库来实现&lt;/p&gt;
&lt;p&gt; JS是单线程执行的，而基于事件循环模型，形成了基本没有阻塞（除了alert或同步XHR等操作）的状态&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 二、Macrotask 与 Microtask&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://www.w3.org/TR/2017/REC-html52-20171214/webappapis.html#event-loops&quot; target=&quot;_blank&quot;&gt;规范&lt;/a&gt;，每个线程都有一个事件循环（Event Loop），在浏览器中除了主要的页面执行线程 外，Web worker是在一个新的线程中运行的，所以可以将其独立看待。&lt;/p&gt;
&lt;p&gt;每个事件循环有至少一个任务队列（Task Queue，也可以称作Macrotask宏任务），各个任务队列中放置着不同来源（或者不同分类）的任务，可以让浏览器根据自己的实现来进行优先级排序&lt;/p&gt;
&lt;p&gt;以及一个微任务队列（Microtask Queue），主要用于处理一些状态的改变，UI渲染工作之前的一些必要操作（可以防止多次无意义的UI渲染）&lt;/p&gt;
&lt;p&gt;主线程的代码执行时，会将执行程序置入执行栈（Stack）中，执行完毕后出栈，另外有个堆空间（Heap），主要用于存储对象及一些非结构化的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728192609678-1575290601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一开始&lt;/p&gt;
&lt;p&gt;宏任务与微任务队列里的任务随着：任务进栈、出栈、任务出队、进队之间交替着进行&lt;/p&gt;
&lt;p&gt;从macrotask队列中取出一个任务处理，&lt;strong&gt;处理完成&lt;/strong&gt;之后（此时&lt;a href=&quot;https://tc39.github.io/ecma262/#execution-context-stack%E3%80%82&quot; target=&quot;_blank&quot;&gt;执行栈&lt;/a&gt;应该是空的），从microtask队列中一个个按顺序取出所有任务进行处理，处理完成之后进入UI渲染后续工作&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;strong&gt;microtask并不是在macrotask完成之后才会触发&lt;/strong&gt;，在回调函数之后，只要执行栈是空的，就会执行microtask。也就是说，macrotask执行期间，执行栈可能是空的（比如在冒泡事件的处理时）&lt;/p&gt;
&lt;p&gt;然后循环继续&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的macrotask有：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常见的microtask有：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;macrotask种类很多，还有 dispatch event事件派发等&lt;/p&gt;
&lt;p&gt;run &amp;lt;script&amp;gt;这个可能看起来比较奇怪，可以把它看成一段代码（针对单个&amp;lt;script&amp;gt;标签）的同步顺序执行，主要用来描述执行程序的第一步执行&lt;/p&gt;
&lt;p&gt;dispatch event主要用来描述事件触发之后的执行任务，比如用户点击一个按钮，触发的onClick回调函数。需要注意的是，事件的触发是同步的，这在下文有例子说明&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，也可认为 run &amp;lt;script&amp;gt;不属于macrotask，毕竟规范也没有这样的说明，也可以将其视为主线程上的同步任务，不在主线程上的其他部分为异步任务&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、在浏览器中的实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先来看看这段蛮复杂的代码，思考一下会输出什么&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            console.log('start'&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; intervalA = setInterval(() =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'intervalA'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'timeout'&lt;span&gt;);

                clearInterval(intervalA);
            }, &lt;/span&gt;0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; intervalB = setInterval(() =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'intervalB'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; intervalC = setInterval(() =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'intervalC'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise'&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 10000; ++&lt;span&gt;i) {
                    i &lt;/span&gt;=== 9999 &amp;amp;&amp;amp;&lt;span&gt; resolve();
                }

                console.log(&lt;/span&gt;'promise after for-loop'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise1'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise2'&lt;span&gt;);

                clearInterval(intervalB);
            });

            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
                setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                    console.log(&lt;/span&gt;'promise in timeout'&lt;span&gt;);
                    resolve();
                });

                console.log(&lt;/span&gt;'promise after timeout'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise4'&lt;span&gt;);
            }).then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise5'&lt;span&gt;);

                clearInterval(intervalC);
            });

            Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise3'&lt;span&gt;);
            });

            console.log(&lt;/span&gt;'end');    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码结合了常规执行代码，setTimeout，setInterval，Promise &lt;/p&gt;
&lt;p&gt;答案为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728150331536-848095512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在解释为什么之前，先看一个更简单的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            console.log('start'&lt;span&gt;);

            setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'timeout'&lt;span&gt;);
            }, &lt;/span&gt;0&lt;span&gt;);

            Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                console.log(&lt;/span&gt;'promise'&lt;span&gt;);
            });

            console.log(&lt;/span&gt;'end');    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 大概的步骤，文字有点多&lt;/p&gt;
&lt;p&gt;1. 运行时（runtime）识别到log方法为一般的函数方法，将其入栈，然后执行输出 start 再出栈&lt;/p&gt;
&lt;p&gt;2. 识别到setTimeout为特殊的异步方法（macrotask），将其交由其他内核模块处理，setTimeout的匿名回调函数被放入macrotask队列中，并设置了一个 0ms的立即执行标识（提供后续模块的检查）&lt;/p&gt;
&lt;p&gt;3. 识别到Promise的resolve方法为一般的方法，将其入栈，然后执行 再出栈&lt;/p&gt;
&lt;p&gt;4. 识别到then为Promise的异步方法(microtask)，将其交由其他内核模块处理，匿名回调函数被放入microtask队列中&lt;/p&gt;
&lt;p&gt;5. 识别到log方法为一般的函数方法，将其入栈，然后执行输出 end 再出栈&lt;/p&gt;
&lt;p&gt;6. 主线程执行完毕，栈为空，随即从microtask队列中取出队首的项，&lt;/p&gt;
&lt;p&gt;这里队首为匿名函数，匿名函数里面有 console的log方法，也将其入栈（如果执行过程中识别到特殊的方法，就在这时交给其他模块处理到对应队列尾部），&lt;/p&gt;
&lt;p&gt;输出 promise后出栈，并将这一项从队列中移除&lt;/p&gt;
&lt;p&gt;7. 继续检查microtask队列，当前队列为空，则将当前macrotask出队，进入下一步（如果不为空，就继续取下一个microtask执行）&lt;/p&gt;
&lt;p&gt;8.检查是否需要进行UI重新渲染等，进行渲染...&lt;/p&gt;
&lt;p&gt;9. 进入下一轮事件循环，检查macrotask队列，取出一项进行处理&lt;/p&gt;
&lt;p&gt; 所以最终的结果是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728195436391-2074674475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再看上面那个例子，对比起来只是代码多了点，混入了setInterval，多个setTimeout与promise的函数部分，按照上面的思路，应该不难理解&lt;/p&gt;
&lt;p&gt;需要注意的三点：&lt;/p&gt;
&lt;p&gt;1. clearInterval(intervalA); 运行的时候，实际上已经执行了 intervalA 的macrotask了&lt;br/&gt;2. promise函数内部是同步处理的，不会放到队列中，放入队列中的是它的then或catch回调&lt;br/&gt;3. promise的then返回的还是promise，所以在输出promise4后，继续检测到后续的then方法，马上放到microtask队列尾部，再继续取出执行，马上输出promise5；&lt;/p&gt;
&lt;p&gt;而输出promise1之后，为什么没有马上输出promise2呢？因为此时promise1所在任务之后是promise3的任务，1和3在promise函数内部返回后就添加至队列中，2在1执行之后才添加&lt;/p&gt;

&lt;p&gt;再来看个例子，就有点微妙了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

        setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timeout1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

        Promise.resolve().then(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;promise1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timeout2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

        requestAnimationFrame(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });

        Promise.resolve().then(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;promise2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        });

        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728202732031-322249058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;requestAnimationFrame是在setTimeout之前执行的，start之后并不是直接输出end，也许这两个&amp;lt;script&amp;gt;标签被独立处理了&lt;/p&gt;

&lt;p&gt;来看一个关于DOM操作的例子，&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=619928018081157120&amp;amp;from=singlemessage&quot; target=&quot;_blank&quot;&gt;Tasks, microtasks, queues and schedules&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    .outer &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #eee&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        margin-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 150px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; flex&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        align-items&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        justify-content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;

    .inner &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #ddd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; outer &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.outer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
            inner &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.inner&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
            clickTimes &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mutate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        }).observe(outer, {
            attributes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        });

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; onClick() {
            console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

            setTimeout(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;timeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            }, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

            Promise.resolve().then(() &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;promise&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            });

            outer.setAttribute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data-click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, clickTimes&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;&lt;span&gt;);
        }

        inner.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, onClick);
        outer.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, onClick);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; inner.click();&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log('done');&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728203548785-204268099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击内部的inner块，会输出什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728203644158-281836874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MutationObserver优先级比promise高，虽然在一开始就被定义，但实际上是触发之后才会被添加到microtask队列中，所以先输出了promise&lt;/p&gt;
&lt;p&gt;两个timeout回调都在最后才触发，因为click事件冒泡了，事件派发这个macrotask任务包括了前后两个onClick回调，两个回调函数都执行完之后，才会执行接下来的 setTimeout任务&lt;/p&gt;
&lt;p&gt;期间第一个onClick回调完成后执行栈为空，就马上接着执行microtask队列中的任务&lt;/p&gt;

&lt;p&gt;如果把代码的注释去掉，使用代码自动 click()，思考一下，会输出什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728205414734-159788440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，事件处理是同步的，done在连续输出两个click之后才输出&lt;/p&gt;
&lt;p&gt; 而mutate只有一个，是因为当前执行第二个onClick回调的时候，microtask队列中已经有一个MutationObserver，它是第一个回调的，因为事件同步的原因没有被及时执行。浏览器会对MutationObserver进行优化，不会重复添加监听回调&lt;/p&gt;


&lt;h2&gt;&lt;span&gt; 四、在Node中的实现&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在Node环境中，macrotask部分主要多了setImmediate，microtask部分主要多了process.nextTick，而这个nextTick是独立出来自成队列的，优先级高于其他microtask&lt;/p&gt;
&lt;p&gt;不过事件循环的的实现就不太一样了，可以参考 &lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot; target=&quot;_blank&quot;&gt;Node事件文档 &lt;/a&gt;  &lt;a href=&quot;http://docs.libuv.org/en/v1.x/design.html&quot; target=&quot;_blank&quot;&gt;libuv事件文档&lt;/a&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Node中的事件循环有6个阶段&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;timers：执行&lt;code&gt;setTimeout()&lt;/code&gt; 和 &lt;code&gt;setInterval()&lt;/code&gt;中到期的callback&lt;/li&gt;
&lt;li&gt;I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行&lt;/li&gt;
&lt;li&gt;idle, prepare：仅内部使用&lt;/li&gt;
&lt;li&gt;poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段&lt;/li&gt;
&lt;li&gt;check：执行setImmediate的callback&lt;/li&gt;
&lt;li&gt;close callbacks：执行close事件的callback，例如&lt;code&gt;socket.on(&quot;close&quot;,func)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728210707057-1709797007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一轮事件循环都会经过六个阶段，在每个阶段后，都会执行microtask&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728215940260-1682381478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比较特殊的是在poll阶段，执行程序同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限&lt;/p&gt;
&lt;p&gt;接下来再检查有无预设的setImmediate，如果有就转入check阶段，没有就先查询最近的timer的距离，以其作为poll阶段的阻塞时间，如果timer队列是空的，它就一直阻塞下去&lt;/p&gt;
&lt;p&gt;而nextTick并不在这些阶段中执行，它在每个阶段之后都会执行&lt;/p&gt;

&lt;p&gt;看一个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
setTimeout(() =&amp;gt; console.log(1&lt;span&gt;));

setImmediate(() &lt;/span&gt;=&amp;gt; console.log(2&lt;span&gt;));

process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(3&lt;span&gt;));

Promise.resolve().then(() &lt;/span&gt;=&amp;gt; console.log(4&lt;span&gt;));

console.log(&lt;/span&gt;5);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据以上知识，应该很快就能知道输出结果是 5 3 4 1 2&lt;/p&gt;
&lt;p&gt;修改一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
process.nextTick(() =&amp;gt; console.log(1&lt;span&gt;));

Promise.resolve().then(() &lt;/span&gt;=&amp;gt; console.log(2&lt;span&gt;));

process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(3&lt;span&gt;));

Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(0&lt;span&gt;));
    console.log(&lt;/span&gt;4&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为 1 3 2 4 0，因为nextTick队列优先级高于同一轮事件循环中其他microtask队列&lt;/p&gt;
&lt;p&gt;修改一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
process.nextTick(() =&amp;gt; console.log(1&lt;span&gt;));

console.log(&lt;/span&gt;0&lt;span&gt;);

setTimeout(()&lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'timer1'&lt;span&gt;);

    Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'promise1'&lt;span&gt;);
    });
}, &lt;/span&gt;0&lt;span&gt;);

process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(2&lt;span&gt;));

setTimeout(()&lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'timer2'&lt;span&gt;);

    process.nextTick(() &lt;/span&gt;=&amp;gt; console.log(3&lt;span&gt;));

    Promise.resolve().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'promise2'&lt;span&gt;);
    });
}, &lt;/span&gt;0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728213248968-105884818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与在浏览器中不同，这里promise1并不是在timer1之后输出，因为在setTimeout执行的时候是出于timer阶段，会先一并处理timer回调&lt;/p&gt;

&lt;p&gt;setTimeout是优先于setImmediate的，但接下来这个例子却不一定是先执行setTimeout的回调&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
setTimeout(() =&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'timeout'&lt;span&gt;);
}, &lt;/span&gt;0&lt;span&gt;);

setImmediate(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;'immediate'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/688270/201807/688270-20180728214321521-1885700184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为在Node中识别不了0ms的setTimeout，至少也得1ms. &lt;/p&gt;
&lt;p&gt;所以，如果在进入该轮事件循环的时候，耗时不到1ms，则setTimeout会被跳过，进入check阶段执行setImmediate回调，先输出 immediate&lt;/p&gt;
&lt;p&gt;如果超过1ms，timer阶段中就可以马上处理这个setTimeout回调，先输出 timeout&lt;/p&gt;
&lt;p&gt;修改一下代码，读取一个文件让事件循环进入IO文件读取的poll阶段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    let fs = require('fs'&lt;span&gt;);

    fs.readFile(&lt;/span&gt;'./event.html', () =&amp;gt;&lt;span&gt; {
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'timeout'&lt;span&gt;);
        }, &lt;/span&gt;0&lt;span&gt;);

        setImmediate(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            console.log(&lt;/span&gt;'immediate'&lt;span&gt;);
        });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么一来，输出结果肯定就是 先 immediate  后 timeout&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 五、用好事件循环&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;知道JS的事件循环是怎么样的了，就需要知道怎么才能把它用好&lt;/p&gt;
&lt;p&gt;1. 在microtask中不要放置复杂的处理程序，防止阻塞UI的渲染&lt;/p&gt;
&lt;p&gt;2. 可以使用process.nextTick处理一些比较紧急的事情&lt;/p&gt;
&lt;p&gt;3. 可以在setTimeout回调中处理上轮事件循环中UI渲染的结果&lt;/p&gt;
&lt;p&gt;4. 注意不要滥用setInterval和setTimeout，它们并不是可以保证能够按时处理的，setInterval甚至还会出现丢帧的情况，可考虑使用 requestAnimationFrame&lt;/p&gt;
&lt;p&gt;5. 一些可能会影响到UI的异步操作，可放在promise回调中处理，防止多一轮事件循环导致重复执行UI的渲染&lt;/p&gt;
&lt;p&gt;6. 在Node中使用immediate来可能会得到更多的保证&lt;/p&gt;
&lt;p&gt;7. 不要纠结&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 14:23:00 +0000</pubDate>
<dc:creator>-渔人码头-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imwtr/p/9383695.html</dc:identifier>
</item>
<item>
<title>OpenCASCADE Extended Data Exchange - XDE - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/XDE.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/XDE.html</guid>
<description>&lt;h3&gt;OpenCASCADE Extended Data Exchange - XDE&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract.&lt;/strong&gt; OpenCASCADE Data Exchange allows developing OCCT-Based applications that can interact with other CAD systems by writing and reading CAD models to and from external data. The exchanges run smoothly regardless of the quality of external data or requirements to its internal representation, for example to the data types, accepted geometric inaccuracies, etc. Data Exchange is organized in a modular way as a set of interfaces that comply with various CAD formats: IGES, STEP, STL, VRML, etc. The interfaces allow software based on OCCT to exchange data with various CAD/PDM software packages, maintaining a good level of interoperability. Extended Data Exchange allows translating additional attributes attached to geometric data(colors, layers, names, materials, etc.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Words.&lt;/strong&gt; DataExchange, STEP, IGES, XDE, OCAF, &lt;/p&gt;
&lt;h3&gt;1. Introduction&lt;/h3&gt;
&lt;p&gt;OpenCASCADE的DataExchange数据交换模块可以通过读写CAD模型数据的方式与其他CAD系统进行交互。标准数据交换（Standardized Data Exchange）的接口可以查询和检查输入文件，转换文件中的CAD模型，正确性检查。目前开源部分支持的文件格式有：&lt;/p&gt;
&lt;p&gt;l STEP（AP203：Mechanical Design；AP214：Automotive Design）&lt;/p&gt;
&lt;p&gt;l IGES（5.3版本）&lt;/p&gt;
&lt;p&gt;l VRML和STL；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220421298-1893799841.png&quot;&gt;&lt;img title=&quot;wps_clip_image-25767&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220421695-995395347.png&quot; alt=&quot;wps_clip_image-25767&quot; width=&quot;328&quot; height=&quot;363&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 1. 导入的STEP模型&lt;/p&gt;
&lt;h3&gt;2. Extended Data Exchange（XDE）&lt;/h3&gt;
&lt;p&gt;扩展的数据交换模块可以转换附加在几何BREP体中其他信息，如颜色、图层，组装结构等，因此提高与其他CAD软件的兼容性。目前包含这些信息的文件格式有IGES和STEP。XDE通过XCAF框架来读写包含颜色、图层等信息的IGES，STEP文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220422004-1853197695.png&quot;&gt;&lt;img title=&quot;wps_clip_image-29842&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220422263-1571178641.png&quot; alt=&quot;wps_clip_image-29842&quot; width=&quot;408&quot; height=&quot;408&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 2. 使用XDE导入的模型&lt;/p&gt;
&lt;h3&gt;3. XDE Basic Terms&lt;/h3&gt;
&lt;p&gt;为了更好的理解XDE，定义了几个关键术语：&lt;/p&gt;
&lt;p&gt;l Shape：单独的模型，不属于任何装配结构(a standalone shape, which does not belong to the assembly structure)；&lt;/p&gt;
&lt;p&gt;l Instance：其他模型的一个实例化，位置信息可以相同，也可以不同(a replication of another shape with a location that can be the same location or different one)；&lt;/p&gt;
&lt;p&gt;l Assembly：装配结构；&lt;/p&gt;
&lt;h3&gt;4. XDE Organization&lt;/h3&gt;
&lt;p&gt;XDE的基础是XCAF，XCAF是一个基于OCAF（Open CASCADE Technology Application Framework）框架的框架，可用于处理装配信息和其他属性数据。XDE使用OCAF来存储装配结构和属性，所以可以得到装配结构树的每层TopoDS表示。&lt;/p&gt;
&lt;h3&gt;5. Assemblies&lt;/h3&gt;
&lt;p&gt;XDE支持装配结构的读写。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220422734-1507649749.png&quot;&gt;&lt;img title=&quot;wps_clip_image-19676&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220424876-473897314.png&quot; alt=&quot;wps_clip_image-19676&quot; width=&quot;577&quot; height=&quot;308&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 3. 装配结构树&lt;/p&gt;
&lt;p&gt;装配结构通过OCAF的Label/SubLabel来组织：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220426417-1404032708.png&quot;&gt;&lt;img title=&quot;wps_clip_image-18828&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220427176-1628464428.png&quot; alt=&quot;wps_clip_image-18828&quot; width=&quot;231&quot; height=&quot;187&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 4. 一个简单的框架模型 &lt;/p&gt;
&lt;p&gt;类XCAFDoc_ShapeTool来管理Label中的模型属性。&lt;/p&gt;
&lt;h3&gt;6. Names&lt;/h3&gt;
&lt;p&gt;XDE支持读写IGES和STEP中的名字数据。这个关闭这个功能以减小文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220428134-1809411936.png&quot;&gt;&lt;img title=&quot;wps_clip_image-10693&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220428432-404507478.png&quot; alt=&quot;wps_clip_image-10693&quot; width=&quot;487&quot; height=&quot;468&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 5. 模型名字&lt;/p&gt;
&lt;h3&gt;7. Colors and Layers&lt;/h3&gt;
&lt;p&gt;XDE可以读写模型的颜色数据，使用到的类有：&lt;/p&gt;
&lt;p&gt;l 通用颜色：generic color(XCAFDoc_ColorGen)&lt;/p&gt;
&lt;p&gt;l 曲面颜色：surface color(XCAFDoc_ColorSurf)&lt;/p&gt;
&lt;p&gt;l 曲线颜色：curve color(XCAFDoc_ColorCurv)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220428823-1004327451.png&quot;&gt;&lt;img title=&quot;wps_clip_image-4463&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220429195-1876009346.png&quot; alt=&quot;wps_clip_image-4463&quot; width=&quot;577&quot; height=&quot;406&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 6. XDE颜色&lt;/p&gt;
&lt;h3&gt;8. Code Example&lt;/h3&gt;
&lt;p&gt;程序将Draw Test Harness的samples的XDE的例子模型来测试读取装配结构、颜色等信息。首先将例子模型通过命令：WriteStep D d:/rod.step来保存装配结构、颜色等数据到STEP格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220429592-1168639044.png&quot;&gt;&lt;img title=&quot;wps_clip_image-24546&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220430028-386604641.png&quot; alt=&quot;wps_clip_image-24546&quot; width=&quot;573&quot; height=&quot;448&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 7. XDE Samples in Draw Test Harness&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220430507-2139575134.png&quot;&gt;&lt;img title=&quot;wps_clip_image-18659&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220430964-335884889.png&quot; alt=&quot;wps_clip_image-18659&quot; width=&quot;577&quot; height=&quot;418&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 8. Shapes with assembly and color info&lt;/p&gt;
&lt;p&gt;使用XDE读取STEP文件代码示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Handle(XCAFDoc_ColorTool) aColorTool;
Handle(XCAFDoc_ShapeTool) aShapeTool;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; visit(&lt;span&gt;const&lt;/span&gt; TDF_Label&amp;amp;&lt;span&gt; theLabel)
{
    theLabel.EntryDump(std::cout);

    Handle(TDataStd_Name) aName;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (theLabel.FindAttribute(TDataStd_Name::GetID(), aName))
    {
        std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aName-&amp;gt;Get() &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aColorTool-&amp;gt;&lt;span&gt;IsSet(theLabel, XCAFDoc_ColorGen))
    {
        Quantity_Color aColor;
        aColorTool&lt;/span&gt;-&amp;gt;&lt;span&gt;GetColor(theLabel, aColor);

        std::cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  Color: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Quantity_Color::StringName(aColor.Name()) &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aShapeTool-&amp;gt;&lt;span&gt;IsShape(theLabel))
    {
        TopoDS_Shape aShape;
        aShapeTool&lt;/span&gt;-&amp;gt;&lt;span&gt;GetShape(theLabel, aShape);
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TDF_ChildIterator c(theLabel); c.More(); c.Next())
    {
        visit(c.Value());
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; readStepXde(&lt;span&gt;const&lt;/span&gt; std::&lt;span&gt;string&lt;/span&gt;&amp;amp;&lt;span&gt; theStepName)
{
    Handle(TDocStd_Document) aDoc;
    Handle(XCAFApp_Application) anApp &lt;/span&gt;=&lt;span&gt; XCAFApp_Application::GetApplication();
    anApp&lt;/span&gt;-&amp;gt;NewDocument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MDTV-XCAF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, aDoc);

    STEPCAFControl_Reader aStepReader;
    aStepReader.SetColorMode(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    aStepReader.SetNameMode(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

    aStepReader.ReadFile(theStepName.c_str());

    aStepReader.Transfer(aDoc);

    TDF_Label aRootLabel &lt;/span&gt;= aDoc-&amp;gt;&lt;span&gt;Main();

    aShapeTool &lt;/span&gt;=&lt;span&gt; XCAFDoc_DocumentTool::ShapeTool(aRootLabel);
    aColorTool &lt;/span&gt;=&lt;span&gt; XCAFDoc_DocumentTool::ColorTool(aRootLabel);

    visit(aRootLabel);

}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    readStepXde(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:/rod.STEP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220431366-571729442.png&quot;&gt;&lt;img title=&quot;wps_clip_image-8893&quot; src=&quot;https://images2018.cnblogs.com/blog/534255/201807/534255-20180728220431754-140561105.png&quot; alt=&quot;wps_clip_image-8893&quot; width=&quot;577&quot; height=&quot;309&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Figure 9. 使用XDE读取STEP装配结构、颜色、名字等&lt;/p&gt;
&lt;h3&gt;9. Conclusion&lt;/h3&gt;
&lt;p&gt;使用XDE模块支持STEP和IGES中的装配结构、颜色、名字等信息的读写，提高与其他CAD系统数据交换效果。&lt;/p&gt;
&lt;p&gt;XDE主要使用OCAF框架来处理装配结构、属性信息，所以要使用XDE，必须理解OCAF的框架，OCAF框架也是一个基于Label的树结构。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 14:05:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/XDE.html</dc:identifier>
</item>
<item>
<title>logstash解耦之redis消息队列 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9383385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9383385.html</guid>
<description>&lt;h3&gt;logstash解耦之redis消息队列&lt;/h3&gt;
&lt;p&gt;架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180728204553194-2037827024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：通过input收集日志消息放入消息队列服务中（redis，MSMQ、Resque、ActiveMQ，RabbitMQ），再通过output取出消息写入ES上，kibana显示。&lt;/p&gt;
&lt;p&gt;好处：松耦合，降低logstash收集日志的负载对业务服务不受影响，前后端分离，消息能存储不影响ES维护。&lt;/p&gt;
&lt;p&gt; 下面我们就用redis做消息队列存储，架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180728212529444-1012601348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;#安装redis，修改redis配置文件，bind和protected-mode&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# yum install -y redis
[root@elk-node1 conf.d]# cp /etc/redis.conf{,.bak}
[root@elk-node1 conf.d]# grep &quot;^[a-z]&quot; /etc/redis.conf
bind 192.168.247.135
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize yes
supervised no
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#启动redis服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# systemctl start redis
You have new mail in /var/spool/mail/root
[root@elk-node1 conf.d]# ss -lntp|grep 6379
LISTEN     0      511    192.168.247.135:6379                     *:*                   users:((&quot;redis-server&quot;,pid=18387,fd=4))
You have new mail in /var/spool/mail/root
[root@elk-node1 conf.d]# grep &quot;^[a-z]&quot; /etc/redis.conf^C
[root@elk-node1 conf.d]# redis-cli -h 192.168.247.135
192.168.247.135:6379&amp;gt; exit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#编写测试文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# cat redis-out.conf
input{
    stdin{

}
}
output{
    redis{
    host =&amp;gt; &quot;192.168.247.135&quot;
    port =&amp;gt; &quot;6379&quot;
    db =&amp;gt; &quot;6&quot;
    data_type =&amp;gt; &quot;list&quot;
    key =&amp;gt; &quot;demo&quot;
}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#logstash配置文件运行输入hello world&lt;br/&gt;[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/redis-out.conf&lt;br/&gt;Settings: Default filter workers: 1&lt;br/&gt;hello world&lt;br/&gt;#另开一个窗口登录redis可以看到一条我们刚输入的hello world消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 ~]# redis-cli -h 192.168.247.135
192.168.247.135:6379&amp;gt; info
Logstash startup completed
# Keyspace
db6:keys=1,expires=0,avg_ttl=0
192.168.247.135:6379&amp;gt; select 6
OK
192.168.247.135:6379[6]&amp;gt; key *
(error) ERR unknown command 'key'
192.168.247.135:6379[6]&amp;gt; keys *
1) &quot;demo&quot;
192.168.247.135:6379[6]&amp;gt; LINDEX demo -1
&quot;{\&quot;message\&quot;:\&quot;hello world\&quot;,\&quot;@version\&quot;:\&quot;1\&quot;,\&quot;@timestamp\&quot;:\&quot;2018-07-28T06:44:50.418Z\&quot;,\&quot;host\&quot;:\&quot;elk-node1\&quot;}&quot;
192.168.247.135:6379[6]&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#接下来我们把消息写入ES，首先再输入多条消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/redis-out.conf
Settings: Default filter workers: 1
Logstash startup completed
fsadf
dgdf
gdg
ad
fd
ds
cd
g
rgergerg
rg
qrg
rh
rg
q
34tr
34
f
gdf
df

df
f
sdv
sdf

re
ter
t4
^CSIGINT received. Shutting down the pipeline. {:level=&amp;gt;:warn}

Logstash shutdown completed
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#写一个输入到ES的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# cat redis-int.conf
input{
    redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;demo&quot;
}
}
output{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;redis-demo-%{+YYYY.MM.dd}&quot;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#logstash配置文件运行&lt;br/&gt;[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/redis-int.conf&lt;br/&gt;Settings: Default filter workers: 1&lt;br/&gt;Logstash startup completed&lt;br/&gt;#这时我们看redis上的消息已经被消费了&lt;br/&gt;192.168.247.135:6379[6]&amp;gt; LLEN demo&lt;br/&gt;(integer) 0&lt;br/&gt;我们在登录ES可以看到已经有记录了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180728213528291-1766375984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#写一个系统监控的配置文件把日志写入redis,inpout里读取日志消息，output里写入redis。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node1 conf.d]# cat shipper.conf 
input {
    file {
      path =&amp;gt; &quot;/var/log/messages&quot;
      type =&amp;gt; &quot;system&quot;
      start_position =&amp;gt; &quot;beginning&quot;
    }
    file {
       path =&amp;gt; &quot;/var/log/elasticsearch/hejianlai.log&quot;
       type =&amp;gt; &quot;es-error&quot;
       start_position =&amp;gt; &quot;beginning&quot;
          codec =&amp;gt; multiline {
          pattern =&amp;gt; &quot;^\[&quot;
          negate =&amp;gt; true
          what =&amp;gt; &quot;previous&quot;
        }
    }
       file {
       path =&amp;gt; &quot;/var/log/nginx/access_json.log&quot;
       codec =&amp;gt; json
       start_position =&amp;gt; &quot;beginning&quot;
       type =&amp;gt; &quot;nginx-log&quot;
    }
        syslog{
        type =&amp;gt; &quot;system-syslog&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;514&quot;
}
}
output {
         
    if [type] == &quot;system&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system&quot;
    }
} 
    if [type] == &quot;es-error&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;es-error&quot;
    }
}
       if [type] == &quot;nginx-log&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;nginx-log&quot;
    }
}
       if [type] == &quot;system-syslog&quot;{
        redis{
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system-syslog&quot;

    }
}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; #运行配置文件&lt;br/&gt;[root@elk-node1 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/shipper.conf&lt;br/&gt;#查看redis已经生成了相应的key&lt;br/&gt;192.168.247.135:6379[6]&amp;gt; keys *&lt;br/&gt;1) &quot;system&quot;&lt;br/&gt;2) &quot;nginx-log&quot;&lt;br/&gt;3) &quot;es-error&quot;&lt;br/&gt;192.168.247.135:6379[6]&amp;gt;&lt;br/&gt;&lt;span&gt;#写一个配置文件从redis中把日志写入ES，inpout里读取redis消息，output里写入ES.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@elk-node2 conf.d]# cat display.conf 
input {
        redis{
        type =&amp;gt; &quot;system-syslog&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system-syslog&quot;

    }
        redis{
      type =&amp;gt; &quot;system&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;system&quot;

    }
        redis{
       type =&amp;gt; &quot;es-error&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;es-error&quot;

    }
        redis{
       type =&amp;gt; &quot;nginx-log&quot;
        host =&amp;gt; &quot;192.168.247.135&quot;
        port =&amp;gt; &quot;6379&quot;
        db =&amp;gt; &quot;6&quot;
        data_type =&amp;gt; &quot;list&quot;
        key =&amp;gt; &quot;nginx-log&quot;

    }

}
output {
         
    if [type] == &quot;system&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;systemlog-%{+YYYY.MM.dd}&quot;
        }
    }
 
    if [type] == &quot;es-error&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;es-error-%{+YYYY.MM.dd}&quot;
        }
    }
       if [type] == &quot;nginx-log&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;nginx-log-%{+YYYY.MM.dd}&quot;
        }
    }
       if [type] == &quot;system-syslog&quot;{
        elasticsearch {
           hosts =&amp;gt; [&quot;192.168.247.135:9200&quot;]
           index =&amp;gt; &quot;system-syslog-log-%{+YYYY.MM.dd}&quot;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; #运行配置文件，就可以收集日志了。&lt;/p&gt;
&lt;p&gt;[root@elk-node2 conf.d]# /opt/logstash/bin/logstash -f /etc/logstash/conf.d/display.conf &amp;amp;&lt;/p&gt;
&lt;p&gt;到此&lt;span&gt;logstash+redis+elasticsearch+kibana&lt;/span&gt;的架构搭建基本结束~~~~~&lt;/p&gt;

</description>
<pubDate>Sat, 28 Jul 2018 14:01:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9383385.html</dc:identifier>
</item>
<item>
<title>js-数组方法的使用和详谈 - 方红亮</title>
<link>http://www.cnblogs.com/fanghl/p/9383581.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanghl/p/9383581.html</guid>
<description>&lt;p&gt;　　写博客的同时也是对自己知识的一次全面总结，方便自己日后复习。今天总结一下JS中Array的所有方法和技巧，对算法题算是一个基础了，有不足的地方，还望童鞋们指出来，一起进步。&lt;/p&gt;
&lt;p&gt;　　在总结方法之前，提到一点，Array中的length属性&lt;strong&gt;它不是只读的&lt;/strong&gt;！通过修改length属性，可以删除或添加数组的项。&lt;/p&gt;
&lt;p&gt;　　数组类型检测问题：instanceof（）方法、Array.isArray（）&lt;/p&gt;
&lt;p&gt;　　开门见山，JS中Array对象有这么几种方法：1、栈方法  2、队列方法  3、排序  4、操作方法   5、位置方法   6、迭代    7、归并&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;一、栈方法、队列方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两个方法最为常见，具体就是 push()  pop()为栈方法，shift()  unshift()为队列方法。数组头尾部的压入和删除&lt;/p&gt;
&lt;p&gt;　   &lt;span&gt;&lt;strong&gt;三、重排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　数组中已经存在两个方法可以进行数组的重排序，即 reserve（）和 sort（），reserve（）是反转数组，而sort（）是数组的重排序，默认为升序，sort（）实现排序原理是会调用每个数组项的  toString（）方法，比较得到的字符串。这个方法可能会出错，因为它比较的是转型后的字符串。通常会配合比较函数一起使用，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180728203919196-1909936429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;四、操作方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Array的操作方法是非常有用的，在数据结构和算法中比较重要。concat（）方法，简单理解为数组复制，再不传参数的情况下，就是复制原数组，参数若是一或多个数组，则将参数数组添加在原数组末尾。 slice（）方法，简单来说就是截取原数组中的一段作为新的数组返回，接受返回项的起始和截止位置。（左闭右开原则）即返回值不包括截止位置的值，只有一个参数的情况下，从参数位置一直截取到数组末尾。若参数中存在负值，则计算位置的方式为 数组长度加上该数 所得值。&lt;/p&gt;
&lt;p&gt;　　最重要的操作方法  splice（）。它可以完成&lt;strong&gt;增删改，&lt;/strong&gt;splice（）方法接受三个参数，起始位置、删除项数目、插入的项。灵活运用这三个参数的变化就可以完成数组的增删改，删除：splice（1， 2）从第二项开始删除两项。 插入： splice（1， 0， &quot;item1&quot;, &quot;item2&quot;）从第二项开始往后插入“item1”，“item2”。替换：splice（1， 2， “item1”， “item2”）原理不变，删除了两项，且在原位置插入了两项达到替换的作用。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;五、位置方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有两个位置方法 indexOf() 和 lastIndexOf()，都接受两个参数，即要查找的项和查找起点的位置（该参数可选），只不过两个方法查找的顺序相反，indexOf（）是从头到尾的，且两个方法都返回被查找的项在数组中的位置，若没找到返回-1，利用这点，我们可以用来进行数组的去重，如图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180728210730522-8040869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上述图例又提到了Array的另一种类型的方法，即迭代方法，JS中有五个迭代方法，every（）、filter（）、forEach（）、map（）、some（）。它们都接收两个参数，一个是在数组每项上都要运行的函数，另一个就是该函数的作用域this。而传入的函数又会接受三个参数，数组项的值、其索引、原数组。解读上图例子，函数norepeat传入数组arr，返回arr的filter方法，filter的参数函数有两个参数，即当前项和其索引，在调用indexOf（）传入当前项ele ，indexOf会查找传入项在数组中第一次出现的位置，将该位置与filter的元素项位置相比，若等于则返回。数组去重会有很多不同位置的项值相等，迭代从左到右，filter里面只是每一项的值和索引，而indexOf（）里面则是某个值在数组中从左到右第一次出现的位置索引，让两个索引相比较。若相等则为首次出现，若不等，则为非首次出现，即重复的值，不返回，则最后得到的结果就是去重后的数组。&lt;/p&gt;
&lt;p&gt;　　every（）和some（）迭代，则是函数作用于数组每一项，结果都是true，才返回true这是every（）方法，some（）则是有一项返回true，则结果返回true，二者很相似。&lt;/p&gt;
&lt;p&gt;　　map（）方法，给数组每一项运行函数，返回其运行结果组成的数组。举例，让某数组全体项扩大二倍 var mapResult = arr.map(function(itrm, index) { retrun item*2});   最后forEach（）本质和for循环迭代数组一样。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;六、归并方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ES5中有两个数组归并方法 reduce（）， reduceRight（）。这两个方法都会迭代数组项，并返回最终的值。类似于贪吃蛇，从第一个点开始，吃掉往后的每一个点并且加在自己身上，最后变成一个包含所有点的结果。该方法接受一个函数和归并基础的初始值（可选）作为参数，而函数接受四个参数，前一项值，当前值，项的索引，原数组。这个函数返回的值都会作为第一个参数自动传给下一项！举例：求数组的和  var reduceResult = arr.reduce( function(prev, cur, index) {return prev + cur} );&lt;/p&gt;
&lt;p&gt;　　作者：方红亮&lt;/p&gt;
&lt;p&gt;　　博客园：https://home.cnblogs.com/u/fanghl/&lt;/p&gt;
&lt;p&gt;　　码字不易，如需转载，请注明出处，谢谢理解！&lt;/p&gt;


</description>
<pubDate>Sat, 28 Jul 2018 13:47:00 +0000</pubDate>
<dc:creator>方红亮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanghl/p/9383581.html</dc:identifier>
</item>
<item>
<title>自制操作系统Antz day04——进入保护模式 (下) 实现内核并从硬盘载入 - 奶BerBer</title>
<link>http://www.cnblogs.com/LexMoon/p/antz04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/antz04.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　目前已经完成了MBR的雏形，并且直接操作显卡完成了屏幕的内容显示。接下来我们要改造之前的MBR，做一个大的改进，使MBR可以读取硬盘，因为我们的MBR受限制于512字节大小，在这么小的空间里没法为内核准备好环境，更不要说加载内核到内存中并运行了，所以我们需要在另一个程序中完成初始化环境与加载内核的任务，这个程序我们叫做loader。loader这个程序放在哪里呢？如何去执行呢？这就是这次MBR改进的任务了，我们需要从硬盘上去把loader加载到内存中，并把执行权的接力棒交给它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在第一天讲过了，MBR是在硬盘的第0扇区，第一扇区是空闲的，但是离的太近总是感觉不安全，所以我们将loader放到第二扇区。MBR从第二扇区中把它都出来，然后放到哪里呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180728175735314-941416677.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原则上空闲位置都是可以的。图中7E00~9FBFF和500~7BFF这两段可用区域都可以。&lt;/span&gt;&lt;span&gt;随着功能的添加，内核必然会越来越大，所以我们尽量把loader放在低处，所以我选择为了0x500处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　说完了本次的基本任务和流程，接下来就是关键的问题了，&lt;span&gt;如何操作硬盘？&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;　　关于硬盘的种类历史此处不做介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　如有兴趣可参考：&lt;a title=&quot;https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98/159825?fr=aladdin&quot; href=&quot;https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98/159825?fr=aladdin&quot; target=&quot;_blank&quot;&gt;硬盘&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先来讲讲它的工作原理，如图是机械硬盘的示意图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180728180925860-1906117037.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　主轴上面有两个盘片，其实不止两个，这里只是示意性画了两个。盘片固定在主轴上随主轴高速转动，每个盘片分为上下两面，每个面都存储有数据，每个盘面都各有一个磁头来读取数据，故一个盘片对应两个磁头(注意盘片和盘面，不要看混)。由于盘面和磁头是一一对应的关系，故用磁头号来标识盘面号，磁头0对应盘面0，磁头1对应盘面1，从0开始计数，盘面0就是第一个盘面。磁头不会自己在盘片上移动，它需要被固定在磁头臂上，在磁头臂的带动下，沿着盘片的边缘向圆心的方向来回摆动，注意&lt;span&gt;摆动的轨迹是个弧&lt;/span&gt;，并不是绝对径向地直来直去。一方面是因为磁头臂是步进电机驱动的，磁头臂一段时步进电机主轴，另一端的磁头，电机每次都会转动一个角度，所以带动磁头臂在“画圆”，而磁头位于磁头臂的另一端，所以也跟着呈钟摆运动，轨迹时弧线，并不是直线。另一方面，磁头读取数据也不需要做直来直去的运动，能否找到数据，&lt;span&gt;只跟它最终落点有关&lt;/span&gt;，和中间路径形状无关，所以一方面盘面自转，另一方面磁头摆动，使得磁头可以盘面任意位置的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　说完了运动，在说存储逻辑，盘片表面时用于存储数据的磁性介质，为了更有效的管理磁盘，这些磁性介质也被“格式化”成易于管理的格局，即将盘面划分成了多个同心环，以同心环画扇形，扇形与每个同心环相交的弧状区域作为最基本的数据存储单元。这个同心环就称为磁道，而同心环上弧状的扇形部分就称为扇区，它作为我们硬盘存储数据的最基本单位，大小是512字节。我们写入数据最终是写入了扇形的扇区中。注意，磁道是一个环，不是线，线上可无法存储数据。&lt;span&gt;磁头臂带动磁头在盘片上方移动，就是在找磁道的位置，盘片高速自转，就是在磁道内定位扇区。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　磁道的编号和磁头的编号也是从0开始，相同编号的磁道组成的管状区域就称为柱面。柱面有什么用呢？ 机械硬盘大的寻道时间是整个硬盘的瓶颈，为了减少寻道时间，就尽量在存储上下功夫。寻道，简而言之就是在磁头在磁道间跳转，跳转所需要的时间就是寻道时间。&lt;span&gt;柱面就可以减少寻道的时间。&lt;span&gt;至于原理，可以这样理解，当我们要存储的数据少于一个磁道的存储量时，我们可以直接存储在一个磁道里面，而不需要跳转到其他磁道(不需要寻道)。当要存储量大于一个磁道时，需要多次寻道，而寻道会浪费大量时间，如果我们使用柱面，存满一个磁道后，将剩下的数据存储在其他盘面的相同磁道号处，就可以避免寻道了，反过来，读取数据也是这样，以此，&lt;span&gt;盘面越多，硬盘越快&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　扇区的编号与磁道磁头不同，它是从1开始编号的，而且一个扇区只对当前磁道有效，所以各个磁道间的扇区编号都相同，至于一个磁道中的扇区数量多少与厂商有关，一般都是63个扇区。磁头如何找到所需的扇区呢？ 每个扇区其实都是有自己的头部的，头部之后才是512字节的存储区，头部包含了扇区自身的信息，哪些信息可以唯一定位一个扇区呢？ 当然是磁头号，磁道号和扇区号了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　之前在&lt;a title=&quot;http://www.cnblogs.com/LexMoon/p/antz03.html&quot; href=&quot;http://www.cnblogs.com/LexMoon/p/antz03.html&quot; target=&quot;_blank&quot;&gt;直接操作显存&lt;/a&gt;中说过，CPU不会直接与这些设备联系，而是与IO接口通信，再由IO接口向下传达信息，CPU与硬盘的联系就是通过硬盘控制器。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　硬盘控制器与硬盘的关系就好像显卡与显示器。关于硬盘的接口，你可能听说过PATA和SATA，ATA是一种全球化的标准，PATA是并行ATA，SATA是后来的串行ATA。以前的主机一般至支持4个并行PATA，在串行SATA出现之后，支持几块硬盘完全取决于主板能力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　两种类型线缆完全不一样，PATA接口的线缆也称为IDE线，一个IDE线上可以挂两块硬盘，一个是主盘，一个是从盘。主盘从盘分工很明显，很多工作都要靠主盘来进行，比如系统就要装在主盘上。随着时代发展，兼容性的提升，主盘从盘已经没有了区别。之前说一个主板支持四块PATA硬盘，那么就是两个IDE线接口。这两个接口也是以0开始编号的，分别是IDE0,IDE1。不过按照ATA的说法，这两个插槽接口叫做通道，IDE0就是Primary通道，IDE1就是Secondary通道。SATA硬盘也是兼容PATA的编程接口。（这里不要把主盘从盘和通道弄混了）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　硬盘是一个很复杂的结构，我们暂时只需要知道一部分端口就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180728200200387-1053972189.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　端口可以分为两组，Command Block registers和Control Block registers。 Command Block registers用于向硬盘启动器写入命令字或者从硬盘控制器获取硬盘状态，Control Block registers用于控制硬盘工作状态。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　端口是按照通道给出的，&lt;span&gt;所以不要认为端口是直接针对某块硬盘的&lt;/span&gt;，一个通道的主从硬盘都是使用这些端口号的，要想操作某通道上的某块硬盘，需要单独指定。看上面的表格，有一个叫做Device的寄存器，这就是驱动器设备，也就是和硬盘相关的。不过此寄存器是八位的，一个通道上就两块硬盘，指定哪块硬盘只用一位就可以了，至于其他位当然也有用处，很多设置都会集中在此寄存器，其中的第四位便是指定通道上的主或从硬盘，0是主盘，1是从盘。端口用途在读写时是有区别的，比如Primary通道上的0x1F1端口来说，读操作时，如果读取失败，里面存储的是失败状态信息，所以称为error寄存器，并且此时会在0x1F2端口中存储未读的扇区数。写操作时就变成Features寄存器，此寄存器用于写命令参数。至于为什么要把一个寄存器分为两种状态，可能时在早期多加寄存器有很大代价吧。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　接下来介绍一下表中各个寄存器的功能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　data寄存器顾名思义就是管理数据的，数据的读写当然是越快越好，所以data寄存器比其他寄存器宽一些，16位。在读硬盘时，硬盘准备好数据后，硬盘控制器将其放在内部的缓存区中，不断读此寄存器便是读出缓存器中的全部数据。在写硬盘时，我们要把数据不断写入此寄存器中，然后数据便会被送入缓存区，硬盘控制器发现这个缓存区中有数据了，便将此处数据写入相应扇区中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　读硬盘时0x171或0x1F1的寄存器叫做Error寄存器，只在读取失败时才有用，里面有记录失败的信息，尚未读取的扇区数在Sector count寄存器中。在写硬盘时，该寄存器叫做Feature寄存器，里面是一些命令需要指定的额外参数。Error和Feature是同一个寄存器，只是在不同情况有不同的名称，它是八位寄存器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　Sector count寄存器用来指定带读取或者带写入的扇区数。硬盘每完成一个扇区，此寄存器中的值就会减一，这是一个八位寄存器，最大值为255，若指定为0，则表示需要操作256个扇区。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　LBA寄存器有LBA low,LBA mid,LBA high三个，它们三个都是8位，LBA  low寄存器用来存储28位地址的第0~7位，LBA mid用来存储28位的第8~15位，LBA high寄存器用来存储28位的第16~23位。那么剩下的四位呢？ 这就是device寄存器的任务了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　device寄存器是个杂项，它的宽度是八位，第四位是存储LBA的第24位~27位。结合上面的三个LBA寄存器，第四位用来指定通道上的主盘或从盘，0代表从，1代表主。第六位用来存储是否启用LBA方式，1代表LBA模式，0代表CHS模式。另外两位第五位和第七位是固定为1的，称为MBS位，可以不用注意。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　读硬盘时，端口0x1F7或0x177的寄存器叫Status，它是8位宽度的寄存器，用来给出硬盘的状态信息。第0位是ERR位，如果此位为1，表示命令出错了，具体原因可见Error寄存器。第三位data request位，如果此位为1，表示数据已经准备好了。第6位为DRDY，表示硬盘就绪。第七位是BSY位，表示硬盘是否繁忙。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　写硬盘时，端口0x1F7或0x177的寄存器叫Command，它和Status是同一个，此寄存器用来存储让硬盘执行的命令，把命令写入此寄存器，只要把命令写入此寄存器，硬盘就开始工作了。主要是以下三个命令：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　1）identify : 0xEC    硬盘识别&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　2）read sector : 0x20   即读扇区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　3)  write sector : 0x30   即写扇区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1291955/201807/1291955-20180728210433555-846381422.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　有的指令直接往command寄存器中写就可以了，有的还需要feature寄存器中写入参数。最主要的就是command寄存器一定要最后写，因为一旦command寄存器被写入后，硬盘就开始干活了。关于操作步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1)先选择通道，往该通道的sector count寄存器中写入带操作的扇区数。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2)往该通道上的三个LBA寄存器写入扇区起始地址的低24位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3)往device寄存器中写入LBA地址的24~27位，并置第六位为1，使其为LBA模式，设置第4位，选择操作的硬盘（主从）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4)往该通道上的额command寄存器中写入操作命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5)读取该通道上的status寄存器，判断硬盘工作是否完成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6)如果以上步骤是读硬盘，进入下一个步骤。否则，完工&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　7)将硬盘数据读出&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　MBR即将改造成可以读取硬盘，那么我们的内核加载就有了方法。所以我们要学会从另一个程序中完成初始化环境并加载内核，这个程序叫做loader，loader放在第二个扇区，地址之前已经讲过了0x500~0x7BFF区域中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; %include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boot.inc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;SECTION MBR vstart=0x7c00
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,cs
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ds,ax
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; es,ax
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ss,ax
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; fs,ax
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; sp,0x7c00
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,0xb800
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; gs,ax
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,0x600
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; bx,0x700
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; cx,&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1010
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;   &lt;span&gt;int&lt;/span&gt;&lt;span&gt; 0x10
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x00],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x01],0xA4
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x02],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x03],0x13
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x04],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x05],0x52
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x06],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x07],0xB1
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x08],&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x09],0xCC
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x0A],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;U&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x0B],0x2B
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x0C],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x0D],0x6D
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x0E],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x0F],0x7E
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x10],&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x11],0x49
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x12],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x13],0xE5
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x14],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x15],0x8A
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x16],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x17],0x96
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x18],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x19],0x68
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; eax,LOADER_START_SECTOR
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; bx,LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; cx,&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;   &lt;span&gt;call&lt;/span&gt;&lt;span&gt; rd_disk_m_16
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;   &lt;span&gt;jmp&lt;/span&gt;&lt;span&gt; LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;rd_disk_m_16:&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; esi,eax
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; di,cx
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f2
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; al,cl
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;   &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; eax,esi
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f3
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;   &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; cl,&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;   &lt;span&gt;shr&lt;/span&gt;&lt;span&gt; eax,cl
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f4
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;   &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt;   &lt;span&gt;shr&lt;/span&gt;&lt;span&gt; eax,cl
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f5
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;   &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;   &lt;span&gt;shr&lt;/span&gt;&lt;span&gt; eax,cl
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;   &lt;span&gt;and&lt;/span&gt;&lt;span&gt; al,0x0f
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;   &lt;span&gt;or&lt;/span&gt;&lt;span&gt; al,0xe0
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f6
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;   &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f7
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; al,0x20
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;   &lt;span&gt;out&lt;/span&gt;&lt;span&gt; dx,al
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;not_ready:&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;   &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;   &lt;span&gt;in&lt;/span&gt;&lt;span&gt; al,dx
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;   &lt;span&gt;and&lt;/span&gt;&lt;span&gt; al,0x88
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;   &lt;span&gt;cmp&lt;/span&gt;&lt;span&gt; al,0x08
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;   &lt;span&gt;jnz&lt;/span&gt;&lt;span&gt; not_ready
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; ax,di
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt; dx,&lt;span&gt;256&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;   &lt;span&gt;mul&lt;/span&gt;&lt;span&gt; dx
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; cx,ax
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; dx,0x1f0
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;go_on_read:&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;   &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ax,dx
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;   &lt;span&gt;mov&lt;/span&gt;&lt;span&gt; [bx],ax
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;   &lt;span&gt;add&lt;/span&gt; bx,&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;  loop go_on_read
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;   &lt;span&gt;ret&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;   times &lt;span&gt;510&lt;/span&gt;-($-$$) db &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;   db 0x55,0xaa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　boot.inc文件内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt;-------------     loader和kernel   ----------&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;LOADER_BASE_ADDR equ 0x900 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; LOADER_START_SECTOR equ 0x2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　LOADER_BASE_ADDR就是loader在内存中的位置，LOADER_START_SECTOR说明了loader放在了第二个扇区。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　内核加载器如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; %include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boot.inc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;section loader vstart=LOADER_BASE_ADDR
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 输出背景色绿色，前景色红色，并且跳动的字符串&quot;1 MBR&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x00],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x01],0xA4     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; A表示绿色背景闪烁，4表示前景色为红色&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x02],&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x03],0xA4
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x04],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x05],0xA4
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x06],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x07],0xA4
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x08],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x09],0xA4
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x0a],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x0b],0xA4
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x0c],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x0d],0xA4
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;0x0e],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;mov&lt;/span&gt; byte [&lt;span&gt;gs:&lt;/span&gt;&lt;span&gt;0x0f],0xA4
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;jmp&lt;/span&gt; $               &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 通过死循环使程序悬停在此&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　使用dd命令将之前生成的bin写入第0个扇区，loader生成的bin写入第2个扇区(个人爱好，也可以是第一个,但boot.inc也要改变)。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 13:26:00 +0000</pubDate>
<dc:creator>奶BerBer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/antz04.html</dc:identifier>
</item>
<item>
<title>macbook 入门 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/9371547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/9371547.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　第一次使用 Mac 之前，需要改变一些原有思维，不应该使用 Windows 的思维习惯去使用 Mac，Mac 会节省系统维护、清理杀毒、升级驱动等操作的时间，让我们可以专注做真正重要的事情，本文将详细介绍 macbook 入门的相关知识&lt;/p&gt;

&lt;h3&gt;按键&lt;/h3&gt;
&lt;p&gt;　　由于 macbook 简化了键盘，取消了标准键盘中的很多按键，下面是常用的补充按键&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
【delete】 fn + backspace&lt;br/&gt;【home】 fn + 左箭头&lt;br/&gt;【end】 fn + 右箭头&lt;br/&gt;【pageup】 fn + 上箭头&lt;br/&gt;【pagedown】 fn + 下箭头
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;电池使用&lt;/h3&gt;
&lt;p&gt;　　现有笔记本、手机，或是锂电池组成的电源系统均会带有电池保护板，过充保护是其中的基本功能之一，充满了就会断开充电回路；几乎上述电器的充电和自身用电都是双回路，也就是说充满后，电器是直接使用市电的，不会用电池；锂电池是没有记忆效应的，一次完整的充放电记为一次循环使用&lt;/p&gt;
&lt;p&gt;　　macbookair用的是三元锂电池，在锂电池中寿命较短，约500次。所以，如果不一直插电源，那就是说反复使用电池，会发现一年后电池就大不如前了，而一直插着市电呢，至少不会过充&lt;/p&gt;
&lt;p&gt;　　当然，锂电池在高温下满电是会影响寿命的，这里的高温指55摄氏度以上的温度，目前的数据显示持续一个月损失1-2%&lt;/p&gt;
&lt;p&gt;　　为什么一直用市电，从不用电池，一年后容量仍然减少呢？一是随着时间推移电池自身的老化，第二是电池还有自放电，第三相信用macos的一般不会关机，而是合盖休眠，这也是耗电的，由此影响了电池寿命&lt;/p&gt;
&lt;p&gt;　　苹果官方说明应当每个月做一次深放电，倒不是说要保养电池，锂电池没有记忆效应，是不需要定期深放的。但是电源系统对电池容量的校准，需要定期做循环才能校准&lt;/p&gt;
&lt;p&gt;　　总结如下，平时插着电源使用，别忘了每月做一次深放电，用于校准电池容量&lt;/p&gt;

&lt;h3&gt;触摸板&lt;/h3&gt;
&lt;p&gt;　　macbook 的触摸板功能强大，使用好触摸板，可以大大提高工作效率，且可以不使用鼠标&lt;/p&gt;
&lt;p&gt;　　点按： 左键点击效果&lt;/p&gt;
&lt;p&gt;　　双指点按： 右键点击效果&lt;/p&gt;
&lt;p&gt;　　双指轻点两下： 智能缩放&lt;/p&gt;
&lt;p&gt;　　双指滚动： 滚轮效果&lt;/p&gt;
&lt;p&gt;　　双指张开或捏合： 缩放效果&lt;/p&gt;
&lt;p&gt;　　双指左扫或右扫： 前进或后退&lt;/p&gt;
&lt;p&gt;　　双指从右侧边缘向左轻扫： 通知中心&lt;/p&gt;
&lt;p&gt;　　三指拖移：（系统偏好设置 -&amp;gt; 辅助功能 -&amp;gt; 鼠标和触控版 -&amp;gt; 触控版选项 -&amp;gt; 启用拖移）&lt;/p&gt;
&lt;p&gt;　　四指左扫或右扫： 在全屏幕的应用之间轻扫&lt;/p&gt;
&lt;p&gt;　　五指张开或捏合： 显示桌面&lt;/p&gt;

&lt;h3&gt;调度中心&lt;/h3&gt;
&lt;p&gt;　　1、关闭仪表盘&lt;/p&gt;
&lt;p&gt;　　系统偏好设置 -&amp;gt; 调度中心 -&amp;gt; 仪表盘&lt;/p&gt;
&lt;p&gt;　　2、打开调度中心&lt;/p&gt;
&lt;p&gt;　　四指上滑，或者使用快捷键command + 上箭头&lt;/p&gt;
&lt;p&gt;　　3、显示桌面&lt;/p&gt;
&lt;p&gt;　　快捷键 fn + f11&lt;/p&gt;
&lt;p&gt;　　4、当页面被放大到全屏后，默认可以使用四指左滑或右滑来调出当前应用的页面&lt;/p&gt;

&lt;h3&gt;快捷键&lt;/h3&gt;
&lt;p&gt;【截图快捷键】&lt;/p&gt;
&lt;p&gt;　　control + command + 3 将屏幕图片存储为文件&lt;/p&gt;
&lt;p&gt;　　control + command + 4 将所选区域的图片存储为文件&lt;/p&gt;
&lt;p&gt;　　control + command + 6 将触控栏的图片存储为文件&lt;/p&gt;
&lt;p&gt;【窗口快捷键】&lt;/p&gt;
&lt;p&gt;　　command + N 新建窗口&lt;/p&gt;
&lt;p&gt;　　command + Q 关闭程序&lt;/p&gt;
&lt;p&gt;　　command + H 隐藏最前面的应用的窗口&lt;/p&gt;
&lt;p&gt;　　command + M 最小化&lt;/p&gt;
&lt;p&gt;【浏览器快捷键】&lt;/p&gt;
&lt;p&gt;　　command + T 新建标签页&lt;/p&gt;
&lt;p&gt;　　command + W 关闭标签页&lt;/p&gt;
&lt;p&gt;　　command + option + 左右箭头 前一个标签或后一个标签&lt;/p&gt;
&lt;p&gt;　　command + option + i 打开或关闭控制台&lt;/p&gt;
&lt;p&gt;　　command + R 刷新&lt;/p&gt;

&lt;h3&gt;软件设置&lt;/h3&gt;
&lt;p&gt;【软件安装】&lt;/p&gt;
&lt;p&gt;　　1、下载软件到Mac之后双击运行，这时候就会看到桌面上生成了一个新的硬盘图标&lt;/p&gt;
&lt;p&gt;　　2、同时还会弹出一个新的安装窗口，如果没有出现这个窗口，就去双击那个硬盘图标。要做的就是将软件的图标拖动到旁边的文件夹图标中&lt;/p&gt;
&lt;p&gt;　　3、安装完成后最好还是打开Finder，在左侧找到那个新生成的硬盘，点击旁边的三角，这样就算是把硬盘弹出了&lt;/p&gt;
&lt;p&gt;【软件卸载】&lt;/p&gt;
&lt;p&gt;　　打开Finder，点击左侧的“应用程序”，然后把相应的软件直接拖到“废纸篓中”，这就算卸载了&lt;/p&gt;

&lt;h3&gt;常用功能&lt;/h3&gt;
&lt;p&gt;【分屏】&lt;/p&gt;
&lt;p&gt;　　1、长按左上角的全屏按钮时，窗口会缩小，可以将其拖动到屏幕的一侧&lt;/p&gt;
&lt;p&gt;　　2、松开该按钮，然后点按另一个窗口，以便开始并排使用这两个窗口&lt;/p&gt;
&lt;p&gt;【utf8】&lt;/p&gt;
&lt;p&gt;　　打开Txt文件时，提示未能打开文稿&quot;***.txt&quot;。文本编码&quot;Unicode(UTF-8)&quot;不适用&lt;/p&gt;
&lt;p&gt;　　要解决上面的问题，需要进行以下几步：&lt;/p&gt;
&lt;p&gt;　　1、打开mac自带的文本编辑器 textEdit.app， 搜索textEdit.app后打开即可&lt;/p&gt;
&lt;p&gt;　　2、打开文本编辑程序的偏好设置，切换到“打开和存储”选项，在“纯文本文件编码”中设置“打开文件”的值为“中文(GB-18030)”&lt;/p&gt;
&lt;p&gt;　　3、重新打开刚才的文本文件，就可以了&lt;/p&gt;
&lt;p&gt;【活动监视器】&lt;/p&gt;
&lt;p&gt;　　Windows中有任务管理器，可以用来查看本机运行的进程的状态和结束进程&lt;/p&gt;
&lt;p&gt;　　Mac中的Activity monitor(活动监视器)有差不多的功能，在Spotlight中搜索 activity， 可以快速启动Activity monitor&lt;/p&gt;

</description>
<pubDate>Sat, 28 Jul 2018 12:28:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/9371547.html</dc:identifier>
</item>
<item>
<title>打造一个简单的TXT文本操作及日志框架 - 殷慈航</title>
<link>http://www.cnblogs.com/jiyuwu/p/9383193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiyuwu/p/9383193.html</guid>
<description>&lt;p&gt;&lt;strong&gt;首先先介绍一下这个项目，该项目实现了文本写入及读取，日志写入指定文件夹或默认文件夹，日志数量控制，单个日志大小控制，通过约定的参数让用户可以用更少的代码解决问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.读取文本文件方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用：JIYUWU.TXT.TXTHelper.ReadToString（“文件物理路径”）&lt;/p&gt;

&lt;p&gt;实现解析：&lt;/p&gt;
&lt;p&gt;（1.为防止任务读取当我们进行读取时需要添加读取锁保证可以依次读取，否则可能出现被占用异常。&lt;/p&gt;
&lt;p&gt;（2.创建读取流StreamReader，依次读取每一行。&lt;/p&gt;
&lt;p&gt;（3.读取完成释放资源。并解锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.写入文本文件方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1.创建文本并写入&lt;/p&gt;
&lt;p&gt;使用：JIYUWU.TXT.TXTHelper.CreateWrite（“文件物理路径”，“文本内容”）&lt;/p&gt;

&lt;p&gt;（2.在文本文件末尾追加写入&lt;/p&gt;
&lt;p&gt;使用：JIYUWU.TXT.TXTHelper.WriteAppend（“文件物理路径”，“文本内容”）&lt;/p&gt;

&lt;p&gt;（3.自动判断换行追加或创建文本&lt;/p&gt;
&lt;p&gt;使用：JIYUWU.TXT.TXTHelper.CreateOrWriteAppendLine（“文件物理路径”，“文本内容”）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CreateOrWriteAppendLine(&lt;span&gt;string&lt;/span&gt; path, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; context)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                LogLock.EnterWriteLock();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;File.Exists(path))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(path, FileMode.Create, FileAccess.Write);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     StreamWriter sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamWriter(fs);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; fl =&lt;span&gt; fs.Length;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    fs.Seek(fl, SeekOrigin.End);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    sw.WriteLine(context);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    sw.Flush();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    sw.Close();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    fs.Close();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     b = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(path, FileMode.Open, FileAccess.Write);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     StreamWriter sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamWriter(fs);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; fl =&lt;span&gt; fs.Length;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    fs.Seek(fl, SeekOrigin.Begin);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    sw.WriteLine(context);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                    sw.Flush();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    sw.Close();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    fs.Close();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     b = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                Console.WriteLine(ex.ToString());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                LogLock.ExitWriteLock();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实现解析：&lt;/p&gt;
&lt;p&gt;（1）为防止多任务读取当我们进行读取时需要添加读取锁保证可以依次写入，否则可能出现被占用异常。&lt;/p&gt;
&lt;p&gt;（2）创建文本流FileStream及写入流StreamWriter，直接进行数据写入。&lt;/p&gt;
&lt;p&gt;（3）读取完成释放资源。并解锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.写入日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用：JIYUWU.TXT.TXTHelper.WriteLog（“文本内容”，“单个文件大小（选填默认1M）”，“目录下文件数量（选填默认20个）”，“输出目录（选填默认bin文件下）”）&lt;/p&gt;

&lt;p&gt;实现解析（以全部默认参数为例说明）：&lt;/p&gt;
&lt;p&gt;（1.为防止多任务进行操作，于是对文档加一个写入锁，否则可能出现被占用异常。&lt;/p&gt;
&lt;p&gt;（2.检测文件目录是否已存在，不存在则创建目录并创建日志文件，存在就判断文件数量和大小，文件大小超过设置的值或默认值就新建一个文本，文件数量超过默认值或设置值就删除最早的一个文件。&lt;/p&gt;
&lt;p&gt;（3.写入到指定文件。&lt;/p&gt;
&lt;p&gt;（4.完成释放资源。并解锁。&lt;/p&gt;
&lt;p&gt;项目框架就介绍到这里吧，后期还会将功能扩展，不多说了源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.csdn.net/download/silverbutter/10569972&quot; data-cke-saved-href=&quot;https://download.csdn.net/download/silverbutter/10569972&quot;&gt;https://download.csdn.net/download/silverbutter/10569972&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 11:44:00 +0000</pubDate>
<dc:creator>殷慈航</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiyuwu/p/9383193.html</dc:identifier>
</item>
<item>
<title>【原创】从策略模式闲扯到lambda表达式 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9380465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9380465.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;策略模式，讲这个模式的文章很多，但都缺乏一个循序渐进的过程。讲lambda表达式的文章也很多，但基本都是堆砌一堆的概念，很少带有自己的见解。博主一时兴起，想写一篇这二者的文章。需要说明的是，在看这篇文章的时候，请忘记所有的概念。容博主一步一步的带你们入坑。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;假设我们有一个Hero类，其UML图如下&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1232869/o_celue2uml.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;这个时候，我们有一个&lt;strong&gt;&lt;span&gt;需求&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们要找出type为刺客的Hero&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时，我们先封装一个要根据type类型来筛选Hero的方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static List&amp;lt;Hero&amp;gt; getHero(List&amp;lt;Hero&amp;gt; heroList, String type){
        List&amp;lt;Hero&amp;gt; result = new ArrayList&amp;lt;Hero&amp;gt;();
        for(Hero hero : heroList){
            if(type.equals(hero.getType())){
                result.add(hero);
            }
        }
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后呢，做如下调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getHero(heroList, &quot;刺客&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;突然有一天，产品突然改需求，现在的&lt;strong&gt;&lt;span&gt;需求&lt;/span&gt;&lt;/strong&gt;是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们要找出stature(身高)大于170的Hero&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也很简单嘛，再加一个重载的getHero方法就可以嘛，重载的getHero(List heroList, int stature)方法如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static List&amp;lt;Hero&amp;gt; getHero(List&amp;lt;Hero&amp;gt; heroList, int stature){
        List&amp;lt;Hero&amp;gt; result = new ArrayList&amp;lt;Hero&amp;gt;();
        for(Hero hero : heroList){
            if(hero.getStature() &amp;gt; stature){
                result.add(hero);
            }
        }
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后呢，做如下调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getHero(heroList, 170);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又过了几日，产品丧心病况的又改需求，现在最新的&lt;strong&gt;&lt;span&gt;需求&lt;/span&gt;&lt;/strong&gt;是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要找出stature(身高)大于170并且type类型为刺客的Hero&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，你或许说了，可以再加一个getHero(List heroList, String type, int stature)方法呀。不过呢，这种改法不够优雅。方法体中存在大量相同的代码，只是判断条件稍作改变。在这种情况下使用策略模式，就能够解决这个问题。&lt;br/&gt;稍微介绍一下策略模式&lt;br/&gt;&lt;strong&gt;策略模式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;意图&lt;/strong&gt;：策略模式定义了一系列的&lt;span&gt;算法&lt;/span&gt;，并将每一个&lt;span&gt;算法&lt;/span&gt;封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：在有多种&lt;span&gt;算法&lt;/span&gt;相似的情况下，使用 if...else 所带来的复杂和难以维护。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：一个系统有许多许多类，而区分它们的只是他们直接的行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：将这些&lt;span&gt;算法&lt;/span&gt;封装成一个一个的类，任意地替换。&lt;/p&gt;
&lt;p&gt;ps:在这里，上面的&lt;span&gt;算法&lt;/span&gt;指的就是上面提到的判断条件。我们将判断条件封装为相应的类。&lt;/p&gt;
&lt;p&gt;此时代码结构如下图所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1232869/o_celue3uml.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;那么此时的getHero方法如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static List&amp;lt;Hero&amp;gt; getHero(List&amp;lt;Hero&amp;gt; heroList, Predicate&amp;lt;Hero&amp;gt; predicate){
        List&amp;lt;Hero&amp;gt; result = new ArrayList&amp;lt;Hero&amp;gt;();
        for(Hero hero : heroList){
            if(predicate.test(hero)){
                result.add(hero);
            }
        }
        return result;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后呢，根据需求做如下调用,想找那种类型的Hero，就传那种类型的Predicate进去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getHero(heroList,new TMPredicate());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可是呢，机智的你又发现了一个&lt;span&gt;缺陷&lt;/span&gt;,每次新增一个算法，要新加一个实现类。于是，机智的你提出，利用匿名内部类来做调用，不写实现类，于是调用代码变成下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getHero(heroList,new Predicate&amp;lt;Hero&amp;gt;() {
    @Override
    public boolean test(Hero t) {
        return t.getStature() &amp;gt; 170 &amp;amp;&amp;amp; &quot;刺客&quot;.equals(t.getType());
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;机智的你突然间又觉得:&lt;span&gt;这么写，占用了太多的行数&lt;/span&gt;，看起来不够美观，于是，你决定用lambda表达式来改写，于是代码最终变成下面的样子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;getHero(heroList,(t)-&amp;gt;t.getStature() &amp;gt; 170 &amp;amp;&amp;amp; &quot;刺客&quot;.equals(t.getType()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里就结束了，是不是比我们最开始的版本简洁了不少，代码优雅了很多。lambda主要的目的就是提供一个更加简洁的代码结构，但是对于初学者，它可能反而增加阅读的难度。&lt;/p&gt;
&lt;p&gt;当然，lambda表达式除了能简化代码代码意外，还能并行处理元素，充分利用多核CPU的性能，例如下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Arrays;
import java.util.List;

public class Demo7 {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; values = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;);
        print(values);
    }

    public static void print(List&amp;lt;String&amp;gt; values){
       values.parallelStream().forEach(System.out :: println);//System.out表示对象，println表示方法
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3
4
1
2&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文以循序渐近的方式说明了，我们为什么要用策略模式以及如何用lambda表达式改写策略模式。希望大家有所收获。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;《JAVA8实战》&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 11:37:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9380465.html</dc:identifier>
</item>
<item>
<title>MySQL中间件之ProxySQL(15)：ProxySQL代理MySQL组复制 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9383126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9383126.html</guid>
<description>&lt;p&gt;&lt;strong&gt;返回&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html#middleware&quot;&gt;ProxySQL系列文章：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;在以前的ProxySQL版本中，要支持MySQL组复制(MGR,MySQL Group Replication)需要借助第三方脚本对组复制做健康检查并自动调整配置，但是从ProxySQL v1.4.0开始，已原生支持MySQL组复制的代理，在main库中也已提供&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;表来控制组复制集群中的读、写组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Admin&amp;gt; show tables ;
+--------------------------------------------+
| tables                                     |
+--------------------------------------------+
| global_variables                           |
| mysql_collations                           |
| mysql_group_replication_hostgroups         |
| mysql_query_rules                          |
...
| runtime_mysql_group_replication_hostgroups |
...
| scheduler                                  |
+--------------------------------------------+

admin&amp;gt; show tables from monitor;
+------------------------------------+
| tables                             |
+------------------------------------+
| mysql_server_connect_log           |
| mysql_server_group_replication_log |
| mysql_server_ping_log              |
| mysql_server_read_only_log         |
| mysql_server_replication_lag_log   |
+------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管已原生支持MGR，但仍然需要在MGR节点中创建一张额外的系统视图&lt;code&gt;sys.gr_member_routing_candidate_status&lt;/code&gt;为ProxySQL提供监控指标。创建该视图的脚本&lt;a href=&quot;https://files.cnblogs.com/files/f-ck-need-u/addition_to_sys.zip&quot;&gt;addition_to_sys.zip&lt;/a&gt;我已上传。在后文需要创建该系统视图的地方，我会将这个脚本的内容贴出来。&lt;/p&gt;
&lt;p&gt;本文先解释&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;表中各字段的意义，然后按照实验环境做好各种组的分配。最后根据实验环境快速搭建单主模型的组复制环境，以及ProxySQL代理单主模型组复制的配置步骤。因为本文描述了ProxySQL代理单主、多主MGR的情形，所以搭建ProxySQL代理多主MGR也是没有任何问题的。&lt;/p&gt;
&lt;p&gt;本文实验环境：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;proxysql&lt;/td&gt;
&lt;td&gt;192.168.100.21&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;node1&lt;/td&gt;
&lt;td&gt;192.168.100.22&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;node2&lt;/td&gt;
&lt;td&gt;192.168.100.23&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;node3&lt;/td&gt;
&lt;td&gt;192.168.100.24&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;mysql_group_replication_hostgroups表&quot;&gt;1.1 mysql_group_replication_hostgroups表&lt;/h2&gt;
&lt;p&gt;该表的定义语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Admin&amp;gt; show create table mysql_group_replication_hostgroups\G
*************************** 1. row ***************************
       table: mysql_group_replication_hostgroups
Create Table: CREATE TABLE mysql_group_replication_hostgroups (
    writer_hostgroup INT CHECK (writer_hostgroup&amp;gt;=0) NOT NULL PRIMARY KEY,
    backup_writer_hostgroup INT CHECK (backup_writer_hostgroup&amp;gt;=0 AND backup_writer_hostgroup&amp;lt;&amp;gt;writer_hostgroup) NOT NULL,
    reader_hostgroup INT NOT NULL CHECK (reader_hostgroup&amp;lt;&amp;gt;writer_hostgroup AND backup_writer_hostgroup&amp;lt;&amp;gt;reader_hostgroup AND reader_hostgroup&amp;gt;0),
    offline_hostgroup INT NOT NULL CHECK (offline_hostgroup&amp;lt;&amp;gt;writer_hostgroup AND offline_hostgroup&amp;lt;&amp;gt;reader_hostgroup AND backup_writer_hostgroup&amp;lt;&amp;gt;offline_hostgroup AND offline_hostgroup&amp;gt;=0),
    active INT CHECK (active IN (0,1)) NOT NULL DEFAULT 1,
    max_writers INT NOT NULL CHECK (max_writers &amp;gt;= 0) DEFAULT 1,
    writer_is_also_reader INT CHECK (writer_is_also_reader IN (0,1)) NOT NULL DEFAULT 0,
    max_transactions_behind INT CHECK (max_transactions_behind&amp;gt;=0) NOT NULL DEFAULT 0,
    comment VARCHAR,
    UNIQUE (reader_hostgroup),
    UNIQUE (offline_hostgroup),
    UNIQUE (backup_writer_hostgroup))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各字段的意义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;writer_hostgroup&lt;/code&gt;：默认的写组。后端&lt;code&gt;read_only=0&lt;/code&gt;的节点会自动分配到这个组中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backup_writer_hostgroup&lt;/code&gt;：如果后端MySQL集群有多个节点可写并设置了&lt;code&gt;max_writes&lt;/code&gt;字段的值，ProxySQL将会把其余的所有节点(超出&lt;code&gt;max_writes&lt;/code&gt;)都放进备写组&lt;code&gt;backup_writer_hostgroup&lt;/code&gt;中作为备份节点。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reader_hostgroup&lt;/code&gt;：负责读的组。查询规则或者只具有只读权限的用户的读请求都会路由到该主机组中的节点。后端&lt;code&gt;read_only=1&lt;/code&gt;的节点会自动分配到这个组中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offline_hostgroup&lt;/code&gt;：当ProxySQL监控并决定了某节点为&lt;code&gt;OFFLINE&lt;/code&gt;后，会将其放进组&lt;code&gt;offline_hostgroup&lt;/code&gt;中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;active&lt;/code&gt;：当启用后，ProxySQL会监控该主机组，并在不同组之间合理地移动节点。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_writers&lt;/code&gt;：该字段的值决定写组&lt;code&gt;writer_hostgroup&lt;/code&gt;中最大允许的节点数量，超出该数量的但允许写的节点都会放进备份组&lt;code&gt;backup_writer_hostgroup&lt;/code&gt;中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;writer_is_also_reader&lt;/code&gt;：决定一个节点升级为写节点(放进&lt;code&gt;writer_hostgroup&lt;/code&gt;)后是否仍然保留在&lt;code&gt;reader_hostgroup&lt;/code&gt;组中提供读服务。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_transactions_behind&lt;/code&gt;：当某节点延后于写节点时，为了防止读取到过期数据，ProxySQL可能会自动避开该节点。该字段决定最多延后写节点多少个事务(具体延后的事务数量可以从MySQL的&lt;code&gt;sys.gr_member_routing_candidate_status&lt;/code&gt;表中的&lt;code&gt;transaction_behind&lt;/code&gt;字段获取)，延后的事务数量超出该值时，ProxySQL就会自动避开这个节点。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comment&lt;/code&gt;：该字段用于说明、注释，可随便定义。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，writer_hostgroup是主键字段，reader_hostgroup、offline_hostgroup、backup_writer_hostgroup具有唯一性，它们的值都是INT数值。&lt;/p&gt;
&lt;p&gt;所以，ProxySQL代理每一个后端MGR集群时，&lt;strong&gt;都必须为这个MGR定义读组、写组、备写组、离线组&lt;/strong&gt;，且这四个组的值各不相同、不允许NULL、具有唯一性。此外，每个username还有一个默认组，一般这个默认组会设置为写组，这样在定义select规则时比较容易。&lt;/p&gt;

&lt;h2 id=&quot;proxysql代理mgr时必须考虑的问题&quot;&gt;1.2 ProxySQL代理MGR时必须考虑的问题&lt;/h2&gt;
&lt;p&gt;ProxySQL代理MGR时有几种情况：ProxySQL代理的MGR运行模式是单主模型还是多主模型，ProxySQL代理的是一个还是多个MGR集群。需要单独考虑这些不同的情况，它们影响ProxySQL如何分配组，甚至配置步骤不同。&lt;/p&gt;

&lt;h3 id=&quot;proxysql代理单主模型的mgr&quot;&gt;1.2.1 ProxySQL代理单主模型的MGR&lt;/h3&gt;
&lt;p&gt;MRG以单主模型运行时，有两个相关特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.非master节点会自动设置&lt;code&gt;read_only=1&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;2.master节点故障时，会自动选举新的master节点，选举时根据权重(group_replication_member_weigth，较老版本的组复制根据server_uuid按字典排序，值小的优先选为master)决定谁是新的master&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以ProxySQL代理单主MGR时，ProxySQL中 &lt;strong&gt;要设置对后端节点read_only值的监控&lt;/strong&gt; 。因为ProxySQL会根据read_only值自动调整读、写组中的节点，所以代理单主模型时非常方便。当然，如果不想让ProxySQL来自动调整MGR节点所属组，则无需设置read_only监控，见下文&quot;ProxySQL代理单个MGR集群&quot;中的描述。&lt;/p&gt;
&lt;p&gt;由于只有一个写节点，所以用不上备写组，但仍然需要定义好它。例如：&lt;br/&gt;写组 --&amp;gt;hg=10&lt;br/&gt;备写组 --&amp;gt;hg=20&lt;br/&gt;读组 --&amp;gt;hg=30&lt;br/&gt;离线组 --&amp;gt;hg=40&lt;/p&gt;

&lt;h3 id=&quot;proxysql代理多主模型的mgr&quot;&gt;1.2.2 ProxySQL代理多主模型的MGR&lt;/h3&gt;
&lt;p&gt;多主模型的MGR，可以同时有多个写节点，并且允许少数节点出现故障。&lt;/p&gt;
&lt;p&gt;仍然假设组的分配情况：&lt;/p&gt;
&lt;p&gt;写组 --&amp;gt;hg=10&lt;br/&gt;备写组 --&amp;gt;hg=20&lt;br/&gt;读组 --&amp;gt;hg=30&lt;br/&gt;离线组 --&amp;gt;hg=40&lt;/p&gt;
&lt;p&gt;192.168.100.{22,23,24}分别命名为node1、node2、node3节点。&lt;/p&gt;
&lt;p&gt;假设&lt;code&gt;max_writers=2&lt;/code&gt;，则node1、node2、node3其中2个节点(假设node1、node2)在写组hg=10中，node3在备写组hg=20中。此时必须设置&lt;code&gt;writer_is_also_reader=1&lt;/code&gt;，否则没有节点负责读操作，所以hg=30中有node1、node2、node3共3个节点。假如node2节点故障，node3节点将从hg=20转移到hg=10，读组hg=30也只有node1和node3，node2会转移到hg=40中，并ProxySQL不断监控它是否上线。&lt;/p&gt;
&lt;p&gt;所以，ProxySQL代理多主模型的MGR时，&lt;strong&gt;必须设置&lt;/strong&gt;&lt;code&gt;writer_is_also_reader=1&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;proxysql代理单个mgr集群&quot;&gt;1.2.3 ProxySQL代理单个MGR集群&lt;/h3&gt;
&lt;p&gt;ProxySQL代理单个MGR集群时，如果不定制复杂的路由规则，完全由ProxySQL来控制读、写组的节点分配，那么在&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;表中只能有一条记录。&lt;/p&gt;
&lt;p&gt;但是如果想要实现复杂的需求，例如想要将开销大的select语句路由到某个固定的slave上或自定义的某个hostgroup中，就不能再让ProxySQL来管理MGR，这时不能在&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;中插入和该MGR集群有关的记录(如果可以，也不要去监控read_only值)，而是在mysql_servers中定义好目标组。这种情况下，ProxySQL不关心后端是MGR还是普通的MySQL实例。&lt;/p&gt;

&lt;h3 id=&quot;proxysql代理多个mgr集群&quot;&gt;1.2.4 ProxySQL代理多个MGR集群&lt;/h3&gt;
&lt;p&gt;很不幸，ProxySQL的&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;表对多MGR集群并不友好。因为ProxySQL通过监控read_only值来自动调整节点所属组。如果ProxySQL代理两个MGR集群X、Y，在&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;添加一条记录后，MGR集群X、Y中的节点都会加入到这条记录所定义的组中，于是两个MGR集群就混乱了。添加多条记录也无济于事，因为这个表中并没有识别集群的方法。其实&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;也一样存在这样的问题。&lt;/p&gt;
&lt;p&gt;这时只能在mysql_servers中对不同MGR集群中的各个节点定义好所属组，然后在规则中指定路由目标。也就是说，用不上&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;表，也无需去监控read_only值。&lt;/p&gt;

&lt;h2 id=&quot;配置组复制&quot;&gt;1.3 配置组复制&lt;/h2&gt;
&lt;p&gt;本文配置的单主模型的组复制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.设置主机名和DNS解析(必须保证各mysql实例的主机名不一致，且能通过主机名找到各成员)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# node1上：
hostnamectl set-hostname --static node1.longshuai.com
hostnamectl -H root@192.168.100.23 set-hostname node2.longshuai.com
hostnamectl -H root@192.168.100.24 set-hostname node3.longshuai.com

# 写/etc/hosts
# node1上：
cat &amp;gt;&amp;gt;/etc/hosts&amp;lt;&amp;lt;eof
    192.168.100.22 node1.longshuai.com
    192.168.100.23 node2.longshuai.com
    192.168.100.24 node3.longshuai.com
eof
scp /etc/hosts 192.168.100.23:/etc
scp /etc/hosts 192.168.100.24:/etc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.提供node1、node2、node3的配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;node1的/etc/my.cnf内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
datadir=/data
socket=/data/mysql.sock

server-id=100                      # 各节点不一致
gtid_mode=on                       
enforce_gtid_consistency=on        
log-bin=/data/master-bin           
binlog_format=row                  
binlog_checksum=none               
master_info_repository=TABLE       
relay_log_info_repository=TABLE    
relay_log=/data/relay-log          
log_slave_updates=ON               
sync-binlog=1                      
log-error=/data/error.log
pid-file=/data/mysqld.pid

transaction_write_set_extraction=XXHASH64         
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;  
loose-group_replication_start_on_boot=off 
loose-group_replication_member_weigth = 40     # 建议各节点设置不同值
loose-group_replication_local_address=&quot;192.168.100.22:20002&quot;  # 各节点不一致
loose-group_replication_group_seeds=&quot;192.168.100.22:20002,192.168.100.23:20003,,192.168.100.24:20004&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;node2和node3的配置文件只需修改几项需要不一致的值即可：&lt;/p&gt;
&lt;p&gt;以下为node2的/etc/my.cnf的部分内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server-id=110
loose-group_replication_member_weigth = 30
loose-group_replication_local_address=&quot;192.168.100.23:20003&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下为node3的/etc/my.cnf的部分内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server-id=120
loose-group_replication_member_weigth = 20
loose-group_replication_local_address=&quot;192.168.100.24:20004&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.启动node1，引导组复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先启动node1的MySQL服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl start mysqld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连上node1节点，创建用于复制的用户。我这里创建的用户为repl，密码为P@ssword1!。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create user repl@'192.168.100.%' identified by 'P@ssword1!';
grant replication slave on *.* to repl@'192.168.100.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在node1上配置恢复通道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;change master to 
            master_user='repl',
            master_password='P@ssword1!'
            for channel 'group_replication_recovery';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装组复制插件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;install plugin group_replication soname 'group_replication.so';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引导、启动组复制功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set @@global.group_replication_bootstrap_group=on;
start group_replication;
set @@global.group_replication_bootstrap_group=off;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看node1是否ONLINE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from performance_schema.replication_group_members\G&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.添加node2、node3到复制组中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先启动node2和node3的mysql服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl start mysqld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再在node2和node3上指定恢复通道，从Donor处恢复数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;change master to 
            master_user='repl',
            master_password='P@ssword1!'
            for channel 'group_replication_recovery';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，在node2和node3上安装组复制插件，并启动组复制功能即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;install plugin group_replication soname 'group_replication.so';
start group_replication;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在任意一个节点上查看node1、node2、node3是否都是ONLINE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from performance_schema.replication_group_members\G

*************************** 1. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a5165443-6aec-11e8-a8f6-000c29827955
 MEMBER_HOST: node1.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 2. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: ba505889-6aec-11e8-a864-000c29b0bec4
 MEMBER_HOST: node2.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 3. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: bf12fe97-6aec-11e8-a909-000c29e55287
 MEMBER_HOST: node3.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，node1、node2、node3组成的3节点单主模型的组复制配置完成。下面配置ProxySQL。&lt;/p&gt;

&lt;h2 id=&quot;配置proxysql&quot;&gt;1.4 配置ProxySQL&lt;/h2&gt;
&lt;p&gt;根据前文的分析，ProxySQL代理单主模型组复制时，如果想让ProxySQL来自动调整节点所属读、写组，需要开启read_only监控，并在&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;表中插入一条记录。&lt;/p&gt;
&lt;p&gt;假设4种组的hostgroup_id为：&lt;br/&gt;写组 --&amp;gt;hg=10&lt;br/&gt;备写组 --&amp;gt;hg=20&lt;br/&gt;读组 --&amp;gt;hg=30&lt;br/&gt;离线组 --&amp;gt;hg=40&lt;/p&gt;
&lt;p&gt;安装ProxySQL的过程略。以下是配置ProxySQL的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.连上ProxySQL的Admin管理接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uadmin -padmin -h127.0.0.1 -P6032 --prompt 'Admin&amp;gt; '&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.向 mysql_servers 表中添加后端节点node1、node2和node3&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delete from mysql_servers;

insert into mysql_servers(hostgroup_id,hostname,port) 
values(10,'192.168.100.22',3306),
      (10,'192.168.100.23',3306),
      (10,'192.168.100.24',3306);

load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看3个节点是否都是ONLINE&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id,hostname,port,status,weight from mysql_servers;
+--------------+----------------+------+--------+--------+
| hostgroup_id | hostname       | port | status | weight |
+--------------+----------------+------+--------+--------+
| 10           | 192.168.100.22 | 3306 | ONLINE | 1      |
| 10           | 192.168.100.23 | 3306 | ONLINE | 1      |
| 10           | 192.168.100.24 | 3306 | ONLINE | 1      |
+--------------+----------------+------+--------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.监控后端节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，在node1上创建ProxySQL用于监控的用户。注意，这里监控用户的权限和ProxySQL代理普通mysql实例不一样，ProxySQL代理组复制时，是从MGR的系统视图&lt;code&gt;sys.gr_member_routing_candidate_status&lt;/code&gt;中获取监控指标，所以授予监控用户对该视图的查询权限，因为无需从&lt;code&gt;show slave status&lt;/code&gt;中获取&lt;code&gt;Seconds_Behind_Master&lt;/code&gt;，所以无需replication client权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在node1上执行：
mysql&amp;gt; create user monitor@'192.168.100.%' identified by 'P@ssword1!';
mysql&amp;gt; grant select on sys.* to monitor@'192.168.100.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后回到ProxySQL上配置监控。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set mysql-monitor_username='monitor';
set mysql-monitor_password='P@ssword1!';

load mysql variables to runtime;
save mysql variables to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.创建系统视图&lt;code&gt;sys.gr_member_routing_candidate_status&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在node1节点上，创建系统视图&lt;code&gt;sys.gr_member_routing_candidate_status&lt;/code&gt;，该视图将为ProxySQL提供组复制相关的监控状态指标。&lt;/p&gt;
&lt;p&gt;如果前面下载了addition_to_sys.sql脚本，执行如下语句导入MySQL即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uroot -pP@ssword1! &amp;lt; addition_to_sys.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以执行如下语句创建该系统视图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;USE sys;

DELIMITER $$

CREATE FUNCTION IFZERO(a INT, b INT)
RETURNS INT
DETERMINISTIC
RETURN IF(a = 0, b, a)$$

CREATE FUNCTION LOCATE2(needle TEXT(10000), haystack TEXT(10000), offset INT)
RETURNS INT
DETERMINISTIC
RETURN IFZERO(LOCATE(needle, haystack, offset), LENGTH(haystack) + 1)$$

CREATE FUNCTION GTID_NORMALIZE(g TEXT(10000))
RETURNS TEXT(10000)
DETERMINISTIC
RETURN GTID_SUBTRACT(g, '')$$

CREATE FUNCTION GTID_COUNT(gtid_set TEXT(10000))
RETURNS INT
DETERMINISTIC
BEGIN
  DECLARE result BIGINT DEFAULT 0;
  DECLARE colon_pos INT;
  DECLARE next_dash_pos INT;
  DECLARE next_colon_pos INT;
  DECLARE next_comma_pos INT;
  SET gtid_set = GTID_NORMALIZE(gtid_set);
  SET colon_pos = LOCATE2(':', gtid_set, 1);
  WHILE colon_pos != LENGTH(gtid_set) + 1 DO
     SET next_dash_pos = LOCATE2('-', gtid_set, colon_pos + 1);
     SET next_colon_pos = LOCATE2(':', gtid_set, colon_pos + 1);
     SET next_comma_pos = LOCATE2(',', gtid_set, colon_pos + 1);
     IF next_dash_pos &amp;lt; next_colon_pos AND next_dash_pos &amp;lt; next_comma_pos THEN
       SET result = result +
         SUBSTR(gtid_set, next_dash_pos + 1,
                LEAST(next_colon_pos, next_comma_pos) - (next_dash_pos + 1)) -
         SUBSTR(gtid_set, colon_pos + 1, next_dash_pos - (colon_pos + 1)) + 1;
     ELSE
       SET result = result + 1;
     END IF;
     SET colon_pos = next_colon_pos;
  END WHILE;
  RETURN result;
END$$

CREATE FUNCTION gr_applier_queue_length()
RETURNS INT
DETERMINISTIC
BEGIN
  RETURN (SELECT sys.gtid_count( GTID_SUBTRACT( (SELECT
Received_transaction_set FROM performance_schema.replication_connection_status
WHERE Channel_name = 'group_replication_applier' ), (SELECT
@@global.GTID_EXECUTED) )));
END$$

CREATE FUNCTION gr_member_in_primary_partition()
RETURNS VARCHAR(3)
DETERMINISTIC
BEGIN
  RETURN (SELECT IF( MEMBER_STATE='ONLINE' AND ((SELECT COUNT(*) FROM
performance_schema.replication_group_members WHERE MEMBER_STATE != 'ONLINE') &amp;gt;=
((SELECT COUNT(*) FROM performance_schema.replication_group_members)/2) = 0),
'YES', 'NO' ) FROM performance_schema.replication_group_members JOIN
performance_schema.replication_group_member_stats USING(member_id));
END$$

CREATE VIEW gr_member_routing_candidate_status AS SELECT
sys.gr_member_in_primary_partition() as viable_candidate,
IF( (SELECT (SELECT GROUP_CONCAT(variable_value) FROM
performance_schema.global_variables WHERE variable_name IN ('read_only',
'super_read_only')) != 'OFF,OFF'), 'YES', 'NO') as read_only,
sys.gr_applier_queue_length() as transactions_behind, Count_Transactions_in_queue as 'transactions_to_cert' from performance_schema.replication_group_member_stats;$$

DELIMITER ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;视图创建后，可以查看该视图：&lt;/p&gt;
&lt;p&gt;node1上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from sys.gr_member_routing_candidate_status;
+------------------+-----------+---------------------+----------------------+
| viable_candidate | read_only | transactions_behind | transactions_to_cert |
+------------------+-----------+---------------------+----------------------+
| YES              | NO        |                   0 |                    0 |
+------------------+-----------+---------------------+----------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;node2上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from sys.gr_member_routing_candidate_status;
+------------------+-----------+---------------------+----------------------+
| viable_candidate | read_only | transactions_behind | transactions_to_cert |
+------------------+-----------+---------------------+----------------------+
| YES              | YES       |                   0 |                    0 |
+------------------+-----------+---------------------+----------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.向&lt;code&gt;mysql_group_replication_hostgroups&lt;/code&gt;中插入记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delete from mysql_group_replication_hostgroups;

insert into mysql_group_replication_hostgroups(writer_hostgroup,backup_writer_hostgroup,reader_hostgroup,offline_hostgroup,active,max_writers,writer_is_also_reader,max_transactions_behind) 
values(10,20,30,40,1,1,0,0);

load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述配置中，我把writer_is_also_reader设置为false，让master只负责写操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_group_replication_hostgroups\G
*************************** 1. row ***************************
       writer_hostgroup: 10
backup_writer_hostgroup: 20
       reader_hostgroup: 30
      offline_hostgroup: 40
                 active: 1
            max_writers: 1
  writer_is_also_reader: 0
max_transactions_behind: 0
                comment: NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看看节点的分组调整情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id, hostname, port,status from runtime_mysql_servers;
+--------------+----------------+------+--------+
| hostgroup_id | hostname       | port | status |
+--------------+----------------+------+--------+
| 10           | 192.168.100.22 | 3306 | ONLINE |
| 30           | 192.168.100.24 | 3306 | ONLINE |
| 30           | 192.168.100.23 | 3306 | ONLINE |
+--------------+----------------+------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看对MGR的监控指标。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Admin&amp;gt; select  hostname,
               port,
               viable_candidate,
               read_only,
               transactions_behind,
               error 
       from mysql_server_group_replication_log 
       order by time_start_us desc 
       limit 6;
+----------------+------+------------------+-----------+---------------------+-------+
| hostname       | port | viable_candidate | read_only | transactions_behind | error |
+----------------+------+------------------+-----------+---------------------+-------+
| 192.168.100.24 | 3306 | YES              | YES       | 0                   | NULL  |
| 192.168.100.23 | 3306 | YES              | YES       | 0                   | NULL  |
| 192.168.100.22 | 3306 | YES              | NO        | 0                   | NULL  |
| 192.168.100.24 | 3306 | YES              | YES       | 0                   | NULL  |
| 192.168.100.23 | 3306 | YES              | YES       | 0                   | NULL  |
| 192.168.100.22 | 3306 | YES              | NO        | 0                   | NULL  |
+----------------+------+------------------+-----------+---------------------+-------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.配置mysql_users&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在node1节点上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grant all on *.* to root@'192.168.100.%' identified by 'P@ssword1!';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到ProxySQL，向mysql_users表插入记录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delete from mysql_users;

insert into mysql_users(username,password,default_hostgroup,transaction_persistent) 
values('root','P@ssword1!',10,1);

load mysql users to runtime;
save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7.配置测试用的读写分离规则&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;delete from mysql_query_rules;

insert into mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply)
VALUES (1,1,'^SELECT.*FOR UPDATE$',10,1),
       (2,1,'^SELECT',30,1);

load mysql query rules to runtime;
save mysql query rules to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试是否按预期进行读写分离。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uroot -pP@ssword1! -h192.168.100.21 -P6033 -e 'create database gr_test;'
mysql -uroot -pP@ssword1! -h192.168.100.21 -P6033 -e 'select user,host from mysql.user;' 
mysql -uroot -pP@ssword1! -h192.168.100.21 -P6033 -e 'show databases;' &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看语句路由状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup,digest_text from stats_mysql_query_digest;  
+-----------+----------------------------------+
| hostgroup | digest_text                      |
+-----------+----------------------------------+
| 10        | show databases                   |
| 30        | select user,host from mysql.user |
| 10        | create database gr_test          |
| 10        | select @@version_comment limit ? |
+-----------+----------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;select语句路由到读组hg=30上，show操作按照默认主机组路由到hg=10，create操作路由到hg=10这个写组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.测试MGR故障转移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将MGR的某个节点停掉，例如直接关闭当前master节点node1的mysql服务。&lt;/p&gt;
&lt;p&gt;在node1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl stop mysqld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，看看ProxySQL上的节点状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id, hostname, port,status from runtime_mysql_servers;
+--------------+----------------+------+---------+
| hostgroup_id | hostname       | port | status  |
+--------------+----------------+------+---------+
| 10           | 192.168.100.23 | 3306 | ONLINE  |
| 40           | 192.168.100.22 | 3306 | SHUNNED |
| 30           | 192.168.100.24 | 3306 | ONLINE  |
+--------------+----------------+------+---------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示node1的状态为&lt;code&gt;SHUNNED&lt;/code&gt;，表示该节点被ProxySQL避开了。且node2节点移到了hg=10的组中，说明该节点被选举为了新的Master节点。&lt;/p&gt;
&lt;p&gt;再将node1加回组中。在node1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shell&amp;gt; systemctl start mysqld

mysql&amp;gt; start group_replication;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，看看ProxySQL上的节点状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id, hostname, port,status from runtime_mysql_servers;
+--------------+----------------+------+--------+
| hostgroup_id | hostname       | port | status |
+--------------+----------------+------+--------+
| 10           | 192.168.100.23 | 3306 | ONLINE |
| 30           | 192.168.100.22 | 3306 | ONLINE |
| 30           | 192.168.100.24 | 3306 | ONLINE |
+--------------+----------------+------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，node1已经重新ONLINE。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Jul 2018 11:22:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9383126.html</dc:identifier>
</item>
</channel>
</rss>