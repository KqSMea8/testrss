<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>git操作之冲突解决 - python学习中</title>
<link>http://www.cnblogs.com/c-x-a/p/9963817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-x-a/p/9963817.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;68&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;应用场景，任哥，我两个人共同修改了git项目上的一个文件。zsh命令行模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-1&quot;&gt;&lt;span&gt;简写命令解释&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;gl=git pull&lt;br/&gt;gp=git push&lt;br/&gt;gst=git status&lt;br/&gt;gcmsg=git commit -m&lt;/p&gt;
&lt;h4 id=&quot;h-2&quot;&gt;&lt;span&gt;操作演示文件&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;test_git.py&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;hdeveloper&quot;&gt;&lt;span&gt;切换到分级developer&lt;/span&gt;&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;git&lt;/span&gt; checkout developer&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;1 &lt;br/&gt;2&lt;br/&gt;3&lt;br/&gt;4&lt;br/&gt;5&lt;br/&gt;6&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;正常情况&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h7&quot;&gt;&lt;span&gt;任哥修改了文件添加了一个7&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;然后执行了以下命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;git&lt;/span&gt; commit -m &lt;span class=&quot;hljs-string&quot;&gt;&quot;add 1-6 to py file&quot;&lt;/span&gt; .&lt;br/&gt;git push&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img title=&quot;任哥的命令操作&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143557236-221213931.png&quot; alt=&quot;任哥的命令操作&quot;/&gt;任哥的命令操作
&lt;h4 id=&quot;hpull&quot;&gt;&lt;span&gt;我pull了一下&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;简写gl&lt;/p&gt;
&lt;img title=&quot;我pull了一下&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143605394-996205708.jpg&quot; alt=&quot;我pull了一下&quot;/&gt;我pull了一下&lt;br/&gt;看

&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;test_git.py | 1+&lt;br/&gt;1 file changed,1 insertion(+)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现我这多了一个文件。&lt;/p&gt;
&lt;h3 id=&quot;h-4&quot;&gt;&lt;span&gt;冲突开始&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h-5&quot;&gt;&lt;span&gt;任哥对原文件进行如下修改：&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;任哥添加了个7&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143613895-869713946.png&quot; alt=&quot;任哥添加了个7&quot;/&gt;任哥添加了个7&lt;br/&gt;然后执行一下的命令

&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;git&lt;/span&gt; commit -m &lt;span class=&quot;hljs-string&quot;&gt;&quot;add 7 to py file&quot;&lt;/span&gt; .&lt;br/&gt;git push&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img title=&quot;命令截图&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143627585-1348299820.png&quot; alt=&quot;命令截图&quot;/&gt;命令截图
&lt;h4 id=&quot;h-6&quot;&gt;&lt;span&gt;我同样修改了文件内容如下：&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;我添加了个8&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143621223-377801969.jpg&quot; alt=&quot;我添加了个8&quot;/&gt;我添加了个8&lt;br/&gt;然后git pull了一下出现下图&lt;br/&gt;&lt;img title=&quot;error:合并冲突&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143634475-469800664.jpg&quot; alt=&quot;error:合并冲突&quot;/&gt;error:合并冲突&lt;br/&gt;然后我执行了git status&lt;br/&gt;&lt;img title=&quot;查看状态&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143642405-1722181073.jpg&quot; alt=&quot;查看状态&quot;/&gt;查看状态&lt;br/&gt;发现红字modified test_git.py 意思是这个文件修改了，因为任哥修改了文件并提交了，我本地也修改了。&lt;br/&gt;根据提示 如果修改了文件执行git add，然后执行git commit，如果没有修改直接执行git commit。

&lt;p&gt;我没有注意提示直接执行了git commit而没有执行git add 出现了如下错误。&lt;br/&gt;具体命令如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;git&lt;/span&gt; commit -m &lt;span class=&quot;hljs-string&quot;&gt;&quot;add 8 to file&quot;&lt;/span&gt; . &lt;br/&gt;git push &lt;br/&gt;git pull&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看最后一行fix conflicts and run &quot;git commit&quot;。让我解决冲突再次提交，此时发现命令行多了个状态&amp;gt;M&amp;lt;，这个符号告诉我们当前处于merge状态。&lt;/p&gt;
&lt;img title=&quot;没有使用add直接提交&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143649600-270852996.jpg&quot; alt=&quot;没有使用add直接提交&quot;/&gt;没有使用add直接提交&lt;br/&gt;然后我再执行git status查看状态&lt;br/&gt;&lt;img title=&quot;查看冲突状态&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143655379-986352639.jpg&quot; alt=&quot;查看冲突状态&quot;/&gt;查看冲突状态
&lt;p&gt;发现红色字体both modified :test_git.py.两个文件都修改了&lt;br/&gt;这个时候我们就需要看看这个文件发生了什么 发现多了一些看不懂的内容，内容如下:&lt;/p&gt;
&lt;img title=&quot;此时文件内容&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143708526-736061059.jpg&quot; alt=&quot;此时文件内容&quot;/&gt;此时文件内容
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;HEAD&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;&lt;br/&gt;======&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;一串字符串&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;冲突的部分使用&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;进行了内容标示，=====将内容分为了两部分，8上面标有HEAD，一般己方修改的会标有HEAD，====下面的7是任哥，添加的。此时我需要做的就是和任哥确认是留8还是7，经过商量最后留我的数字8，然后我需要做的就是修改上面的内容为下面内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;8&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面对这次修改的内容做了一次解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;HEAD  &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;&lt;br/&gt;======  &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;一串字符串  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行&lt;br/&gt;git commit之后执行git push，完成本次修改。&lt;br/&gt;最后习惯性的执行一次git pull 确认是最新的代码。&lt;/p&gt;
&lt;img title=&quot;最后提交&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143743737-1917199238.jpg&quot; alt=&quot;最后提交&quot;/&gt;最后提交&lt;br/&gt;&lt;img title=&quot;拉取最新的代码&quot; src=&quot;https://img2018.cnblogs.com/blog/736399/201811/736399-20181115143750842-1970853031.jpg&quot; alt=&quot;拉取最新的代码&quot;/&gt;拉取最新的代码
&lt;p&gt;显示&lt;strong&gt;Everything up-to-date&lt;/strong&gt;即最新代码&lt;/p&gt;
&lt;p&gt;更多工具使用以及python技巧，请关注公众号：python学习开发。&lt;/p&gt;
&lt;p&gt;如果您喜欢我的文章不防动动小手转发一波&lt;img src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_02.png?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_02.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;img src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_02.png?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_02.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;img src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_02.png?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-src=&quot;https://res.wx.qq.com/mpres/htmledition/images/icon/common/emotion_panel/emoji_wx/2_02.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;，谢谢。&lt;br/&gt;点击阅读原文进入我的博客园，看代码更方便。由于人数超过100所以需要添加我微信:&lt;strong&gt;italocxa&lt;/strong&gt;，然后拉您入群。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 15 Nov 2018 07:30:00 +0000</pubDate>
<dc:creator>python学习中</dc:creator>
<og:description>应用场景，任哥，我两个人共同修改了git项目上的一个文件。zsh命令行模式 准备工作 简写命令解释 gl=git pullgp=git pushgst=git statusgcmsg=git comm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-x-a/p/9963817.html</dc:identifier>
</item>
<item>
<title>JavaScript之深拷贝和浅拷贝 - 蟹丸</title>
<link>http://www.cnblogs.com/ccylovehs/p/9963513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccylovehs/p/9963513.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;工作中会经常遇到操作数组、对象的情况，你肯定会将原数组、对象进行‘备份’&lt;br/&gt;当真正对其操作时发现备份的也发生改变，此时你一脸懵逼，到时是为啥，不是已经备份了么，怎么备份的数组、对象也会发生变化。&lt;br/&gt;如果你对拷贝原理理解的不透彻，此文或许能提供一点帮助。&lt;/p&gt;
&lt;h2&gt;javascript数据类型&lt;/h2&gt;
&lt;h3&gt;基本数据类型&lt;/h3&gt;
&lt;p&gt;string、number、null、undefined、boolean、symbol(ES6新增) 变量值存放在栈内存中，可直接访问和修改变量的值&lt;br/&gt;基本数据类型不存在拷贝，好比如说你无法修改数值1的值&lt;/p&gt;
&lt;h3&gt;引用类型&lt;/h3&gt;
&lt;p&gt;Object Function RegExp Math Date 值为对象，存放在堆内存中&lt;br/&gt;在栈内存中变量保存的是一个指针，指向对应在堆内存中的地址。&lt;br/&gt;当访问引用类型的时候，要先从栈中取出该对象的地址指针，然后再从堆内存中取得所需的数据&lt;/p&gt;
&lt;h2&gt;浅拷贝&lt;/h2&gt;
&lt;p&gt;为什么备份的数组对象也会发生变化，这里就涉及到你用的‘备份’其实是一种浅拷贝&lt;/p&gt;
&lt;h3&gt;简单的引用拷贝&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = [1,2,3,4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a;
a[&lt;/span&gt;0] = 0&lt;span&gt;;
console.log(a,b);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201811/996357-20181115130359573-897600653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到数组a直接赋值给b，a、b引用的其实是一个对象地址，只要地址值发生变化，a、b栈内存指针指向的堆地址也会发生变化，这种引用拷贝只是新增了一个变量栈内存的指针，意义不大&lt;/p&gt;
&lt;h3&gt;数组的concat、slice，对象的assign拷贝&lt;/h3&gt;
&lt;p&gt;同样的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = [1,2,3,4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a.concat();
a[&lt;/span&gt;0] = 0&lt;span&gt;;
console.log(a,b);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201811/996357-20181115131035210-1459023144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时数组a[0]值变成0，b数组依然保持不变，有同学就问了，这不就是深拷贝吗。&lt;/p&gt;
&lt;p&gt;对，也不对， &lt;span class=&quot;cnblogs_code&quot;&gt;Array.prototype.slice&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;Array.prototype.concat&lt;/span&gt; 看似深拷贝，其实质上还是浅拷贝&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = [1,2,[3,4],{name:'ccy'&lt;span&gt;}];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a.concat();
a[&lt;/span&gt;3].name = 'hs'&lt;span&gt;;
console.log(a[&lt;/span&gt;3],b[3]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201811/996357-20181115131634852-1831000913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当数组a中包含对象时， &lt;span class=&quot;cnblogs_code&quot;&gt;Array.prototype.slice&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;Array.prototype.cancat&lt;/span&gt; 拷贝出来数组中的对象还是共享同一内存地址，所以本质上归属浅拷贝&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;Object.assign&lt;/span&gt; 原理也是一样的（对于对象的属性都为基本类型可以当成深拷贝）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = {age:18,name:'ccy',info:{address:'wuhan',interest:'playCards'&lt;span&gt;}};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; Object.assign(a);
a.info.address &lt;/span&gt;= 'shenzhen'&lt;span&gt;;
console.log(a.info,b.info);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201811/996357-20181115132759805-845024100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那怎样才能对对象进行深拷贝呢，请扶好眼镜。&lt;/p&gt;
&lt;p&gt;自定义深拷贝函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; clone = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; construct = Object.prototype.toString.call(obj).slice(8,-1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; res;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(construct === 'Array'&lt;span&gt;){
            res &lt;/span&gt;=&lt;span&gt; [];
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(construct === 'Object'&lt;span&gt;){
            res &lt;/span&gt;=&lt;span&gt; {}
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; obj[item] === 'object'&lt;span&gt;){
                res[item] &lt;/span&gt;=&lt;span&gt; clone(obj[item]);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                res[item] &lt;/span&gt;=&lt;span&gt; obj[item];
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;乍一看好像能处理对象的属性为对象的问题，可以循环遍历直至属性为基本类型；&lt;/p&gt;
&lt;p&gt;但是仔细想，如果遇到对象的属性存在相互引用的话会出现死循环的情况。可以再加一次判断，对象的属性如果引用对象指针则跳出当前循环。&lt;/p&gt;
&lt;h2&gt;深拷贝&lt;/h2&gt;
&lt;p&gt;深拷贝是可以完美的解决浅拷贝的弊端，重新开辟一块地址，深拷贝出来的属性的基本类型值都是相同的。&lt;/p&gt;
&lt;h3&gt;JSON内置对象深拷贝&lt;/h3&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;JSON&lt;/span&gt; 对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = {age:1,name:'ccy',info:{address:'wuhan',interest:'playCards'&lt;span&gt;}};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; JSON.parse(JSON.stringify(a));
a.info.address &lt;/span&gt;= 'shenzhen'&lt;span&gt;;
console.log(a.info,b.info);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201811/996357-20181115135226319-1509372019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;JSON&lt;/span&gt; 可处理一般的对象进行深拷贝，但是不能处理函数、正则等对象&lt;/p&gt;
&lt;p&gt; 我们可以对自定义的拷贝函数再进行优化 &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; clone = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getType(obj){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.prototype.toString.call(obj).slice(8,-1&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getReg(a){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = a.lastIndexOf('/'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg = a.substring(1&lt;span&gt;,c);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; escMap = {'&quot;': '\\&quot;', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t', '\w': '\\w', '\s': '\\s', '\d': '\\d'&lt;span&gt;};
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; escMap){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(reg.indexOf(i)){
                    reg.replace(i,escMap[i]);
                }
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attr = a.substring(c+1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RegExp(reg, attr);
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; construct =&lt;span&gt; getType(obj);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; res;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(construct === 'Array'&lt;span&gt;){
            res &lt;/span&gt;=&lt;span&gt; [];
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(construct === 'Object'&lt;span&gt;){
            res &lt;/span&gt;=&lt;span&gt; {}
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj[item] === obj) &lt;span&gt;continue&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存在引用则跳出当前循环&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(getType(obj[item]) === 'Function'&lt;span&gt;){
                res[item] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Function(&quot;return &quot;+&lt;span&gt;obj[item].toString())();
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(getType(obj[item]) === 'RegExp'&lt;span&gt;){
                res[item] &lt;/span&gt;=&lt;span&gt; getReg(obj[item].toString());
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(getType(obj[item]) === 'Object'&lt;span&gt;){
                res[item] &lt;/span&gt;=&lt;span&gt; clone(obj[item]);
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                res[item] &lt;/span&gt;=&lt;span&gt; obj[item];
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/996357/201811/996357-20181115145225724-46928109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;基本可以实现函数、正则对象的深拷贝，在本地只做了简单的测试，如果存在问题，请及时评论指出。&lt;/p&gt;
&lt;p&gt; 当然像函数库 &lt;span class=&quot;cnblogs_code&quot;&gt;lodash&lt;/span&gt; 的 _.cloneDeep、 &lt;span class=&quot;cnblogs_code&quot;&gt;JQuery&lt;/span&gt; 的 $.extend都实现了深拷贝，有兴趣的同学可自行看下源码。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;MDN&quot; href=&quot;https://developer.mozilla.org/zh-CN/search?q=%E6%B7%B1%E6%8B%B7%E8%B4%9D&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/zh-CN/search?q=%E6%B7%B1%E6%8B%B7%E8%B4%9D&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;github&quot; href=&quot;https://github.com/wengjq/Blog/issues/3&quot; target=&quot;_blank&quot;&gt;https://github.com/wengjq/Blog/issues/3&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 06:57:00 +0000</pubDate>
<dc:creator>蟹丸</dc:creator>
<og:description>前言 工作中会经常遇到操作数组、对象的情况，你肯定会将原数组、对象进行‘备份’当真正对其操作时发现备份的也发生改变，此时你一脸懵逼，到时是为啥，不是已经备份了么，怎么备份的数组、对象也会发生变化。如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccylovehs/p/9963513.html</dc:identifier>
</item>
<item>
<title>Google 的 QUIC 华丽转身成为下一代网络协议： HTTP/3.0 - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/http_over_quic.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/http_over_quic.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fx7wjepg30j30rs0btt9d.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTP/2.0 还没有普及，HTTP/3.0 标准就要被制定了。&lt;/p&gt;
&lt;p&gt;据 IETF 透露，&lt;strong&gt;HTTP-over-QUIC 实验协议将被重命名为 HTTP/3，并成为 HTTP 协议的第三个正式版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;IETF 是 Internet Engineering Task Force 的缩写，意思是&lt;strong&gt;互联网工程任务小组&lt;/strong&gt;，主要负责互联网标准的开发和推动。被他们“钦定”，HTTP-over-QUIC 成为HTTP/3.0 算是没跑了。&lt;/p&gt;
&lt;h3 id=&quot;quic&quot;&gt;QUIC&lt;/h3&gt;
&lt;p&gt;先来了解一下什么是 QUIC。&lt;/p&gt;
&lt;p&gt;QUIC（Quick UDP Internet Connections），是&lt;strong&gt;快速 UDP 互联网连接&lt;/strong&gt;的缩写，这是一种实验性的传输层协议，由 Google 开发，在 2013 年实现。&lt;/p&gt;
&lt;p&gt;QUIC 是基于 UDP 协议，它在两个端点之间创建连接，且支持多路复用。在设计之初 QUIC 希望能够提供等同于 SSL/TLS 层级的安全保障的同时，减少数据传输及创建连接时的延迟时间，双向控制带宽，从而达到更快速的体验。&lt;/p&gt;
&lt;p&gt;QUIC 相比现在广泛应用的 HTTP2 + TCP + TLS 协议有如下的优势：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少 TCP 三次握手及 TLS 握手时间。&lt;/li&gt;
&lt;li&gt;改进的拥塞控制。&lt;/li&gt;
&lt;li&gt;避免队头阻塞的多路复用。&lt;/li&gt;
&lt;li&gt;连接迁移。&lt;/li&gt;
&lt;li&gt;前向冗余纠错。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;HTTP-over-QUIC 算是 QUIC 协议的一种应用实现，而在 IETF 开始标准化该协议时，也有意将它分为两层：&lt;strong&gt;传输&lt;/strong&gt;和 &lt;strong&gt;HTTP&lt;/strong&gt; 部分。&lt;/p&gt;
&lt;p&gt;这个想法也是想将 QUIC 传输的部分独立出来，这样可以方便的用于其他场景下的数据传输，而不仅仅为 HTTP 或者其他类 HTTP 的协议使用。&lt;/p&gt;
&lt;h3 id=&quot;google-与-quic&quot;&gt;Google 与 QUIC&lt;/h3&gt;
&lt;p&gt;Google 一直在对协议标准上做努力，早年间提出的 SPDY 协议，被 IETF 标准化之后推出了类似于 SPDY 的 HTTP/2.0 协议标准，Google 立即宣布放弃对 SPDY 的支持，转而支持 HTTP/2。而 QUIC 也是 Google 提出的一种基于 UDP 的传输协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Google 希望 QUIC 能够慢慢取代 TCP 和 UDP，成为移动互联网上，二进制数据传输的新协议。&lt;/strong&gt;通过 Google 的测试证明，QUIC 更快也更安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fx7vseisqbj30aa05i74b.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;quic-即-http3.0&quot;&gt;QUIC 即 HTTP/3.0&lt;/h3&gt;
&lt;p&gt;QUIC 虽然在 2013 年就被 Google 提出，但是直到 2015 年才被提议作为 IETF 的标准草案，并在一年之后，就是 2016 年 7 月，提出了 HTTP-over-QUIC。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNbRwly1fx7whzheedj30lc0cj0t8.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上个月的邮件讨论中，IETF HTTP 和 QUIC 工作组主席 Mark Nottingham 正式提出将 HTPP-over-QUIC 重命名为 HTTP/3.0。随后的几天讨论中，此项提议被 IETF 成员接受，并给出了官方认可。&lt;/p&gt;
&lt;p&gt;自此，HTTP-over-QUIC 正式成为 HTTP/3.0，为 HTTP 协议的下一个主要版本。&lt;/p&gt;
&lt;h3 id=&quot;quic-还有多远&quot;&gt;QUIC 还有多远&lt;/h3&gt;
&lt;p&gt;虽然 Chrome 从 29 版本开始就添加了 HTTP-over-QUIC 的支持，并且今年开始 Facebook 也开始采用这项技术。&lt;/p&gt;
&lt;p&gt;但是这个在 HTTP/2.0 还不是主流的环境下，HTTP/3.0 已经确定，它就在未来的某个地方。&lt;/p&gt;
&lt;p&gt;据 W3Techs 统计，截止到 2018 年 11 月，前 1000 万网站在中，有 31.2% 支持了 HTTP/2.0，而 QUIC 只有 1.2%，从趋势上看，可以说离我们还很远。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwly1fx7wad1hkyj30gq0beq2u.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;HTTP/3.0 是一个仍在开发中的协议，计划在今年内完成，但是可以预见的，它离普及还很远。&lt;/p&gt;
&lt;p&gt;很多协议的设计思想是非常值得我们借鉴与学习的，对协议有兴趣的朋友，我找了一篇腾讯团队的资深研发工程师写的一篇 QUIC 协议的原理分析，通俗易懂，有兴趣可以点击“&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32553477&quot;&gt;阅读原文&lt;/a&gt;”查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;觉得有帮助记得点赞和分享哦，谢谢。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://www.zdnet.com/article/http-over-quic-to-be-renamed-http3&quot; class=&quot;uri&quot;&gt;https://www.zdnet.com/article/http-over-quic-to-be-renamed-http3&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://daniel.haxx.se/blog/2018/11/11/http-3&quot; class=&quot;uri&quot;&gt;https://daniel.haxx.se/blog/2018/11/11/http-3&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32553477&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/32553477&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我准备的学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步；你还能回复『&lt;strong&gt;提问&lt;/strong&gt;』，向我发起提问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485716&amp;amp;idx=1&amp;amp;sn=7696b3a76cfc899f753d49b0804c9a98&amp;amp;chksm=97851035a0f29923959d07495d772ad9731965e0a0cbcb07807a801cc297e4e8db04b19c0fad#rd&quot;&gt;图解 Chrome，架构篇&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485721&amp;amp;idx=1&amp;amp;sn=e1f6f431869c3255d092ac9d9d484e96&amp;amp;chksm=97851038a0f2992ece3d3c0be940a0e8107a9a51daa6f7b3a532b9ce73e5cc7a9f0851141ed0#rd&quot;&gt;利用预处理脚本，管理小程序代码&lt;/a&gt;| &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485693&amp;amp;idx=1&amp;amp;sn=faaef92c4268a2259477b27463bd3a43&amp;amp;chksm=978511dca0f298ca872b88d36e98ecfad74e71347fcfa5da3341427e5ddbe21b2f3ff2e081b4#rd&quot;&gt;分词，科普及解决方案&lt;/a&gt;| &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485579&amp;amp;idx=1&amp;amp;sn=d939e6b1dabe7495b5ca5f0a0c988c8e&amp;amp;chksm=978511aaa0f298bc75e0d0c507a19e28d5d4fac3b30502565688617b1ae9fcf899a9836b2d65#rd&quot;&gt;图解：HTTP 范围请求&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485702&amp;amp;idx=1&amp;amp;sn=2e89e0e60055212f427db60524f261dc&amp;amp;chksm=97851027a0f299314296d2cf0e49cb970acd75932630f4addd5651e57e2102bcdcc16ff841ae#rd&quot;&gt;小程序学习资料&lt;/a&gt; |&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485524&amp;amp;idx=1&amp;amp;sn=183b34cfd87f2a6fddc43187dc6fa72f&amp;amp;chksm=97851175a0f29863245fe35a402e801cf9fb8f6864acd3e546473aded4b18dd4538154403f79#rd&quot;&gt;HTTP 内容编码&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485510&amp;amp;idx=1&amp;amp;sn=5be673f99e2d83e4b49ee46010734b10&amp;amp;chksm=97851167a0f298718284006a8ea3ad0cebdec2a46123332ae78908e142e408dd0ed04623cd68#rd&quot;&gt;辅助模式实战&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485501&amp;amp;idx=1&amp;amp;sn=795005d17c6e37e6de0adcc4c3500685&amp;amp;chksm=9785111ca0f2980a46bb3e1f40aebd096740065cd84a8f4169467d825616a2020d3a1ead0638#rd&quot;&gt;辅助模式玩出花样&lt;/a&gt; | &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxNjc0ODExMA==&amp;amp;mid=2247485501&amp;amp;idx=1&amp;amp;sn=795005d17c6e37e6de0adcc4c3500685&amp;amp;chksm=9785111ca0f2980a46bb3e1f40aebd096740065cd84a8f4169467d825616a2020d3a1ead0638#rd&quot;&gt;小程序 Flex 布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcly1fpzmg0hppuj30rs0b474v.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 06:50:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<og:description>HTTP/2.0 还没有普及，HTTP/3.0 标准就要被制定了。 据 IETF 透露， HTTP over QUIC 实验协议将被重命名为 HTTP/3，并成为 HTTP 协议的第三个正式版本 。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/http_over_quic.html</dc:identifier>
</item>
<item>
<title>从壹开始微服务 [ DDD ] 之八 ║剪不断理还乱的 值对象和Dto - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9962759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9962759.html</guid>
<description>&lt;p&gt;哈喽大家周四好，时间是过的真快，这几天一直忙着在公司的项目，然后带带新人，眼看这周要过去了，还是要抽出时间学习学习，这些天看到群里的小伙伴也都在忙着新学习，还是很开心的，至少当时的初衷已经达到了，一起学习一起进步嘛，哪怕是对现在或者是对以后的工作有一丢丢的帮助，也是不枉此时的努力，哈哈夜里写文章总是容易多想，好啦，废话不多说，上次咱们说到了《&lt;a id=&quot;post_title_link_9931304&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9931304.html&quot;&gt;从壹开始微服务 [ DDD ] 之七 ║项目第一次实现 &amp;amp; CQRS初探&lt;/a&gt;》，今天本来应该接着写 &lt;strong&gt;领域命令 &lt;/strong&gt;了，在设计的领域命令的时候，发现了值对象的存在，对 &lt;strong&gt;领域模型 &lt;/strong&gt;和 &lt;strong&gt;视图模型 &lt;/strong&gt;有着剪不断理还乱的困扰，所以我就暂时单写一篇了，既是对上一篇的补充，又是对领域命令的铺垫，好啦，马上开始今天的说明吧~~&lt;/p&gt;
&lt;p&gt;还是老规矩，每篇文章先给大家一个小问题，先思考下，然后有助于理解本文：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;问题&lt;/span&gt;：我们在领域模型 Student 中，有一个户籍的值对象（为啥叫户籍，下边会说到），然后我们也有一个学生的视图模型 StudentViewModel ，那么问题来了，我们在 StudentViewModel 中，如何去定义这个户籍的视图模型呢，然后又是如何传给领域模型 Student 呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、不写这户籍一块，直接在业务逻辑里，手动赋值给 Student 领域模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentViewModel
    {&lt;/span&gt;&lt;span&gt;

        [Required(ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Name is Required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [MinLength(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        [MaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        [DisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//... &lt;/span&gt;&lt;span&gt;等等其他，只是学生的个人信息，不涉及户籍地址&lt;/span&gt;&lt;/strong&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、和领域模型一样，也写一个对象，甚至直接就用领域模型中的 Address 值对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentViewModel
    {
        [Key]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required(ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Name is Required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [MinLength(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        [MaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        [DisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;... 等等其他的信息
  

        &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个就是在领域模型Student中使用的，户籍值对象&lt;/span&gt;&lt;/strong&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Address&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、把 Address 属性拆开，一个一个的放在视图模型 StudentViewModel 中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentViewModel
    {
        [Key]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Required(ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Name is Required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [MinLength(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        [MaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        [DisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...  等等其他学生信息，比如手机号，邮箱等&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 城市
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;;  &lt;span&gt;set&lt;/span&gt;; }&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里可以进行set 赋值操作，和值对象不是一回事&lt;/span&gt;&lt;/strong&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 区县
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; County { &lt;span&gt;get&lt;/span&gt;;  &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 街道
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Street { &lt;span&gt;get&lt;/span&gt;;  &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或许你还有其他啥办法，要是有感觉更好的，或者更正确的，&lt;strong&gt;千万要评论留言&lt;/strong&gt;哟，只不过这三种办法是我亲身实验的，这里大家先思考一下，希望看完本文你会有一些自己的想法。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115113121596-1272430989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 话说上次咱们是把领域模型（包括实体和值对象）通过EFCore保存到了数据库，然后也查询出来了相应的学习信息，（这里注意下，学习的户籍信息还没有取出来），这里说一下为什么是户籍地址信息，&lt;/p&gt;
&lt;p&gt;上篇文章中，有小伙伴还是对这个不是很理解，一直想着要一定和数据库对应上，比如说，为啥叫地址，那如果学生有多个地址咋办；再比如，这样修改学生信息，值对象就会发生变化呀，这样就不能满足&lt;strong&gt;值对象不可变&lt;/strong&gt;的特性；等等诸如此类的疑问，这里说一下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;1、值对象其实就是一个值，它和Name、Phone、Email等等一模一样，只不过它是一个对象，复杂了一些，有了自己的内部结构，所以说，值对象是没有状态的，没有唯一标识（多个学生叫张三 == 两个学生一个地址），是内部不可变性，就比如我们修改一个学校省份，需要将整个值对象都修改，这和修改Name是一样的。&lt;/p&gt;
&lt;p&gt;2、值对象是一个领域中孕育出来的概念，千万不要事事都要和数据库，数据模型，扯上关系，如果想要一个会员多个地址，那这个时候地址就是一个实体，甚至是一个聚合了，比如物流地址，这也就是我为什么要把这个Address称之为 &lt;strong&gt;户籍&lt;/strong&gt; 的原因了，从领域出发，而不要再和数据模型数据库表相提并论了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那咱们就先添加学生的 Create 模块&lt;/p&gt;
&lt;h3&gt;1、在 StudentController 中添加 Create Action&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Student/Create
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 页面&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Create()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST: Student/Create
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        [ValidateAntiForgeryToken]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Create(StudentViewModel studentViewModel)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视图模型验证&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(studentViewModel);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行添加方法&lt;/span&gt;
&lt;span&gt;                _studentAppService.Register(studentViewModel);

                ViewBag.Sucesso &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student Registered!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(studentViewModel);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(e.Message);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候大家肯定都已经很熟悉了，而且 Service 层注入什么的，相信大家已经得心应手了，这里都不细说了。&lt;/p&gt;

&lt;h3&gt;2、创建 Create View页面&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@model Christ3D.Application.ViewModels.StudentViewModel
@{
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Register new Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&amp;lt;h2&amp;gt;@ViewData[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]&amp;lt;/h2&amp;gt;
&amp;lt;form asp-action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-horizontal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;hr /&amp;gt;&lt;span&gt;
        @&lt;/span&gt;* Replacing classic Validation Summary to Custom ViewComponent &lt;span&gt;as&lt;/span&gt; TagHelper *&lt;span&gt;@
        &lt;/span&gt;&amp;lt;vc:summary /&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BirthDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BirthDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BirthDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-offset-2 col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;a asp-action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Back to List&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115115509753-391388183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这些都是 AspNetCore.Mvc.ViewFeature 的模型命令还有验证等，相比以前的模型，已经有很大的改善了，这个可以自己试试，很简单，直接往下走，重头戏来了。&lt;/p&gt;
&lt;p&gt;这个时候，如果我们添加信息保存的话，一定会发现一个问题，就是户籍信息到底如何传入呢，上边说的三种办法到底该选择哪一种呢，下边咱们一一来实验下。&lt;/p&gt;


&lt;p&gt; 这个时候肯定会有小伙伴说，为什么一定要把值对象放到视图模型中，就比如文章的第一个方法，我就不放进去，我从页面内获取到Country、Province、City等等后，然后再传到领域模型不就行了，真的么？&lt;/p&gt;
&lt;h3&gt;1、手动赋值的方法&lt;/h3&gt;
&lt;p&gt; 假设我们已经从前台页面内获取到了户籍信息，然后我们就会这么做&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; ActionResult Create(StudentViewModel studentViewModel,&lt;span&gt;string country,string provice,string city,string&lt;/span&gt;&lt;span&gt;&lt;span&gt; street&lt;/span&gt;)
        {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 视图模型验证&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(studentViewModel);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个时候还需要对户籍信息进行验证判断
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比如字符串不能数字，字符啥的

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行添加方法，把户籍信息传递过去                &lt;br/&gt;&lt;span&gt;_studentAppService.Register(studentViewModel,&lt;span&gt;country,  provice,  city,  street&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;
                ViewBag.Sucesso &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student Registered!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(studentViewModel);

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Stop！相信我，你肯定不会这么做的，当然，偶尔偶尔我们会这么接受一个参数，也偶会会这么写，可是这么写肯定是不行的，且不说不是DDD领域驱动设计思想，就连OOP思想也没有发挥起来，所以方法一直接pass。&lt;/p&gt;
&lt;p&gt;这个时候我们开始思考，至少需要把户籍信息放到视图模型 StudentViewMode 中吧，嗯看着文章开头的第二个方法就特别好！对象是吧，这个可是真是的OOP思想，全部用对象接收参数，然后把数据传如到仓储的Add()方法中，这样就直接保存了嘛，多好呀！想想的心动，那就开始吧，一个小坑正在慢慢变大。&lt;/p&gt;

&lt;h3&gt;2、用对象的方法将值对象添加到视图模型中&lt;/h3&gt;
&lt;p&gt;听着很拗口，说白了，就是文章开头的第二种方法，领域模型和视图模型，共用一个 值对象。然后我们修改下 view 页面，用来传递参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BirthDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BirthDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BirthDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.County&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.County&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.County&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.City&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
            &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
                &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.City&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
                &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address.City&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候，我们一定很欢喜，然后点击提交，发现，无论怎么提交都不会在&lt;/p&gt;
&lt;p&gt;　　public ActionResult Create(StudentViewModel studentViewModel)&lt;/p&gt;
&lt;p&gt;中获取到我们需要的户籍信息，天哪！这是啥情况，当然是获取不到的，因为 Address 是一个值对象，具有不可变性，它的 set 都是私有的，不能被赋值，不信请看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115130420844-1978360023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候怎么办，聪明的你肯定能想到一个方法，既然值对象不行，它内部不可变，不能赋值，那我就自己在视图模型中，再写一个 AddressViweModel 不就行啦，然后可以进行set操作，想到这里还是很激动，赶紧试试，这就看看能不能获取到值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115133749455-143676760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 很不错，已经把内容获取到了，然后通过视图对象传到Add() 方法，很成功的达到了目的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115133922811-1184210028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看来这个方法也是可以的，只不过有一个小问题就是，这里需要多了一个类来实现，如果我不想用类接受，而且是直接用属性呢？那就是第三种办法了，请继续往下看。&lt;/p&gt;

&lt;h3&gt;3、用属性字段来讲户籍信息放到视图模型中&lt;/h3&gt;
&lt;p&gt;就是文章开头的第三种办法，这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentViewModel
    {
        
        [Required(ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Name is Required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [MinLength(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)]
        [MaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)]
        [DisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;... 其他&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 省份
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [Required(ErrorMessage = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Province is Required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        [DisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Province { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 城市
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 区县
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; County { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 街道
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Street { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再修改下页面里的调用情况，直接用调用属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-group&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;label asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-2 control-label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;
     &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;col-md-10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
         &amp;lt;input asp-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form-control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
         &amp;lt;span asp-validation-&lt;span&gt;for&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text-danger&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
     &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候，我们满怀开心的运行项目的时候，发现，index页面的户籍信息没有了，也就是说 Student -&amp;gt; StudentViewModel 的时候，通过 Automapper 没有成功。&lt;/p&gt;

&lt;p&gt;然后我们提交的时候，发现后端虽然能接受到数据，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115140337885-85112206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可是在转换到 Student 的时候失败了：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115140420370-382838413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这里显示的是，我们无法对其进行转换，因为在视图模型中，没有匹配到 Student 的 Address 值对象信息，不要慌，下边我们会说这个问题。&lt;/p&gt;


&lt;p&gt; 为了解决上一个问题，我研究了下 Automapper 官网，发现，这种复杂拷贝，需要进行手动配置，其实也是很简单，只需要创建匹配属性即可&lt;br/&gt; 注意，在第二种方法中是不需要配置的，因为第二种方法，两个模型结构几乎一模一样，这第三种方法，结构已经变了，一个是对象，一个仅仅是一个属性值。&lt;/p&gt;
&lt;h3&gt;1、复杂领域模型转换到视图模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置构造函数，用来创建关系映射
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DomainToViewModelMappingProfile()
 {
     CreateMap&lt;/span&gt;&amp;lt;Student, StudentViewModel&amp;gt;&lt;span&gt;()
         .ForMember(d &lt;/span&gt;=&amp;gt; d.County, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.Address.County))
         .ForMember(d &lt;/span&gt;=&amp;gt; d.Province, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.Address.Province))
         .ForMember(d &lt;/span&gt;=&amp;gt; d.City, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.Address.City))
         .ForMember(d &lt;/span&gt;=&amp;gt; d.Street, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.Address.Street))
         ;

  
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个时候，我们看Index页面，户籍信息也出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115142033713-928040142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2、视图模型转换到复杂领域模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 public&lt;span&gt; ViewModelToDomainMappingProfile()
 {
     //手动进行配置
     CreateMap&amp;lt;StudentViewModel, Student&amp;gt;&lt;span&gt;()
      .ForPath(d =&amp;gt; d.Address.Province, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.Province))
      .ForPath(d =&amp;gt; d.Address.City, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.City))
      .ForPath(d =&amp;gt; d.Address.County, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.County))
      .ForPath(d =&amp;gt; d.Address.Street, o =&amp;gt; o.MapFrom(s =&amp;gt;&lt;span&gt; s.Street))
      ;

 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里将 Student 中的户籍信息，一一匹配到视图模型中的属性。&lt;/p&gt;
&lt;p&gt; 然后我们测试数据，不仅仅可以把数据获取到，还可以成功的转换过去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115142521861-1795064551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后首页查看验证信息，以及添加上了，完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201811/1468246-20181115142548089-1812473419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 今天呢，是补充了上一把的坑，一共提供了三个办法，当然其实第一种也不算是方法，主要是后两者，不知道大家是否能看的懂，然后更倾向于哪一种：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;2、不用配置 Automapper 映射信息，只需要新建一个一样的户籍值对象的视图模型 —— 户籍视图模型即可，因为结构相同，所以不需要手动配置映射，就能达到目的。&lt;/p&gt;
&lt;p&gt;3、只需要一个视图模型即可控制，在某些情况下，我们不方便使用嵌套的复杂视图模型，只需要配置下映射文件即可达到目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 今天，也为下一篇做准备，怎么说呢，大家发现，现在我们能正确的添加进去了，但是如果我们要进行验证该怎么办？比如说，我们要判断学校不能小于14岁，手机号格式，邮箱格式等等，&lt;/p&gt;
&lt;p&gt;当然，你可以说，我会用前端js校验，也可以后端获取到，if 判断，都是可以的，&lt;/p&gt;
&lt;p&gt;不过我个人感觉，后端校验还是很需要的，我采用 FluentValidation 进行后端校验，并且融入到 &lt;strong&gt;领域命令 &lt;/strong&gt;中，那如何实现呢，下次再见咯~~~&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/ChristDDD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/ChristDDD&lt;/a&gt; &lt;/p&gt;

</description>
<pubDate>Thu, 15 Nov 2018 06:37:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 哈喽大家周四好，时间是过的真快，这几天一直忙着在公司的项目，然后带带新人，眼看这周要过去了，还是要抽出时间学习学习，这些天看到群里的小伙伴也都在忙着新学习，还是很开心的，至少当时的初衷已经达到了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9962759.html</dc:identifier>
</item>
<item>
<title>AI应用开发基础傻瓜书系列3-激活函数和损失函数 - UniversalAIPlatform</title>
<link>http://www.cnblogs.com/ms-uap/p/9962978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ms-uap/p/9962978.html</guid>
<description>&lt;p&gt;在这一章，我们将简要介绍一下激活函数和损失函数~&lt;/p&gt;
&lt;p&gt;整个系列的目录请点击&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9957265.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;看神经网络中的一个神经元，为了简化，假设该神经元接受三个输入，分别为&lt;span class=&quot;math inline&quot;&gt;\(x_1, x_2, x_3\)&lt;/span&gt;,那么&lt;span class=&quot;math inline&quot;&gt;\(z=\sum\limits_{i}w_ix_i+b_i\)&lt;/span&gt;,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115131900038-1328315496.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;激活函数也就是&lt;span class=&quot;math inline&quot;&gt;\(A=\sigma(Z)\)&lt;/span&gt;这一步了，他有什么作用呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从模仿人类大脑的角度来说：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;神经元在利用突触传递信息时，不是所有信息都可以传递下去的，每个神经元有自己的阈值，必须要刺激强过某个阈值才会继续向后传递。激活函数在某些方面就可以扮演这样一个激活阈值的作用，不达到一定要求的信号是不可以继续向后传递的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;说得形象一点，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设老张家有一个在滴（漏）水的水龙头：水龙头漏水这件事情的严重等级有0~9这样10个的等级，凭借自己的力量可以解决0~2这样3的等级的情况，维修部门可以解决3~6这样的等级，然后譬如需要修改水管线路什么的就是需要更加专业的部门了，他们可以解决7~9这样等级的情况。发现一个等级为5的漏水事件，处理步骤是什么样的呢？&lt;/p&gt;
&lt;p&gt;首先，看到水龙头在滴水，通过视觉细胞处理成信号输入大脑，经过大脑这个黑盒子复杂的处理，判断出这不是简简单单拧紧或者拍拍就能解决的漏水的问题，也就是说，判断出这个事情的严重等级大于2，执行这样一个处理函数：&lt;br/&gt;&lt;code&gt;if 严重等级 &amp;gt; 2: 老张打电话给隔壁老王寻求帮助 else: 自己解决&lt;/code&gt;&lt;br/&gt;这件事情的严重等级超过了自己能力的阈值，所以需要开始传递给隔壁老王，之后老王执行一个类似的判断&lt;br/&gt;&lt;code&gt;if 严重等级 &amp;gt; 6: 寻求物业公司帮助 else: 老王拿着管钳去老张家帮忙&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;类似这个例子中的判断需不需要更专业的人来解决问题，如果严重等级超过了某个设定的阈值，那就需要寻找更专业的人来帮助。在这里的阈值就是能解决的严重等级的上限。&lt;/p&gt;
&lt;p&gt;激活函数在神经网络中起到的就是在控制自己接收到的消息到底是不是需要向后传播的作用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从数学的角度来说&lt;br/&gt;形如&lt;span class=&quot;math inline&quot;&gt;\(z=\sum\limits_{i}w_ix_i+b_i\)&lt;/span&gt;的传递是一种线性的传递过程。如果没有非线性函数添加非线性，直接把很多层叠加在一起会怎么样呢？&lt;br/&gt;以两层为例：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115131935745-1529723576.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[z_1 = w_1x_1 + b_1 \tag{1}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[z_2 = w_2z_1 + b_2 = w_2(w_1x_1 + b_1) + b_2 = (w_2 w_1) x_1 + (w_2b_1 + b_2)=w_{3}x_1+b_{3} \tag{2}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(z_1, z_2\)&lt;/span&gt;即为这两个神经元结点的输出。可以看到，叠加后的&lt;span class=&quot;math inline&quot;&gt;\(z_2\)&lt;/span&gt;的输出也是一个线性函数。&lt;/p&gt;
&lt;p&gt;以此类推，如果缺少非线性层，无论如何叠加，最后得到的还只是一个线性函数。&lt;/p&gt;
&lt;p&gt;然而，按照生活经验来说，大多数的事情都不是线性规律变化的，比如身高随着年龄的变化，价格随着市场的变化。所以需要给这样一个线性传递过程添加非线性才可以更好的去模拟这样一个真实的世界。具体该怎么做呢？&lt;/p&gt;
&lt;p&gt;习惯上，用‘1’来代表一个神经元被激活，‘0’代表一个神经元未被激活，那预期的函数图像是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115131955571-2144873079.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个函数有什么不好的地方呢？主要的一点就是，他的梯度（导数）恒为零（个别点除外)。&lt;/p&gt;
&lt;p&gt;想想我们说过的反向传播公式？梯度传递用到了链式法则，如果在这样一个连乘的式子其中有一项是零，结果会怎么样呢？这样的梯度就会恒为零。这个样子的函数是没有办法进行反向传播的。&lt;/p&gt;
&lt;p&gt;那有没有什么函数可以近似实现这样子的阶梯效果而且还可以反向传播呢？常用的激活函数有哪些呢？&lt;/p&gt;
&lt;h2 id=&quot;sigmoid函数&quot;&gt;sigmoid函数&lt;/h2&gt;
&lt;p&gt;公式：&lt;span class=&quot;math inline&quot;&gt;\(f(z) = \frac{1}{1 + e^{-z}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;反向传播： &lt;span class=&quot;math inline&quot;&gt;\(f^{'}(z) = f(z) * (1 - f(z))\)&lt;/span&gt;，推导过程请参看&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9957269.html&quot;&gt;数学导数公式&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132011727-942296981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从函数图像来看，sigmoid函数的作用是将输入限制到(0, 1)这个区间范围内，这种输出在0~1之间的函数可以用来模拟一些概率分布的情况。他还是一个连续函数，导数简单易求。&lt;/p&gt;
&lt;p&gt;用mnist数据的例子来通俗的解释一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132027167-1159410790.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;形象化的说，每一个隐藏层神经元代表了对某个笔画的感知，也就是说可能第一个神经元代表是否从图中检测到有一条像1一样的竖线存在，第二个神经元代表是否有一小段曲线的存在。但是在实际传播中，怎么表示是不是有这样一条直线或者这样一段曲线存在呢？在生活中，我们经常听到这样的对白“你觉得这件事情成功概率有多大？”“我有六成把握能成功”。sigmoid函数在这里就起到了如何把一个数值转化成一个通俗意义上的把握的表示。值越大，那么这个神经元对于这张图里有这样一条线段的把握就越大，经过sigmoid函数之后的结果就越接近100%，也就是1这样一个值，表现在图里，也就是这个神经元越兴奋（亮）。&lt;/p&gt;
&lt;p&gt;但是这个样子的激活函数有什么问题呢？&lt;/p&gt;
&lt;p&gt;从梯度图像中可以看到，sigmoid的梯度在两端都会接近于0，根据链式法则，把其他项作为&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;,那么梯度传递函数是&lt;span class=&quot;math inline&quot;&gt;\(\alpha*\sigma'(x)\)&lt;/span&gt;，而&lt;span class=&quot;math inline&quot;&gt;\(\sigma'(x)\)&lt;/span&gt;这时是零，也就是说整体的梯度是零。这也就很容易出现梯度消失的问题，并且这个问题可能导致网络收敛速度比较慢，比如采取MSE作为损失函数算法时。&lt;/p&gt;
&lt;p&gt;给个纯粹数学的例子吧，假定我们的学习速率是0.2，sigmoid函数值是0.9，如果我们想把这个函数的值降到0.5，需要经过多少步呢？&lt;/p&gt;
&lt;p&gt;我们先来做公式推导，&lt;br/&gt;第一步，求出当前输入的值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{1}{1 + e^{-x}} = 0.9\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[e^{-x} = \frac{1}{9}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x = ln{9}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二步，求出当前梯度&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[grad = f(x)\times(1 - f(x)) = 0.9 \times 0.1= 0.09\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步，根据梯度更新当前输入值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_{new} = x - \eta \times grad = ln{9} - 0.2 \times 0.09 = ln(9) - 0.018\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第四步，判断当前函数值是否接近0.5&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{1}{1 + e^{-x_{new}}} = 0.898368\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第五步，重复步骤2-3直到当前函数值接近0.5&lt;/p&gt;
&lt;p&gt;说得如果不够直观，那我们来看看图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115133941474-391499187.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上半部分那条五彩斑斓的曲线就是迭代更新的过程了，一共迭代了多少次呢？根据程序统计，sigmoid迭代了67次才从0.9衰减到了接近0.5的水准。有同学可能会说了，才67次嘛，这个次数也不是很多啊！确实，从1层来看，这个速度还是可以接受的，但是神经网络只有这一层吗？多层叠加之后的sigmoid函数，因为反向传播的链式法则，两层的梯度相乘，每次更新的步长更小，需要的次数更多，也就是速度更加慢。如果还是没有反应过来的同学呢，可以先向下看relu函数的收敛速度。&lt;/p&gt;
&lt;p&gt;此外，如果输入数据是(-1, 1)范围内的均匀分布的数据会导致什么样的结果呢？经过sigmoid函数处理之后这些数据的均值就从0变到了0.5，导致了均值的漂移，在很多应用中，这个性质是不好的。&lt;/p&gt;
&lt;p&gt;代码思路：&lt;br/&gt;放到代码中应该怎么实现呢？首先，对于一个输入进sigmoid函数的向量来说，函数的输出和反向传播时的导数是和输入的具体数值有关系的，那么为了节省计算量，可以生成一个和输入向量同尺寸的mask，用于记录前向和反向传播的结果，具体代码来说，就是：&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Csigmoid(object):
    def __init__(self, inputSize):
        self.shape = inputSize

    def forward(self, image):
        # 记录前向传播结果
        self.mask = 1 / (1 + np.exp(-1 * image))
        return self.mask

    def gradient(self, preError):
        # 生成反向传播对应位置的梯度
        self.mask = np.multiply(self.mask, 1 - self.mask)
        return np.multiply(preError, self.mask)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不理解为啥又有前向传播又有梯度计算的小伙伴请戳&lt;a href=&quot;https://www.cnblogs.com/ms-uap/p/9928254.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;tanh函数&quot;&gt;tanh函数&lt;/h2&gt;
&lt;p&gt;形式：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(z) = \frac{e^{z} - e^{-z}}{e^{z} + e^{-z}}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(z) = 2*sigmoid(2*z) - 1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;反向传播:&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f^{'}(z) = (1 + f(z)) * (1 - f(z))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132451472-406541400.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无论从理论公式还是函数图像，这个函数都是一个和sigmoid非常相像的激活函数，他们的性质也确实如此。但是比起sigmoid，tanh减少了一个缺点，就是他本身是零均值的，也就是说，在传递过程中，输入数据的均值并不会发生改变，这就使他在很多应用中能表现出比sigmoid优异一些的效果。&lt;/p&gt;
&lt;p&gt;代码思路：&lt;br/&gt;这么相似的函数没有相似的代码说不过去呀！比起sigmoid的代码，实现tanh只需要改变几个微小的地方就可以了，话不多说，直接上代码吧：&lt;/p&gt;
&lt;p&gt;示例代码:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Ctanh(object):
    def __init__(self, inputSize):
        self.shape = inputSize

    def forward(self, image):
        # 记录前向传播结果
        self.mask = 2 / (1 + np.exp(-2 * image)) - 1
        return self.mask

    def gradient(self, preError):
        # 生成反向传播对应位置的梯度
        self.mask = np.multiply(1 + self.mask, 1 - self.mask)
        return np.multiply(preError, self.mask)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;relu函数&quot;&gt;relu函数&lt;/h2&gt;
&lt;p&gt;形式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(z) = \begin{cases} z &amp;amp; z \geq 0 \\ 0 &amp;amp; z &amp;lt; 0 \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;反向传播:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(z) = \begin{cases} 1 &amp;amp; z \geq 0 \\ 0 &amp;amp; z &amp;lt; 0 \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132107662-1216541041.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来说说神经学方面的解释，为什么要使用relu呢？要说模仿神经元，sigmoid不是更好吗？这就要看2001年神经学家模拟出的更精确的神经元模型&lt;a href=&quot;http://proceedings.mlr.press/v15/glorot11a/glorot11a.pdf&quot;&gt;Deep Sparse Rectiﬁer Neural Networks&lt;/a&gt;。简单说来，结论就是这样两幅图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132121516-872087160.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132139186-2022291337.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来解释函数图像：在输入的信号比0大的情况下，直接将信号输出，否则的话将信号抑制到0，相比较于上面两个激活函数，relu计算方面的开销非常小，避免了指数运算和除法运算。此外，很多实验验证了采用relu函数作为激活函数，网络收敛的速度可以更快。至于收敛更加快的原因，从图上的梯度计算可以看出，relu的反向传播梯度恒定是1，而sigmoid激活函数中大多数时间梯度是比1小的。在叠加很多层之后，由于链式法则的乘法特性，sigmoid作为梯度函数会不断减小反向传播的梯度，而relu可以将比梯度原样传递，也就是说，relu可以使用比较快的速度去进行参数更新。&lt;/p&gt;
&lt;p&gt;用和sigmoid函数那里更新相似的算法步骤和参数，来模拟一下relu的梯度下降次数，也就是学习率&lt;span class=&quot;math inline&quot;&gt;\(\alpha = 0.2\)&lt;/span&gt;，希望函数值从0.9衰减到0.5，这样需要多少步呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132155249-472520004.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，同样的学习速率，relu函数只需要两步就可以做到sigmoid需要67步才能衰减到的程度！&lt;/p&gt;
&lt;p&gt;但是如果回传了一个很大的梯度导致网络更新之后输入信号小于0了呢？那么这个神经元之后接受到的数据是零，对应新的回传的梯度也是零，这个神经元将不被更新，下一次输入的信号依旧小于零，不停重复这个过程。也就是说，这个神经元不会继续更新了，这个神经元“死”掉了。在学习率设置不恰当的情况下，很有可能网络中大部分神经元“死”掉，也就是说不起作用了，而这是不可取的。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;br/&gt;与sigmoid类似，relu函数的前向传播和反向传播与输入的大小有关系，小于0的输入可以被简单的置成0，不小于0的可以继续向下传播，也就是将输入和0中较大的值继续传播，对输入向量逐元素做比较即可。考虑到反向传播时梯度计算也和输入有关，使用一个mask对数据或者根据数据推出的反向传播结果做一个记录也是一个比较好的选择。&lt;/p&gt;
&lt;p&gt;示例代码:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Crelu(object):
    def __init__(self, inputSize):
        self.shape = inputSize

    def forward(self, image):
        # 用于记录传递的结果
        self.mask = np.zeros(self.shape)
        self.mask[image &amp;gt; 0] = 1
        # 将小于0的项截止到0
        return np.maximum(image, 0)

    def gradient(self, preError):
        # 将上一层传递的误差函数和该层各位置的导数相乘
        return np.multiply(preError, self.mask)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;想想看，relu函数的缺点是什么呢？是梯度很大的时候可能导致的神经元“死”掉。而这个死掉的原因是什么呢？是因为很大的梯度导致更新之后的网络传递过来的输入是小于零的，从而导致relu的输出是0，计算所得的梯度是零，然后对应的神经元不更新，从而使relu输出恒为零，对应的神经元恒定不更新，等于这个relu失去了作为一个激活函数的梦想。问题的关键点就在于输入小于零时，relu回传的梯度是零，从而导致了后面的不更新。&lt;/p&gt;
&lt;p&gt;那么最简单粗暴的做法是什么？在输入函数值小于零的时候给他一个梯度不就好了！这就是leaky relu函数的表现形式了！&lt;/p&gt;
&lt;h2 id=&quot;leaky-relu函数&quot;&gt;leaky relu函数&lt;/h2&gt;
&lt;p&gt;形式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(z) = \begin{cases} z &amp;amp; z \geq 0 \\ \alpha * z &amp;amp; z &amp;lt; 0 \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;反向传播:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(z) = \begin{cases} z &amp;amp; 1 \geq 0 \\ \alpha &amp;amp; z &amp;lt; 0 \end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132210867-1254648886.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比较于relu函数，leaky relu同样有收敛快速和运算复杂度低的优点，而且由于给了&lt;span class=&quot;math inline&quot;&gt;\(x&amp;lt;0\)&lt;/span&gt;时一个比较小的梯度&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;,使得&lt;span class=&quot;math inline&quot;&gt;\(x&amp;lt;0\)&lt;/span&gt;时依旧可以进行梯度传递和更新，可以在一定程度上避免神经元“死”掉的问题。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class CleakyRelu(object):
    def __init__(self, inputSize, alpha):
        self.shape = inputSize
        self.alpha = alpha

    def forward(self, image):
        # 用于记录传递的结果,按照传递公式生成对应的值
        self.mask = np.zeros(self.shape)
        self.mask[image &amp;gt; 0] = 1
        self.mask[image &amp;lt;= 0] = self.alpha
        # 将该值对应到输入中
        return np.multiply(image, self.mask)

    def gradient(self, preError):
        # 将上一层传递的误差函数和该层各位置的导数相乘
        return np.multiply(preError, self.mask)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;softmax-函数&quot;&gt;softmax 函数&lt;/h2&gt;
&lt;p&gt;softmax函数，是大名鼎鼎的在计算多分类问题时常使用的一个函数，他长成这个样子:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \phi(z_j) = \frac{e^{z_j}}{\sum\limits_ie^{z_i}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说把接收到的输入归一化成一个每个分量都在&lt;span class=&quot;math inline&quot;&gt;\((0,1)\)&lt;/span&gt;之间并且总和为一的一个概率函数。&lt;/p&gt;
&lt;p&gt;用一张图来形象说明这个过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132225525-1915836322.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当输入的数据是3，1，-3时，按照图示过程进行计算，可以得出输出的概率分布是0.88，0.12，0。&lt;/p&gt;
&lt;p&gt;试想如果我们并没有这样一个softmax的过程而是直接根据3，1，-3这样的输出，而我们期望得结果是1，0，0这样的概率分布结果，那传递给网络的信息是什么呢？我们要抑制正样本的输出，同时要抑制负样本的输出。正样本的输出和期望的差距是2，负样本1和期望的差距是0，所以网络要更加抑制正样本的结果！所以，在输出结果相对而言已经比较理想的情况下，我们给了网络一个相对错误的更新方向：更多的抑制正样本的输出结果。这显然是不可取的呀！&lt;/p&gt;
&lt;p&gt;从继承关系的角度来说，softmax函数可以视作sigmoid的一个扩展，比如我们来看一个二分类问题，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \phi(z_1) = \frac{e^{z_1}}{e^{z_1} + e^{z_2}} = \frac{1}{1 + e^{z_2 - z_1}} = \frac{1}{1 + e^{z_2} e^{- z_1}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;是不是和sigmoid的函数形式非常像？比起原始的sigmoid函数，softmax的一个优势是可以用在多分类的问题中。另一个好处是在计算概率的时候更符合一般意义上我们认知的概率分布，体现出物体属于各个类别相对的概率大小。&lt;/p&gt;
&lt;p&gt;既然采用了这个函数，那么怎么计算它的反向传播呢？&lt;/p&gt;
&lt;p&gt;这里为了方便起见，将&lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i \neq j}e^{z_i}\)&lt;/span&gt;记作&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，那么，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \phi(z_j) = \frac{e^{z_j}}{\sum\limits_ie^{z_i}} = \frac{e^{z_j}}{k + e^{z_j}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \therefore \frac{\partial\phi(z_j)}{\partial z_j} = \frac{e^{z_j}(k + e^{z_j}) - e^{z_j} * e^{z_j}}{{(k + e^{z_j})}^2} = \frac{e^{z_j}}{k + e^{z_j}}\frac{k}{k + e^{z_j}} = softmax(z_j)(1 - softmax(z_j)) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说，softmax的梯度就是&lt;span class=&quot;math inline&quot;&gt;\(softmax(z_j)(1 - softmax(z_j))\)&lt;/span&gt;，之后将这个梯度进行反向传播就可以大功告成啦~&lt;/p&gt;

&lt;h2 id=&quot;作用&quot;&gt;作用&lt;/h2&gt;
&lt;p&gt;在有监督的学习中，需要衡量神经网络输出和所预期的输出之间的差异大小。这种误差函数需要能够反映出当前网络输出和实际结果之间一种量化之后的不一致程度，也就是说函数值越大，反映出模型预测的结果越不准确。&lt;/p&gt;
&lt;p&gt;还是拿练枪的Bob做例子，Bob预期的目标是全部命中靶子的中心，但他现在的命中情况是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132247289-1992782981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最外圈是1分，之后越向靶子中心分数是2，3，4分，正中靶心可以得5分。&lt;/p&gt;
&lt;p&gt;那Bob每次射击结果和目标之间的差距是多少呢？在这个例子里面，用得分来衡量的话，就是说Bob得到的反馈结果从差4分，到差3分，到差2分，到差1分，到差0分，这就是用一种量化的结果来表示Bob的射击结果和目标之间差距的方式。也就是误差函数的作用。因为是一次只有一个样本，所以这里采用的是误差函数的称呼。如果一次有多个样本，那么就要称呼这样子衡量不一致程度的函数就要叫做损失函数了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132302340-393603096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以做线性回归的实际值和预测值为例，若自变量x是[-2, -1, 0, 1, 2]这样5个值，对应的期望值y是[-3, 0, 0, 3, 4]这样的值，目前预测使用的参数是(w, b) = (2, 1), 那么预测得到的值y_ = [-3, -1, 1, 3, 5], 采用均方误差计算这个预测和实际的损失就是&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i = 0}^{4}(y[i] - y_\_[i])^{2}\)&lt;/span&gt;, 也就是3。那么如果采用的参量是(0, 0)，预测出来的值是[0, 0, 0, 0, 0],这是一个显然错误的预测结果，此时的损失大小就是34，&lt;span class=&quot;math inline&quot;&gt;\(3 &amp;lt; 34\)&lt;/span&gt;, 那么(2, 1)是一组比(0, 0)要合适的参量。&lt;/p&gt;
&lt;p&gt;那么常用的损失函数有哪些呢？&lt;br/&gt;这里先给一些前提，比如神经网络中的一个神经元：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132331574-499049181.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中 &lt;span class=&quot;math inline&quot;&gt;\(z = \sum\limits_{i}w_i*x_i+b_i=\theta^Tx\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\sigma(z)\)&lt;/span&gt;是对应的激活函数，也就是说，在反向传播时梯度的链式法则中，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{z}}{\partial{w_i}}=x_i \tag{1}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{z}}{\partial{b_i}}=1 \tag{2}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{loss}}{\partial{w_i}}=\frac{\partial{loss}}{\partial{\sigma(z)}}\frac{\partial{\sigma(z)}}{\partial{z}}\frac{\partial{z}}{\partial{w_i}}=\frac{\partial{loss}}{\partial{\sigma(z)}}\frac{\partial{\sigma(z)}}{\partial{z}}x_i \tag{3}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{loss}}{\partial{b_i}}=\frac{\partial{loss}}{\partial{\sigma(z)}}\frac{\partial{\sigma(z)}}{\partial{z}}\frac{\partial{z}}{\partial{b_i}}=\frac{\partial{loss}}{\partial{\sigma(z)}}\frac{\partial{\sigma(z)}}{\partial{z}} \tag{4}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从公式&lt;span class=&quot;math inline&quot;&gt;\((3),(4)\)&lt;/span&gt;可以看出，梯度计算中的公共项是&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{loss}}{\partial{\sigma(z)}}\frac{\partial{\sigma(z)}}{\partial{z}} = \frac{\partial{loss}}{\partial{z}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;下面我们来探讨&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{loss}}{\partial{z}}\)&lt;/span&gt;的影响。由于梯度的计算和函数的形式是有关系的，所以我们会从常用损失函数入手来逐个说明。&lt;/p&gt;
&lt;h2 id=&quot;常用损失函数&quot;&gt;常用损失函数&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;MSE (均方误差函数)&lt;br/&gt;该函数就是最直观的一个损失函数了，计算预测值和真实值之间的欧式距离。预测值和真实值越接近，两者的均方差就越小。&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;16.5&quot;&gt;&lt;li&gt;想法来源&lt;br/&gt;在给定一些点去拟合直线的时候（比如上面的例子），常采用最小二乘法，使各个训练点到拟合直线的距离尽量小。这样的距离最小在损失函数中的表现就是预测值和真实值的均方差的和。&lt;/li&gt;
&lt;li&gt;函数形式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[loss = \frac{1}{2}\sum_{i}(y[i] - a[i]) ^ 2\]&lt;/span&gt;,&lt;br/&gt;其中， &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;是网络预测所得到的结果，&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;代表期望得到的结果，也就是数据的标签，&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;是样本的序号。&lt;/li&gt;
&lt;li&gt;反向传播：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{loss}}{\partial{z}} = \sum_{i}(y[i] - a[i])*\frac{\partial{a[i]}}{\partial{z}}\]&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;36&quot;&gt;
&lt;p&gt;缺点:&lt;br/&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{a[i]}}{\partial{z}}\)&lt;/span&gt;关系密切，可能会产生收敛速度缓慢的现象，以下图为例（激活函数为sigmoid）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132357239-2020710586.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在激活函数的两端，梯度（黄色）都会趋向于0，采取MSE的方法衡量损失，在&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;趋向于1而&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;是0的情况下，损失loss是1，而梯度会趋近于0，在误差很大时收敛速度也会非常慢。&lt;/p&gt;
&lt;p&gt;在这里我们可以参考activation中关于sigmoid函数求导的例子，假定x保持不变，只有一个输入的一个神经元，权重&lt;span class=&quot;math inline&quot;&gt;\(w = ln(9)\)&lt;/span&gt;， 偏置&lt;span class=&quot;math inline&quot;&gt;\(b = 0\)&lt;/span&gt;，也就是这样一个神经元：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132411258-516844744.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保持参数统一不变，也就是学习率&lt;span class=&quot;math inline&quot;&gt;\(\eta = 0.2\)&lt;/span&gt;，目标输出&lt;span class=&quot;math inline&quot;&gt;\(y = 0.5\)&lt;/span&gt;, 此处输入x固定不变为&lt;span class=&quot;math inline&quot;&gt;\(x = 1\)&lt;/span&gt;，采用MSE作为损失函数计算，一样先做公式推导，&lt;/p&gt;
&lt;p&gt;第一步，计算当前误差&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[loss = \frac{1}{2}(a - y)^2 = \frac{1}{2}(0.9 - 0.5)^2 = 0.08\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二步，求出当前梯度&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[grad = (a - y) \times \frac{\partial{a}}{\partial{z}} \frac{\partial{z}}{\partial{w}} = (a - y) \times a \times (1 - a) \times x = (0.9 - 0.5) \times 0.9 \times (1-0.9) \times 1= 0.036\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步，根据梯度更新当前输入值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[w = w - \eta \times grad = ln(9) - 0.2 \times 0.036 = 2.161\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第四步，计算当前误差是否小于阈值（此处设为0.001)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[a = \frac{1}{1 + e^{-wx}} = 0.8967\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[loss = \frac{1}{2}(a - y)^2 = 0.07868\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第五步，重复步骤2-4直到误差小于阈值&lt;/p&gt;
&lt;p&gt;作出函数图像如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/700062/201811/700062-20181115132424805-1260423712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到函数迭代了287次从才收敛到接近0.5的程度，这比单独使用sigmoid函数还要慢了很多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;交叉熵函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个损失函数的目的是使得预测得到的概率分布和真实的概率分布尽量的接近。两个分布越接近，那么这个损失函数得到的函数值就越小。怎么去衡量两个分布的接近程度呢？这就要用到香农信息论中的内容了。两个概率分布之间的距离，也叫做KL Divergence，他的定义是这个形式的,给定离散概率分布P(x), Q(x)，这两个分布之间的距离是&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ D_{KL}(P || Q) = - \sum_{i}P(i)log(\frac{Q(i)}{P(i)})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;试想如果两个分布完全相同，那么&lt;span class=&quot;math inline&quot;&gt;\(log(\frac{Q(i)}{P(i)}) = 0\)&lt;/span&gt;, 也就是两个分布之间的距离是零，如果两个分布差异很大，比如一个是&lt;span class=&quot;math inline&quot;&gt;\(P(0)=0.9, P(1)=0.1\)&lt;/span&gt;,另一个是&lt;span class=&quot;math inline&quot;&gt;\(Q(0)=0.1,Q(1)=0.9\)&lt;/span&gt;,那么这两个分布之间的距离就是0.763，如果是&lt;span class=&quot;math inline&quot;&gt;\(Q(0)=0.5,Q(1)=0.5\)&lt;/span&gt;，那么距离就是0.160，直觉上来说两个分布越接近那么他们之间的距离就是越小的，具体的理论证明参看&lt;a href=&quot;https://book.douban.com/subject/1822197/&quot;&gt;《信息论基础》&lt;/a&gt;，不过为什么要选用这个作为损失函数呢？&lt;/p&gt;
&lt;ul readability=&quot;9.7606199770379&quot;&gt;&lt;li readability=&quot;22.309988518944&quot;&gt;
&lt;p&gt;从最大似然角度开始说&lt;br/&gt;关于最大似然，请参看:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20447622/answer/161722019&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/20447622/answer/161722019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将神经网络的参数作为&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;，数据的真实分布是&lt;span class=&quot;math inline&quot;&gt;\(P_{data}(y;x)\)&lt;/span&gt;, 输入数据为&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，那么在&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;固定情况下，神经网络输出&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;的概率就是&lt;span class=&quot;math inline&quot;&gt;\(P(y;x, \theta)\)&lt;/span&gt;，构建似然函数，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L = \sum_{i}log(P(y_i;x_i, \theta))\]&lt;/span&gt;，&lt;br/&gt;以&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;为参数最大化该似然函数，即&lt;span class=&quot;math inline&quot;&gt;\(\theta^{*} = {argmax}_{\theta}L\)&lt;/span&gt;。&lt;br/&gt;真实分布&lt;span class=&quot;math inline&quot;&gt;\(P(x_i)\)&lt;/span&gt;对于每一个&lt;span class=&quot;math inline&quot;&gt;\((i, x_i, y_i)\)&lt;/span&gt;来说均是定值,在确定&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;情况下，输出是&lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt;的概率是确定的。在一般的情况下，对于每一个确定的输入，输出某个类别的概率是0或者1，所以可以将真实概率添加到上述式子中而不改变式子本身的意义：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\theta^{*} = {argmax}_{\theta}\sum_{i}P_{data}(y_i;x_i)log(P(y_i;x_i, \theta))\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将&lt;span class=&quot;math inline&quot;&gt;\(D_{KL}\)&lt;/span&gt;展开，得到,&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[D_{KL}(P || Q) = - \sum_{i}P(i)log(\frac{Q(i)}{P(i)}) = \sum_{i}P(i)log(P(i)) - \sum_{i}P(i)log(Q(i)) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(P(i)\)&lt;/span&gt;代表&lt;span class=&quot;math inline&quot;&gt;\(P_{data}(y_i;x_i)\)&lt;/span&gt;， &lt;span class=&quot;math inline&quot;&gt;\(Q(i)\)&lt;/span&gt;代表&lt;span class=&quot;math inline&quot;&gt;\(P(y_i;x_i,\theta)\)&lt;/span&gt;。&lt;/p&gt;
上述右侧式中第一项是和仅真实分布&lt;span class=&quot;math inline&quot;&gt;\(P(i)\)&lt;/span&gt;有关的,在最小化&lt;span class=&quot;math inline&quot;&gt;\(D_{KL}\)&lt;/span&gt;过程中是一个定值，所以最小化&lt;span class=&quot;math inline&quot;&gt;\(D_{KL}\)&lt;/span&gt;等价于最小化&lt;span class=&quot;math inline&quot;&gt;\(-\sum_{i}P(i)log(Q(i))\)&lt;/span&gt;，也就是在最大化似然函数。
&lt;ul readability=&quot;6.7523364485981&quot;&gt;&lt;li&gt;函数形式（以二分类任务为例）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[loss = \sum_{i}y(x_i)log(a(x_i)) + (1 - y(x_i))log(1 - a(x_i))\]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(y(x_i)\)&lt;/span&gt;是真实分布，&lt;span class=&quot;math inline&quot;&gt;\(a(x_i)\)&lt;/span&gt;是神经网络输出的概率分布&lt;/li&gt;
&lt;li readability=&quot;15.882352941176&quot;&gt;
&lt;p&gt;反向传播：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{loss}}{\partial{z}} = (-\frac{y(z)}{a(z)} + \frac{1 - y(z)}{1 - a(z)})*\frac{\partial{a(z)}}{\partial{z}} = \frac{a(z) - y(z)}{a(z)(1-y(z))}*\frac{\partial{a(z)}}{\partial{z}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在使用sigmoid作为激活函数情况下，&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial{a(z)}}{\partial{z}} = a(z)(1-a(z))\)&lt;/span&gt;，也就是说，sigmoid本身的梯度和分母相互抵消，得到，&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial{loss}}{\partial{z}} = \frac{a(z) - y(z)}{y(z)(1-a(z))}*\frac{\partial{a(z)}}{\partial{z}} = a(z) - y(z)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在上述反向传播公式中不再涉及到sigmoid本身的梯度，故不会受到在误差很大时候函数饱和导致的梯度消失的影响。&lt;/p&gt;
&lt;p&gt;总的说来，在使用sigmoid作为激活函数时，使用交叉熵计算损失往往比使用均方误差的结果要好上一些。但是，这个也并不是绝对的，需要具体问题具体分析，针对具体应用，有时需要自行设计损失函数来达成目标。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/alexanderkun/p/8098781.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/alexanderkun/p/8098781.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20447622/answer/161722019&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/20447622/answer/161722019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/1822197/&quot;&gt;《信息论基础》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本系列博客链接：&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 05:41:00 +0000</pubDate>
<dc:creator>UniversalAIPlatform</dc:creator>
<og:description>在这一章，我们将简要介绍一下激活函数和损失函数~ 整个系列的目录请点击</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ms-uap/p/9962978.html</dc:identifier>
</item>
<item>
<title>带着萌新看springboot源码06 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/9959616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/9959616.html</guid>
<description>&lt;p&gt;　　这节来说个大家都比较熟悉的东西，就是servlet三大组件，servlet、filter、listener，再说说springboot的内置tomcat。&lt;/p&gt;
&lt;p&gt;　　也许还会说一下tomcat的运行原理，还有，springboot不是不支持jsp吗（是因为嵌入式tomcat的原因），那我就让springboot支持jsp，其他的还是一样。&lt;/p&gt;
&lt;p&gt;　　比较长，可能要分为两节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.servlet配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;想必大家不会陌生servlet配置，写个类继承HttpServlet，然后在原来的web.xml文件中配置&amp;lt;servlet-name&amp;gt;&amp;lt;servlet-class&amp;gt;还有配置servlet的映射路径&amp;lt;servlet-mapping&amp;gt;,忘记的小伙伴就回头看看啊。&lt;/p&gt;
&lt;p&gt;　　现在的springboot配置servlet，也差不多，写个servlet，但是记住，springboot不能直接识别servlet，需要借助一个工具ServletRegistrationBean（xxxBean在学spring的时候应该很常见，本质上还是一个Bean，但是有能够生产bean的能力，类似一个简单的工厂类）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115105049731-2139880413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们接着随意找个配置类（我图方便，就在那个main方法的主配置类加了），加入如下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115105700083-1258409796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　ok，就这样，然后运行，浏览器输入网址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115105853394-907001696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.配置Filter&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;配置和上面差不多，写个Filter实现类，利用FilterRegistrationBean往容器里添加filter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115111358865-1566623358.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115111508349-1228396604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后运行springboot，输入xxxxx/hehe就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115112045428-1736808930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.配置listener&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;listener最容易，因为前面两个还有配置url映射，这个listener不用配。写个listener，利用ServletListenerRegistrationBean添加到容器里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115112428621-1964742865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115113347877-1787106730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　启动和关闭应用就能看到结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115113425826-1929506733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115113457912-1542528364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后的就是注意ServletListenerRegistrationBean这个类要传入泛型，打开这个类，可以看到我们可以定制监听器的类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115113658812-1371897090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 4，简单说说嵌入式servlet容器（springboot默认当然是用tomcat）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;springboot应用和以前的ssm等应用最大的不同是，springboot可以打成jar包，然后在装有java运行环境的电脑，就能用java -jar xxx.jar就能够直接运行一个springboot应用，非常方便，但是缺点是不支持jsp；&lt;/p&gt;
&lt;p&gt;　　而ssm、ssh等的就要达成war包，然后在新的电脑上配置java环境，下载tomcat，再配置tomcat和java的版本，然后才能部署应用，运行，emmmm....估计要很久！&lt;/p&gt;
&lt;p&gt;　　造成这种结果的最大原因就是springboot装的是小tomcat（咳咳，这是我自己为了方便理解才说的，标准称呼是嵌入式servlet容器，英文全程：EmbeddedServletContainer），以下假如看到小tomcat，就要理解是嵌入式servlet容器啊（EmbeddedServletContainer），这么长的单词一定要记下来，因为后面会有更长的.....&lt;/p&gt;
&lt;p&gt;　　首先简单说说servlet容器种类。常见的Tomcat（springboot默认），Jetty（适用于长连接，比如聊天这种），Undertow(不支持jsp，但是并发性能非常好)，各有优势。&lt;/p&gt;
&lt;p&gt;　　打开pom配置文件，可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115115523995-1464123973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后将tomcat变为jetty就可以了，maven就会自动帮你下载对应的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115115713556-1333823796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　运行springboot，控制台输出如下所示，你就成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181115120019890-1849611941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到这里，springboot配置servlet三大组件以及切换嵌入式servlet容器就讲完了，接下来干什么想必都很清楚，当然是怎么修改容器的默认配置以及运行原理啊！&lt;/p&gt;
&lt;p&gt;　　不知道大家有没有发现上图端口是8081（默认8080）,在配置文件是怎么配置的（以前说过，估计很多人都知道），为什么会起作用？我能不能用@Bean的方式修改容器默认参数呢？以及其中的运行原理？当然，也会带着大家一起走走从主配置类开始，通过一个run方法，逐渐的就运行容器的过程。&lt;/p&gt;
&lt;p&gt;　　后面还会说说不用嵌入式servlet容器的方式，我就用我外界下载的tomcat和springboot应用一起用，并且还支持jsp。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 04:34:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>这节来说个大家都比较熟悉的东西，就是servlet三大组件，servlet、filter、listener，再说说springboot的内置tomcat。 也许还会说一下tomcat的运行原理，还有，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/9959616.html</dc:identifier>
</item>
<item>
<title>从一起“盗币”事件再谈合约安全问题 - baizx</title>
<link>http://www.cnblogs.com/baizx/p/9962754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baizx/p/9962754.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;本来是受到&lt;a href=&quot;https://xlab.tencent.com/cn/2018/11/09/pay-attention-to-the-ethereum-hash-collision-problem-from-the-stealing-coins-incident/#more-404&quot;&gt;从一起“盗币”事件看以太坊存储 hash 碰撞问题&lt;/a&gt;一文启发,但是我并不太认同文中的观点.并且文中有一些技术性错误.&lt;/p&gt;
&lt;h2 id=&quot;一.-起因&quot;&gt;一. 起因&lt;/h2&gt;
&lt;p&gt;今日某安全厂商在以太坊上发布一份让大家来&quot;盗币&quot;的&lt;a href=&quot;https://etherscan.io/address/0x5170a14aa36245a8a9698f23444045bdc4522e0a#code&quot;&gt;合约&lt;/a&gt;,就是希望大家能够意识到不好的合约设计会存在严重安全隐患.下面是这份合约源码.&lt;/p&gt;
&lt;pre class=&quot;sol&quot;&gt;
&lt;code&gt;pragma solidity ^0.4.21;
contract DVPgame {
    ERC20 public token;
    uint256[] map;
    using SafeERC20 for ERC20;
    using SafeMath for uint256;
    constructor(address addr) payable{
        token = ERC20(addr);
    }
    function (){
        if(map.length&amp;gt;=uint256(msg.sender)){
            require(map[uint256(msg.sender)]!=1);
        }
        if(token.balanceOf(this)==0){
            //airdrop is over
            selfdestruct(msg.sender);
        }else{
            token.safeTransfer(msg.sender,100);

            if (map.length &amp;lt;= uint256(msg.sender)) {
                map.length = uint256(msg.sender) + 1;
            }
            map[uint256(msg.sender)] = 1;  

        }
    }
    //Guess the value(param:x) of the keccak256 value modulo 10000 of the future block (param:blockNum)
    function guess(uint256 x,uint256 blockNum) public payable {
        require(msg.value == 0.001 ether || token.allowance(msg.sender,address(this))&amp;gt;=1*(10**18));
        require(blockNum&amp;gt;block.number);
        if(token.allowance(msg.sender,address(this))&amp;gt;0){
            token.safeTransferFrom(msg.sender,address(this),1*(10**18));
        }
        if (map.length &amp;lt;= uint256(msg.sender)+x) {
            map.length = uint256(msg.sender)+x + 1;
        }

        map[uint256(msg.sender)+x] = blockNum;
    }
    //Run a lottery
    function lottery(uint256 x) public {
        require(map[uint256(msg.sender)+x]!=0);
        require(block.number &amp;gt; map[uint256(msg.sender)+x]);
        require(block.blockhash(map[uint256(msg.sender)+x])!=0);
        uint256 answer = uint256(keccak256(block.blockhash(map[uint256(msg.sender)+x])))%10000;
        if (x == answer) {
            token.safeTransfer(msg.sender,token.balanceOf(address(this)));
            selfdestruct(msg.sender);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述文中提到这里面安全问题是因为solidity在存储map时候的地址计算方式,存在hash碰撞问题,所以导致币被盗走. 但是显然并不是因为hash碰撞问题. 确实不好的设计会导致hash碰撞问题,但是这里确实不是hash碰撞引起的问题.&lt;/p&gt;
&lt;h2 id=&quot;二.-solidity复杂变量的地址计算问题&quot;&gt;二. solidity复杂变量的地址计算问题&lt;/h2&gt;
&lt;h3 id=&quot;一个示例&quot;&gt;一个示例&lt;/h3&gt;
&lt;p&gt;开始之前,我们先找一个兼具各种元素&lt;/p&gt;
&lt;pre class=&quot;solidity&quot;&gt;
&lt;code&gt;pragma solidity ^0.4.23; 
contract Locked {
    bool public unlocked = false;    
    struct NameRecord { 
        bytes32 name;
        address mappedAddress;
    }
    mapping(address =&amp;gt; NameRecord) public registeredNameRecord; 
    mapping(bytes32 =&amp;gt; address) public resolve;
    NameRecord []records;
    function register(bytes32 _name, address _mappedAddress) public {
        NameRecord newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress; 
        resolve[_name] = _mappedAddress;
        registeredNameRecord[msg.sender] = newRecord; 
        require(unlocked); 
    }
    function newRecords(uint256 index,bytes32 _name, address _mappedAddress) public{
        NameRecord memory newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress; 
        if(recor)
        records[index]=newRecord;
        require(unlocked);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;简单变量的地址&quot;&gt;简单变量的地址&lt;/h3&gt;
&lt;p&gt;每个合约都会有自己独立的存储空间(storage),运行时的Memory空间.storage和memory空间都是从0开始.&lt;br/&gt;因为EVM是一个256位的虚拟机,因此Storage空间有2**256*256位这么大.&lt;br/&gt;作为Locked这份合约中第一个简单变量unlcoked的地址就是0.&lt;br/&gt;基本类型int,string,bytes32,固定大小的数组等都是简单类型,他们有固定的长度. 很容易算出来占用多少字节空间,因此只需依次累加即可.&lt;br/&gt;比如registeredNameRecord的地址是1,resolve的地址是2,records地址就是3&lt;br/&gt;&lt;strong&gt;另外就是要注意空间对齐问题&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;动态数组以及map的地址&quot;&gt;动态数组以及Map的地址&lt;/h3&gt;
&lt;h4 id=&quot;array计算问题&quot;&gt;Array计算问题&lt;/h4&gt;
&lt;p&gt;因为动态数组,比如这里的records事先无法预知大小,他的地址计算就会用到hash. 简单来说,这里records中元素的起始地址就是hash(slot),这里的slot是3,因为records是第四个变量.&lt;br/&gt;这个hash(slot)就是这个数组的起始地址,真正存储的变量地址则是hash(slot)+offset,offset的计算方式就和其他所有语言的offset计算方式都一样i*sizeof(NameRecord).&lt;/p&gt;
&lt;p&gt;这种方式的好处就在于&lt;strong&gt;节省Gas&lt;/strong&gt;,虽然定义了records对象,但是在你没存储任何对象之前,不会浪费一点Gas,要知道存储一个字就是20000Gas,成本昂贵.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而slot3,也就是3这个地址存的是数组的长度&lt;/strong&gt;.&lt;/p&gt;
&lt;h4 id=&quot;map地址计算问题&quot;&gt;Map地址计算问题&lt;/h4&gt;
&lt;p&gt;Map的存储设计方式类似于Array,一样为了节省Gas,采用hash计算地址.和Array不一样的是,他是Hash(key,slot)而不是简单的slot. 以resolve这个map为例,&quot;arandname&quot;存储地址就是hash(bytes32(&quot;arandnme&quot;),uint256(2).&lt;/p&gt;
&lt;p&gt;如果存储对象比较复杂,不止占用一个字的存储空间,按照顺序递增即可.&lt;/p&gt;
&lt;h2 id=&quot;三.-先来玩demo&quot;&gt;三. 先来玩demo&lt;/h2&gt;
&lt;p&gt;newRecords函数成功调用,必须要求unlocked为true,但是unlocked并没有可以修改的地方. 这是一个棘手的问题,实际上这个是最前面合约问题的简化.&lt;/p&gt;
&lt;p&gt;首先我们知道unlocked的存储地址为0&lt;br/&gt;其次我们已经知道了动态数组的地址计算规则,那么是否可以让records[index]计算结果是0呢?&lt;/p&gt;
&lt;p&gt;这个地址我们已经知道是hash(records_slot)+index*sizeof(NameRecord).&lt;br/&gt;有了这个公式其实已经比较容易算出来了.&lt;/p&gt;
&lt;p&gt;让我们来一步一步计算这个地址吧.&lt;/p&gt;
&lt;h3 id=&quot;部署合约&quot;&gt;部署合约&lt;/h3&gt;
&lt;p&gt;这一步比较容易在Remix中选择Javascript VM方式直接部署即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/124391/201811/124391-20181115120143310-712169367.png&quot; alt=&quot;部署Locked&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;初次调用newrecords&quot;&gt;初次调用newRecords&lt;/h3&gt;
&lt;p&gt;应该说绝大多数时候newRecords肯定是无法直接调用成功,那就先来一次失败调用吧.&lt;br/&gt;我们就传入参数&lt;br/&gt;&lt;code&gt;0,&quot;0x3131313131313131313131313131313131313131313131313131313131313131&quot;,&quot;0x692a70d2e424a56d2c6c27aa97d1a86395877b3a&quot;&lt;/code&gt;&lt;br/&gt;可以看到调用失败了,失败结果如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/124391/201811/124391-20181115120213763-736021450.png&quot; alt=&quot;失败调用&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;从失败中找到正确方法&quot;&gt;从失败中找到正确方法&lt;/h3&gt;
&lt;p&gt;常言说,失败乃成功之母,我们就从失败中寻找成功吧.&lt;/p&gt;
&lt;h4 id=&quot;debug去找寻存储地址hashrecords_slot&quot;&gt;Debug去找寻存储地址hash(records_slot)&lt;/h4&gt;
&lt;p&gt;单击Debug开始找寻地址的旅程吧.&lt;/p&gt;
&lt;p&gt;这整个过程只有最后的&lt;code&gt;records[index]=newRecord&lt;/code&gt;会在storage空间存储内容,因此我们只需快进到sstore指令即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/124391/201811/124391-20181115120232917-246700780.png&quot; alt=&quot;找寻sstore&quot;/&gt;&lt;br/&gt;从Stack中可以看到0元素的起始地址是&lt;code&gt;0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b&lt;/code&gt;,要在这个地址上存储的对象是就是&lt;code&gt;0x3131313131313131313131313131313131313131313131313131313131313131&lt;/code&gt;,恰好就是name的值.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b&lt;/code&gt;就是Sha3(3).&lt;/p&gt;
&lt;h3 id=&quot;构造成功的调用&quot;&gt;构造成功的调用&lt;/h3&gt;
&lt;p&gt;首先起始地址是0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b,而sizeof(NameRecord)是2,&lt;strong&gt;注意不是64,因为EVM单位是32字节而不是字节&lt;/strong&gt;&lt;br/&gt;就很容易推算出来Index是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(0x10000000000000000000000000000000000000000000000000000000000000000-
0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b)/2
=0x1ed452f8b0d361ff8353039b6876926bcb1e6352e27d7e97d0ed74ddc84703d2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们的调用参数就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0x1ed452f8b0d361ff8353039b6876926bcb1e6352e27d7e97d0ed74ddc84703d2,&quot;0x3131313131313131313131313131313131313131313131313131313131313131&quot;,&quot;0x692a70d2e424a56d2c6c27aa97d1a86395877b3a&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图可以看到成功调用.&lt;br/&gt;[调用结果]&lt;img src=&quot;https://img2018.cnblogs.com/blog/124391/201811/124391-20181115120256869-1835023047.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.-再一起来玩dvpgame&quot;&gt;四. 再一起来玩DVPgame&lt;/h2&gt;
&lt;p&gt;有了上面的思路相信大家就不会想着想法设法猜测lottery的x是多少了,直奔我们的fallback函数即可.&lt;/p&gt;
&lt;h3 id=&quot;覆盖token&quot;&gt;覆盖token&lt;/h3&gt;
&lt;p&gt;先通过guess函数把token设置为你自己事先部署的一份ERC20 Token,当然DVPgame就不会有任何这种新Token.&lt;/p&gt;
&lt;p&gt;让hash(1)+msg.sender+x大于2**256,这个很容易满足吧.&lt;br/&gt;然后把blockNum指定为你的token地址,相信他肯定会比当前的block.number大的.&lt;/p&gt;&lt;p&gt;悄悄告诉你hash(1)就是&lt;code&gt;0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&lt;/code&gt;,方便您试试.&lt;/p&gt;
&lt;h3 id=&quot;随便转点以太坊给dvpgame&quot;&gt;随便转点以太坊给DVPgame&lt;/h3&gt;
&lt;p&gt;正常转账给DVPgame这个合约地址,无论多少都无所谓,反正最后都是会回到我们自己的账户上. 不过还是不要太多,万一有人捷足先登了呢.&lt;/p&gt;
&lt;h3 id=&quot;看看别人怎么玩的&quot;&gt;看看别人怎么玩的&lt;/h3&gt;
&lt;p&gt;到底怎么玩我就不做了,因为已经有人玩过了,我也是事后诸葛亮. &lt;a href=&quot;https://etherscan.io/tx/0x4c15cbadc1743503464c7d8e5ad67eeb3247c2b728b846765122722f5635690a#internal&quot;&gt;链上直播看这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五.-剩下的问题&quot;&gt;五. 剩下的问题&lt;/h2&gt;
&lt;p&gt;如果你细心,就会发现我的例子中还有一个register函数没说.如果你自己尝试调用了,就会发现无论怎么调用都会成功,是不是颠覆了三观啊.&lt;br/&gt;其实原因很简单,solidity中结构体默认是分配在storage空间中的(我也不知道为什么这么做,确实有点坑),而且这时候结构体的地址的起始地址就是0. 也就是说&lt;code&gt;newRecord.name = _name;&lt;/code&gt;这句话在你不知不觉中就覆盖了unlocked.&lt;br/&gt;说到这里,我还想说的是：&lt;span&gt;如果你在写合约,请把solidity怎么工作的,搞清楚再动手&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你够细心,至少register中的这个bug是可以避免的,因为solidity都警示你了.&lt;br/&gt;[来自solidity的warn] (https://img2018.cnblogs.com/blog/124391/201811/124391-20181115120330641-1178298347.png)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;solidity的任何warning都请不要忽略&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;六.-小测试工具&quot;&gt;六. 小测试工具&lt;/h2&gt;
&lt;p&gt;计算hash值的小工具&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//Sha3 is short for Keccak256Hash
func Sha3(data ...[]byte) common.Hash {
    return crypto.Keccak256Hash(data...)
}

//BigIntTo32Bytes convert a big int to bytes
func BigIntTo32Bytes(i *big.Int) []byte {
    data := i.Bytes()
    buf := make([]byte, 32)
    for i := 0; i &amp;lt; 32-len(data); i++ {
        buf[i] = 0
    }
    for i := 32 - len(data); i &amp;lt; 32; i++ {
        buf[i] = data[i-32+len(data)]
    }
    return buf
}

func TestCalcHashSlot(t *testing.T) {
    i := big.NewInt(3)
    hash := Sha3(BigIntTo32Bytes(i))
    t.Logf(&quot;hash=%s&quot;, hash.String()) //0xc2575a0e9e593c00f959f8c92f12db2869c3395a3b0502d05e2516446f71f85b
    addr := common.Address{}
    fix := [32]byte{}
    copy(fix[12:], addr[:])
    hash = Sha3(addr[:])
    //addr=0x0000000000000000000000000000000000000000,it's hash=0x5380c7b7ae81a58eb98d9c78de4a1fd7fd9535fc953ed2be602daaa41767312a
    t.Logf(&quot;addr=%s,it's hash=%s&quot;, addr.String(), hash.String())
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 15 Nov 2018 04:05:00 +0000</pubDate>
<dc:creator>baizx</dc:creator>
<og:description>从一起“盗币”事件再谈合约安全问题 &lt;! @import</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baizx/p/9962754.html</dc:identifier>
</item>
<item>
<title>php，vue，vue-ssr 做出来的页面有什么区别？ - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9962253.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9962253.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/2681943&quot;&gt;shirishiyue&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/73029?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前我这边的web页面，都是采用php+smarty模板生成的，是一种比较早期的开发模式。好处是没有现阶段常用的前后端分离出现的首屏问题，因为其本身就是服务器渲染，坏处是代码分离不好做，公用化及组件化不好做。这里涉及前后端分离相关问题，老生常谈，这里暂不讨论。&lt;/p&gt;
&lt;p&gt;​ 近期，在做一些前端分离的尝试。采用国内非常流行的的vue框架，选这个框架而不是react的原因主要是vue的mvvm保留html书写惯性，对于html里写代码多的人来说更容易入手。而且流行框架vue也经过了极大量的测试验证，参考资料充实详尽，可靠性和易用性都满足条件，没有理由不尝试一下。&lt;/p&gt;
&lt;p&gt;​ 总的来说，做了一个如下小应用demo，长下面这样，三个简单页面，分页查看所有王者英雄，或者所有装备。分别采用 php+smarty，vue-cli，vue+ssr，三种方式进行开发，完了再对结果做一下对比。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/y3xe0u8fo6.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 三个版本的体验入口如下&lt;em&gt;（尽量用手机浏览器扫描，微信对ip域名有特殊处理），&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/qslgg8d6kw.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 三个版本并没有严格做相同环境处理，所以下面的对比分析仅作为直观上的对比了解，并不适用于详细性能上的严格对比额。&lt;/p&gt;
&lt;p&gt;​ 对三个页面分别进行webpage test，测试结果如下，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;▲ 详细结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ php版：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.webpagetest.org/result/181108_2D_20fc46a11de58d60dde7421b6d3be954/&quot; class=&quot;uri&quot;&gt;https://www.webpagetest.org/result/181108_2D_20fc46a11de58d60dde7421b6d3be954/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ vue ssr 服务器渲染版：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.webpagetest.org/result/181108_XY_92f54bd829b1b6f02634774294491736/&quot; class=&quot;uri&quot;&gt;https://www.webpagetest.org/result/181108_XY_92f54bd829b1b6f02634774294491736/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ vue-cli 静态版：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.webpagetest.org/result/181108_4G_011f6c33da1e7f199f8a1ecd03ef0728/&quot; class=&quot;uri&quot;&gt;https://www.webpagetest.org/result/181108_4G_011f6c33da1e7f199f8a1ecd03ef0728/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;▲ 综合参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/oa6xp8odzr.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、页面加载时间。理所当然是纯静态的vue-cli最快。vue ssr 和 php 版差不多（忽略上面的php版，因为php版有一些额外资源要加载）。&lt;/p&gt;
&lt;p&gt;2、首字节时间。静态的最快。若扣除dns时间，其实php和vue-ssr版差不多。（注：php版和vue ssr版不是部署在同一台机器上，php版机器性能要强一些，多核，vue-ssr版机器比较弱单cpu单核）&lt;/p&gt;
&lt;p&gt;3、渲染时间和页面呈现熟读指数，vue ssr版比php版本稍微慢一点。这是因为，php的html到页面后直接就呈现了，而vue ssr到client后，有一个vue框架的渲染过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;▲ 加载瀑布流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 从加载流的角度上看一下三者的区别，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/uzt8pgen7p.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;php版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/h85fkxw6ql.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;vue ssr 服务器渲染版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/5za4ctohf0.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;vue-cli静态版本&lt;/p&gt;
&lt;p&gt;​ 从瀑布流上可以看出很多三种页面执行方式的区别，列举一部分如下：&lt;/p&gt;
&lt;p&gt;1、php 版以及 vue-ssr 版 有较长的服务器处理时间，，，对应的首字节时间明显高于没有服务器处理的vue-cli静态页面。&lt;/p&gt;
&lt;p&gt;2、由于服务器版本的php或者vue-ssr的首屏数据都已经生成了，所以页面不会再次请求接口，少了数据的请求过程。而vue-cli版有一个较长的数据请求过程。&lt;/p&gt;
&lt;p&gt;3、vue-cli静态页面的dom content time 或者 document complete time 明显最短，原因是模板html几乎没什么内容。&lt;/p&gt;
&lt;p&gt;4、webpack打包拆离出来的独立js或者css文件，其实在同一域名下，由于浏览器同一域名可以并行6个tcp，以及http的keep-alive性质，其实总的下载时间不多。对比看，跟阻塞的dns时间差不多。&lt;/p&gt;
&lt;p&gt;5、三种页面 Start Renderer Time 分别是 1.2s，1.3s，2.0s。 vue-cli静态页面生成的白屏时间中，大部分是首屏数据请求消耗的时间，，同时也可以对比出，服务器渲染的对首屏时间的确有很明显的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;▲ 直观体验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 时间，，平均速度指数Speed Index，分别是1.2，，，1.3，，，2.0s，，，可以观察下面的对比视频体验。&lt;/p&gt;
&lt;p&gt;​ &amp;gt;&lt;a href=&quot;https://game.gtimg.cn/images/user/cp/a20180412tk/test/PageExperience.html&quot;&gt;点此观看动态视频&amp;lt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/2681943/axu25yp0wp.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.68571428571429&quot;&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1128?fromSource=waitui&quot;&gt;【每日课程推荐】机器学习实战！快速入门在线广告业务及CTR相应知识&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1362652?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 02:56:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9962253.html</dc:identifier>
</item>
<item>
<title>Java中锁的实现与内存语义 - 蜗牛大师</title>
<link>http://www.cnblogs.com/wuqinglong/p/9962142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuqinglong/p/9962142.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;锁在实际使用时只是明白锁限制了并发访问, 但是锁是如何实现并发访问的, 同学们可能不太清楚, 下面这篇文章就来揭开锁的神秘面纱.&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;当线程获取锁时, JMM会把线程对应的本地内存置为无效. 从而使得被监视器保护的临界区的变量必须从主内存中读取.&lt;/li&gt;
&lt;li&gt;当线程释放锁时, JMM会把该线程对应的本地内存中的共享变量刷新到主内存中(并不是不释放锁就不刷新到主内存, 只是释放锁时把未刷新到主内存中的数据刷新到主内存).&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;锁的内存语义与volatile的内存语义&quot;&gt;锁的内存语义与volatile的内存语义&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;锁获取与volatile读有相同的内存语义.&lt;/li&gt;
&lt;li&gt;锁释放与volatile写有相同的内存语义.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;内存语义总结&quot;&gt;内存语义总结&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;线程A释放一个锁, 实质上是线程A向接下来将要获取这个锁的某个线程发出了(线程A对共享变量所做修改的)消息.&lt;/li&gt;
&lt;li&gt;线程B获取一个锁, 实质上是线程B接收了之前某个线程发出的(在释放这个锁之前对共享变量所做修改的)消息.&lt;/li&gt;
&lt;li&gt;线程A释放锁, 随后线程B获取这个锁, 这个过程实质上是线程A通过主内存向线程B发送消息.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以ReentrantLock为例, 获取到锁就是把state改为1(不考虑重入), 释放锁时改为0.&lt;/p&gt;
&lt;p&gt;而加锁的关键代码就是&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected final boolean compareAndSetState(int expect, int update) {
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法以原子操作的方式更新state变量, 本文把Java的compareAndSet()方法简称为CAS. JDK文档对该方法的说明如下: 如果当前状态值等于预期值, 则以原子方式将同步状态设置为给定的更新值. 此操作具有volatile读和写的内存语义.&lt;/p&gt;
&lt;p&gt;这里我们分别从编译器和处理器的角度来分析: CAS如何同时具有volatile读和volatile写的内存语义.&lt;/p&gt;
&lt;p&gt;我们知道, 编译器不会对volatile读与volatile读后面的任意内存操作重排序; 编译器不会对volatile写与volatile写前面的任意内存操作重排序. 组合这两个条件, 意味着为了同时实现volatile读和volatile写的内存语义, 编译器不能对CAS与CAS前面和后面的任意内存操作重排序.&lt;/p&gt;
&lt;p&gt;下面我们来分析在常见的intel X86处理器中, CAS是如何同时具有volatile读和volatile写的内存语义的.&lt;/p&gt;
&lt;p&gt;下面是sun.misc.Unsafe类的compareAndSwapInt()方法的源代码.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到, 这是一个本地方法调用. 这个本地方法在openjdk中依次调用的c++代码为: unsafe.cpp, atomic.cpp 和 atomic_windows_x86.inline.hpp. 这个本地方法的最终实现在openjdk的如下位置: openjdk-7-fcs-src-b147-&lt;br/&gt;27_jun_2011\openjdk\hotspot\src\os_cpu\windows_x86\vm\atomic_windows_x86.inline.hpp(对应于&lt;br/&gt;Windows操作系统, X86处理器). 下面是对应于intel X86处理器的源代码的片段.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    // alternative for InterlockedCompareExchange
    int mp = os::is_MP();
    __asm {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        LOCK_IF_MP(mp)
        cmpxchg dword ptr [edx], ecx
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上面源代码所示, 程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀. 如果程序是在多处理器上运行, 就为cmpxchg指令加上lock前缀(Lock Cmpxchg). 反之, 如果程序是在单处理器上运行, 就省略lock前缀(单处理器自身会维护单处理器内的顺序一致性, 不需要lock前缀提供的内存屏障效果).&lt;/p&gt;
&lt;p&gt;intel的手册对lock前缀的说明如下.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确保对内存的读-改-写操作原子执行. 在Pentium及Pentium之前的处理器中, 带有lock前缀的指令在执行期间会锁住总线, 使得其他处理器暂时无法通过总线访问内存. 很显然, 这会带来昂贵的开销. 从Pentium 4、Intel Xeon及P6处理器开始, Intel使用缓存锁定(Cache Locking)&lt;br/&gt;来保证指令执行的原子性. 缓存锁定将大大降低lock前缀指令的执行开销.&lt;/li&gt;
&lt;li&gt;禁止该指令, 与之前和之后的读和写指令重排序.&lt;/li&gt;
&lt;li&gt;把写缓冲区中的所有数据刷新到内存中.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面的第2点和第3点所具有的内存屏障效果, 足以同时实现volatile读和volatile写的内存语义.&lt;/p&gt;
&lt;p&gt;经过上面的分析, 现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和volatile写的内存语义了.&lt;/p&gt;
&lt;p&gt;从本文对ReentrantLock的分析可以看出, 锁释放-获取的内存语义的实现至少有下面两种方式.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;利用volatile变量的写-读所具有的内存语义.&lt;/li&gt;
&lt;li&gt;利用CAS所附带的volatile读和volatile写的内存语义.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于锁, 可以这么理解, N个线程去通过CAS去修改一个volatile变量, 但是由于CPU提供的机制, 只能有一个线程修改成功, 修改成功的线程获得锁, 其它线程以及后来的线程要么自旋一会儿, 要么直接挂起, 等待获取锁的线程释放锁时去唤醒. 就是这么个过程.&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 02:41:00 +0000</pubDate>
<dc:creator>蜗牛大师</dc:creator>
<og:description>[TOC] 1. 概述 锁在实际使用时只是明白锁限制了并发访问, 但是锁是如何实现并发访问的, 同学们可能不太清楚, 下面这篇文章就来揭开锁的神秘面纱. 2. 锁的内存语义 当线程获取锁时, JMM会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuqinglong/p/9962142.html</dc:identifier>
</item>
<item>
<title>聊聊 scala 的模式匹配 - zzzzMing</title>
<link>http://www.cnblogs.com/listenfwind/p/9962143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/listenfwind/p/9962143.html</guid>
<description>&lt;h3 id=&quot;一.-scala-模式匹配pattern-matching&quot;&gt;一. scala 模式匹配（pattern matching）&lt;/h3&gt;
&lt;p&gt;pattern matching 可以说是 scala 中十分强大的一个语言特性，当然这不是 scala 独有的，但这不妨碍它成为 scala 的语言的一大利器。&lt;/p&gt;
&lt;p&gt;scala 的 pattern matching 是类似这样的，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;e match {
  case Pattern1 =&amp;gt; do Something
  case Pattern2 if-clause =&amp;gt; do others
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，变量 e 后面接一个 match 以及一个代码块，其中每个 case 对应一种可能回匹配的类型，如果匹配成功则执行 =&amp;gt; 后面的代码。&lt;/p&gt;
&lt;p&gt;我们可以用一个具体一些的例子来看看模式匹配是怎么工作的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case class Player(name: String, score: Int)
def printMessage(player: Player) = player match {
  case Player(_, score) if score &amp;gt; 100000 =&amp;gt;
    println(&quot;Get a job, dude!&quot;)
  case Player(name, _) =&amp;gt;
    println(&quot;Hey, $name, nice to see you again!&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来有点类似于其他语言的 switch，但其实还是有很大的不同的。&lt;/p&gt;
&lt;p&gt;以java 的 switch 为例，java 的 switch 仅仅会做一些基本类型的匹配，然后执行一些动作，并且是没有返回值的。&lt;/p&gt;
&lt;p&gt;而 scala 的 pattern matching match 则要强大得多，除了可以匹配数值，同时它还能匹配类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parseArgument(arg: String) = arg match {
    //匹配值
    case &quot;-h&quot; | &quot;--help&quot; =&amp;gt; displayHelp
    case &quot;-v&quot; | &quot;--version&quot; =&amp;gt; displayVerion
    case whatever =&amp;gt; unknownArgument(whatever)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;def f(x: Any): String = x match {
    //匹配类型
    case i:Int =&amp;gt; &quot;integer: &quot; + i
    case _:Double =&amp;gt; &quot;a double&quot;
    case s:String =&amp;gt; &quot;I want to say &quot; + s
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时 pattern matching 是有返回值的，比如上面的 match ，它返回的就是一个 Unit。我们也可以修改上面的代码让它返回一个字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case class Player(name: String, score: Int)
def message(player: Player) = player match {
  case Player(_, score) if score &amp;gt; 100000 =&amp;gt;
    &quot;Get a job, dude!&quot;
  case Player(name, _) =&amp;gt;
    &quot;Hey, $name, nice to see you again!&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得一提的是， pattern matching 返回值是由第一个匹配的模式中的代码块决定的。&lt;/p&gt;
&lt;h3 id=&quot;二.-为什么要用-pattern-matching&quot;&gt;二. 为什么要用 pattern matching&lt;/h3&gt;
&lt;p&gt;看到这里你会发现一个问题， pattern matching 不是和if else 差不多吗？那为什么还要使用 pattern matching 呢？&lt;/p&gt;
&lt;p&gt;首先我们需要明白，模式匹配其实本质上是提供一个方便的解构 (Destructuring) 数据结构的方式，以 scala 为例， pattern matching 其实用到了 scala 中提取器的功能， 提取器其实就是类中的 unapply () 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trait User {
  def name: String
}
class FreeUser(val name: String) extends User
object FreeUser {
  //提取器
  def unapply(user: FreeUser): Option[String] = Some(user.name)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  val user: User = new FreeUser(&quot;Daniel&quot;)
  user match {
    case FreeUser(name) =&amp;gt; println(&quot;it match here&quot; + name)
    case _ =&amp;gt; println(&quot;not me&quot;)
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明白了模式匹配的本质你就会直到，其实 if else 只是 pattern matching 中的一个典型的用法，但并非它的全部。&lt;/p&gt;
&lt;p&gt;同时， pattern matching 允许你解耦两个并不真正属于彼此的东西，也使得你的代码更易于测试。比如上面的 match 部分的代码我们可以写成下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  val user: User = new FreeUser(&quot;Daniel&quot;)
  //将返回结果存在一个常量中
  val message = user match {
    case FreeUser(name) =&amp;gt; &quot;it match here&quot; + name
    case _ =&amp;gt; &quot;not me&quot;
  }
  //可以随意使用该常量，实现解耦
  println(message)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样会赋予代码更多的灵活性，同时也更加方便做进一步操作。&lt;/p&gt;
&lt;p&gt;而以可读性的角度来说，使用一大堆的 if else 代码无疑是比较难看的，而如果使用 pattern matching 的话，代码会简洁清晰很多，而简洁的代码则会更容易阅读。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.yonyoucloud.com/doc/guides-to-scala-book/chp3-pattern-everywhere.html&quot; class=&quot;uri&quot;&gt;https://doc.yonyoucloud.com/doc/guides-to-scala-book/chp3-pattern-everywhere.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/30354775&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/30354775&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 02:41:00 +0000</pubDate>
<dc:creator>zzzzMing</dc:creator>
<og:description>一. scala 模式匹配（pattern matching） pattern matching 可以说是 scala 中十分强大的一个语言特性，当然这不是 scala 独有的，但这不妨碍它成为 sc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/listenfwind/p/9962143.html</dc:identifier>
</item>
</channel>
</rss>