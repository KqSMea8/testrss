<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一份详细的 Matplotlib入门指导 - Jin_liang</title>
<link>http://www.cnblogs.com/jin-liang/p/9863987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jin-liang/p/9863987.html</guid>
<description>&lt;p&gt;hMatplotlib是最受欢迎的二维图形库，但有时我们很难做到得心应手的去使用。&lt;/p&gt;
&lt;p&gt;如何更改图例上的标签名称？ 如何设置刻度线？ 如何将比例更改为对数？ 如何在我的情节中添加注释和箭头？ 如何在我的图中添加网格线？&lt;/p&gt;
&lt;p&gt;本文汇集了有关如何自定义Matplotlib图的常见问题和答案。 这可以作为快速Matplotlib绘图的一个很好的备忘单，而不是Matplotlib库的介绍。 &lt;/p&gt;
&lt;p&gt;首先我们导入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; matplotlib.pyplot as plt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Jupyter Notebook中，您可以在下面包含这一行，这样您就不必在每次想要制作绘图时调用plt.show（）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
%matplotlib inline
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;c6a0&quot; class=&quot;graf graf--h3 graf-after--figure&quot;&gt;图与子图（PLOTS AND SUBPLOTS）&lt;/h3&gt;
&lt;p&gt;Q1:怎样定义图形的尺寸？&lt;/p&gt;
&lt;p&gt;许多情况下，默认的画布都太小，我们需要自己定义一个合适的画布。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
plt.figure(figsize=(20,10))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Q2:什么是子图（subplots）？怎样去创建子图？&lt;/p&gt;
&lt;p&gt;子图是一组较小的轴，它们在一个图中一起存在。 下面是2 x 2形式的四个子图的示例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027233453275-580972306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些子图是使用下面的代码创建的。 我们调用plt.subplot并指定三个数字。 它们指的是要创建子图的的行数，列数和子图号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range (1, 5&lt;span&gt;):
    plt.subplot(&lt;/span&gt;2, 2&lt;span&gt;, i)
    plt.text(&lt;/span&gt;0.5,0.5, str((2, 2, i)), ha=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fontsize = 10&lt;span&gt;)
    plt.tight_layout()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的子图中，图中的文本是对这三个数字的引用。 子图编号的顺序是从左上角开始的行，从数字1开始。例如，左上图是子图编号1，右上图是子图编号2，左下图是子图编号3， 右下图是4号子图。&lt;/p&gt;
&lt;p&gt;请注意，必须专门调用plt.subplot（2,2,1）来创建该子图。&lt;/p&gt;
&lt;p&gt;Q3：如果子图布局不是很精致，怎样来调整呢？&lt;/p&gt;
&lt;p&gt;如果子图排列过于紧凑。 我们可以通过调用plt.tight_layout（）来修复它。它清理子图之间的填充以获得更清晰的外观。&lt;/p&gt;
&lt;p&gt;调整前：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027233908673-451163408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;调整后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027233834825-1416968344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Q4：怎么样天加网格线？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
plt.grid(True)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 风格和属性&lt;/p&gt;
&lt;p&gt;Q5：怎样调整线的颜色\粗细\形状？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
plt.plot(x, y, color = ‘green’ , linewidth = 2, linestyle = “-”)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 常见的形状：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027234345637-105259218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q6：怎样更改标记（marker）的颜色和样式？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
plt.scatter(x, y, marker = ‘o’, color = ‘red’)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 常见的选择：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027234614065-1497314116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Q7：如何更改线条的透明度？&lt;/p&gt;
&lt;p&gt;将alpha参数传递给你的绘图。 Alpha可以设置为0到1，其中0表示完全透明，1表示不透明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
plt.plot(x, y, alpha = 0.1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 下图说明了透明度在0.9,0.5和0.1的alpha水平下的表现.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1345004/201810/1345004-20181027234827146-368740443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Oct 2018 15:58:00 +0000</pubDate>
<dc:creator>Jin_liang</dc:creator>
<og:description>hMatplotlib是最受欢迎的二维图形库，但有时我们很难做到得心应手的去使用。 如何更改图例上的标签名称？ 如何设置刻度线？ 如何将比例更改为对数？ 如何在我的情节中添加注释和箭头？ 如何在我的图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jin-liang/p/9863987.html</dc:identifier>
</item>
<item>
<title>螺旋折线的长度计算 - 一个铁匠</title>
<link>http://www.cnblogs.com/plas/p/9863982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plas/p/9863982.html</guid>
<description>&lt;p&gt;public class Demo3 {&lt;br/&gt;public static void main(String[] args) {&lt;br/&gt;Scanner s = new Scanner(System.in);&lt;br/&gt;String line = s.nextLine();&lt;br/&gt;//截取字符串，并转化成int类型&lt;br/&gt;int x = Integer.parseInt(line.split(&quot;,&quot;)[0]);&lt;br/&gt;int y=Integer.parseInt(line.split(&quot;,&quot;)[1]);&lt;br/&gt;//定义输出结果&lt;br/&gt;int dis=0;&lt;br/&gt;//判断x，y坐标的绝对值，如果y大则执行如下&lt;br/&gt;//以y轴为基准，可以算出每一个x为0的，螺旋线长度，为k*y*y+t*y=长度。&lt;br/&gt;//算出kt值，带入&lt;br/&gt;if (Math.abs(x)&amp;lt;=Math.abs(y)) {&lt;br/&gt;//如果y大于等于0的情况，是直接加上x即可，为负，时自动减去对应的值&lt;br/&gt;if (y&amp;gt;=0) {&lt;br/&gt;dis=4*y*y-y+x;&lt;br/&gt;}else{&lt;br/&gt;//同上，算出y为负时的一元二次方程&lt;br/&gt;dis=4*y*y-3*y-x;&lt;br/&gt;}&lt;br/&gt;}else{&lt;br/&gt;//如果x绝对值大，执行如下&lt;br/&gt;//如果x为正&lt;br/&gt;if (x&amp;gt;=0) {&lt;br/&gt;//同上，算出x的一元二次方程，直接减去y即可，获取的就是对应的螺旋线长度&lt;br/&gt;dis=4*x*x+x-y;&lt;br/&gt;}else{&lt;br/&gt;//为负时，同上算出一元二次方程，并加上对应的y轴坐标&lt;br/&gt;dis=4*y*y+3*x+y;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;//输出结果&lt;br/&gt;System.out.println(&quot;dis(&quot;+x+&quot;,&quot;+y+&quot;)=&quot;+dis);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;感觉主要考察的是数学算术。。。。。。。。。&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:56:00 +0000</pubDate>
<dc:creator>一个铁匠</dc:creator>
<og:description>public class Demo3 {public static void main(String[] args) { Scanner s = new Scanner(System.in); Str</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plas/p/9863982.html</dc:identifier>
</item>
<item>
<title>六边形架构设计 - whthomas</title>
<link>http://www.cnblogs.com/whthomas/p/9863943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whthomas/p/9863943.html</guid>
<description>&lt;p&gt;分层架构是运用最为广泛的架构模式，把一个软件系统进行分层，是我们目前做工程项目的一个共识，我们最初学习的分层架构就是经典的三层架构了。它自顶向下分成三层：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户界面层（User Interface Layer）&lt;/li&gt;
&lt;li&gt;业务逻辑层（Business Logic Layer）&lt;/li&gt;
&lt;li&gt;数据访问层（Data Access Layer）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201810/475531-20181027233900628-771809099.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统的单体应用中，因为业务不算复杂，这种分层并没有什么问题，把数据的渲染交给用户界面层，把核心业务逻辑放到业务逻辑层，然后将数据库的访问交给数据访问层。&lt;/p&gt;
&lt;p&gt;但是随着业务越来越复杂，问题也随之而来：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要依赖的基础设施也不仅仅只有数据库这样单一了&lt;/li&gt;
&lt;li&gt;很多参数的校验，我们开始纠结是放到用户界面层还是业务层。&lt;/li&gt;
&lt;li&gt;缓存是放到哪里去控制&lt;br/&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码开始变得复杂，很快只有上帝能看懂了，然后写代码往往就是牵一发而动全身。&lt;/p&gt;
&lt;p&gt;我们都知道在设计模式中有一个很重要的原则就是&lt;strong&gt;依赖倒置&lt;/strong&gt;，他包含了三层含义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高层模块不应该依赖低层模块，两者都应该依赖其抽象&lt;/li&gt;
&lt;li&gt;抽象不应该依赖细节&lt;/li&gt;
&lt;li&gt;细节应该依赖抽象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以设计模式中产生了一个模式——&lt;strong&gt;适配器模式&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在中间件软件爆发的今天，同一种功能的中间件可能会有非常多的选择。比如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MQ: RabbitMQ, Kafka, ActiveMQ, RocketMQ......&lt;/li&gt;
&lt;li&gt;SQL: MySQL, PostgreSQL......&lt;/li&gt;
&lt;li&gt;NoSQL: Redis,MongoDB, ElasticSearch......&lt;/li&gt;
&lt;li&gt;Job: Elastic-Job, XXL-JOB.....&lt;br/&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外还有各种供应商的需要有备用通道：短信，邮件，推送，业务供应商......&lt;/p&gt;
&lt;p&gt;如果我们在业务逻辑中去关注这些东西，毫无疑问，我们的业务逻辑就会很繁琐：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if ( config == 'A' ) {
    // statement 1
} else if ( config == 'B' ) {
    // statement 2
} else if ( config == 'C' ) {
    // statement 3
} else if ( config == 'D' ) {
    // statement 4
} else {
    // default statement
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别是业务中去选择供应商的时候，我们通常是要有好几个备用通道的，但是我们的业务逻辑本身只是关心：这件事做了没，而不是到底用哪种方式去做。&lt;/p&gt;
&lt;p&gt;所以六边形架构被提出了。六边形架构提倡用一种新的视角来看待整个系统，该架构中存在两个区域，分别是“外部区域”和“内部区域”。在外部区域中，不同的客户均可以提交输入；而内部的系统则用于获取持久化数据，并对程序输出进行存储（比如数据库），或者在中途将输出转发到另外的地方（比如消息）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/475531/201810/475531-20181027234104758-1025752101.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在设计系统的时候，往往过于关注数据库，Http接口等基础设施的设计，而忽略了我们需要关注的业务。在复杂系统中，最容易变化的也是业务形态，产品经常会要求改来改去，因为业务本身就在不断地演进，如果我们一开始就基于数据库作所有的设计，那么势必一旦遇上业务的修改，库表肯定也需要对应先进行变化。假如我们融入六边形架构，将数据库和暴露的Controller都视为是基础设施，先去关注业务的模型和代码，Class的修改比要数据库改起来要简单的多。另外一方面，也大大提高了程序的可测试性：在没有准备一堆基础设施(数据库，接口，异步通知等等)情况下，可以先测试逻辑的完整性。&lt;/p&gt;
&lt;p&gt;另外，有时候随着业务增长有的基础设施是会需要进行替换的，采用六边形架构之后，这种更换的成本就会降低。另外如果出现需要使用Web Service的客户，我们也不必纠结于之前的HTTP接口，直接开出一套新的协议代码供客户使用，而不会纠结领域部分代码有逻辑上的缺失。&lt;/p&gt;
&lt;p&gt;采用六边形架构之后，我们的领域模型也会更加独立，更精简，在适应新的需求时修改也会更容易。&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:41:00 +0000</pubDate>
<dc:creator>whthomas</dc:creator>
<og:description>分层架构是运用最为广泛的架构模式，把一个软件系统进行分层，是我们目前做工程项目的一个共识，我们最初学习的分层架构就是经典的三层架构了。它自顶向下分成三层： 用户界面层（User Interface L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whthomas/p/9863943.html</dc:identifier>
</item>
<item>
<title>毕业这五年 - 帅帅的鱼</title>
<link>http://www.cnblogs.com/appleyk/p/9863822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/appleyk/p/9863822.html</guid>
<description>&lt;p&gt;&lt;span&gt;       一晃高考快十年了，毕业已五年有余，不禁在这个点感慨起来 -- 人生啊，你慢点吧，生活啊，容我缓一缓可好？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       09年，人生第一次参加高考【差点就有第二次了】，考场做题那叫一个自信和潇洒啊；你还别说，博主我从小学到高中，虽说不是尖子中的尖子，好歹班级名次没有下过前十，至于年级里的排名，那就呵呵了好吧【其次没那么惨】；你问我哪来的自信？因为聪明啊！没错，我就这一点自信了；别人在学习的时候，我也在学，别人还在学习的时候，我不；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 整个高中，除了学习这第一爱好之外【内向的外表幽默的嘴脸】；&lt;/span&gt;&lt;span&gt;我的第二爱好就是篮球，不是打球、看球就是练球【容我多扯点，待会再扯回来，原谅我在记流水账】，一周唯一的两节体育课有时候可能还要被其他老师给占用，理由很简单，你们是学生，要以学习为重【啊呸】；只要有体育课，篮球必玩，那时候只玩半场，3V3的那种，不是我吹，那时候我打球还是很奈斯的，基本防不住，模板就是韦德【哈哈，我喜欢科比】，还特么能跳，虽说个子不高，但总喜欢打内线，和中锋抢板；因为喜欢跳，导致我经常崴脚，崴着崴着就习惯了，以至于现在我的两只脚脚脖处骨头都有点变形了，可怕；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　后来上了大学我就只看NBA很少打球，工作后，不打球了也很少看NBA了，回想一下，这就是成长吧，那时候单纯的少年，眼里只有耍帅，现在为了生活，必须努力工作；原来年轻，可以肆无忌惮，现在不行；以前是一个人怎么过都好，现在不行；以前不用担心没钱花，现在不行，这，就叫做成长吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　扯回来，说到09年高考，博主那叫一个自信啊，不说考个一本，至少二本应该是没问题的，但是查成绩的时候，那真叫一个打脸啊，三本？What？怎么办？我还记那是一个夏天的深夜，十一点多，我一个人揣着身份证跑去离家两公里的网吧，网吧叫什么名字，我忘了【哈哈，莫嫌我啰嗦】，打了一把CF，默默的等着零点的到来，等来的确是一句&quot;卧槽！&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缓了几天后，博主想复读了，家人没有表态，他们让我自己决定！再后来，又缓了几天，博主我反悔了，因为我的人生不能因为一次失败就否定了自己，况且复读对我来说，还是很抵触的，三本就三本吧！于是乎，抱着厚厚的一本大学院校的书就选了起来，因为分数的缘故，不敢乱来，只能考虑本省的三本院校，至于专业，那时候真的是年幼无知啊，根本不知道什么是计算机科学与技术，不知道.net方向是什么，那时候09年，我才有了自己的QQ，对开关机这么简单的操作都得反复练习的人，没错，那时候就是一电脑小白，但我却误打误撞，报了一个计算机专业，就像待出嫁的大姑娘一样，恨不得赶快把自己嫁出去；之说以说我年幼无知，是因为当初报的是软件开发.Net方向，要是那时候报的是Java专业，现在就不一样了，后话了，我们继续。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　录取很顺利，入学后，被分在了211寝室，而我们院校是挂在本省的一个出名的一本院校下的一个三本计算机学院，巧了，这个学校是211大学，更巧的是，校门口的公交站，就有211路的公交，以至于后来大学毕业，我对211这三个数字特别有好感，只要注册XXX账号，211成了我最喜欢的名称后缀；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　寝室加我九个人，每个人都很有个性，以至于毕业这么多年了，我都记忆犹新，不是我吹【哈哈，有没有想就此弃看的童鞋】，当时我们寝室可谓是年纪里的风云宿舍，我用最简单的语言形容下九个人包括我自己：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       头号人物，小胖【还记得你大学宿舍的那个小胖吗，甭管是男是女，是不是都有一个】：高中就接触计算机，大学四年在专业上他说第二，没人敢说第一，各科大作业上简直是我们系里的活雷锋，且为人单纯善良耿直，看不惯的就说出来，很有头脑很有主见很有想法的一个人，缺点就是，太执拗，不喜欢溜须拍马，有话藏不住，因为这，在系里&quot;官场仕途&quot;早早宣布over，但是，不妨碍我们全寝室人都爱他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       二号人物，昊哥，一本正经，一身正气，大义凛然...总之就是，看上去让人很敬畏，其实，内心很骚动，性格豪爽，寝室最高的，也是最豪爽的人之一，这个人简直就是一个bug，放着那么有前景的专业不学不学，偏偏大学四年却在自学法律，很有毅力很能吃苦，后来成了人民的律师，缺点就是，太有想法，以至于常常把自己给想进去，活得太认真却不够洒脱，但是，不妨碍我们寝室哥几个佩服他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       三号人物，宿色长，一张本分的脸下，却暗藏一颗不安的心，哈哈，人非常good，脾气好，人好，说话的态度好，总之就是除了他能当211寝室长以外，谁都胜任不了；寝室的秩序和脏活都离不开他，大学四年，色长无偿贡献了他的床，因为下铺方便的原因，寝室八个人轮着睡，以至于色长的床看起来总是最脏的，哈哈，缺点就是，喜欢玩游戏看小说，对专业技能不上心，让人很是操心，但是，不妨碍我们八个人都很尊重他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;/span&gt;&lt;span&gt;四号人物，fuck，说起这个名字的由来也是好笑，因为总喜欢说fuck，几乎成了大学四年的口头禅，干脆寝室人就给他起了一个这样的外号，为人特别干练精明，非常清楚自己想要什么，在年级和系里工作非常努力，经常回来的很晚，以至于差点和寝室脱钩了，缺点就是，为人太随性，不太顾忌身边亲近人的感受，有一套自己的为人处世手册，但是，不妨碍大家对他在工作上的高度认可！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   五号人物，小茗，这个人简直就是神一样的存在，空有聪明的脑袋，却不拿来干正事，单纯里掺和着可爱；喜欢吃泡面喝碳酸饮料；喜欢看动漫打游戏；喜欢熬夜和睡懒觉，总之你能想象到的正常人的生活他都不沾边；最佩服他的就是他认真起来，真的很认真，一个学期专业课几乎不学，但是考前的一周却可以补回来，以前熬夜是为了打游戏，考前一周熬夜居然是为了复习，缺点呢，嗯...想了半天，这是个bug，如果非要说一个的话，那就是太自我，活在自己的世界里像个长不大的孩子，但是，不妨碍我们喜欢和他一起玩！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   六号人物，红星，如红星二锅头一般，这个人很烈，个子不高却蕴藏着大能量，特别特别努力，在专业知识上，很有天赋很出众，学科上，成绩也是系列名列前茅，是我们寝室里唯一拿过奖学金的人，而且还是连拿的那种；喜欢泡自习室，人缘和口碑特好，缺点就是，情商太低，情商太低，情商太低！但是，不妨碍我们大家都很欣赏他，叫他小星星，一闪一闪亮晶晶！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      七号人物，小丕，寝室活得最洒脱的一个人，性格外向，真性情，寝室气氛的活跃和推动者，喜欢自由自在的生活，喜欢旅游，喜欢黑科技；名字的由来，是因为我们玩澄海3C的时候，小丕是他的ID，而且我们当时我们玩浩方，是他带的；点子特别多，很能说，但是很难捉摸透这个人的内心，缺点呢，就是缺心眼，不服就干，哈哈，但是，不妨碍大家都喜欢他，喜欢他身上的洒脱和那种放荡不羁的生活态度！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       八号人物，小迪，别看也带个&quot;小&quot;子，但在寝室也算是老大哥一个了；睡在博主下铺，一个有趣的男人，哈哈；生活上特别讲究，特别细心的一个人，会在我们吃饭的时候，提醒我们:&quot;这个菜不干净，刚才我吃了一个苍蝇出来，MD，恶心死我了&quot;【这样真的好吗，坏笑】，会在玩游戏的时候，提倡大家玩重口味的游戏，比如求生之路，但是却在玩的时候，叫的堪比杀猪声，还一个劲的说着：&quot;太特么吓人了.....&quot;【Oh No! 头疼】，会在生活中，充当知心大哥，教育和指导我们，但是人真的很单纯少年，缺点呢，就是开不起玩笑，认真的时候很认真，不认真的时候也很认真，哈哈，但是，不妨碍我们都很器重他！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       九号人物，本人也，寝室年龄最小的一个，我就不做简短的自我介绍了，我可是本篇博文的主角，关于我，各位有得看了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我的大学四年，很快活，无拘无束，没有思想包袱也没有就业压力【当时房价还没有疯涨，工作遍地都是】，完全活出了自己理想中的样子，吃喝玩乐样样不少【练就一个手好的操作，澄海3C溜的一B&lt;/span&gt;&lt;span&gt;】，逃课挂科什么的，也都亲自试验过，总之就是，颓废！没错，就是这两个字，当时放着那么好的专业门槛不好好学习，却要虚度整个大学四年，虽然博主那时候专业技能很优秀【我有这方面的天赋】，但却没有充分利用好时间和自身聪明的特性去专研学科，以至于毕业后，在专业知识上吃了不少亏，费了老大劲；正所谓你有一把好枪，你却不懂得如何保养它，时间久了，它也就一副锈铁的皮囊，你指望它的时候，它却哑火了；有时候，道理我们都懂，只是，晚熟的人不知道在什么年纪该干什么事，也好，至少博主现在明白过来了，不晚，不晚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　写到这个点了，一看时间，快十二点了，有点累了，标题是毕业后的这五年，我居然用了大半篇幅去讲述我的大学，我是想到什么就写什么，我这个人比较感性，喜欢写东西，上学的时候喜欢在QQ空间里写，后来毕业当了两年兵，喜欢把文字写在心里，再后来，部队复员回来工作后，又喜欢把文字写在博客上，时间是好东西啊，教会了我重新审视自己，今天就到这吧，后面的看心情，我再补上，讲讲博主的部队生活和工作上的心得，下一篇见...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434157/201810/1434157-20181027233032072-1307985239.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:31:00 +0000</pubDate>
<dc:creator>帅帅的鱼</dc:creator>
<og:description>一晃高考快十年了，毕业已五年有余，不禁在这个点感慨起来 -- 人生啊，你慢点吧，生活啊，容我缓一缓可好？ 09年，人生第一次参加高考【差点就有第二次了】，考场做题那叫一个自信和潇洒啊；你还别说，博主我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/appleyk/p/9863822.html</dc:identifier>
</item>
<item>
<title>Go基础系列：数据类型转换(strconv包) - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9863915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9863915.html</guid>
<description>&lt;p&gt;Go不会对数据进行隐式的类型转换，只能手动去执行转换操作。&lt;/p&gt;
&lt;h2 id=&quot;简单的转换操作&quot;&gt;简单的转换操作&lt;/h2&gt;
&lt;p&gt;转换数据类型的方式很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;valueOfTypeB = typeB(valueOfTypeA)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 浮点数
a := 5.0

// 转换为int类型
b := int(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go允许在底层结构相同的两个类型之间互转。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// IT类型的底层是int类型
type IT int

// a的类型为IT，底层是int
var a IT = 5

// 将a(IT)转换为int，b现在是int类型
b := int(5)

// 将b(int)转换为IT，c现在是IT类型
c := IT(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不是所有数据类型都能转换的，例如字母格式的string类型&quot;abcd&quot;转换为int肯定会失败&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;低精度转换为高精度时是安全的，高精度的值转换为低精度时会丢失精度。例如int32转换为int16，float32转换为int&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这种简单的转换方式不能对int(float)和string进行互转，要跨大类型转换，可以使用&lt;code&gt;strconv&lt;/code&gt;包提供的函数&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;strconv&quot;&gt;strconv&lt;/h2&gt;
&lt;p&gt;strconv包提供了简单数据类型之间的类型转换功能。可以将简单类型转换为字符串，也可以将字符串转换为其它简单类型。&lt;/p&gt;
&lt;p&gt;这个包里提供了很多函数，大概分为几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串转int：Atoi()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;int转字符串: Itoa()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;ParseTP类函数将string转换为TP类型：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。因为string转其它类型可能会失败，所以这些函数都有第二个返回值表示是否转换成功&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;其它类型转string类型：FormatBool()、FormatFloat()、FormatInt()、FormatUint()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;AppendTP类函数用于将TP转换成字符串后append到一个slice中：AppendBool()、AppendFloat()、AppendInt()、AppendUint()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有其他一些基本用不上的函数，见官方手册：&lt;code&gt;go doc strconv&lt;/code&gt;或者https://golang.org/pkg/strconv/。&lt;/p&gt;
&lt;p&gt;当有些类型无法转换时，将报错，返回的错误是strconv包中自行定义的error类型。有两种错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ErrRange = errors.New(&quot;value out of range&quot;)
var ErrSyntax = errors.New(&quot;invalid syntax&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，使用Atoi(&quot;a&quot;)将&quot;a&quot;转换为int类型，自然是不成功的。如果print输出err信息，将显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;strconv.Atoi: parsing &quot;a&quot;: invalid syntax&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;string和int的转换&quot;&gt;string和int的转换&lt;/h3&gt;
&lt;p&gt;最常见的是字符串和int之间的转换：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.int转换为字符串：Itoa()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Itoa(): int -&amp;gt; string
println(&quot;a&quot; + strconv.Itoa(32))  // a32&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.string转换为int：Atoi()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Atoi(s string) (int, error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于string可能无法转换为int，所以这个函数有两个返回值：第一个返回值是转换成int的值，第二个返回值判断是否转换成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Atoi(): string -&amp;gt; int
i,_ := strconv.Atoi(&quot;3&quot;)
println(3 + i)   // 6

// Atoi()转换失败
i,err := strconv.Atoi(&quot;a&quot;)
if err != nil {
    println(&quot;converted failed&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;parse类函数&quot;&gt;Parse类函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Parse类函数用于转换字符串为给定类型的值&lt;/strong&gt;：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。&lt;/p&gt;
&lt;p&gt;由于字符串转换为其它类型可能会失败，所以这些函数都有两个返回值，第一个返回值保存转换后的值，第二个返回值判断是否转换成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b, err := strconv.ParseBool(&quot;true&quot;)
f, err := strconv.ParseFloat(&quot;3.1415&quot;, 64)
i, err := strconv.ParseInt(&quot;-42&quot;, 10, 64)
u, err := strconv.ParseUint(&quot;42&quot;, 10, 64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ParseFloat()只能接收float64类型的浮点数。&lt;/p&gt;
&lt;p&gt;ParseInt()和ParseUint()有3个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseUint(s string, base int, bitSize int) (uint64, error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bitSize&lt;/code&gt;参数表示转换为什么位的int/uint，有效值为0、8、16、32、64。当bitSize=0的时候，表示转换为int或uint类型。例如bitSize=8表示转换后的值的类型为int8或uint8。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;base&lt;/code&gt;参数表示以什么进制的方式去解析给定的字符串，有效值为0、2-36。当base=0的时候，表示根据string的前缀来判断以什么进制去解析：&lt;code&gt;0x&lt;/code&gt;开头的以16进制的方式去解析，&lt;code&gt;0&lt;/code&gt;开头的以8进制方式去解析，其它的以10进制方式解析。&lt;/p&gt;
&lt;p&gt;以10进制方式解析&quot;-42&quot;，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;-42&quot;, 10, 64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以5进制方式解析&quot;23&quot;，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;23&quot;, 5, 64)
println(i)    // 13&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为5进制的时候，23表示进位了2次，再加3，所以对应的十进制数为&lt;code&gt;5*2+3=13&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以16进制解析23，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;23&quot;, 16, 64)
println(i)    // 35&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为16进制的时候，23表示进位了2次，再加3，所以对应的十进制数为&lt;code&gt;16*2+3=35&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以15进制解析23，保存为int64类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i, _ := strconv.ParseInt(&quot;23&quot;, 15, 64)
println(i)    // 33&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为15进制的时候，23表示进位了2次，再加3，所以对应的十进制数为&lt;code&gt;15*2+3=33&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;format类函数&quot;&gt;Format类函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;将给定类型格式化为string类型&lt;/strong&gt;：FormatBool()、FormatFloat()、FormatInt()、FormatUint()。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s := strconv.FormatBool(true)
s := strconv.FormatFloat(3.1415, 'E', -1, 64)
s := strconv.FormatInt(-42, 16)
s := strconv.FormatUint(42, 16)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FormatInt()和FormatUint()有两个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func FormatInt(i int64, base int) string
func FormatUint(i uint64, base int) string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个参数base指定将第一个参数转换为多少进制，有效值为&lt;code&gt;2&amp;lt;=base&amp;lt;=36&lt;/code&gt;。当指定的进制位大于10的时候，超出10的数值以a-z字母表示。例如16进制时，10-15的数字分别使用a-f表示，17进制时，10-16的数值分别使用a-g表示。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;FormatInt(-42, 16)&lt;/code&gt;表示将-42转换为16进制数，转换的结果为-2a。&lt;/p&gt;
&lt;p&gt;FormatFloat()参数众多：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func FormatFloat(f float64, fmt byte, prec, bitSize int) string&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bitSize参数表示转换为多少位(32或64)的浮点数对应的字符串。&lt;/p&gt;
&lt;h3 id=&quot;append类函数&quot;&gt;Append类函数&lt;/h3&gt;
&lt;p&gt;AppendTP类函数用于将TP转换成字符串后append到一个slice中：AppendBool()、AppendFloat()、AppendInt()、AppendUint()。&lt;/p&gt;
&lt;p&gt;Append类的函数和Format类的函数工作方式类似，只不过是将转换后的结果追加到一个slice中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
)

func main() {
    // 声明一个slice
    b10 := []byte(&quot;int (base 10):&quot;)
    
    // 将转换为10进制的string，追加到slice中
    b10 = strconv.AppendInt(b10, -42, 10)
    fmt.Println(string(b10))

    b16 := []byte(&quot;int (base 16):&quot;)
    b16 = strconv.AppendInt(b16, -42, 16)
    fmt.Println(string(b16))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int (base 10):-42
int (base 16):-2a&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 27 Oct 2018 15:31:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>Go不会对数据进行隐式的类型转换，只能手动去执行转换操作。 简单的转换操作 转换数据类型的方式很简单。 例如： Go允许在底层结构相同的两个类型之间互转。例如： 但注意： 1. 不是所有数据类型都能转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9863915.html</dc:identifier>
</item>
<item>
<title>运维小哥的工作自述 - 卡子火</title>
<link>http://www.cnblogs.com/kazihuo/p/9863894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kazihuo/p/9863894.html</guid>
<description>&lt;p&gt;　　光阴似箭，日月如梭！弹指间，回首想想，进公司的时间也不短了。在平凡的岗位上默默地耕耘着，似乎是那么不起眼~~但作为一颗螺丝钉，我要大声的告诉自己：螺丝钉也能有自己的价值体现！&lt;/p&gt;
&lt;p&gt;       于是乎，三省吾身！&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098305/201810/1098305-20181027231957094-1296597791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       几千号员工的上市企业，以总部和分部为个体划分，在个体中又以部门为单位划分，各部门的管理、财政、人事都实现独立。总而言之，一个独立的部门就像只小麻雀，五脏俱全！从新人入职的身份到看着新人入职，从环境的陌生到熟悉，从同事的初识到相处，一切的一切，似乎都是那么顺理成章的进行着~~&lt;/p&gt;
&lt;p&gt;      现在总结来看，上份工作算是系统运维，上至集群的升级和扩容，下至机房的上架与拉线，还得拉个箱子满世界的跑~~而目前的运维类型能也就给归个应用运维的类吧，部门做的是医疗健康的app，在进公司之前总想着偌大个企业，在运维体制、系统架构、服务优化、技术规范、监控手段等方面应该高大上，肯定很多地方能大开眼界，但是事实却是并不是想象中的那么高B格，啊哦~&lt;/p&gt;
&lt;p&gt;       公司的应用运维流程是开发在本地将代码调试好推送到Gitlab，通过Jenkins构建，实现将代码打成war包，提取包的md5值并传输到备份服务器，同时将包部署到Tomcat，上线后由测试进行功能验证。系统架构体系则是Nginx+Tomcat ！&lt;/p&gt;
&lt;p&gt;       因是传统的war包方式持续集成，故Jenkins中并未用到太多插件，打包、备份、部署等都是通过在Jenkins中添加的相关Shell命令进行操作。于是乎，当在Jenkins中新建Project时，通过原有的模板进行Copy后，还需多次手动的修改那些频繁出现在Shell命令中的参数（打包的包名、备份服务器地址、部署服务器地址等）。为了删繁就简，于是乎，我将内容集成在脚本中，通过运行脚本并传参的方式实现一次传参达到多次Shell内容参数的调用，Oye！&lt;/p&gt;
&lt;p&gt;       然后说说Gitlab，公司的一些数据资料、项目代码等都存在Gitlab中，而Gitlab权限掌管在运维手中，部门需要新开项目，在Gitlab上建立相应的代码Project都得是运维操办，原有的流程是确定新开项目，运维在Gitlab建立相应Project，然后通过SourceTree工具对新建的Project进行git初始化和指定分支的创建。于是乎，每次新开项目，Gitlab新建完Project后，都得别扭的在Windows中用SourceTree工具，总感觉怪怪的。为了删繁就简，于是乎，我将相关操作集成进脚本，并建立Jenkins执行操作，抛弃了Windows工具的同时实现了相应功能，麻麻再也不担心我不会用工具了，Oye！&lt;/p&gt;
&lt;p&gt;       随着工作的循序渐进，有天开发突然抱着电脑来找我了，说线上Bug紧急修复，要提取线上的代码为基底进行改动，所以问我要线上的代码。然后我就在想：“讲道理，运维负责项目上线，顶多也就支配下项目的版本回滚，代码是开发的命脉，确定线上代码的版本都还要找运维？开发难道不会对代码打好相应的版本标签么？”诶呀！脑壳疼，最终讨论出的结果就是：一个项目可能对应多个开发，项目上线运维一定在，而开发不一定在，开发的水平参差不齐，标签不知道打，或者没法统一等等~~好吧好吧！最后我还是选择在项目上线前通过脚本对其进行版本标记，实时确定线上代码版本，Oye！&lt;/p&gt;
&lt;p&gt;       运维字面上理解为运营、维护；而更深层次的是扮演着管理、制度、推行和监督角色，处理着自动化、网站架构优化、监控预警、流量及日志分析统计、权限管理、安全优化等事务，负责维护整体项目架构体系的稳定运行；同时让自动化的持续集成体系更具有制度化、规范化、流程化~~&lt;/p&gt;
&lt;p&gt;       然而我渐渐的发现了，此刻我不是个单纯的应用型运维，这简直就是啥活都干的功能型运维吖！好吧，既来之，则安之！干着干着，事儿慢慢就多了，譬如：Hi，Gitlab给开个账号；Hi，Gitlab给开个权限；Hi，项目接口502了；Hi，Web页面404了；Hi，项目加个代理；Hi，项目日志哪里看；Hi，这个项目上个预发；Hi，新建个项目环境；Hi，项目上个线~~等等，然后同事的内部访问地址异常了找你给配个DNS；SourceTree拉代码异常了找你给解决下；新同事入职了装些软件给支持一波~~~然后我自我安慰的告诉自己：这是一个认识小哥哥、小姐姐的机会，嗯，不错！&lt;/p&gt;
&lt;p&gt;       话说，不想当将军的士兵不是好士兵，Nice！于是乎，虽然我是一颗螺丝钉，却有着一个顶梁柱的梦~~所以，带着严谨性和责任心默默地耕耘在平凡的岗位上，尽自己的能力去规范化、流程化整个持续集成的运维体系及运作方式，尽自己的努力去将运维流程的自动化做到最大化。当然，这不仅是岗位价值的体现，更重要的是提高工作效率和工作质量，方便了大家的同时也提升了自我！&lt;/p&gt;
&lt;p&gt;       哦，对了，聊正事了。部门做的是app项目，绝大多数项目都是以war包的形式部署到Tomcat中，而当大量新项目的产生，涉及到服务部署、项目迁移等，最让人头疼的问题就是环境的一致性问题。为了删繁就简，于是乎，在老大的默许下，用上了Docker（测试环境）。通过Jenkins+Harbor+Tomcat+Docker+Nginx等服务衔接，配合自己写的Docker容器项目部署脚本，基本实现了个小小的自动化，在实现功能的同时简化了大量环境一致性的操作。因项目需多次更新代码重启服务进行调试，故容器的删除与启动较为频繁，脚本的大致思路是跑a项目容器前，先判断其是否已经在运行，若是，则彻底删除容器并更新代码重新启动，若项目容器是第一次启动，则随机生成映射端口，启动后将服务映射的端口记录到指定文件，当同一个项目需更新代码重新启动容器时，将到记录文件中调用记录的映射端口作为重新启动容器时的映射信息，即保证了容器重新生成的映射端口与第一次的生成信息的一致性！当然，目前只是单纯的用docker，后续估计要慢慢的用上编排工具Kubernetes~~~&lt;/p&gt;
&lt;p&gt;       诶呀！扯了辣么多，不知道读者有没有看晕，反正我差点给自己写晕了~~&lt;/p&gt;
&lt;p&gt;       目前个人工作的运维状况及运维体系大致就是这些了，不知道是不是也有和我感同身受的同僚，希望看了博文的技术小哥小姐们给个鼓励，同时，更希望的是有技术大佬能给一些建议和指教，站在现有的运维基底，怎么让运维体系更具自动化？更有B格范儿？傲娇的小眼神期望着你呢！哼哼哼~~&lt;/p&gt;
&lt;p&gt;       最后来一句：打酱油，我是认真滴！&lt;/p&gt;
&lt;p&gt;       Thank you ！&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:21:00 +0000</pubDate>
<dc:creator>卡子火</dc:creator>
<og:description>光阴似箭，日月如梭！弹指间，回首想想，进公司的时间也不短了。在平凡的岗位上默默地耕耘着，似乎是那么不起眼~~但作为一颗螺丝钉，我要大声的告诉自己：螺丝钉也能有自己的价值体现！ 于是乎，三省吾身！ 几千</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kazihuo/p/9863894.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 开发并部署到Ubuntu - Hubert_Biyo</title>
<link>http://www.cnblogs.com/HubertBiyo/p/9863506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HubertBiyo/p/9863506.html</guid>
<description>


&lt;p&gt;涉及：Asp.Net Core Webapi    Ubuntu服务器   Nginx代理&lt;/p&gt;

&lt;h3&gt;Asp.Net Core WebApi 开发&lt;/h3&gt;
&lt;p&gt;创建Asp.Net Core WebApi程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027161729165-1677895855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 创建一个简单的测试案例就可以了，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Hubert.Api.Demo.Controllers
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController : BaseController
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: api/Demo&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: api/Demo/5&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST: api/Demo&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Post([FromBody] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PUT: api/Demo/5&lt;/span&gt;
        [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Put(&lt;span&gt;int&lt;/span&gt; id, [FromBody] &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE: api/ApiWithActions/5&lt;/span&gt;
        [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;BaseController  代码  这里可以写一些公共的方法参数等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Hubert.Api.Demo.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseController : ControllerBase
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发布Asp.Net Core WebApi程序&lt;/p&gt;
&lt;p&gt;可以先测试一下  部署到IIS需要安装 AspNetCoreModule  并且应用池设置无托管即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027163619608-153293279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;部署Asp.Net Core WebApi 到Ubuntu服务器&lt;/h3&gt;

&lt;p&gt;首先安装Asp.Net Core SDK  &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &amp;gt; microsoft.gpg&lt;/span&gt;
sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/&lt;span&gt;microsoft.gpg
sudo sh &lt;/span&gt;-c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo &quot;deb [arch=amd64] https://packages.microsoft.com/repos/microsoft-ubuntu-bionic-prod bionic main&quot; &amp;gt; /etc/apt/sources.list.d/dotnetdev.list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; install apt-transport-&lt;span&gt;https
sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt;&lt;span&gt; update
sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; install dotnet-sdk-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看DotNet版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dotnet --version
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上传发布文件到Ubuntu&lt;/p&gt;
&lt;p&gt;创建文件夹命令  mkdir     上传文件 rz     &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027164559910-1270887411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027164658098-240185368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传成功之后  运行该程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027165227382-1197085102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过Http://Ip地址：5005  测试访问&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027165347018-1305177968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;安装Nginx并对其做相应配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;安装Nginx

sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt;&lt;span&gt; install nginx


查看Nginx版本

nginx &lt;/span&gt;-&lt;span&gt;v

启动nginx 或者重启nginx

service nginx start

service nginx restart

如果端口号被占用则会提示
nginx: [emerg] &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; directive &lt;span&gt;is&lt;/span&gt; not allowed here &lt;span&gt;in&lt;/span&gt; /etc/nginx/sites-enabled/&lt;span&gt;default&lt;/span&gt;:&lt;span&gt;21&lt;/span&gt;&lt;span&gt;
nginx: configuration file &lt;/span&gt;/etc/nginx/&lt;span&gt;nginx.conf test failed

这个时候你需要 查看端口是否被占用
netstat &lt;/span&gt;-&lt;span&gt;ntpl

杀死这个进程 
kill  关于80端口的进程
然后在启动nginx就可以啦&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建一个关于dotnetcore webapi的配置文件；我这里已经创建好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027170909381-1500081076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 输入命令vi  编辑这个配置文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027171043213-1952552003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还需要在nginx配置文件中引入Hosts文件夹的配置&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027171351657-1724746764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在http里配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
include /etc/nginx/hosts&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027171526200-183234316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后重启nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service nginx restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过域名访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179816/201810/1179816-20181027231040156-331278972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>Hubert_Biyo</dc:creator>
<og:description>涉及：Asp.Net Core Webapi Ubuntu服务器 Nginx代理 Asp.Net Core WebApi 开发 创建Asp.Net Core WebApi程序 创建一个简单的测试案例就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HubertBiyo/p/9863506.html</dc:identifier>
</item>
<item>
<title>学好数据结构和算法 —— 复杂度分析 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9863168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9863168.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;复杂度也称为渐进复杂度&lt;span&gt;，包括渐进时间复杂度和渐进空间复杂度&lt;span&gt;，描述算法随数据规模变化而逐渐变化的趋势&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;复杂度分析是评估算法好坏的基础理论方法，所以掌握好复杂度分析方法是很有必要的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;时间复杂度&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先，学习数据结构是为了解决“快”和“省”的问题，那么如何去评估算法的速度快和省空间呢？这就需要掌握时间和空间复杂度分析。同一段代码运行在不同环境、不同配置机器、处理不同量级数据…效率肯定不会相同。时间复杂度和空间复杂度是不运行代码，从理论上粗略估计算法执行效率的方法。时间复杂度&lt;span&gt;一般用O来表示，如下例子：计算1,2,3…n的和。CPU执行每行代码时间很快，假设每行执行时间都一样&lt;span&gt;为&lt;span&gt;unit_time，第2行为一个&lt;span&gt;unit_time，第3、4行都执行了n遍，那么下面这段代码执行的耗时时间可以这么计算：(1+2*n) * unit_time。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     &lt;span&gt;public &lt;span&gt;int sum(&lt;span&gt;int&lt;span&gt; n) {
&lt;span&gt;2         &lt;span&gt;int sum = 0&lt;span&gt;;
&lt;span&gt;3         &lt;span&gt;for (&lt;span&gt;int i = 1; i &amp;lt;= n; i++&lt;span&gt;) {
&lt;span&gt;4             sum = sum +&lt;span&gt; i;
&lt;span&gt;5 &lt;span&gt;        }
&lt;span&gt;6         &lt;span&gt;return&lt;span&gt; sum;
&lt;span&gt;7     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似的再看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1     &lt;span&gt;public &lt;span&gt;int sum(&lt;span&gt;int&lt;span&gt; n) {
&lt;span&gt; 2         &lt;span&gt;int sum = 0&lt;span&gt;;
&lt;span&gt; 3         &lt;span&gt;int i = 1&lt;span&gt;;
&lt;span&gt; 4         &lt;span&gt;int&lt;span&gt; j;
&lt;span&gt; 5         &lt;span&gt;for (; i &amp;lt;= n; i++&lt;span&gt;) {
&lt;span&gt; 6             j = 1&lt;span&gt;;
&lt;span&gt; 7             &lt;span&gt;for (; j &amp;lt;= n; j++&lt;span&gt;) {
&lt;span&gt; 8                 sum = sum + i *&lt;span&gt; j;
&lt;span&gt; 9 &lt;span&gt;            }
&lt;span&gt;10 &lt;span&gt;        }
&lt;span&gt;11         &lt;span&gt;return&lt;span&gt; sum;
&lt;span&gt;12     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第2、3、4行分别执行执行了一次，时间为3unit_time，第5、6两行循环了n次为2n * unit_time，第7、8两行执行了n*n次为(n²) * unit_time，所以总的执行时间为：(2n²+2n+3) * unit_time&lt;/p&gt;
&lt;p&gt;可以看出来，所有代码执行时间T(n)与每行代码执行次数成正比。可以用如下公式来表示：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;T(n) = O(f(n))&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;T(n)表示代码的执行时间；&lt;/p&gt;
&lt;p&gt;n表示数据规模大小；&lt;/p&gt;
&lt;p&gt;f(n)表示每行代码执行的次数和，是一个表达式；&lt;/p&gt;
&lt;p&gt;O表示执行时间T(n)和f(n)表达式成正比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么上面两个时间复杂度可以表示为：&lt;/p&gt;
&lt;p&gt;T(n) = O&lt;span&gt;(1+2*n) 和 T(n) = O(2n²+2n+3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实际上O并不表示具体的执行时间，只是表示代码执行时间随数据规模变化的趋势，所以时间复杂度实际上是渐进时间复杂度的简称。当n很大时，系数对结果的影响很小可以忽略，上面两个例子的时间复杂度可以粗略简化为：&lt;/p&gt;
&lt;p&gt;T(n) = O&lt;span&gt;(n) 和 T(n) = O(n²)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为时间复杂度是表示的一种趋势，所以常常忽略常量、低阶、系数，只需要最大阶量级就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;分析时间复杂度的几个常见法则&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;1、只关注代码执行最多的一段代码&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;上面例子可以看出，复杂度忽略了低阶、常量和系数，所以执行最多的那一段最能表达时间复杂度的趋势。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2、加法法则：总复杂度等于各部分求和，然后取复杂度量级最高的&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;还是上面的例子，总的时间复杂度等于各部分代码时间复杂度的和，求和之后再用最能表达趋势的项来表示整段代码的时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;3、乘法法则：嵌套代码复杂度等于嵌套内外代码复杂度的乘积&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;上面第二段代码，j 循环段嵌套在 i 循环内部，所以 j 循环体内的时间复杂度等于单独 i 的时间复杂度乘以单独 j 的时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;常见的时间复杂度表示&lt;/h3&gt;
&lt;p&gt;常见的复杂度有以下几种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;常量阶：O(1)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对数阶：O(logn)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线性阶：O(n)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;线性对数阶：O(nlogn)&lt;/li&gt;
&lt;li&gt;平方阶：O(n²)、立方阶O(n³)……&lt;/li&gt;
&lt;li&gt;指数阶：O(2ⁿ)&lt;/li&gt;
&lt;li&gt;阶乘阶：O(n!)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以这么来理解：如果一段代码有1000或10000行甚至更多，行数是一个常量，不会随着数据规模增大而变化，我们就认为时间复杂度为一个常量，用O(1)表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这几种复杂度效率曲线比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181027205420068-1393583158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟一个数组动态扩容例子，如果数组长度够，直接往里面插入一条数据；反之，将数组扩充一倍，然后往里面插入一条数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[10&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; arr.length;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; item) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;=&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] new_arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[len * 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 new_arr[i] =&lt;span&gt; arr[i];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             arr =&lt;span&gt; new_arr;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             len =&lt;span&gt; arr.length;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         arr[i] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;最好时间复杂度（best case time complexity）&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;最好情况下某个算法的时间复杂度。最好情况下，数组空间足够，只需要执行插入数据就可以了，此时时间复杂度是O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;最坏时间复杂度(worst case time complexity)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;最坏情况下某个算法的时间复杂度。最坏情况下数组满了，需要先申请一个空间为原来两倍的数组，然后将数据拷贝进去，此时时间复杂度为O(n)。一般情况下我们说算法复杂度就是指的最坏情况时间复杂度，因为算法时间复杂度不会比最坏情况复杂度更差了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;平均时间复杂度(average case time complexity)&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;最好时间复杂度和最坏时间复杂度都是极端情况下的时间复杂度，发生的概率并不算很大。平均时间复杂度是描述各种情况下平均的时间复杂度。上面的动态扩容例子将1到n+1次为一组来分析，前面n次的时间复杂度都是1，第n+1次时间复杂度是n，将一个数插入数组里的1 至 (n+1)个位置概率都为1/(n+1)，所以平均时间复杂度为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　O(n) = (1 + 1 + 1 + …+n)/(n+1) = O(1)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;均摊时间复杂度(amortized time complexity)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连续的关系。并且和这组数据类型的情况循环往复出现，这时候可以将这一组数据作为一个整体来分析，看看是否可以将最后一个耗时的操作复杂度均摊到其他的操作上，如果可以，那么这种分析方法就是均摊时间复杂度分析法。上面的例子来讲，第n+1次插入数据时候，数组刚好发生扩容，时间复杂度为O(n)，前面n次刚好将数组填满，每次时间复杂度都为O(1)，此时可以将第n+1次均摊到前面的n次上去，所以总的均摊时间复杂度还是O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;空间复杂度&lt;/h2&gt;
&lt;p&gt; 类比时间复杂度，&lt;span&gt;如下代码所示，第2行申请了一个长度为n的数据，第三行申请一个变量i为常量可以忽略，所以空间复杂度为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (; i &amp;lt; n; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             arr[i] = i + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为O(1)。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:04:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>复杂度也称为渐进复杂度，包括渐进时间复杂度和渐进空间复杂度，描述算法随数据规模变化而逐渐变化的趋势。复杂度分析是评估算法好坏的基础理论方法，所以掌握好复杂度分析方法是很有必要的。 时间复杂度 首先，学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9863168.html</dc:identifier>
</item>
<item>
<title>RNN入门（三）利用LSTM生成旅游点评 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/9863848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/9863848.html</guid>
<description>&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;  前几天，某个公众号发文质疑马蜂窝网站，认为它搬运其它网站的旅游点评，对此，马蜂窝网站迅速地做出了回应。相信大多数关注时事的群众已经了解了整个事情的经过，在这里，我们且不论这件事的是是非非，也不关心它是否是通过爬虫等其他技术手段实现的。本文将会展示一种自动生成旅游点评的技术手段。我们用到的模型为LSTM模型。&lt;br/&gt;  LSTM模型是深度学习中一种重要的模型，全称为Long Short-Term Memory，中文译为长短期记忆网络，是RNN家族中的重要成员，它模拟了人的大脑，具有一定的记忆功能，适合于处理和预测时间序列中间隔和延迟相对较长的重要事件，在翻译语言、控制机器人、图像分析、文档摘要、语音识别图像识别、手写识别、控制聊天机器人、预测疾病、点击率和股票、合成音乐等方面有较多应用。&lt;br/&gt;  在本文中，你将会看到LSTM在自动生成文字（在这里就是旅游点评）方面的应用，如果你感到好奇的话，请继续阅读~&lt;/p&gt;
&lt;h3 id=&quot;获取数据集&quot;&gt;获取数据集&lt;/h3&gt;
&lt;p&gt;  第一步，就是获取数据集，我们利用Python爬虫来实现。我们需要爬取的旅游评论来自于携程网站上的旅游评论，在本文中，我们以杭州西湖景点的旅游评论为例，页面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-beb7f43ad573cacd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;携程网站上关于杭州西湖的评论&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们爬取这些评论中的第1至10页，采用concurrent.futures模块实现并发爬取。完整的Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
import pandas as pd
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor, wait, ALL_COMPLETED

# 评论列表
comments = []

# 提取评论，传入参数为网址url
def get_comment(url):

    global comments

    try:
        # 发送HTTP请求
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 \
                             (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36'}
        r = requests.get(url=url, headers=headers)

        # 解析网页，定位到评论部分
        soup = BeautifulSoup(r.text, 'lxml')
        main_content = soup.find_all('div', class_='comment_single')

        # 提取评论
        for para in main_content:
            comment = para.find('span', class_='heightbox')
            #print(comment.text)
            comments.append(comment.text.replace('&amp;amp;quot', ''))

    except Exception as err:
        print(err)

def main():
    # 请求网址
    urls = [&quot;http://you.ctrip.com/sight/hangzhou14/49894-dianping-p%d.html&quot;%x for x in range(1,11)]
    urls[0] = urls[0].replace('-p1', '')

    # 利用多线程爬取景点评论
    executor = ThreadPoolExecutor(max_workers=10)  # 可以自己调整max_workers,即线程的个数
    # submit()的参数： 第一个为函数， 之后为该函数的传入参数，允许有多个
    future_tasks = [executor.submit(get_comment, url) for url in urls]
    # 等待所有的线程完成，才进入后续的执行
    wait(future_tasks, return_when=ALL_COMPLETED)

    # 创建DataFrame并保存到csv文件
    comments_table = pd.DataFrame({'id': range(1, len(comments)+1),
                                   'comments': comments})
    print(comments_table)

    comments_table.to_csv(r&quot;E://LSTM/hangzhou.csv&quot;, index=False)

main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行完该代码，就会得到hangzhou.csv文件，在这个文件中，我们需要把旅游评论中的文字做一些修改，比如去掉特殊字符，添加掉电，去掉换行，修改个别错别字等。修改完后的csv文件（部分）如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-e3e533e9af41b0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;西湖经典评论csv文件（部分）&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到该csv文件后，我们需要将这些评论（只包含评论）转移到txt文件，以便后续的操作，利用下面的Python&lt;br/&gt;代码即可完成：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pandas as pd

# 读取csv文件
df = pd.read_csv('E://LSTM/hangzhou.csv')['comments']
# 将pandas中的评论修改后，写入txt文件
for item in df:
    comments = item.replace('\n','').replace('&amp;amp;quot','') \
        .replace(r' ', '').replace(r'#', '').replace(r'&amp;amp;','') \
        .replace(r'＜', '《').replace(r'＞', '》') \
        .replace(r'↑', '').replace(r'[', '').replace(r']', '') \
        .replace(r'❤', '')
    with open('E://LSTM/comments.txt', 'a', encoding='utf-8') as f:
        f.write(comments)
        f.write('\n')
    #print(comments)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;txt文件部分如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-4dcedaa0a2e396f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;西湖经典评论txt文件（部分)&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该txt文件一共含有41412个文字。我们将会以这些评论为数据集，在此基础上利用Keras建立LSTM模型，训练完模型后，能自动生成其他的旅游点评。&lt;/p&gt;
&lt;h3 id=&quot;lstm模型&quot;&gt;LSTM模型&lt;/h3&gt;
&lt;p&gt;  Keras是一个高级的神经网络API，利用它能够轻松地搭建一些复杂的神经网络模型，是一个不错的深度学习框架。对于刚才得到的旅游点评，为了能够生成其他的旅游点评（人类可读），我们将会用到LSTM模型，之所以使用这个模型，是因为LSTM具有长短时记忆功能，能够很好地处理文本中的文字之间的联系，而不是将文字看成是独立的个体。&lt;br/&gt;  在搭建LSTM模型之前，我们需要做一些准备工作。首先我们需要将每个文字对应到一个数字，该模型的输入特征向量为前10个文字对应的数字组成的向量，目标变量为该10个文字的下一个文字对应的数字。该txt文件中一共有1949个文字（包括汉子和标点符号），按照我们的处理模式，共有41402个样本，将这些样本传入到LSTM模型中。我们建立的模型很简单，先是一个LSTM层，利用含有256个LSTM结构，然后是一个Dropout层，能有效防止模型发生过拟合，最后是Softmax层，将它转化为多分类的问题，采用交叉熵作为模型的损失函数。&lt;br/&gt;  训练模型的Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 搭建简单的LSTM模型用于生成旅游评论
import numpy
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras.callbacks import ModelCheckpoint
from keras.utils import np_utils

# 读取txt文件
filename = &quot;E://LSTM/comments.txt&quot;
with open(filename, 'r', encoding='utf-8') as f:
    raw_text = f.read().lower()

# 创建文字和对应数字的字典
chars = sorted(list(set(raw_text)))
#print(chars)
char_to_int = dict((c, i) for i, c in enumerate(chars))
int_to_char = dict((i, c) for i, c in enumerate(chars))
# 对加载数据做总结
n_chars = len(raw_text)
n_vocab = len(chars)
print(&quot;总的文字数: &quot;, n_chars)
print(&quot;总的文字类别: &quot;, n_vocab)

# 解析数据集，转化为输入向量和输出向量
seq_length = 10
dataX = []
dataY = []
for i in range(0, n_chars-seq_length, 1):
    seq_in = raw_text[i:i + seq_length]
    seq_out = raw_text[i + seq_length]
    dataX.append([char_to_int[char] for char in seq_in])
    dataY.append(char_to_int[seq_out])
n_patterns = len(dataX)
print(&quot;Total Patterns: &quot;, n_patterns)
# 将X重新转化为[samples, time steps, features]的形状
X = numpy.reshape(dataX, (n_patterns, seq_length, 1))
# 正则化
X = X/n_vocab
# 对输出变量做one-hot编码
y = np_utils.to_categorical(dataY)

# 定义LSTM模型
model = Sequential()
model.add(LSTM(256, input_shape=(X.shape[1], X.shape[2])))
model.add(Dropout(0.2))
model.add(Dense(y.shape[1], activation='softmax'))
model.compile(loss='categorical_crossentropy', optimizer='adam')
#print(model.summary())

# 定义checkpoint
filepath=&quot;E://LSTM/weights-improvement-{epoch:02d}-{loss:.4f}.hdf5&quot;
checkpoint = ModelCheckpoint(filepath, monitor='loss', verbose=1, save_best_only=True, mode='min')
callbacks_list = [checkpoint]
# 训练模型，每批训练128个样本，总共训练1000次
epochs = 1000
model.fit(X, y, epochs=epochs, batch_size=128, callbacks=callbacks_list)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先让我们看一下模型的结构及参数情况， 使用代码中的print(model.summary())即可，输出如下：&lt;/p&gt;
&lt;pre class=&quot;______________________________________________________________&quot;&gt;
&lt;code&gt;Layer (type)                 Output Shape              Param #   
=================================================================
lstm_1 (LSTM)                (None, 256)               264192    
_________________________________________________________________
dropout_1 (Dropout)          (None, 256)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 1949)              500893    
=================================================================
Total params: 765,085
Trainable params: 765,085
Non-trainable params: 0
_________________________________________________________________&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然是一个很简单的LSTM模型，但也有76万多个参数，深度学习的参数的个数可见一斑~&lt;br/&gt;  运行代码，训练该模型，在训练了漫长的4,5个小时后，在613次的时候，损失值为0.3040，我们就以这个文件作为模型训练的结果，而不是1000次，因为1000次太费时了。文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-06bd9299969edd9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Keras训练613次后生成的HDF5文件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请注意删除没用的文件，因为这些生成的文件都很大。&lt;/p&gt;
&lt;h3 id=&quot;生成旅游点评&quot;&gt;生成旅游点评&lt;/h3&gt;
&lt;p&gt;  好不容易训练完模型后，下一步，我们将要利用这个模型来生成旅游点评。怎么样，是不是有点期待？生成旅游点评的完整Python如下（我们以输入的句子“杭州西湖天下闻名，西”为例，请注意，每次输入正好10个文字，因为模型训练的输入向量为含10个元素的向量）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 搭建简单的LSTM模型用于生成旅游评论
import numpy
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras.callbacks import ModelCheckpoint
from keras.utils import np_utils

# 读取txt文件
filename = &quot;E://LSTM/comments.txt&quot;
with open(filename, 'r', encoding='utf-8') as f:
    raw_text = f.read().lower()

# 创建文字和对应数字的字典
chars = sorted(list(set(raw_text)))
#print(chars)
char_to_int = dict((c, i) for i, c in enumerate(chars))
int_to_char = dict((i, c) for i, c in enumerate(chars))
# 对加载数据做总结
n_chars = len(raw_text)
n_vocab = len(chars)
print(&quot;总的文字数: &quot;, n_chars)
print(&quot;总的文字类别: &quot;, n_vocab)

# 解析数据集，转化为输入向量和输出向量
seq_length = 10
dataX = []
dataY = []
for i in range(0, n_chars-seq_length, 1):
    seq_in = raw_text[i:i + seq_length]
    seq_out = raw_text[i + seq_length]
    dataX.append([char_to_int[char] for char in seq_in])
    dataY.append(char_to_int[seq_out])
n_patterns = len(dataX)
print(&quot;Total Patterns: &quot;, n_patterns)
# 将X重新转化为[samples, time steps, features]的形状
X = numpy.reshape(dataX, (n_patterns, seq_length, 1))
# 正则化
X = X/n_vocab
# 对输出变量做one-hot编码
y = np_utils.to_categorical(dataY)

# 定义LSTM模型
model = Sequential()
model.add(LSTM(256, input_shape=(X.shape[1], X.shape[2])))
model.add(Dropout(0.2))
model.add(Dense(y.shape[1], activation='softmax'))
model.compile(loss='categorical_crossentropy', optimizer='adam')

# 导入训练完后的文件
filename = &quot;E://LSTM/weights-improvement-613-0.3040.hdf5&quot;
model.load_weights(filename)
# 示例的输入句子
input = '杭州西湖天下闻名，西'
pattern = [char_to_int[value] for value in input]
print(&quot;输入：&quot;)
print(''.join([int_to_char[value] for value in pattern]))
print(&quot;输出：&quot;)
# 生成1000个文字
for i in range(1000):
    x = numpy.reshape(pattern, (1, len(pattern), 1))
    x = x / float(n_vocab)
    prediction = model.predict(x, verbose=0)
    index = numpy.argmax(prediction)
    result = int_to_char[index]
    print(result, end='')
    seq_in = [int_to_char[value] for value in pattern]
    pattern.append(index)
    pattern = pattern[1:len(pattern)]
print(&quot;\n生成完毕。&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行该代码，就能看到生成的文字如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：
杭州西湖天下闻名，西
输出：
湖一年四季特色纷呈，西湖有湖光山色交相辉应，既可看湖又可看山，西湖上的桥也是兼具南北特色，长桥不长，断桥不断。
西湖古迹遍布，山水秀丽，景色宜人，西湖处处有胜景。最著名的西湖十景，西湖十景”是指浙江省杭州市着名旅游景点西湖上的十处特色风景，分别是苏堤春晓、曲苑风荷、平湖秋月、断桥残雪、柳浪闻莺、花港观鱼、雷峰夕照、双峰插云、南屏晚钟、三潭印月等十个景点是杭州游览的热点，不用按照目前的时髦话说什么“非看不可”、“非去不可”，但是，如果去了杭州不看这些景点，不看这些景点的碑刻，就有点可惜了，特别是有康熙爷、乾隆爷的亲笔题词，不去看看，多少会对老祖宗的“大不敬”。
如果天气晴朗下午五点以后去西湖，如果拍视频你就会拍到天蓝蓝水蓝蓝的西湖和夕阳西下渐黄昏的完美，西湖边上有小凳子可以坐下来静静的欣赏西湖美景也可和同行的伙伴聊聊接下来的行程，目的是等待晚上更值得期待的音乐喷泉，得早早坐下来否则就看不到了，看喷泉不允许站着凳子坐满其余人站凳子后面。
西湖游船是游西湖必不可少的。另外早晨可以早点去，人少，而且凉爽。花港观鱼的景色也是不错。雷峰塔就看你需求了，可以俯瞰整个西湖(其实去雷峰塔也是为了看西湖吧，雷峰塔本身貌似没什么看的)吃饭的话，别在景区吃，强烈推荐去弄堂里。好吃又便宜。
8月份出差路过杭州，可以轻松的偷闲半天，顺便预约了离西湖比较近便的酒店入住。8月底的清晨已经有了丝丝的凉意，顺着西湖边开始溜达。早上人还是比较少，本地起来锻炼的大爷大妈比较多，有蘸水在地上练字的，有在小公园练嗓子的，还有坐在长条凳上练二胡的。9点多点，游客开始多了，各种游船排队等候，暑假期间带小孩匆匆而过的人也不少，基本都是到此一游，很少有仔细的欣赏和解说景点的出处。乘凉的地方还是不少，但是蚊子也多的吓人。苏堤的景色不错，特别是两边的高树遮挡了大多数的阳光，即使在这里溜达也不会觉得热，如果时间允许的话，建议溜达过去，步行约30分钟左右，南边的出口还有苏东坡博物馆，比较小，免费开放。
西湖的范围蛮大的，从北山路（北山路上的老建筑，浙江博物馆，断桥残雪，锦带桥，保俶塔，楼外楼，孤山，西冷印社，平湖秋月等。）到南线景区（南山路，西湖天地，御码头，钱王祠，柳浪闻莺，万松书院，长桥，南屏晚钟，净慈寺，雷锋塔太子湾等）以及三堤，外西湖，西里湖等，小南湖，小瀛洲，从白堤_苏堤_曲院风荷_杨公堤_鵒鸪湾_茅家埠。飞来峰景
生成完毕。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们来看一下这段生成的文字，首先，这段文字的可读性还是很高的，基本上人类能够理解，其次，与原文相对比，这段文字并不是一味地抄袭原文，而是有选择地将原文件中的旅游点评组合起来，虽然每部分的旅游点评与原先的相差不多，但重新组合后，是能够生成新的旅游点评的，并不算真正意义上的抄袭。&lt;br/&gt;  用LSTM训练出来的模型生成的文本，是能够作为新的旅游点评的，并不是完全的抄袭，但是对于未在原文中出现的输入向量，可能训练出来的效果就不会太理想，这是需要改进的地方。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;  本文纯属自娱自乐，如果不当之处，还望大家批评指正~~&lt;br/&gt;  当然，对于该项目，还有一些值得改进的地方，比如数据集不够大，这个可以爬取更多的评论；数据预处理过于简单，仅仅做了文字与向量的一一对应以及输入向量的正则化；模型过于简单，读者可以尝试搭建多个LSTM层或其他结构；模型训练过于耗时，可以尝试GPU或改进模型结构或数据预处理方式，等等等等。希望读者在阅读完本文后，能对LSTM模型在文字生成方面有一定的了解，欢迎拥抱LSTM~~&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;p&gt;Text Generation With LSTM Recurrent Neural Networks in Python with Keras： &lt;a href=&quot;https://machinelearningmastery.com/text-generation-lstm-recurrent-neural-networks-python-keras/&quot; class=&quot;uri&quot;&gt;https://machinelearningmastery.com/text-generation-lstm-recurrent-neural-networks-python-keras/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 15:02:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>RNN入门（三）利用LSTM生成旅游点评</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/9863848.html</dc:identifier>
</item>
<item>
<title>积极拥抱.NET Core开源社区 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/9863834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/9863834.html</guid>
<description>&lt;p&gt;&lt;span&gt;潘正磊在上海的Tech Summit 2018 大会上给我们的.NET Core以及开源情况带来了最新信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;.Net Core&lt;/strong&gt; 开源后取得了更加快速的发展，目前越活跃用户高达400万人，每月新增开发者45万，在 GitHub 上的月度增长达到15%。目前有来自超过3,700家企业的1.9万开发者在为 .NET Core 做贡献，.NET 基金会管理着超过60个项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;.NET Core&lt;/strong&gt; &lt;strong&gt;为开发者提供了跨平台、云原生应用的理想开发平台，特别是即将发布的 .NET Core 3，能够全面支持从网页到云端、桌面、物联网、人工智能的全方位的跨平台部署。在大会现场，微软演示了 Windows 桌面在 .NET Core 3.0上运行的情况，充分展现了将其用于未来开发环境的无限可能。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于中国开源，潘正磊讲起了一个发现，那就是今年在 GitHub 报告中看到中国在开源领域已仅次于美国名列第二，“在中国有非常多的开发者参与到开源项目中，这真的是一个非常好的趋势。很高兴看到诸如腾讯、阿里等顶级的互联网公司也开始将企业内部的技术开源，这起到了非常好的领头作用，希望更多的中国企业能够加入开源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过，针对国内开源项目的使用，潘正磊有一点建议，那便是“中国的开源社区需要与国际更加接轨，要形成一个观念 —— 不是说开源项目就等于可以随便使用，明晰开源许可协议。国内有一些大的云服务公司没有很好地遵守相应的 Licence。这可能是大家对于开源的认识存在一些误区，开源并非是可以任意使用源代码，还需要明确其许可协议是什么类型，诸如 GPL、BSD、MIT、Mozilla、Apache 等的区别。”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在中国使用最广泛的JDK，甲骨文宣布，“2019年1月之后”，如果没有商业许可，Java SE 8公开更新将无法用于“商业，商业或生产用途”。组织现在需要对运行Java SE 8的所有软件进行评估，并开始计算明年他们正在寻找的潜在账单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java Development Kit（JDK）是SUN公司针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。目前遵守GPL协议的OpenJDK的发布，并且免费使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OpenJDK 所使用的GPL协议和.NET Core所使用的MIT和Apache 2协议比起来可以看出微软是真的爱开源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天我也正好在杭州的中国计算机大会的现代编程语言论坛分享了《.NET Core和中国开源社区》。随着微软2014年开始积极拥抱开源，国内的社区开发者也在积极拥抱开源社区，我们也和微软一样选择使用对商用最友好的开源协议MIT和Apache2 协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225551490-832084037.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image002&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225551998-1989732729.jpg&quot; alt=&quot;clip_image002&quot; width=&quot;900&quot; height=&quot;672&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们参与开源的方式也是多种多样，既有我们自己的组织，也有积极参与国外的项目，更有参与国内的开源生态型项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参与国外的开源社区项目的代表是Ocelot，这也是我在2年前参与的一位英国Tom 发起的开源项目，我们一起完成了Ocelot的1.0版本，我将他应用于生产，微软.NET团队特意千里迢迢来到深圳和我们的团队一起拍了一个宣传视频，多次出现在潘正磊的演讲中，这次的Keynote上又出现了：https://v.qq.com/x/page/z0505atdyg2.html 。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过这两年在国内的推广，国内已经有很多使用案例，我特意建立了一个微信群收集把Ocelot落地到业务中的公司。也就是这个微信群里的多位同学将他们对Ocelot的扩展进行开源回馈到了Ocelot，不断的丰富了Ocelot的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225552368-778326925.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image004&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225552752-307408245.jpg&quot; alt=&quot;clip_image004&quot; width=&quot;900&quot; height=&quot;672&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这几年时间里我们不局限于单打独斗的开源，我们一定需要通过协作来推动开源项目的发展，我们在github上成立了国内的开源组织dotnetcore：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225553210-725711077.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image006&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225553810-429329913.jpg&quot; alt=&quot;clip_image006&quot; width=&quot;900&quot; height=&quot;672&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个组织最早起源于大家一起进行文档翻译，到现在已经有12个成员项目，最近还有一个比较特别的项目BotSharp的加入，让这个组织更有活力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在云原生应用开发时代，需要建设大量的云基础设施，所以我们也需要融入整个云原生发展的生态之中，这其中有两个代表性的项目是SkyWalking .NET Core 探针和Tarsnet 开源项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225554222-1456212119.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image008&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225554634-27076011.jpg&quot; alt=&quot;clip_image008&quot; width=&quot;900&quot; height=&quot;672&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225555118-286845405.jpg&quot;&gt;&lt;span&gt;&lt;img title=&quot;clip_image010&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201810/510-20181027225555981-1727425956.jpg&quot; alt=&quot;clip_image010&quot; width=&quot;900&quot; height=&quot;683&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里特别想号召有想法的同学加入我们的Tarsnet的开发，目前Tarsnet已经完成最核心的RPC、Codecs以及CLI 工具的开发，接下来有大量的对接tars平台的服务开发工作，有兴趣的同学欢迎微信联系我：geffzhang。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Oct 2018 14:56:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>潘正磊在上海的Tech Summit 2018 大会上给我们的.NET Core以及开源情况带来了最新信息。 .Net Core 开源后取得了更加快速的发展，目前越活跃用户高达400万人，每月新增开发</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/9863834.html</dc:identifier>
</item>
</channel>
</rss>