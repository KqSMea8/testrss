<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>现代密码学中的数论基础知识梳理 - Qcer</title>
<link>http://www.cnblogs.com/qcblog/p/8976017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcblog/p/8976017.html</guid>
<description>&lt;h2&gt;导读&lt;/h2&gt;
&lt;p&gt;数论是一门研究自然数之间的关系和规律的学科，普遍认为是纯数学的分支，但并非是完全没有实用性的学科。现代密码学中用到了很多基础数论中的结论，特别是公钥加密体系（例如RSA算法，椭圆曲线加密等）。&lt;/p&gt;
&lt;p&gt;本文目的在于梳理现代密码学中常用到的基础数论方面的定理和结论。其中包括素数的特性、欧几里德算法、线性方程定理、算术基本定理、模算数运算、线性同余定理、欧拉函数、费马小定理、中国剩余定理、欧拉定理、本原根、离散对数问题等等一些基础知识。了解这些知识，应该能够理解现代密码学中经典的&lt;/p&gt;
&lt;p&gt;Diffie-Hellman密钥协商和RSA算法的原理，进而能够理解秘钥管理、数字签名、消息认证、公钥证书等密码学领域的问题。&lt;/p&gt;
&lt;p&gt;本文很大程度上参考了&lt;strong&gt;&lt;em&gt;数论概述&lt;/em&gt;&lt;/strong&gt;里面的内容，也借鉴了&lt;strong&gt;&lt;em&gt;算法导论&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;密码编码学与网络安全原理与实践&lt;/em&gt;&lt;/strong&gt;的相关章节。&lt;/p&gt;
&lt;h2&gt;一、关于互质和整除的一些有用结论和定理&lt;/h2&gt;
&lt;p&gt; 数论对素数的特性尤其感兴趣，素数是整数的基础构件，就像是元素在化学式中的作用类似。&lt;/p&gt;
&lt;p&gt;1、$d$整除$a$记作：$d \mid a$&lt;/p&gt;
&lt;p&gt; 如果$d \mid a$且$d \mid b$，那么$d \mid (ax + by)$.&lt;/p&gt;
&lt;p&gt;2、如果$p$是素数，且$p$整除乘积$ab$，则$p$整除$a$或者$p$整除$b$（或者$p$同时整除$a$和$b$）。&lt;/p&gt;
&lt;p&gt;证明的关键是假设$p$不整除$a$，考虑$1=gcd(p,a)$同时整除$p$和$a$。但由于$p$是素数，$p$的因子只能是1或者$p$，所以$gcd(p,a)=1$。由后面的线性方程定理得知，可以构造线性方程$px+ay=1=gcd(p,a)$，两边同时乘上$b$，得$bpx+aby=b$，$p$整除左边等价于$p$整除右边的$b$。$p$不整除$b$的情况可以用同样的方式证明。&lt;/p&gt;
&lt;p&gt;拓展：如果素数$p$整除整数乘积$a_{1}a_{2}a_{3}...a_{r}$,则p至少整除$a_{1}$,$a_{2}$,$a_{2}$,$...$,$a_{r}$中至少一个因数。&lt;/p&gt;
&lt;p&gt;3、1和任意一个自然数是都是互质关系。&lt;/p&gt;
&lt;p&gt;4、任意两个质数构成互质关系。&lt;/p&gt;
&lt;p&gt;5、一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。&lt;/p&gt;
&lt;p&gt;6、如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。&lt;/p&gt;
&lt;p&gt;7、 $p$是大于1的整数，则$p$和$p-1$构成互质关系，比如57和56。&lt;/p&gt;
&lt;p&gt;8、$p$是大于1的奇数，则$p$和$p-2$构成互质关系，比如17和15。&lt;/p&gt;
&lt;p&gt;9、素数$p$与1到$p-1$的任意整数均互质。并且阶乘$(p-1)!$与$p$互质，这个结论在后面费马小定理和欧拉定理的证明过程中会用到。&lt;/p&gt;
&lt;h2&gt;二、欧几里德算法&lt;/h2&gt;
&lt;p&gt;欧几里德算法的原理和流程其实比较容易理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(GCD递归定理)&lt;/strong&gt; ：对于任意的非负整数$a$和正整数$b$，满足&lt;/p&gt;
&lt;p&gt;$gcd(a,b)=gcd(b,a\;mod\;b)$&lt;/p&gt;
&lt;p&gt;更详细的将，其计算流程：&lt;/p&gt;
&lt;p&gt;$a=q_{1}\times b+r_{1}\\b=q_{2}\times r_{1}+r_{2}\\r_{1}=q_{3}\times r_{2}+r_{3}\\r_{2}=q_{4}\times r_{3}+r_{4}\\...\\r_{n-3}=q_{n-1}\times r_{n-2}+r_{n-1}\\r_{n-2}=q_{n}\times r_{n-1}+r_{n}\\r_{n-1}=q_{n+1}\times r_{n}+0\\$&lt;/p&gt;
&lt;p&gt;$r_{n}$即为求得的$a$和$b$的最大公约数。&lt;/p&gt;
&lt;p&gt;以上流程主要需要思考三个问题：&lt;/p&gt;
&lt;p&gt;1）为什么$r_{n}$是公约数？（需要从下往上推理）&lt;/p&gt;
&lt;p&gt;2）为什么$r_{n}$是最大的公约数？（假设$d$是$a$与$b$的任意公约数，如果能够证明$d$整数$r_{n}$，即可得证。）&lt;/p&gt;
&lt;p&gt;3）为什么欧几里德算法最后一定会终止？（因为每轮辗转之后的余数是单调递减的，辗转的轮次数有上界，最后一定能够保证余数为0，然后取最后一个非零余数$r_{n}$就是正确的结果。）&lt;/p&gt;
&lt;p&gt;算法实现Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;欧几里德算法迭代实现&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getGCD(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a&amp;lt;b) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保证a&amp;gt;=b&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getGCD(b, a);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b&amp;gt;=1) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保证b&amp;gt;=1&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; temp = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(b&amp;gt;0&lt;span&gt;) {
                temp &lt;/span&gt;= a%&lt;span&gt;b;
                a &lt;/span&gt;=&lt;span&gt; b;
                b &lt;/span&gt;=&lt;span&gt; temp;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、扩展欧几里德算法&lt;/h2&gt;
&lt;p&gt;扩展欧几里德算法可以用来求解一类有意思的线性方程的整数解，该线性方程的整数求解过程与最大公约数有密切关系。&lt;/p&gt;
&lt;p&gt; 对于线性方程（$a,b,c$为常数）：&lt;/p&gt;
&lt;p&gt;$ax+by=c$&lt;/p&gt;
&lt;p&gt;是很熟悉的方程。这里讨论情况是$a,b,c$满足一定的关系：$c=gcd(a,b)$，也即是这样的线性方程：&lt;/p&gt;
&lt;p&gt;$ax+by=gcd(a,b)$&lt;/p&gt;
&lt;p&gt; 这个线性方程必然有整数解，但我们更关心如果用更好算法去求解，该算法利用欧几里德算法求解最大公约数过程中的中间商和余数，进行扩展运算，在求$gcd(a,b)$的过程中，同时也就求得线性方程的整数解$(x,y)$。&lt;/p&gt;
&lt;p&gt; 算法实现Demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[] gcdExt(&lt;span&gt;long&lt;/span&gt; a,&lt;span&gt;long&lt;/span&gt;&lt;span&gt; b){  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; ans;  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;[] result=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[3&lt;span&gt;];  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(b==0&lt;span&gt;)  
        {  
            result[&lt;/span&gt;0]=&lt;span&gt;a;  
            result[&lt;/span&gt;1]=1&lt;span&gt;;  
            result[&lt;/span&gt;2]=0&lt;span&gt;;  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;  
        }  
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; [] temp=gcdExt(b,a%&lt;span&gt;b);  
        ans &lt;/span&gt;= temp[0&lt;span&gt;];  
        result[&lt;/span&gt;0]=&lt;span&gt;ans;  
        result[&lt;/span&gt;1]=temp[2&lt;span&gt;];  
        result[&lt;/span&gt;2]=temp[1]-(a/b)*temp[2&lt;span&gt;];  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;  
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四、算术基本定理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(算术基本定理)&lt;/strong&gt;：每个整数$n\geqslant 2$可唯一分解成素数的乘积：&lt;/p&gt;
&lt;p&gt;$n=p_{1}^{e_{1}}p_{2}^{e_{2}}...p_{r}^{e_{r}}$&lt;/p&gt;
&lt;p&gt;其中，$p_{i}$为素数，且$p_{1}&amp;lt;p_{2} &amp;lt;...&amp;lt;p_{r}$，$e_{i}$为正整数。&lt;/p&gt;
&lt;p&gt; 实际上，看似理所当然的事实，其实并非如此。如果自定义一个有别正整数集合的其他集合，很可能就不再满足唯一分解定理。例如，集合E是由偶数构成的集合：&lt;/p&gt;
&lt;p&gt;$E=\left \{0,2,4,6,8,10,12...\right \}$&lt;/p&gt;
&lt;p&gt;也可在这个集合中定义所谓的“素数”，称之为“E-素数”，2,6,10,14,18,22,26,30都是“E-素数”。对这个集合中的元素尝试做“素因子”分解，并不总是能都到唯一分解的结果，例如180=10x18=2x30，存在两种“E-素数”的分解形式。&lt;/p&gt;
&lt;p&gt; 实际上算术基本定理包含两个方面：&lt;/p&gt;
&lt;p&gt;1）$n$可以分解成素数乘积的形式。&lt;/p&gt;
&lt;p&gt;2）仅有一种这样的素因子分解的形式（当然这里不考虑因数重排序的情况）。&lt;/p&gt;
&lt;p&gt;显然唯一性分解是算术基本定理的关键和重点。&lt;/p&gt;
&lt;p&gt;另外一个有意思的事实：&lt;/p&gt;
&lt;p&gt;如果$n$是一个合数，则在小于等于$\sqrt{n}$的数中必定有一个数$a$整除合数$n$。&lt;/p&gt;
&lt;p&gt;该结论基于算术基本定理：合数$n$必定可以唯一分解多个素数的乘积，这里假设$p$是它的素因子中最小的一个，则$n$必定可以写成$n=p\times m$的形式，这里的$m$是其余大于等于$p$的素因子的乘积，显然$m\geqslant p$,因此$n=p\times m\geqslant p\times p=p^{2}$&lt;/p&gt;
&lt;p&gt;所以，在$0...\sqrt{n}$的范围内，必定存在一个数$a$整除$n$。&lt;/p&gt;
&lt;p&gt;可以利用这种方法简单的分辨一个数是否是素数，也可以反复执行上述过程将一个较小的合数进行素因子分解。&lt;/p&gt;
&lt;h2&gt;五、 同余式与模算术&lt;/h2&gt;
&lt;p&gt;一般来讲，可以将$mod$视为一种求余数的二元运算符，例如$2=5\;mod\;3$；也可以用来表示同余关系，这种同余关系通常用同余式表示。例如$2\equiv 5\;(mod\;3)$表示模3时2与5同余。&lt;/p&gt;
&lt;p&gt;同余式虽然有别于普通的算数运算下的等式，但是具有相同模的同余式与普通等式有一些相似的特性：&lt;/p&gt;
&lt;p&gt;如果已知：&lt;/p&gt;
&lt;p&gt;$a_{1}\equiv b_{1}\;(mod\;m)$ 且$a_{2}\equiv b_{2}\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;那么有：&lt;/p&gt;
&lt;p&gt;$a_{2}\pm a_{2}\equiv b_{2}\pm b_{2}\;(mod\;m)$和$a_{2}a_{2}\equiv b_{2}b_{2}\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;同时，也不难得出：&lt;/p&gt;
&lt;p&gt;如果，$a^{k}\equiv b\;(mod\;m)$，那么，$(a^{k})^j\equiv b^{j}\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;特别的当$b=1$时：&lt;/p&gt;
&lt;p&gt;如果$a^{k}\equiv 1\;(mod\;m)$，那么，$(a^{k})^{j}\equiv 1\;(mod\;m)$。&lt;/p&gt;
&lt;p&gt;但是，由$ac\equiv bc\;(mod\;m)$不一定能得到$a\equiv b\;(mod\;m)$。&lt;/p&gt;
&lt;p&gt;例如$2\times25\equiv2\times20\;(mod\;10) $，但是$25\not\equiv 20\;(mod\;10)$。&lt;/p&gt;
&lt;p&gt;只有当$c$和$m$互质时（也即是$gcd=(c,m)=1$），才能够从同余式两边消去$c$。&lt;/p&gt;
&lt;p&gt; 由同余式可以引出同余方程：&lt;/p&gt;
&lt;p&gt;$ax\equiv c\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;求解上述同余方程有一个定理，叫做同余方程定理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(同余方程定理)&lt;/strong&gt;：设$a,c,m$是整数，$m\geqslant 1$，且设$g=gcd(a,m)$，则&lt;/p&gt;
&lt;p&gt;1）如果$g$不整除$c$，那么同余方程$ax\equiv c\;(mod\;m)$没有解。&lt;/p&gt;
&lt;p&gt;2）如果$g$整除$c$，那么同余方程$ax\equiv c\;(mod\;m)$恰好有$g$个解。&lt;/p&gt;
&lt;p&gt;以上同余方程的求解过程需要用到扩展欧几里德的求解方法。实际上$ax\equiv c\;(mod\;m)$可以转化为线性方程$ax+m(-y)=c$。&lt;/p&gt;
&lt;p&gt;特别地，当$a$和$m$互质，即$g=gcd(a,m)=1$时，同余方程变成：&lt;/p&gt;
&lt;p&gt;$ax\equiv 1\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;$a$和$x$互为模反元素，这在RSA公钥加密算法生成秘钥过程中有应用。&lt;/p&gt;
&lt;h2&gt;六、费马小定理&lt;/h2&gt;
&lt;p&gt;费马小定理揭示了整数的幂在模运算下的特殊规律。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(费马小定理)&lt;/strong&gt;：设$p$是素数，$a$是任意的正整数且满足$a\not\equiv0\;(mod\;p)$，则&lt;/p&gt;
&lt;p&gt;$a^{p-1}\equiv 1 \;(mod\;p)$&lt;/p&gt;
&lt;p&gt;实际上对于条件的更简单的表述可以为&quot;$a$与素数$p$互质&quot;即可。&lt;/p&gt;
&lt;p&gt;证明费马小定理并不是非常难，证明过程是基于这样一个结论：&lt;/p&gt;
&lt;p&gt;设素数$p$与任意正整数$a$互质，那么集合$S=\left \{ a,2a,3a,...(p-1)a \right \}$中任意任意两个元素均不可能模$p$同余。也即是$ja\not\equiv ka\;(mod\;p)$。其证明过程只需要利用反证法即可。&lt;/p&gt;
&lt;p&gt;上述结论表明，如果对集合$S$中的每一个元素模$p$的结果，其结果刚好与集合$T= \left \{ 1,2,3,4...(p-1) \right \}$中的元素一一对应（不考虑次序重排）。&lt;/p&gt;
&lt;p&gt;于是有：&lt;/p&gt;
&lt;p&gt;$a\times 2a\times3a...\times(p-1)a\equiv 1\times2\times3...\times(p-1)\;(mod\;p)$&lt;/p&gt;
&lt;p&gt;稍微整理得：&lt;/p&gt;
&lt;p&gt;$(p-1)!\times a^{p-1}\equiv(p-1)!\;(mod\;p)$&lt;/p&gt;
&lt;p&gt;这里必然后$gcd((p-1)!,p)=1$，所以，可以两边消去$(p-1)!$，得到$a^{p-1}\equiv 1 \;(mod\;p)$。&lt;/p&gt;
&lt;p&gt;正是由于存在这样的关系，所有费马小定理可以用来简化对整数的幂取模的计算。&lt;/p&gt;
&lt;p&gt;费马小定理在数论中非常重要，与其三个定理（分别是威尔逊定理、欧拉定理和中国剩余定理）合称数论四大基本定理。更有趣的是，费马小定理实际上可以视为欧拉定理的一个特例。&lt;/p&gt;
&lt;p&gt;最后，费马小定理还有一种等价的表示形式：&lt;/p&gt;
&lt;p&gt;若$p$是素数，$a$是正整数，则&lt;/p&gt;
&lt;p&gt;$a^{p-1}\equiv a\;(mod\;p)$&lt;/p&gt;
&lt;p&gt;这里不需要$a$与$p$互质的条件。这并不是一件很奇怪的事情，无非是利用模算术的除法特性（见&lt;em&gt;同余式与模算术&lt;/em&gt;）的变形。&lt;/p&gt;
&lt;h2&gt;七、中国剩余定理&lt;/h2&gt;
&lt;p&gt;中国剩余定理（也叫作孙子定理）所描述的问题在小学课本中都能找到，只不过当时只能用方程组去刻画这个的问题。&lt;/p&gt;
&lt;p&gt;在数论中，它有不止一种表述形式，我见到的就至少有两种。&lt;/p&gt;
&lt;p&gt;其中一种比较易懂的描述为：&lt;/p&gt;
&lt;p&gt;设$m,n$是正整数，$gcd(m,n)=1$，$b,c$是任意正整数，则同余方程组&lt;/p&gt;
&lt;p&gt;$x\equiv b\;(mod\;m)\\x\equiv c\;(mod\;n)$&lt;br/&gt;恰有一个解$0\leqslant x\leqslant mn$。&lt;/p&gt;
&lt;p&gt; 以上是从方程的角度描述，另外一种从对应的角度(数与k元组的对应关系)表述也是可行的，可以看做是上面表述形式更抽象的扩展：&lt;/p&gt;
&lt;p&gt; 令&lt;/p&gt;
&lt;p&gt;$M=\prod_{i=1}^{k}m_{i}$，其中$m_{i}$两两互质&lt;/p&gt;
&lt;p&gt;则$Z_{M}=\left \{ 0,1,2,3...(m-1)\right \}$中任意整数会对应一个$k$元组：&lt;/p&gt;
&lt;p&gt;$A\leftrightarrow (a_{1},a_{2}...,a_{k})$&lt;/p&gt;
&lt;p&gt;其中$a_{i}$当然是要在$Z_{m_{i}}$中(也即是$a_{i}\in Z_{m_{i}}$)，并且$a_{i}$由关系$a_{i}=A\;mod\;m_{i}$给出。&lt;/p&gt;
&lt;p&gt;从以上定理实际上可以推断出$A$与$k$元组唯一一对应的事实。&lt;/p&gt;
&lt;p&gt;以上描述形式是&lt;em&gt;算法导论&lt;/em&gt;和&lt;em&gt;密码编码学与网络安全--原理与实践&lt;/em&gt;中采用的表述形式。相比于第一种表述形式，第二种表述更具有通用性，也更抽象。中国剩余在推导欧拉函数求解公式时会用到。&lt;/p&gt;
&lt;h2&gt;八、欧拉函数&lt;/h2&gt;
&lt;p&gt; 欧拉函数$\phi (m)$的含义是1到$m-1$中（也就是$\left [ 1,m-1 \right ]$）且与$m$互质的整数的个数。它是数论中一个非常重要的函数。&lt;/p&gt;
&lt;p&gt;如何计算欧拉函数的值是一个关键的问题。欧拉函数的计算方法的推导主要用到两个结论：&lt;/p&gt;
&lt;p&gt;（1）如果$p$是素数，$k\geqslant 1$，则$\phi (p^{k})=p^k-p^{k-1}=p^k(1-\frac{1}{p})$&lt;/p&gt;
&lt;p&gt;（2）如果$gcd(m,n)=1$，则$\phi (mn)=\phi (m)\times \phi (n)$&lt;/p&gt;
&lt;p&gt;证明（1）的思路很简单：从1到$p^{k}$共有$p^{k}$个整数，这些整数中当然有可能存在与$p^{k}$不互质的数，那么只要扣除去这些数就可以了。显而易见的是，这些与$p^{k}$不互质的数并不难找，它们分别是：&lt;/p&gt;
&lt;p&gt;$p,2p,3p,...,(p^{k-1}-2)\times p,(p^{k-1}-1)\times p,p^{k-1}\times  p$&lt;/p&gt;
&lt;p&gt;一共有$p^{k-1}$个数与$p^{k}$不互质，那么从$p^{k}$中扣除这$p^{k-1}$个数即可。&lt;/p&gt;
&lt;p&gt;证明（2）比较复杂一点，其思路是采用计数的思想然后结合中国剩余定理（第一种表述形式）来证明。&lt;/p&gt;
&lt;p&gt;有了以上两个结论，结合算术基本定理，可以得到计算$\phi (m)$比较通用的公式：&lt;/p&gt;
&lt;p&gt;假设任意正整数$m$，且其素因子分解形式为&lt;/p&gt;
&lt;p&gt;$m=p_{1}^{k_{1}}p_{2}^{k_{2}}...p_{r}^{k_{r}}$&lt;/p&gt;
&lt;p&gt;利用上面的（2）可以得到&lt;/p&gt;
&lt;p&gt;$\phi (m)=\phi (p_{1}^{k_{1}})\phi (p_{2}^{k_{2}})...\phi (p_{r}^{k_{r}})$&lt;/p&gt;
&lt;p&gt;然后利用（1），继续得到&lt;/p&gt;
&lt;p&gt;$\phi (m)=p_{1}^{k_{1}}p_{2}^{k_{2}}...p_{r}^{k_{r}}(1-\frac{1}{p_{1}})(1-\frac{1}{p_{2}})...(1-\frac{1}{p_{r}})$&lt;/p&gt;
&lt;p&gt;也就是&lt;/p&gt;
&lt;p&gt;$\phi (m)=m(1-\frac{1}{p_{1}})(1-\frac{1}{p_{2}})...(1-\frac{1}{p_{r}})$&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;$\phi (12)=\phi (2^{2}\times 3)=\phi (2^{2})\times \phi (3)=12\times (1-\frac{1}{2})\times (1-\frac{1}{3})=4$&lt;/p&gt;
&lt;p&gt;另外，欧拉函数与各因数之间存在一种巧妙的关系：&lt;/p&gt;
&lt;p&gt;设$d_{1},d_{2},...,d_{r}$是$n$的因数，则&lt;/p&gt;
&lt;p&gt;$\phi (d_{1})+\phi (d_{2})+...+\phi (d_{r})=\phi (n)$&lt;/p&gt;
&lt;p&gt;其实当$n=p$或者$n=p^{2}$甚至$n=p^{k}$（$p$是素数）时，很容易验证其正确性。&lt;/p&gt;
&lt;h2&gt;九、欧拉定理&lt;/h2&gt;
&lt;p&gt;欧拉定理与费马小定理同样都是揭示了整数的幂在模运算下的特殊规律，实际上他们有微妙的关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(欧拉定理)&lt;/strong&gt;：如果$gcd(a,m)=1$，则&lt;/p&gt;
&lt;p&gt;$a^{\phi (m)}\equiv 1\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;实际上证明欧拉定理的方法与证明费马小定理基本类似，此处略去。&lt;/p&gt;
&lt;p&gt;欧拉定理与费马小定理有微妙的关系：如果这里的$m$是一个素数，则$\phi (m)=m-1$，由此得到费马小定理。说明费马小定理实际上可以看成欧拉定理的一个特例。&lt;/p&gt;
&lt;p&gt;与费马小定理类似，欧拉定理也有另外一种表现形式：&lt;/p&gt;
&lt;p&gt;$a^{\phi (m)+1}\equiv a\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;这里没有要求$a$与$m$互质的条件。&lt;/p&gt;
&lt;h2&gt;十、模反元素&lt;/h2&gt;
&lt;p&gt;如果两个正整数$a$和$m$互质，那么一定可以找到整数$b$，使得 $ab-1$ 被$m$整除，或者说$ab$被$m$除的余数是1。&lt;/p&gt;
&lt;p&gt;$ab\equiv1\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;则此时$b$就是$a$的模反元素。&lt;/p&gt;
&lt;p&gt;实际上这里相当于求解同余方程$ax\equiv 1\;(mod\;m)$，当$gcd(a,m)=1$时，必定存在一个整数解，因此模反元素必定存在，此解即是$a$的模反元素。&lt;/p&gt;
&lt;p&gt;从欧拉定理的角度&lt;/p&gt;
&lt;p&gt;$a^{\phi (m)}=a\times a^{\phi (m)-1}\equiv 1\;(mod\;m)$&lt;/p&gt;
&lt;p&gt;也可以证明模反元素是存在的。&lt;/p&gt;
&lt;p&gt;更进一步，如果$p$是素数，由集合$Z_{p}=\left \{ 0,1,2,...p-1 \right \}$和二元运算模$p$的算术运算构成一个有限交换群G。G中每一个元素都有乘法逆元，此乘法逆元就是这里的模反元素。&lt;/p&gt;
&lt;h2&gt;十一、本原根&lt;/h2&gt;
&lt;p&gt;本原根通常与幂模有关，观察如下例子：&lt;/p&gt;
&lt;p&gt;$3^{1}\;mod\;7=3\\3^{2}\;mod\;7=2\\3^{3}\;mod\;7=6\\3^{4}\;mod\;7=4\\3^{5}\;mod\;7=5\\3^{6}\;mod\;7=1\\...$&lt;/p&gt;
&lt;p&gt;可以发现3的各幂次模$n$能够得到一个循环的序列$\left \{ 3,2,6,4,5,1 \right \}$，这个序列刚好对应着小于等于7且与7互质的整数集合。这并非一个偶然规律，2或者3的各次幂模5，2或者6或者7或者8的各次幂模11都能够得到同样的规律。&lt;/p&gt;
&lt;p&gt;当然也并不是总是这样，例如&lt;/p&gt;
&lt;p&gt;$2^{1}\;mod\;7=2\\2^{2}\;mod\;7=4\\2^{3}\;mod\;7=1\\2^{4}\;mod\;7=2\\...$&lt;/p&gt;
&lt;p&gt;更一般的，考虑$p$为素数，$gcd(a,p)=1$且$a\leqslant p-1$，如下序列&lt;/p&gt;
&lt;p&gt;$a\;mod\;p,a^{2}\;mod\;p,a^{3}\;mod\;p,...,a^{p-3}\;mod\;p,a^{p-2}\;mod\;p,a^{p-1}\;mod\;p$&lt;/p&gt;
&lt;p&gt;如果$a^{p-1}\;mod\;p=1$，那么可以证明上述序列值必然各不相同（证明可以用反证法，不存在$a^{i}\equiv a^{j}\;(mod\;p)$的情况）。因为这里模$p$运算的结果总会映射到集合$Z_{p}=\left \{ 1,2,3,...,p-2,p-1 \right \}$，这个集合中的每个元素与$p$互质。也即是说不考虑次序重排，上述序列值对应了集合$Z_{p}$的值。&lt;/p&gt;
&lt;p&gt;这时称$a$是$p$的本原根或者生成元。&lt;/p&gt;
&lt;p&gt;并非所有的整数都存在本原根，事实上只有$1,4,p^{\alpha},2p^{\alpha}$才有本原根，其中$p$是任意奇素数，可见素数一定存在本原根。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(原根定理)&lt;/strong&gt;：每个素数$p$都有本原根，而且刚好有$\phi (p-1)$个模$p$的本原根。&lt;/p&gt;
&lt;p&gt; 另外还有一些值得挖掘的规律，不难发现，对于$a^{k}\equiv1\;(mod\;p)$，这样的$k$可能不止一个，比如：&lt;/p&gt;
&lt;p&gt;$2^{3}\equiv 1\;(mod\;p)\\2^{6}\equiv 1\;(mod\;p)$&lt;/p&gt;
&lt;p&gt;取最小的$k$称为$a$模$p$的阶：$ord_{p}(a)$，例如$ord_{7}(2)=3$。&lt;/p&gt;
&lt;p&gt;不难发现，$1\leqslant ord_{p}(a)\leqslant p-1$且总是整除$p-1$（从费马小定理的角度思考可以容易得出结论）。&lt;/p&gt;
&lt;h2&gt;十二、离散对数问题&lt;/h2&gt;
&lt;p&gt;离散对数的问题很好理解，与算术对数相对，只是在算术对数的基础上增加了模运算。&lt;/p&gt;
&lt;p&gt;对于$y=g^{x}\;mod\;p$，如果已知$x,g,p$求$y$是比较容易的求解的；但是反过来，已知$y,g,p$求$x$是很困难的，因此这里可以看成一个单向函数。&lt;/p&gt;
&lt;p&gt;Diffie-Hellman密钥协商原理正是基于这样的离散对数问题而设计。而椭圆曲线加密是基于定义在椭圆曲线上的特殊加法运算规则下的离散对数问题而设计，两者达到的目的是一致的，都是利用某一个方向上的计算困难程度保证加密算法的机密性。&lt;/p&gt;
&lt;h2&gt;十三、References&lt;/h2&gt;
&lt;p&gt;1、数论概述&lt;/p&gt;
&lt;p&gt;2、算法导论.第三一章.数论算法&lt;/p&gt;
&lt;p&gt;3、密码编码学与网络安全原理与实践&lt;/p&gt;
&lt;p&gt;完！&lt;/p&gt;
&lt;p&gt;转载请注明原文出处：&lt;a href=&quot;http://www.cnblogs.com/qcblog/p/8976017.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/qcblog/p/8976017.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 23:31:00 +0000</pubDate>
<dc:creator>Qcer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcblog/p/8976017.html</dc:identifier>
</item>
<item>
<title>管理和安装 chart - 每天5分钟玩转 Docker 容器技术（168） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/9039236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/9039236.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;安装 chart&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当我们觉得准备就绪，就可以安装 chart，Helm 支持四种安装方法：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;安装仓库中的 chart，例如：&lt;/span&gt;&lt;code&gt;&lt;span&gt;helm install stable/nginx&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 tar 包安装，例如：&lt;/span&gt;&lt;code&gt;&lt;span&gt;helm install ./nginx-1.2.3.tgz&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 chart 本地目录安装，例如：&lt;/span&gt;&lt;code&gt;&lt;span&gt;helm install ./nginx&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 URL 安装，例如：&lt;/span&gt;&lt;code&gt;&lt;span&gt;helm install https://example.com/charts/nginx-1.2.3.tgz&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这里我们使用本地目录安装：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092135803-49847944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当 chart 部署到 Kubernetes 集群，便可以对其进行更为全面的测试。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;将 chart 添加到仓库&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;chart 通过测试后可以将其添加到仓库，团队其他成员就能够使用。任何 HTTP Server 都可以用作 chart 仓库，下面演示在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;k8s-node1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;192.168.56.106 上搭建仓库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;k8s-node1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上启动一个 httpd 容器。&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092145817-1636190361.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm package&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 打包。&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092205598-2097831935.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm repo index&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 生成仓库的 index 文件。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092216973-520586780.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;Helm 会扫描 &lt;/span&gt;&lt;code&gt;&lt;span&gt;myrepo&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 目录中的所有 tgz 包并生成 &lt;/span&gt;&lt;code&gt;&lt;span&gt;index.yaml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;--url&lt;/span&gt;&lt;/code&gt;&lt;span&gt;指定的是新仓库的访问路径。新生成的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;index.yaml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录了当前仓库中所有 chart 的信息：&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092226492-856266736.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;当前只有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这一个 chart。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mychart-0.1.0.tgz&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;index.yaml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 上传到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;k8s-node1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/www/charts&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 目录。&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092238761-1444079880.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm repo add&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 将新仓库添加到 Helm。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092247167-992023557.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;仓库命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;newrepo&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，Helm 会从仓库下载 index.yaml。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;现在已经可以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;repo search&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 了。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092255818-1607809957.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;除了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;newrepo/mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这里还有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;local/mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。这是因为在执行第 2 步打包操作的同时，&lt;/span&gt;&lt;code&gt;&lt;span&gt;mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 也被同步到了 local 的仓库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;已经可以直接从新仓库安装 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mychart&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 了。&lt;br/&gt;&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092310171-963875796.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果以后仓库添加了新的 chart，需要用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;helm repo update&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 更新本地的 index。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201805/775365-20180515092320266-1133255474.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;这个操作相当于 Ubutun 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;apt-get update&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本章我们学习了 Kubernetes 包管理器 Helm。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Helm 让我们能够像 apt 管理 deb 包那样安装、部署、升级和删除容器化应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Helm 由客户端和 Tiller 服务器组成。客户端负责管理 chart，服务器负责管理 release。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;chart 是 Helm 的应用打包格式，它由一组文件和目录构成。其中最重要的是模板，模板中定义了 Kubernetes 各类资源的配置信息，Helm 在部署时通过 values.yaml 实例化模板。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Helm 允许用户开发自己的 chart，并为用户提供了调试工具。用户可以搭建自己的 chart 仓库，在团队中共享 chart。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Helm 帮助用户在 Kubernetes 上高效地运行和管理微服务架构应用，Helm 非常重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下节我们开始学习 Kubernetes 网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 23:07:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/9039236.html</dc:identifier>
</item>
<item>
<title>TensorFlow-谷歌深度学习库 文件I/O Wrapper - 火山岩上的小红花</title>
<link>http://www.cnblogs.com/duwenlu/p/9044020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duwenlu/p/9044020.html</guid>
<description>&lt;p&gt;这篇文章主要介绍一下TensorFlow中相关的文件I/O操作，我们主要使&lt;strong&gt;tf.gfile&lt;/strong&gt;来完成。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tf.gfile.Exists(filename)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用来判断一个路径是否存在，如果存在符合的文件夹或文件返回true，否则返回false。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tf.gfile.MakeDirs(dirname)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个文件夹路径。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ListDirectory&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tf.gfile.ListDirectory(dirname)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;列出在此目录下的所有子目录（文件/文件夹）&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;DeleteRecursively&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tf.gfile.DeleteRecursively(dirname)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;循环删除某个文件夹下的所有内容。&lt;/p&gt;


&lt;p&gt;其实挺简单的，感觉就是和python的函数差不多，一些名称有些变化而已啦～～～&lt;/p&gt;
&lt;p&gt;官方文档在这里：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/gfile&quot; target=&quot;_blank&quot;&gt;https://www.tensorflow.org/api_docs/python/tf/gfile&lt;/a&gt;　　　&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 20:46:00 +0000</pubDate>
<dc:creator>火山岩上的小红花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duwenlu/p/9044020.html</dc:identifier>
</item>
<item>
<title>格子刷油漆【动态规划问题】—NYOJ 980 - CN_Simo</title>
<link>http://www.cnblogs.com/lxmwb/p/9043996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxmwb/p/9043996.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人博客页：&lt;a href=&quot;https://www.scriptboy.cn/198.html&quot;&gt;&lt;span&gt;https://www.scriptboy.cn/198.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;&quot; href=&quot;http://lx.lanqiao.cn/problem.page?gpid=T38&quot; data-original-title=&quot;&quot;&gt;蓝桥杯&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;X国的一段古城墙的顶端可以看成 2*N个格子组成的矩形（如下图所示），现需要把这些格子刷上保护漆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://lx.lanqiao.cn/RequireFile.do?fid=HLt96rLF&quot; alt=&quot;&quot; data-tag=&quot;bdshare&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以从任意一个格子刷起，刷完一格，可以移动到和它相邻的格子（对角相邻也算数），但不能移动到较远的格子（因为油漆未干不能踩！）&lt;br/&gt;比如：a d b c e f 就是合格的刷漆顺序。&lt;br/&gt;c e f d a b 是另一种合适的方案。&lt;br/&gt;当已知 N 时，求总的方案数。当N较大时，结果会迅速增大，请把结果对 1000000007 (十亿零七) 取模。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;输入数据为一个正整数（不大于1000）&lt;/p&gt;

&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;输出数据为一个正整数。&lt;/p&gt;

&lt;p&gt;样例输入：&lt;/p&gt;

&lt;p&gt;样例输出：&lt;/p&gt;
&lt;div id=&quot;crayon-5afb20d72ba4a191175061&quot; class=&quot;crayon-syntax crayon-theme-eclipse crayon-font-monaco crayon-os-pc print-yes notranslate&quot; data-settings=&quot; minimize scroll-mouseover&quot;&gt;

&lt;div class=&quot;crayon-main&quot;&gt;
&lt;table class=&quot;crayon-table&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;crayon-row&quot;&gt;&lt;td class=&quot;crayon-nums&quot; data-settings=&quot;hide&quot;&gt;

&lt;/td&gt;
&lt;td class=&quot;crayon-code&quot;&gt;
&lt;div class=&quot;crayon-pre&quot;&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;96&lt;/p&gt;
&lt;p&gt;359635897&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;思路：&lt;/p&gt;
&lt;blockquote readability=&quot;12.404340836013&quot;&gt;
&lt;p&gt;固定起点，由于如果起点在中间（第2~N-1列）可以分为左右两边来讨论，这时起点都是角格子。假如&lt;code&gt;a[i]&lt;/code&gt;表示&lt;code&gt;2*i&lt;/code&gt;的格子从左上角开始刷刷完所有格子的方案数（其中i表示列数，&lt;code&gt;1&amp;lt;=i&amp;lt;=N&lt;/code&gt;），有三种刷法刷完所有格子：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先向下刷（即先刷左下角），向下刷完之后有两种方法跳到下一列，刷完剩下的&lt;code&gt;i-1&lt;/code&gt;列需要&lt;code&gt;2*a[i-1]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;向下一列刷，最后刷左下角，可以看出不能同列刷，只能一直向右刷，且在没有到最后一列之前是不能返回，所以刷完所有格子有2^i个方案；（此种情况比较特殊，后面需要还要用到，所以单独用&lt;code&gt;b[i]&lt;/code&gt;存储下来）&lt;/li&gt;
&lt;li&gt;向下一列刷，有两种方案到下一列，然后返回左下角，再刷下一列未刷格子之后，然后有两种方案再到下一列，可见有四种方案到下下列，所以刷完所有格子有&lt;code&gt;4*a[i-2]&lt;/code&gt;个方案；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;总之，就是左下角格子什么时候刷，造成了不同的情况。如果是起点不在角格子上，不难看出，可以将左右两侧分割成&lt;code&gt;2*i&lt;/code&gt;和&lt;code&gt;2*(N-i)&lt;/code&gt;的矩形，需要其中一个矩形使用第2种刷法刷才能回到另一个矩形中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a title=&quot;&quot; href=&quot;https://blog.csdn.net/roosevelty/article/details/50706322&quot; data-original-title=&quot;&quot;&gt;https://blog.csdn.net/roosevelty/article/details/50706322&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AC代码：&lt;/p&gt;
&lt;div id=&quot;crayon-5afb20d72ba4e567023879&quot; class=&quot;crayon-syntax crayon-theme-eclipse crayon-font-monaco crayon-os-pc print-yes notranslate&quot; data-settings=&quot; minimize scroll-mouseover&quot;&gt;


&lt;div class=&quot;crayon-main&quot;&gt;
&lt;table class=&quot;crayon-table&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;crayon-row&quot; readability=&quot;9&quot;&gt;&lt;td class=&quot;crayon-nums&quot; data-settings=&quot;show&quot;&gt;
&lt;div class=&quot;crayon-nums-content&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;p&gt;18&lt;/p&gt;
&lt;p&gt;19&lt;/p&gt;
&lt;p&gt;20&lt;/p&gt;
&lt;p&gt;21&lt;/p&gt;
&lt;p&gt;22&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;24&lt;/p&gt;
&lt;p&gt;25&lt;/p&gt;
&lt;p&gt;26&lt;/p&gt;
&lt;p&gt;27&lt;/p&gt;
&lt;p&gt;28&lt;/p&gt;
&lt;p&gt;29&lt;/p&gt;
&lt;p&gt;30&lt;/p&gt;
&lt;p&gt;31&lt;/p&gt;
&lt;p&gt;32&lt;/p&gt;
&lt;p&gt;33&lt;/p&gt;
&lt;p&gt;34&lt;/p&gt;
&lt;p&gt;35&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;td class=&quot;crayon-code&quot; readability=&quot;19&quot;&gt;
&lt;div class=&quot;crayon-pre&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;&lt;span class=&quot;crayon-p&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-p&quot;&gt;#define mod 1000000007&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-r&quot;&gt;using &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-t&quot;&gt;namespace &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;std&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;crayon-t&quot;&gt;long &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-t&quot;&gt;long &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-cn&quot;&gt;1005&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-sy&quot;&gt;, &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-cn&quot;&gt;1005&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-sy&quot;&gt;, &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;sum&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;crayon-t&quot;&gt;int &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-e&quot;&gt;main&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-sy&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-sy&quot;&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;    &lt;span class=&quot;crayon-t&quot;&gt;int &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;    &lt;span class=&quot;crayon-st&quot;&gt;while&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-v&quot;&gt;cin &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&amp;gt;&amp;gt; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-sy&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;    &lt;span class=&quot;crayon-sy&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-v&quot;&gt;sum &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;0&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-st&quot;&gt;for&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-t&quot;&gt;int &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-sy&quot;&gt;; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&amp;lt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-sy&quot;&gt;; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;++&lt;span class=&quot;crayon-sy&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-sy&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;            &lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;* &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;2 &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;% &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;mod&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-sy&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;6&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-st&quot;&gt;for&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-t&quot;&gt;int &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;3&lt;span class=&quot;crayon-sy&quot;&gt;; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&amp;lt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-sy&quot;&gt;; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;++&lt;span class=&quot;crayon-sy&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-sy&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;            &lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;+ &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-cn&quot;&gt;4 &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;+ &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;            &lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-sy&quot;&gt;] &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;%= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;mod&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-sy&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-v&quot;&gt;sum &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;+= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;4&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;span class=&quot;crayon-h&quot;&gt;  &lt;span class=&quot;crayon-c&quot;&gt;// 四个角的情况&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-c&quot;&gt;// 中间为起点的情况&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-st&quot;&gt;for&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-t&quot;&gt;int &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-sy&quot;&gt;; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&amp;lt; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-sy&quot;&gt;; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;++&lt;span class=&quot;crayon-sy&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-sy&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;            &lt;span class=&quot;crayon-v&quot;&gt;sum &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;+= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-o&quot;&gt;+&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-v&quot;&gt;a&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-o&quot;&gt;*&lt;span class=&quot;crayon-v&quot;&gt;b&lt;span class=&quot;crayon-sy&quot;&gt;[&lt;span class=&quot;crayon-v&quot;&gt;N&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;i&lt;span class=&quot;crayon-o&quot;&gt;+&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;]&lt;span class=&quot;crayon-sy&quot;&gt;)&lt;span class=&quot;crayon-o&quot;&gt;%&lt;span class=&quot;crayon-v&quot;&gt;mod&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-sy&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-st&quot;&gt;if&lt;span class=&quot;crayon-sy&quot;&gt;(&lt;span class=&quot;crayon-v&quot;&gt;N &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;== &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;1&lt;span class=&quot;crayon-sy&quot;&gt;) &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;sum &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;= &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;2&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;        &lt;span class=&quot;crayon-r&quot;&gt;cout &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&amp;lt;&amp;lt; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;sum &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;%&lt;span class=&quot;crayon-v&quot;&gt;mod &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-o&quot;&gt;&amp;lt;&amp;lt; &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;endl&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;    &lt;span class=&quot;crayon-sy&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-h&quot;&gt;    &lt;span class=&quot;crayon-st&quot;&gt;return &lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-cn&quot;&gt;0&lt;span class=&quot;crayon-sy&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-sy&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 15 May 2018 18:07:00 +0000</pubDate>
<dc:creator>CN_Simo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxmwb/p/9043996.html</dc:identifier>
</item>
<item>
<title>mysql在ubuntu中的操作笔记(详) - 汪凡</title>
<link>http://www.cnblogs.com/wf-skylark/p/9043904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wf-skylark/p/9043904.html</guid>
<description>
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;block&quot;&gt;

&lt;div class=&quot;post&quot;&gt;
&lt;div class=&quot;postcontent&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;
&lt;h2&gt;&lt;span&gt;1.安装&lt;/span&gt;mysql&lt;span&gt;客户端流程：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　-  &lt;span&gt;登录&lt;/span&gt;&lt;span&gt;navicat&lt;/span&gt;&lt;span&gt;官网下载&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　-  &lt;span&gt;将压缩包拷贝&lt;/span&gt;&lt;span&gt;ubuntu&lt;/span&gt;&lt;span&gt;中进行解压，解压命令：&lt;/span&gt;&lt;span&gt;tar zxvf navicat.tar.gz&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232017405-1080286329.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　-  &lt;span&gt;进入解压目录，运行命令&lt;/span&gt;&lt;span&gt;./start_navicatt&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232048610-978381401.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232140756-189383835.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;252&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　-  &lt;span&gt;如果试用是灰色的则进行下一步&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　-  删除 .navicat64/ &lt;span&gt;隐藏文件，再次运行即可&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232304022-1483994477.png&quot; alt=&quot;&quot;/&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232331192-1174480335.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　-  &lt;span&gt;如果试用界面是乱码的则修改配置文件&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;改成如下形式&lt;/span&gt;&lt;span&gt;(vim&lt;/span&gt;&lt;span&gt;常用操作请查看我的另一篇随记&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232434341-860546397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232607865-40633075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　-  &lt;span&gt;再次执行第三步操作即可，试用到期可再次删除那个隐藏文件&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt;2.ubuntu&lt;span&gt;下安装&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　-  sudo apt-get install mysql-server&lt;/h3&gt;
&lt;h2&gt;3.验证安装结果&lt;/h2&gt;
&lt;h3&gt;　　-  &lt;span&gt;命令：&lt;/span&gt;&lt;span&gt;ps aux|grep mysql&lt;/span&gt;，跟下图一样则说明安装成功&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232644810-1162310082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.mysql&lt;span&gt;数据库运行状态&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　- 4.1  sudo service mysql status  &lt;span&gt;查看数据库运行状态&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;绿点 正在运行  &lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232919417-1226219840.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　- &lt;span&gt;白点 停止运行&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515232958211-41919197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 4.2  sudo service mysql start   &lt;span&gt;启动数据库服务&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233124052-1055825752.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt;　　- 4.3  sudo service mysql stop    &lt;span&gt;停止数据库服务&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233129197-1406844549.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt;　　- 4.4  sudo service mysql restart &lt;span&gt;重启数据库服务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233135691-197440619.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 5. &lt;span&gt;登录数据库&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　- 5.1  通过客户端软件登录，&lt;span&gt;详见步骤&lt;/span&gt;1&lt;/h3&gt;
&lt;h3&gt;　　- 5.2  通过命令登录&lt;/h3&gt;
&lt;h4&gt;  　　　　- &lt;span&gt;登录远程主机：&lt;/span&gt;mysql [-h 192.168.205.129 –P 3306] –uroot -p&lt;/h4&gt;
&lt;h4&gt;　　　　- h &lt;span&gt;连接服务端数据库的&lt;/span&gt;IP&lt;span&gt;地址&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- P(&lt;span&gt;大写&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;连接的端口号，一般为&lt;/span&gt;&lt;span&gt;3306&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- u 用户权限&lt;/h4&gt;
&lt;h4&gt;　　　　- p(&lt;span&gt;小写&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;输入密码，一般为&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　　　登陆成功：&lt;/span&gt;  &lt;/h4&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233336251-65438441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6. 退出数据库客户端&lt;/h2&gt;
&lt;h3&gt;　　-  exit、quit、ctrl+d&lt;/h3&gt;
&lt;h2&gt;&lt;span&gt;7. 配置&lt;/span&gt;msyql&lt;span&gt;服务允许远程登录访问&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　- 7.1 数据文件夹：&lt;/h3&gt;
&lt;h3&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233532352-773766615.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;123&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt; 　　&lt;/h3&gt;
&lt;h3&gt;　　　　&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;　　- 7.2 数据库配置文件：&lt;/h3&gt;
&lt;h3&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233542945-1230766876.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;138&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt;　　- 7.3 &lt;span&gt;关闭防火墙&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;pre&quot;&gt;　　　　- sudo apt-get install ufw 安装防火墙&lt;/h4&gt;
&lt;h4 class=&quot;pre&quot;&gt;　　　　- sudo ufw enable 打开防火墙&lt;/h4&gt;
&lt;h4 class=&quot;pre&quot;&gt;　　　　- sudo ufw status 查看防火墙状态&lt;/h4&gt;
&lt;h4 class=&quot;pre&quot;&gt;　　　　- sudo ufw disable 关闭防火墙&lt;/h4&gt;
&lt;h3&gt;　　- 7.4 更改配置文件的bind-address&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;进入配置文件&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233607231-1003643506.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;修改&lt;/span&gt;&lt;span&gt;mysqld.cnf&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;bind-addres，首先给用户可执行权限&lt;/h4&gt;
&lt;h4&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233618242-1709251859.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;再次使用&lt;/span&gt;&lt;span&gt;vim&lt;/span&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;bind-address&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233633671-517293777.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;修改成功&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;再把文件权限改回去&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515233824396-185162660.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　-7.5 &lt;span&gt;修改权限&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- 权限 update `user` set host=”%” where user=”root”&lt;/h4&gt;
&lt;h4&gt;　　　　- 允许指定用户访问：&lt;/h4&gt;
&lt;h4&gt;　　　　GRANT ALL PRIVILEGES ON *.* TO 'root'@'10.10.11.12' IDENTIFIED BY 'FEFJay' WITH GRANT OPTION; 　　　　flush privileges;(IP&lt;span&gt;这里，可以使用&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;来表示所有&lt;/span&gt;&lt;span&gt;IP)&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;重启服务即可&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt;8. 创建数据库&lt;/h2&gt;
&lt;h3&gt;　　- 8.1 &lt;span&gt;使用客户端软件创建数据库&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　- 8.2 &lt;span&gt;使用命令创建数据库&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　-  create database &lt;span&gt;数据库名&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　-  create database &lt;span&gt;数据库名&lt;/span&gt; &lt;span&gt;character set utf8&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　-  show create database &lt;span&gt;数据库名&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 8.3 修改数据库编码&lt;/h3&gt;
&lt;h4&gt;　　　　-  alter database &lt;span&gt;数据库名&lt;/span&gt; &lt;span&gt;character set utf8&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 8.4 删除数据库&lt;/h3&gt;
&lt;h4&gt;　　　　-  drop database &lt;span&gt;数据库名&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 8.5 切换、使用数据库&lt;/h3&gt;
&lt;h4 class=&quot;18&quot;&gt;　　　　 -  use &lt;span&gt;数据库名&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 8.6 显示当前数据库&lt;/h3&gt;
&lt;h4&gt;　　　　-  select database()&lt;/h4&gt;
&lt;h3&gt;　　- 8.7 展示所有数据库&lt;/h3&gt;
&lt;h4&gt;　　　　-  show databases&lt;/h4&gt;
&lt;h2&gt;9. 创建数据表&lt;/h2&gt;
&lt;h3&gt;　　- 9.1 &lt;span&gt;使用命令创建数据表&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　-  create table &lt;span&gt;表名&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　(&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　　　字段&lt;/span&gt;1 &lt;span&gt;字段类型&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　　　字段&lt;/span&gt;2 &lt;span&gt;字段类型&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;　　　　字段&lt;/span&gt;3 &lt;span&gt;字段类型&lt;/span&gt;……&lt;/h4&gt;
&lt;h4&gt;　　　　)&lt;/h4&gt;
&lt;h3&gt;　　- 9.2 &lt;span&gt;常用数据字段类型&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;整数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515234149861-1139029595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　- &lt;span&gt;小数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515234157753-1480375168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　- &lt;span&gt;字符串&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515234202005-398410476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　- &lt;span&gt;日期时间类型&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515234206531-1238952141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180515234218299-244859179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　- &lt;span&gt;枚举&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt;10.查询&lt;/h2&gt;
&lt;h3&gt;　　- 10.1 查询数据表中全部的行和列&lt;/h3&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- select col1,col2,col3….from table&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- select * from table&lt;/h4&gt;
&lt;h3 class=&quot;17&quot;&gt;　　- 10.2 查询表的部分列&lt;/h3&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- select col1,col2,col3…from table&lt;/h4&gt;
&lt;h3 class=&quot;17&quot;&gt;　　- 10.3 给查询出来的数据列设置别名&lt;/h3&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- select col1 as “&lt;span&gt;别名&lt;/span&gt;1”,col2 as ‘&lt;span&gt;别名&lt;/span&gt;2’…from table&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- select col1 ‘&lt;span&gt;别名&lt;/span&gt;1’,col2 ‘&lt;span&gt;别名&lt;/span&gt;2’….from table&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 注意多表查询重名问题&lt;/h4&gt;
&lt;h3 class=&quot;17&quot;&gt;　　- 10.4 DISTINCT&lt;span&gt;关键字的使用&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 作用：消除结果集中的重复数据&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;select distinct col from table&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 注意：要求所有的字段都相同才会去重&lt;/h4&gt;
&lt;h3 class=&quot;17&quot;&gt;　　- 10.5 LIMIT&lt;span&gt;关键字的使用&lt;/span&gt;&lt;/h3&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 作用：指定结果的显示范围&lt;/h4&gt;
&lt;h4&gt;　　　　- 语法：&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　-  select * from table limit m,n&lt;/h4&gt;
&lt;h4&gt;　　　　　　m&lt;span&gt;：起始的位置&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　　　n&lt;span&gt;：显示的数量&lt;/span&gt;&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　-  select * from table limit m&lt;/h4&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　　　m:&lt;span&gt;从第一条开始共显示&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;条数据&lt;/span&gt; &lt;/h4&gt;
&lt;h2&gt;11. 插入数据&lt;/h2&gt;
&lt;h3&gt;　　- 11.1 所有列都插入值&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;insert into table values(v1,v2,v3….)&lt;/h4&gt;
&lt;h4&gt;　　　　- 特点：列值同数，列值同序&lt;/h4&gt;
&lt;h3&gt;　　- 11.2 为指定列插入值&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;insert into table(col1,col2,col3) values(v1,v2,v3)&lt;/h4&gt;
&lt;h4&gt;　　　　- 特点：指定顺序，列值对应&lt;/h4&gt;
&lt;h3&gt;　　- 11.3 一次性插入多条记录&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;insert into table(co1,col2,col3…)values&lt;/h4&gt;
&lt;h4&gt;　　　　　　　　(v1,v2,v3),&lt;/h4&gt;
&lt;h4&gt;　　　　　　　　(v1,v2,v3),&lt;/h4&gt;
&lt;h4&gt;　　　　　　　　(v1,v3,v3)…..&lt;/h4&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;12.&lt;/span&gt;&lt;/strong&gt;修改数据&lt;/h2&gt;
&lt;h3&gt;　　- 12.1 修改指定数据&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;update table set {col1=value1}[…n]where expressioin&lt;/h4&gt;
&lt;h3&gt;　　- 12.2 修改全部数据&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;update table set {col1=value1}[…n]&lt;/h4&gt;
&lt;h2&gt;13. 删除数据&lt;/h2&gt;
&lt;h3&gt;　　- 13.1 &lt;span&gt;使用&lt;/span&gt;delete&lt;span&gt;命令删除数据&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;delete from table where expression&lt;/h4&gt;
&lt;h3&gt;　　- 13.2 逻辑删除&lt;/h3&gt;
&lt;h3&gt;　　- 13.3 &lt;span&gt;使用&lt;/span&gt;truncate&lt;span&gt;命令删除数据&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- truncate table&lt;/h4&gt;
&lt;h3&gt;　　- 13.4 &lt;span&gt;区别&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;语句删除数据，自动编号没有恢复到默认值。但是&lt;/span&gt;&lt;span&gt;truncate&lt;/span&gt;&lt;span&gt;重新设置了自动编号&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;通过&lt;/span&gt;&lt;span&gt;truncate&lt;/span&gt;&lt;span&gt;语句删除数据表数据，不能根据条件删除，而是一次性删除，&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;语句可以根据条件进行删除&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　- &lt;span&gt;truncate&lt;/span&gt;&lt;span&gt;在清空表中数据的时候，速度要比&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;语句快的多&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt;14. 对列进行增删改查&lt;/h2&gt;
&lt;h3&gt;　　- 14.1  &lt;span&gt;增加一列&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- alter table tablename add &lt;span&gt;列名 数据类型&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 14.2  删除一列&lt;/h3&gt;
&lt;h4&gt;　　　　- alter table tablename drop column &lt;span&gt;列名&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 14.3 修改列的数据类型&lt;/h3&gt;
&lt;h4&gt;　　　　- alter table tablename modify &lt;span&gt;列名 数据类型&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　-14.4 修改列的数据类型并且改名&lt;/h3&gt;
&lt;h4&gt;　　　　- alter table tablename change old_colname new_colname &lt;span&gt;数据类型&lt;/span&gt;&lt;/h4&gt;
&lt;h2&gt;15. 约束&lt;/h2&gt;
&lt;h3&gt;　　- &lt;span&gt;问题&lt;/span&gt;1&lt;span&gt;：数据冗余&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516000416449-1941587482.png&quot; alt=&quot;&quot; width=&quot;556&quot; height=&quot;452&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 问题2：失去了完整性&lt;/h3&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516000429241-1224208677.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 问题3：数据缺少唯一标识&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516000503420-415794891.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 问题4：失去了实体完整性&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516000508741-1979177742.png&quot; alt=&quot;&quot; width=&quot;730&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 问题5：失去了引用完整性&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516000517581-289251200.png&quot; alt=&quot;&quot; width=&quot;760&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 问题6：失去了域完整性&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516000525085-2136529870.png&quot; alt=&quot;&quot; width=&quot;768&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 15.1 约束概念：限定数据库中数据的一套规则&lt;/h3&gt;
&lt;h3&gt;　　- 15.2 约束作用：保证数据的准确性、完整性、可靠性、联动性&lt;/h3&gt;
&lt;h3&gt;　　- 15.3 数据库常用约束：&lt;/h3&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 主键约束&lt;/h4&gt;
&lt;h5&gt;　　　　　　- 作用：让数据具有唯一标识&lt;/h5&gt;
&lt;h5&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table table_primarykey&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　id int primary key&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h5&gt;　　　　　　- 特点：自动设置非空约束&lt;/h5&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 自动增长&lt;/h4&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 作用：使数据自动增长，一般给主键设置&lt;/h5&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　　　　　create table table_autoincrement&lt;/h5&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　id int primary key auto_increment&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 唯一约束&lt;/h4&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 作用：保证数据的准确性&lt;/h5&gt;
&lt;h5&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table table_unique&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　qqnumber int unique&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h5&gt;　　　　　　- 特点：可以为多列设置唯一约束&lt;/h5&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 非空约束&lt;/h4&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 作用：保证数据不为空&lt;/h5&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table table_notnull&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　name varchar(30) not null&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 默认约束&lt;/h4&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 作用：给字段设置默认值&lt;/h5&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table table_default&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　sex char(2) default ‘男’&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h4 class=&quot;17&quot;&gt;　　　　- 检查约束&lt;/h4&gt;
&lt;h5 class=&quot;17&quot;&gt;　　　　　　- 作用：检查数据的完整性&lt;/h5&gt;
&lt;h5&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table table_check&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　sex char(2) check(‘男’ or ‘女’)&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table table_enum&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　sex enum(‘男’,’女’) &lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h4&gt;　　　　- 外键约束&lt;/h4&gt;
&lt;h5&gt;　　　　　　- 作用：让两表之间产生联动关系&lt;/h5&gt;
&lt;h5&gt;　　　　　　- 语法：&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table class&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　id int primary key auto_increment,&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　classname varchar(30) not null&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　) &lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　create table score&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　(&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　id int primary key auto_increment,&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　chinese_score int not null,&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　foreign key(id) references class(id)&lt;/h5&gt;
&lt;h5&gt;　　　　　　　　　　)&lt;/h5&gt;
&lt;h5&gt;　　　　　　- &lt;span&gt;要想删除&lt;/span&gt;class&lt;span&gt;表和&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;表，首先要删除&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;表&lt;/span&gt;&lt;/h5&gt;
&lt;h2&gt;16. 为数据增补约束&lt;/h2&gt;
&lt;h3&gt;　　- 16.1 &lt;span&gt;添加&lt;/span&gt;/&lt;span&gt;删除主键约束&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- 添加主键约束&lt;/h4&gt;
&lt;h4&gt;　　　　　　- &lt;span&gt;语法：&lt;/span&gt;alter table table_name add constrain con_name primary key(col_name)&lt;/h4&gt;
&lt;h4&gt;　　　　- 删除主键约束&lt;/h4&gt;
&lt;h3&gt;　　- 16.2 外键约束&lt;/h3&gt;
&lt;h4&gt;　　　　- 添加外键约束&lt;/h4&gt;
&lt;h4&gt;　　　　　　- &lt;span&gt;语法：&lt;/span&gt;alter table table_name add constrain con_name foreign key(col_name) references table(col_name)&lt;/h4&gt;
&lt;h4&gt;　　　　- 删除外键约束 &lt;/h4&gt;
&lt;h3&gt;　　- 16.3 检查约束&lt;/h3&gt;
&lt;h4&gt;　　　　- 添加检查约束&lt;/h4&gt;
&lt;h4&gt;　　　　　　- &lt;span&gt;语法：&lt;/span&gt;alter table table_name add constraint con_name check(expression)&lt;/h4&gt;
&lt;h4&gt;　　　　- 删除检查约束&lt;/h4&gt;
&lt;h3&gt;　　- 16.4 &lt;span&gt;默认约束&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- 添加默认约束&lt;/h4&gt;
&lt;h4&gt;　　　　　　- &lt;span&gt;语法：&lt;/span&gt;alter table table_name alter col_name default value&lt;/h4&gt;
&lt;h4&gt;　　　　- 删除默认约束&lt;/h4&gt;
&lt;h3&gt;　　- 16.5 &lt;span&gt;自动增长&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- 添加自动增长&lt;/h4&gt;
&lt;h4&gt;　　　　　　- &lt;span&gt;语法：&lt;/span&gt;alter table table_name modify column col_name type auto_increment&lt;/h4&gt;
&lt;h4&gt;　　　　- 删除自动增长&lt;/h4&gt;
&lt;h2&gt;17. 条件查询&lt;/h2&gt;
&lt;h3&gt;　　- 17.1 普通条件查询&lt;/h3&gt;
&lt;h4&gt;　　　　- &lt;span&gt;语法：&lt;/span&gt;select * from table where expression&lt;/h4&gt;
&lt;h4&gt;　　　　- where&lt;span&gt;：将查询到的数据，通过&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;后的&lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;一条一条的进行筛选，符合要求则显示，不符合要求则去除。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516001740464-193016972.png&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;295&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516001746675-1623421580.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 17.2 模糊查询&lt;/h3&gt;
&lt;h4&gt;　　　　- 语法：&lt;/h4&gt;
&lt;h4&gt;　　　　　　-  between….and….&lt;/h4&gt;
&lt;h4&gt;　　　　　　-  &lt;span&gt;范围查询&lt;/span&gt;  in &lt;span&gt;、&lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;　　　　　　-  like &lt;span&gt;通配符&lt;/span&gt; &lt;span&gt;%&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;　　- 17.3 查询空值的运算符&lt;/h3&gt;
&lt;h4&gt;　　　　- is null&lt;/h4&gt;
&lt;h2&gt;18. 数据排序&lt;/h2&gt;
&lt;h3&gt;　　- 作用：对查询出的数据进行升序或降序排列&lt;/h3&gt;
&lt;h3&gt;　　- &lt;span&gt;语法：&lt;/span&gt;select col11,col2,col3…from table order by order_by_collist[asc/desc]&lt;/h3&gt;
&lt;h3&gt;　　- 18.1 多列排序：&lt;/h3&gt;
&lt;h4&gt;　　　　- 关注点：升序、降序、优先级&lt;/h4&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516001949697-1310199032.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 19. 数据分组&lt;/h2&gt;
&lt;h3&gt;　　- &lt;span&gt;语法：&lt;/span&gt;select col1..col2.. from table Group by col&lt;span&gt;分组配合排序&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　- &lt;span&gt;注意：如果使用了&lt;/span&gt;group by&lt;span&gt;分组，那么&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;不允许出现其他列，除非这些列包含在分组中&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt;20. 聚合函数&lt;/h2&gt;
&lt;h3&gt;　　- &lt;span&gt;作用：对多条数据做统计功能&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　- &lt;span&gt;注意：在使用聚合函数后，&lt;/span&gt;select&lt;span&gt;后不允许出现其他列，除非这些列包含在分组中或者聚合函数中&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516002132515-300332188.png&quot; alt=&quot;&quot; width=&quot;739&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 20.1 &lt;span&gt;常用聚合函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516002145946-425165025.png&quot; alt=&quot;&quot; width=&quot;745&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 20.2 &lt;span&gt;聚合函数与&lt;/span&gt;Group by&lt;span&gt;语句配合使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516002207715-2120776434.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;21. Having by&lt;span&gt;语句&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　- &lt;span&gt;作用：&lt;/span&gt;having by&lt;span&gt;为&lt;/span&gt;&lt;span&gt;group by&lt;/span&gt;&lt;span&gt;之后得到数据进行进一步的筛选&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　- &lt;span&gt;类似于&lt;/span&gt;select &lt;span&gt;和&lt;/span&gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt;的关系。&lt;/span&gt;Where&lt;span&gt;为&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;后的数据进行进一步的筛选。&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　　　- Having by &lt;span&gt;为&lt;/span&gt;&lt;span&gt;group by&lt;/span&gt;&lt;span&gt;后的数据进行筛选&lt;/span&gt;&lt;/h3&gt;
&lt;h2&gt;22. Limit&lt;span&gt;关键字的使用&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　- 语法：&lt;/h3&gt;
&lt;h4&gt;　　　　select * from table limit m&lt;/h4&gt;
&lt;h4&gt;　　　　select * from table limit m,n&lt;/h4&gt;
&lt;h2&gt;23. sql&lt;span&gt;语句执行顺序&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;　　— from &lt;span&gt;表名&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;　　— where&lt;/h3&gt;
&lt;h3&gt;　　— group by&lt;/h3&gt;
&lt;h3&gt;　　— select distinct *&lt;/h3&gt;
&lt;h3&gt;　　— having&lt;/h3&gt;
&lt;h3&gt;　　— order by&lt;/h3&gt;
&lt;h3&gt;　　— limit&lt;/h3&gt;
&lt;h2&gt;24. 连接查询&lt;/h2&gt;
&lt;h3&gt;　　- 当查询结果的数据来自多张表的时候，需要将多张表连接成一个大的数据集，再选择合适的列进行返回。&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516002405930-1425809462.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516002411441-319254688.png&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180516002416440-1358644425.png&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　- 24.1 内连接：选择两种表中交叉的数据进行返回&lt;/h3&gt;
&lt;h3&gt;　　- 24.2 左连接：选择左表全部数据以及右边中和左表相同的数据&lt;/h3&gt;
&lt;h3&gt;　　- 24.3 右连接：选择右表全部数据以及左表中和右表相同的数据&lt;/h3&gt;
&lt;h3&gt;　　- 24.4 笛卡尔积：两张表数据行的乘积&lt;/h3&gt;
&lt;h2&gt;25. 自关联&lt;/h2&gt;
&lt;h3&gt;　　- &lt;span&gt;概念：&lt;/span&gt;让某张表自己和自己进行连接。&lt;/h3&gt;
&lt;h2&gt;26. 子查询&lt;/h2&gt;
&lt;h3&gt;　　- &lt;span&gt;概念：&lt;/span&gt;将一个查询结果在另一个查询中使用，称之为子查询。&lt;/h3&gt;
&lt;h3&gt;　　- &lt;span&gt;语法：&lt;/span&gt;select * from (select col1,col2,col3 from table) as t&lt;/h3&gt;
&lt;h3&gt;　　- 26.1 子查询分类&lt;/h3&gt;
&lt;h4&gt;　　　　- 独立子查询：&lt;/h4&gt;
&lt;h5&gt;　　　　　　- 子查询可以独立运行&lt;/h5&gt;
&lt;h4&gt;　　　　- 相关子查询：&lt;/h4&gt;
&lt;h5&gt;　　　　　　- 子查询中引用了父查询的结果或者父查询中引用了子查询的结果，子查询和父查询都不可以独立运行&lt;/h5&gt;
&lt;h3&gt;　　-26.2 &lt;span&gt;子查询注意点：&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;　　　　- 如果主查询使用到子查询的数据，则必须给子查询起一个表名。&lt;/h4&gt;
&lt;h4&gt;　　　　- 在子查询使用关系运算符的时候要注意，因为子查询有可能返回多个值。&lt;/h4&gt;
&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;



&lt;/div&gt;
</description>
<pubDate>Tue, 15 May 2018 16:40:00 +0000</pubDate>
<dc:creator>汪凡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wf-skylark/p/9043904.html</dc:identifier>
</item>
<item>
<title>Java 8之重新认识HashMap - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/9043893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/9043893.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;摘要（面试必问题之HashMap）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨&lt;/p&gt;
&lt;p&gt;HashMap的结构实现和功能原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515232318350-1242055938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;java.util.map类图&lt;/p&gt;
&lt;p&gt;下面针对各个实现类的特点做一些说明：&lt;/p&gt;
&lt;p&gt;(1) HashMap：它根据键的hashCode&lt;span&gt;值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。&lt;/span&gt; HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap&lt;span&gt;，可能会导致数据的不一致。如果需要满足线程安全，可以用&lt;/span&gt; Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。&lt;/p&gt;
&lt;p&gt;(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。&lt;/p&gt;
&lt;p&gt; (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 &lt;/p&gt;
&lt;p&gt;(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。&lt;/p&gt;
&lt;p&gt;对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。&lt;/p&gt;
&lt;p&gt;   通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;内部实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;存储结构-字段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515232734606-634696342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;hashMap内存结构图&lt;/p&gt;
&lt;p&gt;这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？&lt;/p&gt;
&lt;p&gt;(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]&lt;span&gt;是何物。&lt;/span&gt; static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {&lt;/p&gt;
&lt;p&gt;final int hash; //用来定位数组索引位置 final K key;&lt;/p&gt;
&lt;p&gt;   V value;&lt;/p&gt;
&lt;p&gt;Node&amp;lt;K,V&amp;gt; next; //链表的下一个node&lt;/p&gt;
&lt;p&gt;Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) { ... }&lt;/p&gt;
&lt;p&gt;public final K getKey(){ ... }&lt;/p&gt;
&lt;p&gt;   public final V getValue() { ... }&lt;/p&gt;
&lt;p&gt;public final String toString() { ... }&lt;/p&gt;
&lt;p&gt;public final int hashCode() { ... }&lt;/p&gt;
&lt;p&gt;   public final V setValue(V newValue) { ... }&lt;/p&gt;
&lt;p&gt;public final boolean equals(Object o) { ... }&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。&lt;/p&gt;
&lt;p&gt;(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：&lt;/p&gt;
&lt;p&gt;map.put(&quot;美团&quot;,&quot;小美&quot;);&lt;/p&gt;
&lt;p&gt;系统将调用&quot;美团&quot;这个key的hashCode()方法得到其hashCode &lt;span&gt;值（该方法适用于每个&lt;/span&gt;Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。&lt;/p&gt;
&lt;p&gt; 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：&lt;/p&gt;
&lt;p&gt; int threshold; // 所能容纳的key-value对极限&lt;/p&gt;
&lt;p&gt;final float loadFactor;// 负载因子&lt;/p&gt;
&lt;p&gt;int modCount;&lt;/p&gt;
&lt;p&gt;int size;&lt;/p&gt;
&lt;p&gt;  首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。&lt;/p&gt;
&lt;p&gt;结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。&lt;/p&gt;
&lt;p&gt;在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考&lt;a href=&quot;http://blog.csdn.net/liuqiyao_01/article/details/14475159&quot;&gt;http://blog.csdn.net/liuqiyao_01/article/details/14475159&lt;/a&gt;，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。&lt;/p&gt;
&lt;p&gt;这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap&lt;span&gt;的性能，其中会用到红黑树的&lt;/span&gt; 插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考&lt;a href=&quot;http://blog.csdn.net/v_july_v/article/details/6105630&quot;&gt;http://blog.csdn.net/v_july_v/article/details/6105630&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;功能实现-方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;  1. 确定哈希桶数组索引位置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span&gt;方法一：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; static final int hash(Object key) { //jdk1.8 &amp;amp; jdk1.7&lt;/p&gt;
&lt;p&gt;int h;&lt;/p&gt;
&lt;p&gt; // h = key.hashCode() 为第一步取hashCode值&lt;/p&gt;
&lt;p&gt; // h ^ (h &amp;gt;&amp;gt;&amp;gt; 16) 为第二步高位参与运算&lt;/p&gt;
&lt;p&gt; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/p&gt;
&lt;p&gt; } &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方法二：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;static int indexFor(int h, int length) { //jdk1.7&lt;span&gt;的源码，&lt;/span&gt;jdk1.8&lt;span&gt;没有这个方法，但是实现原理一样的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   return h &amp;amp; (length-1); //第三步取模运算&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。&lt;/p&gt;
&lt;p&gt;这个方法非常巧妙，它通过h &amp;amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n&lt;span&gt;次方时，&lt;/span&gt; h&amp;amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;amp;比%具有更高的效率。在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。&lt;/p&gt;
&lt;p&gt;下面举例说明下，n为table&lt;span&gt;的长度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515233953159-1608589145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hashMap哈希算法例图&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 分析HashMap的put方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515234038496-1995018455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hashMap put方法执行流程图&lt;/p&gt;
&lt;p&gt;①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；&lt;/p&gt;
&lt;p&gt;②. .根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；&lt;/p&gt;
&lt;p&gt;③. .判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；&lt;/p&gt;
&lt;p&gt;④.判断table[j]是否为treeNode ,即table[门是否是红黑树,如果是红黑树,则直接在树中插入键值对，否则转向⑤;&lt;br/&gt;⑤.遍历table[j] ,判断链表长度是否大于8 ,大于8的话把链表转换为红黑树，在红黑树中执行插入操作,否则进行链表的插入操作;遍历过程中若发现key已经存在直接覆盖value即可;&lt;br/&gt;⑥插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold ,如果超过，进行扩容。&lt;br/&gt;  JDK1.8HashMap的put方法源码如下:&lt;/p&gt;

&lt;div readability=&quot;18&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515234828651-554303669.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515234915476-1256210087.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515235051284-76711107.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;  3.扩容机制&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;  扩容(resize)就是重新计算容量,向HashMap对象里不停的添加元素,而HashMap对象内部的数组无法装载更多的元素时,对象就需要扩大数组的长度,以便能装入更多的元素。当然Java里的数组是无法自动扩容的,方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水,如果想装更多的水,就得换大水桶。&lt;br/&gt;  我们分析下resize的源码，鉴于JDK1 8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一一些，本质上区别不大,具体区别后文再说。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515235338922-672709453.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;   这里就是使用一个容量更大的数组来代替已有的容量小的数组, transfer(方法将原有Entry数组的元素拷贝到新的Entry数组里。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515235504941-455287686.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;39.5&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180515235526656-1829701179.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;newTable们j]的引用赋给了e.next ,也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置;这样先放在-一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话) , 这一点和dk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素,通过重新计算索引位置后,有可能被放到了新数组的不同位置上。&lt;br/&gt;下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod -下表的大小(也就是数组的长度)。其中的哈希桶数组table的size=2,所以key=3、7、5, put顺序依次为5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子loadFactor=1 ,即当键值对的实际大小size大于table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组resize成4 ,然后所有的Node重新rehash的过程。&lt;/p&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000034582-1471869499.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍) ,所以，元素的位置要么是在原位置,要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思, n为table的长度,图(a )表示扩容前的key1和key2两种key确定索引位置的示例，图(b)表示扩容后key1和key2两种key确定索引|位置的示例,其中hash1是key1对应的哈希与高位运算结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000216219-1492640315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;p&gt;  元素在重新计算hash之后,因为n变为2倍,那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化: &lt;/p&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000340828-1721582901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 因此，我们在扩充HashMap的时候,不需要像JDK1.7的实现那样重新计算hash ,只需要看看原来的hash值新增的那个bit是1还是0就好了,是0的话索引没变,是1的话索引变成“原索引+oldCap”,可以看看下图为16扩充为32的resize示意图:&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000456727-1710660986.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt; 这个设计确实非常的巧妙，既省去了重新计算hash值的时间,而且同时,由于新增的1bit是0还是1可以认为是随机的,因此resize的过程,均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1 8新增的优化点。有一点注意区别, JDK1.7中rehash的时候，旧链表迁移新链表的时候,如果在新表的数组索引|位置相同,则链表元素会倒置,但是从上图可以看出，JDK1.8不会倒置。有兴趣的可以研究下JDK1 8的resize源码,写的很赞,如下:&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000626726-1843138091.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;83.5&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000705684-28458130.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000757154-1581072877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000820090-946277313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   线程安全性&lt;br/&gt;  在多线程使用场景中,应该尽量避免使用线程不安全的HashMap ,而使用线程安全的&lt;br/&gt;  ConcurrentHashMap。那么为什么说HashMap是线程不安全的,下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解,仍然使用JDK1.7的环境) :&lt;/p&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516000950028-1304685155.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001015499-1730213157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 其中, map初始化为一个长度为2的数组, loadFactor=0.75 , threshold=2*0.75=1,也就是说当put第二个key的时候 , map就需要进行resize.&lt;br/&gt;通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的 &quot;Entry next=e.next;,&quot;这一行;然后放开线程2的的断点,让线程2进行resize。结果如下图。&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001134563-1166535323.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;   注意, Thread1的e指向了key(3),而next指向了key(7),其在线程二.rehash后, 指向了线程二重组后的链表。&lt;br/&gt;  线程一被调度回来执行,先是执行newTalbe[j] = e,然后是e = next,导致了e指向了key(7) ,而下一-次循环的next = e.next导致了next指向了key(3)。 &lt;/p&gt;
&lt;/div&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001311894-1016993313.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001336034-1163508786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 于是，当我们用线程一调用map.get(11)时 ,悲剧就出现了一Infinite Loop。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK1.8与JDK1.7的性能对比&lt;/strong&gt;&lt;br/&gt;HashMap中,如果key经过hash算法得出的数组索引|位置全部不相同,即Hash算法非常好，那样的话, getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置-样,那样所有的键值对都集中到一个桶中,或者在一个链表中,或者在一一个红黑树中,时间复杂度分别为O(n)和O(lgn)。鉴于JDK1.8做 了多方面的优化,总体性能优于JDK1.7 ,下面我们从两个方面用例子证明这一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hash较均匀的情况&lt;/strong&gt;&lt;br/&gt;为了便于测试，我们先写一个类Key,如下:&lt;/p&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001602474-1384799871.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001621665-335093444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;  这个类复写了equals方法，并且提供了相当好的hashCode函数,任何一个值的hashCode都不会相同,因为直接使用value当做hashcode。为了避免频繁的GC ,我将不变的Key实例缓存了起来，而不是一遍-遍的创建它们。代码如下: &lt;/p&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001758382-1002139312.png&quot; alt=&quot;&quot;/&gt;&lt;div readability=&quot;24.5&quot;&gt;&lt;p&gt;  现在开始我们的试验,测试需要做的仅仅是,创建不同size的HashMap(1、10、100、...10000000屏蔽了扩容的情况，代码如下:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001911563-1802779455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516001931775-1379550256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在测试中会查找不同的值,然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间,除以key的数量,计算一个平均值,主要用来比较,绝对值可能会受很多环境因素的影响。结果如下:&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516002033253-763088112.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 通过观测测试结果可知, JDK1.8的性能要高于JDK1.715%以上,在某些size的区域上，甚至高于100%。由于Hash算法较均匀, JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hash极不均匀的情况&lt;/strong&gt;&lt;br/&gt;假设我们又一一个非常差的Key,它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下:&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516002157032-1612645345.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 仍然执行main方法,得出的结果如下表所示: &lt;/p&gt;
&lt;div readability=&quot;29&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398504/201805/1398504-20180516002309704-724469217.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 从表中结果中可知，随者isize的变大，JDK1.7的花费时间是增长的趋势,而JDK1.8是明显的降低趋势,并且呈现对数增长稳定。当一个链表太长的时候, HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同,这两种情况的相对比较,可以说明一一个好的hash算法的重要性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;(1)扩容是一个特别耗性能的操作,所以当程序员在使用HashMap的时候，估算map的大小,初始化的时候给一个大致的数值,避免map进行频繁的扩容。&lt;br/&gt;(2)负载因子是可以修改的,也可以大于1，但是建议不要轻易修改,除非情况非常特殊。&lt;/p&gt;
&lt;p&gt;(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap ,建议使用ConcurrentHashMap.&lt;/p&gt;
&lt;/div&gt;
(4)JDK1.8引入红黑树大程度优化了HashMap的性能。&lt;/div&gt;


</description>
<pubDate>Tue, 15 May 2018 16:33:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/9043893.html</dc:identifier>
</item>
<item>
<title>SpringCloud实战-Hystrix线程隔离&amp;请求缓存&amp;请求合并 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/9043844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9043844.html</guid>
<description>&lt;p&gt;接着上一篇的Hystrix进行进一步了解。&lt;/p&gt;
&lt;p&gt;当系统用户不断增长时，每个微服务需要承受的并发压力也越来越大，在分布式环境中，通常压力来自对依赖服务的调用，因为亲戚依赖服务的资源需要通过通信来实现，这样的依赖方式比起进程内的调用方式会引起一部分的性能损失，&lt;/p&gt;
&lt;p&gt;在高并发的场景下，Hystrix 提供了请求缓存的功能，我们可以方便的开启和使用请求缓存来优化系统，达到减轻高并发时的请求线程消耗、降低请求响应时间的效果&lt;/p&gt;
&lt;p&gt;Hystrix的缓存，这个功能是有点鸡肋的，因为这个缓存是基于request的，为什么这么说呢？&lt;strong&gt;因为每次请求来之前都必须HystrixRequestContext.initializeContext();进行初始化，&lt;/strong&gt;&lt;strong&gt;每请求一次controller就会走一次filter，上下文又会初始化一次，前面缓存的就失效了，又得重新来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以你要是想测试缓存，你得在一次controller请求中多次调用那个加了缓存的service或HystrixCommand命令。Hystrix的书上写的是：&lt;strong&gt;在同一用户请求的上下文中，相同依赖服务的返回数据始终保持一致。在当次请求内对同一个依赖进行重复调用，只会真实调用一次。在当次请求内数据可以保证一致性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此。希望大家在这里不要理解错了。&lt;/p&gt;

&lt;p&gt; 请求缓存图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180516001053225-1046223275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设两个线程发起相同的HTTP请求，Hystrix会把请求参数初始化到ThreadLocal中，两个Command异步执行，每个Command会把请求参数从ThreadLocal中拷贝到Command所在自身的线程中，Command在执行的时候会通过CacheKey优先从缓存中尝试获取是否已有缓存结果，&lt;/p&gt;
&lt;p&gt;如果命中，直接从HystrixRequestCache返回，如果没有命中，那么需要进行一次真实调用，然后把结果回写到缓存中，在请求范围内共享响应结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RequestCache主要有三个优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在当次请求内对同一个依赖进行重复调用，只会真实调用一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在当次请求内数据可以保证一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以减少不必要的线程开销。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例子还是接着上篇的HelloServiceCommand来进行演示，我们只需要实现HystrixCommand的一个缓存方法名为getCacheKey()即可&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/9.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HelloServiceCommand extends HystrixCommand&amp;lt;String&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; HelloServiceCommand(String commandGroupKey,RestTemplate restTemplate) {&lt;br/&gt;　　　　//根据commandGroupKey进行线程隔离的
        super(HystrixCommandGroupKey.Factory.asKey(commandGroupKey));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.restTemplate =&lt;span&gt; restTemplate;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String run() throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(Thread.currentThread().getName());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; restTemplate.getForEntity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://HELLO-SERVICE/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).getBody();
    }


    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getFallback() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hystrix的缓存&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String getCacheKey() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般动态的取缓存Key,比如userId，这里为了做实验写死了，写为hello&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Controller代码如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {



    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  RestTemplate restTemplate;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/consumer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String helloConsumer() throws ExecutionException, InterruptedException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hystrix的缓存实现，这功能有点鸡肋。&lt;/span&gt;
&lt;span&gt;        HystrixRequestContext.initializeContext();
        HelloServiceCommand command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HelloServiceCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,restTemplate);
        String execute &lt;/span&gt;=&lt;span&gt; command.execute();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清理缓存
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       HystrixRequestCache.getInstance(&quot;hello&quot;).clear();&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

       
     

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在原来的两个provider模块都增加增加一条输出语句，如下：&lt;/p&gt;
&lt;p&gt;provider1模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;访问来1了......&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;provider2模块：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;访问来2了......&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;浏览器输入localhost:8082/consumer &lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180515220334353-576124348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到你刷新一次请求，&lt;strong&gt;上下文又会初始化一次，前面缓存的就失效了，又得重新来，这时候根本就没有缓存了。&lt;/strong&gt;因此，你无论刷新多少次请求都是出现“访问来了”，缓存都是失效的。如果是从缓存来的话，根本就不会输出“访问来了”。&lt;/p&gt;

&lt;p&gt;但是，你如你在一起请求多次调用同一个业务，这时就是从缓存里面取的数据。不理解可以看一下Hystrix的缓存解释：&lt;strong&gt;在同一用户请求的上下文中，相同依赖服务的返回数据始终保持一致。在当次请求内对同一个依赖进行重复调用，只会真实调用一次。在当次请求内数据可以保证一致性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Controller代码修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {



    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  RestTemplate restTemplate;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/consumer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String helloConsumer() throws ExecutionException, InterruptedException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hystrix的缓存实现，这功能有点鸡肋。&lt;/span&gt;
&lt;span&gt;        HystrixRequestContext.initializeContext();
        HelloServiceCommand command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HelloServiceCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,restTemplate);
        String execute &lt;/span&gt;=&lt;span&gt; command.execute();&lt;br/&gt;&lt;/span&gt;　　　　  HelloServiceCommand command1 = new HelloServiceCommand(&quot;hello&quot;,restTemplate);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;        String execute1 =&lt;span&gt; command1.execute();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清理缓存 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; HystrixRequestCache.getInstance(&quot;hello&quot;).clear();&lt;/span&gt; 　　&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; &lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着运行，运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180515222230244-864100677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到只有一个”访问来了“，并没有出现两个”访问来了“。&lt;/p&gt;
&lt;p&gt;之所以没出现第二个，是因为是从缓存中取了。&lt;/p&gt;

&lt;p&gt;删除缓存 例如删除key名为hello的缓存：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HystrixRequestCache.getInstance(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).clear();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你要写操作的时候，你把一条数据给给删除了，这时候你就必须把缓存清空了。&lt;/p&gt;


&lt;p&gt;下面进行请求的合并。&lt;/p&gt;
&lt;p&gt; 为什么要进行请求合并？举个例子，有个矿山，每过一段时间都会生产一批矿产出来（质量为卡车载重量的1/100），卡车可以一等到矿产生产出来就马上运走矿产，也可以等到卡车装满再运走矿产，&lt;/p&gt;
&lt;p&gt;前者一次生产对应卡车一次往返，卡车需要往返100次，而后者只需要往返一次，可以大大减少卡车往返次数。显而易见，利用请求合并可以减少线程和网络连接，开发人员不必单独提供一个批量请求接口就可以完成批量请求。&lt;/p&gt;
&lt;p&gt; 在Hystrix中进行请求合并也是要付出一定代价的，请求合并会导致依赖服务的请求延迟增高，延迟的最大值是合并时间窗口的大小，默认为10ms，当然我们也可以通过hystrix.collapser.default.timerDelayInMilliseconds属性进行修改，&lt;/p&gt;
&lt;p&gt;如果请求一次依赖服务的平均响应时间是20ms，那么最坏情况下（合并窗口开始是请求加入等待队列）这次请求响应时间就会变成30ms。在Hystrix中对请求进行合并是否值得主要取决于Command本身，高并发度的接口通过请求合并可以极大提高系统吞吐量，&lt;/p&gt;
&lt;p&gt;从而基本可以忽略合并时间窗口的开销，反之，并发量较低，对延迟敏感的接口不建议使用请求合并。&lt;/p&gt;
&lt;p&gt;请求合并的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180515225249034-272421860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看出Hystrix会把多个Command放入Request队列中，一旦满足合并时间窗口周期大小，Hystrix会进行一次批量提交，进行一次依赖服务的调用，通过充写HystrixCollapser父类的mapResponseToRequests方法，将批量返回的请求分发到具体的每次请求中。&lt;/p&gt;

&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;首先我们先自定义一个BatchCommand类来继承Hystrix给我们提供的HystrixCollapser类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/13.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HjcBatchCommand extends HystrixCollapser&amp;lt;List&amp;lt;String&amp;gt;,String,Long&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long id;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;
　　//在200毫秒内进行请求合并，不在的话，放到下一个200毫秒
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HjcBatchCommand(RestTemplate restTemplate,Long id) {
        super(Setter.withCollapserKey(HystrixCollapserKey.Factory.asKey(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hjcbatch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                .andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter()
                        .withTimerDelayInMilliseconds(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.restTemplate =&lt;span&gt; restTemplate;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取每一个请求的请求参数&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getRequestArgument() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建命令请求合并&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; HystrixCommand&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; createCommand(Collection&amp;lt;CollapsedRequest&amp;lt;String, Long&amp;gt;&amp;gt;&lt;span&gt; collection) {
        List&lt;/span&gt;&amp;lt;Long&amp;gt; ids = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(collection.size());
        ids.addAll(collection.stream().map(CollapsedRequest::getArgument).collect(Collectors.toList()));
        HjcCommand command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HjcCommand(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hjc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,restTemplate,ids);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; command;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并请求拿到了结果，将请求结果按请求顺序分发给各个请求&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mapResponseToRequests(List&amp;lt;String&amp;gt; results, Collection&amp;lt;CollapsedRequest&amp;lt;String, Long&amp;gt;&amp;gt;&lt;span&gt; collection) {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;分配批量请求结果。。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (CollapsedRequest&amp;lt;String,Long&amp;gt;&lt;span&gt; collapsedRequest : collection){
            String result &lt;/span&gt;= results.&lt;span&gt;get&lt;/span&gt;(count++&lt;span&gt;);
            collapsedRequest.setResponse(result);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着用自定义个HjcCommand来继承Hystrix提供的HystrixCommand来进行服务请求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/13.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HjcCommand extends HystrixCommand&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Long&amp;gt;&lt;span&gt; ids;


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HjcCommand(String commandGroupKey, RestTemplate restTemplate,List&amp;lt;Long&amp;gt;&lt;span&gt; ids) {&lt;br/&gt;　　　　　　//根据commandGroupKey进行线程隔离
        super(HystrixCommandGroupKey.Factory.asKey(commandGroupKey));
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.restTemplate =&lt;span&gt; restTemplate;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ids =&lt;span&gt; ids;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; run() throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送请求。。。参数为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ids.toString()+&lt;span&gt;Thread.currentThread().getName());
        String[] result &lt;/span&gt;= restTemplate.getForEntity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://HELLO-SERVICE/hjcs?ids={1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,String[].&lt;span&gt;class&lt;/span&gt;, StringUtils.join(ids,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).getBody();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Arrays.asList(result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是注意一点：你请求合并必须要异步，因为你如果用同步，是一个请求完成后，另外的请求才能继续执行，所以必须要异步才能请求合并。&lt;/p&gt;
&lt;p&gt;所以Controller层代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerController {



    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  RestTemplate restTemplate;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/consumer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String helloConsumer() throws ExecutionException, InterruptedException {


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求合并&lt;/span&gt;
        HystrixRequestContext context =&lt;span&gt; HystrixRequestContext.initializeContext();
        HjcBatchCommand command &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HjcBatchCommand(restTemplate,&lt;span&gt;1L&lt;/span&gt;&lt;span&gt;);
        HjcBatchCommand command1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HjcBatchCommand(restTemplate,&lt;span&gt;2L&lt;/span&gt;&lt;span&gt;);
        HjcBatchCommand command2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HjcBatchCommand(restTemplate,&lt;span&gt;3L&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里你必须要异步，因为同步是一个请求完成后，另外的请求才能继续执行，所以必须要异步才能请求合并&lt;/span&gt;
        Future&amp;lt;String&amp;gt; future =&lt;span&gt; command.queue();
        Future&lt;/span&gt;&amp;lt;String&amp;gt; future1 =&lt;span&gt; command1.queue();

        String r &lt;/span&gt;= future.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
        String r1 &lt;/span&gt;= future1.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();

        Thread.sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以看到前面两条命令会合并，最后一条会单独，因为睡了2000毫秒，而你请求设置要求在200毫秒内才合并的。&lt;/span&gt;
        Future&amp;lt;String&amp;gt; future2 =&lt;span&gt; command2.queue();
        String r2 &lt;/span&gt;= future2.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(r);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(r1);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(r2);

        context.close();

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个服务提供者provider1,provider2新增加一个方法来模拟数据库数据，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/8.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String hello(){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;访问来2了......&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hjcs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; laowangs(String ids){
        List&lt;/span&gt;&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;laowang1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        list.add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;laowang2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        list.add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;laowang3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动Ribbon模块，运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180515232007483-732297833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看到上图的两个线程是隔离的。&lt;/p&gt;
&lt;p&gt;当请求非常多的时候，你合并请求就变得非常重要了，如果你不合并，一个请求都1 到2秒，这明显不能忍的，会造成效率缓慢，如果你合并后，这时就可以并行处理，降低延迟，但是如果请求不多的时候，只有单个请求，这时候合并也会出现&lt;/p&gt;
&lt;p&gt;效率缓慢的，因为如果请求一次依赖服务的平均响应时间是200ms，那么最坏情况下（合并窗口开始是请求加入等待队列）这次请求响应时间就会变成300ms。所以说要看场合而定的。&lt;/p&gt;

&lt;p&gt;下面用注解的代码来实现请求合并。代码如下：‘&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/5/15.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HjcService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;

    @HystrixCollapser(batchMethod &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getLaoWang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,collapserProperties = {@HystrixProperty(name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timerDelayInMilliseconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Future&amp;lt;String&amp;gt; batchGetHjc(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @HystrixCommand
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; getLaoWang(List&amp;lt;Long&amp;gt;&lt;span&gt; ids){
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送请求。。。参数为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ids.toString()+&lt;span&gt;Thread.currentThread().getName());
        String[] result &lt;/span&gt;= restTemplate.getForEntity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://HELLO-SERVICE/hjcs?ids={1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,String[].&lt;span&gt;class&lt;/span&gt;, StringUtils.join(ids,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).getBody();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Arrays.asList(result);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们还要进行服务的监控的话，那么我们需要在Ribbon模块，和两个服务提供者模块提供如下依赖：&lt;/p&gt;
&lt;p&gt;Ribbon模块依赖如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　&amp;lt;!--仪表盘--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix-dashboard&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!--监控--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个provider模块依赖如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　&amp;lt;!--监控--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着在Ribbon启动类打上@EnableHystrixDashboard注解，然后启动，localhost:8082/hystrix,如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180516000321446-465009364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次访问都有记录：如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201805/1202638-20180516000406122-1329898367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来我们看一下常用的Hystrix属性：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hystrix.command.default和hystrix.threadpool.default中的default为默认CommandKey&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1.Execution相关的属性的配置：&lt;/span&gt;&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;hystrix.command.default.execution.isolation.strategy 隔离策略，默认是Thread, 可选Thread｜Semaphore&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 命令执行超时时间，默认1000ms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.timeout.enabled 执行是否启用超时，默认启用true&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.isolation.thread.interruptOnTimeout 发生超时是是否中断，默认true&lt;/li&gt;
&lt;li&gt;hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 最大并发请求数，默认10，该参数当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。理论上选择semaphore size的原则和选择thread size一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），否则的话应该用thread。&lt;br/&gt;semaphore应该占整个容器（tomcat）的线程池的一小部分。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;2.Fallback相关的属性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;这些参数可以应用于Hystrix的THREAD和SEMAPHORE策略&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests 如果并发数达到该设置值，请求会被拒绝和抛出异常并且fallback不会被调用。默认10&lt;/li&gt;
&lt;li&gt;hystrix.command.default.fallback.enabled 当执行失败或者请求被拒绝，是否会尝试调用hystrixCommand.getFallback() 。默认true&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;3.Circuit Breaker相关的属性&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;hystrix.command.default.circuitBreaker.enabled 用来跟踪circuit的健康性，如果未达标则让request短路。默认true&lt;/li&gt;
&lt;li&gt;hystrix.command.default.circuitBreaker.requestVolumeThreshold 一个rolling window内最小的请求数。如果设为20，那么当一个rolling window的时间内（比如说1个rolling window是10秒）收到19个请求，即使19个请求都失败，也不会触发circuit break。默认20&lt;/li&gt;
&lt;li&gt;hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds 触发短路的时间值，当该值设为5000时，则当触发circuit break后的5000毫秒内都会拒绝request，也就是5000毫秒后才会关闭circuit。默认5000&lt;/li&gt;
&lt;li&gt;hystrix.command.default.circuitBreaker.errorThresholdPercentage错误比率阀值，如果错误率&amp;gt;=该值，circuit会被打开，并短路所有请求触发fallback。默认50&lt;/li&gt;
&lt;li&gt;hystrix.command.default.circuitBreaker.forceOpen 强制打开熔断器，如果打开这个开关，那么拒绝所有request，默认false&lt;/li&gt;
&lt;li&gt;hystrix.command.default.circuitBreaker.forceClosed 强制关闭熔断器 如果这个开关打开，circuit将一直关闭且忽略circuitBreaker.errorThresholdPercentage&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;4.Metrics相关参数&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;hystrix.command.default.metrics.rollingStats.timeInMilliseconds 设置统计的时间窗口值的，毫秒值，circuit break 的打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000&lt;/li&gt;
&lt;li&gt;hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10&lt;/li&gt;
&lt;li&gt;hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true&lt;/li&gt;
&lt;li&gt;hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000&lt;/li&gt;
&lt;li&gt;hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6&lt;/li&gt;
&lt;li&gt;hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100&lt;/li&gt;
&lt;li&gt;hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;5.Request Context 相关参数&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;hystrix.command.default.requestCache.enabled 默认true，需要重载getCacheKey()，返回null时不缓存&lt;br/&gt;hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true&lt;/p&gt;

&lt;p&gt;hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE&lt;br/&gt;hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10&lt;br/&gt;hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true&lt;/p&gt;

&lt;p&gt;线程数默认值10适用于大部分情况（有时可以设置得更小），如果需要设置得更大，那有个基本得公式可以follow：&lt;br/&gt;requests per second at peak when healthy × 99th percentile latency in seconds + some breathing room&lt;br/&gt;每秒最大支撑的请求数 (99%平均响应时间 + 缓存值)&lt;br/&gt;比如：每秒能处理1000个请求，99%的请求响应时间是60ms，那么公式是：&lt;br/&gt;1000 （0.060+0.012）&lt;/p&gt;
&lt;p&gt;基本得原则时保持线程池尽可能小，他主要是为了释放压力，防止资源被阻塞。&lt;br/&gt;当一切都是正常的时候，线程池一般仅会有1到2个线程激活来提供服务&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;hystrix.threadpool.default.coreSize 并发执行的最大线程数，默认10&lt;/li&gt;
&lt;li&gt;hystrix.threadpool.default.maxQueueSize BlockingQueue的最大队列数，当设为－1，会使用SynchronousQueue，值为正时使用LinkedBlcokingQueue。该设置只会在初始化时有效，之后不能修改threadpool的queue size，除非reinitialising thread executor。默认－1。&lt;/li&gt;
&lt;li&gt;hystrix.threadpool.default.queueSizeRejectionThreshold 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝。因为maxQueueSize不能被动态修改，这个参数将允许我们动态设置该值。if maxQueueSize == -1，该字段将不起作用&lt;/li&gt;
&lt;li&gt;hystrix.threadpool.default.keepAliveTimeMinutes 如果corePoolSize和maxPoolSize设成一样（默认实现）该设置无效。如果通过plugin（&lt;a href=&quot;https://github.com/Netflix/Hystrix/wiki/Plugins%EF%BC%89%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%AF%A5%E8%AE%BE%E7%BD%AE%E6%89%8D%E6%9C%89%E7%94%A8%EF%BC%8C%E9%BB%98%E8%AE%A41&quot; target=&quot;_blank&quot;&gt;https://github.com/Netflix/Hystrix/wiki/Plugins）使用自定义实现，该设置才有用，默认1&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;hystrix.threadpool.default.metrics.rollingStats.timeInMilliseconds 线程池统计指标的时间，默认10000&lt;/li&gt;
&lt;li&gt;hystrix.threadpool.default.metrics.rollingStats.numBuckets 将rolling window划分为n个buckets，默认10&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 15 May 2018 16:04:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9043844.html</dc:identifier>
</item>
<item>
<title>Generator的正确打开方式 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/9043778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/9043778.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前两年大量的在写&lt;code&gt;Generator&lt;/code&gt;+&lt;code&gt;co&lt;/code&gt;，用它来写一些类似同步的代码&lt;br/&gt;但实际上，&lt;code&gt;Generator&lt;/code&gt;并不是被造出来干这个使的，不然也就不会有后来的&lt;code&gt;async&lt;/code&gt;、&lt;code&gt;await&lt;/code&gt;了&lt;br/&gt;&lt;code&gt;Generator&lt;/code&gt;是一个可以被暂停的函数，并且何时恢复，由调用方决定&lt;br/&gt;希望本文可以帮助你理解&lt;code&gt;Generator&lt;/code&gt;究竟是什么，以及怎么用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;放一张图来表示我对&lt;code&gt;Generator&lt;/code&gt;的理解：&lt;br/&gt;&lt;img src=&quot;https://blog.jiasm.org/images/understanding-generators/banner.jpeg&quot; alt=&quot;&quot; width=&quot;1047&quot; height=&quot;697&quot;/&gt;&lt;br/&gt;&lt;em&gt;一个咖啡机，虽说我并不喝咖啡，可惜找不到造王老吉的机器-.-&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我所理解的&lt;del&gt;Generator&lt;/del&gt;咖啡机大概就是这么的一个样子的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，我们往机器里边放一些咖啡豆&lt;/li&gt;
&lt;li&gt;等我们想喝咖啡的时候，就可以按开关(&lt;em&gt;gen.next()&lt;/em&gt;)，机器开始磨咖啡豆、煮咖啡、接下来就得到咖啡了&lt;/li&gt;
&lt;li&gt;等接满了一杯咖啡后，阀门就会自动关闭(&lt;em&gt;yield&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;如果你一开始往机器里边放的咖啡豆很多的话，此时，机器里边还是会有一些剩余的，下次再想喝还可以继续按开关，执行（磨豆、煮咖啡、接咖啡）这一套操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;拿&lt;code&gt;Generator&lt;/code&gt;将上述咖啡机实现一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; coffeeMachineGenerator (beans) {
  &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
    yield cookCoffee()
  } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (--&lt;span&gt;beans)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 煮咖啡&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; cookCoffee () {
    console.log(&lt;/span&gt;'cooking'&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'Here you are'&lt;span&gt;
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 往咖啡机放咖啡豆&lt;/span&gt;
let coffeeMachine = coffeeMachineGenerator(10&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我想喝咖啡了&lt;/span&gt;
&lt;span&gt;coffeeMachine.next()

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我在3秒后还会喝咖啡&lt;/span&gt;
setTimeout(() =&amp;gt;&lt;span&gt; {
  coffeeMachine.next()
}, &lt;/span&gt;3 * 1e3)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码运行后，我们首先会得到一条&lt;code&gt;cooking&lt;/code&gt;的&lt;code&gt;log&lt;/code&gt;，&lt;br/&gt;然后在&lt;code&gt;3s&lt;/code&gt;后会再次得到一条&lt;code&gt;log&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就解释了&lt;code&gt;Generator&lt;/code&gt;是什么：&lt;br/&gt;一个可以暂停的迭代器&lt;br/&gt;调用&lt;code&gt;next&lt;/code&gt;来获取数据（&lt;em&gt;我们自己来决定是否何时煮咖啡&lt;/em&gt;）&lt;br/&gt;在遇到&lt;code&gt;yield&lt;/code&gt;以后函数的执行就会停止（&lt;em&gt;接满了一杯，阀门关闭&lt;/em&gt;）&lt;br/&gt;我们来决定何时运行剩余的代码&lt;code&gt;next&lt;/code&gt;（&lt;em&gt;什么时候想喝了再去煮&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是&lt;code&gt;Generator&lt;/code&gt;中最重要的特性，我们只有在真正需要的时候才获取下一个值，而不是一次性获取所有的值&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Generator的语法&quot;&gt;Generator的语法&lt;/h2&gt;
&lt;p&gt;声明&lt;code&gt;Generator&lt;/code&gt;函数有很多种途径，最重要的一点就是，在&lt;code&gt;function&lt;/code&gt;关键字后添加一个&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; generator () {}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; generator () {}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;generator () {}

let generator &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt; *&lt;span&gt; () {}
let generator &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;*&lt;span&gt;  () {}
let generator &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;  *&lt;span&gt;() {}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误的示例&lt;/span&gt;
let generator = *() =&amp;gt;&lt;span&gt; {}
let generator &lt;/span&gt;= ()* =&amp;gt;&lt;span&gt; {}
let generator &lt;/span&gt;= (*) =&amp;gt; {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;或者，因为是一个函数，也可以作为一个对象的属性来存在：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class MyClass {
  &lt;/span&gt;*&lt;span&gt; generator() {}
  &lt;/span&gt;*&lt;span&gt;generator2() {}
}

const obj &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;*&lt;span&gt;generator() {}
  &lt;/span&gt;*&lt;span&gt; generator() {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;generator的初始化与复用&quot;&gt;generator的初始化与复用&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;Generator&lt;/code&gt;函数通过调用两次方法，将会生成两个完全独立的&lt;code&gt;状态机&lt;/code&gt;&lt;br/&gt;所以，保存当前的&lt;code&gt;Generator&lt;/code&gt;对象很重要：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; * generator (name = 'unknown'&lt;span&gt;) {
  yield `Your name: ${name}`
}

const gen1 &lt;/span&gt;=&lt;span&gt; generator()
const gen2 &lt;/span&gt;= generator('Niko Bellic'&lt;span&gt;)

gen1.next() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { value: Your name: unknown    , done: false}&lt;/span&gt;
gen2.next() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; { value: Your name: Niko Bellic, done: false}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;Method-next&quot;&gt;Method: next()&lt;/h3&gt;
&lt;p&gt;最常用的&lt;code&gt;next()&lt;/code&gt;方法，无论何时调用它，都会得到下一次输出的返回对象（在代码执行完后的调用将会始终返回&lt;code&gt;{value: undefined, done: true}&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next&lt;/code&gt;总会返回一个对象，包含两个属性值：&lt;br/&gt;&lt;code&gt;value&lt;/code&gt;：&lt;code&gt;yield&lt;/code&gt;关键字后边表达式的值&lt;br/&gt;&lt;code&gt;done&lt;/code&gt; ：如果已经没有&lt;code&gt;yield&lt;/code&gt;关键字了，则会返回&lt;code&gt;true&lt;/code&gt; .&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; generator () {
  yield &lt;/span&gt;5
  &lt;span&gt;return&lt;/span&gt; 6&lt;span&gt;
}

const gen &lt;/span&gt;=&lt;span&gt; generator()

console.log(gen.next()) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 5, done: false}&lt;/span&gt;
console.log(gen.next()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 6, done: true}&lt;/span&gt;
console.log(gen.next()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
console.log(gen.next()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true} -- 后续再调用也都会是这个结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;作为迭代器使用&quot;&gt;作为迭代器使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt;函数是一个可迭代的，所以，我们可以直接通过&lt;code&gt;for of&lt;/code&gt;来使用它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; generator () {
  yield &lt;/span&gt;1&lt;span&gt;
  yield &lt;/span&gt;2
  &lt;span&gt;return&lt;/span&gt; 3&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let item of generator()) {
  item
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;return&lt;/code&gt;不参与迭代&lt;/em&gt;&lt;br/&gt;&lt;em&gt;迭代会执行所有的&lt;code&gt;yield&lt;/code&gt;，也就是说，在迭代后的&lt;code&gt;Generator&lt;/code&gt;对象将不会再返回任何有效的值&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;Method-return&quot;&gt;Method: return()&lt;/h3&gt;
&lt;p&gt;我们可以在迭代器对象上直接调用&lt;code&gt;return()&lt;/code&gt;，来终止后续的代码执行。&lt;br/&gt;在&lt;code&gt;return&lt;/code&gt;后的所有&lt;code&gt;next()&lt;/code&gt;调用都将返回&lt;code&gt;{value: undefined, done: true}&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; generator () {
  yield &lt;/span&gt;1&lt;span&gt;
  yield &lt;/span&gt;2&lt;span&gt;
  yield &lt;/span&gt;3&lt;span&gt;
}

const gen &lt;/span&gt;=&lt;span&gt; generator()

gen.&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;()     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
gen.&lt;span&gt;return&lt;/span&gt;('hi') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;hi&quot;, done: true}&lt;/span&gt;
gen.next()       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;Method-throw&quot;&gt;Method: throw()&lt;/h3&gt;
&lt;p&gt;在调用&lt;code&gt;throw()&lt;/code&gt;后同样会终止所有的&lt;code&gt;yield&lt;/code&gt;执行，同时会抛出一个异常，需要通过&lt;code&gt;try-catch&lt;/code&gt;来接收：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; generator () {
  yield &lt;/span&gt;1&lt;span&gt;
  yield &lt;/span&gt;2&lt;span&gt;
  yield &lt;/span&gt;3&lt;span&gt;
}

const gen &lt;/span&gt;=&lt;span&gt; generator()

gen.&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;('error text') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error: error text&lt;/span&gt;
gen.next()              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;Yield的语法&quot;&gt;Yield的语法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;的语法有点像&lt;code&gt;return&lt;/code&gt;，但是，&lt;code&gt;return&lt;/code&gt;是在函数调用结束后返回结果的&lt;br/&gt;并且在调用&lt;code&gt;return&lt;/code&gt;之后不会执行其他任何的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; method (a) {
  let b &lt;/span&gt;= 5
  &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下边的两句代码永远不会执行&lt;/span&gt;
  b = 6
  &lt;span&gt;return&lt;/span&gt; a *&lt;span&gt; b
}

method(&lt;/span&gt;6) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;
method(6) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;而yield的表现则不一样&quot;&gt;而yield的表现则不一样&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; yieldMethod(a) {
  let b &lt;/span&gt;= 5&lt;span&gt;
  yield a &lt;/span&gt;+&lt;span&gt; b
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在执行第二次`next`时，下边两行则会执行&lt;/span&gt;
  b = 6
  &lt;span&gt;return&lt;/span&gt; a *&lt;span&gt; b
}

const gen &lt;/span&gt;= yieldMethod(6&lt;span&gt;)
gen.next().value &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;
gen.next().value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;yield&quot;&gt;yield*&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;yield*&lt;/code&gt;用来将一个&lt;code&gt;Generator&lt;/code&gt;放到另一个&lt;code&gt;Generator&lt;/code&gt;函数中执行。&lt;br/&gt;有点像&lt;code&gt;[...]&lt;/code&gt;的功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; gen1 () {
  yield &lt;/span&gt;2&lt;span&gt;
  yield &lt;/span&gt;3&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; gen2 () {
  yield &lt;/span&gt;1&lt;span&gt;
  yield &lt;/span&gt;*&lt;span&gt; gen1()
  yield &lt;/span&gt;4&lt;span&gt;
}

let gen &lt;/span&gt;=&lt;span&gt; gen2()

gen.next().value &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
gen.next().value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
gen.next().value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
gen.next().value &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;yield的返回值&quot;&gt;yield的返回值&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;yield&lt;/code&gt;是可以接收返回值的，返回值可以在后续的代码被使用&lt;br/&gt;&lt;em&gt;一个诡异的写法&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; generator (num) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; yield yield num
}

let gen &lt;/span&gt;= generator(1&lt;span&gt;)

console.log(gen.next())  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 1, done: false}&lt;/span&gt;
console.log(gen.next(2)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 2, done: false}&lt;/span&gt;
console.log(gen.next(3)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 3, done: true }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们在调用第一次&lt;code&gt;next&lt;/code&gt;时候，代码执行到了&lt;code&gt;yield num&lt;/code&gt;，此时返回&lt;code&gt;num&lt;/code&gt;&lt;br/&gt;然后我们再调用&lt;code&gt;next(2)&lt;/code&gt;，代码执行的是&lt;code&gt;yield (yield num)&lt;/code&gt;，而其中返回的值就是我们在&lt;code&gt;next&lt;/code&gt;中传入的参数了，作为&lt;code&gt;yield num&lt;/code&gt;的返回值存在。&lt;br/&gt;以及最后的&lt;code&gt;next(3)&lt;/code&gt;，执行的是这部分代码&lt;code&gt;return (yield (yield num))&lt;/code&gt;，第二次&lt;code&gt;yield&lt;/code&gt;表达式的返回值。&lt;/p&gt;
&lt;h2 id=&quot;一些实际的使用场景&quot;&gt;一些实际的使用场景&lt;/h2&gt;
&lt;p&gt;上边的所有示例都是建立在已知次数的&lt;code&gt;Generator&lt;/code&gt;函数上的，但如果你需要一个未知次数的&lt;code&gt;Generator&lt;/code&gt;，仅需要创建一个无限循环就够了。&lt;/p&gt;
&lt;h3 id=&quot;一个简单的随机数生成&quot;&gt;一个简单的随机数生成&lt;/h3&gt;
&lt;p&gt;比如我们将实现一个随机数的获取：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; randomGenerator (...randoms) {
  let len &lt;/span&gt;=&lt;span&gt; randoms.length
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    yield randoms[Math.floor(Math.random() &lt;/span&gt;*&lt;span&gt; len)]
  }
}

const randomeGen &lt;/span&gt;= randomGenerator(1, 2, 3, 4&lt;span&gt;)

randomeGen.next().value &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个随机数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;代替一些递归的操作&quot;&gt;代替一些递归的操作&lt;/h3&gt;
&lt;p&gt;那个最著名的&lt;em&gt;斐波那契数&lt;/em&gt;，基本上都会选择使用递归来实现&lt;br/&gt;但是再结合着&lt;code&gt;Generator&lt;/code&gt;以后，就可以使用一个无限循环来实现了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt; fibonacci(seed1, seed2) {
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    yield (() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      seed2 &lt;/span&gt;= seed2 +&lt;span&gt; seed1;
      seed1 &lt;/span&gt;= seed2 -&lt;span&gt; seed1;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; seed2;
    })();
  }
}

const fib &lt;/span&gt;= fibonacci(0, 1&lt;span&gt;);
fib.next(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 1, done: false}&lt;/span&gt;
fib.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 2, done: false}&lt;/span&gt;
fib.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 3, done: false}&lt;/span&gt;
fib.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 5, done: false}&lt;/span&gt;
fib.next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 8, done: false}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;与async-await的结合&quot;&gt;与async/await的结合&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;再次重申，我个人不认为async/await是Generator的语法糖。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是写前端的童鞋，基本上都会遇到处理分页加载数据的时候&lt;br/&gt;如果结合着&lt;code&gt;Generator&lt;/code&gt;+&lt;code&gt;async&lt;/code&gt;、&lt;code&gt;await&lt;/code&gt;，我们可以这样实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt; *&lt;span&gt; loadDataGenerator (url) {
  let page &lt;/span&gt;= 1

  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    page &lt;/span&gt;=&lt;span&gt; (yield await ajax(url, {
      data: page
    })) &lt;/span&gt;|| ++&lt;span&gt;page
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用setTimeout模拟异步请求&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ajax (url, { data: page }) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
    setTimeout(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      console.log(`get page: ${page}`);
      resolve()
    }, &lt;/span&gt;1000&lt;span&gt;)
  })
}

let loadData &lt;/span&gt;= loadDataGenerator('get-data-url'&lt;span&gt;)

await loadData.next()
await loadData.next()

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; force load page 1&lt;/span&gt;
await loadData.next(1&lt;span&gt;)
await loadData.next()

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get page: 1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; get page: 2&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; get page: 1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; get page: 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样我们可以在简单的几行代码中实现一个分页控制函数了。&lt;br/&gt;如果想要从加载特定的页码，直接将&lt;code&gt;page&lt;/code&gt;传入&lt;code&gt;next&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;小记&quot;&gt;小记&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Generator&lt;/code&gt;还有更多的使用方式，（实现异步流程控制、按需进行数据读取）&lt;br/&gt;个人认为，&lt;code&gt;Generator&lt;/code&gt;的优势在于代码的惰性执行，&lt;code&gt;Generator&lt;/code&gt;所实现的事情，我们不使用它也可以做到，只是使用&lt;code&gt;Generator&lt;/code&gt;后，能够让代码的可读性变得更好、流程变得更清晰、更专注于逻辑的实现。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果有什么不懂的地方 or 文章中一些的错误，欢迎指出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/@hidace/javascript-es6-generators-part-i-understanding-generators-93dea22bf1b&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;Javascript (ES6) Generators — Part I: Understanding Generators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codeburst.io/what-are-javascript-generators-and-how-to-use-them-c6f2713fd12e&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;What are JavaScript Generators and how to use them&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Jiasm/notebook/tree/master/blog-storage/how-to-use-generator&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;文章示例代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 15:43:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/9043778.html</dc:identifier>
</item>
<item>
<title>Egg Dropping Puzzle问题的分析 - CMlhc</title>
<link>http://www.cnblogs.com/CMlhc/p/9043763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CMlhc/p/9043763.html</guid>
<description>&lt;p&gt;首先，基本问题是这样：You are given two eggs, and access to a 100-storey building. The aim is to find out the highest floor from which an egg will not break when dropped out of a window from that floor.&lt;/p&gt;
&lt;p&gt;翻译成中文大概是这样：你得到两个鸡蛋，并进入一个100层楼。目的是找出从地板上掉下来的鸡蛋从地板上掉下来时不会破裂的最高层。&lt;/p&gt;

&lt;p&gt;我谷歌了一下这个题目，发现应该是和动态规划相关的问题，应该有优化的过程。&lt;/p&gt;

&lt;p&gt;我们可以用w(n,k)来表示，其中n表示鸡蛋的个数，k表示楼需要验证的层数。题目则用（2，100）来表示，假设第一次在第i个楼层扔鸡蛋，如果破碎了，则下一个鸡蛋从（1，i）的范围，所对应的公式为（1，i-1）；如果没有碎，则这两个鸡蛋则从（i，100）的范围进行实验，所对应的公式为w(2,100-i)。&lt;/p&gt;

&lt;p&gt;其对于的公式为&lt;/p&gt;
&lt;p&gt;       w(n,k)=1+max{w(n-1,i-1),w(n,k-i)}&lt;/p&gt;
&lt;p&gt;其中w(1,1)到w(1,k)=k，w(n,1)=1,w(1,0)=0.&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;math.h&amp;gt;
&lt;span&gt;#define&lt;/span&gt; MAX 200
&lt;span&gt;#define&lt;/span&gt; MAXMAX 10000
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; w[MAX][MAX]={&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,k;
    cin&lt;/span&gt;&amp;gt;&amp;gt;n&amp;gt;&amp;gt;&lt;span&gt;k;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=k;i++&lt;span&gt;)
    {
        w[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;][i]=&lt;span&gt;i;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        w[i][&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
     {
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;2&lt;/span&gt;;j&amp;lt;=k;j++&lt;span&gt;)
         {
             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; the_max=&lt;span&gt;MAXMAX;
             &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; x=&lt;span&gt;1&lt;/span&gt;;x&amp;lt;=j;x++&lt;span&gt;)
             {
                 t&lt;/span&gt;=max(w[i-&lt;span&gt;1&lt;/span&gt;][x-&lt;span&gt;1&lt;/span&gt;],w[i][j-&lt;span&gt;x]);
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(the_max&amp;gt;&lt;span&gt;t)
                 {
                     the_max&lt;/span&gt;=&lt;span&gt;t;
                 }
             }
            w[i][j]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;the_max;

        }
     }

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout&amp;lt;&amp;lt;w[n][k]&amp;lt;&amp;lt;endl;&lt;/span&gt;
     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;=k;j++&lt;span&gt;)
     {
         printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%4d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,j);
     }
     cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
     {
         printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%4d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,i);
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=k;j++&lt;span&gt;)
         {
              printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%4d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,w[i][j]);
         }
         cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;

     }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以w(2,36)为例，运行截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1365727/201805/1365727-20180515233820584-725704510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行w(2,100)即可得到题目所求。&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 15:39:00 +0000</pubDate>
<dc:creator>CMlhc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CMlhc/p/9043763.html</dc:identifier>
</item>
<item>
<title>Nordic nRF51/nRF52开发环境搭建 - iini</title>
<link>http://www.cnblogs.com/iini/p/9043565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iini/p/9043565.html</guid>
<description>&lt;p&gt;本文将详述Nordic nRF51系列（包括nRF51822/nRF51802/nRF51422等）和nRF52系列（包括nRF52832/nRF52810/nRF52840）开发环境搭建。&lt;/p&gt;

&lt;p&gt;如下工具必须安装，否则无法开发Nordic nRF51/52产品&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;strong&gt;IDE&lt;/strong&gt;。Nordic nRF51/52支持Keil，GCC，IAR和SES（Segger Embedded Studio）四种IDE，大家随便选择&lt;strong&gt;其中一种&lt;/strong&gt;安装即可。
&lt;ul&gt;&lt;li&gt;Keil。大家自行下载安装，这里不再赘述。&lt;/li&gt;
&lt;li&gt;IAR。大家自行下载安装，这里不再赘述。&lt;/li&gt;
&lt;li&gt;SES（推荐）。SES跟Keil非常像，是Segger公司为Nordic芯片量身打造的，对Nordic用户来说，永久免费。SES支持Windows/MacOS/Linux三种平台，下载链接为：&lt;a href=&quot;https://www.segger.com/downloads/embedded-studio&quot;&gt;https://www.segger.com/downloads/embedded-studio&lt;/a&gt;。下载成功后，你将得到“Setup_EmbeddedStudio_v330_win_x64.exe”之类的安装包（Windows 64bit版本），成功安装后，SES软件界面如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225227611-1638399837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;em&gt;如果你是硬件工程师，IDE&lt;/em&gt;&lt;em&gt;不是必须安装的，因为Nordic SDK&lt;/em&gt;&lt;em&gt;所有例子都有已经编译好的hex&lt;/em&gt;&lt;em&gt;文件供你使用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;         下完之后，你将得到 “nRF5_SDK_15.0.0_a53641a.zip”之类的压缩包，解压缩该压缩包，SDK即安装完成，如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225252288-1951246423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安装与本&lt;/strong&gt;&lt;strong&gt;SDK&lt;/strong&gt;&lt;strong&gt;版本配套的&lt;/strong&gt;&lt;strong&gt;ARM CMSIS&lt;/strong&gt;&lt;strong&gt;软件包和&lt;/strong&gt;&lt;strong&gt;IDE&lt;/strong&gt;&lt;strong&gt;插件&lt;/strong&gt;。&lt;strong&gt;如果你是&lt;/strong&gt;&lt;strong&gt;Keil5&lt;/strong&gt;&lt;strong&gt;用户，&lt;/strong&gt;一般可以通过如下界面，把相应的CMSIS和Device family pack安装好&lt;strong&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225426866-617556650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于某些原因，很多用户在上述界面无法安装，因此可以将CMSIS和IDE插件从网上下载下来，单独安装。&lt;/p&gt;
&lt;p&gt;ARM CMSIS安装包下载地址：&lt;a href=&quot;https://github.com/ARM-software/CMSIS/releases&quot;&gt;https://github.com/ARM-software/CMSIS/releases&lt;/a&gt;。从如下界面选择你需要的CMSIS版本。那具体选择哪个CMSIS版本呢？你可以随便打开SDK中一个例子，Keil或者其他IDE就会报错告诉你缺少那个版本的CMSIS（一般来说，缺少的都是CMSIS4.5.0），你再把它下下来即可。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225459529-1496495135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;ARM CMSIS4.5.0 Windows/Keil5安装界面如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225520170-1633436188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;所有IDE插件都可以到如下网址下载：&lt;a href=&quot;https://www.nordicsemi.com/eng/Products/nRF52840#Downloads&quot;&gt;https://www.nordicsemi.com/eng/Products/nRF52840#Downloads&lt;/a&gt;。根据自己的IDE，选择相应的插件：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225538447-1028370593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：上述所有插件都有2&lt;/strong&gt;&lt;strong&gt;个版本，2&lt;/strong&gt;&lt;strong&gt;个版本的功能是一模一样的，只是版权会有点不同。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以Keil5插件为例，Keil5的插件是Device family pack（其实上文已经提到它了），其安装界面如下所示（安装过程中有可能会报错，不要管它！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225648458-207165702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225728281-639623051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt; 以Windows系统为例，下载上图中的红圈中的win32版本，得到“nRF5x-Command-Line-Tools_9_7_2_Installer.exe”之类的可执行文件，双击安装，界面如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225825275-2081613229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;安装过程中，不要去更改默认选项，直接按照默认选项去安装即可。不过如下界面，一定要选择“select all”&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225837709-1529640434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2. 推荐安装项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安卓版&lt;/strong&gt;&lt;strong&gt;nRF connect&lt;/strong&gt;&lt;strong&gt;或者&lt;/strong&gt;&lt;strong&gt;iOS&lt;/strong&gt;&lt;strong&gt;版&lt;/strong&gt;&lt;strong&gt;nRF connect&lt;/strong&gt;。nRF connect是Nordic开发的一个通用性BLE app，以支持BLE扫描，BLE连接，BLE广播，BLE监视，BLE服务发现，BLE连接后交互等功能。iOS版nRF connect请到苹果app store下载，搜索“nRF”即可以找到。安卓版nRF connect是放在Google play里面的，如果你无法访问Google play，那么可以到Nordic Github官网上下载，下载链接为：&lt;a href=&quot;https://github.com/NordicSemiconductor/Android-nRF-Connect/releases&quot;&gt;https://github.com/NordicSemiconductor/Android-nRF-Connect/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          安装成功后，你将看到如下所示的nRF connect：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225903557-1699494374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225920979-1497263013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;           桌面版nRF connect安装成功后，将如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225932035-380338978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;确切地说，桌面版nRF connect更像一个容器，它可以装载各种不同的应用，前面提到的手机版nRF connect只是桌面版nRF connect的一个“Bluetooth Low Energy”应用。点击“Add/remove apps”，可以安装或者卸载Nordic其他的应用。另外，你也可以基于桌面版nRF connect（使用HTML5或者Javascript）来开发自己的应用，比如量产测试程序。&lt;/p&gt;

&lt;p&gt;注：&lt;strong&gt;桌面版&lt;/strong&gt;&lt;strong&gt;nRF connect&lt;/strong&gt;&lt;strong&gt;前身是Master Control Panel&lt;/strong&gt;&lt;strong&gt;（MCP&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;，Nordic现已正式停止对MCP的支持，MCP所有功能都可以通过桌面版nRF connect来取代和实现。&lt;/p&gt;

&lt;h2&gt;3. 可选安装项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安卓版或者&lt;/strong&gt;&lt;strong&gt;iOS&lt;/strong&gt;&lt;strong&gt;版&lt;/strong&gt;&lt;strong&gt;nRF toolbox&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;nRF toolbox是Nordic开发的一系列BLE应用集，包括心率应用，蓝牙透传应用，DFU等。iOS版nRF toolbox请到苹果app store下载，搜索“nRF”即可以找到。安卓版nRF toolbox是放在Google play里面的，如果你无法访问Google play，那么可以到Nordic Github官网上下载，下载链接为：&lt;a href=&quot;https://github.com/NordicSemiconductor/Android-nRF-Toolbox/releases&quot;&gt;https://github.com/NordicSemiconductor/Android-nRF-Toolbox/releases&lt;/a&gt;。nRF Toolbox代码（包括iOS版和安卓版）是开源的，可以直接到上述Nordic Github上下载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          安装成功后，你将看到如下所示的nRF toolbox：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225959394-556387113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;nRFgo studio&lt;/strong&gt;。图形化的Flash烧写工具，以及nRF24系列开发工具，而且还集成有DTM，DFU升级等功能，不过随着桌面版nRF connect功能越来越多，nRFgo studio越来越被边缘化，因为大部分nRFgo studio的功能都可以被桌面版nRF connect取代，比如Flash烧写，DFU等。nRFgo studio下载链接为：&lt;a href=&quot;https://www.nordicsemi.com/eng/Products/2.4GHz-RF/nRFgo-Studio/(language)/eng-GB#Downloads&quot;&gt;https://www.nordicsemi.com/eng/Products/2.4GHz-RF/nRFgo-Studio/(language)/eng-GB#Downloads&lt;/a&gt;。安装nRFgo studio的时候，请按照默认选项来安装（&lt;strong&gt;不要去更改默认的安装目录&lt;/strong&gt;！），安装成功后，界面如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230015488-1860139169.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：nRFgo studio&lt;/strong&gt;&lt;strong&gt;安装包也自带Jlink&lt;/strong&gt;&lt;strong&gt;驱动安装包，如果你前面通过nRF5x command line tools&lt;/strong&gt;&lt;strong&gt;已经把jlink&lt;/strong&gt;&lt;strong&gt;驱动装好了，那么安装nRFgo studio&lt;/strong&gt;&lt;strong&gt;的时候就不要再安装Jlink&lt;/strong&gt;&lt;strong&gt;驱动了。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;nrfjprog&lt;/strong&gt;&lt;strong&gt;（必选）&lt;/strong&gt;。nrfjprog用于代码擦除烧写读取，芯片复位，存储器访问等，其使用界面（Windows命令行或者Linux命令行或者MacOS命令行）如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230039627-844344989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于在安装nRF5x command line tools的时候，系统就会自动安装nrfjprog，因此你不需要再额外安装nrfjprog。对于Windows系统，nrfjprog将位于如下目录“C:\Program Files (x86)\Nordic Semiconductor\nrf5x\bin” 你只需在Windows path变量（环境变量）中包含此目录，就可以直接在Windows‘Command Prompt’中执行nrfjprog命令了。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230100455-1038825601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;nrfjprog详细说明请参考：&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrf5x_command_line_tools%2Fnrf5x_nrfjprogexe.html&amp;amp;cp=5_1_3&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrf5x_command_line_tools%2Fnrf5x_nrfjprogexe.html&amp;amp;cp=5_1_3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sniffer&lt;/strong&gt;。Sniffer用于抓取空中蓝牙包以debug通信问题，sniffer包括硬件和软件两部分，硬件就是一个nRF51的dongle或者PCA10028开发板或者PCA10040开发板（将来还会支持PCA10056开发板以及PCA10059 dongle），硬件连接图如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230113482-318584895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;软件就是Wireshark，界面如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230124589-1202823407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Sniffer详细使用说明请参考：&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fsniffer%2Fsniffer_intro.html&amp;amp;cp=5_4&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fsniffer%2Fsniffer_intro.html&amp;amp;cp=5_4&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;低版本（&lt;/strong&gt;&lt;strong&gt;0.x.x&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;。低版本nrfutil主要用于&lt;strong&gt;明文&lt;/strong&gt;&lt;strong&gt;OTA/DFU&lt;/strong&gt;时生成手机端新固件zip包，安装nRFgo studio的时候，会自动安装nrfutil，nrfutil所在目录为“C:\Program Files (x86)\Nordic Semiconductor\nRFgo Studio”。 你只需在Windows path变量（环境变量）中包含此目录，就可以直接在Windows‘Command Prompt’中执行nrfutil命令了&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230143188-1255298707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;低版本nrfutil工作界面如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230216670-78836960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt;高版本&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;&amp;gt;1.5.0&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;。高版本nrfutil用于&lt;strong&gt;签名&lt;/strong&gt;&lt;strong&gt;OTA/DFU&lt;/strong&gt;时生成手机端新固件 zip包，以及生成公私钥对，生成settings page，执行DFU操作等，&lt;strong&gt;高版本&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;&lt;strong&gt;和低版本nrfutil&lt;/strong&gt;&lt;strong&gt;是两个完全不兼容的软件，使用的时候，一定要“&lt;/strong&gt;&lt;strong&gt;二选一”&lt;/strong&gt;，一般来说只有在早期的SDK9/10/11进行明文DFU的时候，才会用到低版本nrfutil，除此之外，都是要使用高版本nrfutil的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;高版本nrfutil&lt;/strong&gt;&lt;strong&gt;安装说明及使用说明请参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_intro.html&amp;amp;cp=5_5&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_intro.html&amp;amp;cp=5_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可通过“nrfutil version”来得知当前nrfutil是高版本还是低版本，如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230245354-1507762851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;低版本nrfutil版本号一般为0.x.x，而高版本nrfutil版本号大于1.5.0。如果发现nrfutil版本弄错了，&lt;strong&gt;请通过修改&lt;/strong&gt;&lt;strong&gt;Windows path&lt;/strong&gt;&lt;strong&gt;变量（环境变量）来指向正确的nrfutil&lt;/strong&gt;&lt;strong&gt;版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 15 May 2018 15:22:00 +0000</pubDate>
<dc:creator>iini</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iini/p/9043565.html</dc:identifier>
</item>
</channel>
</rss>