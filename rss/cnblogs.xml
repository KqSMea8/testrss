<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>PHP多进程系列笔记（二） - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/9196593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/9196593.html</guid>
<description>&lt;p&gt;上一篇文章讲解了&lt;code&gt;pcntl_fork&lt;/code&gt;和&lt;code&gt;pcntl_wait&lt;/code&gt;两个函数的使用，本篇继续讲解PHP多进程相关新知识。&lt;/p&gt;
&lt;h2 id=&quot;僵尸zombie进程&quot;&gt;僵尸(zombie)进程&lt;/h2&gt;
&lt;p&gt;这里说下僵尸进程：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;僵尸进程是指的父进程已经退出，而该进程dead之后没有进程接受，就成为僵尸进程(zombie)进程。任何进程在退出前(使用exit退出) 都会变成僵尸进程(用于保存进程的状态等信息)，然后由init进程接管。如果不及时回收僵尸进程，那么它在系统中就会占用一个进程表项，如果这种僵尸进程过多，最后系统就没有可以用的进程表项，于是也无法再运行其它的程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过如下命令查看是否有僵尸进程，如果有，类似下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]'
Z+     282   283 [php] &amp;lt;defunct&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果子进程还没有结束时，父进程就结束了，那么init进程会自动接手这个子进程，进行回收。&lt;/li&gt;
&lt;li&gt;如果父进程是循环，又没有安装&lt;code&gt;SIGCHLD&lt;/code&gt;信号处理函数调用&lt;code&gt;wait&lt;/code&gt;或&lt;code&gt;waitpid()&lt;/code&gt;等待子进程结束。那么子进程结束后，没有回收，就产生僵尸进程了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;br/&gt;fork_zombie.php&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;pcntl_fork&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
    &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fork fail&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}&lt;span class=&quot;kw&quot;&gt;elseif&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;getmypid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;   
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Parent process,pid &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$id}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, child pid &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$pid}\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;   

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;} &lt;span class=&quot;co&quot;&gt;//#1&lt;/span&gt;
}&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;getmypid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;   
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Child process,pid &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$id}\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;   
    &lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行里运行程序，然后新终端查看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ps -A -o stat,ppid,pid,cmd | grep -e '^[Zz]'
Z+    7252  7253 [php] &amp;lt;defunct&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现了一个僵尸进程。这时候就算手动结束脚本程序也无法关闭这个僵尸子进程了。需要使用&lt;code&gt;kill -9&lt;/code&gt;关闭。&lt;/p&gt;
&lt;h2 id=&quot;pcntl_signal&quot;&gt;pcntl_signal&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;bool &lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; int &lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; callback &lt;span class=&quot;kw&quot;&gt;$handler&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[,&lt;/span&gt; bool &lt;span class=&quot;kw&quot;&gt;$restart_syscalls&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数为&lt;code&gt;signo&lt;/code&gt;指定的信号安装一个新的信号处理器。&lt;/p&gt;
&lt;h3 id=&quot;安装sigchld信号&quot;&gt;安装SIGCHLD信号&lt;/h3&gt;
&lt;p&gt;上一节里，我们讲到僵尸进程产生的原因：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果父进程是循环，又没有安装&lt;code&gt;SIGCHLD&lt;/code&gt;信号处理函数调用&lt;code&gt;wait&lt;/code&gt;或&lt;code&gt;waitpid()&lt;/code&gt;等待子进程结束。那么子进程结束后，没有回收，就产生僵尸进程了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本小节我们通过安装SIGCHLD信号处理函数来解决僵尸进程问题。示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 

&lt;span class=&quot;co&quot;&gt;//表示每执行一条低级指令，就检查一次信号，如果检测到注册的信号，就调用其信号处理器&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;declare&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;ticks = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安装SIGCHLD信号&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;SIGCHLD&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;{
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;SIGCHLD &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;pcntl_wait&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$status&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//#2&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;pcntl_fork&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt; == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
    &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fork fail&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}&lt;span class=&quot;kw&quot;&gt;elseif&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$pid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;getmypid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;   
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Parent process,pid &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$id}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, child pid &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$pid}\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;   

    &lt;span class=&quot;co&quot;&gt;//先sleep一下，否则代码一直循环，无法处理信号接收&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;} &lt;span class=&quot;co&quot;&gt;//#1&lt;/span&gt;
}&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
    &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;getmypid&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;   
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Child process,pid &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{$id}\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;   
    &lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt; 
    &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一次注释掉&lt;code&gt;#1&lt;/code&gt;和&lt;code&gt;#2&lt;/code&gt;处的代码，父进程提前结束，子进程被init进程接手，所以没有产生僵尸进程。&lt;br/&gt;第二次我们注释掉&lt;code&gt;#2&lt;/code&gt;处的代码，开启&lt;code&gt;#1&lt;/code&gt;处的代码，即父进程是个死循环，又没有回收子进程，就产生僵尸进程了。&lt;br/&gt;第三次我们开启&lt;code&gt;#1&lt;/code&gt;处和&lt;code&gt;#2&lt;/code&gt;处的代码，父进程由于安装了信号处理，并调用wait函数等待子进程结束，所以也没有产生僵尸进程。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;对子进程的结束不感兴趣&lt;/strong&gt;&lt;br/&gt;如果父进程不关心子进程什么时候结束，那么可以用&lt;code&gt;pcntl_signal(SIGCHLD, SIG_IGN)&lt;/code&gt;通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收，并不再给父进程发送信号。这样我们就不写子进程退出的处理函数了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果去掉&lt;code&gt;declare( ticks = 1 );&lt;/code&gt;无法响应信号。因php的信号处理函数是基于ticks来实现的，而不是注册到真正系统底层的信号处理函数中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装其他信号&quot;&gt;安装其他信号&lt;/h3&gt;
&lt;p&gt;我们可以在主进程安装更多信号，例如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;declare&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; ticks  =  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//信号处理函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;  sig_handler &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
{

     &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
         &lt;span class=&quot;kw&quot;&gt;case &lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGTERM&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;// 处理SIGTERM信号&lt;/span&gt;
              &lt;span class=&quot;fu&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;case &lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGHUP&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;:&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;//处理SIGHUP信号&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;case &lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;:&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Caught SIGUSR1...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;default:&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;// 处理所有其他信号&lt;/span&gt;
      }

}

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Installing signal handler...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安装信号处理器&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGTERM&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;sig_handler&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGHUP&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;   &lt;span class=&quot;st&quot;&gt;&quot;sig_handler&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;sig_handler&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Generating signal SIGTERM to self...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//向当前进程发送SIGUSR1信号&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;posix_kill&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;posix_getpid&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(),&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Done&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：通过 &lt;code&gt;kill -l&lt;/code&gt; 可以看到Linux下所有的信号常量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;kill&lt;/span&gt; -l
 &lt;span class=&quot;kw&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGHUP&lt;/span&gt;   2) &lt;span class=&quot;kw&quot;&gt;SIGINT&lt;/span&gt;   3) &lt;span class=&quot;kw&quot;&gt;SIGQUIT&lt;/span&gt;  4) &lt;span class=&quot;kw&quot;&gt;SIGILL&lt;/span&gt;   5) &lt;span class=&quot;kw&quot;&gt;SIGTRAP&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGABRT&lt;/span&gt;  7) &lt;span class=&quot;kw&quot;&gt;SIGBUS&lt;/span&gt;   8) &lt;span class=&quot;kw&quot;&gt;SIGFPE&lt;/span&gt;   9) &lt;span class=&quot;kw&quot;&gt;SIGKILL&lt;/span&gt; 10) &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGSEGV&lt;/span&gt; 12) &lt;span class=&quot;kw&quot;&gt;SIGUSR2&lt;/span&gt; 13) &lt;span class=&quot;kw&quot;&gt;SIGPIPE&lt;/span&gt; 14) &lt;span class=&quot;kw&quot;&gt;SIGALRM&lt;/span&gt; 15) &lt;span class=&quot;kw&quot;&gt;SIGTERM&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;16&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGSTKFLT&lt;/span&gt;   17) &lt;span class=&quot;kw&quot;&gt;SIGCHLD&lt;/span&gt; 18) &lt;span class=&quot;kw&quot;&gt;SIGCONT&lt;/span&gt; 19) &lt;span class=&quot;kw&quot;&gt;SIGSTOP&lt;/span&gt; 20) &lt;span class=&quot;kw&quot;&gt;SIGTSTP&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;21&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGTTIN&lt;/span&gt; 22) &lt;span class=&quot;kw&quot;&gt;SIGTTOU&lt;/span&gt; 23) &lt;span class=&quot;kw&quot;&gt;SIGURG&lt;/span&gt;  24) &lt;span class=&quot;kw&quot;&gt;SIGXCPU&lt;/span&gt; 25) &lt;span class=&quot;kw&quot;&gt;SIGXFSZ&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;26&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGVTALRM&lt;/span&gt;   27) &lt;span class=&quot;kw&quot;&gt;SIGPROF&lt;/span&gt; 28) &lt;span class=&quot;kw&quot;&gt;SIGWINCH&lt;/span&gt;    29) &lt;span class=&quot;kw&quot;&gt;SIGIO&lt;/span&gt;   30) &lt;span class=&quot;kw&quot;&gt;SIGPWR&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;31&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGSYS&lt;/span&gt;  34) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN&lt;/span&gt;    35) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+1&lt;/span&gt;  36) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+2&lt;/span&gt;  37) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+3&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;38&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+4&lt;/span&gt;  39) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+5&lt;/span&gt;  40) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+6&lt;/span&gt;  41) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+7&lt;/span&gt;  42) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+8&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;43&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+9&lt;/span&gt;  44) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+10&lt;/span&gt; 45) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+11&lt;/span&gt; 46) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+12&lt;/span&gt; 47) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+13&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;48&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+14&lt;/span&gt; 49) &lt;span class=&quot;kw&quot;&gt;SIGRTMIN+15&lt;/span&gt; 50) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-14&lt;/span&gt; 51) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-13&lt;/span&gt; 52) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-12&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;53&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-11&lt;/span&gt; 54) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-10&lt;/span&gt; 55) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-9&lt;/span&gt;  56) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-8&lt;/span&gt;  57) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-7&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;58&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-6&lt;/span&gt;  59) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-5&lt;/span&gt;  60) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-4&lt;/span&gt;  61) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-3&lt;/span&gt;  62) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;63&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX-1&lt;/span&gt;  64) &lt;span class=&quot;kw&quot;&gt;SIGRTMAX&lt;/span&gt;    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;防盗版声明&lt;/strong&gt;：本文系原创文章，发布于公众号&lt;code&gt;飞鸿影的博客(fhyblog)&lt;/code&gt;及&lt;a href=&quot;http://52fhy.cnblogs.com&quot;&gt;博客园&lt;/a&gt;，转载需作者同意。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;ticks相关&quot;&gt;ticks相关&lt;/h3&gt;
&lt;blockquote readability=&quot;7.4596622889306&quot;&gt;
&lt;p&gt;PHP的 &lt;code&gt;ticks=1&lt;/code&gt; 表示每执行1行PHP代码就回调此函数（指的&lt;code&gt;pcntl_signal_dispatch&lt;/code&gt;）。实际上大部分时间都没有信号产生，但ticks的函数一直会执行。如果一个服务器程序1秒中接收1000次请求，平均每个请求要执行1000行PHP代码。那么PHP的pcntl_signal，就带来了额外的 1000 * 1000，也就是100万次空的函数调用。这样会浪费大量的CPU资源。&lt;br/&gt;(摘自：韩天峰(Rango)的博客 » PHP官方的pcntl_signal性能极差&lt;br/&gt;&lt;a href=&quot;http://rango.swoole.com/archives/364&quot; class=&quot;uri&quot;&gt;http://rango.swoole.com/archives/364&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pcntl_signal_dispatch的作用就是查看是否收到了信号需要处理，如果有信号的话，就调用相应的信号处理函数。&lt;/p&gt;
&lt;p&gt;所以上述问题比较好的做法是去掉ticks，转而手动调用&lt;code&gt;pcntl_signal_dispatch&lt;/code&gt;，在代码循环中自行处理信号。&lt;/p&gt;
&lt;p&gt;我们把上一小节的例子改改，不使用ticks：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 

&lt;span class=&quot;co&quot;&gt;//declare( ticks  =  1 );&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//信号处理函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;  sig_handler &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
{

     &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$signo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
         &lt;span class=&quot;kw&quot;&gt;case &lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;:&lt;/span&gt;
             &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Caught SIGUSR1...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
             &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;kw&quot;&gt;default:&lt;/span&gt;
              &lt;span class=&quot;co&quot;&gt;// 处理所有其他信号&lt;/span&gt;
      }

}

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Installing signal handler...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安装信号处理器&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;sig_handler&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Generating signal SIGTERM to self...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//向当前进程发送SIGUSR1信号&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;posix_kill&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;posix_getpid&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(),&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;SIGUSR1&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
pcntl_signal_dispatch&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt;  &lt;span class=&quot;st&quot;&gt;&quot;Done&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Installing signal handler...
Generating signal SIGTERM to self...
Caught SIGUSR1...
Done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比每执行一条php语句都会调用 &lt;code&gt;pcntl_signal_dispatch&lt;/code&gt; 一次，效率好多了。&lt;/p&gt;
&lt;h2 id=&quot;pcntl_alarm&quot;&gt;pcntl_alarm&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;int &lt;span class=&quot;fu&quot;&gt;pcntl_alarm&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt; int &lt;span class=&quot;kw&quot;&gt;$seconds&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数创建一个计时器，在指定的秒数后向进程发送一个 &lt;code&gt;SIGALRM&lt;/code&gt; 信号。每次对 &lt;code&gt;pcntl_alarm()&lt;/code&gt; 的调用都会取消之前设置的alarm信号。注意不是定时器，只会运行一次。&lt;/p&gt;
&lt;p&gt;下面是一个隔5秒发送一个SIGALRM信号，并由signal_handler函数获取，然后打印一个 &lt;code&gt;SIGALRM&lt;/code&gt; 的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?php&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;declare&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;ticks = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//安装SIGALRM信号&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_signal&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;SIGALRM&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;{
    &lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;SIGALRM&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;pcntl_alarm&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//再次调用，会重新发送一个SIGALRM信号&lt;/span&gt;
}&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;pcntl_alarm&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//发送一个SIGALRM信号&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;run...&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;//死循环，否则进程会退出&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;{&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：如果不想使用ticks，那么需要在主循环里主动增加&lt;code&gt;pcntl_signal_dispatch()&lt;/code&gt;调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 23:38:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/9196593.html</dc:identifier>
</item>
<item>
<title>如何通过努力出书，如何写有畅销资质的书，本文汇集了多位计算机图书作者的经验 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/9192155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/9192155.html</guid>
<description>&lt;p&gt;    最近，我在博客园里看到不少网友晒自己写的书，都很精彩，尤其的，我朋友肖同学也写了本《HTTP抓包实战》，&lt;a href=&quot;https://item.jd.com/12375396.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12375396.html&lt;/a&gt;。写书有什么好处？第一能总结，第二能在此基础上不断提升，第三在找工作时帮助很大。我知道在博客园里，有更多的朋友想出书，在本文里，我就来分享下两个话题，第一如何出书以及出书的各种细节，第二，如何写出有畅销资质的书。&lt;/p&gt;
&lt;h4&gt;1   写书对能力的要求未必像想象中那么高，更关键得靠长时间的毅力&lt;/h4&gt;
&lt;p&gt;    开始照例是鸡汤文，我记得看过一篇古文，叫《为学一首示子侄》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180617093659243-1457344482.png&quot; alt=&quot;&quot; width=&quot;226&quot; height=&quot;127&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    其中讲了个故事，四川有两位和尚，一位贫穷一位富裕。穷和尚对富和尚说：“我想去南海。”富和尚说：“您凭借着什么去呢？”穷和尚说：“我只需要一个盛水的水瓶一个盛饭的饭碗就足够了。”富和尚说：“我几年来想要雇船去，尚且没有成功。你凭借着什么去！”到了第二年，穷和尚从南海回来了，把到过南海的这件事告诉富和尚。富和尚的脸上露出了惭愧的神情。&lt;/p&gt;
&lt;p&gt;    我听一些编辑说，他们在招募潜在作者时，不少作者都会说能力不够而拒绝写书，诚然，写书的前提是对这方面的能力要有所了解，否则会误人子弟，但绝非要到成为大牛级别才能写。&lt;/p&gt;
&lt;p&gt;    一般来说，如果要写案例类书，作者需要有大致2年的相关经验，写经验类书，需要有4年左右相关经验。虽然经验是多多益善，但即使感觉经验能力不够，可以通过努力勤奋来弥补。&lt;/p&gt;
&lt;p&gt;    这里我向一些要写书的朋友透个底，出书开始容易结束难，这话怎么讲：给编辑选题大纲和样章后，一般都能开始写，但很多作者（至少7成）写着写着，或者因为工作太忙，或者因为感觉无法把握内容，或者干脆热度过后不想写了，就半途而废了。所以如果大家确实想出书，而且得做好之后至少10个月内吃苦的准备，然后再开始写，否则会耽误自己和编辑的时间。&lt;/p&gt;

&lt;h4&gt;2  如何准备选题，如何找出版渠道&lt;/h4&gt;
&lt;p&gt;    在写作前需要列大纲，也就是书的目录，通过这个步骤，可以大致规划下书的内容。这里给出些不同种类书大纲的列法。&lt;/p&gt;
&lt;p&gt;    1 案例类书，比如讲python机器学习，那么可以在前几章讲概念和一些准备知识，后面一章一个案例，然后每章按案例展开。像这类案例书，着重的是对案例的讲述，比较适合新手作者。&lt;/p&gt;
&lt;p&gt;    2 系列地讲述某个方面的知识，比如讲述spring cloud，或高并发网站架构。&lt;/p&gt;
&lt;p&gt;    在这类书的大纲里，每个章节讲述的这系列中某个方面的知识，比如像spring cloud，其中分ribbon,hystrix等，那么每个章节就可以讲具体的一个组件，然后在每章里，用2级或3级目录再细化地讲述该组件的知识点。&lt;/p&gt;
&lt;p&gt;    3 前瞻性书，比如当市面上还没有机器学习类经典书时，某位大神来一本，这类书就没什么条条框框了，一般就按大神的思路来写。&lt;/p&gt;
&lt;p&gt;    在计划写书后，一定得列出本书的选题，这样就能看出这本书所需要的时间了，写书前，最好在这个领域的每个方面都积累些知识，比如收集些案例，或者至少知道这部分的知识点该从哪里获取。&lt;/p&gt;
&lt;p&gt;      准备好以后，就可以找渠道了，我知道博客园里有不少图书编辑，或者图书出版公司的老师，很荣幸我还认识一些，如果有谁需要，可以私信我。&lt;/p&gt;
&lt;p&gt;     或者，大家可以直接到各出版社的主页上去找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180618070705197-376434888.png&quot; alt=&quot;&quot; width=&quot;156&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    一般来说，各大出版社的主页上，都会在显著位置放着招募选题或作者的内容。&lt;/p&gt;
&lt;h4&gt;3  找出版社编辑还是图书公司编辑&lt;/h4&gt;
&lt;p&gt;    这里说下我的感受，新手作者可以先找图书公司的编辑，他们的作用有些像找工作时的猎头，第一知道出版的渠道比较多，第二往往知道新手作者写书的坑，所以会有针对性的帮助。毕竟新手作者在入门时，可能两眼一抹黑，不知道该怎么办。这时候有位能指导的人，对自己的帮助就很大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180618071202134-1451118291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这里我倒不是说，出版社的编辑帮助就不大，而是说，对新手作者而言，图书公司编辑的帮助似乎更大些。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;如果直接去找出版社的编辑，中间就少了个渠道，&lt;/strong&gt;但出版社的编辑一般直接让作者填选题单，其中要包括大纲，本书特色等内容，这时，如果是资深作者，那么问题不大，但如果是新手作者，要列出符合要求的选题单和大纲，那可能就有些难度的，所以还是建议先找个指导者。&lt;/p&gt;
&lt;p&gt;    况且，可能图书公司的人认识的编辑会多些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180618071812054-1423639358.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    比如某个新手作者的大纲，勉强达到了出版的要求，这时如果直接找编辑，就有可能无法出版了，但如果是图书公司的人，就有可能推荐给多个编辑，那么出版的概率就大些了。&lt;/p&gt;
&lt;p&gt;    而对于资深作者，一般是找编辑，毕竟中间少些流程，中间沟通的成本能少些，钱也能多些。&lt;/p&gt;
&lt;h4&gt;4  稿酬不多，但成大牛后，真能靠书挣钱&lt;/h4&gt;
&lt;p&gt;    打起精神来，这里谈钱了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180618072242280-314104187.png&quot; alt=&quot;&quot; width=&quot;273&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    稿酬分两种。&lt;/p&gt;
&lt;p&gt;    一种是卖断，按页算，比如一页多少钱，我最近一直是按版税算，所以不知道这个行情了，但大家可以照着版税来反推。&lt;/p&gt;
&lt;p&gt;    第二是版税，一般是书的8%，算上个人所得税，估计是7%左右。目前400页的书大概是80出头，我的书，&lt;strong&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt;&lt;/strong&gt;，大概300出头点，原价69。虽然京东等网站会打折，但版税是按原价算。&lt;/p&gt;
&lt;p&gt;    说到这里，有同学可能就乐坏了，一本书如果卖了1万本，岂不是发财了？&lt;/p&gt;
&lt;p&gt;    出版社的常规做法是，第一次印刷是2500到5000本不等，也就是说是按印刷量（有出版社还会按实际销量）乘以一本书的价钱再乘以版税率，算下来，一页估计是35元左右。&lt;/p&gt;
&lt;p&gt;    我们再算比细账，一本350页的书估计要写10个月，收入估计在15000左右，一个月估计也就1500。&lt;/p&gt;
&lt;p&gt;    但这仅仅是开始，如果成为大牛后，就可以待价而沽了，就可以和出版社谈如下的条件。&lt;/p&gt;
&lt;p&gt;    1 版税率可以适当提升，比如可以到12%。2 首次印刷数量，可以提升到5000本。&lt;/p&gt;
&lt;p&gt;    如果你的书真的在市面上有一定影响了，那么这真不是问题了。&lt;/p&gt;
&lt;p&gt;    比如某位大牛用了10个月写了一本350页的书，就算70元，按12%的版税，印了5000册，半年卖完，然后第二次印刷，一年卖了10000册，那么这本书的收入就8万多了，平摊到1个月就8千了，就不算少了，而且，年销量1万本只是勉强算得上畅销，也就是畅销书的作者收入更高。  &lt;/p&gt;
&lt;h4&gt;5  写书就得写畅销书，别敷衍（综述篇）&lt;/h4&gt;
&lt;p&gt;    我见过不少作者，他们一旦打定主意开始写书了，就真的是全力以赴，往畅销书的方向努力了。&lt;/p&gt;
&lt;p&gt;    一本书是否畅销，有时候得靠推广等手段，有时候还得看市场，甚至得凭运气，但有一点很重要，内容得给力，如果是敷衍读者，那么读者一定不会买。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180618074045552-2022577982.png&quot; alt=&quot;&quot; width=&quot;210&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这里我们讲述下策划畅销书的一些要点。&lt;/p&gt;
&lt;p&gt;    1 挑选一个热门话题&lt;/p&gt;
&lt;p&gt;    话题可以是当前比较流行的，或者说，用得人比较多，这样潜在读者的群体就很大了，同时最好组合些热门元素，比如python加数据统计，python加机器学习，或者spring cloud加架构，又如java web框架加面试等。&lt;/p&gt;
&lt;p&gt;   选择时，别选太冷门的，也就是用得人比较少，一般来说，大家可以去看下市面上的招聘广告，哪些技能出现的频率较高，这方面一般就比较热门，大家就可以选这类话题。&lt;/p&gt;
&lt;p&gt;   2 选择读者群，然后有取舍地选择内容点&lt;/p&gt;
&lt;p&gt;    概括来讲，一边本可以面向零基础，或初学者（2年之内经验），或高级开发或测试（3年左右的），或资深开发或测试。&lt;/p&gt;
&lt;p&gt;    一般来说，面向初学者的书好写些，而面向高级或资深开发的书比较难写，因为其中得包含足够的经验。&lt;/p&gt;
&lt;p&gt;    这里想说的是，每个群体，都有足够多的人数，换句话说，面向任何人群，只要写好了，这本书照样可以畅销。&lt;/p&gt;
&lt;p&gt;    但新手作者往往会把握不好，明明想面向零基础，但写着写着，就想讲些只有高级开发才能掌握的技能，这就属于好心办坏事了，这就好比在小学的教材中过早提到高中的知识点，这往往会两头不讨好，而无法定位到某个具体的群体的后果是，写出来的书，四不像，结果谁都不会买。&lt;/p&gt;
&lt;p&gt;    3 内容上，一定得切合选中的读者群。&lt;/p&gt;
&lt;p&gt;    比如某本书讲spring cloud，是面向高级开发的，想让读者看好后能升级到架构，那么选内容时，就不能太简单，讲述时，一些基础知识可以少讲，而得选用些适用高级开发的内容，比如在讲其中Ribbon负载均衡时，可以加入架构师平时的项目经验，而没必要过多地讲述项目环境的搭建。&lt;/p&gt;
&lt;p&gt;   4 建议录制视频，毕竟在书里无法动态地给出案例演示，这时视频就更有吸引力了。  &lt;/p&gt;
&lt;h4&gt;6  写畅销书的注意要点（实施篇）&lt;/h4&gt;
&lt;p&gt;    其实写畅销书不容易，这里是给出一些作者的经验体会，更关键的还得靠作者自己不断摸索，但这些作者的体会一定能帮助到大家。&lt;/p&gt;
&lt;p&gt;    1 别大段地引用概念性文字，一般来说，如果1页内纯粹是文字，没图，没表格，没代码，这本书可能就很枯燥。如果大家要写畅销书，一定得结合图表代码来讲。&lt;/p&gt;
&lt;p&gt;    2 案例可以借鉴别人的，但一定得在自己理解的基础上改写，别就运行通了就直接用。&lt;/p&gt;
&lt;p&gt;    这里姑且不说版权问题，如果某段代码作者自己仅仅是运行通过，而不是自己理解，那么一定无法写清楚描述，这类书一定无法吸引到读者。&lt;/p&gt;
&lt;p&gt;    3 任何叙述性文字，文学功底未必好，但得保证无病句错别字，更重要的是，得在自己理解的基础上，用读者群能接受的方式讲述出来。&lt;/p&gt;
&lt;p&gt;    这就是所谓的用心，肯不肯写好是态度问题，而能不能写好是能力问题，只有态度好了，才能静下心来组织文字，从而让你的书能吸引读者。&lt;/p&gt;
&lt;p&gt;    4 可以采用如下的方法组织章节内容，比如我要写spring cloud的书，其中要讲ribbon负载均衡，在这一章里，我可以先讲大致概念，再列ribbon的要点，比如负载均衡的策略，如何实施，以及如何同eureka整合，这就是一些二级目录，（比如1.1和1.2这些就算2级目录），在每个3二级目录里，再用3级目录来细化内容，比如在讲负载均衡策略时，可以用类似1.1.1之类的三级目录来讲述各类负载均衡的算法实现。&lt;/p&gt;
&lt;p&gt;   组织好之后，在每个三级目录里（也就是每个知识点），选用一定量的代码案例来演示，代码之后再用文字说明，这就是一般的写书思路。&lt;/p&gt;
&lt;h4&gt;7 新手作者可以通过写案例书练手&lt;/h4&gt;
&lt;p&gt;    这里首先得说明，出版社对新手的要求不会降低，毕竟如果人家出了本质量不好的书，作者最多是少拿钱，出版社是亏钱了。这就导致新手作者在拿第一个选题和写第一本书时，会有些难度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226172/201806/1226172-20180618231430866-2095912179.png&quot; alt=&quot;&quot; width=&quot;227&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    但之前就讲过，写书靠能力不假，更得靠毅力。对于新手作者来说，只要肯写，那么第一本书可以用案例书来练手。&lt;/p&gt;
&lt;p&gt;    这种书为什么适合新手作者？因为有案例，所以文字叙述量会少些，而且读者往往关注案例，对于案例说明文字，只要别太差就行。&lt;/p&gt;
&lt;p&gt;    这类书的策划和写作方式一般是：&lt;/p&gt;
&lt;p&gt;    1 找个用得比较多的技术，比如最近比较热门的机器学习，然后选个实施语言，比如python。&lt;/p&gt;
&lt;p&gt;     2 从各处找15个案例，请注意这里的案例是综合性案例，一个案例得包含10个左右的文件，能独立地实现一个功能，比如能实现分词统计等。这些案例一定别有版权问题，比如可以通过在自己理解的基础上适当改编。&lt;/p&gt;
&lt;p&gt;     3 往往案例准备全了，书就完成大半工作了，然后就对着案例写说明文字，最好是录个视频，告诉读者这个案例该如何搭建，如何运行。&lt;/p&gt;
&lt;h4&gt;8 总结（更是后继博文的引导篇）&lt;/h4&gt;
&lt;p&gt;    至此，在本篇博文里列出了如何出书以及写畅销书的一些经验。&lt;/p&gt;
&lt;p&gt;    我知道，靠这些仅仅能向大家展示些出书的步骤，而一些经验虽然汇集了众多作者，但限于篇幅，无法逐一展开。&lt;/p&gt;
&lt;p&gt;    所以，如果本文反响好的话，我将在后继针对每个方面着重展开讲，比如如何面向不同的读者群准备措辞，以及如何在用心的基础上选择读者感兴趣的案例和文字。&lt;/p&gt;
&lt;p&gt;    或者如果大家有什么想要听的，或者有作者在写作途中有任何问题，都可以私信来找我，我在和大家交流的同时，一定也能不断扩展我的视野，提升我的能力。 &lt;/p&gt;
&lt;h4&gt;9 版权说明（欢迎转载）和求推荐&lt;/h4&gt;
&lt;p&gt;    本文是利用端午长假的时间写成的，而且我在3天内还加了1天半的班，所以如果文中有疏忽遗漏，万望大家理解，同时也请及时告诉我。如果感觉我的这篇文章写得还行，请大家多多推荐，大家的推荐以及回复乃至批评建议，是我前进的动力。&lt;/p&gt;
&lt;p&gt;    最近有不少公众号转载了我的文章，我不胜荣幸。我的文章，除非有特别说明之外，可以转载，但请保留原作者和原文链接，同时也请全文转载，谢绝二次加工。&lt;/p&gt;
&lt;p&gt;    各位公众号在转载前，请告诉我一下，以便我准备后继的博文，如果大家想听什么话题，也可以告诉我，虽然我事情比较多，但我能写的一定写。&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 23:10:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/9192155.html</dc:identifier>
</item>
<item>
<title>[译文]Domain Driven Design Reference（七）—— 大型战略设计结构 - Zachary_Fan</title>
<link>http://www.cnblogs.com/Zachary-Fan/p/DDDReference7.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zachary-Fan/p/DDDReference7.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本书是Eric Evans对他自己写的《领域驱动设计-软件核心复杂性应对之道》的一本字典式的参考书，可用于快速查找《领域驱动设计》中的诸多概念及其简明解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　&lt;strong&gt;上周末电脑硬盘文件莫名丢失，狼狈了大半周才缓过来 T_T 。《Domain Driven Design Reference》的原版pdf也丢了，好在这篇文章提前翻好了，只是这次没法再次做校对了，大致读了一遍还算通顺，大家讲究看吧~&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其它本系列其它文章地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference1.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（一）—— 前言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_8117860&quot; href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference2.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（二）—— 让模型起作用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_8341318&quot; href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference3.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（三）—— 模型驱动设计的构建模块&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Zachary-Fan/p/DDDReference4.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（四）—— 柔性设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Zachary-Fan/p/DDDReference5.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（五）—— 为战略设计的上下文映射&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Zachary-Fan/p/DDDReference6.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（六）—— 提炼战略设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Zachary-Fan/p/DDDReference7.html&quot; target=&quot;_blank&quot;&gt;[译文]Domain Driven Design Reference（七）—— 大型战略设计结构&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;　　在一个大的系统中，没有任何能够让元素按照其在整个设计模式中的角色来解释它们，好比是开发人员无法看到树木的森林。我们需要能够理解个体在整体中的角色，而不需要深入研究整体的细节。&lt;/p&gt;
&lt;p&gt;　　“大规模结构”是一种语言，可让您广泛地讨论和理解系统。一组高级概念或规则，或两者都为整个系统建立了设计模式。这个组织原则可以指导设计和帮助理解。它有助于协调独立的工作，因为有一个共同的概念:各个部分的角色如何塑造整体。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;设计一种规则或角色和关系的模式，它将跨越整个系统，并且在不详细了解该部分责任的情况下，允许对整个系统中的每个部分进行一些理解。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;演化有序&lt;/h2&gt;
&lt;p&gt;　　无设计的生产系统是没有人能理解整体的，而且它们很难维护。但是，架构可以用预先设计的假设来约束一个项目，并且从应用程序特定部分的开发人员/设计人员那里获得大量权力。很快，开发人员就会降低应用程序以适应结构，或者他们会破坏这个结构，并且根本就没有任何结构，这就导致了不协调开发的问题。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;让这个概念性的大型结构与应用程序一起演进，可能会在过程中变成一种完全不同的结构类型。不要过度限制详细的设计和模型决策必须要有详细的知识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当一个结构可以被发现的时候，就应该采用大规模结构【这2句不是很顺，但也没办法了】，这样就能在不违反模型开发的前提下，大大澄清系统。因为一个不合适的结构比没有更糟糕，所以最好不要选择全面性，而是寻找一个最小的集合来解决已经出现的问题。少即是多。&lt;/p&gt;
&lt;p&gt;　　接下来是在一些项目中出现的四种特定模式的大规模结构，它们是这种模式的代表。&lt;/p&gt;

&lt;h2&gt;系统隐喻&lt;/h2&gt;
&lt;p&gt;　　隐喻思维在软件开发中非常普遍，特别是对于模型。但是，“隐喻”的极限编程实践，使用隐喻为整个系统的发展带来秩序已经成为一种特殊的方式。&lt;/p&gt;
&lt;p&gt;　　软件设计往往是非常抽象和难以理解的。开发人员和用户都需要切实的方法来理解系统，并共享整个系统的视图。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当一个与系统的具体类比出现时，它抓住了团队成员的想象力，并且似乎将思维导向有用的方向时，把它作为一个大规模结构。围绕这个隐喻组织设计，并将其吸收到通用语言中。系统隐喻既能促进关于系统的交流，又能引导系统的发展。这增加了系统不同部分的一致性，甚至可能跨越不同的限界上下文。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;职责层&lt;/h2&gt;
&lt;p&gt;　　在面向对象的设计中，每个对象都被分配了一系列的相关职责。责任驱动设计也适用于较大规模。&lt;/p&gt;
&lt;p&gt;　　当每个单独的对象都有手工制定的职责时，没有指导原则，不统一，也没有能力一起处理大范围的领域。为了实现一个大型模型的一致性，对这些责任的分配施加一些结构是有用的。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;查看模型中的概念依赖关系，以及领域不同部分的变化率和变化源。如果你确定了领域中的自然层次，就把它们作为宽泛的抽象职责。这些职责应该讲述一个关于您的系统的高级目标和设计的故事。重构模型，使每个领域对象、聚合和模块的职责完全符合一个层的职责。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;知识层次&lt;/h2&gt;
&lt;p&gt;　　一组描述另一组对象应该如何表现的对象。&lt;/p&gt;
&lt;p&gt;　　在一个应用程序中，实体之间的角色和关系在不同的情况下有所不同，复杂性可能会爆炸。既不是完全通用的模型，也不是用户需要的高度定制的模型。对象最终引用其他类型来涵盖各种情况，或者在不同情况下以不同方式使用的属性。具有相同数据和行为的类可能只是为了适应不同的程序集规则而组装。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;创建一组可用于描述和约束基本模型的结构和行为的独特对象。将这些关注点分为两个“层次”，一个非常具体，另一个反映用户或超级用户能够自定义的规则和知识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（见Fowler，M.1997。分析模式：可重复使用的对象模型，Addison-Wesley。）&lt;/p&gt;

&lt;h2&gt;可插拔组件框架&lt;/h2&gt;
&lt;p&gt;　　机会出现在一个非常成熟的模型中，并且是深入和精炼的。一个可插拔组件框架通常只有在几个应用程序已经在同一个领域中实现之后才开始发挥作用。&lt;/p&gt;
&lt;p&gt;　　当各种应用程序必须互操作时，所有的应用程序都基于相同的抽象，但是独立地设计，在多个有界的上下文之间的转换会限制集成。对于不紧密协作的团队来说，共享内核是不可行的。复制和碎片化增加了开发和安装成本，互操作性变得非常困难。&lt;/p&gt;
&lt;p&gt;　　因此：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;提炼接口和交互的抽象核心，并创建一个允许这些接口的各种实现自由替换的框架。同样，允许任何应用程序使用这些组件，只要它严格地通过抽象核心的接口进行操作即可。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/Zachary-Fan&quot; target=&quot;_blank&quot;&gt;Zachary_Fan&lt;/a&gt;&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/Zachary-Fan/p/DDDReference7.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/Zachary-Fan/p/DDDReference7.html&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;如果你想及时得到个人自写文章的消息推送，欢迎扫描下面的二维码~。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/397048/201805/397048-20180508110423470-695014188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 22:49:00 +0000</pubDate>
<dc:creator>Zachary_Fan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Zachary-Fan/p/DDDReference7.html</dc:identifier>
</item>
<item>
<title>数据压缩的重要组成部分---位操作 - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/9153691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/9153691.html</guid>
<description>&lt;h3&gt;数据压缩描述&lt;/h3&gt;
&lt;p&gt;数据压缩是一个减少数据存储空间的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据压缩包括两个过程：一个过程是，压缩或编码数据，数据大小减小；另一个过程是，解压缩或解码数据，还原到数据本身的状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据信息的内容，所有的数据都会表现出一定的特性，称为熵（从热力学借用的一个术语）。压缩是可能的，因为绝大多数数据所表现出来的容量都大于其熵所建议的最佳容量。为了衡量压缩的效率，通常用1减去压缩数据大小除以原始数据大小的值。这个值称为数据的压缩率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从广义上讲，数据压缩的方法分为两大类：有损压缩和无损压缩&lt;/strong&gt;。在有损压缩中，我们接受数据有一定的损失来换取更大的压缩比。在某些应用中，一定的损失是可以接受的，比如图像或音频的处理，因为这种损失不会影响其效果并且会受到严格控制。然而，我们通常使用的是无损压缩，它能够保证解压缩时准确的还原原始数据。&lt;/p&gt;
&lt;p&gt;我们重点介绍无损压缩，实现无损压缩主要有两种方法：最小冗余编码和基于字典的方法。最小冗余编码使用更少的位对出现更为频繁的字符进行编码，用较长的位对出现频繁较低的字符进行编码。在基于字典的方法中，其通过对数据进行符号编码，来代替那些重复多余的短语。&lt;/p&gt;
&lt;h3&gt;数据压缩的重要组成部分&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;位操作是数据压缩的重要组成部分，因为绝大多数方法在某种程度上都需要对数据的位进行操作&lt;/strong&gt;。C语言本身提供了一些位操作的接口，可以用这些接口来实现一些扩展的位操作类。&lt;/p&gt;
&lt;p&gt;我们先来看一下数据压缩的头文件(在数据压缩介绍中必不可少，包括各种符号常量、压缩、解压缩的接口等)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;compress.h  数据压缩的头文件&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#ifndef COMPRESS_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; COMPRESS_H&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bitree.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义霍夫曼树的节点数据结构&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HuffNode_
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; symbol;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;           freq;
}HuffNode;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义霍夫曼代码表中条目的数据结构&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HuffCode_
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;  used;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;  code;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;  size;
}HuffCode;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义LZ77令牌成员所需要的位数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; LZ77_TYPE_BITS   1
&lt;span&gt;#define&lt;/span&gt; LZ77_WINOFF_BITS 12
&lt;span&gt;#define&lt;/span&gt; LZ77_BUFLEN_BITS 5
&lt;span&gt;#define&lt;/span&gt; LZ77_NEXT_BITS   8

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义滑动窗口的大小和LZ77的超前缓冲区.
每个都必须小于或等于2，分别提高到LZ77_WINOFF_BITS和LZ77_BUFLEN_BITS。
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; LZ77_WINDOW_SIZE  4096
&lt;span&gt;#define&lt;/span&gt; LZ77_BUFFER_SIZE  32 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义LZ77短语标记的位数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; LZ77_SYMBOL_BITS  (LZ77_TYPE_BITS + LZ77_WINOFF_BITS + LZ77_NEXT_BITS + LZ77_BUFLEN_BITS)

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;函数接口&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; huffman_compress(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *original, unsigned &lt;span&gt;char&lt;/span&gt; **compressed, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; huffman_uncompress(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *compressed, unsigned &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;original);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lz77_compress(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *original, unsigned &lt;span&gt;char&lt;/span&gt; **compressed, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; lz77_uncompress(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *compressed, unsigned &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;original);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; COMPRESS_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;位操作的描述&lt;/h3&gt;
&lt;p&gt;在压缩和解压缩数据时，常常要在小于一个字节的数量级上进行数据操作。所以，在学习各种数据压缩的方法之前，必须熟悉一些对数据位进行的操作，这非常重要。本节展示的方法包含了对任意位的缓冲区的操作。当然，这里介绍的位操作只是一部分，只是定义了现在数据压缩和后续的数据加密中所要用到的操作。&lt;/p&gt;
&lt;h3&gt;位操作的接口定义&lt;/h3&gt;
&lt;p&gt;bit_get&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;int bit_get (const unsigned char *bits, int pos);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：相应位所处的状态：0或1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：获取缓冲区bits中处于位置pos的位的状态。缓冲区最左边的位置为0。返回的状态值为0或1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（1）&lt;/p&gt;
&lt;p&gt;bit_set&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;void bit_set (unsigned char *bits, int pos, int state);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：设置缓冲区bits中处于位置pos的位的状态（根据state值来设置）。缓冲区最左边的位设置为0。状态值必须为0或1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（1）&lt;/p&gt;
&lt;p&gt;bit_xor&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;void bit_xor (const unsigned char *bits1, const unsigned char *bits2, unsigned char *bitsx, int size);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值：&lt;/strong&gt;无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：按位计算两个缓冲区bits1和bits2的异或值，其中每个缓冲区包含size个位，然后将结果返回bitsx中。异或的过程是将两个二进制操作数进行运算，&lt;strong&gt;如果操作数据处于位置i的两位相同，得到0；如果处于位置i的两位不同，则返回1&lt;/strong&gt;。例如：11010 异或 01011 = 10001。bitsx所需要的存储空间由函数调用者来管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（B），其中B为每个缓冲区中位的个数。&lt;/p&gt;
&lt;p&gt;bit_rot_left&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;void bit_rot_left (unsigned char *bits, int size, int count);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;/strong&gt;：无&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：轮转缓冲区bits（含size位），将位值向左移动count位。此操作完成后，处于最左端的count位移动到缓冲区的最右端，而且其他的位也相应的轮转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复杂度&lt;/strong&gt;：O（nB），其中B为每个缓冲区中位的个数，n为要轮转到左边的位数。&lt;/p&gt;
&lt;h3&gt;位操作的实现与分析&lt;/h3&gt;
&lt;p&gt;每个位操作都可操作缓冲区中的数据，缓冲区由无符号字符作为指针来指定。该指针指向足够多的字节来表示缓冲区中的位数。如果缓冲区中的位数不是8的倍数，那么说明最后一个字节的某些位没有使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_get&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_get操作获取缓冲区中一个位的状态&lt;/strong&gt;。要做到这一点，首先要确定位所在的字节，然后通过一个掩码从字节中获取相应的位。掩码中设置为1的位是将要从字节中读出的位，用一个循环操作将此位移动到适当的位置，通过索引bits中相应的字节，并应用调用后的掩码，可以获取所需的位。&lt;/p&gt;
&lt;p&gt;bit_get的时间复杂度为O（1）。这是因为获取缓冲区中的位的状态所进行的操作都能够在固定的时间内完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_set 操作设置缓冲区中的一个位的状态&lt;/strong&gt;。此操作与bit_get的工作方式相似，只是它是利用掩码设置指定的位的状态，而bit_get是获取指定位的状态。&lt;/p&gt;
&lt;p&gt;bit_set的时间复杂度为O（1）。这是因为获取缓冲区中位的状态所进行的所有操作都能够在固定的时间内完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_xor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_xor对两个缓冲区bits1和bits2进行按位异或运算，并将计算的结果放到缓冲区bitsx中。&lt;/strong&gt;要做到这一点，将bits1中第i个位置的位与bits2中第i个位置的位进行比较，如果位值相同，将第i个位置的位置为0；否则，将第i个位置的位置为1。这个过程持续下去直到缓冲区中size指定的每个位都计算完成。&lt;/p&gt;
&lt;p&gt;bit_xor的时间复杂度为O（B），其中B是每个缓冲区中的位数。这是因为此操作要在每个位上循环迭代一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_rot_left&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bit_rot_left将缓冲区指定数量的位向左轮转。&lt;/strong&gt;首先，保存最左端字节的最左端的位，然后向左一位一位地移动每个字节的位值。在移动字节的过程中，将前一个字节最右边的位移动到当前字节的最左边。当处理到最后一个字节时，将其最右边的位移动到首字节的最高位上。这个过程一直持续下去直到所有的位都轮转到位。&lt;/p&gt;
&lt;p&gt;bit_rot_left的时间复杂度为O（nB），其中n为要向左轮转的位的个数，B是缓冲区中位的个数。这是因为，对于每次轮转，要进行（B/8）+1次移动。&lt;/p&gt;
&lt;p&gt; 示例：位操作的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;bit.c  位操作的实现&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;bit_get  获取缓冲区bits中处于pos位的状态&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; bit_get(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *bits, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos)
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;  mask;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;            i;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置掩码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    mask &lt;/span&gt;=&lt;span&gt; ox80;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;(pos % &lt;span&gt;8&lt;/span&gt;); i++&lt;span&gt;)
        mask &lt;/span&gt;= mask &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;用位与运算获取对应的位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; (((mask &amp;amp; bits[(&lt;span&gt;int&lt;/span&gt;)(pos / &lt;span&gt;8&lt;/span&gt;)]) == mask)? &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;bit_set  设置缓冲区bits中位于pos位的状态&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; bit_set(unsigned &lt;span&gt;char&lt;/span&gt; *bits, &lt;span&gt;int&lt;/span&gt; pos, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state)
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; mask;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;           i;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置掩码&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    mask &lt;/span&gt;=&lt;span&gt; ox80;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;(pos % &lt;span&gt;8&lt;/span&gt;); i++&lt;span&gt;)
        mask&lt;/span&gt;=mask&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;依据state设置位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(state)
        bits[pos&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;] = bits[pos/&lt;span&gt;8&lt;/span&gt;] |&lt;span&gt; mask;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        bits[pos&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;] = bits[pos/&lt;span&gt;8&lt;/span&gt;] &amp;amp; (~&lt;span&gt;mask);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;bit_xor  按位异或运算&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; bit_xor(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *bits1,&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *bits2,unsigned &lt;span&gt;char&lt;/span&gt; *bitsx,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算两个缓冲区的按位异或&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;size;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(bit_get(bits1,i) !=&lt;span&gt; bit_get(bits2,i))
            bit_set(bitsx,i,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            bit_set(bitsx,i,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;bit_rot_left 轮转缓冲区bits(含size位)，将位值向左移count位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; bit_rot_left(unsigned &lt;span&gt;char&lt;/span&gt; *bits,&lt;span&gt;int&lt;/span&gt; size,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;  fbit,lbit,i,j;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将缓冲区向左轮转指定位数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(size &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;count; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;=((size-&lt;span&gt;1&lt;/span&gt;)/&lt;span&gt;8&lt;/span&gt;); i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获得要从当前字节偏移的位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                lbit &lt;/span&gt;= bit_get(&amp;amp;bit[i],&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;保存要从首字节移动到后面的位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    fbit &lt;/span&gt;=&lt;span&gt; lbit;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将前一字节最右边的位设置为当前字节最左边的位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    bit_set(&lt;/span&gt;&amp;amp;bits[i-&lt;span&gt;1&lt;/span&gt;],&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,lbit);
                }

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将当前字节向左移动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                bits[i] &lt;/span&gt;= bits[i] &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将缓冲区最右边的位设置为从第一个字节偏移的位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            bit_set(bits,size&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,fbit);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 18 Jun 2018 22:44:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/9153691.html</dc:identifier>
</item>
<item>
<title>基于Vue cli生成的Vue项目的webpack4升级 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/9196906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/9196906.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍从webpack3到webpack4的升级过程&lt;/p&gt;

&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;　　相比于webpack3，webpack4可以零配置运行，打包速度比之前提高了90%，可以直接到ES6的代码进行无用代码剔除，新增的optimization使用简单&lt;/p&gt;
&lt;p&gt;　　在未来，CSS、HTMl和文件都会成为原生模块&lt;/p&gt;
&lt;p&gt;【0配置】&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　webpack4&lt;/code&gt; 设置了默认值，以便无配置启动项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
entry 默认值是 ./src/&lt;span&gt;
output.path 默认值是 .&lt;/span&gt;/&lt;span&gt;dist
mode 默认值是 production&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【模块类型】&lt;/p&gt;
&lt;p&gt;　　webpack4提供了5种模块类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;json: 可通过 require 和 import 导入的 JSON 格式的数据(默认为 .json 的文件)
webassembly: WebAssembly 模块，（目前是 .wasm 文件的默认类型）
javascript/&lt;span&gt;auto: (webpack 3中的默认类型)支持所有的JS模块系统：CommonJS、AMD。
javascript/&lt;span&gt;esm: EcmaScript模块（默认 .mjs 文件）。
javascript/dynamic: 仅支持 CommonJS &amp;amp;&lt;span&gt; AMD。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　webpack 4 不仅支持本地处理 JSON，还支持对 JSON 的 Tree Shaking。当使用 ESM 语法 import json 时，webpack 会消除掉JSON Module 中未使用的导出。此外，如果要用 loader 转换 json 为 js，需要设置 type 为 javascript/auto&lt;/p&gt;

&lt;h3&gt;模式mode&lt;/h3&gt;
&lt;p&gt;　　相比于webpack3，webpack4新增了一个mode配置选择，用来表示配置模式的选择情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  mode: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;production&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　包括生产环境production、开发环境devolopment和自定义none这三个选择可选&lt;/p&gt;
&lt;p&gt;【开发模式】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;浏览器调试工具
注释、开发阶段的详细错误日志和提示
快速和优化的增量构建机制
开启 output.pathinfo 在 bundle 中显示模块信息
开启 NamedModulesPlugin
开启 NoEmitOnErrorsPlugin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【生产模式】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;启用所有优化代码的功能
更小的bundle大小
去除只在开发阶段运行的代码
关闭内存缓存
Scope hoisting 和 Tree&lt;/span&gt;-&lt;span&gt;shaking
开启 NoEmitOnErrorsPlugin
开启 ModuleConcatenationPlugin
开启 optimization.minimize&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【none】&lt;/p&gt;
&lt;p&gt;　　禁用所有的默认设置&lt;/p&gt;

&lt;h3&gt;optimization&lt;/h3&gt;
&lt;p&gt;　　从webpack4开始官方移除了commonchunk插件，改用了optimization属性进行更加灵活的配置，下面来介绍optimization下的一些常用配置项&lt;/p&gt;
&lt;p&gt;【minimize】&lt;/p&gt;
&lt;p&gt;　　利用unglifyjsWebpackPlugin插件来压缩模块，生产环境下该值默认为true&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  optimization: {
    minimize: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【minimier】&lt;/p&gt;
&lt;p&gt;　　可以使用其他插件来执行压缩功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; UglifyJsPlugin = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uglifyjs-webpack-plugin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;  optimization: {
    minimizer: [
      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; UglifyJsPlugin({ &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; your config &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; })
    ]
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【splitChunks】&lt;/p&gt;
&lt;p&gt;　　webpack4默认使用splitChunksPlugin插件来实现代码分割功能，来替代webpack3中的commonChunksPlugin插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;  optimization: {
    splitChunks: {
      chunks: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      minSize: &lt;/span&gt;&lt;span&gt;30000&lt;/span&gt;&lt;span&gt;,
      minChunks: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
      maxAsyncRequests: &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
      maxInitialRequests: &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
      automaticNameDelimiter: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      name: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      cacheGroups: {
        vendors: {
          test: &lt;/span&gt;/[\\/]node_modules[\\/]/&lt;span&gt;,
          priority: &lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: {
          minChunks: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
          priority: &lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
          reuseExistingChunk: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        }
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【runtimeChunk】&lt;/p&gt;
&lt;p&gt;　　通过设置 runtimeChunk: true 来为每一个入口默认添加一个只包含 runtime 的 chunk&lt;/p&gt;
&lt;p&gt;　　通过提供字符串值，可以使用插件的预设模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;signal: 创建一个被所有生成的块共享的runtime文件
multiple: 为共同的块创建多个runtime文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　缺省值为false，表示每个入口块默认内嵌runtime代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    runtimeChunk {
      name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【noEmitOnErrors】&lt;/p&gt;
&lt;p&gt;　　只要在编译时出现错误，就使用noEmitOnErrors属性来跳过emit 阶段，用来替代&lt;code&gt;NoEmitOnErrorsPlugin&lt;/code&gt; 插件&lt;/p&gt;
&lt;p&gt;【nameModules】&lt;/p&gt;
&lt;p&gt;　　使用可读的模块标识，方便更好的调试。webpack在开发模式下默认开启，生产模式下默认关闭，用来替代 &lt;code&gt;NamedModulesPlugin&lt;/code&gt; 插件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;  optimization: {
    namedModules: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;升级&lt;/h3&gt;
&lt;p&gt;　　下面就基于vue-cli的项目对webpack配置进行升级&lt;/p&gt;
&lt;p&gt;　　1、升级nodejs&lt;/p&gt;
&lt;p&gt;　　使用 webpack4 时，必须保证 Node.js 版本 &amp;gt;= 8.9.4，因为 webpack4 使用了大量的ES6语法，这些语法在 nodejs新版 v8 中得到了原生支持&lt;/p&gt;
&lt;p&gt;　　2、升级webpack主要部件，包括webpack、webpack-bundle-analyzer、webpack-dev-server、webpack-merge&lt;/p&gt;
&lt;p&gt;　　升级的操作很简单，先删除，再安装即可。但要注意的是webpack4版本中 cli 工具分离成了 &lt;code&gt;webpack&lt;/code&gt; 核心库 与 &lt;code&gt;webpack-cli&lt;/code&gt; 命令行工具两个模块，需要使用 &lt;code&gt;CLI&lt;/code&gt;，必安装 &lt;code&gt;webpack-cli&lt;/code&gt; 至项目中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm uninstall -D webpack webpack-bundle-analyzer webpack-dev-server webpack-merge
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install -D webpack webpack-cli webpack-bundle-analyzer webpack-dev-server webpack-merge
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、升级webpack相关插件，包括copy-webpack-plugin、css-loader、eslint-loader、file-loader、html-webpack-plugin、url-loader、friendly-errors-webpack-plugin、optimize-css-assets-webpack-plugin、uglifyjs-webpack-plugin&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cnpm uninstall -D copy-webpack-plugin css-loader eslint-loader file-loader html-webpack-plugin url-loader  friendly-errors-webpack-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cnpm install -D copy-webpack-plugin css-loader eslint-loader file-loader html-webpack-plugin url-loader  friendly-errors-webpack-plugin optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、升级vue-loader&lt;/p&gt;
&lt;p&gt;　　由于vue-loader升级到版本15后，配置有较多的变化，稳妥起见，可以只将vue-loader升级到14.4.2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm uninstall -D vue-&lt;span&gt;loader
cnpm uninstall &lt;/span&gt;-D vue-loader@&lt;span&gt;14.4.2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、替换webpack相关插件，extract-text-webpack-plugin替换为mini-css-extract-plugin&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm uninstall -D extract-text-webpack-plugin
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cnpm install -D mini-css-extract-plugin
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;配置&lt;/h3&gt;
&lt;p&gt;　　下面对配置文件的修改进行详细说明：&lt;/p&gt;
&lt;p&gt;　　1、webpack.base.conf.js文件&lt;/p&gt;
&lt;p&gt;　　增加node:process.env.NODE_ENV即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
&lt;/span&gt;+&lt;span&gt;  mode: process.env.NODE_ENV,
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、webpack.prop.conf.js文件&lt;/p&gt;
&lt;p&gt;　　该文件的配置项较为复杂&lt;/p&gt;
&lt;p&gt;　　（1）将ExtractTextPlugin替换为MiniCssExtraPlugin&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
+ &lt;span&gt;const&lt;/span&gt; MiniCssExtractPlugin = require(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mini-css-extract-plugin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;- &lt;span&gt;const&lt;/span&gt; ExtractTextPlugin = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;extract-text-webpack-plugin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

...
&lt;/span&gt;-    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtractTextPlugin({
&lt;/span&gt;+    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MiniCssExtractPlugin({
      filename: utils.assetsPath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;css/[name].[contenthash].css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
      allChunks: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    }),
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）删除UglifyJsPlugin配置项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
- &lt;span&gt;const&lt;/span&gt; UglifyJsPlugin = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uglifyjs-webpack-plugin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;- &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UglifyJsPlugin({
&lt;/span&gt;-&lt;span&gt;      uglifyOptions: {
&lt;/span&gt;-&lt;span&gt;        compress: {
&lt;/span&gt;-          warnings: &lt;span&gt;false&lt;/span&gt;
-&lt;span&gt;        }
&lt;/span&gt;-&lt;span&gt;      },
&lt;/span&gt;-&lt;span&gt;      sourceMap: config.build.productionSourceMap,
&lt;/span&gt;-      parallel: &lt;span&gt;true&lt;/span&gt;
- })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）删除CommonsChunkPlugin配置项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
- &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
&lt;/span&gt;-      name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;vendor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;-&lt;span&gt;      minChunks (module) {
&lt;/span&gt;-        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;-          module.resource &amp;amp;&amp;amp;
-          /\.js$/.test(module.resource) &amp;amp;&amp;amp;
-&lt;span&gt;          module.resource.indexOf(
&lt;/span&gt;-            path.join(__dirname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../node_modules&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;-          ) === &lt;span&gt;0&lt;/span&gt;
-&lt;span&gt;        )
&lt;/span&gt;-&lt;span&gt;      }
&lt;/span&gt;-&lt;span&gt;    }),
&lt;/span&gt;-    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
&lt;/span&gt;-     name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;manifest&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;-&lt;span&gt;      minChunks: Infinity
&lt;/span&gt;-&lt;span&gt;    }),
&lt;/span&gt;-    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
&lt;/span&gt;-      name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;-      &lt;span&gt;async&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;vendor-async&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;-      children: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;-      minChunks: &lt;span&gt;3&lt;/span&gt;
-&lt;span&gt;    }), 
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（4）添加optimization配置项&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
+&lt;span&gt;  optimization: {
&lt;/span&gt;+&lt;span&gt;    splitChunks: {
&lt;/span&gt;+      chunks: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;async&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+      minSize: &lt;span&gt;30000&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+      minChunks: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+      maxAsyncRequests: &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+      maxInitialRequests: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+      automaticNameDelimiter: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+      name: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+&lt;span&gt;      cacheGroups: {
&lt;/span&gt;+&lt;span&gt;        vendors: {
&lt;/span&gt;+          test: /[\\/]node_modules[\\/]/&lt;span&gt;,
&lt;/span&gt;+          priority: -&lt;span&gt;10&lt;/span&gt;
+&lt;span&gt;        },
&lt;/span&gt;+        &lt;span&gt;default&lt;/span&gt;&lt;span&gt;: {
&lt;/span&gt;+          minChunks: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+          priority: -&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;+          reuseExistingChunk: &lt;span&gt;true&lt;/span&gt;
+&lt;span&gt;        }
&lt;/span&gt;+&lt;span&gt;      }
&lt;/span&gt;+&lt;span&gt;    },
&lt;/span&gt;+    runtimeChunk: { name: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;runtime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;+  },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　详细配置移步&lt;a href=&quot;https://github.com/littlematch0123/blog-client&quot; target=&quot;_blank&quot;&gt;前端小站源码&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 18:42:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/9196906.html</dc:identifier>
</item>
<item>
<title>编程开发之--Oracle数据库--存储过程和存储函数（1） - ZeroMZ</title>
<link>http://www.cnblogs.com/ZeroMZ/p/9189706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZeroMZ/p/9189706.html</guid>
<description>&lt;p&gt;1、存储过程和存储函数&lt;/p&gt;
&lt;p&gt;描述：指存储在数据库中供所有用户程序调用的子程序叫做存储过程、存储函数&lt;/p&gt;
&lt;p&gt;区别：存储函数可以通过return子句返回一个函数的值&lt;/p&gt;
&lt;p&gt;（1）存储过程&lt;/p&gt;
&lt;p&gt;     语法：create [or replace] PROCEDURE 过程名（参数列表）&lt;/p&gt;
&lt;p&gt;                AS&lt;/p&gt;
&lt;p&gt;                PLSQL子程序体;&lt;/p&gt;
&lt;p&gt;     存储过程的调用方式：&lt;/p&gt;
&lt;p&gt;         a)exec/execute 过程名();&lt;/p&gt;
&lt;p&gt;         b)begin&lt;/p&gt;
&lt;p&gt;                 过程名();&lt;/p&gt;
&lt;p&gt;                 过程名();&lt;/p&gt;
&lt;p&gt;             end;&lt;/p&gt;
&lt;p&gt;              /&lt;/p&gt;
&lt;p&gt;       带参数的存储过程：&lt;/p&gt;
&lt;p&gt;           举例：为指定的员工涨100块钱工资，并且打印涨前以及涨后的工资。&lt;/p&gt;
&lt;p&gt;               在sql developer中创建带参数的存储过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create or replace PROCEDURE raisesalary(eno in number)
as
  --定义一个变量保存涨前的薪水
  psal emp.sal%type;
begin
  --得到员工涨前的薪水
  select sal into psal from emp where empno=eno;
  
  --给该员工涨100
  update emp set sal=sal+100 where empno=eno;
  
  --注意：一般不在存储过程或者存储函数中，commit和rollback。
  
  --打印
  DBMS_OUTPUT.PUT_LINE('涨前：'||psal||'涨后：'||(psal+100));
end;
/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;           使用sql developer调试调用plsql程序：&lt;/p&gt;
&lt;p&gt;               &lt;img src=&quot;https://images2018.cnblogs.com/blog/1242064/201806/1242064-20180618190749191-1830924238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;               &lt;img src=&quot;https://images2018.cnblogs.com/blog/1242064/201806/1242064-20180618191223874-2033471473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           如果缺少权限，可以使用数据库超管赋予当前用户权限：&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1242064/201806/1242064-20180618191714509-654329278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1242064/201806/1242064-20180618192139869-1109710212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （2）存储函数&lt;/p&gt;
&lt;p&gt;        语法：&lt;/p&gt;
&lt;p&gt;             create [or replace] FUNCTION 函数名(参数列表)&lt;/p&gt;
&lt;p&gt;             return  函数值类型&lt;/p&gt;
&lt;p&gt;             AS&lt;/p&gt;
&lt;p&gt;             PLSQL子程序体；&lt;/p&gt;
&lt;p&gt;         举例：查询某员工的年收入&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create or replace FUNCTION queryempincome(eno in number)
return number
as
  --定义一个变量保存员工的薪水和奖金
  psal emp.sal%type;
  pcomm emp.comm%type;
begin
  --得到员工的月薪和奖金
  select sal,comm into psal,pcomm from emp where empno=eno;
  
  --直接返回年收入
  return psal*12+nvl(pcomm,0);
end;
/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     &lt;span&gt;&lt;em&gt;调试过程类似调试存储过程的步骤!&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、使用存储过程和使用存储函数的一条简单非必要原则：如果只有一个返回值，使用存储函数的return子句返回；如果有多个返回值，则使用存储过程通过out参数返回。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create or replace PROCEDURE queryempinform(eno in number,
                                           pename out varchar2,
                                           psal out number,
                                           pjob out varchar2)
as
begin
  --得到员工的姓名、月薪、职位
  select ename,sal,job into pename,psal,pjob from emp where empno=eno;
end;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　问题思考：&lt;/p&gt;
&lt;p&gt;        a)如果查询某人的所有字段信息（并且字段比较多），该如何解决？&lt;/p&gt;
&lt;p&gt;        b)如何返回多条符合条件的结果集，out参数可以返回结果集吗？&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 16:06:00 +0000</pubDate>
<dc:creator>ZeroMZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZeroMZ/p/9189706.html</dc:identifier>
</item>
<item>
<title>在Golang开发中使用Redis - zzayne</title>
<link>http://www.cnblogs.com/zzayne/p/9196790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzayne/p/9196790.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;周五上班的主要任务是在公司老平台上用redis处理一个队列问题，顺便复习了一下redis操作的基础知识，回来后就想着在自己的博客demo里，用redis来优化一些使用场景，学习一下golang开发下redis的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;redis简单介绍&quot;&gt;Redis简单介绍&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;关于Redis的讨论，其实在现在的后台开发中已经是个老生常谈的问题，基本上也是后端开发面试的基本考察点。其中 Redis的背景介绍和细节说明在这里就不赘述。不管怎么介绍，核心在于Redis是一个基于内存的key-value的多数据结构存储，并可以提供持久化服务。基于内存的特性决定了Redis天然适合高并发的数据读写缓存优化，同时也带来了内存开销过大的问题。所以在一些特定情景下，Redis是一把无往不利的大杀器，值得深入学习。&lt;/p&gt;
&lt;p&gt;学习Redis的一个难点或者说入门点，我个人感觉在于对象存储理念的转变。刚接触&lt;code&gt;Redis&lt;/code&gt;时，我刚从大学毕业，脑子里基本都是关系型数据存储的理念，使用时总想着靠数据内的关系来建立数据之间的联系，用起来很不顺手。后来慢慢入门了才感受到了一些操作的好处。举个栗子，比如查询用户在某个文章下的评论，用&lt;code&gt;sql&lt;/code&gt;的思路就是搜索评论表里面用户ID和文章ID匹配的数据，有时还需要联合查询出其他信息，但是如果是&lt;code&gt;Redis&lt;/code&gt;操作，以'前缀:文章ID:用户ID'为key，比如'comment:666:888'就可以快速取出用户评论，十分方便。&lt;code&gt;Redis&lt;/code&gt;的强大远不仅如此，可以在实践中慢慢体会。&lt;/p&gt;
&lt;h3 id=&quot;主要数据结构&quot;&gt;主要数据结构&lt;/h3&gt;
&lt;p&gt;Redis主要有五种基本数据结构，满足了绝大多数缓存结构的需要，如果你在使用一种结构存储时感觉别扭时，很有可能是选错了存储结构，可以考虑一下其他结构的正确实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;String ，可以是字符串、整数和浮点数。如果是序列化数据，并涉及到修改操作的话，不推荐用&lt;code&gt;string&lt;/code&gt;，可以考虑用&lt;code&gt;Hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hash, key-value 对象，可以存放对象数据，比如用户信息之类。&lt;/li&gt;
&lt;li&gt;List，有序数据集合，元素可以重复，用&lt;code&gt;LPUSH&lt;/code&gt;、&lt;code&gt;LPOP&lt;/code&gt;、&lt;code&gt;RPUSH&lt;/code&gt;、&lt;code&gt;RPOP&lt;/code&gt;等指令组合可以实现栈和队列操作。&lt;/li&gt;
&lt;li&gt;Set，无序集合，元素唯一。&lt;/li&gt;
&lt;li&gt;Sorted Set，Sort的有序版，可以设定&lt;code&gt;Score&lt;/code&gt;值来决定元素排序，适合用户排名这样的业务场景。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常见使用场景&quot;&gt;常见使用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;高并发下数据缓存。 比如在某个场景下，大量日志同时写入数据库会给服务器带来巨大压力，这时可以先将数据写入&lt;code&gt;redis&lt;/code&gt;中，再由&lt;code&gt;redis&lt;/code&gt;写入数据库，减轻同时写入压力。&lt;/li&gt;
&lt;li&gt;热点信息快速显示。假设现在有一个新闻首页，需要快速显示各栏目前20条热点新闻，如果直接查询数据库，在大量用户同时访问下，会消耗极大数量的数据库请求。这时就可以用&lt;code&gt;redis&lt;/code&gt;来优化，在新闻录入的时候将标题、时间和来源写入&lt;code&gt;redis&lt;/code&gt;中，客户端访问时，可以从内存中一次性取出当天热单新闻列表，极大地提高请求速度和节约了服务器开销。&lt;/li&gt;
&lt;li&gt;保存会话信息。可以将登录后用户信息缓存入&lt;code&gt;redis&lt;/code&gt;并同时设置&lt;code&gt;key&lt;/code&gt;过期时间,这样后台&lt;code&gt;api&lt;/code&gt;过滤请求时，就可以从内存中读取用户信息，而且&lt;code&gt;redis&lt;/code&gt;的过期机制，天然支持用户身份有效期校验，用起来十分方便。&lt;/li&gt;
&lt;li&gt;统计计数。比如系统中常见一个功能是限制同一用户固定时间段内的登录次数或者所有请求次数，这时就可以以用户id为key，次数值为value，将计数信息缓存起来，并且有&lt;code&gt;INCRBY&lt;/code&gt;命令原生支持。&lt;/li&gt;
&lt;li&gt;其他。Redis的应用场景十分广发，队列、发布订阅、统计分析等等，可以看看其他文章的介绍说明。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;golang连接redis&quot;&gt;Golang连接Redis&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;Golang&lt;/code&gt;开发的一大直观感受就是，基本上你日常遇到的开发问题，都有官方或者第三方包帮你辅助实现，同时这些包都是开源的，只要你感兴趣，都可以深入到包的内部实现去学习理解包的实现思路和方法。当然这也有利有弊，第三包的不稳定和质量参差不齐也增加了一些开发成本，目前还是感受利大于弊。研究好的包源码实现，也是目前我的一个学习方向。&lt;/p&gt;
&lt;h3 id=&quot;garyburdredigo-包简介&quot;&gt;garyburd/redigo 包简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;garyburd/redigo&lt;/code&gt; 包是网上很多博文都在推荐使用的一个高Star的&lt;code&gt;Redis&lt;/code&gt;连接包，但是当我自己去&lt;code&gt;Github&lt;/code&gt;的项目地址 &lt;a href=&quot;https://github.com/garyburd/redigo&quot;&gt;garyburd/redigo&lt;/a&gt; 上查看&lt;code&gt;API&lt;/code&gt;时，发现这个项目目前是归档状态，项目已经迁移到了&lt;a href=&quot;https://github.com/gomodule/redigo&quot;&gt;gomodule/redigo&lt;/a&gt;，同时包的获取也理所当然地改成了&lt;code&gt;go get github.com/gomodule/redigo/redis&lt;/code&gt;，这已经不是我第一次感受了第三方包的不稳定，之前用&lt;code&gt;dep&lt;/code&gt;进行包管理时，就遇到过&lt;code&gt;dep&lt;/code&gt;拉取的包版本和本地包版本&lt;code&gt;API&lt;/code&gt;冲突的问题，这个有时间单独再说。总之，暂时不管这两个包的详细区别，以下就以新包为准，介绍下&lt;code&gt;redigo&lt;/code&gt;包使用。&lt;/p&gt;
&lt;h3 id=&quot;建立连接池&quot;&gt;建立连接池&lt;/h3&gt;
&lt;p&gt;Redigo Pool 结构维护一个 Redis 连接池。应用程序调用 Get 方法从池中获取连接，并使用连接的 Close 方法将连接的资源返回到池中。一般我们在系统初始化时声明一个全局连接池，然后在需要操作&lt;code&gt;redis&lt;/code&gt;时获得连接，执行指令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pool := &amp;amp;redis.Pool{
        MaxIdle:     3, /*最大的空闲连接数*/
        MaxActive:   8, /*最大的激活连接数*/
        Dial: func() (redis.Conn, error) {
            c, err := redis.Dial(&quot;tcp&quot;, '链接地址，例如127.0.0.1:6379', redis.DialPassword('密码'))
            if err != nil {
                return nil, err
            }
            return c, nil
        }
}
c:=pool.Get()
defer c.Close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;执行指令&quot;&gt;执行指令&lt;/h3&gt;
&lt;p&gt;查看源码，发现&lt;code&gt;Conn&lt;/code&gt; 接口有一个执行 Redis 命令的通用方法：&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;//gomodule/redigo/redis/redis.go&lt;/p&gt;
&lt;p&gt;// Conn represents a connection to a Redis server.&lt;br/&gt;type Conn interface {&lt;br/&gt;// Close closes the connection.&lt;br/&gt;Close() error&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Err returns a non-nil value when the connection is not usable.
Err() error

// Do sends a command to the server and returns the received reply.
Do(commandName string, args ...interface{}) (reply interface{}, err error)

// Send writes the command to the client's output buffer.
Send(commandName string, args ...interface{}) error

// Flush flushes the output buffer to the Redis server.
Flush() error

// Receive receives a single reply from the Redis server
Receive() (reply interface{}, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://redis.io/commands&quot; class=&quot;uri&quot;&gt;http://redis.io/commands&lt;/a&gt; 中的 Redis 命令参考列出了可用的命令。&lt;code&gt;do&lt;/code&gt;的参数和&lt;code&gt;redis-cli&lt;/code&gt;命令参数格式一致，比如&lt;code&gt;SET key value EX 360&lt;/code&gt; 对应函数调用为&lt;code&gt;Do(&quot;SET&quot;, &quot;key&quot;, &quot;value&quot;，&quot;EX&quot;,360)&lt;/code&gt;，常用的命令示例有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
c:=pool.Get()
defer c.Close()
//存值,
_, err := c.Do(&quot;SET&quot;, &quot;key&quot;, &quot;value&quot;)
//设置过期时间
_, err := c.Do(&quot;SET&quot;, &quot;key&quot;, &quot;value&quot;，&quot;EX&quot;,360)
//存int
_, err := c.Do(&quot;SET&quot;, &quot;key&quot;, 2)

//取值
v,err:=redis.String(c.Do(&quot;GET&quot;,&quot;key&quot;))
bytes, err := redis.Bytes(c.Do(&quot;GET&quot;, &quot;key&quot;))

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;golang&lt;/code&gt;中连接使用&lt;code&gt;redis&lt;/code&gt;相对比较简单，所以暂时也没什么其他好说的，如果后面自己使用过程中发现有遗漏再进行补充，关键还是在于熟悉&lt;code&gt;redis-cli&lt;/code&gt;原生的指令操作。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 15:47:00 +0000</pubDate>
<dc:creator>zzayne</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzayne/p/9196790.html</dc:identifier>
</item>
<item>
<title>领域驱动设计的必要性和模型标准——《领域驱动设计-精简版》 - geons</title>
<link>http://www.cnblogs.com/geons/p/9195619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geons/p/9195619.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、领域驱动设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;领域驱动设计早在30年前就已经为人所知，一些设计人员开始&lt;strong&gt;开始领域建模，领域通用语言的思维构造&lt;/strong&gt;，以便能够在领域专家和开发专家形成高效的沟通，Eric Evans将这种思维（思潮）定义为Domain-Driven Desigin（领域驱动设计，简称DDD）。DDD在B/S还不这么流行的年代，主要应用在软件公司，因为很多都是C端，但是现在各个互联网公司将很多业务尝试模块化、量级上规模化，业务上多样化，不再是CRUD这么简单，因此，领域驱动设计在互联网开发中也起到了一个很好的引领作用。这本书在InfoQ上有专家改写出了一本精简版，全文82页，本文主要将个人阅读笔记和思考做分享。可以通过网址直接访问或下载阅读（&lt;a href=&quot;https://files.cnblogs.com/files/anderslly/dddquickly-chinese-version.pdf&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/anderslly/dddquickly-chinese-version.pdf&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、领域驱动设计必要性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 软件开发离不开具体的业务需求，开发人员会先从理解业务开始，此时需要请教领域专家，通过了解专家口中的领域术语，对应转换成软件开发人员能够理解的计算机概念。但是，两种不同的角色身份对于同一领域有不同的理解和表达，为了让两者更加高效和准确理解，同时也提高大型软件系统的可用性，需要建立一个领域模型来向双方反映领域知识，开发人员依据领域模型来开发软件，用代码来实现模型，从而达到了通用的设计流程。实现领域模型驱动软件设计开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、建立一个领域模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;领域模型是沟通领域专家和软件专家的桥梁，也是唯一实现实例抽象成统一模型，而该模型可以被两者认同。所以，在领域驱动设计时候，建立一个领域模型是非常重要的，它一般具有以下特点：&lt;/p&gt;
&lt;p&gt;1、模型有边界，只反映具体某个领域所关注的部分。&lt;/p&gt;
&lt;p&gt;2、领域模型只反映业务，和具体编程语言、技术无关。&lt;/p&gt;
&lt;p&gt;3、领域模型确保了软件逻辑都在一个模型里，也在同一个地方，尽量实现高内聚，低耦合。&lt;/p&gt;
&lt;p&gt;4、领域模型能够帮助开发人员将领域专业知识转换为软件设计知识，方便开发人员区别和学习。&lt;/p&gt;
&lt;p&gt;5、领域模型不仅用在沟通阶段，贯穿整个开发过程，。&lt;/p&gt;
&lt;p&gt;6、领域模型在软件开发阶段，会对原有的模型完善和细化、深入，是一个多方共同维护的结果。&lt;/p&gt;
&lt;p&gt;7、图是表示领域模型最常见和最形象的方式，可以参见&lt;a href=&quot;https://tech.meituan.com/DDD%20in%20practice.html&quot; target=&quot;_blank&quot;&gt;美团技术团队-领域驱动设计在互联网业务中的应用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;8、领域模型是整个软件的核心，后续的业务变更和扩展也是基于原有的模型进行迭代，因此模型建立非常重要。&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 14:55:00 +0000</pubDate>
<dc:creator>geons</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geons/p/9195619.html</dc:identifier>
</item>
<item>
<title>C语言使用hiredis访问redis - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/9196527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/9196527.html</guid>
<description>&lt;p&gt;&lt;code&gt;Hiredis&lt;/code&gt; 是Redis数据库的简约C客户端库。它是简约的，因为它只是增加了对协议的最小支持，但是同时它使用了一个高级别的 printf-like API，所以对于习惯了 printf 风格的C编程用户来说，其非常容易使用，而且API中没有明确的绑定每个 Redis 命令。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/redis/hiredis&quot; class=&quot;uri&quot;&gt;https://github.com/redis/hiredis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装hiredis&quot;&gt;安装hiredis&lt;/h2&gt;
&lt;p&gt;编译安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; clone git@github.com:redis/hiredis.git
$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; hiredis
$ &lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; 
$ &lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是&lt;code&gt;make install&lt;/code&gt;的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /usr/local/include/hiredis /usr/local/include/hiredis/adapters /usr/local/lib
cp -pPR hiredis.h async.h read.h sds.h /usr/local/include/hiredis
cp -pPR adapters/*.h /usr/local/include/hiredis/adapters
cp -pPR libhiredis.so /usr/local/lib/libhiredis.so.0.13
cd /usr/local/lib &amp;amp;&amp;amp; ln -sf libhiredis.so.0.13 libhiredis.so
cp -pPR libhiredis.a /usr/local/lib
mkdir -p /usr/local/lib/pkgconfig
cp -pPR hiredis.pc /usr/local/lib/pkgconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制动态链接库到lib：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; libhiredis.so /usr/lib64 /usr/lib &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若是32系统只需要运行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; libhiredis.so /usr/lib&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还需要更新下动态链接库缓存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/sbin/ldconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;ldconfig&lt;/code&gt; 命令的用途主要是在默认搜寻目录 &lt;code&gt;/lib&lt;/code&gt; 和 &lt;code&gt;/usr/lib&lt;/code&gt; 以及动态库配置文件 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 内所列的目录下，搜索出可共享的动态链接库（格式如&lt;code&gt;lib*.so*&lt;/code&gt;）,进而创建出动态装入程序(&lt;code&gt;ld.so&lt;/code&gt;)所需的连接和缓存文件。缓存文件默认为 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; ，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令 &lt;code&gt;ldconfig&lt;/code&gt; ，此执行程序存放在/sbin目录下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;ldconfig&lt;/code&gt;通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;客户端代码&quot;&gt;客户端代码&lt;/h2&gt;
&lt;p&gt;test.c&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;  &lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;hiredis/hiredis.h&amp;gt;  &lt;/span&gt;
  
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()  
{  
    redisContext* conn = redisConnect(&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;);  
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(conn-&amp;gt;err)   printf(&lt;span class=&quot;st&quot;&gt;&quot;connection error:%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, conn-&amp;gt;errstr);  
  
    redisReply* reply = redisCommand(conn, &lt;span class=&quot;st&quot;&gt;&quot;set foo 1234&quot;&lt;/span&gt;);  
    freeReplyObject(reply);  
  
    reply = redisCommand(conn, &lt;span class=&quot;st&quot;&gt;&quot;get foo&quot;&lt;/span&gt;);  
  
    printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, reply-&amp;gt;str);  
    freeReplyObject(reply);  
  
    redisFree(conn);  
  
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;gcc&lt;/span&gt; test.c -o test -lhiredis&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译是一定要使用&lt;code&gt;-l&lt;/code&gt;连接动态库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;-lstack&lt;/code&gt; 告诉编译器要链接 &lt;code&gt;lhiredis&lt;/code&gt; 库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./test
1234&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数原型&quot;&gt;函数原型&lt;/h2&gt;
&lt;h3 id=&quot;redisconnect&quot;&gt;redisConnect&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;redisContext *redisConnect(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *ip, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：该函数用来连接redis数据库，参数为数据库的ip地址和端口，一般redis数据库的端口为6379。&lt;/p&gt;
&lt;p&gt;该函数返回一个结构体&lt;code&gt;redisContext&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;rediscommand&quot;&gt;redisCommand&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *redisCommand(redisContext *c, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：该函数执行命令，就如sql数据库中的SQL语句一样，只是执行的是&lt;code&gt;redis&lt;/code&gt;数据库中的操作命令，第一个参数为连接数据库时返回的&lt;code&gt;redisContext&lt;/code&gt;，剩下的参数为变参，就如C标准函数&lt;code&gt;printf&lt;/code&gt;函数一样的变参。&lt;/p&gt;
&lt;p&gt;返回值为&lt;code&gt;void*&lt;/code&gt;，一般强制转换成为&lt;code&gt;redisReply&lt;/code&gt;类型的进行进一步的处理。&lt;/p&gt;
&lt;h3 id=&quot;freereplyobject&quot;&gt;freeReplyObject&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; freeReplyObject(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *reply);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：释放 &lt;code&gt;redisCommand&lt;/code&gt; 执行后返回的 &lt;code&gt;redisReply&lt;/code&gt; 所占用的内存。&lt;/p&gt;
&lt;h3 id=&quot;redisfree&quot;&gt;redisFree&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; redisFree(redisContext *c);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：释放 &lt;code&gt;redisConnect()&lt;/code&gt; 所产生的连接。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、Redis：安装、配置、操作和简单代码实例(C语言Client端) - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/hj19870806/article/details/8724907&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/hj19870806/article/details/8724907&lt;/a&gt;&lt;br/&gt;2、C语言访问redis（hiredis) - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/sole_cc/article/details/38015765&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sole_cc/article/details/38015765&lt;/a&gt;&lt;br/&gt;3、error while loading shared libraries问题解决 - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qgd19931120/article/details/50971142&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qgd19931120/article/details/50971142&lt;/a&gt;&lt;br/&gt;4、ldconfig命令_Linux ldconfig 命令用法详解：动态链接库管理命令&lt;br/&gt;&lt;a href=&quot;http://man.linuxde.net/ldconfig?mstqrk=qdwrv1&quot; class=&quot;uri&quot;&gt;http://man.linuxde.net/ldconfig?mstqrk=qdwrv1&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 14:17:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/9196527.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day23 Java容器类详解（六）HashMap源码分析（中） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9195465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9195465.html</guid>
<description>&lt;p&gt;　　上一篇中对HashMap中的基本内容做了详细的介绍，解析了其中的get和put方法，想必大家对于HashMap也有了更好的认识，本篇将从了算法的角度，来分析HashMap中的那些函数。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618101953480-884502030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;HashCode&lt;/h2&gt;
&lt;p&gt;　　先来说说HashMap中HashCode的算法，在上一篇里，我们看到了HashMap中的put方法是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那这个hash函数又是什么呢？让我们来看看它的真面目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将高位与低位进行与运算来计算哈希值。因为在hashmap中使用2的整数幂来作为掩码，所以只在当前掩码之上的位上发生
     * 变化的散列总是会发生冲突。（在已知的例子中，Float键的集合在小表中保持连续的整数）因此，我们应用一个位运算
     * 来向下转移高位的影响。 这是在综合考虑了运算速度，效用和质量之后的权衡。因为许多常见的散列集合已经合理分布
     * （所以不能从扩散中受益），并且因为我们使用树来处理bin中发生的大量碰撞的情况，所以我们尽可能以代价最低的方式
     * 对一些位移进行异或运算以减少系统损失， 以及合并由于hashmap容量边界而不会被用于散列运算的最高位的影响。
     *
     * todo 扰动函数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，这里并不是简单的使用了key的hashCode，而是将它的高16位与低16位做了一个异或操作。（“&amp;gt;&amp;gt;&amp;gt;”是无符号右移的意思，即右移的时候左边空出的部分用0填充）这是一个扰动函数，具体效果后面会说明。接下来再看看之前的putval方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前table未初始化，则先重新调整大小至初始容量&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             n = (tab =&lt;span&gt; resize()).length;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;（n-1）&amp;amp; hash 这个地方即根据hash求序号，想了解更多散列相关内容可以查看下一篇&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不存在，则新建节点&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Node&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先找到对应的node&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;15&lt;/span&gt;                     ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 e =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是树节点，则调用相应的putVal方法，这部分放在第三篇内容里
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo putTreeVal&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是链表则之间遍历查找&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有找到则在该链表新建一个节点挂在最后&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                         p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果链表长度达到树化的最大长度，则进行树化，该函数内容也放在第三篇
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo treeifyBin&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                            treeifyBin(tab, hash);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;34&lt;/span&gt;                             ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     p =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已存在该key的映射，则将值进行替换&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                afterNodeAccess(e);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改次数加一&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         ++&lt;span&gt;modCount;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            resize();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        afterNodeInsertion(evict);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意看第八行的代码：&lt;/p&gt;
&lt;pre&gt;
　　tab[i = (n - 1) &amp;amp; hash]
&lt;/pre&gt;
&lt;p&gt;　　(n - 1) &amp;amp; hash 即通过key的hash值来取对应的数组下标，并非是对table的size进行取余操作。&lt;/p&gt;
&lt;p&gt;　　那么，为什么要这样做呢？首先，扰动函数的目的就是为了扩大高位的影响，使得计算出来的数值包含了高 16 位和第 16 位的特性，让 hash 值更加深不可测&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618204159467-1589754963.png&quot; alt=&quot;&quot;/&gt;来降低碰撞的概率。从hash方法的注释中，我们也可以找到答案，一般的散列，其实都是做取余处理，但是HashMap中的table大小是2的整数次幂，也就是说，肯定不是质数，那么在取余的时候，偶数的映射范围势必就要小了一半，这样效果显然就差很多，而且，除法和取余其实是很慢的操作，所以在JDK8中，使用了一种很巧妙的方式来进行散列。首先，table的大小size设置成了2的整数次幂，这样使用size-1就变成了掩码，下面是我找的一张图，能很好的解释这个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618204339416-1965613332.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　n是table的大小，默认是16，二进制即为10000，n - 1 对应的二进制则为1111，这样再与hash值做“与”操作时，就变成了掩码，除了最后四位全部被置为0，而最后四位的范围肯定会落在（0~n-1）之间，正好是数组的大小范围，散列函数的妙处就在于此了。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618205337754-1047084402.png&quot; alt=&quot;&quot;/&gt;简直不能更稳，一波操作猛如虎。&lt;/p&gt;
&lt;p&gt;　　那么我们继续上一篇的栗子，我们来一步一步分析一下，小明和小李的hash值的映射过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618211602288-1519665676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　小明的hash值是756692，转换为二进制为10111000101111010100，table的大小是32，n-1=31，对应的二进制为：11111，做“与”运算之后，得到的结果是10100，即为20。&lt;/p&gt;
&lt;p&gt;　　小李的hash值是757012，转换为二进制为10111000110100010100，与11111做与运算后，得到的结果也是10100，即20，于是就与小明发生了冲突，但还是要先来后到，于是小李就挂在了小明后面。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618211830315-1873354682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　散列函数看完了，我们接下来再看看扩容函数。&lt;/p&gt;
&lt;h2&gt;扩容函数&lt;/h2&gt;
&lt;p&gt;　　扩容函数其实之前也已经见过了，就在上面的putVal方法里，往上面翻一翻，第六行可以看到resize函数，这就是扩容函数，让我们来看看它的庐山真面目：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618210522998-492533759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 初始化或将table的大小进行扩容。 如果table为null，则按照字段threshold中的初始容量目标进行分配。
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 否则，因为我们使用2次幂进行扩容，所以在新表中，来自每个bin中的元素必须保持在相同的索引处，或者以原偏移量的2次幂进行移动。
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的容量扩展成原来的两倍&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
&lt;span&gt;17&lt;/span&gt;                     oldCap &amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阈值也调整为原来的两倍&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 newThr = oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             newCap =&lt;span&gt; oldThr;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             newThr = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
&lt;span&gt;30&lt;/span&gt;                     (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         threshold =&lt;span&gt; newThr;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         table =&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将旧数组中的node重新散列到新数组中&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                             next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                                     loHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                                     loTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                                 loTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                                     hiHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;                                     hiTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                                 hiTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                         } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                             loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                             newTab[j] =&lt;span&gt; loHead;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                             hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                             newTab[j + oldCap] =&lt;span&gt; hiHead;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里可以看到，如果原来的table还未被初始化的话，调用该函数后就会被扩容到默认大小（16），上一篇中也已经说过，HashMap也是使用了懒加载的方式，在构造函数中并没有初始化table，而是在延迟到了第一次插入元素之后。&lt;/p&gt;
&lt;p&gt;　　当使用put插入元素的时候，如果发现目前的bins占用程度已经超过了Load Factor所设置的比例，那么就会发生resize，简单来说就是把原来的容量和阈值都调整为原来的2倍，之后重新计算index，把节点再放到新的bin中。因为index值的计算与table数组的大小有关，所以扩容后，元素的位置有可能会调整：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618212401787-1490727982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上图为例，如果对应的hash值第五位是0，那么做与操作后，得到的序号不会变，那么它的位置就不会改变，相反，如果是1，那么它的新序号就会变成原来的序号+16,。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618212800997-1184758067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好像也不是很多嘛，嗯，算法部分就先介绍到这里了，之后的一篇再来说说HashMap中的EntrySet，KeySet和values（如果时间够的话顺便把迭代器也说一说）。&lt;/p&gt;
&lt;p&gt;　　好了，本篇就此愉快的结束了，最后祝大家端午节快乐！如果觉得内容还不错的话记得动动小手点关注哦，你的支持就是我最大的动力！&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180618213134741-752299546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 13:32:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9195465.html</dc:identifier>
</item>
</channel>
</rss>