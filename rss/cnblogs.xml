<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>log4j详细配置 - 上海-chp-java</title>
<link>http://www.cnblogs.com/haopengchen/p/9209386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haopengchen/p/9209386.html</guid>
<description>&lt;p&gt;参考博客：&lt;a href=&quot;https://blog.csdn.net/sinat_30185177/article/details/73550377&quot;&gt;https://blog.csdn.net/sinat_30185177/article/details/73550377&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;log4j。。很简单好用的一个记录日志的东东，正因为好用，本人从来没有亲自配置过(都是别人在项目里面配好的，直接copy过来用)，但是最近进了一家新公司，(或许因为某些原因)他们封装了一个日志工具类日志打印特定的信息，因为此项目以后由我接手，所以我做主就后来改了日志打印方式，原本代码如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此方式称之为方法一..&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogTool {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; debugSysLog(String logtext) {
        writeLog(logtext,&lt;/span&gt;&quot;info&quot;&lt;span&gt;);
        System.out.println(logtext);
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Logger log = Logger.getLogger(LogTool.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeLog(String msg,String level){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(level.equals(&quot;debug&quot;&lt;span&gt;))
            log.debug(msg);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(level.equals(&quot;error&quot;&lt;span&gt;))
            log.error(msg);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(level.equals(&quot;warn&quot;&lt;span&gt;))
            log.warn(msg);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            log.info(msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;log4j.properties的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
log4j.rootLogger=&lt;span&gt;INFO,logfile,stdout,DEBUG

#输出到控制台
log4j.appender.stdout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.stdout.Target &lt;/span&gt;=&lt;span&gt; System.out
log4j.appender.stdout.layout.ConversionPattern&lt;/span&gt;=%d %p [%c]:%l - %m%&lt;span&gt;n

#log4j.appender.logfile&lt;/span&gt;=&lt;span&gt;org.apache.log4j.FileAppender
#log4j.appender.logfile&lt;/span&gt;=&lt;span&gt;org.apache.log4j.RollingFileAppender&lt;br/&gt;#log4j.appender.logfile.MaxFileSize&lt;/span&gt;=&lt;span&gt;1MB

#输出到文件
log4j.appender.logfile&lt;/span&gt;=&lt;span&gt;org.apache.log4j.DailyRollingFileAppender
log4j.appender.logfile.DatePattern&lt;/span&gt;='.'yyyy-MM-&lt;span&gt;dd

log4j.appender.logfile.File&lt;/span&gt;=${catalina.home}/webapps/logs/&lt;span&gt;invoice.log

#log4j.appender.logfile.MaxBackupIndex&lt;/span&gt;=20&lt;span&gt;
log4j.appender.logfile.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern&lt;/span&gt;=%d %p : %l - %m%n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的log4j配置文件我已经修改过了，原本的是不打印错误信息的，即下面的一些东东记一下就行了。&lt;br/&gt;#%m   输出代码中指定的消息&lt;br/&gt;#%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL&lt;br/&gt;#%r   输出自应用启动到输出该log信息耗费的毫秒数&lt;br/&gt;#%c   输出所属的类目，通常就是所在类的全名&lt;br/&gt;#%t   输出产生该日志事件的线程名&lt;br/&gt;#%n   输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n”&lt;br/&gt;#%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日  22:10:28&lt;br/&gt;#%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/Administrator/AppData/Roaming/Tencent/Users/895216249/QQ/WinTemp/RichOle/GR(EK7QIGU%7DI)%7DSV7R3%5BM%5BF.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;使用工具类打印的信息如上图红色部分(很整洁，漂亮，，有乱用？？有一次项目报错空指针，都不知道哪里错的。。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用同样的配置文件，在项目里面使用如下代码打印日志，会提示的很完整，且方法一能实现的方法二都可以实现..&lt;br/&gt;Logger log = Logger.getLogger(InvoiceBuildServlet.class);&lt;/p&gt;
&lt;p&gt; 在catch里面用 log.error(&quot;error&quot;,e);&lt;/p&gt;
&lt;p&gt;很简单。。&lt;/p&gt;
&lt;p&gt;下面是配置文件源文件的下载地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/haopengchen/log4j.properties.zip&quot;&gt;https://files.cnblogs.com/files/haopengchen/log4j.properties.zip&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 07:42:00 +0000</pubDate>
<dc:creator>上海-chp-java</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haopengchen/p/9209386.html</dc:identifier>
</item>
<item>
<title>sql server 索引阐述系列三 表的堆组织 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9200800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9200800.html</guid>
<description>&lt;h3&gt;一.   概述&lt;/h3&gt;
&lt;p&gt;　　这一节来详细介绍堆组织，通过讲解堆的结构，堆与非聚集索引的关系，堆的应用场景，堆与聚集索引的存储空间占用，堆的页拆分现象，最后堆的使用建议 ，这几个维度来描述堆组织。在sqlserver里，表有二种组织方式，在表上没有创建聚集索引时，表就是堆组织, 有聚集索引就是B树组织。无论哪种组织方式，都可以在表上建多个非聚集索引。表的组织方式也称为HOBT。&lt;/p&gt;
&lt;p&gt;　　之所以称为堆，是因为它的数据不按任何顺序进行组织，而是按分区组对数据进行组织。 在一个堆中。用于保存数据之间的关系的唯一结构是索引分配映射(IAM , index allocation map)的位图页，上一章节中有说过页文件类型。&lt;/p&gt;
&lt;p&gt;　　IAM位图页有指向数据页的指针，如果一个IAM不足以覆盖所有页，将维护一个IAM页的链，在查询数据时，先使用IAM页来遍历分配单元的数据。&lt;/p&gt;
&lt;p&gt;　　堆结构在数据插入没有更改时是有存储顺序的，但一改动如修改删除，结构就会发生变化， 因为没有特定的顺序来维护数据， 所以在新增表中的行时，可以保存到任何数据页上。&lt;/p&gt;
&lt;p&gt;　　Sql server内部使用文件页(PFS, Page Free Space)可用空间页，PFS位图来跟踪数据页中的可用空间,  以便可以快速找到有足够空间能容纳新行的页面，如果没有则分配一个新数据页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 堆组织结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在堆组织中对于一个select查询，首先查询IAM页，然后根据IAM页提供的信息，遍历每个区，把区内符合条件下的数据页返回，在堆中查询从上到下依次是Heap--&amp;gt;IAM--&amp;gt;区--&amp;gt;数据页。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180620174741644-1894039078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 堆上的非聚集索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;非聚集索引也可以结构化为一颗B树，与聚集索引类似，唯一区别就是非聚集索引的叶子层只包含索引键列和指向数据行的指针（行定位符）。如果是在堆上建立非聚集索引，则指针指向堆结构中的数据行&lt;/p&gt;
&lt;p&gt;　　在堆中非聚集索引都有一个相对应的partition, 在这个partition下都有一个连接指向Root page根，在叶子层有会一个连接(文件号，页号，行号)指向真正的数据，真正的数据还是以堆结构存放的。在堆上建立的非聚集索引查询从上到下依次是Heap--&amp;gt;Root根--&amp;gt;root index中间层--&amp;gt;叶节点(文件号，页号，行号)--&amp;gt;数据页。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180620175016507-1745464353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二. 堆应用场景&lt;/h3&gt;
&lt;p&gt;　　堆最常用的现象就是使用临时表，一般都很少会主动加clustered primary关键词，很多时间临时对象的应用也没有必要使用聚集索引。但如果临时表在会话里需要使用多次条件查询，排序 等操作，聚集索引则少一部分开销。下面演示下：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建临时表堆&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; #tempWithHeap(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;, model &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;插入数据&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; #tempWithHeap
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sid&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,model &lt;span&gt;FROM&lt;/span&gt; dbo.Product &lt;span&gt;WHERE&lt;/span&gt; UpByMemberID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; Product.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Product 
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; #tempWithHeap 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; #tempWithHeap.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; dbo.Product.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图在执行计划里能看到临时表是表扫描方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180620175300526-233821831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建临时表聚集&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; #tempWithCLUSTERED(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;CLUSTERED&lt;/span&gt;, model &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; #tempWithCLUSTERED
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;sid&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;,model &lt;span&gt;FROM&lt;/span&gt; dbo.Product &lt;span&gt;WHERE&lt;/span&gt; UpByMemberID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; Product.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; Product 
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; #tempWithCLUSTERED 
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; #tempWithCLUSTERED.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; dbo.Product.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图在执行计划里能看到临时表是聚集索引扫描方式&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180620175408515-1938023895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面来演示堆和索引在排序下不同的执行计划&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;临时表堆上排序&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; Product.SID &lt;span&gt;FROM&lt;/span&gt; Product &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; #tempWithHeap
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; #tempWithHeap.SID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;Product.SID
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; #tempWithHeap.SID
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在下图执行计划中排序显示开销&lt;span&gt;15%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180620175612463-1139594123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;临时表聚集索引上排序&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; Product.SID &lt;span&gt;FROM&lt;/span&gt; Product &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; #tempWithCLUSTERED
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; #tempWithCLUSTERED.SID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;Product.SID
&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; #tempWithCLUSTERED.SID
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在下图执行计划中排序开销没有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180620175658351-534594329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三.堆上的页拆分&lt;/h3&gt;
&lt;p&gt; 　　堆上的页拆分叫&lt;span lang=&quot;EN-US&quot;&gt;Forwarded records&lt;span lang=&quot;EN-US&quot;&gt;，是指更新数据后，原有页面空间大小已经无法存放该数据，&lt;span lang=&quot;EN-US&quot;&gt;sql server 会把这个数据移到堆中的新数据页里，并在新旧页中分别添加一个指针，标识这个数据在新旧页中的位置，从旧页指向新页的指针叫&lt;span lang=&quot;EN-US&quot;&gt;Forwarded records pointer &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;存放于旧页中, 从新页指向旧页的指针叫作back pointer 存放于新页中。&lt;/p&gt;
&lt;p&gt;　　下面来演示下页拆分现象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;这里定义一个堆表，使用变长字段2500&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; HeapForwardedRecords
(
    ID  &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
    DATA &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;2500&lt;/span&gt;&lt;span&gt;)  
)
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;插入数据，这里data字段插入2000，插入24条&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; HeapForwardedRecords(data)
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;TOP&lt;/span&gt; &lt;span&gt;24&lt;/span&gt; &lt;span&gt;REPLICATE&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;2000&lt;/span&gt;) &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; sys.objects

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查看碎片信息&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;OBJECT_NAME&lt;/span&gt;(&lt;span&gt;object_id&lt;/span&gt;),&lt;span&gt;object_id&lt;/span&gt;&lt;span&gt;,
index_type_desc,page_count,record_count,
forwarded_record_count
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sys.dm_db_index_physical_stats(&lt;span&gt;DB_ID&lt;/span&gt;(), &lt;span&gt;OBJECT_ID&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HeapForwardedRecords&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  ,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Detailed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图显示：共6页，24条数据，页拆分0条。 （一行数据2000字节，一页存储4行， 24行共6页）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180621123452001-220899410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面将data字段存储的2000字节，修改为2500字节，每页4行更新二行，原来一页存储4行(4*2000&amp;lt;8060)，现更新后就是(2*2000 +2*2500)&amp;gt;8060字节，原页就只能存储三行，这时堆上的页就会拆分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;更新数据,12行受影响&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; HeapForwardedRecords &lt;span&gt;SET&lt;/span&gt; DATA&lt;span&gt;=&lt;/span&gt;&lt;span&gt;REPLICATE&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;2500&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; ID&lt;span&gt;%&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再次查看碎片信息，发现原来6页存储变为了9页， forwarded_record_count是指页拆分次数(是指向另一个数据位置的指针的记录数，在更新过程中，如果在原始位置存储的空间不足，将会出现此状态) 如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180621142609468-960090264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　总结：通过sys.dm_db_index_physical_stats 我们可以查询到碎片信息，page count的页数越多，内存消耗就越多。 要整理碎片可以重建聚集索引。若要减少堆的区碎片，请对表创建聚集索引，然后删除该索引。更多碎片信息查看 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008-r2/ms188917(v=sql.105)&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008-r2/ms188917(v=sql.105)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如下图：forwarded_record_count为0了 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180621143710223-1652277380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四.堆存储结构对空间使用的影响　&lt;/h3&gt;
&lt;p&gt; &lt;strong&gt;4.1 等量数据的存储方式，使用DBCC SHOWCONFIG来查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下面演示表结构相同情况下在堆组织和聚集索引组织二种方式， 存储等量数据，来查看空间的占用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;堆表&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ProductWithDeap&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Model&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Brand&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UpdateTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UpByMemberID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UpByMemberName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;插入表堆数据(60703 行)&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt;  ProductWithDeap(Model,Brand,UpdateTime,UpByMemberID,UpByMemberName) 
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; Model,Brand,UpdateTime,UpByMemberID,UpByMemberName &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.Product 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;  UpByMemberID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;聚集索引&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;dbo&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ProductWithClustered&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;IDENTITY&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Model&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;Brand&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UpdateTime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UpByMemberID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;UpByMemberName&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;nvarchar&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;CONSTRAINT&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PK_ProductWithClustered&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;CLUSTERED&lt;/span&gt;&lt;span&gt; 
(
    &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;SID&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  &lt;span&gt;ASC&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt; (PAD_INDEX  &lt;span&gt;=&lt;/span&gt; &lt;span&gt;OFF&lt;/span&gt;, STATISTICS_NORECOMPUTE  &lt;span&gt;=&lt;/span&gt; &lt;span&gt;OFF&lt;/span&gt;, IGNORE_DUP_KEY &lt;span&gt;=&lt;/span&gt; &lt;span&gt;OFF&lt;/span&gt;, ALLOW_ROW_LOCKS  &lt;span&gt;=&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt;, ALLOW_PAGE_LOCKS  &lt;span&gt;=&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt;) &lt;span&gt;ON&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;插入表聚集数据(60703 行)&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt;  ProductWithClustered(Model,Brand,UpdateTime,UpByMemberID,UpByMemberName) 
&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; Model,Brand,UpdateTime,UpByMemberID,UpByMemberName &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.Product 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;  UpByMemberID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180621105042749-1532139965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;存储方式&lt;/td&gt;
&lt;td&gt;使用页面数量&lt;/td&gt;
&lt;td&gt;使用区数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;堆组织&lt;/td&gt;
&lt;td&gt; 517&lt;/td&gt;
&lt;td&gt; 69&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;聚集索引&lt;/td&gt;
&lt;td&gt; 518&lt;/td&gt;
&lt;td&gt; 66&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;4.2 删除数据后，对空间的释放情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　delete  from ProductWithDeap&lt;/p&gt;
&lt;p&gt;       delete from ProductWithclustered&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/151560/201806/151560-20180621105612793-384768416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;存储方式&lt;/td&gt;
&lt;td&gt;剩余空间数量&lt;/td&gt;
&lt;td&gt;剩余区数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;堆组织&lt;/td&gt;
&lt;td&gt; 50&lt;/td&gt;
&lt;td&gt; 11&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;聚集索引&lt;/td&gt;
&lt;td&gt; 1&lt;/td&gt;
&lt;td&gt; 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　使用delete后我们发现，建立堆组织的空间不会马上释放掉，聚集索引能很好的释放空间，但也存在1页未释放，如果完全释放使用truncate table。&lt;/p&gt;
&lt;p&gt;      总结：当我们考虑表是用堆组织还是用聚集索引时，通过上面的演示我们知道，聚集索引的叶子层就是数据本身，并不会因为建立聚集索引而消耗过多的空间（&lt;span&gt;注意非聚集索引会占用空间，不管是建立在堆组织上还是聚集索引上&lt;/span&gt;），而且能够更好的管理数据和空间的释放。除非特殊情况（后面有选择堆的理由）&lt;/p&gt;
&lt;h3&gt;五.堆的使用建议&lt;/h3&gt;
&lt;p&gt;　　5.1堆需要考虑点&lt;/p&gt;
&lt;p&gt;            过多的产生forwarded records 来维护堆表,产生额外的io操作。&lt;/p&gt;
&lt;p&gt;       5.2 堆选择理由&lt;/p&gt;
&lt;p&gt;              高频率的增删操作。&lt;/p&gt;
&lt;p&gt;              键值经常改变，特别在索引上的位置改变。&lt;/p&gt;
&lt;p&gt;              插入大量数据列到表中。&lt;/p&gt;
&lt;p&gt;              主键值并不自增或者唯一。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 07:34:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9200800.html</dc:identifier>
</item>
<item>
<title>在windows下安装git中文版客户端并连接gitlab - 坤霸天下</title>
<link>http://www.cnblogs.com/xwgcxk/p/9209237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xwgcxk/p/9209237.html</guid>
<description>&lt;p&gt;转载自：https://blog.whsir.com/post-1801.html&lt;/p&gt;

&lt;p&gt;下载git Windows客户端&lt;/p&gt;
&lt;p&gt;git客户端下载地址：&lt;a href=&quot;https://git-scm.com/downloads&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里下载的是Git-2.14.0-64-bit.exe版本&lt;/p&gt;
&lt;p&gt;下载TortoiseGit&lt;/p&gt;
&lt;p&gt;TortoiseGit客户端下载地址：&lt;a href=&quot;https://tortoisegit.org/download&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://tortoisegit.org/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;TortoiseGit客户端要下载两个，一个是安装程序，一个是中文语言包&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1802&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git1.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;601&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述下载完成后，你会得到以下这三个文件&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1803&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git2.png&quot; alt=&quot;&quot; width=&quot;336&quot; height=&quot;72&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果上述三个文件下载过慢的话，可以直接下载我这里打包好的：&lt;a href=&quot;http://down.whsir.com/downloads/gitclient.rar&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://down.whsir.com/downloads/gitclient.rar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装顺序：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、Git-2.13.3-64-bit.exe&lt;br/&gt;2、TortoiseGit-2.5.0.0-64bit.msi&lt;br/&gt;3、TortoiseGit-LanguagePack-2.5.0.0-64bit-zh_CN.msi&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Git客户端安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1804&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git3.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1805&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git4.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1806&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git5.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1807&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git6.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git6.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1808&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git7.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1809&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git8.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1810&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git9.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1811&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git10.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git10.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1812&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git11.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git11.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1813&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git12.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git12.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1814&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git13.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git13.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TortoiseGit客户端安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1815&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git14.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git14.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1816&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git15.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git15.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1817&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git16.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git16.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1818&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git17.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git17.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1819&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git18.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不运行开始向导直接完成即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TortoiseGit-LanguagePack安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1820&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git19.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1821&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git20.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;388&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git20.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;任意空白处右键，TortoiseGit设置，重新运行首次启动向导&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1822&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git21.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;509&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git21.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1823&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git22.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;509&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git22.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一直下一步就好，有一处需要设置个用户名和邮箱（不用于身份验证）&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1824&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git23.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;447&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git23.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成PuTTY密钥对&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1825&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git24.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;509&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git24.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1826&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git25.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;509&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git25.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意下，这个进度条你会发现很慢，需要你动鼠标在空白处多晃动几下就很快了，注意上面写的Please内容&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1827&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git26.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;467&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git26.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1828&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git27.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;467&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git27.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面圈出部分是公钥，将私钥保存下来&lt;/p&gt;
&lt;p&gt;我这里用的是gitlab，将公钥复制到gitlab中&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone wp-image-1829&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git28.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;368&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git28.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里本地已经搭好了一个gitlab，加载Putty密钥，这个就是刚才保存的私钥&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1830&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git29.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;392&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git29.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignnone size-full wp-image-1831&quot; src=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git30.png&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;345&quot; data-original=&quot;http://blog.whsir.com/wp-content/uploads/2017/08/git30.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果ssh连接不成功，请检查你的ssh端口是否是默认的22&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 07:19:00 +0000</pubDate>
<dc:creator>坤霸天下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xwgcxk/p/9209237.html</dc:identifier>
</item>
<item>
<title>辅助模式最终考验的是想象力，先来看看怎么用！| Accessibility - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/accessibility_android.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/accessibility_android.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641ab5989fe05a4?w=1080&amp;amp;h=720&amp;amp;f=jpeg&amp;amp;s=36209&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一序&quot;&gt;一、序&lt;/h2&gt;
&lt;p&gt;Hi，大家好，我是承香墨影！&lt;/p&gt;
&lt;p&gt;Android 的辅助模式（Accessibility）功能非常的强大。基本上被获取到授权之后，可以监听手机上的任何事件，例如：屏幕点击、窗口的变化、以及模拟点击、模拟系统按键等等。&lt;/p&gt;
&lt;p&gt;比较常见的实际使用例子，就是一般应用市场，会推荐开启辅助模式，以便在安装 Apk 的时候，自动帮你点击“下一步”和“安装”按钮。还有个例子就是微信抢红包插件，也是基于它来实现的。&lt;/p&gt;
&lt;p&gt;Accessibility 的权限非常的高，基本上你授权开启某个别人提供的 AccessibilityService 之后，他就可以干很多事情而不让你知道，而这些是不需要 Root 权限的。所以一般小体量的产品，可能支持它并没有什么用，因为信任度太低了，大部分用户根本不会打开。比较常见的就是一些工具类的 App，帮用户节省一些点击的时间。&lt;/p&gt;
&lt;p&gt;虽然很多时候，Accessibility 不会被用在商业产品上，但是这并不妨碍我们使用 Accessibility 来做一些有意思的功能。&lt;/p&gt;
&lt;h2 id=&quot;二辅助模式的使用步骤&quot;&gt;二、辅助模式的使用步骤&lt;/h2&gt;
&lt;p&gt;辅助模式是可以支持第三方开发，也就是我们可以按照文档对其进行支持，只要用户授权开启此服务，我们就可以利用 Accessibility 提供的一些标准 Api 实现很多有意思的功能。&lt;/p&gt;
&lt;p&gt;如果你想要使用辅助模式，你还需要如下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现一个继承自 AccessibilityService 的服务类。&lt;/li&gt;
&lt;li&gt;设定配置信息，以便系统知道该辅助模式的一些基本信息，例如监听那些事件。&lt;/li&gt;
&lt;li&gt;在清单文件（AndroidManifest.xml）中，注册此服务。&lt;/li&gt;
&lt;li&gt;在系统设置中，找到“无障碍”，并开启此服务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来我们一步一步讲解这里的步骤和细节。&lt;/p&gt;
&lt;h3 id=&quot;继承-accessibilityservice&quot;&gt;2.1 继承 AccessibilityService&lt;/h3&gt;
&lt;p&gt;辅助模式，本质上还是一个服务，我们如果想要支持它，首先需要继承 AccessibilityService 这个类。&lt;/p&gt;
&lt;p&gt;AccessibilityService 类提供了很多需要重写的方法，其中有两个是强制重写的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onAccessibilityEvent&lt;/span&gt;(AccessibilityEvent event);
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onInterrupt&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当开启了某个 AccessibilityService 服务之后，系统会在该服务监听的事件发生的时候，回调它的 &lt;code&gt;onAccessibilityEvent()&lt;/code&gt; 方法，并将该事件的信息当参数传递过去，如果你监听的事件足够多，它就会被频繁调用。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;onInterrupt()&lt;/code&gt; 方法会在系统事件被打断的时候回调，也是会被频繁调用，一般我们不需要做额外处理。&lt;/p&gt;
&lt;p&gt;通常我们只需要在 &lt;code&gt;onAccessibilityEvent()&lt;/code&gt; 方法中，编写核心逻辑即可，其他的方法，只是辅助使用。&lt;/p&gt;
&lt;h3 id=&quot;配置辅助模式&quot;&gt;2.2 配置辅助模式&lt;/h3&gt;
&lt;p&gt;当创建一个 AccessibilityService 之后，我们还需要对其进行一些基本的配置，否则在系统设置的“无障碍”中，是看不到我们编写的服务的。&lt;/p&gt;
&lt;p&gt;配置 AccessibilityService 有两种方式，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 xml 配置文件&lt;/li&gt;
&lt;li&gt;通过 Java 代码中动态配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是其实有一些属性是只能通过 XML 配置文件进行配置的，Java 代码只是让某一些配置项更灵活了而已，后面会细说。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、xml 配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要使用 XML 配置文件，首先需要创建一个 res/xml 的目录，并在其内创建一个 xml 文件，文件名随意无要求，内部定义一个 &lt;code&gt;accessibility-service&lt;/code&gt; 标签，在其中设定 AccessibilityService 的各项配置。例如我这里创建一个 &lt;code&gt;accessibility_config.xml&lt;/code&gt; 的文件，后面会用到这个文件。&lt;/p&gt;
&lt;p&gt;XML 配置 AccessibilityService 是我们一个比较常用的配置方法，非常清晰且方便。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;accessibility-service&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:android=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:accessibilityEventTypes=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;typeAllMask&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:accessibilityFeedbackType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;feedbackAllMask&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:accessibilityFlags=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;flagReportViewIds&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:canRetrieveWindowContent=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:packageNames=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.forwarding.wechat&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:description=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;@string/accessbility_desc&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:notificationTimeout=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;100&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如上面就是一个常见的配置，如果没有特殊要求的话，直接复制过去，修改一些个别参数就可以使用。&lt;/p&gt;
&lt;p&gt;各项属性的含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;accessibilityEventTypes：监听的事件类型，例如：typeAllMask 表示全部事件，而 typeViewClicked 表示只监听点击事件。&lt;/li&gt;
&lt;li&gt;accessibilityFeedbackType：监听事件的反馈模式。&lt;/li&gt;
&lt;li&gt;canRetrieveWindowContent：是否允许获取视图层级的访问权，如果它被设置为 false，&lt;code&gt;node.getSource()&lt;/code&gt; 方法会调用失败。&lt;/li&gt;
&lt;li&gt;accessibilityFlags：指定 Flag，一般用于指定根据 Node 获取 View ID 的权限。&lt;/li&gt;
&lt;li&gt;packageNames：开启监听的应用包名，可以指定多个包名，通过逗号“,”分割，不设置此属性标识全局监听。&lt;/li&gt;
&lt;li&gt;description：辅助功能的描述，它会显示在系统设置的“无障碍”中的描述信息中。&lt;/li&gt;
&lt;li&gt;notificationTimeout：响应的毫秒数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些可配置的参数，系统都提供了可选的配置参数，正常不需要额外定制的时候，使用上面默认的配置即可，如果有定制需要，还是查阅官方文档获得最全的介绍。&lt;/p&gt;
&lt;blockquote readability=&quot;0.99099099099099&quot;&gt;
&lt;p&gt;AccessibilityService:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/reference/android/accessibilityservice/AccessibilityService&quot; class=&quot;uri&quot;&gt;https://developer.android.com/reference/android/accessibilityservice/AccessibilityService&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2、Java 代码中动态配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了 XML 文件配置的方式，我们还可以通过重写 AccessibilityService 的 &lt;code&gt;onServiceConnected()&lt;/code&gt; 方法，我们首先需要构建一个 AccessibilityServiceInfo 对象，通过它的标准 Api 进行配置，再使用 &lt;code&gt;setServiceInfo()&lt;/code&gt; 方法将它设置给辅助模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onServiceConnected()&lt;/code&gt; 会在应用成功连接到此辅助服务的时候系统调用，一般在其中做一些初始化的操作即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;onServiceConnected&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onServiceConnected&lt;/span&gt;()
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; serviceInfo = &lt;span class=&quot;fu&quot;&gt;AccessibilityServiceInfo&lt;/span&gt;()
    serviceInfo.&lt;span class=&quot;fu&quot;&gt;eventTypes&lt;/span&gt; = AccessibilityEvent.&lt;span class=&quot;fu&quot;&gt;TYPES_ALL_MASK&lt;/span&gt;
    serviceInfo.&lt;span class=&quot;fu&quot;&gt;feedbackType&lt;/span&gt; = AccessibilityServiceInfo.&lt;span class=&quot;fu&quot;&gt;FEEDBACK_ALL_MASK&lt;/span&gt;
    serviceInfo.&lt;span class=&quot;fu&quot;&gt;notificationTimeout&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;
    serviceInfo.&lt;span class=&quot;fu&quot;&gt;packageNames&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;arrayOf&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.forwarding.wechat&quot;&lt;/span&gt;)
    serviceInfo.&lt;span class=&quot;fu&quot;&gt;flags&lt;/span&gt; =  AccessibilityServiceInfo.&lt;span class=&quot;fu&quot;&gt;FLAG_REPORT_VIEW_IDS&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;setServiceInfo&lt;/span&gt;(serviceInfo)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里提供的例子，其实和前面使用 XML 配置的效果一直。推荐使用 XML 的配置方式，会更清晰且灵活，而且像 description 这种属性，在 AccessibilityServiceInfo 中，并没有提供有效的类似 &lt;del&gt;setDescription()&lt;/del&gt; 方法，这一点也确实是设计如此，毕竟服务没有运行，就不存在描述信息，在系统设置的“无障碍”页面，就读取不到。&lt;/p&gt;
&lt;p&gt;也就是说即便是使用 &lt;code&gt;setServiceInfo()&lt;/code&gt; 方法动态设置，也逃不脱使用 XML 配置文件的方式，我还是强烈建议都使用 XML 配置文件的方式配置辅助服务，主要是为了省事。&lt;/p&gt;
&lt;h3 id=&quot;清单文件中注册服务&quot;&gt;2.3 清单文件中注册服务&lt;/h3&gt;
&lt;p&gt;本质上 AccessibilityService 还是一个 Service，使用它我们还需要在清单文件中配置它。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;service&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; android:label=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;承香墨影的辅助工具&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:permission=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    android:name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;.WeForwardServer&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;intent-filter&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;action&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; android:name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;android.accessibilityservice.AccessibilityService&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta-data&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        android:name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;android.accessibilityservice&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        android:resource=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;@xml/accessibility_config&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/service&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是一个标准的 Service，其中 &lt;code&gt;label&lt;/code&gt; 会被解析在系统设置的“辅助模式中显示”，而 &lt;code&gt;intent-filter&lt;/code&gt; 和 &lt;code&gt;meta-data&lt;/code&gt; 按照格式写就好了，没什么原因。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;meta-data&lt;/code&gt; 中，通过 &lt;code&gt;android:resource&lt;/code&gt; 属性指定的就是我们在第二步编辑的配置文件路径，指定它就好了。&lt;/p&gt;
&lt;h3 id=&quot;开启辅助模式&quot;&gt;2.4 开启辅助模式&lt;/h3&gt;
&lt;p&gt;以上步骤都完成之后，你就可以在系统的“无障碍”设置里，看到你编写的辅助模式的开关了。&lt;/p&gt;
&lt;p&gt;默认为关闭状态，打开它的时候，你会收到一个警告弹窗，说明当前你正在开启一个无障碍的服务，它有哪些权限，这个对话框，我们是控制不了的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641ab598a1d9243?w=434&amp;amp;h=192&amp;amp;f=jpeg&amp;amp;s=10096&quot; alt=&quot;open-accessibility&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这里的 Title 就是清单文件里配置的 &lt;code&gt;android:label&lt;/code&gt; ，而描述就是 XML 配置文件里的 &lt;code&gt;android:description&lt;/code&gt; 信息。&lt;/p&gt;
&lt;p&gt;当你在系统设置里，能看到此开关的时候，就说明你的辅助模式的服务，配置的没问题了，接下来就要思考如何使用它。&lt;/p&gt;
&lt;h2 id=&quot;三编写逻辑代码&quot;&gt;三、编写逻辑代码&lt;/h2&gt;
&lt;p&gt;前面提到，在 AccessibilityService 里，我们最需要关注的就是 &lt;code&gt;onAccessibilityEvent()&lt;/code&gt; 方法，它会在我们监听的事件发生的时候，被系统回调，并传递过来该事件相关的信息。&lt;/p&gt;
&lt;p&gt;接下来我们看看如何在 &lt;code&gt;onAccessibilityEvent()&lt;/code&gt; 回调方法里，编写具体的逻辑。&lt;/p&gt;
&lt;p&gt;接下来 &quot;程序员思维&quot; 要上线了，把大象关冰箱，需要几步。我们接下来来拆分辅助模式的步骤。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断事件，&lt;code&gt;onAccessibilityEvent()&lt;/code&gt; 会被回调多次，而我们只需要处理我们关心的事件，其他的忽略过滤掉即可。&lt;/li&gt;
&lt;li&gt;找到需要控制的关键节点（Node），以便之后进行控制。&lt;/li&gt;
&lt;li&gt;对关键节点，发送对于的操作事件，以便完成我们的步骤。&lt;/li&gt;
&lt;li&gt;回收资源，防止资源泄露。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很简单对不对，接下来我们细细的说下，这些步骤相关的方法和属性。&lt;/p&gt;
&lt;h3 id=&quot;判断事件&quot;&gt;3.1 判断事件&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;onAccessibilityEvent()&lt;/code&gt; 被系统回调的时候，同时也会传递过来一个 AccessibilityEvent 对象，它其中包含了很多与当前事件相关的信息，有兴趣可以看看源码，我们这里只关注最需要的几个属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、eventType 判断事件类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 eventType 来判断事件的类型，我们可以利用 &lt;code&gt;getEventType()&lt;/code&gt; 方法获取到它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641ab598a28b5b1?w=629&amp;amp;h=691&amp;amp;f=jpeg&amp;amp;s=133876&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些事件都很好辨认，例如：TYPE_NOTIFICATION_STATE_CHANGED 是一个窗口 View 发生了变化，TYPE_VIEW_CLICKED 是某个 View 发生了一次点击事件等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、packageName 判断事件发生的 App&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;getPackageName()&lt;/code&gt; 方法，判断出事件发生在那个 App 里的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、className 判断当前发生事件的是那个类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;getClassName()&lt;/code&gt; 判断当前发生事件的是那个类，例如 页面的显示，className 可能指向一个 Activity，一个按钮的点击，className 可能指向的是一个 Button，这些都是根据实际场景区分的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、text 判断当前事件触发源上的 Text&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;getText()&lt;/code&gt; 获取当前事件源的 text 属性，可能是 TextView 的 Text，也可能是 Activity 的 Label 属性，依然是根据实际情况区分。&lt;/p&gt;
&lt;p&gt;一般我们可以通过以上几种方式，猜测是否是我们需要监听的事件，下一步就是我们找到我们要操作的源。&lt;/p&gt;
&lt;h3 id=&quot;找到待控制的关键节点node&quot;&gt;3.2 找到待控制的关键节点（Node）&lt;/h3&gt;
&lt;p&gt;通常我们是使用辅助模式去操作页面上的某个元素，那这一步，就是为了找到它。&lt;/p&gt;
&lt;p&gt;在辅助模式下，页面上的每个元素，其实都是一个个 AccessibilityNodeInfo 节点，它是一个类似树形的结构，其内和我们真实 App 内的布局层级是一致的，但是并不能将它单纯的理解成一个 ViewTree。&lt;/p&gt;
&lt;p&gt;既然是树形结构，我们首先要获取到根节点的 NodeInfo，可以通过以下两个方式获取：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;event.getSource()&lt;/li&gt;
&lt;li&gt;getRootInActiveWindow()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个方法都会返回一个 AccessibilityNodeInfo 对象。&lt;code&gt;getSource()&lt;/code&gt; 是AccessibilityEvent 的方法，它可用的前提是前面配置 &lt;code&gt;android:canRetrieveWindowContent&lt;/code&gt; 的时候，被设置为 True。所以我推荐使用 &lt;code&gt;getRootInActiveWindow()&lt;/code&gt; 方法来获取。这两个方法还是略微有些差异，有兴趣可以打断点看看信息，但是大多数情况下，对我们使用者来说是一致的。&lt;/p&gt;
&lt;p&gt;获得根节点的 AccessibilityNodeInfo 之后，就可以通过它找到我们想操作的关键节点，在 AccessibilityNodeInfo 中，提供了以下两个方法来找到关键节点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;findAccessibilityNodeInfosByViewId(String viewId)&lt;/li&gt;
&lt;li&gt;findAccessibilityNodeInfosByText(String text)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个是依赖 ViewId，另外一个是依赖 Text 信息。&lt;/p&gt;
&lt;p&gt;使用 ViewId 查找&lt;strong&gt;关键节点&lt;/strong&gt;是稳妥的方案，而使用 Text 去查找，可能会找不到。&lt;/p&gt;
&lt;p&gt;无论通过哪种方式查找 &lt;strong&gt;关键节点&lt;/strong&gt; ，都是存在能找到多个 NodeInfo 的可能的，所以这两个方法干脆的都返回了一个 &lt;code&gt;List&amp;lt;AccessibilityNodeInfo&amp;gt;&lt;/code&gt; ，所以需要我们通过其他条件再过滤一遍，通常就是通过 Text 信息过滤。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; mNodeInfo = rootInActiveWindow
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; listItem = mNodeInfo.&lt;span class=&quot;fu&quot;&gt;findAccessibilityNodeInfosByViewId&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.tencent.mm:id/lp&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (item &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; listItem) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (item.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;承香墨影&quot;&lt;/span&gt;)){
        &lt;span class=&quot;fu&quot;&gt;nodeClick&lt;/span&gt;(item)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是使用 &lt;code&gt;findXxxByText()&lt;/code&gt; 的方法的话，还需要注意它实际上不是通过类似 &lt;code&gt;==&lt;/code&gt; 或者 &lt;code&gt;equals()&lt;/code&gt; 的方法来查找子节点的，而是通过类似 &lt;code&gt;contain()&lt;/code&gt; 的方式，所以只要节点的 text 属性包含查找的内容，都会被找到，这个我们额外还需要增加判断条件。&lt;/p&gt;
&lt;p&gt;如果这些方法都试过，还是找不到关键节点，可以通过遍历的方式查找。&lt;/p&gt;
&lt;p&gt;AccessibilityNodeInfo 既然是一个树状结构，也提供了我们遍历树的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getParent()：查找父节点。&lt;/li&gt;
&lt;li&gt;getChild()：返回子节点。&lt;/li&gt;
&lt;li&gt;getChildCount()：当前节点的子节点个数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过 &lt;code&gt;getChild()&lt;/code&gt; 和 &lt;code&gt;getChildCount()&lt;/code&gt; 两个方法，我们是可以对整个 ViewNodeTree 进行遍历，来找到我们关注的关键节点，这是一个最后的方案，并不推荐使用。&lt;/p&gt;
&lt;h3 id=&quot;触发事件&quot;&gt;3.3 触发事件&lt;/h3&gt;
&lt;p&gt;辅助模式一般都是帮助我们响应一些事件，而这些事件大体上，可以分为两类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局系统事件。&lt;/li&gt;
&lt;li&gt;View 事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于全局系统事件，其实我们并不需要第二步找到的关键节点。AccessibilityService 提供了一个 &lt;code&gt;performGlobalAction()&lt;/code&gt; 方法，我们可以通过该方法，操作一些全局的系统事件，例如：模拟返回键点击、模拟 HOME 键点击、锁屏等等。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 返回键&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;performGlobalAction&lt;/span&gt;(AccessibilityService.&lt;span class=&quot;fu&quot;&gt;GLOBAL_ACTION_BACK&lt;/span&gt;);
&lt;span class=&quot;co&quot;&gt;// HOME键&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;performGlobalAction&lt;/span&gt;(AccessibilityService.&lt;span class=&quot;fu&quot;&gt;GLOBAL_ACTION_HOME&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些事件被封装在 AccessibilityService 中，以 &lt;code&gt;GLOBAL_&lt;/code&gt; 为前缀，看看属性说明就懂了。&lt;/p&gt;
&lt;p&gt;除了全局系统事件之外，通常我们就是想操作第二步拿到的关键节点。&lt;/p&gt;
&lt;p&gt;在 AccessibilityNodeInfo 中，提供了一个 &lt;code&gt;performAction()&lt;/code&gt; 的方法，可以通过该方法，对关键节点传递一个我们需要的事件。&lt;/p&gt;
&lt;p&gt;这些事件都被定义在 AccessibilityNodeInfo 中，以 &lt;code&gt;ACTION_&lt;/code&gt; 为前缀定义。例如：ACTION_CLICK 是一个点击事件，ACTION_SET_TEXT 设置一个输入。&lt;/p&gt;
&lt;p&gt;这里仅介绍一些比较常见的操作，更多的操作也是类似的使用方式。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; View 的点击&lt;/p&gt;
&lt;p&gt;找到关键节点之后，就可以发送 &lt;code&gt;AccessibilityNodeInfo.ACTION_CLICK&lt;/code&gt; 模拟对这个 View 的点击操作。&lt;/p&gt;
&lt;p&gt;但是有时候它是不生效的，主要原因是因为你找到的这个关键节点，它的 &lt;code&gt;isClickable()&lt;/code&gt; 为 false。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641ab598a06eed9?w=434&amp;amp;h=466&amp;amp;f=jpeg&amp;amp;s=23858&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如微信的这个公众号分享弹窗，如果我们想要查找“发送给朋友”，其实最好的办法是找到这个 TextView 控件所代表的关键节点（NodeInfo），然后对它进行点击。而实际上这个 TextView 是不具有点击效果的，它的 &lt;code&gt;isClickable()&lt;/code&gt; 为 false。&lt;/p&gt;
&lt;p&gt;这个时候可以想一个折中的方案，去找关键节点（NodeInfo）的父节点，再去判断它是否可点击，可点击则点击它，否则继续向上找。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;nodeClick&lt;/span&gt;(node : AccessibilityNodeInfo?){
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; clickNode = node;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (clickNode!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(clickNode.&lt;span class=&quot;fu&quot;&gt;isClickable&lt;/span&gt;){
            clickNode.&lt;span class=&quot;fu&quot;&gt;performAction&lt;/span&gt;(AccessibilityNodeInfo.&lt;span class=&quot;fu&quot;&gt;ACTION_CLICK&lt;/span&gt;)
            break;
        }
        clickNode = node?.&lt;span class=&quot;fu&quot;&gt;parent&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然 AccessibilityNodeInfo 其实也开放了 &lt;code&gt;setClickable()&lt;/code&gt; 方法，但是我不建议操作它，有些时候会抛出一个异常，不太稳定。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; EditText 输入文字&lt;/p&gt;
&lt;p&gt;对 EditText 输入文字，最少需要两个参数，关键节点和输入的文字。这就需要用到 &lt;code&gt;performAction()&lt;/code&gt; 的另外一个重载方法，它允许额外在传递一个 Bundle 来指定参数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;nodeSetText&lt;/span&gt;(node : AccessibilityNodeInfo?,text:String){
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; argument = &lt;span class=&quot;fu&quot;&gt;Bundle&lt;/span&gt;()
    argument.&lt;span class=&quot;fu&quot;&gt;putString&lt;/span&gt;(AccessibilityNodeInfo.&lt;span class=&quot;fu&quot;&gt;ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE&lt;/span&gt;,text)
    node?.&lt;span class=&quot;fu&quot;&gt;performAction&lt;/span&gt;(AccessibilityNodeInfo.&lt;span class=&quot;fu&quot;&gt;ACTION_SET_TEXT&lt;/span&gt;,argument)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有支持定义的额外参数，都被定义在 AccessibilityNodeInfo 中，并以 &lt;code&gt;ACTION_ARGUMENT_&lt;/code&gt; 为前缀定义。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; ListView 的滚动&lt;/p&gt;
&lt;p&gt;AccessibilityNodeInfo 其实只能操作当前屏幕下可见的 节点，所以碰上 ListView 或者 RecycleView 这种列表，就需要对它进行滚动。&lt;/p&gt;
&lt;p&gt;滚动的事件有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ACTION_SCROLL_FORWARD&lt;/li&gt;
&lt;li&gt;ACTION_SCROLL_BACKWARD&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;nodeScrollList&lt;/span&gt;(node : AccessibilityNodeInfo?){
    node?.&lt;span class=&quot;fu&quot;&gt;performAction&lt;/span&gt;(AccessibilityNodeInfo.&lt;span class=&quot;fu&quot;&gt;ACTION_SCROLL_FORWARD&lt;/span&gt;)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个前进一个后退，足够使用了。&lt;/p&gt;
&lt;h3 id=&quot;回收资源&quot;&gt;3.4 回收资源&lt;/h3&gt;
&lt;p&gt;在使用完 AccessibilityNodeInfo 之后，别忘了还需要调用 &lt;code&gt;recycle()&lt;/code&gt; 方法，释放资源。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;nodeInfo.&lt;span class=&quot;fu&quot;&gt;recycle&lt;/span&gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;
&lt;p&gt;辅助模式如何使用，到现在已经讲解的非常清楚了，后面基本上就是靠自己的想象力来做小功能了。&lt;/p&gt;
&lt;p&gt;利用辅助模式，发挥想象力，你也可以做出很多有意思的功能。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我准备的学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步；你还能回复『&lt;strong&gt;提问&lt;/strong&gt;』，向我发起提问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641ab598a1fb85b?w=1000&amp;amp;h=400&amp;amp;f=jpeg&amp;amp;s=27637&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 07:14:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/accessibility_android.html</dc:identifier>
</item>
<item>
<title>C# 设置Excel超链接（二） - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/9209170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/9209170.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;超链接能够快速地将当前文本或图片链接到指定目标地址，在日常办公中给我们提供了极大的便利。本文将介绍在C#语言中如何通过免费版组件对Excel表格添加超链接，示例中将包含以下要点：&lt;/p&gt;
&lt;p&gt;1.添加链接到网页（文本、图片）&lt;/p&gt;
&lt;p&gt;   1.1 链接到文本&lt;/p&gt;
&lt;p&gt;   1.2 链接到图片&lt;/p&gt;
&lt;p&gt;2.添加链接到指定文档&lt;/p&gt;
&lt;p&gt;3.添加链接到指定单元格&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;使用工具&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;下载安装该组件，并添加引用该组件Spire.Xls.dll到项目程序即可（如下图），dll文件可在安装路径下的Bin文件夹中获取。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201806/706090-20180621143744877-2019080133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;示例代码操作&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;1.添加链接到网页&lt;/h3&gt;
&lt;p&gt;（这里分两种情况，添加文本链接和图片链接。）&lt;/p&gt;
&lt;h4&gt;  1.1添加超链接到文本字符串&lt;/h4&gt;
&lt;p&gt;步骤1：创建Excel，获取工作表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Workbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
Worksheet sheet &lt;/span&gt;= wb.Worksheets[&lt;span&gt;0&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤2：获取单元格，添加文本并设置对齐方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;绿色交通（Green Transpotation）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style.VerticalAlignment = VerticalAlignType.Bottom;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤3：设置超链接到指定单元格&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
HyperLink UrlLink = sheet.HyperLinks.Add(sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
UrlLink.TextToDisplay &lt;/span&gt;= sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Text;
UrlLink.Type &lt;/span&gt;=&lt;span&gt; HyperLinkType.Url;
UrlLink.Address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://baike.baidu.com/item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;1.2 链接到图片&lt;/h4&gt;
&lt;p&gt;步骤1：初始化一个string类，加载图片 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; picPath = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\images\th.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤2：将图片添加到A1单元格,并设置超链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ExcelPicture picture = sheet.Pictures.Add(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, picPath);           
picture.SetHyperLink(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://en.wikipedia.org/wiki/Sustainable_transport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤3：调整图片在单元格中的位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sheet.Columns[&lt;span&gt;0&lt;/span&gt;].ColumnWidth = &lt;span&gt;28&lt;/span&gt;&lt;span&gt;;
sheet.Rows[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].RowHeight = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
picture.TopRowOffset &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wb.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hyperlink.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2013);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hyperlink.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调试运行该项目程序后，生成文档，如下图所示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201806/706090-20180621143951831-1225088149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_0cc257ab-99c8-48ef-be42-bce8b2b4cc95&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0cc257ab-99c8-48ef-be42-bce8b2b4cc95&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0cc257ab-99c8-48ef-be42-bce8b2b4cc95&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Xls;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TextHyperlink_XLS
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加文本超链接
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Workbook类对象，获取第一个工作表&lt;/span&gt;
            Workbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
            Worksheet sheet &lt;/span&gt;= wb.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个单元格添加文本并设置文本对齐方式&lt;/span&gt;
            sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;绿色交通（Green Transpotation）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            sheet.Range[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Style.VerticalAlignment =&lt;span&gt; VerticalAlignType.Bottom;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个超链接类对象，在A1单元格设置文本超链接&lt;/span&gt;
            HyperLink UrlLink = sheet.HyperLinks.Add(sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
            UrlLink.TextToDisplay &lt;/span&gt;= sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Text;
            UrlLink.Type &lt;/span&gt;=&lt;span&gt; HyperLinkType.Url;
            UrlLink.Address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://baike.baidu.com/item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
           
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加图片超链接。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化一个string类，加载图片 &lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; picPath = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\images\th.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将图片添加到A1单元格,并设置超链接&lt;/span&gt;
            ExcelPicture picture = sheet.Pictures.Add(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, picPath);           
            picture.SetHyperLink(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://en.wikipedia.org/wiki/Sustainable_transport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置图片在单元格中的位置&lt;/span&gt;
            sheet.Columns[&lt;span&gt;0&lt;/span&gt;].ColumnWidth = &lt;span&gt;28&lt;/span&gt;&lt;span&gt;;
            sheet.Rows[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].RowHeight = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
            picture.TopRowOffset &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存并打开文件&lt;/span&gt;
            wb.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hyperlink.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2013);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hyperlink.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;2.添加链接到文档&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;【C#】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化一个Workbook类并加载Excel文档&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\Sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个工作表&lt;/span&gt;
Worksheet sheet = workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置超链接到指定单元格&lt;/span&gt;
CellRange range = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
HyperLink FileLink &lt;/span&gt;=&lt;span&gt; sheet.HyperLinks.Add(range);
FileLink.Type &lt;/span&gt;=&lt;span&gt; HyperLinkType.File;
FileLink.TextToDisplay &lt;/span&gt;= sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Text;
FileLink.Address &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存并打开文档&lt;/span&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FileLink.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FileLink.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;效果示例：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201806/706090-20180621144203415-2127291937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;3.添加链接到指定单元格&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;【C#】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个Excel类对象，加载Excel文档，获取第一个工作表&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\Sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Worksheet sheet &lt;/span&gt;= workbook.Worksheets[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定单元格，链接至指定文档中的特定单元格&lt;/span&gt;
CellRange range = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
HyperLink WbLink &lt;/span&gt;=&lt;span&gt; sheet.HyperLinks.Add(range);
WbLink.Type &lt;/span&gt;=&lt;span&gt; HyperLinkType.Workbook;
WbLink.TextToDisplay &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已清算&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
WbLink.Address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A账目明细!A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存并打开文档&lt;/span&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LinktoCell.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ExcelVersion.Version2013);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LinktoCell.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;效果展示：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201806/706090-20180621144335930-1702728275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;4.添加链接Unc路径&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;【C#】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个Workbook类对象，加载Excel文档，获取第二个工作表&lt;/span&gt;
Workbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Workbook();
workbook.LoadFromFile(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\Sample.xlsx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Worksheet sheet &lt;/span&gt;= workbook.Worksheets[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Unc链接至A1单元格，设置连接类型为Unc，添加显示文本及链接路径&lt;/span&gt;
CellRange range = sheet.Range[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
HyperLink UncLink &lt;/span&gt;=&lt;span&gt; sheet.HyperLinks.Add(range);
UncLink.Type &lt;/span&gt;=&lt;span&gt; HyperLinkType.Unc;
UncLink.TextToDisplay &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
UncLink.Address &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\192.168.1.118&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档&lt;/span&gt;
workbook.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LinktoUnc.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201806/706090-20180621144428314-271146260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上是关于添加Excel超链接的全部内容。&lt;/p&gt;
&lt;p&gt;&amp;lt;本文完&amp;gt;&lt;/p&gt;
&lt;p&gt;如需转载，请注明出处。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 07:11:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/9209170.html</dc:identifier>
</item>
<item>
<title>Java关键字(三)——static - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9202016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9202016.html</guid>
<description>&lt;p&gt;　　我们说Java是一种面向对象编程的语言，而对象是把数据及对数据的操作方法放在一起，作为一个相互依存的整体，对同类对象抽象出其共性，便是Java中的类，我们可以用类描述世间万物，也可以说万物皆对象。但是这里有个特殊的东西——static，它不属于对象，那么为什么呢？&lt;/p&gt;
&lt;p&gt;　　static 是Java的一个关键字，可以用来修饰成员变量、修饰成员方法、构造静态代码块、实现静态导报以及实现静态内部类，下面我们来分别介绍。&lt;/p&gt;
&lt;h3&gt;1、修饰成员变量&lt;/h3&gt;
&lt;p&gt;　　用 static 修饰成员变量可以说是该关键字最常用的一个功能，通常将用 static 修饰的成员变量称为类成员或者静态成员，那么静态成员和不用 static 修饰的非静态成员有什么区别呢？&lt;/p&gt;
&lt;p&gt;　　我们先看看不用 static 修饰的成员变量在内存中的构造。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f1677bfa-34c3-4d95-8877-fd169ee0e6f3')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_f1677bfa-34c3-4d95-8877-fd169ee0e6f3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f1677bfa-34c3-4d95-8877-fd169ee0e6f3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f1677bfa-34c3-4d95-8877-fd169ee0e6f3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f1677bfa-34c3-4d95-8877-fd169ee0e6f3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name, Integer age) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
&lt;span&gt;18&lt;/span&gt;                 &quot;name='&quot; + name + '\'' +
&lt;span&gt;19&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt;20&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get和set方法省略&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　首先，我们创建一个实体类 Person，有两个属性 name 和 age，都是普通成员变量（没有用 static 关键字修饰），接着我们通过其构造方法创建两个对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person p1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Tom&quot;,21&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Person p2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Marry&quot;,20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; System.out.println(p1.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person{name='Tom', age=21}&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; System.out.println(p2.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person{name='Marry', age=20}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两个对象在内存中的存储结构如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180620210908837-557591297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　由上图可知，我们创建的两个对象 p1 和 p2  存储在堆中，但是其引用地址是存放在栈中的，而且这两个对象的两个变量互相独立，我们修改任何一个对象的属性值，是不改变另外一个对象的属性值的。&lt;/p&gt;
&lt;p&gt;　　下面我们将 Person 类中的 age 属性改为由 static 关键字修饰：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a89fc9cc-dbfb-4ff8-ac98-d7d8990baa8d')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_a89fc9cc-dbfb-4ff8-ac98-d7d8990baa8d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a89fc9cc-dbfb-4ff8-ac98-d7d8990baa8d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a89fc9cc-dbfb-4ff8-ac98-d7d8990baa8d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a89fc9cc-dbfb-4ff8-ac98-d7d8990baa8d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String name;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name, Integer age) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
&lt;span&gt;18&lt;/span&gt;                 &quot;name='&quot; + name + '\'' +
&lt;span&gt;19&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt;20&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get和set方法省略&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　同样我们还是向上面一样，创建 p1 和 p2 两个对象，并打印这两个对象，看看和上面打印的有啥区别呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person p1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Tom&quot;,21&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Person p2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Marry&quot;,20&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; System.out.println(p1.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person{name='Tom', age=20}&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; System.out.println(p2.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person{name='Marry', age=20}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们发现第三行代码打印的 p1 对象 age 属性变为 20了，这是为什么呢？&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180620212435546-1183265110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是因为用在 jvm 的内存构造中，会在堆中开辟一块内存空间，专门用来存储用 static 修饰的成员变量，称为静态存储区，无论我们创建多少个对象，用 static 修饰的成员变量有且只有一份存储在静态存储区中，所以该静态变量的值是以最后创建对象时设置该静态变量的值为准，也就是由于 p1 先设置 age = 21，后来创建了 p2 对象，p2将 age 改为了20，那么该静态存储区的 age 属性值也被修改成了20。&lt;/p&gt;
&lt;p&gt;　　PS：在 JDK1.8 以前，静态存储区是存放在方法区的，而方法区不属于堆，在 JDK1.8 之后，才将方法区干掉了，方法区中的静态存储区改为到堆中存储。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;总结：static 修饰的变量被所有对象所共享，在内存中只有一个副本。由于与对象无关，所以我们可以直接通过 类名.静态变量 的方式来直接调用静态变量。对应的非静态变量是对象所拥有的，多少个对象就有多少个非静态变量，各个对象所拥有的副本不受影响。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2、修饰修饰成员方法&lt;/h3&gt;
&lt;p&gt;　　用 static 关键字修饰成员方法也是一样的道理，我们可以直接通过 类名.静态方法名() 的方式来调用，而不用创建对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ebc49ccc-74e8-4dc9-a618-d6b7d6deb0e2')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ebc49ccc-74e8-4dc9-a618-d6b7d6deb0e2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ebc49ccc-74e8-4dc9-a618-d6b7d6deb0e2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ebc49ccc-74e8-4dc9-a618-d6b7d6deb0e2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ebc49ccc-74e8-4dc9-a618-d6b7d6deb0e2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String name;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Integer age;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printClassName(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;com.ys.bean.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name, Integer age) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person{&quot; +
&lt;span&gt;16&lt;/span&gt;                 &quot;name='&quot; + name + '\'' +
&lt;span&gt;17&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt;18&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get和set方法省略&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　调用静态方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person.printClassName();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;com.ys.bean.Person&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、静态代码块&lt;/h3&gt;
&lt;p&gt;　　用 static 修饰的代码块称为静态代码块，静态代码块可以置于类的任意一个地方（和成员变量成员方法同等地位，不可放入方法中），并且一个类可以有多个静态代码块，在类初次载入内存时加载静态代码块，并且按照声明静态代码块的顺序来加载，且仅加载一次，优先于各种代码块以及构造函数。&lt;/p&gt;
&lt;p&gt;　　关于静态代码块、构造代码块、构造函数、普通代码块的区别可以参考我的&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8194428.html&quot; target=&quot;_blank&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CodeBlock {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(&quot;静态代码块&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于静态代码块只在类载入内存时加载一次的特性，我们可以利用静态代码块来优化程序性能，比如某个比较大配置文件需要在创建对象时加载，这时候为了节省内存，我们可以将该配置文件的加载时机放入到静态代码块中，那么我们无论创建多少个对象时，该配置文件也只加载了一次。&lt;/p&gt;
&lt;h3&gt;4、静态导包&lt;/h3&gt;
&lt;p&gt;　　用 static 来修饰成员变量，成员方法，以及静态代码块是最常用的三个功能，静态导包是 JDK1.5以后的新特性，用 import static 包名 来代替传统的 import 包名 方式。那么有什么用呢？&lt;/p&gt;
&lt;p&gt;　　比如我们创建一个数组，然后用 JDK 自带的 Arrays 工具类的 sort 方法来对数组进行排序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticTest {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arrays = {3,4,2,8,1,9&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        Arrays.sort(arrays);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以看到，调用 sort 方法时，需要进行 import java.util.Arrays 的导包操作，那么变为静态导包呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; java.util.Arrays.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticTest {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] arrays = {3,4,2,8,1,9&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        sort(arrays);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以看到第三行代码的 import java.util.Arrays 变为了 import static  java.util.Arrays.*，意思是导入 Arrays 类中的所有静态方法，当然你也可以将 * 变为某个方法名，也就是只导入该方法，那么我们在调用该方法时，就可以不带上类名，直接通过方法名来调用（第 11 行代码）。&lt;/p&gt;
&lt;p&gt;　　静态导包只会减少程序员的代码编写量，对于性能是没有任何提升的（也不会降低性能，Java核心技术第10版卷1第148页4.7.1章节类的导入有介绍），反而会降低代码的可读性，所以实际如何使用需要权衡。&lt;/p&gt;
&lt;h3&gt;5、静态内部类&lt;/h3&gt;
&lt;p&gt;　　首先我们要知道什么是内部类，定义在一个类的内部的类叫内部类，包含内部类的类叫外部类，内部类用 static 修饰便是我们所说的静态内部类。&lt;/p&gt;
&lt;p&gt;　　定义内部类的好处是外部类可以访问内部类的所有方法和属性，包括私有方法和私有属性。&lt;/p&gt;
&lt;p&gt;　　访问普通内部类，我们需要先创建外部类的对象，然后通过外部类名.new 创建内部类的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by hadoop
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutClass {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  * OuterClass oc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OuterClass();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  * OuterClass.InnerClass in = oc.&lt;span&gt;new&lt;/span&gt; InnerClass();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　访问静态内部类，我们不需要创建外部类的对象，可以直接通过 外部类名.内部类名 来创建实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by hadoop
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutClass {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; OuterClass.StaticInnerClass sic = &lt;span&gt;new&lt;/span&gt; OuterClass.StaticInnerClass();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、常见问题&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;①、静态变量能存在于普通方法中吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　能。很明显，普通方法必须通过对象来调用，静态变量都可以直接通过类名来调用了，更不用说通过对象来调用，所以是可以存在于普通方法中的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、静态方法能存在普通变量吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不能。因为静态方法可以直接通过类名来直接调用，不用创建对象，而普通变量是必须通过对象来调用的。那么将普通变量放在静态方法中，在直接通过类来调用静态方法时就会报错。所以不能。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、静态代码块能放在方法体中吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不能。首先我们要明确静态代码块是在类加载的时候自动运行的。&lt;/p&gt;
&lt;p&gt;　　普通方法需要我们创建对象，然后手工去调用方法，所静态代码块不能声明在普通方法中。&lt;/p&gt;
&lt;p&gt;　　那么对于用 static 修饰的静态方法呢？同样也是不能的。因为静态方法同样也需要我们手工通过类名来调用，而不是直接在类加载的时候就运行了。&lt;/p&gt;
&lt;p&gt;　　也就是说静态代码块能够自动执行，而不管是普通方法还是静态方法都是需要手工执行的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、静态导包会比普通导包消耗更多的性能？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不会。静态导包实际上在编译期间都会被编译器进行处理，将其转换成普通按需导包的形式，所以在程序运行期间是不影响性能的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;⑤、static 可以用来修饰局部变量吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不能。不管是在普通方法还是在静态方法中，static 关键字都不能用来修饰局部变量，这是Java的规定。稍微想想也能明白，局部变量的声明周期是随着方法的结束而结束的，因为static 修饰的变量是全局的，不与对象有关的，如果用 static 修饰局部变量容易造成理解上的冲突，所以Java规定 static 关键字不能用来修饰局部变量。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 06:53:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9202016.html</dc:identifier>
</item>
<item>
<title>[webpack]--webpack 如何解析代码模块路径 - FannieGirl</title>
<link>http://www.cnblogs.com/ifannie/p/9208808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ifannie/p/9208808.html</guid>
<description>&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;   webpack是如何解析代码模块路径&lt;/p&gt;
&lt;p&gt;    webpack 中有一个很关键的模块 &lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fenhanced-resolve%2F&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;enhanced-resolve&lt;/a&gt; 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块解析规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解析相对路径&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;查找相对当前模块的路径下是否有对应文件或文件夹&lt;/li&gt;
&lt;li&gt;是文件则直接加载&lt;/li&gt;
&lt;li&gt;是文件夹则继续查找文件夹下的 package.json 文件&lt;/li&gt;
&lt;li&gt;有 package.json 文件则按照文件中 main 字段的文件名来查找文件&lt;/li&gt;
&lt;li&gt;无 package.json 或者无 main 字段则查找 index.js 文件.&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;   解析模块名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;             查找当前文件目录下，父级目录及以上目录下的 &lt;code&gt;node_modules&lt;/code&gt; 文件夹，看是否有对应名称的模块&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;   解析绝对路径（不建议使用）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;             直接查找对应路径的文件&lt;/p&gt;
&lt;p&gt;　在 webpack 配置中，和模块路径解析相关的配置都在 &lt;code&gt;resolve&lt;/code&gt; 字段下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module.exports = {
  resolve: {
    // ...
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;&lt;code&gt;resolve.alias&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;假设我们有个 utils 模块极其常用，经常编写相对路径很麻烦，希望可以直接 import 'utils' 来引用，那么我们可以配置某个模块的别名，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alias: {
 utils: path.resolve(__dirname, 'src/utils')
 // 这里使用 path.resolve 和 __dirname 来获取绝对路径 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import 'utils/query.js' 
// 等同于 import '[项目绝对路径]/src/utils/query.js'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果需要进行精确匹配可以使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;alias: { 
utils$: path.resolve(__dirname, 'src/utils')
 // 只会匹配 import 'utils' 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;更多匹配相关的写法可以参考官方文档 Resolve Alias，这里不一一举例说明。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;&lt;code&gt;resolve.extensions&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;extensions: ['.wasm', '.mjs', '.js', '.json', '.jsx'],
// 这里的顺序代表匹配后缀的优先级，例如对于 index.js 和 index.jsx，会优先选择 index.js&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到数组中配置的字符串大概就可以猜到，这个配置的作用是和文件后缀名有关的。是的，这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找，例如有了上述的配置，当你在 src/utils/ 目录下有一个 common.js 文件时，就可以这样来引用.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import * as common from './src/utils/common'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;webpack 会尝试给你依赖的路径添加上 extensions 字段所配置的后缀，然后进行依赖路径查找，所以可以命中 src/utils/common.js 文件。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;&lt;code&gt;resolve.modules&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;前面的内容有提到，对于直接声明依赖名的模块（如 &lt;code&gt;react&lt;/code&gt; ），webpack 会类似 Node.js 一样进行路径搜索，搜索 node_modules 目录，这个目录就是使用 &lt;code&gt;resolve.modules&lt;/code&gt; 字段进行配置的，默认就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resolve: {
  modules: ['node_modules'],
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;如果可以确定项目内所有的第三方依赖模块都是在项目根目录下的 node_modules 中的话，那么可以在 node_modules 之前配置一个确定的绝对路径：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;resolve: {
  modules: [
    path.resolve(__dirname, 'node_modules'), // 指定当前目录下的 node_modules 优先查找
    'node_modules', // 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录
  ],
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这样配置在某种程度上可以简化模块的查找，提升构建速度。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　resolve 还有一些其他的配置，还有其他的伙伴那就去官网看看，以上都是实际项目中使用到的。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 06:15:00 +0000</pubDate>
<dc:creator>FannieGirl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ifannie/p/9208808.html</dc:identifier>
</item>
<item>
<title>python3之requests - Py.qi</title>
<link>http://www.cnblogs.com/zhangxinqi/p/9201594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinqi/p/9201594.html</guid>
<description>&lt;h3&gt;1、requests简介&lt;/h3&gt;
&lt;p&gt;requests是通过urllib3实现自动发送HTTP/1.1请求，它能轻松的实现cookies，登陆验证，代理设置等操作。&lt;/p&gt;
&lt;p&gt;Python内置的urllib模块，用于访问网络资源。但是，它用起来比较麻烦，而且，缺少很多实用的高级功能。&lt;br/&gt;更好的方案是使用requests。它是一个Python第三方库，处理URL 资源特别方便&lt;/p&gt;
&lt;p&gt;requests实现内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保持活力和连接池&lt;/li&gt;
&lt;li&gt;支持国际域名和网址&lt;/li&gt;
&lt;li&gt;会话与Cookie持久性&lt;/li&gt;
&lt;li&gt;浏览器式SSL验证&lt;/li&gt;
&lt;li&gt;自动内容解码&lt;/li&gt;
&lt;li&gt;基本/摘要式身份验证&lt;/li&gt;
&lt;li&gt;自动解压缩&lt;/li&gt;
&lt;li&gt;Unicode响应body&lt;/li&gt;
&lt;li&gt;HTTP(s)代理支持&lt;/li&gt;
&lt;li&gt;多部分文件上传&lt;/li&gt;
&lt;li&gt;流媒体下载&lt;/li&gt;
&lt;li&gt;连接超时&lt;/li&gt;
&lt;li&gt;分块的请求&lt;/li&gt;
&lt;li&gt;.netrc 支持&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2、requests的安装&lt;/h3&gt;
&lt;p&gt;(1)源码安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
git clone git: // github.com / requests / requests.git &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 克隆公共存储库&lt;/span&gt;
&lt;span&gt;或者下载tarball
curl &lt;/span&gt;- OL https: // github.com / requests / requests / tarball /&lt;span&gt; master
cd requests &lt;/span&gt;/&lt;span&gt; requests
pip install .&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)pip安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install requests
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)pipenv安装在虚拟环境下安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pipenv install requests
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;request依赖包关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
requests==2.19.1
  - certifi [required: &amp;gt;=2017.4.17, installed: 2018.4.16]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;CA认证模块&lt;/span&gt;
  - chardet [required: &amp;lt;3.1.0,&amp;gt;=3.0.2, installed: 3.0.4]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通用字符编码检测器模块&lt;/span&gt;
  - idna [required: &amp;lt;2.8,&amp;gt;=2.5, installed: 2.7]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;国际化域名解析模块&lt;/span&gt;
  - urllib3 [required: &amp;lt;1.24,&amp;gt;=1.21.1, installed: 1.23] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;线程安全HTTP库&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、requests请求&lt;/h3&gt;
&lt;p&gt;所有请求的功能可通过这7种方法访问，他们都返回response对象的一个实例。&lt;br/&gt;(1)requests.request(method,url,**kwargs):构造并发送一个request，返回一个response对象&lt;br/&gt;参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;method：　　request对象的方法(POST)&lt;/li&gt;
&lt;li&gt;url：　　request对象的URL&lt;/li&gt;
&lt;li&gt;params：可选的，要在查询字符串中发送的字典或字节request&lt;/li&gt;
&lt;li&gt;data：可选的，字典或元祖列表以表单编码，字节或类似文件的对象在主体中发送[(key,value)]&lt;/li&gt;
&lt;li&gt;json：可选的，一个json可序列化的python对象，在主体中发送request&lt;/li&gt;
&lt;li&gt;headers：可选的，用于编写http头信息&lt;/li&gt;
&lt;li&gt;cookies：可选，用dict或cookieJar对象发送Cookies&lt;/li&gt;
&lt;li&gt;file：可选，用于多部分编码上传的字典，可以是多元祖，其中是定义给定文件的内容类型的字符串，以及包含问文件添加的额外头文件的类字典对象&lt;/li&gt;
&lt;li&gt;auth：可选，身份验证元祖，自定义http身份验证&lt;/li&gt;
&lt;li&gt;timeout：可选，发送等待请求数据的超时时间(float/tuple),设置为元祖即为练级connect和read读取超时，如果设置为None即为永久等待&lt;/li&gt;
&lt;li&gt;allow_redirects：布尔值，可选，启用或禁用GET,OPTIONS,POST,PUT,PATCH,DELETE,HEAD重定向，默认为true&lt;/li&gt;
&lt;li&gt;proxies：可选，字典映射协议到代理的URL&lt;/li&gt;
&lt;li&gt;verify：可选，可以是布尔值，可以指定验证服务器的TLS证书路径，默认为true&lt;/li&gt;
&lt;li&gt;stream：可选，如果是False，响应内容将立即下载&lt;/li&gt;
&lt;li&gt;cert：可选，如果是string，则为ssl客户端证书文件路径，如果是元祖则('cert','key')指定证书和密钥&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 10:04&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_reqst.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; requests &lt;span&gt;import&lt;/span&gt;&lt;span&gt; request
header&lt;/span&gt;=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.79 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
response&lt;/span&gt;=request(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://api.github.com/events&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,headers=header) &lt;span&gt;#定义头信息&lt;/span&gt;&lt;span&gt;发送请求返回response对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.url) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回请求的URL&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.status_code)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回状态码200&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.encoding)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回编码&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.text)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回响应的内容以unicode表示&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.headers) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回头信息&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.cookies) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回cookies CookieJar&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.json()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回json数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)requests.head(url,**kwargs):发送head请求，url:网站URL地址，返回一个response对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 11:19&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_head.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; requests &lt;span&gt;import&lt;/span&gt;&lt;span&gt; head
header&lt;/span&gt;=head(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com/get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,header.text) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;不会返回内容信息&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;headers:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,header.headers) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回头信息&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(header.cookies.items()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回cookies元组列表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)requests.get(url,params=None,**kwargs):发送GET请求，params:要在查询字符串中发送的字典或字节request，返回一个response对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 11:29&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_get.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; requests &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get
response&lt;/span&gt;=get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/get&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,params={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;py.qi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:22})&lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加参数查询&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.text) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回结果包含args参数,headers头信息,URL和IP信息&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.url) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回组合的URL(http://httpbin.org/get?name=py.qi&amp;amp;age=22)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.json()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果返回网页是JSON格式，可以使用json()方法解析返回字典数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抓取网页：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 11:46&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_zhuaqu.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.runoob.com/python3/python3-reg-expressions.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
headers&lt;/span&gt;=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.79 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
response&lt;/span&gt;=requests.get(url,headers=&lt;span&gt;headers)
response.encoding&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(response.encoding)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(response.text)&lt;/span&gt;
pattern = re.compile(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id=&quot;content&quot;&amp;gt;.*?&amp;lt;h1&amp;gt;(.*?)&amp;lt;/h1&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;(.*?)&amp;lt;/p&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;/p&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;/p&amp;gt;.*?&amp;lt;p&amp;gt;(.*?)&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,re.S)
text &lt;/span&gt;=&lt;span&gt; re.search(pattern,response.text)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; text.groups():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&lt;span&gt;Python3 正则表达式
正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。
Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。
re 模块使 Python 语言拥有全部的正则表达式功能。 
compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 
re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抓取二进制文件：图像，BytesIO创建内存对象存储数据，Image打开图像获得图像对象，也可以用上下问方式将图像直接写入文件，适合音频，视频等文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 14:10&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_content.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; io &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BytesIO
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image

url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://docs.python-requests.org/en/master/_static/requests-sidebar.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
r&lt;/span&gt;=&lt;span&gt;requests.get(url)
i&lt;/span&gt;=Image.open(BytesIO(r.content)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获得一个图像对象&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(i.format,i.size,i.mode) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看图像的来源，像素和像素类型（RGB）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(i.show())  #显示图片&lt;/span&gt;
i.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;requests_log.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存图像数据到文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4)requests.post(url,data=None,json=None,**kwargs):发送POST请求，data:字典数据也可以是元组列表，将被表单编码，以字节或文件对象在数据主体中发送&lt;br/&gt;json:在json数据中发送正文，返回一个response对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 14:41&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_post1.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
data&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
r &lt;/span&gt;= requests.post(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data=data) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;以表单数据发送数据&lt;/span&gt;
body=r.json()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获得字典格式的返回数据 &lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(body[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;窃取表单编码数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传文件：files参数指定上传文件，上传的文件在主体数据中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 15:23&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_post_file.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
files&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;network.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)}
files1&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filename.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fileanme.xls&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/vnd.ms-excel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;expires&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})} &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置文件名&lt;/span&gt;
r=requests.post(url,files=files) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定文件发送请求&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.json()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多个文件上传：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/post&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

multple_files&lt;/span&gt;=&lt;span&gt;[
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;images1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;11.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;11.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image/jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
    (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;images2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;22.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;22.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image/jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)),
]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;字段代表意思依次为：文件名，文件对象，文件类型&lt;/span&gt;
r=requests.post(url,files=&lt;span&gt;multple_files)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.text)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在网站中PUT,PATCH,DELETE请求很少使用，不做介绍&lt;/p&gt;
&lt;p&gt;(5)requests.put(url,data=None,**kwargs):发送PUT请求参数同POST一样，将返回一个response对象&lt;/p&gt;
&lt;p&gt;(6)requests.patch(url,data=None,**kwargs):发送PATCH请求&lt;br/&gt;(7)requests.delete(url,**kwargs):发送DELETE请求&lt;/p&gt;
&lt;h3&gt;4、请求响应&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;class response.Response&lt;/strong&gt; ：该Response对象包含服务器对HTTP请求的响应信息&lt;/p&gt;
&lt;p&gt;该对象包含的属性和方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;apparent_encodind：&lt;/code&gt;由chardet库提供的明显编码。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;close()：&lt;/code&gt;将连接释放回池中，即关闭连接，通常不需要调用&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;content：&lt;/code&gt;响应的内容，以字节为单位。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;cookies&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None ：&lt;/em&gt;服务器发回的Cookies CookieJar。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;elapsed&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None ：&lt;/em&gt;发送请求和响应到达之间所经过的时间量（作为timedelta）。该属性具体测量发送请求的第一个字节和完成解析报头之间的时间。因此，它不受消费响应内容或&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;stream&lt;/span&gt;&lt;/code&gt;关键字参数值的影响。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;encoding&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None ：&lt;/em&gt;编码以在访问r.text时进行解码。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;headers&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None ：&lt;/em&gt;不区分大小写的响应头字典。例如，&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;headers['content-encoding']&lt;/span&gt;&lt;/code&gt;将返回&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;'Content-Encoding'&lt;/span&gt;&lt;/code&gt;响应头的值。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;history&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None ：&lt;/em&gt;&lt;code class=&quot;xref py py-class docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Response&lt;/span&gt;&lt;/code&gt;请求历史记录中的对象列表。任何重定向响应都会在这里结束。该列表从最旧的到最近的请求进行排序。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;is_permanent_redirect：&lt;/code&gt;如果此响应为真，则为重定向的永久版本之一。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;is_redirect：&lt;/code&gt;如果此响应是可以自动处理的格式良好的HTTP重定向，则为真。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;iter_content&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;（&lt;em&gt;chunk_size = 1&lt;/em&gt;&lt;span&gt;，&lt;/span&gt;&lt;em&gt;decode_unicode = False &lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;）：&lt;/span&gt;&lt;/span&gt;迭代响应数据。在请求中设置stream = True时，可以避免将内容一次性读入内存以获得较大的响应。块大小是它应该读入内存的字节数；chunk_size必须是int或None类型。stream = True将在数据以任何大小接收到的数据到达时读取数据。如果stream = False，则数据作为单个块返回；如果decode_unicode为True，则内容将使用基于响应的最佳可用编码进行解码。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;iter_lines(&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;&lt;em&gt;chunk_size = 512&lt;/em&gt;&lt;span&gt;，&lt;/span&gt;&lt;em&gt;decode_unicode = None&lt;/em&gt;&lt;span&gt;，&lt;/span&gt;&lt;em&gt;delimiter = None )：&lt;/em&gt;&lt;/span&gt;迭代响应数据，一次一行。在请求中设置stream = True时，可以避免将内容一次性读入内存以获得较大的响应。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;json&lt;/code&gt;&lt;span class=&quot;sig-paren&quot;&gt;（&lt;em&gt;** kwargs &lt;/em&gt;&lt;span class=&quot;sig-paren&quot;&gt;）：&lt;/span&gt;&lt;/span&gt;返回响应的json编码内容&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;links：&lt;/code&gt;返回解析的响应头部链接&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;next：&lt;/code&gt;返回重定向链中下一个请求的PreparedRequest&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;ok：&lt;/code&gt;如果&lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;status_code&lt;/span&gt;&lt;/code&gt;小于400 则返回True，否则返回False&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;reason&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None：&lt;/em&gt;响应HTTP状态的文本原因，例如“未找到”或“确定”。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;request&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None：&lt;/em&gt;一个响应的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;status_code&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None：&lt;/em&gt;整数响应HTTP状态的代码，例如404或200。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;text：&lt;/code&gt;响应的内容，以unicode表示。 &lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;code class=&quot;descname&quot;&gt;url&lt;/code&gt;&lt;em class=&quot;property&quot;&gt;=None：&lt;/em&gt;响应的最终URL位置&lt;/li&gt;
&lt;/ul&gt;&lt;dl class=&quot;attribute&quot;&gt;&lt;dt id=&quot;requests.Response.url&quot;/&gt;
&lt;dt&gt;发送请求后，会得到响应信息，我们可以使用text和content获取相应的内容，此外还有很多属性和方法来获取其他信息，如状态码，响应头，Cookies等&lt;/dt&gt;
&lt;/dl&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/20 15:51&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_respon.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
headers&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.79 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://docs.python-requests.org/en/master/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chardet提供的编码:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.apparent_encoding)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;响应字节内容:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.content)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;响应cookies:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.cookies.items())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请求到响应之间的时间:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.elapsed)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;响应编码:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.encoding)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;响应头信息:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.headers)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;头信息中的server:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,r.headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请求历史记录:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.history)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;迭代响应数据:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.iter_lines())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;print('响应json编码数据:',r.json())&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;返回解析的响应头链接:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.links)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;返回状态码:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.status_code)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;响应str内容:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.text)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;响应URL:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.url)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;返回发送的头参数:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,r.request.headers)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;chardet提供的编码: Windows-1254&lt;span&gt;
响应字节内容: b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&amp;lt;!DOCTYPE html PUBLIC...&lt;/span&gt;
&lt;span&gt;响应cookies: []
请求到响应之间的时间: 0:&lt;/span&gt;00:00.844991&lt;span&gt;
响应编码: ISO&lt;/span&gt;-8859-1&lt;span&gt;
响应头信息: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nginx/1.10.3 (Ubuntu)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Wed, 20 Jun 2018 08:10:26 GMT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Last-Modified&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Thu, 14 Jun 2018 13:27:43 GMT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Transfer-Encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chunked&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept-Encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ETag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;W/&quot;5b226d4f-8438&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X-Cname-TryFiles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X-Served&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Nginx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;X-Deity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;web05&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gzip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
头信息中的server: nginx&lt;/span&gt;/1.10.3&lt;span&gt; (Ubuntu)
请求历史记录: []
迭代响应数据: &lt;/span&gt;&amp;lt;generator object Response.iter_lines at 0x0000005A4A6F3888&amp;gt;&lt;span&gt;
返回解析的响应头链接: {}
返回状态码: &lt;/span&gt;200&lt;span&gt;
响应str内容: &lt;/span&gt;&amp;lt;&lt;span&gt;!DOCTYPE html PUBLIC.....
响应URL: http:&lt;/span&gt;//docs.python-requests.org/en/master/&lt;span&gt;
返回发送的头参数: {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.79 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept-Encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gzip, deflate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*/*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、requests异常处理&lt;/h3&gt;
&lt;p&gt;exception requests.RequestException(*args, **kwargs)：发送一个模糊的异常&lt;br/&gt;exception requests.ConnectionError(*args, **kwargs)：发生连接错误时的异常&lt;br/&gt;exception requests.HTTPError(*args, **kwargs)：发生HTTP错误时的异常&lt;br/&gt;exception requests.URLRequired(*args, **kwargs)：URL错误时的异常&lt;br/&gt;exception requests.TooManyRedirects(*args, **kwargs)：太多的重定向&lt;br/&gt;exception requests.ConnectTimeout(*args, **kwargs)：连接服务器是请求超时&lt;br/&gt;exception requests.ReadTimeout(*args, **kwargs)：服务器没有在指定的时间内发送数据&lt;br/&gt;exception requests.Timeout(*args, **kwargs)：请求超时&lt;/p&gt;
&lt;h3&gt;6、cookies&lt;/h3&gt;
&lt;p&gt;cookies包括下面四个类：&lt;/p&gt;
&lt;p&gt;requests.utils.dict_from_cookiejar(cj)：从CookieJar中返回一个键/值字典,cj为CookieJar对象，返回字典&lt;br/&gt;requests.utils.add_dict_to_cookiejar(cj, cookie_dict)：从键/值字典中返回CookieJar，cj指定CookieJar类型，cookie_dict，字典类型的JAR值，返回CookieJar&lt;br/&gt;requests.cookies.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True)：从键/值字典中返回CookieJar&lt;br/&gt;class requests.cookies.RequestsCookieJar(policy=None)：创建CookieJar，应用请求和未指定的请求和会话&lt;/p&gt;
&lt;p&gt;cookieJar对象方法与属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add_cookie_header(request)：添加正确的Cookie到请求头&lt;/li&gt;
&lt;li&gt;clear(domain=None,path=None,name=None)：清除cookies&lt;/li&gt;
&lt;li&gt;clear_expired_cookies()：丢弃所有过期的cookies。&lt;/li&gt;
&lt;li&gt;clear_session_cookies()：丢弃所有会话cookie。&lt;/li&gt;
&lt;li&gt;copy()：返回这个RequestsCookieJar的副本。&lt;/li&gt;
&lt;li&gt;extract_cookies(response,request)：根据请求提取允许的响应中的cookie。&lt;/li&gt;
&lt;li&gt;get(name,default = None,domain = None,path = None)：类似于字典的get()，它还支持可选的域和路径参数，以解决在多个域中使用一个cookie jar造成的命名冲突。&lt;/li&gt;
&lt;li&gt;get_dict(domain=None,path=None)：以可选域和路径作为参数，并返回符合要求的名称 - 值对Cookie的普通旧Python字典。&lt;/li&gt;
&lt;li&gt;items()：类似Dict的项目()从jar中返回名称值元组的列表。&lt;/li&gt;
&lt;li&gt;iteritems()：类似于dict的iteritems()从jar中返回名称值元组的迭代器。&lt;/li&gt;
&lt;li&gt;iterkeys()：返回jar中cookie的名字的迭代器。&lt;/li&gt;
&lt;li&gt;itervalues()：返回jar中cookie值的迭代器。&lt;/li&gt;
&lt;li&gt;keys()：返回jar中的cookies的名字列表。&lt;/li&gt;
&lt;li&gt;list_domains()：实用程序方法列出jar中的所有域。&lt;/li&gt;
&lt;li&gt;list_paths()：实用程序方法列出jar中的所有路径。&lt;/li&gt;
&lt;li&gt;make_cookies(response,request)：从响应对象中提取的Cookie对象的返回序列。&lt;/li&gt;
&lt;li&gt;multiple_domains()：如果jar中有多个域，则返回True。否则返回False。&lt;/li&gt;
&lt;li&gt;pop(k[,d]) ：移除指定的键并返回相应的值。&lt;/li&gt;
&lt;li&gt;popitem() ：移除并返回（键，值）对&lt;/li&gt;
&lt;li&gt;set(name,value)：还支持可选的域和路径参数，以解决在多个域中使用一个cookie jar造成的命名冲突。&lt;/li&gt;
&lt;li&gt;set_cookie(cookie，* args，** kwargs)：设置一个cookie，不检查是否应该设置。&lt;/li&gt;
&lt;li&gt;set_cookie_if_ok(cookie,request)：判断设置cookies是否可行，返回OK&lt;/li&gt;
&lt;li&gt;update(other)：用另一个CookieJar或类似字典的cookie更新这个jar&lt;/li&gt;
&lt;li&gt;values()：返回jar中cookie的值列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 获取网站cookies：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.cookies)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.cookies.items())


&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;&amp;lt;RequestsCookieJar[&amp;lt;Cookie BDORZ=27315 &lt;span&gt;for&lt;/span&gt; .baidu.com/&amp;gt;]&amp;gt;   &lt;span&gt;#RequestsCookieJar对象&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; [(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;BDORZ&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;27315&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用cookies维持登陆状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
headers&lt;/span&gt;=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www51cto=F7A5DB397E1897B2B12EEC15A74FB351kYaA; Cto_lvt_=1503809599; ......#&lt;/span&gt;&lt;span&gt;登陆网站后将cookie信息拷贝到此处&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://blog.51cto.com/zhangxinqi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.text)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.cookies.items())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示结果是登陆后的信息，表明登陆成功&lt;/span&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-UA-Compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IE=edge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;link type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;favicon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shortcut icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/favicon.ico&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
        &amp;lt;title&amp;gt;80后小菜鸟-51CTO博客&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keywords&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;80后小菜鸟,linux技术,windows技术,网络技术,zabbix监控,数据库,虚拟化,自动化运维,系统安全,集群架构,python,企业应用,51CTO博客&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

[(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;574c0a6fbf29ac6f44f66068e5f02b0b438aed6840bf......&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建RequestsCookieJar对象，使用cookies保持登陆：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.cookies &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RequestsCookieJar

cookie&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www51cto=F7A5DB397E1897B2B12EEC15A74FB351kYaA; ......&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
headers &lt;/span&gt;= {    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

jar&lt;/span&gt;=RequestsCookieJar()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建Jar对象&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; cookie.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    key,value &lt;/span&gt;= i.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1&lt;span&gt;)
    jar.set(key,value)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置cookies的键值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(jar.items())&lt;/span&gt;
r=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://blog.51cto.com/zhangxinqi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,cookies=jar,headers=headers) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;传入cookies&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(r.text)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(r.headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Set-Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])  
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.request.headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取客户端设置的cookie&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、请求会话(Session)&lt;/h3&gt;
&lt;p&gt;在requests中，如果直接利用get()和post()方法的确可以做到模拟网页的请求，但这实际上是相当于不同的会话，也就是说相当于使用了两个浏览器打开ileal不同的页面&lt;/p&gt;
&lt;p&gt;如果利用psot()请求登陆了网站，然后使用get()方法请求个人信息，将得到两个完全不同的会话，就不能获取到个人信息，实际上可以使用设置cookies一样请求会话得到个人信息，&lt;/p&gt;
&lt;p&gt;单方法显得很繁琐，可用使用更简单的方法，Session维持会话，利用它不需要设置cookies，它能帮助我们自动处理，下面先看下Session对象的API&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class requests.Session&lt;/strong&gt;:请求会话，提供cookie持久性，连接池和配置&lt;/p&gt;
&lt;p&gt;方法与属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;auth=None 身份验证元祖&lt;/li&gt;
&lt;li&gt;cert=None SSL客户端证书路径，如果为元祖('cert','key')&lt;/li&gt;
&lt;li&gt;close() 关闭会话&lt;/li&gt;
&lt;li&gt;cookies=None 会话中设置的未处理的cookie的cookieJar，默认是一个RequestsCookieJar&lt;/li&gt;
&lt;li&gt;delete(url,**kwargs) 发送DELETE请求,返回一个response对象&lt;/li&gt;
&lt;li&gt;get(url) 发送GET请求，返回response对象&lt;/li&gt;
&lt;li&gt;get_adapter(url) 为给定的URL返回适当的连接适配器&lt;/li&gt;
&lt;li&gt;get_redirect_target(resp) 返回重定向URL或None&lt;/li&gt;
&lt;li&gt;head(url) 发送head请求，返回response对象&lt;/li&gt;
&lt;li&gt;headers=None 一个不区分大小写的字典，由字典发送Session&lt;/li&gt;
&lt;li&gt;hooks=None 事件处理&lt;/li&gt;
&lt;li&gt;max_redirects=None 允许最大重定向次数默认为30&lt;/li&gt;
&lt;li&gt;merge_environment_settings(url,proxies,stream,verify,cert) 检查环境并将参数设置合并，返回字典&lt;/li&gt;
&lt;li&gt;params=None 设置传递的参数&lt;/li&gt;
&lt;li&gt;post(url,data=None,json=None) 发送POST请求返回response对象&lt;/li&gt;
&lt;li&gt;prepare_request(request) 构造一个PreparedRequest并返回它，将生成一个请求的数据结构，通过Session发送&lt;/li&gt;
&lt;li&gt;proxies=None 代理URL&lt;/li&gt;
&lt;li&gt;request(method,url,params=None,data=None,headers=None,cookies=None,files=None,auth=None,timeout=None,allow_redirects=True,proxies=None,hooks=None,stream=None,verify=None,cert=None,json=None) 构建一个request,返回response对象&lt;/li&gt;
&lt;li&gt;send(request) 发送给定的PreparedRequest，返回Response对象&lt;/li&gt;
&lt;li&gt;stream=None 流响应的内容&lt;/li&gt;
&lt;li&gt;trust_env=None 代理设置的身份验证和信任环境设置&lt;/li&gt;
&lt;li&gt;verify=None SSL验证,设置为false则忽略SSL验证&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试能否获取自己设置的cookies：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用测试网站设置cookies的名称为number值为123456&lt;/span&gt;
requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/cookies/set/number/123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/cookies&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(r.text) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;然后通过请求获取cookies，结果cookies显示为空&lt;/span&gt;

&lt;span&gt;#
&lt;/span&gt;{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而并不能获取到设置的cookies，说明它们使用不同的浏览器访问了页面，即得到的cookies会不一样&lt;/p&gt;
&lt;p&gt;现在我们使用Seesion会话保持来设置请求看有什么变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

s&lt;/span&gt;=requests.Session()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建session对象&lt;/span&gt;
s.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/cookies/set/number/123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
r&lt;/span&gt;=s.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/cookies&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过session获取请求的cookies&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.text)  

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;成功返回cookies信息&lt;/span&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用session可以 做到模拟同一个会话而不用担心cookies的问题，它常用于模拟登陆成功后再进行下一步操作，可以模拟在同一个浏览器中打开同一个站点的不同页面&lt;/p&gt;
&lt;p&gt;实例：通过session会话登陆页面获取个人信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/21 9:12&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_session.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTTPBasicAuth


url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://192.168.146.140/admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
s&lt;/span&gt;=&lt;span&gt;requests.Session()
response&lt;/span&gt;=s.get(url,auth=HTTPBasicAuth(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.text)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.headers)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(response.status_code)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;8、SSL证书验证&lt;/h3&gt;
&lt;p&gt;rerquests提供了证书验证的功能，当发送http请求时，它会检查SSL证书，可以通过verify参数来控制是否检查此证书，如果不设置默认为True会自动验证,我们使用https://www.12306.cn测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.12306.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.status_code)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回SSLError&lt;/span&gt;
&lt;span&gt;raise&lt;/span&gt; SSLError(e, request=request)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将verify参数设置为false在看结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.12306.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.status_code)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;能正常返回200，但有个警告信息&lt;/span&gt;
D:\virtualenv-36\.venv\lib\site-packages\urllib3\connectionpool.py:857: InsecureRequestWarning: Unverified HTTPS request &lt;span&gt;is&lt;/span&gt; being made. Adding certificate verification &lt;span&gt;is&lt;/span&gt; strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ssl-warnings&lt;/span&gt;
&lt;span&gt;  InsecureRequestWarning)
&lt;/span&gt;200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用urllib3中的disable_warnings()忽略警告，也可以用logging日子模块将警告写入日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib3
urllib3.disable_warnings()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;忽略警告&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;logging.captureWarnings(True)  #也可以写入日志中&lt;/span&gt;
r=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.12306.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,verify=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(r.status_code)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了以上的方法，我们如果有证书的话，可以cert参数指定证书路径，如果是单个文件包含密钥和证书，也可以设置两个文件路径的元祖分别指向证书和密钥&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
 
response &lt;/span&gt;= requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.12306.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, cert=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/path/server.crt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/path/key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response.status_code)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意，如果是本地私有证书的key必须是解密状态，加密状态的key是不支持的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;9、代理设置&lt;/h3&gt;
&lt;p data-line-num=&quot;1813 1814&quot;&gt;对于某些网站，在测试的时候请求几次，能正常获取内容。但是一旦开始大规模爬取，对于大规模且频繁的请求，网站可能会弹出验证码，或者跳转到登录认证页面，更甚者可能会直接封禁客户端的IP，导致一定时间段内无法访问。&lt;/p&gt;
&lt;p data-line-num=&quot;1815 1816&quot;&gt;那么，为了防止这种情况发生，我们需要设置代理来解决这个问题，这就需要用到&lt;code&gt;proxies&lt;/code&gt;参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
 
proxies &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.10.1.10:3128&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.10.1.10:1080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
}
 
requests.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.taobao.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, proxies=proxies)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若代理需要使用HTTP Basic Auth，可以使用类似http://user:password@host:port这样的语法来设置代理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
 
proxies &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://user:password@10.10.1.10:3128/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
}
requests.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.taobao.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, proxies=proxies)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了基本的HTTP代理外，requests还支持SOCKS协议的代理&lt;/p&gt;
&lt;p&gt;这是一个可选功能，需要在使用前安装额外的第三方库&lt;/p&gt;
&lt;p&gt;您可以从以下位置获取此功能的依赖关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ pip install requests[socks]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦你安装了这些依赖项，使用SOCKS代理就像使用HTTP代理一样简单:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
 
proxies &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;socks5://user:password@host:port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;socks5://user:password@host:port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
requests.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.taobao.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, proxies=proxies)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用该方案&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;socks5&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;会导致DNS解析发生在客户端上，而不是在代理服务器上,&lt;span&gt;&lt;span&gt;它使用该方案来决定是否在客户端或代理上执行DNS解析。&lt;/span&gt;&lt;span&gt;如果要解析代理服务器上的域，请使用&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;socks5h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;该方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;10、身份认证&lt;/h3&gt;
&lt;p&gt;如果访问的网站需要身份认证的话，可以使用requests自带的身份认证功能，其中包括四个类：&lt;/p&gt;
&lt;p&gt;class requests.auth.AuthBase：所有auth实现派生自的基类&lt;/p&gt;
&lt;p&gt;class requests.auth.HTTPBasicAuth(username, password)：将HTTP基本认证附加到给定的请求对象&lt;/p&gt;
&lt;p&gt;class requests.auth.HTTPProxyAuth(username, password)：将HTTP代理身份验证附加到给定的请求对象&lt;/p&gt;
&lt;p&gt;class requests.auth.HTTPDigestAuth(username, password)：将HTTP摘要式身份验证附加到给定的请求对象&lt;/p&gt;
&lt;p&gt; 基本认证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTTPBasicAuth


url&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://192.168.146.140/admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
s&lt;/span&gt;=&lt;span&gt;requests.Session()
auth&lt;/span&gt;=HTTPBasicAuth(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建密码认证对象&lt;/span&gt;
response=s.get(url,auth=auth)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;附加认证信息&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(response.text)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代理身份验证：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/21 10:36&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_proxauth.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HTTPProxyAuth

proauth&lt;/span&gt;=HTTPProxyAuth(username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
proxies&lt;/span&gt;=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10.0.0.10:3324&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}
s&lt;/span&gt;=requests.Session()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建session对象&lt;/span&gt;
s.trust_env=proauth   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加代理身份验证&lt;/span&gt;
s.proxies=proxies   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;添加代理URL&lt;/span&gt;
response=s.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.facebook.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(response.text)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;11、编码&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当您收到响应时，请求会在您访问&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Response.text&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;属性&lt;/span&gt;&lt;span&gt;时猜测用于解码响应的编码&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;请求将首先检查HTTP标头中的编码，如果不存在，将使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;chardet通用字符编码检测器，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;来尝试猜测编码，&lt;/span&gt;&lt;/span&gt;如果没有明确的字符集是存在于HTTP头&lt;strong&gt;，&lt;/strong&gt;并在&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Content-Type&lt;/span&gt;&lt;/code&gt; 头中包含&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;text&lt;/span&gt;&lt;/code&gt;。在这种情况下，RFC 2616指定默认字符集必须是&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;ISO-8859-1&lt;/span&gt;&lt;/code&gt;。在这种情况下，请求遵循规范。如果你需要不同的编码，你可以手动设置&lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Response.encoding&lt;/span&gt;&lt;/code&gt; 属性，或者使用原始的&lt;code class=&quot;xref py py-attr docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;Response.content&lt;/span&gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;requests.utils.get_encodings_from_content(content)：从给定的内容字符串返回编码&lt;/p&gt;
&lt;p&gt;requests.utils.get_encoding_from_headers(headers)：从给定的HTTP标题字典返回编码,headers头文件字典，返回str&lt;/p&gt;
&lt;p&gt;requests.utils.get_unicode_from_response(r)：以unicode形式返回请求的内容，r是响应对象，返回str&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/21 11:46&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_enconding.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_encodings_from_content
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_encoding_from_headers
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; requests.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_unicode_from_response
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://cnblogs.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(get_encodings_from_content(r.text)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从内容中返回编码&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(get_encoding_from_headers(r.headers)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从头文件中返回编码&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(get_unicode_from_response(r))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;unicode返回请求内容&lt;/span&gt;


&lt;span&gt;#
&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
utf&lt;/span&gt;-8
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-cn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;referrer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;always&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;title&amp;gt;博客园 - 开发者的网上家园&amp;lt;/title&amp;gt;.............
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;12、其他说明&lt;/h3&gt;
&lt;p&gt;(1)状态码&lt;/p&gt;
&lt;p&gt;requests.codes 该codes对象定义了从http状态中通过名称映射的数字代码的状态码，可以作为属性或字典访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(requests.codes[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;forbidden&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;403&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(requests.codes[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(requests.codes[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;not_modified&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(requests.codes[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;not_found&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;404&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(requests.codes[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;internal_server_error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.python-requests.org/en/master/api/#status-code-lookup&quot; target=&quot;_blank&quot;&gt;其他状态码查询...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(2)超时设置&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果服务器没有及时响应，大多数对外部服务器的请求应该附加一个超时值。&lt;/span&gt;&lt;span&gt;默认情况下，除非显式设置超时值，否则请求不会超时。&lt;/span&gt;&lt;span&gt;如果没有超时，您的代码可能会挂起几分钟或更长时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;一旦你的客户端连接到服务器并发送了HTTP请求， &lt;/span&gt;&lt;/span&gt;读取&lt;span&gt;&lt;span&gt;超时就是客户端等待服务器发送响应的秒数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为超时指定单个值，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
r = requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, timeout=5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;超时值将应用于&lt;/span&gt;&lt;span&gt; 超时&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;connect&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;和&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;read&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt;超时。&lt;/span&gt;&lt;span&gt;如果您想单独设置值，请指定一个元组：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
r = requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, timeout=(3.05, 27))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果远程服务器速度非常慢，您可以通过将None作为超时值，让“请求”永久等待响应：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
r = requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://github.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, timeout=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)流媒体请求&lt;/p&gt;
&lt;p&gt;可以使用iter_content方法迭代获取数据，或者使用iter_line()，但在构建请求是需要指定stream=True来返回流内容数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Time    : 2018/6/21 12:38&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Author  : Py.qi&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @File    : req_block.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; @Software: PyCharm&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
r&lt;/span&gt;=requests.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://httpbin.org/stream/20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,stream=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; r.iter_content(chunk_size=1024,decode_unicode=&lt;span&gt;True):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; i:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.loads(i.decode()))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多关于requests使用请查看&lt;a title=&quot;http://docs.python-requests.org/en/master/&quot; href=&quot;http://docs.python-requests.org/en/master/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; -----------------------------------------end&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 05:20:00 +0000</pubDate>
<dc:creator>Py.qi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxinqi/p/9201594.html</dc:identifier>
</item>
<item>
<title>为什么写博客？如何在博客中更好的分享？ - 勋爵</title>
<link>http://www.cnblogs.com/X-knight/p/9163320.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-knight/p/9163320.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　为什么要写技术博客呢？主要是受一本书的启发，这本书叫《软技能--代码之外的生存指南》，乐于分享就是其中的一项软技能。&lt;/strong&gt;写技术博客是对自己已有知识和经验的总结和归纳，便于日后温故而知新，也把自己的知识和经验分享出来给有需要的人。同时博客也可以让他人看到你在这个领域的能力水平，也可以交一些相同方向的好友，大家一起学习交流、一起成长！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;我觉得，作为一个博客作者，写出来的东西能被更多的人看到、拥有更多交流技术的粉丝才是博客的核心价值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;    故，在这里我想分享一下如何更好的写博客，顺便提高博客访问量，同时也以此鼓励自己按照这样的标准，不断前行！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我从网上找了一篇cnblogs积分规则，当然这个规则是很久以前的，现在规则肯定不是这样的，博客团队肯定也不会告知你他们现行的排名规则。但是，通过浏览大量排名靠前的博文，我觉得之前的积分规则，还是有一定参考价值的！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　博客排行榜排名分值 = 个人blog所有随笔与文章的阅读数之和 + 个人blog所有评论数之和*10  + 个人所发表的评论数之和*50 &lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;&lt;/em&gt;随笔的阅读次数是如何统计的？ &lt;/p&gt;
&lt;p&gt;　　阅读次数统计的是阅读人数, 同一个人的多次点击只计数一次, 这样能准确反映文章的阅读情况, 防止了故意的多次点击。&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;       &lt;/em&gt;&lt;/em&gt;&lt;/em&gt; 所以，分值主要由三部分构成：&lt;/p&gt;
&lt;p&gt;　　　　1.“个人blog所有随笔与文章的阅读数之和”；（其实主要就是点击率啦！）&lt;/p&gt;
&lt;p&gt;　　　　2.“个人blog所有评论数之和*10”；&lt;/p&gt;
&lt;p&gt;　　　　3.“个人所发表的评论数之和*50 ”.&lt;/p&gt;
&lt;p&gt;　　所以，文章的评论数直接影响的博客的积分。&lt;/p&gt;
&lt;p&gt;　　当然，打铁还需自身硬！提升自己的博文质量才是王道！&lt;/p&gt;
&lt;p&gt;　　这里先给各位看官提一些建议，帮助大家提高自己文章的阅读量：　&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1. 文章对大家有用（the most important !）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　发布前想一想，文章是否对大家有用？&lt;/p&gt;
&lt;p&gt;　　如果不确定有用，那还是不要发布在首页上了，发布在自己的首页上就好了。&lt;/p&gt;
&lt;p&gt;　　发布在首页，一定要有技术参考价值！如果博客写得好，自然会有人关注的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2. 注意文章排版&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　文章格式很重要！如果真的想让博客成为你的名片。多在排版上下点功夫还是值得的。&lt;/p&gt;
&lt;p&gt;　　文章写完后，自己预览一下！或是自己从网上找个好看的排版，然后自定义博客园风格！&lt;/p&gt;
&lt;p&gt;　　有的文章，无论是&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-knight/p/9159804.html&quot; target=&quot;_blank&quot;&gt;博客园设计&lt;/a&gt;&lt;/strong&gt;还是文章排版，都让人赏心悦目，自然会吸引来很多粉丝！（我的博客园，就是最近才美化了一下，文章阅读量逐渐增多，效果很明显！）&lt;/p&gt;
&lt;p&gt;　　其实，排版的事情很简单，往往仅仅加几个空行，设几个粗体字就够了。最好不要搞太多花哨的东西。代码还是有语法高亮好一些。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3. 起好文章标题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　文章好，标题一定要好，否则即使发布到博客园首页，也很难被大家注意到。很多时候，标题党一把也无妨。文章标题吸引眼球，自然会叫座！&lt;/p&gt;
&lt;p&gt;　　这里尤其要注意标题的前几个字。如果能将你的文章的精华浓缩在前几个字上，那就是最好的了。这样，更利于关注该主题的人发现你的文章。比如：我最近对于“区块链”，“分布式系统”很关注。如果你将这些关键字没有出现在标题，那很难被人注意到！　&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4. 斟酌你的摘要&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　如果你没有注意书写自己文章的摘要，博客园一般将前几段强制输出为摘要！（自己就经常忽略这个问题！）&lt;/p&gt;
&lt;p&gt;　　大家看完标题后，会对摘要稍微浏览一下，大致了解下文章在写啥！虽然，为文章写一个好的摘要是一件很费劲的工作。但是，对你的访问量会有很大好处的。&lt;/p&gt;
&lt;h3&gt;5.为系列文章建立目录&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　最好能够为你的系列文章专门建立一个目录页，并且每个文章的前面都有到目录的链接。这样，如果我忽略了你的第一片文章，还可以很容易的在你的系列文章中跳转。&lt;/p&gt;
&lt;p&gt;　　时刻要记着，搜索引擎也是你的文章读者的一个重要来源。建立目录会帮助搜索引擎带来的读者，更直观的了解你的博文结构、找到重点！&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;6. 写系列文章，并且为整个系列起一个好名字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　整个系列的文章无论对于SEO还是首页来的访客都会提供很大方便。如果可能，写整个系列的文章之前，做一些规划。将系列文章放入一个分类，并相互增加目录索引。如果能够为系列起一个好的名字，就更好了。另外，最好将系列标题放在文章标题的前面。这对于增加访问量会很有好处。&lt;/p&gt;
&lt;p&gt;　　很多时候，好的系列文章会让人主动订阅你的博客（RSS）。即使没有订阅，你的系列标题也会成为访客所关注的关键字。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;7. 选择正确的发布时间&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　如果你有一帮抢沙发的粉丝，什么时间发贴不重要。但是，对于大多数如我一般的作者，必要的时候，还是选择一下发布时间为好。最好在工作日的下午。那样可以为你的文章带来更高的曝光率。&lt;/p&gt;
&lt;p&gt;　　其实，本条是有点邪恶，哈哈。首先，文章质量还是最重要的。如果大家都来掐时间发贴，只会是大家都没有好处得。但是，世上还是懒人多。一分耕耘，一分收获嘛。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;8. 偶尔发布一些感性的文章&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　博客和正规出版物的不同就是他更关注个人。偶尔发布一点感性的文章会帮助别人更全面的了解你。从而为你赢得一些订阅。但是，一定不能往首页上发的，那只会导致骂仗。&lt;/p&gt;
&lt;p&gt;　　记住，订阅用户才是最有价值的读者。为他们，付出再多都值得。例如，我曾经就发表过一篇，考研和工作选择的文章，引来许多读者的评论与互动，所以，有时一些感性文章及自己对于工作、学习的所思所想，还是很重要的！&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 04:37:00 +0000</pubDate>
<dc:creator>勋爵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-knight/p/9163320.html</dc:identifier>
</item>
<item>
<title>RabbitMQ入门：发布/订阅（Publish/Subscribe） - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/9208008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/9208008.html</guid>
<description>&lt;p&gt;在前面的两篇博客中&lt;/p&gt;
&lt;p&gt;遇到的实例都是&lt;strong&gt;一个消息只发送给一个消费者（工作者）&lt;/strong&gt;，他们的消息模型分别为（P代表生产者，C代表消费者，红色代表队列）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621102325395-768497266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621102345741-232809488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次我们来看下将&lt;strong&gt;一个消息发送给多个消费者（工作者）&lt;/strong&gt;，这种模式一般被称为“发布/订阅”模式。其工作模型为（P代表生产者，X代表Exchange(路由器/交换机)，C代表消费者，红色代表队列）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621102800484-62205405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，工作模型中首次出现路由器，并且每个消费者有单独的队列。生产者生成消息后将其发送给路由器，然后路由器转送到队列，消费者各自到自己的队列里面获取消息进行消费。在实际的应用场景中，&lt;strong&gt;生产者一般不会直接将消息发送给队列，而是发送给路由器进行中转&lt;/strong&gt;，Exchange必须清楚的知道怎么处理收到的消息：是将消息发送到一个特定队列还是多有队列，或者直接废弃消息。这种才符合&lt;strong&gt;RabbitMQ消息模型的核心思想&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来我们详细展开今天的话题：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Exchange&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Exchange在我们的工作模型中首次出现，因此需要详细介绍下。&lt;/p&gt;
&lt;p&gt;Exchange分为4种类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Direct：完全根据key进行投递的，例如，绑定时设置了routing key为”abc”，那么客户端提交的消息，只有设置了key为”abc”的才会投递到队列。
Topic：对key进行模式匹配后进行投递，符号”#”匹配一个或多个词，符号”&lt;/span&gt;*”匹配正好一个词。例如”abc.#”匹配”abc.def.ghi”，”abc.*&lt;span&gt;”只匹配”abc.def”。
Fanout：不需要key，它采取广播模式，一个消息进来时，投递到与该交换机绑定的所有队列。
Headers:我们可以不考虑它。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;今天我们的实例采用fanout类型的exchange。&lt;/p&gt;
&lt;p&gt;尽管首次出现，但是其实我们前面的案例中也有用到exchange，只是我们没有给他名字，用的是RabbitMQ默认的，比如下面这段代码，我们将路由器名这个参数传入了“”，如果我们需要自己声明exchange的话，这个就不能传入“”了，而是传入自己定义好的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621104513927-1191385928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、临时队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面两篇博客中，我们都在使用队列的时候给出了定义好的名字，这在生产者和消费者共用相同队列的时候很有必要，但是我们有了exchange，生产者不需要知道有哪些队列，因此队列名字可以不用指定了，而是通过RabbitMQ 接口自己去生成临时队列，队列名字也由RabbitMQ自动生成。通过&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621105641974-2002126277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以声明一个非持久的、通道独占的、自动删除的队列，getQueue()方法可以获取随机队列名字。这个名字用来在队列和exchange之间建立binding关系的时候使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621105927566-498001291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于上面exchange和临时队列的知识铺垫，可以展开今天的代码实现了。&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt; 生产者
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;exchange名字&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String EXCHANGE_NAME = &quot;exchange&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建连接和通道&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.为通道声明exchange和exchange的类型&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);
            
            String msg &lt;/span&gt;= &quot; hello rabbitmq, this is publish/subscribe mode&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.发送消息到指定的exchange,队列指定为空,由exchange根据情况判断需要发送到哪些队列&lt;/span&gt;
            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, msg.getBytes());
            System.out.println(&lt;/span&gt;&quot;product send a msg: &quot; +&lt;span&gt; msg);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.关闭连接&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (channel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    channel.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
                    e.printStackTrace();
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    connection.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;消费者1
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer1 {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ConnectionFactory factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
        factory.setHost(&lt;/span&gt;&quot;localhost&quot;&lt;span&gt;);
        Connection connection &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Channel channel &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.创建连接和通道&lt;/span&gt;
            connection =&lt;span&gt; factory.newConnection();
            channel &lt;/span&gt;=&lt;span&gt; connection.createChannel();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2.为通道声明exchange以及exchange类型&lt;/span&gt;
&lt;span&gt;            channel.exchangeDeclare(Product.EXCHANGE_NAME, BuiltinExchangeType.FANOUT);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.创建随机名字的队列&lt;/span&gt;
            String queueName =&lt;span&gt; channel.queueDeclare().getQueue();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.建立exchange和队列的绑定关系&lt;/span&gt;
            channel.queueBind(queueName, Product.EXCHANGE_NAME, &quot;&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot; **** Consumer1 keep alive ,waiting for messages, and then deal them&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.通过回调生成消费者并进行监听&lt;/span&gt;
            Consumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handleDelivery(String consumerTag, Envelope envelope,
                        com.rabbitmq.client.AMQP.BasicProperties properties, &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取消息内容然后处理&lt;/span&gt;
                    String msg = &lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;);
                    System.out.println(&lt;/span&gt;&quot;*********** Consumer1&quot; + &quot; get message :[&quot; + msg + &quot;]&quot;&lt;span&gt;);
                }
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6.消费消息&lt;/span&gt;
            channel.basicConsume(queueName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, consumer);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;消费者2，核心代码同消费者1一样，只是在日志打印上将&quot;Consumer1&quot;改为&quot;Consumer2&quot;而已。这里不再列出具体代码。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;先运行消费者1和2，然后运行生产者，观察控制台log打印情况：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;生产者：&lt;/strong&gt;
product send a msg:  hello rabbitmq, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; is publish/&lt;span&gt;subscribe mode

&lt;strong&gt;消费者1&lt;/strong&gt;：
 &lt;/span&gt;**** Consumer1 keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; messages, and then deal them
&lt;/span&gt;*********** Consumer1 get message :[ hello rabbitmq, &lt;span&gt;this&lt;/span&gt; is publish/&lt;span&gt;subscribe mode]

&lt;strong&gt;消费者2：
 &lt;/strong&gt;&lt;/span&gt;**** Consumer2 keep alive ,waiting &lt;span&gt;for&lt;/span&gt;&lt;span&gt; messages, and then deal them
&lt;/span&gt;*********** Consumer2 get message :[ hello rabbitmq, &lt;span&gt;this&lt;/span&gt; is publish/subscribe mode]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，当生产者发出消息后，两个消费者最终都收到了消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;我们去查看RabbitMQ管理页面：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621110936374-2138037317.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;在Exchanges 标签页里面多了一个名为“exchange”的路由器，他的类型是fanout。点exchange 的link进入详细页面：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621111212953-1142976835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现在binding项目中有了两条绑定关系，队列的名字也可以看到。将页面切换到Queues标签页：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621111504687-65861729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现了两个新的队列，队列名字和绑定关系中的一样，并且队列都是自动删除的、通道独占的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;然后将消费者1和消费者2都停掉，重新查看管理页面，我们发现exchange还在，binding关系不存在了，临时队列也自动删除了&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621111913946-1209466755.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621111935430-730193399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201806/1345071-20180621111946589-624780148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 21 Jun 2018 03:43:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/9208008.html</dc:identifier>
</item>
</channel>
</rss>