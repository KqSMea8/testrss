<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS学习——内存泄漏检查及原因分析 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/8144742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/8144742.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;项目的代码很多，前两天老大突然跟我说项目中某一个ViewController的dealloc()方法没有被调用，存在内存泄漏问题，需要排查原因，解决内存泄漏问题。由于刚加入项目组不久，对出问题的模块的代码还不太熟悉，所以刚拿到问题时觉得很棘手，再加上作为一个iOS菜鸟，对内存泄漏的排查方法和原因确实基本上不了解。所以，也借着这样的机会，我研究了一下关于iOS开发中内存泄漏的排查方法和原因分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，补充两个基本概念的解释：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;内存溢出 （out of memory）：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。通俗理解就是内存不够，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;内存泄露（ memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;我们知道，iOS开发中对内存管理的要求非常严格，一旦存在内存泄漏，后果是非常严重的，会导致程序非常容易崩溃。尽管目前iOS开发基本上都是采用的ARC方式进行内存管理，但是一不小心就会存在内存泄漏的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们需要定位内存泄漏的问题，目前比较常用的内存泄漏的排查方法有两种，都在xcode中可以直接使用：静态分析方法（Analyze）和动态分析方法（Instrument的leak）。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.1 静态内存泄漏分析方法&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;通过xcode打开项目，然后点击product--&amp;gt;Analyze，如下图左侧的图所示，这样就开始对项目进行静态内存泄漏分析，分析结果如下图右侧的图所示。根据分析结果进行休整之后在进行分析就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229135805601-1777918676.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;136&quot;/&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229135926648-1677233162.jpg&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;静态分析方法能发现大部分的问题，但是只能是静态分析结果，有一些并不准确，还有一些动态分配内存的情形并没有进行分析。所以仅仅使用静态内存泄漏分析得到的结果并不是非常可靠，如果需要，我们需要将对项目进行更为完善的内存泄漏分析和排查。那就需要用到我们下面要介绍的动态内存泄漏分析方法Instruments中的Leaks方法进行排查。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.2 动态内存泄漏分析方法&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;分析内存泄露不能把所有的内存泄露查出来，有的内存泄露是在运行时，用户操作时才产生的。那就需要用到Instruments了。具体操作是通过xcode打开项目，然后点击product--&amp;gt;profile，如下图左侧图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229141920648-1920934131.jpg&quot; alt=&quot;&quot; width=&quot;294&quot; height=&quot;239&quot;/&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229142152210-833734724.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;按上面操作，build成功后跳出Instruments工具，如上图右侧图所示。选择Leaks选项，点击右下角的【choose】按钮，这时候项目程序也在模拟器或手机上运行起来了，在手机或模拟器上对程序进行操作，工具显示效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229142538445-354826089.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;点击左上角的红色圆点，这时项目开始启动了，由于leaks是动态监测，所以手动进行一系列操作，可检查项目中是否存在内存泄漏问题。如图所示，橙色矩形框中所示绿色为正常，如果出现如右侧红色矩形框中显示红色，则表示出现内存泄漏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229142817382-776295339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;选中Leaks Checks,在Details所在栏中选择CallTree,并且在右下角勾选Invert Call Tree 和Hide System Libraries，会发现显示若干行代码，双击即可跳转到出现内存泄漏的地方，修改即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201712/926487-20171229142908757-558299920.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;在目前主要以ARC进行内存管理的开发模式，导致内存泄漏的根本原因是代码中&lt;span&gt;&lt;strong&gt;存在循环引用&lt;/strong&gt;&lt;/span&gt;，从而导致一些内存无法释放，这就会导致dealloc()方法无法被调用。主要原因大概有一下几种类型。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.1 ViewController中存在NSTimer&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你的ViewController中有NSTimer，那么你就要注意了，因为当你调用&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[NSTimer scheduledTimerWithTimeInterval:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt; 
                                 target:self 
                               selector:@selector(updateTime:) 
                               userInfo:nil 
                                repeats:YES];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
&lt;span&gt;时的 &lt;span class=&quot;cnblogs_code&quot;&gt;target：self&lt;/span&gt; &lt;code class=&quot;has-numbering&quot;&gt;就增加了ViewController的return count，如果你不将这个timer invalidate，将别想调用dealloc。&lt;br/&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;2.2 ViewController中的代理delegate&lt;/h2&gt;
&lt;p class=&quot;prettyprint&quot;&gt;&lt;span&gt;　　一个比较隐秘的因素，你去找找与这个类有关的代理，有没有强引用属性？如果你这个VC需要外部传某个Delegate进来，来通过Delegate+protocol的方式传参数给其他对象，那么这个delegate一定不要强引用，尽量assign或者weak，否则你的VC会持续持有这个delegate，直到它自身被释放。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.3 ViewController中Block&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;这个可能就是经常容易犯的一个问题了，Block体内使用实例变量也会造成&lt;strong&gt;循环引用&lt;/strong&gt;，使得拥有这个实例的对象不能释放。因为该block本来就是当前viewcontroller的一部分，现在盖子部门又强引用self，导致循环引用无法释放。 例如你这个类叫OneViewController,有个属性是NSString *name; 如果你在block体中使用了self.name，或者_name，那样子的话这个类就没法释放。 要解决这个问题其实很简单，就是在block之前申明当前的self引用为弱引用即可。&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MRC下代码如下&lt;/span&gt;
__block Viewcontroller *weakSelf =&lt;span&gt; self;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ARC下代码如下&lt;/span&gt;
__weak Viewcontroller *weakSelf = self;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.4 ViewController的子视图对self的持有&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这个问题也是我的项目中内存泄漏的问题所在。我们有时候需要在子视图或者某个cell中点击跳转等操作，需要在子视图或cell中持有当前的ViewController对象，这样跳转之后的back键才能直接返回该页面，同时也不销毁当前ViewController。此时，你就要注意在子视图或者cell中对当前页面的持有对象不能是强引用，尽量assign或者weak，否则会造成循环引用，内存无法释放。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 07:33:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mukekeheart/p/8144742.html</dc:identifier>
</item>
<item>
<title>canvas 从初级到XX 2# 让我们在之前的基础之上，再迈进一步吧 [中级向] （上） - 编号2973</title>
<link>http://www.cnblogs.com/z890524/p/8143030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z890524/p/8143030.html</guid>
<description>&lt;p&gt;还是老样子，先啰嗦一点前言。&lt;/p&gt;
&lt;p&gt;最近各种事务缠身，所以也就隔了比较长的时间才开始码这篇文。希望不会这么快就过气。&lt;/p&gt;
&lt;p&gt;好了，接下来就开始码代码。（写到中途，突然感觉到的。本篇设计大量初中物理知识，请怀念的往下看）&lt;/p&gt;
&lt;p&gt;这次不像之前，是已经写好的文件，拿出来解析一波，就糊弄出来了一篇随笔。总之，我就一边的编代码，一边写文章。时不时的截图一个效果出来&lt;span&gt;，不知道这样，能不能糊弄过去&lt;/span&gt;。。。。&lt;/p&gt;
&lt;p&gt;这次，目标是准备实现很多canvas,素材网站上比较常见的烟花效果。只看过几次效果，也许实现的最终效果有些差异。但是，希望大家最后能以自己的能力改成自己更期待的结果，而不是只能跟着我做出一样的东西，没有任何的衍生。那意义就会缺少很多了。&lt;/p&gt;
&lt;p&gt;既然是canvas，这一段还是不能省的。（注：往后的文章，可能会省略这段代码。主要记住ctx , width , height 这3个变量各自代表是什么就好了。之后我就直接使用了。所以希望大家多多包涵。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_e380418b-1b37-4b74-9a2c-b4ee8b63d5a3&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e380418b-1b37-4b74-9a2c-b4ee8b63d5a3&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e380418b-1b37-4b74-9a2c-b4ee8b63d5a3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; drawing = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;drawing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ctx = drawing.getContext(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width =&lt;span&gt; drawing.width
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; height = drawing.height
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li readability=&quot;5.5&quot;&gt; 对烟花的分析：&lt;br/&gt;大家心里都对，烟花有一定的印象。烟花有一个升空的过程，然后在空中爆炸散开成很多束。然后渐渐消散。&lt;br/&gt;总之，就是有2种状态了。用一个 Boolean 值来判断就好了。&lt;br/&gt;除此之外，还有烟花的位置，x, y轴上的速度，以及烟花的各种颜色。当然，还有其他各种属性，一时之间也想不到那么完美，不如我们走一步看一步，如何呢？&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;p&gt;function Fireworks (x, y, xSpeed, ySpeed, color) {&lt;/p&gt;
&lt;p&gt;    this.x = x&lt;br/&gt;    this.y = y&lt;br/&gt;    this.xSpeed = xSpeed&lt;br/&gt;    this.ySpeed = ySpeed&lt;br/&gt;    this.color = color&lt;br/&gt;    this.boom = false&lt;br/&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其实，写到这里挺犹豫的。因为，不知道各位看官的知识面有多广，是否应该用  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt; ，最终，考量了一下，使用es6的，肯定知道构造函数，但是，反过来就不一定了。所以，也就简单做一个优雅降级吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;上天吧！&lt;br/&gt;嘛。。。此情此景上天的当然是烟花咯。&lt;br/&gt;继承的写法多种多样，希望大家不要过多的考究。万分感谢。&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    Fireworks.prototype.draw =&lt;span&gt; function(){
      ctx.clearRect(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, width, height)
      ctx.beginPath()
      ctx.arc(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x, &lt;span&gt;this&lt;/span&gt;.y, &lt;span&gt;10&lt;/span&gt; , &lt;span&gt;0&lt;/span&gt; , &lt;span&gt;2&lt;/span&gt; *&lt;span&gt;Math.PI)
      ctx.fill()
    }

    Fireworks.prototype.toSky &lt;/span&gt;=&lt;span&gt; function(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x += &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.xSpeed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y += &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ySpeed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.draw()
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了更加的真实，我们还需要模拟重力加速度。 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;var&lt;/span&gt; g = 9.8&lt;/span&gt; 当然，这里只是假设。并不是我们必须设定的和实际的重力加速度一样。只是方便理解，而我百分百的确定，我之后一定会改变这个值的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Fireworks.prototype.toSky = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x += &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.xSpeed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y += &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ySpeed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ySpeed -=&lt;span&gt; g
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.draw()
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时。比较细心的朋友，以及正跟着一步步敲代码的朋友，应该都会发现。这段代码里面有一些问题。我当然是故意的啦。&lt;span&gt;不然，我就直接去上面改成没问题的代码，然后减掉这一段了！&lt;br/&gt;&lt;/span&gt;问题的bug，就是我们速度的正负值，以及canvas的y轴方向和我们正常习惯的y轴方向。有一些比较厉害的朋友，自己写方法将canvas的轴，修改成，我们通常使用的。&lt;br/&gt;但是，本篇还是使用的原生的，y轴正方向向下的情况。于是。。我们的烟花要升天。就要使用一个负值的速度。重力加速度，也需要相应的改动。我就不在这里做改动，混字数了，大家可以小修正一下y轴相关值正负，然后创建一个 &lt;span class=&quot;cnblogs_code&quot;&gt;Fireworks&lt;/span&gt; 实例加一个定时器来调用  &lt;span class=&quot;cnblogs_code&quot;&gt;toSky&lt;/span&gt;。就可以看到一小效果了，但是，这样就够了吗？&lt;span&gt;其实，我接下来有更多需要丰满的地方。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;53&quot;&gt;现在该做什么呢?&lt;br/&gt;开头说的那么故弄玄虚，到现在不是就值做出了一个走抛物线的小球吗？而且还是写死的半径为10的黑球。就连之前说好的 &lt;span class=&quot;cnblogs_code&quot;&gt;color&lt;/span&gt; 都没有加上去。教练，这和说好的不一样啊！！&lt;br/&gt;所以，本来这一段效果优化的代码，准备放在总体逻辑完成之后再写下来的。但是现在的体验极差。就先丰满这一部分的视觉效果吧。&lt;br/&gt;首先，做一个简单操作 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;var&lt;/span&gt; r = Math.random.bind(Math)&lt;/span&gt;  很多人看到random。 就感觉有大事要发生。没错，就是这样。让我们对最初的构造函数，先做出小改动吧。&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Fireworks () {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x = width * (r() * .8 + .1&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; height
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.xSpeed = x &amp;gt; width / 2 ? -(20 * r() - 10)  : (20 * r() - 10&lt;span&gt;) 
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ySpeed = 20 * r() + 10
      &lt;span&gt;this&lt;/span&gt;.color = 'rgb('+ f(r() * 256) +',' + f(r() * 256) + ','+ f(r() * 256) +' )'
      &lt;span&gt;this&lt;/span&gt;.radius = 5
      &lt;span&gt;this&lt;/span&gt;.dotNum = 20
      &lt;span&gt;this&lt;/span&gt;.dots =&lt;span&gt; []
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大致的改动，大家都是可以自己看出来的。将起始点，定在canvas的最底部，起始点最少距离左右边缘都会有十分之一的宽度，根据起始点的位置，来决定，x轴的方向。将速度，颜色。都改成了随机数。将圆的半径也定义了进来。&lt;br/&gt;这些数字类型的值，大多都是可以自己按需修改，或者定义常量来使用。就不要过于纠结了。当然，这些数值都还不完善。只能最后我们添加了定时器，实际运行的时候，才能确定比较合理的数值。&lt;/p&gt;&lt;p&gt;既然说到了定时器，不如就多说几句吧。一般我们动画上使用的定时器，每帧的间隔都会使用15ms。至于为什么就不说了。随便查一下就能找到，而且说太多了也偏离了本篇的主题了。想多说的就是做动画效果的时候的另外一个API， &lt;span class=&quot;cnblogs_code&quot;&gt;requestAnimationFrame&lt;/span&gt; 这里也不会介绍太多关于这个API，因为会偏题呀。只是之后会使用，所以，还不太了解的同学，可以先去了解一下这个API。&lt;br/&gt;到此，似乎，我们实际的效果并没有什么改变。&lt;br/&gt;那么接下来，就让我来使用新增的2个属性吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Fireworks.prototype.createDotArr = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dots.length
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (length &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dotNum) 
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.dots.push(
          {
            x: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x, 
            y: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y
          })
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length - 1; i++&lt;span&gt;) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dots[i] = &lt;span&gt;this&lt;/span&gt;.dots[i + 1&lt;span&gt;]
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dots[length - 1] =&lt;span&gt; {
          x: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.x, 
          y: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y
        }
      }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个方法，将我们之前的那个抛物线的圆，经过的点记录下来。因为只是一段较短的抛物线，所以我们暂时只记录20个点。也就是 &lt;span class=&quot;cnblogs_code&quot;&gt;dotNum&lt;/span&gt; 这个属性控制的点数。&lt;br/&gt;接下来就是将每个点都进行绘制，所以改写了我们之前的方法。于是就成了这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    Fireworks.prototype.draw = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
      ctx.clearRect(&lt;/span&gt;0, 0&lt;span&gt;, width, height)
      self.dots.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v){
        ctx.beginPath()
        ctx.arc(v.x, v.y, self.radius , &lt;/span&gt;0 , 2 *&lt;span&gt; Math.PI)
        ctx.fill()
      })
    }

   Fireworks.prototype.toSky &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x += &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.xSpeed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y -= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ySpeed
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ySpeed -=&lt;span&gt; g
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.createDotArr()
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.draw()
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，让我们来进行一下测试。看看现在效果如何了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:false;&quot;&gt;
var test = new Fireworks()
    function animate () {
      requestAnimationFrame(function () {
        test.toSky()
        animate()
      })
    }
    animate()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并不是最终的调用形式。 只是做一个测试的效果。所以，之后这段是不包含在逻辑代码里的。另外，大家可以在做这个测试的时候，去改变构造函数内的常量参数，将它变成你喜欢的样子。我就不多废话了。&lt;br/&gt;其实，现在看起来好像也还不是很美观，颜色也并没有加上去。那就让我来加上颜色吧。当然并不是你们所想的 &lt;span class=&quot;cnblogs_code&quot;&gt;fillStyle = this.color&lt;/span&gt; 。因为这样看起来也并不好看啊。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
Fireworks.prototype.draw = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
      ctx.clearRect(&lt;/span&gt;0, 0&lt;span&gt;, width, height)
      self.dots.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v, i){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gradients = ctx.createRadialGradient(v.x, v.y, 1, v.x, v.y, i / self.dots.length * self.radius + 1&lt;span&gt;)
        gradients.addColorStop(&lt;/span&gt;0, &quot;rgba(&quot; + self.R + &quot;,&quot; + self.G + &quot;,&quot; + self.B + &quot;,&quot; + i / self.dotNum + &quot;)&quot;&lt;span&gt;)
        gradients.addColorStop(&lt;/span&gt;1, &quot;rgba(&quot; + self.R + &quot;,&quot; + self.G + &quot;,&quot; + self.B + &quot;, 0 )&quot;&lt;span&gt;)
        ctx.fillStyle &lt;/span&gt;=&lt;span&gt; gradients
        ctx.beginPath()
        ctx.arc(v.x, v.y, self.radius , &lt;/span&gt;0 , 2 *&lt;span&gt; Math.PI)
        ctx.fill()
      })
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;忘记补充的一点，R,G,B属性。是我在构造函数中，将color属性，拆分成了，这3个属性。大家可以自己实现，我就不贴代码了。&lt;br/&gt;这里采用的渐变色，内部为最深的颜色，但是在点的索引逐渐变大，也就是这个点存在的时间变长的时候，逐渐变的透明，向外部延伸直至完全透明。要保证渐变向外延伸，所以在 &lt;span class=&quot;cnblogs_code&quot;&gt;createRadialGradient&lt;/span&gt; 的第六个参数的最后 + 1，以此确保这个值是大于1的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小结： &lt;/p&gt;
&lt;p&gt;至此，就是一个可以上天，但是还不能爆炸的哑炮烟花了。代码敲到这里，主要实现烟花的各种逻辑已经全部都有讲到了，之后的内容没有什么新的知识点，大家可以自己尝试完成接下来的内容。由于时间不足，就写到这里，不久之后，我会回来填坑的。&lt;/p&gt;
&lt;p&gt; 大家就不要打我了。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 07:28:00 +0000</pubDate>
<dc:creator>编号2973</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z890524/p/8143030.html</dc:identifier>
</item>
<item>
<title>Python 爬虫实战（一）：使用 requests 和 BeautifulSoup - 吴小龙同學</title>
<link>http://www.cnblogs.com/WuXiaolong/p/8144459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WuXiaolong/p/8144459.html</guid>
<description>&lt;p&gt;我之前写的《&lt;a href=&quot;https://mp.weixin.qq.com/s/ZkOXwR3sjuUWiXTCYkbasA&quot;&gt;Python 3 极简教程.pdf&lt;/a&gt;》，适合有点编程基础的快速入门，通过该系列文章学习，能够独立完成接口的编写，写写小东西没问题。&lt;/p&gt;

&lt;p&gt;requests，Python HTTP 请求库，相当于 Android 的 Retrofit，它的功能包括 Keep-Alive 和连接池、Cookie 持久化、内容自动解压、HTTP 代理、SSL 认证、连接超时、Session 等很多特性，同时兼容 Python2 和 Python3，GitHub：&lt;a href=&quot;https://github.com/requests/requests&quot; class=&quot;uri&quot;&gt;https://github.com/requests/requests&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;Mac：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip3 install requests&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Windows：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip install requests&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;发送请求&quot;&gt;发送请求&lt;/h2&gt;
&lt;p&gt;HTTP 请求方法有 get、post、put、delete。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; requests

&lt;span class=&quot;co&quot;&gt;# get 请求&lt;/span&gt;
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/all'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# post 请求&lt;/span&gt;
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.post(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/insert'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# put 请求&lt;/span&gt;
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.put(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/update'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# delete 请求&lt;/span&gt;
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.delete(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/delete'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求返回 Response 对象，Response 对象是对 HTTP 协议中服务端返回给浏览器的响应数据的封装，响应的中的主要元素包括：状态码、原因短语、响应首部、响应 URL、响应 encoding、响应体等等。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 状态码&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(response.status_code)

&lt;span class=&quot;co&quot;&gt;# 响应 URL&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(response.url)

&lt;span class=&quot;co&quot;&gt;# 响应短语&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(response.reason)

&lt;span class=&quot;co&quot;&gt;# 响应内容&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(response.json())&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;定制请求头&quot;&gt;定制请求头&lt;/h2&gt;
&lt;p&gt;请求添加 HTTP 头部 Headers，只要传递一个 dict 给 headers 关键字参数就可以了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;header &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'Application-Id'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'19869a66c6'&lt;/span&gt;,
          &lt;span class=&quot;co&quot;&gt;'Content-Type'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'application/json'&lt;/span&gt;
          }
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/all/'&lt;/span&gt;, headers&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;header)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;构建查询参数&quot;&gt;构建查询参数&lt;/h2&gt;
&lt;p&gt;想为 URL 的查询字符串(query string)传递某种数据，比如：&lt;a href=&quot;http://127.0.0.1:1024/developer/api/v1.0/all?key1=value1&amp;amp;key2=value2&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:1024/developer/api/v1.0/all?key1=value1&amp;amp;key2=value2&lt;/a&gt; ，Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'value1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'value2'&lt;/span&gt;}
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;&quot;http://127.0.0.1:1024/developer/api/v1.0/all&quot;&lt;/span&gt;, params&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;payload)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以将 list 作为值传入：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'value1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;: [&lt;span class=&quot;st&quot;&gt;'value2'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'value3'&lt;/span&gt;]}
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;&quot;http://127.0.0.1:1024/developer/api/v1.0/all&quot;&lt;/span&gt;, params&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;payload)

&lt;span class=&quot;co&quot;&gt;# 响应 URL&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(response.url)&lt;span class=&quot;co&quot;&gt;# 打印：http://127.0.0.1:1024/developer/api/v1.0/all?key1=value1&amp;amp;key2=value2&amp;amp;key2=value3&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;post-请求数据&quot;&gt;post 请求数据&lt;/h2&gt;
&lt;p&gt;如果服务器要求发送的数据是表单数据，则可以指定关键字参数 data。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;payload &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'key1'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'value1'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'key2'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'value2'&lt;/span&gt;}
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.post(&lt;span class=&quot;st&quot;&gt;&quot;http://127.0.0.1:1024/developer/api/v1.0/insert&quot;&lt;/span&gt;, data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;payload)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要求传递 json 格式字符串参数，则可以使用 json 关键字参数，参数的值都可以字典的形式传过去。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
    &lt;span class=&quot;st&quot;&gt;&quot;article_title&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;小公务员之死2&quot;&lt;/span&gt;
}
&lt;span class=&quot;co&quot;&gt;# response = requests.post('http://127.0.0.1:1024/developer/api/v1.0/insert', json=obj)&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;响应内容&quot;&gt;响应内容&lt;/h2&gt;
&lt;p&gt;Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 响应内容&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 返回是 是 str 类型内容&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# print(response.text())&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 返回是 JSON 响应内容&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(response.json())
&lt;span class=&quot;co&quot;&gt;# 返回是二进制响应内容&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# print(response.content())&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 原始响应内容，初始请求中设置了 stream=True&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# response = requests.get('http://127.0.0.1:1024/developer/api/v1.0/all', stream=True)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# print(response.raw())&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;超时&quot;&gt;超时&lt;/h2&gt;
&lt;p&gt;如果没有显式指定了 timeout 值，requests 是不会自动进行超时处理的。如果遇到服务器没有响应的情况时，整个应用程序一直处于阻塞状态而没法处理其他请求。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/all'&lt;/span&gt;, timeout&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 单位秒数&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;代理设置&quot;&gt;代理设置&lt;/h2&gt;
&lt;p&gt;如果频繁访问一个网站，很容易被服务器屏蔽掉，requests 完美支持代理。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 代理&lt;/span&gt;
proxies &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
    &lt;span class=&quot;st&quot;&gt;'http'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024'&lt;/span&gt;,
    &lt;span class=&quot;co&quot;&gt;'https'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:4000'&lt;/span&gt;,
}
response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:1024/developer/api/v1.0/all'&lt;/span&gt;, proxies&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;proxies)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;BeautifulSoup，Python Html 解析库，相当于 Java 的 jsoup。&lt;/p&gt;
&lt;h2 id=&quot;安装-1&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;BeautifulSoup 3 目前已经停止开发，直接使用BeautifulSoup 4。&lt;/p&gt;
&lt;p&gt;Mac：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip3 install beautifulsoup4&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Windows：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip install beautifulsoup4&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;安装解析器&quot;&gt;安装解析器&lt;/h2&gt;
&lt;p&gt;我用的是 html5lib，纯 Python 实现的。&lt;/p&gt;
&lt;p&gt;Mac：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip3 install html5lib&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Windows：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;pip install html5lib&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;简单使用&quot;&gt;简单使用&lt;/h2&gt;
&lt;p&gt;BeautifulSoup 将复杂 HTML 文档转换成一个复杂的树形结构，每个节点都是 Python 对象。&lt;/p&gt;
&lt;h3 id=&quot;解析&quot;&gt;解析&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; BeautifulSoup

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; get_html_data():
    html_doc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;title&amp;gt;WuXiaolong&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;p&amp;gt;分享 Android 技术，也关注 Python 等热门技术。&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;p&amp;gt;写博客的初衷：总结经验，记录自己的成长。&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;p&amp;gt;你必须足够的努力，才能看起来毫不费力！专注！精致！&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;p class=&quot;Blog&quot;&amp;gt;&amp;lt;a href=&quot;http://wuxiaolong.me/&quot;&amp;gt;WuXiaolong's blog&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;p class=&quot;WeChat&quot;&amp;gt;&amp;lt;a href=&quot;https://open.weixin.qq.com/qr/code?username=MrWuXiaolong&quot;&amp;gt;公众号：吴小龙同学&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;p class=&quot;GitHub&quot;&amp;gt;&amp;lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&amp;gt;GitHub&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &amp;lt;/html&amp;gt;   &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;
    soup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BeautifulSoup(html_doc, &lt;span class=&quot;st&quot;&gt;&quot;html5lib&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;tag&quot;&gt;tag&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tag &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; soup.head
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(tag)  &lt;span class=&quot;co&quot;&gt;# &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;WuXiaolong&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(tag.name)  &lt;span class=&quot;co&quot;&gt;# head&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(tag.title)  &lt;span class=&quot;co&quot;&gt;# &amp;lt;title&amp;gt;WuXiaolong&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(soup.p)  &lt;span class=&quot;co&quot;&gt;# &amp;lt;p&amp;gt;分享 Android 技术，也关注 Python 等热门技术。&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(soup.a[&lt;span class=&quot;st&quot;&gt;'href'&lt;/span&gt;])  &lt;span class=&quot;co&quot;&gt;# 输出 a 标签的 href 属性：http://wuxiaolong.me/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：tag 如果多个匹配，返回第一个，比如这里的 p 标签。&lt;/p&gt;
&lt;h3 id=&quot;查找&quot;&gt;查找&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(soup.find(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;# &amp;lt;p&amp;gt;分享 Android 技术，也关注 Python 等热门技术。&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;find 默认也是返回第一个匹配的标签，没找到匹配的节点则返回 None。如果我想指定查找，比如这里的公众号，可以指定标签的如 class 属性值：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 因为 class 是 Python 关键字，所以这里指定为 class_。&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(soup.find(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;WeChat&quot;&lt;/span&gt;))
&lt;span class=&quot;co&quot;&gt;# &amp;lt;p class=&quot;WeChat&quot;&amp;gt;&amp;lt;a href=&quot;https://open.weixin.qq.com/qr/code?username=MrWuXiaolong&quot;&amp;gt;公众号&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查找所有的 P 标签：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; p &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; soup.find_all(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;):
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(p.string) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前段时间，有用户反馈，我的个人 APP 挂了，虽然这个 APP 我已经不再维护，但是我也得起码保证它能正常运行。大部分人都知道这个 APP 数据是爬来的（详见：《&lt;a href=&quot;http://mp.weixin.qq.com/s/tvYx2NbnFIM7aQ7QiBx_jQ&quot;&gt;手把手教你做个人app&lt;/a&gt;》），数据爬来的好处之一就是不用自己管数据，弊端是别人网站挂了或网站的 HTML 节点变了，我这边就解析不到，就没数据。这次用户反馈，我在想要不要把他们网站数据直接爬虫了，正好自学 Python，练练手，嗯说干就干，本来是想着先用 Python 爬虫，MySQL 插入本地数据库，然后 Flask 自己写接口，用 Android 的 Retrofit 调，再用 bmob sdk 插入 bmob……哎，费劲，感觉行不通，后来我得知 bmob 提供了 RESTful，解决大问题，我可以直接 Python 爬虫插入就好了，这里我演示的是插入本地数据库，如果用 bmob，是调 bmob 提供的 RESTful 插数据。&lt;/p&gt;
&lt;h2 id=&quot;网站选定&quot;&gt;网站选定&lt;/h2&gt;
&lt;p&gt;我选的演示网站：&lt;a href=&quot;https://meiriyiwen.com/random&quot; class=&quot;uri&quot;&gt;https://meiriyiwen.com/random&lt;/a&gt; ，大家可以发现，每次请求的文章都不一样，正好利用这点，我只要定时去请求，解析自己需要的数据，插入数据库就 OK 了。&lt;/p&gt;
&lt;h2 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h2&gt;
&lt;p&gt;我直接用 NaviCat Premium 创建的，当然也可以用命令行。&lt;br/&gt;&lt;img src=&quot;http://7q5c2h.com1.z0.glb.clouddn.com/Python3Learn8.png?imageView2/0/format/png/q/75%7Cwatermark/2/text/5ZC05bCP6b6Z5ZCM5a24/font/5a6L5L2T/fontsize/1200/fill/IzIxOTZGMw==/dissolve/100/gravity/SouthEast/dx/10/dy/10%7Cimageslim&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建表&quot;&gt;创建表&lt;/h2&gt;
&lt;p&gt;创建表 article，用的 pymysql，表需要 id，article_title，article_author，article_content 字段，代码如下，只需要调一次就好了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pymysql


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; create_table():
    &lt;span class=&quot;co&quot;&gt;# 建立连接&lt;/span&gt;
    db &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pymysql.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'localhost'&lt;/span&gt;,
                         user&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'python3learn'&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# 创建名为 article 数据库语句&lt;/span&gt;
    sql &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'''create table if not exists article (&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    id int NOT NULL AUTO_INCREMENT, &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    article_title text,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    article_author text,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    article_content text,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    PRIMARY KEY (`id`)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    )'''&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 使用 cursor() 方法创建一个游标对象 cursor&lt;/span&gt;
    cursor &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; db.cursor()
    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# 执行 sql 语句&lt;/span&gt;
        cursor.execute(sql)
        &lt;span class=&quot;co&quot;&gt;# 提交事务&lt;/span&gt;
        db.commit()
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'create table success'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;pp&quot;&gt;BaseException&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; e:  &lt;span class=&quot;co&quot;&gt;# 如果发生错误则回滚&lt;/span&gt;
        db.rollback()
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(e)

    &lt;span class=&quot;cf&quot;&gt;finally&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# 关闭游标连接&lt;/span&gt;
        cursor.close()
        &lt;span class=&quot;co&quot;&gt;# 关闭数据库连接&lt;/span&gt;
        db.close()


&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    create_table()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;解析网站&quot;&gt;解析网站&lt;/h2&gt;
&lt;p&gt;首先需要 requests 请求网站，然后 BeautifulSoup 解析自己需要的节点。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; requests
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; BeautifulSoup


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; get_html_data():
    &lt;span class=&quot;co&quot;&gt;# get 请求&lt;/span&gt;
    response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;'https://meiriyiwen.com/random'&lt;/span&gt;)

    soup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BeautifulSoup(response.content, &lt;span class=&quot;st&quot;&gt;&quot;html5lib&quot;&lt;/span&gt;)
    article &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; soup.find(&lt;span class=&quot;st&quot;&gt;&quot;div&quot;&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'article_show'&lt;/span&gt;)
    article_title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article.h1.string
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'article_title=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_title)
    article_author &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article.find(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;article_author&quot;&lt;/span&gt;).string
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'article_author=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article.find(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;article_author&quot;&lt;/span&gt;).string)
    article_contents &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article.find(&lt;span class=&quot;st&quot;&gt;'div'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;article_text&quot;&lt;/span&gt;).find_all(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;)
    article_content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; content &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; article_contents:
        article_content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article_content &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(content)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'article_content=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_content)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;插入数据库&quot;&gt;插入数据库&lt;/h2&gt;
&lt;p&gt;这里做了一个筛选，默认这个网站的文章标题是唯一的，插入数据时，如果有了同样的标题就不插入。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pymysql


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; insert_table(article_title, article_author, article_content):
    &lt;span class=&quot;co&quot;&gt;# 建立连接&lt;/span&gt;
    db &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pymysql.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'localhost'&lt;/span&gt;,
                         user&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'python3learn'&lt;/span&gt;,
                         charset&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# 插入数据&lt;/span&gt;
    query_sql &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'select * from article where article_title=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;
    sql &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'insert into article (article_title,article_author,article_content) values (&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;)'&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 使用 cursor() 方法创建一个游标对象 cursor&lt;/span&gt;
    cursor &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; db.cursor()
    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        query_value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (article_title,)
        &lt;span class=&quot;co&quot;&gt;# 执行 sql 语句&lt;/span&gt;
        cursor.execute(query_sql, query_value)
        results &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; cursor.fetchall()
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(results) &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
            value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (article_title, article_author, article_content)
            cursor.execute(sql, value)
            &lt;span class=&quot;co&quot;&gt;# 提交事务&lt;/span&gt;
            db.commit()
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'--------------《&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;》 insert table success-------------'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_title)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'--------------《&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;》 已经存在-------------'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_title)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;

    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;pp&quot;&gt;BaseException&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; e:  &lt;span class=&quot;co&quot;&gt;# 如果发生错误则回滚&lt;/span&gt;
        db.rollback()
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(e)

    &lt;span class=&quot;cf&quot;&gt;finally&lt;/span&gt;:  &lt;span class=&quot;co&quot;&gt;# 关闭游标连接&lt;/span&gt;
        cursor.close()
        &lt;span class=&quot;co&quot;&gt;# 关闭数据库连接&lt;/span&gt;
        db.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;定时设置&quot;&gt;定时设置&lt;/h2&gt;
&lt;p&gt;做了一个定时，过段时间就去爬一次。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; sched
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time


&lt;span class=&quot;co&quot;&gt;# 初始化 sched 模块的 scheduler 类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 第一个参数是一个可以返回时间戳的函数，第二个参数可以在定时未到达之前阻塞。&lt;/span&gt;
schedule &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sched.scheduler(time.time, time.sleep)


&lt;span class=&quot;co&quot;&gt;# 被周期性调度触发的函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; print_time(inc):
    &lt;span class=&quot;co&quot;&gt;# to do something&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'to do something'&lt;/span&gt;)
    schedule.enter(inc, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, print_time, (inc,))


&lt;span class=&quot;co&quot;&gt;# 默认参数 60 s&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; start(inc&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;):
    &lt;span class=&quot;co&quot;&gt;# enter四个参数分别为：间隔事件、优先级（用于同时间到达的两个事件同时执行时定序）、被调用触发的函数，&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 给该触发函数的参数（tuple形式）&lt;/span&gt;
    schedule.enter(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, print_time, (inc,))
    schedule.run()


&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    &lt;span class=&quot;co&quot;&gt;# 5 s 输出一次&lt;/span&gt;
    start(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;完整代码&quot;&gt;完整代码&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pymysql
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; requests
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; bs4 &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; BeautifulSoup
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; sched
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; create_table():
    &lt;span class=&quot;co&quot;&gt;# 建立连接&lt;/span&gt;
    db &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pymysql.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'localhost'&lt;/span&gt;,
                         user&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'python3learn'&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# 创建名为 article 数据库语句&lt;/span&gt;
    sql &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'''create table if not exists article (&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    id int NOT NULL AUTO_INCREMENT, &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    article_title text,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    article_author text,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    article_content text,&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    PRIMARY KEY (`id`)&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    )'''&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 使用 cursor() 方法创建一个游标对象 cursor&lt;/span&gt;
    cursor &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; db.cursor()
    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# 执行 sql 语句&lt;/span&gt;
        cursor.execute(sql)
        &lt;span class=&quot;co&quot;&gt;# 提交事务&lt;/span&gt;
        db.commit()
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'create table success'&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;pp&quot;&gt;BaseException&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; e:  &lt;span class=&quot;co&quot;&gt;# 如果发生错误则回滚&lt;/span&gt;
        db.rollback()
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(e)

    &lt;span class=&quot;cf&quot;&gt;finally&lt;/span&gt;:
        &lt;span class=&quot;co&quot;&gt;# 关闭游标连接&lt;/span&gt;
        cursor.close()
        &lt;span class=&quot;co&quot;&gt;# 关闭数据库连接&lt;/span&gt;
        db.close()


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; insert_table(article_title, article_author, article_content):
    &lt;span class=&quot;co&quot;&gt;# 建立连接&lt;/span&gt;
    db &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pymysql.&lt;span class=&quot;ex&quot;&gt;connect&lt;/span&gt;(host&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'localhost'&lt;/span&gt;,
                         user&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         password&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'root'&lt;/span&gt;,
                         db&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'python3learn'&lt;/span&gt;,
                         charset&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;utf8&quot;&lt;/span&gt;)
    &lt;span class=&quot;co&quot;&gt;# 插入数据&lt;/span&gt;
    query_sql &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'select * from article where article_title=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;
    sql &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'insert into article (article_title,article_author,article_content) values (&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;)'&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 使用 cursor() 方法创建一个游标对象 cursor&lt;/span&gt;
    cursor &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; db.cursor()
    &lt;span class=&quot;cf&quot;&gt;try&lt;/span&gt;:
        query_value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (article_title,)
        &lt;span class=&quot;co&quot;&gt;# 执行 sql 语句&lt;/span&gt;
        cursor.execute(query_sql, query_value)
        results &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; cursor.fetchall()
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(results) &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
            value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (article_title, article_author, article_content)
            cursor.execute(sql, value)
            &lt;span class=&quot;co&quot;&gt;# 提交事务&lt;/span&gt;
            db.commit()
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'--------------《&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;》 insert table success-------------'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_title)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'--------------《&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;》 已经存在-------------'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_title)
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;

    &lt;span class=&quot;cf&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;pp&quot;&gt;BaseException&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; e:  &lt;span class=&quot;co&quot;&gt;# 如果发生错误则回滚&lt;/span&gt;
        db.rollback()
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(e)

    &lt;span class=&quot;cf&quot;&gt;finally&lt;/span&gt;:  &lt;span class=&quot;co&quot;&gt;# 关闭游标连接&lt;/span&gt;
        cursor.close()
        &lt;span class=&quot;co&quot;&gt;# 关闭数据库连接&lt;/span&gt;
        db.close()


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; get_html_data():
    &lt;span class=&quot;co&quot;&gt;# get 请求&lt;/span&gt;
    response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; requests.get(&lt;span class=&quot;st&quot;&gt;'https://meiriyiwen.com/random'&lt;/span&gt;)

    soup &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; BeautifulSoup(response.content, &lt;span class=&quot;st&quot;&gt;&quot;html5lib&quot;&lt;/span&gt;)
    article &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; soup.find(&lt;span class=&quot;st&quot;&gt;&quot;div&quot;&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'article_show'&lt;/span&gt;)
    article_title &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article.h1.string
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'article_title=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_title)
    article_author &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article.find(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;article_author&quot;&lt;/span&gt;).string
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'article_author=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article.find(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;article_author&quot;&lt;/span&gt;).string)
    article_contents &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article.find(&lt;span class=&quot;st&quot;&gt;'div'&lt;/span&gt;, class_&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;article_text&quot;&lt;/span&gt;).find_all(&lt;span class=&quot;st&quot;&gt;'p'&lt;/span&gt;)
    article_content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; content &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; article_contents:
        article_content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; article_content &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(content)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'article_content=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; article_content)

    &lt;span class=&quot;co&quot;&gt;# 插入数据库&lt;/span&gt;
    insert_table(article_title, article_author, article_content)


&lt;span class=&quot;co&quot;&gt;# 初始化 sched 模块的 scheduler 类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 第一个参数是一个可以返回时间戳的函数，第二个参数可以在定时未到达之前阻塞。&lt;/span&gt;
schedule &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sched.scheduler(time.time, time.sleep)


&lt;span class=&quot;co&quot;&gt;# 被周期性调度触发的函数&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; print_time(inc):
    get_html_data()
    schedule.enter(inc, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, print_time, (inc,))


&lt;span class=&quot;co&quot;&gt;# 默认参数 60 s&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; start(inc&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;):
    &lt;span class=&quot;co&quot;&gt;# enter四个参数分别为：间隔事件、优先级（用于同时间到达的两个事件同时执行时定序）、被调用触发的函数，&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;# 给该触发函数的参数（tuple形式）&lt;/span&gt;
    schedule.enter(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, print_time, (inc,))
    schedule.run()


&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    start(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题：这只是对一篇文章爬虫，如果是那种文章列表，点击是文章详情，这种如何爬虫解析？首先肯定要拿到列表，再循环一个个解析文章详情插入数据库？还没有想好该如何做更好，留给后面的课题吧。&lt;/p&gt;

&lt;p&gt;虽然我学 Python 纯属业余爱好，但是也要学以致用，不然这些知识很快就忘记了，期待下篇 Python 方面的文章。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.python-requests.org/zh_CN/latest/user/quickstart.html&quot;&gt;快速上手 — Requests 2.18.1 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/HKBeOAbl4H7JsEInP6_-1A&quot;&gt;爬虫入门系列（二）：优雅的HTTP库requests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html&quot;&gt;Beautiful Soup 4.2.0 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s/XMxACsYyk0m22dhjh-tDxw&quot;&gt;爬虫入门系列（四）：HTML文本解析库BeautifulSoup&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 06:46:00 +0000</pubDate>
<dc:creator>吴小龙同學</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WuXiaolong/p/8144459.html</dc:identifier>
</item>
<item>
<title>Robotframework-Appium系列：登录操作 - janehost</title>
<link>http://www.cnblogs.com/LOVEYU/p/8144175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LOVEYU/p/8144175.html</guid>
<description>&lt;p&gt;之前Appium的环境已经配置完成(参考&lt;a href=&quot;http://www.cnblogs.com/LOVEYU/p/7813434.html&quot;&gt;Robotframework-Appium系列：安装配置&lt;/a&gt;)，接下来就是如何使用Appium来完成我们的apk的测试工作。&lt;/p&gt;
&lt;h2 id=&quot;一环境准备&quot;&gt;一、环境准备&lt;/h2&gt;
&lt;p&gt;所需的软件列表如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Robotframework&lt;/li&gt;
&lt;li&gt;Appium&lt;/li&gt;
&lt;li&gt;Android模拟器--夜神模拟器&lt;/li&gt;
&lt;li&gt;测试的apk文件&lt;/li&gt;
&lt;li&gt;uiautomatorviewer：apk软件定位工具&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动上述列出的软件，如截图所示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;说明&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 未启动显示的是三角形，启动之后变为正方形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 测试的应用程序的路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 测试的应用程序的包名以及activity名，在路径输入之后，会自动显示，不用修改，使用默认&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 测试apk的平台和使用的工具，这里选择的是Android6.0，Appium工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在第一次使用夜神模拟器的时候，会自动安装Appium Settings和Unlock两个工具；apk文件可以直接拖到夜神模拟器中，模拟器会自动安装。&lt;/p&gt;
&lt;h3 id=&quot;uiautomatorviewer定位apk元素&quot;&gt;uiautomatorviewer定位apk元素&lt;/h3&gt;
&lt;p&gt;安装apk完成之后，打开需要测试的apk，点击图标所示1，定位元素如图&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/g1PFw64.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;说明&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 图标1处，打开apk后，点击此处可以定位当前页面中的所有元素信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 图标2处，定位的用户名的具体元素定位&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目结构和library以及resource的导入&quot;&gt;项目结构和library以及resource的导入&lt;/h3&gt;
&lt;p&gt;项目结构如图所示&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/jZY5vJY.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关键字封装&quot;&gt;关键字封装&lt;/h3&gt;
&lt;p&gt;接下来就是关键字封装，在robotframework中首先需要打开测试的应用程序，打开应用程序的关键字封装代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;打开应用程序
Open Application    http://192.168.8.170:4723/wd/hub    platformName=Android
platformVersion=6.0.0    deviceName=192.168.8.170:62001
app=F:\\test\\mis.apk
appPackage=com.xxx.xxx
...    appActivity=com.xxx.xxx.atys.StartAty    unicodeKeyboard=True    resetKeyboard=True&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;界面如图所示&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/UIzxLXi.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开应用程序之后，就需要定位我们刚刚使用uiautomatorviewer工具定位的登陆用户名，具体代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入用户名
[Arguments]    ${username}
AppiumLibrary.wait until page contains element    id=com.xxx.xxx:id/username
AppiumLibrary.input text    id=com.xxx.xxx:id/username    ${username}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，登陆的用户名的关键字已经封装好了，在下次使用的时候可以直接使用封装好的关键字-输入用户名即可。&lt;/p&gt;
&lt;h2 id=&quot;三登陆流程&quot;&gt;三、登陆流程&lt;/h2&gt;
&lt;p&gt;关于登陆页面的关键字封装完成之后，接下来就是登陆流程的梳理，针对测试apk，登陆的步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开应用apk程序&lt;/li&gt;
&lt;li&gt;在欢迎页面中点击开始&lt;/li&gt;
&lt;li&gt;输入登陆的用户名&lt;/li&gt;
&lt;li&gt;输入登陆的密码&lt;/li&gt;
&lt;li&gt;点击登陆&lt;/li&gt;
&lt;li&gt;跳过新手指引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据登陆的流程，接下来就是针对已经封装好的关键字进行流程的操作，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;登录成功
打开应用程序
点击开始
截图    login
输入用户名    ${username}
输入密码    ${password}
点击登录
截图    login
跳过新手指引
截图    login&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四断言&quot;&gt;四、断言&lt;/h2&gt;
&lt;p&gt;而对于一个测试用例而已，最重要的就是断言，而针对登陆成功的断言，我们只需要判断登陆的用户名和我们输入的用户名是否一致，如果一致则登陆成功，否则登陆失败。&lt;br/&gt;而apk中登陆的用户名定位需要先进入个人中心，所以封装的关键字如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;进入个人中心
appiumLibrary.click element    id = com.xxx.xxx:id/txt_more1

获取登录的用户名
${getLoginName}    appiumLibrary.get text    id = com.xxx.xxx:id/tvName
[Return]    ${getLoginName}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么接下来就是断言，在robotframework这里使用&lt;code&gt;should contain&lt;/code&gt;关键字断言，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; #断言
进入个人中心
${getLoginName}    获取登录的用户名
BuiltIn .should contain    ${username}    ${getLoginName}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;此处的关键字&lt;code&gt;should contain&lt;/code&gt;使用的是&lt;code&gt;Builtln&lt;/code&gt;包,所以需要加上包名&lt;/p&gt;
&lt;h2 id=&quot;五集成jenkins执行用例&quot;&gt;五、集成jenkins执行用例&lt;/h2&gt;
&lt;p&gt;之前偶然发现集成工具jenkins，使用一段时间之后，发现它的功能竟这么强大，基本上我们想要实现的集成都可以通过jenkins集成完成操作，省去了一系列麻烦的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前接触的更新测试环境的代码、接口postman和jmeter都可以使用jenkins工具进行集成构建，对于公司长期的项目进行定时构建，并且发送测试结果给指定的负责人。这样早上来到公司就可以直接看到测试结果。而对于多次迭代的项目测试，不仅提高了工作效率，相对而言也节省了成本。&lt;/p&gt;
&lt;p&gt;具体的配置，可以参考：&lt;a href=&quot;http://www.cnblogs.com/LOVEYU/p/7765144.html&quot;&gt;RobotFrameWork自动化系列：安装配置&lt;/a&gt;，具体配置截图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/yYOhJMV.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jenkins运行结果展示&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/g4eyTv4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6i9Mfx7.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Rlqdh4L.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;邮件提醒和文件配置可以参考：&lt;a href=&quot;http://www.cnblogs.com/LOVEYU/p/8087062.html&quot;&gt;JMeter接口测试系列：Jmeter+jenkins+ant 的自动化构建&lt;/a&gt;&lt;br/&gt;这里集成结果会发送到指定的邮箱中，这样我们就可以根据测试结果提bug到bug管理系统了。&lt;/p&gt;
&lt;p&gt;封装的所有关键字代码展示如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;打开应用程序
Open Application    http://192.168.8.170:4723/wd/hub    platformName=Android 
platformVersion=6.0.0    deviceName=192.168.8.170:62001
app=F:\\test\\mis.apk
appPackage=com.xxx.xxx
...    appActivity=com.xxx.xxx.atys.StartAty    unicodeKeyboard=True    resetKeyboard=True

切换服务器
#切换登录服务器
AppiumLibrary.click element    id = com.xxx.xxx:id/login_iv_icon
AppiumLibrary.click element    id = com.xxx.xxx:id/login_iv_icon
AppiumLibrary.click element    id = com.xxx.xxx:id/login_iv_icon
AppiumLibrary.click element    id = com.xxx.xxx:id/login_iv_icon
AppiumLibrary.click element    id = com.xxx.xxx:id/login_iv_icon
AppiumLibrary.click element    id=com.xxx.xxx:id/login_rela_login

截图
[Arguments]    ${ScreenName}
AppiumLibrary.Capture Page Screenshot    ${ScreenName}

输入用户名
[Arguments]    ${username}
AppiumLibrary.wait until page contains element    id=com.xxx.xxx:id/username
AppiumLibrary.input text    id=com.xxx.xxx:id/username    ${username}

输入密码
[Arguments]    ${password}
AppiumLibrary.input text    id=com.xxx.xxx:id/pwd    ${password}

点击登录
AppiumLibrary.click element    id=com.xxx.xxx:id/login

跳过新手指引
AppiumLibrary.click element    id = com.xxx.xxx:id/jump_over

点击监测统计
AppiumLibrary.click element    id = com.xxx.xxx:id/txt_poi1

点击日历选择
AppiumLibrary.click element    id =com.xxx.xxx:id/anIvRight



进入个人中心
appiumLibrary.click element    id = com.xxx.xxx:id/txt_more1

获取登录的用户名
${getLoginName}    appiumLibrary.get text    id = com.xxx.xxx:id/tvName
[Return]    ${getLoginName}

登录页面点击下一步
AppiumLibrary.click element    id = com.xxx.xxx:id/guide4_btn&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的登陆成功测试用例代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;登录成功
打开应用程序
点击开始
截图    login
输入用户名    ${username}
输入密码    ${password}
点击登录
截图    login
跳过新手指引
截图    login
#断言
进入个人中心
${getLoginName}    获取登录的用户名
BuiltIn .should contain    ${username}    ${getLoginName}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/kDEV7jy.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 05:55:00 +0000</pubDate>
<dc:creator>janehost</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LOVEYU/p/8144175.html</dc:identifier>
</item>
<item>
<title>IX-Protected Dataplane Operating System解读 - 负赑屃</title>
<link>http://www.cnblogs.com/mar-q/p/8144151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mar-q/p/8144151.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文为作者原创，转载请注明出处（http://www.cnblogs.com/mar-q/）by 负赑屃&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　一、概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　商业操作系统在应用程序每秒钟需要数百万次操作时才能保持高吞吐量和低（尾）延迟，对于最慢的请求只需几百微秒。&lt;/span&gt;&lt;span&gt;通常认为对于高性能网络（小信息的高包率、低延迟）的构建，最好都是在内核之外构建用户态协议，IX提出了dataplane operating system，提供高IO性能同时保持内核的安全性。IX通过硬件虚拟化技术分离内核网络处理的调度和管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果阅读本文有些困惑，可以先阅读我的上一篇文章《&lt;a href=&quot;http://www.cnblogs.com/mar-q/p/8144083.html&quot; target=&quot;_blank&quot;&gt;NFV、DPDK以及部分用户态协议研究&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　二、IX在HOME服务器的配置运行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;0&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;基本需求&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　未发现IX的requirement page（估计关闭了），在GitHub上说需要DPDK以及Intel网卡82599、X520、X540，aws ec2测试失败，家里一台realtek网卡机器测试失败，现在另一台Intel网卡服务器测试，具体配置信息为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Ubuntu &lt;span&gt;16.04&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&lt;span&gt; LTS
#lspci &lt;/span&gt;|&lt;span&gt; # hardinfo
Intel(R) Core(TM) i7&lt;/span&gt;-6800K CPU @ &lt;span&gt;3&lt;/span&gt;.40GHz &lt;span&gt;12&lt;/span&gt;
&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;19.0&lt;/span&gt; Ethernet controller: Intel Corporation Ethernet Connection (&lt;span&gt;2&lt;/span&gt;) I218-V (rev &lt;span&gt;05&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt; Network controller: Intel Corporation WiFi Link &lt;span&gt;5100&lt;/span&gt;
&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt;&lt;span&gt; VGA compatible controller: NVIDIA Corporation Device 1b80 (rev a1)
# lscpu
虚拟化：VT&lt;/span&gt;-&lt;span&gt;x
L1d cache：32K
L1i cache：32K
L2  cache：256K
L3  cache：15360K
# &lt;/span&gt;/proc/&lt;span&gt;meminfo
MemTotal:&lt;/span&gt;&lt;span&gt;16329504&lt;/span&gt; kB
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;1&quot; readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;下载ix项目及相关子模块&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/ix-project/ix.git&lt;/span&gt;
git submodule update --&lt;span&gt;init
## 子模块下载速度比较慢，尤其是dpdk（我在aws上下载好了）
[submodule &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deps/dpdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    url &lt;/span&gt;= http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dpdk.org/git/dpdk&lt;/span&gt;
[submodule &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deps/dune&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    url &lt;/span&gt;= https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/ix-project/dune.git&lt;/span&gt;
[submodule &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deps/pcidma&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    url &lt;/span&gt;= https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/ix-project/pcidma.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;编译子模块&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## 逐步编译，dpdk可能报错，建议先把所有依赖环境安装完毕，参照DPDK的安装使用及测试。
&lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; +r /boot/System.map-`&lt;span&gt;uname&lt;/span&gt; -&lt;span&gt;r`
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt; -sj64 -C deps/&lt;span&gt;dune
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt; -sj64 -C deps/&lt;span&gt;pcidma
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt; -sj64 -C deps/dpdk config T=x86_64-native-linuxapp-&lt;span&gt;gcc&lt;/span&gt;
&lt;span&gt;make&lt;/span&gt; -sj64 -C deps/dpdk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;pcima模块用于PCI设备驱动，目的在于进行DMA/总线控制，后面的ix配置文件中如果网卡成功绑定了PCI设备号，就可以获取DMA/总线控制权，同时，使用完毕，pcima模块负责释放控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　dune模块是他们提到的安全控制模块，通过硬件虚拟化技术，让应用跑在ring0层（Intel的CPU分层访问机制），像OS一样拥有访问CPU特权并且能改变page table和注册中断等等，同时还能执行正常的系统调用。&lt;a href=&quot;http://dune.scs.stanford.edu/&quot;&gt;http://dune.scs.stanford.edu/&lt;/a&gt;dune有两大模块：kern和libdune，就是虚拟化内核和使用库函数，它只会影响调用dune_init的app，其他系统中的app不受影响。这个项目比较早，大概2010年就开工了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134317085-41092755.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;109&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;编译IX：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
## 注意centos和Ubuntu安装包不同，编译出现过dev报错，&lt;span&gt;make&lt;/span&gt;&lt;span&gt; clean后重新编译了一次才成功。
apt&lt;/span&gt;-get &lt;span&gt;install&lt;/span&gt; libconfig-dev libnuma-&lt;span&gt;dev
&lt;/span&gt;&lt;span&gt;make&lt;/span&gt; -sj64
&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;环境配置&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## 目录下ix.conf为主配置文件。
&lt;/span&gt;&lt;span&gt;cp&lt;/span&gt;&lt;span&gt; ix.conf.sample ix.conf
# modify at least host_addr, gateway_addr, devices, and cpu
## 修改了大页配置，设置大页内存为4096（这里只是一次性修改，注意node&lt;/span&gt;*&lt;span&gt;，分配给了每个NUMA节点）
&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt; -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;for i in /sys/devices/system/node/node*/hugepages/hugepages-2048kB/nr_hugepages; do echo 4096 &amp;gt; $i; done&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
## 将编译好的dune和pcima加载到内核中
&lt;/span&gt;&lt;span&gt;insmod&lt;/span&gt; deps/dune/kern/&lt;span&gt;dune.ko
&lt;/span&gt;&lt;span&gt;insmod&lt;/span&gt; deps/pcidma/&lt;span&gt;pcidma.ko
## 加载dpdk的用户态uio驱动
&lt;/span&gt;&lt;span&gt;modprobe&lt;/span&gt;&lt;span&gt; uio
&lt;/span&gt;&lt;span&gt;insmod&lt;/span&gt; deps/dpdk/build/kmod/&lt;span&gt;igb_uio.ko
## 特别注意，这里需要关闭网卡，因为要进行dpdk绑定，ssh链接确保有两块网卡，否则需要在服务器上调试
&lt;/span&gt;&lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt;
eno1   Link encap:以太网  硬件地址 4c:&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;:6a:&lt;span&gt;43&lt;/span&gt;:5d:&lt;span&gt;91&lt;/span&gt;&lt;span&gt;
          inet 地址:&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.100&lt;/span&gt;  广播:&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2.255&lt;/span&gt;  掩码:&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;
          inet6 地址: fe80::&lt;/span&gt;&lt;span&gt;9193&lt;/span&gt;:&lt;span&gt;9580&lt;/span&gt;:a1ed:cb9e/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; Scope:Link
lo        Link encap:本地环回
          inet 地址:&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  掩码:&lt;span&gt;255.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
          inet6 地址: ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; Scope:Host
wlp7s0    Link encap:以太网  硬件地址 &lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:1e:7e:c3:7a:&lt;span&gt;06&lt;/span&gt;&lt;span&gt;
          inet 地址:&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;3.200&lt;/span&gt;  广播:&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;3.255&lt;/span&gt;  掩码:&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;
          inet6 地址: fe80::5f5c:c814:4b64:35fd&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; Scope:Link
ifdown eno1
## 无法执行，新的Linux更改了网卡的命名方式，ifdown无法识别，改用命令：
&lt;/span&gt;&lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; eno1 down
## 断开链接，使用另一个ssh连接电脑——
## 绑定dpdk的uio模块到eno1网卡，address为前面检测到的PCI地址，或者lspci &lt;/span&gt;| &lt;span&gt;grep&lt;/span&gt; -&lt;span&gt;i eth
deps&lt;/span&gt;/dpdk/tools/dpdk_nic_bind.py -&lt;span&gt;b igb_uio PCI_ADDRESS
## 运行IX的TCP echo服务器，这里出了一点错误：配置文件中也需要修改pci地址和同一个网段的ip地址
.&lt;/span&gt;/dp/ix -- ./apps/echoserver &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
## &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;123&lt;/span&gt; | nc -vv &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.xxx &lt;span&gt;1234&lt;/span&gt;&lt;span&gt; 
## 默认端口号为1234，不在同一网段，连接失败，但是服务运行成功。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134452117-732349487.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于网卡支持的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134514054-139360327.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　他们说最新支持的型号看doc，反正我没找到doc。。。大概翻了一下的他们的代码，关于设备驱动的就这里进行了特殊加载：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134609242-1226691704.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　ixgbe和i40e驱动都是Intel支持虚拟化功能的驱动，它们的主要作用有两点：一是SR-IOV mode，直接将端口资源分配给不同访客操作系统，以开启本地模式；二是VMDq mode，通过IO虚拟机或虚拟监视器进行网络资源集中管理，可以进行软件切换加速模式。上面也看到了，在加载vfio模块的时候报错了，但是这里ix跳过去了，应该也是支持普通模式的，我还没研究这个普通模式的具体区别是啥样的。&lt;a href=&quot;http://dpdk.readthedocs.io/en/latest/nics/intel_vf.html&quot;&gt;http://dpdk.readthedocs.io/en/latest/nics/intel_vf.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　三、最后再介绍一下IX-project这波人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个项目是DARPA（美国国防预先研究计划局）的crash计划资助的，有一定的军方背景，论文主要是14年在USENIX的OSDI发表的这篇：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134712101-409969021.png&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;100&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;同年和15年产生了很多类似的项目，更出名一点的是韩国人在USENIX的NSDI发表的mtcp。16年IX这波人在ACM的TOCS上又投了一篇类似的文章。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134723398-937146129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　人没咋换，我就顺手看了一下，主要是斯坦福的几个人，瑞士的没仔细看。一作Adam Belay是16年毕业的博士，这里头的三作者Christos Kozyrakis是他的导师，Christos是希腊人，到UC Berkeley读的研究生，他研究的东西挺杂，硬件架构、系统环境、系统软件、编程模型等等，从他的词云里没看到ix，只看到了前面的dune，这个项目也是Adam Belay和他搞的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134746163-22234644.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134750710-1350248967.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;262&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;　　&lt;span&gt;我就又查了查Christos的导师，他02年从伯克利毕业，导师是UC Berkeley的David Patterson，这个老头很出名，他是精简指令集RSIC的创始人，他还提出了冗余廉价磁盘阵列RAID，他还是体系结构的量化分析、云计算等概念的创始人之一。。。震惊。。。原来老外的水都这么深。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1035124/201712/1035124-20171229134828038-389192258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 05:51:00 +0000</pubDate>
<dc:creator>负赑屃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mar-q/p/8144151.html</dc:identifier>
</item>
<item>
<title>阿里聚安全年终盘点|2017互联网安全领域十大话题 - 阿里聚安全</title>
<link>http://www.cnblogs.com/alisecurity/p/8144137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alisecurity/p/8144137.html</guid>
<description>&lt;p&gt;&lt;strong data-spm-anchor-id=&quot;a313e.7916648.0.i0.4365431dPBMhx7&quot;&gt;导语：&lt;/strong&gt;2017年即将过去，2018新年还有3天，回顾2017，看似很平淡地过去了，但总有一些印记让我们印象深刻。作为互联网安全领域的一份子，阿里聚安全时刻关注着互联网行业的安全事件，让我们一起来盘点2017年安全圈的一些大事吧，看看是否与你关注的差不多~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、勒索软件与安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gamk5oorv0.jpeg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;勒索软件的风险一直存在，2017上半年5月份，wannacry的爆发，小到个人，大到企业、医疗卫生，民生政务，教育机构皆受到不同程度威胁，风头一时无二。&lt;/p&gt;

&lt;p&gt;WannaCry利用窃取自美国国家安全局的黑客工具EternalBlue（永恒之”）实现了全球范围内的快速传播。随后，WannaCry 2.0，手机“农药”辅助软件勒索病毒，国产一键生成Android勒索软件制作工具接二连三出现。&lt;/p&gt;
&lt;p&gt;下半年Bad Rabbit(坏兔子)在欧洲的肆虐，让西方的企业政府等部门，在勒索软件的阴影下，瑟瑟发抖。&lt;/p&gt;

&lt;p&gt;Bad Rabbit通过伪装成Adobe Flash Player软件升级更新弹窗，诱骗用户主动下载并安装运行恶意程序。可以加密文档类型、数据库文件、虚拟机文件等类型文件，同时还会使用账号弱口令密码扫描内网和SMB共享服务获取登录凭证尝试登录和感染内网主机，对业务存在高安全风险。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、应用商店安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gam4d844a0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;面对越来越多的网络恶意应用，去官方应用商店下载是个不错的选择。但事实证明，官方应用商店也不是那么的让人放心。&lt;/p&gt;

&lt;p&gt;年初，“SMSVova”恶意程序隐藏在一款虚假的“软件更新”应用程序中，并通过短信从攻击方接收指令，以执行诸如为“SMSVova”间谍软件设置和更改密码以及检索位置数据等功能。&lt;/p&gt;
&lt;p&gt;11月4日报道，安全研究人员Dexter Genius近期发现黑客利用官方 Google Play商店作为恶意软件存储仓库、部署冒牌WhatsApp应用。&lt;/p&gt;

&lt;p&gt;而国外科技作者Johnny Lin发表一篇名为《如何利用App Store月入8万美金》，揭苹果应用商店存在一类诈骗APP，利用广告刷榜加指纹支付骗取用户订阅，“诈骗订阅”的存在凸显了苹果应用商店审核机制的不完善以及用户操作过于粗心大意。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;三、漏洞与赏金&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gan282mml0.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;

&lt;p&gt;被称为黑客世界杯的移动Pwn2Own黑客大会今年宣布，攻破iOS奖励10万美元。根据安全漏洞的不同，奖金也有变化。&lt;/p&gt;

&lt;p&gt;8月28日大疆宣布推出“大疆威胁识别奖励计划”，最低奖励为100美元（约合人民币658元），最高3万美元（约合人民币197457元），金额根据威胁潜在的影响而定。&lt;/p&gt;
&lt;p&gt;10月20日消息，为了清除Google Play商店中的漏洞，谷歌本周四启动新项目，开始向发现Android应用漏洞的安全专家提供奖励。承诺每发现一个漏洞，安全专家获得的奖励至少为1000美元。&lt;/p&gt;

&lt;p&gt;赏金计划的推陈出新和赏金额度的不断提高表现了业内对安全的日益重视，但全球安全人才缺口巨大，整体形势依然严峻。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;四、网络内容安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/dedrpq9aot8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;信息爆炸的时代，网络内容的复杂性成几何上升。诸如网络鉴黄师，网站内容审核，贴吧论坛管理员等等会对网络内容安全进行审核。但网络上动辄以万亿计数的信息条目让人工审核捉襟见肘。过去，只有增加审核人员一条路，但是高强度的工作，接收过多的负面信息让内容审核岗位成为冷门。&lt;/p&gt;

&lt;p&gt;2017年9月16日，“2017网络安全博览会暨网络安全成就展”（网络安全周）上，在数据安全、隐私保护备受关注，网络黑灰产日渐猖獗，作案手段不断翻新的背景下，&lt;strong&gt;阿里巴巴分享了阿里系最新的“十大安全黑科技”。&lt;/strong&gt;&lt;strong&gt;其中内容安全技术迎合主流的人工+智能的审核方式，成为了众多企业开发者考察的对象。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;五、实人认证与安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gane1c36k0.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;

&lt;p&gt;《网络安全法》第二十四条  网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;云栖大会阿里巴巴分享核身实践：利用生物识别技术进行身份认证、人机交互已经成为很多移动端产品的重要趋势。阿里实人认证技术可以利用活体检测、人脸对比等并结合权威数据源与阿里实人可信模型，判定用户身份真实性、有效性的在线身份校验服务。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;12月初，英国广播公司（BBC）当地时间12月10日报道，BBC记者约翰·苏德沃斯在我国贵阳体验 “天网工程 ”，在被手机拍下一张面部照片后，仅仅 “潜逃”七分钟，就被中国警方抓获。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六、《网络安全法》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gghehhdqu0.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;454&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2016 年11月7日，全国人大常委会表决通过的《中华人民共和国网络安全法》，于2017年6月1日起施行。这部法律填补了我国关于网络安全犯罪行政处罚方面的空白，它有6个亮点：&lt;/p&gt;
&lt;p&gt;明确了网络空间主权的原则；&lt;/p&gt;
&lt;p&gt;明确了网络产品和服务提供者的安全义务；&lt;/p&gt;
&lt;p&gt;明确了网络运营者的安全义务；&lt;/p&gt;
&lt;p&gt;进一步完善了个人信息保护规则；&lt;/p&gt;
&lt;p&gt;建立了关键信息基础设施安全保护制度；&lt;/p&gt;
&lt;p&gt;确立了关键信息基础设施重要数据跨境传输的规则。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对个人而言，个人信息保护是关键，如法律中明确规定网络实名制，若不提供真实身份信息，网络运营者将不能为其提供相关服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对企业而言，比较侧重于企业安全，比如企业应该怎么去保护信息、怎么去保护网络安全等。此后企业有了更具体的义务和责任去维护网络安全，并对用户和客户负责。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;七、云栖大会（杭州）-移动安全专场&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gao776js50.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2017年10月11日-14日在杭州召开了云栖大会，迎来世界各地4万多位开发者、创业者、科学家、行业先锋们。&lt;/p&gt;
&lt;p&gt;了解业务安全端安全方面应该注意的风险，区分业务风险优先级，关注纵深防御节点，做出平衡业务的取舍，才能使业务安全部门更敏捷，更具有弹性。在云栖大会的移动安全专场，阿里巴巴集团的安全专家们就业务安全端方面做了一些分享。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阿里巴巴安全专家孙泽夺-《APP加固新方向》，重点介绍android加固对于端上的业务风险控制是如何做到自动化部署和分析，能更快捷的感知安全风险，以便快速做出响应，减少不必要的业务损失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里巴巴移动安全专家马征-《APP渠道推广作弊攻防那些事儿》，为如何能减少APP推广经费被羊毛党消耗问题做了详尽的分析。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里巴巴高级算法专家王炎分享《生物识别：阿里巴巴在移动端的核身技术实践》，讲述了阿里实人认证技术和声纹识别技术为移动端设备提供额外的安全性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;八、KRACK-WiFi漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gap95k2nh0.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;

&lt;p&gt;10月中下旬，安全研究人员Mathy Vanhoef在WPA2协议的四次握手过程中发现了严重的安全漏洞KRA（Key Reinstallation Attacks），可能影响所有WiFi设备，利用这个漏洞发起的攻击就叫KRACK攻击。&lt;/p&gt;
&lt;p&gt;几乎所有支持Wi-Fi的设备（Android, Linux, Apple, Windows, OpenBSD, MediaTek, Linksys等）都面临安全威胁，危害较大。&lt;/p&gt;

&lt;p&gt;因此一时间各安全厂商与个人用户人心惶惶，好在暂未发现在野利用实例，而微软、苹果等厂商都及时发布补丁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里安全技术平台团队第一时间对该漏洞做出详尽的漏洞分析报告，并提出漏洞安全加固建议。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;九、IPv6部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gghjmitgm0.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;

&lt;p&gt;今年11月底，由下一代互联网国家工程中心牵头发起的“雪人计划”已在全球完成25台IPv6根服务器架设，中国部署了其中的4台，打破了中国过去没有根服务器的困境。&lt;/p&gt;
&lt;p&gt;12月初，中共中央办公厅、国务院办公厅印发了《推进互联网协议第六版（IPv6）规模部署行动计划》，加快推进IPv6规模部署，IPv6城域网、政府网站IPv6双栈化改造、IPv6城市公共无线网络等均已开始试点和部署，互联网BAT部分内容已支持IPv6访问，流量增长迅速，新的网络环境以及新兴领域均将面临着新的安全挑战。&lt;/p&gt;

&lt;p&gt;针对IPv6安全，计划中重点要求升级安全系统，强化IPv6地址管理，增强IPv6安全防护，加强IPv6环境工业互联网、物联网、车联网、云计算、大数据、人工智能等领域的网络安全技术、管理及机制研究，构筑新兴领域安全保障能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里安全技术平台团队针对IPv6安全防护问题从IPv6安全威胁结合互联网网络安全运营视角进行了重点分析，同时探讨了互联网IPv6网络安全保障体系面临安全风险及加固建议。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;十、iOS11.2  完美越狱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/46gapr74dtl0.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;

&lt;p&gt; “非完美越狱”后的手机一旦重启，需重新手动操作一遍越狱流程。而完美越狱可在重启手机后，能自动执行越狱代码，在重启前完成越狱。&lt;/p&gt;
&lt;p&gt;阿里安全潘多拉实验于2017年成立，此前仅在阿里先知创新大会上露过一次面，其安全研究员用视频演示了安卓8.0的Root提权和iOS 11.1的完美越狱。&lt;/p&gt;

&lt;p&gt;12 月13日，阿里安全潘多拉实验室称，已经完美越狱苹果iOS 11.2。一天后，在苹果发布了iOS 11.2.1之后的数小时内，他们又演示了针对该版本的完美越狱。&lt;/p&gt;
&lt;p&gt;研究人员龙磊表示，理解iOS系统，研究它的安全机制，验证苹果系统是否有“缺口”才是实验的目的。这也是后来潘多拉实验室一直没发布越狱工具的原因之一.。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：当然，2017年安全领域的关键词还有很多，小编整理的也只是一小部分，阿里聚安全在2017年有很多收获也有一些不足，在此与大家共勉，希望在2018年能继续为用户提供满意的安全服务，共同进步！感恩！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;https://jaq.alibaba.com/community/art/show?articleid=1295&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 05:47:00 +0000</pubDate>
<dc:creator>阿里聚安全</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alisecurity/p/8144137.html</dc:identifier>
</item>
<item>
<title>Hibernate学习---Configuration，Session，SessionFactory - MindMrWang</title>
<link>http://www.cnblogs.com/MindMrWang/p/8143981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MindMrWang/p/8143981.html</guid>
<description>&lt;p&gt;上一节我们讲到了Hibernate的测试，并且给出了测试代码，刚开始看见这个测试代码的同学估计是一头雾水把，所以这一节我们来讲一下测试代码。&lt;br/&gt;本节主要内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Configuration&lt;/li&gt;
&lt;li&gt;SessionFactory&lt;/li&gt;
&lt;li&gt;Session&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们再来看一下上一节的测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //加载配置文件
        Configuration config = new Configuration().configure();
        //根据配置文件创建会话工厂
        SessionFactory factory = config.buildSessionFactory();
        //根据会话工厂创建会话
        Session session = factory.getCurrentSession();
        //创建一个事物对象
        Transaction tx = session.beginTransaction();
        //new 一个学生对象
        Student student = new Student(&quot;小三&quot;,19,99);
        //将对象持久化到数据表中
        session.save(student);
        //提交事务
        tx.commit();
        //关闭会话
        session.close();
        //关闭工厂
        factory.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;configuration&quot;&gt;Configuration：&lt;/h2&gt;
&lt;p&gt;首先是Configuration，它是用来解析我们配置的一个类，它加载配置的时候使用了这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Configuration config = new Configuration().configure();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这段代码的第一感觉是为啥还要在后面加一个方法，直接new一个Configuration不就行了吗，为啥还加了一个configure方法。&lt;br/&gt;我们来打开源码瞧瞧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Configuration configure() throws HibernateException {
        return configure( StandardServiceRegistryBuilder.DEFAULT_CFG_RESOURCE_NAME );
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了没，configure方法返回了一个有参的方法，且参数为：&lt;br/&gt;StandardServiceRegistryBuilder.DEFAULT_CFG_RESOURCE_NAME&lt;br/&gt;我们跟进去会发现这个参数是StandardServiceRegistryBuilder类定义的一个名字叫hibernate.config.xml的成员变量。&lt;br/&gt;所以我们可以得出一个结论：如果你采用以下段代码来加载配置文件那么你的主配置文件名字必须叫作hibernate.config.xml&lt;br/&gt;&lt;code&gt;Configuration config = new Configuration().configure();&lt;/code&gt;&lt;br/&gt;当然你也可以自定义，例如这样随意指定：&lt;br/&gt;&lt;code&gt;Configuration config = new Configuration().configure(&quot;xxx.xml');&lt;/code&gt;&lt;br/&gt;但是我们建议使用hibernate指定的配置文件名。&lt;br/&gt;这里我们只介绍这些，所以对于Configuration我们仅需要知道它是用来加载配置文件即可，以后具体分析，现在我们先将hibernate的基本原理讲明白就好。&lt;/p&gt;
&lt;h2 id=&quot;sessionfactory&quot;&gt;SessionFactory：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;SessionFactory factory = config.buildSessionFactory();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们知道主配置文件里面最外面的便是&lt;code&gt;&amp;lt;hibernate-configuration&amp;gt;&lt;/code&gt;接下来就是&lt;code&gt;&amp;lt;session-factory&amp;gt;&lt;/code&gt;，所以通过Configuration实例对象的buildSessionFactory可以根据我们的配置文件建立会话工厂。值得注意的是SessionFactory是一个重量级的组件，是一个单例的，线程安全的。按理说单例对象一定是被共享的是线程不安全的，我们将它的实现类SessionFactoryimpl打开看发现它的大多数的成员变量都是final的，所以它是线程安全的。&lt;br/&gt;一般SessionFactory实例都不进行关闭（开销太大），而是在应用结束的时候自动将其销毁。&lt;/p&gt;
&lt;h2 id=&quot;session&quot;&gt;Session：&lt;/h2&gt;
&lt;p&gt;session由SessionFactory的getCurrentSession()或者openSession()进行创建，在web应用中，每当有一个用户访问时就会为这个用户创建一个Session，所以Session是多例的，它包含了许多非final变量，对同一个用户可能会产生多个事务，若多事务同时对Session的同一个变量进行访问就会引起并发的问题从而导致线程不安全。&lt;/p&gt;
&lt;p&gt;上面提到了Session的两种获取方式，接下来我们说一下两种方式的区别：&lt;br/&gt;getCurrentSession无论执行多少次只要是在同一个线程中它获取到的都是同一个Session对象，使用这个方法获取的Session对象是由ThreadLocal变量存储的（ThreadLocal在我的多线程文章里面有介绍），它的底层是一个Map，key就为线程的名字，所以用这个方法创建的Session对象是线程唯一的。&lt;br/&gt;它创建Session对象的时候会进行判断，判断线程是是否已经存在session，如果不存在便进行创建。以下便是它的实现源码（有源码有真相）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public Session getCurrentSession() throws HibernateException {
        if ( currentSessionContext == null ) {
            throw new HibernateException( &quot;No CurrentSessionContext configured!&quot; );
        }
        return currentSessionContext.currentSession();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不存在那么久进行创建，底层也是通过openSession创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected Session buildOrObtainSession() {
        return baseSessionBuilder()
                .autoClose( isAutoCloseEnabled() )
                .connectionReleaseMode( getConnectionReleaseMode() )
                .flushBeforeCompletion( isAutoFlushEnabled() )
                .openSession();//就是这里
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的逻辑太多，不方便一直跟下去，所以有兴趣的可以一直跟下去。&lt;br/&gt;openSession进行创建时，每执行一次便会创建一个Session对象，所以需要我们手动关闭，而getCurrentSession不用关闭。&lt;/p&gt;
&lt;p&gt;getCurrentSession获得的Session对象不用注册便能够使用而openSession无需注册。&lt;/p&gt;
&lt;p&gt;getCurrentSession获得的session对象一定要在事务里面指定，而openSession获得的对象可以不在事务里面执行。&lt;br/&gt;以上就是对两种获取方式的简单总结。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 05:14:00 +0000</pubDate>
<dc:creator>MindMrWang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MindMrWang/p/8143981.html</dc:identifier>
</item>
<item>
<title>Android破解学习之路（四）——Android游戏 3D摩托飞车破解 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8127953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8127953.html</guid>
<description>&lt;p&gt;&lt;span&gt;经过前面三期的破解，想必大家已经非常熟悉破解的流程，这一篇也算是练手项目，我们继续来练习吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;apk下载地址:链接: https://pan.baidu.com/s/1sl3b3R3 密码: 6666&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;破解步骤：&lt;/h2&gt;
&lt;h3&gt;1.试玩，找到关键字&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如下图，可以看到弹出了Toast对话框，&lt;span&gt;支付失败！&lt;/span&gt;这几字就是我们要找的关键字了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227214752691-1165207037.jpg&quot; alt=&quot;&quot; width=&quot;861&quot; height=&quot;538&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;2.反编译，查找关键字&lt;/h3&gt;
&lt;p&gt;由下图，可以看到三个结果，我们一个个打开，使用工具，查看java源码，可以确定最后一个才是我们修改的smail文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227220525550-1316400384.png&quot; alt=&quot;&quot; width=&quot;965&quot; height=&quot;521&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227220655050-973125533.png&quot; alt=&quot;&quot; width=&quot;1097&quot; height=&quot;588&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;可以看到里面有支付取消，支付成功的相关代码&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.破解开始&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;还记得上一节说的switch方法吗，我们只需要将原本要跳转到支付失败的那个改为跳转到支付成功的即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看smail文件，可以知道pswitch_1代表着支付失败，pswitch_0即相对地代表着支付成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227221037128-341334995.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将pswitch_1修改为pswitch_0即完成破解，或者是删除pswitch_1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171227221141144-1136200444.png&quot; alt=&quot;&quot; width=&quot;961&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再或者，使用goto语句，直接跳到pswitch_0中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228153017663-1738033101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后，删除不必要的权限，拨打电话和发送短信权限都删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228153132819-629788302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;或者还有其他的权限，你可以一一对照来进行删除，不知道权限是什么意思，&lt;span&gt;可以在Androidkiller中的工程信息查看&lt;/span&gt;，鼠标悬浮在相应的权限，就会有权限的说明，红色则是危险权限，一般删除红色的权限就可以了，你觉得其他权限不需要，也可以继续删除。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228153311084-1954969725.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt; 4.测试&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里不得吐槽一下，之前用的Android平板电脑来测试，测了N次都不成功，我还以为我思路错了，可能是平板电脑没有sim卡的缘故，之后，使用手机测试，则是破解成功了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228152619975-1150549151.jpg&quot; alt=&quot;&quot; width=&quot;705&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1210268/201712/1210268-20171228152707319-44399046.jpg&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;398&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 04:50:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8127953.html</dc:identifier>
</item>
<item>
<title>4.前端基于react,后端基于.net core2.0的开发之路（4） 前端打包，编译，路由，模型，服务 - Ambre</title>
<link>http://www.cnblogs.com/Ambre/p/7991484.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ambre/p/7991484.html</guid>
<description>&lt;h2&gt;1.简要的介绍&lt;/h2&gt;
&lt;p&gt;学习react，首先学习的就是javascript,然后ES6,接着是jsx，通常来说如果有javascript的基础，上手非常快，但是真正要搭建一个前端工程化项目，还是有很多坑的&lt;/p&gt;
&lt;p&gt;搞定上面的东西，那么去了解一下&lt;a href=&quot;https://segmentfault.com/a/1190000004029168&quot; target=&quot;_blank&quot;&gt;Virtual DOM&lt;/a&gt;，可以让你更快的了解react&lt;/p&gt;
&lt;p&gt;状态管理和路由都是基于dva(dva基于react-router,redux)，所以就按照dva的命名和规则来玩。建议一边实践一边学习。因为dva对新手非常的友好，建议使用它来入门。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.心路历程（坑路历程）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一个坑，基本来说很简单，就是安装node，然后通过npm初始化项目，然后通过&lt;span&gt;dva-cli&lt;/span&gt;创建你的第一个项目，对我就是用dva-cli初始化项目后开始搭建的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二个坑，我需要放弃dva自带的roadhog插件,使用&lt;span&gt;webpack&lt;/span&gt;，这个时候配置webpack就是一个深坑了&lt;/p&gt;
&lt;p&gt;第三个坑，这个坑是webpack带来的，简单来说就是各种loader，你会发现，当你填完前面一个坑后，接着会再出现一个坑让你填，对，就是&lt;span&gt;babel&lt;/span&gt;！css-loader,less-loader这里就不说了，相对简单。&lt;/p&gt;
&lt;p&gt;我们重点说说babel，babel分presets和plugins，如果是react，你需要babel编译es2015，react，然后通常还需要几个plugins包，比如'...'这个语法，就需要特殊的包来编译他。简单来说，你使用webpack命令打包程序时，问题会一个一个浮现出来，然后你需要通过查询官方文档，来一个一个解决他。&lt;/p&gt;
&lt;p&gt;第四个坑，服务端渲染的坑，当你需要做这个的时候，你会发现，你能查到的文章，并不能给你解决实际问题（文章太老旧），你需要Github去找别人的解决方案，你需要去官方文档里翻可能存在在角落的官方实例（也可能没有），当你解决这个问题的时候，你会发现，自己用的react-router版本不是最新的，然后你还会发现，最新版本直接重写了！不向下兼容。&lt;/p&gt;
&lt;p&gt;然后这个坑会让你去学习如何搭建&lt;span&gt;Node&lt;/span&gt;,如何使用node的服务端框架如&lt;span&gt;express&lt;/span&gt;,然后node怎么记录&lt;span&gt;session&lt;/span&gt;等等问题。&lt;/p&gt;
&lt;p&gt;第五个坑，如何在node层拦截请求，并进行处理。&lt;/p&gt;
&lt;p&gt;好了心路历程走完，我们可以把所有的知识点串联起来了&lt;/p&gt;
&lt;p&gt;dva-cli-&amp;gt;dva-&amp;gt;react-&amp;gt;webpack-&amp;gt;babel-&amp;gt;node-&amp;gt;express&lt;/p&gt;
&lt;h2&gt;3.来个Todo实战一下，了解下路由，模型，服务&lt;/h2&gt;
&lt;p&gt;通过dva-cli先建一个项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695836/201712/695836-20171206100232425-467696535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; 然后&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd learnreact
npm run start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695836/201712/695836-20171206100653925-274299025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 启动成功！&lt;/p&gt;
&lt;p&gt;我们来看看项目构成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695836/201712/695836-20171206100727191-152693062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;入口文件index.js&lt;/p&gt;
&lt;p&gt;路由入口router.js&lt;/p&gt;
&lt;p&gt;路由文件夹routes&lt;/p&gt;
&lt;p&gt;模型文件夹models&lt;/p&gt;
&lt;p&gt;服务文件夹services&lt;/p&gt;
&lt;p&gt;简单写一下查询数据，就OK了，我们开始&lt;/p&gt;
&lt;p&gt;如果你不需要做服务端渲染，那么，webpack,mock之类的就不要自己加了，直接用roadhog，创建的时候都给你配置好了，拿来即用。&lt;/p&gt;

&lt;p&gt;第一步，创建服务，并引用到模型里&lt;/p&gt;
&lt;p&gt;路径：services/home.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import request from '../utils/request'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetHomeInfo() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; request('/api/getHomeInfo'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后把request.js修改下&lt;/p&gt;
&lt;p&gt;路径：utils/request&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; request(url, options) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fetch(url, options)
    .then(checkStatus)
    .then(parseJSON)
&lt;span&gt;&lt;strong&gt;    .then((data) &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;=&amp;gt; {
      return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; { data };
    })&lt;/strong&gt;&lt;/span&gt;
    .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; ({ err }));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步，建立模型（store），并注入进去&lt;/p&gt;
&lt;p&gt;路径：models/home.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
import { GetHomeInfo } from '../services/home'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {

  namespace: &lt;/span&gt;'home'&lt;span&gt;,

  state: {
    homeInfo: []
  },

  subscriptions: {
    setup({ dispatch, history }) {  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-line&lt;/span&gt;
&lt;span&gt;
    },
  },

  effects: {
    &lt;/span&gt;*getHomeInfo({ payload }, { call, put }) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-line&lt;/span&gt;
      const result =&lt;span&gt; yield call(GetHomeInfo, payload);
      const { data } &lt;/span&gt;=&lt;span&gt; result;
      yield put({ type: &lt;/span&gt;'setHomeInfo'&lt;span&gt;, payload: data.data });
    },
  },

  reducers: {
    setHomeInfo(state, { payload }) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; { ...state, homeInfo: payload };
    },
  },

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;然后把模型引用进去：

&lt;/div&gt;
&lt;p&gt;路径：src/index.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import dva from 'dva'&lt;span&gt;;
import &lt;/span&gt;'./index.css'&lt;span&gt;;
import home from &lt;/span&gt;'../src/models/home'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. Initialize&lt;/span&gt;
const app =&lt;span&gt; dva();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. Plugins&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; app.use({});&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. Model&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; app.model(require('./models/example'));&lt;/span&gt;
&lt;span&gt;app.model(home);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. Router&lt;/span&gt;
app.router(require('./router'&lt;span&gt;));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. Start&lt;/span&gt;
app.start('#root');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步，创建路由&lt;/p&gt;
&lt;p&gt;路径：routes/Home.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import React, { Component } from 'react'&lt;span&gt;;
import { connect } from &lt;/span&gt;'dva'&lt;span&gt;;

class Home extends Component {
    componentDidMount() {
        const { dispatch } &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props;
&lt;span&gt;        dispatch({ type: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'home/getHomeInfo'&lt;/span&gt;&lt;span&gt;&lt;span&gt; });&lt;/span&gt;
    }
    render() {
        const { &lt;span&gt;homeInfo&lt;/span&gt; } &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.home;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div&amp;gt;&lt;span&gt;
            {homeInfo.map((item, index) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;lt;div key={item.key}&amp;gt;&lt;span&gt;
                    {item.name}
                &lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;span&gt;            })}
        &lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;span&gt;    }
}

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; connect(({ home }) =&amp;gt; ({ home }))(Home);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四部，添加mock拦截请求&lt;/p&gt;
&lt;p&gt;路径：.roadhogrc.mock.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'GET /api/getHomeInfo': (req, res) =&amp;gt; {
        res.json({
            success: true,
            data: [
                { key: 1, name: 'nick', age: 19 },
                { key: 2, name: 'tony', age: 20 },
                { key: 3, name: 'lili', age: 21 },
                { key: 4, name: 'lilei', age: 22&lt;/span&gt;&lt;span&gt;&lt;span&gt; },
            ],
        });
    },&lt;/span&gt;

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后跑起来看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695836/201712/695836-20171229122000913-1653147403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，成功啦，这就是一个简单的查询，查询走通了，其他操作就是堆积木了。&lt;/p&gt;
&lt;p&gt;数据的走向都清楚了&lt;/p&gt;
&lt;p&gt;router-&amp;gt;model(effects)-&amp;gt;service-&amp;gt;api-&amp;gt;result-&amp;gt;model(reducers)-&amp;gt;router.&lt;/p&gt;
&lt;p&gt;再说一下里面出现的一些关键字：&lt;/p&gt;
&lt;p&gt;class, extends ,export，import ,componentDidMount,render&lt;/p&gt;
&lt;p&gt;前4个是ES6的语法，class类，extends基础，export导出和import导入都是模块化的东西，componentDidMount是react的&lt;a href=&quot;https://www.jianshu.com/p/4784216b8194&quot; target=&quot;_blank&quot;&gt;生命周期&lt;/a&gt;,render就是渲染了，所有state的变化都会触发render，不管你是this.setState(),还是dispatch修改了模型的里的state.&lt;/p&gt;

&lt;p&gt;最后，打包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dist文件夹里就是打包文件，可以直接部署在iis上面&lt;/p&gt;
&lt;p&gt;这篇文章就写这么多吧~.&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 04:30:00 +0000</pubDate>
<dc:creator>Ambre</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ambre/p/7991484.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上-2017年最错误的选择： 生产环境使用 docker swarm - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8143854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8143854.html</guid>
<description>&lt;p&gt;2017年12月29日 10:18 ~ 11:00 左右，由于整个 docker swarm 集群宕机，造成我们迁移至 .net core 跑在 docker swram 上的所有站点无法正常访问，由此给您带来很大很大的麻烦，请您谅解。受这次故障影响的站点有 &lt;a href=&quot;https://ing.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;闪存&lt;/a&gt;，&lt;a href=&quot;https://q.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博问&lt;/a&gt;，&lt;a href=&quot;https://edu.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;班级&lt;/a&gt;，&lt;a href=&quot;https://home.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;园子&lt;/a&gt;，&lt;a href=&quot;https://msg.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;短信息&lt;/a&gt;，&lt;a href=&quot;https://job.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;招聘&lt;/a&gt;，&lt;a href=&quot;https://group.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;小组&lt;/a&gt;，openapi ...&lt;/p&gt;
&lt;p&gt;2017年，随着将一个一个项目从 .net framework 迁移至 .net core ，我们兴奋地在部署上迈出了重要的一步——终于可以进行 docker 部署了。对于 docker 集群的选型，我们最终选择了 docker swarm ，因为 docker swarm 的简单，因为 docker swarm 与 docker 结合的天衣无缝，因为 docker swarm 已经经历了多年的磨练与发展，因为阿里云对 docker 支持的与时俱进，我们想应该不会有什么大坑。&lt;/p&gt;
&lt;p&gt;但是，我们错了，大错特错。一次一次的 docker swarm 集群的不稳定让我们痛苦不堪，不管是开发环境，还是生产环境，有时少数节点宕机，有时多数节点宕机造成整个集群宕机，有时节点看似正常而实际节点的overlay网络无法进行正常通信。。。当出现节点宕机时，多数情况下通过阿里云控制台1次或多次重启服务器可以恢复正常，但有时多数 manager 节点出现宕机，重启后集群无法恢复，只有重建整个集群，我们今天遇到的故障就属于这种情况。&lt;/p&gt;
&lt;p&gt;从我们一次次遇到的生产集群宕机情况看，宕机发生的概率可能与集群中节点的持续运行时间有关，当我们将集群中的所有节点通过阿里云控制台重启后的一段时间内，不会出现宕机问题。这次故障是发生在集群持续运行25天之后。接下来，我们会每隔2周重启一下集群中的所有节点，看是否还会出现节点宕机的问题。&lt;/p&gt;
&lt;p&gt;我们的 docker swarm 集群节点使用了 5 台阿里云 2 核 4 G的独享服务器（VPC网络），3 个 manager 节点，2 个 worker 节点，运行的容器在 50 个之内，docker 版本是 Docker version 17.10.0-ce, build f4ffd25 。&lt;/p&gt;
&lt;p&gt;我们真的不知道这是 docker swarm 的问题，还是阿里云的问题，但是我们知道这是我们选择的问题，我们要为我们的选择负责，想尽一切办法避免再次出现整个集群宕机的问题。再次请大家谅解这次故障给您带来的麻烦。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 04:26:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8143854.html</dc:identifier>
</item>
</channel>
</rss>