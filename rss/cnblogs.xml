<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一行css解决图片统一大小后的拉伸问题(被冷漠的object-fit) - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9640729.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9640729.html</guid>
<description>&lt;h3 id=&quot;一先来个实战&quot;&gt;一、先来个实战&lt;/h3&gt;
&lt;h4 id=&quot;测试案例&quot;&gt;1. 测试案例&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;需求: 要求表情库里所有表情包大小都固定&lt;/li&gt;
&lt;li&gt;实际效果: 由于图片原始大小都不一样,强行设定大小值会导致拉伸,如果不设定大小则参差不齐。例如:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//html
&amp;lt;body&amp;gt;
    &amp;lt;img src=&quot;1.jpg&quot; /&amp;gt;
    &amp;lt;img src=&quot;2.jpg&quot; /&amp;gt;
    &amp;lt;img src=&quot;3.jpg&quot; /&amp;gt;
    ....
&amp;lt;/body&amp;gt;

//css
img{
    width: 80px;
    height: 80px;
    margin-right: 10px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180913143239104-759096743.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决方法&quot;&gt;2. 解决方法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大多数都是利用&lt;code&gt;background-size: cover&lt;/code&gt; 来避免对图片造成的压缩或者拉伸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;小巧而强大的object-fit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;object-fit似乎是被人忽视的一个CSS3属性。因为存在兼容性,所以没有&lt;code&gt;background-size&lt;/code&gt;好用,但是由于某种情况,你不得不用&lt;code&gt;img&lt;/code&gt;标签来引入图片,这时候用&lt;code&gt;object-fit&lt;/code&gt;是很好的选择。&lt;/p&gt;
&lt;p&gt;我们给上图所有img都统一加上&lt;code&gt;object-fit: cover;&lt;/code&gt;属性,看看效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180913144218993-1111457114.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完美解决！真的很方便,只需要一行css&lt;/p&gt;
&lt;p&gt;我们具体学一下&lt;strong&gt;object-fit&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;fill&lt;/td&gt;
&lt;td&gt;默认值。整个对象将完全填充此框。 如果对象的高宽比不匹配其框的宽高比，那么该对象将被&lt;span&gt;拉伸以适应&lt;/span&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;contain&lt;/td&gt;
&lt;td&gt;整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被&lt;span&gt;添加“黑边”&lt;/span&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;cover&lt;/td&gt;
&lt;td&gt;被替换的内容大小保持其宽高比，同时填充元素的整个内容框。 如果对象的宽高比与盒子的宽高比不匹配，该对象将&lt;span&gt;被剪裁以适应&lt;/span&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;内容尺寸不会被改变。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;scale-down&lt;/td&gt;
&lt;td&gt;内容的尺寸就像是指定了none或contain，默认应用尺寸最小的值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们用一张图片作为例子解析以上上面各个属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//html

&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./public/test.jpg&quot; class=&quot;initImg&quot;/&amp;gt; 
    &amp;lt;p&amp;gt;图片初始化&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./public/test.jpg&quot; class=&quot;initImg fillImg&quot;/&amp;gt; 
    &amp;lt;p&amp;gt;object-fit:fill&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./public/test.jpg&quot; class=&quot;initImg containImg&quot;/&amp;gt; 
    &amp;lt;p&amp;gt;object-fit:contain&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/br&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./public/test.jpg&quot; class=&quot;initImg coverImg&quot;/&amp;gt; 
    &amp;lt;p&amp;gt;object-fit:cover&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./public/test.jpg&quot; class=&quot;initImg noneImg&quot;/&amp;gt; 
    &amp;lt;p&amp;gt;object-fit:none&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;
    &amp;lt;img src=&quot;./public/test.jpg&quot; class=&quot;initImg scaleDownImg&quot;/&amp;gt; 
    &amp;lt;p&amp;gt;object-fit:scale-down&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;


//css
body div{
    display: inline-block;
    text-align: center;
}
.initImg{
    width: 150px;
    height: 80px;
}
.fillImg{
    object-fit: fill;
}
.containImg{
    object-fit: contain;
}
.coverImg{
    object-fit: cover;
}
.noneImg{
    object-fit: none;
}
.scaleDownImg{
    object-fit: scale-down;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180913150724205-1722267078.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里稍微解释一下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;fill: 默认值,和未设置一样。会将图片压缩拉伸&lt;/li&gt;
&lt;li&gt;contain: 当宽/高的值达到父容器规定的最小宽/高时,则对应的另一个值会按照原始宽高比进行生成。例如上面,图片的高度达到父容器高度后,宽度按照比例生成,导致左右留白&lt;/li&gt;
&lt;li&gt;cover: 和&lt;code&gt;contain&lt;/code&gt;不一样,cover是以最大值为规定的。例如上图,图片的高度(较小值)首先达到父容器高度后,而宽度并未达到父容器的宽度,图片会继续'生长',直到宽度达到和父容器宽度一致。而&lt;strong&gt;等比伸缩&lt;/strong&gt;的高度会溢出,溢出部分裁剪&lt;/li&gt;
&lt;li&gt;none: 顾名思义宽高对图片不起作用,即使设置了固定的宽高,图片仍然以原始大小展现,但是超出设置的值会被遮挡&lt;/li&gt;
&lt;li&gt;scale-down: 以&lt;code&gt;contain&lt;/code&gt;或&lt;code&gt;none&lt;/code&gt;图片最小尺寸为标准.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上就是object-fit的全部用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很简单,但是很强大&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然,也可以用&lt;code&gt;background-size&lt;/code&gt;解决图片伸缩问题&lt;/p&gt;
&lt;p&gt;例如淘宝网:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201809/1414709-20180913152049766-922740942.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当从文章提取的图片和文章list的展示块尺寸比例不一致的时候，背景图可通过指定 &lt;code&gt;background-size:contain | cover&lt;/code&gt; 来避免对图片造成的压缩或者拉伸。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 07:22:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、先来个实战 1. 测试案例 需求: 要求表情库里所有表情包大小都固定 实际效果: 由于图片原始大小都不一样,强行设定大小值会导致拉伸,如果不设定大小则参差不齐。例如: 2. 解决方法 大多数都是利</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9640729.html</dc:identifier>
</item>
<item>
<title>python multiprocessing深度解析 - yanghuahui</title>
<link>http://www.cnblogs.com/yanghuahui/p/9640697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanghuahui/p/9640697.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在写pythond多线程代码的时候，会用到multiprocessing这个包，这篇文章总结了一些这个包在多进程管理方面的一些原理和代码分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1. 问题一：是否需要显式调用pool的close和join方法，不调用的话，子进程是否无法退出？&lt;/p&gt;
&lt;p&gt;首先初始化Pool的时候，指定processes的个数，就是pool中worker的个数，pool初始化的时候，会把worker以daemon=True的子进程方式启动起来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _repopulate_pool(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Bring the number of pool processes up to the specified number,
        for use after reaping workers which have exited.
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self._processes -&lt;span&gt; len(self._pool)):
            w &lt;/span&gt;= self.Process(target=&lt;span&gt;worker,
                             args&lt;/span&gt;=&lt;span&gt;(self._inqueue, self._outqueue,
                                   self._initializer,
                                   self._initargs, self._maxtasksperchild)
                            )
            self._pool.append(w)
            w.name &lt;/span&gt;= w.name.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Process&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PoolWorker&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            w.daemon &lt;/span&gt;=&lt;span&gt; True
            w.start()
            debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;added worker&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;推荐在使用完pool之后，用thread pool的时候调用close()和join()方法，这样可以把pool中的worker都释放掉（等待子任务结束）。但是如果不显式的调用，在主进程退出的时候，这些子进程也会退出（原因是设置了daemon这个flag）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; _exit_function(info=info, debug=debug, _run_finalizers=&lt;span&gt;_run_finalizers,
                   active_children&lt;/span&gt;=&lt;span&gt;active_children,
                   current_process&lt;/span&gt;=&lt;span&gt;current_process):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; NB: we hold on to references to functions in the arglist due to the&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; situation described below, where this function is called after this&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; module's globals are destroyed.&lt;/span&gt;

    &lt;span&gt;global&lt;/span&gt;&lt;span&gt; _exiting

    info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;process shutting down&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running all &quot;atexit&quot; finalizers with priority &amp;gt;= 0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    _run_finalizers(0)

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; current_process() &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; NB: we check if the current process is None here because if&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; it's None, any call to ``active_children()`` will throw an&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; AttributeError (active_children winds up trying to get&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; attributes from util._current_process).  This happens in a&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; variety of shutdown circumstances that are not well-understood&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; because module-scope variables are not apparently supposed to&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; be destroyed until after this function is called.  However,&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; they are indeed destroyed before this function is called.  See&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; issues 9775 and 15881.  Also related: 4106, 9205, and 9207.&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; active_children():
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; p._daemonic:
                info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;calling terminate() for daemon %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, p.name)
                p._popen.terminate()

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; active_children():
            info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;calling join() for process %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, p.name)
            p.join()

    debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;running the remaining &quot;atexit&quot; finalizers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    _run_finalizers()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主进程退出的时候，会调用_exit_function, 如果看到active的children是_daemonic的就会调用其terninate方法，让子进程退出。exit是通过这个调用注册的，atexit.register(_exit_function)，本质是利用系统的退出hook方法，在退出的时候触发对应的函数。&lt;/p&gt;
&lt;p&gt;2. 问题二：如果启动之后，kill -9主进程，子进程会不会无法退出？&lt;/p&gt;
&lt;p&gt;如下代码是pool中worker的主代码逻辑，如果kill -9主进程，子进程如果没有在处理作业，因为主进程退出了，get()方法从queue中拿task的时候，就会发生exception，这样worker会退出。如果子进程正在处理任务，任务结束的时候，需要往queue中扔回结果，因为主进程退出了，所以也会exception，worker一样会退出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; worker(inqueue, outqueue, initializer=None, initargs=(), maxtasks=&lt;span&gt;None):
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; maxtasks &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; (type(maxtasks) == int &lt;span&gt;and&lt;/span&gt; maxtasks &amp;gt;&lt;span&gt; 0)
    put &lt;/span&gt;=&lt;span&gt; outqueue.put
    get &lt;/span&gt;=&lt;span&gt; inqueue.get
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; hasattr(inqueue, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;_writer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        inqueue._writer.close()
        outqueue._reader.close()

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; initializer &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        initializer(&lt;/span&gt;*&lt;span&gt;initargs)
    completed &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; maxtasks &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; (maxtasks &lt;span&gt;and&lt;/span&gt; completed &amp;lt;&lt;span&gt; maxtasks):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            task &lt;/span&gt;=&lt;span&gt; get()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (EOFError, IOError):
            debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;worker got EOFError or IOError -- exiting&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; task &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;worker got sentinel -- exiting&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

        job, i, func, args, kwds &lt;/span&gt;=&lt;span&gt; task
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            result &lt;/span&gt;= (True, func(*args, **&lt;span&gt;kwds))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception, e:
            result &lt;/span&gt;=&lt;span&gt; (False, e)
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            put((job, i, result))
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            wrapped &lt;/span&gt;= MaybeEncodingError(e, result[1&lt;span&gt;])
            debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Possible encoding error while sending result: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (
                wrapped))
            put((job, i, (False, wrapped)))
        completed &lt;/span&gt;+= 1&lt;span&gt;
    debug(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;worker exiting after %d tasks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % completed)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;worker退出的时候，看如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# process.py&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _bootstrap(self):
        &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; . &lt;span&gt;import&lt;/span&gt;&lt;span&gt; util
        &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; _current_process

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self._children &lt;/span&gt;=&lt;span&gt; set()
            self._counter &lt;/span&gt;= itertools.count(1&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                sys.stdin.close()
                sys.stdin &lt;/span&gt;=&lt;span&gt; open(os.devnull)
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (OSError, ValueError):
                &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;
            _current_process &lt;/span&gt;=&lt;span&gt; self
            util._finalizer_registry.clear()
            util._run_after_forkers()
            util.info(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;child process calling self.run()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                self.run()
                exitcode &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
                util._exit_function()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子进程run()会结束，然后调用_exit_function()清理一些子进程，调用_run_finalizers()结束进程。&lt;/p&gt;
&lt;p&gt;但是如果子进程在pool的worker中跑的是长时间不退出的task，那这个子进程就会无法退出，一直在运行。如果task都是短作业，即使主进程被kill -9，子进程也会在作业跑完之后都退出。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 07:19:00 +0000</pubDate>
<dc:creator>yanghuahui</dc:creator>
<og:description>在写pythond多线程代码的时候，会用到multiprocessing这个包，这篇文章总结了一些这个包在多进程管理方面的一些原理和代码分析。 1. 问题一：是否需要显式调用pool的close和jo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanghuahui/p/9640697.html</dc:identifier>
</item>
<item>
<title>.NET Core 中正确使用 HttpClient 的姿势 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/net-core-httpclient.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/net-core-httpclient.html</guid>
<description>&lt;div readability=&quot;80.781376518219&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/191097/201809/191097-20180913150300207-2058028607.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更方便在服务端调用 HTTP 请求，微软在 .NET Framework 4.x 的时候引入了 HttpClient。但 HttpClient 有很多严重问题，一直饱受诟病，比如 InfoQ 的这篇文章 &lt;a href=&quot;https://www.infoq.com/news/2016/09/HttpClient&quot;&gt;t.cn/Evzy80y&lt;/a&gt;，吐槽了 HttpClient 不能立即关闭连接、性能消耗严重等的问题。&lt;/p&gt;
&lt;p&gt;.NET Core 2.1 开始引入的 HttpClientFactory 解决了 HttpClient 的所有痛点。有了 HttpClientFactory，我们不需要关心如何创建 HttpClient，又如何释放它。通过它可以创建具有特定业务的 HttpClient，而且可以很友好的和 DI 容器结合使用，更为灵活。下面以 ASP.NET Core 为例介绍 HttpClient 新的三种正确使用方式。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;一、直接使用方式&lt;/h2&gt;
&lt;p&gt;不管是哪种方式，都要先注册服务，对于 ASP.NET Core 应用则是在 &lt;code&gt;Startup.cs&lt;/code&gt; 文件的 &lt;code&gt;ConfigureServices&lt;/code&gt; 添加如果代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;services.AddHttpClient();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在 Controller 中通过构造注入的试获得 &lt;code&gt;IHttpClientFactory&lt;/code&gt;，然后通过它来创建 HttpClient 对象。示例代码：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;BaseController&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;readonly&lt;/span&gt; IHttpClientFactory _httpClientFactory;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IHttpClientFactory httpClientFactory)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_httpClientFactory = httpClientFactory;&lt;br/&gt;}&lt;p&gt;[HttpGet]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; client = _httpClientFactory.CreateClient();&lt;br/&gt;client.BaseAddress = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://api.github.com&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; result = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(result)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种使用方式适合一次性的 HTTP 请求调用，弊端是如果多次都要请求 github 的接口，那就得写很多重复代码配置 HttpClient。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;二、命名式使用方式&lt;/h2&gt;
&lt;p&gt;命名式的使用方式可以解决第一种方式的问题，对于特定域名的 HTTP 调用，可以只做一次配置，然后在多个地方通过名称拿到相同的 Client 来使用。&lt;/p&gt;
&lt;p&gt;首先在 &lt;code&gt;Startup.cs&lt;/code&gt; 注册服务的地方添加带有特定名称的 HttpClient 服务，并添加需要的配置，如下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;services.AddHttpClient();&lt;br/&gt;services.AddHttpClient(&lt;span class=&quot;hljs-string&quot;&gt;&quot;github&quot;&lt;/span&gt;, c =&amp;gt;&lt;br/&gt;{&lt;br/&gt;c.BaseAddress = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.github.com/&quot;&lt;/span&gt;);&lt;br/&gt;c.DefaultRequestHeaders.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Accept&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/vnd.github.v3+json&quot;&lt;/span&gt;);&lt;br/&gt;c.DefaultRequestHeaders.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;User-Agent&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;HttpClientFactory-Sample&quot;&lt;/span&gt;);&lt;br/&gt;});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里添加了两次 &lt;code&gt;AddHttpClient&lt;/code&gt;，一次是没有命名的，一次是有命名的。在 Controller 中的使用方式是：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;BaseController&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;readonly&lt;/span&gt; IHttpClientFactory _httpClientFactory;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(IHttpClientFactory httpClientFactory)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_httpClientFactory = httpClientFactory;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;[HttpGet]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; client = _httpClientFactory.CreateClient(&lt;span class=&quot;hljs-string&quot;&gt;&quot;github&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; result = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(result)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但如果使用很频繁，这种获取 Client 的方式还是有一点麻烦。下面介绍第三种方式，可以在使用的时候方便一点，但配置要麻烦些。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;三、类型化使用方式&lt;/h2&gt;
&lt;p&gt;类型化的使用方式可以预先把配置放到自定义的 HttpClient 中，然后在需要的地方都过依赖注入直接拿到 HttpClient 实例。&lt;/p&gt;
&lt;p&gt;我们来看具体的例子，首先自定义一个 HttClient 类，比如访问 github 接口的类可以这样定义：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GitHubClient&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; HttpClient Client { &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt;; }&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GitHubClient&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(HttpClient httpClient)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;httpClient.BaseAddress = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;hljs-string&quot;&gt;&quot;https://api.github.com/&quot;&lt;/span&gt;);&lt;br/&gt;httpClient.DefaultRequestHeaders.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Accept&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;application/vnd.github.v3+json&quot;&lt;/span&gt;);&lt;br/&gt;httpClient.DefaultRequestHeaders.Add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;User-Agent&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;HttpClientFactory-Sample&quot;&lt;/span&gt;);&lt;br/&gt;Client = httpClient;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;GetData&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; _client.GetStringAsync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;GetData&lt;/code&gt; 就是额外扩展的共用方法。使用前需要为这个类注册服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-csharp&quot;&gt;services.AddHttpClient&amp;lt;GitHubClient&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在需要的地方（比如 Controller）中这样使用：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs language-csharp&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt; : &lt;span class=&quot;hljs-title&quot;&gt;BaseController&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;readonly&lt;/span&gt; GitHubClient _gitHubClient;;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ValuesController&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(GitHubClient gitHubClient)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;_gitHubClient = gitHubClient;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;[HttpGet]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;Get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; result = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; _gitHubClient.GetData();&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(result)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}
&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类型化的方式和命名式的方式相比，虽然在配置的时候会麻烦一点，但它有两个好处：一是不用通过名称字符串来获得 Client，而是直接通过依赖注入获得具体的 Client；二是可以在自定义的 HttpClient 类中扩展共用的方法。&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Thu, 13 Sep 2018 07:06:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>在 .NET Core 2.1 中，有新的 HttpClient 使用方式，你知道吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/net-core-httpclient.html</dc:identifier>
</item>
<item>
<title>纯小白入手 vue3.0 CLI - 2.4 - 新组件 Forms.vue 中学习表单 - nDos</title>
<link>http://www.cnblogs.com/ndos/p/9617526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ndos/p/9617526.html</guid>
<description>&lt;p&gt;vue3.0 CLI 真小白一步一步入手全教程系列：&lt;a href=&quot;https://www.cnblogs.com/ndos/category/1295752.html&quot;&gt;https://www.cnblogs.com/ndos/category/1295752.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的 github 地址 - &lt;a href=&quot;https://github.com/yokees/vue3.0Study&quot; target=&quot;_blank&quot;&gt;vue3.0Study&lt;/a&gt; - 阶段学习成果都会建立分支。&lt;/p&gt;
&lt;p&gt;==========================&lt;/p&gt;
&lt;h3&gt;新组件 - 新路由 Forms.vue ( 下面仅介绍如何创立, 不进行介绍 ) ：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;&amp;lt;div class=&quot;form&quot;&amp;gt;
  &amp;lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&amp;gt;
  &amp;lt;p&amp;gt;Message is: {{ message }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'forms', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line&lt;/span&gt;
  data: &lt;span&gt;function&lt;/span&gt; () { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; { 
    d: &lt;/span&gt;'' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line&lt;/span&gt;
&lt;span&gt;  } }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新建路由 ( 在 router.js 中 )：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import Forms from './views/Forms.vue'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  routes: [
    { path: &lt;/span&gt;'/'&lt;span&gt;, .......},
    {
      path: &lt;/span&gt;'/form'&lt;span&gt;,
      name: &lt;/span&gt;'forms'&lt;span&gt;,
      component: Forms
    },
    { path: &lt;/span&gt;'/about'&lt;span&gt;, ......}
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就建立新的路由，这块我建立了新的 git commit。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意&lt;/span&gt;：组件名称尽量满足以下要求：1、勿采用 HTML 标签名；2、勿采用 vue 内部保留的名称如 slot ( 插槽 )、partial、component等。3、以字母开头。更加详细的组件命名内容请参见：&lt;a href=&quot;https://cnodejs.org/topic/5816aabdcf18d0333412d323&quot; target=&quot;_blank&quot;&gt;https://cnodejs.org/topic/5816aabdcf18d0333412d323&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;文本表单&lt;/h3&gt;
&lt;p&gt;贴个代码，具体的使用方法不多介绍：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;&amp;lt;div class=&quot;form&quot;&amp;gt;
  &amp;lt;input v-model=&quot;message1&quot; placeholder=&quot;单行文本&quot;&amp;gt;
  &amp;lt;p&amp;gt;单行文本: {{ message1 }}&amp;lt;/p&amp;gt;

  &amp;lt;span&amp;gt;多行文本:&amp;lt;/span&amp;gt;
  &amp;lt;p&amp;gt;{{ message2 }}&amp;lt;/p&amp;gt;
  &amp;lt;textarea v-model=&quot;message2&quot; placeholder=&quot;多行文本&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'forms', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line&lt;/span&gt;
  data: &lt;span&gt;function&lt;/span&gt; () { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; { 
    message1: &lt;/span&gt;''&lt;span&gt;,
    message2: &lt;/span&gt;'差值' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line&lt;/span&gt;
&lt;span&gt;  } }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是：&amp;lt;textarea v-model=&quot;message2&quot; placeholder=&quot;多行文本&quot;&amp;gt;&lt;span&gt;{{ someProp }}&lt;/span&gt;&amp;lt;/textarea&amp;gt; 中的红色部分无效。&lt;/p&gt;
&lt;h3&gt;选择框&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;cd&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;color:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单选框：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;cd&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;cd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ checked1 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;jack&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;color:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;复选集合：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name1&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;章三&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;name1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;章三&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name2&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;里斯&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;name2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;里斯&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;name3&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;王五&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checkedNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;name3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;王五&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;所选的人有: {{ checkedNames }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单选集合：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;nan&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;男&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;nan&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;男&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;radio&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;nv&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;女&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;picked&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;nv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;女&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;性别是: {{ picked }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单选下拉框：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;disabled value&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请选择&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选择的是: {{ selected1 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color:green&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;多选下拉框：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;v-model&lt;/span&gt;&lt;span&gt;=&quot;selected2&quot;&lt;/span&gt;&lt;span&gt; multiple style&lt;/span&gt;&lt;span&gt;=&quot;width: 50px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;B&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选择的是: {{ selected2 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'forms', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line&lt;/span&gt;
  data: &lt;span&gt;function&lt;/span&gt; () { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    checked1: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    checkedNames: [],
    picked: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    selected1: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    selected2: [],
    message1: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    message2: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eslint-disable-next-line&lt;/span&gt;
&lt;span&gt;  } }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：尽管有的选择框，无须在 data 属性中也声明同样的属性，但别这么做，任何选择框的属性，都应该在 &lt;span&gt;data 声明该属性&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于多选框，也可以采用 v-for 来循环显示，读者可自行实验。&lt;/p&gt;
&lt;h3&gt;值绑定&lt;/h3&gt;
&lt;p&gt;上面介绍那些选择框，属性绑定的默认的值。对此先来看看下面这个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;cd&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;checked1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;cd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ checked1 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input
  &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;checkbox&quot;&lt;/span&gt;&lt;span&gt;
  id&lt;/span&gt;&lt;span&gt;=&quot;cd1&quot;&lt;/span&gt;&lt;span&gt;
  v-model&lt;/span&gt;&lt;span&gt;=&quot;checked11&quot;&lt;/span&gt;&lt;span&gt;
  true-value&lt;/span&gt;&lt;span&gt;=&quot;有效&quot;&lt;/span&gt;&lt;span&gt;
  false-value&lt;/span&gt;&lt;span&gt;=&quot;无效&quot;&lt;/span&gt;
&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;cd1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ checked11 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子，是系统默认的，选中之后 checked1 是 true。下面就是修改了选中之后，属性 checked11 对应的值，也就是【有效】。&lt;/p&gt;
&lt;p&gt;再比如：&amp;lt;label style=&quot;color:green&quot;&amp;gt;绑定到a：&amp;lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; &lt;span&gt;v-bind:value=&quot;a&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;&lt;/p&gt;
&lt;p&gt;其中 v-bind:value=&quot;a&quot; 意思：选中之后，data.pick = data.a 。在 js 中 data 必须要设置这两个属性，且 a 要有初始值。&lt;/p&gt;
&lt;p&gt;可以绑定到对象：&amp;lt;label style=&quot;color:green&quot;&amp;gt;绑定到对象：&amp;lt;input type=&quot;radio&quot; v-model=&quot;pick1&quot; &lt;span&gt;v-bind:value=&quot;{a:1}&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;&lt;/p&gt;
&lt;p&gt;也可以：&amp;lt;label style=&quot;color:green&quot;&amp;gt;绑定到对象：&amp;lt;input type=&quot;radio&quot; v-model=&quot;pick1&quot; &lt;span&gt;v-bind:value=&quot;obj&quot;&lt;/span&gt;&amp;gt;&amp;lt;/label&amp;gt;&lt;/p&gt;
&lt;p&gt;对于所有的上面介绍的表单，都可以采用这种值绑定，限于篇幅，不一一介绍。&lt;/p&gt;
&lt;h3&gt;最后还有 - 修饰符&lt;/h3&gt;
&lt;p&gt;.lazy   .number   .trim&lt;/p&gt;
&lt;p&gt;.lazy 改变 input 和 textarea 输入框的更新模式。上面的两个输入框的例子，都是在敲键盘&lt;span&gt;一边输入一边更新&lt;/span&gt;；加入这个之后，变成&lt;span&gt;失去焦点才会更新&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;.number 则是将强制输入转换为 Number 类型。&lt;/p&gt;
&lt;p&gt;.trim 去掉输入的字符串空格 ( 注意：加入之后，不但首尾的空格会去掉，中间部分&lt;span&gt;连续多个空格&lt;/span&gt;会替换为&lt;span&gt;单个空格&lt;/span&gt; )。&lt;/p&gt;
&lt;p&gt;比如如下例子： &amp;lt;textarea v-model.trim=&quot;message2&quot; placeholder=&quot;多行文本&quot;&amp;gt;&amp;lt;/textarea&amp;gt;&lt;/p&gt;
&lt;p&gt;=================&lt;/p&gt;
&lt;p&gt;关于组件内部的基础功能 ( 表单、指令、绑定、属性 ) 已经简单了解熟悉，深入的理解需要在运用过程中不断加深。后面的学习将进一步理解 MVC 框架的核心概念之一 【组件】。本文代码都已更新至 github。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 06:38:00 +0000</pubDate>
<dc:creator>nDos</dc:creator>
<og:description>vue3.0 CLI 真小白一步一步入手全教程系列：https://www.cnblogs.com/ndos/category/1295752.html 我的 github 地址 - vue</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ndos/p/9617526.html</dc:identifier>
</item>
<item>
<title>HashMap源码分析 - 吴庆龙</title>
<link>http://www.cnblogs.com/wuqinglong/p/9640159.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuqinglong/p/9640159.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;


&lt;p&gt;HashMap是一种key/value形式的存储结构. 它综合了数组(查询容易, 插入和删除困难)和链表(插入和删除容易, 查询困难)的特点.&lt;/p&gt;
&lt;p&gt;HashMap的核心点就是&lt;strong&gt;hash算法&lt;/strong&gt;和&lt;strong&gt;红黑树算法&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;HashMap是&lt;strong&gt;无序的&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;HashMap的存储结构为&lt;strong&gt;数组 + 链表/红黑树&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;其中数组就是普通的数组, 链表是为了解决hash冲突而产生的, 如果冲突元素大于指定值, 就会由链表变为红黑树, 如果冲突元素少于指定的值, 就会由红黑树变为链表.&lt;/p&gt;
&lt;h2 id=&quot;什么是hash冲突&quot;&gt;2-1. 什么是hash冲突?&lt;/h2&gt;
&lt;p&gt;当产生hash冲突的时候就产生了链表或红黑树, 一个完美的HashMap是单纯的数组结构, 并不会存在链表或红黑树结构的, 不过完美的事是不存在的, 只能尽可能的接近完美.&lt;/p&gt;
&lt;p&gt;假设元素A被成功的添加到HashMap中, 存储在数组下标为0的地方, 这时元素B要被添加进来, 但是经过hash算法计算, 元素B要也要存储在数组下标为0的地方上, 这时候就产生了hash冲突.&lt;/p&gt;
&lt;h2 id=&quot;如何解决hash冲突&quot;&gt;2-2. 如何解决hash冲突?&lt;/h2&gt;
&lt;p&gt;出现了hash冲突, 解决方法就是在数组下标0处, 产生一个链表, 元素A为链表的表头, 新元素B放到链表的尾部.&lt;/p&gt;
&lt;h2 id=&quot;负载因子的作用&quot;&gt;2-3. 负载因子的作用&lt;/h2&gt;
&lt;p&gt;是这样的, 默认负载因子是0.75, 也就是HashMap中的数组填满了75%之后就会进行扩容.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果负载因子过大, 则会导致hash冲突的机会越大, 但是空间使用率高;&lt;/li&gt;
&lt;li&gt;如果负载因子过小, 则会导致空间的过度浪费, 但是hash冲突的机会越小.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以, 必须在冲突的机会和空间利用率之间寻求一种平衡, 这种平衡本质上是数据结构中有名的时间和空间的平衡.&lt;/p&gt;
&lt;h2 id=&quot;hashmap的数组容量桶容量为什么必须是2的幂次方&quot;&gt;2-4. HashMap的数组容量(桶容量)为什么必须是2的幂次方?&lt;/h2&gt;
&lt;p&gt;首先给出答案: 为了使元素坐落于HashMap的承载量(size)之间.&lt;/p&gt;
&lt;p&gt;答案和问题看起来毫无关系, 下面来分析一下是如何联系在一起的?&lt;/p&gt;
&lt;p&gt;比如: 把&quot;1&quot;存入HashMap中, 会进行如下几步&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;计算key的hashCode(key.hashCode()), 得到h&lt;/li&gt;
&lt;li&gt;然后对h进行低16位和高16位的异或运算, 得到hash (异或运算: 两个值不同为1, 相同为0)&lt;/li&gt;
&lt;li&gt;然后进行 (size - 1) &amp;amp; hash 的运算得到 (与运算: 只要有一个为1, 结果就是1)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二步中的低16位与高16位进行运算是为了更好的进行散列(如果两个元素的低16位相同, 不进行高低16位运算的话, 出现hash冲突的机会就会变大), 高低16位运算之后, 可以减少hash冲突的机会.&lt;/p&gt;
&lt;p&gt;最重要的就是第三步了, 也就是问题的答案, 如果桶容量大小是2的倍数(默认值16), 进行(size - 1)运算之后的值为15, 15的二进制为0001111, 15与第二步得到的hash进行运算后, 只会保留低4位的值, 高于4位的值都被去掉了(运算后为0). 既然只有低4位的值, 那么转化为十进制之后, 必然小于16, 正确的坐落于桶上. 完美!&lt;/p&gt;

&lt;p&gt;只说这个比较重要的构造函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                           initialCapacity);
    if (initialCapacity &amp;gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的负载因子为: DEFAULT_LOAD_FACTOR(0.75).&lt;/p&gt;
&lt;p&gt;用户自定义初始化容量, 但是HashMap会对传入的初始化容量进行校验(tableSizeFor), 需要确保这个值必须是2的幂次方.&lt;/p&gt;

&lt;h2 id=&quot;添加&quot;&gt;4-1. 添加&lt;/h2&gt;
&lt;p&gt;添加操作分为三种情况:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在数组上添加&lt;/li&gt;
&lt;li&gt;在链表上添加&lt;/li&gt;
&lt;li&gt;在红黑树上添加(比较菜, 不做讨论)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;在数组上添加&quot;&gt;4-1-1. 在数组上添加&lt;/h3&gt;
&lt;p&gt;所谓在数组上添加, 就是没有发生hash冲突的情况下进行元素的添加, 这是最好的情况.&lt;/p&gt;
&lt;h3 id=&quot;在链表上添加&quot;&gt;4-1-2. 在链表上添加&lt;/h3&gt;
&lt;p&gt;在链表上添加, 出现了hash冲突, 元素会被添加到链表的尾端&lt;/p&gt;
&lt;h3 id=&quot;在红黑树上添加&quot;&gt;4-1-3. 在红黑树上添加&lt;/h3&gt;
&lt;p&gt;在红黑树上添加, 就是冲突的元素太多了, 链表的长度大于了指定的长度, 由于对链表的查询比较耗性能, 所以会转变为红黑树.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有红黑树生成的情况下是HashMap性能最差的情况.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加源码如下&quot;&gt;添加源码如下&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {

    HashMap.Node&amp;lt;K,V&amp;gt;[] tab; // 引用HashMap的table
    HashMap.Node&amp;lt;K,V&amp;gt; p; // HashMap中的一个节点
    int n, i; // n:HashMap中元素的个数; i:新元素的在数组中的下标

    // 如果table没有进行初始化, 先进行初始化操作
    if ((tab = table) == null || (n = tab.length) == 0) {
        n = (tab = resize()).length;
    }

    // 通过上面的说明: (n - 1) &amp;amp; hash 这段代码就是进行数组下标的运算
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null) {
        // 这是最好的情况: 没有出现hash冲突, 直接在创建一个节点放到该位置上
        tab[i] = newNode(hash, key, value, null);
    } else {
        // 出现了hash冲突, 需要区分几种情况: 
        // 1. 判断p的hash, key是否与传入的相同, 如果相同, 则默认会使用传入的value替换原先的value值.
        // 2. 如果有不同, 判断p节点是否是树, 如果是, 则进行红黑树的添加操作.
        // 3. 如果有不同, 并且不是树, 则只能是链表, 使用循环找到链表的最后一个元素, 链接在链表的尾部, 如果链表的长度大于一定长度, 就会由链表变为红黑树
        HashMap.Node&amp;lt;K,V&amp;gt; e;
        K k;

        // 这里比较了 hash, key 是否相同
        if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) {
            e = p;
        } else if (p instanceof HashMap.TreeNode) {
            // 进行红黑树的添加操作
            e = ((HashMap.TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        } else {
            // 循环找到链表的最后一个元素, 并进行计数
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    // 链接到最后一个元素
                    p.next = newNode(hash, key, value, null);
                    // 判断是否需要转为红黑树
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) { // -1 for 1st
                        treeifyBin(tab, hash);
                    }
                    
                    // 找到最后一个元素后即退出
                    break;
                }
                
                // 每次循环时都要判断一下链表上元素的hash, key是否与传入的相同, 如果相同, 则默认会使用传入的value替换原先的value值.
                // 相同时, e对象即为冲突元素
                if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                    break;
                }
                p = e;
            }
        }
        
        // 如果e不为空, 则表示发生了冲突
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null) {
                e.value = value;
            }
            // 这个在HashMap中实现为空, LinkedHashMap需要实现它
            afterNodeAccess(e);
            return oldValue;
        }
    }

    // HashMap结构的改变次数
    ++modCount;

    // 判断是否需要扩容
    if (++size &amp;gt; threshold) {
        resize();
    }

    // 这个在HashMap中实现为空, LinkedHashMap需要实现它
    afterNodeInsertion(evict);
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除&quot;&gt;4-2. 删除&lt;/h2&gt;
&lt;p&gt;由HashMap的数据结构可以想得到, 删除分为三种情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在数组上删除, 这种情况是最简单的, 只需指向null即可.&lt;/li&gt;
&lt;li&gt;在链表上删除, 由于链表对删除比较擅长, 直接让&lt;/li&gt;
&lt;li&gt;在红黑树上删除, 母鸡呀.&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;删除源码如下&quot;&gt;4-2-1. 删除源码如下&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implements Map.remove and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to match if matchValue, else ignored
 * @param matchValue if true only remove if value is equal
 * @param movable if false do not move other nodes while removing
 * @return the node, or null if none
 */
final Node&amp;lt;K,V&amp;gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&amp;lt;K,V&amp;gt;[] tab; 
    Node&amp;lt;K,V&amp;gt; p; 
    int n, index;
    
    // 计算得到数组的下标, 判断是否有元素
    if ((tab = table) != null &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
        (p = tab[index = (n - 1) &amp;amp; hash]) != null) {
        
        Node&amp;lt;K,V&amp;gt; node = null, e; 
        K k; 
        V v;
        
        // hash, key相同, 说明要删除该元素, 这种情况: node = p
        if (p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) {
            node = p;
        } else if ((e = p.next) != null) { // 如果hash,key不同, 判断是否有下一个元素
        
            // 如果下一个元素的节点类型是 TreeNode, 则去获取红黑树的节点
            if (p instanceof TreeNode)
                node = ((TreeNode&amp;lt;K,V&amp;gt;)p).getTreeNode(hash, key);
            else {
                // 是链表, 循环, 依次判断链表上的元素的hash和key是否相同, 找到即退出.
                do {
                    if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    // p的值永远是相同节点的上一个节点
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        
        // 上面只是进行元素的查找, 这里才是真正的删除
        if (node != null &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;amp;&amp;amp; value.equals(v)))) {
                             
            // 红黑树的删除
            if (node instanceof TreeNode)
                ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(this, tab, movable);
                
            // 数组上的删除
            else if (node == p)
                tab[index] = node.next;
                
            // 链表上的删除
            else
                p.next = node.next;
                
            // 记录集合元素改变次数
            ++modCount;
            
            // 集合元素数量减1
            --size;
            
            // 这个在HashMap中实现为空, LinkedHashMap需要实现它
            afterNodeRemoval(node);
            
            // 返回删除的节点, 具体返回删除节点的value值.
            return node;
        }
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询&quot;&gt;4-3. 查询&lt;/h2&gt;
&lt;p&gt;通过分析上面的删除操作, 很明显, 在删除操作的前半部分是一个常规的查询操作.&lt;/p&gt;
&lt;h2 id=&quot;替换&quot;&gt;4-4. 替换&lt;/h2&gt;
&lt;p&gt;替换操作也可以想象的到, 先找到要替换的元素(就是查询操作), 然后把value替换了即可.&lt;/p&gt;

&lt;p&gt;HashMap的的遍历有几种&lt;/p&gt;
&lt;h2 id=&quot;使用foreach进行遍历&quot;&gt;5-1. 使用foreach进行遍历&lt;/h2&gt;
&lt;p&gt;实际上这种方式被编译之后是Iterator的方式.&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;HashMap&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
for (Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()) {
    System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;反编译class文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;HashMap&amp;lt;String, String&amp;gt; map = new HashMap();
Iterator var2 = map.entrySet().iterator();
while(var2.hasNext()) {
    Entry&amp;lt;String, String&amp;gt; entry = (Entry)var2.next();
    System.out.println((String)entry.getKey() + &quot;:&quot; + (String)entry.getValue());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到实际上是使用的entrySet().iterator()的方式, 语法糖?&lt;/p&gt;
&lt;h2 id=&quot;使用keyset进行遍历&quot;&gt;5-2. 使用keySet进行遍历&lt;/h2&gt;
&lt;p&gt;这种方式不如使用foreach的性能好, 可以发现, 这种方式还要进行一次map.get(key)操作.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Iterator&amp;lt;String&amp;gt; iterator = map.keySet().iterator();
while (iterator.hasNext()) {
    String key = iterator.next();
    System.out.println(key + &quot;:&quot; + map.get(key));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;遍历所有的key&quot;&gt;5-3. 遍历所有的key&lt;/h2&gt;
&lt;p&gt;这种方式就可以简单的通过map.keySet()进行实现.&lt;/p&gt;
&lt;h2 id=&quot;遍历所有的value&quot;&gt;5-4. 遍历所有的value&lt;/h2&gt;
&lt;p&gt;这种方式可以通过map.values()进行获取.&lt;/p&gt;

&lt;p&gt;这是一个比较重要的点, 扩容的同时还会带有rehash操作.&lt;/p&gt;
&lt;p&gt;正常状态下, 会进行2倍扩容.&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Initializes or doubles table size.  If null, allocates in
 * accord with initial capacity target held in field threshold.
 * Otherwise, because we are using power-of-two expansion, the
 * elements from each bin must either stay at same index, or move
 * with a power of two offset in the new table.
 * 
 * @return the table
 */
final Node&amp;lt;K,V&amp;gt;[] resize() {

    // 获取桶引用
    Node&amp;lt;K,V&amp;gt;[] oldTab = table;
    
    // new HashMap()时oldCap=0
    // 有元素时, oldCap即为oldTab.length
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    
    // new HashMap()时threshold为0
    // 有元素时, threshold为桶长度的0.75
    int oldThr = threshold;
    
    // 定义新的桶容量, 新的threshold
    int newCap, newThr = 0;
    
    // new HashMap()时不会进入if
    // 有元素时, 旧桶的容量大于0, 会进入
    if (oldCap &amp;gt; 0) {
        
        // 旧桶的容量是否大于MAXIMUM_CAPACITY(1 &amp;lt;&amp;lt; 30, 也就是Integer.MAX_VALUE / 2 + 1)
        // 直接返回 Integer.MAX_VALUE, 这里校验是防止 oldCap * 2 之后发生整型溢出.
        if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        
        // 新桶的大小是旧桶大小的2倍(2倍扩容).
        else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
                // 旧桶的长度大于等于16了
                oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY) {
                 
            // 2倍, 桶的长度扩大2倍,threshold也同时扩大2倍, 保持0.75不变.
            newThr = oldThr &amp;lt;&amp;lt; 1; // double threshold
        }
    }
    
    // oldCap = 0 &amp;amp; oldThr &amp;gt; 0; 这种情况是使用 new HashMap(int initialCapacity) 
    // 或 new HashMap(int initialCapacity, float loadFactor)产生的
    else if (oldThr &amp;gt; 0) { // initial capacity was placed in threshold
        newCap = oldThr;
    }
        
    // new HashMap()时, 走这里
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY; // 16
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  // 16 * 0.75 = 12
    }
    
    // 如果newThr还是为0, 可能是走了else if (oldThr &amp;gt; 0)这个条件
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    
    // new HashMap()时 threshold = 12
    threshold = newThr;
    
    // 根据newCap创建新的桶
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
    Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
    
    // 改变table的指向
    table = newTab;
    
    // 进行旧桶中元素的rehash
    if (oldTab != null) {
        
        // 循环整个旧数组(桶)
        for (int j = 0; j &amp;lt; oldCap; ++j) {
            
            // 临时存储当前节点
            Node&amp;lt;K,V&amp;gt; e;
            
            // 节点不为null, 进行处理
            if ((e = oldTab[j]) != null) {
            
                // 先将桶的该位置置为null
                oldTab[j] = null;
            
                // 如果该节点的next属性为null, 说明这个节点处既没有链表也没有红黑树.
                // 直接用其hash值与新数组的长度进行一次与运算, 得到新的下标, 将该元素填充到这里
                if (e.next == null) {
                    newTab[e.hash &amp;amp; (newCap - 1)] = e;
                }
                
                // 如果该节点是树节点, 进行相关的操作
                else if (e instanceof TreeNode) {
                    ((TreeNode&amp;lt;K,V&amp;gt;)e).split(this, newTab, j, oldCap);
                }

                // 是链表
                else { // preserve order
                
                    // 将原先的一条链表拆分为两条链表
                    Node&amp;lt;K,V&amp;gt; loHead = null, loTail = null;
                    Node&amp;lt;K,V&amp;gt; hiHead = null, hiTail = null;
                    Node&amp;lt;K,V&amp;gt; next;
                    do {
                        
                        // 获取当前节点的下一个节点
                        next = e.next;
                        
                        // 构造计算之后等于0的一条链表
                        if ((e.hash &amp;amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        
                        // 构造计算之后不等于0的一条链表
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    
                    // 等于0的这条链表放在原先的位置不变
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    
                    // 不等于0的这条链表放在 j+oldCap 的位置上
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;ol&gt;&lt;li&gt;HashMap是无序的, 有序的Map可以参考LinkedHashMap.&lt;/li&gt;
&lt;li&gt;HashMap是线程不安全的, 安全的Map可以参考ConcurrentHashMap.&lt;/li&gt;
&lt;li&gt;HashMap的存储结构是&lt;strong&gt;数组 + 链表/红黑树&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;不要随便更改HashMap的负载因子: loadFactor.&lt;/li&gt;
&lt;li&gt;遍历HashMap时, 尽可能使用foreach语法或者使用entry().iterator().&lt;/li&gt;
&lt;li&gt;HashMap扩容是2倍扩容, 并且伴随着rehash操作.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不要因为知识简单就忽略, 不积跬步无以至千里.&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 06:04:00 +0000</pubDate>
<dc:creator>吴庆龙</dc:creator>
<og:description>目录 [TOC] 1. 概述 HashMap是一种key/value形式的存储结构. 它综合了数组(查询容易, 插入和删除困难)和链表(插入和删除容易, 查询困难)的特点. HashMap的核心点就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuqinglong/p/9640159.html</dc:identifier>
</item>
<item>
<title>spring cloud连载第二篇之Spring Cloud Config - CLAYJJ</title>
<link>http://www.cnblogs.com/CLAYJJ/p/9633109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CLAYJJ/p/9633109.html</guid>
<description>&lt;p&gt;Spring Cloud Config为分布式服务提供了服务侧和客户侧的外部配置支持。通过Spring Cloud Config你可以有一个统一的地方来管理所有应用的外部配置。&lt;/p&gt;
&lt;p&gt;默认服务端存储实现用的是git，因此，它很容易支持配置环境的标签版本，并且可以访问各种管理内容的工具。&lt;/p&gt;

&lt;h2 class=&quot;title&quot;&gt;1. Quick Start&lt;/h2&gt;
&lt;p&gt;此小结将介绍Spring Cloud Config Server的客户端和服务端。&lt;/p&gt;
&lt;p&gt;首先，启动服务端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $ cd spring-cloud-config-&lt;span&gt;server
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; $ ../mvnw spring-boot:run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着试一下客户端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $ curl localhost:8888/foo/&lt;span&gt;development
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; {&quot;name&quot;:&quot;foo&quot;,&quot;label&quot;:&quot;master&quot;,&quot;propertySources&quot;&lt;span&gt;:[
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   {&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;,&quot;source&quot;:{&quot;bar&quot;:&quot;spam&quot;&lt;span&gt;}},
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   {&quot;name&quot;:&quot;https://github.com/scratches/config-repo/foo.properties&quot;,&quot;source&quot;:{&quot;foo&quot;:&quot;bar&quot;&lt;span&gt;}}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; ]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认定位属性资源的策略是使用git（spring.cloud.config.server.git.uri），并且用它来初始化一个迷你SpringApplication，这个迷你application的Environment是用来枚举属性资源并将它发布到一个JSON端点。&lt;/p&gt;
&lt;p&gt;HTTP服务的格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; /{application}/{profile}[/&lt;span&gt;{label}]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /{application}-&lt;span&gt;{profile}.yml
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; /{label}/{application}-&lt;span&gt;{profile}.yml
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; /{application}-&lt;span&gt;{profile}.properties
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; /{label}/{application}-{profile}.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中application是是使用spring.config.name属性注入的，profile是一个激活的配置文件（或者是以逗号分隔的属性），label是一个可选的git标签（默认是master）。&lt;/p&gt;
&lt;p&gt;Spring Cloud Config Server从git仓库为客户端拉取配置，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;title&quot;&gt;1.1 Client Side Usage（客户端用法）&lt;/h2&gt;
&lt;p&gt;要在一个应用中使用这些特性，你可以构建一个Spring Boot application并且添加spring-cloud-config-client相关的依赖，最方便的方法是添加org.springframework.cloud:spring-cloud-starter-config依赖。&lt;/p&gt;
&lt;p&gt;下面是一个典型的maven配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;parent&amp;gt;
&lt;span&gt; 2&lt;/span&gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt; 3&lt;/span&gt;        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;        &amp;lt;version&amp;gt;{spring-boot-docs-version}&amp;lt;/version&amp;gt;
&lt;span&gt; 5&lt;/span&gt;        &amp;lt;relativePath /&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
&lt;span&gt; 6&lt;/span&gt;    &amp;lt;/parent&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &amp;lt;dependencyManagement&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;dependencies&amp;gt;
&lt;span&gt;10&lt;/span&gt;         &amp;lt;dependency&amp;gt;
&lt;span&gt;11&lt;/span&gt;             &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&lt;span&gt;12&lt;/span&gt;             &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
&lt;span&gt;13&lt;/span&gt;             &amp;lt;version&amp;gt;{spring-cloud-version}&amp;lt;/version&amp;gt;
&lt;span&gt;14&lt;/span&gt;             &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
&lt;span&gt;15&lt;/span&gt;             &amp;lt;scope&amp;gt;&lt;span&gt;import&lt;/span&gt;&amp;lt;/scope&amp;gt;
&lt;span&gt;16&lt;/span&gt;         &amp;lt;/dependency&amp;gt;
&lt;span&gt;17&lt;/span&gt;     &amp;lt;/dependencies&amp;gt;
&lt;span&gt;18&lt;/span&gt; &amp;lt;/dependencyManagement&amp;gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &amp;lt;dependencies&amp;gt;
&lt;span&gt;21&lt;/span&gt;     &amp;lt;dependency&amp;gt;
&lt;span&gt;22&lt;/span&gt;         &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
&lt;span&gt;23&lt;/span&gt;         &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
&lt;span&gt;24&lt;/span&gt;     &amp;lt;/dependency&amp;gt;
&lt;span&gt;25&lt;/span&gt;     &amp;lt;dependency&amp;gt;
&lt;span&gt;26&lt;/span&gt;         &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt;27&lt;/span&gt;         &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
&lt;span&gt;28&lt;/span&gt;         &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&lt;span&gt;29&lt;/span&gt;     &amp;lt;/dependency&amp;gt;
&lt;span&gt;30&lt;/span&gt; &amp;lt;/dependencies&amp;gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &amp;lt;build&amp;gt;
&lt;span&gt;33&lt;/span&gt;     &amp;lt;plugins&amp;gt;
&lt;span&gt;34&lt;/span&gt;            &amp;lt;plugin&amp;gt;
&lt;span&gt;35&lt;/span&gt;                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
&lt;span&gt;36&lt;/span&gt;                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
&lt;span&gt;37&lt;/span&gt;            &amp;lt;/plugin&amp;gt;
&lt;span&gt;38&lt;/span&gt;     &amp;lt;/plugins&amp;gt;
&lt;span&gt;39&lt;/span&gt; &amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以创建一个标准的Spring Boot application，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     @RequestMapping(&quot;/&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String home() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Hello World!&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         SpringApplication.run(Application.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当这个HHTP服务启动时，它默认从本地的config server（端口8888）加载配置，可以使用bootstrap.properties配置来改变这个默认行为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; spring.cloud.config.uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myconfigserver.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用/env端点来查看bootstrap properties配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $ curl localhost:8080/&lt;span&gt;env
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &quot;profiles&quot;&lt;span&gt;:[],
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   &quot;configService:https://github.com/spring-cloud-samples/config-repo/bar.properties&quot;:{&quot;foo&quot;:&quot;bar&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &quot;servletContextInitParams&quot;&lt;span&gt;:{},
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   &quot;systemProperties&quot;&lt;span&gt;:{...},
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;  ...
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;title&quot;&gt;2. Spring Cloud Config Server（配置服务器的服务端）&lt;/h2&gt;
&lt;p&gt;Spring Cloud Config Server为外部配置提供一个基于资源的HTTP API。使用注解@EnableConfigServer可以在一个Spring Boot application中嵌入配置服务器。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@EnableConfigServer
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServer {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     SpringApplication.run(ConfigServer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最简单的方法是通过属性spring.config.name=configserver启动，因为在config server的jar中有一个configserver.yml配置文件，它已经设置好了默认的配置仓库。&lt;/p&gt;
&lt;p&gt;或者你可以使用自己的配置：application.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; server.port: 8888
&lt;span&gt;2&lt;/span&gt; spring.cloud.config.server.git.uri: file:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${user.home}/config-repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中${user.home}/config-repo是一个包含YAML或者properties格式配置文件的git仓库。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1）在windows上，你需要在file url前多添加一个“/”，如果是绝对路径的话。（例如：&lt;a class=&quot;link&quot; target=&quot;_top&quot;&gt;file:///${user.home}/config-repo&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;2）使用本地仓库只是为了演示和测试使用，在正式环境中需要使用一台服务器来管理配置&lt;/p&gt;
&lt;p&gt;3）初始化克隆配合仓库在只有一个文件时可能比较快，但是如果存储一个二进制文件，特别是比较大的文件时，可能在第一次请求配置时有延迟甚至可能导致服务端内存溢出。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;2.1 Environment Repository&lt;/h2&gt;
&lt;p&gt;在config server中我们应该将配置存储在什么地方？掌控这个行为的策略的就是为Environment对象服务的EnvironmentRepository。&lt;/p&gt;
&lt;p&gt;Environment资源由一下三个变量参数化：&lt;/p&gt;
&lt;p&gt;1）{application} 对应客户端的spring.application.name&lt;/p&gt;
&lt;p&gt;2）{profile} 对应客户端的spring.profiles.active（以逗号分隔）&lt;/p&gt;
&lt;p&gt;3）{label} 它是服务器端功能标签“版本化”的配置文件集&lt;/p&gt;
&lt;p&gt;Repository的实现通常像一个spring boot application，从一个和{application}相等的spring.config.name参数和与{profiles}相等的spring.profiles.active参数指定的文件来加载配置。&lt;/p&gt;
&lt;p&gt;优先级策略和普通spring boot 的应用一样：Active profiles优先级比默认的高，如果有多个profiles，那么最后一个优先级最高。下面是客户端bootstrap 配置bootstrap.yml：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  application:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    name: foo
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  profiles:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     active: dev,mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（和一般Spring Boot application一样，这些参数也可以在环境变量或者命令行参数中指定）&lt;/p&gt;
&lt;h3 class=&quot;title&quot;&gt;2.1.1 Git Backend&lt;/h3&gt;
&lt;p&gt;在config server中使用spring.cloud.config.server.git.uri来设置仓库位置，如果uri是以file:开头，则是本地仓库。&lt;/p&gt;
&lt;p&gt;但是如果要扩展config server并且高可用的话，必须使所有服务器实例指向同一个仓库。因此需要一个共享的文件系统。在这种情况下，使用ssh协议是比较好的，这样服务器可以克隆一份配置到本地作为缓存使用。&lt;/p&gt;
&lt;p&gt;仓库的实现是将HTTP路径中的{label}映射到一个git标签（commit id, branch name, or tag），如果一个git分支或者标签中包含“/”斜杠，那么在HTTP url中需要用一个特殊字符(_)来替代，以免发生混淆。&lt;/p&gt;
&lt;p&gt;比如标签为foo/bar，则应该替换成：foo(_)bar。这个规则同样可应用到{application}参数上。&lt;/p&gt;
&lt;h4 class=&quot;title&quot;&gt;Skipping SSL Certificate Validation（跳过ssl验证）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;example.com/my/repo&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;           skipSslValidation: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;title&quot;&gt;Setting HTTP Connection Timeout（设置HTTP连接超时时间，以秒为单位）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  cloud:
    config:
      server:
        git:
          uri: https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;example.com/my/repo&lt;/span&gt;
          timeout: 4
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;title&quot;&gt;Placeholders in Git URI（git URI中的占位符）&lt;/h4&gt;
&lt;p&gt;Spring Cloud Config Server支持git URI中的占位符为：{application}，{profile}，{label}（记住label是作为git 的标签使用的）。通过下面的配置你可以支持每个应用一个仓库的策略：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/myorg/{application}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;title&quot;&gt;Pattern Matching and Multiple Repositories（规则匹配和多仓库）&lt;/h4&gt;
&lt;p&gt;Spring Cloud Config包含对application和profile名称的规则匹配支持，规则格式是包含通配符的以逗号分隔的{application}/{profile}名称。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;          repos:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             simple: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/simple/config-repo&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            special:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;               pattern: special*/dev*,*special*/dev*
&lt;span&gt;11&lt;/span&gt;               uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/special/config-repo&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            local:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;               pattern: local*
&lt;span&gt;14&lt;/span&gt;               uri: file:/home/configsvc/config-repo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果{application}/{profile}不匹配任何一个规则，则使用spring.cloud.config.server.git.uri下面的默认URI。在上面的例子中，匹配“simple”仓库的规则是simple/*（{application}为simple，{profile}为任意值）。“local”仓库匹配任何一个以local开头的应用名称，如果没有指定{profile}规则，则会自动在规则后面添加“/*”。&lt;/p&gt;
&lt;p&gt;由于pattern参数实际上是一个数组，所以使用YAML数组（或者在.properties文件中使用[0], [1]等后缀）来绑定多种规则。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;          repos:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            development:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;              pattern:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 - '*/development'
&lt;span&gt;11&lt;/span&gt;                 - '*/staging'
&lt;span&gt;12&lt;/span&gt;               uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/development/config-repo&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            staging:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;              pattern:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 - '*/qa'
&lt;span&gt;16&lt;/span&gt;                 - '*/production'
&lt;span&gt;17&lt;/span&gt;               uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/staging/config-repo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个仓库都可以在子目录中存储配置文件，如果要在子目录中搜索则需要使用searchPaths配置。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;           searchPaths: foo,bar*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，服务器将会在顶级目录和foo子目录还有以bar开头的子目录中搜索配置文件。&lt;/p&gt;
&lt;p&gt;默认情况下，服务器会在第一次收到配置请求时，克隆远程仓库。也可以在服务启动时克隆远程仓库，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/common/config-repo.git&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;          repos:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             team-&lt;span&gt;a:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 pattern: team-a-*
&lt;span&gt;10&lt;/span&gt;                 cloneOnStart: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/team-a/config-repo.git&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             team-&lt;span&gt;b:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 pattern: team-b-*
&lt;span&gt;14&lt;/span&gt;                 cloneOnStart: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/team-b/config-repo.git&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             team-&lt;span&gt;c:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 pattern: team-c-*
&lt;span&gt;18&lt;/span&gt;                 uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/team-a/config-repo.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中只有team-a的远程仓库会在启动时克隆，其他的都是在第一次接受到配置请求时才克隆。&lt;/p&gt;
&lt;h4 class=&quot;title&quot;&gt;Authentication（用户验证）&lt;/h4&gt;
&lt;p&gt;添加username和password属性来使用远程仓库基于HTTP的验证。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;          username: trolley
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;           password: strongpassword
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不使用HTTPS和用户凭证，也可以使用SHH，在默认目录下存储key（~/.ssh），并且URI指向一个SSH地址（例如：git@github.com:configuration/cloud-configuration）。&lt;/p&gt;
&lt;h4 class=&quot;title&quot;&gt;Git SSH configuration using properties（使用属性配置GIT SSH）&lt;/h4&gt;
&lt;p&gt;SSH配置可以使用java属性来解决，spring.cloud.config.server.git.ignoreLocalSshSettings值必须设置为true。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    cloud:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;      config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        server:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;          git:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             uri: git@gitserver.com:team/&lt;span&gt;repo1.git
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             ignoreLocalSshSettings: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            hostKey: someHostKey
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             hostKeyAlgorithm: ssh-&lt;span&gt;rsa
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             privateKey: |
&lt;span&gt;11&lt;/span&gt;                          -----BEGIN RSA PRIVATE KEY-----
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                         MIIEpgIBAAKCAQEAx4UbaDzY5xjW6hc9jwN0mX33XpTDVW9WqHp5AKaRbtAC3DqX
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                          IXFMPgw3K45jxRb93f8tv9vL3rD9CUG1Gv4FM+o7ds7FRES5RTjv2RT/&lt;span&gt;JVNJCoqF
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                          ol8+ngLqRZCyBtQN7zYByWMRirPGoDUqdPYrj2yq+ObBBNhg5N+&lt;span&gt;hOwKjjpzdj2Ud
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                          1l7R+&lt;span&gt;wxIqmJo1IYyy16xS8WsjyQuyC0lL456qkd5BDZ0Ag8j2X9H9D5220Ln7s9i
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                         oezTipXipS7p7Jekf3Ywx6abJwOmB0rX79dV4qiNcGgzATnG1PkXxqt76VhcGa0W
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                         DDVHEEYGbSQ6hIGSh0I7BQun0aLRZojfE3gqHQIDAQABAoIBAQCZmGrk8BK6tXCd
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                          fY6yTiKxFzwb38IQP0ojIUWNrq0+9Xt+&lt;span&gt;NsypviLHkXfXXCKKU4zUHeIGVRq5MN9b
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                          BO56/RrcQHHOoJdUWuOV2qMqJvPUtC0CpGkD+&lt;span&gt;valhfD75MxoXU7s3FK7yjxy3rsG
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                          EmfA6tHV8/&lt;span&gt;4a5umo5TqSd2YTm5B19AhRqiuUVI1wTB41DjULUGiMYrnYrhzQlVvj
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                         5MjnKTlYu3V8PoYDfv1GmxPPh6vlpafXEeEYN8VB97e5x3DGHjZ5UrurAmTLTdO8
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                          +AahyoKsIY612TkkQthJlt7FJAwnCGMgY6podzzvzICLFmmTXYiZ/28I4BX/&lt;span&gt;mOSe
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                          pZVnfRixAoGBAO6Uiwt40/PKs53mCEWngslSCsh9oGAaLTf/&lt;span&gt;XdvMns5VmuyyAyKG
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                          ti8Ol5wqBMi4GIUzjbgUvSUt+&lt;span&gt;IowIrG3f5tN85wpjQ1UGVcpTnl5Qo9xaS1PFScQ
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                          xrtWZ9eNj2TsIAMp/svJsyGG3OibxfnuAIpSXNQiJPwRlW3irzpGgVx/&lt;span&gt;AoGBANYW
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                         dnhshUcEHMJi3aXwR12OTDnaLoanVGLwLnkqLSYUZA7ZegpKq90UAuBdcEfgdpyi
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                          PhKpeaeIiAaNnFo8m9aoTKr+7I6/&lt;span&gt;uMTlwrVnfrsVTZv3orxjwQV20YIBCVRKD1uX
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                         VhE0ozPZxwwKSPAFocpyWpGHGreGF1AIYBE9UBtjAoGBAI8bfPgJpyFyMiGBjO6z
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                          FwlJc/xlFqDusrcHL7abW5qq0L4v3R+FrJw3ZYufzLTVcKfdj6GelwJJO+8wBm+&lt;span&gt;R
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                          gTKYJItEhT48duLIfTDyIpHGVm9+&lt;span&gt;I1MGhh5zKuCqIhxIYr9jHloBB7kRm0rPvYY4
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                          VAykcNgyDvtAVODP+4m6JvhjAoGBALbtTqErKN47V0+&lt;span&gt;JJpapLnF0KxGrqeGIjIRV
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                         cYA6V4WYGr7NeIfesecfOC356PyhgPfpcVyEztwlvwTKb3RzIT1TZN8fH4YBr6Ee
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                          KTbTjefRFhVUjQqnucAvfGi29f+9oE3Ei9f7wA+H35ocF6JvTYUsHNMIO/&lt;span&gt;3gZ38N
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                          CPjyCMa9AoGBAMhsITNe3QcbsXAbdUR00dDsIFVROzyFJ2m40i4KCRM35bC/&lt;span&gt;BIBs
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                          q0TY3we+ERB40U8Z2BvU61QuwaunJ2+&lt;span&gt;uGadHo58VSVdggqAo0BSkH58innKKt96J
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                          69pcVH/4rmLbXdcmNYGm6iu+&lt;span&gt;MlPQk4BUZknHSmVHIFdJ0EPupVaQ8RHT
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                          -----END RSA PRIVATE KEY-----
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;strong&gt;hostKeyAlgorithm必须是ssh-dss, ssh-rsa, ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, or ecdsa-sha2-nistp521中的一个。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 class=&quot;title&quot;&gt;Force pull in Git Repositories&lt;/h4&gt;
&lt;p&gt;如果本地copy已经失效（即远程仓库有改动），则Spring Cloud Config Server会强制从从远程库拉取最新的配置。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;           force-pull: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有多个远程仓库的话，可以使用类似下面的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/common/config-repo.git&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;           force-pull: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;          repos:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             team-&lt;span&gt;a:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 pattern: team-a-*
&lt;span&gt;11&lt;/span&gt;                 uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/team-a/config-repo.git&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 force-pull: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             team-&lt;span&gt;b:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 pattern: team-b-*
&lt;span&gt;15&lt;/span&gt;                 uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/team-b/config-repo.git&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 force-pull: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             team-&lt;span&gt;c:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 pattern: team-c-*
&lt;span&gt;19&lt;/span&gt;                 uri: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;git/team-a/config-repo.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;force-pull属性默认是false。&lt;/p&gt;
&lt;h4 class=&quot;title&quot;&gt;Deleting untracked branches in Git Repositories（删除git仓库中未跟踪的分支）&lt;/h4&gt;
&lt;p&gt;因为Spring Cloud Config Server会克隆远程仓库到本地并且会一直保持这个分支知道下次重启，所以有一种情况是远程分支已经被删除，但是本地副本还仍然可用。&lt;/p&gt;
&lt;p&gt;为了保证本地仓库分支和远程同步，需要设置deleteUntrackedBranches属性，它会使Spring Cloud Config Server强制删除本地未跟踪的分支。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      server:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        git:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;           uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/spring-cloud-samples/config-repo&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;           deleteUntrackedBranches: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;deleteUntrackedBranches默认值为false。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;3. Spring Cloud Config Client（配置客户端）&lt;/h2&gt;
&lt;h2 class=&quot;title&quot;&gt;3.1 Config First Bootstrap（启动时先读取config server配合）&lt;/h2&gt;
&lt;p&gt;在classpath中存在Spring Cloud Config Client的任何应用的默认行为如下：当一个config客户端启动时，它绑定到Config Server（通过bootstrap的配置属性spring.cloud.config.uri）然后使用远程配置文件初始化spring环境。&lt;/p&gt;
&lt;p&gt;这种行为的最终结果是所有想要到 Config Server消费的客户端应用都需要一个配置有spring.cloud.config.uri（默认为：&quot;http://localhost:8888&quot;）的bootstrap.yml或者环境变量。&lt;/p&gt;

&lt;h2 class=&quot;title&quot;&gt;3.2 Discovery First Bootstrap（使用服务发现寻找config server）&lt;/h2&gt;
&lt;p&gt;如果你正在使用服务发现框架例如Spring Cloud Netflix 和 Eureka Service Discovery 或者 Spring Cloud Consul，你可以把Config Server 注册到服务注册中心。&lt;/p&gt;
&lt;p&gt;但是在默认的“Config First”模式下，客户端是感知不到注册中心中的config server服务的。如果你选择使用服务发现来定位Config Server，那么你需要在Config server中设置spring.cloud.config.discovery.enabled=true，&lt;/p&gt;
&lt;p&gt;默认是false。这么做的话就需要每个客户端应用都要有一个bootstrap.yml或者环境变量来配置服务注册中心的内容。例如在Spring Cloud Netflix中，你需要配置Eureka server地址（eureka.client.serviceUrl.defaultZone），&lt;/p&gt;
&lt;p&gt;这么做的代价是在启动时需要一个额外的网络往返来定位服务注册中心。好处是，只要注册中心是固定的，那么config server就可以随意改变坐标。默认的服务ID是configserver，但是可以通过spring.cloud.config.discovery.serviceId&lt;/p&gt;
&lt;p&gt;来重新设置（但是通常是通过spring.application.name来设置一个服务ID）。&lt;/p&gt;
&lt;p&gt;一般服务发现实现客户端都是支持某些元数据映射的（例如在Eureka中的eureka.instance.metadataMap）。为了让配置客户端能正确连接到config server需要在Config Server中配一些服务注册相关的元数据。&lt;/p&gt;
&lt;p&gt;如果Config Server安全策略是基于HTTP的，你可以设置一些用户凭证像username，password。另外，如果Config Server有上下文路径，可以使用configPath设置。如下（bootstrap.yml）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;eureka:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  instance:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    ...
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    metadataMap:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;      user: osufhalskjrtl
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;      password: lviuhlszvaorhvlo5847
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;       configPath: /config
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;title&quot;&gt;3.3 Config Client Fail Fast（快速失败响应）&lt;/h2&gt;
&lt;p&gt;在某些情况下，你可能希望服务在启动时如果连接config server失败时立刻响应失败而停止启动，可以设置spring.cloud.config.fail-fast=true。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;3.4 Config Client Retry（配置客户端重试机制）&lt;/h2&gt;
&lt;p&gt;如果你觉得config server在你启动应用是不可达是暂时的或者偶然的，你需要在一次失败后接着重新尝试连接。第一步，设置spring.cloud.config.fail-fast=false。&lt;/p&gt;
&lt;p&gt;接着将spring-retry和spring-boot-starter-aop加入到classpath中。默认行为是重试6次，初始间隔为1000ms，后续间隔乘以1.1。&lt;/p&gt;
&lt;p&gt;可以通过设置spring.cloud.config.retry.*来改变默认行为。&lt;/p&gt;
&lt;p&gt;注意：如果要完全控制重试机制，可以通过创建一个RetryOperationsInterceptor类型id为configServerRetryInterceptor的bean。&lt;/p&gt;
&lt;p&gt;可以使用Spring Retry中的RetryInterceptorBuilder来创建。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;3.5 Locating Remote Configuration Resources（定位远程配置资源）&lt;/h2&gt;
&lt;p&gt;配置服务提供/{name}/{profile}/{label}的属性源，其在客户端应用的映射为：&lt;/p&gt;
&lt;ul class=&quot;itemizedlist&quot;&gt;&lt;li class=&quot;listitem&quot;&gt;&quot;name&quot; = &lt;code class=&quot;literal&quot;&gt;${spring.application.name}&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&quot;profile&quot; = &lt;code class=&quot;literal&quot;&gt;${spring.profiles.active}（其实是Environment.getActiveProfiles()）&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&quot;label&quot; = &quot;master&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以使用spring.cloud.config.*来覆盖上面的默认值。&lt;/p&gt;
&lt;p&gt;其中可以使用label属性回滚到以前的版本。在config server的实现中，label可以是git 标签，分支名或者commit ID。也可以是以逗号分隔的列表。在这种列表情况下，其中的元素会一个一个的被尝试，直到有一个成功。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;3.6 Specifying Multiple Urls for the Config Server（指定多个config server url）&lt;/h2&gt;
&lt;p&gt;为了保证高可用，你可能部署多个config server，在客户端可以使用spring.cloud.config.uri，以逗号分隔指定多个URL，或者将config server的多个实例注册到服务注册中心，此时客户端需要使用之前提到的Discovery-First Bootstrap&lt;/p&gt;
&lt;p&gt;模式（spring.cloud.config.discovery.enabled=true）。&lt;/p&gt;
&lt;p&gt;如果Config Server使用的是HTTPS协议，则可以将用户凭证信息填写在每个config server 的 url上。如果使用其他的安全机制，则不支持为每个config server配置验证信息。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;3.7 Configuring Read Timeouts（读取超时）&lt;/h2&gt;
&lt;p&gt;使用spring.cloud.config.request-read-timeout配置超时时间。&lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;3.8 Security（安全机制）&lt;/h2&gt;
&lt;p&gt;如果config server使用的是HTTPS，则需要在url上指定用户名和密码，或者使用单独的username和password属性设置。如下（bootstrap.yml）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;user:secret@myconfig.mycompany.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  cloud:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    config:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      uri: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myconfig.mycompany.com&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;     username: user
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;      password: secret
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;spring.cloud.config.password&lt;/code&gt; 和 &lt;code class=&quot;literal&quot;&gt;spring.cloud.config.username会覆盖url中的用户名和密码。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;好了，spring cloud config就先讲到这。下一篇就是spring cloud netflix。如果文章中写的有问题的希望各位读者批评指出。如果觉得在我这学到了点东西的，特别希望您能动动可爱的小手给点个赞！^_^&lt;/p&gt;

</description>
<pubDate>Thu, 13 Sep 2018 05:39:00 +0000</pubDate>
<dc:creator>CLAYJJ</dc:creator>
<og:description>spring cloud config</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CLAYJJ/p/9633109.html</dc:identifier>
</item>
<item>
<title>2018,全新出发(全力推动实现住有所居) - 何戈洲</title>
<link>http://www.cnblogs.com/hegezhou_hot/p/9638427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hegezhou_hot/p/9638427.html</guid>
<description>&lt;h2&gt;2013-停止了写博&lt;/h2&gt;
&lt;p&gt;        自2013年写完《&lt;a href=&quot;https://www.cnblogs.com/hegezhou_hot/p/3489795.html&quot;&gt;系统架构师-基础到企业应用架构-分层[上篇]&lt;/a&gt;》后便停止写博客了，至今快5年了，现在突然想写的时候，却又发现迟迟无法下手打字，细心思考感触颇多，这5年对于我来说经历了太多，也成长了许多，职业发展的路径可以说是连绵曲折，但过程中也收获颇丰，人生便是历练，感谢这样的机遇，让我慢下来，重新思考、全新出发。&lt;/p&gt;
&lt;p&gt;       鄙人有幸参与并见证了互联网、移动互联网、人工智能、云计算、大数据、区块链等技术的兴起、蓬勃发展及成熟。也逐步被科技改变生活的习惯及方式，每天看电脑手机的时间超过12小时。可以说离开了他们，我们的生活变得无趣和乏味。&lt;/p&gt;
&lt;p&gt;       现在基本上大家每天的状态是刷刷抖音、看看朋友圈、听听音乐、追追剧、看看电影、购购物，悄然科技已无处不在，让我们的生活变得更加的丰富多彩，特别是近几年又开始流行直播、粉丝经济、IP付费等内容。&lt;/p&gt;
&lt;p&gt;       毫不夸张的说，博客园里面的很多专家和大咖可以说是先驱，早早就开始了IP时代，形成了早期的雏形，只是没有像现在各类形式的直播或多媒体社交平台，那时候已经有了知识付费的概念，只是不像现在这么广泛和流行。&lt;/p&gt;
&lt;p&gt;       IP，是Intellectual Property的缩写，字面粗译为“知识产权”，特指具有长期生命力和商业价值的跨媒介内容运营。伴随着移动互联网时代的降临，从商业和资本的角度来看，IP更多被引申为“可供多维度开发的文化产业产品”。比如说目前比较知名的“罗辑思维”、“喜马拉雅FM”等，我曾构想，如果那时候不放弃，继续坚持和持续分享，是不是就没有罗辑思维了，哈哈。&lt;/p&gt;
&lt;p&gt;       封笔可以说是我个人做过的最错误的决定，写博客不单能够与行业内的各位专家、同仁进行深度的经验交流，还可在过程中结识未来更多的合作伙伴，带来更大的收获。为了给后续的新朋友提供点前车之鉴，在此我重新梳理工作过程中遇到的各类问题及解决方案（末尾有提纲），希望能够给与大家帮助。&lt;/p&gt;

&lt;h2&gt;2014-转型管理者（技术、产品管理）&lt;/h2&gt;
&lt;p&gt;        2013年还在北京工作，一次偶然的机会，在互联网上有幸认识了一个创业企业的老板(医疗行业)，我们双方前期多次见面沟通，最终在老板描绘的远大前程和前景下，没有禁住诱惑加入了该公司，一起奋斗，希望能够实现屌丝逆袭，来北京的外地人，打工者怕是都有这样的想法，期待某一天能够鲤鱼跳龙门一飞冲天。&lt;/p&gt;
&lt;p&gt;       这次的机会可以说对于我的职业发展来说是一次挑战和转型。挑战是技术体系需要重新开始、研发技术的实力不足、人员也比较短缺，公司的产品设计能力不足。转型是不再是一个架构师的角色，承担的职责和义务更多了，当然我喜欢这样的挑战，因为有挑战才会有进步，也能够检验一下自己的水平和能力。可以说前期很长的一段时间过于乐观的高估了自己，整体的情况开展的并不好，这样的状态持续了近8个月的时间，我总结了下过程中存在的问题主要集中在以下几个方面：&lt;/p&gt;
&lt;p&gt;       A、技术语言不同（设计思想理念一致），之前是搞.NET，该公司需要混合体系(JAVA提供SOA服务端),开始学习JAVA并进行混合架构模式。&lt;/p&gt;
&lt;p&gt;       B、不会管人（技术人员如何统筹、任务分配、项目风险应对、进度跟踪等方面做的不到位，管理经营缺乏）&lt;/p&gt;
&lt;p&gt;       C、性格弱势（之前一直是技术人员，性格比较木讷、腼腆、较弱势，在与人的沟通及协作上比较容易让步和被人左右）&lt;/p&gt;
&lt;p&gt;       D、团队文化缺乏（没有团队文化，大家的积极性不高，在竞争较激烈的环境下无法生存）&lt;/p&gt;
&lt;p&gt;       E、统筹规划及部门发展战略（缺乏整体统筹思维、还达不到技术总监的任职及能力要求）&lt;/p&gt;

&lt;h2&gt;2015-复合型工作（战略规划统筹、售前）&lt;/h2&gt;
&lt;p&gt;        2014年伴随着缓慢的成长及过程中不断的学习和总结，总算是摸到了管理的门道，但是在很多方面还是缺乏经验，以至于处理问题的解决不是最好的，即便如此，我们老板还是非常的信任我，在2014年底公司的年会上公布了公司的组织架构，明确了我的工作职责及相关内容，把公司整体的战略规划统筹、核心产品等职能统一交给我，这些工作对于我来说又是一次全新的挑战。&lt;/p&gt;
&lt;p&gt;       战略规划统筹负责制定公司整体的发展目标、竞争优势及策略、打造企业可持续发展的动力，肩负这样的实名，我不断学习及演讲该项内容，同时紧贴行业发展的趋势，设计及规划公司有核心竞争力及价值的产品。为企业构建壁垒、抢占更多的独占资源。同时，售前及解决方案工作也是由我来负责具体的落实实施，组织配合销售进行解决方案制定、招投标相关事宜、落地及实施方案、产品设计、技术架构等内容。&lt;/p&gt;
&lt;p&gt;       经过1年多的努力，终于在2015年底完成2各项目的落地实施，也算是对于当前的付出有所收货，这1年出差是常态基本上站到三分之一的时间不在家，售前工作为主。同步推进外部业务合作及内部产品、项目交付。过程中也是磕磕绊绊出现了不少的问题，我总结了下主要集中在以下几个方面：&lt;/p&gt;
&lt;p&gt;       A、销售理念及思考维度（如何站在客户的角度思考问题，直击用户痛点。拿出有竞争力及超出用户预期的解决方案）&lt;/p&gt;
&lt;p&gt;       B、关系运作及讲话（汇报的对象及说话、沟通方式方面的技巧，汇报时的演讲技巧）&lt;/p&gt;
&lt;p&gt;       C、领导接待（技术人员的思维都是干好自己的工作，关于如何接待领导这块是真想不周全，考虑不到那么多的细节）&lt;/p&gt;
&lt;p&gt;       D、业务拓展及赚钱能力（作为销售及售前，一是是否能够发现商机积极拓展业务内容，另外是是否能够赚钱，能赚钱是硬道理，亦或带来核心资源）&lt;/p&gt;

&lt;h2&gt;2016-爱上这个浪漫之都（大连）&lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;        随着小孩的不断成长，上学问题是不得不考虑和面临的问题，北京学区房及户口都没有的情况下，小孩上学问题较难解决，为了给孩子提供更好的教育及后续的成长空间，我与老婆协商甄选了几个城市，最终选择了与专业较对口的城市大连，之前我们也来大连旅游过，对大连的印象特别的好，旅游城市，环境优美，房价不高，落户及教育问题都可以很好的解决，再就是就业岗位也比较多，IT、互联网公司也多，在家庭生活及工作都可以提供保障。&lt;/p&gt;
&lt;p&gt;       大连当地有20多家世界500强的公司，有几千家软件企业，有非常好的IT、互联网等行业的发展环境，软件技术人员也非常多，特别是IT软件外包行业更是全国领先。经过1个半月的面试及谨慎选择，最终选择去东软去工作（以专家6级的身份,架构师岗位），算是稳定下来了，在接下来的3个月内，跟着项目完成了从项目前期的需求梳理、设计、架构、开发、测试等环节，过程中从项目组的2人扩编到20多人的项目团队。在业务推进的过程中，我也在持续的思考我为什么要工作，我个人的职业发展规划是什么，我希望成为什么样的人，离开了互联网越发不适应。在思考和做决定的过程并没有纠结太多，我还是希望我是一个互联网人，互联网给我带来了视野、格局、经验、成长。另外，互联网能够实现四两拨千斤的力量，也能实现屌丝逆袭梦。&lt;/p&gt;
&lt;p&gt;       经过对我们当前生活所涉及的各个方面进行详细的梳理分析发现，互联网/移动互联网已改变了我们的生活习惯及生活方式，吃、喝、玩、乐、购物、出行等行业已成熟，共享经济已发展到2.0时代，基本上通过手机可以解决我们日常生活所需的各类需求了，包括互联网目前在各传统行业的命，如小米和格力的赌约似的，互联网时代再改变服务提供方式及参与方式。&lt;/p&gt;
&lt;p&gt;       在这个过程中刚好大连本地的互联网公司（大连市房屋租赁运营管理有限公司）和我联系，向我介绍了公司的业务及建设模式，听完之后，我瞬间变得激动起来，这不正是可以改变百姓生活的行业吗，模式也很新颖并且具有独占的资源优势，目前行业内还没有竞争者，只要我们思考清楚如何做，并且按照战略规划有效落实，我们就可以实现互联网模式的成功，改变居住行业，成为下一个互联网巨头企业。&lt;/p&gt;
&lt;p&gt;       经过与家人协商一致并交接好工作后加入到大连市房屋租赁运营管理有限公司工作，还是以架构师的身份开展工作，主要的工作职责是支撑&lt;strong&gt;大连市房屋租赁公共服务平台（简称“平台”）&lt;/strong&gt;的整体技术架构及技术体系构建，之前的工作经验告诉我，好的架构师一定是结合业务场景来选择最优的系统架构解决方案，基于我的工作职责范围及内容，我做了以下几个方面的工作，让我在2个月的时间内快速理解公司业务及技术方案，梳理出全新的技术架构及方向：&lt;/p&gt;
&lt;p&gt;        A、公司的战略方向、定位、布局。未来规划等。&lt;strong&gt;技术是为业务服务的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        B、熟悉平台业务，问产品、市场及运营部门等要相关的资料，快速理解业务。&lt;/p&gt;
&lt;p&gt;        C、调研行业内的类似平台或相似产品，分析出他们的技术体系及业务内容，摸透为什么这么设计和实现。&lt;/p&gt;
&lt;p&gt;        D、互联网行业技术的变革，目前主流的技术体系是什么？我们需要熟悉并跟上技术的发展步伐&lt;strong&gt;（诸如微服务模式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        E、产品面向的用户是谁？使用场景？使用方式？约束有哪些？我们的优势是什么？&lt;/p&gt;
&lt;p&gt;        F、现在的产品、技术、业务、参与者、运行等情况？详细的技术路线？架构？业务设计？&lt;/p&gt;
&lt;p&gt;        G、综合管理模式是什么？诸如研发中心内部的协作流程，管理模式，团队构成及水平？公司管理模式等&lt;/p&gt;
&lt;p&gt;        H、调研了解公司内部的信息化水平情况？是否与我们提供的产品服务平台之间有什么业务联动？数据监测及大数据应用方面的需求是什么？&lt;/p&gt;
&lt;p&gt;       经过6个月的建设，&lt;strong&gt;大连市房屋租赁公共服务平台于2016年11月9日上线试运行，作为全国首个房屋租赁领域的公共服务平台，得到了住建部领导的高度认可。我们第一次面向全国释放声音，为全国住房租赁市场指明了发展的方向和思路。&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;2017-社会担当及责任&lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;       在业务高速发展的过程中，我也伴随着平台的发展快速成长， 个人承担的工作内容也越来越多了，公司董事长做了一个大胆的决定，破格任命我为公司的副总裁，全面推进平台的业务发展，非常感谢董事长对于我的信任，我将全力以赴的投入，快速推进公司整体的业务发展，期间做了一系列的工作调整，涵盖技术、人员、管理制度等方面的内容，之前几年的工作经验这时候可以全部派上用场了，经过这些调整后，公司的业务内容更明确了，发展的速度有小幅提升，距离预期的差距比较大，其中的原因很多，后面一一总结。&lt;/p&gt;
&lt;p&gt;       平台经过几个月的试运行，于2017年春季的房交会上正式亮相，推出多项创新服务内容，各大媒体争相报道，可以说是在大连引起广泛热议，让我们对于平台的前景及发展充满信心，通过平台提供围绕居住场景为核心的一站式居住生活服务，涵盖公共服务、租赁服务、便民服务、大数据服务等内容。&lt;/p&gt;
&lt;p&gt;       过程中随着业务的成熟，平台开始进行全国业务拓展的复制，我们曾先后到北、上、广、深、武汉、成都、郑州、重庆、佛山等10多个地市进行业务沟通及交流，得到了大家的广泛认同，我们将平台的理念，建设模式，建设方案，遇到的问题及解决方案等倾囊相授，就是希望住房租赁行业能够快速发展起来，我们没有等太久，2017年7月18日，可以说是全国房地产行业发展的大日子和里程碑，住建部颁布12个试点城市开展培育及发展住房租赁市场，全国一下子掀起了住房租赁市场培育发展的热潮，住房租赁市场开始被关注，资本市场也开始介入，好不热闹。紧接着十九大的召开，习大大提出“房子用来住的，不是用来炒的，建立租购并举的住房制度”，一下子把住房租赁推向前所未有的高度，整个政府租赁市场活了，紧接着平台也活了，一下子进入到风口行业，各类融资平台、资本开始找寻热点进行投资，也有不少找到了我们。&lt;/p&gt;
&lt;p&gt;       我们没有被资本和热度冲破头脑，我们依然稳步前行，不断丰富平台功能及服务内容，对接更多的政府部门、企业机构、百姓公众等，并于2017年11月9日举行一周年的工作成果汇报会，发布了大连住房租赁领域的首个大数据共享平台。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;作为有社会担当及责任感、使命感的公司，我们不断学习、不断完善服务内容及服务理念，强化平台技术能力，突破创新，形成企业的竞争优势&lt;/strong&gt;，总结来看，我们有以下几方面的优势：&lt;/p&gt;
&lt;p&gt;       A、时间优势（介入住房租赁市场较早，产品及服务理念、建设模式、业务服务等都较成熟&lt;strong&gt;）（领先全国，早1年多的时间）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       B、业务优势（围绕居住场景，实现多委办局的业务融合，服务好行业内参与的企业、百姓，全面满足行业参与者的需求，而不是某一方的需求，诸如仅是政府监管需求？）&lt;/p&gt;
&lt;p&gt;       C、平台模式（平台在运作上采取创新模式，拥有政府的独占资源，并借助互联网技术及服务模式，支持多方需求并满足企业的发展诉求）&lt;/p&gt;
&lt;p&gt;       D、技术及团队（拥有一批专业的互联网从业人员，有丰富的经验实现从0~1，技术在大连地区可以说绝对领先，主流的技术组合（微服务、云容器、SaaS等））&lt;/p&gt;
&lt;p&gt;       E、其他资源（企业资源、渠道等）&lt;/p&gt;

&lt;h2&gt;2018-全新出发&lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;       2018年在2017年的基础上，需要我们加快前进的部分，市场的竞争越来越激烈了，竞争者也越来越大牌了，诸如阿里、腾讯、京东、58同城、平安银行等，我们得自身强大，才可以在激烈的竞争中生存下来。&lt;/p&gt;
&lt;p&gt;       18年上半年经过业务的优化调整，我们在产品的功能及流程上增加了多项刚性的公共服务、便民服务等内容，着实为百姓在租住的过程中规避风险和问题，&lt;strong&gt;这里列举几项有价值的服务内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       A、信息真实有效（实人验证，人脸识别，确保房东、房客、经纪公司/经纪人信息真实），房源展示提供VR、产权验真等确保信息真实&lt;/p&gt;
&lt;p&gt;       B、统一租赁合同范本（制定符合住建部、辽宁省要求的租赁合同示范文本，全面保障房东、房客、经纪人等多方的职责和权益，保障公平性），同时完成政府监管账要求的内容。&lt;/p&gt;
&lt;p&gt;       C、公共服务（租赁备案：影响保障房申请，子女入学，租房补贴等;居住证：类似于大连户口的待遇）（落实租购同权）&lt;/p&gt;
&lt;p&gt;       D、租金分期（由银行提供信用卡分期，支持12家银行机构，非P2P或互联网金融，规避爆仓风险）。&lt;/p&gt;
&lt;p&gt;       随着平台业务的完善及作用的日益凸显，大连市政府非常重视培育及发展住房租赁市场，成立了专门的领导小组，重点研究及推进住房租赁市场的相关工作，我们平台的业务完善及发展是其中的核心工作内容，特别制定了2018~2020年-3年的滚动计划，全面推进该项工作。（被重视的感觉真好）&lt;/p&gt;
&lt;p&gt;       不但在本地的业务开展的越来越顺利，同时在全国的业务推进上，公司发展的节奏也越来越快，我们已在深圳成立了分公司，业务也即将落地深圳，业务发展也越来越快。&lt;/p&gt;
&lt;p&gt;       为更好的支撑业务的落地，过程中公司做了非常大的改革调整，以便支持公司业务更快、更好的发展，其中重大的几项措施如下：&lt;/p&gt;
&lt;p&gt;        A、绩效考核体系：基于岗位薪酬，透明化薪酬，薪随岗动，综合绩效考核体系（360-态度及责任心、KPI-岗位技能、OKR-工作量及目标）&lt;/p&gt;
&lt;p&gt;        B、产品、技术体系升级：主流的产品设计体系，覆盖所有终端，为用户提供全方位的服务接入方式。技术采取微服务架构，采用主流的容器技术，打造SaaS模式的产品服务体系。&lt;/p&gt;
&lt;p&gt;        C、高效协作流程：采取敏捷的协作模式，各部门间无缝的信息共享，高效的并行工作方式，高质量的成果交付。确保工作的快速推进，借助工具(JIRA+Confluence)实行内部协同的管理。&lt;/p&gt;
&lt;p&gt;        D、企业内部管理体系：健全公司整体的内部管理体系，确保企业经营过程中的各环节的有序运作。&lt;/p&gt;
&lt;p&gt;        E、企业文化打造：企业成功的关键因素，优秀企业的基石，重塑公司的使命、愿景及企业文化，构建百年基业。&lt;/p&gt;
&lt;p&gt;        通过上述几项措施的有效实行，预计今年年底将实现百万用户、盈利模式的落地实践，同时完成在全国的战略布局，实行企业的既定战略目标的落地，对于我来说机遇和挑战并存，随着公司优秀人员的加入，我们的团队越来越优秀，离成功的目标越来越近了。&lt;/p&gt;

&lt;h2&gt;写到最后&lt;/h2&gt;
&lt;p&gt;       实话实话，如果系统化的梳理下工作的过程，可能需要很长的篇幅来阐述，有些也都是细枝末节的内容，一方面为了更好的总结经验，另一方面我也希望能够系统化的梳理下工作过程中在各个方面遇到的问题及梳理的解决方案与大家分享，后续在大家遇到类似问题的时候能够提供些解决问题的思路，后续我将持续梳理相关内容，初步计划分享以下内容：&lt;/p&gt;
&lt;p&gt;       A、技术层面：专业技术、系统架构、行业解决方案、案例分析等&lt;/p&gt;
&lt;p&gt;       B、产品层面：产品规划及设计、竞争策略及优势制定&lt;/p&gt;
&lt;p&gt;       C、管理层面：研发内部管理、公司综合管理&lt;/p&gt;
&lt;p&gt;       D、市场及运营层面：产品的市场及运营策略&lt;/p&gt;
&lt;p&gt;       E、商业模式及盈利模式：分析梳理企业的商业模式、盈利模式&lt;/p&gt;
&lt;p&gt;       F、投融资：商业计划书(BP)、投融资事宜&lt;/p&gt;
&lt;p&gt;       G、职业规划及发展：关于个人的职业规划及发展（技术方向、业务分析、管理方向、销售）&lt;/p&gt;
&lt;p&gt;       鄙人不才，有些内容无法写的特别的深入，只能从个人的角度把相关的经验和认识讲述清楚，也欢迎大家共同交流学习，有兴趣欢迎加群交流，也希望大家加群投票，共同进步。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;&lt;span&gt;微信交流群（7天有效）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/46256/201809/46256-20180913075705256-2118506841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 13 Sep 2018 05:01:00 +0000</pubDate>
<dc:creator>何戈洲</dc:creator>
<og:description>2013-停止了写博 自2013年写完《系统架构师-基础到企业应用架构-分层[上篇]》后便停止写博客了，至今快5年了，现在突然想写的时候，却又发现迟迟无法下手打字，细心思考感触颇多，这5年对于我来说经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hegezhou_hot/p/9638427.html</dc:identifier>
</item>
<item>
<title>当你「ping 一下」的时候，你知道它背后的逻辑吗？ - IVAN-jsjwk</title>
<link>http://www.cnblogs.com/jsjwk/p/9639908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jsjwk/p/9639908.html</guid>
<description>&lt;p&gt;&lt;span&gt;我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;一、「ping」命令的作用和原理？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;简单来说，「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping 命令是基于 ICMP 协议来工作的，「 ICMP 」全称为 Internet 控制报文协议（ Internet Control Message Protocol）。ping 命令会发送一份ICMP回显请求报文给目标主机，并等待目标主机返回ICMP回显应答。因为ICMP协议会要求目标主机在收到消息之后，必须返回ICMP应答消息给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举一个例子来描述「ping」命令的工作过程：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;9&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;当主机B收到这个数据帧之后，会首先检查它的目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;通过ping的流程可以发现，ICMP协议是这个过程的基础，是非常重要的，因此下面就把ICMP协议再详细解释一下。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;二、什么是「 ICMP 」？&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我们知道，ping命令是基于ICMP协议来实现的。那么我们再来看下图，就明白了ICMP协议又是通过IP协议来发送的，即ICMP报文是封装在IP包中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSzLZTPfIuhicN1BpIGhxoI4EX4cAo6jnThtXGibtC3IHOmcRwPJsibfRyEg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.3010033444816054&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSzLZTPfIuhicN1BpIGhxoI4EX4cAo6jnThtXGibtC3IHOmcRwPJsibfRyEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;299&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP协议是一种无连接的，不可靠的数据包协议，它并不能保证数据一定被送达，那么我们要保证数据送到就需要通过其它模块来协助实现，这里就引入的是ICMP协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当传送的IP数据包发送异常的时候，ICMP就会将异常信息封装在包内，然后回传给源主机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将上图再细拆一下可见：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSzNRHM9LecBROMgAzmu6XPOMq7OQiaIickicJ9r9kWurC7Bn7ZibKnw8UnxA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.20151133501259447&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSzNRHM9LecBROMgAzmu6XPOMq7OQiaIickicJ9r9kWurC7Bn7ZibKnw8UnxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;397&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继续将ICMP协议模块细拆:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSzdnVk2q78vGzOCOfWVwZw2djg8mKaea7kxzKibU4ly9z25kHQbunPicicw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.33555555555555555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSzdnVk2q78vGzOCOfWVwZw2djg8mKaea7kxzKibU4ly9z25kHQbunPicicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot; data-fail=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由图可知，ICMP数据包由8bit的类型字段和8bit的代码字段以及16bit的校验字段再加上选项数据组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ICMP协议大致可分为两类：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查询报文类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;差错报文类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.0166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jgOJKOvxkePwicNpdstiaTM9z6piaop7KSz2SR01JbEbvDZFLzDKiaePWXQ9T4eBKQeH2r9vxOgAYNed7qgGkEjibPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;查询报文类型&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;查询报文主要应用于：ping查询、子网掩码查询、时间戳查询等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面讲到的ping命令的流程其实就对应ICMP协议查询报文类型的一种使用。在主机A构建ICMP请求数据包的时候，其ICMP的类型字段中使用的是 8 （回送请求），当主机B构建ICMP应答包的时候，其ICMP类型字段就使用的是 0 （回送应答），更多类型值参考上表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对 查询报文类型 的理解可参考一下文章最开始讲的ping流程，这里就不做赘述。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;差错报文类型&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;差错报文主要产生于当数据传送发送错误的时候。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;它包括：目标不可达（网络不可达、主机不可达、协议不可达、端口不可达、禁止分片等）、超时、参数问题、重定向（网络重定向、主机重定向等）等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;差错报文通常包含了引起错误的IP数据包的第一个分片的IP首部，加上该分片数据部分的前8个字节。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当传送IP数据包发生错误的时候（例如 主机不可达），ICMP协议就会把错误信息封包，然后传送回源主机，那么源主机就知道该怎么处理了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那是不是只有遇到错误的时候才能使用 差错报文类型 呢？也不一定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Traceroute 就是一个例外，Traceroute是用来侦测源主机到目标主机之间所经过路由情况的常用工具。Traceroute 的原理就是利用ICMP的规则，制造一些错误的事件出来，然后根据错误的事件来评估网络路由情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体做法就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Traceroute会设置特殊的TTL值，来追踪源主机和目标主机之间的路由数。首先它给目标主机发送一个 TTL=1 的UDP数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL=0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时）的ICMP数据包回发给源主机，也就是差错包。这个时候源主机就拿到了第一个路由节点的IP和相关信息了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着，源主机再给目标主机发一个 TTL=2 的UDP数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如此反复进行，Traceroute就可以拿到从主机A到主机B之间所有路由器的信息了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是有个问题是，如果数据包到达了目标主机的话，即使目标主机接收到TTL值为1的IP数据包，它也是不会丢弃该数据包的，也不会产生一份超时的ICMP回发数据包的，因为数据包已经达到了目的地嘛。那我们应该怎么认定数据包是否达到了目标主机呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Traceroute的方法是在源主机发送UDP数据包给目标主机的时候，会设置一个不可能达到的目标端口号（例如大于30000的端口号），那么当这个数据包真的到达目标主机的时候，目标主机发现没有对应的端口号，因此会产生一份“端口不可达”的错误ICMP报文返回给源主机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可见Traceroute的原理确实很取巧，很有趣。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，就是对ping的基本原理以及ICMP协议的基本讲解了，欢迎大家一起交流。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流Java、Web、架构、大数据、职业发展、技术管理。  &lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1453917/201809/1453917-20180913124845636-21657495.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/blockquote&gt;
</description>
<pubDate>Thu, 13 Sep 2018 04:49:00 +0000</pubDate>
<dc:creator>IVAN-jsjwk</dc:creator>
<og:description>我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？ 一、「ping」命令的作用和原理？ 简单来说，「ping」是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jsjwk/p/9639908.html</dc:identifier>
</item>
<item>
<title>BigDecimal精度与相等比较的坑 - 欠扁的小篮子</title>
<link>http://www.cnblogs.com/z941030/p/9639717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/z941030/p/9639717.html</guid>
<description>&lt;p&gt;先想一下，创建BigDecimal对象的时候一般是怎么创建的？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;new一个，传进去值&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;BigDecimal.valueOf方法，传进去值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为一个数字类型，经常有的操作是比较大小，有一种情况是比较是否相等。用equal方法还是compareTo方法？这里就是一个大坑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;new 传进去一个double&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; BigDecimal newZero = &lt;span&gt;new&lt;/span&gt; BigDecimal(0.0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;System.out.println(BigDecimal.ZERO.equals(newZero));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;new 传进去一个字符串&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; BigDecimal stringNewZero = &lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;0.0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;System.out.println(BigDecimal.ZERO.equals(stringNewZero));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;valueOf  传进去一个double&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; BigDecimal noScaleZero = BigDecimal.valueOf(0.0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;System.out.println(BigDecimal.ZERO.equals(noScaleZero));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;valueOf  传进去一个double，再手动设置精度为1&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; BigDecimal scaleZero = BigDecimal.valueOf(0.0).setScale(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; System.out.println(BigDecimal.ZERO.equals(scaleZero));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用于比较的值全都是0，猜一猜上面几个equals方法返回的结果是什么？全都是true？no no no...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;惊不惊喜，意不意外？原因是什么呢？看一下BigDecimal的equals方法的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object x) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类型不同，直接返回false&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!(x &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BigDecimal))
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     BigDecimal xDec =&lt;span&gt; (BigDecimal) x;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同一个对象，直接返回true&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;精度不同，直接返回false！！&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (scale !=&lt;span&gt; xDec.scale)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; s = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.intCompact;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; xs =&lt;span&gt; xDec.intCompact;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (s !=&lt;span&gt; INFLATED) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (xs ==&lt;span&gt; INFLATED)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             xs =&lt;span&gt; compactValFor(xDec.intVal);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; xs ==&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (xs !=&lt;span&gt; INFLATED)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; xs == compactValFor(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.intVal);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inflated().equals(xDec.inflated());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从前面三个简单的判断就可以看出来，debug跟一下就知道是上面equals方法有三个返回false，都是因为精度不同。那么BigDecimal.ZERO的精度是多少呢？看下源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cache of common small BigDecimal values.&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BigDecimal zeroThroughTen[] =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.ZERO,       0,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.ONE,        1,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(2), 2,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(3), 3,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(4), 4,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(5), 5,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(6), 6,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(7), 7,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(8), 8,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.valueOf(9), 9,  0, 1&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; BigDecimal(BigInteger.TEN,        10, 0, 2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;  
&lt;span&gt;16&lt;/span&gt;  
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * The value 0, with a scale of 0.
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt;  1.5
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BigDecimal ZERO = zeroThroughTen[0];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BigDecimal.ZERO值为0，精度为0.&lt;/p&gt;

&lt;p&gt;而上面几种返回false的case，都是因为精度不同。精度不同的原因，则是BigDecimal对象初始化的方式不同,从源码上看，前三种初始化的方式都不同。&lt;/p&gt;
&lt;p&gt;所以说，BigDecimal比较大小，还是用compareTo方法比较靠谱，改为compareTo之后，上面四个case返回的结果都是相等：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; BigDecimal newZero = &lt;span&gt;new&lt;/span&gt; BigDecimal(0.0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;System.out.println(BigDecimal.ZERO.compareTo(newZero));
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; BigDecimal stringNewZero = &lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;0.0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;System.out.println(BigDecimal.ZERO.compareTo(stringNewZero));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  
&lt;span&gt; 7&lt;/span&gt; BigDecimal noScaleZero = BigDecimal.valueOf(0.0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;System.out.println(BigDecimal.ZERO.compareTo(noScaleZero));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;  
&lt;span&gt;10&lt;/span&gt; BigDecimal scaleZero = BigDecimal.valueOf(0.0).setScale(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; System.out.println(BigDecimal.ZERO.compareTo(scaleZero));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果&lt;/p&gt;


&lt;p&gt;由此联想到的一个更大的坑是，如果将BigDecimal的值作为HashMap的key，因为精度的问题，相同的值就可能出现hashCode值不同并且equals方法返回false，导致put和get就很可能会出现相同的值但是存取了不同的value。&lt;/p&gt;
&lt;p&gt;再想一想，小数类型在计算机中本来就不能精确存储，再把其作为HashMap的key就相当不靠谱了，以后还是少用。&lt;/p&gt;

&lt;p&gt;另外需要注意的一点是，写代码调别人写的方法时，最好是点进去看一下实现。再小再常用的方法，都可能埋着大坑&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 03:52:00 +0000</pubDate>
<dc:creator>欠扁的小篮子</dc:creator>
<og:description>先想一下，创建BigDecimal对象的时候一般是怎么创建的？ new一个，传进去值 BigDecimal.valueOf方法，传进去值 作为一个数字类型，经常有的操作是比较大小，有一种情况是比较是否</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/z941030/p/9639717.html</dc:identifier>
</item>
<item>
<title>巧用机器学习定位云服务器故障 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9639618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9639618.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.0454545454545&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/2546206?fromSource=waitui&quot;&gt;roganhuang&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/5199?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导语&lt;/p&gt;
&lt;p&gt;随着腾讯云业务的扩大，母机数量越来越多。为减少人力并实现母机故障的自动化定位，本文尝试利用机器学习算法，通过对历史故障母机的日志数据学习，训练模型实现自动化分析定位母机故障原因。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;对于每一单母机故障我们都需要定位出背后真实的故障原因，以便对相应的部件进行更换以及统计各种部件故障率的情况，因此故障定位和分析消耗的人力也越来越多。希望能&lt;strong&gt;借助机器学习的方法对历史故障母机的日志数据进行学习，沉淀出一些模型出来实现自动化的分析新的母机故障的原因&lt;/strong&gt;，进而提高母机工单的处理效率解放人力，同时也能分析出故障的一些规律，进而实现对故障的预测等。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;p&gt;1、对母机宕机故障进行自动化的分析，准确定位故障原因；&lt;/p&gt;
&lt;p&gt;2、当故障分类准确率达到足够准确之后，能够不需要人工参与，实现自动化结单；&lt;/p&gt;
&lt;p&gt;3、实时流式处理母机的各种数据，实现部分故障的预测。&lt;/p&gt;
&lt;h2 id=&quot;数据&quot;&gt;数据&lt;/h2&gt;
&lt;p&gt;1、dmesg ：机器宕机前的最后一屏，含有netconsole数据；&lt;/p&gt;
&lt;p&gt;2、mcelog ：系统检查到硬件错误产生的日志；&lt;/p&gt;
&lt;p&gt;3、sel ：系统事件日志，是服务器传感器收集数据发现异常产生的日志。&lt;/p&gt;
&lt;h2 id=&quot;方法步骤&quot;&gt;方法步骤&lt;/h2&gt;
&lt;p&gt;主要步骤包括数据筛选、数据清洗、文本向量化、模型构建、结果分析等。&lt;/p&gt;
&lt;h3 id=&quot;数据筛选&quot;&gt;数据筛选&lt;/h3&gt;
&lt;p&gt;1)查看三类日志，分析是否每一种日志对故障定位都有存价值。剔除无价值的日志；&lt;/p&gt;
&lt;p&gt;2)根据业务需求，选择特定的故障类别。因为某些故障的工单数量特别少，难以建立机器学习模型做分类；&lt;/p&gt;
&lt;p&gt;3)保留三种日志不全为空的故障工单，完全无记录的工单是无法利用的；&lt;/p&gt;
&lt;p&gt;4)根据工单编号ticket_id将日志及故障工单整合，工单和母机应该是一一对应的。&lt;/p&gt;
&lt;h3 id=&quot;数据清洗&quot;&gt;数据清洗&lt;/h3&gt;
&lt;p&gt;1)剔除特殊符号'#', '&amp;lt;', '&amp;gt;', '&amp;amp;', '@','!', '(', ')', '*', '_'等；&lt;/p&gt;
&lt;p&gt;2)剔除日志的无用信息，如数字格式和英文格式的；&lt;/p&gt;
&lt;p&gt;3)日志分开清洗，当不同日志的格式不一致时，需要区分对待分开清洗。&lt;/p&gt;
&lt;h3 id=&quot;文本向量化&quot;&gt;文本向量化&lt;/h3&gt;
&lt;p&gt;日志数据一般为文本数据，在构建文档分类模型时，需要将文本型数据转化成数值型数据。文本向量化（也叫做特征权重计算）常用以下三种方法。&lt;/p&gt;
&lt;p&gt;1)&lt;strong&gt;布尔权重（Boolean vector），是最简单的权重计算方法。&lt;/strong&gt;如果某特征词在文本中出现，其权重即为1,；不出现，即为0.这一简单粗暴的方法容易丢失文本内部具体信息，效果略差。但适用于一些采用二分类的模型，比如决策树和概率分类器。&lt;/p&gt;
&lt;p&gt;2)&lt;strong&gt;频度权值（term frequence），是最直观的权重计算方法。&lt;/strong&gt;单词在文本中出现的次数即为频度权重。这种方法的思想是，出现次数越多的特征单词，其重要性越大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/bj0hfnzqr6.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)Tf-idf（Term Frequency-Inverse Document Frequency, 词频-逆文件频率），是应用最广泛的权值计算方法。单词在一条工单的日志中出现次数越多, 同时在所有工单中出现次数越少, 越能够代表该故障工单。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比于频度权值，引入了IDF。IDF的主要思想是：如果包含词条t的文档越少, IDF越大，则说明词条具有很好的类别区分能力。计算公式如下，分母之所以要加1，是为了避免分母为0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/rjedci2zmj.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/7c9ucn3lc3.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考示例： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/03/tf-idf.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2013/03/tf-idf.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;模型构建&quot;&gt;模型构建&lt;/h3&gt;
&lt;p&gt;在已有数据（标记）的基础上构造出一个分类函数/分类模型， 即为一个决策面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/yi61ud1g6f.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1)&lt;strong&gt;数据划分：&lt;/strong&gt;随机分层抽样，划分训练集（70%）用于构建模型，测试集（30%）用于验证模型效果；&lt;/p&gt;
&lt;p&gt;2)&lt;strong&gt;数据预处理：&lt;/strong&gt;数据整合、数据清洗、文本分词等过程在训练集和测试集上是同样的处理方式，以确保最后的干净的训练集和测试数据的格式是统一的；&lt;/p&gt;
&lt;p&gt;3)&lt;strong&gt;文本向量化：&lt;/strong&gt;采用tf-idf将文本向量化，选择l2正则化，结合文档频率df和最大词频tf进行特征选择，选出若干个关键词；设置停用词['is', 'not', 'this', 'the', 'do', 'in']等；&lt;/p&gt;
&lt;p&gt;4)&lt;strong&gt;模型构建：&lt;/strong&gt;选取分类问题常用的算法构建模型，构建模型过程中不断参数调优，构建最佳的模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/rhmwt08m70.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：对于数量特别少的故障类型，如果依靠专家知识分析已有的工单日志能够一一正确区分的话，那么可以人为地抽象出独一无二的故障特征，并编写模块实现自动化分类。&lt;/p&gt;
&lt;h3 id=&quot;结果分析&quot;&gt;结果分析&lt;/h3&gt;
&lt;p&gt;故障诊断阶段，将构建好的模型运用到测试集上，对故障诊断结果分析。以决策树建立故障诊断模型，可见在训练集上的效果可达98.94%，测试集上可达90.24%。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/7epgnn6szj.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为进一步提高模型性能，&lt;/strong&gt;一方面应具体分析训练集和测试集上被错误分类的故障工单，查看三种日志的内容并查找问题；另一方面，可增加更多的数据用于构建模型，一般而言，数据量越大，模型越接近。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不同算法：&lt;/strong&gt;尝试采用不同的文本分类算法用于故障分类，测试效果能反映出该算法对当前问题的适用性。如下，笔者采用了8种算法进行对比，并对结果进行总结分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/53p6g4hrlf.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/8vgf6kjkly.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关联规则：左键 -&amp;gt;右键，&lt;/strong&gt;左键的组合导致右键的发生。引入关联规则挖掘，可进一步分析日志中关键词的出现，可以如何判定某一类故障的发生。譬如当{'TSC', 'CPU', 'Hardware', 'Error'}等词同时出现时，可理解为当这些关键词出现时，有89.1%的置信度人为发生了硬件故障-内存故障。&lt;/p&gt;
&lt;h2 id=&quot;解决方案补充&quot;&gt;解决方案补充&lt;/h2&gt;
&lt;p&gt;从工程实践的角度出发，笔者提出以下几种可能的解决方案，以作为对上面方法步骤的补充：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;故障分级：&lt;/strong&gt;将故障划分等级，如一级故障（硬件故障-软件故障），二级故障为硬件故障下更具体的故障类型。当直接对所有二级故障做分类效果不理想时，可先&lt;strong&gt;考虑对一级故障做分类，再对二级故障做分类，实现故障分级的效果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;数据不平衡：&lt;/strong&gt;即不同类别的故障工单在数量级上不一致，数据量上相差较大，使得分类模型偏向于数量多的故障。考虑到故障工单数据不平衡的问题，&lt;strong&gt;可考虑将数目少的归总为一类——其他类&lt;/strong&gt;。示例如下，九分类问题可被转化为四分类问题。但是，在工单数量严重不平衡而且故障类别多的情况下，这种归总少类样本为其他类的方法，使得模型分类效果具有较大的随机性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/2546206/7soinkmpnf.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;多字特征词：&lt;/strong&gt;原理即将文本内容按字节流进行大小为N的滑动窗口操作，形成长度为N的字节片段序列，以自动产生多字特征词。相比于分开存在，几个单词的连续出现可能会有产生不一样的意义，对分类产生影响。&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;布尔权重：&lt;/strong&gt;CPU发生故障时，CPU多核故障和单核故障属于同一类，但多核故障会记录每一个核的情况，导致某些关键词或者格式重复出现，使得模型对于两者的相似性降低。此时，可考虑&lt;strong&gt;使用布尔权重代替tf-idf进行文本向量化&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;后续&quot;&gt;后续&lt;/h2&gt;
&lt;p&gt;由于文本分类涵盖的内容较多，本文尽可能从简出发，阐述母机日志分析的大体流程，以及工程实践上的解决方案，以供交流。对于文本分类特征选择，模型参数调优和数据不平衡的更为详细的解决方法，笔者将在后续跟进。&lt;/p&gt;
&lt;p&gt;以上内容基于roganhuang(黄荣庚) 在实习期间工作的总结。感谢运营开发组的小伙伴们的帮助，感谢学长@simbazhou，导师@lelandwu和学姐@mengnizhang给予的指导和帮助。&lt;/p&gt;
&lt;p&gt;笔者不才。如有错误，欢迎指正！&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://blog.csdn.net/zrc199021/article/details/53728499&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zrc199021/article/details/53728499&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;https://blog.csdn.net/sangyongjia/article/details/52440063&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sangyongjia/article/details/52440063&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/03/tf-idf.html&quot; class=&quot;uri&quot;&gt;http://www.ruanyifeng.com/blog/2013/03/tf-idf.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;https://blog.csdn.net/lxg0807/article/details/52776183?fps=1&amp;amp;locationNum=10&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/lxg0807/article/details/52776183?fps=1&amp;amp;locationNum=10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;https://blog.csdn.net/wangongxi/article/details/51591031&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wangongxi/article/details/51591031&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.&lt;a href=&quot;https://blog.csdn.net/wangongxi/article/details/51591031&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wangongxi/article/details/51591031&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.47524752475248&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/98210?fromSource=waitui&quot;&gt;机器学习入门需要哪些数学基础？&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1194352?fromSource=waitui&quot;&gt;基于多维数据频繁项挖掘的母机隐患排查&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1197199?fromSource=waitui&quot;&gt;再也不用担心网吧开黑队友听不清了！&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1197316?fromSource=waitui&quot;&gt;自己动手打造前端性能监控系统&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1128?fromSource=waitui&quot;&gt;【每日课程推荐】机器学习实战！快速入门在线广告业务及CTR相应知识&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1194357?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Thu, 13 Sep 2018 03:40:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9639618.html</dc:identifier>
</item>
</channel>
</rss>