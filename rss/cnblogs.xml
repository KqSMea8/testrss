<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【三十】php之PDO抽象层 - 花花妹子。</title>
<link>http://www.cnblogs.com/8013-cmf/p/8303222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/8013-cmf/p/8303222.html</guid>
<description>&lt;p&gt;PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。&lt;/p&gt;
&lt;p&gt;PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。&lt;/p&gt;
&lt;p&gt;示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/772876/201801/772876-20180117092554615-402738661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置pdo的开启状态。在php.ini文件中找到如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;extension=php_pdo.dll　　//开启pdo&lt;/li&gt;
&lt;li&gt;extension=php_pdo_mysql.dll　　//pdo访问mysql驱动&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;查看是否成功开启pdo，可以通过phpinfo函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pdo提供了三组类：PDO、PDOStatement、PDOException。分别为数据库使用、预处理、异常&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;连接数据库和异常处理代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.使用try、catch来进行错误处理。有专门的PDOException异常类&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     2.PDO参数解析：数据源DSN、用户名、密码、属性设置
//         2.1 数据源DSN:'数据库驱动：地址=localhost;数据库名：test'
//         2.2 数据库驱动：mysql
//         2.3 属性设置：drive_opt。通过数组来设置这些属性&lt;/span&gt;
    &lt;span&gt;$drive_opt&lt;/span&gt;=&lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
        PDO&lt;/span&gt;::ATTR_AUTOCOMMIT=&amp;gt;1,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改成功&lt;/span&gt;
        PDO::ATTR_SERVER_VERSION=&amp;gt;4 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改失败。因为setAttribut没有修改ATTR_SERVER_VERSION属性&lt;/span&gt;
&lt;span&gt;    );
    &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PDO('mysql:host=localhost;dbname=test','root','',&lt;span&gt;$drive_opt&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;setAttribute(PDO::ATTR_ERRMODE, PDO::&lt;span&gt;ERRMODE_EXCEPTION);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     获取与连接相关的信息&lt;/span&gt;
     &lt;span&gt;echo&lt;/span&gt;  &lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;getAttribute(PDO::ATTR_CONNECTION_STATUS).&quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;  &lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;getAttribute(PDO::ATTR_SERVER_VERSION).&quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;getAttribute(PDO::ATTR_AUTOCOMMIT).&quot;&amp;lt;br/&amp;gt;&quot;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt;  &lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;getAttribute(PDO::&lt;span&gt;ATTR_ERRMODE);
}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;( &quot;数据库链接错误&quot;&lt;span&gt;);
}
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/772876/201801/772876-20180117100935818-1917737763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以使用setAttribute来设置属性值。使用getAttribute来获取属性值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/772876/201801/772876-20180117100633865-51780087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;一：增删改（执行没有结果集的查询，使用exec()方法将返回查询所影响的行数）&lt;/h3&gt;
&lt;p&gt;在pdo操作sql有错误的情况下，提供了3中报错的方式，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/772876/201801/772876-20180117125816818-438895938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果使用默认模式，需要我们自己进行判断和输出错误结果&lt;/li&gt;
&lt;li&gt;如果使用警告模式，会自动提醒pdo操作数据库存在的问题&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;如果使用异常模式，则需要通过try{}catch{}来捕获&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;$drive_opt&lt;/span&gt;=&lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
    PDO&lt;/span&gt;::MYSQL_ATTR_INIT_COMMAND=&amp;gt;'SET NAMES UTF8',　　&lt;span&gt;//设置字符集编码&lt;/span&gt;&lt;span&gt;
    PDO&lt;/span&gt;::ATTR_ERRMODE=&amp;gt;PDO::ERRMODE_EXCEPTION   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意 一定要写这个，不如写try catch 不会执行异常&lt;/span&gt;
&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PDO('mysql:host=localhost;dbname=test','root','',&lt;span&gt;$drive_opt&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;){
   &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;('数据库连接失败'.&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增删改&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;$sql&lt;/span&gt;=&quot;insert into user1(name,Password,Email,age) values('hello',md5(456),'hello@qq.com',55);&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$res&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;&lt;span&gt;exec&lt;/span&gt;(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$res&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;添加成功&quot;&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;添加失败&quot;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  如果是使用的默认模式，需要自己对结果进行判断输出
//     $sql=&quot;insert into use4r1(name,Password,Email,age) values('hello',md5(456),'hello@qq.com',55);&quot;;
//     $res=$_pdo-&amp;gt;exec($sql);
//     if (!$res){
//         print_r($_pdo-&amp;gt;errorInfo());
//     }&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二：查（一次执行一个查询，应使用query()方法）&lt;/h3&gt;
&lt;p&gt;query()方法详解：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置字符集编码（$_pdo-&amp;gt;query(&quot;SET NAMES UTF8&quot;);）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;获取数据集（返回的不是结果集，而是预处理对象PDOStatement）&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/772876/201801/772876-20180117130507146-1690107990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;$drive_opt&lt;/span&gt;=&lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
    PDO&lt;/span&gt;::MYSQL_ATTR_INIT_COMMAND=&amp;gt;'SET NAMES UTF8',&lt;span&gt;
    PDO&lt;/span&gt;::ATTR_ERRMODE=&amp;gt;PDO::&lt;span&gt;ERRMODE_EXCEPTION  
);
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PDO('mysql:host=localhost;dbname=test','root','',&lt;span&gt;$drive_opt&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;){
   &lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;('数据库连接失败'.&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;$sql1&lt;/span&gt;=&quot;select id,name from user1;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;= &lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;query(&lt;span&gt;$sql1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$stmt&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以对象的方式获取下一行的结果集
//     while(!!$_row=$stmt-&amp;gt;fetchObject()){
//         print_r($_row);
//     }
//----------一次性获取所有的数据----------
//     foreach ($stmt-&amp;gt;fetchAll()as $_row){
//         print_r($_row);
//     }
//-----------使用fetch方法，可以获取结果集下一行------------------
//     while (!!$_row=$stmt-&amp;gt;fetch()){
//         print_r($_row);
//     }
    //-----------通过foreach循环来获取每行的数据------------------&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$stmt&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$_row&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;$_row&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         echo $_row[0].&quot;----&quot;.$_row[1].&quot;&amp;lt;br/&amp;gt;&quot;;&lt;/span&gt;
&lt;span&gt;    }
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
}
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多次执行一个查询（prepare()）&lt;/p&gt;
&lt;p&gt;准备语句是使用两个方法实现的：prepare()负责准备要执行的查询，execute()使用一组给定的列参数返回地执行查询。这些参数可以现实地作为数组传递给 execute()方法，也可以使用通过 bindParam()方法指定的绑定参数提供给 execute()方法。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;如果采用 prepare 和 execute&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt; 方法，还可以防止 &lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;SQL 注入等攻击。因为所有的变量都会&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;被自动转义。而如果采用 query()方法，将不具备这种保护，必须手动转义，比如使用 PDO&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;里的 quote()方法来转义变量&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;使用prepare和execute方法增删改&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PDO('mysql:host=localhost;dbname=test','root',''&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         $sql='';
//         $sql=&quot;insert into user1(name,Password,Email,age) values('hi',md5(456),'hi@qq.com',55);&quot;;&lt;/span&gt;
        &lt;span&gt;$sql&lt;/span&gt;=&quot;update user1 set name='test_hhh' where id=3&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;prepare(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span&gt;execute();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         rowCount()获取影响的行数，通过影响的行数判断是否增删改成功&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span&gt;rowCount()){
            &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;修改成功&quot;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;数据没有被修改，修改失败&quot;&lt;span&gt;;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         获取最后新增的id
//         echo &quot;新增的id为&quot;.$_pdo-&amp;gt;lastInsertId();&lt;/span&gt;
?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;新增多条数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PDO('mysql:host=localhost;dbname=test','root',''&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         使用”？“号准备语句新增多条数据&lt;/span&gt;
           &lt;span&gt;$sql&lt;/span&gt;=&quot;insert into user1(name,Password,Email,age) values(?,?,?,?);&quot;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;prepare(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;execute(&lt;span&gt;array&lt;/span&gt;('aa','md5(456)','aa@qq.com','55'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         使用”：名称“号准备语句新增多条数据 &lt;/span&gt;
           &lt;span&gt;$sql&lt;/span&gt;=&quot;insert into user1(name,Password,Email,age) values(:name,:Password,:Email,:age);&quot;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;prepare(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;execute(&lt;span&gt;array&lt;/span&gt;(':name'=&amp;gt;'abc',':Password'=&amp;gt;'111',':Email'=&amp;gt;'abc.qq.com',':age'=&amp;gt;'18'&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;          结合绑定新增多条数据         &lt;/span&gt;
           &lt;span&gt;$sql&lt;/span&gt;=&quot;insert into user1(name,Password,Email,age) values(:name,:Password,:Email,:age)&quot;&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;prepare(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;bindParam(':name', &lt;span&gt;$name&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;bindParam(':Password', &lt;span&gt;$Password&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;bindParam(':Email', &lt;span&gt;$Email&lt;/span&gt;&lt;span&gt;);
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;bindParam(':age', &lt;span&gt;$age&lt;/span&gt;&lt;span&gt;);        
           &lt;/span&gt;&lt;span&gt;$name&lt;/span&gt;='qwe'&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$Password&lt;/span&gt;='555'&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$Email&lt;/span&gt;='qwe@qq.com'&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$age&lt;/span&gt;='18'&lt;span&gt;;
           &lt;/span&gt;&lt;span&gt;$stmt&lt;/span&gt;-&amp;gt;&lt;span&gt;execute();
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;PDO 为能够执行事务的数据库提供了事务支持。有 3 个 PDO 方法可以完成事务任务：&lt;em id=&quot;__mceDel&quot;&gt;beginTransaction()、commit()和 rollback()。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;所谓事务，说白了，就是一组 SQL 关联的操作，如果其中一条 SQL 有误没有执行，而其他的 SQL 都会撤销执行。&lt;/li&gt;
&lt;li&gt;MySQL 数据库类型为 InnoDB 方可启用事务处理&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; PDO('mysql:host=localhost;dbname=test','root',''&lt;span&gt;);
            
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;         PS:一定要注意定义error模式。不然不会执行try catch&lt;/span&gt;
        &lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;setAttribute(PDO::ATTR_ERRMODE,PDO::&lt;span&gt;ERRMODE_EXCEPTION );
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;beginTransaction();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启事务&lt;/span&gt;
   &lt;span&gt;$sql&lt;/span&gt;=&quot;UPDATE account1 SET balance=balance+50 where id=1;&quot;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;$_stmt&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;prepare(&lt;span&gt;$sql&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;$_stmt&lt;/span&gt;-&amp;gt;&lt;span&gt;execute();
   &lt;/span&gt;&lt;span&gt;$sql1&lt;/span&gt;=&quot;UPDATE account1 SET balance=balance-50 where id=2;&quot;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;$_stmt1&lt;/span&gt;=&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;prepare(&lt;span&gt;$sql1&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;$_stmt1&lt;/span&gt;-&amp;gt;&lt;span&gt;execute();
   &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;commit();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;
} &lt;span&gt;catch&lt;/span&gt; (PDOException &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;die&lt;/span&gt;(&lt;span&gt;$e&lt;/span&gt;-&amp;gt;&lt;span&gt;getMessage());
    &lt;/span&gt;&lt;span&gt;$_pdo&lt;/span&gt;-&amp;gt;rollBack();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回滚&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 17 Jan 2018 07:36:00 +0000</pubDate>
<dc:creator>花花妹子。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/8013-cmf/p/8303222.html</dc:identifier>
</item>
<item>
<title>从Unity中的Attribute到AOP(八) - 星门</title>
<link>http://www.cnblogs.com/cangxw/p/8303171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cangxw/p/8303171.html</guid>
<description>&lt;p&gt;本文将讲一下在UnityEditor命名空间下的一些特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CallBackOrder&lt;/strong&gt;，这个Attribute是所有带callback index的Attribute的基类，由于官方也没有给出详细的说明，因此这里暂略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PreferenceItem&lt;/strong&gt;，这个特性是在Preference界面新加一个选项。以官方代码为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117115958506-551799880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，这段代码我们放在了一个普通类中，并没有继承自Monobehaviour，其实继不继承都可以，但方法必须是静态方法。&lt;/p&gt;
&lt;p&gt;我们在Editor里面选择Preference菜单，可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117120202490-1286194685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ShaderIncludePath&lt;/strong&gt;，这个特性是2018.1b版本新加的特性。&lt;/p&gt;
&lt;p&gt;当我们尝试些一个shader库的时候，会经常需要include一些存在任意位置的文件，这个特性允许你返回一些列的shader include路径。查看官方代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DefaultShaderIncludes
{
    [ShaderIncludePath]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] GetPaths()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Assets/ScriptableRenderPipeline/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Assets/SRP/ScriptableRenderPipeline/LightweightPipeline/Shaders&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;DrawGizmo&lt;/strong&gt;属性允许你为任何一个Component提供一个gizmo渲染器。渲染器的函数必须是静态的，并且需要两个参数：正在绘制的Gizmo的对象，以及指示正在绘制Gizmo的GizmoType。&lt;/p&gt;
&lt;p&gt;渲染器的函数可以在任意的函数内，包括Editor文件，这样你不必放在组件脚本中，也不会被包含在工程中。&lt;/p&gt;
&lt;p&gt;新建代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117144004740-1718817771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意Test并没有从Mono继承过来，而这个Attribute有一个可选参数。&lt;/p&gt;
&lt;p&gt;在场景中我们新建一个空GO，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117143616912-1039890631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认选中是什么也没有的，把Test脚本中指定ComponentTest的添加到GO上，再次选中，则可以看到：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117144046068-388774069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以根据自己的具体情况来绘制，具体绘制参考&lt;a href=&quot;https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Gizmos.html&quot; target=&quot;_blank&quot;&gt;Gizmos&lt;/a&gt;类。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;InitializeOnLoad&lt;/strong&gt;和&lt;strong&gt;InitializeOnLoadMethod&lt;/strong&gt;这两个特性功能类似，都是在Unity启动时候可以执行一系列操作，这个操作主要针对编辑器。&lt;/p&gt;
&lt;p&gt;写了以下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117150812506-1923625003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意构造函数必须为静态的。当Unity启动的时候，会自动运行今天运行里面的内容。同时我们也可以指定一些编辑器里的其他操作。如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117152028459-950903131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，编辑器里会不停地输出。每次修改完代码，编辑器会重新执行一次Test构造函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1314038/201801/1314038-20180117152525959-1787571466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二个Attribute则是作用于静态函数之上。功能类似。&lt;/p&gt;
&lt;p&gt;关于&lt;strong&gt;CustomEditor&lt;/strong&gt;，&lt;strong&gt;CanEditMultipleObjects&lt;/strong&gt;，&lt;strong&gt;CustomPreview&lt;/strong&gt;，&lt;strong&gt;CustomPorpertyDrawer&lt;/strong&gt;之后会在关于Editor扩展中进行讲解。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 07:30:00 +0000</pubDate>
<dc:creator>星门</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cangxw/p/8303171.html</dc:identifier>
</item>
<item>
<title>浩瀚的知识海洋中怎么管理自己的知识 - 幕三少</title>
<link>http://www.cnblogs.com/smiler/p/8302971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smiler/p/8302971.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;strong&gt;已调整格式段落!!!&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;知识管理方法论解决的是效率和效果的问题,其实没有方法论的时候,足够的专注和努力也是可以的,许三多就是这方面的典型代表,他几乎没有什么技巧性的方法,完全是靠执着和努力,这种&quot;傻气&quot;有一个中肯的名字叫做&quot;钝感力&quot;.方法论并不意味着能够&quot;空手套白狼&quot;,其出发点并不是投机取巧的心理,而是一种自我调整过程中摸索出来一套最优方案组合;这样看个人知识管理方法论有两个特点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[1] 不是那么具有普适性,至少不是任何人都能全盘拿过来用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2] 方法论是动态的,会根据个人的情况进化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;   &lt;span&gt;个人知识管理方法论的关键在于其有效性,所以在不断的进化过程中,一些无效的行为会识别出来进行剪除;比如,我从来不用浏览器收藏,也不会囤积电子书,因为我发现收藏过的文章几乎都不会再看,囤积的电子书就那么一两本会看;对我来说这两件事情用下面的方式是有效的:在Evernote里面有一个&quot;待读&quot;列表,我会逐渐把里面的文章消化掉;电子书要读的,我会放在Kindle里面.下面这张图就是我知识管理方法论的概况:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/17329/201402/052134533722447.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;    好多人宁可先陷入各种细节中也不愿意去想想自己&lt;strong&gt;目标&lt;/strong&gt;是什么,回避最开始的目标设定环节.翻翻讲时间管理的书,很多时间管理技法的书都是从如何操作开始,而关键的并不是技法,是目标,试想如果没有目标,或者没有想清楚目标,那么使用各种技巧争取来的整块时间用来做什么呢?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   类似的,知识管理也是要从目标设定开始,先确定做事的意义所在,做到什么程度;否则你投入了很多精力在一个领域,你得到你想要的了吗?你达到预期的效果了吗?没法回答!&quot;但行好事,莫问前程&quot;,&quot;本想顺路打劫,哪想弄假成真&quot;这两种心态说不上坏,但也算不上好;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   设定了目标,就有了目的地,从你现在的位置到目的地怎么完成这段旅程?这就是&lt;strong&gt;路线图&lt;/strong&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我们读书的时候,有目录,目录其实就是一本书的路线图;阅读过程中善用目录是学问的,详情请参见&amp;lt;如何阅读一本书&amp;gt;.我们需要拟定一个类似的东西,路线图的好处是,我们在任一时刻都知道自己在什么位置,下一步要到哪里,障碍是什么.有什么方法可以帮我们克服障碍.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  没有目的地的船是无所谓偏离航道的.&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;     &lt;span&gt;输入有很多方式,或者说有太多的方式,在信息轰炸情况下,获取遴选优质的信息是必备技能;RSS,邮件推送是我最常用的信息获取方式;到目前为止我还是排斥微博,微信这类信息渠道,我发现只要是重要的信息,不上微博也会有其它渠道看到,而微博获取信息的成本太高了,超级碎片化无关联的信息,很难集中精力,所以早早的玩了一阵微博后,就决然退出不玩了;微信也类似,社交网络在信息获取上的特点是你关注了什么人就得到了什么信息,明白了这一点,完全不必拘泥于微博,可以通过RSS之类完成这个过程;对于豆瓣我有两种截然不同的用途,一方面维护了一个Erlang资讯小站,另一方面我关注了一堆和电影,音乐相关的人;因为豆瓣小站和个人主页的时间线有明显产品形式上的区分,所以很容易完成两种状态的切换.还有一点要强调的是:作为一个成熟的人,一定要意识到你在社交媒体上的种种行为对别人来讲是没有多大意义的;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;   2.1输入过水&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;   &lt;span&gt;读技术类的书的时候,我都会预测一下,这本书要是我写,我会怎样注水凑字数;开始阅读的时候,就会比较有意识的把注水的部分略过.比如:讲Redis的书注水的方式就是大篇幅讲如何安装,没节操点就把安装输出也打印出来,然后罗列一堆命令,逐一解释;讲大数据的书,就先大篇幅讲大数据发展现状,前景,展望... 在图书信息组织上,这种信息无可厚非,逻辑上是说的通的,但,这是你想从书中得到的吗?&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;   2.2 高强度的输入过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt; 不得不承认的是,在输入的过程中,信息会出现丢失;所以,会有一些高强度的方法来尽可能的减少信息输入过程中的丢失,比如开源项目代码注释版,手敲代码,翻译文章,为代码绘制流程图等等;这些都不轻松,比如翻译文章可以试一下,读一篇技术文章和信达雅的翻译,投入的精力可能差很多.很多人无法理解技术人的这种行为,认为难以理解,我是这样解释的:&quot;作为一个技术人,发现一个好的项目,恨不能把自己也编译到代码里面去&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;   2.3 榨取每一次输入的价值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;    &lt;span&gt;我把每一次的输入都当做&quot;线索&quot;;买到一本好书的时候我会把这个作者其它的作品也看一下;搜索到一个资料的时候,我会关注一下这个网站,如果是平台就注册一下;如果是Blog就订阅一下RSS,就看看这个博客的主人还关注了哪些人;如果是中文作者,看看他们有没有豆瓣ID,你认可的人读过的书,可能是一个非常好的阅读线索.&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;   2.4 &lt;strong&gt;自己的错误是最好的输入&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;  &lt;span&gt;我曾经开玩笑说&quot;小时候把错误较多试卷盖住的孩子,长大后会习惯性Catch所有异常而不处理&quot;;自己犯的错误是最佳的输入,这要么是知识盲点,要么是思维缺陷,相比那些已经做得很好的事情,这些错误才真正包含让你更强的信息量.面对错误的那种挫败感和后悔情绪是于事无补的,无任何建设性,&quot;往者不可谏来者犹可追&quot;说的就是这个道理.我第一次看到&quot;破甑不顾&quot;这个成语真心佩服:&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;  《后汉书·郭泰传》：“客居太原，荷甑堕地，不顾而去。林宗见而问其意，对曰：‘甑已破矣，视之何益。’&lt;/p&gt;

&lt;/blockquote&gt;



&lt;p&gt;    &lt;span&gt;内化,就是有自己的看法,自己的理解;&quot;自己的看法&quot;,这个东西在咱们这里挺稀罕,我们被灌输了太多标准化的东西,自己的看法被大大的弱化了;内化就是用自己的思维方式话语方式去描述一个东西,一个比较好玩的例子就是王朔用北京话翻译了一遍&amp;lt;金刚经&amp;gt;和&amp;lt;六祖坛经&amp;gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    内化不是简单记住,知识需要/值得记住的部分是有限的,把可以RTFM从大脑移除,让值得思考的部分留在大脑;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一本书或者一份资料放在面前,没有必要完全按照现有的结构去接受它,可以进行信息的结构上的重构;这种重构只有一个标准:自己理解起来方便.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.3 多种视角&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;       &lt;span&gt;从多个视角来观察事物,可以获得更深的印象更好的理解,如果只有一种视角来观察事物,那么看待事物的肯定是片面的;学习同样一种知识也需要多个角度,如果只是一种角度,那最后脱离了这种视角就无法解决问题了;比如,我们熟记TCP/IP相关的各种资料,却不知道在现实中这些参数对应的问题和现象是什么,那么这就是典型的一种维度缺失,只适合用来考试而不是自己掌握的技能;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images0.cnblogs.com/blog/17329/201402/052113353653254.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt; 关系型数据库实际上是对现实世界的一种抽象方式,不同的抽象方式落实在设计中就是不同的数据表,不同的数据字段; 当我们接触一个新知识的时候,书本上给我们只是知识的一个切片,一种抽象而已;避免盲人摸象的尴尬就需要从多个视角去认识同一个事物.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     多种视角实际上是对书本知识的突破,因为书本上通常只提供一两种视角的解读,从多个视角去分析解构知识,能够获得&quot;自己的看法&quot;.换句话说,在从多个视角去理解一个知识的时候,实际上完成了知识的内化过程.如果只用一种方式了解一个事物,那你就没有真正理解它.在我们所受的教育中,一个非常的变态的概念就是&quot;标准答案&quot;,一个更变态的是&quot;标准过程&quot;,前者还只是答案正确即可,后者还要要求过程也正确.横切苹果的案例实际上就是一个事物从不同视角切入时的奇妙景象.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images0.cnblogs.com/blog/17329/201402/052118346091232.jpg&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;  高中时代有一个事情,一个运算能力超强的同学,在解决物理试卷上往对面扔沙袋,扔多少个对面小车会停住的问题时,没有使用数学归纳发,而是1,2,3,4,5....这样一个个算出来的,算到第21个的时候,得到答案;这个事情留下印象太深了,使用数学归纳法的也未必真正理解其解法的合理性,而这位同学使用了一种自己理解且擅长的方式解出了问题,值得琢磨.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    &lt;span&gt;如何找到多个视角呢?&lt;strong&gt;这里有一个工具就是&quot;提问&quot;&lt;/strong&gt;;比如我们现在遇到一个新的东西:Redis,在了解了基本的情况之后,我们可以提出一堆问题:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Redis和Memcached区别是什么?本质差异在哪里?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis的性能怎么样?和Memcache相比如何?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis安装,部署,使用上有什么需要注意的?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis的数据结构在实际业务场景中有哪些&quot;最佳实践&quot;?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis在NoSQL体系中是怎么分类的?为什么?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis的Bitmap有什么妙用?在以前这些问题是怎么解决的?&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis模拟队列和Rabbitmq队列&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;........&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;span&gt;这里可以提出的问题太多了,甚至有些问题需要去代码里面寻找答案了.能够提出问题,实际上是强调了&quot;主动性&quot;,通过主动思考发现其中的疑问,而不是被动的灌输;一开始通过提问打开多种视角的时候,效果可能非常差,主要是问题问得太水了,只要多练习,特别是针对一种类型的事物反复练习再次遇到同类型的事物基本上条件反射就能提出质量较高的问题.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;3.4 可复用视角(思考模型)   &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    同一类事物,我们提出的问题往往是类似的,比如网站系统会考虑页面缓存,静态动态资源分离,SEO优化等等;如果是数据库方案会考虑业务数据的使用情况,数据增长情况,对事务的要求;如果是接口调用,会考虑安全问题,信任问题等等;这些对同一类事物可复用的视角,可以固化下来作为一种思考模型,省得每一次都从头开始想起了,在不断使用过程中思考模型也不断的调整优化;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    我至今难以理解的就是政治课和政治试题,这门课你不能用自己的语言去解答,需要按照书本上的标准描述去回答,因为老师要计算得分点,在快速判卷的情况下,死记硬背标准话语模式是有效的.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   系统化,实际上就是建立知识点之间的联系,不再孤立,把它融入你的知识体系,说句矫情的话就是&quot;不让一滴水蒸发最好的方法就是把它放入大海&quot;.系统化的知识是不容易遗忘的,即使忘掉了,也可以顺藤摸瓜把相关的东西全拎出来;如何做到系统化呢?这里我常用的工具是&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[1]&quot;画图&quot; &lt;/p&gt;
&lt;p&gt;[2]&quot;讲故事&quot; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;画图&lt;/strong&gt;,有两种方式;一种是直接用纸笔画图,纸笔没有什么讲究,随便写,随便画;一种是思维导图工具,思维导图工具用了好多年,在还没有接触过电脑的时候我就开始用思维导图,这也是让我接触电脑后最为惊喜的软件.知识长时间不用必然存在遗忘,不必纠结,我们能做就是留下足够的&quot;线索&quot;或者说是索引,需要的时候有足够的线索唤醒就OK,图形化的内容由于直观简洁且都是按照自己的思路整理出来的,再次进入真的很快.今年在项目中再次用到Storm的时候,我找到了当时的思维导图和笔记,有种热数据瞬间加载的感觉,非常棒.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;&lt;strong&gt; 讲故事&lt;/strong&gt;,这也是常用的一个方法,王朔在&amp;lt;致女儿书&amp;gt;里面就是用讲故事的方式把人类进化史和自己家族的历史讲了一遍,也有文章用某种语言设计过程中的趣事八卦串联起来语言的演变过程,这些都是把枯燥的知识有趣化,孤立的知识系统化的好方法.&amp;lt;苏菲的世界&amp;gt; &amp;lt;上帝掷骰子吗?&amp;gt;都是这方面的典范;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   讲故事还有一种套路就是&lt;strong&gt;跨学科讲故事&lt;/strong&gt;;高中时候的生物老师是这方面的好手,他经常这样:&quot;在茫茫的草原上,各种动物刚刚渡过了寒冬,一场在幸存者之间的杀戮马上就要开始,同学们想一想这个食物链是怎样的?今天我们要讲的就是食物链.....&quot; &quot;李白斗酒诗百篇,白酒经过消化道发生了哪些变化?&quot;.就这样天马行空但从不喧宾夺主,这位从不用普通话讲课的老师,给同学们留下无数谈资;我们的生物课成绩也是相当不错;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   我也试过比喻类比之类的方式,发现这种路子开始的时候有效,慢慢就会把我带上歪路;理由很简单,既然是客观上两个截然不同的东西,比喻和类比只能在一定程度上进行,分寸把握不好反而会影响理解.目前对我而言,还在尝试中的方法是TRIZ理论,还不好说效果如何,已经验证行之有效的方法就是画图和讲故事.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   在我们所受的教育中,特别是在面对考试的时候,特别强调的就是&quot;知识点&quot; &quot;重点&quot;,零散的知识点是经不起时间考验的,好在学校里面通过反复的练习强化,来对抗这个记忆衰退.当我们走出校园,开始在工作中使用掌握的知识的时候,还有重点吗?只要影响你解决问题的都是重点.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重点? 知识深度和广度&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   重点,是一种非常功利化的概念,是针对考试去讲的,隐含的意思是能够立竿见影有较高的ROI.但实际工作中出现的问题不是XX命题小组搞出来的了,哪里有什么重点.之前和梁同学聊这个问题的时候,我们把知识掌握情况大致划分成下面几种:&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;已经掌握的知识,需要解决的问题是抗遗忘&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;以为自己掌握而实际未掌握的知识,一旦遇到问题就能发现,及时弥补即可&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;知道自己不知道的知识,很简单,意识到短板,弥补即可&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不知道自己不知道的知识,这种是最可怕的,往往会做出错误归因&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;   特别关注一下最后一点,比如我们在解决某个技术问题时用了很久,表面原因是我们用很久才定位问题,其深层次的原因可能是在于我们对操作系统,对网络知识掌握不扎实,不能够快速的定位或者排除某个可选项;所以我常常和朋友开玩笑说,基础知识是那种平时看没什么用,用到的时候抱不了佛脚的知识,甚至你都意识不到是基础知识缺乏导致的问题,这里的基础知识是不限于计算机领域的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  知识点之间建立联系,从某个点看,要么是在深度上下功夫,要么是在广度上下功夫;深度层面探究原理,机制,思想;广度方面看应用,看实践;深度和广度两者是互相影响的,这对我们也是一策略调整的机会:深入研究一段时间之后可以透透气看看应用层面的东西,反之亦然.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;注意止损&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    无论是深度探索还是广度探索,可能在某个点上,我们投入了很多精力却收获很少,ROI很低,边际效益递减;这时候,需要提醒自己适时止损,跳出;可能过一段时间之后,再回头看的时候就会有新的理解了,可以进行下去了.其实这是一种有效避免小巷思维的方法.比如我研究一个开源项目的时候,有一个地方想了两天没明白为什么这样设计,我给自己的截止时间就是两天,然后我就把这个事情挂起了,后来看文档的时候看到了那个设计的解释,豁然开朗.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      &lt;span&gt;掌握知识一定要有输出思维,输出方式可以是在项目中实践,可以是给自己或别人讲清楚,可以是一篇文章或者是一副图,但是无论如何一定要有输出;信息闭塞时代,一招鲜吃遍天和教会徒弟饿死师傅的情况并存,但是网络打破了这种情况,只有分享和思辨才能保持知识的新鲜.我老家所在的村庄有很多做豆腐的,但是只有一家从南方学来了制作&quot;豆腐泡&quot;的工艺,每次做的时候都是大门紧闭,对外人一字不漏;后来接触网络,我在搜索引擎中搜索的前十个问题中就有这个,原来关键在于收水和油温;看,这种知识壁垒,在网络时代是很容易打破的;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    输出最简单的形式就是讲给自己听了,你以为掌握了,开始尝试把这个东西讲出来的时候就颠三倒四,是真掌握了吗?输出给同事,既然是输出给同事,占用别人的时间,如果你提供的信息混乱没有干货,真是罪莫大焉,出于对听众负责的态度也要保证分享内容的质量;输出为一篇博客文章,只要不是涉及商业机密的内容,总是有好处的.刘未鹏之前写过一篇 &lt;a href=&quot;http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/&quot;&gt;为什么你应该（从现在开始就）写博客&lt;/a&gt; ,博客也是一种很好的输出方式,具体好处请看原文.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     输出思维一方面强迫我们用主动的和&quot;实用&quot;的标准去认知,一方面通过外界反馈调整;如果没有输出,学了就是学了,连一个检验是否真的懂了的方式都没有,有什么意义呢? &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 07:05:00 +0000</pubDate>
<dc:creator>幕三少</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smiler/p/8302971.html</dc:identifier>
</item>
<item>
<title>迁移数据库数据到SQL Server 2017 - DB乐之者</title>
<link>http://www.cnblogs.com/wenBlog/p/8302903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenBlog/p/8302903.html</guid>
<description>&lt;h3&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h3&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇我们将利用DMA一步一步实现SQL Server 的迁移。帮助大家理解现在的SQL Server与新版本的融合问题，同时需要我们做哪些操作来实现新版本的升级或者迁移&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;SQL Server 迁移&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;一定要有一个准备好的计划，我下面列出了所有的迁移过程需要做的工作，如下列表：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;步骤列表&lt;/strong&gt;&lt;/h3&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SQL Server迁移步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;必要环境的准备（比如高版本的服务器操作系统）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;研究弃用和停用的功能、特性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;运行数据迁移助手（DMA）了解哪些改变不被允许或者会影响迁移。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;确认SQL Server 服务，数据引擎，SSIS,SSAS，SSRS等等可用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;排序规则注意一致或者有变更的仔细核对&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;确保应用程序的连接需求&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;日志、聚集、数据库镜像、复制、全文索引、分布式服务等服务类的都需要有计划的去管理迁移。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;管理有效的连接服务器，迁移&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;9&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;备份策略和计划的完整迁移，包含了完整、差别、事务日志备份。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;10&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;规划需要的磁盘空间&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;11&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;管理迁移各个服务的账号&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;检查数据一致性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;13&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;预升级--升级前后比较性能指标&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;14&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;评估宕机时间及影响&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;15&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;定稿升级流程&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;16&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;制定升级、迁移的验收标准&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;17&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;最终验收&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;18&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;回滚计划以及测试&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;19&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;务必通知所有涉及和影响的负责人&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;20&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;向所有负责人发送升级、迁移的步骤&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;21&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;准备新的、或者迁移旧的数据库维护计划&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;以上的列表就是我的迁移计划中的主要步骤，仅供参考。当然根据不同的环境和使用者的情况，可以调整出一套更适合自己的文档来满足需求，比如升级时的顺序，&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;手把手教你使用DMA&lt;/h3&gt;
&lt;p&gt;  &lt;span&gt;    经过上面，我们直奔主题，讨论如何使用DMA帮助我们初始评估迁移，在正式迁移之前需要一个预估。首先，请到微软的下载中心（&lt;a title=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=53595&quot; href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=53595&quot;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=53595&lt;/a&gt;），下载最新版本的DMA。然后安装，无论是服务器还是客户机，当你运行DMA后画面如下，当你是第一次打开这个向导时，需要创建一个项目。点击左侧的“+”号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/6483/SQL_Server-Migrate_2017-image001.jpg&quot; alt=&quot;DMA start screen&quot; width=&quot;624&quot; height=&quot;372&quot;/&gt;&lt;br/&gt;&lt;span&gt;开始屏幕&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一个屏幕中将会有两个选项:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) Assessment&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) Migration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们选择assessment，因为这时我们是评估并不是真的要迁移。在开始实际迁移之前，我们要评估所有的事实并分析报告。发现潜在的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/3239/SQL_Server-Migrate_2017-image002.jpg&quot; alt=&quot;Project type and Project name&quot; width=&quot;624&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在选择后，你需要制定一个项目名称，比如我这边是从2014升级到2017，SQL2K14toSQL2K17。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在剩下的部分，你需要选择自己的源和目标服务器选择类型:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/9720/SQL_Server-Migrate_2017-image003.jpg&quot; alt=&quot;Source server type and Target server type&quot; width=&quot;623&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;源数据库类型即你计划迁移、升级的数据源类型，我这里选择的是SQL Server，当然也是支持其他类型数据源的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目标服务器类型只能选择SQL Server 或者Azure DataBase。我选择的是SQL Server。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成所有选型后，点击创建按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/2706/SQL_Server-Migrate_2017-image004.jpg&quot; alt=&quot;Create project&quot; width=&quot;623&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里将会创建你的评估项目，并且打开一个新的屏幕。新屏幕上将给你一个选项来选择目标数据库版本。我选的是2017。这里版本基于你的目标服务器类型。如果选择Azure服务器将会是Azure的版本，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/755/SQL_Server-Migrate_2017-image005.jpg&quot; alt=&quot;Select Target version&quot; width=&quot;624&quot; height=&quot;374&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;让我们继续，选择多选框，这里选中兼容性问题和新特性推荐。Check feature parity不能选择是因为这个选项是专门为Linux 上的数据库准备的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/4727/SQL_Server-Migrate_2017-image006.jpg&quot; alt=&quot;Select report type&quot; width=&quot;624&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来，需要连接源数据库的信息和权限。在屏幕下方，看到实例有关权限集的信息。点击Connect按钮连接数据库。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/4520/SQL_Server-Migrate_2017-image007.jpg&quot; alt=&quot;Select Source SQL Server and Authentication type&quot; width=&quot;623&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一旦，成功连接，下面就会真是给你可用的数据库。选择数据库评估迁移。这时你已经能够灵活的选择一个还是多个数据库进行迁移。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/4128/SQL_Server-Migrate_2017-image008.jpg&quot; alt=&quot;Select databases to assess&quot; width=&quot;624&quot; height=&quot;396&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里我选择了两个数据库，执行对它们的迁移评估。在点击ADD按钮后，下个界面将会开启迁移评估。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/9398/SQL_Server-Migrate_2017-image009.jpg&quot; alt=&quot;Start migration assessment&quot; width=&quot;624&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;评估时间取决于你的数据库大小，在下个界面，你会看到评估进度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/3642/SQL_Server-Migrate_2017-image010.jpg&quot; alt=&quot;Migration assessment progress&quot; width=&quot;624&quot; height=&quot;395&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后DMA完成所有评估，下图展示界面会展示评估结果。这个界面提供了情报信息帮助了解当前迁移的状况。包含了很多实际迁移中会触发的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/5633/SQL_Server-Migrate_2017-image011.jpg&quot; alt=&quot;Assessment report with Export report option&quot; width=&quot;624&quot; height=&quot;517&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;DMA提供了一个选项导出评估报告，两种格式; 1. JSON 2. CSV。这也简化了我们制作评估的难度，方便给其他人看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.databasejournal.com/imagesvr_ce/7289/SQL_Server-Migrate_2017-image012.jpg&quot; alt=&quot;Report format options to save&quot; width=&quot;624&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保存结果。迁移与评估操作基本类似这里就不在重复操作了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;     &lt;span&gt;DMA是一个强大的工具，能够评估SQL Server 升级和迁移到更高版本，从而满足公司和业务的需要。这个工具帮助迁移SQL Server到本地服务器或者是Azure上服务器。本篇我们一起一步一步的执行了整个SQL Server 2014 到 SQL Server 2017的迁移。按照我之前所列的步骤将其他任务依次完成，最后我这边完整升级了整个系统并没有出现其他问题。希望大家也能完美升级，不出bug。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 06:55:00 +0000</pubDate>
<dc:creator>DB乐之者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenBlog/p/8302903.html</dc:identifier>
</item>
<item>
<title>HashTable源码阅读 - hongdongjian</title>
<link>http://www.cnblogs.com/dj3839/p/8302851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dj3839/p/8302851.html</guid>
<description>&lt;p&gt;环境jdk1.8.0_121&lt;/p&gt;
&lt;p&gt;与HashMap有几点区别&lt;/p&gt;
&lt;p&gt;在HashMap中，冲突的值会在bucket形成链表，当达到8个，会形成红黑树，而在HashTable中，冲突的值就以链表的形式存储&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make sure the value is not null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Makes sure the key is not already in the hashtable.&lt;/span&gt;
        Entry&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; key.hashCode();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)tab[index];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(; entry != &lt;span&gt;null&lt;/span&gt; ; entry =&lt;span&gt; entry.next) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((entry.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; entry.key.equals(key)) {
                V old &lt;/span&gt;=&lt;span&gt; entry.value;
                entry.value &lt;/span&gt;=&lt;span&gt; value;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
            }
        }

        addEntry(hash, key, value, index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会发现求索引的方式也不一样，(hash&amp;amp;0x7FFFFFFF)%tab.length，而在HashMap中是(hash^(hash&amp;gt;&amp;gt;&amp;gt;16))&amp;amp;(tab.length-1)，可以看出HashTable里，并没有做出相应的优化，这边解释下HashMap中的优化，(hash^(hash&amp;gt;&amp;gt;&amp;gt;16))这一步是其实是让一个hash值的高16位和低16位做异或，混合高位和低位，加大低位的随机性，(hash^(hash&amp;gt;&amp;gt;&amp;gt;16))&amp;amp;(tab.length-1)求与，其实就是相当于HashTable中的取模，只是在你计算机中用位预算效率比较高，当然tab.length在HashMap中其实是一个2的n次方，所以能达到这一的效果。&lt;/p&gt;
&lt;p&gt;还有一点，可以看到HashTable中是不允许放值为Null的value，它会抛出错误。而且key值也不能为null，因为它直接拿key.hashCode()，null是拿不到hashCode也会发生错误。&lt;/p&gt;
&lt;p&gt;继续看addEntry，开始添加元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        modCount&lt;/span&gt;++&lt;span&gt;;

        Entry&lt;/span&gt;&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt;=&lt;span&gt; threshold) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rehash the table if the threshold is exceeded&lt;/span&gt;
&lt;span&gt;            rehash();

            tab &lt;/span&gt;=&lt;span&gt; table;
            hash &lt;/span&gt;=&lt;span&gt; key.hashCode();
            index &lt;/span&gt;= (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Creates the new entry.&lt;/span&gt;
        @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
        Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;) tab[index];
        tab[index] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
        count&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码非常简洁，如果数量大于限定值，就开始扩充，重新计算索引位置，然后插入&lt;/p&gt;
&lt;p&gt;先看插入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
tab[index] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;(hash, key, value, e);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在创建entry的时候，传了个bucket的第一个entry，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; Entry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Entry&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt;  key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看构造函数其实可以看出，在这里进行指向旧的第一个entry，因此，在hashtable中其实是插入在链表的头，而在HashMap是在尾&lt;/p&gt;
&lt;p&gt;然后我们在看它的rehash&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rehash() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; table.length;
        Entry&lt;/span&gt;&amp;lt;?,?&amp;gt;[] oldMap =&lt;span&gt; table;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAX_ARRAY_SIZE)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Keep running with MAX_ARRAY_SIZE buckets&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            newCapacity &lt;/span&gt;=&lt;span&gt; MAX_ARRAY_SIZE;
        }
        Entry&lt;/span&gt;&amp;lt;?,?&amp;gt;[] newMap = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;&lt;span&gt;[newCapacity];

        modCount&lt;/span&gt;++&lt;span&gt;;
        threshold &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1&lt;span&gt;);
        table &lt;/span&gt;=&lt;span&gt; newMap;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = oldCapacity ; i-- &amp;gt; 0&lt;span&gt; ;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; old = (Entry&amp;lt;K,V&amp;gt;)oldMap[i] ; old != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ; ) {
                Entry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; old;
                old &lt;/span&gt;=&lt;span&gt; old.next;

                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (e.hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; newCapacity;
                e.next &lt;/span&gt;= (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)newMap[index];
                newMap[index] &lt;/span&gt;=&lt;span&gt; e;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比HashMap简单的多。。。len扩充2*len+1，然后对原来bucket中的entry重新计算索引，并赋值，不改变链表原先的顺序，在HashMap中复杂的多，可以看我另个讲HashMap的博客&lt;/p&gt;
&lt;p&gt;而且在hashtable中，调用构造函数时，直接初始化了里面的数组table，而在hashmap中是在进行put操作时，进行初始化，这个操作也在resize中&lt;/p&gt;
&lt;p&gt;可以看下HashTable中的初始化方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; Hashtable(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Capacity: &quot;+&lt;span&gt;
                                               initialCapacity);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Load: &quot;+&lt;span&gt;loadFactor);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity==0&lt;span&gt;)
            initialCapacity &lt;/span&gt;= 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
        table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;&lt;span&gt;[initialCapacity];
        threshold &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一点，HashTable它的初始化，默认容量len是为11，后面也是2*len+1扩充，而HashMap是16，以后的扩充数量都是len*2，并且我们提供容量大小时，也是会转成一个2的n次方，为什么会有这样的区分，和它计算hash有关，在前面提到了(hash^(hash&amp;gt;&amp;gt;&amp;gt;16))&amp;amp;(tab.length-1)，2^n-1，二进制就是n个1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Hashtable() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(11, 0.75f&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但相对HashMap，HashTable是线程安全的，因为在很多方法，比如get,put,equals等，都使用了synchronized同步锁。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1. HashTable的key、value不能为null&lt;/p&gt;
&lt;p&gt;2. HashTable线程安全&lt;/p&gt;
&lt;p&gt;3. HashTable的优化其实没有HashMap做的好，在单线程的情况，最好使用HashMap&lt;/p&gt;
&lt;p&gt;贴上一句源码中的提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 * Java Collections Framework&amp;lt;/a&amp;gt;.  Unlike the &lt;span&gt;new&lt;/span&gt;&lt;span&gt; collection
 &lt;/span&gt;* implementations, {@code Hashtable} is &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt;.  If a
 &lt;/span&gt;* thread-&lt;span&gt;safe implementation is not needed, it is recommended to use
 &lt;/span&gt;* {@link HashMap} in place of {@code Hashtable}.  If a thread-&lt;span&gt;safe
 &lt;/span&gt;* highly-&lt;span&gt;concurrent implementation is desired, then it is recommended
 &lt;/span&gt;*&lt;span&gt; to use {@link java.util.concurrent.ConcurrentHashMap} in place of
 &lt;/span&gt;* {@code Hashtable}.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大致意思就是：不需要线程安全用HashMap，需要线程安全的高并发用ConcurrentHashMap&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 06:47:00 +0000</pubDate>
<dc:creator>hongdongjian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dj3839/p/8302851.html</dc:identifier>
</item>
<item>
<title>登录模块的进化史，带大家回顾java学习历程（二） - 独王</title>
<link>http://www.cnblogs.com/xiadewang/p/8302364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiadewang/p/8302364.html</guid>
<description>&lt;p&gt;接着前面的&lt;a target=&quot;_blank&quot;&gt;登录模块的进化史，带大家回顾java学习历程（一）&lt;/a&gt; 继续往下面讲&lt;/p&gt;
&lt;p&gt;前面我们去实现登录功能，都是想着要完成这个功能，直接在处理实际业务的类中去开始写具体的代码一步步实现，也就是面向过程的编程。&lt;/p&gt;
&lt;p&gt;那么现在我们站在设计的角度上去实现该如何做呢？实际上在项目开发的时候，需求规划和数据库设计好之后，我们开始写代码，往往只用写一些接口出来，接口里面只有一些各个业务对应的空方法，没有具体的实现，在架构师进行接口设计的时候，就已经想好了该功能之后通过实现与调用这个接口肯定是可以实现的，等各个功能相关的接口设计好之后，剩下的就是程序员去实现与调用这些接口，就跟填空一样。在做接口设计的时候只用关心方法的形参与返回值类型，可以写好对应的接口文档，描述每个接口的作用，接口中每个方法的形参的含义和返回值的含义，这样可以更好的方便团队开发。其实这个跟做房子很像，做房子也是先把设计图做好，然后搭建框架，剩下的就是码砖了。&lt;/p&gt;
&lt;p&gt;在我们使用函数（方法）的时候，我们要理解一个概念。一去一回（也可以说是请求与响应），特别是在做http请求时更加明显。在非void返回类型的函数中，都是需要retrun一个返回值的，而调用函数给形参传递实参的时候，这个过程我们就可以看做是“去”，在函数体类做一大堆的逻辑与业务的处理，待处理完之后，就返回一个结果回去，这个就是“回”。&lt;/p&gt;
&lt;p&gt;比如做一个网页登陆的功能，首先是从html里面的输入框将用户名和密码信息（实参）传递到服务端，服务端就存在一个checkLogin的函数来接收前端传递过来的实参，然后去查询数据库，处理完结果之后返回一个结果告知前端是否登录成功，前端可以根据这个返回值进行UI界面的提示与界面跳转等工作。在做分成业务涉及的时候，前面的用户名和密码可能还要经过几次函数之间的传递，但是都是又去有回。像web设计中的ajax与android网络请求retorfit中都体现的特别明显，大家充分理解了一去一回的原理之后，可以更加的方便我们对功能模块进行设计。&lt;/p&gt;
&lt;p&gt;好下面，我们具体来通过代码进行展示。&lt;/p&gt;
&lt;p&gt;我们新建一个java工程，然后此时我们不着急去写代码，先做个分包（package）的工作，相当于一个组织架构，使代码结构更加清晰，也更方便阅读与维护。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/890216/201801/890216-20180117135627912-907545703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;dao这个包下面就用来存放我们的接口，daoimpl下面用来存放我们的接口实现类，main作为项目的主入口，用来存放具体业务的实现，pojo用来存放数据模型类（等下具体讲解pojo的作用），utils用来存放工具类（把上一章我们写好的DBHelper放到这个包下）。&lt;/p&gt;
&lt;p&gt;POJO（Plain Old Java Objects）简单的Java对象，实际就是普通JavaBeans，其中有一些属性及其getter setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法，可以看成是与数据库中的表相映射的 java 对象。&lt;/p&gt;
&lt;p&gt;我们在pojo包下面新建一个User类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xdw.pojo;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; xiadewang
 *2018年1月14日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; User(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, String username, String password) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the id
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id the id to set
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the username
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username the username to set
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the password
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password the password to set
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面我们面向接口进行编程，比如说我们现在的业务有如下：&lt;/p&gt;
&lt;p&gt;1、登录&lt;/p&gt;
&lt;p&gt;2、注册&lt;/p&gt;
&lt;p&gt;3、根据id查询用户信息&lt;/p&gt;
&lt;p&gt;4、根据username查询用户信息&lt;/p&gt;
&lt;p&gt;5、修改用户密码&lt;/p&gt;
&lt;p&gt;这时候，如果是面向过程设计的话，我们就想着先去完整的完成登录的功能，然后完成注册的功能，然后继续下面的345的业务。&lt;/p&gt;
&lt;p&gt;换成接口设计的话，就是我们先在dao下面新建一个接口UserDao，具体代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xdw.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.pojo.User;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; xiadewang
 *2018年1月14日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 传递用户名和密码来校验登录
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkLogin(String username,String password);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 传递user对象来校验登陆
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User checkLogin(User user);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 传递user对象进来，返回值1代表注册成功，0代表注册失败
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; register(User user);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 传递int型的id参数，返回值为user对象
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; User getUserById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 传递字符串类型的用户名，返回值为user对象
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; username
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUserByUsername(String username);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 传递要修改密码的user对象，和要修改的密码，返回值1代表修改成功，0代表修改失败
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; password
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modifyPassword(User user,String password);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于这里的功能很简单，直接把接口说明文档写到了注释之中，这个时候设计工作就完了，下面换个程序员来完成程序的完整功能。&lt;/p&gt;
&lt;p&gt;在daoimpl包下面写一个接口实现类UserDaoImpl，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xdw.daoimpl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.dao.UserDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.pojo.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.utils.DBHelper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; xiadewang
 *2018年1月14日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#checkLogin(java.lang.String, java.lang.String)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkLogin(String username, String password) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#checkLogin(com.xdw.pojo.User)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User checkLogin(User user) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#register(com.xdw.pojo.User)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; register(User user) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#getUserById(int)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User getUserById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#getUserByUsername(java.lang.String)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUserByUsername(String username) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#modifyPassword(com.xdw.pojo.User, java.lang.String)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modifyPassword(User user, String password) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }



}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些都是编译器自动生成的代码，这个时候我们甚至都不用去完成里面每个方法的具体内容，可以直接跳到实现业务的主类中去实现我们的业务，因为这些方法都会存在一个默认的返回值，并不影响程序的编译与运行。&lt;/p&gt;
&lt;p&gt;这个时候我们在main包中创建一个实现业务的类MainClass，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xdw.main;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.dao.UserDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.daoimpl.UserDaoImpl;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.pojo.User;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; xiadewang
 *2018年1月14日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainClass {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        UserDao userDao=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDaoImpl();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userDao.checkLogin(&quot;xdw&quot;,&quot;123456&quot;&lt;span&gt;)) {
            System.out.println(&lt;/span&gt;&quot;用户xdw登录成功&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;用户xdw登录失败&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userDao.checkLogin(&quot;xxx&quot;,&quot;1234&quot;&lt;span&gt;)) {
            System.out.println(&lt;/span&gt;&quot;用户xxx登录成功&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;用户xxx登录失败&quot;&lt;span&gt;);
        }
        
        User user1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; User(1,&quot;xdw&quot;,&quot;123456&quot;&lt;span&gt;);
        User user2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; User(2,&quot;xxx&quot;,&quot;ttt&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userDao.checkLogin(user1) !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;用户xdw登录成功&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;用户xdw登录失败&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userDao.checkLogin(user2) !=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;用户xxx登录成功&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;用户xxx登录失败&quot;&lt;span&gt;);
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，我只用2个重载的checkLogin方法做了业务展示，大家现在可以运行下，运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/890216/201801/890216-20180117142739178-1455117313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进行到了，其实整个业务的设计与实现就完成了，剩下的工作我们就是要去具体的完善接口实现类的内容了，让他们更加的符合实际的业务处理，比如要连接数据库做真实的数据处理，这里只用第一个checkLogin做下举例，完善后的UserDaoImpl如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xdw.daoimpl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.dao.UserDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.pojo.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xdw.utils.DBHelper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; xiadewang
 *2018年1月14日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String sql = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DBHelper db1 = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ResultSet ret = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#checkLogin(java.lang.String, java.lang.String)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkLogin(String username, String password) {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            sql &lt;/span&gt;= &quot;select * from user where username= ? and password= ?&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SQL语句&lt;/span&gt;
            db1 = &lt;span&gt;new&lt;/span&gt; DBHelper(sql);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建DBHelper对象&lt;/span&gt;
            db1.pst.setString(1&lt;span&gt;, username);
            db1.pst.setString(&lt;/span&gt;2&lt;span&gt;, password);
            ret &lt;/span&gt;= db1.pst.executeQuery();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行语句，得到结果集&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ret.next()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            ret.close();
            db1.close();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
&lt;span&gt;            
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#checkLogin(com.xdw.pojo.User)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User checkLogin(User user) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#register(com.xdw.pojo.User)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; register(User user) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#getUserById(int)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User getUserById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#getUserByUsername(java.lang.String)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User getUserByUsername(String username) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (non-Javadoc)
     * @see com.xdw.dao.UserDao#modifyPassword(com.xdw.pojo.User, java.lang.String)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modifyPassword(User user, String password) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到这里就不用我来啰嗦接口的重要作用了吧，java的核心个人觉得就是类、对象与接口，特别是面向接口编程。&lt;/p&gt;
&lt;p&gt;初学者往往会觉得接口没什么鸟用，本来可以几行代码实现的功能，偏偏要添加一个接口出来，还要再添加一个实现类，不光增加代码还绕来绕去。&lt;/p&gt;
&lt;p&gt;通过这里的接口编程的演示，大家有没有发现可以让我们做项目的时候思路更加清晰，代码可阅读和可扩展性也越强。我们要有一个概念，编程不是代码越少越好，而是要设计与思路越清晰越好。&lt;/p&gt;
&lt;p&gt;这篇就到此为止，下一篇将引入servlet+jsp，到时候就会有UI界面了，前面的都还是console控制台输出，可能会觉得不过瘾，还是觉得代码没有什么用，不能运用到实际中。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 06:42:00 +0000</pubDate>
<dc:creator>独王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiadewang/p/8302364.html</dc:identifier>
</item>
<item>
<title>WebAPI 实现前后端分离 - 秃驴竟敢跟贫道抢师太</title>
<link>http://www.cnblogs.com/NET-BLOG/p/8286918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NET-BLOG/p/8286918.html</guid>
<description>&lt;p&gt;随着Web技术的发展，现在各种框架，前端的，后端的，数不胜数。全栈工程师的压力越来越大。&lt;/p&gt;
&lt;p&gt;现在的前端的框架，既可以做各种Web，又可以做各种APP，前端框架更新换代越来越快，越来越多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前端和后端进行调试，修改都非常麻烦。往往前端配合后端很痛苦，后端也嫌前端麻烦。&lt;/p&gt;
&lt;p&gt;（无解，能动手解决的事，尽量别动嘴。办公室应该常备一些，绷带，止血条，速效救心丸等药品。为了阻止事态升级，办公室要加强刀具管制条例。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前后端分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前端根据事先约定好的文档，可以自己摸拟数据，然后开发，测试，调试UI，发布到线上时把API接口改成线上API接口，即可完事。&lt;/p&gt;
&lt;p&gt;前端日后增加新功能，修改UI，自己修改，自己编译更新自己UI站点，发布线上只要调上线上API接口即可。并不需要麻烦到后端。两者工作进行分离。&lt;/p&gt;
&lt;p&gt;后端需要跟前端商量好接口，写好接口文档，在接口功能上相互沟通（其实相当于需求相互沟通），一旦接口文档订好之后，只需按事先约定实现API接口即口。把项目编译好发布到线上服务器。即可完事。&lt;/p&gt;
&lt;p&gt;后端实现WebApi接口，还可以面对各种调用，如PC端web，手机APP，或者其它设备。一个接口多种调用，实现代码去重。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作模式分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对前端和后端进行分离。各司其职，各自在自己的领域集中精力研究。更能有效的加深技术深度。&lt;/p&gt;

&lt;p&gt;前后端分离的模式，你需要N名前端工程师和N名后端工程师。&lt;/p&gt;
&lt;p&gt;首先我们要约定一些返回基本的格式，比如用XML，还是JSON。结果大多数前端都是喜欢JSON，因为JS天生就支持JSON。我贴出一些示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ResultCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1300&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;权限不足&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ResultCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1600&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;逻辑异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DetailError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ErrCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1601001&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ErrMsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;金额必须大于&amp;gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;返回参数说明&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;参数名&lt;/td&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;是否必有&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ResultCode&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;返回码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Message&lt;/td&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;结果说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;DetailError&lt;/td&gt;
&lt;td&gt;josn&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;具体错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Data&lt;/td&gt;
&lt;td&gt;josn&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;数据&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;p&gt;&lt;strong&gt;ResultCode&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;ResultCode&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1100&lt;/td&gt;
&lt;td&gt;服务器异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1200&lt;/td&gt;
&lt;td&gt;身份验证异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1300&lt;/td&gt;
&lt;td&gt;权限不足&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;1400&lt;/td&gt;
&lt;td&gt;传递参数验证不通过&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1500&lt;/td&gt;
&lt;td&gt;版本异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1600&lt;/td&gt;
&lt;td&gt;业务逻辑异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1700&lt;/td&gt;
&lt;td&gt;系统成升级中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1800&lt;/td&gt;
&lt;td&gt;该接口己弃用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;p&gt;&lt;strong&gt;具体异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个有点争议的地方，有很多业务逻辑异常，出于对用户的友好提示。一些生涩难懂的错误提示，直接给到用户，用户一脸懵逼。但是后端却不能修改成友好提示，这样不方便调试，寻找问题原因。&lt;/p&gt;
&lt;p&gt;一般来讲，前端可以自动修改友好提示给用户。&lt;/p&gt;
&lt;p&gt;如果后端返回字符串，前端写死在代码中，万一，某一天后端认为这个描述更符合场景，修改的字符串。敌军还有30秒到达战场。&lt;/p&gt;
&lt;p&gt;建议：尽量使用异常代码，大家可以看到上面贴出例子，就使用的异常代码。每种异常都有唯一编号，描述可以更改。但是编号不变。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;用户异常（1601000）&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1601001&lt;/td&gt;
&lt;td&gt;账号/密码错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1601002&lt;/td&gt;
&lt;td&gt;账号被冰冻&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1601003&lt;/td&gt;
&lt;td&gt;原密码不对&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;&lt;strong&gt;版本控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 每个API都有一个版本，其实也是就针对APP，如果是WEB端的，都是直接升级的因为B/S结构本身就是存在升级方便的优势，只需要把服务端更新就可以了。&lt;/p&gt;
&lt;p&gt;版本控制一般用两种方式&lt;/p&gt;
&lt;p&gt;第一种：URL不变，版本写在HTTP标头内面。&lt;/p&gt;
&lt;p&gt;第二种：版本写在URL上面。&lt;/p&gt;
&lt;p&gt;本人推荐第二种，比较直接方便了解。示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.xxx.com/版本号&lt;/span&gt;
&lt;span&gt;
当前版本号：v1

http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com/v1/UserSecurity/Login&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;API风格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在流行的api风格比较多，最出名的就是restful风格。&lt;/p&gt;
&lt;p&gt;按本人的经验，完全走restful风格是很困难的，可能也是水平问题，在团队内面也要考虑到其它成员的水平问题。我们目前API风格还是保留以前风格。&lt;/p&gt;
&lt;p&gt;示例，V*代表版本号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xx.com/V*/UserSecurity/SignOut&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;HTTP谓词&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Post 方法在服务器上创建/修改/删除资源&lt;/p&gt;
&lt;p&gt;使用 Get 方法从服务器检索某个资源或者资源集合&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本命名规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用骆驼式命名法-大驼峰法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;跨域处理&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前端站点和后端API布署到不同的站点，就会产生跨域问题。&lt;/p&gt;
&lt;p&gt;什么是同源策略？&lt;/p&gt;
&lt;p&gt;同源是域名，协议，端口相同。也就是说如果不同，则是非同源。&lt;/p&gt;
&lt;p&gt;同源策略是浏览器的一基本的安全功能，非同源访问，浏览器会进行拒绝。&lt;/p&gt;
&lt;p&gt;HMTL上面的SRC地址，你可以指定任何URL，表单提交，你可以提交到任何URL。&lt;/p&gt;
&lt;p&gt;但是，你如果使用AJAX技术，就会受到同源策略的影响，拒绝提交。&lt;/p&gt;
&lt;p&gt;现代浏览器几乎都支持跨域资源请求的一种方式。这种技术叫CORS（跨域资源共享）&lt;/p&gt;
&lt;p&gt;CORS跨域分两种&lt;/p&gt;
&lt;p&gt;第一种，简单跨域。&lt;/p&gt;
&lt;p&gt;第二种，复杂跨域。&lt;/p&gt;
&lt;p&gt;解决方案：HTTP输出标头增加如何节点&lt;/p&gt;
&lt;p&gt;注意有前端框架版本，对安全要求较高，不能使用通配符*，要指定跨域域名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Access-Control-Allow-Origin：*
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面节点可填，可不填，根据实际情况，自行决定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Access-Control-Allow-Methods：GET,POST,OPTIONS
Access-Control-Allow-Credentials：true
Access-Control-Allow-Headers：根据请求头的内容，填写
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：复杂跨域比要简单跨域麻烦，更花费性能。因为复杂跨域在请求之前会先发一个options预请求，根据响应判断服务器是否支持跨域。也就是说，实际上请求了两次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookies作用域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同的站点，如何通用Cookies?&lt;/p&gt;
&lt;p&gt;一般情况只需把cookies作用域设置顶级域名，浏览器会自动把cookies在访问子域名的时候捎上去。&lt;/p&gt;
&lt;p&gt;示例，访问二级域名时候，cookies默认会被传送过去。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;顶级域名:baidul.com
cookies作用域：.baidu.com
二级域名：
www.baidu.com
api.baidu.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面贴一些示例文档，其它的就不多讲啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/141499/201801/141499-20180117142800646-224055875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/141499/201801/141499-20180117142809740-38294613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/141499/201801/141499-20180117142827053-1116703926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;基本上，WebApi前后端分离的细节和注意点，都记录下来，还有更多的细节，需要读者在开发过程自己去寻找答案。随笔完毕！&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 06:31:00 +0000</pubDate>
<dc:creator>秃驴竟敢跟贫道抢师太</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NET-BLOG/p/8286918.html</dc:identifier>
</item>
<item>
<title>网络基础知识-网络协议 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8298025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8298025.html</guid>
<description>&lt;h2&gt;操作系统基础&lt;/h2&gt;
&lt;p&gt; 操作系统:(Operating System，简称OS)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。&lt;/p&gt;
&lt;p&gt;注：计算机(硬件)－&amp;gt;操作系统－&amp;gt;应用软件&lt;/p&gt;
&lt;h2&gt;网络通信原理&lt;/h2&gt;
&lt;h3&gt;——互联网的本质就是一系列的网络协议&lt;/h3&gt;
&lt;p&gt;一台硬设有了操作系统，然后装上软件你就可以正常使用了，然而你也只能自己使用，每个人都拥有一台自己的机器，然而彼此孤立，那么如何把每个人都联系在一起呢？&lt;/p&gt;
&lt;p&gt;如果把计算机看成分布于世界各地的人，那么连接两台计算机之间的internet实际上就是一系列统一的标准，这些标准称之为互联网协议，互联网的本质就是一系列的协议，总称为‘互联网协议’（Internet Protocol Suite).&lt;/p&gt;
&lt;p&gt;互联网协议的功能：定义计算机如何接入internet，以及接入internet的计算机通信的标准。&lt;/p&gt;
&lt;h3&gt;——网络层次划分&lt;/h3&gt;
&lt;p&gt;为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。&lt;/p&gt;
&lt;p&gt;　　除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示：&lt;/p&gt;

&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201509/764050-20150904094019903-1923900106.jpg&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;310&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;——OSI七层协议&lt;/h3&gt;
&lt;p&gt;互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层&lt;/p&gt;
&lt;p&gt;TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201509/764050-20150904095142060-1017190812.gif&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;273&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;——tcp/ip五层模型&lt;/h3&gt;
&lt;p&gt;我们将应用层，表示层，会话层并作应用层，从tcp／ip五层协议的角度来阐述每层的由来与功能，搞清楚了每层的主要协议&lt;/p&gt;
&lt;p&gt;就理解了整个互联网通信的原理。&lt;/p&gt;
&lt;p&gt;首先，用户感知到的只是最上面一层应用层，自上而下每层都依赖于下一层，所以我们从最下一层开始切入，比较好理解&lt;/p&gt;
&lt;p&gt;每层都运行特定的协议，越往上越靠近用户，越往下越靠近硬件。&lt;/p&gt;
&lt;h4&gt;（1）物理层&lt;/h4&gt;
&lt;p&gt;物理层功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0&lt;/p&gt;
&lt;p&gt;激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。&lt;strong&gt;该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。&lt;/strong&gt;物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。&lt;/p&gt;
&lt;h4&gt;（2）数据链路层&lt;/h4&gt;
&lt;p&gt;数据链路层由来：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思&lt;/p&gt;
&lt;p&gt;数据链路层的功能：定义了电信号的分组方式&lt;/p&gt;
&lt;p&gt; 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。&lt;/p&gt;
&lt;p&gt;　　有关数据链路层的重要知识点：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1&amp;gt; 数据链路层为网络层提供可靠的数据传输；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&amp;gt; 基本数据单位为帧；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3&amp;gt; 主要的协议：以太网协议；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4&amp;gt; 两个重要设备名称：网桥和交换机。&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;（3）网络层&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1&amp;gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&amp;gt; 基本数据单位为IP数据报；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3&amp;gt; 包含的主要协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　IP协议（Internet Protocol，因特网互联协议）;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;ARP协议（Address Resolution Protocol，地址解析协议）;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4&amp;gt; 重要的设备：路由器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（&lt;strong&gt;4）传输层（Transport Layer）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。&lt;/p&gt;
&lt;p&gt;　　传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。&lt;/p&gt;
&lt;p&gt;　　网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。&lt;/p&gt;
&lt;p&gt;　　有关网络层的重点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1&amp;gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&amp;gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3&amp;gt; 重要设备：网关。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（&lt;strong&gt;5）会话层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）表示层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。&lt;/p&gt;
&lt;p&gt;（7）应用层&lt;/p&gt;
&lt;p&gt;应用层由来：用户使用的都是应用程序，均工作于应用层，互联网是开发的，大家都可以开发自己的应用程序，数据多种多样，必须规定好数据的组织形式 &lt;/p&gt;
&lt;p&gt;应用层功能：规定应用程序的数据格式。&lt;/p&gt;
&lt;p&gt;例：TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。&lt;/p&gt;
&lt;p&gt;会话层、表示层和应用层重点：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1&amp;gt; 数据传输基本单位为报文；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2&amp;gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;网络通信实现&lt;/h2&gt;
&lt;p&gt;想实现网络通信，每台主机需具备四要素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本机的IP地址&lt;/li&gt;
&lt;li&gt;子网掩码&lt;/li&gt;
&lt;li&gt;网关的IP地址&lt;/li&gt;
&lt;li&gt;DNS的IP地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;获取这四要素分两种方式&lt;/p&gt;
&lt;p&gt;1.静态获取&lt;/p&gt;
&lt;p&gt;即手动配置&lt;/p&gt;
&lt;p&gt;2.动态获取&lt;/p&gt;
&lt;p&gt;通过dhcp获取&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;以太网头&lt;/td&gt;
&lt;td&gt;ip头&lt;/td&gt;
&lt;td&gt;udp头&lt;/td&gt;
&lt;td&gt;dhcp数据包&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。&lt;/p&gt;

&lt;p&gt;（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。&lt;/p&gt;

&lt;p&gt;（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。&lt;/p&gt;

&lt;p&gt;这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。&lt;/p&gt;

&lt;p&gt;接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。&lt;/p&gt;

&lt;p&gt;新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数&lt;/p&gt;
&lt;h2&gt;网络通信流程&lt;/h2&gt;
&lt;h3&gt;1.本机获取&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本机的IP地址：192.168.1.100&lt;/li&gt;
&lt;li&gt;子网掩码：255.255.255.0&lt;/li&gt;
&lt;li&gt;网关的IP地址：192.168.1.1&lt;/li&gt;
&lt;li&gt;DNS的IP地址：8.8.8.8&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.NAT协议&lt;/h3&gt;
&lt;p&gt;NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。&lt;/p&gt;
&lt;h3&gt;3.dns协议(基于udp协议)&lt;/h3&gt;
&lt;p&gt;DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，&lt;strong&gt;可以简单地理解为将URL转换为IP地址&lt;/strong&gt;。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180116221008146-1982423361.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;580&quot;/&gt;&lt;/p&gt;
&lt;p&gt;13台根dns：&lt;/p&gt;
&lt;p&gt;A.root-servers.net198.41.0.4美国&lt;br/&gt;B.root-servers.net192.228.79.201美国（另支持&lt;a class=&quot;baidu-highlight&quot; href=&quot;https://www.baidu.com/s?wd=IPv6&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;IPv6&lt;/a&gt;）&lt;br/&gt;C.root-servers.net192.33.4.12法国&lt;br/&gt;D.root-servers.net128.8.10.90美国&lt;br/&gt;E.root-servers.net192.203.230.10美国&lt;br/&gt;F.root-servers.net192.5.5.241美国（另支持&lt;a class=&quot;baidu-highlight&quot; href=&quot;https://www.baidu.com/s?wd=IPv6&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;IPv6&lt;/a&gt;）&lt;br/&gt;G.root-servers.net192.112.36.4美国&lt;br/&gt;H.root-servers.net128.63.2.53美国（另支持&lt;a class=&quot;baidu-highlight&quot; href=&quot;https://www.baidu.com/s?wd=IPv6&amp;amp;tn=44039180_cpr&amp;amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9ryR4nhnsn1b3ujfYPAfk0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3ErH0YPW6snH0&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;IPv6&lt;/a&gt;）&lt;br/&gt;I.root-servers.net192.36.148.17瑞典&lt;br/&gt;J.root-servers.net192.58.128.30美国&lt;br/&gt;K.root-servers.net193.0.14.129英国（另支持IPv6）&lt;br/&gt;L.root-servers.net198.32.64.12美国&lt;br/&gt;M.root-servers.net202.12.27.33日本（另支持IPv6）&lt;/p&gt;

&lt;p&gt;域名定义：http://jingyan.baidu.com/article/1974b289a649daf4b1f774cb.html&lt;/p&gt;
&lt;p&gt;顶级域名：以.com,.net,.org,.cn等等属于国际顶级域名，根据目前的国际互联网域名体系，国际顶级域名分为两类：类别顶级域名(gTLD)和地理顶级域名(ccTLD)两种。类别顶级域名是　　　　　　　　            以&quot;COM&quot;、&quot;NET&quot;、&quot;ORG&quot;、&quot;BIZ&quot;、&quot;INFO&quot;等结尾的域名，均由国外公司负责管理。地理顶级域名是以国家或地区代码为结尾的域名，如&quot;CN&quot;代表中国，&quot;UK&quot;代表英国。地理顶级域名一般由各个国家或地区负责管理。&lt;/p&gt;
&lt;p&gt;二级域名：二级域名是以顶级域名为基础的地理域名，比喻中国的二级域有，.com.cn,.net.cn,.org.cn,.gd.cn等.子域名是其父域名的子域名，比喻父域名是abc.com,子域名就是www.abc.com或者*.abc.com.&lt;br/&gt;一般来说，二级域名是域名的一条记录，比如alidiedie.com是一个域名，www.alidiedie.com是其中比较常用的记录，一般默认是用这个，但是类似*.alidiedie.com的域名全部称作是alidiedie.com的二级&lt;/p&gt;
&lt;h3&gt;4.HTTP协议&lt;/h3&gt;

&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;GET / HTTP/1.1&lt;br/&gt;Host: www.google.com&lt;br/&gt;Connection: keep-alive&lt;br/&gt;User-Agent: Mozilla/5.0 (Windows NT 6.1) ……&lt;br/&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&lt;br/&gt;Accept-Encoding: gzip,deflate,sdch&lt;br/&gt;Accept-Language: zh-CN,zh;q=0.8&lt;br/&gt;Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3&lt;br/&gt;Cookie: … …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。&lt;/p&gt;
&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　HTTP&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;协议包括哪些请求？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　GET：请求读取由URL所标志的信息。&lt;/p&gt;
&lt;p&gt;　　POST：给服务器添加信息（如注释）。&lt;/p&gt;
&lt;p&gt;　　PUT：在给定的URL下存储一个文档。&lt;/p&gt;
&lt;p&gt;　　DELETE：删除给定的URL所标志的资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　HTTP&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;中，&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;与&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）Get是从服务器上获取数据，Post是向服务器传送数据。&lt;/p&gt;
&lt;p&gt;　　2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。&lt;/p&gt;
&lt;p&gt;　　3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。&lt;/p&gt;
&lt;p&gt;　　4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。&lt;/p&gt;
&lt;p&gt;　　I. 所谓 &lt;strong&gt;安全的&lt;/strong&gt; 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。&lt;/p&gt;
&lt;p&gt;　　II. &lt;strong&gt;幂等&lt;/strong&gt; 的意味着对同一URL的多个请求应该返回同样的结果。&lt;/p&gt;

&lt;h3&gt;5 TCP协议&lt;/h3&gt;

&lt;p&gt;TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。&lt;/p&gt;
&lt;p&gt;TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　IP层接收由更低层（网络接口层例如以太网设备驱动程序）发来的数据包，并把该数据包发送到更高层---TCP或UDP层；相反，IP层也把从TCP或UDP层接收来的数据包传送到更低层。IP数据包是不可靠的，因为IP并没有做任何事情来确认数据包是否按顺序发送的或者有没有被破坏，IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）。&lt;/p&gt;
&lt;p&gt; 　　TCP是面向连接的通信协议，通过三次握手建立连接，通讯完成时要拆除连接，由于TCP是面向连接的所以只能用于端到端的通讯。TCP提供的是一种可靠的数据流服务，采用“带重传的肯定确认”技术来实现传输的可靠性。TCP还采用一种称为“滑动窗口”的方式进行流量控制，所谓窗口实际表示接收能力，用以限制发送方的发送速度。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;TCP报文首部格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201509/764050-20150904110054856-961661137.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;389&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;TCP协议的三次握手和四次挥手：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/764050/201509/764050-20150904110008388-1768388886.gif&quot; alt=&quot;&quot; data-bd-imgshare-binded=&quot;1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　注：seq&lt;/strong&gt;:&quot;sequance&quot;序列号；&lt;strong&gt;ack&lt;/strong&gt;:&quot;acknowledge&quot;确认号；&lt;strong&gt;SYN&lt;/strong&gt;:&quot;synchronize&quot;请求同步标志；&lt;strong&gt;；ACK&lt;/strong&gt;:&quot;acknowledge&quot;确认标志&quot;&lt;strong&gt;；&lt;/strong&gt;&lt;strong&gt;FIN&lt;/strong&gt;：&quot;Finally&quot;结束标志。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;TCP连接建立过程：&lt;/strong&gt;首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;TCP连接断开过程：&lt;/strong&gt;假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;为什么要三次挥手？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;为什么要四次挥手？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！&lt;/p&gt;
&lt;p&gt;　　使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。&lt;/p&gt;
&lt;h3&gt;6 IP协议&lt;/h3&gt;
&lt;p&gt;然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。&lt;/p&gt;
&lt;p&gt;IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。&lt;/p&gt;

&lt;h3&gt;7 以太网协议&lt;/h3&gt;
&lt;p&gt;最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。&lt;/p&gt;
&lt;p&gt;以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。&lt;/p&gt;
&lt;h3&gt;8.DHCP协议&lt;/h3&gt;
&lt;p&gt;DHCP动态主机设置协议（Dynamic Host Configuration Protocol）是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。&lt;/p&gt;
&lt;h3&gt;9.UDP协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。&lt;/strong&gt;&lt;strong&gt;UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;52&quot;&gt;
&lt;p&gt;　　每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下：&lt;br/&gt;　　（1）源端口号；&lt;/p&gt;
&lt;p&gt;　　（2）目标端口号；&lt;/p&gt;
&lt;p&gt;　　（3）数据报长度；&lt;/p&gt;
&lt;p&gt;　　（4）校验值。&lt;/p&gt;
&lt;p&gt;　　使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;TCP&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;与&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;UDP&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;的区别：&lt;/strong&gt;TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。&lt;/p&gt;
&lt;h3 class=&quot;para&quot;&gt;10.路由选择协议&lt;/h3&gt;
&lt;div class=&quot;para&quot; readability=&quot;13&quot;&gt;常见的路由选择协议有：RIP协议、OSPF协议。
&lt;p&gt;&lt;strong&gt;　　RIP&lt;/strong&gt;&lt;strong&gt;协议&lt;/strong&gt; ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。&lt;/p&gt;
　　&lt;strong&gt;OSPF&lt;/strong&gt;&lt;strong&gt;协议&lt;/strong&gt; ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。&lt;/div&gt;
&lt;h3 class=&quot;para&quot;&gt;11.ARP/RARP协议&lt;/h3&gt;
&lt;div class=&quot;para&quot; readability=&quot;57&quot;&gt;&lt;strong&gt;地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。&lt;/strong&gt;主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。&lt;strong&gt;ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。&lt;/strong&gt;
&lt;p&gt;　　ARP工作流程举例：&lt;/p&gt;
&lt;p&gt;　　主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01；&lt;/p&gt;
&lt;p&gt;　　主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02；&lt;/p&gt;
&lt;p&gt;　　当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程：&lt;/p&gt;
&lt;p&gt;　　（1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。&lt;/p&gt;
&lt;p&gt;　　（2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。&lt;/p&gt;
&lt;p&gt;　　（3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。&lt;/p&gt;
&lt;p&gt;　　（4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。&lt;/p&gt;
&lt;p&gt;　　（5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;逆地址解析协议，即RARP，功能和ARP协议相对，其将局域网中某个主机的物理地址转换为IP地址&lt;/strong&gt;，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。&lt;/p&gt;
&lt;p&gt;　　RARP协议工作流程：&lt;/p&gt;
&lt;p&gt;　　（1）给主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址；&lt;/p&gt;
&lt;p&gt;　　（2）本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址；&lt;/p&gt;
&lt;p&gt;　　（3）如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用；&lt;/p&gt;
&lt;p&gt;　　（4）如果不存在，RARP服务器对此不做任何的响应；&lt;/p&gt;
&lt;p&gt;　　（5）源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;12.服务器端响应 &lt;/h3&gt;
&lt;p&gt;经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。&lt;/p&gt;
&lt;p&gt;根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。&lt;/p&gt;
&lt;p&gt;本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。&lt;/p&gt;
&lt;h3&gt;举个例子&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在浏览器中输入&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;a href=&quot;http://www.baidu.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;www.baidu.com&lt;/strong&gt;&lt;strong&gt;&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; &lt;strong&gt;后执行的全部过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　现在假设如果我们在客户端（客户端）浏览器中输入http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：&lt;/p&gt;
&lt;p&gt;　　1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。&lt;/p&gt;
&lt;p&gt;　　2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。&lt;/p&gt;
&lt;p&gt;　　3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。&lt;/p&gt;
&lt;p&gt;　　4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。&lt;/p&gt;


&lt;p&gt;此处参考http://www.cnblogs.com/maybe2030/p/4781555.html#_labelTop&lt;/p&gt;
&lt;p&gt;在这里只作为学习，复习的资料，谢谢&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 06:30:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8298025.html</dc:identifier>
</item>
<item>
<title>5.移植uboot-设置默认环境变量,裁剪,并分区 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8302690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8302690.html</guid>
<description>&lt;p&gt;&lt;span&gt;在上一章,我们使用网卡传输文件,每次启机时,环境变量都要变为默认值,需要重新设置ip,MAC地址才行,由于没有配置mtdparts命令,启动内核也不成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以本章主要学习:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt;修改环境变量默认值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;裁剪uboot  &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt;分区,设置mtdparts命令&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.修改之前,先来理解下uboot的环境参数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先,uboot会去校验(CRC)存放环境变量的一段空间 ,若CRC有效则使用该空间里的环境变量,无效则用默认的环境变量.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而我们移植的uboot,由于一直没有使用save,所以没有读不出CRC校验,使用的默认环境变量,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094252537-506690199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.来修改uboot的默认环境变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(PS:uboot此时的内存分区还没修改,所以每次设置环境后,不能用save保存,怕破坏掉nand里面的内容)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1搜索using default environment,找到位于set_default_env()函数:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094302912-1085576179.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面代码可以看到, &lt;span&gt;default_environment&lt;/span&gt;这个变量,这是个全局字符数组,从字面上就可知道,这个是默认环境变量数组,里面保存了各个环境值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2进入default_environment[]看看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094319787-1773242910.png&quot; alt=&quot;&quot; width=&quot;388&quot; height=&quot;202&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个数组比较长,所以只剪切一部分,其中&lt;span&gt;MK_STR()&lt;/span&gt;的作用就是将数值转换为字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些都是环境参数,比如&lt;span&gt;&quot;bootargs=&quot;&lt;/span&gt;(环境变量里最重要的一个),里面会保存文件系统位置,控制台console等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们以bootargs为例:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在default_environment[]数组里,若&lt;span&gt;CONFIG_BOOTARGS宏&lt;/span&gt;有值,便会组成一串字符串&lt;span&gt;&quot;bootargs=... ...&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如在以前的uboot里,可以看到:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=&lt;span&gt;ttySAC0
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;root:指定文件系统位置
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;init:指定内核启动后执行的第一个应用程序
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console:指定使用哪个终端,比如串口0,使用ttySAC0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其它宏也是这样.比如我们熟悉的有:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;bootcmd=&quot;&lt;/span&gt;, 用来启动内核的命令&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;bootdelay=&quot;&lt;/span&gt;,uboot启动的倒计时,默认值为5S,只有设置了bootcmd,该倒计时才有用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;baudrate=&quot;&lt;/span&gt;,波特率,默认为115200&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;ethaddr=&quot;&lt;/span&gt;,网卡的MAC地址(也叫物理地址)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;ipaddr=&quot;&lt;/span&gt;,ip地址&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;serverip=&quot;&lt;/span&gt;,使用tftp时的服务器地址&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;netmask=&quot;&lt;/span&gt;,掩码, 默认值为255.255.255.0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&quot;mtdparts=&quot;&lt;/span&gt;,mtd分区表&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3所以接下来,便修改smdk2440.h里面与环境相关的宏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置默认环境变量宏(位于include/configs/&lt;span&gt;smdk2440.h&lt;/span&gt;):&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_BOOTARGS &quot;noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0&quot;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootargs&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_BOOTCOMMAND &quot;nand read  0x30000000 0x60000 0x200000; bootm 0x30000000&quot; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootcmd&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_BOOTDELAY       10                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;uboot 倒计时      &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_NETMASK         255.255.255.0           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;掩码&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_IPADDR          192.168.2.103           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本机IP&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_SERVERIP        192.168.2.101           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;电脑IP&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_ETHADDR         00:0c:29:35:21:29       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;MAC地址&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中bootcmd是随意写的,因为此时的内核位置还不确定放在哪(后面配置mtdparts命令后,会在4.6小节修改)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于nand中要划分bootload空间、环境变量空间、内核空间、系统空间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而uboot就有400多k,所以我们需要裁剪uboot,裁剪后再来划分内存分区&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.裁剪uboot&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;uboot很多文件都是基于Makefile,里面通过判断宏来加载文件.而宏大部分都定义在include/configs/&lt;span&gt;smdk2440.h&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1进入smdk2440.h,把不需要的功能的宏去掉,比如usb,文件系统,rtc等&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;去掉usb支持&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************************************
// * USB support (currently only works with D-cache off)
// ***********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_USB_OHCI
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_USB_KEYBOARD
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_USB_STORAGE
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_DOS_PARTITION&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;去掉rtc支持&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************************************
// * RTC
// ***********************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_RTC_S3C24X0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt;去掉BOOTP选项&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
// * BOOTP options
// &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_BOOTP_BOOTFILESIZE
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_BOOTP_BOOTPATH
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_BOOTP_GATEWAY
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_BOOTP_HOSTNAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;/span&gt;去掉部分不需要的命令行配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #define CONFIG_CMD_DHCP     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态主机配置协议命令行
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; #define CONFIG_CMD_USB      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;USB命令行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;5)&lt;/strong&gt;&lt;/span&gt;去掉文件系统&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
// * File system
// &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_CMD_FAT
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_CMD_EXT2
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_CMD_UBI
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_CMD_UBIFS
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_CMD_MTDPARTS
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_MTD_DEVICE
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_MTD_PARTITIONS
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_YAFFS2
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_RBTR&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 编译&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于屏蔽的宏在其它文件也会用到,而make在之前用过,再次make只会编译修改过的文件.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以输入:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;make clean                  
make s3c2440config
make               &lt;/span&gt;&lt;span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;make后,打印以下错误:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
common/libcommon.o: In function `do_date&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;
/work/system/u-boot-&lt;span&gt;2012.04&lt;/span&gt;.&lt;span&gt;01&lt;/span&gt;/common/cmd_date.c:&lt;span&gt;60&lt;/span&gt;: undefined reference to `rtc_reset&lt;span&gt;'&lt;/span&gt;
/work/system/u-boot-&lt;span&gt;2012.04&lt;/span&gt;.&lt;span&gt;01&lt;/span&gt;/common/cmd_date.c:&lt;span&gt;63&lt;/span&gt;: undefined reference to `rtc_get&lt;span&gt;'&lt;/span&gt;
/work/system/u-boot-&lt;span&gt;2012.04&lt;/span&gt;.&lt;span&gt;01&lt;/span&gt;/common/cmd_date.c:&lt;span&gt;72&lt;/span&gt;: undefined reference to `rtc_set&lt;span&gt;'&lt;/span&gt;
/work/system/u-boot-&lt;span&gt;2012.04&lt;/span&gt;.&lt;span&gt;01&lt;/span&gt;/common/cmd_date.c:&lt;span&gt;81&lt;/span&gt;: undefined reference to `rtc_get&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;make: &lt;/span&gt;*** [u-boot] 错误 &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的cmd_date.c文件以及出错变量rtc_xxx,从字面上来看显然是与RTC有关,我们直接屏蔽该文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过Makefile,找到需要&lt;span&gt;屏蔽&lt;/span&gt;宏CONFIG_CMD_DATE(宏定义位于include/configs/smdk2440.h):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094344506-463659677.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;30&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 屏蔽后,make成功,可以看到uboot只有200kb了:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094355287-1975972835.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来,便开始分区,使我们的环境变量能保存在uboot指定位置里&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.设置分区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以前,我们每次启动内核时,都会打印以下分区信息:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Creating &lt;span&gt;4&lt;/span&gt; MTD partitions on &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NAND 256MiB 3,3V 8-bit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;0x00000000&lt;/span&gt;-&lt;span&gt;0x00040000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootloader&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放uboot&lt;/span&gt;
&lt;span&gt;0x00040000&lt;/span&gt;-&lt;span&gt;0x00060000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放环境变量&lt;/span&gt;
&lt;span&gt;0x00060000&lt;/span&gt;-&lt;span&gt;0x00260000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kernel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放内核&lt;/span&gt;
&lt;span&gt;0x00260000&lt;/span&gt;-&lt;span&gt;0x10000000&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放文件系统&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以,我们新的uboot,还是照着这个来分区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还记得之前,我们每次设置了环境变量,都不敢用save命令来保存.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.1所以我们通过&lt;span&gt;sava -help&lt;/span&gt;命令,看它位于哪个文件,找到save命令相关宏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094444959-346169952.png&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;102&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2然后在si里搜索&lt;span&gt;saveenv&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;搜索如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094453068-102930134.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;121&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以发现,在env_flash.c 和env_nand.c这两个文件都有saveenv()函数.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然&lt;span&gt;env_flash.c&lt;/span&gt;的作用是,通过save命令将环境变量保存在nor flash.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而&lt;span&gt;env_nand.c&lt;/span&gt;,是将环境变量保存在nand flash里.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3接下来在common/Makefile搜索,看看这两个文件依赖哪两个宏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094459521-993645637.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;29&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094502881-1608361838.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;28&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4然后在smdk2440.h搜索这两个宏,看看板卡默认配置的是不是env_nand.c&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094513599-848084673.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到,smdk2440.h是将环境变量保存在&lt;span&gt;nor flash&lt;/span&gt;,由于2440在nand启动下是无法支持nor,所以我们需要屏蔽这三处宏,重新设置宏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5设置save相关宏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在其它板卡里搜索&lt;span&gt;CONFIG_ENV_IS_IN_NAND&lt;/span&gt;,看看别人是怎么通过宏配置save的,然后在env_nand.c文件里搜索宏,来看宏是怎么用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终宏修改为如下所示(位于include/configs/smdk2440.h):&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_ENV_ADDR                    (CONFIG_SYS_FLASH_BASE + 0x070000)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_ENV_IS_IN_FLASH
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define CONFIG_ENV_SIZE               0x10000&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; CONFIG_ENV_SIZE                 0x20000       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境变量空间大小&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_ENV_IS_IN_NAND
&lt;span&gt;#define&lt;/span&gt; CONFIG_ENV_OFFSET               0x40000          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;位于0x40000~(0X40000+0x20000)&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_ENV_RANGE                CONFIG_ENV_SIZE  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境变量的擦除范围,要&amp;gt;=SIZE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;上面的&lt;span&gt;CONFIG_ENV_RANGE&lt;/span&gt;宏,其实不定义,内核也会自动定义(位于&lt;span&gt;env_nand.c&lt;/span&gt;):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094530662-1799621617.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;59&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后重新编译新的uboot,就可以使用save命令保存环境变量了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接着我们烧写内核：&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tftp &lt;span&gt;30000000&lt;/span&gt;&lt;span&gt; uImage
nand erase &lt;/span&gt;&lt;span&gt;60000&lt;/span&gt; &lt;span&gt;200000&lt;/span&gt;&lt;span&gt;                         
nand write &lt;/span&gt;&lt;span&gt;30000000&lt;/span&gt; &lt;span&gt;60000&lt;/span&gt; &lt;span&gt;200000&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存在内核分区里&lt;/span&gt;&lt;span&gt;
bootm &lt;/span&gt;&lt;span&gt;30000000&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动内核&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从这里，看出烧个内核还需要记录这些分区空间地址,非常麻烦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6 设置&lt;span&gt;mtdparts&lt;/span&gt;命令(在旧版uboot里,是mtd命令)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实,我们可以使用mtdparts命令,通过分区名字来代替这些地址,比如以前的uboot,直接输入:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nand erase kernel              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个kernel名字就等于: 60000 200000 &lt;/span&gt;&lt;span&gt;
nand write  &lt;/span&gt;&lt;span&gt;30000000&lt;/span&gt; kernel    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个kernel名字就等于: 60000 200000 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于smdk2440板卡里没有配置mtdparts命令,所以步骤如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;搜索mtdparts,发现位于common/&lt;span&gt;cmd_mtdparts.c&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt; 在common/Makefile搜索,找到cmd_mtdparts.c文件依赖&lt;span&gt;CONFIG_CMD_MTDPARTS宏&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094645318-958564206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt;在其它板卡里搜索CONFIG_CMD_MTDPARTS,看看别人是怎么通过宏配置nand的,别人写的配置如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094658584-823956170.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;90&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&quot;-&quot;&lt;/span&gt;&lt;/strong&gt;：表示剩余空间都是文件系统。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(PS:当执行mtdparts default命令时,uboot就会检测是否有CONFIG_CMD_MTDPARTS宏,然后再根据上面的MTDPARTS_DEFAULT宏保存的mtd分区信息,来将nand和nor分区)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;/span&gt;设置mtdparts相关宏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来,便复制上面的宏到smdk2440.h中,改为:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-----------------------------------------------------------------------
 * mtdparts
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_CMD_MTDPARTS
&lt;span&gt;#define&lt;/span&gt; CONFIG_MTD_DEVICE
&lt;span&gt;#define&lt;/span&gt; MTDIDS_DEFAULT           &quot;nand0=smdk2440-0&quot;  
&lt;span&gt;#define&lt;/span&gt; MTDPARTS_DEFAULT       &quot;mtdparts=smdk2440-0:256k(u-boot),&quot;      \ 
                                          &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;128k(params),&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;            \         
                                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2m(kernel),&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  \      
                                          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-(rootfs)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;        \
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后重新修改,之前设置的环境参数&lt;span&gt;bootcmd&lt;/span&gt;(位于smdk2440.h):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_BOOTCOMMAND &quot;nand read  0x30000000 0x60000 0x200000; bootm 0x30000000&quot; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootcmd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;改为:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; CONFIG_BOOTCOMMAND &quot;nand read  0x30000000 kernel; bootm 0x30000000&quot;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bootcmd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;5)&lt;/strong&gt;&lt;/span&gt;修改好后,我们还需要在board_init_r()函数里的for(;;)前面添加(位于arch/arm/lib/&lt;span&gt;board.c&lt;/span&gt;):&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  run_command(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtdparts default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加此处代码&lt;/span&gt;
 
       &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
              main_loop();
       }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样uboot每次启动时,都会执行一次&lt;span&gt;mtdparts default&lt;/span&gt;命令,使它根据默认参数来自动分区.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mtdparts命令就此设置好了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来,便重新烧写uboot,来测试&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.测试mtdparts分区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入mtdparts,查看默认分区名称:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201801/1182576-20180117094719178-380994521.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;148&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示,接下来我们便可以直接使用kernel名字来擦除kernel分区,并烧写内核了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tftp &lt;span&gt;30000000&lt;/span&gt;&lt;span&gt; uImage
nand erase.part kernel      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等于nand erase 200000    60000&lt;/span&gt;&lt;span&gt;
nand write &lt;/span&gt;&lt;span&gt;30000000&lt;/span&gt; kernel  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从sdram拷贝到nand &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来,下章来使&lt;span lang=&quot;EN-US&quot;&gt;uboot支持&lt;span lang=&quot;EN-US&quot;&gt;yaffs及制作补丁&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 06:26:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8302690.html</dc:identifier>
</item>
<item>
<title>Python列表生成器 - 小破孩92</title>
<link>http://www.cnblogs.com/miqi1992/p/8302597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miqi1992/p/8302597.html</guid>
<description>&lt;blockquote readability=&quot;3.8&quot;&gt;
&lt;p&gt;本篇将介绍python生成器，更多内容请参考：&lt;a href=&quot;http://www.cnblogs.com/miqi1992/p/8082471.html&quot;&gt;python学习指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅访问前面几个元素，那后面绝大多数占用的空间都白白浪费了。&lt;br/&gt;&lt;code&gt;python生成器&lt;/code&gt;是用来代替&quot;不一定能够使用全部元素的数组&quot;,等到使用某一元素时,才生成该元素,用来节省空间.&lt;/p&gt;
&lt;h3 id=&quot;生成器创建方式&quot;&gt;生成器创建方式&lt;/h3&gt;
&lt;h4 id=&quot;第一种&quot;&gt;第一种:&lt;/h4&gt;
&lt;p&gt;在前面我们介绍python列表生成式，这里我们只需要把列表生成式的&lt;code&gt;[]&lt;/code&gt;改成&lt;code&gt;()&lt;/code&gt;,就创建了一个generatro&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;L &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [x &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)]
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;L
[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;81&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;]
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;g &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (x&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;))
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;g
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;generator &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;genexpr&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt; at &lt;span class=&quot;bn&quot;&gt;0x1022ef630&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;创建&lt;code&gt;L&lt;/code&gt;和&lt;code&gt;g&lt;/code&gt;的区别仅在于最外层的&lt;code&gt;[]&lt;/code&gt;和&lt;code&gt;()&lt;/code&gt;,&lt;code&gt;L&lt;/code&gt;是一个list,而&lt;code&gt;g&lt;/code&gt;是一个generator&lt;br/&gt;上面表达式中我们可以直接列出list(L)的每一个元素，但我们打印g的时候，却打印了g的类型，那么，我们如何打印generator的每一个元素呢？&lt;br/&gt;如果要一个一个打印出来，可以通过&lt;code&gt;next()&lt;/code&gt;函数获得generator的下一个返回值：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;dv&quot;&gt;81&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
Traceback (most recent call last):
  File &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;stdin&amp;gt;&quot;&lt;/span&gt;, line &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;module&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;pp&quot;&gt;StopIteration&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generator保存的是算法，每次调用&lt;code&gt;next(g)&lt;/code&gt;,就计算出&lt;code&gt;g&lt;/code&gt;的下一个元素的值，知道计算出最后一个元素，没有更多元素时，抛出&lt;code&gt;StopIteration&lt;/code&gt;的错误。&lt;br/&gt;这样不断调用&lt;code&gt;next(g)&lt;/code&gt;实在是太变态了，生成器是可迭代对象&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Iterable  &lt;span class=&quot;co&quot;&gt;#载入模块&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;isinstance&lt;/span&gt;(g, Iterable)  &lt;span class=&quot;co&quot;&gt;#生成器是可迭代对象吗？&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，知道用什么来了吧？&lt;br/&gt;当然是使用强大的&lt;code&gt;for...in&lt;/code&gt;迭代来实现&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;g &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (x &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; x &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;))
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; g:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(n)
&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;81&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code&gt;for&lt;/code&gt;迭代的方式来循环生成器，并不用关心&lt;code&gt;StopIteration&lt;/code&gt;的错误。&lt;/p&gt;
&lt;h3 id=&quot;使用关键字-yield-关键字&quot;&gt;使用关键字 yield 关键字&lt;/h3&gt;
&lt;p&gt;generator非常强大。如果推算的算法比较复杂，用类似列表生成式的&lt;code&gt;for&lt;/code&gt;循环无法实现的时候，还可以用函数来实现&lt;/p&gt;

&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; creatNum():
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;---开始执行生成器方法---&quot;&lt;/span&gt;)
    a,b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;):
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;--step1--&quot;&lt;/span&gt;)
        &lt;span class=&quot;cf&quot;&gt;yield&lt;/span&gt; b
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;--step2--&quot;&lt;/span&gt;)
        a,b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; b,a&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;b
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;--step3--&quot;&lt;/span&gt;)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;--stop--&quot;&lt;/span&gt;)

&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;直接调用方法...&quot;&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(creatNum())

&lt;span class=&quot;co&quot;&gt;#这里用一个标识符来指向生成器(不要把creatNum()当做函数)&lt;/span&gt;
func &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; creatNum()

&lt;span class=&quot;co&quot;&gt;#使用for循环来执行生成器&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; func:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(i)
输出结果: (执行完毕不会崩溃)

&lt;span class=&quot;co&quot;&gt;#直接调用方法...&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;generator &lt;span class=&quot;bu&quot;&gt;object&lt;/span&gt; creatNum at &lt;span class=&quot;bn&quot;&gt;0x101c30f10&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;---&lt;/span&gt;开始执行生成器方法&lt;span class=&quot;op&quot;&gt;---&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step1&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step2&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step3&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step1&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step2&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step3&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step1&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step2&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step3&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step1&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step2&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step3&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step1&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step2&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;step3&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;stop&lt;span class=&quot;op&quot;&gt;--&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在执行生成器时,可以使用 生成器.send(param) 方法&lt;br/&gt;send方法不光是执行一步next操作,还会把send里面的参数传到生成器中充当yield表达式的返回值&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test():
    i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;:
        temp &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;yield&lt;/span&gt; i
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(temp)
        i &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;

t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; test()

&lt;span class=&quot;co&quot;&gt;#先使用next执行,看能出来什么结果&lt;/span&gt;
t.&lt;span class=&quot;fu&quot;&gt;__next__&lt;/span&gt;()
t.&lt;span class=&quot;fu&quot;&gt;__next__&lt;/span&gt;()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(t.&lt;span class=&quot;fu&quot;&gt;__next__&lt;/span&gt;())

&lt;span class=&quot;co&quot;&gt;#使用send执行&lt;/span&gt;
t.send(&lt;span class=&quot;st&quot;&gt;&quot;1231231231223123&quot;&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(t.send(&lt;span class=&quot;st&quot;&gt;&quot;hahahahhahaha&quot;&lt;/span&gt;))
输出结果: (可见next输出temp为none , 而send 则把值传递进了生成器)

&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;1231231231223123&lt;/span&gt;
hahahahhahaha
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/98fd8cd0094a&quot;&gt;python生成器是怎样工作的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/fb67382a0455&quot;&gt;Python中的yield关键字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/390825367392&quot;&gt;python生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000&quot;&gt;廖雪峰-生成器&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 17 Jan 2018 06:13:00 +0000</pubDate>
<dc:creator>小破孩92</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miqi1992/p/8302597.html</dc:identifier>
</item>
</channel>
</rss>