<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET没有魔法——ASP.NET Identity 的“多重”身份验证代码篇 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/7942513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/7942513.html</guid>
<description>&lt;p&gt;　　上篇文章介绍了ASP.NET中身份验证的机制与流程，本文将使用代码的来介绍如何实现第三方账户验证与双因子验证。&lt;/p&gt;
&lt;p&gt;　　本章主要内容有：&lt;br/&gt;　　● 实现基于微软账户的第三方身份验证&lt;br/&gt;　　● 实现双因子身份验证&lt;br/&gt;　　● 验证码机制&lt;/p&gt;
&lt;h2&gt;实现基于微软账户的第三方身份验证&lt;/h2&gt;
&lt;p&gt;　　在微软提供的ASP.NET MVC模板代码中，默认添加了微软、Google、twitter以及Facebook的账户登录代码(虽然被注释了)，另外针对国内的一些社交账户提供了相应的组件，所有组件都可以通过Nuget包管理器安装：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143137867-1790084273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图中看到有优酷、微信、QQ、微博等组件，其中一些是微软提供的，一些是其它开发者提供的。而本文将使用微软账户为例来介绍如何实现一个第三方登录。&lt;br/&gt;　　&lt;span&gt;注：本章主要代码参考ASP.NET MVC模板代码，所以在文章中只列出关键代码，其余代码与模板中的完全一致。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;组件安装及Key申请&lt;/h3&gt;
&lt;p&gt;　　在开发之前首先需要通过Nuget安装Microsoft.Owin.Security.MicrosoftAccount：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143356305-790468817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外就是需要去微软的开发者中心使用微软账户创建一个自己的应用信息&lt;a href=&quot;https://apps.dev.microsoft.com/&quot; target=&quot;_blank&quot;&gt;https://apps.dev.microsoft.com/&lt;/a&gt;，并保存应用的ID以及密钥用于对身份验证中间件进行配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143541602-414223347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建过程如下：&lt;br/&gt;　　1. 点击添加应用按钮，进入应用程序注册页面，填写应用名称并点击Create按钮(注：由于我已经有一个名称为My Blog的App，所以下面的Test App的创建流程仅仅是用于演示，后续的身份验证实际上是使用之前创建的My Blog)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143632555-582048560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 在后续页面中点击生成新密码来生成密钥&lt;span&gt;（注：该密码只显示一次，需要在弹出框中复制并保存下来）&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143758961-676840719.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 添加平台：点击添加平台按钮，添加一个Web平台，并在平台的重定向Url中填入本地调试的地址信息（&lt;span&gt;注：一定需要启动HTTPS并且地址后需要添加signin-microsoft，VS可以在项目的属性中开启SSL，并设置SSL的URL&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143901398-1285452279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143917164-1630018112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　4. 保存更改。&lt;/p&gt;
&lt;h3&gt;添加中间件&lt;/h3&gt;
&lt;p&gt;　　在上一篇文章中介绍了，第三方账户身份验证除了特定账户身份验证中间件外，还需要添加一个消极模式的外部Cookie身份验证中间件，所以首先需要在项目的Startup文件中添加一下代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201143959680-1949172011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后再在该中间件后加入微软身份验证中间件(注：中间件顺序会影响处理流程，微软身份验证中间件必须在外部Cookie中间件后)，并设置上面创建的应用ID及密钥：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144022852-1915070861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;添加Controller及页面的功能支持&lt;/h3&gt;
&lt;p&gt;　　现在可以说应用中已经支持微软的账户身份验证了，但是在应用中还未提供微软身份验证的入口，以及登陆后用户信息的补全等功能。&lt;br/&gt;　　1. 在页面上添加验证入口，在Login页面上加入以下代码，通过AuthenticationManager来获取所有的第三方身份验证方式，并生成对应链接：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144119383-702473144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144129180-597064788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　2. 在AccountController中添加ExternalLogin Action方法（注：该方法主要目的是调用AuthenticationManager的Challenge方法来触发微软身份验证中间件的ResponseChallenge方法来完成页面的跳转）：&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144231055-1665438509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中ChallengeResult是一个自定义的ASP.NET MVC Reuslt类型：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144308773-1784605080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 加入第三方验证后的回调方法ExternalLoginCallback，该回调方法是获取第三方身份验证后的用户信息，然后在本地数据库中查找该用户，如果存在那么登录成功，否则需要对该用户信息进行补全。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144328086-2070720867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. 添加第三方账户信息补全页面及Action方法，其中action方法接收到补全的用户信息后完成用户注册功能，但要注意的是第三方账户没有密码，仅仅是在AspNetUserLogins表中添加了第三方验证的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144350133-1630378104.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　运行结果：&lt;br/&gt;　　1.访问登录页面出现Microsoft的按钮（注：必须使用HTTPS地址才能正常的使用微软身份验证）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144605539-1976379717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 点击微软身份验证按钮后，跳转到微软账户登录页面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144627992-1281437197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144648352-1719949793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 完成登录后，由于是第一次登录，所以会跳转到信息补全页面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144719164-942554108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　输入邮箱后将登录成功：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144748617-1077699234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　数据库中的信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144807945-2084610730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中可以看到无密码，然后在Login表中有一条数据：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144830320-93151865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现双因子身份验证&lt;/h2&gt;
&lt;p&gt;　　Identity的双因子身份验证实际上是Identity的一个内置功能，为什么说是内置呢？因为只需要实现信息的发送(如邮件、短信等)，然后再对Identity中的SignInManager进行简单的配置然后添加一些用于发送、填写验证码的页面就可以完成。所以首先需要完成的就是实现信息发送功能。&lt;br/&gt;　　&lt;span&gt;注：这里信息发送功能使用将信息写到硬盘的方式模拟。&lt;/span&gt;&lt;br/&gt;　　1. 实现信息的发送：&lt;br/&gt;　　在ASP.NET MVC默认的模板中就为我们创建了如下代码：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201144917227-1429497290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　默认的邮件及短信发送器，只不过它没有实现，仅仅是返回了一个空值，现在使用写硬盘的方式将信息写到硬盘上：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145235617-1744656780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 完成UserManager的双因子验证配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145301555-771192437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　三个关键点：1. TokenProvider，它用来生成验证码。2. 信息格式。3. 信息发送服务。&lt;/p&gt;
&lt;p&gt;　　3. 在身份验证管道中加入双因子验证中间件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145339789-635517741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　两个中间件前者用于处理二次验证，后者用于记住登录状态，下次访问系统时自动登录。&lt;/p&gt;
&lt;p&gt;　　4. 添加验证码发送方式选择以及验证码填写页面及相应的Action方法(代码略)。&lt;br/&gt;　　5. 在数据库中将演示用的用户信息改为启用二次验证(注：模板代码中有用于管理个人信息的功能，此处省略了实现，直接通过修改数据数据的方式开启用户的双因子验证、添加电话号码等)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145532523-580620444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6. 运行结果：&lt;br/&gt;　　登录后需要选择验证码发送方式：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145556695-424098730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　选择后点击提交按钮，页面调整到验证页面的同时，指定的文件中生成了需要的验证码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145622195-1784543613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145632742-18217513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　填写验证码后点击提交按钮，则登录成功：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145656008-902868301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145709336-1471624762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：双因子验证也可以应用到第三方账户的登录方式上，双因子验证只与用户有关与身份验证方式无关。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;验证码机制&lt;/h2&gt;
&lt;p&gt;　　对于双因子验证来说，它实际上就是在普通验证或第三方账户验证的基础上增加了验证码的发送和验证两个环节，那么对于&lt;span&gt;验证码&lt;/span&gt;这个主体Identity是如何来维护的呢？&lt;br/&gt;　　在上面的介绍中，有一个环节就是需要通过对UserManager进行配置以支持双因子验证的消息发送、消息生成等等：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145751086-2035443346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　根据这个代码看来XXXTokenProvider是专门用来维护验证码的，而XXXService是用来发送的，所以这里将对TokenProvider进行说明，了解验证码是如何维护的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201145814461-1248773115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图是TokenProvider相关的一个简单类图，从类图中可以看出TokenProvider实际上是实现了一个名为IUserTokenProvider的接口，该接口中有4个方法，它们的作用分别是：&lt;br/&gt;　　● GenerateAsync：根据UserManager以及User信息来生成一个令牌(Token)。&lt;br/&gt;　　● IsValidProviderForUserAsync：判断这个Token提供器对这个用户是否是有效的（如果使用短信验证，但是该用户没有设置手机号，那么就是无效的）。&lt;br/&gt;　　● NotifyAsync：当Token生成后调用该方法通知用户，如短信或邮件通知。&lt;br/&gt;　　● ValidateAsync：用于验证Token是否有效。&lt;/p&gt;
&lt;p&gt;　　而TotpSecutityStampBasedTokenProvider是一个实现了IUserTokenProvider接口的，通过用户安全戳生成验证码的生成器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201150141945-917251717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从代码中可以看到该算法是基于rfc6238(TOTP: Time-Based One-Time Password Algorithm，基于时间的一次性密码算法) &lt;a href=&quot;https://tools.ietf.org/html/rfc6238&quot; target=&quot;_blank&quot;&gt;https://tools.ietf.org/html/rfc6238&lt;/a&gt;，然后通过用户的安全戳以及GetUserModifierAsync方法生成特定的信息熵来完成密码加密，关于信息熵可参考：&lt;a href=&quot;https://www.zhihu.com/question/22178202&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/22178202&lt;/a&gt;，上面将生成后的令牌执行ToString(&quot;D6&quot;)是将其转换为一个6位数字的字符串。&lt;br/&gt;　　而Token的验证方式和生成差不多都是通过用户安全戳和信息熵来验证提交的验证码(它实际上是一种hash算法)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201150255992-1979118118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以上已经解释了最初验证码的生成和验证的问题，所以对于EmailTokenProvider和PhoneNumberTokenProvider只是对熵的生成、对Provider的有效性(是否存在Email或电话号码)、通知方式进行了修改，下面是PhoneNumberTokenProvider相关代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201150630633-807615736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201150657977-1786474988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201712/640251-20171201150711070-629114294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;小结　　&lt;/h2&gt;
&lt;p&gt;　　本章主要是使用代码的形式实现了ASP.NET中的第三方验证和双因子验证，文中的代码都来自ASP.NET MVC的模板，所以文中仅仅是对关键的代码进行了介绍，一些细节的内容可参考完整代码。其中第三方验证使用的是微软账户，如果有环境支持可以尝试国内的微信、QQ等身份验证。&lt;br/&gt;　　另外在文章最后对验证码的生成和校验代码进行了分析，知道了它是基于Hash算法的信息加密、验证的机制来实现的。&lt;br/&gt;ASP.NET MVC基于Identity提供了非常完善、强大的用户管理和身份验证功能，除了以上介绍的以外还有账户锁定、注册邮箱或短信验证功能，基本上已经涵盖了现在开发常用的功能，但这些功能被一个模板实现了，所以ASP.NET强大吗？&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.zhihu.com/question/22178202&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/22178202&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/external-authentication-services&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/external-authentication-services&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.benday.com/2014/02/25/walkthrough-asp-net-mvc-identity-with-microsoft-account-authentication/&quot; target=&quot;_blank&quot;&gt;https://www.benday.com/2014/02/25/walkthrough-asp-net-mvc-identity-with-microsoft-account-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET Identity 的“多重”身份验证代码篇&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7942513.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/7942513.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 07:30:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/7942513.html</dc:identifier>
</item>
<item>
<title>c# winform treelistview的使用(treegridview) - 波谷</title>
<link>http://www.cnblogs.com/liuxiaobo93/p/7942619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuxiaobo93/p/7942619.html</guid>
<description>&lt;p&gt;TreeView控件显示的内容比较单一，如果需要呈现更详细信息TreeListView是一个不错的选择。&lt;/p&gt;
&lt;p&gt;先看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/607217/201712/607217-20171201151030133-1999221337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先需要引用文件System.Windows.Forms.TreeListView.dll、System.Runtime.InteropServices.APIs.dll&lt;/p&gt;
&lt;p&gt;你可以将TreeListView加入到工具箱中然后在添加到窗体中。&lt;/p&gt;
&lt;p&gt;1.你需要添加列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/607217/201712/607217-20171201151051633-1165725981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.你需要添加一个ImageList作为节点图标的容器（你还需要配置TreeListView的SmallImageList属性为ImageList控件的ID）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/607217/201712/607217-20171201151121852-692889976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.现在可以给控件绑定数据了&lt;/p&gt;
&lt;p&gt;此控件比较适合呈现具有父子级关系的复杂数据结构，当然也包含XML格式的数据&lt;/p&gt;
&lt;p&gt;下面尝试解析一个设备树XML然后绑定到控件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Device &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hidc-1600tv _192.168.230.188&quot;&lt;/span&gt;&lt;span&gt; ItemType&lt;/span&gt;&lt;span&gt;=&quot;DVR&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Onvif&quot;&lt;/span&gt;&lt;span&gt; TypeID&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; Code&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; location&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; Description&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; ID&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; UniqueID&lt;/span&gt;&lt;span&gt;=&quot;192.168.230.188&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;IP &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;192.168.230.188&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Port &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;80&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Username &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;admin&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Password &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;1234&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AuthenAddress &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;AuthenMode &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OnvifUser &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;admin&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OnvifPwd &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;1234&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;OnvifAddress &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;/onvif/device_service&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RTSPUser &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;admin&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RTSPPwd &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;1234&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ChildDevices&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Device &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; ItemType&lt;/span&gt;&lt;span&gt;=&quot;Channel&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; TypeID&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; Code&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; location&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; Description&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; UniqueID&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZEnable &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ1 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ2 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;15&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ3 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;25&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ4 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;35&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ5 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;45&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ6 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;55&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ7 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;65&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ8 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;75&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PTZ9 &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;85&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ChildDevices&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Device &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; ItemType&lt;/span&gt;&lt;span&gt;=&quot;RStreamer&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; TypeID&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Code&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; location&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; Description&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MediaProfile &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Multicast &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Device&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Device &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; ItemType&lt;/span&gt;&lt;span&gt;=&quot;RStreamer&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; TypeID&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Code&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; location&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; Description&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MediaProfile &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Multicast &lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Device&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ChildDevices&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Device&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ChildDevices&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Device&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用递归算法很容易提取XML的结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LoadXmlTree(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; xml)
        {
            XDocument xDoc &lt;/span&gt;=&lt;span&gt; XDocument.Parse(xml);

            TreeListViewItem item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeListViewItem();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; title = xDoc.Root.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?.Value ??&lt;span&gt; xDoc.Root.Name.LocalName;
            item.Text &lt;/span&gt;=&lt;span&gt; title;
            item.ImageIndex &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            item.SubItems.Add(xDoc.Root.Attribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UniqueID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value);
            item.SubItems.Add(xDoc.Root.Attribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ItemType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value);
            PopulateTree (xDoc.Root, item.Items);
            tvDevice.Items.Add(item);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PopulateTree (XElement element, TreeListViewItemCollection items)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (XElement node  &lt;span&gt;in&lt;/span&gt;&lt;span&gt; element.Nodes())
            {
                TreeListViewItem item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeListViewItem();
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; title =&lt;span&gt; node.Name.LocalName.Trim();
                item.Text &lt;/span&gt;=&lt;span&gt; title;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (title == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Device&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attr = node.Attribute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ItemType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value;
                    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (attr)
                    {
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Channel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: item.ImageIndex = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RStreamer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: item.ImageIndex = &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    item.SubItems.Add(node.Attribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UniqueID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value);
                    item.SubItems.Add(node.Attribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ItemType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    item.ImageIndex &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                    item.SubItems.Add(node.Attribute(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)?&lt;span&gt;.Value);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node.HasElements)
                {
                    PopulateTree (node, item.Items);
                }
                items.Add(item);
            }
        }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;TreeListViewItem可构造传入value和imageindex，其中value会赋值给Text属性，imageindex就是节点显示的图标所对应的ImageList的索引。TreeListViewItem的SubItems就是其扩展列，它会按顺序依次显示到后面的列中。&lt;/p&gt;
&lt;p&gt;你可以设置ExpandMethod属性来控制节点展开的方式，设置CheckBoxes属性控制是否显示复选框。&lt;/p&gt;
&lt;p&gt;你可以通过订阅BeforeExpand、BeforeCollapse、BeforeLabelEdit三个事件来修改不同状态下的图标，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeListView1_BeforeExpand(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender,  TreeListViewCancelEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.Item.ImageIndex == &lt;span&gt;0&lt;/span&gt;) e.Item.ImageIndex = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以设置LabelEdit属性来激活或禁用编辑，TreeListViewBeforeLabelEditEventArgs参数提供了相应的属性值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeListView1_BeforeLabelEdit(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, TreeListViewBeforeLabelEditEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.ColumnIndex == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                ComboBox combobox &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ComboBox();
                combobox.Items.AddRange(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[]{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;});
                e.Editor &lt;/span&gt;=&lt;span&gt; combobox;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TreeListView开源你也可以根据自己的需要进行修改。&lt;/p&gt;
&lt;p&gt;本文出处：http://www.cnblogs.com/liuxiaobo93/p/7942619.html&lt;/p&gt;
&lt;p&gt;附件下载： &lt;a href=&quot;https://files.cnblogs.com/files/liuxiaobo93/TreeListView.rar&quot; target=&quot;_blank&quot;&gt;TreeListView&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 07:27:00 +0000</pubDate>
<dc:creator>波谷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuxiaobo93/p/7942619.html</dc:identifier>
</item>
<item>
<title>Vue-Access-Control：前端用户权限控制解决方案 - 雅X共赏</title>
<link>http://www.cnblogs.com/refined-x/p/7942276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refined-x/p/7942276.html</guid>
<description>&lt;h3&gt;&lt;span&gt;原文地址：&lt;a href=&quot;http://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/&quot; target=&quot;_blank&quot;&gt;http://refined-x.com/2017/11/28/Vue2.0用户权限控制解决方案/&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://refined-x.com/Vue-Access-Control/&quot;&gt;Vue-Access-Control&lt;/a&gt;是一套基于Vue/Vue-Router/axios 实现的前端用户权限控制解决方案，通过对路由、视图、请求三个层面的控制，使开发者可以实现任意颗粒度的用户权限控制。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;span&gt;整体思路&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;会话开始之初，先初始化一个只有登录路由的Vue实例，在根组件created钩子里将路由定向到登录页，用户登录成功后前端拿到用户token，设置axios实例统一为请求headers添加&lt;code&gt;{&quot;Authorization&quot;:token}&lt;/code&gt;实现用户鉴权，然后获取当前用户的权限数据，主要包括路由权限和资源权限，之后动态添加路由，生成菜单，实现权限指令和全局权限验证方法，并为axios实例添加请求拦截器，至此完成权限控制初始化。动态加载路由后，路由组件将随之加载并渲染，而后展现前端界面。&lt;/p&gt;
&lt;p&gt;为解决浏览器刷新路由重置的问题，拿到token后要将其保存到&lt;code&gt;sessionStorage&lt;/code&gt;，根组件的created钩子负责检查本地是否已有token，如果有则无需登录直接用该token获取权限并初始化，如果token有效且当前路由有权访问，将加载路由组件并正确展现；若当前路由无权访问将按路由设置跳转404；如果token失效，后端应返回4xx状态码，前端统一为axios实例添加错误拦截器，遇到4xx状态码执行退出操作，清除&lt;code&gt;sessionStorage&lt;/code&gt;数据并跳转到登录页，让用户重新登录。&lt;/p&gt;
&lt;h3 id=&quot;最小依赖原则&quot;&gt;最小依赖原则&lt;/h3&gt;
&lt;p&gt;Vue-Access-Control的定位是单一领域解决方案，除了Vue/Vue-Router/axios之外没有其他依赖，理论上可以无障碍的应用到任何有权限控制需求的Vue项目中，项目基于&lt;a href=&quot;https://github.com/vuejs-templates/webpack&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;webpack&lt;/a&gt; 模板开发构建，大多数新项目可以直接基于检出代码继续开发。需要说明的是，项目额外引入的&lt;a href=&quot;http://element-cn.eleme.io/#/zh-CN&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;Element-UI&lt;/a&gt;和&lt;a href=&quot;https://www.npmjs.com/package/crypto-js&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;CryptoJS&lt;/a&gt;仅用于开发演示界面，他们不是必须且与权限控制毫无关系，项目应用中可以自行取舍。&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
src/
  |-- api/                  //接口文件
  |     |-- index.js             //输出通用axios实例
  |     |-- account.js           //按业务模块组织的接口文件，所有接口都引用./index提供的axios实例
  |-- assets/
  |-- components/
  |-- router/
  |     |-- fullpath.js         //完整路由数据，用于匹配用户的路由权限得到实际路由
  |     `-- index.js            //输出基础路由实例
  |-- views/
  |-- App.vue
  ·-- main.js
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据格式约定&quot;&gt;数据格式约定&lt;/h3&gt;
&lt;ul readability=&quot;0.4846547314578&quot;&gt;&lt;li readability=&quot;0.95102040816327&quot;&gt;
&lt;p id=&quot;数据格式约定&quot;&gt;路由权限数据必须是如下格式的对象数组，&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;parent_id&lt;/code&gt;相同的两个路由具有上下级关系，如果希望使用自定义格式的路由数据，需要修改路由控制的相关实现，详见&lt;a href=&quot;http://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6&quot;&gt;路由控制&lt;/a&gt;数据格式约定&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[
    {
      &quot;id&quot;: &quot;1&quot;,
      &quot;name&quot;: &quot;菜单1&quot;,
      &quot;parent_id&quot;: null,
      &quot;route&quot;: &quot;route1&quot;
    },
    {
      &quot;id&quot;: &quot;2&quot;,
      &quot;name&quot;: &quot;菜单1-1&quot;,
      &quot;parent_id&quot;: &quot;1&quot;,
      &quot;route&quot;: &quot;route2&quot;
    }
  ]　　
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.3272251308901&quot;&gt;
&lt;p&gt;资源权限数据必须是如下格式的对象数组，每个对象代表一个RESTful请求，支持带参数的url，具体格式说明见&lt;a href=&quot;http://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#%E8%AF%B7%E6%B1%82%E6%8E%A7%E5%88%B6&quot;&gt;&lt;strong&gt;请求控制&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 [
    {
      &quot;id&quot;: &quot;2c9180895e172348015e1740805d000d&quot;,
      &quot;name&quot;: &quot;账号-获取&quot;,
      &quot;url&quot;: &quot;/accounts&quot;,
      &quot;method&quot;: &quot;GET&quot;
    },
    {
      &quot;id&quot;: &quot;2c9180895e172348015e1740c30f000e&quot;,
      &quot;name&quot;: &quot;账号-删除&quot;,
      &quot;url&quot;: &quot;/account/**&quot;,
      &quot;method&quot;: &quot;DELETE&quot;
    }
]
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;路由控制&quot;&gt;路由控制&lt;/h2&gt;
&lt;p&gt;路由控制包括动态注册路由和动态生成菜单两部分。&lt;/p&gt;
&lt;h3 id=&quot;动态注册路由&quot;&gt;动态注册路由&lt;/h3&gt;
&lt;p&gt;最初实例化的路由仅包括登录和404两个路径，我们期待完整的路由是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;63&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[{
  path: '/login',
  name: 'login',
  component: (resolve) =&amp;gt; require(['../views/login.vue'], resolve)
}, {
  path: '/404',
  name: '404',
  component: (resolve) =&amp;gt; require(['../views/common/404.vue'], resolve)
}, {
  path: '/',
  name: '首页',
  component: (resolve) =&amp;gt; require(['../views/index.vue'], resolve),
  children: [{
    path: '/route1',
    name: '栏目1',
    meta: {
      icon: 'icon-channel1'
    },
    component: (resolve) =&amp;gt; require(['../views/view1.vue'], resolve)
  }, {
    path: '/route2',
    name: '栏目2',
    meta: {
      icon: 'ico-channel2'
    },
    component: (resolve) =&amp;gt; require(['../views/view2.vue'], resolve),
    children: [{
      path: 'child2-1',
      name: '子栏目2-1',
      meta: {
        
      },
      component: (resolve) =&amp;gt; require(['../views/route2-1.vue'], resolve)
    }]
  }]
}, {
  path: '*',
  redirect: '/404'
}]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;那么接下来就需要获取首页以及其子路由们，思路是事先在本地存一份整个项目的完整路由数据，然后根据用户权限对完整路由进行筛选。&lt;/p&gt;
&lt;p&gt;筛选的实现思路是先将后端返回的路由数据处理成如下哈希结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
let hashMenus = {
   &quot;/route1&quot;:true,
   &quot;/route1/route1-1&quot;:true,
   &quot;/route1/route1-2&quot;:true,
   &quot;/route2&quot;:true,
   ...
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后遍历本地完整路由，在循环中将路径拼接成上述结构中的key格式，通过&lt;code&gt;hashMenus[route]&lt;/code&gt;就可以判断路由是否匹配，具体实现见&lt;code&gt;App.vue&lt;/code&gt;文件中的&lt;code&gt;getRoutes()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果后端返回的路由权限数据与约定不同，就需要自行实现筛选逻辑，只要能得到实际可用的路由数据就可以，最终使用&lt;code&gt;addRoutes()&lt;/code&gt;方法将他们动态添加到路由实例中，注意404页面的模糊匹配一定要放在最后。&lt;/p&gt;
&lt;h3 id=&quot;动态菜单&quot;&gt;动态菜单&lt;/h3&gt;
&lt;p&gt;路由数据可以直接用来生成导航菜单，但路由数据是在根组件中得到的，导航菜单存在于&lt;code&gt;index.vue&lt;/code&gt;组件中，显然我们需要通过某种方式共享菜单数据，方法有很多，一般来说首先想到的是Vuex，但菜单数据在整个用户会话过程中不会发生改变，这并不是Vuex的最佳使用场景，而且为了尽量减少不必要的依赖，这里用了最简单直接的方法，把菜单数据挂在根组件&lt;code&gt;data.menuData&lt;/code&gt;上，在首页里用&lt;code&gt;this.$parent.menuData&lt;/code&gt;获取。&lt;/p&gt;
&lt;p&gt;另外，导航菜单很可能会有添加栏目图标的需求，这可以通过在路由中添加&lt;code&gt;meta&lt;/code&gt;数据实现，例如将图标class或unicode存到路由meta里，模板中就可以访问到meta数据，用来生成图标标签。&lt;/p&gt;
&lt;p&gt;在多角色系统中可能遇到的一个问题是，不同角色有一个名字相同但功能不同的路由，比如说&lt;em&gt;系统管理员&lt;/em&gt;和&lt;em&gt;企业管理员&lt;/em&gt;都有”账号管理”这个路由，但他们的操作权限和目标不同，实际上是两个完全不同的界面，而Vue不允许多个路由同名，因此路由的name必须做区分，但把区分后的name显示在前端菜单上会很不美观，为了让不同角色可以享有同一个菜单名称，我们只要将这两个路由的&lt;code&gt;meta.name&lt;/code&gt;都设置成”账号管理”，在模板循环时优先使用&lt;code&gt;meta.name&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;p&gt;菜单的具体实现可以参考&lt;code&gt;views/index.vue&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;视图控制&quot;&gt;视图控制&lt;/h2&gt;
&lt;p&gt;视图控制的目标是根据当前用户权限决定界面元素显示与否，典型场景是对各种操作按钮的显示控制。实现视图控制的本质是实现一个权限验证方法，输入请求权限，输出是否获准。然后配合&lt;code&gt;v-if&lt;/code&gt;或&lt;code&gt;jsx&lt;/code&gt;或自定义指令就能灵活实现各种视图控制。&lt;/p&gt;
&lt;h3 id=&quot;全局验证方法&quot;&gt;全局验证方法&lt;/h3&gt;
&lt;p&gt;验证方法的的实现本身很简单，无非是根据后端给出的资源权限做判断，重点在于优化方法的输入输出，提升易用性，经过实践总结最终使用的方案是，将权限跟请求同时维护，验证方法接收请求对象数组为参数，返回是否具有权限的布尔值。&lt;/p&gt;
&lt;p&gt;请求对象格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//获取账户列表
const request = {
  p: ['get,/accounts'],
  r: params =&amp;gt; {
    return instance.get(`/accounts`, {params})
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;权限验证方法&lt;code&gt;$_has()&lt;/code&gt;的调用格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
v-if=&quot;$_has([request])&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;权限验证方法的具体实现见&lt;code&gt;App.vue&lt;/code&gt;中&lt;code&gt;Vue.prototype.$_has&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;将权限验证方法全局混入，就可以在项目中很容易的配合&lt;code&gt;v-if&lt;/code&gt;实现元素显示控制，这种方式的优点在于灵活，除了可以校验权限外，还可以在判断表达式中加入运行时状态做更多样性的判断，而且可以充分利用&lt;code&gt;v-if&lt;/code&gt;响应数据变化的特点，实现动态视图控制。&lt;/p&gt;
&lt;p&gt;具体实现细节参考&lt;a href=&quot;http://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/&quot;&gt;基于Vue实现后台系统权限控制&lt;/a&gt;中的相关章节。&lt;/p&gt;
&lt;h3 id=&quot;自定义指令&quot;&gt;自定义指令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;v-if&lt;/code&gt;的响应特性是把双刃剑，因为判断表达式在运行过程中会频繁触发，但实际上在一个用户会话周期内其权限并不会发生变化，因此如果只需要校验权限的话，用&lt;code&gt;v-if&lt;/code&gt;会产生大量不必要的运算，这种情况只需在视图载入时校验一次即可，可以通过自定义指令实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//权限指令
Vue.directive('has', {
  bind: function(el, binding) {
    if (!Vue.prototype.$_has(binding.value)) {
      el.parentNode.removeChild(el);
    }
  }
});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;自定义指令内部仍然是调用全局验证方法，但优点在于只会在元素初始化时执行一次，多数情况下都应该使用自定义指令实现视图控制。&lt;/p&gt;
&lt;h2 id=&quot;请求控制&quot;&gt;请求控制&lt;/h2&gt;
&lt;p&gt;请求控制是利用axios拦截器实现的，目的是将越权请求在前端拦截掉，原理是在请求拦截器中判断本次请求是否符合用户权限，以决定是否拦截。&lt;/p&gt;
&lt;p&gt;普通请求的判断很容易，遍历后端返回的的资源权限格式，直接判断&lt;code&gt;request.method&lt;/code&gt;和&lt;code&gt;request.url&lt;/code&gt;是否吻合就可以了，对于带参数的url需要使用通配符，这里需要根据项目需求前后端协商一致，约定好通配符格式后，拦截器中要先将带参数的url处理成约定格式，再判断权限，方案中已经实现了以下两种通配符格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
1. 格式：/resources/:id
   示例：/resources/1
   url: /resources/**
   解释：一个名词后跟一个参数，参数通常表示名词的id
   
2. 格式：/store/:id/member
   示例：/store/1/member
   url：/store/*/member
   解释：两个名词之间夹带一个参数，参数通常表示第一个名词的id
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于第一种格式需要注意的是，如果你要发起一个url为&lt;code&gt;&quot;/aaa/bbb&quot;&lt;/code&gt;的请求，默认会被处理成&lt;code&gt;&quot;/aaa/**&quot;&lt;/code&gt;进行权限校验，如果这里的”bbb”并不是参数而是url的一部分，那么你需要将url改成&lt;code&gt;&quot;/aaa/bbb/&quot;&lt;/code&gt;，在最后加一个”/“表示该url不需要转化格式。&lt;/p&gt;
&lt;p&gt;拦截器的具体实现见&lt;code&gt;App.vue&lt;/code&gt;中的&lt;code&gt;setInterceptor()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果你的项目还需要其他的通配符格式，只需要在拦截器中实现对应的检测和转化方法就可以了。&lt;/p&gt;
&lt;h2 id=&quot;演示及说明&quot;&gt;演示及说明&lt;/h2&gt;
&lt;h3 id=&quot;演示说明：&quot;&gt;演示说明：&lt;/h3&gt;
&lt;p&gt;DEMO项目中演示了动态菜单、动态路由、按钮权限、请求拦截。&lt;/p&gt;
&lt;p&gt;演示项目后端由&lt;a href=&quot;http://rap2.taobao.org/&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;rap2&lt;/a&gt;生成mock数据，登录请求通常应该是POST方式，但因为rap2的编程模式无法获取到非GET的请求参数，因此只能用GET方式登录，实际项目中不建议仿效；&lt;/p&gt;
&lt;p&gt;另外登录后获取权限的接口本来不需要携带额外参数，后端可以根据请求头携带的token信息实现用户鉴权，但因为rap2的编程模式获取不到headers数据，因此只能增加一个”Authorization”参数用于生成模拟数据。&lt;/p&gt;
&lt;h3 id=&quot;测试账号&quot;&gt;测试账号:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
1. username: root
   password: 任意
2. username: client
   password: 任意
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;演示地址&quot;&gt;演示地址:&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://vue-access-control.refined-x.com/&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;vue-access-control.refined-x.com&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 06:48:00 +0000</pubDate>
<dc:creator>雅X共赏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refined-x/p/7942276.html</dc:identifier>
</item>
<item>
<title>APP加固技术历程及未来级别方案：虚机源码保护 - 顶象技术</title>
<link>http://www.cnblogs.com/dxjx/p/7942171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dxjx/p/7942171.html</guid>
<description>&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;6mado-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6mado-0-0&quot;&gt;传统App加固技术，前后经历了四代技术变更，保护级别每一代都有所提升，但其固有的安全缺陷和兼容性问题始终未能得到解决。而下一代加固技术—虚机源码保护，适用代码类型更广泛，App保护级别更高，兼容性更强，堪称未来级别的保护方案。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/7ae/7aeeb49f-bfd7-4804-9c96-2391295d882d.jpg&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aospb-0-0&quot;&gt;（加固技术发展历程）&lt;/span&gt;&lt;/p&gt;

&lt;h2 data-offset-key=&quot;autj9-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;autj9-0-0&quot;&gt;第一代加固技术—动态加载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;j6kl-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;j6kl-0-0&quot;&gt;第一代Android加固技术用于保护应用的逻辑不被逆向与分析，最早普遍在恶意软件中使用，其主要基于Java虚拟机提供的动态加载技术。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;7u1ll-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7u1ll-0-0&quot;&gt;其保护流程是：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;7sqv9-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7sqv9-0-0&quot;&gt;开发阶段中将程序切分成加载（Loader）与关键逻辑（Payload）两部分，并分别打包；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/4d8/4d828a0c-c842-4bdf-8dd6-e338fde2b916.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;cri47-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cri47-0-0&quot;&gt;（开发阶段）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;3fpj3-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3fpj3-0-0&quot;&gt;运行时加载部分（Loader）会先运行，释放出关键逻辑（Payload），然后java的动态加载技术进行加载，并转交控制权。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/5ca/5ca908d4-5162-40d4-a1de-d0781d57a497.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;2ug59-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2ug59-0-0&quot;&gt;（启动流程）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/78b/78bf2bdb-17e8-4aad-87ac-b8cb5508cc14.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;3dmsn-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3dmsn-0-0&quot;&gt;（核心代码）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;9hkm0-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;9hkm0-0-0&quot;&gt;备注（multidex组件的加固原理）：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;210m5-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;210m5-0-0&quot;&gt;Android的DEX文件在设计之初程序普遍较小，所以在DEX文件设计时，只允许包含65535个函数引用。而随着Android应用的发展，大量的应用的代码已经超过了65535的限制，为了解决这个问题，Android5.0之后原生支持加载多个dex，而为了对旧版本的兼容，Android提供了multidex组件。该组件的实现原理与上面介绍的是一致的。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;195me-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;195me-0-0&quot;&gt;缺陷与对抗&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;c51sm-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c51sm-0-0&quot;&gt;第一代加固技术的缺陷是依赖Java的动态加载机制，而这个机制要求关键逻辑（Payload）部分必须解压，并且释放到文件系统，这就给了攻击机会去获取对应的文件。虽然可以通过关键逻辑（Payload）被加载后，被从文件系统删除，用于防止被复制，但是攻击者可以拦截对应的删除函数，阻止删除。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;25ks7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;25ks7-0-0&quot;&gt;而关键逻辑（Payload）会被加密后保存，可用于对抗静态分析，但是攻击者可以通过自定义虚拟机，拦截动态加载机制所使用的关键函数，在这个函数内部，复制文件系统中的关键逻辑（Payload）文件。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 data-offset-key=&quot;bte1g-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;bte1g-0-0&quot;&gt;第二代加固技术—不落地加载&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;8bd2a-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8bd2a-0-0&quot;&gt;相对第一代加固技术，第二代加固技术在APK修改方面已经完善，能做到对开发的零干扰。开发过程中不需要对应用做特殊处理，只需要在最终发布前进行保护即可。而为了实现这个零干扰的流程，Loader需要处理好Android的组件的生命周期。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;a3e5g-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a3e5g-0-0&quot;&gt;主要流程：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;ait8f-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ait8f-0-0&quot;&gt;1）Loader被系统加载。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;9bru-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9bru-0-0&quot;&gt;2）系统初始化Loader内的StubApplication。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;ddr91-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ddr91-0-0&quot;&gt;3）StubApplication解密并且加载原始的DEX文件（Payload）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;fuu1e-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fuu1e-0-0&quot;&gt;4）StubApplication从原始的DEX文件（Payload）中找到原始的Application对象，创建并初始化。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;53euh-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;53euh-0-0&quot;&gt;5）将系统内所有对StubApplication对象的引用使用替换成原始Application，此步骤使用JAVA的反射机制实现。6）由Android系统进行其他组件的正常生命周期管理。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/fc6/fc62a6eb-45bf-4849-a792-ab93e726e418.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;f2fuk-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f2fuk-0-0&quot;&gt;（对开发零干扰的加固后启动流程）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;6dfgg-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;6dfgg-0-0&quot;&gt;另一方面，不落地加载技术是在第一代加固技术的基础上改进，主要解决第一代技术中Payload必须释放到文件系统（俗称落地）的缺陷，其主要的技术方案有两种：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;9fmuq-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9fmuq-0-0&quot;&gt;A．拦截系统IO相关的函数（如read、write），在这些函数中提供透明加解密。具体的流程是：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;bbm5j-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bbm5j-0-0&quot;&gt;1）关键逻辑（Payload）以加密的方式存储在APK中。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;3hboq-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3hboq-0-0&quot;&gt;2）运行时加载部分（Loader）将关键逻辑释（Payload）放到文件系统，此时关键逻辑（Payload）还处于加密状态。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;7c6i8-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7c6i8-0-0&quot;&gt;3）加载部分拦截对应的系统IO函数（read，write等）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;chm99-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;chm99-0-0&quot;&gt;4）加载部分（Loader）正常调用Java动态加载机制。由于虚拟机的IO部分被拦截，所以虚拟机读取到已经解密的关键逻辑（Payload）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/59c/59c215d8-970b-467d-8653-b231ec92e145.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;e3sqa-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e3sqa-0-0&quot;&gt;（透明加解密方案流程）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;18d93-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;18d93-0-0&quot;&gt;B．直接调用虚拟机提供的函数进行不落地的加载，具体流程是：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;21fr3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;21fr3-0-0&quot;&gt;1）关键逻辑（Payload）以加密的方式存储在APK中。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;vnh3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;vnh3-0-0&quot;&gt;2）运行时加载部分（Loader）将关键逻辑释（Payload）放到内存。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;egha9-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;egha9-0-0&quot;&gt;3）加载部分调用虚拟机内部接口进行加载。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/ade/ade75f1d-c350-4f1a-80f9-8397daabc04b.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;62qfb-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;62qfb-0-0&quot;&gt;（不落地加载流程）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;d6ohb-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;d6ohb-0-0&quot;&gt;关键的系统函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/e2a/e2a67a93-ea91-489a-b204-171bdbe0922e.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;7a9cl-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7a9cl-0-0&quot;&gt;方案A透明加密方案由于其需要拦截系统的IO函数，这部分会使用inline hook或者got hook等技术，其会带来一定的兼容性问题&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;4tru8-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4tru8-0-0&quot;&gt;方案B的不落地加载方案由于其调需要调用系统内部的接口，而这个接口并不导出，各个厂商在实现时又有各自的自定义修改，导致该方案存在兼容性问题。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;beneh-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;beneh-0-0&quot;&gt;缺陷与对抗&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;9jd7p-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9jd7p-0-0&quot;&gt;第二代加固技术在应用启动时要处理大量的加解密加载操作，会造成应用长时间假死（黑屏），用户体验差。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;2rlr5-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2rlr5-0-0&quot;&gt;在加固技术实现上没有本质区别，虽然能防止第一代加固技术文件必须落地被复制的缺陷，但是也可以从以下方面进行对抗：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;41qe0-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;41qe0-0-0&quot;&gt;例如内存中的DEX文件头会被清除，用于防止在dump文件中被找到；DEX文件结构被破坏，例如增加了一些错误的数据，提高恢复的成本。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;d0clj-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d0clj-0-0&quot;&gt;但是Payload被加载之后，在内存中是连续的，利用gdb等调试工具dump内存后可以直接找到Payload，进行简单的处理之后可以恢复出100%的Payload文件。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;dqph9-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dqph9-0-0&quot;&gt;和第一代加固技术的对抗方法一样，不落地加载也无法对抗自定义虚拟机。只需对上述的关键函数进行拦截然后将对应的内存段写出去，即可恢复Payload。注意，由于IO相关的函数被拦截，所以无法直接调用read/write等函数进行直接的读写，需要使用syscall函数进行绕过。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;5vqc1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5vqc1-0-0&quot;&gt;虽然厂商会自己实现可能上述函数，从而绕过上述函数的拦截。但是Android的类加载器必须能找到对于的结构体才能正常执行，攻击者可以以类加载器做为起点，找到对应的Payload在内存中的位置。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 data-offset-key=&quot;d0dn6-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;d0dn6-0-0&quot;&gt;第三代加固技术—指令抽离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;15uv7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;15uv7-0-0&quot;&gt;由于第二代加固技术仅仅对文件级别进行加密，其带来的问题是内存中的Payload是连续的，可以被攻击者轻易获取。第三代加固技术对这部分进行了改进，将保护级别降到了函数级别。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;4l8rs-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4l8rs-0-0&quot;&gt;主要的流程是：发布阶段将原始DEX内的函数内容（Code Item）清除，单独移除到一个文件中。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/29f/29f871c7-88d0-4afe-8bac-d52b265d2051.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;48h20-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;48h20-0-0&quot;&gt;（发布阶段）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;750oc-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;750oc-0-0&quot;&gt;运行阶段将函数内容重新恢复到对应的函数体。恢复的时间点有几个方式：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;5hctv-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5hctv-0-0&quot;&gt;A.加载之后恢复函数内容到DEX壳所在的内存区域&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/c73/c73d44d7-77b5-41ea-8cba-1f6551e317dd.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;8gv6g-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8gv6g-0-0&quot;&gt;（运行阶段）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;cuksc-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;cuksc-0-0&quot;&gt;B.加载之后将函数内容恢复到虚拟机内部的结构体上：虚拟机读取DEX文件后内部对每一个函数有一个结构体，这个结构体上有一个指针指向函数内容（CodeItem），可以通过修改这个指针修改对应的函数内容。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/b2d/b2dd9e91-21fc-4b87-9706-9b8e119b7b78.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;di39v-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;di39v-0-0&quot;&gt;C.拦截虚拟机内与查找执行代码相关的函数，返回函数内容。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;cce9c-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cce9c-0-0&quot;&gt;指令抽离技术使用了大量的虚拟内部结构与未被文档的特性，再加上Android复杂的厂商定制，带来大量的兼容性问题。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;egqa9-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;egqa9-0-0&quot;&gt;缺陷与对抗&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;6ffb5-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6ffb5-0-0&quot;&gt;指令抽离技术的某些方案与虚拟机的JIT性能优化冲突，无法达到最佳的运行性能。依旧使用了java虚拟机进行函数内容的执行。攻击者可以通过自定义Android虚拟机，在解释器的代码上做记录一个函数的内容（CodeItem）。接下来遍历触发所有函数，从而获取到全部的函数内容。最终重新组装成一个完整的DEX文件。目前已经有自动化工具可以指令抽离技术中脱壳。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/7e2/7e249d36-0b50-471d-9771-527febd1c84c.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4idce-0-0&quot;&gt;（第三代加固DEX文件脱壳流程）&lt;/span&gt;&lt;/p&gt;

&lt;h2 data-offset-key=&quot;bhs5b-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;bhs5b-0-0&quot;&gt;第四代加固技术—指令转换/VMP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;btg8q-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;btg8q-0-0&quot;&gt;第三代加固技术在函数级别的保护，使用Android虚拟机内的解释器执行代码，带来可能被记录的缺陷，第四代加固技术使用自己的解释器来避免第三代的缺陷。而自定义的解释器无法对Android系统内的其他函数进行直接调用，必须使用JAVA的JNI接口进行调用。其主要实现由两种：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;4kt38-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4kt38-0-0&quot;&gt;A.DEX文件内的函数被标记为native，内容被抽离并转换成一个符合JNI要求的动态库。 动态库内通过JNI和Android系统进行交互。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/96c/96c77d37-73e2-4974-bda5-c8f754bfe0cf.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;bs1or-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bs1or-0-0&quot;&gt;B.DEX文件内的函数被标记为native，内容被抽离并转换成自定义的指令格式，该格式使用自定义接收器执行，和A一样需要使用JNI和Android系统进行调用。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/544/5447059c-ace3-44c1-bcb0-202e506894de.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;6iq7i-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6iq7i-0-0&quot;&gt;第四代VMP加固技术一般配合第三代加固技术使用，所以第三代的所有兼容性问题，指令转换/VMP加固也存在。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;3rrpf-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3rrpf-0-0&quot;&gt;缺陷与对抗&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;esos-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;esos-0-0&quot;&gt;不论使用指令转换/VMP加固的A方案或者B方案，其必须通过虚拟机提供的JNI接口与虚拟机进行交互，攻击者可以直接将指令转换/VMP加固方案当作黑盒，通过自定义的JNI接口对象，对黑盒内部进行探测、记录和分析，进而得到完整DEX程序。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/1be/1be1b184-7813-4574-bef9-a450aa69b1a9.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;3ko87-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3ko87-0-0&quot;&gt;（第四代加固DEX文件恢复）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;5e5jm-0-0&quot; readability=&quot;8&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;5e5jm-0-0&quot;&gt;另外，第四代VMP加固技术只实现Java代码保护，没有做到使用VMP技术来保护C/C++等代码，安全保护能力有所欠缺。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 data-offset-key=&quot;55ag5-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;55ag5-0-0&quot;&gt;下一代加固技术—虚机源码保护&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;234fd-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;234fd-0-0&quot;&gt;跟第四代的VMP加固技术，虚机源码保护加固是用虚机技术保护所有的代码，包括Java，Kotlin，C/C++，Objective-C，Swift等多种代码，具备极高的兼容性；使App得到更高安全级别的保护，运行更加稳定。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;deifd-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;deifd-0-0&quot;&gt;虚机源码保护为用户提供一套完整的工具链，首先把用户待保护的核心代码编译成中间的二进制文件，随后生成独特的虚机源码保护执行环境和只能在该环境下执行的运行程序。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;e80qs-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e80qs-0-0&quot;&gt;虚机源码保护会在App内部隔离出独立的执行环境，该核心代码的运行程序在此独立的执行环境里运行。即便App本身被破解，这部分核心代码仍然不可见。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://cdn.dingxiang-inc.com/images/64e/64e67945-0e11-4ddf-b81e-6f6aa57a487c.png&quot; alt=&quot;undefined&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;ej6k9-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ej6k9-0-0&quot;&gt;（虚机源码保护加固流程）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;stus-0-0&quot; readability=&quot;10&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;stus-0-0&quot;&gt;生成的虚机源码保护拥有独特的可变指令集，极大的提高了指令跟踪、逆向分析的难度。同时，虚机源码保护还提供了反调试能力和监控能力。虚机源码保护可以通过自身的探针感知到环境的变化，实时探测到外界对本环境的调试、注入等非正常执行流程变化，将调试动作引入程序陷阱，并发出警报，进而进行实时更新，提高安全强度。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div data-block=&quot;true&quot; data-editor=&quot;ep0ab&quot; data-offset-key=&quot;5ctqe-0-0&quot; readability=&quot;9.1866028708134&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5ctqe-0-0&quot;&gt;加固技术发展及其攻防对抗的更迭，伴随着互联网技术发展不断升级，我们深信邪不能胜正，而虚机源码保护加固作为当前领先的加固技术，在未来很长一段时间，能够为App提供足够强度的保护，为企业和开发者的业务发展保驾护航。&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Fri, 01 Dec 2017 06:34:00 +0000</pubDate>
<dc:creator>顶象技术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dxjx/p/7942171.html</dc:identifier>
</item>
<item>
<title>使用面向对象抽取业务算法 - 王森</title>
<link>http://www.cnblogs.com/wangsen/p/7942065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangsen/p/7942065.html</guid>
<description>&lt;p&gt;前面我们已经对领域内的名词进行了抽取，并且已经确定了业务流程中参与的核心对象。&lt;br/&gt;但是对象只是静态的描述，系统中往往会有很多的业务操作，偏算法的，之前我们说过&lt;br/&gt;领域内的对象往往是比较稳定不怎么变化的，但是，业务的流程以及业务操作这些是往往&lt;br/&gt;千变万化，防不胜防，那么我们如何去及时发现这些系统内变化点，并且如何使用面向对象&lt;br/&gt;的方式去抽象，封装它呢？，下面就简单介绍我们大神的一些个人经验，也在此记录一下。&lt;/p&gt;

&lt;p&gt;关注系统中的变化点或者说业务的流程中某个节点的多变的算法，&lt;br/&gt;提供系统的可维护性和扩展性。&lt;/p&gt;

&lt;p&gt;先说步骤，步骤后面跟着一些场景进行解析，试着理解步骤。&lt;/p&gt;
&lt;h2 id=&quot;找出变化点&quot;&gt;找出变化点&lt;/h2&gt;
&lt;p&gt;这是第一步也是关键的一步，如果你连这个系统中的变化点都找不到，下面的工作也就&lt;br/&gt;无从谈起，所以我们在这个阶段就要去细心观察找出那些业务的变化点，&lt;br/&gt;一般的我们可以从产品的原型中，产品的沟通中可以找到：&lt;br/&gt;关注那些从描述上看起来不一样，却又是在做同一件事的场景。&lt;/p&gt;
&lt;h2 id=&quot;去限定词&quot;&gt;去限定词&lt;/h2&gt;
&lt;p&gt;找出这个场景或者算法每次而且每条都出现的领域名词和没有限定词的动词，其他的全部可以忽略。&lt;br/&gt;简单的说就是把场景中的不断出现的领域名词都删除掉，留下动词。&lt;/p&gt;
&lt;h2 id=&quot;抽取动词&quot;&gt;抽取动词&lt;/h2&gt;
&lt;p&gt;根据上一步的操作，我们对场景中的动词需要进行抽象一下，使用一个动作统一概括。&lt;/p&gt;
&lt;h2 id=&quot;抽取接口&quot;&gt;抽取接口&lt;/h2&gt;
&lt;p&gt;将这个动作作为一个接口存在，确定这个接口中的方法用来做什么以及它的输入，输出。&lt;br/&gt;说白了就是定义一个函数的名称，参数，返回值。&lt;br/&gt;一般来说输入的要是抽象中每次都出现的名词，输出是这个抽象需要的内容。&lt;/p&gt;
&lt;h2 id=&quot;聚合接口&quot;&gt;聚合接口&lt;/h2&gt;
&lt;p&gt;并不是说一个接口只能有一个方法，实际上，有些方法是成双成对，甚至是成几对出现的。&lt;br/&gt;如果发现两个接口合在一起刚好可以表达一个完整的事情就可以将这两个接口合并成一个接口。&lt;/p&gt;

&lt;h2 id=&quot;场景一描述&quot;&gt;场景一描述&lt;/h2&gt;
&lt;p&gt;在优学习（教育网站http://www.uxuexi.com）这个网站上为用户提供了很多的服务，比如：&lt;br/&gt;可以购买单个视频进行观看，&lt;br/&gt;也可以将视频打包购买进行观看，&lt;br/&gt;可以购买阅卷服务让老师给用户的试卷进行评阅&lt;br/&gt;也可以购买约课的服务让老师上门或者在线进行辅导&lt;br/&gt;这个业务场景是一个变化点，因为平台中可以添加任何具有服务性质的东西让用户购买。&lt;br/&gt;这里可以抽取一个商品的概念，其实用户购买的就是商品，不管它是视频，评卷服务，辅导服务都是商品。&lt;br/&gt;所有我们按照步骤就这么做。&lt;/p&gt;
&lt;h3 id=&quot;去限定词-1&quot;&gt;去限定词：&lt;/h3&gt;
&lt;p&gt;购买xx商品得到xx商品的服务&lt;/p&gt;
&lt;h3 id=&quot;抽取动词-1&quot;&gt;抽取动词：&lt;/h3&gt;
&lt;p&gt;购买，服务&lt;/p&gt;
&lt;h3 id=&quot;抽取接口-1&quot;&gt;抽取接口：&lt;/h3&gt;
&lt;p&gt;IBuy&lt;br/&gt;接口中的方法：&lt;br/&gt;方法名称：goToBuy&lt;br/&gt;参数：商品&lt;br/&gt;执行：完成购买&lt;br/&gt;返回：空&lt;br/&gt;IService&lt;br/&gt;方法名称：supply&lt;br/&gt;参数：商品&lt;br/&gt;执行：商品提供的服务&lt;br/&gt;返回：空&lt;/p&gt;
&lt;h3 id=&quot;类图如下&quot;&gt;类图如下：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/506422/201712/506422-20171201141519492-1890651360.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;合并接口&quot;&gt;合并接口&lt;/h3&gt;
&lt;p&gt;我们会发现但凡我们需要增加一个商品都需要实现这两个接口，这个时候就说明我们可以&lt;br/&gt;将这两个接口抽取成一个接口，这就是聚合接口。&lt;/p&gt;
&lt;h3 id=&quot;类图如下-1&quot;&gt;类图如下：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/506422/201712/506422-20171201141532820-1818247995.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;场景二描述&quot;&gt;场景二描述&lt;/h2&gt;
&lt;p&gt;在电商网站中支付是一个重要的环节，往往会有以下需求：&lt;br/&gt;用户可以使用支付宝完成订单支付&lt;br/&gt;用户可以使用微信完成订单支付&lt;br/&gt;用户可以使用银行卡的方式完成订单支付&lt;/p&gt;
&lt;h3 id=&quot;找出变化点-1&quot;&gt;找出变化点&lt;/h3&gt;
&lt;p&gt;这个场景的变化点就是用户可以使用多种方式完成支付。&lt;/p&gt;
&lt;h3 id=&quot;去限定词-2&quot;&gt;去限定词&lt;/h3&gt;
&lt;p&gt;使用xx方式完成订单支付&lt;/p&gt;
&lt;h3 id=&quot;抽取动词-2&quot;&gt;抽取动词&lt;/h3&gt;
&lt;p&gt;这个场景强调的动作是支付，所以动词应该就是：去支付&lt;br/&gt;但是，我们知道每一个支付都需要我们提供给一个支付完成的回调供支付平台通知支付结果，&lt;br/&gt;所以这里要添加一个动作：完成支付&lt;/p&gt;
&lt;h3 id=&quot;抽取接口-2&quot;&gt;抽取接口&lt;/h3&gt;
&lt;p&gt;接口中的方法：&lt;br/&gt;方法名称：goToPay&lt;br/&gt;参数：订单&lt;br/&gt;执行：完成购买&lt;br/&gt;返回：空&lt;br/&gt;方法名称：finish&lt;br/&gt;参数：订单&lt;br/&gt;执行：完成购买&lt;br/&gt;返回：空&lt;/p&gt;
&lt;h3 id=&quot;类图&quot;&gt;类图：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/506422/201712/506422-20171201141551930-2010442350.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;场景三描述&quot;&gt;场景三描述&lt;/h2&gt;
&lt;p&gt;在做优学习网站时，出现了这么一个场景，每一个视频的播放需要鉴权，&lt;br/&gt;也就是说用户点击某个视频的时候由后台决定他是否有观看的权限。&lt;br/&gt;情况如下：&lt;br/&gt;免费的视频可以观看&lt;br/&gt;课程包中的第一个视频可以观看&lt;br/&gt;购买的视频中包含这个视频的可以观看&lt;br/&gt;请求来源的域名如果在白名单中可以观看所有视频&lt;br/&gt;网站的合作商可以观看所有视频&lt;br/&gt;等等。。。。&lt;/p&gt;
&lt;h3 id=&quot;找出变化点-2&quot;&gt;找出变化点&lt;/h3&gt;
&lt;p&gt;判断视频是否可以播放的条件在不断增加，这就是一个变化点。&lt;/p&gt;
&lt;h3 id=&quot;去限定词-3&quot;&gt;去限定词&lt;/h3&gt;
&lt;p&gt;视频是否可以观看&lt;/p&gt;
&lt;h3 id=&quot;抽取动作&quot;&gt;抽取动作&lt;/h3&gt;
&lt;p&gt;判断视频是否可以观看其实就是鉴权，所以动作就是：是否可以播放&lt;/p&gt;
&lt;h3 id=&quot;抽取接口-3&quot;&gt;抽取接口&lt;/h3&gt;
&lt;p&gt;接口名称：IVideoAuthentication&lt;br/&gt;接口中的方法：&lt;br/&gt;方法名称：goToPay&lt;br/&gt;参数：视频id&lt;br/&gt;执行：判断是否具有播放权限&lt;br/&gt;返回：布尔&lt;/p&gt;
&lt;h3 id=&quot;类图-1&quot;&gt;类图：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/506422/201712/506422-20171201141658023-1469267785.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接口有了，但是我们怎么更好组织它呢？&lt;br/&gt;一般的场景我们可以采用以下方案：&lt;/p&gt;
&lt;h2 id=&quot;平行算法&quot;&gt;平行算法&lt;/h2&gt;
&lt;p&gt;如果这些接口的具体实现在同一时刻只能出现一个具体算法，这些算法又可以平行替换，&lt;br/&gt;我们就可以参考“策略模式&quot;去设计。&lt;/p&gt;
&lt;h2 id=&quot;串行算法&quot;&gt;串行算法&lt;/h2&gt;
&lt;p&gt;如果这些接口的具体实现在同一时刻有可能需要组合一起去完成某个功能这就是串行，&lt;br/&gt;我们可以使用”职责链模式“去设计。&lt;/p&gt;
&lt;h2 id=&quot;考虑重用&quot;&gt;考虑重用&lt;/h2&gt;
&lt;p&gt;如果这些算法之间有一些公用的逻辑，业务，算法我们可以考虑使用，模板模式，装饰模式去解决重复问题，&lt;br/&gt;让我们的设计更加合理有扩展性。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 06:27:00 +0000</pubDate>
<dc:creator>王森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangsen/p/7942065.html</dc:identifier>
</item>
<item>
<title>（译）学习JavaScript闭包 - RichardLau</title>
<link>http://www.cnblogs.com/Lau7/p/7942100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lau7/p/7942100.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包是JavaScript中一个基础概念，这是每个严格意思上的程序员都应该十分熟悉的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网络上有很多文章介绍闭包是什么，但是很少有文章深入讲解为什么是这样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我发觉从根本上去理解一种技术，能够使开发人员去熟练地使用他们所掌握的工具，所以这篇文章致力于从细节上去讲解闭包内部原理是怎么样的，以及为什么是这样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;希望在你以后的日常工作中，能够更好的运用闭包的优势。那我们开始吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;什么是闭包？&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;闭包是JavaScript（和大多数编程语言）中一个强大的特性。MDN对闭包的定义是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包是指向独立（自由）变量的函数，换句话说，定义在闭包里的函数“记住”了它创建时的环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：自由变量是指那些既不是局部变量，也不是作为参数传递的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看几个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; numberGenerator() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 闭包里的局部“自由”变量&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; num = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkNumber() { 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    console.log(num);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; checkNumber;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; number =&lt;span&gt; numberGenerator();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; number(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;在上面的例子中，&lt;strong&gt;numberGenerator&lt;/strong&gt;函数创建了一个局部的“自由”变量&lt;strong&gt;num &lt;/strong&gt;（数字变量）和&lt;strong&gt;checkNumber &lt;/strong&gt;（把&lt;strong&gt;num&lt;/strong&gt;打印在命令窗口的函数）。&lt;strong&gt;checkNumber &lt;/strong&gt;函数中没有定义局部变量——然而，它可以访问父函数（&lt;strong&gt;numberGenerator&lt;/strong&gt;）里定义的变量，这就是因为闭包。因此，它可以使用定义在&lt;strong&gt;numberGenerator&lt;/strong&gt;函数里的&lt;strong&gt;num&lt;/strong&gt;变量，并成功地把它输出在命令窗口，即便是在&lt;strong&gt;numberGenerator&lt;/strong&gt;函数返回之后依然如此。&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;例2：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个例子中，我们将演示一个闭包里包含了所有定义在其父函数内部定义的局部变量。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; say = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { console.log(hello); }
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Local variable that ends up within the closure &lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; hello = 'Hello, world!'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; say;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; sayHelloClosure =&lt;span&gt; sayHello(); 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; sayHelloClosure(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ‘Hello, world!’&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;span&gt;&lt;br/&gt;注意变量&lt;strong&gt;hello&lt;/strong&gt;是如何在匿名函数后定义的，但这个匿名函数依然可以访问&lt;strong&gt;hello&lt;/strong&gt;变量，这是因为&lt;strong&gt;hello&lt;/strong&gt;变量被创建时已经定义在函数“作用域”里了，这使得当匿名函数最终执行时，&lt;strong&gt;hello&lt;/strong&gt;变量依然可用。（别急，我将随后在这篇文章中解释什么是“作用域”，现在，就让我们来看看）&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;高层次的理解&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两个例子从一个高层次来阐述了“什么”闭包。一般的主题是这样的——我们可以访问定义在封闭函数里的变量，即使这些封闭函数定义在变量返回之后。显然，在这背后肯定做了一些其它的事情，这些事使得这些变量即使在其后的封闭函数返回之后还可以访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了理解这是怎么实现的，我们需要去接触一些相关的概念——我们将从更高的层次一步步走向闭包。让我们从一个函数运行的全局上下文开始，即所谓的“执行上下文”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;执行上下文&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行上下文是ECMAScript规范使用的抽象概念，用于跟踪代码的运行时评估。这可以是你代码首先执行时的全局上下文，或者是当执行到一个函数体时的上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*_LacLIeET7asTTIKpHCawA.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在任意一个时间点，都只能运行一个执行上下文，这就是为什么JavaScript是“单线程”的，这就意味着每次只能有一条命令被处理。通常，浏览器使用“栈”来维护这个执行上下文，栈是后进先出的数据结构，这意味着最后压进栈的是最先被弹出来的（这是因为我们只能在栈顶插入或删除元素）。当前或“正在运行的”执行上下文总是在栈顶的，当运行执行上下文的代码被完全执行后，它就从栈顶弹出，这就允许下一个顶部项接管运行执行上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，仅仅因为执行上下文正在运行，并不意味着它必须在不同的执行上下文运行之前完成运行；有时，运行执行上下文被挂起，不同的执行上下文成为运行的执行上下文，被挂起的执行上下文可能会在以后的某个点上重新回到它被挂起的位置，在任何时刻，一个执行上下文就这样被其它执行上下文替代，一个新的执行上下文被创建，并压到栈里，成为当前执行上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*M8VqttSMghsxyXcBo2Zz1w.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在浏览器里用实际的例子来说明这个概念，请看下面这个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; b = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(c) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; d = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; boop(x + a + b + c +&lt;span&gt; d);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; boop(e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; e * -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; moar = foo(5); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Closure  &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  The function below executes the function bar which was returned 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  when we executed the function foo in the line above. The function bar 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;  invokes boop, at which point bar gets suspended and boop gets push 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  onto the top of the call stack (see the screenshot below)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; moar(15); 
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*YWiyU5u3ONPrszk8QvHaqw.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当boop 返回时，它会弹出栈顶，而bar 复原：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*MMgltiRSX6zGyCPQTM7CjA.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们有一串执行上下文一个接一个运行时——通常一个执行上下文在中间被暂停，然后又会被恢复——我们需要一种方式来跟进这个状态的变化，所以我们可以管理这些执行这些上下文的顺序，实际上就是这样的。根据ECMAScript规范，每个执行上下文有各种状态组件，用于记录每个上下文中的代码的进展情况。这包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;代码评估状态:&lt;/strong&gt;执行、暂停和恢复与此执行上下文相关的代码的任何状态。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;函数：&lt;/strong&gt;该执行上下文正在评估的函数对象。（如果被评估的上下文是脚本或模块，则为null）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;领域：&lt;/strong&gt;一组内部对象，ECMAScript全局环境，在该全局环境范围内加载的所有ECMAScript代码，以及其他关联的状态和资源。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;词法环境：&lt;/strong&gt; 用来解析该执行上下文中的代码所作的标识符引用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;变量环境：&lt;/strong&gt;词法环境，环境记录保存由该执行上下文中的变量状态创建的绑定。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果这听起来让你很迷惑，不要担心，所有这些变量，词法环境变量对我们来说是最有意思的变量，因为它显示声明，它解析该执行上下文中的代码所作的“标识符引用”。你可以认为“标识符”就是变量。因为我们最初的目的是弄清楚，它是怎么去访问那些即使函数（或“上下文”）已经返回的变量，词法环境看起来就是我们应该去深究的东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;从技术上说，通过使用变量环境和词法环境一起来实现闭包，但是为了简单起见，我们将统一用“环境”来表示，对于词法环境和变量环境间的不同处的细节解释，可以查看 Alex Rauschmayer’s博士的&lt;a href=&quot;http://www.2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html&quot;&gt;article&lt;/a&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;词法环境&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义：词法环境是一种规范类型，用于根据ECMAScript代码的词汇嵌套结构定义标识符与特定变量和函数的关联。词汇环境由一个环境记录和一个指向外部词汇环境的可能为空的引用组成。通常，词汇环境与ECMAScript代码的某些特定的语法结构相关联，比如函数声明、块语句或异常捕获语句，以及每次执行这些代码时，都会创建一个新的词法环境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们来分开解释下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;“用于定义标识符的关联”：&lt;/strong&gt;词法环境的目的是用来管理代码里的数据（如标识符），换句话说，它使得标识符有意义。例如，如果我们有一行代码“&lt;em&gt;console.log(x / 10)&lt;/em&gt;”，如果变量(或“标识符”)&lt;strong&gt;x&lt;/strong&gt;没有任何含义，那么这行代码就没有任何意义了。词法环境就是通过它的环境记录来提供意义（或“关联”）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;“词法环境由环境记录组成”：&lt;/strong&gt;环境记录是用一种奇特的方式来描述它是保存了所有标识符和它们在词法环境里的绑定的记录。每个词法环境都有各自的环境记录。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;“词法嵌套结构”：&lt;/strong&gt;这是最有意思的部分，这个基本上说是它的内部环境引用它的外部环境，而它的外部环境也一样可以有它的外部环境，所以，一个环境可以是多个内部环境的外部环境。全局环境是唯一一个没有外部环境的词法环境，这就是JS的棘手之处，我们可以用洋葱的皮层来表示词法环境：全局环境就是洋葱最外层的皮层，每一个子层都嵌套在它里面。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*WIBH8HW9WzoKfBsQPGFHHg.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;抽象地说，用伪代码来描述环境它看起来就是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; LexicalEnvironment =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  EnvironmentRecord: {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Identifier bindings go here&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   
&lt;span&gt;6&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reference to the outer environment&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;   outer: &amp;lt; &amp;gt;
&lt;span&gt;8&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; &lt;strong&gt;“每次执行这样的代码就会创建一个新的词法环境”：&lt;/strong&gt;每次一个封闭的外部函数被调用时，就会创建一个新的词法环境，这一点很重要——我们在文章最后将会再说到这点。（&lt;em&gt;边注：函数不是唯一可以创建词法环境的方式，块语句和catch子句也可以创建词法环境，为了简单起见，在这篇文章中我们将只说函数创建的环境。&lt;/em&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总之，每一个执行上下文都有一个词法环境，这个词法环境包含了变量和其相关的值，以及对它外部环境的引用。词法环境可以是全局环境、模块环境（它包含对模块顶层声明的绑定），或者函数环境（由于调用函数创建的环境）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;作用域链&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于上面的定义，我们知道一个环境可以访问它的父环境，它的父环境也可以访问它的父环境，依次类推。每个环境都可以访问的这个标识符集称为“作用域”。我们可以嵌套作用域到一个层次环境链里，这就是我们所知道的“作用域链”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来看一个嵌套结构的例子：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; y = 20; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; free variable&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; z = 15; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; free variable&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x + y +&lt;span&gt; z;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;就像你所看到的，&lt;strong&gt;bar&lt;/strong&gt;就是嵌套在&lt;strong&gt;foo&lt;/strong&gt;里，为你帮你视觉化嵌套，请看下图：&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*CwxZxltknV8DEEm_Y_ykfA.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在文章后面再回顾一下这个例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用域链或者一个函数相关的环境链，是在创建时保存在这个函数对象。它是由源代码中的位置静态定义的。（这就是我们熟知的“词法作用域”）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们快速地了解一下“动态作用域”和“静态作用域”的不同之处，这将帮助我们理解为了实现闭包， 为什么静态作用域（或者词法作用域）是必须存在的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;动态作用域 VS 静态作用域&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态作用域语言具有“基于栈的实现”，这意味着局部变量和函数参数被存放在堆栈里，因此，程序堆栈的运行时状态决定了你所引用的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一方面，静态范围是根据创建的时间来记录在上下文中，换句话说，程序源代码的结构决定了你所引用的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到此，你可能会想动态作用域和静态作用域是如何不同的。下面有两个例子来帮你阐述这一点：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; y = x + 5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; y;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; x = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; foo();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   foo(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Static scope: 15; Dynamic scope: 15&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   bar(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Static scope: 15; Dynamic scope: 7&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;当&lt;strong&gt;bar&lt;/strong&gt;函数被调用时，我们可以看到上面的动态作用域和静态作用域返回了不同的值。&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在静态作用域里，&lt;strong&gt;bar&lt;/strong&gt;返回的值是基于&lt;strong&gt;foo&lt;/strong&gt;函数创建时返回的&lt;strong&gt;x&lt;/strong&gt;的值，这是因为源代码的静态和词法结构，结果就是&lt;strong&gt;x&lt;/strong&gt;的值是10，最后返回的结果就是15.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一方面，动态作用域在运行时为我们提供了一组变量定义——这样我们具体使用的是哪个&lt;strong&gt;x&lt;/strong&gt;就取决于哪个&lt;strong&gt;x&lt;/strong&gt;在作用域里，以及在运行时哪个&lt;strong&gt;x&lt;/strong&gt;被动态定义了。运行&lt;strong&gt;bar&lt;/strong&gt;函数把x=2压到栈顶，这样就使得&lt;strong&gt;foo&lt;/strong&gt;返回7了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;例2：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; myVar = 100&lt;span&gt;;
 
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  console.log(myVar);
}
 
foo(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Static scope: 100; Dynamic scope: 100&lt;/span&gt;
&lt;span&gt; 
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myVar = 50&lt;span&gt;;
  foo(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Static scope: 100; Dynamic scope: 50&lt;/span&gt;
&lt;span&gt;})();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Higher-order function&lt;/span&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (arg) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myVar = 1500&lt;span&gt;;
  arg();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Static scope: 100; Dynamic scope: 1500&lt;/span&gt;
})(foo);
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;span&gt;同样，在动态作用域的例子，上面的&lt;strong&gt;myVar&lt;/strong&gt;变量在使用了&lt;strong&gt;myVar&lt;/strong&gt;变量的函数被调用的地方解析。另一方面，在静态作用域里，将&lt;strong&gt;myVar&lt;/strong&gt;解析为在创建两个IIFE函数的范围内保存的变量&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像你所看到的，动态作用域常常导致一些歧义，这不能明确知道自由变量将解析自哪个作用域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有些可能让你觉得离题了，但是事实上，我们已经涵盖了我们所需要了解闭包的所有东西了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;每个函数都有一个执行上下文，它包含给定函数里的变量意义的环境，和指向它父环境里的引用。指向父环境里的引用使得父作用域里的所有变量对于其所有内部函数都是可用的，不管内部函数是否在它们创建时的作用域内或外被调用。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;所以，这就像函数“记住”它的环境（或者作用域），因为函数实际上有一个指向这个环境的引用（以及定义在那个环境里的变量）&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到嵌套结构的例子：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = 10&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = 20; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; free variable&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; z = 15; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; free variable&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x + y +&lt;span&gt; z;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; test =&lt;span&gt; foo();

test(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;span&gt;基于我们对环境是如何工作的认识，我们可以说，上面例子中定义的环境看起来是这样的（注意，这个完全是伪代码）：&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
GlobalEnvironment =&lt;span&gt; {
  EnvironmentRecord: { 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; built-in identifiers&lt;/span&gt;
    Array: '&amp;lt;func&amp;gt;'&lt;span&gt;,
    Object: &lt;/span&gt;'&amp;lt;func&amp;gt;'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; etc..&lt;/span&gt;
    
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; custom identifiers&lt;/span&gt;
    x: 10&lt;span&gt;
  },
  outer: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
};
 
fooEnvironment &lt;/span&gt;=&lt;span&gt; {
  EnvironmentRecord: {
    y: &lt;/span&gt;20&lt;span&gt;,
    bar: &lt;/span&gt;'&amp;lt;func&amp;gt;'&lt;span&gt;
  }
  outer: GlobalEnvironment
};

barEnvironment &lt;/span&gt;=&lt;span&gt; {
  EnvironmentRecord: {
    z: &lt;/span&gt;15&lt;span&gt;
  }
  outer: fooEnvironment
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当我们调用&lt;strong&gt;test&lt;/strong&gt;函数时，我们得到的结果是45，这是从&lt;strong&gt;bar&lt;/strong&gt;函数被调用时返回的值（因为&lt;strong&gt;foo&lt;/strong&gt;函数返回&lt;strong&gt;bar&lt;/strong&gt;函数），即使&lt;strong&gt;foo&lt;/strong&gt;函数返回后，&lt;strong&gt;bar&lt;/strong&gt;还是可以访问变量&lt;strong&gt;y&lt;/strong&gt;，因为&lt;strong&gt;bar&lt;/strong&gt;通过它的外部环境引用&lt;strong&gt;y&lt;/strong&gt;，它的外部环境就是&lt;strong&gt;foo&lt;/strong&gt;的环境，&lt;strong&gt;bar&lt;/strong&gt;也可以访问全局变量&lt;strong&gt;x&lt;/strong&gt;，因为&lt;strong&gt;foo&lt;/strong&gt;的环境可以访问全局环境。这称之为“沿着作用域链查找”&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回我们讨论的动态作用域和静态作用域：要实现闭包，我们不能使用动态作用域来存储我们的变量。这是因为，这样做的话，当函数返回时，变量将会从栈里弹出，并将不再有效——这就和我们对闭包最初的定义正好相反。取而代之是闭包中父级上下文中的数据被保存在称之为“堆”的东西里，它允许函数调用返回后，它的数据还保存在堆里（比如 即使执行上下文被弹出执行调用栈）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;听起来很有道理？很好，我们现在在抽象层面理解了闭包的内部实现，让我们来多看几个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;例1：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个典型的例子/错误是当有一个for循环，而且我们尝试把for循环中的计数变量与for循环中的一些函数相关联：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; [];
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
  result[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(i);
  };
}

result[&lt;/span&gt;0](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5, expected 0&lt;/span&gt;
result[1](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5, expected 1&lt;/span&gt;
result[2](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5, expected 2&lt;/span&gt;
result[3](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5, expected 3&lt;/span&gt;
result[4](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5, expected 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;span&gt;回到我们刚才所学的，我们就可以轻而易举就发现其中的错误所在！绝对，当for循环结束后，它这里的环境就像下面的一样：&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;environment: {
  EnvironmentRecord: {
    result: [...],
    i: &lt;/span&gt;5&lt;span&gt;
  },
  outer: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;span&gt;&lt;br/&gt;这里错误的假想在作用域，以为结果数组中五个函数的作用域是不一样的，然而，事实上结果数组中五个函数的环境（或者/上下文/作用域）是一样的，因此，变量&lt;strong&gt;i&lt;/strong&gt;每增加一次，它就更新了作用域里的值——这个作用域里的值是被所有函数共享的。这就是为什么五个函数中的任意一个去访问&lt;strong&gt;i&lt;/strong&gt;时都返回5的原因（当for循环结束时，&lt;strong&gt;i&lt;/strong&gt;等于5）。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决这个问题的一种方式，是为每一个函数创建一个附加的封闭上下文，这样每个函数都能取得它们自己拥有的执行上下文/作用域：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; [];
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
  result[i] &lt;/span&gt;= (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inner(x) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; additional enclosing context&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      console.log(x);
    }
  })(i);
}

result[&lt;/span&gt;0](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0, expected 0&lt;/span&gt;
result[1](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, expected 1&lt;/span&gt;
result[2](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2, expected 2&lt;/span&gt;
result[3](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3, expected 3&lt;/span&gt;
result[4](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4, expected 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;span&gt;对！这样就可以了：）&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，更聪明的方法是用let代替var，因为let是块作用域，所以在for循环中一个新的标识符绑定是在每次迭代时被创建的：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; [];
 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; 5; i++&lt;span&gt;) {
  result[i] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    console.log(i);
  };
}

result[&lt;/span&gt;0](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0, expected 0&lt;/span&gt;
result[1](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, expected 1&lt;/span&gt;
result[2](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2, expected 2&lt;/span&gt;
result[3](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3, expected 3&lt;/span&gt;
result[4](); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4, expected 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;例2：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这个例子里，我们将展示每次回调函数时是怎么创建一个新的、独立的闭包：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; iCantThinkOfAName(num, obj) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This array variable, along with the 2 parameters passed in, &lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; are 'captured' by the nested function 'doSomething'&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; array = [1, 2, 3&lt;span&gt;];
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; doSomething(i) {
    num &lt;/span&gt;+=&lt;span&gt; i;
    array.push(num);
    console.log(&lt;/span&gt;'num: ' +&lt;span&gt; num);
    console.log(&lt;/span&gt;'array: ' +&lt;span&gt; array);
    console.log(&lt;/span&gt;'obj.value: ' +&lt;span&gt; obj.value);
  }
  
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; doSomething;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; referenceObject = { value: 10&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foo = iCantThinkOfAName(2, referenceObject); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; closure #1&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; bar = iCantThinkOfAName(6, referenceObject); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; closure #2&lt;/span&gt;
&lt;span&gt;
foo(&lt;/span&gt;2&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  num: 4
  array: 1,2,3,4
  obj.value: 10
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

bar(&lt;/span&gt;2&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  num: 8
  array: 1,2,3,8
  obj.value: 10
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

referenceObject.value&lt;/span&gt;++&lt;span&gt;;

foo(&lt;/span&gt;4&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  num: 8
  array: 1,2,3,4,8
  obj.value: 11
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

bar(&lt;/span&gt;4&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  num: 12
  array: 1,2,3,8,12
  obj.value: 11
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;在这个例子里，我们可以看到每次调用&lt;strong&gt;iCantThinkOfAName&lt;/strong&gt;函数时都会创建一个新的闭包，也就是&lt;strong&gt;foo&lt;/strong&gt;和&lt;strong&gt;bar&lt;/strong&gt;。后续调用每个闭包函数都会更新闭包内的变量，这展示了&lt;strong&gt;iCantThinkOfAName&lt;/strong&gt;函数返回后，每个闭包里的变量继续被&lt;strong&gt;iCantThinkOfAName&lt;/strong&gt;函数里的&lt;strong&gt;doSomething&lt;/strong&gt;函数所使用。&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;例3：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mysteriousCalculator(a, b) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mysteriousVariable = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        add: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = a + b +&lt;span&gt; mysteriousVariable;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toFixedTwoPlaces(result);
        },
        
        subtract: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = a - b -&lt;span&gt; mysteriousVariable;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toFixedTwoPlaces(result);
        }
    }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; toFixedTwoPlaces(value) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value.toFixed(2&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; myCalculator = mysteriousCalculator(10.01, 2.01&lt;span&gt;);
myCalculator.add() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 15.02&lt;/span&gt;
myCalculator.subtract() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5.00&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;span&gt;&lt;br/&gt;我们能够看到的是&lt;strong&gt;mysteriousCalculator&lt;/strong&gt;是在全局作用域里，而且它返回了两个函数。抽象来看，上面例子中的环境就像是这样的：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
GlobalEnvironment =&lt;span&gt; {
  EnvironmentRecord: { 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; built-in identifiers&lt;/span&gt;
    Array: '&amp;lt;func&amp;gt;'&lt;span&gt;,
    Object: &lt;/span&gt;'&amp;lt;func&amp;gt;'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; etc...&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; custom identifiers&lt;/span&gt;
    mysteriousCalculator: '&amp;lt;func&amp;gt;'&lt;span&gt;,
    toFixedTwoPlaces: &lt;/span&gt;'&amp;lt;func&amp;gt;'&lt;span&gt;,
  },
  outer: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
};
 
mysteriousCalculatorEnvironment &lt;/span&gt;=&lt;span&gt; {
  EnvironmentRecord: {
    a: &lt;/span&gt;10.01&lt;span&gt;,
    b: &lt;/span&gt;2.01&lt;span&gt;,  
    mysteriousVariable: &lt;/span&gt;3&lt;span&gt;,
  }
  outer: GlobalEnvironment,
};

addEnvironment &lt;/span&gt;=&lt;span&gt; {
  EnvironmentRecord: {
    result: &lt;/span&gt;15.02&lt;span&gt;
  }
  outer: mysteriousCalculatorEnvironment,
};

subtractEnvironment &lt;/span&gt;=&lt;span&gt; {
  EnvironmentRecord: {
    result: &lt;/span&gt;5.00&lt;span&gt;
  }
  outer: mysteriousCalculatorEnvironment,
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;span&gt;因为我们的&lt;strong&gt;add&lt;/strong&gt;和&lt;strong&gt;subtract&lt;/strong&gt;函数都有一个指向&lt;strong&gt;mysteriousCalculator&lt;/strong&gt;函数环境的引用，它们可以使用那个环境里的变量来计算结果。&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;例4：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后这个例子演示了闭包最重要的一个功能：维护一个私有指向外部作用域变量的引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; secretPassword() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; password = 'xh38sk'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    guessPassword: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(guess) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (guess ===&lt;span&gt; password) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      }
    }
  }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; passwordGame =&lt;span&gt; secretPassword();
passwordGame.guessPassword(&lt;/span&gt;'heyisthisit?'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
passwordGame.guessPassword('xh38sk'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;span&gt;&lt;br/&gt;&lt;span&gt;这是一个很强大的技巧——它使得闭包函数&lt;strong&gt;guessPassword&lt;/strong&gt;可以独占访问&lt;strong&gt;password&lt;/strong&gt;变量，同时让&lt;strong&gt;password&lt;/strong&gt;变量不能从外部访问。&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;摘要&lt;/span&gt;&lt;/h2&gt;
&lt;div&gt;&lt;span&gt; &lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;执行上下文是ECMAScript规范用来根据运行时代码执行的一个抽象概念。在任何时候，在代码执行时都只有一个执行上下文。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;每个执行上下文都有一个词法环境，这个词法环境保留着标识符绑定（如变量及其相关的值），同时还有一个指向它外部环境的引用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个环境都可以访问的标识符集称为“作用域”。我们可以嵌套这些作用域到层次环境链中，这就是“作用域链”。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每个函数都有一个执行上下文，它由一个给予函数里的变量意义的词法环境，和指向父环境的引用组成，这看起来就像是函数“记住”这个环境（或者作用域），因为函数事实上有一个指向这个环境的引用，这就是闭包。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每次一个封闭外部函数被调用时就会创建一个闭包，换句话说，内部函数不需要返回要创建的闭包。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;JavaScript里的闭包作用域就是词法，这意味着它是在源代码里的位置静态定义的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;闭包用许多实际的用处，最重要的一个用处是维护一个私有指向外部环境变量的引用。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;结束语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我希望这篇文章能对你有所帮助，希望它能给你一种心智模式——在JavaScript里闭包是如何实现的。正如你所见，理解它们是如何工作的，可以让你更好地掌握闭包——更不用说当你调试Bug时为你省下了很多麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：人有失足——如果你发现有任何问题，我希望你能跟我说一声。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了简单起见，我避开了一些可能对有些读者感兴趣的主题，下面是一些我想分享给你们的链接：&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 06:22:00 +0000</pubDate>
<dc:creator>RichardLau</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Lau7/p/7942100.html</dc:identifier>
</item>
<item>
<title>离职篇 | 记一次史上最狗血的跳槽 - Jared.Nie</title>
<link>http://www.cnblogs.com/Romantic/p/7941973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Romantic/p/7941973.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/31975/201712/31975-20171201135736742-317721233.jpg&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 前几天朋友刚住上新房，于是周末找了点时间去给温居，好歹也算是在北京扎了根了，房子也买了户口也转出集体了。几个老朋友在一起在新家喝着小酒谈天说地好不快活，期间有个朋友说他换工作了，我们都惊讶的说，你之前的工作不是挺好的，烧个啥包，怎么样？double了？这时候朋友不慌不忙的说，double不double不重要，关键是这次换工作太狗血了，太爽了，太爽了，估计你们这辈子也不会遇到。他这一句“太爽了”把我们胃口吊的足足的。事情原来是这样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的朋友刘国平是个典型的Java开发人员，几乎可以说是个Java大牛，Java内存模型、并发多线程、底层垃圾回收机制、各种数据结构及算法都精通的很，另外像开源组件的源码tomcat、mycat、spring、kafka、zookeeper、nginx之流都读烂了，还给公司拿logback改造了一套日志组件，技术很棒人品也不错，在一家小公司慕芯科技（为了避嫌使用了化名）做项目开发，货真价实的架构师+技术骨干，2014年还曾经拿到过阿里的offer，当时说职级可以给评定到P7，懂阿里系职级的都明白P7是什么含义，不过后来因为工作地是在杭州，也由于女票的工作原因无法离京，所以就此作罢了。&lt;/p&gt;
&lt;p&gt;三个月前，他找到我另外一个老朋友说想跳槽，不想干了，让帮忙看看给介绍工作，毕竟大家都是IT圈子，工作久的IT人找工作基本上不用投简历靠圈子就够了。刘国平在慕芯做了两年多，这两年多从零开始完成了一个大项目，作为开发的架构师和核心技术骨干，虽然没有职务头衔，但由于技术过硬，也愿意分享技术，大家都把他当做技术经理看，自然开发压力很大，特别是项目上线前的几个月非常辛苦，已经不是什么业内的996了，几乎是7X24，每晚都要加班到12点以后，一周都有几天用睡袋在公司过夜，周末最多只有一天休息，一个项目组不足15个人就这样拼死拼活的往前赶，最紧的时候头上的头发一抓就是一把，作为三十多岁的人，每掉一根头发都很心疼，因为头发越来越少了。于是在最艰难的时候，老板给大家大气，“大家再坚持坚持，项目上线赚钱了，就给大家涨薪水，公司是绝对不会亏待大家的”，在老板豪言壮语的加薪鼓励下，大家要紧牙关拼上了。终于，就在半年前项目如期上线了，项目也由最初的拼命赶工到了修复bug、运维的阶段了，运行也慢慢稳定了，公司赚钱也多了起来。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;是的，公司赚钱了，利润很可观，当然这中间也有老板神秘的人脉关系吴司长，虽然跟随老板两年多，老板跟员工在一起的时候谈天说地无话不谈，但关于这位吴司长，从来不曾听老板提及，在我们眼里更是神秘，至今连人都没见，真的，一次都没见过。据说项目之所以能顺利开展多亏这位神秘的吴司长协助，这中间的利益链条关系，我们更是摸不清楚了。公司真的赚到钱了公司上上下下都知道，老板也是咧着嘴出咧着嘴进，可是一两个月过去了，加薪的事情完全没了影子，老板就像从来没提过一样。于是，刘国平向人事经理说出了希望加薪的要求，最后，得到的回复是：&lt;/p&gt;
&lt;p&gt;（1）刘国平目前的薪水与外面相比，基本是持平的&lt;/p&gt;
&lt;p&gt;（2）刘国平目前的工作比较悠闲，工作量不饱和&lt;/p&gt;
&lt;p&gt;（3）刘国平在进入公司两年多以来，没有特别突出的贡献&lt;/p&gt;
&lt;p&gt;虽然这话是出自人事之口，但是谁都知道这也是老板的意思。再者说，刘国平目前的薪水与外面相比是否持平，这东西没有定论，项目进入运维阶段的确是比苦逼赶进度的时候是悠闲了一些，不过这才是项目的正常状态而之前是拼命状态。是最后一条把刘国平逼上梁山的，作为一个IT人听到这句话基本上都能从头凉到脚后跟，这时候他心一横，心里冒出来两个字：“离职”。&lt;/p&gt;
&lt;p&gt;刘国平收到回复后虽然很是生气，但并没有马上提出离职，而是希望找机会能和老板谈一次，有一天他在和同事们一起吃饭时，就忍不住埋怨起公司来，后来，这话居然传到了老板的耳朵里，老板很有骨气：越是抱怨，越不给你涨薪水，看你怎么样。刘国平约过几次老板想谈谈薪资的事情，可是老板不是出差，就是有事忙不开，一直拖着，并且是故意拖着，终于，刘国平忍无可忍一封 farewell message 决定离职，而这个时候老板呢，也一如既往的有骨气：离职就离职，离开你公司就转不了了？我就不信拿钱招不到有水平的人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;说实话对于像刘国平这种技术大牛并不难找工作，尤其是在工作机会满地都是的北京，只是有些咽不下这口气，一来二去联系到了大学舍友仇祥民，仇祥民在另外一家睿信科技公司做技术经理，睿信科技公司也是一家名不见经传的的小企业，规模和慕芯差不都，业务领域虽然不同，但模式也差不多，他所在部门的架构师李际晓早在此前的半月递交了离职申请，仇祥民说：“国平，我部门的架构师走了，能不能帮我推荐个人，事成之后咱还能拿到2k的推荐费”，这时候刘国平心里暗喜，真是天意，于是刘国平满口答应一定会帮忙找到最合适的人选，事情如你所料的那样顺利，此时仇祥民并不知道刘国平已经离职，这天仇祥民和候选人如约进行了面试，HR匆忙的拿着材料找技术经理来面试，当仇祥民打开门一瞬间，俩人哈哈大笑，由于是多年舍友关系，知根知底，这面试就变得形式化了。就这样刘国平拿到offer，顺利的加入睿信科技公司，以刘国平个人水平加上仇祥民的协助涨薪40%。心里乐开了花，心想一定想办法让上家公司的老板，瞧瞧，此处不留爷自有留爷处。&lt;/p&gt;
&lt;p&gt;刘国平从慕芯离职后，慕芯的线上系统的维护升级就成为一个大问题了，毕竟那套系统的架子是刘国平一手搭的，虽然其他同事也能看懂，修个bug都没问题，但是涉及到优化和升级增加新模块的时候就有些力不从心了，这时老板命令人事经理赶快找人来顶上，苦逼的人事经理在QQ里群发了招聘的信息，这个信息也发给了刘国平。刘国平心想哎，虽然老板不厚道，但毕竟自己一手搭的系统，心里也是略微有一丝的伤感……老板当初怎么不想想我们那些日夜奋战的日子呢，哎……罢了罢了……&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;而此时的李际晓也已经面试了多家公司，手里几份offer，但是都没有自己特别中意的，不过好在已有几家保底的倒也不是那么仓促，希望多给自己一些选择。毕竟三十几岁的人换工作也不是那么随意，要考虑的事情还不少，求发展的同时还要图稳定，求收入的前提下还要自己干的爽。就在这时，刘国平把正在找工作的李际晓推荐过去了，而此时的慕芯业务相对稳定，公司的模式也得到了验证，再加上有那位吴司长的助推，公司顺风顺水，据说老板还在和一家融资机构谈一笔融资，由于两家公司的模式都差不多，对于李际晓也是轻车熟路，李际晓在慕芯工作一个月后就破格转正了，老板异常欢喜对于李际晓的表现也非常满意，相比之前在睿信薪水上涨了30%，和现在刘国平的薪水差不多，另外年后还要着手给业务骨干分配一些期权作为激励。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;这真是一个皆大欢喜的局面！&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（1）刘国平到睿信公司接手了李际晓原来的工作，薪水涨了40%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）李际晓到慕芯公司接手了刘国平原来的工作，薪水涨了30%，外加若干期权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）慕芯、睿信两家公司的老板都爽了，对新进来的员工的表现都非常满意&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）两家公司的人事经理也爽了，还号称是给公司注入了新鲜血液&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）刘国平和舍友仇祥民还拿到了2K推荐费，老板对他更加信任和喜欢了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）此外刘国平还和李际晓成为了好朋友，除了经常探讨技术外，还经常谈论这次搞笑的离职加薪过程，交流心得&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这是一个真实的不能再真实的故事，也是在这次温居的过程中听到当事人亲自口述的，在这个过程中所有人都得到了满足。这让我想起来一个经济学家与GDP的故事。&lt;/p&gt;

&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;有两个经济学研究生甲和乙，二人在路上走，发现一坨狗屎。甲对乙说：你把它吃了，我给你5000万。乙一听，这么容易就赚5000万，臭就臭点吧，大不了拿了钱去洗胃，于是就把屎吃了。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二人继续走，心里都有点不平衡，甲白白损失了5000万，什么也没捞着。乙虽说赚了5000万，但是吃了坨屎心里也堵得慌。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时又发现一坨屎，还热乎的，乙终于找到了平衡，对甲说：你把它吃了，我也给你5000万。甲一想损失的5000万能赚回来，吃坨屎算什么，乙不是也吃了吗？于是也把屎吃了。按理说这下二人该平衡了，但是他们越琢磨越觉得不对劲，两个人的资本一点也没有增加，反而一人吃了一坨屎。于是就去找教授，教授听了他们的诉说，激动得潸然泪下：同学们，你们应该高兴啊，你们仅仅吃了两坨屎，就为咱们国家贡献了1个亿的GDP啊！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目前公众号成立尚不足1个月，还是一颗小幼苗，请园友们多给些支持，关注个人公众号《程序员故事会》，后续会送上更优质精彩的程序员故事。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;再次致谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ID：coder-story &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;上一篇文章有人问能否投稿，有很多老猿小猿希望分享自己的故事，分享自己的心路历程的同时也许还能给各位猿们一些启迪，何乐而不为呢，目前已接受博客园 @枫，@程序员 的投稿，感谢各位！&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IN3rCM7gLSZa87GQJz3fGXMAnXWtkqIiaqptmMwgsTIU3NC5G5KXy19iamKdeGLRPzx2xWof7qO41rWmicSs7XcDQ/0?wx_fmt=jpeg&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-w=&quot;600&quot; data-backw=&quot;556&quot; data-backh=&quot;556&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 06:07:00 +0000</pubDate>
<dc:creator>Jared.Nie</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Romantic/p/7941973.html</dc:identifier>
</item>
<item>
<title>多线程编程学习笔记——任务并行库（二） - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/7941955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/7941955.html</guid>
<description>&lt;p&gt;&lt;span&gt;接上文 &lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/7891186.html&quot;&gt;&lt;span&gt;多线程编程学习笔记——任务并行库（一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三、   组合任务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;        本示例是学习如何设置相互依赖的任务。我们学习如何创建一个任务的子任务，这个子任务必须在父任务执行结束之后，再执行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1,示例代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks; 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ThreadTPLDemo
{

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task 组合操作 ————&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);     

           Task&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; task1 =CreateTask(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
           

            Task&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; task2 = CreateTask(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给task1创建一个延续操作(子操作)&lt;/span&gt;
            task1.ContinueWith(t =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1子操作：{0}，线程ID：{1}，是不是线程池中的线程：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;br/&gt;t.Result, Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread),TaskContinuationOptions.OnlyOnRanToCompletion);     


            task1.Start();
            task2.Start();
            &lt;/span&gt;&lt;span&gt;&lt;span&gt;Thread.Sleep(TimeSpan.FromSeconds(4));&lt;/span&gt; &lt;/span&gt;
&lt;span&gt;
            Task task3&lt;/span&gt;=task2.ContinueWith(t =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2子操作：{0}，线程ID：{1}，是不是线程池中的线程：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;br/&gt;t.Result, Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread), &lt;br/&gt;TaskContinuationOptions.OnlyOnRanToCompletion|&lt;span&gt;TaskContinuationOptions.ExecuteSynchronously); 

            task3.GetAwaiter().OnCompleted(() &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3异步操作完成，线程ID：{0}，是不是线程池中的线程：{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;br/&gt;Thread.CurrentThread.ManagedThreadId, Thread.CurrentThread.IsThreadPoolThread));

            Thread.Sleep(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------------父子任务--------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task5= &lt;span&gt;new&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(() =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task6 = Task.Factory.StartNew(() =&amp;gt; TaskOper(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;子任务Task6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;), TaskCreationOptions.AttachedToParent);
                task6.ContinueWith(t&lt;/span&gt;=&amp;gt;TaskOper(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;延时操作 task7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;),TaskContinuationOptions.AttachedToParent);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; TaskOper(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            });
            task5.Start();
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;task5.IsCompleted)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task5状态——{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task5.Status);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——task5状态—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task5.Status);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; task5.Result;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task5运行结果——{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
            Console.ReadKey();

        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TaskOper(&lt;span&gt;string&lt;/span&gt;  name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds)
        {           

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task 线程 ID：{0} 上，是不是线程池中的线程：{1}，名称： {2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            Thread.CurrentThread.ManagedThreadId,Thread.CurrentThread.IsThreadPoolThread, name);
            Thread.Sleep(TimeSpan.FromSeconds(seconds));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程ID：{0}，名称：{1}:秒：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId,name,seconds);

        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; CreateTask(&lt;span&gt;string&lt;/span&gt; name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(() =&amp;gt;&lt;span&gt; TaskOper(name,seconds));

        }
    }
}

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.程序运行结果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/10343/201712/10343-20171201134825367-1631996067.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       如结果所示，程序在启动时创建了两个任务task1与task2，并为第一个任务创建了一个子操作。启动这两个任务，然后等待4秒，然后给第task2运行子操作，并通过TaskContinuationOptions. OnlyOnRanToCompletion的选项尝试同步执行这个子操作。如果子操作的运行时间非常短，则以上方式非常有用，因为放在主线程中运行比放在线程池运行要快。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      如果我们注释掉那等待4秒的代码(蓝色字体)，task2这个操作就会被放到线程池中，如下图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/10343/201712/10343-20171201134931945-1175281362.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      接着，我们对task2任务的子操作定义了一个子操作task3，对task3使用新的GetAwaiter和Oncompleted方法，来执行一个后续操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       最后我们创建了一个新的任务task5，通过TaskContinuationOptions. AttachedToParent选项来运行一个子任务task6与后续操作task7。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四、   将APM模式转为任务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;          本示例，将上一篇(&lt;span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/7803384.html&quot;&gt;&lt;span&gt;多线程编程学习笔记——线程池（一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;)中的(&lt;span&gt;示例&lt;/span&gt;&lt;span&gt;一线程池中调用委托&lt;/span&gt;)转为任务。将APM转换为TPL的关键是Task&amp;lt;T&amp;gt;.Factory.FromAsync()方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 1.代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ThreadTPLDemo
{ 

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AsyncTaskRun(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; IncompAsyncTaskRun(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId);
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 将APM模式转为Task。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threadId = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            AsyncTaskRun tkDele &lt;/span&gt;=&lt;span&gt; RunTask;
            IncompAsyncTaskRun taskDele &lt;/span&gt;=&lt;span&gt; RunTask; 

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; --------1------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
          Task&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; task1=Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;.Factory.FromAsync(
             tkDele.BeginInvoke(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Callback, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task异步调用回调函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),tkDele.EndInvoke);
            task1.ContinueWith(t &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1回调函数执行结束，执行后续子操作：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Result)); 

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;task1.IsCompleted)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task1状态——{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task1.Status);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            }

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——task1状态—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task1.Status);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);           

            Console.WriteLine();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ---------------2-----------——&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; task2 = Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;.Factory.FromAsync(tkDele.BeginInvoke,tkDele.EndInvoke,

          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task异步调用回调函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            task2.ContinueWith(t &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2 回调函数执行结束，执行后续子操作：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Result)); 

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;task2.IsCompleted)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task2状态——{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task2.Status);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            }

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——task2状态—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task2.Status);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);          

            Console.WriteLine();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ---------------3-----------——&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IAsyncResult r &lt;/span&gt;= taskDele.BeginInvoke(&lt;span&gt;out&lt;/span&gt; threadId, Callback, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在线程池中异步调用回调函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; task3 = Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;.Factory.FromAsync(r,_=&amp;gt; taskDele.EndInvoke(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; threadId,r));
            task2.ContinueWith(t &lt;/span&gt;=&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3 回调函数执行结束，执行后续子操作：{0},线程ID：{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, t.Result,threadId));
 

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;task2.IsCompleted)
            {

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task3状态——{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task2.Status);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);
            }

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——task3状态—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task2.Status);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; --------------------------——&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);        

            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
            Console.Read(); 

        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Callback(IAsyncResult r)
        {

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始调用回调函数。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回调函数此时的状态 ：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, r.AsyncState);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用此回调函数的线程是否在线程池 ：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.IsThreadPoolThread);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用此回调函数的线程在线程池在的ID ：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RunTask(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始工作。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用此回调函数的线程是否在线程池 ：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.IsThreadPoolThread);
            Thread.Sleep(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            Thread.CurrentThread.Name &lt;/span&gt;=&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; threadId =&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;此线程的ID ：{0}，名称{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadId, Thread.CurrentThread.Name);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RunTask(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId)
        {

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始工作。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调用此回调函数的线程是否在线程池 ：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.IsThreadPoolThread);
            Thread.Sleep(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            threadId &lt;/span&gt;=&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;此线程在线程池在的ID ：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadId);

        }
    }
}

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt; 2.程序运行结果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/10343/201712/10343-20171201135450820-1698274037.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       程序运行结果中可以看出来，task1中直接传入了IAsyncResult和Func&amp;lt; IAsyncResult,string&amp;gt;，task1执行委托的异步调用，正常。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;        Task2与task1类似，只是使用了不同的FromAsync的方法重载，这个重载不允许指定一个将会在异步调用完成之后被调用的回调函数。我们在示例中使用后续操作代替了回调函数。如果必须使用回调函数，可以使用类似task1的调用方式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;        Task3我们通过一个技巧实现了调用与FromAsync不兼容的委托。我们通过将EndInvoke封装到一个lambda表达式中，从而适应FromAsync方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五、   将EAP模式转换为任务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;/span&gt;   本示例，将上一篇(&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/chillsrc/p/7864929.html&quot;&gt;&lt;span&gt;多线程编程学习笔记——线程池（三）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;)中的(使用BackgroundWorker组件示例)转为任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        本示例是学习如何基于事件的异步转换为TASK来运行。本示例的关键是使用TaskCompletionSource&amp;lt;T&amp;gt;,T是异步操作结果的类型。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks; 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ThreadPoolDemo

{  

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    { 

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 将EAP模式转为Task。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tcs = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; worker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BackgroundWorker();
            worker.DoWork &lt;/span&gt;+= (sender, eventArgs) =&amp;gt;&lt;span&gt;
            {
                eventArgs.Result &lt;/span&gt;= RunTask(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;后台线程 1 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
            };

            worker.RunWorkerCompleted &lt;/span&gt;+= (sender, eventArgs) =&amp;gt;&lt;span&gt;
             {
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (eventArgs.Error!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                 {
                     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——出错—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, eventArgs.Error);
                     tcs.SetException(eventArgs.Error);
                 }

                 &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;

                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (eventArgs.Cancelled)
                 {
                     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——取消—&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                     tcs.SetCanceled();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消&lt;/span&gt;
&lt;span&gt;                 }
                 &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                 {
                     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——设置结果值—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, eventArgs.Result);
                     tcs.SetResult((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)eventArgs.Result);
                 }          

             };

            worker.RunWorkerAsync();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result =&lt;span&gt; tcs.Task.Result;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ——任务Task运行结果—{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);         

            Console.Read();

        } 

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RunTask(&lt;span&gt;string&lt;/span&gt; name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seconds)
        {

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Task {0}  运行在线程={1}中，是否在线程池 ：{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name, Thread.CurrentThread.ManagedThreadId,&lt;br/&gt;Thread.CurrentThread.IsThreadPoolThread);
            Thread.Sleep(TimeSpan.FromSeconds(seconds));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;42&lt;/span&gt; *&lt;span&gt; seconds;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.程序运行结果如下图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/10343/201712/10343-20171201135540836-2075924110.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      注：tcs.SetResult要封闭在try-catch中，以方便获取异常。或者可以使用tcs.TrySetResult。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 05:59:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/7941955.html</dc:identifier>
</item>
<item>
<title>ABAP 7.52 中的Open SQL新特性 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/7941300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/7941300.html</guid>
<description>&lt;p&gt;S/4 HANA 1709 已经在几个月前发布，随之而来的是ABAP 7.52。&lt;/p&gt;
&lt;p&gt;本文翻译了更新文档中有关Open SQL的部分。&lt;/p&gt;
&lt;p&gt;如果读者是Open SQL的新手，请不要从本文看起。更合适的教程是：&lt;a href=&quot;https://blogs.sap.com/2014/05/21/a-complete-guide-to-opensql-statements-step-by-step-tutorial-with-screenshots/&quot; target=&quot;_blank&quot;&gt;A complete guide to OpenSQL statements – Step-by-step tutorial with screenshots&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a href=&quot;http://www.cnblogs.com/hhelibeb/p/7941300.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hhelibeb/p/7941300.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1，内表作为数据源&lt;/h2&gt;
&lt;p&gt;现在可以将内表指定为查询语句的&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_data_source.htm&quot; target=&quot;_blank&quot;&gt;数据源&lt;/a&gt;。如果内表数据需要传递给数据库的话，则只能在部分数据库上运行。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DATA&lt;/span&gt; itab &lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;HASHED&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;OF&lt;/span&gt;&lt;span&gt; scarr
          &lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt;&lt;span&gt;&lt;span&gt; UNIQUE KEY&lt;/span&gt; mandt carrid.

&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; cl_abap_dbfeatures=&amp;gt;&lt;span&gt;use_features(
         &lt;/span&gt;&lt;span&gt;EXPORTING&lt;/span&gt;&lt;span&gt;
           requested_features &lt;/span&gt;=&lt;span&gt;&lt;span&gt;
             VALUE&lt;/span&gt; #( ( cl_abap_dbfeatures&lt;/span&gt;=&amp;gt;&lt;span&gt;itabs_in_from_clause ) ) ).
  cl_demo_output&lt;/span&gt;=&amp;gt;&lt;span&gt;display(
    `&lt;span&gt;System does &lt;/span&gt;&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt;&lt;span&gt; support internal tables as data source&lt;/span&gt;` ).
  &lt;span&gt;RETURN&lt;/span&gt;.
&lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

itab &lt;/span&gt;=  &lt;span&gt;VALUE&lt;/span&gt; #( ( carrid = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;LH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; carrname = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;L.H.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; )
                 ( carrid &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; carrname = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;U.A.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) ).

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; scarr~carrid, scarr~carrname, spfli~connid
       &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; @itab &lt;span&gt;AS&lt;/span&gt; scarr
         &lt;span&gt;INNER JOIN&lt;/span&gt; spfli &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; scarr~carrid =&lt;span&gt; spfli~carrid
       &lt;/span&gt;&lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; @&lt;span&gt;DATA&lt;/span&gt;&lt;span&gt;(result)
       ##db_feature_mode[itabs_in_from_clause].

cl_demo_output&lt;/span&gt;=&amp;gt;display( result ).
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2，关系表达式&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://help.sap.com/http.svc/rc/abapdocu_752_index_htm/7.52/en-US/abenosql_expr_logexp.htm&quot; target=&quot;_blank&quot;&gt;条件表达式&lt;/a&gt;现支持以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以对字符类数据类型大小比较，并且不再限制N类型。&lt;/li&gt;
&lt;li&gt;操作符BETWEEN不再限制N类型，SQL表达式现在可以在右侧使用了。&lt;/li&gt;
&lt;li&gt;现在也支持LIKE操作符。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;3，转换函数&lt;/h2&gt;
&lt;p&gt;新的类型转换函数&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/http.svc/rc/abapdocu_752_index_htm/7.52/en-US/abensql_type_conv_func.htm&quot; target=&quot;_blank&quot;&gt;BINTOHEX&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/http.svc/rc/abapdocu_752_index_htm/7.52/en-US/abensql_type_conv_func.htm&quot; target=&quot;_blank&quot;&gt;HEXTOBIN&lt;/a&gt;&lt;/strong&gt;现在可以在SQL表达式中把byte strings转换为character strings，这种功能在CAST表达式中是不可行的。&lt;/p&gt;
&lt;p&gt;示例程序，可以看到两种转换方式的结果是一样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SINGLE&lt;/span&gt;&lt;span&gt; id &lt;span&gt;AS&lt;/span&gt; uuid32, hextobin( id ) &lt;strong&gt;AS&lt;/strong&gt; uuid16
       &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; iwreferenc
       &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; tcode = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SE38&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
       &lt;span&gt;INTO&lt;/span&gt; @&lt;span&gt;DATA&lt;/span&gt;&lt;span&gt;(wa).

&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; sy-subrc = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.
  &lt;/span&gt;&lt;span&gt;DATA&lt;/span&gt; uuid16 &lt;span&gt;LIKE&lt;/span&gt; wa-&lt;span&gt;uuid16.
  cl_system_uuid&lt;/span&gt;=&amp;gt;&lt;span&gt;convert_uuid_c32_static(
    &lt;/span&gt;&lt;span&gt;EXPORTING&lt;/span&gt;&lt;span&gt;
      uuid          &lt;/span&gt;=     wa-&lt;span&gt;uuid32
    &lt;/span&gt;&lt;span&gt;IMPORTING&lt;/span&gt;&lt;span&gt;
      uuid_x16      &lt;/span&gt;=&lt;span&gt;     uuid16 ).
  &lt;span&gt;ASSERT&lt;/span&gt; wa&lt;/span&gt;-uuid16 =&lt;span&gt; uuid16.
&lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4，路径表达式&lt;/h2&gt;
&lt;p&gt;以下特性现在在&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abenopen_sql_path.htm&quot; target=&quot;_blank&quot;&gt;路径表达式&lt;/a&gt;（path expression）中可用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在传参的空白部分、属性方括号的空白部分和斜杠\前的位置，路径表达式可以分割为多个代码行。&lt;/li&gt;
&lt;li&gt;目标数据也是CDS表函数（table function）的时候，也可以使用Association了。&lt;/li&gt;
&lt;li&gt;参数可以在路径表达式association的后面传递。由此可以指定带有参数的CDS entities作为association的数据源。&lt;/li&gt;
&lt;li&gt;在路径表达式中，现在可以指定join表达式的cardinality和类型作为属性。&lt;/li&gt;
&lt;li&gt;association的过滤条件现在可以在路径表达式中指定。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;5，访问控制&lt;/h2&gt;
&lt;p&gt;新的关键字&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_data_source.htm&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;WITH PRIVILEGED ACCESS&lt;/strong&gt;&lt;/a&gt;可以关闭&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abencds_access_control_glosry.htm&quot; target=&quot;_blank&quot;&gt;CDS的访问控制&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;6，子查询中的ORDER BY和UP TO, OFFSET&lt;/h2&gt;
&lt;p&gt;在子查询中，现在可以使用ORDER BY子句和附加项UP TO, OFFSET了。不过，不是所有数据库都支持在子查询中运行ORDER BY。&lt;/p&gt;
&lt;p&gt;注意：在子查询中，UP TO只能用在ORDER BY子句后面，附加项OFFSET也只能在UP TO后面指定。&lt;/p&gt;
&lt;h2&gt;7，LFET OUT JOIN中的Cardinality&lt;/h2&gt;
&lt;p&gt;在LFET OUTER JOIN中，可以用附加项ONE TO MANY指定Cardinality。它可以被SAP HANA识别为一种优化说明。&lt;/p&gt;
&lt;h2&gt;8，SELECT列表中的FOR ALL ENTRIES IN和字符串&lt;/h2&gt;
&lt;p&gt;在先前的&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abenopensql_strict_modes.htm&quot; target=&quot;_blank&quot;&gt;严格模式语法检查&lt;/a&gt;中，SELECT语句的附加项FOR ALL ENTRIES IN不能和SELECT列表中类型为STRING和RAWSTRING或者LCHR和LRAW的列一起出现。现在这个限制已经被移除，语法检查只会对此提示一个警告，而不是错误。&lt;/p&gt;
&lt;h2&gt;9，严格模式的语法检查&lt;/h2&gt;
&lt;p&gt;如果你用到了上面列出的Open SQL中的任一新特性，语法检查会以严格模式运行。&lt;/p&gt;
&lt;h2&gt;10，Client处理&lt;/h2&gt;
&lt;p&gt;在切换Client读取CDS entities时，附加项&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_client.htm&quot; target=&quot;_blank&quot;&gt;USING CLIENT&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_client.htm&quot; target=&quot;_blank&quot;&gt;CLIENT SPECIFIED&lt;/a&gt;&lt;/strong&gt;会应用以下（更严格的）规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CDS访问控制不会在跨Client访问时工作。因此，附加项&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_client.htm&quot; target=&quot;_blank&quot;&gt;USING CLIENT&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_client.htm&quot; target=&quot;_blank&quot;&gt;CLIENT SPECIFIED&lt;/a&gt;&lt;/strong&gt;只能在CDS entities的访问控制被关闭的时候使用，即注解为&lt;span class=&quot;qtext400&quot;&gt;&lt;strong&gt;AccessControl.authorizationCheck.#NOT_ALLOWED&lt;/strong&gt;，或者查询语句中使用了上文5中的&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_data_source.htm&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;WITH PRIVILEGED ACCESS&lt;/strong&gt;&lt;/a&gt;时。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;路径表达式只能在自动Client处理打开的时候使用。不可以使用&lt;strong&gt;&lt;a href=&quot;https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapselect_client.htm&quot; target=&quot;_blank&quot;&gt;CLIENT SPECIFIED&lt;/a&gt;&lt;/strong&gt;，以防路径表达式中的association中的FROM子句中的目标数据是指定Client（Client-specific）的数据源（？），association的源数据源也不可以是指定客户端的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;11，Open SQL中的代理服务&lt;/h2&gt;
&lt;p&gt;类&lt;a href=&quot;https://help.sap.com/http.svc/rc/abapdocu_752_index_htm/7.52/en-US/abencl_osql_replace.htm&quot; target=&quot;_blank&quot;&gt;CL_OSQL_REPLACE&lt;/a&gt;可以在ABAP Unit单元测试中将数据库访问重定向至访问其它数据库的Open SQL。&lt;/p&gt;
&lt;p&gt;该类只能在测试类中使用。&lt;/p&gt;
&lt;p&gt;示例程序：DEMO_CL_OSQL_REPLACE&lt;/p&gt;

</description>
<pubDate>Fri, 01 Dec 2017 05:51:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/7941300.html</dc:identifier>
</item>
<item>
<title>【阿里聚安全·安全周刊】阿里双11技术十二讲直播预约|AWS S3配置错误曝光NSA陆军机密文件 - 阿里聚安全</title>
<link>http://www.cnblogs.com/alisecurity/p/7941911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/alisecurity/p/7941911.html</guid>
<description>&lt;p&gt;&lt;strong&gt;关键词：&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;阿里双11技术十二讲直播&lt;/strong&gt;丨&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;雪人计划&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;丨&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;亚马逊AWS S3配置错误&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;丨&lt;/strong&gt;&lt;strong&gt;2018威胁预测&lt;/strong&gt;&lt;strong&gt;丨&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;MacOS漏洞&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;丨&lt;/strong&gt;&lt;strong&gt;智能风控平台MTEE3&lt;/strong&gt;&lt;strong&gt;丨&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;黑客窃取《权利的游戏》剧本&lt;/strong&gt;&lt;/strong&gt;|&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Android 8.1&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;本周资讯top3&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【技&lt;/strong&gt;&lt;strong&gt;术直播】&lt;/strong&gt;&lt;strong&gt;承担双11万亿流量，阿里核心技术揭秘：12位大咖告诉你！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;12月13日-14日，云栖社区联合阿里巴巴技术协会，共同举办《2017阿里双11技术十二讲》在线直播峰会，独家分享双11背后技术最佳实践，欢迎预约直播！&lt;/p&gt;
&lt;p&gt;分享主题有：《阿里下一代技术架构：云化架构演进之路》、《2017双11供应链的那些事儿》、《分布式存储系统盘古在双11中的战役》、《双11中的智能化网络实践》······&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469kda23r240.jpg&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.2.4551b12c9bUytq&amp;amp;articleid=1245&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1245&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【雪人计划】“雪人计划”在全球架设IPv6根服务器 中国部署４台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;11月27日悉，由下一代互联网国家工程中心牵头发起的“雪人计划”已在全球完成25台IPv6（互联网协议第六版）根服务器架设，中国部署了其中的4台，打破了中国过去没有根服务器的困境，事实上形成了13台原有根加25台IPv6根的新格局，为建立多边、民主、透明的国际互联网治理体系打下坚实基础。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469kfrcu5910.jpg&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.8.4551b12c9bUytq&amp;amp;articleid=1237&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1237&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【数据泄露】美政府再因亚马逊AWS S3配置错误：超100GB NSA陆军机密文件曝光&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;11月28日消息，继数周前美国陆军中央司令部（CENTCOM）与太平洋司令部（PACOM）的敏感数据暴露于不安全亚马逊AWS S3服务器后，网络安全公司UpGuard研究人员Chris Vickery近期再次发现托管在AWS S3服务器的47份美国陆军情报与安全司令部（INSCOM）机密文件（逾 100GB）在线曝光，其中竟有3份重要文件可任意下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469kgojurk80.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.3.4551b12c9bUytq&amp;amp;articleid=1243&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1243&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;资讯篇&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【威胁预测】&lt;/strong&gt;&lt;strong&gt; 卡巴斯基发布安全公告：2018年威胁预测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为高度关注安全动态的人而言，需要时刻关注安全事件，每一件全球性的安全事件都是一场无法弥补的灾难。威胁预测并不是简单的“玩票”行为，而是试图通过展示未来一年安全趋势的形式进一步带动全年的研究，同时也为相关机构发出安全警告，领先威胁一步做好安全防范，最大限度降低威胁带来的损失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469kj9t6pn40.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.5.4551b12c9bUytq&amp;amp;articleid=1241&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1241&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【MacOS漏洞】&lt;/strong&gt;&lt;strong&gt;别玩了，苹果已经修复MacOS漏洞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;据国外媒体报道，苹果MacOS High Sierra系统被曝出现多年来最大的安全漏洞，允许未授权用户无需密码就能获得系统管理权限。此外，还有可能被黑客远程安装恶意软件或控制操作系统。但苹果已发布 MacOS紧急安全补丁Security Update 2017-001修复了这一严重的安全漏洞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469kmus0a2g0.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.4.4551b12c9bUytq&amp;amp;articleid=1242&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1242&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【业务安全】&lt;/strong&gt;&lt;strong&gt; “刺激的”2017双11 ——阿里安全工程师首度揭秘智能风控平台MTEE3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MTEE3的中文名称叫业务安全智能风控平台，最后面的3代表这是全新一代的3.0系统。这套系统的功用是为阿里经济体的各类核心业务提供账号安全、黄牛刷单、活动反作弊、内容安全、人机识别等几十种风险的防护与保障。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469l5du2fca0.jpeg&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;655&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.6.4551b12c9bUytq&amp;amp;articleid=1240&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1240&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【数据泄露】&lt;/strong&gt;&lt;strong&gt;FBI指控伊朗黑客窃取《权利的游戏》剧本，泄露HBO敏感数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;美国联邦调查局和美国司法部对黑客Behzad Mesri正式提出了官方指控。Behzad Mesri是一名伊朗黑客，据说此前入侵HBO并泄露美剧《权力的游戏》剧本的就是他。除此之外，他还曾尝试向HBO电视台勒索赎金，并泄露了大量HBO未播出电视剧的剧本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469l64dqcif0.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.11.259133f9vA4X7U&amp;amp;articleid=1235&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1235&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;技术篇&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【下载】Android 8.1最终预览版发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Google公布了Android 8.1 Oreo的第二个开发者预览版，已经放出了Nexus 5X/6P/Pixel C/Pixel/Pixel XL/Pixel 2/Pixel 2 XL的设备镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://epo.alicdn.com/image/469l6vf9a9t0.jpg&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;368&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.2.63a689fe9aWmyC&amp;amp;articleid=1238&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1238&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【技术分享】黑客技能：快速提取Windows密码和Wi-Fi密钥凭证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过LaZagne实现自动化提取Windows密码和Wi-Fi密钥凭证，LaZagne比较适合黑客和安全管理员，可以在Linux，Windows和MacOS上运行，而且几乎适用于每一个目标。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.1.36e4b1f8HaOTtH&amp;amp;articleid=1244&quot; target=&quot;_blank&quot;&gt;https://jaq.alibaba.com/community/art/show?&amp;amp;articleid=1244&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-------------------------------------------------------&lt;/p&gt;
&lt;p&gt;以上是本周的安全周刊，想了解更多内容，请访问&lt;a href=&quot;http://jaq.alibaba.com/community/index.htm&quot; target=&quot;_blank&quot;&gt;阿里聚安全官方博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Dec 2017 05:51:00 +0000</pubDate>
<dc:creator>阿里聚安全</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/alisecurity/p/7941911.html</dc:identifier>
</item>
</channel>
</rss>