<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【SSH框架】之Spring系列（一） - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8457785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8457785.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;微信公众号：compassblog&lt;/p&gt;
&lt;p&gt;欢迎关注、转发，互相学习，共同进步！&lt;/p&gt;
&lt;p&gt;有任何问题，请后台留言联系！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1、前言&lt;/h3&gt;
&lt;p&gt;前面更新过几篇关于 Struts2 框架和 Hibernate 框架的文章，但鉴于这两种框架在今天的主流开发中已经很少用了，所以关于这两种框架的更新权当兴趣，有时间也还会更新的。现在主流开发中代替这两个框架的是 SpringMVC 和 MyBatis 等等，接下来主要精力集中于 Spring、SpringMVC、Spring Boot 等等，特别是 Spring Boot 框架，当然肯定也会有其他方面的内容，知无不写，写无不尽。&lt;/p&gt;
&lt;h3&gt;2、Spring 框架概述&lt;/h3&gt;
&lt;p&gt;（1）、Spring 框架在三层架构中的位置&lt;/p&gt;
&lt;p&gt;Spring 框架在三层架构中的位置在【&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;【SSH框架】之Hibernate系列（一）&lt;/a&gt;】这篇文章中已经提到过，主要描述与下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxvRd8ricTDcbRfexcPJJ0o5koNSPJmssnFTGSYVUGm9eib5smcugmbJvcm2NOGPSS4CQQia9uNmI0dhg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5015015015015015&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、Spring 是什么&lt;/p&gt;
&lt;p&gt;Spring 是一个轻量级的 Java 开源框架，兴起于2003年，它分层架构的特点为 J2EE 应用程序开发提供集成的框架。Spring 的核心是控制反转（IOC）和面向切面（AOP），是一个一站式的框架。&lt;/p&gt;
&lt;p&gt;（3）、Spring 框架的优势与功能（一站式）&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring 相当于一个容器，可以将所有对象创建和依赖关系维护，交给 Spring 管理 &lt;br/&gt;AOP 编程的支持，容器中装什么对象就有什么功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能声明式事务的支持只需要通过配置就可以完成对事务的管理，而无需手动编程，使得程序的测试更为方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring 不仅不排斥各种优秀的开源框架，如：Struts、Hibernate、MyBatis等，还能帮其他框架管理对象，降低 JavaEE API 的使用难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring 对 JavaEE 中的 API 如 JDBC、JavaMail等提供了封装，使这些 API 应用难度大大降低。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Spring 支持 JUnit 测试支持，可以通过注解方便的测试 Spring 程序方便集成各种优秀框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3、搭建 Spring 开发环境并完成第一个测试实例&lt;/h3&gt;
&lt;p&gt;（1）、新建一个 web 项目，导入 Spring 所需要的基本包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxvRd8ricTDcbRfexcPJJ0o5ksibx7mQiaRqJNMtcbTPUpWK1kHAfQOHuRPzaZjA7VAX6XCEqPJwo5CnQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.7351694915254238&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、创建一个 Bean 对象，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;package com.spring.bean;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Student {&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、在 src 下新建配置文件 applicationContext.xml，将注册对象写入容器，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;applicationContext.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;beans &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd &quot;&amp;gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;beans&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、书写测试类 TestDemo.java，代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;5&quot;&gt;package com.spring.test;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.junit.Test;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.context.ApplicationContext;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.context.support.ClassPathXmlApplicationContext;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com.spring.bean.Student;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;TestDemo {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;test&lt;span class=&quot;hljs-params&quot;&gt;(){&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、使用 JUnit4 进行测试，结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxvRd8ricTDcbRfexcPJJ0o5kOxSLe6efUkSsuvz6odTo19Fiar8wUrAKoE6DYjsHSSzKA0Khq8auwyQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.2641509433962264&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxvRd8ricTDcbRfexcPJJ0o5kHVCCWblYIsxx1f0WK2evBVZC26fxcJL8XvjfDAqoBmibb1FEH8le10w/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.2824561403508772&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本项目运行环境：&lt;/strong&gt;jdk1.7&lt;/p&gt;
&lt;h3&gt;4、Spring 配置详解&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&amp;lt;!-- Bean元素:使用该元素描述需要spring容器管理的对象&lt;br/&gt;class属性:被管理对象的完整类名.&lt;br/&gt;name属性:给被管理的对象起个名字.获得对象时根据该名称获得对象.  &lt;br/&gt;可以重复.可以使用特殊字符.&lt;br/&gt;id属性: 与name属性一模一样. &lt;br/&gt;名称不可重复.不能使用特殊字符.&lt;br/&gt;结论: 尽量使用name属性.&lt;br/&gt;--&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean  &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;stu&quot; &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.spring.bean.Student&quot; &amp;gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;bean&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;5、Spring 框架的思想&lt;/h3&gt;
&lt;p&gt;（1）、IOC：Inverse Of Control，即控制反转，将对象创建的方式交给了 Spring 容器；&lt;/p&gt;
&lt;p&gt;（2）、DI：Dependency Injection，即依赖注入，IOC 的实现需要 DI 支持。&lt;/p&gt;
&lt;h3&gt;6、Spring 属性注入&lt;/h3&gt;
&lt;p&gt;（1）、set方法注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean  &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;stu&quot; &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.spring.bean.Student&quot; &amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、构造函数注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;stu1&quot; &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.spring.bean.Student&quot; &amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注微信公众号compassblog，后台回复 “Spring系列一” 获取本项目源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;您可能还喜欢：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系列后期仍会持续更新，欢迎关注！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章有用，欢迎转发分享给你的好友！&lt;/p&gt;

&lt;p&gt;本号文章可以任意转载，转载请注明出处！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;扫码关注微信公众号，了解更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3R4VBiavfDxuP6hBA0uiayPYfoqQ9fvsibmVarqGdicZMqAGFhJalcWg78yg9aJicVFibDqjlPx679hdNQlzPBZA0rfA/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 21 Feb 2018 15:31:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8457785.html</dc:identifier>
</item>
<item>
<title>nginx + tomcat实现负载均衡 - 代码风云</title>
<link>http://www.cnblogs.com/cjh-notes/p/8457727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjh-notes/p/8457727.html</guid>
<description>&lt;p&gt;&lt;span&gt;作者Mr.Chen，转载请注明博客出处：&lt;a href=&quot;http://www.cnblogs.com/cjh-notes/&quot;&gt;http://www.cnblogs.com/cjh-notes/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;负载均衡就是流量分发，优选软件解决方案，成本低效果好。&lt;/p&gt;

&lt;h2&gt;第一步：下载安装nginx和tomcat&lt;/h2&gt;
&lt;p&gt;安装方法可以看这里&lt;a href=&quot;http://www.cnblogs.com/cjh-notes/p/7868262.html&quot;&gt;http://www.cnblogs.com/cjh-notes/p/7868262.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ps：如果是纯测试可以下载两个不同版本的tomcat方便查看效果&lt;/p&gt;

&lt;h2&gt;第二步：配置tomcat&lt;/h2&gt;
&lt;p&gt;复制一个节点，修改配置文件，要修改的地方有三处，vi全局替换即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
%s/&lt;span&gt;8005&lt;/span&gt;/&lt;span&gt;8006&lt;/span&gt;/&lt;span&gt;g

&lt;/span&gt;%s/&lt;span&gt;8080&lt;/span&gt;/&lt;span&gt;8081&lt;/span&gt;/&lt;span&gt;g

&lt;/span&gt;%s/&lt;span&gt;8009&lt;/span&gt;/&lt;span&gt;8010&lt;/span&gt;/g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接着启动节点服务器，访问正常：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1283057/201802/1283057-20180221231428115-164727867.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1283057/201802/1283057-20180221231505200-1032145071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;第三步：配置nginx&lt;/h2&gt;
&lt;p&gt;配置很简单，在http模块中添加upstream并修改代理转发，附上配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
upstream backserver {

    server 127.0.0.1:8080;

    server 127.0.0.1:8081;

}

 

server {

    listen 80;

    server_name 39.108.182.210;

    root /usr/share/nginx/html;



    location / {

        proxy_pass http://backserver;

    }
 

}    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若有兴趣做进一步了解首选官方文档：&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html%23example&quot;&gt;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#example&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;最后一步：测试&lt;/h2&gt;
&lt;p&gt;直接输入ip或域名访问（不带端口），每刷新一次，发现页面在tomcat7和tomcat8的首页间切换，测试通过～&lt;/p&gt;


&lt;h2&gt;nginx负载均衡有几种常用方式：&lt;/h2&gt;
&lt;h3&gt;1、轮询&lt;/h3&gt;
&lt;p&gt;按时间顺序逐一分配，这是默认的方式，&lt;span&gt;上面的测试结果呈现了该方式的效果&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、weight&lt;/h3&gt;
&lt;p&gt;指定被访问的几率，用于节点服务器性能不均的情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
upstream backserver {

    server 192.168.0.1 weight=2;

    server 192.168.0.2 weight=8;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3、fair（第三方模块）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;智能的轮询，按响应时间来分配，完全可以替代以上两种模式&lt;/p&gt;
&lt;p&gt;还没用过，日后再更新～&lt;/p&gt;
&lt;h3&gt;4、&lt;span&gt;iphash&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;请求按ip的hash结果分配，访客每次访问的都是同一个节点，解决session同步最快最简单的方法，当然缺点也很明显&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
upstream backserver {

    ip_hash;

    server 192.168.0.1;

    server 192.168.0.2;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 21 Feb 2018 15:12:00 +0000</pubDate>
<dc:creator>代码风云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjh-notes/p/8457727.html</dc:identifier>
</item>
<item>
<title>撸一撸Spring Cloud Ribbon的原理 - 白色的海</title>
<link>http://www.cnblogs.com/kongxianghai/p/8445030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kongxianghai/p/8445030.html</guid>
<description>&lt;p&gt;说起负载均衡一般都会想到服务端的负载均衡，常用产品包括LBS硬件或云服务、Nginx等，都是耳熟能详的产品。&lt;/p&gt;
&lt;p&gt;而Spring Cloud提供了让服务调用端具备负载均衡能力的Ribbon，通过和Eureka的紧密结合，不用在服务集群内再架设负载均衡服务，很大程度简化了服务集群内的架构。&lt;/p&gt;
&lt;p&gt;具体也不想多写虚的介绍，反正哪里都能看得到相关的介绍。&lt;/p&gt;
&lt;p&gt;直接开撸代码，通过代码来看Ribbon是如何实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/166781/201802/166781-20180214012425859-1316261402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详解：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.RibbonAutoConfiguration配置生成RibbonLoadBalancerClient实例。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码位置：&lt;/p&gt;
&lt;p&gt;spring-cloud-netflix-core-1.3.5.RELEASE.jar&lt;br/&gt;org.springframework.cloud.netflix.ribbon&lt;br/&gt;RibbonAutoConfiguration.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass({ IClient.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, RestTemplate.&lt;span&gt;class&lt;/span&gt;, AsyncRestTemplate.&lt;span&gt;class&lt;/span&gt;, Ribbon.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@RibbonClients
@AutoConfigureAfter(name &lt;/span&gt;= &quot;org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration&quot;&lt;span&gt;)
&lt;span&gt;@AutoConfigureBefore({LoadBalancerAutoConfiguration.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, AsyncLoadBalancerAutoConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
@EnableConfigurationProperties(RibbonEagerLoadProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonAutoConfiguration {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;
    @Bean
    @ConditionalOnMissingBean(LoadBalancerClient.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt; LoadBalancerClient&lt;/span&gt; loadBalancerClient() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; RibbonLoadBalancerClient&lt;/span&gt;(springClientFactory());
    }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看配置条件项，RibbonAutoConfiguration配置必须在LoadBalancerAutoConfiguration配置前执行，因为在LoadBalancerAutoConfiguration配置中会使用RibbonLoadBalancerClient实例。&lt;/p&gt;
&lt;p&gt;RibbonLoadBalancerClient继承自LoadBalancerClient接口，是负载均衡客户端，也是负载均衡策略的调用方。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.LoadBalancerInterceptorConfig配置生成：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;1).负载均衡拦截器LoadBalancerInterceptor实例&lt;br/&gt;包含：&lt;br/&gt;  LoadBalancerClient实现类的RibbonLoadBalancerClient实例&lt;br/&gt;  负载均衡的请求创建工厂LoadBalancerRequestFactory:实例&lt;br/&gt;2).RestTemplate自定义的RestTemplateCustomizer实例&lt;/p&gt;
&lt;p&gt;代码位置：&lt;/p&gt;
&lt;p&gt;spring-cloud-commons-1.2.4.RELEASE.jar&lt;br/&gt;org.springframework.cloud.client.loadbalancer&lt;br/&gt;LoadBalancerAutoConfiguration.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;span&gt;@ConditionalOnClass(RestTemplate.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;@ConditionalOnBean(LoadBalancerClient.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
@EnableConfigurationProperties(LoadBalancerRetryProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerAutoConfiguration {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  略&lt;/span&gt;
&lt;span&gt;
    @Bean
    @ConditionalOnMissingBean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory loadBalancerRequestFactory(
            LoadBalancerClient loadBalancerClient) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory(loadBalancerClient, transformers);
    }

    @Configuration
    @ConditionalOnMissingClass(&lt;/span&gt;&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptorConfig {
        @Bean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt; LoadBalancerInterceptor&lt;/span&gt; ribbonInterceptor(
                &lt;span&gt;LoadBalancerClient loadBalancerClient&lt;/span&gt;,
                &lt;span&gt;LoadBalancerRequestFactory requestFactory&lt;/span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; LoadBalancerInterceptor(loadBalancerClient, requestFactory)&lt;/span&gt;;
        }

        @Bean
        @ConditionalOnMissingBean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt; RestTemplateCustomizer&lt;/span&gt; restTemplateCustomizer(
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor loadBalancerInterceptor) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; RestTemplateCustomizer()&lt;/span&gt; {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; customize(RestTemplate restTemplate) {
                    List&lt;/span&gt;&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(
                            restTemplate.getInterceptors());
                    list.add(loadBalancerInterceptor);
                    restTemplate.setInterceptors(list);
                }
            };
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  略&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看配置条件项：&lt;/p&gt;
&lt;p&gt;要求在项目环境中必须要有RestTemplate类。&lt;/p&gt;
&lt;p&gt;要求必须要有LoadBalancerClient接口的实现类的实例，也就是上一步生成的RibbonLoadBalancerClient。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.通过上面一步创建的RestTemplateCustomizer配置所有RestTemplate实例，就是将负载均衡拦截器设置给RestTemplate实例。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
@ConditionalOnClass(RestTemplate.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ConditionalOnBean(LoadBalancerClient.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@EnableConfigurationProperties(LoadBalancerRetryProperties.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerAutoConfiguration {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton loadBalancedRestTemplateInitializer(
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;RestTemplateCustomizer&amp;gt;&lt;span&gt; customizers) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SmartInitializingSingleton() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterSingletonsInstantiated() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (RestTemplate restTemplate : LoadBalancerAutoConfiguration.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.restTemplates) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;&lt;span&gt; (RestTemplateCustomizer customizer : customizers) {
                        &lt;span&gt;customizer.customize(restTemplate);&lt;/span&gt;
                    }&lt;/span&gt;
                }
            }
        };
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;
    @Configuration
    @ConditionalOnMissingClass(&lt;/span&gt;&quot;org.springframework.retry.support.RetryTemplate&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptorConfig {
        @Bean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor ribbonInterceptor(
                LoadBalancerClient loadBalancerClient,
                LoadBalancerRequestFactory requestFactory) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(loadBalancerClient, requestFactory);
        }

        @Bean
        @ConditionalOnMissingBean
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer restTemplateCustomizer(
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor loadBalancerInterceptor) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplateCustomizer() {
                @Override
                &lt;/span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; customize(RestTemplate restTemplate) {&lt;/span&gt;
                    &lt;span&gt;List&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;
                            &lt;span&gt;restTemplate.getInterceptors());&lt;/span&gt;
                    &lt;span&gt;list.add(loadBalancerInterceptor);&lt;/span&gt;
                    &lt;span&gt;restTemplate.setInterceptors(list);&lt;/span&gt;
                }
            };
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;restTemplate.setInterceptors(list)这个地方就是注入负载均衡拦截器的地方LoadBalancerInterceptor。&lt;/p&gt;
&lt;p&gt;从这个地方实际上也可以猜出来，RestTemplate可以通过注入的拦截器来构建相应的请求实现负载均衡。&lt;/p&gt;
&lt;p&gt;也能看出来可以自定义拦截器实现其他目的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.RibbonClientConfiguration配置生成ZoneAwareLoadBalancer实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码位置：&lt;/p&gt;
&lt;p&gt;spring-cloud-netflix-core-1.3.5.RELEASE.jar&lt;br/&gt;org.springframework.cloud.netflix.ribbon&lt;br/&gt;RibbonClientConfiguration.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
@SuppressWarnings(&quot;deprecation&quot;&lt;span&gt;)
@Configuration
@EnableConfigurationProperties
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Order is important here, last should be the default, first should be optional
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; see &lt;/span&gt;&lt;span&gt;https://github.com/spring-cloud/spring-cloud-netflix/issues/2086&lt;/span&gt;&lt;span&gt;#issuecomment-316281653&lt;/span&gt;
@Import({OkHttpRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;, RestClientRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;, HttpClientRibbonConfiguration.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RibbonClientConfiguration {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;
    @Bean
    @ConditionalOnMissingBean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt; ILoadBalancer&lt;/span&gt; ribbonLoadBalancer(IClientConfig config,
            ServerList&lt;/span&gt;&amp;lt;Server&amp;gt; serverList, ServerListFilter&amp;lt;Server&amp;gt;&lt;span&gt; serverListFilter,
            IRule rule, IPing ping, ServerListUpdater serverListUpdater) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.propertiesFactory.isSet(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, name)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.propertiesFactory.get(ILoadBalancer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, config, name);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ZoneAwareLoadBalancer&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;(config, rule, ping, serverList,&lt;/span&gt;
                &lt;span&gt;serverListFilter, serverListUpdater);&lt;/span&gt;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ZoneAwareLoadBalancer继承自ILoadBalancer接口，该接口有一个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Choose a server from load balancer.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key An object that the load balancer may use to determine which server to return. null if 
     *         the load balancer does not use this parameter.
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; server chosen
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Server chooseServer(Object key);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ZoneAwareLoadBalancer就是一个具体的负载均衡实现类，也是默认的负载均衡类，通过对chooseServer方法的实现选取某个服务实例。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;拦截&amp;amp;请求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/166781/201802/166781-20180217154849593-520024459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.使用RestTemplate进行Get、Post等各种请求，都是通过doExecute方法实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码位置：&lt;strong&gt;&lt;span&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;spring-web-4.3.12.RELEASE.jar&lt;br/&gt;org.springframework.web.client&lt;br/&gt;RestTemplate.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RestTemplate &lt;span&gt;extends&lt;/span&gt; InterceptingHttpAccessor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RestOperations {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;

    &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T &lt;span&gt;doExecute&lt;/span&gt;(URI url, HttpMethod method, RequestCallback requestCallback,
            ResponseExtractor&lt;/span&gt;&amp;lt;T&amp;gt; responseExtractor) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RestClientException {

        Assert.notNull(url, &lt;/span&gt;&quot;'url' must not be null&quot;&lt;span&gt;);
        Assert.notNull(method, &lt;/span&gt;&quot;'method' must not be null&quot;&lt;span&gt;);
        ClientHttpResponse response &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;span&gt;ClientHttpRequest request &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; createRequest(url, method)&lt;/span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requestCallback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                requestCallback.doWithRequest(request);
            }
            &lt;span&gt;response &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; request.execute();&lt;/span&gt;
            handleResponse(url, method, response);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (responseExtractor != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseExtractor.extractData(response);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
            String resource &lt;/span&gt;=&lt;span&gt; url.toString();
            String query &lt;/span&gt;=&lt;span&gt; url.getRawQuery();
            resource &lt;/span&gt;= (query != &lt;span&gt;null&lt;/span&gt; ? resource.substring(0, resource.indexOf('?'&lt;span&gt;)) : resource);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ResourceAccessException(&quot;I/O error on &quot; + method.name() +
                    &quot; request for \&quot;&quot; + resource + &quot;\&quot;: &quot; +&lt;span&gt; ex.getMessage(), ex);
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                response.close();
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;支持的各种http请求方法最终都是调用doExecute方法，该方法内调用创建方法创建请求实例，并执行请求得到响应对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.生成请求实例创建工厂&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上一步代码中，调用createRequest方法创建请求实例，这个方法是定义在父类中。&lt;/p&gt;
&lt;p&gt;先整理出主要的继承关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/166781/201802/166781-20180217162438624-511848339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; createRequest方法实际是定义在HttpAccessor抽象类中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpAccessor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ClientHttpRequestFactory requestFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; SimpleClientHttpRequestFactory&lt;/span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRequestFactory(ClientHttpRequestFactory requestFactory) {
        Assert.notNull(requestFactory, &lt;/span&gt;&quot;ClientHttpRequestFactory must not be null&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requestFactory =&lt;span&gt; requestFactory;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ClientHttpRequestFactory getRequestFactory() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestFactory;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ClientHttpRequest &lt;span&gt;createRequest&lt;/span&gt;(URI url, HttpMethod method) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        ClientHttpRequest request &lt;/span&gt;=&lt;span&gt;&lt;span&gt; getRequestFactory()&lt;/span&gt;.createRequest(url, method);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;Created &quot; + method.name() + &quot; request for \&quot;&quot; + url + &quot;\&quot;&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; request;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在createRequest方法中调用getRequestFactory方法获得请求实例创建工厂，实际上getRequestFactory并不是当前HttpAccessor类中定义的，而是在子类InterceptingHttpAccessor中定义的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptingHttpAccessor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpAccessor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;ClientHttpRequestInterceptor&amp;gt; interceptors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setInterceptors(List&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; interceptors) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptors =&lt;span&gt; interceptors;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; getInterceptors() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interceptors;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ClientHttpRequestFactory &lt;span&gt;getRequestFactory&lt;/span&gt;() {
        &lt;span&gt;ClientHttpRequestFactory delegate &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;super&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;.getRequestFactory()&lt;/span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;&lt;span&gt;CollectionUtils.isEmpty(getInterceptors())&lt;/span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt; InterceptingClientHttpRequestFactory&lt;/span&gt;(delegate, getInterceptors());
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里做了个小动作，首先还是通过HttpAccessor类创建并获得SimpleClientHttpRequestFactory工厂，这个工厂主要就是在没有拦截器的时候创建基本请求实例。&lt;/p&gt;
&lt;p&gt;其次，在有拦截器注入的情况下，创建InterceptingClientHttpRequestFactory工厂，该工厂就是创建带拦截器的请求实例，因为注入了负载均衡拦截器，所以这里就从InterceptingClientHttpRequestFactory工厂创建。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.通过工厂创建请求实例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建实例就看工厂的createRequest方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptingClientHttpRequestFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractClientHttpRequestFactoryWrapper {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; interceptors;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InterceptingClientHttpRequestFactory(ClientHttpRequestFactory requestFactory,
            List&lt;/span&gt;&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; interceptors) {

        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(requestFactory);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptors = (interceptors != &lt;span&gt;null&lt;/span&gt; ? interceptors : Collections.&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt;emptyList());
    }


    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ClientHttpRequest &lt;span&gt;createRequest&lt;/span&gt;(URI uri, HttpMethod httpMethod, ClientHttpRequestFactory requestFactory) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;InterceptingClientHttpRequest&lt;/span&gt;(requestFactory, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interceptors, uri, httpMethod);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是new了个InterceptingClientHttpRequest实例，并且把拦截器、基本请求实例创建工厂注进去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.请求实例调用配置阶段注入的负载均衡拦截器的拦截方法intercept&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可从第1步看出，创建完请求实例后，通过执行请求实例的execute方法执行请求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ClientHttpRequest request =&lt;span&gt; createRequest(url, method);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requestCallback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    requestCallback.doWithRequest(request);
}
response &lt;/span&gt;= &lt;span&gt;request.execute();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际请求实例是InterceptingClientHttpRequest，execute实际是在它的父类中。&lt;/p&gt;
&lt;p&gt;类定义位置：&lt;/p&gt;
&lt;p&gt;spring-web-4.3.12.RELEASE.jar&lt;br/&gt;org.springframework.http.client&lt;br/&gt;InterceptingClientHttpRequest.class&lt;/p&gt;
&lt;p&gt;看一下它们的继承关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/166781/201802/166781-20180217232147015-1280396031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在execute方法中实际调用了子类实现的executeInternal方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractClientHttpRequest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ClientHttpRequest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HttpHeaders headers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpHeaders();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; executed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; HttpHeaders getHeaders() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.executed ? HttpHeaders.readOnlyHttpHeaders(&lt;span&gt;this&lt;/span&gt;.headers) : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.headers);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; OutputStream getBody() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        assertNotExecuted();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getBodyInternal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.headers);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ClientHttpResponse &lt;span&gt;execute&lt;/span&gt;() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        assertNotExecuted();
        ClientHttpResponse result &lt;/span&gt;= &lt;span&gt;executeInternal&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.headers);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.executed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; assertNotExecuted() {
        Assert.state(&lt;/span&gt;!&lt;span&gt;this&lt;/span&gt;.executed, &quot;ClientHttpRequest already executed&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; OutputStream getBodyInternal(HttpHeaders headers) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; ClientHttpResponse executeInternal(HttpHeaders headers) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是InterceptingClientHttpRequest类的executeInternal方法，其中，又调用了一个执行器InterceptingRequestExecution的execute，通关判断如果有拦截器注入进来过，就调用拦截器的intercept方法。&lt;/p&gt;
&lt;p&gt;这里的拦截器实际上就是在配置阶段注入进RestTemplate实例的负载均衡拦截器LoadBalancerInterceptor实例，可参考上面配置阶段的第2步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; InterceptingClientHttpRequest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractBufferingClientHttpRequest {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ClientHttpResponse &lt;span&gt;executeInternal&lt;/span&gt;(HttpHeaders headers, &lt;span&gt;byte&lt;/span&gt;[] bufferedOutput) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        InterceptingRequestExecution requestExecution &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterceptingRequestExecution();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;requestExecution.execute&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, bufferedOutput);
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterceptingRequestExecution &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ClientHttpRequestExecution {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Iterator&amp;lt;ClientHttpRequestInterceptor&amp;gt;&lt;span&gt; iterator;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InterceptingRequestExecution() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.iterator =&lt;span&gt; interceptors.iterator();
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ClientHttpResponse execute(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.hasNext()) {
                ClientHttpRequestInterceptor nextInterceptor &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.iterator.next();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;nextInterceptor.intercept(request, body, &lt;span&gt;this&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                ClientHttpRequest delegate &lt;/span&gt;=&lt;span&gt; requestFactory.createRequest(request.getURI(), request.getMethod());
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt; entry : request.getHeaders().entrySet()) {
                    List&lt;/span&gt;&amp;lt;String&amp;gt; values =&lt;span&gt; entry.getValue();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String value : values) {
                        delegate.getHeaders().add(entry.getKey(), value);
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (body.length &amp;gt; 0&lt;span&gt;) {
                    StreamUtils.copy(body, delegate.getBody());
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.execute();
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.负载均衡拦截器调用负载均衡客户端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在负载均衡拦截器LoadBalancerInterceptor类的intercept方法中，又调用了负载均衡客户端LoadBalancerClient实现类的execute方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoadBalancerInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ClientHttpRequestInterceptor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LoadBalancerClient loadBalancer;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory requestFactory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadBalancer =&lt;span&gt; loadBalancer;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requestFactory =&lt;span&gt; requestFactory;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoadBalancerInterceptor(LoadBalancerClient loadBalancer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for backwards compatibility&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;(loadBalancer, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadBalancerRequestFactory(loadBalancer));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ClientHttpResponse &lt;span&gt;intercept&lt;/span&gt;(&lt;span&gt;final&lt;/span&gt; HttpRequest request, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] body,
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ClientHttpRequestExecution execution) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; URI originalUri =&lt;span&gt; request.getURI();
        String serviceName &lt;/span&gt;=&lt;span&gt; originalUri.getHost();
        Assert.state(serviceName &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;, &quot;Request URI does not contain a valid hostname: &quot; +&lt;span&gt; originalUri);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.loadBalancer.execute&lt;/span&gt;(serviceName, requestFactory.createRequest(request, body, execution));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在配置阶段的第1步，可以看到实现类是RibbonLoadBalancerClient。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.负载均衡客户端调用负载均衡策略选取目标服务实例并发起请求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在RibbonLoadBalancerClient的第一个execute方法以及getServer方法中可以看到，实际上是通过ILoadBalancer的负载均衡器实现类作的chooseServer方法选取一个服务，交给接下来的请求对象发起一个请求。&lt;/p&gt;
&lt;p&gt;这里的负载均衡实现类默认是ZoneAwareLoadBalancer区域感知负载均衡器实例，其内部通过均衡策略选择一个服务。&lt;/p&gt;
&lt;p&gt;ZoneAwareLoadBalancer的创建可以参考配置阶段的第4步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RibbonLoadBalancerClient &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; LoadBalancerClient {
&lt;/span&gt;&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        ILoadBalancer loadBalancer &lt;/span&gt;=&lt;span&gt;&lt;span&gt; getLoadBalancer(serviceId)&lt;/span&gt;;
        Server server &lt;/span&gt;=&lt;span&gt;&lt;span&gt; getServer(loadBalancer)&lt;/span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;No instances available for &quot; +&lt;span&gt; serviceId);
        }
        RibbonServer ribbonServer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonServer(serviceId, server, isSecure(server,
                serviceId), serverIntrospector(serviceId).getMetadata(server));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;&lt;span&gt; execute(serviceId, ribbonServer, request)&lt;/span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&amp;lt;T&amp;gt; request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        Server server &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(serviceInstance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RibbonServer) {
            server &lt;/span&gt;=&lt;span&gt; ((RibbonServer)serviceInstance).getServer();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (server == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;No instances available for &quot; +&lt;span&gt; serviceId);
        }

        RibbonLoadBalancerContext context &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory
                .getLoadBalancerContext(serviceId);
        RibbonStatsRecorder statsRecorder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RibbonStatsRecorder(context, server);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;span&gt;T returnVal &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; request.apply(serviceInstance)&lt;/span&gt;;
            statsRecorder.recordStats(returnVal);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnVal;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; catch IOException and rethrow so RestTemplate behaves correctly&lt;/span&gt;
        &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ex) {
            statsRecorder.recordStats(ex);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            statsRecorder.recordStats(ex);
            ReflectionUtils.rethrowRuntimeException(ex);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
       
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略 &lt;/span&gt;

    &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Server getServer(ILoadBalancer loadBalancer) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadBalancer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;loadBalancer.chooseServer(&quot;default&quot;);&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: better handling of key&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ILoadBalancer getLoadBalancer(String serviceId) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientFactory.getLoadBalancer(serviceId);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RibbonServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServiceInstance {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String serviceId;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Server server;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; secure;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; metadata;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RibbonServer(String serviceId, Server server) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(serviceId, server, &lt;span&gt;false&lt;/span&gt;, Collections.&amp;lt;String, String&amp;gt;&lt;span&gt; emptyMap());
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RibbonServer(String serviceId, Server server, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; secure,
                Map&lt;/span&gt;&amp;lt;String, String&amp;gt;&lt;span&gt; metadata) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.serviceId =&lt;span&gt; serviceId;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.server =&lt;span&gt; server;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.secure =&lt;span&gt; secure;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.metadata =&lt;span&gt; metadata;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
&lt;span&gt;    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码撸完，总结下。&lt;/p&gt;
&lt;p&gt;普通使用RestTemplate请求其他服务时，内部使用的就是常规的http请求实例发送请求。&lt;/p&gt;
&lt;p&gt;为RestTemplate增加了@LoanBalanced 注解后，实际上通过配置，为RestTemplate注入负载均衡拦截器，让负载均衡器选择根据其对应的策略选择合适的服务后，再发送请求。&lt;/p&gt;

&lt;p&gt;End&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 14:42:00 +0000</pubDate>
<dc:creator>白色的海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kongxianghai/p/8445030.html</dc:identifier>
</item>
<item>
<title>插上腾飞的翅膀：为asp.net core添加protobuf支持 - 月亮光光</title>
<link>http://www.cnblogs.com/Mutuduxf/p/8457011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mutuduxf/p/8457011.html</guid>
<description>&lt;p&gt;通过NuGet获取Zaabee.AspNetCoreProtobuf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Zaabee.AspNetCoreProtobuf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup.cs文件中修改ConfigureServices方法&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc(options =&amp;gt; { options.AddProtobufSupport(); });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搞掂……这时候你就可以通过application/x-protobuf的content-type来让asp.net core使用protobuf来进行序列化/反序列化。&lt;/p&gt;
&lt;h2 id=&quot;测试代码&quot;&gt;测试代码&lt;/h2&gt;
&lt;p&gt;在asp.net core项目中添加以下DTO&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[ProtoContract]
public class TestDto
{
    [ProtoMember(1)] public Guid Id { get; set; }
    [ProtoMember(2)] public string Name { get; set; }
    [ProtoMember(3)] public DateTime CreateTime { get; set; }
    [ProtoMember(4)] public List&amp;lt;TestDto&amp;gt; Kids { get; set; }
    [ProtoMember(5)] public long Tag { get; set; }
    [ProtoMember(6)] public TestEnum Enum { get; set; }
}

public enum TestEnum
{
    Apple,
    Banana,
    Pear
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个XUnit项目，通过Nuget引用Microsoft.AspNetCore.TestHost，建立一个测试类&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AspNetCoreProtobufTest
{
    private readonly TestServer _server;
    private readonly HttpClient _client;

    public AspNetCoreProtobufTest()
    {
        _server = new TestServer(
            new WebHostBuilder()
                .UseKestrel()
                .UseStartup&amp;lt;Startup&amp;gt;());
        _client = _server.CreateClient();
    }

    [Fact]
    public void Test()
    {
        // HTTP Post with Protobuf Response Body
        _client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(&quot;application/x-protobuf&quot;));

        var dtos = GetDtos();
        var stream = new MemoryStream();
        ProtoBuf.Serializer.Serialize(stream, dtos);

        HttpContent httpContent = new StreamContent(stream);

        // HTTP POST with Protobuf Request Body
        var responseForPost = _client.PostAsync(&quot;api/Values&quot;, httpContent);

        var result = ProtoBuf.Serializer.Deserialize&amp;lt;List&amp;lt;TestDto&amp;gt;&amp;gt;(
            responseForPost.Result.Content.ReadAsStreamAsync().Result);

        Assert.True(CompareDtos(dtos,result));
    }

    private static bool CompareDtos(List&amp;lt;TestDto&amp;gt; lstOne, List&amp;lt;TestDto&amp;gt; lstTwo)
    {
        lstOne = lstOne ?? new List&amp;lt;TestDto&amp;gt;();
        lstTwo = lstTwo ?? new List&amp;lt;TestDto&amp;gt;();

        if (lstOne.Count != lstTwo.Count) return false;

        for (var i = 0; i &amp;lt; lstOne.Count; i++)
        {
            var dtoOne = lstOne[i];
            var dtoTwo = lstTwo[i];
            if (dtoOne.Id != dtoTwo.Id || dtoOne.CreateTime != dtoTwo.CreateTime || dtoOne.Enum != dtoTwo.Enum ||
                dtoOne.Name != dtoTwo.Name || dtoOne.Tag != dtoTwo.Tag || !CompareDtos(dtoOne.Kids, dtoTwo.Kids))
                return false;
        }

        return true;
    }

    private static List&amp;lt;TestDto&amp;gt; GetDtos()
    {
        return new List&amp;lt;TestDto&amp;gt;
        {
            new TestDto
            {
                Id = Guid.NewGuid(),
                Tag = long.MaxValue,
                CreateTime = DateTime.Now,
                Name = &quot;0&quot;,
                Enum = TestEnum.Apple,
                Kids = new List&amp;lt;TestDto&amp;gt;
                {
                    new TestDto
                    {
                        Id = Guid.NewGuid(),
                        Tag = long.MaxValue - 1,
                        CreateTime = DateTime.Now,
                        Name = &quot;00&quot;,
                        Enum = TestEnum.Banana
                    },
                    new TestDto
                    {
                        Id = Guid.NewGuid(),
                        Tag = long.MaxValue - 2,
                        CreateTime = DateTime.Now,
                        Name = &quot;01&quot;,
                        Enum = TestEnum.Pear
                    }
                }
            },
            new TestDto
            {
                Id = Guid.NewGuid(),
                Tag = long.MaxValue - 3,
                CreateTime = DateTime.Now,
                Name = &quot;1&quot;,
                Enum = TestEnum.Apple,
                Kids = new List&amp;lt;TestDto&amp;gt;
                {
                    new TestDto
                    {
                        Id = Guid.NewGuid(),
                        Tag = long.MaxValue - 4,
                        CreateTime = DateTime.Now,
                        Name = &quot;10&quot;,
                        Enum = TestEnum.Banana
                    },
                    new TestDto
                    {
                        Id = Guid.NewGuid(),
                        Tag = long.MaxValue - 5,
                        CreateTime = DateTime.Now,
                        Name = &quot;11&quot;,
                        Enum = TestEnum.Pear
                    }
                }
            }
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;为什么要用protobuf&quot;&gt;为什么要用protobuf？&lt;/h2&gt;
&lt;p&gt;因为快……在我们这边使用业务数据的测试中，protobuf的序列化/反序列化性能大概是Json.net的三倍，序列化后的体积大概只有Json的二分之一，这可以在相当程度上提高webapi的吞吐性能。&lt;/p&gt;
&lt;p&gt;另外就是Json对于浮点数的处理存在精度丢失，因为JS的number类型的安全整数是53位。当我们使用雪花算法来提供全局递增ID时会因为精度丢失导致重复主键。而且情况不仅如此，由于同样原因传递DateTime类型也会因为毫秒不一致导致时间匹配错误。一般的解决方法是使用字符串传递，不过这毕竟属于偏方并没有从根源上解决问题，因此我们还是直接使用protobuf来处理。&lt;/p&gt;
&lt;h2 id=&quot;protobuf的缺点&quot;&gt;protobuf的缺点&lt;/h2&gt;
&lt;p&gt;DTO层必须引用protobuf-net来添加特性，这在一定程度上导致了代码的侵入。基本上DTO属于POCO，依赖第三方包的话总觉得有点不贞洁……另外就是protobuf序列化后的数据不具有可视化，因此如果是使用消息队列或者请求监控的地方，就要综合考虑protobuf是否适合使用场景。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;asp.net core是基于中间件方式来实现，其自带默认的JsonFormater（基于Json.net），asp.net core会根据content type来选择对应的Formater来处理对象的序列化，当中包括InputFormatter（反序列化）和OutputFormatter（序列化）。因此除了protobuf，我们还可以添加或者替换其它的序列化方式，例如使用Jil来代替Json.net来提高Json性能。&lt;/p&gt;
&lt;p&gt;以上实现以及Demo和测试的源代码已放到&lt;a href=&quot;https://github.com/Mutuduxf/Zaabee.AspNetCoreProtobuf&quot;&gt;GitHub&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;最后给大家拜个晚年，祝大家新年快乐~&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 10:22:00 +0000</pubDate>
<dc:creator>月亮光光</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mutuduxf/p/8457011.html</dc:identifier>
</item>
<item>
<title>【深度学习】L1正则化和L2正则化 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8456968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8456968.html</guid>
<description>&lt;p&gt;在机器学习中，我们非常关心模型的预测能力，即模型在新数据上的表现，而不希望过拟合现象的的发生，我们通常使用正则化（regularization）技术来防止过拟合情况。正则化是机器学习中通过显式的控制模型复杂度来避免模型过拟合、确保泛化能力的一种有效方式。如果将模型原始的假设空间比作“天空”，那么天空飞翔的“鸟”就是模型可能收敛到的一个个最优解。在施加了模型正则化后，就好比将原假设空间（“天空”）缩小到一定的空间范围（“笼子”），这样一来，可能得到的最优解能搜索的假设空间也变得相对有限。有限空间自然对应复杂度不太高的模型，也自然对应了有限的模型表达能力。这就是“正则化有效防止模型过拟合的”一种直观解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180221174015826-824922748.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;l2正则化&quot;&gt;L2正则化&lt;/h2&gt;
&lt;p&gt;在深度学习中，用的比较多的正则化技术是L2正则化，其形式是在原先的损失函数后边再加多一项：&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{2}\lambda\theta_{i}^2\)&lt;/span&gt;，那加上L2正则项的损失函数就可以表示为：&lt;span class=&quot;math inline&quot;&gt;\(L(\theta)=L(\theta)+\lambda\sum_{i}^{n}\theta_{i}^2\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;就是网络层的待学习的参数，&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;则控制正则项的大小，较大的取值将较大程度约束模型复杂度，反之亦然。&lt;/p&gt;
&lt;p&gt;L2约束通常对稀疏的有尖峰的权重向量施加大的惩罚，而偏好于均匀的参数。这样的效果是鼓励神经单元利用上层的所有输入，而不是部分输入。所以L2正则项加入之后，权重的绝对值大小就会整体倾向于减少，尤其不会出现特别大的值（比如噪声），即网络偏向于学习比较小的权重。所以L2正则化在深度学习中还有个名字叫做“权重衰减”（weight decay），也有一种理解这种衰减是对权值的一种惩罚，所以有些书里把L2正则化的这一项叫做惩罚项（penalty）。&lt;/p&gt;
&lt;p&gt;我们通过一个例子形象理解一下L2正则化的作用，考虑一个只有两个参数&lt;span class=&quot;math inline&quot;&gt;\(w_{1}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(w_{2}\)&lt;/span&gt;的模型，其损失函数曲面如下图所示。从a可以看出，最小值所在是一条线，整个曲面看起来就像是一个山脊。那么这样的山脊曲面就会对应无数个参数组合，单纯使用梯度下降法难以得到确定解。但是这样的目标函数若加上一项&lt;span class=&quot;math inline&quot;&gt;\(0.1\times(w_{1}^2+w_{2}^2)\)&lt;/span&gt;，则曲面就会变成b图的曲面，最小值所在的位置就会从一条山岭变成一个山谷了,此时我们搜索该目标函数的最小值就比先前容易了，所以L2正则化在机器学习中也叫做“岭回归”（ridge regression）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180221174027599-1004937268.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;l1正则化&quot;&gt;L1正则化&lt;/h2&gt;
&lt;p&gt;L1正则化的形式是：&lt;span class=&quot;math inline&quot;&gt;\(\lambda|\theta_{i}|\)&lt;/span&gt;,与目标函数结合后的形式就是：&lt;span class=&quot;math inline&quot;&gt;\(L(\theta)=L(\theta)+\lambda\sum_{i}^{n}|\theta_{i}|\)&lt;/span&gt;。需注意，L1 正则化除了和L2正则化一样可以约束数量级外，L1正则化还能起到使参数更加稀疏的作用，稀疏化的结果使优化后的参数一部分为0，另一部分为非零实值。非零实值的那部分参数可起到选择重要参数或特征维度的作用，同时可起到去除噪声的效果。此外，L1正则化和L2正则化可以联合使用：&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{1}|\theta_{i}|+\frac{1}{2}\lambda_{2}\theta_{i}^2\)&lt;/span&gt;。这种形式也被称为“Elastic网络正则化”。&lt;/p&gt;
&lt;h2 id=&quot;正则化对偏导的影响&quot;&gt;正则化对偏导的影响&lt;/h2&gt;
&lt;p&gt;对于L2正则化：&lt;span class=&quot;math inline&quot;&gt;\(C=C_{0}+\frac{\lambda}{2n}\sum_{i}\omega_{i}^2\)&lt;/span&gt;，相比于未加正则化之前,权重的偏导多了一项&lt;span class=&quot;math inline&quot;&gt;\(\frac{\lambda}{n}\omega\)&lt;/span&gt;，偏置的偏导没变化，那么在梯度下降时&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的更新变为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180221174039841-1960887716.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;的系数使得权重下降加速，因此L2正则也称weight decay(caffe中损失层的weight_decay参数与此有关)。对于随机梯度下降(对一个mini-batch中的所有x的偏导求平均)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180221174050281-1300633515.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于L1正则化：&lt;span class=&quot;math inline&quot;&gt;\(C=C_{0}+\frac{\lambda}{n}\sum_{i}|\omega_{i}|\)&lt;/span&gt;，梯度下降的更新为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1093303/201802/1093303-20180221174101712-99095034.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;符号函数在&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;大于0时为1，小于0时为-1，在&lt;span class=&quot;math inline&quot;&gt;\(\omega=0\)&lt;/span&gt;时&lt;span class=&quot;math inline&quot;&gt;\(|\omega|\)&lt;/span&gt;没有导数，因此可令sgn(0)=0，在0处不使用L1正则化。&lt;br/&gt;相比于L2，有所不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;L1减少的是一个常量，L2减少的是权重的固定比例&lt;/li&gt;
&lt;li&gt;孰快孰慢取决于权重本身的大小，权重刚大时可能L2快，较小时L1快&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实践中L2正则化通常优于L1正则化。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 09:44:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8456968.html</dc:identifier>
</item>
<item>
<title>🖥️ 自制虚拟机 - 概念和汇编器 - I.am.Conmajia</title>
<link>http://www.cnblogs.com/conmajia/p/virtual-machine-part-one.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/conmajia/p/virtual-machine-part-one.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Conmajia 🇨🇳 © 2012, Alan Bryan 🇺🇸 © 2012&lt;br/&gt;部分设计参考了 B32 虚拟机，已获 Alan Bryan 书面授权.&lt;br/&gt;Updated on Feb. 19, 2018&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这篇文章是我自制虚拟机系列文章的第一部分. 这个系列将从零开始，设计并实现一个完整可运行的虚拟机.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;虚拟机（virtual machine）和模拟器（simulator）在概念上有重叠. 我所指的虚拟机是&lt;strong&gt;软件模拟的仿真计算机&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虚拟机是一种模拟硬件环境的中间件（middleware）， 是高度隔离的软件容器，可以运行自己的操作系统和应用程序，行为完全类似于一台实际的计算机. 它包含自己的 CPU，有些甚至扩展了 RAM、硬盘和网络接口卡（NIC）等虚拟硬件.&lt;/p&gt;
&lt;p&gt;操作系统无法分辨虚拟机与物理硬件之间的差异，应用程序和网络中的其他计算机也无法分辨. 即使是虚拟机本身也认为自己是一台&lt;em&gt;真正的&lt;/em&gt;计算机. 不过，虚拟机完全由虚拟机软件组成，不含任何硬件组件. 因此，虚拟机具备物理硬件所没有的很多独特优势.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;兼容性（compatibility）&lt;/li&gt;
&lt;li&gt;隔离（isolation）&lt;/li&gt;
&lt;li&gt;封装（packing）&lt;/li&gt;
&lt;li&gt;独立于硬件（hardware independent）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虚拟机来自于对实际硬件的虚拟. 我设计了一款&lt;em&gt;简化版&lt;/em&gt;的 16bit 处理器：SunnyApril. 因为 CPU 位宽只有 16bit，所以针对它设计的虚拟机寻址空间为 &lt;code&gt;0x0000&lt;/code&gt;~&lt;code&gt;0xffff&lt;/code&gt;. 接下来为 SunnyApril 添加&lt;strong&gt;寄存器&lt;/strong&gt;（register）. 寄存器是具有有限存贮容量（通常是 1、2 字节）的高速存储部件，用来暂存指令、数据或者地址. 简单来说，寄存器就是 &lt;strong&gt;CPU 内部的内存&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;为了简单，我只设计了 5 个寄存器，分别是 &lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;D&lt;/code&gt;、&lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt; 寄存器是 8 位寄存器，可以保存 &lt;code&gt;0x00&lt;/code&gt;~&lt;code&gt;0xff&lt;/code&gt; 的无符号数或是 &lt;code&gt;0x80&lt;/code&gt;~&lt;code&gt;0x7f&lt;/code&gt; 的有符号数. &lt;code&gt;X&lt;/code&gt;、&lt;code&gt;Y&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 寄存器都是 16 位的，可以保存 &lt;code&gt;0x0000&lt;/code&gt;~&lt;code&gt;0xffff&lt;/code&gt; 的无符号数或是 &lt;code&gt;0x8000&lt;/code&gt;~&lt;code&gt;0x7fff&lt;/code&gt; 的有符号数. 同样是为了设计简便，只考虑无符号数的情况，有符号数将在后面研究浮点数的时候一起进行.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;D&lt;/code&gt; 寄存器是一个特殊的 16 位寄存器. 它的值是由 &lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt; 寄存器的值合并而成，&lt;code&gt;A&lt;/code&gt; 保存了 &lt;code&gt;D&lt;/code&gt; 的高 8 位值，&lt;code&gt;B&lt;/code&gt; 保存了低 8 位值. 例如 &lt;code&gt;A&lt;/code&gt; 寄存器值为 &lt;code&gt;0x3c&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 寄存器值为 &lt;code&gt;0x10&lt;/code&gt;，则 &lt;code&gt;D&lt;/code&gt; 寄存器值为 &lt;code&gt;0x3c10&lt;/code&gt;. 反之，如果修改 &lt;code&gt;D&lt;/code&gt; 寄存器值为 &lt;code&gt;0x07c0&lt;/code&gt;，则 &lt;code&gt;A&lt;/code&gt; 寄存器值变为 &lt;code&gt;0x07&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt; 寄存器值变为 &lt;code&gt;0xc0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;图 1 说明了 SunnyApril 的寄存器关系.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/407692/201802/407692-20180221151426370-847545614.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 1 寄存器布局&lt;/p&gt;
&lt;p&gt;为了让虚拟机能在第一时间&lt;em&gt;反馈&lt;/em&gt;运行结果，我从 64KB 的内存空间中留出 4000 字节的空间（&lt;code&gt;0xa000&lt;/code&gt;~&lt;code&gt;0xafa0&lt;/code&gt;）作为&lt;em&gt;临时显示器&lt;/em&gt;的缓存. 模仿 DOS 命令行的显示风格，我用其中 2000 字节用于保存显示字符（这样可以得到 80$\times$25 的字符屏幕），2000 字节用于保存每个字符的样式. 样式字节低 3 位分别表示前景色的红、绿、蓝颜色值，第 4 位表示明暗度，5~7 位用于表示背景颜色. 样式字节的最高位本来是表示是否闪烁字符，但在我的设计中不需要这个功能，所以直接忽略.&lt;/p&gt;
&lt;p&gt;接下来的工作就是设计能让虚拟机运行起来的&lt;strong&gt;指令集&lt;/strong&gt;（instruction set）和&lt;strong&gt;字节码&lt;/strong&gt;（binary code）. 指令集和 SunnyApril 的&lt;em&gt;汇编语言&lt;/em&gt;一起设计，简便起见，先设计 4 个指令，如表 1 所示.&lt;/p&gt;
&lt;p&gt;表 1 SunnyApril CPU 指令集（部分）&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;LDA&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;0x01&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;将数据存入 &lt;code&gt;A&lt;/code&gt; 寄存器&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;LDA #41H&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;A=0x41&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;LDX&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;0x02&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;将数据存入 &lt;code&gt;X&lt;/code&gt; 寄存器&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;LDX #1000H&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;X=0x1000&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;STA&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;0x03&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;将 &lt;code&gt;A&lt;/code&gt; 寄存器的值存入操作数指定的内存地址&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;STA X&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[0x1000]=0x41&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;END&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;code&gt;0x04&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;结束程序，并标记起始标签&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;END START&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以 &lt;code&gt;LDA&lt;/code&gt; 指令为例，这个指令用于将&lt;strong&gt;操作数&lt;/strong&gt;（operand）存入 &lt;code&gt;A&lt;/code&gt; 寄存器. 由于操作数寻址方式太多，这里简单地用 &lt;code&gt;#&lt;/code&gt; 符号起头，表示&lt;em&gt;立即数&lt;/em&gt;（类似 51 单片机的汇编语言）. 以 &lt;code&gt;H&lt;/code&gt; 结尾的数字表示为十六进制，类似的有 &lt;code&gt;O&lt;/code&gt;（八进制）、&lt;code&gt;B&lt;/code&gt;（二进制）和 &lt;code&gt;D&lt;/code&gt;（十进制，可以省略）.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;END&lt;/code&gt; 指令表示程序结束. 它的操作数称为&lt;strong&gt;标签&lt;/strong&gt;，表示程序的起始标签，用于标注程序运行的开始位置. 标签是以字母开头，半角冒号结尾的单行字符串，例如：&lt;/p&gt;
&lt;p&gt;程序 1 标签&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;START:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来设计编译后的二进制文件格式. 大部分编译器的二进制文件格式都是以一串&lt;em&gt;魔术字&lt;/em&gt;字符串开头的. 例如，DOS/Windows 中的 PE 文件用 &lt;code&gt;MZ&lt;/code&gt; 开头. Java 二进制文件用 4 字节的数字 3405691582 开头，写成 16 进制就是 &lt;code&gt;0xCAFEBABE&lt;/code&gt;（cafe babe）. SunnyApril 使用 &lt;code&gt;CONMAJIA&lt;/code&gt; 作为魔术字，文件头结构参见表 2.&lt;/p&gt;
&lt;p&gt;表 2 SunnyApril 文件头（单位：字节）&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;[&lt;span class=&quot;math inline&quot;&gt;\(\Delta-13\)&lt;/span&gt;]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;文件体紧跟于头部，保存了程序编译后的全部二进制代码.&lt;/p&gt;

&lt;p&gt;现在可以设计汇编器了. 汇编器将编写的汇编源程序编译后输出到可以供虚拟机运行的二进制字节码文件中（即&lt;em&gt;可执行文件&lt;/em&gt;）.&lt;/p&gt;
&lt;p&gt;汇编文件格式如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;[标签:]&lt;br/&gt;&amp;lt;指令&amp;gt; &lt;span class=&quot;math inline&quot;&gt;\(\sqcup\)&lt;/span&gt; &amp;lt;操作数&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;方括号中的内容是可选的，&lt;span class=&quot;math inline&quot;&gt;\(\sqcup\)&lt;/span&gt; 表示一个空格字符.&lt;/p&gt;
&lt;p&gt;下面是一个汇编源程序的例子：&lt;/p&gt;
&lt;p&gt;程序 2 示例源代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 START:
2 LDA #65
3 LDX #A000H
4 STA X
5 END START&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个程序的功能是把字符“A”输出到屏幕的左上角.&lt;/p&gt;
&lt;p&gt;第一行代码定义了 &lt;code&gt;START&lt;/code&gt; 标签. 第二行将立即数 &lt;code&gt;65&lt;/code&gt;（即 ASCII 字母 A）存入 &lt;code&gt;A&lt;/code&gt; 寄存器. 第三行将立即数 &lt;code&gt;0xa000&lt;/code&gt;（即显存的起始地址）存入 &lt;code&gt;X&lt;/code&gt; 寄存器. 第四行代码将 &lt;code&gt;A&lt;/code&gt; 寄存器中的值存入 &lt;code&gt;X&lt;/code&gt; 寄存器中的数值指向的显存地址. 最后用 &lt;code&gt;END&lt;/code&gt; 指令结束程序.&lt;/p&gt;
&lt;h2 id=&quot;实现汇编器&quot;&gt;3.1 实现汇编器&lt;/h2&gt;
&lt;p&gt;汇编器（assembler）界面如图 2 所示，它实际上是编译器（compiler）和连接器（linker）的集合体.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic002.cnblogs.com/images/2012/407692/2012091401194051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 2 SunnyApril 汇编器&lt;/p&gt;
&lt;h3 id=&quot;寄存器枚举&quot;&gt;寄存器枚举&lt;/h3&gt;
&lt;p&gt;程序 3 Registers 枚举&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1 enum Registers
2 {
3     Unknown = 0,
4     A = 4,
5     B = 2,
6     D = 1,
7     X = 16,
8     Y = 8
9 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;汇编器的核心代码&quot;&gt;汇编器的核心代码&lt;/h3&gt;
&lt;p&gt;程序 4 SunnyApril 汇编器图形界面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 1 if (textBox1.Text == string.Empty)
 2     return;
 3 
 4 labelDict.Clear();
 5 binaryLength = (UInt16)numericUpDown1.Value;
 6 
 7 FileInfo fi = new FileInfo(textBox1.Text);
 8 
 9 BinaryWriter output;
10 FileStream fs = new FileStream(
11     Path.Combine(
12     fi.DirectoryName,
13     fi.Name + &quot;.sab&quot;),
14     FileMode.Create
15     );
16 output = new BinaryWriter(fs);
17 
18 // magic word
19 output.Write('C');
20 output.Write('O');
21 output.Write('N');
22 output.Write('M');
23 output.Write('A');
24 output.Write('J');
25 output.Write('I');
26 output.Write('A');
27 
28 // org
29 output.Write((UInt16)numericUpDown1.Value);
30 
31 // scan to ORG and start writing byte-code
32 output.Seek((int)numericUpDown1.Value, SeekOrigin.Begin);
33 
34 // parse source code line-by-line
35 TextReader input = File.OpenText(textBox1.Text);
36 string line;
37 while ((line = input.ReadLine()) != null)
38 {
39     parse(line.ToUpper(), output);
40     dealedSize += line.Length;
41     Invoker.Set(progressBar1, &quot;Value&quot;, (int)((float)dealedSize / (float)totalSize * 100));
42 }
43 input.Close();
44 
45 // binary length &amp;amp; execution address (7 magic-word, 2 org before)
46 output.Seek(10, SeekOrigin.Begin);
47 output.Write(binaryLength);
48 output.Write(executionAddress);
49 output.Close();
50 fs.Close();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源代码解析器&quot;&gt;源代码解析器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;parse()&lt;/code&gt; 函数用于对源代码逐行解析，主要代码如下：&lt;/p&gt;
&lt;p&gt;程序 5 &lt;code&gt;parse()&lt;/code&gt; 函数代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 1 private void parse(string line, BinaryWriter output)
 2 {
 3     // eat white spaces and comments
 4     line = cleanLine(line);
 5     if (line.EndsWith(&quot;:&quot;))
 6         // label
 7         labelDict.Add(line.TrimEnd(new char[] { ':' }), binaryLength);
 8     else
 9     {
10         // code
11         Match m = Regex.Match(line, @&quot;(\w+)\s(.+)&quot;);
12         string opcode = m.Groups[1].Value;
13         string operand = m.Groups[2].Value;
14 
15         switch (opcode)
16         {
17             case &quot;LDA&quot;:
18                 output.Write((byte)0x01);
19                 output.Write(getByteValue(operand));
20                 binaryLength += 2;
21                 break;
22             case &quot;LDX&quot;:
23                 output.Write((byte)0x02);
24                 output.Write(getWordValue(operand));
25                 binaryLength += 3;
26                 break;
27             case &quot;STA&quot;:
28                 output.Write((byte)0x03);
29                 // NOTE: No error handling.
30                 Registers r = (Registers)Enum.Parse(typeof(Registers), operand);
31                 output.Write((byte)r);
32                 binaryLength += 2;
33                 break;
34             case &quot;END&quot;:
35                 output.Write((byte)0x04);
36                 if (labelDict.ContainsKey(operand))
37                 {
38                     output.Write(labelDict[operand]);
39                     binaryLength += 2;
40                 }
41                 binaryLength += 1;
42                 break;
43             default:
44                 break;
45         }
46     }
47 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中用到了读取字节（byte）操作数的内部方法，如下所示. 稍作改进可以很方便地支持多种数制. 读取字（Word）操作数的方法与此类似.&lt;/p&gt;
&lt;p&gt;程序 6 读取字节函数代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 1 private byte getByteValue(string operand)
 2 {
 3     byte ret = 0;
 4     if (operand.StartsWith(&quot;#&quot;))
 5     {
 6         operand = operand.Remove(0, 1);
 7         char last = operand[operand.Length - 1];
 8         if (char.IsLetter(last))
 9             switch (last)
10             {
11                 case 'H':
12                     // hex
13                     ret = Convert.ToByte(operand.Remove(operand.Length - 1, 1), 16);
14                     break;
15                 case 'O':
16                     // oct
17                     ret = Convert.ToByte(operand.Remove(operand.Length - 1, 1), 8);
18                     break;
19                 case 'B':
20                     // bin
21                     ret = Convert.ToByte(operand.Remove(operand.Length - 1, 1), 2);
22                     break;
23                 case 'D':
24                     // dec
25                     ret = Convert.ToByte(operand.Remove(operand.Length - 1, 1), 10);
26                     break;
27             }
28         else
29             ret = byte.Parse(operand);
30     }
31 
32     return ret;
33 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;3.2 运行结果&lt;/h2&gt;
&lt;p&gt;运行汇编器，对前面保存的 &lt;code&gt;demo1.asm&lt;/code&gt; 文件进行汇编，得到 &lt;code&gt;demo1.sab&lt;/code&gt; 二进制字节码文件，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic002.cnblogs.com/images/2012/407692/2012091401540421.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 3 &lt;code&gt;demo1.sab&lt;/code&gt; 可执行文件内容&lt;/p&gt;
&lt;p&gt;汇编器忠实地完成了任务，正确计算了文件大小，从 &lt;code&gt;0x0200&lt;/code&gt; 位置处开始，汇编出的字节码为 &lt;code&gt;01 00 02 00 00 03 10 04 00 02&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;验证&quot;&gt;3.3 验证&lt;/h2&gt;
&lt;p&gt;下面根据程序 2 的源代码，逐行验证上述汇编器工作情况.&lt;/p&gt;
&lt;p&gt;第一行为 &lt;code&gt;START&lt;/code&gt; 标签，将地址 &lt;code&gt;0x0200&lt;/code&gt; 存入缓存（在文件中没有体现）.&lt;/p&gt;
&lt;p&gt;第二行 &lt;code&gt;LDA&lt;/code&gt; 指令，存入字节码 &lt;code&gt;0x01&lt;/code&gt;，然后存入单字节操作数（&lt;code&gt;A&lt;/code&gt; 寄存器是 8 位寄存器）65，即 &lt;code&gt;0x41&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;第三行 &lt;code&gt;LDX&lt;/code&gt; 指令，存入字节码 &lt;code&gt;0x02&lt;/code&gt;，然后存入双字节操作数（&lt;code&gt;X&lt;/code&gt; 寄存器是 16 位寄存器）&lt;code&gt;0xa000&lt;/code&gt;. 由于 SunnyApril 采用&lt;em&gt;小端模式&lt;/em&gt;（低位在前），所以在文件中是以 &lt;code&gt;00 A0&lt;/code&gt; 的形式存储的.&lt;/p&gt;
&lt;p&gt;第四行 &lt;code&gt;STA&lt;/code&gt; 指令，存入字节码 &lt;code&gt;0x03&lt;/code&gt;，然后存入 &lt;code&gt;Registers.X&lt;/code&gt; 枚举值（16，即 0x10`）.&lt;/p&gt;
&lt;p&gt;第五行 &lt;code&gt;END&lt;/code&gt; 指令，存入字节码 &lt;code&gt;0x04&lt;/code&gt;，然后存入 &lt;code&gt;START&lt;/code&gt; 标签地址 &lt;code&gt;0x0200&lt;/code&gt;（2 字节，仍以小端模式存储）.&lt;/p&gt;
&lt;p&gt;至此，可以判断，这个 SunnyApril 汇编器符合设计预期.&lt;/p&gt;

&lt;p&gt;在下一章中，我将开始设计 SunnyApril CPU 的其他部分.&lt;/p&gt;
&lt;p&gt;The End. &lt;span class=&quot;math inline&quot;&gt;\(\Box\)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 09:36:00 +0000</pubDate>
<dc:creator>I.am.Conmajia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/conmajia/p/virtual-machine-part-one.html</dc:identifier>
</item>
<item>
<title>SqlSugar ORM 入门到精通【一】入门篇 - 孙凯旋</title>
<link>http://www.cnblogs.com/sunkaixuan/p/8454844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunkaixuan/p/8454844.html</guid>
<description>&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;SqlSugar是一款国产ORM，除了拥有媲美原生的性能 另外还有满足各种需求的功能，简单好用一分钟就能够轻松上手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.x版本正式在自已公司内部项目使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.x版本得到了更多公司的喜欢不过也会抱怨有很多不足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.x版本17年5月发布后得到的评价超出了我的预期， 刚发布的时候做了大量的单元测试，不过还是有不少BUG，经过大量的用户反馈8月份左右成型和稳定，并且大量的项目得到交付，也得到了使用者的好评，现在我认为是一个较出色的版本所以我才开始写这篇文章介绍它&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.x版本 预计今年的5月份发布试用版本会完美兼4.X版本，随着几年对emit和拉姆达解析的深入理解，5.x版本将会有颠覆ORM的改变，具体什么样的功能暂时保密。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;支持&lt;/strong&gt;：Oracle、Mysql、Sqlite、SqlSever四种数据库，Postgresql年后也将支持已经在开发中了，支持的字段数据类型也是相当齐全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;功能&lt;/strong&gt;： 批量操作、CodeFirst、DbFirst、二级分布式缓存、AOP、读写分离、自定义Sql函数的扩展、动态表别名列别名，属性表别名列别名，拉姆达子查询，JOIN，UNIONALL，插入支持了默认值，更新支持了指定列排除列等常用功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;： 性能、语法简单、功能强大和持续更新维护&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;安装下载&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a title=&quot;https://github.com/sunkaixuan/SqlSugar&quot; href=&quot;https://github.com/sunkaixuan/SqlSugar&quot; target=&quot;_blank&quot;&gt;https://github.com/sunkaixuan/SqlSugar&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Nuget：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.net 4.0及以上版本： &lt;code&gt;Install-Package sqlSugar &lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.net core 2.0 版本：&lt;code&gt;Install-Package sqlSugarCore&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;连接数据库&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;SqlSugar是通过SqlSugarClient来进行数据库的操作，而创建SqlSugarClient我们需要ConnectionConfig这个类对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConnectionConfig有6个属性分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.ConnectionString（&lt;span&gt;必填&lt;/span&gt;）：&lt;/strong&gt;连接字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.DataType&lt;/strong&gt;（&lt;span&gt;必填&lt;/span&gt;）&lt;/span&gt;: 数据库类型&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.IsAutoCloseConnection：&lt;/strong&gt;(默认false)是否自动释放数据库，设为true我们不需要close或者Using的操作，比较推荐&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.InitKeyType：&lt;/strong&gt;&lt;span&gt;(默认SystemTable)初始化主键和自增列信息的方式(注意：如果是数据库权限受管理限制或者找不到主键一定要设成attribute)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;InitKeyType.SystemTable&lt;/span&gt;表示自动从数据库读取主键自增列的信息（适合SA等高权限的账户）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果是这种模式实体类就普通的实体类便可以，不需要加任何东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;InitKeyType.Attribute&lt;/span&gt; 表示从实体类的属性中读取 主键和自增列的信息(适合有独立的运维组的用户没有系统表操作权限)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如果是这种模式实体类需要有所改变&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SugarColumn(IsPrimaryKey=true,IsIdentity=true)] //如果是主键并且是自增列就加上2个属性
&lt;/pre&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[SugarColumn(IsPrimaryKey=true)]//如果只是主键只能加一个　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.MoreSettings &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于一些全局设置&lt;/p&gt;
&lt;p&gt;MoreSettings .IsAutoRemoveDataCache 为true表示可以自动删除二级缓存&lt;/p&gt;
&lt;p&gt;MoreSettings .IsWithNoLockQuery 为true表式查询的时候默认会加上.With(SqlWith.NoLock)，可以用With(SqlWith.Null)让全局的失效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.ConfigureExternalServices&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以扩展你想要的序列化方式和缓存方式等服务&lt;/p&gt;

&lt;h3&gt;实现一个简单的增、删、查和改&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
SqlSugarClient db = new SqlSugarClient(new ConnectionConfig() { 
ConnectionString = Config.ConnectionString, //必填
DbType = DbType.SqlServer, //必填
IsAutoCloseConnection = true}); //默认InitKey=SystemTable


var list=db.Queryable&amp;lt;Student&amp;gt;().ToList();//查询所有（使用SqlSugarClient查询所有到LIST）

var list2 = db.Queryable&amp;lt;Student, School, Student, Student, Student&amp;gt;((st, sc, st2, st3, st4) =&amp;gt; new object[] {
JoinType.Left,st.SchoolId==sc.Id,
JoinType.Left,st.Id==st2.Id,
JoinType.Left,st.Id==st3.Id,
JoinType.Left,st.Id==st4.Id
})
.Where((st,sc)=&amp;gt;sc.Id==1)
.Select((st, sc, st2,st3,st4) =&amp;gt; new { id= st.Id ,name=st.Name,st4=st4}).ToList();//5表查询


db.Insertable(insertObj).ExecuteCommand();//插入
db.Updateable(updateObj).ExecuteCommand();//更新
db.Deleteable&amp;lt;Student&amp;gt;(1).ExecuteCommand();//删除&lt;br/&gt;//db.Aop功能&lt;br/&gt;//db.Ado功能&lt;br/&gt;//...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SqlSugarClient对象可以完成非常复杂的数据库操，这些功能会在后面介绍&lt;/p&gt;

&lt;h3&gt;简化增、删、查和改&lt;/h3&gt;
&lt;p&gt;SqlSugarClient对象虽然强大但是大多数用户还是会在我的基础上在封装一层仓储然后简化增删查改，复杂的功能在用SqlSugarClient实现&lt;/p&gt;
&lt;p&gt;所以我就集成了&lt;span&gt;SimpleClient&lt;/span&gt;这个类让你不用在去写额外代码。&lt;/p&gt;

&lt;p&gt;你可以建一个类继承SimpleClient或者直接使用SimpleClient&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//我们就来扩展一个SimpleClient取名叫DbSet
public class DbSet&amp;lt;T&amp;gt;:SimpleClient&amp;lt;T&amp;gt; where T : class, new()
{
    public DbSet(SqlSugarClient context):base(context)
    {
            
    }
    //SimpleClient中的方法满足不了你，你可以扩展自已的方法
    public List&amp;lt;T&amp;gt; GetByIds(dynamic [] ids)
    {
        return Context.Queryable&amp;lt;T&amp;gt;().In(ids).ToList(); ;
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来创建一个DbContext类，里面包含了Db、StudentDb和SchoolDb &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//创建一个DbContext类，使用DbSet(或者SimpleClient)
public class DbContext
{
        public DbContext()
        {
            Db = new SqlSugarClient(new ConnectionConfig()
            {
                ConnectionString = &quot;xx&quot;,
                DbType = DbType.SqlServer,
                IsAutoCloseConnection = true,//开启自动释放模式和EF原理一样我就不多解释了
                //InitKey默认SystemTable
            });
        }
        public SqlSugarClient Db;//用来处理事务多表查询和复杂的操作
        public DbSet&amp;lt;Student&amp;gt; StudentDb { get { return new DbSet&amp;lt;Student&amp;gt;(db); } }//用来处理Student表的常用操作
        public DbSet&amp;lt;School&amp;gt; SchoolDb { get { return new DbSet&amp;lt;School&amp;gt;(db); } }//用来处理School表的常用操作
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们只要继承DbContext就可以方便的操作数据库了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
使用 DbSet 对象实现增删查和改
StudentDb.GetList(
StudentDb.GetById
StudentDb.Delete
StudentDb.Update
StudentDb.Insert
StudentDb.GetPageList

使用SqlSugarClient对象
Db.Ado.UseTran(()=&amp;gt;{ 操用 })//事务操作
Db.Queryable&amp;lt;T,T2&amp;gt; //实现复杂查询&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过本篇相信你已经可以方便的用SqlSugar ORM实现简单的增、删、查和改了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;我上面的例子使用的是默认InitKey方式实现的，如果用InitKey.Attribute需要在实体的属性上添加主键标记，在本篇的&lt;span&gt;连接数据库&lt;/span&gt;中有详细介绍。&lt;/p&gt;
&lt;p&gt;如果还不明白的话可以下载 &lt;a title=&quot;https://github.com/sunkaixuan/SqlSugar&quot; href=&quot;https://github.com/sunkaixuan/SqlSugar&quot; target=&quot;_blank&quot;&gt;https://github.com/sunkaixuan/SqlSugar&lt;/a&gt; 里面有详细的DEMO和建库脚本&lt;/p&gt;

&lt;h3&gt;下一篇预告&lt;/h3&gt;
&lt;p&gt;介绍SimpleClient具体函数和使用场景&lt;/p&gt;
&lt;p&gt;结合主流js插件 bootstrap-table 实现动态询功能&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 09:15:00 +0000</pubDate>
<dc:creator>孙凯旋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunkaixuan/p/8454844.html</dc:identifier>
</item>
<item>
<title>二维码开源库ZBar-MDK STM32F429移植 - 非正式码农</title>
<link>http://www.cnblogs.com/greyorbit/p/8456814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/greyorbit/p/8456814.html</guid>
<description>&lt;p&gt;前两篇文章已经实现ZBar在Windows平台下的编译和使用，本文将介绍如何把ZBar移植到STM32F429，IDE使用MDK。&lt;/p&gt;
&lt;h2&gt;1. MDK工程设置&lt;/h2&gt;
&lt;p&gt;（1）不勾选Use MicroLIB ，使用ISO C。&lt;br/&gt;如MDK 帮助文档关于MicroLIB的介绍，故在硬件资源允许的情况还是优先使用ISO C。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333201/201802/1333201-20180221160152284-531325283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333201/201802/1333201-20180221160927756-1666321112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）勾选C99 Mode，因为ZBar源码是基于C99的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333201/201802/1333201-20180221160950825-2135613140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;（3）不勾选Use Memory Layout From Target Dialog，使用自定义Scatter File&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333201/201802/1333201-20180221161026160-1453858310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.工程目录结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333201/201802/1333201-20180221161249060-2010175581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3. ZBar源码修改地方&lt;/h2&gt;
&lt;p&gt;由于MDK使用的编译器不是GCC，故不能支持一些特殊GCC语法和相应的C库函数。&lt;br/&gt;（1） error.c和error.h文件中strdup函数报错。&lt;br/&gt;处理方法：屏蔽该函数相关代码或者自己实现strdup函数&lt;br/&gt;（2） 屏蔽img_scanner.c文件中的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.....
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;time.h&amp;gt; /* clock_gettime */
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;sys/time.h&amp;gt; /* gettimeofday */&lt;/span&gt;
&lt;span&gt;....
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; struct timeval abstime;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; gettimeofday(&amp;amp;abstime, NULL);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; iscn-&amp;gt;time = (abstime.tv_sec * 1000) + ((abstime.tv_usec / 500) + 1) / 2;&lt;/span&gt;
.....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3） GCC默认void*为char*，MDK的编译器对void指针的加减操作当作错误处理&lt;br/&gt;处理方法：把void指针强制转换为char指针&lt;/p&gt;
&lt;h2&gt;4. 系统存储空间分配&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;对于STM32来说ZBar对Heap消耗较大，经测试需要2M左右的Heap，具体ZBar对RAM的要求暂时没深究。&lt;br/&gt;Scatter file 如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
LR_IROM1 &lt;span&gt;0x08000000&lt;/span&gt; &lt;span&gt;0x00100000&lt;/span&gt;&lt;span&gt;  {    ; load region size_region
    ER_IROM1 &lt;/span&gt;&lt;span&gt;0x08000000&lt;/span&gt; &lt;span&gt;0x00100000&lt;/span&gt;  {  ; load address =&lt;span&gt; execution address
    &lt;/span&gt;*.o (RESET, +&lt;span&gt;First)
    &lt;/span&gt;*&lt;span&gt;(InRoot$$Sections)
    .ANY (&lt;/span&gt;+&lt;span&gt;RO)
    }
    

    RW_IRAM_DATA &lt;/span&gt;&lt;span&gt;0x20000000&lt;/span&gt; &lt;span&gt;0x00030000&lt;/span&gt;&lt;span&gt; {  ; RW data
    .ANY (&lt;/span&gt;+RW +&lt;span&gt;ZI)
    }
    
    
    ARM_LIB_STACK &lt;/span&gt;&lt;span&gt;0x20030000&lt;/span&gt; EMPTY -(&lt;span&gt;0x20030000&lt;/span&gt; -&lt;span&gt; ImageLimit(RW_IRAM_DATA))  ; Stack region growing down
    { }
   
   
    RW_ERAM &lt;/span&gt;&lt;span&gt;0xD0000000&lt;/span&gt; &lt;span&gt;0x00800000&lt;/span&gt;&lt;span&gt; { ;Extern SDRAM
    main.o(&lt;/span&gt;+RW +&lt;span&gt;ZI)
    }
    
    ARM_LIB_HEAP &lt;/span&gt;+&lt;span&gt;0&lt;/span&gt; EMPTY  (&lt;span&gt;0xD0800000&lt;/span&gt; -&lt;span&gt; ImageLimit(RW_ERAM)) ; Heap region growing up
    { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 修改默认的启动文件startup_stm32f429_439xx.s&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;（1） Stack和Heap已经在Scatter文件中指定，故屏蔽startup_stm32f429_439xx.s中Stack和Heap的相关代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
;Stack_Size      EQU     &lt;span&gt;0x00000400&lt;/span&gt;&lt;span&gt;

                ;AREA    STACK, NOINIT, READWRITE, ALIGN&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
;Stack_Mem       SPACE   Stack_Size
;__initial_sp


;; &lt;/span&gt;&amp;lt;h&amp;gt;&lt;span&gt; Heap Configuration
;;   &lt;/span&gt;&amp;lt;o&amp;gt;  Heap Size (&lt;span&gt;in&lt;/span&gt; Bytes) &amp;lt;&lt;span&gt;0x0&lt;/span&gt;-&lt;span&gt;0xFFFFFFFF&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;&amp;gt;&lt;span&gt;
;; &lt;/span&gt;&amp;lt;/h&amp;gt;&lt;span&gt;

;Heap_Size       EQU     &lt;/span&gt;&lt;span&gt;0x00000200&lt;/span&gt;&lt;span&gt;

                ;AREA    HEAP, NOINIT, READWRITE, ALIGN&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
;__heap_base
;Heap_Mem        SPACE   Heap_Size
;__heap_limit

......

                 ;IF      :DEF:__MICROLIB
                
                 ;EXPORT  __initial_sp
                 ;EXPORT  __heap_base
                 ;EXPORT  __heap_limit
                
                 ;ELSE
                
                 ;IMPORT  __use_two_region_memory
                 ;EXPORT  __user_initial_stackheap
                 
;__user_initial_stackheap

                 ;LDR     R0, &lt;/span&gt;=&lt;span&gt;  Heap_Mem
                 ;LDR     R1, &lt;/span&gt;=(Stack_Mem +&lt;span&gt; Stack_Size)
                 ;LDR     R2, &lt;/span&gt;= (Heap_Mem +&lt;span&gt;  Heap_Size)
                 ;LDR     R3, &lt;/span&gt;=&lt;span&gt; Stack_Mem
                 ;BX      LR

                 ;ALIGN

                 ;ENDIF&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;（2） 把Scatter文件指定的Stack基地址赋给向量表的首地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.....
                IMPORT  &lt;/span&gt;|Image$$ARM_LIB_STACK$$Base|&lt;span&gt;
__Vectors       DCD     &lt;/span&gt;|Image$$ARM_LIB_STACK$$Base|&lt;span&gt;;__initial_sp               ; Top of Stack
.....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3） &lt;span class=&quot;Apple-tab-span&quot;&gt;因为Heap分配在外部SDRAM中，故在进入__main前需初始化SDRAM&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;....
        IMPORT  SystemInit
        IMPORT  SDRAM_Init
        IMPORT  __main

                 LDR     R0, &lt;/span&gt;=&lt;span&gt;SystemInit
                 BLX     R0
                 LDR     R0, &lt;/span&gt;=&lt;span&gt;SDRAM_Init
                 BLX     R0
                 LDR     R0, &lt;/span&gt;=&lt;span&gt;__main
                 BX      R0
                 ENDP
....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 6.测试代码&lt;/h2&gt;
&lt;p&gt;　　之前Windows平台下的测试例程是直接读取PNG格式的二维码，在STM32F429平台下没有移植文件系统和PNG解码库，为了简单起见，直接把待&lt;/p&gt;
&lt;p&gt;测试的二维码图片转换为二值化数组，然后把该该数组传给ZBar。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type_define.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;usart.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sdram.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
 #include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zbar.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;280X280的二维码图片灰度值数组&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; uint8_t image_data_buf[] =&lt;span&gt; {
.......
};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Zbar_Test(&lt;span&gt;void&lt;/span&gt;* raw, &lt;span&gt;int&lt;/span&gt; width, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; height)
{
      zbar_image_scanner_t &lt;/span&gt;*scanner =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; create a reader &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    scanner &lt;/span&gt;=&lt;span&gt; zbar_image_scanner_create();

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; configure the reader &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    zbar_image_scanner_set_config(scanner, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, ZBAR_CFG_ENABLE, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; obtain image data &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int width = 0, height = 0;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;void *raw = NULL;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get_data(&quot;barcode.png&quot;, &amp;amp;width, &amp;amp;height, &amp;amp;raw);&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; wrap image data &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    zbar_image_t &lt;/span&gt;*image =&lt;span&gt; zbar_image_create();
    zbar_image_set_format(image, &lt;/span&gt;*(&lt;span&gt;int&lt;/span&gt;*)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y800&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    zbar_image_set_size(image, width, height);
    zbar_image_set_data(image, raw, width &lt;/span&gt;*&lt;span&gt; height, zbar_image_free_data);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; scan the image for barcodes &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; zbar_scan_image(scanner, image);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; extract results &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; zbar_symbol_t *symbol =&lt;span&gt; zbar_image_first_symbol(image);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(; symbol; symbol =&lt;span&gt; zbar_symbol_next(symbol)) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; do something useful with results &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        zbar_symbol_type_t typ &lt;/span&gt;=&lt;span&gt; zbar_symbol_get_type(symbol);
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *data =&lt;span&gt; zbar_symbol_get_data(symbol);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;decoded %s symbol \&quot;%s\&quot;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               zbar_get_symbol_name(typ), data);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;len = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strlen(data));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k=&lt;span&gt;0&lt;/span&gt;; k&amp;lt;strlen(data); k++&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%X &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, (uint8_t)data[k]);
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; clean up &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    zbar_image_destroy(image);
    zbar_image_scanner_destroy(scanner);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}      

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{    
    Usart_Init();   
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello CJS\r\n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);    
    Zbar_Test((&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* )image_data_buf,&lt;span&gt;280&lt;/span&gt;,&lt;span&gt;280&lt;/span&gt;&lt;span&gt;);    
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    { 
    
    }
　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.运行结果&lt;/h2&gt;
&lt;p&gt;编译下载到STM32F429后，运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333201/201802/1333201-20180221164531423-2009914334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到此，ZBar已经能正常在STM32F429上运行了，但有点小问题，如上图，会检测到decoded I2/5 symbol &quot;&quot;，原因未知。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 08:51:00 +0000</pubDate>
<dc:creator>非正式码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/greyorbit/p/8456814.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 XV——RecyclerView - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/8456508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/8456508.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上文我们很详细的分析了ListView的使用、优化、及ListView的RecycleBin机制，读者如果对ListView不太清楚，那么请参看我的上篇博文。不过呢，Google Material Design提供的RecyclerView已经逐渐的取代ListView。RecyclerView提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。&lt;/p&gt;
&lt;p&gt;如果说上面的理由只是大而空泛的话，那我们来看以下场景&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你想控制数据的显示方式，列表显示、网格显示、瀑布流显示等等，之前你需要ListView,GridView和自定义View，而现在你可以通过RecyclerView的布局管理器LayoutManager控制&lt;/li&gt;
&lt;li&gt;你想要控制Item间的间隔（可绘制），想自定义更多样式的分割线，之前你可以设置divider,那么现在你可以使用RecyclerView的ItemDecoration，想怎么画怎么画。&lt;/li&gt;
&lt;li&gt;你想要控制Item增删的动画，ListView呢我们只能自己通过属性动画来操作 Item 的视图。RecyclerView可使用ItemAnimator&lt;/li&gt;
&lt;li&gt;你想要局部刷新某个Item,对于ListView来说，我们知道notifyDataSetChanged 来通知视图更新变化，但是该方法会重绘每个Item，而对于RecyclerView.Adapter 则提供了 notifyItemChanged 用于更新单个 Item View 的刷新，我们可以省去自己写局部更新的工作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除了上述场景外，RecyclerView强制使用了ViewHolder模式，我们知道ListView使用ViewHolder来进行性能优化，但是这不是必须得，但是在RecyclerView中是必须的，另外RecyclerView还有许多优势，这里就不一一列举了，总体来说现在越来越多的项目使用RecyclerView,许多老旧项目也渐渐使用RecyclerView来替代ListView。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：当我们想要一个列表显示控件的时候，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其他情况下ListView在使用上反而更加方便，快捷。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前言我们就讲到这，那么我们来进入正题。&lt;/p&gt;

&lt;p&gt;作为一个“新”控件，RecyclerView的使用有许多需要注意的地方&lt;/p&gt;
&lt;h2 id=&quot;recyclerview的简单使用&quot;&gt;RecyclerView的简单使用&lt;/h2&gt;
&lt;p&gt;一样的我们新建一个Demo来演示RecyclerView的使用&lt;/p&gt;
&lt;p&gt;[RecyclerViewDemo1Activity.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RecyclerViewDemo1Activity extends AppCompatActivity {
    @BindView(R.id.recycler_view)
    RecyclerView mRecyclerView;

    private List&amp;lt;String&amp;gt; mData;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_recycler_demo1_view);
        ButterKnife.bind(this);

        //LayoutManager必须指定，否则无法显示数据,这里指定为线性布局，
        mRecyclerView.setLayoutManager(new LinearLayoutManager(this));
        //虚拟数据
        mData = createDataList();
        //设置Adapter必须指定，否则数据怎么显示
        mRecyclerView.setAdapter(new RecyclerViewDemo1Adapter(mData));
    }

    protected List&amp;lt;String&amp;gt; createDataList() {
        mData = new ArrayList&amp;lt;&amp;gt;();
        for (int i=0;i&amp;lt;20;i++){
            mData.add(&quot;这是第&quot;+i+&quot;个View&quot;);
        }
        return mData;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其对应的布局文件也很简单activity_recycler_demo1_view.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    &amp;gt;

    &amp;lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/recycler_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        &amp;gt;
    &amp;lt;/android.support.v7.widget.RecyclerView&amp;gt;


&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们再来看RecyclerViewDemo1Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 与ListView的Adapter不同，RecyclerView的Adapter需要继承RecyclerView.Adapter&amp;lt;VH&amp;gt;(VH是ViewHolder的类名)
 * 记为RecyclerViewDemo1Adapter。
 * 创建ViewHolder：在RecyclerViewDemo1Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，记为ViewHolder
 * (RecyclerView必须使用ViewHolder模式，这里的ViewHolder实现几乎与ListView优化时所使用的ViewHolder一致)
 * 在RecyclerViewDemo1Adapter中实现：
 *      ViewHolder onCreateViewHolder(ViewGroup parent, int viewType): 映射Item Layout Id，创建VH并返回。
 *      
 *      void onBindViewHolder(ViewHolder holder, int position): 为holder设置指定数据。
 *      
 *      int getItemCount(): 返回Item的个数。
 *      
 * 可以看出，RecyclerView将ListView中getView()的功能拆分成了onCreateViewHolder()和onBindViewHolder()。
 */
public class RecyclerViewDemo1Adapter extends RecyclerView.Adapter&amp;lt;RecyclerViewDemo1Adapter.ViewHolder&amp;gt; {

    private List&amp;lt;String&amp;gt; mData;

    public RecyclerViewDemo1Adapter(List&amp;lt;String&amp;gt; data) {
        this.mData = data;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater
                    .from(parent.getContext())
                    .inflate(R.layout.item_menu_main, parent, false);

        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        holder.setData(this.mData.get(position));
        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //item点击事件
            }
        });
    }

    @Override
    public int getItemCount() {
        return this.mData != null ? this.mData.size() : 0;
    }

    static class ViewHolder extends RecyclerView.ViewHolder{
        private TextView mTextView;
        public ViewHolder(View itemView) {
            super(itemView);
            mTextView = (TextView) itemView.findViewById(R.id.tv_title);
        }

        public void setData(String title) {
            this.mTextView.setText(title);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是RecyclerView没有提供如ListView的setOnItemClickListener或者setOnItemLongClickListener之类的Item点击事件，我们必须自己去实现该部分功能，实现的方法有很多种，也比较容易，本例中采用在Adapter中BindViewHolder绑定数据的时候为item设置了点击事件。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;RecyclerView的四大组成分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Adapter：为Item提供数据。必须提供,关于Adapter我们上面的代码注释已经说的很明白了&lt;/li&gt;
&lt;li&gt;Layout Manager：Item的布局。必须提供,我们需要为RecyclerView指定一个布局管理器&lt;/li&gt;
&lt;li&gt;Item Animator：添加、删除Item动画。可选提供，默认是DefaultItemAnimator&lt;/li&gt;
&lt;li&gt;Item Decoration：Item之间的Divider。可选提供，默认是空&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以上面代码的运行结果看起来像是是一个没有分割线的ListView&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/SvrSBvp.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;recyclerview的进阶使用&quot;&gt;RecyclerView的进阶使用&lt;/h2&gt;
&lt;p&gt;上面的基本使用我们是会了，而且点击Item也有反应了，不过巨丑无比啊有木有。起码的分割线都没有，真无语&lt;/p&gt;
&lt;h3 id=&quot;为recyclerview添加分割线&quot;&gt;为RecyclerView添加分割线&lt;/h3&gt;
&lt;p&gt;那么如何创建分割线呢，&lt;br/&gt;创建一个类并继承RecyclerView.ItemDecoration，重写以下两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onDraw()或者onDrawOver: 绘制分割线。&lt;/li&gt;
&lt;li&gt;getItemOffsets(): 设置分割线的宽、高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后使用RecyclerView通过addItemDecoration()方法添加item之间的分割线。&lt;br/&gt;我们来看一下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RecyclerViewDemo2Activity extends AppCompatActivity {
    @BindView(R.id.recycler_view)
    RecyclerView mRecyclerView;

    private List&amp;lt;String&amp;gt; mData;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_recycler_demo1_view);
        ButterKnife.bind(this);

        //LayoutManager必须指定，否则无法显示数据,这里指定为线性布局，
        mRecyclerView.setLayoutManager(new LinearLayoutManager(this));

        //虚拟数据
        mData = createDataList();

        //设置Adapter必须指定，否则数据怎么显示
        mRecyclerView.setAdapter(new RecyclerViewDemo2Adapter(mData));

        //设置分割线
        mRecyclerView.addItemDecoration(
            new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));
    }

    protected List&amp;lt;String&amp;gt; createDataList() {
        mData = new ArrayList&amp;lt;&amp;gt;();
        for (int i=0;i&amp;lt;20;i++){
            mData.add(&quot;这是第&quot;+i+&quot;个View&quot;);
        }
        return mData;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;布局文件还跟上面的一致，代码也大致相同，不过我们多了一行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置分割线
mRecyclerView.addItemDecoration(
    new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的DividerItemDecoration是Google给了一个参考的实现类，这里我们通过分析这个例子来看如何自定义Item Decoration。&lt;/p&gt;
&lt;p&gt;[DividerItemDecoration.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DividerItemDecoration extends RecyclerView.ItemDecoration {
    public static final int HORIZONTAL = LinearLayout.HORIZONTAL;
    public static final int VERTICAL = LinearLayout.VERTICAL;

    private static final int[] ATTRS = new int[]{ android.R.attr.listDivider };

    private Drawable mDivider;

  
    private int mOrientation;

    private final Rect mBounds = new Rect();

    /**
     * 创建一个可使用于LinearLayoutManager的分割线
     *
     */
    public DividerItemDecoration(Context context, int orientation) {
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
        setOrientation(orientation);
    }



    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        if (parent.getLayoutManager() == null) {
            return;
        }
        if (mOrientation == VERTICAL) {
            drawVertical(c, parent);
        } else {
            drawHorizontal(c, parent);
        }
    }

    @SuppressLint(&quot;NewApi&quot;)
    private void drawVertical(Canvas canvas, RecyclerView parent) {
        canvas.save();
        final int left;
        final int right;
        if (parent.getClipToPadding()) {
            left = parent.getPaddingLeft();
            right = parent.getWidth() - parent.getPaddingRight();
            canvas.clipRect(left, parent.getPaddingTop(), right,
                    parent.getHeight() - parent.getPaddingBottom());
        } else {
            left = 0;
            right = parent.getWidth();
        }

        final int childCount = parent.getChildCount();
        for (int i = 0; i &amp;lt; childCount; i++) {
            final View child = parent.getChildAt(i);
            parent.getDecoratedBoundsWithMargins(child, mBounds);
            final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
            final int top = bottom - mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(canvas);
        }
        canvas.restore();
    }


    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
            RecyclerView.State state) {
        if (mOrientation == VERTICAL) {
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
        } else {
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看构造函数，构造函数中获得系统属性android:listDivider，该属性是一个Drawable对象。接着设置mOrientation,我们这里传入的是DividerItemDecoration.VERTICAL。&lt;/p&gt;
&lt;p&gt;上面我们就说了如何添加分割线，那么作为实例，我们先看DividerItemDecoration的getItemOffsets方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
        RecyclerView.State state) {
    if (mOrientation == VERTICAL) {
        outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
    } else {
        outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;outRect是当前item四周的间距，类似margin属性，现在设置了该item下间距为mDivider.getIntrinsicHeight()。&lt;/p&gt;
&lt;p&gt;那么getItemOffsets()是怎么被调用的呢？&lt;/p&gt;
&lt;p&gt;RecyclerView继承了ViewGroup，并重写了measureChild()，该方法在onMeasure()中被调用，用来计算每个child的大小，计算每个child大小的时候就需要加上getItemOffsets()设置的外间距：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void measureChild(View child, int widthUsed, int heightUsed) {
    final LayoutParams lp = (LayoutParams) child.getLayoutParams();

    final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
    widthUsed += insets.left + insets.right;
    heightUsed += insets.top + insets.bottom;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;也就是说getItemOffsets()方法是确定分割线的大小的(这个大小指的是高度，宽度)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么接着onDraw()以及onDrawOver()，两者的作用是什么呢以及两者之间有什么关系呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RecyclerView extends ViewGroup {
    @Override
    public void draw(Canvas c) {
        super.draw(c);

        final int count = mItemDecorations.size();
        
        for (int i = 0; i &amp;lt; count; i++) {
            mItemDecorations.get(i).onDrawOver(c, this, mState);
        }
        ......
    }

    @Override
    public void onDraw(Canvas c) {
        super.onDraw(c);

        final int count = mItemDecorations.size();
        for (int i = 0; i &amp;lt; count; i++) {
            mItemDecorations.get(i).onDraw(c, this, mState);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;根据View的绘制流程，首先调用RecyclerView重写的draw()方法，随后super.draw()即调用View的draw()，该方法会先调用onDraw()（这个方法在RecyclerView重写了），再调用dispatchDraw()绘制children。因此：ItemDecoration的onDraw()在绘制Item之前调用，ItemDecoration的onDrawOver()在绘制Item之后调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在RecyclerView的onDraw()方法中会得到分割线的数目，并循环调用其onDraw()方法，我们再来看分割线实例DividerItemDecoration的onDraw()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
    if (parent.getLayoutManager() == null) {
        return;
    }
    if (mOrientation == VERTICAL) {
        drawVertical(c, parent);
    } else {
        drawHorizontal(c, parent);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用了drawVertical&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SuppressLint(&quot;NewApi&quot;)
private void drawVertical(Canvas canvas, RecyclerView parent) {
    canvas.save();
    final int left;
    final int right;
    if (parent.getClipToPadding()) {
        left = parent.getPaddingLeft();
        right = parent.getWidth() - parent.getPaddingRight();
        canvas.clipRect(left, parent.getPaddingTop(), right,
                parent.getHeight() - parent.getPaddingBottom());
    } else {
        left = 0;
        right = parent.getWidth();
    }

    final int childCount = parent.getChildCount();
    for (int i = 0; i &amp;lt; childCount; i++) {
        final View child = parent.getChildAt(i);
        parent.getDecoratedBoundsWithMargins(child, mBounds);
        final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
        final int top = bottom - mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);
        mDivider.draw(canvas);
    }
    canvas.restore();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;drawVertical的逻辑比较简单，重要的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //为分割线设置bounds
 mDivider.setBounds(left, top, right, bottom);
 //画出来
 mDivider.draw(canvas);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结-1&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;在RecyclerView中添加分割线需要的操作已经在上文中比较详细的说明了，这里再总结一下。我们在为RecyclerView添加分割线的时候使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置分割线
mRecyclerView.addItemDecoration(
    new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中addItemDecoration方法的参数即为分割线的实例，那么如何创建分割线呢，&lt;br/&gt;创建一个类并继承RecyclerView.ItemDecoration，重写以下两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onDraw()或者onDrawOver: 绘制分割线。&lt;/li&gt;
&lt;li&gt;getItemOffsets(): 设置分割线的宽、高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;基本功能设计&quot;&gt;基本功能设计&lt;/h4&gt;
&lt;p&gt;RecyclerView没有提供类似ListView的addHeaderView或者addFooterView方法，所以我们要自己实现。关于实现的方法也有很多种。目前网上能搜到的主流解决办法是在Adapter中重写getItemViewType方法为头部或者底部布局生成特定的item。从而实现头部布局以及底部布局。&lt;/p&gt;
&lt;p&gt;本篇的解决办法与上面的并无本质上的不同，只是我们在Adapter的外面再包上一层，以类似装饰者设计模式的方式对Adapter进行无侵入式的包装。&lt;/p&gt;
&lt;p&gt;我们希望使用的方式比较简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//这个是真正的Adapter，在本例中不需要对其改变
mAdapter = new RecyclerViewDemo2Adapter(mData);
//包装的wrapper，对Adapter进行包装。实现添加Header以及Footer等的功能
mHeaderAndFooterWrapper = new HeaderAndFooterWrapper(mAdapter);

TextView t1 = new TextView(this);
t1.setText(&quot;Header 1&quot;);
TextView t2 = new TextView(this);
t2.setText(&quot;Header 2&quot;);
mHeaderAndFooterWrapper.addHeaderView(t1);
mHeaderAndFooterWrapper.addHeaderView(t2);

mRecyclerView.setAdapter(mHeaderAndFooterWrapper);
mHeaderAndFooterWrapper.notifyDataSetChanged();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们下面先对HeaderAndFooterWrapper基本功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HeaderAndFooterWrapper&amp;lt;T&amp;gt; extends RecyclerView.Adapter&amp;lt;RecyclerView.ViewHolder&amp;gt;
{
    //以较高的数值作为基数，每一个Header或者Footer对应不同的数值
    private static final int BASE_ITEM_TYPE_HEADER = 100000;
    private static final int BASE_ITEM_TYPE_FOOTER = 200000;
    
    //存储Header和Footer的集合
    private SparseArrayCompat&amp;lt;View&amp;gt; mHeaderViews = new SparseArrayCompat&amp;lt;&amp;gt;();
    private SparseArrayCompat&amp;lt;View&amp;gt; mFootViews = new SparseArrayCompat&amp;lt;&amp;gt;();
    
    //内部的真正的Adapter
    private RecyclerView.Adapter mInnerAdapter;

    public HeaderAndFooterWrapper(RecyclerView.Adapter adapter)
    {
        mInnerAdapter = adapter;
    }

    private boolean isHeaderViewPos(int position)
    {
        return position &amp;lt; getHeadersCount();
    }

    private boolean isFooterViewPos(int position)
    {
        return position &amp;gt;= getHeadersCount() + getRealItemCount();
    }

    
    public void addHeaderView(View view)
    {
        mHeaderViews.put(mHeaderViews.size() + BASE_ITEM_TYPE_HEADER, view);
    }

    public void addFootView(View view)
    {
        mFootViews.put(mFootViews.size() + BASE_ITEM_TYPE_FOOTER, view);
    }

    public int getHeadersCount()
    {
        return mHeaderViews.size();
    }

    public int getFootersCount()
    {
        return mFootViews.size();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里使用SparseArrayCompat作为存储Header和Footer的集合，SparseArrayCompat有什么特点呢？它类似于Map，只不过在某些情况下比Map的性能要好，并且只能存储key为int的情况。&lt;/p&gt;
&lt;p&gt;我们这里可以看到HeaderAndFooterWrapper是继承于RecyclerView.Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//真正进行数据处理以及展示的Adapter
mAdapter = new RecyclerViewDemo2Adapter(mData);
//添加Header以及Footer的wrapper
mHeaderAndFooterWrapper = new HeaderAndFooterWrapper(mAdapter);
//设置空View的wrapper
mEmptyWrapperAdapter = new EmptyWrapper(mHeaderAndFooterWrapper);

mRecyclerView.setAdapter(mEmptyWrapperAdapter);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重写相关方法&quot;&gt;重写相关方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    public class HeaderAndFooterWrapper&amp;lt;T&amp;gt; extends 
        RecyclerView.Adapter&amp;lt;RecyclerView.ViewHolder&amp;gt;
{
    private static final int BASE_ITEM_TYPE_HEADER = 100000;
    private static final int BASE_ITEM_TYPE_FOOTER = 200000;
    //SparseArrayCompat类似于Map，其用法与map相似
    private SparseArrayCompat&amp;lt;View&amp;gt; mHeaderViews = new SparseArrayCompat&amp;lt;&amp;gt;();
    private SparseArrayCompat&amp;lt;View&amp;gt; mFootViews = new SparseArrayCompat&amp;lt;&amp;gt;();

    private RecyclerView.Adapter mInnerAdapter;

    public HeaderAndFooterWrapper(RecyclerView.Adapter adapter)
    {
        mInnerAdapter = adapter;
    }

    /**
     * 重写onCreateViewHolder，创建ViewHolder
     * @param parent 父容器，这里指的是RecyclerView
     * @param viewType view的类型，用int表示，也是SparseArrayCompat的key
     * @return
     */
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
    {
        if (mHeaderViews.get(viewType) != null)
        {//如果以viewType为key获取的View为null

            //创建ViewHolder并返回
            ViewHolder holder = new ViewHolder(parent.getContext(), mHeaderViews.get(viewType));
            return holder;

        } else if (mFootViews.get(viewType) != null)
        {
            ViewHolder holder =  new ViewHolder(parent.getContext(), mFootViews.get(viewType));
            return holder;
        }
        return mInnerAdapter.onCreateViewHolder(parent, viewType);
    }

    /**
     * 获得对应position的type
     * @param position
     * @return
     */
    @Override
    public int getItemViewType(int position)
    {
        if (isHeaderViewPos(position))
        {
            return mHeaderViews.keyAt(position);
        } else if (isFooterViewPos(position))
        {
            return mFootViews.keyAt(position - getHeadersCount() - getRealItemCount());
        }
        return mInnerAdapter.getItemViewType(position - getHeadersCount());
    }

    private int getRealItemCount()
    {
        return mInnerAdapter.getItemCount();
    }

    /**
     * 绑定数据
     * @param holder
     * @param position
     */
    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)
    {
        if (isHeaderViewPos(position))
        {
            return;
        }
        if (isFooterViewPos(position))
        {
            return;
        }
        mInnerAdapter.onBindViewHolder(holder, position - getHeadersCount());
    }

    /**
     * 得到item数量 (包括头部布局数量和尾部布局数量)
     * @return
     */
    @Override
    public int getItemCount()
    {
        return getHeadersCount() + getFootersCount() + getRealItemCount();
    }


    private boolean isHeaderViewPos(int position)
    {
        return position &amp;lt; getHeadersCount();
    }

    private boolean isFooterViewPos(int position)
    {
        return position &amp;gt;= getHeadersCount() + getRealItemCount();
    }

    /**
    *以mHeaderViews.size() + BASE_ITEM_TYPE_HEADER为key，头部布局View为Value
    *放入mHeaderViews
    */
    public void addHeaderView(View view)
    {
        mHeaderViews.put(mHeaderViews.size() + BASE_ITEM_TYPE_HEADER, view);
    }

    public void addFootView(View view)
    {
        mFootViews.put(mFootViews.size() + BASE_ITEM_TYPE_FOOTER, view);
    }

    public int getHeadersCount()
    {
        return mHeaderViews.size();
    }

    public int getFootersCount()
    {
        return mFootViews.size();
    }

    class ViewHolder extends RecyclerView.ViewHolder {
        private View mConvertView;
        private Context mContext;

        public ViewHolder(Context context, View itemView) {
            super(itemView);
            mContext = context;
            mConvertView = itemView;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面的代码，HeaderAndFooterWrapper继承于RecyclerView.Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 重写onCreateViewHolder，创建ViewHolder
 * @param parent 父容器，这里指的是RecyclerView
 * @param viewType view的类型，用int表示，也是SparseArrayCompat的key
 * @return
 */
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
{
    if (mHeaderViews.get(viewType) != null)
    {//如果以viewType为key获取的View为null

        //创建ViewHolder并返回
        ViewHolder holder = new ViewHolder(parent.getContext(), mHeaderViews.get(viewType));
        return holder;

    } else if (mFootViews.get(viewType) != null)
    {
        ViewHolder holder =  new ViewHolder(parent.getContext(), mFootViews.get(viewType));
        return holder;
    }
    return mInnerAdapter.onCreateViewHolder(parent, viewType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看onCreateViewHolder方法，该方法返回ViewHolder,我们在其中为头部以及底部布局单独创建ViewHolder，对于普通的item，我们依然调用内部的mInnerAdapter的onCreateViewHolder方法&lt;/p&gt;
&lt;p&gt;创建好ViewHolder后，便进行绑定的工作了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 绑定数据
 * @param holder
 * @param position
 */
@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)
{
    if (isHeaderViewPos(position))
    {
        return;
    }
    if (isFooterViewPos(position))
    {
        return;
    }
    mInnerAdapter.onBindViewHolder(holder, position - getHeadersCount());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们头部以及底部布局不进行数据的绑定，其他普通的item依然调用内部真正的mInnerAdapter.onBindViewHolder&lt;/p&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wtFuQho.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;适配gridlayoutmanager&quot;&gt;适配GridLayoutManager&lt;/h4&gt;
&lt;p&gt;上面我们已经初步实现为RecyclerView添加Header以及Footer了，不过上面的我们的布局模式是LinearyLayoutManager，当我们使用GridLayoutManager时，效果就不是我们所想像的那样了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置GridLayoutManager
mRecyclerView.setLayoutManager(new GridLayoutManager(this,3));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ZtqmvMZ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们设置GridLayoutManager时，可以看到头部布局所展示的样子，头部布局还真的被当做一个普通的item布局了。那么我们需要为这个布局做一些特殊处理。我们知道使用GridLayoutManager的SpanSizeLookup设置某个Item所占空间&lt;/p&gt;
&lt;p&gt;在我们的HeaderAndFooterWrapper中重写onAttachedToRecyclerView方法（该方法在Adapter与RecyclerView相关联时回调），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onAttachedToRecyclerView(RecyclerView recyclerView)
{
    mInnerAdapter.onAttachedToRecyclerView(recyclerView);

    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
    if (layoutManager instanceof GridLayoutManager)
    {
        final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;
        final GridLayoutManager.SpanSizeLookup spanSizeLookup = gridLayoutManager.getSpanSizeLookup();

        gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup()
        {
            @Override
            public int getSpanSize(int position)
            {
               int viewType = getItemViewType(position);
              if (mHeaderViews.get(viewType) != null)
              {
                  return layoutManager.getSpanCount();
              } else if (mFootViews.get(viewType) != null)
              {
                  return layoutManager.getSpanCount();
              }
              if (spanSizeLookup != null)
                  return spanSizeLookup.getSpanSize(position);
              return 1;
            }
        });
        gridLayoutManager.setSpanCount(gridLayoutManager.getSpanCount());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当发现layoutManager为GridLayoutManager时，通过设置SpanSizeLookup，对其getSpanSize方法，返回值设置为layoutManager.getSpanCount();&lt;/p&gt;
&lt;h4 id=&quot;适配staggeredgridlayoutmanager&quot;&gt;适配StaggeredGridLayoutManager&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(3, 
    OrientationHelper.VERTICAL));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们设置StaggeredGridLayoutManager时，可以看到如下效果&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/SfE3dZ5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而针对于StaggeredGridLayoutManager，我们需要使用 StaggeredGridLayoutManager.LayoutParams&lt;/p&gt;
&lt;p&gt;在我们的HeaderAndFooterWrapper中重写onViewAttachedToWindow方法（该方法在Adapter与RecyclerView相关联时回调），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onViewAttachedToWindow(RecyclerView.ViewHolder holder)
{
    mInnerAdapter.onViewAttachedToWindow(holder);
    int position = holder.getLayoutPosition();
    if (isHeaderViewPos(position) || isFooterViewPos(position))
    {
         ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();

        if (lp != null
                &amp;amp;&amp;amp; lp instanceof StaggeredGridLayoutManager.LayoutParams)
        {

            StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) lp;

            p.setFullSpan(true);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为recyclerview设置emptyview&quot;&gt;为RecyclerView设置EmptyView&lt;/h3&gt;
&lt;p&gt;上面已经详细给出了为RecyclerView添加Header以及Footer的例子，关于EmptyView的实现方法与上面基本类似，读者可自行实现，当然在本篇末会给出完整的源码地址。&lt;/p&gt;

&lt;p&gt;RecyclerView和ListView的回收机制非常相似，但是ListView是以View作为单位进行回收，RecyclerView是以ViewHolder作为单位进行回收。相比于ListView，RecyclerView的回收机制更为完善&lt;/p&gt;
&lt;p&gt;Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mAttachedScrap: 缓存在屏幕上的ViewHolder。&lt;/li&gt;
&lt;li&gt;mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用getView()。&lt;/li&gt;
&lt;li&gt;mViewCacheExtensions: 需要用户定制，默认不实现。&lt;/li&gt;
&lt;li&gt;mRecyclerPool: 缓存池，多个RecyclerView共用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想理解RecyclerView的回收机制，我们就必须从其数据展示谈起，我们都知道RecyclerView使用LayoutManager管理其数据布局的显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：以下源码来自support-v7 25.4.0&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;recyclerviewlayoutmanager&quot;&gt;RecyclerView$LayoutManager&lt;/h2&gt;
&lt;p&gt;LayoutManager是RecyclerView下的一个抽象类，Google提供了LinearLayoutManager,GridLayoutManager以及StaggeredGridLayoutManager基本上能满足大部分开发者的需求。这三个类的代码都非常长，这要分析下来可了不得。本篇文章只分析LinearLayoutManager的一部分内容&lt;/p&gt;
&lt;p&gt;与分析ListView时类似，RecyclerView作为一个ViewGroup，肯定也跑不了那几大过程，我们依然还是只分析其layout过程&lt;/p&gt;
&lt;p&gt;[RecyclerView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
    dispatchLayout();
    TraceCompat.endSection();
    mFirstLayoutComplete = true;
}

void dispatchLayout() {
    if (mAdapter == null) {
        Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);
        // leave the state in START
        return;
    }
    if (mLayout == null) {
        Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);
        // leave the state in START
        return;
    }
    mState.mIsMeasuring = false;
    if (mState.mLayoutStep == State.STEP_START) {
        //1 没有执行过布局流程的情况
        dispatchLayoutStep1();
        mLayout.setExactMeasureSpecsFrom(this);
        dispatchLayoutStep2();
    } else if (mAdapterHelper.hasUpdates() 
        || mLayout.getWidth() != getWidth() ||
            mLayout.getHeight() != getHeight()) {
        //2 执行过布局流程，但是之后size又有变化的情况
        mLayout.setExactMeasureSpecsFrom(this);
        dispatchLayoutStep2();
    } else {
        //3 执行过布局流程，可以直接使用之前数据的情况
        mLayout.setExactMeasureSpecsFrom(this);
    }
    dispatchLayoutStep3();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，无论什么情况，最终都是完成dispatchLayoutStep1，dispatchLayoutStep2和dispatchLayoutStep3这三步，这样的情况区分只是为了避免重复计算。&lt;/p&gt;
&lt;p&gt;其中第二步的dispatchLayoutStep2是真正的布局!&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void dispatchLayoutStep2() {
    ...... // 设置状态
    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作
    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager
    mLayout.onLayoutChildren(mRecycler, mState);
    ......// 设置和恢复状态
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上面的代码可以知道布局的具体操作都交给了具体的LayoutManager,那我们来分析其中的LinearLayoutManager&lt;/p&gt;
&lt;p&gt;[LinearLayoutManager.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
*LinearLayoutManager的onLayoutChildren方法代码也比较多，这里也不进行逐行分析
*只来看关键的几个点
*/
@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, 
                                RecyclerView.State state) {
    
    ......
    //状态判断以及一些准备操作
    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
    /**
    *1 感觉这个函数应该跟上一篇我们所分析的ListView的detachAllViewsFromParent();有点像
    */
    detachAndScrapAttachedViews(recycler);
    ......
    //2 感觉这个函数跟上一篇我们所分析的ListView的fillUp有点像
    fill(recycler, mLayoutState, state, false);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面已经给出了真正布局的代码。我们还是按照上一篇的思路来分析，两次layout&lt;/p&gt;
&lt;h3 id=&quot;第1次layout&quot;&gt;第1次layout&lt;/h3&gt;
&lt;h4 id=&quot;第1个重要函数&quot;&gt;第1个重要函数&lt;/h4&gt;
&lt;p&gt;[RecyclerView$LayoutManager]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     *暂时detach和scrap所有当前附加的子视图。视图将被丢弃到给定的回收器中（即参数recycler）。
    *回收器(即Recycler)可能更喜欢重用scrap的视图。
     *
     * @param recycler 指定的回收器Recycler
     */
    public void detachAndScrapAttachedViews(Recycler recycler) {
        final int childCount = getChildCount();
        for (int i = childCount - 1; i &amp;gt;= 0; i--) {
            final View v = getChildAt(i);
            scrapOrRecycleView(recycler, i, v);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第1次layout时，RecyclerView并没有Child,所以跳过该函数，不过我们从上面的代码注释也知道了该函数跟缓存Recycler有关&lt;/p&gt;
&lt;h4 id=&quot;第2个重要函数&quot;&gt;第2个重要函数&lt;/h4&gt;
&lt;p&gt;[LinearLayoutManager.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
        RecyclerView.State state, boolean stopOnFocusable) {
    ......
    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
    while ((layoutState.mInfinite || remainingSpace &amp;gt; 0) 
            &amp;amp;&amp;amp; layoutState.hasMore(state)) {//这里循环判断是否还有空间放置item
        ......
        //真正放置的代码放到了这里
        layoutChunk(recycler, state, layoutState, layoutChunkResult);
        ......
    }
    if (DEBUG) {
        validateChildOrder();
    }
    return start - layoutState.mAvailable;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进layoutChunk&lt;/p&gt;
&lt;p&gt;[LinearLayoutManager.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
        LayoutState layoutState, LayoutChunkResult result) {
    /**
    *获取一个View，这个函数应该是重点了，
    */
    View view = layoutState.next(recycler);
    ......
    //添加View
    addView(view);
    ......
    //计算View的大小
    measureChildWithMargins(view, 0, 0);
    ......
    //布局
    layoutDecoratedWithMargins(view, left, top, right, bottom);
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进next()&lt;/p&gt;
&lt;p&gt;[LinearLayoutManager$LayoutState]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;View next(RecyclerView.Recycler recycler) {
    if (mScrapList != null) {
        return nextViewFromScrapList();
    }
    final View view = recycler.getViewForPosition(mCurrentPosition);
    mCurrentPosition += mItemDirection;
    return view;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getViewForPosition方法可以说是RecyclerView中缓存策略最重要的方法，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，或者新创建一个View&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;View getViewForPosition(int position, boolean dryRun) {
    /**
    *从这个函数就能看出RecyclerView是以ViewHolder为缓存单位的些许端倪
    */
    return tryGetViewHolderForPositionByDeadline
    (position, dryRun, FOREVER_NS).itemView;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进tryGetViewHolderForPositionByDeadline&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *试图获得给定位置的ViewHolder，无论是从 
 *mAttachedScrap、mCachedViews、mViewCacheExtensions、mRecyclerPool、还是直接创建。
 *
 * @return ViewHolder for requested position
 */
@Nullable
ViewHolder tryGetViewHolderForPositionByDeadline(int position,
        boolean dryRun, long deadlineNs) {
    ......
    // 1) 尝试从mAttachedScrap获取
    if (holder == null) {
        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
        ......
    }

    if (holder == null) {
        ......
        final int type = mAdapter.getItemViewType(offsetPosition);
        // 2) 尝试从mCachedViews获取
        if (mAdapter.hasStableIds()) {
            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                    type, dryRun);
            if (holder != null) {
                // update position
                holder.mPosition = offsetPosition;
                fromScrapOrHiddenOrCache = true;
            }
        }
        
        // 3) 尝试从mViewCacheExtensions获取
        if (holder == null &amp;amp;&amp;amp; mViewCacheExtension != null) {
            ......
            final View view = mViewCacheExtension
                    .getViewForPositionAndType(this, position, type);
            if (view != null) {
                holder = getChildViewHolder(view);
                ......
            }
        }

        // 4) 尝试从mRecyclerPool获取
        if (holder == null) { // fallback to pool
           
            holder = getRecycledViewPool().getRecycledView(type);
            if (holder != null) {
                holder.resetInternal();
                if (FORCE_INVALIDATE_DISPLAY_LIST) {
                    invalidateDisplayListInt(holder);
                }
            }
        }
        if (holder == null) {
           // 5) 直接创建
            holder = mAdapter.createViewHolder(RecyclerView.this, type);
           
        }
    }

    ......
    // 6) 判断是否需要bindHolder
    if (!holder.isBound() 
        || holder.needsUpdate() 
        || holder.isInvalid()) {
            
            final int offsetPosition = mAdapterHelper.findPositionOffset(position);
            bound = tryBindViewHolderByDeadline
                (holder, offsetPosition, position, deadlineNs);
        }
    ......

    return holder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在第1次layout时，，前4步都不能获得ViewHolder，那么进入第5， 直接创建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;holder = mAdapter.createViewHolder(RecyclerView.this, type);

public final VH createViewHolder(ViewGroup parent, int viewType) {
    TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);
    //这里终于看到我们的亲人onCreateViewHolder
    final VH holder = onCreateViewHolder(parent, viewType);
    holder.mItemViewType = viewType;
    TraceCompat.endSection();
    return holder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个onCreateViewHolder正是在RecyclerViewDemo1Adapter中我们重写的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    Log.d(TAG,&quot;onCreateViewHolder-&amp;gt;viewtype&quot;+viewType);
    View view = LayoutInflater
                .from(parent.getContext())
                .inflate(R.layout.item_menu_main, parent, false);

    return new ViewHolder(view);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初次创建了ViewHolder之后，便进入6，导致我们重写的onBindViewHolder回调，数据与View绑定了&lt;/p&gt;
&lt;h3 id=&quot;第2次layout&quot;&gt;第2次layout&lt;/h3&gt;
&lt;p&gt;从上一篇ListView中我们就知道了再简单的View也至少需要两次Layout,在ListView中通过把屏幕的子View detach并加入mActivieViews，以避免重复添加item并可通过attach提高性能，那么在RecyclerView中，它的做法与ListView十分类似，RecyclerView也是通过detach子View，并把子View对应的ViewHolder加入其1级缓存mAttachedScrap。这部分我们就不详细分析了，读者可参照上一篇的步骤进行分析。&lt;/p&gt;
&lt;h2 id=&quot;recyclerview与listview-缓存机制对比分析&quot;&gt;RecyclerView与ListView 缓存机制对比分析&lt;/h2&gt;
&lt;p&gt;ListView和RecyclerView最大的区别在于数据源改变时的缓存的处理逻辑，ListView是”一锅端”，将所有的mActiveViews都移入了二级缓存mScrapViews，而RecyclerView则是更加灵活地对每个View修改标志位，区分是否重新bindView。&lt;/p&gt;
&lt;h2 id=&quot;小结-2&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异，&lt;strong&gt;但是在需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本篇呢，我们分析了RecyclerView的使用方法以及RecyclerView部分源码。目的是为了更好的掌握RecyclerView。&lt;/p&gt;
&lt;p&gt;这里呢再上图总结一下RecyclerView的layout流程&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;img src=&quot;https://i.imgur.com/zOZdPu3.png&quot;/&gt;&lt;/h2&gt;

&lt;p&gt;下篇呢，也是一篇干货，上面两篇文章，我们的数据都是虚拟的，静态的，而实际开发中数据通常都是从服务器动态获得的，这也产生了一系列问题，如&lt;strong&gt;列表的下拉刷新以及上拉加载、ListVIew异步获取图片显示错位等等问题&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/51854533&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/lmj623565791/article/details/51854533&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 05:11:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/8456508.html</dc:identifier>
</item>
<item>
<title>Python学习-使用opencv-python提取手掌和手心及部分掌纹 - take-fetter</title>
<link>http://www.cnblogs.com/take-fetter/p/8453589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/take-fetter/p/8453589.html</guid>
<description>&lt;p&gt;上次我们成功训练了手掌识别器http://www.cnblogs.com/take-fetter/p/8438747.html，可以成功得到识别的结果如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1317659/201802/1317659-20180219110044361-1863624034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来需要使用opencv来获取手掌，去除背景部分，这里就需要用到掩膜(mask)、ROI（region of interest）等相关知识,具体的概念还是不讲了,网上很多。&lt;/p&gt;
&lt;p&gt;首先从图中根据上次的程序画框部分提取手掌(当然自己截图再保存也可以-.-)如下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180220093247591-1495515910.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;接下来讲解一下提取手掌的方法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;将图片copy，并将图片转换为ycrcb模式，根据ycrcb中的肤色获取和手掌颜色相近的部分，生成黑白图片&lt;/li&gt;
&lt;li&gt;使用黑白图片获得最大的轮廓并生成轮廓图片并得到一个近似的椭圆&lt;/li&gt;
&lt;li&gt;根据椭圆角度进行旋转(原图片和黑白图片及轮廓图片同时旋转)以尽可能的将手掌放为竖直&lt;/li&gt;
&lt;li&gt;根据原图片和黑白图片，利用黑白图片作为掩膜，得到的原图片如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180220102028019-2087654852.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　提取手掌中心:&lt;/h2&gt;
&lt;p&gt;　　算法思想：根据黑白图片，基于距离变换得到手掌中心，并根据最大半径画出手掌的内切圆如图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221100651489-1345219202.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
 distance = cv2.distanceTransform(black_and_white, cv2.DIST_L2, 5&lt;span&gt;, cv2.CV_32F)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Calculates the distance to the closest zero pixel for each pixel of the source image.&lt;/span&gt;
    maxdist =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rows,cols = img.shape&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(distance.shape[0]):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(distance.shape[1&lt;span&gt;]):
            dist &lt;/span&gt;=&lt;span&gt; distance[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; maxdist &amp;lt;&lt;span&gt; dist:
                x &lt;/span&gt;=&lt;span&gt; j
                y &lt;/span&gt;=&lt;span&gt; i
                maxdist &lt;/span&gt;= dist
&lt;/pre&gt;
&lt;pre&gt;
 cv2.circle(original, (x, y), maxdist, (255, 100, 255), 1, 8, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 　　提取掌纹&lt;/h2&gt;
&lt;p&gt;　　　　现在我们已知了圆的半径和圆心坐标，因此可以根据ROI提取出内切正方形(虽然内切正方形会损失很多的信息，但是目前我还没有想到其他的更好的办法)，作出正方形如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221103009887-1501819522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作正方形并提取的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
final_img =&lt;span&gt; original.copy()&lt;br/&gt;#cv2.circle() this line 
half_slide &lt;/span&gt;= maxdist * math.cos(math.pi / 4&lt;span&gt;)
    (left, right, top, bottom) &lt;/span&gt;= ((x - half_slide), (x + half_slide), (y - half_slide), (y +&lt;span&gt; half_slide))
    p1 &lt;/span&gt;=&lt;span&gt; (int(left), int(top))
    p2 &lt;/span&gt;=&lt;span&gt; (int(right), int(bottom))
    cv2.rectangle(original, p1, p2, (&lt;/span&gt;77, 255, 9), 1, 1&lt;span&gt;)
    final_img &lt;/span&gt;= final_img[int(top):int(bottom),int(left):int(right)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221105014044-173895605.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到出现了灰色部分，按理说是不会存在的，使用cv2.imwrite发现没有出现任何问题，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221105114695-1136785976.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感觉是cv2.imshow对于输出图片的像素大小有一定限制,进行了自动填充或者是默认有灰色作为背景色且比在这里我们提取出的图片要大&lt;/p&gt;
&lt;p&gt;代码地址：https://github.com/takefetter/Get_PalmPrint/blob/master/process_palm.py&lt;/p&gt;
&lt;h2&gt;感谢：&lt;/h2&gt;
&lt;p&gt;1.https://github.com/dev-td7/Automatic-Hand-Detection-using-Wrist-localisation 这位老哥的repo，基于肤色的提取和形成近似椭圆给我的启发很大（虽然后半部分完全没有用.....）&lt;/p&gt;
&lt;p&gt;2.http://answers.opencv.org/question/180668/how-to-find-the-center-of-one-palm-in-the-picture/ 虽然基于距离变化参考至这里的回答，不过也算是完成了提问者的需求。&lt;/p&gt;
&lt;p&gt;转载请注明出处http://www.cnblogs.com/take-fetter/p/8453589.html&lt;/p&gt;

</description>
<pubDate>Wed, 21 Feb 2018 03:22:00 +0000</pubDate>
<dc:creator>take-fetter</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/take-fetter/p/8453589.html</dc:identifier>
</item>
</channel>
</rss>