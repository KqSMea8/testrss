<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RDD概念、特性、缓存策略与容错 - Huidoo_Yang</title>
<link>http://www.cnblogs.com/yangp/p/8620934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangp/p/8620934.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、RDD概念与特性&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. RDD的概念&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　RDD（Resilient Distributed Dataset），是指弹性分布式数据集。数据集：Spark中的编程是基于RDD的，将原始数据加载到内存变成RDD，RDD再经过若干次转化，仍为RDD。分布式：读数据一般都是从分布式系统中去读，如hdfs、kafka等，所以原始文件存在磁盘是分布式的，spark加载完数据的RDD也是分布式的，换句话说RDD是抽象的概念，实际数据仍在分布式文件系统中；因为有了RDD，在开发代码过程会非常方便，只需要将原始数据理解为一个集合，然后对集合进行操作即可。RDD里面每一块数据/partition，分布在某台机器的物理节点上，这是物理概念。弹性：这里是指数据集会进行转换，所以会忽大忽小，partition数量忽多忽少。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. RDD的特性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　Spark-1.6.1源码在org.apache.spark.rdd下的RDD.scala指出了每一个RDD都具有五个主要特点，如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180330154048345-2098592027.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;146&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;A list of partion&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　RDD是由一组partition组成。例如要读取hdfs上的文本文件的话，可以使用textFile()方法把hdfs的文件加载过来，把每台机器的数据放到partition中，并且封装了一个HadoopRDD，这就是一个抽象的概念。每一个partition都对应了机器中的数据。因为在hdfs中的一个Datanode，有很多的block，读机器的数据时，会将每一个block变成一个partition，与MapReduce中split的大小由min split，max split，block size （max(min split, min(max split, block size))）决定的相同，spark中的partition大小实际上对应了一个split的大小。经过转化，HadoopRDD会转成其他RDD，如FilteredRDD、PairRDD等，但是partition还是相应的partition，只是因为有函数应用里面的数据变化了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;A function for computing each split&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对每个split（partition）都有函数操作。一个函数应用在一个RDD上，可以理解为一个函数对集合（RDD）内的每个元素（split）的操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;A list of dependencies on other RDDs&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　一个RDD依赖于一组RDD。例如，下列代码片段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
val lines=sc.textFlie(&quot;hdfs://namenode:8020/path/file.txt&quot;&lt;span&gt;)
val wc&lt;/span&gt;=lines.flatMap(_.split(&quot; &quot;)).map((_,1)).reduceByKey(_+&lt;span&gt;_).sortBy(_._2)
wc.foreach(println)&lt;br/&gt;sc.stop()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里就存在RDD的依赖关系。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Optionally, a Partitioner for key-value RDDs&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　该可选项意思是对于一个RDD，如果其中的每一个元素是Key-Value形式时，可以传一个Partitioner（自定义分区），让这个RDD重新分区。这种情况的本质是shuffle，多点到多点的数据传输。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Optionally, a list of preferred locations to compute each split on&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　textFile()过程中，可以指定加载到性能好的机器中。例如，hdfs中的数据可能放在一大堆破旧的机器上，hdfs数据在磁盘上，磁盘可能很大，CPU、内存的性能很差。Spark默认做的事情是，把数据加载进来，会把数据抽象成一个RDD，抽象进来的数据在内存中，这内存指的是本机的内存，这是因为在分布式文件系统中，要遵循数据本地性原则，即移动计算（把函数、jar包发过去）而不移动数据（移动数据成本较高）。而一般hdfs的集群机器的内存比较差，如果要把这么多数据加载到烂机器的内存中，会存在问题，一是内存可能装不下，二是CPU差、计算能力差，这就等于没有发挥出spark的性能。在这种情况下，Spark的RDD可以提供一个可选项，可以指定一个preferred locations，即指定一个位置来加载数据。这样就可以指定加载到性能好的机器去计算。例如，可以将hdfs数据加载到Tachyon内存文件系统中，然后再基于Tachyon来做spark程序。 &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、RDD缓存策略&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 源码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　源码org.apache.spark.storage包下的StorageLevel.scala中定义缓存&lt;span&gt;策略&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　StorageLevel类默认的构造器有五个属性，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180330175831233-162918719.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;246&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180330000839876-1206926674.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 源码解读&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;StorageLevel私有类的构造器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; StorageLevel &lt;span&gt;private&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; var _useDisk: Boolean,&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用磁盘&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; var _useMemory: Boolean,&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用内存&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; var _useOffHeap: Boolean,&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;不使用堆内存（堆在JVM中）&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; var _deserialized: Boolean,&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;不序列化&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; var _replication: Int = 1)&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;副本数，默认为1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　val NONE = new StorageLevel(false, false, false, false)&lt;/p&gt;
&lt;p&gt;　　NONE表示不需要缓存。（不使用磁盘，不用内存，使用堆，序列化）&lt;/p&gt;
&lt;p&gt;　　val DISK_ONLY = new StorageLevel(true, false, false, false)&lt;/p&gt;
&lt;p&gt;　　DISK_ONLY表示使用磁盘。（使用磁盘，不用内存，使用堆，序列化）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;DISK_ONLY_2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val DISK_ONLY_2 = new StorageLevel(true, false, false, false, 2)&lt;/p&gt;
&lt;p&gt;　　DISK_ONLY_2表示使用磁盘，两个副本。（使用磁盘，不用内存，使用堆，序列化，2）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_ONLY&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_ONLY = new StorageLevel(false, true, false, true)&lt;/p&gt;
&lt;p&gt;　　MEMORY_ONLY表示只使用内存，例如1G的数据要放入512M的内存，会将数据切成两份，先将512M加载到内存，剩下的512M还在原来位置（如hdfs），之后如果有RDD的运算，会从内存和磁盘中去找各自的512M数据。（不使用磁盘，使用内存，使用堆，不序列化）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_ONLY_2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_ONLY_2 = new StorageLevel(false, true, false, true, 2)&lt;/p&gt;
&lt;p&gt;　　MEMORY_ONLY_2表示只使用内存，2个副本。（不使用磁盘，使用内存，使用堆，不序列化，2）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_ONLY_SER&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_ONLY_SER = new StorageLevel(false, true, false, false)&lt;/p&gt;
&lt;p&gt;　　MEMORY_ONLY_SER表示只使用内存，序列化。（不使用磁盘，使用内存，使用堆，序列化）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_ONLY_SER_2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_ONLY_SER_2 = new StorageLevel(false, true, false, false, 2)&lt;/p&gt;
&lt;p&gt;　　MEMORY_ONLY_SER表示只使用内存，序列化,2个副本。（不使用磁盘，使用内存，使用堆，序列化，2）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_AND_DISK&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)&lt;/p&gt;
&lt;p&gt;　　MEMORY_AND_DISK和MEMORY_ONLY很类似，都使用到了内存和磁盘，只是使用的是本机本地磁盘，例如1G数据要加载到512M的内存中，首先将hdfs的1G数据的512M加载到内存，另外的512M加载到本地的磁盘缓存着（和hdfs就没有关系了），RDD要读取数据的话就在内存和本地磁盘中找。（使用磁盘，使用内存，使用堆，不序列化）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_AND_DISK_2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_AND_DISK_2 = new StorageLevel(true, true, false, true, 2)&lt;/p&gt;
&lt;p&gt;　　MEMORY_AND_DISK_2表示两个副本。（使用磁盘，使用内存，使用堆，不序列化，2）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_AND_DISK_SER&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_AND_DISK_SER = new StorageLevel(true, true, false, false)&lt;/p&gt;
&lt;p&gt;　　MEMORY_AND_DISK_SER本地内存和磁盘，序列化。序列化的好处在于可以压缩，但是压缩就意味着要解压缩，需要消耗一些CPU。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;MEMORY_AND_DISK_SER_2&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　val MEMORY_AND_DISK_SER_2 = new StorageLevel(true, true, false, false, 2)&lt;/p&gt;
&lt;p&gt;　　MEMORY_AND_DISK_SER2，两个副本。&lt;/p&gt;
&lt;p&gt;　　val OFF_HEAP = new StorageLevel(false, false, true, false)&lt;/p&gt;
&lt;p&gt;　　OFF_HEAP不使用堆内存（例如可以使用Tachyon的分布式内存文件系统）。（不使用磁盘，不用内存，不使用堆，序列化）&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 缓存策略试验&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.huidoo.spark

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.{SparkConf, SparkContext}

object TestCache {
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; main(args: Array[String]): Unit =&lt;span&gt; {
    val conf &lt;/span&gt;= new SparkConf().setAppName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestCache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).setMaster(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local[2]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    val sc &lt;/span&gt;=&lt;span&gt; new SparkContext(conf)
    val lines &lt;/span&gt;= sc.textFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hdfs://cdh01:8020/flume/2018-03-23/2230&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) //目录下有17个文件，总大小约为335MB&lt;span&gt;，不做缓存

    val beginTime1 &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis() &lt;/span&gt;//&lt;span&gt;记录第1个job开始时间
    val count1 &lt;/span&gt;= lines.count() //&lt;span&gt;调用count()方法，会产生一个job
    val endTime1 &lt;/span&gt;= System.currentTimeMillis() //&lt;span&gt;记录第1个job结束时间

    val beginTime2 &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis() &lt;/span&gt;//&lt;span&gt;记录第2个job开始时间
    val count2 &lt;/span&gt;= lines.count() //&lt;span&gt;调用count()方法，会产生一个job
    val endTime2 &lt;/span&gt;= System.currentTimeMillis() //&lt;span&gt;记录第2个job结束时间

    println(count1)
    println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第1个job总共消耗时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (endTime1 - beginTime1) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;毫秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    println(count2)
    println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第2个job总共消耗时间&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + (endTime2 - beginTime2) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;毫秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    sc.stop()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180331001634619-357929723.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;153&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可见，所有文件的总行数为1935077行，第一个job和第二个job的用时分别为14.7s和12.2s，差别不大。&lt;/p&gt;
&lt;p&gt; 　　只需在原代码基础上将HadoopRDD lines添加调用cache()方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
val lines = sc.textFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hdfs://cdh01:8020/flume/2018-03-23/2230&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).cache() //目录下有17个文件，总大小约为335MB，做缓存
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/884765/201803/884765-20180331002906993-1699524800.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;155&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可见，所有文件的总行数为1935077行，第一个job和第二个job的用时分别为19.4s和0.09s，速度相比不做缓存明显提升。这是因为没有做缓存，第二个job还需要先从hdfs上读取数据，需要消耗更长时间；而做了缓存则直接从缓存中读取（cache方法默认缓存策略是MEMORY_ONLY），所以速度会快很多。 &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、RDD Lineage与容错&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. Lineage（血统）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　一系列RDD到RDD的transformation操作，称为lineage（血统）。某个RDD依赖于它前面的所有RDD。例如一个由10个RDD到RDD的转化构成的lineage，如果在计算到第9个RDD时失败了，一般较好的计算框架会自动重新计算。一般地，这种错误发生了会去找上一个RDD，但是实际上如果不做缓存是找不到的，因为即使RDD9知道它是由RDD8转化过来的，但是因为它并没有存RDD数据本身，在内存中RDD瞬时转化，瞬间就会在内存中消失，所以还是找不到数据。如果这时RDD8做过cache缓存，那么就是在RDD8的时候进行了数据的保存并记录了位置，这时如果RDD9失败了就会从缓存中读取RDD8的数据；如果RDD8没有做cache就会找RDD7，以此类推，如果都没有做cache就需要重新从HDFS中读取数据。所以所谓的容错就是指，当计算过程复杂，为了降低因某些关键点计算出错而需要重新计算的带来的惨重代价的风险，则需要在某些关键点使用cache或用persist方法做一下缓存。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 容错&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;容错理论&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　上述缓存策略还存在一个问题。使用cache或persist的缓存策略是使用默认的仅在内存，所以实际的RDD缓存位置是在内存当中，如果机器出现问题，也会造成内存中的缓存RDD数据丢失。所以可以将要做容错的RDD数据存到指定磁盘（可以是hdfs）路径中，可以对RDD做doCheckpoint()方法。使用doCheckpoint()方法的前提示，需要在sc中要先设置SparkContext.setCheckpointDir()，设置数据存储路径。这时候如果程序计算过程中出错了，会先到cache中找缓存数据，如果cache中没有就会到设置的磁盘路径中找。&lt;/p&gt;
&lt;p&gt;　　在RDD计算，通过checkpoint进行容错，做checkpoint有两种方式，一个是checkpoint data，一个是logging the updates。用户可以控制采用哪种方式来实现容错，默认是logging the updates方式，通过记录跟踪所有生成RDD的转换（transformations）也就是记录每个RDD的lineage（血统）来重新计算生成丢失的分区数据。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;容错源码解读&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
//&lt;span&gt;RDD.scala中的doCheckpoint方法：
&lt;/span&gt;/**
 * Performs the checkpointing of this RDD by saving this. It &lt;span&gt;is&lt;/span&gt;&lt;span&gt; called after a job using this RDD
 &lt;/span&gt;* has completed (therefore the RDD has been materialized &lt;span&gt;and&lt;/span&gt; potentially stored &lt;span&gt;in&lt;/span&gt;&lt;span&gt; memory).
 &lt;/span&gt;* doCheckpoint() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; called recursively on the parent RDDs.
 &lt;/span&gt;*/&lt;span&gt;
private[spark] &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; doCheckpoint(): Unit =&lt;span&gt; {
  
  RDDOperationScope.withScope(sc, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checkpoint&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, allowNesting = false, ignoreParent =&lt;span&gt; true) {
    &lt;/span&gt;//&lt;span&gt;如果doCheckpointCalled不为true，就先将其改为true
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (!doCheckpointCalled) {
      doCheckpointCalled &lt;/span&gt;=&lt;span&gt; true
      &lt;/span&gt;//&lt;span&gt;如果checkpointData已定义，就把data get出来，然后做一下checkpoint。
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (checkpointData.isDefined) {
        checkpointData.get.checkpoint()
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;//&lt;span&gt;如果checkpointData没有的话，就把这个RDD的所有依赖拿出来，foreach一把，把里面的每个元素RDD，再递归调用本方法。
        dependencies.foreach(_.rdd.doCheckpoint())
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
//&lt;span&gt;RDD.scala中的checkpoint()方法
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; checkpoint(): Unit =&lt;span&gt; RDDCheckpointData.synchronized {
  &lt;/span&gt;// NOTE: we use a &lt;span&gt;global&lt;/span&gt;&lt;span&gt; lock here due to complexities downstream with ensuring
  &lt;/span&gt;//&lt;span&gt; children RDD partitions point to the correct parent partitions. In the future
  &lt;/span&gt;//&lt;span&gt; we should revisit this consideration.
  &lt;/span&gt;//&lt;span&gt;首先检查context的checkpointDir是否为空，如果没有设置就会抛出异常
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.checkpointDir.isEmpty) {
    throw new SparkException(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Checkpoint directory has not been set in the SparkContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (checkpointData.isEmpty) {
    checkpointData &lt;/span&gt;=&lt;span&gt; Some(new ReliableRDDCheckpointData(this))
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//SparkContext.scala中的setCheckpointDir方法
&lt;/span&gt;/**
 *&lt;span&gt; Set the directory under which RDDs are going to be checkpointed. The directory must
 &lt;/span&gt;* be a HDFS path &lt;span&gt;if&lt;/span&gt;&lt;span&gt; running on a cluster.
 &lt;/span&gt;*/
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setCheckpointDir(directory: String) {

  &lt;/span&gt;// If we are running on a cluster, log a warning &lt;span&gt;if&lt;/span&gt; the directory &lt;span&gt;is&lt;/span&gt;&lt;span&gt; local.
  &lt;/span&gt;// Otherwise, the driver may attempt to reconstruct the checkpointed RDD &lt;span&gt;from&lt;/span&gt;
  // its own local file system, which &lt;span&gt;is&lt;/span&gt;&lt;span&gt; incorrect because the checkpoint files
  &lt;/span&gt;//&lt;span&gt; are actually on the executor machines.
  &lt;/span&gt;//&lt;span&gt;如果运行了集群模式，checkpointDir必须是非本地的。
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isLocal &amp;amp;&amp;amp;&lt;span&gt; Utils.nonLocalPaths(directory).isEmpty) {
    logWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Checkpoint directory must be non-local &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;if Spark is running on a cluster: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; directory)
  }

  checkpointDir &lt;/span&gt;= Option(directory).map { dir =&amp;gt;&lt;span&gt;
    val path &lt;/span&gt;=&lt;span&gt; new Path(dir, UUID.randomUUID().toString)
    val fs &lt;/span&gt;=&lt;span&gt; path.getFileSystem(hadoopConfiguration)
    fs.mkdirs(path)
    fs.getFileStatus(path).getPath.toString
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 01 Apr 2018 07:16:00 +0000</pubDate>
<dc:creator>Huidoo_Yang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangp/p/8620934.html</dc:identifier>
</item>
<item>
<title>Hibernate学习（4）-  Hibernate对象的生命周期 - _Json</title>
<link>http://www.cnblogs.com/JsonShare/p/8686078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JsonShare/p/8686078.html</guid>
<description>&lt;h2&gt;1、Hibernate对象的生命周期（瞬时状态、持久化状态、游离状态）&lt;/h2&gt;
&lt;p&gt;1、瞬时状态（Transient）：&lt;br/&gt;　　使用new操作符初始化的对象就是瞬时状态，没有跟任何数据库数据相关联；&lt;br/&gt;2、持久化状态（Parsistent）：&lt;br/&gt;　　如果对象与Session对象关联起来，且该对象对应到数据库记录，则称该对象处于持久化状态。&lt;br/&gt;3、游离状态（Detached）&lt;br/&gt;　　Session被关闭或调用了Session的evict或clear方法把它从Session中移除了，则该对象脱离了Session的管理，持久化状态变成游离状态，这表示该对象不在和数据库保持同步，不受hibernate管理。&lt;/p&gt;
&lt;h2&gt;2、三种状态的比较&lt;/h2&gt;
&lt;p&gt;Transient：瞬时状态的对象只存在于内存中。&lt;br/&gt;Parsistent：持久状态的对象分别存在于内存、session对象、数据库之中。&lt;br/&gt;Detached：游离状态的对象存在于内存、数据库之中，但不在session对象中。&lt;/p&gt;
&lt;h2&gt;3、三种状态之间的转换&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/633261/201804/633261-20180401111501243-954123062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1、转化路径详解&lt;/h3&gt;
&lt;p&gt;1）瞬时对象(Transient)&lt;/p&gt;
&lt;p&gt;　　new 创建 (无-&amp;gt;Transient) ，即：对象通过构造方法成为瞬时态；&lt;/p&gt;
&lt;p&gt;2）持久对象(Persistent)&lt;/p&gt;
&lt;p&gt;　　1.1）get/load (无-&amp;gt;Persistent)，即：对象可以由session的load或get方法直接成为持久态；&lt;/p&gt;
&lt;p&gt;　　　　get通过类名和id从数据库读取指定记录，无匹配记录返回null。&lt;br/&gt;　　　　load通过类名和id从数据库读取指定记录，无匹配记录抛ObjectNotException异常。&lt;/p&gt;
&lt;p&gt;　　1.2）save/saveOrUpdate/persist (Transient-&amp;gt;Persistent) ，即：瞬时态对象可以通过save，saveOrUpdate或persist方法成为持久态；&lt;/p&gt;
&lt;p&gt;　　1.3）update/saveOrUpdate(Detached-&amp;gt;Persistent)，即：游离态对象则可以通过update，saveOrUpdate成为持久态；&lt;/p&gt;
&lt;p&gt;3）游离对象(Detached)&lt;/p&gt;
&lt;p&gt;　　游离态只能由持久态转换而来(Persistent-&amp;gt;Detached)，通过close、clear、evict方法实现。&lt;/p&gt;
&lt;p&gt;　　evict--把某个对象从session中移除，变为游离态；&lt;br/&gt;　　clear--把所有对象从session中移除，对象全部变为游离态；&lt;br/&gt;　　close--关闭session，其中的对象全部变为游离态；&lt;/p&gt;
&lt;h3&gt;2、几种方法的详解&lt;/h3&gt;
&lt;p&gt;1、get 与 load&lt;/p&gt;
&lt;p&gt;　　都是从数据库中加载数据封装为java对象，直接变为持久态；&lt;/p&gt;
&lt;p&gt;2、save，update与saveOrUpdate&lt;/p&gt;
&lt;p&gt;　　save是将瞬时态转为持久态；&lt;br/&gt;　　update是将游离态转为持久态；&lt;br/&gt;　　saveOrUpdate可以说是两者的综合，它执行时先判断对象的状态（主要是通过有无主键判断的），若是自由态，则save，若是游离态，则update；&lt;/p&gt;
&lt;p&gt;3、save与persist&lt;/p&gt;
&lt;p&gt;　　两者都是将对象由瞬时态转为持久态，但返回值不同：save返回主键值，而persist不返回；&lt;/p&gt;
&lt;h2&gt; 4、实例，详见注解状态（封装的工具类详见Demo）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.Session;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.Utils.HibernateUtil;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.pojo.User;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SessionTest {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveTest() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            session.beginTransaction();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建瞬时状态对象&lt;/span&gt;
            user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            user.setName(&lt;/span&gt;&quot;东方不败&quot;&lt;span&gt;);
            user.setPwd(&lt;/span&gt;&quot;123456&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;user仍是一个瞬态对象
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;持久状态，user被session管理，并且id有值   -- oid
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时user已变成 持久态对象&lt;/span&gt;
&lt;span&gt;            session.save(user);
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在持久状态下脏数据检查:当提交事务，清理缓存时发现session中的数据与数据库的数据不一致时，会把session的数据更新到数据库
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存以后，再修改对象，会产生多条sql语句，效率降低，所以在save前修改数据&lt;/span&gt;
            user.setName(&quot;西方求败&quot;&lt;span&gt;);
            session.getTransaction().commit();        
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;close、clear、evict方法都会使持久态对象  变成 游离状态 -- user&lt;/span&gt;
        user.setName(&quot;令狐冲&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            session.beginTransaction();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;update使对象变成 持久状态&lt;/span&gt;
&lt;span&gt;            session.update(user);
            session.getTransaction().commit();        
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getTest() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get后变为持久状态
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get方法会立即查询该对象：范围（查询不到去下一级查询）从session -&amp;gt; sessionFactory -&amp;gt;数据库
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get方法找不到对象，不会有异常，返回nul&lt;/span&gt;
            User user = session.get(User.&lt;span&gt;class&lt;/span&gt;, 7L&lt;span&gt;);
            System.out.println(user.toString());
            
            User user2 &lt;/span&gt;= session.get(User.&lt;span&gt;class&lt;/span&gt;, 17L&lt;span&gt;);
            System.out.println(user2);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; loadTest() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;load后变为持久状态(这里加载机制与get不同，稍后我会单独写一篇文章 介绍 get与load 的区别)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象不存在时，抛出异常&lt;/span&gt;
            User user = session.load(User.&lt;span&gt;class&lt;/span&gt;, 7L&lt;span&gt;);
            System.out.println(user.toString());
            
            User user2 &lt;/span&gt;= session.load(User.&lt;span&gt;class&lt;/span&gt;, 17L&lt;span&gt;);
            System.out.println(user2.toString());
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clearTest() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            session.beginTransaction();
            user &lt;/span&gt;= session.get(User.&lt;span&gt;class&lt;/span&gt;,7L&lt;span&gt;);
            System.out.println(user.getName());
            session.getTransaction().commit();    
            session.clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;游离状态，不被session管理，数据库不会被更改&lt;/span&gt;
            user.setName(&quot;任我行&quot;&lt;span&gt;);
            System.out.println(user.getName());
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateTest() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            session.beginTransaction();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;瞬时状态
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动构造对象 也可以修改，但是需要指定所有的属性值，否则，不设置的对象会置空,不建议这样update数据&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;user = new User();
            user.setId(7L);
            user.setName(&quot;盈盈&quot;);
            session.update(user);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般这样修改
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先去查询&lt;/span&gt;
            user = session.get(User.&lt;span&gt;class&lt;/span&gt;,7L&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(user != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                user.setName(&lt;/span&gt;&quot;盈盈&quot;&lt;span&gt;);
                session.update(user);
            }
            session.getTransaction().commit();    
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteTest() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        User user &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; HibernateUtil.currentSession();
            session.beginTransaction();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;瞬时状态
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动构造一个对象，指定主键是可以删除数据的，不建议这样搞&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;user = new User();
            user.setId(7L);
            session.delete(user);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;应该这样删除数据
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从数据先加载该对象，然后删除，可以避免异常&lt;/span&gt;
            user = session.get(User.&lt;span&gt;class&lt;/span&gt;, 7L&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(user != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                session.delete(user);
            }
            session.getTransaction().commit();    
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            HibernateUtil.closeSession();
        }
    }
    
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PS：源码地址   &lt;strong&gt;&lt;a title=&quot;https://github.com/JsonShare/hibernate-demo&quot; href=&quot;https://github.com/JsonShare/hibernate-demo&quot; target=&quot;_blank&quot;&gt;https://github.com/JsonShare/hibernate-demo&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS：原文地址  &lt;a title=&quot;http://www.cnblogs.com/JsonShare/p/8686078.html&quot; href=&quot;http://www.cnblogs.com/JsonShare/p/8686078.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/JsonShare/p/8686078.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 06:30:00 +0000</pubDate>
<dc:creator>_Json</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JsonShare/p/8686078.html</dc:identifier>
</item>
<item>
<title>CountDownLatch 源码解析—— countDown() - 猫咪大王</title>
<link>http://www.cnblogs.com/cuglkb/p/8686415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cuglkb/p/8686415.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/cuglkb/p/8572609.html&quot; target=&quot;_blank&quot;&gt;上一篇文章&lt;/a&gt;从源码层面说了一下CountDownLatch 中 await() 的原理。这篇文章说一下countDown() 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; countDown() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;
    sync.releaseShared(1&lt;span&gt;);
}
    ↓
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt; arg) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AQS&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryReleaseShared(arg)) {
        doReleaseShared();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}
    ↓
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt; releases) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CountDownLatch.Sync 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decrement count; signal when transition to zero&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nextc = c-1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetState(c, nextc))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextc == 0&lt;span&gt;;
    }
}
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过构造器 CountDownLatch end = new CountDownLatch(2);  state 被设置为2，所以c == 2，nextc = 2-1, &lt;/p&gt;
&lt;p&gt;然后通过下面这个CAS操作将state设置为1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compareAndSetState(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; update) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; See below for intrinsics setup to support this&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, stateOffset, expect, update);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时nextc还不为0，返回false。一直等到countDown()  方法被调用两次，state == 0，nextc ==0,此时返回true。&lt;/p&gt;
&lt;p&gt;进入doReleaseShared()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;doReleaseShared();
    ↓
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doReleaseShared() {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        Node h &lt;/span&gt;=&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h !=&lt;span&gt; tail) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; h.waitStatus;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop to recheck cases&lt;/span&gt;
&lt;span&gt;                unparkSuccessor(h);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ws == 0 &amp;amp;&amp;amp;
                     !compareAndSetWaitStatus(h, 0&lt;span&gt;, Node.PROPAGATE))
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop on failed CAS&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h == head)                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; loop if head changed&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回顾一下此时的等待队列模型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       +--------------------------+   prev           +------------------+&lt;span&gt;
head   &lt;/span&gt;| waitStatus = Node.SIGNAL | &amp;lt;---- node(tail) | currentThread    |
       +--------------------------+                  +------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时head 不为null，也不为tail，waitStatus == Node.SIGNAL，所以进入 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) 这个判断。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!compareAndSetWaitStatus(h, Node.SIGNAL, 0&lt;span&gt;))
    ↓
 &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * CAS waitStatus field of a node.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; compareAndSetWaitStatus(Node node,
                                                     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; expect,
                                                     &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; update) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unsafe.compareAndSwapInt(node, waitStatusOffset,
                                    expect, update);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个CAS 操作将 state 设置为 0 ，也就是说此时Head 中的 waitStatus 是0.此时队列模型如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
       +----------------+   prev           +------------------+&lt;span&gt;
head   &lt;/span&gt;| waitStatus = 0 | &amp;lt;---- node(tail) | currentThread    |
       +----------------+                  +------------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法返回true。进入unparkSuccessor(h);&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;unparkSuccessor(h);
    ↓
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unparkSuccessor(Node node) {
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * If status is negative (i.e., possibly needing signal) try
    * to clear in anticipation of signalling.  It is OK if this
    * fails or if status is changed by waiting thread.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; node.waitStatus;
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws &amp;lt; 0&lt;span&gt;)
       compareAndSetWaitStatus(node, ws, &lt;/span&gt;0&lt;span&gt;);

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * Thread to unpark is held in successor, which is normally
    * just the next node.  But if cancelled or apparently null,
    * traverse backwards from tail to find the actual
    * non-cancelled successor.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   Node s &lt;/span&gt;=&lt;span&gt; node.next;
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; 0&lt;span&gt;) {
       s &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t =&lt;span&gt; t.prev)
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= 0&lt;span&gt;)
               s &lt;/span&gt;=&lt;span&gt; t;
   }
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
       LockSupport.unpark(s.thread);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s 就是head的后继结点，也就是装有当前线程的结点。s != null ，并且s.waitStatus ==0 ，所以进入 LockSupport.unpark(s.thread);&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unpark(Thread thread) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (thread != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            UNSAFE.unpark(thread);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是unlock 被阻塞的线程。裁判被允许吹哨了！&lt;/p&gt;
&lt;p&gt;countDown() 的原理就此就非常清晰了，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每执行一次countDown() 方法，state 就是减1，直到state == 0，则开始释放被阻塞在队列中的线程，根据前驱结点中waitStatus的状态，释放后续结点中的线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OK,回到上一篇文章的问题，什么时候跳出下面这个循环（await方法中的循环）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; head) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; tryAcquireShared(arg);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (r &amp;gt;= 0&lt;span&gt;) {
            setHeadAndPropagate(node, r);
            p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
            failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
        parkAndCheckInterrupt())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时state == 0，所以进入 setHeadAndPropagate 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;setHeadAndPropagate(node, r);
    ↓
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setHeadAndPropagate(Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; propagate) {
    Node h &lt;/span&gt;= head; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Record old head for check below&lt;/span&gt;
&lt;span&gt;    setHead(node);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Try to signal next queued node if:
     *   Propagation was indicated by caller,
     *     or was recorded (as h.waitStatus either before
     *     or after setHead) by a previous operation
     *     (note: this uses sign-check of waitStatus because
     *      PROPAGATE status may transition to SIGNAL.)
     * and
     *   The next node is waiting in shared mode,
     *     or we don't know, because it appears null
     *
     * The conservatism in both of these checks may cause
     * unnecessary wake-ups, but only when there are multiple
     * racing acquires/releases, so most need signals now or soon
     * anyway.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (propagate &amp;gt; 0 || h == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0 ||&lt;span&gt;
        (h &lt;/span&gt;= head) == &lt;span&gt;null&lt;/span&gt; || h.waitStatus &amp;lt; 0&lt;span&gt;) {
        Node s &lt;/span&gt;=&lt;span&gt; node.next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; s.isShared())
            doReleaseShared();
    }
}
    ↓
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHead(Node node) {
    head &lt;/span&gt;=&lt;span&gt; node;
    node.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    node.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法将head 的后继结点变为head。该方法过后，又将node的next结点设置为null，模型变成下图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
       prev                +---------+&lt;span&gt;  next
&lt;/span&gt;&lt;span&gt;null&lt;/span&gt; &amp;lt;---- node(tail/head) | &lt;span&gt;null&lt;/span&gt;    | ----&amp;gt; &lt;span&gt;null&lt;/span&gt;
                           +---------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是node head tail 什么的都被置为null，等待GC回收了，这个时候return，跳出了for循环，队列被清空。&lt;/p&gt;
&lt;p&gt;下面演示一下整个过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;setHeadAndPropagate(node, r);

           &lt;/span&gt;+----------------+&lt;span&gt;  
head(tail) &lt;/span&gt;|  waitStatus=0  |
           |  thread =&lt;span&gt;null&lt;/span&gt;  |
           +----------------+&lt;span&gt;
                    ↓
           &lt;/span&gt;+----------------+            +----------------+
           |   waitStatus=0 |   prev     | waitStatus=0   |&lt;span&gt;
head(tail) &lt;/span&gt;|   thread =&lt;span&gt;null&lt;/span&gt; | &amp;lt;---- node | currentThread  |
           +----------------+            +----------------+&lt;span&gt;           
                    ↓
     &lt;/span&gt;+----------------+                  +----------------+
     |   waitStatus=0 |   prev           | waitStatus=0   |&lt;span&gt;
head &lt;/span&gt;|   thread =&lt;span&gt;null&lt;/span&gt; | &amp;lt;---- node(tail) | currentThread  |
     +----------------+                  +----------------+&lt;span&gt;
                    ↓
     &lt;/span&gt;+----------------+                  +----------------+
     |   Node.SIGNAL  |   prev           | waitStatus=0   |&lt;span&gt;
head &lt;/span&gt;|   thread =&lt;span&gt;null&lt;/span&gt; | &amp;lt;---- node(tail) | currentThread  |
     +----------------+                  +----------------+&lt;span&gt;
                         ↓
     &lt;/span&gt;+----------------+                  +----------------+
     |   waitStatus=0 |   prev           | waitStatus=0   |&lt;span&gt;
head &lt;/span&gt;|   thread =&lt;span&gt;null&lt;/span&gt; | &amp;lt;---- node(tail) | currentThread  |
     +----------------+                  +----------------+&lt;span&gt;
                         ↓
                            &lt;/span&gt;+----------------+&lt;span&gt;
        prev                &lt;/span&gt;| waitStatus=0   |&lt;span&gt; next
&lt;/span&gt;&lt;span&gt;null&lt;/span&gt; &amp;lt;---- node(tail/head)  | &lt;span&gt;null&lt;/span&gt;           | ----&amp;gt; &lt;span&gt;null&lt;/span&gt;
                            +----------------+
                            
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;CountDownLatch 的核心就是一个阻塞线程队列，这是由链表构造而成的队列，里面包含thread 和 waitStatus，其中waitStatus说明了后继结点线程状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;state 是一个非常重要的标志，构造时，设置为对应的n值，如果n != 0，阻塞队列将一直阻塞，除非中断线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每次调用countDown()  方法，就是将state-1，而调用await() 方法就是将调用该方法的线程加入到阻塞队列，直到state==0，才能释放线程。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 05:56:00 +0000</pubDate>
<dc:creator>猫咪大王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cuglkb/p/8686415.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上-容器难容：容器服务故障以及自建 docker swarm 集群故障 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8683754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8683754.html</guid>
<description>&lt;p&gt;3月21日，由于使用阿里云服务器自建 docker swarm 集群的不稳定，我们将自建 docker swarm 集群上的所有应用切换阿里云容器服务 swarm 版（非swarm mode）。&lt;/p&gt;
&lt;p&gt;3月22日，我们进行移除与重启节点的操作时引发了故障，详见 &lt;a href=&quot;https://www.cnblogs.com/cmt/p/8626825.html&quot; target=&quot;_blank&quot;&gt;云计算之路-阿里云上-容器服务：移除节点引发博问站点短暂故障&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;3月24日，我们参考&lt;a href=&quot;https://help.aliyun.com/document_detail/48933.html&quot; target=&quot;_blank&quot;&gt;阿里云容器服务帮助文档-指定多节点调度&lt;/a&gt;通过给节点添加用户标签的方式成功移除了部分节点。我们是这么操作的，当时所有节点没有添加用户标签，给待移除节点之外的所有节点添加了“group:1”标签，在编排文件的 environment 配置中添加了“constraint:group==1”，对待移除节点上部署的所有应用进行“变更配置”操作（选中“重新调度”）。&lt;/p&gt;
&lt;p&gt;3月31日（昨天），16:00 左右，我们再次进行移除节点的操作。由于上次操作时已给所有节点打上了“group:1”标签，这次操作时就需要删除待移除节点的“group:1”标签，然后进行“变更配置”+“重新调度”。但操作后发现不起作用，待移除节点上的所有应用容器纹丝不动。多次操作，一次次仔细检查操作步骤，未发现任何问题，而容器依然与待移除节点在一起，我们似乎听到容器对节点说“You jump, I jump”。被容器与节点在一起的决心所打动，再加上实在找不到其他解决方法，我们决定铤而走险——直接移除这个节点，但这不是盲目的选择，是基于一个前提——这个节点上对应的应用都有2个容器，并且部署在不同的节点上。结果幸运的是冒险成功，节点成功移除，容器与节点比翼双飞，这些应用剩下的部署在其他节点上的容器正常提供服务。&lt;/p&gt;
&lt;p&gt;在移除节点后，我们向集群中添加了一个同样配置的新节点。&lt;/p&gt;
&lt;p&gt;之后，我们准确对集群中的一个节点进行重启，为了避免重启节点引发故障，我们参考&lt;a href=&quot;https://help.aliyun.com/document_detail/56435.html&quot; target=&quot;_blank&quot;&gt;阿里云容器服务帮助文档-容器重新调度&lt;/a&gt;在编排文件的 environment 添加了 “reschedule:on-node-failure”，17: 00 左右重启了节点服务器。&lt;/p&gt;
&lt;p&gt;17:20 左右，悲剧开始上演了。。。&lt;/p&gt;
&lt;p&gt;一边接到 CPU 报警&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/35695/201804/35695-20180401112010946-2081221556.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一边发现集群上的部分站点 503&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/35695/201804/35695-20180401112150817-1866709464.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一边发现有节点离线&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/35695/201804/35695-20180401112329111-1391416456.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么回事？重启节点时，那个被重启节点上的容器被迁移到了配置最低、容器最多的节点上，造成那个节点 CPU 100%，为什么不迁移到新加的节点上？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/35695/201804/35695-20180401112906486-844673033.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;264&quot;/&gt;&lt;/p&gt;
&lt;p&gt;干脆把这个挂掉的节点移除吧，却发现移除按钮为灰色，不可点，只好重启节点。。。&lt;/p&gt;
&lt;p&gt;又发现另外一个低配节点出现同样的问题，但可以移除，先将之移除。。。&lt;/p&gt;
&lt;p&gt;在这期间越来越多的站点出现 503 。。。&lt;/p&gt;
&lt;p&gt;将开始移除的高配节点加入进来。。。&lt;/p&gt;
&lt;p&gt;后来节点逐步恢复了正常，然后一个一个“重新部署”应用，有些应用恢复了。但很多应用不管“重新部署”还是“变更配置”，依然503，虽然阿里云容器服务控制台显示应用正常，其实容器列表中一个容器没有，只能通过容器服务控制台一个一个删除并重新创建应用，重建后容器都起来了，多数应用恢复了正常。但发现有些跑在容器中的内部服务连不上，排查发现集群的服务发现出现了问题，解析出来的 IP 地址与实际运行的容器的 IP 地址不匹配，很可能是解析的是已经删除的容器的 IP 。&lt;/p&gt;
&lt;p&gt;被迫无奈，只能赶紧创建 docker swarm 集群，将那些始终无法恢复的应用先迁移过来。&lt;/p&gt;
&lt;p&gt;直到 19:30 左右才基本恢复正常。&lt;/p&gt;
&lt;p&gt;后来，我们将阿里云容器服务中的所有应用全部迁移回自建 docker swarm 集群。但在 22:35 左右，docker swarm 集群的 2 个 worker 节点宕机造成故障，当时只有 1 manger 节点 2 个 worker 节点，重启 worker 节点后 22:45 左右恢复正常。&lt;/p&gt;
&lt;p&gt;然后往集群中加节点，在加第 2 个 manager 节点时，出现下面的错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;郁闷至极，我们知道 2 个 manager 节点会出现这个问题，但我们是想从 1 个 manager 加到 3 个 manager 节点，必然要经过 2 个 manager ，就那一会就出现了集群群龙无首的问题。&lt;/p&gt;
&lt;p&gt;在 23:15 左右再次出现故障，只能重建集群，刚建好集群不久，因为 1 个 manager 节点出现问题又出现故障，最后将这个 manager 节点退出并重新加入集群后，在 23:25 左右恢复正常。&lt;/p&gt;
&lt;p&gt;非常抱歉，昨天下午到晚上的故障给您带来了很大的麻烦，请您谅解！&lt;/p&gt;
&lt;p&gt;接下来，我们将要采取的应对措施是同时部署多个自建 docker swarm 集群，挂载到同一个负载均衡下，只有所有集群全部宕机才会造成网站访问故障。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Apr 2018 04:19:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8683754.html</dc:identifier>
</item>
<item>
<title>linux小白成长之路10————SpringBoot项目部署进阶 - 云开发</title>
<link>http://www.cnblogs.com/cloud-dev/p/linux-xiao-bai-cheng-zhang-zhi-lu10SpringBoot-xian.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-dev/p/linux-xiao-bai-cheng-zhang-zhi-lu10SpringBoot-xian.html</guid>
<description>&lt;p&gt;&lt;span&gt;【内容指引】&lt;/span&gt;&lt;br/&gt;war包部署；&lt;br/&gt;jar包部署；&lt;br/&gt;基于Docker云部署。&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;一、war包部署&lt;/h2&gt;
&lt;p&gt;通过“云开发”平台初始化的SpringBoot项目默认采用jar形式打包，这也是我们推荐的方式。但是，因为某些原因，软件需求方特别要求用war形式打包，我们该怎么做？&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;1.项目尚未开始&lt;/h3&gt;
&lt;p&gt;如果开发前，软件需求就指明要war形式打包和部署，那么我们在利用IntelliJ IDEA创建Spring Boot项目时直接选择打包方式(Packaging)是war形式即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113314740-1591725096.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;打包方法和上篇文章jar的打包方式一样。也可以通过指令打包，方法是先在Mac终端中进入项目根路径，然后运行指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mvn &lt;span&gt;package&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113314942-1051529616.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;2.项目已开发&lt;/h3&gt;
&lt;p&gt;如果软件需求方中途要求通过war形式打包和发布，而我们是通过jar形式创建的项目该怎么做呢？&lt;/p&gt;
&lt;h4 id=&quot;toc_3&quot;&gt;1&amp;gt;.pom.xml&lt;/h4&gt;
&lt;p&gt;将“jar”改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;增加如下依赖覆盖默认内嵌的Tomcat依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113315906-1111198105.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h4 id=&quot;toc_4&quot;&gt;2&amp;gt;.增加ServletInitializer类&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; mobi.weiapp.cms;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.builder.SpringApplicationBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.web.support.SpringBootServletInitializer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * war打包时指定启动类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServletInitializer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SpringBootServletInitializer {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SpringApplicationBuilder configure(SpringApplicationBuilder application){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; application.sources(CmsApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113316669-1086221075.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;3.部署war包&lt;/h3&gt;
&lt;p&gt;我们在《linux小白成长之路6————安装Java+Apache(httpd)+Tomcat》中安装过Tomcat，安装完成后，&lt;span&gt;tomcat索引目录为：/usr/share/tomcat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113315505-1699655945.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将Mac中打包好的war包重命名为&quot;cms.war&quot;拷贝到CentOS7虚拟机中tomcat的webapps目录下，它会自动解压：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113316192-1790992288.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;安装Tomcat时我们将Tomcat设置为虚拟机启动时自动开启，使用的是8080端口，现在我们访问：http://localhost:8080/cms&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;二、jar包部署&lt;/h2&gt;
&lt;p&gt;上一篇我们已经示范了怎样进行jar形式的打包和部署。&lt;br/&gt;我们通常将Linux下运行的软件注册为服务。这里介绍如何将jar包注册为Linux服务，实现通过指令开启、关闭以及保持开机启动等功能。&lt;/p&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;1.修改pom.xml中的编译插件配置&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将上面spring-boot-maven-plugin的配置修改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;executable&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/executable&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;toc_8&quot;&gt;2.编译成jar包&lt;/h3&gt;
&lt;p&gt;通过指令“mvn package”打包，或用上篇介绍的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113315557-867268848.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;3. 上传jar包&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;进入CentOS7虚拟机(或远程Linux服务器)，进入&quot;/var&quot;目录：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113316630-1789890955.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;在该目录下看看有没有“apps”目录，如果没有就新建一个：&lt;br/&gt;指令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mkdir apps
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113317863-878374871.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将上面编译的jar包可以重命名为&quot;cms-service.jar&quot;,拷贝到CentOS7虚拟机的&quot;/var/apps&quot;下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113316367-1509049484.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;4.基于Linux的Systemd部署&lt;/h3&gt;
&lt;p&gt;在CentOS7的“/etc/systemd/system/”目录下新建文件&quot;cms.service&quot;:&lt;br/&gt;指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nano /etc/systemd/system/cms.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写入如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Unit]
Description&lt;/span&gt;=&lt;span&gt;cms
After&lt;/span&gt;=&lt;span&gt;syslog.target

[Service]
ExecStart&lt;/span&gt;= /usr/bin/java -jar /var/apps/cms-&lt;span&gt;service.jar

[Install]
WantedBy&lt;/span&gt;=multi-user.target
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113321461-52276779.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务指令&lt;/strong&gt;&lt;br/&gt;启动服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl start cms.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;停止服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl stop cms.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl status cms.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开机启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl enable cms.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看项目日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
journalctl -u cms.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_11&quot;&gt;三、基于Docker云部署&lt;/h2&gt;
&lt;h3 id=&quot;toc_12&quot;&gt;1.在CentOS7中建立存放jar包的docker目录&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113318941-1098179080.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_13&quot;&gt;2.将jar包存放在该目录下&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113331395-1057115036.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_14&quot;&gt;3.在jar包存放的目录建立如下Dockerfile&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113321638-1091172345.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
FROM java:8&lt;span&gt;

MAINTAINER mac.manon

ADD cms.jar app.jar

EXPOSE &lt;/span&gt;8888&lt;span&gt;

ENTRYPOINT [&lt;/span&gt;&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113321787-1000072589.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_15&quot;&gt;4.编译镜像&lt;/h3&gt;
&lt;p&gt;编译镜像前确保虚拟机是可以连互联网的。&lt;br/&gt;在/var/apps/cmsdocker目录下执行编译镜像的指令。&lt;br/&gt;指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build -t cloudev/cmsdocker .
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113323347-423433645.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113324941-58006949.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;编译好后查看本地镜像：&lt;br/&gt;指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker images
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113322749-97743238.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_16&quot;&gt;5.运行镜像&lt;/h3&gt;
&lt;p&gt;指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
docker run -d --restart=always --name mycms -p 8888:8888 cloudev/cmsdocker
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180401113325394-1762316582.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 03:34:00 +0000</pubDate>
<dc:creator>云开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-dev/p/linux-xiao-bai-cheng-zhang-zhi-lu10SpringBoot-xian.html</dc:identifier>
</item>
<item>
<title>04_Python的数据类型1数值和字符串_Python编程之路 - susmote</title>
<link>http://www.cnblogs.com/susmote/p/8684770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/susmote/p/8684770.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://www.susmote.com/zb_users/upload/2018/03/201803282155419945522.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一节我们通过一个helloworld程序学习python的一些简单操作，还有输入与输出&lt;/p&gt;
&lt;p&gt;这节我们来讲Python的数据类型与变量的操作&lt;/p&gt;


&lt;p&gt;在讲这个之前，我要先讲一下python的交互器，之后讲解代码（除了做简单项目）都在交互器上进行，这样可能比较直接一些，有利于刚接触python的人理解代码&lt;/p&gt;
&lt;p&gt;python在命令行自带一个交互器，我们可以直接通过输入python进入python的交互器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266253/201803/1266253-20180331221357118-1311489417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是他的功能并不是很齐全，比如代码着色，和变量的提示，以及操作shell命令的功能都没有&lt;/p&gt;
&lt;p&gt;所以我在这推荐一款更强大的Python“交互器Shell”，IPython&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266253/201803/1266253-20180331222030000-462558037.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IPython 是一个 python 的交互式 shell，比默认的python shell 好用得多，支持变量自动补全，自动缩进，支持 bash shell 命令，内置了许多很有用的功能和函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1266253/201803/1266253-20180331222504329-1892024533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如可以直接在ipython中直接使用Linux命令，如 ls  命令查看文件夹下的文件&lt;/p&gt;
&lt;p&gt;安装ipython只需要执行以下命令即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip install ipython
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　使用ipython只需要输入ipython即可&lt;/p&gt;


&lt;p&gt;在交互器中，Python语言可以和自然语言一样处理数学的计算，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [1]: 4+4
Out[1]: 8

In [2]: 100 - 6*3
Out[2]: 82

In [3]: (100 - 5*6) / 10
Out[3]: 7.0

In [4]: 10 / 3
Out[4]: 3.3333333333333335
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意在Python中进行除法时只返回浮点数，也就是带小数点的数&lt;/p&gt;
&lt;h3&gt;整型 int&lt;/h3&gt;
&lt;p&gt;像4， 45， 255， 2455这些都是整型数字&lt;/p&gt;
&lt;h3&gt;浮点数 float&lt;/h3&gt;
&lt;p&gt;像5.0，3.1415，5.733都是浮点数&lt;/p&gt;
&lt;p&gt;前面讲了进行除法时使用&quot; / &quot;只会返回一个浮点数&lt;/p&gt;
&lt;p&gt;如果你想返回一个整数，那么你就可以使用&quot; // &quot;操作符&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [5]: 20 / 3
Out[5]: 6.666666666666667

In [6]: 20 // 3
Out[6]: 6
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 取余操作符&quot; % &quot;&lt;/h3&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [8]: 30 % 4    #30取4的余数
Out[8]: 2

In [9]: 4 * 7 + 2
Out[9]: 30
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;次方操作符 &quot; ** &quot;&lt;/h3&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [10]: 4 ** 2    #4的二次方
Out[10]: 16

In [11]: 2 * 4    #2的四次方
Out[11]: 8
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：进行负数的次方运算时最好把负数加上括号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [27]: -2**4
Out[27]: -16

In [28]: (-2)**4
Out[28]: 16
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;赋值符号 &quot; = &quot;&lt;/h3&gt;
&lt;p&gt;把一个数值赋给一个变量&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [14]: height = 12.5    #长

In [15]: width = 5    #宽

In [16]: area = height * width　　#面积

In [17]: print(area)
62.5
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;em&gt;需要注意的是一个变量必须要在使用时对其赋初值定义&lt;/em&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;混合数据类型的计算&lt;/h3&gt;
&lt;p&gt;在进行混合类型的计算时，Python的解释器总是会在整数与浮点数的计算中返回一份浮点数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [19]: 7 * 8 - 2.00
Out[19]: 54.0
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;操作浮点数的精度 &quot;round&quot;&lt;/h3&gt;
&lt;p&gt;round()方法需要传入两个参数，第一个是要操作的数字，第二个是浮点数的精度&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [25]: PAI = 3.1415926535 

In [26]: round(PAI, 2)
Out[26]: 3.14
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Python中，字符串是最常用的数据类型，当然数值也不例外，&lt;/p&gt;
&lt;p&gt;申明一个字符串可以用 '  ' 和 ''  ''&lt;/p&gt;
&lt;h5&gt;在输出单引号和双引号时我们可以使用转义符号&quot;  \  &quot;&lt;/h5&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [29]: 'hello world'
Out[29]: 'hello world'

In [30]: &quot;hello world&quot;
Out[30]: 'hello world'

In [31]: &quot; PHP是世界上\&quot;最好\&quot;的语言 &quot;
Out[31]: ' PHP是世界上&quot;最好&quot;的语言 '
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在这里我们稍微扩展以下，常见的转义字符&lt;/p&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;转义字符&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\(在行尾时)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;续行符&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\\&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;反斜杠符号&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\'&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;单引号&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;双引号&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\a&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;响铃&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\b&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;退格(Backspace)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\e&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;转义&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\000&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;空&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\n&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;换行&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\v&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;纵向制表符&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\t&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;横向制表符&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\r&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;回车&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;\f&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;换页&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;\oyy&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;八进制数，yy代表的字符，例如：\o12代表换行&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;\xyy&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;十六进制数，yy代表的字符，例如：\x0a代表换行&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;\other&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;其它的字符以普通格式输出&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



















&lt;p&gt;注意：python的print（）方法是默认换行输出的，只有使用输出方法时，\n才会生效，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [4]: talk = &quot;你好\nPython&quot;

In [5]: talk
Out[5]: '你好\nPython'

In [6]: print(talk)
你好
Python
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然如果你不这么麻烦，想直接输入一段话，不考虑转义，这是你就可以使用原始字符串，把要输出的字符串加上引号，然后在&lt;span&gt;&lt;strong&gt;前面加上 r 即可&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出一段路径时&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [7]: print(&quot;D:\notepad++\bin&quot;)
D:
otepad+in

In [8]: print(r&quot;D:\notepad++\bin&quot;)
D:\notepad++\bin
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然除了上面的方法，还有一个就是用python的格式化输出&lt;/p&gt;
&lt;h3&gt;格式化输出 '''   ....   '''&lt;/h3&gt;
&lt;p&gt;如果想要格式化输出一行或多行文本时，就可以用 三引号 来输出&lt;/p&gt;
&lt;p&gt;例如输出一个人的基本信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [9]: info = ''' name: %s   age: %d   '''%(&quot;susmote&quot;,18)

In [10]: print(info)
 name: susmote   age: 18 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多行输出时&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [12]: print('''\
    ...: name : %s
    ...: age  : %d
    ...: '''%(&quot;susmote&quot;,18) )
name : susmote
age  : 18
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;字符串的连接输出&lt;/h3&gt;
&lt;p&gt;python作为一门弱类型语言，你可以花式操作字符串&lt;/p&gt;
&lt;p&gt;例如要重复输出一段字符串时，其他语言只能通过循环去完成，而python除了循环，你还可以对他进行数学操作，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [15]: 'h' + 'e' + 2*'l' + 'o'
Out[15]: 'hello'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然你也可以不用加号&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [19]: 'h' 'e' +2*'l'+ 'o'
Out[19]: 'hello'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意，不能把一个变量跟字符串直接相连（不加“ + ”号）&lt;/p&gt;

&lt;h3&gt;字符串索引切片&lt;/h3&gt;
&lt;p&gt;字符串，通俗来讲也就用字符连接成的串，那么我们怎么能够获取其中包含的字符呢，这时我们就要用到索引（index）了,只需要在字符串后面加'' [ index ] '',index代表你要获取的字符顺序&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意索引都是从0开始的，这个目前市场上主流语言都适用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [30]: name = &quot;susmote&quot;

In [31]: name[0]
Out[31]: 's'

In [33]: name[1]
Out[33]: 'u'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了用正序索引，我们也可以使用倒序索引，用&quot; - &quot;开始&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [34]: name[-1]　　相当于name[6]
Out[34]: 'e'

In [35]: name[-2]　　相当于name[5]
Out[35]: 't'
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;字符串的切片&lt;/h4&gt;
&lt;p&gt;用上面的方法我们每次最多也只能获取一个&lt;span&gt;字符&lt;span&gt;，但是如果我们想获取多个字符该怎么办呢，这时就要用到切片了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;切片操作，只需要在字符串后加   [ index1 : index2 ],注意两个index之间用&quot; : &quot;(分号)隔开，index1代表开始的字符，index2代表结束的字符&lt;/p&gt;
&lt;p&gt;注意切片是 包头不包尾的&lt;/p&gt;
&lt;p&gt;例如以下例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [43]: name = 'susmote'

In [44]: name[0:1]
Out[44]: 's'

In [45]: name[0:2]
Out[45]: 'su'

In [46]: name[0:6]
Out[46]: 'susmot'

In [47]: name[0:7]
Out[47]: 'susmote'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;也可以不加索引（开始的索引和结束的索引），默认index1（开始字符的索引）是0,index2(结束字符的索引)是最后的字符索引加1&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [49]: name[:]
Out[49]: 'susmote'

In [50]: name[0:]
Out[50]: 'susmote'

In [51]: name[:7]
Out[51]: 'susmote'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;切片也可以用&lt;strong&gt;&quot; - &quot;  &lt;/strong&gt;倒序索引&lt;/p&gt;
&lt;p&gt;但是切片是按照正序来操作的，所以针对复杂的切片还是要仔细分析索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [72]: name[-1:]
Out[72]: 'e'

In [73]: name[:-1]
Out[73]: 'susmot'

In [74]: name[-7:-1]
Out[74]: 'susmot'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;索引的结构如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
+---+---+---+---+---+---+---+
| s | u | s | m | o | t | e |
+---+---+---+---+---+---+---+
　0 　 1 　2 　3 　4 　 5   6    
 -6   -5 -4  -3  -2  -1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果开始字符的索引超出了字符的长度，那么什么都不会输出&lt;/p&gt;
&lt;p&gt;如果结束字符的索引超出了字符的长度，那么只会输出开始的字符到整个字符串的最后一个字符索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [75]: name[40:]
Out[75]: ''

In [76]: name[3:40]
Out[76]: 'mote'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意字符串类型是不可以被改变的，你不能对索引对象和切片对象进行赋值&lt;/p&gt;
&lt;h3&gt;获取字符串的长度&lt;/h3&gt;
&lt;p&gt;获取的字符串的长度我们可以通过 len() 方法来获得&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
In [79]: well = &quot;susmote very smart&quot;

In [80]: len(well)
Out[80]: 18
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;数值和字符串简单的我们就讲到这里，下一节在介绍python其他的数据类型&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 03:28:00 +0000</pubDate>
<dc:creator>susmote</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/susmote/p/8684770.html</dc:identifier>
</item>
<item>
<title>为什么要持续重构 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8280135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8280135.html</guid>
<description>&lt;p&gt;&lt;strong&gt; 什么是重构？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重构是在不改变软件可观察行为的前提下改善其内部结构。---Martin Fowler&lt;/li&gt;
&lt;li&gt;通俗说法：看起来没做啥调整，让系统继续更好的满足客户需求。同时，希望重构完成后，这个系统能够多蹦跶几年。　&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;重构的分类：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码重构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如果想了解代码方面的重构主要有哪些方法，可以参考《重构：改善既有代码的设计》、《重构与模式》。&lt;/p&gt;
&lt;p&gt;　　之前我们在有次讨论的时候，一个童鞋说：“我们现在的程序设计都被框架封装了，设计模式基本是用不到的。”这个说法我不太同意。因为我们现在也在进行代码重构，抛去设计不谈，但从代码风格上，最令人吐槽的是里面充斥着大量的if和else。刚毕业的童鞋可以觉得很正常。但是稍有经验的人就知道这些逻辑计算应该用策略来代替。设计模式是从细节代码到设计架构处处充斥着的一门设计美学，任何工程师都需要掌握和学以致用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;架构重构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如果想了解架构方面的重构主要有哪些方法，可以参考《软件设计重构》。下面列了一些架构重构方面的主要考虑点，并对其中一点做了说明。&lt;/p&gt;
&lt;p&gt;　　1&amp;gt;可扩展和负载均衡策略&lt;/p&gt;
&lt;p&gt;　　2&amp;gt;数据库的读写分离和主从切换&lt;/p&gt;
&lt;p&gt;　　3&amp;gt;按需扩容&lt;/p&gt;
&lt;p&gt;　　4&amp;gt;两地三中心，机房故障也能稳定的提供服务&lt;/p&gt;
&lt;p&gt;　　5&amp;gt;持续的容量规划&lt;/p&gt;
&lt;p&gt;　　每个阶段都有自己的业务目标。订单量会对系统容量有新的要求。针对业务目标做评估，对组件做评估，看当前支撑的量是多少，找到其中的瓶颈点做架构升级。应该有1.5倍到两倍的冗余。把握节奏，太早会影响需求的迭代速度，运维成本高。太晚会不足以支持单量。&lt;br/&gt;技术方案长期规划，逐步实施。持续重构，重构在每个阶段都要有人力。&lt;/p&gt;
&lt;p&gt;　　6&amp;gt;持续的性能优化&lt;br/&gt;　　7&amp;gt;性能影响用户的留存率、成本&lt;br/&gt;　　8&amp;gt;单机容量低、响应慢　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重构的目标：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最终目标：更好的承载业务&lt;/li&gt;
&lt;li&gt;具体目标有：改进设计、模型规范、重建生命周期、增大负载能力、提高响应速度、抽象、解耦、无法维护、扩容、业务复杂度、降级开发成本、容易理解、技术栈革新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;重构面临的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新的系统就不会再有问题了么？&lt;/li&gt;
&lt;li&gt;再过几年，新系统也会变成老系统&lt;/li&gt;
&lt;li&gt;一个正在运行的系统，如何新老系统平滑迁移？&lt;/li&gt;
&lt;li&gt;日常需求不停顿，还要花费大量精力重新设计编码&lt;/li&gt;
&lt;li&gt;之前踩过的坑如果没有很好地沉淀，可能会重新入坑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　既然重构面临这么多问题，到底要不要重构？那就问自己愿不愿意为重构负起责任，坚持到底，并承担后果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要重构？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一般说需要重构了，都会是因为面临着一些问题。近期问题如：不能支持业务、故障、响应不满足需求、单点无法扩容。长期问题如：维护成本大、扩容成本大、有明显风险、不支持业务扩展。&lt;/p&gt;
&lt;p&gt;　　我们的代码迫切的需要重构。我曾经为了申请重构资源，做了很多工作想让领导认识到我们重构的必要性。尝试着列举不重构的话，TOP3无法解决的问题：&lt;/p&gt;
&lt;p&gt;　　1.我们是一个平台系统，当初的设计却是为了其中一个业务研发的，功能都是定制化的&lt;/p&gt;
&lt;p&gt;　　2.在不合理的逻辑上叠加需求&lt;/p&gt;
&lt;p&gt;　　3.数据模型不能覆盖目前的需求&lt;/p&gt;

&lt;p&gt;　　不重构很痛，但总感觉没有说到痛点。后来我们领导说：“重构的目的是为了甩掉历史包袱。”听着更接近本质一点了，但是总感觉还是缺少什么。&lt;/p&gt;
&lt;p&gt;　　后来我仔细想了一下。当初必须要重构。因为不重构一改就会出问题。当初资源申请困难是因为我一直都没解释清楚为什么一改就出问题。因为按照正常的理解：改出来问题是能力的问题，对业务没有很好的把控，对代码没有深入的研究。而实际上重构是因为”坏味道“使得架构和代码本身已经无法阐述它的行为。再通俗点说就是：现有架构和代码，与目前承担的事情不是一个东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么要持续重构？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从本质上，重构就是在代码写好之后改进它的设计。&lt;/li&gt;
&lt;li&gt;如果你发现自己需要为程序添加一个特性，而代码结构使你无法很方便地达成目的，那就先重构那个程序，使特性的添加比较容易进行，然后再添加特性。&lt;/li&gt;
&lt;li&gt;重构改进软件设计，因为代码结构的流失是累积性的。&lt;/li&gt;
&lt;li&gt;重构使软件更容易理解&lt;/li&gt;
&lt;li&gt;重构帮助找到bug&lt;/li&gt;
&lt;li&gt;重构提高编程速度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　对我们组来说，为什么要持续重构？&lt;/p&gt;
&lt;p&gt;　　因为持续重构的代码是确保代码长期没有人动，一动就出问题的有效手动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;何时重构？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;三次法则：事不过三，三则重构。&lt;/li&gt;
&lt;li&gt;添加功能时重构&lt;/li&gt;
&lt;li&gt;修补错误时重构&lt;/li&gt;
&lt;li&gt;复审代码时重构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt; 重构和性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重构是对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。它提供了一种更高效且受控的代码整理技术。&lt;/li&gt;
&lt;li&gt;和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能不得不那么做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;”两顶帽子“如何权衡&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;　　在开发过程中，通常会遇到两顶帽子。一顶是需求的帽子，一顶是重构的帽子。囚徒困境，如何抉择？&lt;/p&gt;
&lt;p&gt;　　我刚接手交易的时候，对此也很迷惑，所以特地去了解了一下交易的前世今生。了解之前的交易负责人的关注点。有的疲于应付询问和问题；有的关注需求；重构是解决业务支撑开发量大的有力武器。但是需求来了，怎么办？&lt;/p&gt;
&lt;p&gt; 　  权衡的时候，重要紧急、重要不紧急、紧急不重要、不重要不紧急的四象限理论怎么发挥作用？都紧急的时候怎么按照重要度来进行排序。&lt;/p&gt;
&lt;p&gt;　　回答这个问题就要先弄清楚交易最重要的是什么。交易的核心是稳定。如果重构是维持稳定的必要条件，而我们需要一个重做级别的重构，需要大量的时间。那么这时就需要保证重构和需求至少1：1的投入。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重构的原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.测试优先原则&lt;/p&gt;
&lt;p&gt;　　　　TDD(Test-Driven Development):测试驱动开发&lt;/p&gt;
&lt;p&gt;　　2.OCP原则&lt;/p&gt;
&lt;p&gt;　　　　Open For Extension:开放封闭原则&lt;/p&gt;
&lt;p&gt;　　3.小步快跑原则&lt;/p&gt;
&lt;p&gt;　　　　大布局、小迭代&lt;/p&gt;
&lt;p&gt;　　　　进化式设计和增量开发&lt;/p&gt;
&lt;p&gt;　　　　　　避免过度设计，对于未来的变化，既不要考虑的太多，也不能一点都不考虑&lt;/p&gt;
&lt;p&gt;　　　　　　代码满足当前需求，并留有可扩展余地 &lt;/p&gt;
&lt;p&gt; 　　4.数据一致性原则&lt;/p&gt;
&lt;p&gt;　　　　　　分库分表（横向、纵向）&lt;/p&gt;
&lt;p&gt;　　　　　　字段合并、冗余&lt;/p&gt;
&lt;p&gt;　　　　　　索引优化、数据缓存&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重构设计方案选用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 技术方案没有好坏，只有合适不合适。合适的方案用到合适的系统。判断合适主要考虑的方面：&lt;/p&gt;
&lt;p&gt;1.业务契合度&lt;/p&gt;
&lt;p&gt;2.覆盖面全不全&lt;/p&gt;
&lt;p&gt;3.扩展性&lt;/p&gt;
&lt;p&gt;4.人力投入成本&lt;/p&gt;
&lt;p&gt;5.系统稳定性&lt;/p&gt;
&lt;p&gt;6.安全&lt;/p&gt;
&lt;p&gt;7.简单明了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重构的注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免盲目重构&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　要重构，上面我的内容我自己认为都是需要想清楚的。另外还有一点，需要对重构系统进行一个生命周期预估，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;未来需求预判&lt;/li&gt;
&lt;li&gt;模块划分拆解&lt;/li&gt;
&lt;li&gt;总结历史问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;隐性及显性需求 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我在知乎上看到说怎么判断隐性需求：隐性需求就是大家都觉得很不爽，但是又说不出个所以然。显性需求和隐性需求实际上没区别，视力不同的人看到不同的世界，洞察力不同的人看到不同的需求。 &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;割接（新旧系统替换、迁移）实测演练&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这块着重说一下，交易重构的割接采用的是留壳抠瓤的方式。就是对外接口和暴露方式不变，内部逐渐灰度用重构后的系统来替换新系统。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结与思考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以前上学的时候最不喜欢遇到主观题。因为一个试卷上有主观题，就基本上意味着得不了满分。 如今工作中，发现自己做的都是主观题。别人给自己打分，自己给别人打分。说好的标准可能到时候会发现难以实施。说好的加分项，自己也做了很大努力的，结果真正打分的时候，也只能呵呵了。但是通常面对结果，我会对自己说：“我会有一分钟的不开心，但是我服。”&lt;/p&gt;
&lt;p&gt;　　因为打分的人总有自己的思考过程，得不了满分总意味自己有改进的地方。牺牲两周的午饭时间排练的街舞，得了第一名，也就得了一副蓝牙耳机。结果其实没那么重要，只是过程很开心而已。但是经验与教训的区别：经验给出了一条思路，教训却给了很多条。&lt;/p&gt;
&lt;p&gt;　　我之前一个同事，自己创业失败去了我之前工作过的一家公司。后来在美团刚起步的时候加入了美团。做好了之后，如今又去了另外一家刚起步但是很有前景的公司。&lt;/p&gt;
&lt;p&gt;　　我还认识一些人。他们很早买了房子。房价涨了，他们觉得赚了。又继续买了其他的房子。同样，价值都在增长。&lt;/p&gt;
&lt;p&gt;　　这些都是成功的经验得以复制的例子。&lt;/p&gt;
&lt;p&gt;　　教训的例子却不太好举。因为一旦成为教训，做出的思考很多，采取的改进往往也不是单方面的，得到的提高也往往是综合的。&lt;/p&gt;
&lt;p&gt;　　如今，我不再怕主观题。对别人给我打得分，我会给自己一个实质性的收获。对我给别人打得分，我也会给别人一个满意的成长。在公司里能够得到的最大财富就是自身的成长改变，所以感激每一件能让自己反思自身的事情和经历。&lt;/p&gt;
&lt;p&gt;　　就像我常说的：人生就是一场游戏，关键是经验值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;郁金香　　&lt;/p&gt;
&lt;p&gt;　　桌上的混合花束，和同事谈事情的时候无意看了一眼，一支郁金香脑袋耷拉下来。原来这一支插入水中的比较浅，它根部的水已经蒸发掉了。赶紧给添了水，并给这支郁金香摆了个造型支在旁边的康乃馨上。第二天，这支郁金香又硬挺起来，而且它的花茎还保持着我之前摆的造型，宛然一件艺术品。原来在挫折下可以变得更完美的，不只是人类，也不只是内心。&lt;/p&gt;
&lt;p&gt;樱花&lt;/p&gt;
&lt;p&gt;　　4月是樱花的季节。记得日本出差的时候，签证最多只能停留3个月。12月底去的，赶上了日本的成人礼，18岁的姑娘们个个穿着和服赶往庙堂，一片美人海；赶上了情人节，夜晚小树林里、公园里好多哭哭啼啼的女孩子；却在只剩下几天就樱花祭的时候回国了。所以看到樱花，心里的感觉总不一样。&lt;/p&gt;
&lt;p&gt;　　带着大小情人去公园，看到樱花。想起新海诚《樱花抄》里明里看到樱花时的话：“像雪一样。”只是樱花花瓣落于掌心，不会像雪一样融化。而那年春夏秋冬寻寻觅觅想要在人群中看到的那个人、那些曾经拼命想要忘却的记忆，竟然像落于掌心的雪花一样，不见了&lt;/p&gt;
&lt;p&gt;蝴蝶兰&lt;/p&gt;
&lt;p&gt;　　一年四季，前台上总放着一盆蝴蝶兰。我仔细观察过，不是塑料花。室内常见的盆栽，自然条件下本来是开花的，养在花盆里却成了常绿无花的灌木。常说的难以办到的事情之一就有：“铁树开花。”巴西铁其实却是可以开花的，只是条件苛刻。而蝴蝶兰却总是给人最美的样子，像是痴痴地等待着一个人。&lt;/p&gt;
&lt;p&gt;　　我用一生等你，你不来我不老。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;招贤纳士：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    美团点评核心交易招收实习生，方向：JAVA开发。要求：19年毕业研究生、985院校优先。有意向请与关注我的公众号：编程一生，并留言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201804/1112728-20180401112435734-400254658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 01 Apr 2018 03:14:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8280135.html</dc:identifier>
</item>
<item>
<title>通过软引用和弱引用提升JVM内存使用性能的方法（面试时找机会说出，一定能提升成功率） - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8685993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8685993.html</guid>
<description>&lt;p&gt;    初学者或初级程序员在面试时如果能证明自己具有分析内存用量和内存调优的能力，这相当有利，因为这是针对5年左右相关经验的高级程序员的要求。而对于高级程序员来说，如果能在面试时让面试官感觉你确实做过内存调优的工作，那么面试官很有可能不问Java Core部分的其它问题了，毕竟虚拟机调优是Java Core部分非常资深的知识点。&lt;/p&gt;
&lt;p&gt;    在Java对象里，有强弱软虚四种引用，它们都和垃圾回收流程密切相关，在项目里，我们可以通过合理地使用不同类型的引用来优化代码的内存使用性能。&lt;/p&gt;
&lt;p&gt;    指向通过new得到的内存空间的引用叫强引用。比如有String a = newString(“123”);，其中的a就是一个强引用，它指向了一块内容是123的堆空间。&lt;/p&gt;
&lt;p&gt;    平时我们用的最多的引用就是强引用，以至于很多人还不知道有其他类型引用的存在，下面我们来说下弱软虚这三种平时不常见（但在关键时刻不可替代）的用途。    &lt;/p&gt;
&lt;h5&gt;1 软引用和弱引用的用法&lt;/h5&gt;
&lt;p&gt;    软引用（SoftReference）的含义是，如果一个对象只具有软引用，而当前虚拟机堆内存空间足够，那么垃圾回收器就不会回收它，反之就会回收这些软引用指向的对象。&lt;/p&gt;
&lt;p&gt;    弱引用（WeakReference）与软引用的区别在于，垃圾回收器一旦发现某块内存上只有弱引用（一定请注意只有弱引用，没强引用），不管当前内存空间是否足够，那么都会回收这块内存。&lt;/p&gt;
&lt;p&gt;    通过下面的ReferenceDemo.java，我们来看下软引用和弱引用的用法，并对比一下它们的差别。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.ref.SoftReference;
&lt;/span&gt;2    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.ref.WeakReference;
&lt;/span&gt;3    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReferenceDemo {
&lt;/span&gt;4        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;5            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强引用&lt;/span&gt;
6            String str=&lt;span&gt;new&lt;/span&gt; String(&quot;abc&quot;&lt;span&gt;); 
&lt;/span&gt;7            SoftReference&amp;lt;String&amp;gt; softRef=&lt;span&gt;new&lt;/span&gt; SoftReference&amp;lt;String&amp;gt;(str);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 软引用   &lt;/span&gt;
8            str = &lt;span&gt;null&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去掉强引用&lt;/span&gt;
9            System.gc(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 垃圾回收器进行回收&lt;/span&gt;
10&lt;span&gt;            System.out.println(softRef.get());        
&lt;/span&gt;11            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强引用&lt;/span&gt;
12            String abc = &lt;span&gt;new&lt;/span&gt; String(&quot;123&quot;&lt;span&gt;);
&lt;/span&gt;13            WeakReference&amp;lt;String&amp;gt; weakRef=&lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;String&amp;gt;(abc); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 弱引用    &lt;/span&gt;
14            abc = &lt;span&gt;null&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去掉强引用&lt;/span&gt;
15            System.gc(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 垃圾回收器进行回收&lt;/span&gt;
16&lt;span&gt;            System.out.println(weakRef.get());
&lt;/span&gt;17&lt;span&gt;        }
&lt;/span&gt;18    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   在第8行里，我们定义了SoftReference&amp;lt;String&amp;gt;类型的软引用softRef，用来指向第7行通过new创建的空间，在第14行，我 们是通过弱引用weakRef指向第13行创建的空间。&lt;/p&gt;
&lt;p&gt;    接下来我们通过下表来观察下具体针对内存空间的操作。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;行号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;针对内存的操作以及输出结果&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在堆空间里分配一块空间（假设首地址是1000），在其中写入String类型的abc，并用str这个强引用指向这块空间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;用softRef这个软引用指向1000号内存，这时1000号内存上有一个强引用str，一个软引用softRef&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;把1000号内存上的强引用str撤去，此时该块内容上就只有一个软引用softRef&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;9&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;通过System.gc()，启动垃圾回收动作&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;通过softRef.get()输出软引用所指向的值，此时1000号内存上没有强引用，只有一个软引用。但由于此时内存空间足够，所以1000号内存上虽然只有一个软引用，但第9行的垃圾回收代码不会回收1000号的内存，所以这里输出结果是123。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在堆空间里分配一块空间（假设首地址是2000），在其中写入String类型的123，并用abc这个强引用指向这块空间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;用weakRef这个弱引用指向2000号内存，这时2000号内存上有一个强引用abc，一个软引用weakRef&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;14&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;把2000号内存上的强引用abc撤去，此时该块内容上就只有一个弱引用weakRef&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;15&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;通过System.gc()，启动垃圾回收动作&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;40&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;16&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;480&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;通过weakRef.get()输出软引用所指向的值，此时2000号内存上没有强引用，只有一个弱引用，所以第15行的垃圾回收代码会回收2000号的内存，所以这里输出结果是null。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h5&gt;2 软引用的使用场景&lt;/h5&gt;
&lt;p&gt;    比如在一个博客管理系统里，为了提升访问性能，在用户在点击博文时，如果这篇博文没有缓存到内存中，则需要做缓存动作，这样其它用户在点击同样这篇文章时，就能直接从内存里装载，而不用走数据库，这样能降低响应时间。&lt;/p&gt;
&lt;p&gt;    我们可以通过数据库级别的缓存在做到这点，这里也可以通过软引用来实现，具体的实现步骤如下。&lt;/p&gt;
&lt;p&gt;    第一，可以通过定义Content类来封装博文的内容，其中可以包括文章ID、文章内容、作者、发表时间和引用图片等相关信息。&lt;/p&gt;
&lt;p&gt;    第二，可以定义一个类型为HashMap&amp;lt;String, SoftReference&amp;lt;Content&amp;gt;&amp;gt;的对象类保存缓存内容，其中键是String类型，表示文章ID，值是指向Content的软引用。&lt;/p&gt;
&lt;p&gt;    第三，当用户点击某个ID的文章时，根据ID到第二步定义的HashMap里去找，如果找到，而且所对应的SoftReference&amp;lt;Content&amp;gt;值内容不是null，则直接从这里拿数据并做展示动作，这样不用走数据库，可以提升性能。&lt;/p&gt;
&lt;p&gt;    第四，如果用户点击的某个文章的ID在HashMap里找不到，或者虽然找到，但对应的值内容是空，那么就从数据库去找，找到后显示这个文章，同时再把它插入到HashMap里，这里请注意，显示后需要撤销掉这个Content类型对象上的强引用，保证它上面只有一个软引用。&lt;/p&gt;
&lt;p&gt;    来分析下用软引用有什么好处？假设我们用1个G的空间缓存了10000篇文章，这10000篇文章所占的内存空间上只有软引用。如果内存空间足够，那么我们可以通过缓存来提升性能，但万一内存空间不够，我们可以依次释放这10000篇文章所占的1G内存，释放后不会影响业务流程，最多就是降低些性能。&lt;/p&gt;
&lt;p&gt;    对比一下，如果我们这里不用软应用，而是用强引用来缓存，由于不知道文章何时将被点击，我们还无法得知什么时候可以撤销这些文章对象上的强引用，或者即使我们引入了一套缓存淘汰流程，但这就是额外的工作了，这就没刚才使用“软引用“那样方便了。&lt;/p&gt;
&lt;h5&gt;3 通过WeakHashMap来了解弱引用的使用场景&lt;/h5&gt;
&lt;p&gt;    WeakHashMap和HashMap很相似，可以存储键值对类型的对象，但我们可以从它的名字上看出，其中的引用是弱引用。通过下面的WeakHashMapDemo.java，我们来看下它的用法。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;  
&lt;/span&gt;2    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;  
&lt;/span&gt;3    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;  
&lt;/span&gt;4    &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.WeakHashMap;    
&lt;/span&gt;5    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeakHashMapDemo {  
&lt;/span&gt;6        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {  
&lt;/span&gt;7            String a = &lt;span&gt;new&lt;/span&gt; String(&quot;a&quot;&lt;span&gt;);  
&lt;/span&gt;8            String b = &lt;span&gt;new&lt;/span&gt; String(&quot;b&quot;&lt;span&gt;);  
&lt;/span&gt;9            Map weakmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakHashMap();  
&lt;/span&gt;10            Map map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();  
&lt;/span&gt;11            map.put(a, &quot;aaa&quot;&lt;span&gt;);  
&lt;/span&gt;12            map.put(b, &quot;bbb&quot;&lt;span&gt;);            
&lt;/span&gt;13            weakmap.put(a, &quot;aaa&quot;&lt;span&gt;);  
&lt;/span&gt;14            weakmap.put(b, &quot;bbb&quot;&lt;span&gt;);            
&lt;/span&gt;15&lt;span&gt;            map.remove(a);            
&lt;/span&gt;16            a=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;17            b=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;            
&lt;/span&gt;18&lt;span&gt;            System.gc();  
&lt;/span&gt;19            Iterator i =&lt;span&gt; map.entrySet().iterator();  
&lt;/span&gt;20            &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (i.hasNext()) {  
&lt;/span&gt;21                Map.Entry en = (Map.Entry)i.next();              System.out.println(&quot;map:&quot;+en.getKey()+&quot;:&quot;+&lt;span&gt;en.getValue());  
&lt;/span&gt;22&lt;span&gt;            }    
&lt;/span&gt;23            Iterator j =&lt;span&gt; weakmap.entrySet().iterator();  
&lt;/span&gt;24            &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (j.hasNext()) {  
&lt;/span&gt;25                Map.Entry en = (Map.Entry)j.next();System.out.println(&quot;weakmap:&quot;+en.getKey()+&quot;:&quot;+&lt;span&gt;en.getValue());                
&lt;/span&gt;26&lt;span&gt;            }  
&lt;/span&gt;27&lt;span&gt;        }  
&lt;/span&gt;28    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    通过下表，我们来详细说明关键代码的含义。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;行号&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;针对内存的操作以及输出结果&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在堆空间里分配一块空间（假设首地址是1000），在其中写入String类型的a，并用a这个强引用指向这块空间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在堆空间里分配一块空间（假设首地址是2000），在其中写入String类型的b，并用b这个强引用指向这块空间。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;11，12&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在HashMap里了插入两个键值对，其中键分别是a和b引用，这样1000号和2000号内存上就分别多加了一个强引用了（有两个强引用了）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;13,14&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;在WeakHashMap里了插入两个键值对，其中键分别是a和b引用，这样1000号和2000号内存上就分别多加了一个弱引用了（有两个强引用，和一个弱引用）。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;15&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;从HashMap里移出键是a引用的键值对，这时1000号内存上有一个String类型的强引用和一个弱引用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;16&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;撤销掉1000号内存上的a这个强引用，此时1000号内存上只有一个弱引用了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;17&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;撤销掉2000号内存上的b这个强引用，此时2000号内存上有一个HashMap指向的强引用和一个WeakHashMap指向的弱引用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;18&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;通过System.gc()回收内存&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;19~22&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;遍历并打印HashMap里的对象，这里争议不大，在11和12行放入了a和b这两个强引用的键，在第15行移出a，所以会打印map:b:bbb。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td width=&quot;47&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;23~25&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;473&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;遍历并打印WeakHashMap里的对象，这里的输出是weakmap:b:bbb。&lt;/p&gt;
&lt;p class=&quot;a1&quot; align=&quot;left&quot;&gt;虽然我们没有从WeakHashMap里移除a这个引用，但之前a所对应的1000号内存上的强引用全都已经被移除，只有一个弱引用，所以在第18行时，1000号内存里的内存已经被回收，所以WeakHashMap里也看不到a了，只能看到b。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;    根据上文和这里的描述，我们知道如果当一个对象上只有弱引用时，这个对象会在下次垃圾回收时被回收，下面我们给出一个弱引用的使用场景。&lt;/p&gt;
&lt;p&gt;    比如在某个电商网站项目里，我们会用Coupan这个类来保存优惠券信息，在其中我们可以定义优惠券的打折程度，有效日期和所作用的商品范围等信息。当我们从数据库里得到所有的优惠券信息后，会用一个List&amp;lt;Coupan&amp;gt;类型的coupanList对象来存储所有优惠券。&lt;/p&gt;
&lt;p&gt;    而且，我们想要用一种数据结构来保存一个优惠券对象以及它所关联的所有用户，这时我们可以用WeakHashMap&amp;lt;Coupan, &amp;lt;List&amp;lt;WeakReference &amp;lt;User&amp;gt;&amp;gt;&amp;gt;类型的weakCoupanHM对象。其中它的键是Coupan类型，值是指向List&amp;lt;User&amp;gt;用户列表的弱引用。&lt;/p&gt;
&lt;p&gt;    大家可以想象下，如果有100个优惠券，那么它们会存储于List&amp;lt;Coupan&amp;gt;类型的coupanList，同时，WeakHashMap&amp;lt;Coupan, &amp;lt;List&amp;lt;WeakReference &amp;lt;User&amp;gt;&amp;gt;&amp;gt;类型的weakCoupanHM对象会以键的形式存储这100个优惠券。而且，如果有1万个用户，那么我们可以用List&amp;lt;User&amp;gt;类型的userList对象来保存它们，假设coupan1这张优惠券对应着100个用户，那么我们一定会通过如下的代码存入这种键值对关系，weakCoupanHM.put(coupan1,weakUserList);，其中weakUserList里以弱引用的方式保存coupan1所对应的100个用户。&lt;/p&gt;
&lt;p&gt;    这样的话，一旦当优惠券或用户发生变更，它们的对应关系就能自动地更新，具体表现如下。&lt;/p&gt;
&lt;p&gt;    1 当某个优惠券（假设对应于coupan2对象）失效时，我们可以从coupanList里去除该对象，coupan2上就没有强引用了，只有weakCoupanHM对该对象还有个弱引用，这样coupan2对象能在下次垃圾回收时被回收，从而weakCoupanHM里就看不到了。&lt;/p&gt;
&lt;p&gt;    2 假设某个优惠券coupan3用弱引用的方式指向于100个用户，当某个用户（假设user1）注销账号时，它会被从List&amp;lt;User&amp;gt;类型的userList对象中被移除。这时该对象上只有weakCoupanHM里的值（也就是&amp;lt;List&amp;lt;WeakReference &amp;lt;User&amp;gt;&amp;gt;）这个弱引用，该对象同样能在下次垃圾回收时被回收，这样coupan3的关联用户就会自动地更新为99个。&lt;/p&gt;
&lt;p&gt;    如果不用弱引用，而是用常规的HashMap&amp;lt;Coupan,List&amp;lt;User&amp;gt;&amp;gt;来保存对应关系的话，那么一旦出现优惠券或用户的变更的话，那么我们就不得不手动地更新这个表示对应关系的HashMap对象了，这样，代码就会变得复杂，而且我们很有可能因疏忽而忘记在某个位置添加更新代码。相比之下，弱引用给我们带来的“自动更新“就能给我们带来很大的便利。&lt;/p&gt;
&lt;h5&gt;4 不能投机取巧，但面试确实有技巧&lt;/h5&gt;
&lt;p&gt;    笔者写本文的意思，不是让大家投机取巧，事实上，如果大家只知道这些知识，而不知道其他虚拟机（或Java Core）相关的知识点，面试通过的可能性很低。&lt;/p&gt;
&lt;p&gt;    但话说回来，如果大家在平时开发时积累了很多经验，但不会总结，在面试时也无法很好地展示各种能力，这样也是非常可惜的。&lt;/p&gt;
&lt;p&gt;    根据本人在培训学校的经验，首先通过可能掌握各种Java技能，在这个基础上再讲述上述软引用和弱引用的技能，这些候选人得到的反馈是，至少在Java Core方面比较精通。&lt;/p&gt;
&lt;p&gt;    在本文的其它博客里，也列了相关面试技巧，欢迎大家看其它的文章。&lt;/p&gt;



</description>
<pubDate>Sun, 01 Apr 2018 03:11:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8685993.html</dc:identifier>
</item>
<item>
<title>SpringMVC之处理流程 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8683971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8683971.html</guid>
<description>&lt;p&gt; 之前在学servlet时写过&lt;a href=&quot;http://www.cnblogs.com/5ishare/p/6534407.html&quot; target=&quot;_blank&quot;&gt;JavaWeb与Asp.net工作原理比较分析&lt;/a&gt;，那篇主要是大致描述了下servlet的工作流程,今天在家了解了下springmvc的工作原理,与asp.net中的mvc进行了一下比较&lt;a href=&quot;http://www.cnblogs.com/5ishare/p/4515850.html&quot; target=&quot;_blank&quot;&gt;asp.net MVC 的处理流程&lt;/a&gt;，思想都是差不多，都是通过一个url怎么映射到类中做完处理返回浏览器的过程，首先要解决三大问题,一是url映射转换成request和response对象的问题二是浏览器与服务端的数据交互问题三是服务端的request、response怎么响应给客户端。今天了解了下它的运行流畅,其实网上也有好多教程。&lt;/p&gt;
&lt;p&gt;一图顶千言万语，用数据、用图说话,下图是springmvc的工作原理图。 &lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401021502228-788157259.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SpringMVC工作流程&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一、  用户发送请求至前端控制器DispatcherServlet。　&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　    &lt;span&gt;1.DispatcherServlet它也是servlet,load-on-startup=1,tomcat启动时它也会初始化,初始化参数是contextConfigLocation上下文配置文件位置,参数值就是&lt;a href=&quot;http://www.cnblogs.com/5ishare/p/7703513.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JavaWeb之Eclipse中使用Maven构建SpringMVC项目&lt;/span&gt;&lt;/a&gt;  配置的spring-mvc。在spring-mvc中可以配置自动扫描包名、默认注解映射支持、视图解释类、拦截器、对静态资源文件的访问等信息，通过自动扫描包名、注解映射支持、静态资源访问这些配置的信息在就会实例化HandlerMapping对象。这些对象是在tomcat进行参数初始化的时候也会实例化完成。在DispatcherServlet中维护着一个表,类似C#MVC中的RouteTable 路由表,存放的是HandlerMapping对象list.下面截图是DispatcherServlet中的部分代码,在DispatcherServlet中维护着handerMappings、handerAdapters等对象列表。在initStrategies中对上面的一些属性进行初始化。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401000506924-312070040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_42c2145f-47b9-461b-84ec-9100654de1ac&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_42c2145f-47b9-461b-84ec-9100654de1ac&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_42c2145f-47b9-461b-84ec-9100654de1ac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initStrategies(ApplicationContext context) {
        initMultipartResolver(context);
        initLocaleResolver(context);
        initThemeResolver(context);
        initHandlerMappings(context);
        initHandlerAdapters(context);
        initHandlerExceptionResolvers(context);
        initRequestToViewNameTranslator(context);
        initViewResolvers(context);
        initFlashMapManager(context);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.客户端发出请求，由 Tomcat 接收到这个请求，如果匹配 DispatcherServlet 在 web.xml 中配置的映射路径，Tomcat 就将请求转交给 DispatcherServlet 处理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;二、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;span&gt;请求到达DispatcherServlet中之后，就是get、post这些请求，这些请求是DispatcherServlet的父类FrameworkServlet中定义着的，而在这些方法中又调用了processRequest，processRequest中调用了doService，DispatcherServlet重写了doService方法，doService中主要设置了一些属性和调用doDispatch方法,doDispatch用来做分发请求。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_c51de5ca-adfb-4382-8cdd-fc63234250ea&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c51de5ca-adfb-4382-8cdd-fc63234250ea&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c51de5ca-adfb-4382-8cdd-fc63234250ea&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doDispatch(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        HttpServletRequest processedRequest &lt;/span&gt;=&lt;span&gt; request;
        HandlerExecutionChain mappedHandler &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; multipartRequestParsed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        WebAsyncManager asyncManager &lt;/span&gt;=&lt;span&gt; WebAsyncUtils.getAsyncManager(request);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ModelAndView mv &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            Exception dispatchException &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                processedRequest &lt;/span&gt;=&lt;span&gt; checkMultipart(request);
                multipartRequestParsed &lt;/span&gt;= (processedRequest !=&lt;span&gt; request);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine handler for the current request.&lt;/span&gt;
                mappedHandler =&lt;span&gt; getHandler(processedRequest);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    noHandlerFound(processedRequest, response);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine handler adapter for the current request.&lt;/span&gt;
                HandlerAdapter ha =&lt;span&gt; getHandlerAdapter(mappedHandler.getHandler());

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process last-modified header, if supported by the handler.&lt;/span&gt;
                String method =&lt;span&gt; request.getMethod();
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isGet = &quot;GET&quot;&lt;span&gt;.equals(method);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isGet || &quot;HEAD&quot;&lt;span&gt;.equals(method)) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lastModified =&lt;span&gt; ha.getLastModified(request, mappedHandler.getHandler());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; +&lt;span&gt; lastModified);
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp;&lt;span&gt; isGet) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mappedHandler.applyPreHandle(processedRequest, response)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Actually invoke the handler.&lt;/span&gt;
                mv =&lt;span&gt; ha.handle(processedRequest, response, mappedHandler.getHandler());

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (asyncManager.isConcurrentHandlingStarted()) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                applyDefaultViewName(processedRequest, mv);
                mappedHandler.applyPostHandle(processedRequest, response, mv);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
                dispatchException &lt;/span&gt;=&lt;span&gt; ex;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable err) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; As of 4.3, we're processing Errors thrown from handler methods as well,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; making them available for @ExceptionHandler methods and other scenarios.&lt;/span&gt;
                dispatchException = &lt;span&gt;new&lt;/span&gt; NestedServletException(&quot;Handler dispatch failed&quot;&lt;span&gt;, err);
            }
            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable err) {
            triggerAfterCompletion(processedRequest, response, mappedHandler,
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; NestedServletException(&quot;Handler processing failed&quot;&lt;span&gt;, err));
        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (asyncManager.isConcurrentHandlingStarted()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instead of postHandle and afterCompletion&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (mappedHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Clean up any resources used by a multipart request.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (multipartRequestParsed) {
                    cleanupMultipart(processedRequest);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面的代码是核心代码，其实下面的几项其实就是代码的说明.　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
processedRequest =&lt;span&gt; checkMultipart(request);
multipartRequestParsed &lt;/span&gt;= (processedRequest != request);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面这两句是判断请求是不是上传文件的请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mappedHandler =&lt;span&gt; getHandler(processedRequest);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedHandler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    noHandlerFound(processedRequest, response);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401003856440-1497378997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401005210447-1162924460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getHander返回的是一个HandlerExecutionChain,这个HandlerExecutionChain中包含一个handler和多个HandlerInterceptor(拦截器),这个和asp.net中的管道模型有点类似，一个httphandler和多个httpmodule,httpmodule也是用来做拦截操作的。同时要留意HandlerExecutionChain是通过HandlerMapping对象的getHandler获取的.其实这里还可以扩展比如拦截器的使用、HandlerMapping的介绍等,由于篇幅有限，会在以后的博客中一个一个的介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;四、  DispatcherServlet调用HandlerAdapter处理器适配器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_f7a7bdcc-0051-4ca8-bc48-e911de255b34&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f7a7bdcc-0051-4ca8-bc48-e911de255b34&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f7a7bdcc-0051-4ca8-bc48-e911de255b34&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; HandlerAdapter getHandlerAdapter(Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.handlerAdapters != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (HandlerAdapter ha : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlerAdapters) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isTraceEnabled()) {
                    logger.trace(&lt;/span&gt;&quot;Testing handler adapter [&quot; + ha + &quot;]&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ha.supports(handler)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ha;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;No adapter for handler [&quot; + handler +
                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;获取适配器是通过遍历handlerAdapters列表找的,HandlerAdapter包含了3个方法.boolean supports(Object handler);ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;long getLastModified(HttpServletRequest request, Object handler);&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_79303388-652a-4008-9528-0330fe5c8c48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_79303388-652a-4008-9528-0330fe5c8c48&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_79303388-652a-4008-9528-0330fe5c8c48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2002-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt;
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.lang.Nullable;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * MVC framework SPI, allowing parameterization of the core MVC workflow.
 *
 * &amp;lt;p&amp;gt;Interface that must be implemented for each handler type to handle a request.
 * This interface is used to allow the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; DispatcherServlet} to be indefinitely
 * extensible. The {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; DispatcherServlet} accesses all installed handlers through
 * this interface, meaning that it does not contain code specific to any handler type.
 *
 * &amp;lt;p&amp;gt;Note that a handler can be of type {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Object}. This is to enable
 * handlers from other frameworks to be integrated with this framework without
 * custom coding, as well as to allow for annotation-driven handler objects that
 * do not obey any specific Java interface.
 *
 * &amp;lt;p&amp;gt;This interface is not intended for application developers. It is available
 * to handlers who want to develop their own web workflow.
 *
 * &amp;lt;p&amp;gt;Note: {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HandlerAdapter} implementors may implement the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt;
 * org.springframework.core.Ordered} interface to be able to specify a sorting
 * order (and thus a priority) for getting applied by the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; DispatcherServlet}.
 * Non-Ordered instances get treated as lowest priority.
 *
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Rod Johnson
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Juergen Hoeller
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.SimpleServletHandlerAdapter
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; HandlerAdapter {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Given a handler instance, return whether or not this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; HandlerAdapter}
     * can support it. Typical HandlerAdapters will base the decision on the handler
     * type. HandlerAdapters will usually only support one handler type each.
     * &amp;lt;p&amp;gt;A typical implementation:
     * &amp;lt;p&amp;gt;{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt;
     * return (handler instanceof MyHandler);
     * }
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler handler object to check
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; whether or not this object can use the given handler
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; supports(Object handler);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Use the given handler to handle this request.
     * The workflow that is required may vary widely.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; response current HTTP response
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler handler to use. This object must have previously been passed
     * to the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; supports} method of this interface, which must have
     * returned {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true}.
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception in case of errors
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; ModelAndView object with the name of the view and the required
     * model data, or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} if the request has been handled directly
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Nullable
    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Same contract as for HttpServlet's {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; getLastModified} method.
     * Can simply return -1 if there's no support in the handler class.
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request current HTTP request
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; handler handler to use
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the lastModified value for the given handler
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServlet#getLastModified
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.LastModified#getLastModified
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt;&lt;span&gt; getLastModified(HttpServletRequest request, Object handler);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;五、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。&lt;/p&gt;
&lt;p&gt;六、  Controller执行完成返回ModelAndView。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;七、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1075c2bb-89bc-482e-9e93-d6e3ad22a219&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1075c2bb-89bc-482e-9e93-d6e3ad22a219&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1075c2bb-89bc-482e-9e93-d6e3ad22a219&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process last-modified header, if supported by the handler.&lt;/span&gt;
                String method =&lt;span&gt; request.getMethod();
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isGet = &quot;GET&quot;&lt;span&gt;.equals(method);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isGet || &quot;HEAD&quot;&lt;span&gt;.equals(method)) {
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lastModified =&lt;span&gt; ha.getLastModified(request, mappedHandler.getHandler());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                        logger.debug(&lt;/span&gt;&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; +&lt;span&gt; lastModified);
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp;&lt;span&gt; isGet) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mappedHandler.applyPreHandle(processedRequest, response)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Actually invoke the handler.&lt;/span&gt;
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 上面的几行代码先判断如果是get请求更新下lastModified请求头,然后执行HandlerExecutionChain中的applyPreHandle这个方法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_35148a87-656d-4b19-95b1-bdac7f074e16&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35148a87-656d-4b19-95b1-bdac7f074e16&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35148a87-656d-4b19-95b1-bdac7f074e16&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;boolean&lt;/span&gt; applyPreHandle(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        HandlerInterceptor[] interceptors &lt;/span&gt;=&lt;span&gt; getInterceptors();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ObjectUtils.isEmpty(interceptors)) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; interceptors.length; i++&lt;span&gt;) {
                HandlerInterceptor interceptor &lt;/span&gt;=&lt;span&gt; interceptors[i];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!interceptor.preHandle(request, response, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handler)) {
                    triggerAfterCompletion(request, response, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptorIndex =&lt;span&gt; i;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_966e5abb-12ee-4e48-98e9-8460695c6f4e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_966e5abb-12ee-4e48-98e9-8460695c6f4e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_966e5abb-12ee-4e48-98e9-8460695c6f4e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        HandlerInterceptor[] interceptors &lt;/span&gt;=&lt;span&gt; getInterceptors();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ObjectUtils.isEmpty(interceptors)) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;.interceptorIndex; i &amp;gt;= 0; i--&lt;span&gt;) {
                HandlerInterceptor interceptor &lt;/span&gt;=&lt;span&gt; interceptors[i];
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    interceptor.afterCompletion(request, response, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handler, ex);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex2) {
                    logger.error(&lt;/span&gt;&quot;HandlerInterceptor.afterCompletion threw exception&quot;&lt;span&gt;, ex2);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在applyPreHandle中它会遍历该HandlerExecutionChain中所有的拦截器,然后使用拦截器通过preHandle对handler进行预处理，如果所有的拦截器都能处理那就会继续往下执行，如果一旦有一个拦截器不能处理，就没必要往下走了，那就会触发triggerAfterCompletion方法，在triggerAfterCompletion中它是倒序遍历的拦截器的，执行完triggerAfterCompletion返回false之后doDispatch这个方法就执行结束了，下面的八、九、十、十一就不再执行。从第五步括号里的备注也能猜出来HandlerExecutionChain.handler是什么,它可以是Controller。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;八、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 九、  ViewReslover解析后返回具体View。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
applyDefaultViewName(processedRequest, mv);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ab186f58-e894-4ad0-a26f-cbac279d9c33&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ab186f58-e894-4ad0-a26f-cbac279d9c33&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab186f58-e894-4ad0-a26f-cbac279d9c33&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; applyDefaultViewName(HttpServletRequest request, @Nullable ModelAndView mv) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mv != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;mv.hasView()) {
            String defaultViewName &lt;/span&gt;=&lt;span&gt; getDefaultViewName(request);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultViewName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                mv.setViewName(defaultViewName);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_ce3ffef9-e4f6-46ab-97fa-92cd3146abe2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ce3ffef9-e4f6-46ab-97fa-92cd3146abe2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ce3ffef9-e4f6-46ab-97fa-92cd3146abe2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; String getDefaultViewName(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.viewNameTranslator != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;.viewNameTranslator.getViewName(request) : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;找到ModelAndView对应的viewname，设置成它的属性值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mappedHandler.applyPostHandle(processedRequest, response, mv);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;applyPostHandle与applyPreHandle是对应着的，遍历handler的拦截器，执行postHandle方法。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_22230f62-2a2c-411f-b3be-e4592ef804f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_22230f62-2a2c-411f-b3be-e4592ef804f8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_22230f62-2a2c-411f-b3be-e4592ef804f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processDispatchResult(HttpServletRequest request, HttpServletResponse response,
            @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
            @Nullable Exception exception) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; errorView = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ModelAndViewDefiningException) {
                logger.debug(&lt;/span&gt;&quot;ModelAndViewDefiningException encountered&quot;&lt;span&gt;, exception);
                mv &lt;/span&gt;=&lt;span&gt; ((ModelAndViewDefiningException) exception).getModelAndView();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                Object handler &lt;/span&gt;= (mappedHandler != &lt;span&gt;null&lt;/span&gt; ? mappedHandler.getHandler() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                mv &lt;/span&gt;=&lt;span&gt; processHandlerException(request, response, handler, exception);
                errorView &lt;/span&gt;= (mv != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did the handler return a view to render?&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (mv != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;mv.wasCleared()) {
            render(mv, request, response);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (errorView) {
                WebUtils.clearErrorRequestAttributes(request);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(&lt;/span&gt;&quot;Null ModelAndView returned to DispatcherServlet with name '&quot; + getServletName() +
                        &quot;': assuming HandlerAdapter completed request handling&quot;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Concurrent handling started during a forward&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mappedHandler.triggerAfterCompletion(request, response, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_d80b83d6-3d58-4985-adfc-361f7c026ec0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d80b83d6-3d58-4985-adfc-361f7c026ec0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d80b83d6-3d58-4985-adfc-361f7c026ec0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Determine locale for request and apply it to the response.&lt;/span&gt;
        Locale locale =&lt;span&gt;
                (&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.localeResolver != &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.localeResolver.resolveLocale(request) : request.getLocale());
        response.setLocale(locale);

        View view;
        String viewName &lt;/span&gt;=&lt;span&gt; mv.getViewName();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (viewName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We need to resolve the view name.&lt;/span&gt;
            view =&lt;span&gt; resolveViewName(viewName, mv.getModelInternal(), locale, request);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;Could not resolve view with name '&quot; + mv.getViewName() +
                        &quot;' in servlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; No need to lookup: the ModelAndView object contains the actual View object.&lt;/span&gt;
            view =&lt;span&gt; mv.getView();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (view == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +
                        &quot;View object in servlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Delegate to the View object for rendering.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
            logger.debug(&lt;/span&gt;&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name '&quot; + getServletName() + &quot;'&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mv.getStatus() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                response.setStatus(mv.getStatus().value());
            }
            view.render(mv.getModelInternal(), request, response);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                logger.debug(&lt;/span&gt;&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name '&quot; +&lt;span&gt;
                        getServletName() &lt;/span&gt;+ &quot;'&quot;&lt;span&gt;, ex);
            }
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在processDispatchResult方法中有一句render(mv, request, response),在render中先是获取View对象然后调用view.render(mv.getModelInternal(), request, response);将view和model绑定来进行渲染试图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十一、 DispatcherServlet响应用户。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;响应用户其实是在父类FrameworkServlet的processRequest方法中&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201804/733213-20180401021314722-1672082247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;十二、小结&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上面黑字部分是参考其他博客的，红色的是通过读源码找的，现在基本清楚springmvc大致的流程，其实如果继续深入的话，还有好多知识点，这篇博客就写到这，以后再慢慢补充。好久没熬夜学习了，今天算是毕业之后最用功的一天了,哈哈...(今天四月一,愚人节!!!)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;参考:https://www.cnblogs.com/xiaoxi/p/6164383.html&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 18:35:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8683971.html</dc:identifier>
</item>
<item>
<title>论文阅读——Visual inertial odometry using coupled nonlinear optimization - 跃行者</title>
<link>http://www.cnblogs.com/yuely/p/8684369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuely/p/8684369.html</guid>
<description>&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;论文提出一种新的视觉里程计算法，其直接利用带噪声的IMU数据和视觉特征位置来优化相机位姿。不同于对IMU和视觉数据运行分离的滤波器，这种算法将它们纳入联合的非线性优化框架中。视觉特征的透视重投影代价函数以及从IMU和位姿轨迹得到的加速度和角速度运动代价函数被联合优化。&lt;/p&gt;
&lt;h2&gt;一、算法的整体框架&lt;/h2&gt;
&lt;p&gt;　　文中提出的在线VIO算法，其限制优化窗口只包括最近的观测和参数。随着窗口尺寸的变化，估计精度和计算成本之间的权衡就会出现。这种算法属于利用优化框架的基于关键帧的方法，与之前方法相反的是，不边缘化之前的状态并优化局部窗口内的所有位姿。其主要的贡献是设计了局部优化代价函数，它不仅高效，而且尽可能的保证精度。算法的主要流程如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331214437583-2007808559.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;传统的视觉里程计系统包括特征捕捉、位姿估计和滤波或优化步骤。特征点的检测与跟踪贯穿于所有输入帧，然后帧（或者关键帧）之间的相机运动从特征运动计算出来。可视的特征被保留为3D路标，并且它们被用于计算或提高相机轨迹。文中提出的算法遵循了视觉里程计的基本步骤，并且融合了来自IMU的加速度和角速度测量值。&lt;/p&gt;
&lt;h2&gt;二、算法细节&lt;/h2&gt;
&lt;p&gt;　　利用IMU数据存在几个问题，首先是IMU数据的获取频率与视频帧率不一致，并且远高于视频帧率。我们利用相机帧数k表示设备运动的参考时间索引。由于IMU测量频率远高于帧率，假设加入的IMU测量值(&lt;em&gt;t&lt;sub&gt;k&lt;/sub&gt;+∆t&lt;/em&gt;)紧接着帧&lt;em&gt;k&lt;/em&gt;。独立的加速度和角速度Kalman滤波器被用来减轻传感器读数中的噪声，并且我们用样条内插法来计算在相机帧处的同步的IMU估计值（如下图）。IMU读数带有偏差并且必须对它们精准的建模和估计以避免偏移。不同于在滤波框架中对偏差进行建模，在优化中，偏差参数和相机位姿以及路标位置一起通过完整地利用视觉特征观测进行估计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331215344087-2078417223.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单目视觉里程计只能估计相机运动到尺度，在视觉惯性里程计中，来自IMU的加速度数据可以被用来确定度量尺度。然而IMU只提供带噪声的设备的加速度测量值，恢复移动的距离必须被双重积分。并且，原始的IMU加速度数据包括重力，其必须被消除以正确计算运动，这需要精确的垂直方向估计。&lt;/p&gt;
&lt;h3&gt;A、数学公式&lt;/h3&gt;
&lt;p&gt;　　相机在&lt;em&gt;t&lt;/em&gt;时刻的六自由度位姿&lt;strong&gt;p&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;/em&gt;表示成旋转和位移矢量(&lt;strong&gt;r&lt;/strong&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;em&gt;&lt;sup&gt;T&lt;/sup&gt;&lt;/em&gt;, &lt;strong&gt;t&lt;/strong&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;em&gt;&lt;sup&gt;T&lt;/sup&gt;&lt;/em&gt;)&lt;em&gt;&lt;sup&gt;T&lt;/sup&gt;&lt;/em&gt; 。3×3旋转矩阵&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;可以和&lt;strong&gt;r&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;相互转换：&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt; = R(&lt;strong&gt;r&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;)并且&lt;strong&gt;r&lt;/strong&gt;&lt;em&gt;t &lt;/em&gt;= rot(&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;t&lt;/em&gt;)。相机位姿和路标位置在大地坐标系其&lt;em&gt;z&lt;/em&gt;轴平行于重力方向。 IMU测量的加速度$\mathbf{\hat{a}}_t$包含重力和偏差。其在载体坐标系中。为了计算在大地坐标系下的加速度&lt;strong&gt;a&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;/em&gt;，加速度偏差$\mathbf{\hat{b}}_t$ 和重力&lt;strong&gt;g&lt;/strong&gt;必须被适当的减掉:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331220559763-573914042.png&quot; alt=&quot;&quot; width=&quot;193&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从三个利用视觉特征计算出的相机位姿，我们也可以计算加速度$\mathbf{\bar{a}}_t$ 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331220837355-1534735561.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，Δt是两连续帧之间的时间。在我们的优化框架中的加速度误差即为从视觉特征得到的加速度和从IMU得到的加速度之间的差别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331220959996-1993379725.png&quot; alt=&quot;&quot; width=&quot;134&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;角速度$\mathbf{\hat{ω}}_t$也通过IMU测量出来，并且角速度在大地坐标系下为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331222434064-709519397.png&quot; alt=&quot;&quot; width=&quot;225&quot; height=&quot;30&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，$\mathbf{\hat{b}}_t$是陀螺仪偏差。来自视觉特征的角速度$\mathbf{\bar{ω}}_t$ 为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331222641519-1543484511.png&quot; alt=&quot;&quot; width=&quot;188&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因而角速度误差$\mathbf{e}^ω_t$可以被定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331222826185-1303478097.png&quot; alt=&quot;&quot; width=&quot;129&quot; height=&quot;33&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，重投影误差$\mathbf{e}^{proj}_{i,j}$通过利用相机位姿&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;&lt;em&gt;j&lt;/em&gt;&lt;/sub&gt;和路标&lt;strong&gt;x&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;位置计算：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331223211956-472693728.png&quot; alt=&quot;&quot; width=&quot;230&quot; height=&quot;40&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，proj(&lt;strong&gt;x&lt;/strong&gt;;&lt;strong&gt;p&lt;/strong&gt;)是3D点在相机位姿&lt;strong&gt;p&lt;/strong&gt;的投影图像坐标，并且f&lt;sub&gt;&lt;em&gt;i,j&lt;/em&gt;&lt;/sub&gt;是图像&lt;em&gt;j&lt;/em&gt;中路标&lt;em&gt;i&lt;/em&gt;的特征位置。&lt;/p&gt;
&lt;h3&gt;B、批量优化（用来做对比）&lt;/h3&gt;
&lt;p&gt;　　当视频帧和IMU测量值已知时，我们可以计算使得以上误差最小的相机轨迹。对于IMU读数$\{\mathbf{\hat{a}}_t, \mathbf{\hat{ω}}_t\}_T$以及跟踪的特征集合F = {&lt;strong&gt;f&lt;/strong&gt;&lt;em&gt;&lt;sub&gt;i,j&lt;/sub&gt;&lt;/em&gt;}，批量优化的代价函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331224211521-1651272463.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;68&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在相机位姿&lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt;, …, &lt;strong&gt;p&lt;/strong&gt;&lt;sub&gt;T&lt;/sub&gt;，路标&lt;strong&gt;x&lt;/strong&gt;&lt;sub&gt;1&lt;/sub&gt;, …, &lt;strong&gt;x&lt;/strong&gt;&lt;sub&gt;T&lt;/sub&gt;，和偏差&lt;strong&gt;b&lt;/strong&gt;&lt;sub&gt;a&lt;/sub&gt;, &lt;strong&gt;b&lt;/strong&gt;&lt;sub&gt;ω&lt;/sub&gt;处优化。||·||Σ是Mahalanobis距离，协方差为Σ。在论文中，协方差设为固定的方差$\mathbf{σ}_f^2, \mathbf{σ}_a^2, \mathbf{σ}_ω^2$的对角协方差矩阵。批量优化算法的结果显著地优于任何在线算法。批量优化可以生成最准确的结果，但是其要求所有的数据在处理之前就准备好，并且其需要长时间来收敛。&lt;/p&gt;
&lt;h3&gt;C、在线优化（滑动窗口法）&lt;/h3&gt;
&lt;p&gt;　　考虑应用目的，VIO必须能够实时地输出当前的相机位姿。为达到此目的，论文提出了简化的批量优化版本。在大多数视觉里程计系统中，当运动或视觉内容存在存在显著的改变时，选为关键帧。重投影误差项仅仅建立在关键帧和路标上。我们采取用了惯例，并利用关键帧来生成路标和位姿优化。在每一帧，相机位姿利用3维路标的图像位置计算出来，并且当相机移动较为明显时，帧被初始化为关键帧。建立在关键帧上的特征轨迹在优化中提供了足够多的相机位姿和路标位置上的约束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331224647942-209342180.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而如果IMU测量值在关键帧之间平均可能就成问题，因为关键帧比帧更加稀疏。最近的一些关键帧之间的帧被包含在优化中以约束连续帧之间的运动。这些活动的VIO帧用惯性约束连接了关键帧。这些帧的特征位置没有在优化中利用，因为这样会增加计算成本，并且连续帧之间的特征运动并不明显。当关键帧添加后，在线优化在活动的VO关键帧K&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;和活动的路标L&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;以及活动的VIO帧T&lt;sub&gt;&lt;em&gt;a&lt;/em&gt;&lt;/sub&gt;上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331225006252-2087289299.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中K&lt;em&gt;&lt;sub&gt;f&lt;/sub&gt;&lt;/em&gt;是固定VO关键帧，它被用来强制路标位置与局部优化窗口之外的观测保持一致。VIO在线优化过程概括如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331225122735-1171975724.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;D、实施细节&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;前端：&lt;/strong&gt;对于VO或VIO系统，通常要么采用快速二进制描述子比如BRIEF或ORB，或者特征跟踪器比如KLT。论文采用Harris角点检测子和KLT用于特征跟踪。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化：&lt;/strong&gt;绝对尺度可以从IMU数据恢复，但是在初始化期间只存在有限数量的带噪声的IMU数据。论文选择的初始化策略是：首先利用可得到的数据（视觉信息）大致正确地初始化模型，然后在在线优化过程中利用即将到来的测量值更新模型。为了确定初始尺度因子&lt;em&gt;s&lt;/em&gt;首先通过积分IMU数据计算出最开始的两个关键帧之间的实际移动距离d&lt;em&gt;&lt;sub&gt;IMU&lt;/sub&gt;&lt;/em&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352904/201803/1352904-20180331225346471-936710800.png&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;170&quot;/&gt;　　　 计算出的尺度&lt;em&gt;s&lt;/em&gt;乘以相机和路标的位置，然后在两个关键帧以及关键帧之间的所有帧上执行在线优化以得到更加准确的初始化。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 16:19:00 +0000</pubDate>
<dc:creator>跃行者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuely/p/8684369.html</dc:identifier>
</item>
</channel>
</rss>