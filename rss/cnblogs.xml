<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>帅案之上——作为开发者的远见与卓识 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/8088163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/8088163.html</guid>
<description>&lt;p&gt;一周以来有关“欧建新”的话题在网络上不断发酵，愈演愈烈。有的人说是不惑之年的彷徨，也有人认为是国内IT从业人员的悲凉。今日又有传言南京途牛旅游突然裁员，遭到裁员的人员主要是各部门的开发人员。看来，真正的严冬才刚刚开始。如何度过一个又一个寒冬并生存下来，我们聊聊。&lt;/p&gt;
&lt;p&gt;一、未来五年的机会在哪里&lt;/p&gt;
&lt;p&gt;中国的“速度”举世瞩目，到底如何辉煌不需要我在这里吹嘘。但是就我切身体会而言，与其用“中国速度”不如用“中国波动”来形容国内经济变化的波诡云谲来的更加贴切。观察自80年代改革开放以来，国内经济每逢重大变革无一不是伴随着一批人的青云直上和另一批人的黯然离场。时至今日，这种波动也愈发剧烈。如果以前我们还可以用下一个十年来总结未来中国经济发展走向的话，如今只能用未来五年甚至三年来作为判断的跨度。毫无疑问，时代的宠儿——“互联网”已经在所谓“互联网+”的本轮浪潮中走进了它的巅峰时刻。&lt;/p&gt;
&lt;p&gt;水满自溢，月满而亏。无论是哪种形式的“互联网”经济都很难延续曾经的辉煌。下一轮IT业的浪潮或许将体现在人工智能和工业4.0等领域。这里我有意避免提及当下势头正劲的“机器学习”，因为“机器学习”类似自然科学中的基础理论，它的价值必须要同生产力相结合才能得以体现。就目前来看最大的可能就是工业4.0概念——也正是中国要从制造业大国转型为制造业强国的关键。&lt;/p&gt;
&lt;p&gt;根据以上的宏观判断，我个人的想法是以C/C++为代表的底层开发语言或以Python为代表的时尚新贵将异军突起。&lt;/p&gt;
&lt;p&gt;二、学会下蹲与起跳&lt;/p&gt;
&lt;p&gt;人生也好，事业也罢。就如同行走在路上的旅人，脚下的路并非只是康庄大道，绝美与壮丽伴随艰辛与崎岖。以前总是听到说三十岁以后就不适合继续从事开发，后来又说四十岁就必须转行做管理。我想，以上论点的正确与否暂且不论，作为一个独立的个体首先应该具备独立思考的能力。如果希望自己能在开发者的道路上不断前进，应该明白如何下蹲以及何时起跳。&lt;/p&gt;
&lt;p&gt;在大部分的开发任务中，客户总是希望你能够快速的完成任务，快速的解决故障，快速的修改需求。在此我们不谈具体的开发手段——例如迭代开发或敏捷开发——从自身出发如何有效分析需求，对于开发中暂时无法确定的方案如何预留出空间亦或通过合理的结构降低模块耦合。都是我们需要通过不断练习才能获得的技能。&lt;/p&gt;
&lt;p&gt;此外，我们还应该善于利用时间：阅读开源框架或深入系统的学习某些方面的知识并至少应该掌握2至3种主流开发语言。因为只有当你的自身储备足够丰富的时候，身边的“机会”才能如同水中的石头逐渐显露出来。&lt;/p&gt;
&lt;p&gt;掌握节奏，为下一次起跳做足功课。诚然“下蹲”不是我们的目的，但是要想“跳”的更高你必须有所准备，否则再多的尝试也不过是原地蹦跶。&lt;/p&gt;
&lt;p&gt;三、静水流深&lt;/p&gt;
&lt;p&gt;你为什么要做一个开发者？如果你觉得这个问题不好回答让我换个问法：是什么吸引你来到这个行业？&lt;/p&gt;
&lt;p&gt;先谈谈我对这个问题的理解。之所以是理解而不说是答案主要是因为我自己能给出的回答都不止一个。但是如果今天只能留下一种回答的话，我想应该是：开发工作能够给予我的心流体验是其它所不能比拟的。也正是如此，我才会在本已而立的年龄毅然转行并通过学习一步步实现着核心竞争力的锻造。&lt;/p&gt;
&lt;p&gt;我们行走在各自的人生轨道上，大部分人都或多或少有着自己的目标与追求。人人都向往成功，但现实是——我们之中或许只有极少数的人能真正做到成功，甚至恐怕有些人一出生就注定只能平凡度日。我们会经历苦痛，也会品尝到挫折，如果这些都未曾将你击倒请不要迷失在眼前的繁华中。&lt;/p&gt;

&lt;p&gt;后记：今天是12月22日——冬至。回家后同父母下楼烧了些纸钱。望着眼前的四丛火焰摇曳着，眼角突然就湿润了。泛着红光的纸屑被风吹到很远的地方，似乎也从我的心中抽走了些东西，是什么呢...&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 16:34:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/8088163.html</dc:identifier>
</item>
<item>
<title>读研以来的一些感想：名校好在哪里？ - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8088158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8088158.html</guid>
<description>&lt;p&gt;读研半年以来，逐渐了解了学校对学生的培养是怎么样的，同时我把现在的学校做的一些举措跟我本科的学校做了下对比，顿时感慨良多：名校与普通学校的对学生的培养真的非常不一样。我本科是普通一本，研究生读的是一所很不错的985。读研以来，身边发生的一些事，见过的一些人，都让我深深地感受到，名校与普通学校对学生的培养，是全方位的不一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.对学生的要求不一样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举两个身边的两件事说明一下。第一件事是图书馆借书还书的规定，我本科学校对于逾期还书的同学的处理是交钱，一天好像2毛，这也是全国众多图书馆对于逾期还书读者的一些惩罚手段。而现在的学校，对于处理逾期还书的读者的做法就是，做题！逾期30天的，做50题，逾期60天的，做100题，反正就是逾期越久做题越多。还有逾期多次的，直接取消借书资格。我对于这种处理是相当服气的，有一次我逾期了，我以为也只是交几块钱就算完事了。但却被告知要做50题，不做完没法继续借书，而且要达到一定准确率，当然啦，做的题都是一些图书馆的管理规定题，就是让你好好记住以后别忘记还书了。我硬生生地做了半个小时，非常痛苦，也下定决心以后不再逾期还书了。&lt;/p&gt;
&lt;p&gt;第二件事是现在的学校采取了一个很有意思的规定，就是每个学生都要修够一定的公益时才能毕业。什么是公益时？就是去参加一些自愿活动和公益活动，然后就会获得相应的公益时，换言之，每个学生要在他的学习之余抽出时间做一下对他人对社会有贡献事情，比如帮人家修修电脑啊，当一下一些活动的工作人员啊，去看望老奶奶啊等等。这个规定我觉得是真的棒，在大学里学习，学的不仅是知识，还有要学正确的价值观，懂得怎么回报社会，感激他人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.学习氛围一级棒&lt;/strong&gt;&lt;br/&gt;也举两件事来说明一下。&lt;/p&gt;
&lt;p&gt;第一件事就是实验室氛围。我们实验室的同学还是很努力的，每天都会搞到很晚，没有人打游戏没有人看电影偷懒，感觉都很自觉。不知道其他实验室氛围如何，反正我对我的实验室氛围很满意，跟一群勤奋的家伙一起学习工作，想要不落后他们，最好的办法就跟紧他们的脚步！&lt;/p&gt;
&lt;p&gt;第二件事就是学生的积极性。尤其是本科生，对于实践和学习非常热衷。很多大二大三的学生都已经加入实验室做一些研究了，这让我一个研一师兄脸红不已。我想想我大二大三在干嘛？LOL啊！差距差距。。。上段时间我的项目需要招募一些本科生做一些开发，就随意发了个消息到大三级群来招募队员，当时也没说有什么福利。没想到的是，还是有很多学生第一时间联系我了，要求加入项目组。我就纳闷了，你们怎么这么积极参加这些东西？他们说想积累一些项目经验，为以后找工作多做准备。他们平时课程很多，但是总能挤出时间完成我分配给他们的任务，他们还有时间搞搞自己的APP，打打比赛，这种积极性我确实佩服。那我本科学校没有这种同学吗？肯定有，但是非常少，而这边却是一大堆学生都这么优秀，真的厉害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.有钱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;名校就是有钱，而且就是比你普通学校有钱得多！服务器就买最贵的，我们所就有3台18W 的TITAN X*8的服务器，跑深度学习爽的飞起。重要的是，我们用的人并不多，不需要抢来抢去，人均3个TITAN X GPU吧，想想都开心。当然，老师也经常向我们强调，这些资源都是他们很努力才争取回来的，让我们好好搞尽快出成果。哈哈，当然，有好的设备，学习和研究都会顺利很多。除了设备方面，生活方面都显得比较土豪，什么发月饼啊发汤圆啊发饺子啊，虽然都不是值钱的东西，但是发了总会让学生开心一阵子。这些我本科学校都没见到（手动微笑）。&lt;/p&gt;
&lt;p&gt;还有就是讲座，学院经常请到一些很牛的人过来做演讲，比如什么院士啊，CEO啊，微软经理啊等等，一开始还是很有兴趣经常去听，但是讲座确实太多，到后来我都懒得去了，只挑最感兴趣的讲座去听一下。然后回想一下，我本科四年居然没听过讲座哈哈！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.一些我认为差别不大的地方&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读研之前，我以为名校老师讲课都很认真，很厉害，很想在课堂中一睹大咖们的风采。其实啊，名校老师的学术背景会比较强，但是讲课好不好或者认不认真讲就一回事了。反正我觉得能把课讲好的老师并不多，这还是有点失望的。当然啦，他们对考核会更严格一些，也许跟现在上的是研究生课程有关？&lt;/p&gt;
&lt;p&gt;这些都是我读研以来对学校教育的一些感想，总体感觉就是，好的平台给你了，起不起飞就看自己了。不能起飞，就给自己响亮的两个耳光吧！共勉！&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 16:31:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8088158.html</dc:identifier>
</item>
<item>
<title>System.getProperty()方法获取系统变量 - 人不学习枉少年</title>
<link>http://www.cnblogs.com/homejim/p/8088124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/8088124.html</guid>
<description>&lt;p&gt;来自我的CSDN博客   今天在阅读JDBC的DriverManager类源码时，看到了这么一句代码：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;System.getProperty(&quot;jdbc.drivers&quot;)；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  getProperty()这个方法是获取指定键指示的系统属性的，也就是说上面的代码获取的是jdbc.drivers这个属性。我写了个测试测试输出，发现是null值。于是就打算看看系统属性中有没有jdbc.drivers这个值。   查看了一下java api中的getProperty()这个方法，后通过getProperties()找到了能获取到的属性，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171222234017144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3MTM5MTk3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;getProperties()能获取到的属性&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  但是居然没有我的jdbc.drivers,于是本着负责的态度，我决定将所有的属性都输出看一看。以下是通过System.getPropertys()和System.getProperty()变量所有系统属性的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void test(){
            //获取所有的属性
        Properties properties = System.getProperties();
        //遍历所有的属性
        for (String key : properties.stringPropertyNames()) {
            //输出对应的键和值
            System.out.println(key + &quot;=&quot; + properties.getProperty(key));
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  对应的结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;java.runtime.name=Java(TM) SE Runtime Environment sun.boot.library.path=C:\javaweb\jdk1.8.0_101_64\jre\bin java.vm.vendor=Oracle Corporation java.vendor.url=http://java.oracle.com/ path.separator=; java.vm.name=Java HotSpot(TM) 64-Bit Server VM file.encoding.pkg=sun.io user.script= user.country=CN sun.java.launcher=SUN_STANDARD sun.os.patch.level= java.vm.specification.name=Java Virtual Machine Specification user.dir=E:\7.ProjectCodeSource\jdbc java.runtime.version=1.8.0_101-b13 java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment java.endorsed.dirs=C:\javaweb\jdk1.8.0_101_64\jre\lib\endorsed os.arch=amd64 java.io.tmpdir=C:\Users\ADMINI~1\AppData\Local\Temp&lt;br/&gt;line.separator=&lt;/p&gt;
&lt;p&gt;java.vm.specification.vendor=Oracle Corporation user.variant= os.name=Windows 10 sun.jnu.encoding=GBK java.library.path=C:\javaweb\jdk1.8.0_101_64\bin; java.specification.name=Java Platform API Specification java.class.version=52.0 sun.management.compiler=HotSpot 64-Bit Tiered Compilers os.version=10.0 user.home=C:\Users\Administrator user.timezone= java.awt.printerjob=sun.awt.windows.WPrinterJob file.encoding=UTF-8 java.specification.version=1.8 user.name=Administrator java.class.path=E:\7.ProjectCodeSource\jdbc\target\test-classes; java.vm.specification.version=1.8 sun.arch.data.model=64 java.home=C:\javaweb\jdk1.8.0_101_64\jre sun.java.command=org.eclipse.jdt.internal.junit.runner.RemoteTestRunner -version 3 -port 57975 -testLoaderClass org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader -loaderpluginname org.eclipse.jdt.junit4.runtime -test com.jim.jdbc.JDBCTest:test java.specification.vendor=Oracle Corporation user.language=zh awt.toolkit=sun.awt.windows.WToolkit java.vm.info=mixed mode java.version=1.8.0_101 java.ext.dirs=C:\javaweb\jdk1.8.0_101_64\jre\lib\ext;C:\Windows\Sun\Java\lib\ext sun.boot.class.path=C:\javaweb\jdk1.8.0_101_64\jre\lib\resources.jar;C:\javaweb\jdk1.8.0_101_64\jre\lib\rt.jar;C:\javaweb\jdk1.8.0_101_64\jre\lib\sunrsasign.jar; java.vendor=Oracle Corporation file.separator=&lt;br/&gt;java.vendor.url.bug=http://bugreport.sun.com/bugreport/ sun.cpu.endian=little sun.io.unicode.encoding=UnicodeLittle sun.desktop=windows sun.cpu.isalist=amd64&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  输出的东西也太乱了，我就加了一句判断看有没有jdbc.drivers这个属性。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
    public void test(){
        //获取所有的属性
        Properties properties = System.getProperties();
        //为了看看系统的属性有几个，加了一个计数器
        int count = 0;
        //遍历所有的属性
        for (String key : properties.stringPropertyNames()) {
            System.out.println(key + &quot;=&quot; + properties.getProperty(key));
            count++;
            if (key.equalsIgnoreCase(&quot;jdbc.drivers&quot;)){
                System.out.println(&quot;YES&quot;);
                return ;
            }

        }
        System.out.println(count);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  结果是根本没有jdbc.drivers这个属性，系统的属性有57个，比java api中列出来的要多，所以如果你的属性不再java api的所列出的列表中，不要灰心，可以使用上面的代码判断一下。&lt;/p&gt;
&lt;p&gt;  我后来看了java api之后，加了一句代码在方法最前面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   System.setProperty(&quot;jdbc.drivers&quot;,&quot;aaa.bbb.ccc&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  结果就显示有了。也就是说，DriverManager中的jdbc.drivers这个系统属性不是本来系统自带的，需要用户自己设定采用。如果不设定，则为null。这样看来，一切都说通了。 来自我的CSDN博客&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 16:18:00 +0000</pubDate>
<dc:creator>人不学习枉少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/8088124.html</dc:identifier>
</item>
<item>
<title>灵感手环第一步——0.96寸OLED显示实验 - Andrew_qian</title>
<link>http://www.cnblogs.com/qsyll0916/p/8088102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qsyll0916/p/8088102.html</guid>
<description>&lt;p&gt;这算是我这个系列的第一篇博客吧。首先要解决的就是屏幕显示问题。我选择了目前新兴起的OLED显示模块。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OLED(OrganicLightEmittingDiode)，中文译作有机发光二极管，目前被广泛的应用于移动设备甚至电视上。它既拥有超快的响应速度和轻薄的优势，又存在寿命与对大尺寸支持不足的瓶颈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OLED的优点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、厚度可以小于1毫米，仅为LCD屏幕的1/3，并且重量也更轻；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、固态机构，没有液体物质，因此抗震性能更好，不怕摔；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、几乎没有可视角度的问题，即使在很大的视角下观看，画面仍然不失真；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、响应时间是LCD的千分之一，显示运动画面绝对不会有拖影的现象；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5、低温特性好，在零下40度时仍能正常显示，而LCD则无法做到；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6、制造工艺简单，成本更低；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7、发光效率更高，能耗比LCD要低；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8、能够在不同材质的基板上制造，可以做成能弯曲的柔软显示器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;OLED的缺点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、寿命通常只有5000小时，要低于LCD至少1万小时的寿命；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、不能实现大尺寸屏幕的量产，因此目前只适用于便携类的数码类产品；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;3、存在色彩纯度不够的问题，不容易显示出鲜艳、浓郁的色彩。&lt;/span&gt;&lt;em&gt;&lt;span&gt;   &lt;/span&gt;               &lt;/em&gt;&lt;/span&gt;           ******************【&lt;strong&gt;摘自百度&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201712/1083998-20171222224144975-1480387265.jpg&quot; alt=&quot;&quot;/&gt;                                                                       &lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201712/1083998-20171222224309350-96620661.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，该模块采用SPI  或  IIC 通信方式，最多占用5个IO口。我使用的是7针模块，采用4线SPI 通信方式。&lt;/p&gt;
&lt;p&gt;该模块有以下特点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 模块有单色和双色可选，单色为纯蓝色，双色为黄蓝双色（本人选用单色）；&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 显示尺寸为0.96寸&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3. 分辨率为128*64&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4. 多种接口方式，该模块提供了总共 5 种接口包括： 6800、 8080 两种并行接口方式、 3线或4线的SPI接口，IIC接口方式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;5. 不需要高压，直接接3.3V就可以工作；（可以与stm32的引脚直接相接）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该模块内部采用SSD1306驱动，显存为128*64bit大小, SSD1306将全部显存分为8页,每页128字节&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20161103160838453&quot; alt=&quot;SSD1306分页&quot; width=&quot;709&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OLED相当于64行128列点阵,每个像素点,0点亮,1熄灭 &lt;br/&gt;OLED将纵向64行分为8页,每页8行&lt;/p&gt;
&lt;p&gt;该实验的难点就在于理解取模的ASCII码表与写入程序的关系。下面我们来详细分析一下。&lt;/p&gt;
&lt;p&gt;首先根据这个官方给出的设置格式，我们采用列行式，就是先取列，再取行。比如我们取个大写的   “A”  的字模。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201712/1083998-20171222235236209-1403685458.png&quot; alt=&quot;&quot; width=&quot;163&quot; height=&quot;316&quot;/&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20} ,/*&quot;A&quot;,0*/&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;/* (8 X 16 , 宋体 )*/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析：&lt;br/&gt;&lt;span&gt;第一个0X00------表示第一列前8个像素，从高位向低位，也就是从下往上写，全灭，所以是0X00，所以在SPI_Write（）函数中，是从高位往低位写的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第二个0X00------表示第二列前8个像素，同上。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第三个0XC0--&amp;gt;  1100 0000，从高位往低位，正好下面两个像素亮了。&lt;/span&gt;&lt;br/&gt;后面都是这样分析，大家可以自己对一下。&lt;br/&gt;也就是说按照他的设置，这个取模软件取的是按照从高位往低位取，前8个字节是第一页的所有像素状态。一共可以取128个字节。因为每一页有128列，8行。但是这个大写字母和汉字不一样，他的宽度是汉字的一半，所以生成的ASCII码表只有16个，一列，因为前8个字节是第一页的，后8个字节是第二页的，一个16*16的汉字需要占用两页（16行），16列。&lt;/p&gt;
&lt;p&gt;下面是节选的显示汉字的程序分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201712/1083998-20171223000528662-2027228117.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我使用STM32F103C8T6对该模块进行驱动，程序修改自中景园科技官方驱动程序。亲测可用。&lt;/p&gt;
&lt;p&gt;OLED引脚介绍：&lt;br/&gt;　　　　CS：OLED片选信号&lt;br/&gt;　　　　RST：OLED复位端口&lt;br/&gt;　　　　DC： 命令/数据选择端口（0：读写命令， 1： 读写数据）&lt;br/&gt;　　　　SCLK（D0）：串口时钟线&lt;br/&gt;　　　　SDIN（D1）: 串口数据线　&lt;/p&gt;
&lt;p&gt;关于SPI的相关知识，可以参见这篇博客：&lt;a href=&quot;http://www.cnblogs.com/qsyll0916/p/8053905.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/qsyll0916/p/8053905.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是SPI.C，包含了对该模块的各种操作，就是对SPI 写进行符合OLED的包装。写字符，写数字，写字符串，可调显示字体大小，但是需要包含两个ASCII字库。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;125&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spi.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;word.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字库头文件&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; OLED_Order 0       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义写命令&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; OLED_Data  1        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义写数据  &lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尽在内部调用函数&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; u32 oled_pow(u8 m,u8 n);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OLED_GPIO_INIT(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SPI_Write(u8 data, u8 Mode);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_Coord(u8 x, u8 y);  

//使用管脚初始化
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OLED_GPIO_INIT(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    GPIO_InitTypeDef GPIO_InitStruct;  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启GPIOD的时钟  &lt;/span&gt;
&lt;span&gt;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置GPIO的基本参数  &lt;/span&gt;
    GPIO_InitStruct.GPIO_Pin = OLED_CS_PIN | OLED_RST_PIN | OLED_DC_PIN | OLED_D0_PIN |&lt;span&gt; OLED_D1_PIN;  
    GPIO_InitStruct.GPIO_Mode &lt;/span&gt;= GPIO_Mode_Out_PP;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;推挽输出  &lt;/span&gt;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出速度50MHz  &lt;/span&gt;
&lt;span&gt;      
    GPIO_Init(OLED_PORT, &lt;/span&gt;&amp;amp;&lt;span&gt;GPIO_InitStruct);  
      
    GPIO_SetBits(OLED_PORT, OLED_CS_PIN &lt;/span&gt;| OLED_RST_PIN | OLED_DC_PIN | OLED_D0_PIN |&lt;span&gt; OLED_D1_PIN);  
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;    SPI写数据/命令 
 *    Mode :OLED_Order:写命令   OLED_Data：写数据 
 *    data :数据/命令 
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SPI_Write(u8 data, u8 Mode)  
{      
    u8 i &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Mode)  
    {  
        OLED_DC(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DC引脚输入高，表示写数据  &lt;/span&gt;
&lt;span&gt;    }  
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;  
    {  
        OLED_DC(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DC引脚输入低，表示写命令  &lt;/span&gt;
&lt;span&gt;    }  
    OLED_CS(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CS引脚输入低，片选使能  &lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt;)  
    {  
        OLED_D0(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;D0引脚输入低  &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(data&amp;amp;&lt;span&gt;0x80&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断传输的数据最高位为1还是0  &lt;/span&gt;
&lt;span&gt;        {  
            OLED_D1(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;D1引脚输入高  &lt;/span&gt;
&lt;span&gt;        }  
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;  
        {  
            OLED_D1(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;D1引脚输入低  &lt;/span&gt;
&lt;span&gt;        }  
        OLED_D0(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;D1引脚输入高  &lt;/span&gt;
        data&amp;lt;&amp;lt;=&lt;span&gt;1&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据左移一位  &lt;/span&gt;
&lt;span&gt;    }  
    OLED_DC(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DC引脚输入低  &lt;/span&gt;
    OLED_CS(&lt;span&gt;1&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CS引脚输入高，片选失能  &lt;/span&gt;
&lt;span&gt;}  

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;        设置OLED屏的显示坐标 
 *  　　  X : 表示OLED的水平坐标（0—127） 
 * 　　   Y : 表示OLED的页（0—7）     
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_Coord(u8 x, u8 y)  
{      
    SPI_Write((&lt;/span&gt;&lt;span&gt;0xb0&lt;/span&gt; +&lt;span&gt; y) ,OLED_Order); 
    SPI_Write((((x &lt;/span&gt;&amp;amp; &lt;span&gt;0xf0&lt;/span&gt;)&amp;gt;&amp;gt;&lt;span&gt;4&lt;/span&gt;) | &lt;span&gt;0x10&lt;/span&gt;), OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高4位  &lt;/span&gt;
    SPI_Write((x &amp;amp; &lt;span&gt;0x0f&lt;/span&gt;)|&lt;span&gt;0x01&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低4位  &lt;/span&gt;
&lt;span&gt;}  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清屏，一开始这里写错了，把写命令写成了写数据，导致清屏不正确，发现屏幕上有很多噪点，说明没有清屏成功。&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; OLED_Clear(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)  
{  
    u8 i &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;, j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;8&lt;/span&gt;; i++&lt;span&gt;)  
    {  
        SPI_Write(&lt;/span&gt;&lt;span&gt;0xb0&lt;/span&gt; +&lt;span&gt; i,OLED_Order);
        SPI_Write(&lt;/span&gt;&lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;,OLED_Order);
        SPI_Write(&lt;/span&gt;&lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;,OLED_Order);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;128&lt;/span&gt;; j++&lt;span&gt;)  
        {  
            SPI_Write(&lt;/span&gt;&lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;, OLED_Data);  
        }  
    }  
}  

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关oled显示&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; OLED_Display_Off(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)  
{
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x8D&lt;/span&gt;&lt;span&gt;,OLED_Order);
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;,OLED_Order);
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xAE&lt;/span&gt;&lt;span&gt;,OLED_Order);
}  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开oled显示&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; OLED_Display_On(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;电荷泵设置（初始化时必须打开，否则看不到显示）&lt;/span&gt;
    SPI_Write(&lt;span&gt;0x8D&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x14&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bit2   0：关闭        1：打开  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xAF&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xAF:开显示      &lt;/span&gt;
&lt;span&gt;}  

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;oled参数初始化&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; OLED_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)  
{  
    OLED_GPIO_INIT();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口初始化&lt;/span&gt;
&lt;span&gt;      
    OLED_RST(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);     
    delay_ms(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);  
    OLED_RST(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);  
    delay_ms(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);  
    OLED_RST(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xAE&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xAE:关显示     &lt;/span&gt;
&lt;span&gt;      
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x00&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置低列地址  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x10&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置高列地址  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置行显示的开始地址(0-63)  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;40-47: (01xxxxx)  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x40&lt;/span&gt;&lt;span&gt;, OLED_Order);
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置对比度  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x81&lt;/span&gt;&lt;span&gt;, OLED_Order);
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xff&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个值越大，屏幕越亮(和上条指令一起使用)(0x00-0xff)  &lt;/span&gt;
&lt;span&gt;      
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xA1&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xA1: 左右反置，  0xA0: 正常显示（默认0xA0）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xC8&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xC8: 上下反置，  0xC0: 正常显示（默认0xC0）  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xA6: 表示正常显示（在面板上1表示点亮，0表示不亮）  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xA7: 表示逆显示（在面板上0表示点亮，1表示不亮）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xA6&lt;/span&gt;&lt;span&gt;, OLED_Order);  
      
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xA8&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置多路复用率（1-64）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x3F&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（0x01-0x3f）(默认为3f)  
      
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置显示抵消移位映射内存计数器  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xD3&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x00&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（0x00-0x3f）(默认为0x00)  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置显示时钟分频因子/振荡器频率  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xD5&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;低4位定义显示时钟(屏幕的刷新时间)（默认：0000）分频因子= [3:0]+1  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高4位定义振荡器频率（默认：1000）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x80&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;  
      
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时钟预充电周期  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xD9&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xF1&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3:0],PHASE 1;   [7:4] PHASE 2  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置COM硬件应脚配置  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xDA&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x12&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[5:4]  默认：01  &lt;/span&gt;
&lt;span&gt;      
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xDB&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;  
    SPI_Write(&lt;span&gt;0x40&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;  
      
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置内存寻址方式  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x20&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;00: 表示水平寻址方式  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;01: 表示垂直寻址方式  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10: 表示页寻址方式（默认方式）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x02&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;      
      
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;电荷泵设置（初始化时必须打开，否则看不到显示）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0x8D&lt;/span&gt;&lt;span&gt;, OLED_Order);  
    SPI_Write(&lt;/span&gt;&lt;span&gt;0x14&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;bit2   0：关闭        1：打开  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置是否全部显示 0xA4: 禁止全部显示  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xA4&lt;/span&gt;&lt;span&gt;, OLED_Order);  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xA6: 表示正常显示（在面板上1表示点亮，0表示不亮）  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xA7: 表示逆显示（在面板上0表示点亮，1表示不亮）  &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xA6&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;  
&lt;span&gt;      
    SPI_Write(&lt;/span&gt;&lt;span&gt;0xAF&lt;/span&gt;, OLED_Order);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0xAF:开显示     &lt;/span&gt;
    SPI_Write(&lt;span&gt;0xAF&lt;/span&gt;, OLED_Order); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不知道为什么要写两次&lt;/span&gt;
&lt;span&gt;    
    OLED_Clear();
    OLED_Coord(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}  

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示汉字，设置坐标，&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_ShowChinese(u8 x, u8 y, u8 chinese)  
{  
    u8 t,adder&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    OLED_Coord(x,y);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(t=&lt;span&gt;0&lt;/span&gt;;t&amp;lt;&lt;span&gt;16&lt;/span&gt;;t++)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每行16个元素，一个字需要两行字符串&lt;/span&gt;
&lt;span&gt;    {
        SPI_Write(Hzk[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;chinese][t],OLED_Data);
        adder&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
     }    
    
    OLED_Coord(x,y&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
     
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(t=&lt;span&gt;0&lt;/span&gt;;t&amp;lt;&lt;span&gt;16&lt;/span&gt;;t++&lt;span&gt;)
    {    
        SPI_Write(Hzk[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;*chinese+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;][t],OLED_Data);
        adder&lt;/span&gt;+=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
      }    
} 


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在指定位置显示一个字符,包括部分字符
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x:0~127
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y:0~63
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mode:0,反白显示;1,正常显示
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size:选择字体 16/12 &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_ShowChar(u8 x, u8 y, u8 chr)  
{  
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; c=&lt;span&gt;0&lt;/span&gt;,   i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
    
    c &lt;/span&gt;= chr - &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到偏移后的值&lt;/span&gt;
    
        &lt;span&gt;if&lt;/span&gt;(x &amp;gt; Max_Column - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {x&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;y=y+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;}
            
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(SIZE ==&lt;span&gt;16&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;8*16字符&lt;/span&gt;
&lt;span&gt;        {
            OLED_Coord(x,y);
            
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;8&lt;/span&gt;;i++&lt;span&gt;)
                SPI_Write(F8X16[c&lt;/span&gt;*&lt;span&gt;16&lt;/span&gt;+&lt;span&gt;i],OLED_Data);
            
            OLED_Coord(x,y&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;8&lt;/span&gt;;i++&lt;span&gt;)
                SPI_Write(F8X16[c&lt;/span&gt;*&lt;span&gt;16&lt;/span&gt;+i+&lt;span&gt;8&lt;/span&gt;&lt;span&gt;],OLED_Data);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6*8字符&lt;/span&gt;
&lt;span&gt;        {    
            OLED_Coord(x,y&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;6&lt;/span&gt;;i++&lt;span&gt;)
                SPI_Write(F6x8[c][i],OLED_Data);
            
        }
}  

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示字符串&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; OLED_Show_String(u8 x, u8 y, u8 *&lt;span&gt;chr)
{
    u8 j&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (chr[j]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    {
        OLED_ShowChar(x,y,chr[j]);

        x&lt;/span&gt;+= &lt;span&gt;8&lt;/span&gt;&lt;span&gt; ;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x&amp;gt;&lt;span&gt;120&lt;/span&gt;){x=&lt;span&gt;0&lt;/span&gt;;y+=&lt;span&gt;2&lt;/span&gt;;}  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动换行写&lt;/span&gt;
&lt;span&gt;
        j&lt;/span&gt;++&lt;span&gt;;
    }
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;m^n函数&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt; u32 oled_pow(u8 m,u8 n)
{
    u32 result &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n--)result*=&lt;span&gt;m;    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示数字
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x,y :起点坐标     
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;len :数字的位数
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size:字体大小
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mode:模式    0,填充模式;1,叠加模式
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;num:数值(0~4294967295);               &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size)
{             
    u8 t &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;, temp = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    u8 enshow&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(t=&lt;span&gt;0&lt;/span&gt;;t&amp;lt;len;t++&lt;span&gt;)
    {
        temp&lt;/span&gt;=(num/oled_pow(&lt;span&gt;10&lt;/span&gt;,len-t-&lt;span&gt;1&lt;/span&gt;))%&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(enshow==&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;t&amp;lt;(len-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                OLED_ShowChar(x&lt;/span&gt;+(size/&lt;span&gt;2&lt;/span&gt;)*t,y,&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; enshow=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
              
        }
         OLED_ShowChar(x&lt;/span&gt;+(size/&lt;span&gt;2&lt;/span&gt;)*t,y,temp+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
    }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是头文件：SPI.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef __SPI_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; __SPI_H&lt;span&gt;

#include &lt;/span&gt;&amp;lt;stm32f10x.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;systick.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; OLED_PORT   GPIOA

&lt;span&gt;#define&lt;/span&gt; OLED_CS_PIN            GPIO_Pin_3
&lt;span&gt;#define&lt;/span&gt; OLED_RST_PIN        GPIO_Pin_4
&lt;span&gt;#define&lt;/span&gt; OLED_DC_PIN            GPIO_Pin_5
&lt;span&gt;#define&lt;/span&gt; OLED_D0_PIN            GPIO_Pin_6
&lt;span&gt;#define&lt;/span&gt; OLED_D1_PIN            GPIO_Pin_7

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;X为1时对应GPIO端口输出高电平，X为0时对应GPIO端口输出低电平 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; OLED_CS(X)   X?GPIO_SetBits(OLED_PORT, OLED_CS_PIN):GPIO_ResetBits(OLED_PORT, OLED_CS_PIN)  
  
&lt;span&gt;#define&lt;/span&gt; OLED_RST(X)  X?GPIO_SetBits(OLED_PORT, OLED_RST_PIN):GPIO_ResetBits(OLED_PORT, OLED_RST_PIN)      
  
&lt;span&gt;#define&lt;/span&gt; OLED_DC(X)   X?GPIO_SetBits(OLED_PORT, OLED_DC_PIN):GPIO_ResetBits(OLED_PORT, OLED_DC_PIN)  
  
&lt;span&gt;#define&lt;/span&gt; OLED_D0(X)   X?GPIO_SetBits(OLED_PORT, OLED_D0_PIN):GPIO_ResetBits(OLED_PORT, OLED_D0_PIN)      
  
&lt;span&gt;#define&lt;/span&gt; OLED_D1(X)   X?GPIO_SetBits(OLED_PORT, OLED_D1_PIN):GPIO_ResetBits(OLED_PORT, OLED_D1_PIN)      
  
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OLED模式设置&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SIZE 16
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define SIZE 8    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SIZE选择英文字体的大小&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; XLevelL        0x00
&lt;span&gt;#define&lt;/span&gt; XLevelH        0x10
&lt;span&gt;#define&lt;/span&gt; Max_Column    128
&lt;span&gt;#define&lt;/span&gt; Max_Row        64
&lt;span&gt;#define&lt;/span&gt;    Brightness    0xFF 
&lt;span&gt;#define&lt;/span&gt; X_WIDTH     128
&lt;span&gt;#define&lt;/span&gt; Y_WIDTH     64

&lt;span&gt;void&lt;/span&gt; OLED_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; OLED_Clear(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; OLED_Display_Off(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; OLED_Display_On(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_ShowChinese(u8 x, u8 y, u8 chinese);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_ShowChar(u8 x, u8 y, u8 chr);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; OLED_Show_String(u8 x, u8 y, u8 *&lt;span&gt;chr);  
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size);


&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写完这两个文件，就可以在主函数调用  OLED_ShowChinese() ，进行参数配置后，就可以显示了。&lt;/p&gt;
&lt;p&gt;具体调用方式为：OLED_ShowChinese(32,0,0);//钱&lt;/p&gt;
&lt;p&gt;这个里面前两个参数是进行显示坐标选择，第三个参数是选择你的字库里面第几个汉字的行数。比如我选择了 0，那么在我的字库头文件中前两个ASCII码表就是我要显示汉字的ASCII码表，这个码表是采用字模软件生成的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;char&lt;/span&gt; Hzk[][&lt;span&gt;32&lt;/span&gt;]=&lt;span&gt;{

{&lt;/span&gt;&lt;span&gt;0x20&lt;/span&gt;,&lt;span&gt;0x10&lt;/span&gt;,&lt;span&gt;0x2C&lt;/span&gt;,&lt;span&gt;0xE7&lt;/span&gt;,&lt;span&gt;0x24&lt;/span&gt;,&lt;span&gt;0x24&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;,&lt;span&gt;0x90&lt;/span&gt;,&lt;span&gt;0x90&lt;/span&gt;,&lt;span&gt;0xFF&lt;/span&gt;,&lt;span&gt;0x90&lt;/span&gt;,&lt;span&gt;0x49&lt;/span&gt;,&lt;span&gt;0x4A&lt;/span&gt;,&lt;span&gt;0x48&lt;/span&gt;,&lt;span&gt;0x40&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;},
{&lt;/span&gt;&lt;span&gt;0x01&lt;/span&gt;,&lt;span&gt;0x01&lt;/span&gt;,&lt;span&gt;0x01&lt;/span&gt;,&lt;span&gt;0x7F&lt;/span&gt;,&lt;span&gt;0x21&lt;/span&gt;,&lt;span&gt;0x11&lt;/span&gt;,&lt;span&gt;0x40&lt;/span&gt;,&lt;span&gt;0x40&lt;/span&gt;,&lt;span&gt;0x20&lt;/span&gt;,&lt;span&gt;0x13&lt;/span&gt;,&lt;span&gt;0x0C&lt;/span&gt;,&lt;span&gt;0x14&lt;/span&gt;,&lt;span&gt;0x22&lt;/span&gt;,&lt;span&gt;0x41&lt;/span&gt;,&lt;span&gt;0xF8&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;},&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&quot;钱&quot;,7&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; (16 X 16 , 宋体 )&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用PCtoLCD2002完美版进行取模。具体字模生成方式可参见中景园官方教程：&lt;a href=&quot;https://wenku.baidu.com/view/42efcb877cd184254a353584.html&quot; target=&quot;_blank&quot;&gt;https://wenku.baidu.com/view/42efcb877cd184254a353584.html&lt;/a&gt;&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span readability=&quot;2&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201712/1083998-20171222230558178-2011008462.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;406&quot;/&gt;&lt;p&gt;汉字生成为两行16进制码表。&lt;br/&gt;显示效果：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1083998/201712/1083998-20171222231309037-1910439987.jpg&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 22 Dec 2017 16:08:00 +0000</pubDate>
<dc:creator>Andrew_qian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qsyll0916/p/8088102.html</dc:identifier>
</item>
<item>
<title>vue-cli 安装失败Failed to download repo vuejs-templates/webapck-simple: Response code 404 (Not Found) - 林丶易</title>
<link>http://www.cnblogs.com/suger-life/p/8088057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suger-life/p/8088057.html</guid>
<description>&lt;p&gt;新学习vue的萌新们经常会遇到各种各样的坑。例如上面这个报错。这个一般是命令行面板写错单词导致。&lt;/p&gt;
&lt;p&gt;正确：vue init webpack-simple .（注意“.”点，指当前目录）&lt;/p&gt;
&lt;p&gt;正确2：veu init webapck project(project自己取得名字)；&lt;/p&gt;
&lt;p&gt;在安装之前，请确保在命令行输入vue -V（大写V） node -v（小写v）能输出版本号&lt;/p&gt;
&lt;p&gt;并且命令行输入“ping github.com”能连接得上。连接不上也无所谓，百度淘宝镜像，按照要求装个cnpm就ok拉。&lt;/p&gt;
&lt;p&gt;好东西大家一起分享- =。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 15:53:00 +0000</pubDate>
<dc:creator>林丶易</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suger-life/p/8088057.html</dc:identifier>
</item>
<item>
<title>python用户管理系统 - smelond</title>
<link>http://www.cnblogs.com/smelond/p/8088038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smelond/p/8088038.html</guid>
<description>
&lt;p&gt;学Python这么久了，第一次写一个这么多的代码（我承认只有300多行，重复的代码挺多的，我承认我确实垃圾），但是也挺不容易的&lt;/p&gt;
&lt;p&gt;自定义函数+装饰器，每一个模块写的一个函数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多地方能用装饰器（逻辑跟不上，有的地方没用），包括双层装饰器（不会），很多地方需要优化,重复代码太多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我还是把我的流程图拿出来吧，虽然看着比上次的垃圾，但是我也做了一个小时，不容易！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1270591/201712/1270591-20171222234215303-836538859.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;好像是挺丑的（表示不会画，但我下次一定努力）&lt;/p&gt;
&lt;p&gt; 用户文件：&lt;/p&gt;
&lt;p&gt;文件名为：user.txt&lt;/p&gt;
&lt;p&gt;1代表管理员用户&lt;/p&gt;
&lt;p&gt;2代表普通用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
smelond|admin|xx@qq.com|1&lt;span&gt;
admin&lt;/span&gt;|admin|qweqwe@qq.com|2&lt;span&gt;
qwe&lt;/span&gt;|qweasd|qwe@qq.com|2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码（感觉这个程序还有很多bug）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;97&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; _*_ coding:utf-8 _*_&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; File_type:用户管理程序，装饰器版本，多功能&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Filename:user_manage_program.py&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Author:smelond&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

os.system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; windows中的清屏&lt;/span&gt;
&lt;span&gt;
COUNT &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计数器&lt;/span&gt;
WHETHER_LOGIN = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于判断是否有用户登录&lt;/span&gt;
USER_LIST = []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前用户信息存放的列表&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; register_function():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注册函数 （所有注册都来调用这个函数）&lt;/span&gt;
    count = 3  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计数器，做到了一个提示用户的作用&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(3):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环3次&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户注册【你只有3次机会】，你还有【%s】次机会&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.center(80, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) % count)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出提示&lt;/span&gt;
        count -= 1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次减1&lt;/span&gt;
        username = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            passwd &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(passwd) &amp;gt;= 5&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果输入的密码小于5,位数，向下操作&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入大于5位数的密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                input_passwd &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【1：继续输入；2：返回上一步】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; input_passwd == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    main()
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            email &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入邮箱：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            email_count &lt;/span&gt;= email.count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看输入的邮箱是否带@,&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(email_count)  # 返回1代表有一个@&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; email_count == 1&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果有一个@符号，代表邮箱输入正确，跳出当前循环&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入正确的邮箱&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                input_email &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【1：继续输入；2：返回上一步】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; input_email == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    main()

        register_user &lt;/span&gt;= [username, passwd, email, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将我们输入的用户名密码以及邮箱放到一个列表中，普通用户，所以加上了一个2&lt;/span&gt;
        with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as user:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
                f_user_list &lt;/span&gt;= line.strip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; register_user[0] ==&lt;span&gt; f_user_list[0]:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名已被注册&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; register_user[2] == f_user_list[2]:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断我们输入得的邮箱和用户名是否以及存在&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;邮箱已被注册&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接下来是通过了上面的筛选，开始把我们的注册信息写进数据库（总感觉上面有bug）&lt;/span&gt;
                user_write = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join(register_user)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用join方法将这个列表转换为以|分隔&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; open_user = open(&quot;user.txt&quot;, &quot;a&quot;)  # a 以追加方式写入文件&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; open_user.write(&quot;\n&quot; + user_write)&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; open_user.close()  # 记得关闭&lt;/span&gt;
                with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f:
                    f.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + user_write)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跟上面一样的方法，这种不用关闭文件&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                user_write &lt;/span&gt;= &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用户名：【%s】;密码：【%s】;邮箱：【%s】&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; \
                             &lt;/span&gt;% (register_user[0], register_user[1], register_user[2])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注册成功的提示信息&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; user_write  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回提示信息&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; outer(func):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 装饰器，用于管理接口&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; inner(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; USER_LIST[3] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为什么要加上引号，因为在列表中存储的是字符串，而不是整形&lt;/span&gt;
            r = func()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行我们传入的函数&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; r  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; USER_LIST[3] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果为普通用户，提示没有足够权限并且返回到main函数&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n当前用户为普通用户【%s】，没有足够的权限&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; USER_LIST[0])
            main()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n当前没有用户登录,请登录后再试。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 否者就是没有登录了&lt;/span&gt;
&lt;span&gt;            main()

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; user_login(func):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测用户是否登录的装饰器&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; inner(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否登录&lt;/span&gt;
            r =&lt;span&gt; func()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果已经登录，返回到原本的函数&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            user_no &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请登录后再试【1：用户登录；2：返回】:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_no == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                login()
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;返回成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                main()

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; inner  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切记，这里必须返回一个inner，不然上面的inner不会执行,不能再后面加()，如果加上了，就相当于调用这个函数&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; exit_login():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6退出登录&lt;/span&gt;
    &lt;span&gt;global&lt;/span&gt;&lt;span&gt; USER_LIST
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; USER_LIST:
        quit_login &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前用户为【%s】，确定要退出【Y/N】：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; USER_LIST[0])
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; if quit_login == &quot;Y&quot; or quit_login == &quot;y&quot; or quit_login == &quot;yes&quot;:&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; quit_login &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yeS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yEs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YEs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果quit_login满足其中一个，继续执行&lt;/span&gt;
            WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            USER_LIST &lt;/span&gt;= []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接将列表清除为初始状态，不知道这种方法好不好，但是好像管用&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; quit_login &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有用户登录。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; verifi_passwd():
    with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as old_user:
        lines &lt;/span&gt;= old_user.readlines()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性读取整个文件，感觉这方方式不好&lt;/span&gt;
    flag =&lt;span&gt; True
    cout &lt;/span&gt;= 3
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; flag:
        cout &lt;/span&gt;-= 1&lt;span&gt;
        user_info &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_info == &lt;span&gt;&quot;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否输入字符串&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你没有输入任何用户。。。\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            manage()
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines:
            user_all_info &lt;/span&gt;= line.strip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_info ==&lt;span&gt; user_all_info[0]:
                current_user &lt;/span&gt;= user_all_info  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果输入的用户和用户文件里面的用户相同，那就将他的所有信息写入一个新的列表中&lt;/span&gt;
                flag =&lt;span&gt; False
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cout ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;然而，你可能不知道有哪些用户，赶紧去查看吧。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            manage()

    lines_user &lt;/span&gt;=&lt;span&gt; [lines, current_user]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lines_user


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; user_info_func(username, password_or_power, user_info, lines):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 几个传入的类型为：用户名、密码或用户权限，需要修改的用户列表的位置、需要循环的文件内容&lt;/span&gt;
    new_user_info = username.copy()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将username复制给new_user_info&lt;/span&gt;
    new_user_info[user_info] = password_or_power  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将新的用户密码修改为输入的新密码&lt;/span&gt;
    username = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join(username)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将列表转换为数据库可以识别的内容&lt;/span&gt;
    new_user_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(new_user_info)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(username, new_user_info)&lt;/span&gt;
    with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as new_user:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将返回的整个文件循环打印&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; username &lt;span&gt;in&lt;/span&gt; line:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果返回的用户信息在返回的文件里面&lt;/span&gt;
                line = line.replace(username, new_user_info)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 那就将旧的用户信息替换为新的用户信息&lt;/span&gt;
            new_user.write(line)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入文件&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;修改成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提示信息&lt;/span&gt;
&lt;span&gt;

@outer  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用装饰器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; manage():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5用户管理接口&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户管理接口【欢迎管理员[%s]】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.center(69, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) %&lt;span&gt; USER_LIST[0])
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1：查看所有用户；2、添加新用户；3：删除用户；4：修改用户密码；5：升级用户权限；6：退出用户管理&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        user_input &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入对象序号：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; user_input == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看用户信息&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印80个-&lt;/span&gt;
            with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as user_info:
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user_info:
                    user_list &lt;/span&gt;= line.strip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去掉默认的\n和|将他转换为列表类型&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; user_list[3] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                        user_rights &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;管理员用户&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户最后一个数如果等于1，代表管理员&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                        user_rights &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;普通用户&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 否者为普通用户&lt;/span&gt;
                    ordinary_user = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用户名【%s】\t密码【%s】\t邮箱【%s】\t用户等级【%s】&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; \
                                    &lt;/span&gt;% (user_list[0], user_list[1], user_list[2], user_rights)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 中间默认有一个换行符&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ordinary_user)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; * 80 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; user_input == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                ret &lt;/span&gt;= register_function()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用注册函数&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出返回值&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跳出当前这个while循环&lt;/span&gt;

        &lt;span&gt;elif&lt;/span&gt; user_input == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            flag &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认是没有用户的（做到一个提示作用）&lt;/span&gt;
            del_user = verifi_passwd()[1][0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到函数返回的第二个值&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\033[1;31m删除用户为：\033[0m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, del_user)
            with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as old_user:
                lines &lt;/span&gt;= old_user.readlines()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性读取整个文件，感觉这方方式不好1&lt;/span&gt;
            with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as new_user:
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将上面读取到的文集一行一行的循环出来&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; line.startswith(del_user):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查数据库里面是否有我们输入的用户（以输入的用户名开头）&lt;/span&gt;
                        flag = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                        &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
                    new_user.write(line)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; flag == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提示成功&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有这个用户。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果输入的为空格或一些没有的用户，提示没有这个用户&lt;/span&gt;
                    &lt;span&gt;continue&lt;/span&gt;

        &lt;span&gt;elif&lt;/span&gt; user_input == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            ret &lt;/span&gt;= verifi_passwd()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到函数返回值&lt;/span&gt;
            lines = ret[0]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取到返回的整个文件内容&lt;/span&gt;
            username = ret[1]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取到返回的需要修改密码的用户&lt;/span&gt;
            new_password = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户的新密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(new_password) &amp;lt; 5:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断输入的密码长度是否大于或等于5位数&lt;/span&gt;
                error_prompt = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你输入的密码长度小于5位数，由于你是管理员，输入Y继续：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).strip(&lt;span&gt;&quot;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去掉输入的空格&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; error_prompt &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果输入的值不为y或Y，就直接退出&lt;/span&gt;
                    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
            user_info_func(username, new_password, &lt;/span&gt;1, lines)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入实参到函数，1在列表中的位置代表用户的新密码&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; user_input == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面这部分和上面的部分基本相似，其实可以写一个函数用来调用的&lt;/span&gt;
            ret =&lt;span&gt; verifi_passwd()
            lines &lt;/span&gt;=&lt;span&gt; ret[0]
            username &lt;/span&gt;= ret[1]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取到输入用户的所有信息&lt;/span&gt;
            new_power = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入Y提升用户权限：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; new_power &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入错误。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
            user_info_func(username, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 3, lines)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入实参：用户名、权限（1代表管理员）、位置、循环的文件内容&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; user_input == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;返回上一级！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            main()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入有误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


@user_login  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用装饰器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; see():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4查询当前用户的基本信息&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; USER_LIST[3] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据库里面定义了1代表管理员用户，2代表普通用户&lt;/span&gt;
        user_level = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;管理员用户&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        user_level &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;普通用户&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    user_see &lt;/span&gt;= &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    ----------------------------------------
    用户名：  【%s】
    密  码：  【%s】
    邮  箱：  【%s】
    用户等级：【%s】
    ----------------------------------------
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; % (USER_LIST[0], USER_LIST[1], USER_LIST[2], user_level)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个简单的格式化输出&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(user_see)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; error_password():
    counter &lt;/span&gt;= 3
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        counter &lt;/span&gt;-= 1
        &lt;span&gt;if&lt;/span&gt; counter ==&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你输入错误的次数太多，程序自动返回。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            main()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;两次输入的密码不相同。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;


@user_login  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用装饰器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; alter():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3修改密码&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前用户为：【%s】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; USER_LIST[0])
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        old_user_password &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入当前用户的旧密码密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; old_user_password == USER_LIST[1&lt;span&gt;]:
            flag &lt;/span&gt;=&lt;span&gt; True
            count &lt;/span&gt;= 3
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt; flag:
                count &lt;/span&gt;-= 1&lt;span&gt;
                new_user_password &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入当前用户的\033[1;31m新密码\033[0m：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给新密码字体加颜色&lt;/span&gt;
                new_user_password1 = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;再次输入当前用户的\033[1;31m新密码\033[0m：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(new_user_password) &amp;gt;= 5&lt;span&gt;:
                    flag &lt;/span&gt;=&lt;span&gt; False
                &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; count ==&lt;span&gt; 0:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;多次不合法，程序自动返回。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    main()
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入不合法，请输入大于5位数的密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; new_user_password == new_user_password1:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断两次输入的密码是否相等&lt;/span&gt;
                with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) as user_info:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以读的方式打开这个文件&lt;/span&gt;
                    old_user_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join(USER_LIST)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取以前的旧信息&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; user_info:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将获取到的每行循环输出&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; USER_LIST[0] &lt;span&gt;in&lt;/span&gt; line:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到当前登录的用户的这个用户名&lt;/span&gt;
                            USER_LIST[1] = new_user_password1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果找到了，就把新密码重新加入到我们全局的用户的信息列表中&lt;/span&gt;
                            new_user_info = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join(USER_LIST)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将用户信息表中的内容用join方法转换为用户数据库里面的格式（新用户信息）&lt;/span&gt;
                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(new_user_info)&lt;/span&gt;
                            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(old_user_info)&lt;/span&gt;
                            &lt;span&gt;break&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跳出当前&lt;/span&gt;
                with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as old_user:
                    lines &lt;/span&gt;= old_user.readlines()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性读取整个文件，感觉这方方式不好&lt;/span&gt;
                with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as new_user:
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将上面读取到的文集一行一行的循环出来&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; old_user_info &lt;span&gt;in&lt;/span&gt; line:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查文件里面是否有我们用户的旧信息&lt;/span&gt;
                            line = line.replace(old_user_info, new_user_info)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果有就用replace替换&lt;/span&gt;
                        new_user.write(line)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接着写入到文件&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;修改成功√&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 完成后跳出&lt;/span&gt;

            &lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两次不相等&lt;/span&gt;
                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;两次输入的密码不相同，程序自动返回。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                main()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前用户密码输入错误&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前用户密码输入错误，程序自动返回。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            main()


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; register():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2用户注册&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        quit_login &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无法注册用户，请退出登录后重试【1：退出登录；2：返回上一步】：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; quit_login == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            exit_login()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跳转到退出用户函数&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; quit_login == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;返回成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        ret &lt;/span&gt;= register_function()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用注册函数&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将返回值输出&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt; login():  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1用户登录&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.center(82, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    username &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    passwd &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    with open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as user:
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
            f_user_list &lt;/span&gt;= line.strip(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去除每行默认的回车，以及|，并且将它转换为列表赋给f_admin_list&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; f_user_list[0] == username &lt;span&gt;and&lt;/span&gt; f_user_list[1] ==&lt;span&gt; passwd:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; USER_LIST
                USER_LIST &lt;/span&gt;= f_user_list  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将获取到的当前行放到用户信息列表中&lt;/span&gt;
                WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 登录成功将is_login的值设置success&lt;/span&gt;
                WHETHER_LOGIN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = username  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将我们登录的用户放入字典用，方便后期查询&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(USER_LIST)&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; f_user_list
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; COUNT
        COUNT &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户管理系统&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.center(80, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1、用户登录；2：用户注册；3：修改密码；4：用户信息；5：用户管理；6：退出登录；7：退出程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        inp &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入序号：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; USER_LIST:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; USER_LIST[3] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前为管理员用户：【%s】，不能继续登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; USER_LIST[0])
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前用户为【%s】,不能继续登录&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; USER_LIST[0])
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                login()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            register()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            alter()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            see()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            manage()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            exit_login()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; inp == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;程序已退出！！！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; COUNT == 3&lt;span&gt;:
                exit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入错误次数过多，程序自动退出。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入有误，请重新输入。。。\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;


main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 22 Dec 2017 15:48:00 +0000</pubDate>
<dc:creator>smelond</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smelond/p/8088038.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——2. 当构造方法参数过多时使用builder模式 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8087978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8087978.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;静态工厂和构造方法都有一个限制：它们不能很好地扩展到很多可选参数的情景。请考虑一个代表包装食品上的营养成分标签的例子。这些标签有几个必需的属性——每次建议的摄入量，每罐的份量和每份卡路里 ，以及超过20个可选的属性——总脂肪、饱和脂肪、反式脂肪、胆固醇、钠等等。大多数产品都有非零值，只有少数几个可选属性。&lt;/p&gt;
&lt;p&gt;应该为这样的类编写什么样的构造方法或静态工厂？传统上，程序员使用了可伸缩（telescoping constructor）构造方法模式，在这种模式中，只提供了一个只所需参数的构造函数，另一个只有一个可选参数，第三个有两个可选参数，等等，最终在构造函数中包含所有可选参数。这就是它在实践中的样子。为了简便起见，只显示了四个可选属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Telescoping constructor pattern - does not scale well!

public class NutritionFacts {
    private final int servingSize;  // (mL)            required
    private final int servings;     // (per container) required
    private final int calories;     // (per serving)   optional
    private final int fat;          // (g/serving)     optional
    private final int sodium;       // (mg/serving)    optional
    private final int carbohydrate; // (g/serving)     optional

    public NutritionFacts(int servingSize, int servings) {
        this(servingSize, servings, 0);
    }

    public NutritionFacts(int servingSize, int servings,
            int calories) {
        this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings,
            int calories, int fat) {
        this(servingSize, servings, calories, fat, 0);
    }

    public NutritionFacts(int servingSize, int servings,
            int calories, int fat, int sodium) {
        this(servingSize, servings, calories, fat, sodium, 0);
    }

    public NutritionFacts(int servingSize, int servings,
           int calories, int fat, int sodium, int carbohydrate) {
        this.servingSize  = servingSize;
        this.servings     = servings;
        this.calories     = calories;
        this.fat          = fat;
        this.sodium       = sodium;
        this.carbohydrate = carbohydrate;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常情况下，这个构造方法的调用需要许多你不想设置的参数，但是你不得不为它们传递一个值。 在这种情况下，我们为&lt;code&gt;fat&lt;/code&gt;属性传递了0值。 『只有』六个参数可能看起来并不那么糟糕，但随着参数数量的增加，它会很快失控。&lt;/p&gt;
&lt;p&gt;简而言之，可伸缩构造方法模式是有效的，但是当有很多参数时，很难编写客户端代码，而且很难读懂它。读者不知道这些值是什么意思，并且必须仔细地计算参数才能找到答案。一长串相同类型的参数可能会导致一些细微的bug。如果客户端意外地反转了两个这样的参数，编译器并不会抱怨，但是程序在运行时会出现错误行为(条目51)。&lt;/p&gt;
&lt;p&gt;当在构造方法中遇到许多可选参数时，另一种选择是JavaBeans模式，在这种模式中，调用一个无参数的构造函数来创建对象，然后调用setter方法来设置每个必需的参数和可选参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// JavaBeans Pattern - allows inconsistency, mandates mutability

public class NutritionFacts {
    // Parameters initialized to default values (if any)
    private int servingSize  = -1; // Required; no default value
    private int servings     = -1; // Required; no default value
    private int calories     = 0;
    private int fat          = 0;
    private int sodium       = 0;
    private int carbohydrate = 0;

    public NutritionFacts() { }

    // Setters
    public void setServingSize(int val)  { servingSize = val; }
    public void setServings(int val)    { servings = val; }
    public void setCalories(int val)    { calories = val; }
    public void setFat(int val)         { fat = val; }
    public void setSodium(int val)      { sodium = val; }
    public void setCarbohydrate(int val) { carbohydrate = val; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式没有伸缩构造方法模式的缺点。有点冗长，但创建实例很容易，并且易于阅读所生成的代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NutritionFacts cocaCola = new NutritionFacts();
cocaCola.setServingSize(240);
cocaCola.setServings(8);
cocaCola.setCalories(100);
cocaCola.setSodium(35);
cocaCola.setCarbohydrate(27);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不幸的是，JavaBeans模式本身有严重的缺陷。由于构造方法在多次调用中被分割，所以在构造过程中JavaBean可能处于不一致的状态。该类没有通过检查构造参数参数的有效性来执行一致性的选项。在不一致的状态下尝试使用对象可能会导致与包含bug的代码大相径庭的错误，因此很难调试。一个相关的缺点是，JavaBeans模式排除了让类不可变的可能性(条目17)，并且需要在程序员的部分增加工作以确保线程安全。&lt;/p&gt;
&lt;p&gt;当它的构造完成时，手动“冻结”对象，并且不允许它在解冻之前使用，可以减少这些缺点，但是这种变体在实践中很难使用并且很少使用。 而且，在运行时会导致错误，因为编译器无法确保程序员在使用对象之前调用&lt;code&gt;freeze&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;幸运的是，还有第三种选择，它结合了可伸缩构造方法模式的安全性和javabean模式的可读性。 它是Builder模式[Gamma95]的一种形式。客户端不直接调用所需的对象，而是调用构造方法(或静态工厂)，并使用所有必需的参数，并获得一个builder对象。然后，客户端调用builder对象的&lt;code&gt;setter&lt;/code&gt;相似方法来设置每个可选参数。最后，客户端调用一个无参的&lt;code&gt;build&lt;/code&gt;方法来生成对象，该对象通常是不可变的。Builder通常是它所构建的类的一个静态成员类(条目24)。以下是它在实践中的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Builder Pattern

public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;

        // Optional parameters - initialized to default values
        private int calories      = 0;
        private int fat           = 0;
        private int sodium        = 0;
        private int carbohydrate  = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings    = servings;
        }

        public Builder calories(int val) { 
            calories = val;      
            return this;
        }

        public Builder fat(int val) { 
           fat = val;           
           return this;
        }

        public Builder sodium(int val) { 
           sodium = val;        
           return this; 
        }

        public Builder carbohydrate(int val) { 
           carbohydrate = val;  
           return this; 
        }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize  = builder.servingSize;
        servings     = builder.servings;
        calories     = builder.calories;
        fat          = builder.fat;
        sodium       = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NutritionFacts&lt;/code&gt;类是不可变的，所有的参数默认值都在一个地方。builder的setter方法返回builder本身，这样调用就可以被链接起来，从而生成一个流畅的API。下面是客户端代码的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
    .calories(100).sodium(35).carbohydrate(27).build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个客户端代码很容易编写，更重要的是易于阅读。 Builder模式模拟Python和Scala中的命名可选参数。&lt;/p&gt;
&lt;p&gt;为了简洁起见，省略了有效性检查。 要尽快检测无效参数，检查builder的构造方法和方法中的参数有效性。 在&lt;code&gt;build&lt;/code&gt;方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，在从builder复制参数后对对象属性进行检查（条目 50）。 如果检查失败，则抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常（条目 72），其详细消息指示哪些参数无效（条目 75）。&lt;/p&gt;
&lt;p&gt;Builder模式非常适合类层次结构。 使用平行层次的builder，每个嵌套在相应的类中。 抽象类有抽象的builder; 具体的类有具体的builder。 例如，考虑代表各种比萨饼的根层次结构的抽象类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Builder pattern for class hierarchies

import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;

public abstract class Pizza {
    public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE}
    final Set&amp;lt;Topping&amp;gt; toppings;
    
    abstract static class Builder&amp;lt;T extends Builder&amp;lt;T&amp;gt;&amp;gt; {
        EnumSet&amp;lt;Topping&amp;gt; toppings = EnumSet.noneOf(Topping.class);

        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }
        
        abstract Pizza build();
        
        // Subclasses must override this method to return &quot;this&quot;
        protected abstract T self();
    }

    Pizza(Builder&amp;lt;?&amp;gt; builder) {
        toppings = builder.toppings.clone(); // See Item 50
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，&lt;code&gt;Pizza.Builder&lt;/code&gt;是一个带有递归类型参数（ recursive type parameter）（条目 30）的泛型类型。 这与抽象的&lt;code&gt;self&lt;/code&gt;方法一起，允许方法链在子类中正常工作，而不需要强制转换。 Java缺乏自我类型的这种变通解决方法被称为模拟自我类型（simulated self-type）的习惯用法。&lt;/p&gt;
&lt;p&gt;这里有两个具体的&lt;code&gt;Pizza&lt;/code&gt;的子类，其中一个代表标准的纽约风格的披萨，另一个是半圆形烤乳酪馅饼。前者有一个所需的尺寸参数，而后者则允许指定酱汁是否应该在里面或在外面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Objects;

public class NyPizza extends Pizza {
    public enum Size { SMALL, MEDIUM, LARGE }
    private final Size size;

    public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; {
        private final Size size;

        public Builder(Size size) {
            this.size = Objects.requireNonNull(size);
        }

        @Override public NyPizza build() {
            return new NyPizza(this);
        }

        @Override protected Builder self() {
            return this;
        }
    }

    private NyPizza(Builder builder) {
        super(builder);
        size = builder.size;
    }
}

public class Calzone extends Pizza {
    private final boolean sauceInside;
    
    public static class Builder extends Pizza.Builder&amp;lt;Builder&amp;gt; {
        private boolean sauceInside = false; // Default

        public Builder sauceInside() {
            sauceInside = true;
            return this;
        }
        
        @Override public Calzone build() {
            return new Calzone(this);
        }
        
        @Override protected Builder self() {
            return this; 
        }
    }
    
    private Calzone(Builder builder) {
        super(builder);
        sauceInside = builder.sauceInside;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，每个子类builder中的&lt;code&gt;build&lt;/code&gt;方法被声明为返回正确的子类：&lt;code&gt;NyPizza.Builder&lt;/code&gt;的&lt;code&gt;build&lt;/code&gt;方法返回&lt;code&gt;NyPizza&lt;/code&gt;，而&lt;code&gt;Calzone.Builder&lt;/code&gt;中的&lt;code&gt;build&lt;/code&gt;方法返回&lt;code&gt;Calzone&lt;/code&gt;。 这种技术，其一个子类的方法被声明为返回在超类中声明的返回类型的子类型，称为协变返回类型( covariant return typing)。 它允许客户端使用这些builder，而不需要强制转换。&lt;/p&gt;
&lt;p&gt;这些“分层builder”的客户端代码基本上与简单的&lt;code&gt;NutritionFacts&lt;/code&gt; builder的代码相同。为了简洁起见,下面显示的示例客户端代码假设枚举常量的静态导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NyPizza pizza = new NyPizza.Builder(SMALL)
        .addTopping(SAUSAGE).addTopping(ONION).build();
Calzone calzone = new Calzone.Builder()
        .addTopping(HAM).sauceInside().build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;builder对构造方法的一个微小的优势是，builder可以有多个可变参数，因为每个参数都是在它自己的方法中指定的。或者，builder可以将传递给多个调用的参数聚合到单个属性中，如前面的&lt;code&gt;addTopping&lt;/code&gt;方法所演示的那样。&lt;/p&gt;
&lt;p&gt;Builder模式非常灵活。 单个builder可以重复使用来构建多个对象。 builder的参数可以在构建方法的调用之间进行调整，以改变创建的对象。 builder可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。&lt;/p&gt;
&lt;p&gt;Builder模式也有缺点。为了创建对象，首先必须创建它的builder。虽然创建这个builder的成本在实践中不太可能被注意到，但在性能关键的情况下可能会出现问题。而且，builder模式比伸缩构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但是请记住，如果希望在将来添加更多的参数。但是，如果从构造方法或静态工厂开始，并切换到builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂就会面临尴尬的处境。因此，所以，最好从一开始就创建一个builder。&lt;/p&gt;
&lt;p&gt;总而言之，当设计类的构造方法或静态工厂的参数超过几个时，Builder模式是一个不错的选择，特别是如果许多参数是可选的或相同类型的。客户端代码比使用伸缩构造方法（telescoping constructors）更容易读写，并且builder比JavaBeans更安全。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 15:23:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8087978.html</dc:identifier>
</item>
<item>
<title>Python 学习(1) 简单的小爬虫 - 愤怒的鸡蛋面</title>
<link>http://www.cnblogs.com/lyndoo/p/8087954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyndoo/p/8087954.html</guid>
<description>&lt;p&gt;　　　最近抽空学了两天的Python，基础知识都看完了，正好想申请个联通日租卡，就花了2小时写了个小爬虫，爬一下联通日租卡的申请页面，看有没有好记一点的手机号~   人工挑眼都挑花了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127589/201712/1127589-20171222230536678-2129997934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用的IDE是PyCharm，首先下载一些需要用到的包和模块: requests 和 beautifulsoup4。 不过发现请求的url返回的是json数据，就没用beautifulsoup4而是直接用正则提取手机号了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1127589/201712/1127589-20171222225833865-321387731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注释写的还是很详细的，打分的方法非常简陋，一般这种便宜的套餐也没啥好号，今天太晚了，就这样吧，哪天有空了可以在增加些打分的规则。   代码在下面：  困，睡觉去~&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; http.client
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; URL = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://m.10010.com/NumApp/NumberCenter/qryNum?callback=jsonp_queryMoreNums&amp;amp;provinceCode=76&amp;amp;cityCode=760&amp;amp;monthFeeLimit=0&amp;amp;groupKey=41242783&amp;amp;searchCategory=3&amp;amp;net=01&amp;amp;amounts=200&amp;amp;codeTypeCode=&amp;amp;searchValue=&amp;amp;qryType=02&amp;amp;goodsNet=4&amp;amp;_=1513948237449&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_content(url):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;获取url内容&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;request header信息&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     header =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept-Encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;gzip, deflate, br&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Accept-Language&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh-CN,zh;q=0.9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时时间&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     timeout = random.choice(range(80,180&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求url获取返回的response对象&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             rep = requests.get(url, headers=header, timeout=&lt;span&gt;timeout)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; rep = requests.get(url)&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             rep.encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;出错后延迟一段你时间重试&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             time.sleep(random.choice(range(5, 20&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rep.text
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; grade(phone):
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;给手机号打分&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; phone[3:7] == phone[7:]:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;1--abcdabcd&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 100
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; phone[3:5] == phone[7:9] &lt;span&gt;and&lt;/span&gt; phone[5:7] == phone[9:]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1--aabbaabb&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 95
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; phone[3:7] == phone[7::-1]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1--abcddcba&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 90
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; phone[7:9] == phone[9:]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;尾号aabb&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 80
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; phone[7:9] == phone[9::-1]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;尾号abba&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 70
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; phone[3:5] == phone[7:9]: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1--ab--ab--&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 50
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可以在加一些其他的判定条件&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; save_resule(result):
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;把结果保存到result.txt文件&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; len(result) &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;result.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 f.write(x + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环查询次数&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; loop = 5
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;结果集合&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; result =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; len(sys.argv) == 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     loop = int(sys.argv[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, loop+1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; now = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print('{}  第{}次查询'.format(now, i))&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;     html = get_content(URL) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求url，获取json内容&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(html)&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;     regex_str = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1\d{10}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;提取手机号&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;     phones =&lt;span&gt; re.findall(regex_str, html)
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; phones:
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         level =&lt;span&gt; grade(x)
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; level &amp;gt; 0 &lt;span&gt;and&lt;/span&gt; x &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;            result.append(x)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(level, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, x)
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;     time.sleep(random.choice(range(1, 5)))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;不要请求的太频繁&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt; save_resule(result)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环结束保存到result.txt文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 22 Dec 2017 15:14:00 +0000</pubDate>
<dc:creator>愤怒的鸡蛋面</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyndoo/p/8087954.html</dc:identifier>
</item>
<item>
<title>更便捷的css处理方式-postcss - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/8059939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/8059939.html</guid>
<description>&lt;p&gt;一般来说介绍一个东西都是要从是什么，怎么用的顺序来讲。我感觉这样很容易让大家失去兴趣，先看一下postcss能做点什么，有兴趣的话再往下看，否则可能没有耐心看下去。让我们开始吧&lt;/p&gt;
&lt;h2 id=&quot;postcss能做什么&quot;&gt;postcss能做什么&lt;/h2&gt;
&lt;h3 id=&quot;补全css属性浏览器前缀&quot;&gt;补全css属性浏览器前缀&lt;/h3&gt;
&lt;p&gt;手写的代码可以是这样的:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.div&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;postcss可以转换之后成了这样:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.div&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -webkit-box&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -ms-flexbox&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;检查css语法&quot;&gt;检查css语法&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;    body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; #f0&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会有以下提示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;src/er.css
 2:12  ✖  Unexpected invalid hex color &quot;#f0&quot;   color-no-invalid-hex



[18:27:28] 'css-lint' errored after 98 ms
[18:27:28] Error in plugin 'gulp-stylelint'
Message:
    Failed with 1 error&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拥抱下个版本规范的css-即css4&quot;&gt;拥抱下个版本规范的css 即css4&lt;/h3&gt;
&lt;p&gt;对于下个规范的css而言，变量，方法等功能的都会增加上去，你可以这样来定义一个变量：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;dv&quot;&gt;:root&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;kw&quot;&gt;--red:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#d33&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
  a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt; 
      &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; var(--red)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然直接在现有浏览器上是跑不通的，就正如es2015刚开始一样，我们需要一个转化器来将其转成当前可用规范。postcss的插件就可以做到。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;a&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;#d33&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了上面之外还有其他很多功能，postcss及其插件都能提供。&lt;/p&gt;
&lt;h2 id=&quot;什么是postcss&quot;&gt;什么是postcss&lt;/h2&gt;
&lt;p&gt;现在让我们回到最基本的问题，postcss是什么。&lt;br/&gt;援引官网的定义，一种使用js来转化css的工具(A tool for transforming CSS with JavaScript)。其实我们更多的时候提到postcss是有两个含义的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;postcss本身，也就是我们npm install时的安装部分&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;基于postCss的丰富插件系统。&lt;br/&gt;上文那些功能，都是基于postcss的插件提供的功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;postcss本身并不直接用于处理样式，只有配合它的插件，才能完成相关的编译工作。&lt;/p&gt;
&lt;h4 id=&quot;postcss不是预编译语言的替代品&quot;&gt;postcss不是预编译语言的替代品&lt;/h4&gt;
&lt;p&gt;我想你脑海里一直在复现两个名词，less/sass，开始的时候我也一样，认为postcss跟二者一样是一种css预编译语言或者起到类似作用的一种语言。postcss不是要取代哪一个，更多的是提供的一种补充，完全可以是互补的概念。&lt;br/&gt;作为一个是使用js将css转化为AST然后进行处理的工具，完全不是预处理语言的替代品，postcss处理的必须是css文件，所以完全可以和预编译语言结合，使用预编译语言转化为css之后然后进行处理。&lt;br/&gt;我一直认为两者不是互斥的关系，完全可以互补使用。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要postcss&quot;&gt;为什么需要postcss&lt;/h2&gt;
&lt;p&gt;大家可能有这么个疑问既然两者不互相冲突，目前我使用less/sass 也很容易满足我的需求，为什么要使用新的东西呢。我认为主要原因是其提供的丰富的插件功能，可以工作更加的简单化，便捷化，一句话，你只需要编写基本的css，其他的功能交给postcss就好。做了简单的对比可能更加清晰明了。&lt;/p&gt;
&lt;h4 id=&quot;实现给css属性加上浏览器前缀的功能&quot;&gt;实现给css属性加上浏览器前缀的功能&lt;/h4&gt;
&lt;p&gt;对比一下less和postcss的实现：&lt;/p&gt;
&lt;p&gt;1、 对于less而言，肯定是写一个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.flex-block&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -ms-flexbox&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -webkit-flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.flex-block()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、使用postcss&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要编译的时候使用autoprefixer处理就好。&lt;br/&gt;可能一个属性的效果不是特别明显，要是有很多个属性需要处理呢?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.flex-block&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -ms-flexbox&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; -webkit-flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.transform&lt;/span&gt;()&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;//仅仅是举例子&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.ccc&lt;/span&gt;()&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.flex-block()&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.transform()&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;.ccc()&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候postcss还是只需要如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.test&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; flex&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;transform:&lt;/span&gt;rotate(&lt;span class=&quot;dt&quot;&gt;7deg&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候就能看出来postcss的便捷性了，我一直认为可以抽象公共化的东西完全没有必要去重复的去手动开发。&lt;/p&gt;
&lt;h2 id=&quot;postcss工作原理&quot;&gt;postcss工作原理&lt;/h2&gt;
&lt;p&gt;postcss本身是一个node模块，可以将css文件解析为抽象语法树(AST)，将该树在多个插件方法传递，然后将AST转换为字符串返回，该字符串可以输出到目标文件中。传递过程中的插件可以选择是否改变该语法树，上诉改变可以通过sourcemap来记录。如下面的流程所示(借用w3cplus的一张图)：&lt;br/&gt;&lt;img src=&quot;https://www.w3cplus.com/sites/default/files/blogs/2017/1707/figure-18.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这里我们更应该关联起来的是babel，看一下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将未来规范的转化为当前规范的转义器&lt;/li&gt;
&lt;li&gt;实现相同，都是将源文件解析为AST然后经由插件处理。&lt;/li&gt;
&lt;li&gt;丰富的插件，满足不同的需求&lt;/li&gt;
&lt;li&gt;支持自定义插件的开发&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;当前工作流中引入postcss&quot;&gt;当前工作流中引入postcss&lt;/h4&gt;
&lt;p&gt;大家可能会有这种想法，又是一种新的工具，我当前的开发框架中岂不是要大动。其实这种担心是没必要的。postcss是很容易引入当前的工作流中的。无论是webpack还是gulp，都有比较方便的方式。&lt;a href=&quot;https://github.com/postcss/postcss#usage&quot;&gt;官方有详细的介绍文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;原先很早就看到postCss，当时太年轻认为是less的一种替代品罢了，所以一直没有去关注。了解之后感觉真的不错，至于如何使用这里就不去演示了，有兴趣的可以查看下&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/postcss/tree/master/&quot;&gt;我的简单示例&lt;/a&gt;希望更多的人使用。&lt;/p&gt;
&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/&quot; class=&quot;uri&quot;&gt;http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/&quot; class=&quot;uri&quot;&gt;http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 14:08:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/8059939.html</dc:identifier>
</item>
<item>
<title>C#中级-从零打造基于Socket在线升级模块 - airforce094</title>
<link>http://www.cnblogs.com/lovecsharp094/p/8087605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovecsharp094/p/8087605.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;      &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;前段时间一直在折腾基于Socket的产品在线升级模块。之前我曾写过基于.Net Remoting的、基于WCF的在线升级功能，由于并发量较小及当时代码经验的不足一直没有实际应用。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;这次下定决心撰写基于Socket的在线更新功能，一方面是觉得Socket的并发量较高，另一方面也是自己工作了一年多，积攒了一定的经验，应该能hold住。本文将展示的是&lt;span&gt;&lt;strong&gt;Protype&lt;/strong&gt;&lt;/span&gt;版本，Release版本已在远程测试服务器上运行，并发数过万没有什么问题，文件更新都很正常。代码的Github地址将在本文最后提供。本文将展示的在线更新功能模块涉及Devexpress WPF、Webapi、Windows Service，我会从最基础的开始说起，非常适合初入的新手，大牛或者老司机可直接略过。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;公司的产品是运行在某一BIM软件上的插件，要想做在线更新，有以下两种方案：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        方案一：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        插件安装后会在客户桌面上生成一个快捷方式，双击快捷方式会启动一个LaunchProduct.exe，在这里面进行更新操作，更新完之后再启动BIM软件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        方案二：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        用户首先运行BIM软件，点击插件里的更新按钮，然后通过Socket下载文件。进程中Kill掉该BIM软件，执行文件替换，再自动启动该BIM软件。（不kill掉的话程序一直被占用是无法更新文件的）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、步骤详解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;      &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;无论是方案一，还是方案二，有些核心步骤是不变的。下面详细论述：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Step1：&lt;/strong&gt;&lt;/span&gt; 从注册表中读取当前产品的版本、安装位置等信息。注册表是在做产品安装包时就应该要做的一件事情。我正好也是做产品安装包的，非常熟悉产品注册表里有哪些内容。那么这里，我封装了一个读注册表的class，可以在Github项目里找到：&lt;span&gt;&lt;strong&gt;RegistryUtils （UpdaterClient工程中）&lt;/strong&gt;&lt;span&gt;在这里要提醒的一个地方是：有时候注册表明明有内容，C#代码调试却是null，那么解决的办法如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; localMachineRegistry = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ?&lt;span&gt; RegistryView.Registry64 : RegistryView.Registry32);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用这个localMachineRegistry去OpenSubKey()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step2：&lt;/span&gt;&lt;/strong&gt; 从注册表里读取完本地产品的相关信息后，我把这些数据封装成一个对象，去请求产品服务器上的某个Webapi，如果有更新文件会返回给我更新文件的大小及MD5值。更新文件的大小决定了我每个分包的大小，更新文件的MD5值用于我下载完分包进行合并后进行MD5比对，验证下载的包是否完整。&lt;span&gt;&lt;span&gt;&lt;strong&gt;Md5Utils &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;（UpdaterShare工程中）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Get Download File Info 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;basicInfo&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serverAddress&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;controllerName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;actionName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serverResult&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; RequestDownloadFileInfo(ClientBasicInfo basicInfo,
                                                   &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serverAddress, 
                                                   &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; controllerName,
                                                   &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; actionName,
                                                   &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; DownloadFileInfo serverResult)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; packageInfo =&lt;span&gt; JsonConvert.SerializeObject(basicInfo);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient
                {
                    BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(serverAddress),
                    Timeout &lt;/span&gt;= TimeSpan.FromMinutes(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
                };

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ConnectionTest(serverAddress))
                {
                    StringContent strData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringContent(packageInfo, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; postUrl = httpClient.BaseAddress + $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/{controllerName}/{actionName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    Uri address &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(postUrl);
                    Task&lt;/span&gt;&amp;lt;HttpResponseMessage&amp;gt; task =&lt;span&gt; httpClient.PostAsync(address, strData);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        task.Wait();
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    }
                    HttpResponseMessage response &lt;/span&gt;=&lt;span&gt; task.Result;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;response.IsSuccessStatusCode)
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; jsonResult =&lt;span&gt; response.Content.ReadAsStringAsync().Result;
                        serverResult &lt;/span&gt;= JsonConvert.DeserializeObject&amp;lt;DownloadFileInfo&amp;gt;&lt;span&gt;(jsonResult);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (serverResult != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }                     
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex)
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    }                
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step3：&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;拿到更新文件的大小及MD5值后，我们就可以开始本地通过Socket去请求服务器下载更新文件了。这里的Socket我使用的是APM写法，也就是异步编程模型。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;APM是微软比较早的提供用于Socket通信的方法。其最常见的写法就是 BeginAction(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state)，在&lt;span&gt;callback&lt;/span&gt;回调函数里EndAction。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我在Client里是通过生成5个Task，每个Task各有一个Socket去下载文件，每个Task只下载1/5文件，最后合并。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/943487/201712/943487-20171222212302240-1339783743.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;var&lt;/span&gt; tasks = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Task[packetCount];
           &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; packetCount; index++&lt;span&gt;)
           {
               &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; packetNumber =&lt;span&gt; index;
               &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task = &lt;span&gt;new&lt;/span&gt; Task(() =&amp;gt;&lt;span&gt;
               {                  
                  Socket client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                  ComObject state &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ComObject { WorkSocket = client, PacketNumber =&lt;span&gt; packetNumber };
                  client.BeginConnect(remoteEp, ConnectCallback, state);
               });                  
               tasks[packetNumber] &lt;/span&gt;=&lt;span&gt; task;
               task.Start();
           }
           Task.WaitAll(tasks);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;那么有的线程接收文件快，有的接收文件慢。因为最后还要分别生成5个临时文件进行合并。所以需要一个线程同步，让快的或慢的都在终点线等着。&lt;span&gt;这里就要用到&lt;/span&gt; &lt;span&gt;&lt;strong&gt;ManualResetEvent&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，其继承于&lt;/span&gt;&lt;strong&gt;&lt;span&gt;EventWaitHandle&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;EventWaitHandle&lt;/strong&gt;&lt;/span&gt;又继承于&lt;span&gt;&lt;strong&gt;WaitHandle&lt;/strong&gt;&lt;/span&gt;。&lt;span&gt;&lt;strong&gt;ManualResetEvent&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是怎么使用的呢？因为代码都在Github上，这里提炼一下，总结就是：初始为false的时候，只有使用&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Set()&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;方法，才能让写在&lt;/span&gt;&lt;strong&gt;&lt;span&gt;WaitOne()&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;之后的代码运行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在Socket里肯定要定义一个自己产品的数据包格式，因为Socket里传的都是byte[]，你肯定要让客户端/服务器知道你发的byte[]是什么意思吧，所以要定义数据包格式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
A Packet = start_tag + version_tag + request/response_tag + length_tag + data + crc16_tag        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1. 包头标识，一般用 { 0xAA, 0x55 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 格式版本，暂且定为 { 0x01 }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 发送标识，是客户端发的呢？还是服务器发的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 长度标识，用于记录整个数据包的长度，此标识占2个字节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 数据，要传输的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. crc16校验码。用于判断传输的byte[]是否完整，相对于MD5，crc16校验码的字节数更短，不会占太多传输字节，非常适合用于字节数组的比较。MD5常常用于文件对比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，有了长度标识与crc16校验码的双保险，我们就可以知道传输的byte[]是否完整了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当一方发送byte[]后，另一方收到后可以拿出长度标识，判断byte[]长度是否正确；当长度正确后，使用&lt;/span&gt; &lt;span&gt;&lt;strong&gt;Crc16Utils&lt;/strong&gt; 计算收到的byte[]的crc16码并与byte[]中的crc16码进行比对。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step4：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;服务器端的Socket是写在Windows Service里的。更新文件就放在该Windows Service同路径下，因为Windows Service在启动运行之后会在注册表写下相应信息，通过注册表就能知道该Windows Service的执行路径，继而得到更新文件的路径。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/943487/201712/943487-20171222212956990-475721981.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Get Latest File From Windows Service by Registry
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceName&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFilePathFromService(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; serviceName)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                ServiceController[] services &lt;/span&gt;=&lt;span&gt; ServiceController.GetServices();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; socketService = services.FirstOrDefault(x =&amp;gt; String.Equals(x.ServiceName, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SocketService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketService != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {&lt;br/&gt;&lt;span&gt;var &lt;span&gt;localMachineRegistry = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ?&lt;/span&gt;&lt;span&gt; &lt;br/&gt;RegistryView.Registry64 : RegistryView.Registry32); &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;&lt;span&gt;&lt;span&gt;localMachineRegistry&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;.OpenSubKey(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SYSTEM\CurrentControlSet\Services\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; serviceName);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceExePath = GetString(key.GetValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ImagePath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).ToString());
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; folderPath =&lt;span&gt; Path.GetDirectoryName(serviceExePath);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!String.IsNullOrEmpty(folderPath) &amp;amp;&amp;amp;&lt;span&gt; Directory.Exists(folderPath))
                        {
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; folderPath;
                        }                    
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Step5：&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;当下载完文件，其实已经完成了90%的工作了，剩下的无非就是简单的替换文件，更新注册表信息等等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后附上完整的流程图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/943487/201712/943487-20171222212614412-1232022665.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四&lt;strong&gt;、其它&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我在写代码的时候参考了微软的示例，还是非常有帮助的，在此提供下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Microsoft官方示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/network-programming/asynchronous-client-socket-example&quot;&gt;https://docs.microsoft.com/en-us/dotnet/framework/network-programming/asynchronous-client-socket-example&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前微软早已提供了更接近Socket底层的SocketAsyncEventArgs（SAEA）写法，该方法不同于APM的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. APM多次Send\Receive会产生多个IAsyncResult对象，增加消耗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. SAEA配合BufferManager以及池化能很好的调配服务器资源，有多少坑就蹲多少人，再多了就可以考虑转移至其它服务器做均衡了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. SAEA的并发能力比APM略高，但是坑也不少，比如APM中，通过EndReceive是否为0我就能知道还有没有数据要接收，但是SAEA中的Avilable等于0时还可能有数据没接收完，这个问题的解决方法网上各种各样，各位可以自己搜搜。SAEA的服务器写法我看看之后有没有时间写写。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GitHub地址：&lt;span&gt;&lt;a href=&quot;https://github.com/airforce094/SocketUpdater&quot;&gt;https://github.com/airforce094/SocketUpdater&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五&lt;strong&gt;、最后&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;  此Github里&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;涉及Devexpress WPF、Webapi、Windows Service，不求Star，您的阅读就是对我最大的支持。有什么问题可留言相互讨论。今年由于公司管理层变动，人员及业务会有较大调整，突然觉得小公司有时候也挺折腾的。我继续淡定学车，坐看其变。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;《原创，转载请注明来源》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;来自：airforce094&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Dec 2017 13:52:00 +0000</pubDate>
<dc:creator>airforce094</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovecsharp094/p/8087605.html</dc:identifier>
</item>
</channel>
</rss>