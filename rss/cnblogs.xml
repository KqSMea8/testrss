<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java数据类型 - 三哥无邪</title>
<link>http://www.cnblogs.com/sangewuxie/p/8473514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sangewuxie/p/8473514.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;基本数据类型    4类8种&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;四类&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;八种&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;字节数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;数据表示范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;整&lt;/strong&gt;&lt;strong&gt;型&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;byte&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot;&gt;-128～127&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;short&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot;&gt;-32768～32767&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot;&gt;-2147483648～2147483648&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;long&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot;&gt;-2&lt;sup&gt;63&lt;/sup&gt;～2&lt;sup&gt;63&lt;/sup&gt;-1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;浮点型&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;float&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot;&gt;-3.403E38～3.403E38&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;double&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot;&gt;
&lt;p class=&quot;16&quot;&gt;-1.798E308～1.798E308&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;字符型&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;16&quot;&gt;表示一个字符，如('a'，'A'，'0'，'家')&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p class=&quot;16&quot; align=&quot;center&quot;&gt;&lt;strong&gt;布尔型&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;159&quot;&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt;boolean&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;144&quot;&gt;
&lt;p class=&quot;16&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;375&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;16&quot;&gt;只有两个值true与false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据类型转换&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;转换的过程中，数据遵循一个原则：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围小的数据类型值（如&lt;/span&gt;byte&lt;span&gt;），可以直接转换为范围大的数据类型值（如&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围大的数据类型值（如&lt;/span&gt;int&lt;span&gt;），不可以直接转换为范围小的数据类型值（如&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;各种数据类型按照数据范围从小到大依次列出：&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;byte -&amp;gt; short -&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;strong&gt;自动类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;表示范围小的数据类型转换成范围大的数据类型，这种方式称为自动类型转换&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;自动类型转换格式：&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;span&gt;范围大的数据类型&lt;/span&gt; &lt;span&gt;变量&lt;/span&gt; = 范围小的数据类型值；&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;如：&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    double d = 1000;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;或&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    int i = 100;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    double d2 = i;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;strong&gt;强制类型转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;表示范围大的数据类型转换成范围小的数据类型，这种方式称为强制类型转换&lt;/p&gt;
&lt;p&gt;强制类型转换格式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围小的数据类型&lt;/span&gt;  &lt;span&gt;变量&lt;/span&gt; = (&lt;span&gt;范围小的数据类型&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;范围大的数据类型值&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;int  i = (int)6.718;   //i&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;double  d = 3.14;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;int  i2 = (int)d;     //i2&lt;span&gt;的值为&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 07:34:00 +0000</pubDate>
<dc:creator>三哥无邪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sangewuxie/p/8473514.html</dc:identifier>
</item>
<item>
<title>JAVAEE——BOS物流项目06：分页查询、分区导出Excel文件、定区添加、分页问题总结 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/8473467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/8473467.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1&lt;span&gt;、分区组合条件分页查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 分区分页查询（没有过滤条件）&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 分区分页查询（带有过滤条件）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;span&gt;、分区导出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 页面调整&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n &lt;span&gt;使用&lt;/span&gt;POI&lt;span&gt;将数据写到&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 通过输出流进行文件下载&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;span&gt;、定区添加&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 定区概念&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 定区添加页面调整&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 服务端实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;span&gt;、定区分页查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 页面调整&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 服务端实现&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 分页问题总结&lt;/p&gt;


&lt;h2&gt;2.1 &lt;strong&gt;分区分页查询（没有过滤条件）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;页面：&lt;/span&gt;WEB-INF/pages/base/subarea.jsp&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：修改&lt;/span&gt;jsp&lt;span&gt;页面中&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226151854705-2011535504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：在&lt;/span&gt;SuareaAction&lt;span&gt;中提供分页查询方法&lt;/span&gt;&lt;span&gt;pageQuery&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226151906433-2004422680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：修改&lt;/span&gt;subarea.hbm.xml&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226151911114-18143344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 &lt;strong&gt;分区分页查询（带有过滤条件）&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;2.2.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226151917185-1025635016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;datagrid&lt;span&gt;提供的方法：用于重新发送&lt;/span&gt;&lt;span&gt;ajax&lt;/span&gt;&lt;span&gt;请求，并且可以提交参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226151920484-3076443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第一步：提供一个工具方法，可以将指定的&lt;/span&gt;form&lt;span&gt;表单中所有的输入项转为&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;数据，用于参数提交&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个工具方法，用于将指定的form表单中所有的输入项转为json数据{key:value,key:value}&lt;/span&gt;
        $.fn.serializeJson=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){  
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serializeObj=&lt;span&gt;{};  
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serializeArray();
            $(array).each(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){  
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(serializeObj[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name]){  
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($.isArray(serializeObj[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name])){  
                        serializeObj[&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name].push(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value);  
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{  
                        serializeObj[&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name]=[serializeObj[&lt;span&gt;this&lt;/span&gt;.name],&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value];  
                    }  
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{  
                    serializeObj[&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name]=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value;   
                }  
            });  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; serializeObj;  
        };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：为查询窗口中查询按钮绑定事件&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
$(&quot;#btn&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将指定的form表单中所有的输入项转为json数据{key:value,key:value}&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; p = $(&quot;#searchForm&quot;&lt;span&gt;).serializeJson();
            console.info(p);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用数据表格的load方法，重新发送一次ajax请求，并且提交参数&lt;/span&gt;
            $(&quot;#grid&quot;).datagrid(&quot;load&quot;&lt;span&gt;,p);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭查询窗口&lt;/span&gt;
            $(&quot;#searchWindow&quot;).window(&quot;close&quot;&lt;span&gt;);
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152017093-1693338322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.2 &lt;strong&gt;&lt;span&gt;修改&lt;/span&gt;Action&lt;span&gt;中分页查询方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分页查询
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String pageQuery(){
        DetachedCriteria dc &lt;/span&gt;=&lt;span&gt; pageBean.getDetachedCriteria();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态添加过滤条件&lt;/span&gt;
        String addresskey =&lt;span&gt; model.getAddresskey();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isNotBlank(addresskey)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加过滤条件，根据地址关键字模糊查询&lt;/span&gt;
            dc.add(Restrictions.like(&quot;addresskey&quot;, &quot;%&quot;+addresskey+&quot;%&quot;&lt;span&gt;));
        }
        
        Region region &lt;/span&gt;=&lt;span&gt; model.getRegion();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(region != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            String province &lt;/span&gt;=&lt;span&gt; region.getProvince();
            String city &lt;/span&gt;=&lt;span&gt; region.getCity();
            String district &lt;/span&gt;=&lt;span&gt; region.getDistrict();
            dc.createAlias(&lt;/span&gt;&quot;region&quot;, &quot;r&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isNotBlank(province)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加过滤条件，根据省份模糊查询-----多表关联查询，使用别名方式实现
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数一：分区对象中关联的区域对象属性名称
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数二：别名，可以任意&lt;/span&gt;
                dc.add(Restrictions.like(&quot;r.province&quot;, &quot;%&quot;+province+&quot;%&quot;&lt;span&gt;));
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isNotBlank(city)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加过滤条件，根据市模糊查询-----多表关联查询，使用别名方式实现
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数一：分区对象中关联的区域对象属性名称
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数二：别名，可以任意&lt;/span&gt;
                dc.add(Restrictions.like(&quot;r.city&quot;, &quot;%&quot;+city+&quot;%&quot;&lt;span&gt;));
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isNotBlank(district)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加过滤条件，根据区模糊查询-----多表关联查询，使用别名方式实现
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数一：分区对象中关联的区域对象属性名称
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数二：别名，可以任意&lt;/span&gt;
                dc.add(Restrictions.like(&quot;r.district&quot;, &quot;%&quot;+district+&quot;%&quot;&lt;span&gt;));
            }
        }
        subareaService.pageQuery(pageBean);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.java2Json(pageBean, &lt;span&gt;new&lt;/span&gt; String[]{&quot;currentPage&quot;,&quot;detachedCriteria&quot;,&quot;pageSize&quot;&lt;span&gt;,
                        &lt;/span&gt;&quot;decidedzone&quot;,&quot;subareas&quot;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;BaseDao&lt;span&gt;中的分页查询方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152055312-301024258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;3.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;为页面中导出按钮绑定事件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152102658-595341973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.2 &lt;strong&gt;服务端实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;第一步：查询所有的分区数据&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：使用&lt;/span&gt;POI&lt;span&gt;将数据写到&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;文件中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步：使用输出流进行文件下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分区数据导出功能
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String exportXls() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步：查询所有的分区数据&lt;/span&gt;
        List&amp;lt;Subarea&amp;gt; list =&lt;span&gt; subareaService.findAll();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二步：使用POI将数据写到Excel文件中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在内存中创建一个Excel文件&lt;/span&gt;
        HSSFWorkbook workbook = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFWorkbook();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个标签页&lt;/span&gt;
        HSSFSheet sheet = workbook.createSheet(&quot;分区数据&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建标题行&lt;/span&gt;
        HSSFRow headRow = sheet.createRow(0&lt;span&gt;);
        headRow.createCell(&lt;/span&gt;0).setCellValue(&quot;分区编号&quot;&lt;span&gt;);
        headRow.createCell(&lt;/span&gt;1).setCellValue(&quot;开始编号&quot;&lt;span&gt;);
        headRow.createCell(&lt;/span&gt;2).setCellValue(&quot;结束编号&quot;&lt;span&gt;);
        headRow.createCell(&lt;/span&gt;3).setCellValue(&quot;位置信息&quot;&lt;span&gt;);
        headRow.createCell(&lt;/span&gt;4).setCellValue(&quot;省市区&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Subarea subarea : list) {
            HSSFRow dataRow &lt;/span&gt;= sheet.createRow(sheet.getLastRowNum() + 1&lt;span&gt;);
            dataRow.createCell(&lt;/span&gt;0&lt;span&gt;).setCellValue(subarea.getId());
            dataRow.createCell(&lt;/span&gt;1&lt;span&gt;).setCellValue(subarea.getStartnum());
            dataRow.createCell(&lt;/span&gt;2&lt;span&gt;).setCellValue(subarea.getEndnum());
            dataRow.createCell(&lt;/span&gt;3&lt;span&gt;).setCellValue(subarea.getPosition());
            dataRow.createCell(&lt;/span&gt;4&lt;span&gt;).setCellValue(subarea.getRegion().getName());
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三步：使用输出流进行文件下载（一个流、两个头）&lt;/span&gt;
&lt;span&gt;        
        String filename &lt;/span&gt;= &quot;分区数据.xls&quot;&lt;span&gt;;
        String contentType &lt;/span&gt;=&lt;span&gt; ServletActionContext.getServletContext().getMimeType(filename);
        ServletOutputStream out &lt;/span&gt;=&lt;span&gt; ServletActionContext.getResponse().getOutputStream();
        ServletActionContext.getResponse().setContentType(contentType);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取客户端浏览器类型&lt;/span&gt;
        String agent = ServletActionContext.getRequest().getHeader(&quot;User-Agent&quot;&lt;span&gt;);
        filename &lt;/span&gt;=&lt;span&gt; FileUtils.encodeDownloadFilename(filename, agent);
        ServletActionContext.getResponse().setHeader(&lt;/span&gt;&quot;content-disposition&quot;, &quot;attachment;filename=&quot;+&lt;span&gt;filename);
        workbook.write(out);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;定区是进行物流分配的基本单位，可以将取派员、分区、客户信息进行关联，为自动分单提供数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页面：&lt;/span&gt;WEB-INF/pages/base/decidedzone.jsp&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152137669-1163972229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;4.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;4.1.1 &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;combobox&lt;span&gt;展示取派员数据&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;第一步：修改定区页面中&lt;/span&gt;combobox&lt;span&gt;下拉框&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152143003-134671887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第二步：在&lt;/span&gt;StaffAction&lt;span&gt;中提供&lt;/span&gt;&lt;span&gt;listajax&lt;/span&gt;&lt;span&gt;方法，查询所有未删除的取派员，返回&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有未删除的取派员，返回json
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String listajax(){
        List&lt;/span&gt;&amp;lt;Staff&amp;gt; list =&lt;span&gt; staffService.findListNotDelete();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.java2Json(list, &lt;span&gt;new&lt;/span&gt; String[]{&quot;decidedzones&quot;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第三步：在&lt;/span&gt;BaseDao&lt;span&gt;中扩展一个通用查询方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152202176-181980568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第四步：在&lt;/span&gt;StaffService&lt;span&gt;中扩展方法，查询未删除的取派员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152207272-299096470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152212993-1847072124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.1.2 &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;datagrid&lt;span&gt;展示分区数据&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;第一步：修改页面中&lt;/span&gt;datagrid&lt;span&gt;的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152223249-727194864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：在&lt;/span&gt;SubareaAction&lt;span&gt;中提供&lt;/span&gt;&lt;span&gt;listajax&lt;/span&gt;&lt;span&gt;方法，查询所有未关联到定区的分区，返回&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152229523-619922868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：在&lt;/span&gt;SubareaService&lt;span&gt;中扩展方法，查询未关联到定区的分区&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152236318-1035528619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152241988-2015211983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;4.1.3 &lt;strong&gt;为保存按钮绑定事件提交表单&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152249317-2072100129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;问题一：提交的表单中存在多个&lt;/span&gt;id&lt;span&gt;参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152254717-1196086897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解决方案：将&lt;/span&gt;datagrid&lt;span&gt;的&lt;/span&gt;&lt;span&gt;filed&lt;/span&gt;&lt;span&gt;由&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;改为&lt;/span&gt;&lt;span&gt;subareaid&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152301241-273815457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;问题二：提交的表单中&lt;/span&gt;subareaid&lt;span&gt;参数的值为&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152307601-1013005428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;解决方案：在分区类中提供&lt;/span&gt;getSubareaid&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152314758-1722555852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152325445-1984587741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.2 &lt;strong&gt;服务端实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建定区的&lt;/span&gt;Action&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Dao&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152332984-853753602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Service&lt;span&gt;代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152340665-1548383691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;配置&lt;/span&gt;struts.xml&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152344752-900433520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;第一步：修改定区&lt;/span&gt;jsp&lt;span&gt;页面中&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152350706-1124486369.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：在定区&lt;/span&gt;Action&lt;span&gt;中提供&lt;/span&gt;&lt;span&gt;pageQuery&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152354978-720596033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：在&lt;/span&gt;Decidedzone.hbm.xml&lt;span&gt;中修改，查询定区对象时需要立即加载关联的取派员对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201802/1135185-20180226152358585-762662511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;1&lt;span&gt;、页面不需要展示关联数据时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决：将关联对象属性排除掉&lt;/p&gt;

&lt;p&gt;2&lt;span&gt;、页面需要展示关联数据时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决：将关联对象改为立即加载，并且将关联对象中的属性排除&lt;/p&gt;

</description>
<pubDate>Mon, 26 Feb 2018 07:26:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/8473467.html</dc:identifier>
</item>
<item>
<title>Python网络编程（1）-socket - 无敌小怪兽</title>
<link>http://www.cnblogs.com/Chen-Zhipeng/p/8472936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chen-Zhipeng/p/8472936.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;　　　我会在近期尽快更新好之前写的博客，会添加新的知识点和注意问题，排版和内容都会较之前有很大的改观，感谢大家一直的支持！&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;1、&lt;/strong&gt; &lt;strong&gt;客户端/服务器架构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　客户端/服务器架构也称主从式架构，简称C/S架构，它是一种网络结构，把客户端（Client）(通常是一个采用图形界面的程序)与服务器（server）区分开来，在C/S架构中，服务器是一系列的硬件或软件，客户端是提交服务请求的用户，客户端提供用户请求接口，服务端响应请求进行对应的处理，并返回给客户端。客户端/服务器架构既可以应用于计算机硬件，也可以应用于软件。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.1、&lt;/strong&gt; &lt;strong&gt;硬件客户端/服务器架构&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　典型的硬件客户端/服务器架构就是打印机，在企业中，员工通过局域网将个人电脑连接到打印机上，作为客户端向打印机发送打印请求，打印机作为服务端完成响应处理相应的请求。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;1.2、&lt;/strong&gt; &lt;strong&gt;软件客户端/服务器架构&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　软件服务器也是运行在硬件之上的，典型的软件服务器是Web服务器。在一台或多台电脑上搭建Web服务器，以提供用户访问所需的Web页面和应用程序，Web服务器一旦启动，都将可能永远运行，除非受到一些外力驱使才会停止，如人为关闭，服务器硬件故障等。它的工作就是接收客户端的请求，并响应请求给客户端返回相应的Web页面，然后等待下一个客户端的请求。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2、&lt;/strong&gt; &lt;strong&gt;套接字&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　套接字是网络编程中的一个基本组件，如果想要服务器能够响应客户端发来的请求，首先要建立一个通信端点，使服务器能够监听服务，当通信端点建立后，就会进入无限循环的等待请求状态，当接收到客户端的请求，就会响应该请求。&lt;/p&gt;
&lt;p&gt;　　套接字就是两个程序之间的信息通道，可以理解为上面提到的“通信端点”的概念。在通信开始之前，网络应用程序必须创建套接字。套接字是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息:连接使用的协议，本地主机的IP地址，本地进程的协议端口号，远程主机的IP地址，远程进程的协议端口号。&lt;/p&gt;
&lt;p&gt;　　套接字起源于 20 世纪 70 年代，它是加利福尼亚大学伯克利分校版本的 Unix的一部分,即人们所说的 BSD Unix。 因此,套接字也被人们称为“伯克利套接字”或“BSD 套接字”。套接字最初被设计用于同一台主机上多个应用程序之间的通讯，这也就是所谓的进程间通讯（IPC）。&lt;/p&gt;
&lt;p&gt;　　TCP用主机的IP地址加上主机的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）表示。&lt;/p&gt;
&lt;p&gt;　　套接字有两种类型,分别是基于文件的和基于网络的。&lt;/p&gt;
&lt;p&gt;　　基于文件的套接字家族名字叫做“AF_UNIX”,代表地址家族（address family）：UNIX。在Unix和linux操作系统中，熟为人知的一句话就是：一切皆文件，一个或多个进程运行在同一台机器上，所以套接字是基于文件的，它就可以通过访问底层的基础结构来实现进程之间的通信&lt;/p&gt;
&lt;p&gt;　　基于网络的套接字家族名字叫做“AF_INET”，代表地址家族（address family）：INET(因特网)。它使用IPv4进行通信，因为IPv4使用32位地址，相比于IPv6的128位来说，计算更快，更适合于局域网的通信。目前它也是使用最广泛的。&lt;/p&gt;
&lt;p&gt;　　在本文中，重点讲网络编程，所以在后面的涉及最多的还是AF_INET。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.1、&lt;/strong&gt; &lt;strong&gt;流式套接字（SOCK_STREAM）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　不论使用哪种地址家族，都只有两种套接字的连接方式，一种是面向连接的，一种是无连接的。&lt;/p&gt;
&lt;p&gt;　　面向连接的套接字连接方式，意味着在进程通信之前必须先建立好一个连接，这种套接字就称为流式套接字。&lt;/p&gt;
&lt;p&gt;　　流式套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission Control Protocol）协议。在Python中，创建TCP套接字，就必须声明SOCK_STREAM作为套接字类型。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.2、&lt;/strong&gt; &lt;strong&gt;数据报套接字（SOCK_DGRAM）&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　数据报套接字提供了一种&lt;a href=&quot;https://baike.baidu.com/item/%E6%97%A0%E8%BF%9E%E6%8E%A5&quot; target=&quot;_blank&quot;&gt;无连接&lt;/a&gt;的服务。这也意味着，使用这种连接方式不需要在进程通信前建立连接。在数据的传输过程中，SOCK_DGRAM并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。&lt;/p&gt;
&lt;p&gt;　　虽然存在数据丢失、重复、数据无序接受等很多缺点，但它也有优势所在，在流式套接字中，因为是面向连接并提供了可靠的数据传输服务，这对于虚拟电路连接的维护需要很大的开销，但数据报套接字就不需要这些额外的开销，所以维护、资源占用成本更低。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3、&lt;/strong&gt; &lt;strong&gt;网络编程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　Python是一个很强大的网络编程工具，Python内有很多针对网络协议的库，这些库对网络协议的各个层次进行抽象封装，这对于程序员来说就意味着：不必关心网络协议的原理，只需要通过对程序的逻辑处理，就可以实现网络数据的传输。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1、&lt;/strong&gt; &lt;strong&gt;创建套接字&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在Python中，创建套接字需要使用socket模块，通过socket()函数创建套接字对象。&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; socket(_socket.socket):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         -- skip --
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             -- skip --
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　从socket函数的的构造方法中可以看出，可以指定地址家族和套接字的连接方式，proto默认是0，通常都省略。即创建套接字对象的时候：&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　import socket&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　#创建TCP/IP套接字，地址家族AF_INET&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　&lt;strong&gt;　tcp_socket = socket.socket(socket.AF_INET,socket.SOCKET_STREAM)&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　#创建UDP/IP套接字，地址家族AF_INET&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;udp_socket = socket.socket(socket.AF_INET,socket.SOCKET_DGRAM)&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.2、&lt;/strong&gt; &lt;strong&gt;套接字的内置方法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;常见的套接字内置函数&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;st.recv()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;pre&gt;
接受TCP的消息
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;st.recv_into()&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;接受TCP的消息到指定的缓存区&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;st.send()&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;发送TCP的消息(当待发送的消息量大于缓存区剩余内存时，数据会丢失)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;st.sendall()&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;完整的发送TCP消息（当待发送的消息量大于缓存区剩余内存时，数据不会丢失，循环调用send 直到发完为止）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;st.recvfrom()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;接收UDP的消息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;st.recvfrom_into()&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;接收UDP的消息到指定的缓存区&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;st.sendto()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;发送UDP的消息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;st.getpeername()&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;连接到套接字的远程地址（TCP）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;st.getsockname()&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取当前套接字的地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;st.getsockopt()&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取指定套接字的参数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;st.setsockopt()&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置指定套接字的参数&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;st.close()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;关闭套接字&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;st.shutdown()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;关闭连接&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　&lt;strong&gt;服务端套接字方法&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.bind()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将IP地址+端口号绑定到套接字上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.listen()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;开启TCP监听功能&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.accept()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;被动的接受TCP客户端的连接，（阻塞式）一直等待连接直到连接到达&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　&lt;strong&gt;客户端套接字方法&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.connect()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;主动发起TCP服务器连接&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.connect_ex()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;connect()的扩展版本，以错误代码的形式返回问题，而不是抛出异常&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;      &lt;strong&gt;面向阻塞的套接字方法&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.setblocking()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置套接字为阻塞模式或非阻塞模式&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.settimeout()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置阻塞套接字的操作超时时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.gettimoout()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;获取阻塞套接字的操作超时时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;    &lt;strong&gt;面向文件的套接字方法&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.fileno()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;套接字的文件描述符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.makefile()&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;创建与套接字相关联的文件对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;    &lt;strong&gt;数据属性&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.family&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;套接字家族&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.type&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;套接字类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;st.proto&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;套接字协议&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;strong&gt;3.3、&lt;/strong&gt; &lt;strong&gt;Tcp&lt;/strong&gt;&lt;strong&gt;服务器和客户端的通信&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　上面提到过，套接字对象都是通过socket.socket()函数来创建的，下面模拟一个TCP服务器和客户端，来实现进程间的通信。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　Tcp服务端:&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; tcp_server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)  //&lt;span&gt;创建服务器套接字
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; tcp_server.bind((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,8000))                           //&lt;span&gt;将套接字与地址绑定
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; tcp_server.listen(5)                                          //&lt;span&gt;建立监听连接
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The server has started&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     conn,addr= tcp_server.accept()                           //&lt;span&gt;接受客户端的连接
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             data = conn.recv(1024)                          //&lt;span&gt;会话的接收（或发送）
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg is&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))           //&lt;span&gt;要将收到的会话数据进行解码
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             conn.send(data.title())                      //&lt;span&gt;会话的发送（或接受）
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     conn.close()                                         //&lt;span&gt;关闭连接
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; tcp_server.close()                                      //关闭服务器套接字
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 　　在Tcp服务端，先创建服务器套接字并指定类型为流式套接字（SOCK_STREAM）。因为服务器需要占用一个端口并等待客户端的请求，所以它们必须绑定到一个本地地址。Tcp是一种面向连接的通信方式，所以必须建立监听连接，listen(5)的意义是允许传入连接的最大数为5个。当调用accept()函数后，服务端就会进入一个等待状态，默认情况下，accept()处于阻塞状态，也就意味着，执行到此处，程序会暂停，直到有新的连接到达，才会进行下一步的收发操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Tcp客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; tcp_client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)  //&lt;span&gt;创建客户端套接字
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; tcp_client.connect((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,8000))                        //&lt;span&gt;连接服务器
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     msg = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please input your message:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; msg:&lt;span&gt;continue&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     tcp_client.send(msg.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))                      //&lt;span&gt;会话接收（或发送）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     data = tcp_client.recv(1024&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reply is&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,data.decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; tcp_client.close()                                            //关闭客户端套接字
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　创建客户端比服务端要简单很多，客户端一旦拥有了套接字，就可以利用套接字的connect()方法直接创建一个服务器的连接，建立好连接，就可以参与到服务端的会话中，当客户端的需求全部完成，就会关闭套接字，终止此次连接。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.4、&lt;/strong&gt; &lt;strong&gt;Udp&lt;/strong&gt;&lt;strong&gt;服务端和客户端的通信&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Udp服务器不需要Tcp服务器那么多的配置，因为它不是面向连接的，除了等待传入的连接，它基本不需要其他的操作。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Udp服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; ip_port = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,8000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; udp_server = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) //&lt;span&gt;创建服务端套接字
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; udp_server.bind(ip_port)                                    //&lt;span&gt;绑定本地地址
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the server has started&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     data,addr = udp_server.recvfrom(1024)                 //&lt;span&gt;关闭接收（或发送）
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     udp_server.sendto(data.title(),addr)                //&lt;span&gt;关闭发送（或接受）
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     从上面代码中可以看出，除了创建套接字并绑定本地地址后，基本
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p align=&quot;left&quot;&gt;　　没有其它的操作，它是无连接的，这也就意味着，它无需为了成功通信而使一个客户端连接到一个“特定”的套接字进行转换操作，服务器端仅仅是接收数据并进行回复。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    &lt;strong&gt;   Udp客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ip_port = (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,8000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; udp_client = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)  //&lt;span&gt;创建服务端套接字
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     msg = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     udp_client.sendto(msg.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),ip_port)           //&lt;span&gt;发送
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     data,addr = udp_client.recvfrom(1024)                   //&lt;span&gt;接收
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; udp_client.close()                                        //关闭套接字
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;    Udp客户端，一旦创建了套接字，就可以进行会话循环中，当会话结束，关闭套接字。&lt;/p&gt;
&lt;p&gt;    在使用Udp进行通信的时候，服务端可以同时接收多个客户端的会话请求并返回请求结果。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 06:56:00 +0000</pubDate>
<dc:creator>无敌小怪兽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chen-Zhipeng/p/8472936.html</dc:identifier>
</item>
<item>
<title>广告等第三方应用嵌入到web页面方案 之 使用js片段 - wolfSoul</title>
<link>http://www.cnblogs.com/yuqing6/p/8467177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuqing6/p/8467177.html</guid>
<description>&lt;p&gt;&lt;span&gt;在自己的项目中嵌入过广告的朋友们可能都用过百度联盟, 只需要嵌入如下一段js代码片段, 就可以在自己的项目中嵌入广告, 来获得收益.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script type=“text javascript”&amp;gt;
   var cpro_id = “u2557752”;
&amp;lt;/script&amp;gt;
&amp;lt;script src=“http://cpro.baidustatic.com/cpro/ui/cm.js?id='i9898'” type=“text/javascript”&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　本文就是主要介绍如何通过嵌入js片段的方式来嵌入广告等第三方的应用的, 具体的实现方案有两种:&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;在服务端生成脚本:&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;　&lt;/span&gt;&lt;/span&gt;　服务端接收到请求后, 从url中提取到参数, 再根据参数从数据库中查找出对应的数据信息,比如是广告的话, 就查找到对应的广告素材, 并将查询到的数据信息插到javascript模板中,&lt;/p&gt;
&lt;p&gt;浏览器执行js脚本代码,创建出广告&lt;/p&gt;
&lt;h3&gt;直接引入静态js脚本:&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;首先js文件中提取到参数,根据参数向服务端发起请求, 获取到对应的数据, 再通过js创建html片段,输出到页面上&lt;/p&gt;
&lt;p&gt;两种方案对比: &lt;/p&gt;
&lt;p&gt;       服务端生成脚本,所有的代码和数据都包含在生成的js文件中,不需要做额外的请求,适用于内容及样式相对简单的页面.比如只有一个图片的广告展示.对于内容较多,样式较为复杂的内容展示通过第二种方案实现更加灵活.&lt;/p&gt;
&lt;p&gt;两种方案实现起来, 主要以下几步: &lt;/p&gt;
&lt;p&gt;1.获取参数 --&amp;gt; 2.获取数据 --&amp;gt; 3.输出html&lt;/p&gt;
&lt;h3&gt;1.传递参数&lt;/h3&gt;
&lt;p&gt;下面介绍一下脚本参数传递的几种方式的优缺点:&lt;/p&gt;
&lt;p&gt;　　1.通过拼接URL传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;script src=“http://cpro.baidustatic.com/cpro/ui/cm.js?cpro_id=u2557752” type=“text/javascript”&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　优点: 可通过URL传递到服务器&lt;/p&gt;
&lt;p&gt;　　缺点: 必须进行DOM查询,无法缓存&lt;/p&gt;
&lt;p&gt;　　2.通过hash传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;script src=“http://cpro.baidustatic.com/cpro/ui/cm.js#cpro_id=u2557752” type=“text/javascript”&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;优点: 使用URL,便于缓存&lt;/p&gt;
&lt;p&gt;　　缺点:  必须进行DOM查询&lt;/p&gt;
&lt;p&gt;　　3.自定义属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;script data-hxh-coupon-id=‘1234’ src=“http://cpro.baidustatic.com/cpro/ui/cm.js type=“text/javascript”&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;优点: 可读性强, 便于缓存, 易于识别脚本引入代码的位置&lt;/p&gt;
&lt;p&gt;　　缺点:  必须进行DOM查询&lt;/p&gt;
&lt;p&gt;　　4.使用全局变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;script type=“text/javascript”&amp;gt;
  var couponId = ‘87393’;
&amp;lt;/script&amp;gt;
&amp;lt;script src=“http://cpro.baidustatic.com/cpro/ui/cm.js type=“text/javascript”&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;优点: 可读性强,便于缓存,参数类型灵活,无需进行DOM查询&lt;/p&gt;
&lt;p&gt;　　缺点: 使用了全局变量&lt;/p&gt;
&lt;h3&gt;2.获取数据&lt;/h3&gt;
&lt;p&gt;关于获取数据, 服务端生成脚本, 服务端直接查询数据, 静态js脚本方案中, 可使用jsonP, Cors等方案进行跨域请求.&lt;/p&gt;
&lt;h3&gt;3.输出html&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用document.write&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　document.write直接在当前文档流中写入字符串，一旦文档流已经关闭，就打开新的文档流并写入，原来的文档流会被清空，已渲染好的页面就会被清除，浏览器将重新构建DOM并渲染页面.所以使用这种方案, 就一必须是同步执行嵌入的这段js代码, 作为第三方脚本引入,阻塞性的脚本会阻止主页面的渲染,如果js文件加载迟缓,甚至不可用的, 会给主页面造成严重的性能问题, 所有不建议使用.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt; 操作DOM添加&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　1.在目标位置嵌入js片段, 并使用预先定义的ID,class,data-*等(如上)&lt;/p&gt;
&lt;p&gt;　　2.js文件中创建DOM元素,将HTML字符串赋值给元素的innerHTML属性&lt;/p&gt;
&lt;p&gt;　　3.根据ID,calss,data-*等查询到脚本所在位置,并将元素添加到DOM中 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;script id='hxh-coupon-scandown' type=&quot;text/javascript&quot;&amp;gt;
        (function(){
                var script = document.createElement('script');
                script.async = true;
                script.src = 'http://www.boxmars.com?id=123';
                var entry = document.getElementsByTagName('script')[0];
                entry.parentNode.insertBefore(script, entry);
        })()
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　优点: &lt;/p&gt;
&lt;p&gt;　　　　1.可以异步加载第三方DOM, 不阻塞主页面的渲染,即使js出错,也不会影响到主页面&lt;/p&gt;
&lt;p&gt;　　　　2.可以将创建的DOM动态插入到已存在的元素之后(即可以追加到已知位置) &lt;/p&gt;
&lt;p&gt;　　缺点:&lt;/p&gt;
&lt;p&gt;　　　　1.使用字符串拼接不利于HTML片段的编写和维护&lt;/p&gt;
&lt;p&gt;　　　　2.会继承父页面样式&lt;/p&gt;
&lt;p&gt;　　　　3.主页面可更改DOM内容&lt;/p&gt;
&lt;p&gt;　　字符串拼接不利于编写和维护的问题,可以通过JavaScript模板引擎库来编写HTML片段, 流行模板库:HandlebarsJS,Mustache,BAIDU-Template,artTemplate等&lt;/p&gt;
&lt;p&gt;　　主页面提供一个不设置src的iframe标签,通过iframe的contentWindow访问iframe的DOM,使用document.write将HTML直接写入到iframe中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var doc = document.getElementsByTagName('iframe')[0].contentWindow.document;
doc.writeln(&quot;&amp;lt;button id=\'btn\'&amp;gt;点击&amp;lt;/button&amp;gt;&quot;);
doc.writeln(&quot;&amp;lt;script type=\'text/javascript\'&amp;gt;&quot;);
doc.writeln(&quot;var btn = document.getElementById(\'btn\');&quot;);
doc.writeln(&quot;btn.onclick = function(){&quot;);
doc.writeln(&quot;parent.parentEvent();&quot;);
doc.writeln(&quot;&amp;lt;/script&amp;gt;&quot;);
doc.close();　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　注: iframe由浏览器异步处理, 所以此处使用document.write()并不会阻止父页面的加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;优点: &lt;/p&gt;
&lt;p&gt;　　1.完全独立的DOM环境,不会继承父页面的样式&lt;/p&gt;
&lt;p&gt;　　2完全独立的window,避免和主页面其他脚本冲突&lt;/p&gt;
&lt;p&gt;　　3.可直接与主页面进行交互(与iframe引入外部页面对比)&lt;/p&gt;
&lt;p&gt;缺点: &lt;/p&gt;
&lt;p&gt;　　1. Iframe标签的创建速度慢&lt;/p&gt;
&lt;p&gt;　　2.主页面可以访问iframe的DOM环境并可进行更改&lt;/p&gt;

&lt;p&gt; 嵌入第三方页面两种方案中,另一种方案(&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/yuqing6/p/8462239.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yuqing6/p/8462239.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;) 都大篇幅介绍使用了iframe进行html输出,iframe提供了一种最佳的避免样式和脚本冲突的嵌入途径,但是有些情况在主页面的DOM中去渲染更为合适&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不适合使用iframe的情况: &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.需要在iframe外部呈现内容, 场景: 第三方应用中需要弹出对话框时,如果iframe不是覆盖整个页面的, 就无法正常展示对话框 &lt;/p&gt;
&lt;p&gt;　　2.一个页面引入很多个iframe嵌入页面, 同一个页面引入许多个iframe时, 会带来主页面很大的性能开销, 对于只是渲染一两次情况, 这种性能消耗可以忽略不计&lt;/p&gt;
&lt;p&gt;　　3.需要继承父页面的基础样式, 有些时候,希望第三方应用继承父页面的基础样式, 来和主页面的样式风格保持一致,这种情况不适用于使用iframe&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 06:48:00 +0000</pubDate>
<dc:creator>wolfSoul</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuqing6/p/8467177.html</dc:identifier>
</item>
<item>
<title>Redis进阶实践之十二 Redis的Cluster集群动态扩容 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8473135.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8473135.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、引言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    　　上一篇文章我们一步一步的教大家搭建了Redis的Cluster集群环境，形成了3个主节点和3个从节点的Cluster的环境。当然，大家可以使用 Cluster info 命令查看Cluster集群的状态，也可以使用Cluster Nodes 命令来详细了解Cluster集群每个节点的详细信息和关系。我们可以在主节点上增加数据、操作数据，也可以在从节点上读取数据，这些操作当然都没有问题。我们今天这篇文章主要是讲解一下如何在不停掉Cluster集群环境的情况下，动态的往集群环境中增加主、从节点和动态的从集群环境中删除节点。好了，废话不多说，开始我们今天的讲解。在开始之前，先要说明一下，因为redis的动态扩容操作都是通过redis-trib.rb脚本文件来完成的，所以我们先来看看对这个脚本文件的说明，效果如图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　[root@linux redis] # ruby redis-trib.rb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226135720029-1684808882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Cluster集群增加操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    　　 现在正是开始我们的操作，我把增加节点和删除节点分开来写，并且增加或者删除节点，我都分了两个方面来说，一个方面是主节点的操作，另一个方面是从节点的操作，因为主、从节点在操作上会有差异，所以分来来说。&lt;span&gt;&lt;strong&gt;增加节点的顺序是先增加Master主节点，然后在增加Slave从节点&lt;/strong&gt;&lt;/span&gt;，当然这篇文章是在上一篇文章所讲的Cluster集群模式的基础之上来讲的，那就让我们先来看看上一篇文章所建立的Cluster集群模式的详细信息。效果如图：&lt;/p&gt;&lt;p&gt;    　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226140025354-605023854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226140200203-1294145792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;    　　&lt;span&gt;&lt;strong&gt;1、动态增加Master主服务器节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;       　　 　　&lt;strong&gt;&lt;span&gt;1.1、创建目录7006（Master主节点文件夹）和7007（Slave从节点文件夹），并从以前Cluster集群节点7000-7005任一节点中拷贝配置文件redis.conf到7006和7007目录下。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        　　  　　  [root@linux redis-&lt;span&gt;cluster]# pwd
         　　 　　  [root@linux redis&lt;/span&gt;-cluster]# /root/application/program/redis-cluster/&lt;span&gt;

         　　  　　 [root@linux redis&lt;/span&gt;-cluster]# mkdir &lt;span&gt;7006&lt;/span&gt; &lt;span&gt;7007&lt;/span&gt;&lt;span&gt;

         　　  　　 [root@linux redis&lt;/span&gt;-&lt;span&gt;cluster]# ls
           　　　　 &lt;/span&gt;&lt;span&gt;7000&lt;/span&gt; &lt;span&gt;7001&lt;/span&gt; &lt;span&gt;7002&lt;/span&gt; &lt;span&gt;7003&lt;/span&gt; &lt;span&gt;7004&lt;/span&gt; &lt;span&gt;7005&lt;/span&gt; &lt;span&gt;7006&lt;/span&gt; &lt;span&gt;7007&lt;/span&gt;&lt;span&gt;

                   [root@linux redis&lt;/span&gt;-cluster]# cp &lt;span&gt;7000&lt;/span&gt;/redis.conf &lt;span&gt;7006&lt;/span&gt;&lt;span&gt;
                   [root@linux redis&lt;/span&gt;-cluster]# cp &lt;span&gt;7000&lt;/span&gt;/redis.conf &lt;span&gt;7007&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;            　　　　1、创建目录：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226140414015-1310401703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　2、拷贝配置文件：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141551095-1492814429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;         　　　1.2、修改配置文件，将7006和7007目录下面的redis.conf配置文件的端口进行相应修改，与自己的目录名称保持一致，修改项目如下：（在linux环境下可以执行如下命令进行全局替换：:%s/7000/7006/g，%s/7000/7007/g，保存并退出则可）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　 　　1.2.1、7006节点的配置文件：redis.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                　　bind &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;&lt;span&gt;

                　　port &lt;/span&gt;&lt;span&gt;7006&lt;/span&gt;&lt;span&gt;
    
                　　daemonize yes

               　　 pidfile &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/run/redis-&lt;span&gt;7006&lt;/span&gt;&lt;span&gt;.pid

                　　logfile &lt;/span&gt;/root/application/program/redis-cluster/&lt;span&gt;7006&lt;/span&gt;/&lt;span&gt;redis.log
    
                　　dir &lt;/span&gt;/root/application/program/redis-cluster/&lt;span&gt;7006&lt;/span&gt;/&lt;span&gt;

                　　cluster&lt;/span&gt;-&lt;span&gt;enabled yes

                　　cluster&lt;/span&gt;-config-file nodes-&lt;span&gt;7006&lt;/span&gt;&lt;span&gt;.conf


               　　 cluster&lt;/span&gt;-node-timeout &lt;span&gt;15000&lt;/span&gt;&lt;span&gt;

                　　appendonly yes

                　　appendfsync always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;            　　　　　　1.2.2、7007节点的配置文件：redis.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                　　bind &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;&lt;span&gt;

                　　port &lt;/span&gt;&lt;span&gt;7007&lt;/span&gt;&lt;span&gt;

                　　daemonize yes

                　　pidfile &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/run/redis-&lt;span&gt;7007&lt;/span&gt;&lt;span&gt;.pid

                　　logfile &lt;/span&gt;/root/application/program/redis-cluster/&lt;span&gt;7007&lt;/span&gt;/&lt;span&gt;redis.log
    
                　　dir &lt;/span&gt;/root/application/program/redis-cluster/&lt;span&gt;7007&lt;/span&gt;/&lt;span&gt;

                　　cluster&lt;/span&gt;-&lt;span&gt;enabled yes

                　　cluster&lt;/span&gt;-config-file nodes-&lt;span&gt;7007&lt;/span&gt;&lt;span&gt;.conf


                　　cluster&lt;/span&gt;-node-timeout &lt;span&gt;15000&lt;/span&gt;&lt;span&gt;

                　　appendonly yes

                　　appendfsync always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;        　　　1.3、启动7006和7007目录下Redis实例，并查看效果。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            　　[root@linux redis]# pwd
            　　[root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;


            　　[root@linux redis]# redis&lt;/span&gt;-server ../redis-cluster/&lt;span&gt;7006&lt;/span&gt;/&lt;span&gt;redis.conf
            　　[root@linux redis]# redis&lt;/span&gt;-server ../redis-cluster/&lt;span&gt;7007&lt;/span&gt;/redis.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;                        　　效果如图：&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226140855761-568850389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;　　　　　　&lt;br/&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226140927279-1117605475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        　　1.4、将7006主节点加入到Cluster集群。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            [root@linux redis]# pwd
            [root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            [root@linux redis]# ruby redis&lt;/span&gt;-trib.rb add-node &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7006&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;            　　　　注意：当添加新节点成功以后，新的节点不会有任何数据，因为他没有分配任何的数据Slot（哈希slots）,这一步需要手动操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;           　　 　　&lt;strong&gt;1、增加7006：&lt;/strong&gt;&lt;br/&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141128684-270483771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;　　　　　　　　2、节点增加成功。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141328543-930880100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　3、cluster info 验证：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141411077-1273465906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　4、cluster nodes验证：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141430466-581984674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        　　1.5、为7006Master主节点分配数据Slots，分配方法是从集群中知道任何一个主节点（因为只有Master主节点才有数据slots）,然后对其进行重新分片工作。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            　　[root@linux redis]# pwd
            　　[root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            　　[root@linux redis]# ruby redis&lt;/span&gt;-trib.rb reshard &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;            　　　　　　&lt;strong&gt;1、分配数据槽：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141837135-502239350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;            　　　　　　2、选择接收数据槽的节点和数据槽产生的方式：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226141919957-397703845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;            　　　　　　&lt;strong&gt;3、执行分配计划：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142059322-1526206958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            　　　　　　5、数据槽分配成功：&lt;/strong&gt;&lt;br/&gt;　　　　　　　　　　&lt;br/&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142140240-894997477.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;            &lt;/p&gt;&lt;p&gt;    　　　&lt;span&gt;&lt;strong&gt;2、动态增加Slave从服务器节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        　　　　　　在增加主节点7006的时候，前面的3步是共有的，也就是从1.1-1.3，之后才是建立主节点的内容，前面的3步骤针对从节点7007也是必须的，我只是把这些步骤写到了创建主节点7006的步骤里，大家请知晓。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        　　　　　　2.1、将7007节点增加到集群中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            　　[root@linux redis]# pwd
            　　[root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            　　[root@linux redis]# ruby redis&lt;/span&gt;-trib.rb add-node &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7007&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;            　　　　效果如图：&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142421319-1533039710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;       　　　　 　　2.2、指定7007节点作为7006的从节点，实现主从的配置。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;           　　 [root@linux redis]# pwd
           　　 [root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            　　[root@linux redis]# redis&lt;/span&gt;-cli -c -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt; -p &lt;span&gt;7007&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;登陆7007&lt;/span&gt;
           　　 &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;::&lt;span&gt;7007&lt;/span&gt;&amp;gt;&lt;span&gt;cluster replicate 71ecd970838e9b400a2a6a15cd30a94ab96203bf(主节点的ID，这里是7006)
           　　 &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;::&lt;span&gt;7007&lt;/span&gt;&amp;gt;OK
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;            　　　　　　效果如图：&lt;/p&gt;&lt;p&gt;　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142514712-1494758413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Cluster集群删除操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    　　　　由于我们在上面的步骤里面创建7006和7007两个主从的节点，下面接下来的操作，我就是从这个Cluster集群模式中动态的删除掉这两个节点。&lt;strong&gt;&lt;span&gt;删除的顺序是先删除Slave从节点，然后在删除Master主节点，&lt;/span&gt;&lt;/strong&gt;最后还原到我们上一篇文章建立的Cluster集群模式，也就是3个主节点和3个从节点。现在是4个主节点和4个从节点。效果如图：&lt;/p&gt;&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142642941-1118954714.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;&lt;strong&gt;    　　1、动态删除Slave从服务器节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;        　　　　1.1、删除7007从节点，输入del-node命令，指定删除节点的IP地址和Port端口号，同时还要提供该从节点ID名称。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            [root@linux redis]# pwd
            [root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            [root@linux redis]# ruby redis&lt;/span&gt;-trib.rb del-node &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7007&lt;/span&gt; 991ed242102aaa08873eb9404a18e0618a4e37bd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;            　　　　删除成功如图：&lt;/strong&gt;&lt;br/&gt;　　　　　　　　　　&lt;br/&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142757851-1888788507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　删除前如图：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142820071-393051350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　删除后如图：&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226142838720-1812420472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;    　　2、动态删除Master主服务器节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        　　　　要想删除Master主节点，可能要繁琐一些。因为在Master主节点上有数据槽（slots）,为了保证数据的不丢失，必须把这些数据槽迁移到其他Master主节点上，然后在删除主节点。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        　　　　　　2.1、重新分片，把要删除的Master主节点的数据槽移动到其他Master主节点上，以免数据丢失。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            　　[root@linux redis]# pwd
            　　[root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            　　[root@linux redis]# ruby redis&lt;/span&gt;-trib.rb reshard &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7006&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;            　　　　　　　　1、移除多少槽如图：创建输入200，这里要输入199，因为计数是从0开始的，切记。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143118992-1273788798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;            　　　　　　　　2、接受槽的Master主节点ID：这个节点可以是任意一个主节点都可以，我选择7002，ID是：3b025b3ecfa65f462de639c7a412be443cf1dd1c&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143216987-1993758208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　　　　　3、从哪个主节点移除，该主节点是7006，ID是：71ecd970838e9b400a2a6a15cd30a94ab96203bf&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143245200-641185490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　　　　　4、执行分区计划，选择yes。分区完成，效果如图：&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;                         　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143326009-816396604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　　　　　5、当前7006主节点已经没有数据槽了。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143356091-464903585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;        　　　　　　2.2、删除7006主节点，提供要删除节点的IP地址和Port端口，当然还有要删除的节点的ID名称。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            　　　　[root@linux redis]# pwd
            　　　　[root@linux redis]# &lt;/span&gt;/root/application/program/redis/&lt;span&gt;

            　　　　[root@linux redis]# ruby redis&lt;/span&gt;-trib.rb del-node &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.130&lt;/span&gt;:&lt;span&gt;7006&lt;/span&gt; 71ecd970838e9b400a2a6a15cd30a94ab96203bf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;            　　　　　　1、删除成功&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;                　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143532453-1732299600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;           　　　　　　 2、查看节点效果&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;               　　　　　　　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1048776/201802/1048776-20180226143551214-1016724846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    　　今天就写到这里了，做一个小小的总结。主从复制和哨兵模式这两个集群模式由于不能动态扩容，而且主节点之间（有多个主节点的情况）数据完全一样，导致了主节点的容量成了整个集群的瓶颈，如果想扩展集群容量，必须扩展主节点的容量。由于以上的问题，redis在3.0开始Cluster集群模式，这个模式在主节点之间数据是不一样的，数据也可以根据需求自动转向其他节点。这样就可以实现横向动态扩容，新增加的主从节点，用于存储新的数据则可，对以前的节点的数据不会有任何影响。再者说，配置也很简单，这才是我们所需要的集群模式。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 06:37:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8473135.html</dc:identifier>
</item>
<item>
<title>Python 3 利用 Dlib 19.7 实现摄像头人脸检测特征点标定 - TimeStamp</title>
<link>http://www.cnblogs.com/AdaminXie/p/8472743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AdaminXie/p/8472743.html</guid>
<description>&lt;p&gt;&lt;strong&gt;0.引言&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　利用python开发，借助Dlib库捕获摄像头中的人脸，进行实时特征点标定；&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1152352/201802/1152352-20180226134938010-1077521263.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;图1 工程效果示例（gif）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1152352/201802/1152352-20180226132813524-1266021399.jpg&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;884&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;图2 工程效果示例（静态图片）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　&lt;em&gt;（实现比较简单，代码量也比较少，适合入门或者兴趣学习。）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　python:　　3.6.3&lt;/p&gt;
&lt;p&gt;　　dlib:　　　 19.7&lt;/p&gt;
&lt;p&gt;　　OpenCv, numpy&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; dlib         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 人脸识别的库dlib&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; numpy as np  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据处理的库numpy&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; cv2          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 图像处理的库OpenCv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.源码介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;其实实现很简单，主要分为两个部分：&lt;strong&gt;摄像头调用+人脸特征点标定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 摄像头调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　介绍下opencv中摄像头的调用方法；&lt;/p&gt;
&lt;p&gt;　　利用 cap = cv2.VideoCapture(0) 创建一个对象；&lt;/p&gt;
&lt;p&gt;　　（具体可以参考官方文档：&lt;a title=&quot;Reading and Writing Images and Video&quot; href=&quot;https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html&quot; target=&quot;_blank&quot;&gt;https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html&lt;/a&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-2-26&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;cv2.VideoCapture(), 创建cv2摄像头对象/ open the default camera
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    Python: cv2.VideoCapture() → &amp;lt;VideoCapture object&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    Python: cv2.VideoCapture(filename) → &amp;lt;VideoCapture object&amp;gt;    
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    filename – name of the opened video file (eg. video.avi) or image sequence (eg. img_%02d.jpg, which will read samples like img_00.jpg, img_01.jpg, img_02.jpg, ...)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    Python: cv2.VideoCapture(device) → &amp;lt;VideoCapture object&amp;gt;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    device – id of the opened video capturing device (i.e. a camera index). If there is a single camera connected, just pass 0.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; cap =&lt;span&gt; cv2.VideoCapture(0)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;cv2.VideoCapture.set(propId, value)，设置视频参数;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    propId:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_POS_MSEC Current position of the video file in milliseconds.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_POS_FRAMES 0-based index of the frame to be decoded/captured next.
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_POS_AVI_RATIO Relative position of the video file: 0 - start of the film, 1 - end of the film.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_FRAME_WIDTH Width of the frames in the video stream.
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_FRAME_HEIGHT Height of the frames in the video stream.
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_FPS Frame rate.
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_FOURCC 4-character code of codec.
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_FRAME_COUNT Number of frames in the video file.
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_FORMAT Format of the Mat objects returned by retrieve() .
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_MODE Backend-specific value indicating the current capture mode.
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_BRIGHTNESS Brightness of the image (only for cameras).
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_CONTRAST Contrast of the image (only for cameras).
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_SATURATION Saturation of the image (only for cameras).
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_HUE Hue of the image (only for cameras).
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_GAIN Gain of the image (only for cameras).
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_EXPOSURE Exposure (only for cameras).
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_CONVERT_RGB Boolean flags indicating whether images should be converted to RGB.
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_WHITE_BALANCE_U The U value of the whitebalance setting (note: only supported by DC1394 v 2.x backend currently)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_WHITE_BALANCE_V The V value of the whitebalance setting (note: only supported by DC1394 v 2.x backend currently)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_RECTIFICATION Rectification flag for stereo cameras (note: only supported by DC1394 v 2.x backend currently)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_ISO_SPEED The ISO speed of the camera (note: only supported by DC1394 v 2.x backend currently)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    CV_CAP_PROP_BUFFERSIZE Amount of frames stored in internal buffer memory (note: only supported by DC1394 v 2.x backend currently)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    value: 设置的参数值/ Value of the property
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; cap.set(3, 480&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;cv2.VideoCapture.isOpened(), 检查摄像头初始化是否成功 / check if we succeeded
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;返回true或false
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;cap.isOpened()
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;cv2.VideoCapture.read([imgage]) -&amp;gt; retval,image, 读取视频 / Grabs, decodes and returns the next video frame
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;返回两个值：
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    一个是布尔值true/false，用来判断读取视频是否成功/是否到视频末尾
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    图像对象，图像的三维矩阵
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; flag, im_rd = cap.read()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2.2 人脸特征点标定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　调用预测器“shape_predictor_68_face_landmarks.dat”进行68点标定，这是dlib训练好的模型，可以直接调用进行人脸68个人脸特征点的标定；&lt;/p&gt;
&lt;p&gt;　　具体可以参考我的另一篇博客（&lt;a title=&quot;Python 3 利用 Dlib 19.7 实现人脸68个特征点的标定&quot; href=&quot;http://www.cnblogs.com/AdaminXie/p/8137580.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie/p/8137580.html&lt;/a&gt;）；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.3 源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;实现的方法比较简单：&lt;/p&gt;
&lt;p&gt;　　　　利用 cv2.VideoCapture() 创建摄像头对象，然后利用 flag, im_rd = cv2.VideoCapture.read() 读取摄像头视频，im_rd就是视频中的一帧帧图像；&lt;/p&gt;
&lt;p&gt;　　　　然后就类似于单张图像进行人脸检测，对这一帧帧的图像im_rd利用dlib进行特征点标定，然后绘制特征点；&lt;/p&gt;
&lt;p&gt;　　　　你可以按下s键来获取当前截图，或者按下q键来退出摄像头；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;102&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2018-2-26&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; By TimeStamp&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cnblogs: http://www.cnblogs.com/AdaminXie&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; github: https://github.com/coneypo/Dlib_face_detection_from_camera&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; dlib                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;人脸识别的库dlib&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; numpy as np              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据处理的库numpy&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; cv2                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;图像处理的库OpenCv&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dlib预测器&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; detector =&lt;span&gt; dlib.get_frontal_face_detector()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; predictor = dlib.shape_predictor(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shape_predictor_68_face_landmarks.dat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建cv2摄像头对象&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; cap =&lt;span&gt; cv2.VideoCapture(0)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.set(propId, value)&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置视频参数，propId设置的视频参数，value设置的参数值&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; cap.set(3, 480&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 截图screenshoot的计数器&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; cnt =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.isOpened（） 返回true/false 检查初始化是否成功&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(cap.isOpened()):
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; cap.read()&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回两个值：&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    一个布尔值true/false，用来判断读取视频是否成功/是否到视频末尾&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    图像对象，图像的三维矩阵&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     flag, im_rd =&lt;span&gt; cap.read()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每帧数据延时1ms，延时为0读取的是静态帧&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     k = cv2.waitKey(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取灰度&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     img_gray =&lt;span&gt; cv2.cvtColor(im_rd, cv2.COLOR_RGB2GRAY)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 人脸数rects&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     rects =&lt;span&gt; detector(img_gray, 0)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(len(rects))&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 待会要写的字体&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     font =&lt;span&gt; cv2.FONT_HERSHEY_SIMPLEX
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标68个点&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(len(rects)!=&lt;span&gt;0):
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测到人脸&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(rects)):
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             landmarks = np.matrix([[p.x, p.y] &lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; predictor(im_rd, rects[i]).parts()])
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; idx, point &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(landmarks):
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 68点的坐标&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;                 pos = (point[0, 0], point[0, 1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用cv2.circle给每个特征点画一个圈，共68个&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;                 cv2.circle(im_rd, pos, 2, color=(0, 255&lt;span&gt;, 0))
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 利用cv2.putText输出1-68&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;                 cv2.putText(im_rd, str(idx + 1), pos, font, 0.2, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         cv2.putText(im_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;faces: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+str(len(rects)), (20,50), font, 1, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有检测到人脸&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         cv2.putText(im_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no face&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (20, 50), font, 1, (0, 0, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加说明&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;     im_rd = cv2.putText(im_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s: screenshot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (20, 400), font, 0.8, (255, 255, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     im_rd = cv2.putText(im_rd, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;q: quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (20, 450), font, 0.8, (255, 255, 255), 1&lt;span&gt;, cv2.LINE_AA)
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按下s键保存&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (k == ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)):
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         cnt+=1
&lt;span&gt;74&lt;/span&gt;         cv2.imwrite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;screenshoot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+str(cnt)+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, im_rd)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按下q键退出&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(k==ord(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)):
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 窗口显示&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;     cv2.imshow(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;camera&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, im_rd)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放摄像头&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;cap.release()
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; 
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除建立的窗口&lt;/span&gt;
&lt;span&gt;87&lt;/span&gt; cv2.destroyAllWindows()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;# 请尊重他人劳动成果，转载或者使用源码请注明出处：&lt;/strong&gt;&lt;a title=&quot;xie&quot; href=&quot;http://www.cnblogs.com/AdaminXie/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/AdaminXie&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;# 如果对您有帮助，欢迎在GitHub上star本项目: &lt;a title=&quot;Dlib_face_detection_from_camera&quot; href=&quot;https://github.com/coneypo/Dlib_face_detection_from_camera&quot; target=&quot;_blank&quot;&gt;https://github.com/coneypo/Dlib_face_detection_from_camera&lt;/a&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Feb 2018 05:36:00 +0000</pubDate>
<dc:creator>TimeStamp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AdaminXie/p/8472743.html</dc:identifier>
</item>
<item>
<title>应用负载均衡之LVS(三)：使用ipvsadm以及详细分析VS/DR模式 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8472744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8472744.html</guid>
<description>&lt;p&gt;&lt;strong&gt;LVS系列文章：&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html#lb&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog1&quot;&gt;&lt;span&gt;1. 使用ipvsadm&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog1.1&quot;&gt;&lt;span&gt;1.1 安装ipvsadm&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog1.2&quot;&gt;&lt;span&gt;1.2 ipvsadm语法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog2&quot;&gt;&lt;span&gt;2.实现VS/NAT模式的负载均衡&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog3&quot;&gt;&lt;span&gt;3 VS/DR模式的数据包流向分析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog4&quot;&gt;&lt;span&gt;4.实现VS/DR模式的负载均衡(CIP、VIP、RIP同网段)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog5&quot;&gt;&lt;span&gt;5.实现VS/DR模式的负载均衡(CIP、VIP、RIP不同网段)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog5.1&quot;&gt;&lt;span&gt;5.1 CIP、RIP不同网段时为何特殊？&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog5.2&quot;&gt;&lt;span&gt;5.2 反向路径过滤rp_filter参数的作用&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html#blog5.3&quot;&gt;&lt;span&gt;5.3 实现VS/DR模式的负载均衡(CIP、RIP不同网段)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-ipvsadm&quot;&gt;1.使用ipvsadm&lt;/h2&gt;
&lt;p&gt;ipvsadm是ipvs的命令行管理工具，可以定义、删除、查看virtual service和Real Server的属性。&lt;/p&gt;

&lt;h3 id=&quot;1-1-ipvsadm&quot;&gt;1.1 安装ipvsadm&lt;/h3&gt;
&lt;p&gt;可以直接yum安装。以下是编译安装ipvsadm的过程，对于内核版本2.6.xx，需要安装的ipvsadm版本要大于1.24。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;
&lt;span class=&quot;hljs-title&quot;&gt;wget&lt;/span&gt; &lt;span class=&quot;hljs-url&quot;&gt;http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz&lt;/span&gt; -P /tmp
cd /tmp

yum -y install libnl* popt*

tar xf ipvsadm-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;.tar.gz 
cd ipvsadm-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;26&lt;/span&gt;
make &amp;amp;&amp;amp; make install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译安装完之后，会在/etc/init.d/ (CentOS6)或/usr/lib/systemd/system/ (CentOS7)目录下自动生成ipvsadm服务管理脚本，这和一般的编译不一样，比较人性化。&lt;/p&gt;
&lt;p&gt;安装ipvsadm后，生成以下文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@xuexi ~]# rpm -ql ipvsadm
/etc/sysconfig/ipvsadm-config
/usr/lib/systemd/system/ipvsadm.service
/usr/sbin/ipvsadm            # ipvs规则管理工具
/usr/sbin/ipvsadm-&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;restore&lt;/span&gt;    # ipvs规则恢复工具
/usr/sbin/ipvsadm-save       # ipvs规则保存工具
/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;share&lt;/span&gt;/doc/ipvsadm-&lt;span class=&quot;hljs-number&quot;&gt;1.27&lt;/span&gt;
/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;share&lt;/span&gt;/doc/ipvsadm-&lt;span class=&quot;hljs-number&quot;&gt;1.27&lt;/span&gt;/README
/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;share&lt;/span&gt;/man/man8/ipvsadm-&lt;span class=&quot;hljs-keyword&quot;&gt;restore&lt;/span&gt;.8.gz
/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;share&lt;/span&gt;/man/man8/ipvsadm-save.8.gz
/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;share&lt;/span&gt;/man/man8/ipvsadm.8.gz&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;1-2-ipvsadm-&quot;&gt;1.2 ipvsadm语法&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;ipvsadm --help&lt;/code&gt;可以查看使用方法。ipvs的更多功能以及ipvsadm的更详细用法，请&lt;code&gt;man ipvsadm&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;ipvsadm的选项中，大写选项管理虚拟服务virtual service，小写选项管理关联了虚拟服务的真实服务器RealServer，&lt;span class=&quot;hljs-string&quot;&gt;&quot;-L&quot;&lt;/span&gt;和&lt;span class=&quot;hljs-string&quot;&gt;&quot;-l&quot;&lt;/span&gt;除外，它们同义。

(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;).管理virtual services：
    添加：-A  -t|u|f service-address [&lt;span class=&quot;hljs-operator&quot;&gt;-s&lt;/span&gt; scheduler]
            -t：tcp协议的集群
            -u：udp协议的集群
                service-address格式为IP:PORT
            &lt;span class=&quot;hljs-operator&quot;&gt;-f&lt;/span&gt;：firewall-mark防火墙标记
                service-address：a num &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; mark
            &lt;span class=&quot;hljs-operator&quot;&gt;-s&lt;/span&gt;：调度算法
    修改：-E -t|u|f service-address [&lt;span class=&quot;hljs-operator&quot;&gt;-s&lt;/span&gt; scheduler]     和-A使用方法一样
    删除：-D -t|u|f service-address
示例：


(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;).管理virtual service中的RealServer：
    添加：&lt;span class=&quot;hljs-operator&quot;&gt;-a&lt;/span&gt;  -t|u|f service-address -r server-address [-g|i|m] [-w weight]
        -t|u|f service-address：指定Real server所绑定的virtual service
        -r server-address：某RS地址，在NAT模型中，可IP:PORT实现端口映射，即端口无需等于VIP对应的port
        -g|i|m：指定lvs的类型，有三种:
            -g：gataway即DR类型（默认的模型）
            -i：--ipip，即TUN类型
            -m：masquerade地址伪装即NAT
        -w：指定权重（需要调度算法支持权重）
    修改：&lt;span class=&quot;hljs-operator&quot;&gt;-e&lt;/span&gt;和&lt;span class=&quot;hljs-operator&quot;&gt;-a&lt;/span&gt;用法一样
    删除：&lt;span class=&quot;hljs-operator&quot;&gt;-d&lt;/span&gt;  -t|u|f service-address -r server-address表示从哪个virtual service中删除哪个realserver
示例：



(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;).查看：  
    -L或者&lt;span class=&quot;hljs-operator&quot;&gt;-l&lt;/span&gt;:列出状态信息，配合以下选项用于显示更精确数据
        -n:只显示数字格式，不反解IP地址和端口
        --stats：显示统计信息
        --rate：显示速率信息（每秒的值）
        --timeout：显示tcp/tcpfin/udp的会话超时时间长度
        --daemon：显示进程状态和多播端口（不太用）
        --sort：对-n列出来的进行排序（按协议、IP、端口号升序排序）
        -c：显示当前ipvs的连接状况（不能和stats选项同用）

(&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;).其他项：
-Z：清空统计数据
-C：删除一个或所有virtual service，连同与之绑定的real server也删除
-S：保存规则  ipvsadm -S &amp;gt; /path/to/somefile 或者使用ipvsadm-save &amp;gt; /path/to/somefile
-R：载入规则  ipvsadm -R &amp;lt; /path/to/somefile 或者使用ipvsadm-restore &amp;lt; /path/to/somefile
    service ipvsadm save
    service ipvsadm restore
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;2-vs-nat-&quot;&gt;2.实现VS/NAT模式的负载均衡&lt;/h2&gt;
&lt;p&gt;实验环境如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201802/733013-20180220221318819-1488159260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;br/&gt;CIP:172.16.10.22&lt;br/&gt;VIP:172.16.10.21&lt;br/&gt;DIP:192.168.100.17&lt;br/&gt;RIP1:192.168.100.39&lt;br/&gt;RIP2:192.168.100.23&lt;/p&gt;
&lt;p&gt;在开始操作前，先回顾下VS/NAT模式的相关内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;请求过程：CIP--&amp;gt;VIP--ip_forward--&amp;gt;DIP--&amp;gt;RIP
响应过程：RIP--&amp;gt;DIP--ip_forward--&amp;gt;VIP--&amp;gt;CIP
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于director接收到CIP发送的数据包后，需要转发给Real Server进行处理，但Real Server的RIP和DIP是同一网段的，因此Director必须将VIP接口上收到的数据包转发给DIP，也就是说&lt;span&gt;&lt;strong&gt;Director需要开启ip_forward功能&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当RS处理完成后，响应数据需要先转发给Director，但因为&lt;span&gt;&lt;strong&gt;响应数据的目标地址为CIP，因此需要将RS的网关指向Director的DIP&lt;/strong&gt;&lt;/span&gt;，这样CIP目的的数据包才能保证交给director进行处理并返回给客户端。&lt;/p&gt;
&lt;p&gt;因此，如下操作Director：假设该实验中的VS/NAT采用wrr调度算法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/ip_forward
ipvsadm -A -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -s wrr
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.39&lt;/span&gt; -m -w &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.23&lt;/span&gt; -m -w &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下操作各RS：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;yum -y &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;install&lt;/span&gt; httpd
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS1:192.168.100.39&quot;&lt;/span&gt; &amp;gt;/&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/www/html/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html  # 在RS1上操作
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS2:192.168.100.23&quot;&lt;/span&gt; &amp;gt;/&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/www/html/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.html  # 在RS2上操作
service httpd &lt;span class=&quot;hljs-keyword&quot;&gt;start&lt;/span&gt;
route &lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; gw &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.17&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在客户端Win2003上的浏览器上输入&lt;code&gt;http://172.16.10.21&lt;/code&gt;进行测试，同时测试调度算法的比例。可以使用下面的命令查看统计数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-constant&quot;&gt;IP&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Virtual&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Server&lt;/span&gt; version &lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (size=&lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt;)
&lt;span class=&quot;hljs-constant&quot;&gt;Prot&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;LocalAddress&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:Port&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Scheduler&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Flags&lt;/span&gt;
  -&amp;gt; &lt;span class=&quot;hljs-constant&quot;&gt;RemoteAddress&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:Port&lt;/span&gt;           &lt;span class=&quot;hljs-constant&quot;&gt;Forward&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Weight&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;ActiveConn&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;InActConn&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;TCP&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;172.16&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;10.21&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; wrr
  -&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.23&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;            &lt;span class=&quot;hljs-constant&quot;&gt;Masq&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   
  -&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;            &lt;span class=&quot;hljs-constant&quot;&gt;Masq&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;   

[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
&lt;span class=&quot;hljs-constant&quot;&gt;IP&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Virtual&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;Server&lt;/span&gt; version &lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (size=&lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt;)
&lt;span class=&quot;hljs-constant&quot;&gt;Prot&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;LocalAddress&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:Port&lt;/span&gt;               &lt;span class=&quot;hljs-constant&quot;&gt;Conns&lt;/span&gt;   &lt;span class=&quot;hljs-constant&quot;&gt;InPkts&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;OutPkts&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;InBytes&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;OutBytes&lt;/span&gt;
  -&amp;gt; &lt;span class=&quot;hljs-constant&quot;&gt;RemoteAddress&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:Port&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;TCP&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;172.16&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;10.21&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;                    &lt;span class=&quot;hljs-number&quot;&gt;25&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;113&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;95&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;10293&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;8913&lt;/span&gt;
  -&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.23&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;                  &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;67&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;55&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;6059&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;4921&lt;/span&gt;
  -&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;                  &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;40&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;4234&lt;/span&gt;     &lt;span class=&quot;hljs-number&quot;&gt;3992&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意点：&lt;br/&gt;(1).建议不要使用win7/win8/win10作为客户端进行测试，而是使用win server类系统或直接使用unix系统测试。&lt;br/&gt;(2).调度算法是&lt;span&gt;&lt;strong&gt;对连接进行调度&lt;/strong&gt;&lt;/span&gt;，而不是对数据包、字节等调度，因此查看统计数据时，应该比较的是Conns列的比例。另外，如果连接数大致满足比例，但数据包或者字节数却远不符合比例(高的多或低的多)，那么可能对应的那台RS主机性能比其它RS的性能要好或差。&lt;/p&gt;
&lt;p&gt;实验完成后，删除Director上的virtual service，并重新设置RS上的默认路由。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;ipvsadm&lt;/span&gt; -C
route del default gw &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.17&lt;/span&gt;   
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;3-vs-dr-&quot;&gt;3.VS/DR模式的数据包流向分析&lt;/h2&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201802/733013-20180226082129108-1055097851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在分析数据包流向前，需要厘清一个容易产生疑惑的要点：&lt;strong&gt;&lt;span&gt;在VS/DR模式下，TCP连接是客户端和RS之间建立的，Director只是负责改造、转发建立TCP连接时的数据包给后端RealServer；当TCP连接建立完成后，就有了客户端和服务端(RS)的概念，这时客户端将直接和RS进行数据通信，而Director已经退出舞台，不再负责改造、转发请求数据包。也就是说，Director改造、转发的数据包只有客户端第一次发送的syn包，其它数据包和它无关&lt;/span&gt;。&lt;/strong&gt;可以想象，这样的Director相比NAT模式，性能高的不是一点点。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).当客户端发起&lt;code&gt;http://VIP&lt;/code&gt;的请求时，数据包的源和目标地址为&lt;code&gt;CIP--&amp;gt;VIP&lt;/code&gt;。这个数据包最终会到达Director。&lt;/li&gt;
&lt;li&gt;(2).当Director收到请求数据包后，将根据调度算法选择一台后端RealServer作为调度的目标。于是修改数据包的目标MAC地址为该RealServer的RIP所在MAC地址。数据包将转发给该RS，此时数据包的源和目标IP地址仍然为&lt;code&gt;CIP--&amp;gt;VIP&lt;/code&gt;，但源和目标MAC地址为&lt;code&gt;DIP_MAC--&amp;gt;RIP_MAC&lt;/code&gt;。
&lt;ul&gt;&lt;li&gt;需要注意的是，Director要将数据包交给RS，需要从VIP接口转发给DIP接口，因此Director需要开启ip_forward功能。但如果VIP和DIP/RIP处于同一个网段，则无需开启该转发功能，因为VIP接口可以直接和RIP接口通信，这时DIP没有存在的必要。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;(3).被调度到的RS收到Director转发的数据包后，发现目标IP地址已经配置在自身内核，因此会收下该数据包。之后会处理请求，并构建响应数据。&lt;/li&gt;
&lt;li&gt;(4).RS将响应数据响应给客户端，该响应数据包的源和目标IP地址为&lt;code&gt;VIP--&amp;gt;CIP&lt;/code&gt;。
&lt;ul&gt;&lt;li&gt;由于RS上的VIP一般配置在lo的别名接口上，它无法和外界直接通信，因此数据包最终会从普通网卡上流出，如RIP所在接口。根据TCP/IP协议，响应数据包的源MAC地址也将是普通网卡(如RIP所在接口)的MAC地址。这一细节在后面配置CIP、VIP、RIP不同网段时会引出一种特殊问题，详情见后文。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-vs-dr-cip-vip-rip-&quot;&gt;4.实现VS/DR模式的负载均衡(CIP、VIP、RIP同网段)&lt;/h2&gt;
&lt;p&gt;CIP、VIP和RIP同网段时，配置非常简单，几乎无需考虑额外的路由问题，也都无需分析数据包流向问题。&lt;/p&gt;
&lt;p&gt;实验环境如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201802/733013-20180226091405492-313584435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;br/&gt;CIP:192.168.100.46&lt;br/&gt;VIP:192.168.100.11&lt;br/&gt;DIP:192.168.100.17(由于VIP和RIP同网段，因此它是多余的)&lt;br/&gt;RIP1:192.168.100.47&lt;br/&gt;RIP2:192.168.100.23&lt;/p&gt;
&lt;p&gt;配置过程：&lt;br/&gt;&lt;strong&gt;如下操作各RS：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;
yum -y install httpd
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS1:192.168.100.47&quot;&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/var/www&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/html/index&lt;/span&gt;.html  
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS2:192.168.100.23&quot;&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/var/www&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/html/index&lt;/span&gt;.html  
service httpd start


echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/all/arp_ignore
echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/all/arp_announce


ifconfig &lt;span class=&quot;hljs-symbol&quot;&gt;lo:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.11&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt; up
route add -host &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.11&lt;/span&gt; dev &lt;span class=&quot;hljs-symbol&quot;&gt;lo:&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如下操作Director：由于VIP和RIP同网段，因此无需开启ip_forward&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;ipvsadm&lt;/span&gt; -C
ipvsadm -A -t &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.11:80&lt;/span&gt; -s wrr
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.11:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.47:80&lt;/span&gt; -g -w &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.11:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.23:80&lt;/span&gt; -g -w &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试时，建议不要使用win7/win8/win10作为客户端，而是使用win server类系统或直接使用unix系统测试。&lt;/p&gt;

&lt;h2 id=&quot;5-vs-dr-cip-vip-rip-&quot;&gt;5.实现VS/DR模式的负载均衡(CIP、VIP、RIP不同网段)&lt;/h2&gt;

&lt;h3 id=&quot;5-1-cip-rip-&quot;&gt;5.1 CIP、RIP不同网段时为何特殊？&lt;/h3&gt;
&lt;p&gt;考虑实际的生产环境，由于公网地址有限，一般只给web server的负载均衡系统分配一个公网地址。这个公网地址可能直接分配给VIP，这样CIP、VIP、RIP两两都处于不同网段；还可能分配给路由器或防火墙，然后VIP和RIP都是用私网地址，这样VIP/RIP同网段，但它们和CIP不同网段。&lt;/p&gt;
&lt;p&gt;不管公网地址分配给谁，CIP、RIP总是不同网段的。这时需要考虑以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RS将响应数据响应给客户端，该响应数据包的源和目标IP地址为&lt;code&gt;VIP--&amp;gt;CIP&lt;/code&gt;，但因为是从RIP所在网卡流出的，这个响应数据包的源MAC地址为MAC_RIP；&lt;/li&gt;
&lt;li&gt;由于RIP和CIP不同网段，因此RS需要借助某个路由设备来转发这个数据包；&lt;/li&gt;
&lt;li&gt;由于RS上的VIP被隐藏，DIP/RIP所在网段的所有主机(包括这个路由设备)上缓存的关于VIP的arp记录都是Director上的(即&lt;code&gt;VIP&amp;lt;--&amp;gt;MAC_V&lt;/code&gt;)，即使重新发起arp请求，也只能获取到这样的对应关系。因此，响应数据包的源IP、源MAC的对应关系和路由设备arp缓存中记录不一致，这个响应数据包是&quot;非法&quot;数据包。就像同宿舍的人都知道你和你的身份证号码，但如果有一个人拿着你的身份证去找你的舍友办事，他肯定知道这个人是冒充的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;这个路由设备发现数据包的源MAC地址、源IP和它arp缓存中的记录不一致，它会丢弃这个数据包吗？&lt;/span&gt;&lt;/strong&gt;分三种情况：
&lt;ul&gt;&lt;li&gt;(1).如果这个数据包的目标IP就是自身的，它会收下这个数据包并处理。当RIP和Client的某个网卡同网段时，就是这种情况，此时Client就是最终的路由目标。&lt;/li&gt;
&lt;li&gt;(2).如果这个数据包被路由到普通的路由设备上，路由设备默认会将这个数据包丢弃，因为会检查源地址。这称为&quot;reverse path filter&quot;(反向路径过滤)功能。Linux上控制该功能的参数为rp_filter。&lt;/li&gt;
&lt;li&gt;(3).如果这个数据包被路由到Director所在主机(Linux)上，默认会丢弃这个数据包，因为源IP地址正好在本机上。但可以为内核打上forward_shared补丁，以便使用forward_shared和rp_filter参数来开启转发源IP地址为自身地址数据包的功能。转发时，需要设置转发接口为VIP所在接口，这样数据包的源MAC地址和VIP相互对应，之后的路由过程会一路顺畅。&lt;br/&gt;根据第四点的三种情况，RS上的路由表可以按需设置成三种情况。当然，第一种情况在实际环境中是不可能的。第二种情况设置很简单，但路由设备关闭源IP地址检查功能后，将更容易受到DDos攻击。第三种情况可以忽略，不仅要重新编译内核，更重要的是VS/DR模式的优点本就在于让Director专注于调度工作来实现高性能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，本文将以第二种情况来做实验测试。第三种情况可参考网上一篇博文：&lt;span&gt;&lt;a href=&quot;http://blog.itpub.net/124805/viewspace-1047686/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;LVS-DR VIP和RIP不同网段的配置方法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;h3 id=&quot;5-2-rp_filter-&quot;&gt;5.2 反向路径过滤rp_filter参数的作用&lt;/h3&gt;
&lt;p&gt;以下是&lt;span&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Linux内核文档&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中关于rp_filter变量的描述：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rp_filter - INTEGER
    0 - No source validation.
    1 - Strict mode as defined in RFC3704 Strict Reverse Path
        Each incoming packet is tested against the FIB and if the interface
        is not the best reverse path the packet &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt; will fail.
        &lt;span class=&quot;hljs-keyword&quot;&gt;By&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; failed packets &lt;span class=&quot;hljs-keyword&quot;&gt;are&lt;/span&gt; discarded.
    &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; - Loose &lt;span class=&quot;hljs-keyword&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; defined &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; RFC3704 Loose &lt;span class=&quot;hljs-keyword&quot;&gt;Reverse&lt;/span&gt; Path
        &lt;span class=&quot;hljs-keyword&quot;&gt;Each&lt;/span&gt; incoming packet&lt;span class=&quot;hljs-string&quot;&gt;'s source address is also tested against the FIB
        and if the source address is not reachable via any interface
        the packet check will fail.

    Current recommended practice in RFC3704 is to enable strict mode
    to prevent IP spoofing from DDos attacks. If using asymmetric routing
    or other complicated routing, then loose mode is recommended.

    The max value from conf/{all,interface}/rp_filter is used
    when doing source validation on the {interface}.

    Default value is 0. Note that some distributions enable it
    in startup scripts.&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大致说明下：rp_filter参数有三个值，0、1、2，Linux上默认为1。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0：不开启源地址校验。&lt;/li&gt;
&lt;li&gt;1：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。&lt;/li&gt;
&lt;li&gt;2：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不通，则直接丢弃该数据包。这个值是只是为了防止转发无效或冒充的源IP地址，如192.16.10这样的不完整IP。&lt;/li&gt;
&lt;li&gt;取/proc/sys/net/ipv4/conf/{all,interface}/rp_filter中的最大值生效。注意，对lo接口设置该参数是无意义的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于CIP、RIP不同网段的VS/DR模式来说，当RS将响应数据包(ack+syn)交给Linux路由设备，数据包源IP是VIP，源MAC地址是RIP_MAC。Linux充当路由设备时：&lt;/p&gt;
&lt;p&gt;如果设置rp_filter=1(默认)，会反向检查源IP是否是最佳路径。显然，由于Router上只能获取到Director上的&lt;code&gt;VIP&amp;lt;--&amp;gt;MAC_VIP&lt;/code&gt;arp缓存记录，因此反向检查时总是查找到Director上去，但这不是到RIP_MAC的路径，因此丢弃该数据包。&lt;/p&gt;
&lt;p&gt;如果设置rp_filter=2，由于Router反向检查时能和VIP能互相通信(尽管是和Director上的VIP通信)，因此数据包保留。&lt;/p&gt;
&lt;p&gt;如果设置rp_filter=0，则完全不检查源地址，直接转发。&lt;/p&gt;
&lt;p&gt;一般情况下，保持默认值比较安全，这样可以防止DDos攻击。如果有修改该参数的需要，则应该将其设置为2。无可奈何的情况下才设置为0。&lt;/p&gt;

&lt;h3 id=&quot;5-3-vs-dr-cip-vip-&quot;&gt;5.3 实现VS/DR模式的负载均衡(CIP、VIP不同网段)&lt;/h3&gt;
&lt;p&gt;实验环境如下：之所以&lt;code&gt;Client--&amp;gt;Router--&amp;gt;Director&lt;/code&gt;给出了虚线，是因为这里CIP和VIP同网段，它会直接和Director通信，而不会经过Router，但这并不影响结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201802/733013-20180226123853097-772043133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了测试的便利性，将Director自身也设置为一个RS，其RIP设置为127.0.0.1。&lt;/p&gt;
&lt;p&gt;因此：&lt;br/&gt;CIP:172.16.10.22&lt;br/&gt;Route IP1:172.16.10.23&lt;br/&gt;Route IP2:192.168.100.32&lt;br/&gt;VIP:172.16.10.21&lt;br/&gt;DIP:192.168.100.17&lt;br/&gt;RIP1:192.168.100.47&lt;br/&gt;RIP2:192.168.100.23&lt;br/&gt;RIP3:127.0.0.1(在Director上的RIP)&lt;/p&gt;
&lt;p&gt;配置过程：&lt;br/&gt;&lt;strong&gt;如下操作各RS：不包括Director上的本地RS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;
yum -y install httpd
&lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS1:192.168.100.47&quot;&lt;/span&gt; &amp;gt;/&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/www/html/index.html  
&lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS2:192.168.100.23&quot;&lt;/span&gt; &amp;gt;/&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/www/html/index.html  
service httpd start


&lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_ignore
&lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/all/arp_announce


ifconfig lo:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;172.16&lt;/span&gt;.10.21/&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt; up
route add -host &lt;span class=&quot;hljs-number&quot;&gt;172.16&lt;/span&gt;.10.21 dev lo:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;


route del &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;
route add &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; gw &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.32
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如下操作Router：开启转发功能，但暂时不设置rp_filter，以查看实验结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/ip_forward
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后如下操作Director：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/ip_forward
ipvsadm -C
ipvsadm -A -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -s wrr
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.47:80&lt;/span&gt; -g -w &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.23:80&lt;/span&gt; -g -w &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
ipvsadm -a -t &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.21:80&lt;/span&gt; -r &lt;span class=&quot;hljs-number&quot;&gt;127.0.0.1:80&lt;/span&gt; -g -w &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;


yum -y install httpd
echo &lt;span class=&quot;hljs-string&quot;&gt;&quot;from RS3:127.0.0.1&quot;&lt;/span&gt; &amp;gt;/var/www/html/index.html
service httpd start


route add -host &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.22&lt;/span&gt; gw &lt;span class=&quot;hljs-number&quot;&gt;172.16.10.23&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试时，只有当调度到RS3时，才能得到正确的响应结果，而调度器调度到RS1和RS2时，将无法得到正确的响应。实际上是客户端和RS1、RS2无法建立TCP连接。&lt;/p&gt;
&lt;p&gt;查看Director上的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[root@xuexi ~]&lt;/span&gt;# &lt;span class=&quot;hljs-tag&quot;&gt;ipvsadm&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;-ln&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;-c&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;IPVS&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;connection&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;entries&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;pro&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;expire&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;state&lt;/span&gt;       &lt;span class=&quot;hljs-tag&quot;&gt;source&lt;/span&gt;             &lt;span class=&quot;hljs-tag&quot;&gt;virtual&lt;/span&gt;            &lt;span class=&quot;hljs-tag&quot;&gt;destination&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;TCP&lt;/span&gt; 14&lt;span class=&quot;hljs-pseudo&quot;&gt;:58&lt;/span&gt;  &lt;span class=&quot;hljs-tag&quot;&gt;ESTABLISHED&lt;/span&gt; 172&lt;span class=&quot;hljs-class&quot;&gt;.16&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.22&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:1683&lt;/span&gt;  172&lt;span class=&quot;hljs-class&quot;&gt;.16&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.21&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:80&lt;/span&gt;    127&lt;span class=&quot;hljs-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:80&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;TCP&lt;/span&gt; 00&lt;span class=&quot;hljs-pseudo&quot;&gt;:57&lt;/span&gt;  &lt;span class=&quot;hljs-tag&quot;&gt;SYN_RECV&lt;/span&gt;    172&lt;span class=&quot;hljs-class&quot;&gt;.16&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.22&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:1679&lt;/span&gt;  172&lt;span class=&quot;hljs-class&quot;&gt;.16&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.21&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:80&lt;/span&gt;    192&lt;span class=&quot;hljs-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.23&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:80&lt;/span&gt;
&lt;span class=&quot;hljs-tag&quot;&gt;TCP&lt;/span&gt; 00&lt;span class=&quot;hljs-pseudo&quot;&gt;:55&lt;/span&gt;  &lt;span class=&quot;hljs-tag&quot;&gt;SYN_RECV&lt;/span&gt;    172&lt;span class=&quot;hljs-class&quot;&gt;.16&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.22&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:1681&lt;/span&gt;  172&lt;span class=&quot;hljs-class&quot;&gt;.16&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.10&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.21&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:80&lt;/span&gt;    192&lt;span class=&quot;hljs-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.47&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:80&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，这里显示的状态是RS上的TCP连接状态，不是Director的。SYN_RECV表示RS1/RS2发送的syn+ack得不到客户端的回应。如果在Router和Client机器上抓包分析的话，会发现syn+ack数据包到Router上就断了，Client根本就没收到syn+ack。&lt;/p&gt;
&lt;p&gt;正如前面的分析，只有调度到RS3时，响应数据包的源MAC地址、源IP地址和Router上的arp缓存记录是对应的。默认rp_filter=1反向检查时，这正好是最佳路径。而调度到RS1和RS2时，Router反向检查时由于只能检查到Director上的VIP，因此数据包会被丢弃。&lt;/p&gt;
&lt;p&gt;现在，将Router上和RS通信的接口rp_filter设置为2。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/eth&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;/rp_filter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再测试时，发现无论是RS1、RS2、RS3都能正确响应结果。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8472744.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8472744.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 05:36:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8472744.html</dc:identifier>
</item>
<item>
<title>彻底理解 Android 中的阴影 - 承香墨影</title>
<link>http://www.cnblogs.com/plokmju/p/8472683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/plokmju/p/8472683.html</guid>
<description>&lt;p&gt;如果我们想创造更好的 Android App，我相信我们需要遵循 Material Design 的设计规范。一般而言，Material Design 是一个包含光线，材质和投影的三维环境。如果我们想要在 App 的开发过程中，跟随 Material Design 的设计原则，那么理解 光 与 阴影 就显得尤为重要了。&lt;/p&gt;
&lt;p&gt;我将尝试解释本文中的以下主题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Android 中的 3D&lt;/li&gt;
&lt;li&gt;深度（Depth）&lt;/li&gt;
&lt;li&gt;Z 轴，Elevation 和 Translation Z。&lt;/li&gt;
&lt;li&gt;光源&lt;/li&gt;
&lt;li&gt;按钮状态（按下和静止）&lt;/li&gt;
&lt;li&gt;Outline&lt;/li&gt;
&lt;li&gt;自定义的 ViewOutlineProvider&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在深入到阴影和光线之前，我想告诉你我们的真实环境什么？&lt;/p&gt;
&lt;h2 id=&quot;什么是-3d&quot;&gt;什么是 3D？&lt;/h2&gt;
&lt;p&gt;真实的物质环境，是一个三维空间，这意味着所有的物体对象都有 X、Y 和 Z 维度。Z轴与显示器的平面垂直对齐，正 Z 轴朝向观察者延伸。在 Material Design 的世界里，每个物体都有 1dp 的厚度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b04432fb8e?w=800&amp;amp;h=505&amp;amp;f=jpeg&amp;amp;s=16233&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;android-的-depth&quot;&gt;Android 的 &lt;strong&gt;Depth&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Material Design 不同于其他的设计指南，因为它增加了 Depth（深度）的概念。而 Depth 在真实的视觉中，有重要的意义。&lt;/p&gt;
&lt;p&gt;我们可以认为我们桌子上有一层纸，如果我们再贴一张纸，我们的眼睛会觉得它有一个深度。&lt;/p&gt;
&lt;p&gt;让我们通过 Material Design 的应用截图来想象它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b043fbce3b?w=2000&amp;amp;h=827&amp;amp;f=jpeg&amp;amp;s=109846&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们来看看屏幕上的各个元素。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;屏幕（表层 - 深度为 0 ）&lt;/li&gt;
&lt;li&gt;CardViews&lt;/li&gt;
&lt;li&gt;App UI 布局&lt;/li&gt;
&lt;li&gt;浮动动作按钮（Floating Action Button）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里面，每个元素都在另一个元素之上。CardView 可以滚动，所以我们可以说第一层是可滚动的内容，第二层是 AppBar 布局，第三层（顶层）是浮动动作按钮。&lt;/p&gt;
&lt;p&gt;那么，我们如何定义层级？我们如何让用户感受到深度？答案是： Z 轴。&lt;/p&gt;
&lt;h2 id=&quot;android-中的-z-值是什么&quot;&gt;Android 中的 Z 值是什么？&lt;/h2&gt;
&lt;p&gt;View 的 Z 值有两个组成部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Elevation：高度，一个静态值。&lt;/li&gt;
&lt;li&gt;Translation Z：Z轴变动值，用于动画的动态值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我总是在想 Elevation 和 Translation Z 有什么区别。&lt;/p&gt;
&lt;p&gt;Elevation 是静态的，所以你最好不要动态的去改变他。如果你想在 Z 轴上做动画的效果（如按下态或者静止态），你需要使用 Translation Z 属性。&lt;/p&gt;
&lt;p&gt;Translation Z 是动态的，当你创建一个空白项目，并在其中增加一个按钮的时候，当你按下它你将会看到阴影变大了。实际上 Elevation 并没有变化，而是 Translation Z 属性在变化。这是 Android 使用默认的状态列表动画，更改 Z 属性。&lt;/p&gt;
&lt;p&gt;Z Vaue = Elevation + TranslationZ&lt;/p&gt;
&lt;p&gt;如果我们改变两个具有 Z 值的 View，让它们相交。Android如何处理屏幕上的层级？让我用一个我设计的图表向你展示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b0440d1d46?w=1000&amp;amp;h=557&amp;amp;f=jpeg&amp;amp;s=41008&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一个问题，我们如何看到物体的影子？我们是需要一个阴影吗？不是的，我们是需要一个光源。&lt;/p&gt;
&lt;h2 id=&quot;android-中的光源是什么&quot;&gt;Android 中的光源是什么？&lt;/h2&gt;
&lt;p&gt;其实问题不在于是什么？而是在哪里。&lt;/p&gt;
&lt;p&gt;在现实中，如果我们手持一个手电筒照桌子上的物体（从它的顶部），阴影的长度会缩短，当你降低它的时候，阴影的长度会增加。&lt;/p&gt;
&lt;p&gt;那么在 Android 的 Material Design 中，光源在哪里？在顶部？还是有角度的？经过一番研究，我发现这个现象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b04405dd2e?w=800&amp;amp;h=534&amp;amp;f=jpeg&amp;amp;s=9135&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Android 中存在两个光源，顶部那个是关键的光源，而另一个是环境光源，我们看到的阴影实际上是这两个光源的组合。&lt;/p&gt;
&lt;p&gt;让我们看看显示的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b044174560?w=1208&amp;amp;h=456&amp;amp;f=jpeg&amp;amp;s=20624&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Android 中，我们有很多小部件。按钮、CardView、对话框，抽屉等所有这些都是视图。如果有一个光源，我们就有阴影。那么我们如何在Android中决定 Z 值呢？Material Design 是如何规定这些的？&lt;/p&gt;
&lt;p&gt;有一个示意图来反映这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b05dea19f2?w=2000&amp;amp;h=827&amp;amp;f=jpeg&amp;amp;s=102528&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;静止或者按下&quot;&gt;静止或者按下&lt;/h2&gt;
&lt;p&gt;正如我之前提到的，在 Android Framework 中，一些动画是为小部件而实现的。如果你在布局中放置浮动操作按钮，默认情况下它将具有 &lt;strong&gt;6dp&lt;/strong&gt; 的 Elevation。但是你会注意到当你按下按钮时，FAB 的 Elevation 将会提高到&lt;strong&gt;12 dp&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;让我告诉你，在这个过程中发生了什么。&lt;/p&gt;
&lt;p&gt;其实FAB有 6dp 的 &lt;strong&gt;Elevation&lt;/strong&gt;。当您按下按钮时，&lt;strong&gt;translationZ&lt;/strong&gt; 值开始增加。ViewPropertyAnimator 通过将 translationZ 值从 0dp 更改为 6dp 来 让视图动起来。如果你释放按钮，ViewPropertyAnimator 播放动画，将 translationZ 从 6dp 变到 0dp。你可以为你的视图创建自定义状态列表动画，并将其添加到你的视图上。&lt;/p&gt;
&lt;p&gt;我们来看一下这个过程的流程图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b05df1a6f1?w=2000&amp;amp;h=839&amp;amp;f=jpeg&amp;amp;s=85077&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;阴影的秘密outline&quot;&gt;阴影的秘密：Outline&lt;/h2&gt;
&lt;p&gt;Outline 是一个属于 android.graphic 下的类，看看它的文档都说了什么&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;定义一个简单的形状，用于图形的边界区域。&lt;/p&gt;
&lt;p&gt;可以为 View 计算，也可以由 Drawable 计算，以驱动由视图投射的阴影的形状，或剪裁视图的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个 View 都有默认的轮廓以显示其阴影。如果我们创建一个可绘制的自定义形状，其轮廓将根据其形状在内部进行计算。所以，如果我们画圆，轮廓将会是圆的。如果我们绘制矩形，轮廓将是矩形。&lt;/p&gt;
&lt;p&gt;总而言之，有一个 &lt;strong&gt;Outlin&lt;/strong&gt; 可以让你以不可见的方式看到这个效果。但是，如果我想创建一个自定义的视图，并动态地改变它的边界呢？Android 会为我的自定义视图提供了 Outline 吗？&lt;/p&gt;
&lt;p&gt;Android 当然为我们提供了自定义 Outline 的办法，那就是 ： &lt;code&gt;ViewOutlineProvider&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;什么是-viewoutlineprovider&quot;&gt;什么是 ViewOutlineProvider&lt;/h2&gt;
&lt;p&gt;在我最近的开源的 &lt;a href=&quot;https://github.com/iammert/ScalingLayout&quot;&gt;&lt;strong&gt;ScalingLayout&lt;/strong&gt;&lt;/a&gt; 库中，我没有对自定义视图实现阴影效果。我以为这是非常漂亮，没有影子。但要记住 Material Design 的基础知识，3D，Depth，Z-Value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07c45eacfe66?w=300&amp;amp;h=191&amp;amp;f=gif&amp;amp;s=2112369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个动画中，我们可能无法确定那些地方是可以被点击的，而且缩放布局中并没有阴影。&lt;/p&gt;
&lt;p&gt;接下来我们为自定义的视图提供动态的轮廓。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ScalingLayoutOutlineProvider &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ViewOutlineProvider {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getOutline&lt;/span&gt;(View view, Outline outline) {
        outline.&lt;span class=&quot;fu&quot;&gt;setRoundRect&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, width, height, radius);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ScalingLayout &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; FrameLayout {
    
    &lt;span class=&quot;co&quot;&gt;//...&lt;/span&gt;
    viewOutline = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ScalingLayoutOutlineProvider&lt;/span&gt;(w, h, currentRadius);
    &lt;span class=&quot;fu&quot;&gt;setOutlineProvider&lt;/span&gt;(viewOutline);
    &lt;span class=&quot;co&quot;&gt;//..&lt;/span&gt;
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们就为自定义的 View 增加了高度的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b0664986b9?w=2000&amp;amp;h=519&amp;amp;f=jpeg&amp;amp;s=67337&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多有关于 ViewOutlineProvider 的使用中，被简化的一些基础知识，你可以在 ScalingLayout 中找到细节。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iammert/ScalingLayout&quot; class=&quot;uri&quot;&gt;https://github.com/iammert/ScalingLayout&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作者 | &lt;a href=&quot;https://android.jlelse.eu/@iammert?source=post_header_lockup&quot;&gt;Mert Şimşek&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译 | 承香墨影&lt;/p&gt;
&lt;p&gt;授权 承香墨影 翻译并发布&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://android.jlelse.eu/mastering-shadows-in-android-e883ad2c9d5b&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今天在公众号后台回复成长『&lt;strong&gt;成长&lt;/strong&gt;』，将会得到我整理的一些学习资料，也能回复『&lt;strong&gt;加群&lt;/strong&gt;』，一起学习进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/26/161d07b07acda462?w=600&amp;amp;h=600&amp;amp;f=jpeg&amp;amp;s=54770&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 05:16:00 +0000</pubDate>
<dc:creator>承香墨影</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/plokmju/p/8472683.html</dc:identifier>
</item>
<item>
<title>对 url 中含有的中文进行转码操作 - ljmatlight</title>
<link>http://www.cnblogs.com/ljmatlight/p/8472666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljmatlight/p/8472666.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;一般情况下，将带有中文的 &lt;code&gt;url&lt;/code&gt; 拷贝到开发工具，开发工具都会有相应的转码（自动转码），&lt;br/&gt;现在大部分的浏览器也可以对含有中文的 &lt;code&gt;url&lt;/code&gt; 进行转码（自动转码）&lt;/p&gt;
&lt;h2 id=&quot;情景说明&quot;&gt;情景说明&lt;/h2&gt;
&lt;h3 id=&quot;android&quot;&gt;android&lt;/h3&gt;
&lt;p&gt;安卓系统，能够识别中文路径：&lt;/p&gt;
&lt;pre class=&quot;url&quot;&gt;
&lt;code&gt;https://spdbimg.idoupiao.com/film/my/美国队长3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ios&quot;&gt;IOS&lt;/h3&gt;
&lt;p&gt;苹果系统，不能够识别中文路径：&lt;/p&gt;
&lt;pre class=&quot;url&quot;&gt;
&lt;code&gt;https://spdbimg.idoupiao.com/film/my/美国队长3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必须将以上路径进行转码为下来形式才可以访问：&lt;/p&gt;
&lt;pre class=&quot;url&quot;&gt;
&lt;code&gt;https://spdbimg.idoupiao.com/film/my/%E7%BE%8E%E5%9B%BD%E9%98%9F%E9%95%BF3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和他们各自的战略定位有关系。。。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;编码实现&quot;&gt;编码实现&lt;/h2&gt;
&lt;p&gt;1、先寻找有没有已经实现类似功能的成熟工具。&lt;br/&gt;2、找到 &lt;code&gt;JDK&lt;/code&gt; 提供的 &lt;code&gt;URLEncoder&lt;/code&gt; 类的 &lt;code&gt;encode&lt;/code&gt; 方法基本满足需求。&lt;br/&gt;3、测试是否满足当下需求。&lt;br/&gt;经过测试发现，&lt;code&gt;JDK&lt;/code&gt; 提供的 &lt;code&gt;URLEncoder&lt;/code&gt; 类的 &lt;code&gt;encode&lt;/code&gt; 方法会将 ':' 和 '/' 等字符也进行编码。&lt;br/&gt;4、查找 &lt;code&gt;JDK&lt;/code&gt; 提供的 &lt;code&gt;URLEncoder&lt;/code&gt; 类的 &lt;code&gt;encode&lt;/code&gt; 方法 相关源码。&lt;br/&gt;5、发现可以进行部分改造满足当前需求，重写 &lt;code&gt;URLEncoder&lt;/code&gt; 类，并将其设置为私有静态类，多人合作时，防止他人误用。&lt;br/&gt;6、改造完成进行验证型测试。&lt;/p&gt;
&lt;p&gt;添加以下两条语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    // 排除这两个特殊字符的编码
    dontNeedEncoding.set(':');
    dontNeedEncoding.set('/');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写后的 &lt;code&gt;URLEncoder&lt;/code&gt; 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
/**
     * Utility class for HTML form encoding. This class contains static methods
     * for converting a String to the &amp;lt;CODE&amp;gt;application/x-www-form-urlencoded&amp;lt;/CODE&amp;gt; MIME
     * format. For more information about HTML form encoding, consult the HTML
     * &amp;lt;A HREF=&quot;http://www.w3.org/TR/html4/&quot;&amp;gt;specification&amp;lt;/A&amp;gt;.
     *
     * &amp;lt;p&amp;gt;
     * When encoding a String, the following rules apply:
     *
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;The alphanumeric characters &amp;amp;quot;{@code a}&amp;amp;quot; through
     *     &amp;amp;quot;{@code z}&amp;amp;quot;, &amp;amp;quot;{@code A}&amp;amp;quot; through
     *     &amp;amp;quot;{@code Z}&amp;amp;quot; and &amp;amp;quot;{@code 0}&amp;amp;quot;
     *     through &amp;amp;quot;{@code 9}&amp;amp;quot; remain the same.
     * &amp;lt;li&amp;gt;The special characters &amp;amp;quot;{@code .}&amp;amp;quot;,
     *     &amp;amp;quot;{@code -}&amp;amp;quot;, &amp;amp;quot;{@code *}&amp;amp;quot;, and
     *     &amp;amp;quot;{@code _}&amp;amp;quot; remain the same.
     * &amp;lt;li&amp;gt;The space character &amp;amp;quot; &amp;amp;nbsp; &amp;amp;quot; is
     *     converted into a plus sign &amp;amp;quot;{@code +}&amp;amp;quot;.
     * &amp;lt;li&amp;gt;All other characters are unsafe and are first converted into
     *     one or more bytes using some encoding scheme. Then each byte is
     *     represented by the 3-character string
     *     &amp;amp;quot;&amp;lt;i&amp;gt;{@code %xy}&amp;lt;/i&amp;gt;&amp;amp;quot;, where &amp;lt;i&amp;gt;xy&amp;lt;/i&amp;gt; is the
     *     two-digit hexadecimal representation of the byte.
     *     The recommended encoding scheme to use is UTF-8. However,
     *     for compatibility reasons, if an encoding is not specified,
     *     then the default encoding of the platform is used.
     * &amp;lt;/ul&amp;gt;
     *
     * &amp;lt;p&amp;gt;
     * For example using UTF-8 as the encoding scheme the string &amp;amp;quot;The
     * string &amp;amp;#252;@foo-bar&amp;amp;quot; would get converted to
     * &amp;amp;quot;The+string+%C3%BC%40foo-bar&amp;amp;quot; because in UTF-8 the character
     * &amp;amp;#252; is encoded as two bytes C3 (hex) and BC (hex), and the
     * character @ is encoded as one byte 40 (hex).
     *
     * @author  Herb Jellinek
     * @since   JDK1.0
     */
    private static class URLEncoder {
        static BitSet dontNeedEncoding;
        static final int caseDiff = ('a' - 'A');
        static String dfltEncName = null;

        static {

        /* The list of characters that are not encoded has been
         * determined as follows:
         *
         * RFC 2396 states:
         * -----
         * Data characters that are allowed in a URI but do not have a
         * reserved purpose are called unreserved.  These include upper
         * and lower case letters, decimal digits, and a limited set of
         * punctuation marks and symbols.
         *
         * unreserved  = alphanum | mark
         *
         * mark        = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; | &quot;(&quot; | &quot;)&quot;
         *
         * Unreserved characters can be escaped without changing the
         * semantics of the URI, but this should not be done unless the
         * URI is being used in a context that does not allow the
         * unescaped character to appear.
         * -----
         *
         * It appears that both Netscape and Internet Explorer escape
         * all special characters from this list with the exception
         * of &quot;-&quot;, &quot;_&quot;, &quot;.&quot;, &quot;*&quot;. While it is not clear why they are
         * escaping the other characters, perhaps it is safest to
         * assume that there might be contexts in which the others
         * are unsafe if not escaped. Therefore, we will use the same
         * list. It is also noteworthy that this is consistent with
         * O'Reilly's &quot;HTML: The Definitive Guide&quot; (page 164).
         *
         * As a last note, Intenet Explorer does not encode the &quot;@&quot;
         * character which is clearly not unreserved according to the
         * RFC. We are being consistent with the RFC in this matter,
         * as is Netscape.
         *
         */

            dontNeedEncoding = new BitSet(256);
            int i;
            for (i = 'a'; i &amp;lt;= 'z'; i++) {
                dontNeedEncoding.set(i);
            }
            for (i = 'A'; i &amp;lt;= 'Z'; i++) {
                dontNeedEncoding.set(i);
            }
            for (i = '0'; i &amp;lt;= '9'; i++) {
                dontNeedEncoding.set(i);
            }
            dontNeedEncoding.set(' '); /* encoding a space to a + is done
                                    * in the encode() method */
            dontNeedEncoding.set('-');
            dontNeedEncoding.set('_');
            dontNeedEncoding.set('.');
            dontNeedEncoding.set('*');

            // 排除这两个特殊字符的编码
            dontNeedEncoding.set(':');
            dontNeedEncoding.set('/');


            dfltEncName = AccessController.doPrivileged(
                    new GetPropertyAction(&quot;file.encoding&quot;)
            );
        }

        /**
         * You can't call the constructor.
         */
        private URLEncoder() { }

        /**
         * Translates a string into {@code x-www-form-urlencoded}
         * format. This method uses the platform's default encoding
         * as the encoding scheme to obtain the bytes for unsafe characters.
         *
         * @param   s   {@code String} to be translated.
         * @deprecated The resulting string may vary depending on the platform's
         *             default encoding. Instead, use the encode(String,String)
         *             method to specify the encoding.
         * @return  the translated {@code String}.
         */
        @Deprecated
        public static String encode(String s) {

            String str = null;

            try {
                str = encode(s, dfltEncName);
            } catch (UnsupportedEncodingException e) {
                // The system should always have the platform default
            }

            return str;
        }

        /**
         * Translates a string into {@code application/x-www-form-urlencoded}
         * format using a specific encoding scheme. This method uses the
         * supplied encoding scheme to obtain the bytes for unsafe
         * characters.
         * &amp;lt;p&amp;gt;
         * &amp;lt;em&amp;gt;&amp;lt;strong&amp;gt;Note:&amp;lt;/strong&amp;gt; The &amp;lt;a href=
         * &quot;http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&amp;gt;
         * World Wide Web Consortium Recommendation&amp;lt;/a&amp;gt; states that
         * UTF-8 should be used. Not doing so may introduce
         * incompatibilities.&amp;lt;/em&amp;gt;
         *
         * @param   s   {@code String} to be translated.
         * @param   enc   The name of a supported
         *    &amp;lt;a href=&quot;../lang/package-summary.html#charenc&quot;&amp;gt;character
         *    encoding&amp;lt;/a&amp;gt;.
         * @return  the translated {@code String}.
         * @exception  UnsupportedEncodingException
         *             If the named encoding is not supported
         * @see URLDecoder#decode(java.lang.String, java.lang.String)
         * @since 1.4
         */
        public static String encode(String s, String enc)
                throws UnsupportedEncodingException {

            boolean needToChange = false;
            StringBuffer out = new StringBuffer(s.length());
            Charset charset;
            CharArrayWriter charArrayWriter = new CharArrayWriter();

            if (enc == null)
                throw new NullPointerException(&quot;charsetName&quot;);

            try {
                charset = Charset.forName(enc);
            } catch (IllegalCharsetNameException e) {
                throw new UnsupportedEncodingException(enc);
            } catch (UnsupportedCharsetException e) {
                throw new UnsupportedEncodingException(enc);
            }

            for (int i = 0; i &amp;lt; s.length();) {
                int c = (int) s.charAt(i);
                //System.out.println(&quot;Examining character: &quot; + c);
                if (dontNeedEncoding.get(c)) {
                    if (c == ' ') {
                        c = '+';
                        needToChange = true;
                    }
                    //System.out.println(&quot;Storing: &quot; + c);
                    out.append((char)c);
                    i++;
                } else {
                    // convert to external encoding before hex conversion
                    do {
                        charArrayWriter.write(c);
                    /*
                     * If this character represents the start of a Unicode
                     * surrogate pair, then pass in two characters. It's not
                     * clear what should be done if a bytes reserved in the
                     * surrogate pairs range occurs outside of a legal
                     * surrogate pair. For now, just treat it as if it were
                     * any other character.
                     */
                        if (c &amp;gt;= 0xD800 &amp;amp;&amp;amp; c &amp;lt;= 0xDBFF) {
                        /*
                          System.out.println(Integer.toHexString(c)
                          + &quot; is high surrogate&quot;);
                        */
                            if ( (i+1) &amp;lt; s.length()) {
                                int d = (int) s.charAt(i+1);
                            /*
                              System.out.println(&quot;\tExamining &quot;
                              + Integer.toHexString(d));
                            */
                                if (d &amp;gt;= 0xDC00 &amp;amp;&amp;amp; d &amp;lt;= 0xDFFF) {
                                /*
                                  System.out.println(&quot;\t&quot;
                                  + Integer.toHexString(d)
                                  + &quot; is low surrogate&quot;);
                                */
                                    charArrayWriter.write(d);
                                    i++;
                                }
                            }
                        }
                        i++;
                    } while (i &amp;lt; s.length() &amp;amp;&amp;amp; !dontNeedEncoding.get((c = (int) s.charAt(i))));

                    charArrayWriter.flush();
                    String str = new String(charArrayWriter.toCharArray());
                    byte[] ba = str.getBytes(charset);
                    for (int j = 0; j &amp;lt; ba.length; j++) {
                        out.append('%');
                        char ch = Character.forDigit((ba[j] &amp;gt;&amp;gt; 4) &amp;amp; 0xF, 16);
                        // converting to use uppercase letter as part of
                        // the hex value if ch is a letter.
                        if (Character.isLetter(ch)) {
                            ch -= caseDiff;
                        }
                        out.append(ch);
                        ch = Character.forDigit(ba[j] &amp;amp; 0xF, 16);
                        if (Character.isLetter(ch)) {
                            ch -= caseDiff;
                        }
                        out.append(ch);
                    }
                    charArrayWriter.reset();
                    needToChange = true;
                }
            }

            return (needToChange? out.toString() : s);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @Test
    public void testReplace() throws UnsupportedEncodingException {

        // https://ojjqzz83h.qnssl.com/film/my/美国队长3?imageView2/1/w/140/h/90/interlace/0/q/100
        // https://spdbimg.idoupiao.com/film/my/%E7%BE%8E%E5%9B%BD%E9%98%9F%E9%95%BF3

        String oldImgUrl = &quot;https://spdbimg.idoupiao.com/film/my/美国队长3&quot;;

        oldImgUrl = URLEncoder.encode(oldImgUrl, &quot;UTF-8&quot;);

//        oldImgUrl = new String(Base64.getEncoder().encode(oldImgUrl.getBytes()));

        String oldDomain = &quot;spdbimg.idoupiao.com&quot;;
        String newDomain = &quot;ojjqzz83h.qnssl.com&quot;;
        String suffix = &quot;?imageView2/1/w/140/h/90/interlace/0/q/100&quot;;

        String newImgUrl = StringUtils.replace(oldImgUrl, oldDomain, newDomain).concat(suffix);

        System.out.println(&quot;newImgUrl === &quot; + newImgUrl);

    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;
package com.github.ljmatlight.util;

import org.junit.Test;
import sun.security.action.GetPropertyAction;

import java.io.CharArrayWriter;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.Charset;
import java.nio.charset.IllegalCharsetNameException;
import java.nio.charset.UnsupportedCharsetException;
import java.security.AccessController;
import java.util.BitSet;

/**
 * Description：对 url 中含有的中文进行转码操作
 * &amp;lt;br /&amp;gt; Author：ljmatlight
 */
public class StringTest {


    @Test
    public void testReplace() throws UnsupportedEncodingException {

        // https://ojjqzz83h.qnssl.com/film/my/美国队长3?imageView2/1/w/140/h/90/interlace/0/q/100
        // https://spdbimg.idoupiao.com/film/my/%E7%BE%8E%E5%9B%BD%E9%98%9F%E9%95%BF3

        String oldImgUrl = &quot;https://spdbimg.idoupiao.com/film/my/美国队长3&quot;;

        oldImgUrl = URLEncoder.encode(oldImgUrl, &quot;UTF-8&quot;);

//        oldImgUrl = new String(Base64.getEncoder().encode(oldImgUrl.getBytes()));

        String oldDomain = &quot;spdbimg.idoupiao.com&quot;;
        String newDomain = &quot;ojjqzz83h.qnssl.com&quot;;
        String suffix = &quot;?imageView2/1/w/140/h/90/interlace/0/q/100&quot;;

        String newImgUrl = StringUtils.replace(oldImgUrl, oldDomain, newDomain).concat(suffix);

        System.out.println(&quot;newImgUrl === &quot; + newImgUrl);

    }


    /**
     * Utility class for HTML form encoding. This class contains static methods
     * for converting a String to the &amp;lt;CODE&amp;gt;application/x-www-form-urlencoded&amp;lt;/CODE&amp;gt; MIME
     * format. For more information about HTML form encoding, consult the HTML
     * &amp;lt;A HREF=&quot;http://www.w3.org/TR/html4/&quot;&amp;gt;specification&amp;lt;/A&amp;gt;.
     *
     * &amp;lt;p&amp;gt;
     * When encoding a String, the following rules apply:
     *
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;The alphanumeric characters &amp;amp;quot;{@code a}&amp;amp;quot; through
     *     &amp;amp;quot;{@code z}&amp;amp;quot;, &amp;amp;quot;{@code A}&amp;amp;quot; through
     *     &amp;amp;quot;{@code Z}&amp;amp;quot; and &amp;amp;quot;{@code 0}&amp;amp;quot;
     *     through &amp;amp;quot;{@code 9}&amp;amp;quot; remain the same.
     * &amp;lt;li&amp;gt;The special characters &amp;amp;quot;{@code .}&amp;amp;quot;,
     *     &amp;amp;quot;{@code -}&amp;amp;quot;, &amp;amp;quot;{@code *}&amp;amp;quot;, and
     *     &amp;amp;quot;{@code _}&amp;amp;quot; remain the same.
     * &amp;lt;li&amp;gt;The space character &amp;amp;quot; &amp;amp;nbsp; &amp;amp;quot; is
     *     converted into a plus sign &amp;amp;quot;{@code +}&amp;amp;quot;.
     * &amp;lt;li&amp;gt;All other characters are unsafe and are first converted into
     *     one or more bytes using some encoding scheme. Then each byte is
     *     represented by the 3-character string
     *     &amp;amp;quot;&amp;lt;i&amp;gt;{@code %xy}&amp;lt;/i&amp;gt;&amp;amp;quot;, where &amp;lt;i&amp;gt;xy&amp;lt;/i&amp;gt; is the
     *     two-digit hexadecimal representation of the byte.
     *     The recommended encoding scheme to use is UTF-8. However,
     *     for compatibility reasons, if an encoding is not specified,
     *     then the default encoding of the platform is used.
     * &amp;lt;/ul&amp;gt;
     *
     * &amp;lt;p&amp;gt;
     * For example using UTF-8 as the encoding scheme the string &amp;amp;quot;The
     * string &amp;amp;#252;@foo-bar&amp;amp;quot; would get converted to
     * &amp;amp;quot;The+string+%C3%BC%40foo-bar&amp;amp;quot; because in UTF-8 the character
     * &amp;amp;#252; is encoded as two bytes C3 (hex) and BC (hex), and the
     * character @ is encoded as one byte 40 (hex).
     *
     * @author  Herb Jellinek
     * @since   JDK1.0
     */
    private static class URLEncoder {
        static BitSet dontNeedEncoding;
        static final int caseDiff = ('a' - 'A');
        static String dfltEncName = null;

        static {

        /* The list of characters that are not encoded has been
         * determined as follows:
         *
         * RFC 2396 states:
         * -----
         * Data characters that are allowed in a URI but do not have a
         * reserved purpose are called unreserved.  These include upper
         * and lower case letters, decimal digits, and a limited set of
         * punctuation marks and symbols.
         *
         * unreserved  = alphanum | mark
         *
         * mark        = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; | &quot;(&quot; | &quot;)&quot;
         *
         * Unreserved characters can be escaped without changing the
         * semantics of the URI, but this should not be done unless the
         * URI is being used in a context that does not allow the
         * unescaped character to appear.
         * -----
         *
         * It appears that both Netscape and Internet Explorer escape
         * all special characters from this list with the exception
         * of &quot;-&quot;, &quot;_&quot;, &quot;.&quot;, &quot;*&quot;. While it is not clear why they are
         * escaping the other characters, perhaps it is safest to
         * assume that there might be contexts in which the others
         * are unsafe if not escaped. Therefore, we will use the same
         * list. It is also noteworthy that this is consistent with
         * O'Reilly's &quot;HTML: The Definitive Guide&quot; (page 164).
         *
         * As a last note, Intenet Explorer does not encode the &quot;@&quot;
         * character which is clearly not unreserved according to the
         * RFC. We are being consistent with the RFC in this matter,
         * as is Netscape.
         *
         */

            dontNeedEncoding = new BitSet(256);
            int i;
            for (i = 'a'; i &amp;lt;= 'z'; i++) {
                dontNeedEncoding.set(i);
            }
            for (i = 'A'; i &amp;lt;= 'Z'; i++) {
                dontNeedEncoding.set(i);
            }
            for (i = '0'; i &amp;lt;= '9'; i++) {
                dontNeedEncoding.set(i);
            }
            dontNeedEncoding.set(' '); /* encoding a space to a + is done
                                    * in the encode() method */
            dontNeedEncoding.set('-');
            dontNeedEncoding.set('_');
            dontNeedEncoding.set('.');
            dontNeedEncoding.set('*');

            // 排除这两个特殊字符的编码
            dontNeedEncoding.set(':');
            dontNeedEncoding.set('/');


            dfltEncName = AccessController.doPrivileged(
                    new GetPropertyAction(&quot;file.encoding&quot;)
            );
        }

        /**
         * You can't call the constructor.
         */
        private URLEncoder() { }

        /**
         * Translates a string into {@code x-www-form-urlencoded}
         * format. This method uses the platform's default encoding
         * as the encoding scheme to obtain the bytes for unsafe characters.
         *
         * @param   s   {@code String} to be translated.
         * @deprecated The resulting string may vary depending on the platform's
         *             default encoding. Instead, use the encode(String,String)
         *             method to specify the encoding.
         * @return  the translated {@code String}.
         */
        @Deprecated
        public static String encode(String s) {

            String str = null;

            try {
                str = encode(s, dfltEncName);
            } catch (UnsupportedEncodingException e) {
                // The system should always have the platform default
            }

            return str;
        }

        /**
         * Translates a string into {@code application/x-www-form-urlencoded}
         * format using a specific encoding scheme. This method uses the
         * supplied encoding scheme to obtain the bytes for unsafe
         * characters.
         * &amp;lt;p&amp;gt;
         * &amp;lt;em&amp;gt;&amp;lt;strong&amp;gt;Note:&amp;lt;/strong&amp;gt; The &amp;lt;a href=
         * &quot;http://www.w3.org/TR/html40/appendix/notes.html#non-ascii-chars&quot;&amp;gt;
         * World Wide Web Consortium Recommendation&amp;lt;/a&amp;gt; states that
         * UTF-8 should be used. Not doing so may introduce
         * incompatibilities.&amp;lt;/em&amp;gt;
         *
         * @param   s   {@code String} to be translated.
         * @param   enc   The name of a supported
         *    &amp;lt;a href=&quot;../lang/package-summary.html#charenc&quot;&amp;gt;character
         *    encoding&amp;lt;/a&amp;gt;.
         * @return  the translated {@code String}.
         * @exception  UnsupportedEncodingException
         *             If the named encoding is not supported
         * @see URLDecoder#decode(java.lang.String, java.lang.String)
         * @since 1.4
         */
        public static String encode(String s, String enc)
                throws UnsupportedEncodingException {

            boolean needToChange = false;
            StringBuffer out = new StringBuffer(s.length());
            Charset charset;
            CharArrayWriter charArrayWriter = new CharArrayWriter();

            if (enc == null)
                throw new NullPointerException(&quot;charsetName&quot;);

            try {
                charset = Charset.forName(enc);
            } catch (IllegalCharsetNameException e) {
                throw new UnsupportedEncodingException(enc);
            } catch (UnsupportedCharsetException e) {
                throw new UnsupportedEncodingException(enc);
            }

            for (int i = 0; i &amp;lt; s.length();) {
                int c = (int) s.charAt(i);
                //System.out.println(&quot;Examining character: &quot; + c);
                if (dontNeedEncoding.get(c)) {
                    if (c == ' ') {
                        c = '+';
                        needToChange = true;
                    }
                    //System.out.println(&quot;Storing: &quot; + c);
                    out.append((char)c);
                    i++;
                } else {
                    // convert to external encoding before hex conversion
                    do {
                        charArrayWriter.write(c);
                    /*
                     * If this character represents the start of a Unicode
                     * surrogate pair, then pass in two characters. It's not
                     * clear what should be done if a bytes reserved in the
                     * surrogate pairs range occurs outside of a legal
                     * surrogate pair. For now, just treat it as if it were
                     * any other character.
                     */
                        if (c &amp;gt;= 0xD800 &amp;amp;&amp;amp; c &amp;lt;= 0xDBFF) {
                        /*
                          System.out.println(Integer.toHexString(c)
                          + &quot; is high surrogate&quot;);
                        */
                            if ( (i+1) &amp;lt; s.length()) {
                                int d = (int) s.charAt(i+1);
                            /*
                              System.out.println(&quot;\tExamining &quot;
                              + Integer.toHexString(d));
                            */
                                if (d &amp;gt;= 0xDC00 &amp;amp;&amp;amp; d &amp;lt;= 0xDFFF) {
                                /*
                                  System.out.println(&quot;\t&quot;
                                  + Integer.toHexString(d)
                                  + &quot; is low surrogate&quot;);
                                */
                                    charArrayWriter.write(d);
                                    i++;
                                }
                            }
                        }
                        i++;
                    } while (i &amp;lt; s.length() &amp;amp;&amp;amp; !dontNeedEncoding.get((c = (int) s.charAt(i))));

                    charArrayWriter.flush();
                    String str = new String(charArrayWriter.toCharArray());
                    byte[] ba = str.getBytes(charset);
                    for (int j = 0; j &amp;lt; ba.length; j++) {
                        out.append('%');
                        char ch = Character.forDigit((ba[j] &amp;gt;&amp;gt; 4) &amp;amp; 0xF, 16);
                        // converting to use uppercase letter as part of
                        // the hex value if ch is a letter.
                        if (Character.isLetter(ch)) {
                            ch -= caseDiff;
                        }
                        out.append(ch);
                        ch = Character.forDigit(ba[j] &amp;amp; 0xF, 16);
                        if (Character.isLetter(ch)) {
                            ch -= caseDiff;
                        }
                        out.append(ch);
                    }
                    charArrayWriter.reset();
                    needToChange = true;
                }
            }

            return (needToChange? out.toString() : s);
        }
    }


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7.2166172106825&quot;&gt;
&lt;p&gt;作者：随风浮云&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/ljmatlight&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/ljmatlight&lt;/a&gt;&lt;br/&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明。&lt;br/&gt;文中有不妥或者错误的地方，欢迎勘误，如果你有更好的建议，可以给我留言讨论，共同进步。&lt;br/&gt;互联网技术时效性较强，引用请慎重。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;</description>
<pubDate>Mon, 26 Feb 2018 05:09:00 +0000</pubDate>
<dc:creator>ljmatlight</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljmatlight/p/8472666.html</dc:identifier>
</item>
<item>
<title>一步一步从原理跟我学邮件收取及发送 13.mime格式与常见字符编码 - clq</title>
<link>http://www.cnblogs.com/-clq/p/8472538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-clq/p/8472538.html</guid>
<description>&lt;p&gt;    在前面的本系列文章中我们已经学会了邮件的发送和收取。但在收取中我们看到的是一串串的乱码，回忆前面的发送过程，我们会奇怪：我们前面的邮件是明文啊。为什么明文的邮件明明也可以正常工作，还要弄乱码似的字符串编码呢？让我们先来看一下前面发送过的邮件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
From: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1@newbt.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;test1@newbt.net&amp;gt;&lt;span&gt;
To: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clq@newbt.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;clq@newbt.net&amp;gt;&lt;span&gt;
Subject: test
Date: Sun, &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; Jan &lt;span&gt;2018&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt;&lt;span&gt; GMT

Hello World.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    从中我们可以看到，其实可以直接在&quot;记事本&quot;中把邮件直接写出来。这是因为电子邮件的格式是 mime 而最简单的 mime 格式并不复杂。mime 当然也是有 rfc 文档进行说明的，不过明显太过复杂，我们先不要管它，先直接直观的看看眼前的这个邮件的格式。前面几行比较简单，我们猜也能猜出来，无非是说明了邮件的发件人、收件人这样的信息。后面的内容也简单啊，不就是邮件内容嘛！但是这里就有一个 mime 初学者非常容易出错的地方，后面的内容不仅仅是电子邮件的内容那么简单。实际上它包含了分隔符。什么分隔符号？你会问。我要说这封邮件里包含了两部分：一部分是头信息，包括发件人、收件人、标题、日期；另一部分是内容 &quot;Hello World.&quot; 你能从上面的内容中找到它们的分隔符号是什么吗？大部分的同学仔细看过都会说，我看得出来是两部分，但是分隔符号是什么我真不知道。这个就是直观感受和程序处理的区别了，一眼看过去我们似乎能知道是两部分，但具体的就要知道格式的标准了。在这里，它的标准说明是：分隔符号是一个空行，不过在程序中它应该或者说必须描述为 &lt;span&gt;&lt;strong&gt;&quot;字符串流中的第一个空行前是头信息&quot;&lt;/strong&gt;&lt;/span&gt; 我不能说之后的就是内容，虽然这封信里看起来是这样。只能说对于这封信来说后面的内容是具体的信息，可以用下图表示：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/318151/201802/318151-20180226122016527-195208198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在继续往下说以前我们要明白 &lt;strong&gt;mime 实际上在 http 中和 email 中是不太一样的，学过 http 的 mime 内容的同学要注意了：mime 在电子邮件中要比 http 中复杂得多，虽然它们是同一个标准&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;    这里要再提出一个问题，如果我们要写一个中文的标题应该怎么写？你会说，改 subject 那里为&quot;中文标题&quot;就可以啦。如果我们这样做的话，确实对方可以收到一封中文的邮件。但我要说的是这样做是错误的。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/318151/201802/318151-20180226122128724-1499248889.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（错误的中文标题做法）&lt;/p&gt;&lt;p&gt;我们前面的文章已经说过了，中文的内容在传统上是要使用编码的，所以正确的标题应该是下面的这样：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/318151/201802/318151-20180226122234809-673576717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;这里使用的编码方式就是前面说过的 base64。不过在邮件编码中还有一种更传统的，那就是&quot;quoted-printable&quot;编码，例如以下的这封 facebook 的信件内容就是这种编码的。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/318151/201802/318151-20180226122259683-810309100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;所以我们就明白了，要处理好电子邮件的 mime 那么就要先处理好这些编码格式，幸好常用的编码就这两种，而 base64 我们前面又掌握了。所以我们只要再学会&quot;quoted-printable&quot;编码就可以了。&lt;/p&gt;&lt;p&gt;其实&quot;quoted-printable&quot;说来也很简单，基本上就是我们常用的 http 的网址的编码，即将一个不可打印字符按16进制转换成基本字符串，然后在前面加上&quot;=&quot;号就可以了，所以一个普通字符转换后要变成三个字符，是比较占空间的。不过现在是地球村时代，我们要特别注意字符集的处理，具体处理我们下一篇用纯C的代码来做一个示例。好了这一次的内容就到这里了。&lt;/p&gt;
&lt;p&gt;注：查看电子邮件源码的话，直接在163 这样的站点上是看不到的，可以搜索一下 foxmail4.2 （最新版本我没试过）；也可以用笔者的 eemail ，不过早期版本 mime 标题部分不完善，请到以下地址下载最新版本：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://newbt.net/ms/vdisk/show_bbs.php?id={B7106D5A-A5CB-3CFE-DFEB-4A4909A9B13A}&amp;amp;pid=43&quot; target=&quot;_blank&quot;&gt;http://newbt.net/ms/vdisk/show_bbs.php?id={B7106D5A-A5CB-3CFE-DFEB-4A4909A9B13A}&amp;amp;pid=43&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇的内容稍少，不过不先搞清楚&quot;quoted-printable&quot;编码是不行的，所以还是得有这一章节。&lt;/p&gt;
&lt;p&gt;--------------------------------------------------&lt;/p&gt;
&lt;p&gt;版权声明:&lt;/p&gt;
&lt;p&gt;本系列文章已授权百家号 &quot;clq的程序员学前班&quot; . 文章编排上略有差异.&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 04:34:00 +0000</pubDate>
<dc:creator>clq</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-clq/p/8472538.html</dc:identifier>
</item>
</channel>
</rss>