<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[机器学习]-[数据预处理]-中心化 缩放 KNN（一） - CodingStar</title>
<link>http://www.cnblogs.com/BoyceYang/p/8345863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BoyceYang/p/8345863.html</guid>
<description>&lt;p&gt;&lt;span data-offset-key=&quot;er6tc-0-0&quot;&gt;据预处理是总称，涵盖了数据分析师使用它将数据转处理成想要的数据的一系列操作。例如，对某个网站进行分析的时候，可能会去掉 html 标签，空格，缩进以及提取相关关键字。分析空间数据的时候，一般会把带单位（米、千米）的数据转换为“单元性数据”，这样，在算法的时候，就不需要考虑具体的单位。数据预处理不是凭空想象出来的。换句话说，预处理是达到某种目的的手段，并且没有硬性规则，一般会跟根据个人经验会形成一套预处理的模型，预处理一般是整个结果流程中的一个环节，并且预处理的结果好坏需要放到到整个流程中再进行评估。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;2jbf7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2jbf7-0-0&quot;&gt;本次，只使用缩放数值数据来说明预处理的重要性，数值数据：值包含数字，缩放：使用基本的运算来改变数据的范围。最后，将会使用真实的数据来演示缩放预处理提升了结果。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;5lhi5-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5lhi5-0-0&quot;&gt;首先，简单说一下机器学习和 KNN（k-Nearest Neighblors）的分类问题，分类问题是他们里面最简单的算法。为了体现缩放数据的重要性，还会介绍模型评估方式和训练集、测试集的概念。这些概念和操作都会在分类红酒质量的时演示。演示的时候会看到预处理前后对结果的影响。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;9sdf-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9sdf-0-0&quot;&gt;分类和标记问题是一个们古老的艺术。比如，亚里士多德构建的生物分类系统。现在，分类一般都是作为机器任务任务的一个通用框架，特别是监督学习。监督学习的基本概念也不复杂，这样的数据中包含预测参数和预测目标结果，监督学习的目标是构建善于通过给出的预测参参数预测目标结果的模型。如果目标结果包含分类信息（如，‘good’,'bad'），这就是所说分类学习任务。如果目标结果是不断变化的，这就是一个回归任务。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;fbq3b-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fbq3b-0-0&quot;&gt;介绍一个有用的数据集：心脏病数据集，其中有 75 个预测参数，如，‘age’，‘sex’以及目标结果，心脏病患病概率范围是0（无病）-4。对这个数据集的大部分分析集中在预测是否出现心脏病。这就是一个分类任务。如果是预测0-4的实际值，那么，就是回归问题。以后再讨论回归问题。这次主要讨论分类任务重最简单的算法，KNN。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;dprc8-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dprc8-0-0&quot;&gt;假设已经有一些标记好的数据，例如，包含红酒特征的数据，预测参数：alcohol content， density， amount of citric acid， pH，目标结果：Quality（good，bad）。然后，使用特征的新数据，没有标记结果，分类任务就是去预测结果 Quality。如果所有的预测参数都是数值，我们就可以想象一个 n 为空间，每行/红酒作为空间中的一个点。KNN 是概念和计算都很简单的分类方法，我们计算这些没有标记的数据行，在 n 维空间中，最近的 K 个已经标记过的邻居。然后，根据这 K 个邻居的标签，good 或 bad，再将命中率最高（占比最高）的标签值给新的预测数据（例如，如果 K=10,其中 7 个 good，3 个 bad，结果就是 good）。注意，这里没有 fit 参数。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;b56lm-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b56lm-0-0&quot;&gt;下面是 KNN 的一个 2D 图。思考一下，中间绿色问好的点应该如何分类。如果 K = 5，分类就是蓝色，，如果 k = 10 ，结果又如何呢？&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-8e854f2f31d3138bfe592d2d953e6478_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;200&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;49cj5-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;49cj5-0-0&quot;&gt;&lt;span data-offset-key=&quot;49cj5-0-0&quot;&gt;&lt;span data-offset-key=&quot;49cj5-0-0&quot;&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180125012403834-1552534685.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;atv4h-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;atv4h-0-0&quot;&gt;我们接下来看一下 KNN 的例子。我们将红酒质量数据集加载到 pandas 的 DataFrame 中，然后通过直方图看下数据基本信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;atv4h-0-0&quot;&gt;&lt;span data-offset-key=&quot;atv4h-0-0&quot;&gt;&lt;span data-offset-key=&quot;atv4h-0-0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180125012426834-18797410.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-1ecc74a7e10a6ba0688460ac388c3e61_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;184&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-f9a743a053e0780c672887b6a5786917_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;434&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/80/v2-a3e728a4ff1a28e943f54a7532fce70f_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;890&quot; data-rawheight=&quot;442&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic6.zhimg.com/80/v2-eb40d6e7041aad4a367f9f1717756189_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1022&quot; data-rawheight=&quot;336&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;1k112-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1k112-0-0&quot;&gt;我们看下这两个预测变量，free sulfur dioxide 的范围 1-72，volatile acidity 的范围是 0.12-1.58。简单的说就是，前一个的的范围和数量级都比后一个大很多。像 KNN 这样的算法，关心的是两个数据点之间的距离，因此，算法可能会将关注点直接放在范围更范围的变量上，这样就会对范围小的变量不公平，像 free sulfur dioxide 可能还会有噪点，这样的数据必然会导致结果准确度有所降低。这就是为什么要缩放我们即将使用的数据。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;r6g7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;r6g7-0-0&quot;&gt;现在目标结果就是红酒的‘Quality’率，它的范围是 3 到 8。简单起见，将这个范围转换为二分类，大于 5 -&amp;gt; good，小于等于 5 -&amp;gt; bad。下面用直方图说明一下二分类前后目标结果的变化：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;r6g7-0-0&quot;&gt;&lt;span data-offset-key=&quot;r6g7-0-0&quot;&gt;&lt;span data-offset-key=&quot;r6g7-0-0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180125012501490-1335148769.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;r6g7-0-0&quot;&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-989144a8b43f5f2b7232f15f5dc569ce_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1018&quot; data-rawheight=&quot;506&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;4ltcf-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4ltcf-0-0&quot;&gt;接下来我们就准备执行 KNN。我们本次的目的是比较我们的模型在有无缩放处理的情况下的结果优劣，既然要区分结果的优劣我们就需要一个评价标准。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;a1jdk-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a1jdk-0-0&quot;&gt;有很多对分类的评价方式/指标，最终重要的是，要认识到方式/指标的选择是一个很有深度的领域，并且需要具体问题具体分析。对于平衡类（目标结果，要么是是，要么是否）数据集，通常将准确性作为评价标准。事实上，在 scikit learn 中 KNN 和逻辑回归默认评分方法就是精度。那么，什么是精度呢？它就是正确预测的数量除以预测的总数：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;ami5i-0-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ami5i-0-0&quot;&gt;Accuracy = 正确预测数量/预测总数&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;30soq-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;30soq-0-0&quot;&gt;我们就使用上面介绍的江都作为衡量的标准，如果我们把先有的数据都作为训练模型用，我们应该用什么数据集来作为计算精度的数据呢？我们需要一个能很好推广到新数据的模型。也就是说，如果我们在数据集 A 上训练模型，也使用数据集 A 计算精度，那么得出的结果远远好于实际结果。这就是我们常说的过拟合。为了解决这个问题，通常会选取数据集中的一部分作为训练集，然后，在训练集上训练模型，再使用剩下的数据集进行评估。我们也是要这么做的。一般的经验规则是使用大约 80% 的数据用于训练，剩下 20% 的数据用于测试。现在我们就可以分析红酒质量数据了:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;30soq-0-0&quot;&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180125012709647-980737765.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/80/v2-0ef907eb032aa7e31f1df161dd8cf4c2_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1016&quot; data-rawheight=&quot;206&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;9ebg0-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9ebg0-0-0&quot;&gt;现在我构建 KNN 模型，对测试集进行预测，为了评估模型，我们需要对比预测值和真实值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9ebg0-0-0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/331267/201801/331267-20180125012741725-1951798010.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/80/v2-c24d8f58e5f169575c4bc0958f8fb52f_hd.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;542&quot; data-rawheight=&quot;130&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;8d9ae-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8d9ae-0-0&quot;&gt;在 scikit learn 中精度是 KNN 的默认评分方法，精度的结果是 61%，这个结果并不好，但对于没有任何预处理的结果来说，也并不是太坏。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;93amf-0-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;93amf-0-0&quot;&gt;&lt;span&gt;&lt;strong&gt;预告&lt;/strong&gt;&lt;/span&gt; [数据预处理]-中心化 缩放 KNN（二）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;do0q2-0-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;do0q2-0-0&quot;&gt;使用其他的评估方法（reacll，f1）重新评估结果&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;ci5lr-0-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ci5lr-0-0&quot;&gt;使用预处理将精度结果再提高 10% 左右&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;85umn&quot; data-offset-key=&quot;bil9u-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bil9u-0-0&quot;&gt;完整的代码&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;



</description>
<pubDate>Wed, 24 Jan 2018 23:15:00 +0000</pubDate>
<dc:creator>CodingStar</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BoyceYang/p/8345863.html</dc:identifier>
</item>
<item>
<title>数据结构与算法（1）-----&gt;排序 - Mairr</title>
<link>http://www.cnblogs.com/Mairr/p/8047905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mairr/p/8047905.html</guid>
<description>

&lt;p&gt;　　这一版块，把必备的数据结构和算法做一个总结！包括排序、队列、链表、二叉树、排组合，动态规划......。&lt;/p&gt;
&lt;p&gt;　　总结的过程包括&lt;span&gt;&lt;em&gt;&lt;strong&gt;理论部分，练题目可以自己去leetcode/牛客网刷起来～&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第一篇文章讲排序～&lt;/p&gt;


&lt;p&gt;　　分为时间复杂度为 O（n的平方）的： &lt;span&gt;&lt;strong&gt;&lt;em&gt;冒泡排序、选择排序、插入排序&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;　　时间复杂度为 O（ n 乘 log N）的： &lt;strong&gt;&lt;em&gt;&lt;span&gt;归并排序、快速排序、堆排序、希尔排序&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　时间复杂度为 O（n）的排序算法：&lt;strong&gt;&lt;em&gt;&lt;span&gt;计数排序算法、基数排序算法;&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1.1  冒泡排序&lt;/h2&gt;
&lt;p&gt;　　冒泡排序的时间复杂度为 O（n的平方）。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 0 4 1 2&lt;/p&gt;
&lt;p&gt;　　冒泡排序思路：（对比下图来看）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次交换区间是0～N-1，第一和第二个数字进行比较，大的数字放在后面;接着第二第三个数字进行比较，同样，大的放在后面。如此，依次进行交换，直到换到最后一个数N-1。这样，最大的数字就到了N-1位置;&lt;/li&gt;
&lt;li&gt;第二次交换的区间变为0～N-2（最后一个数字不需要再移动了），比较方法类似步骤一;最后，第二大的数字到达了N-2的位置;&lt;/li&gt;
&lt;li&gt;依次交换，直到最后一次交换区间变为0，整个数组此时已经变得有序，结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　图画得有点丑，将就着看吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180124153044537-1645511345.png&quot; alt=&quot;&quot; width=&quot;239&quot; height=&quot;342&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.2  选择排序&lt;/h2&gt;
&lt;p&gt;　　选择排序的时间复杂度为 O（n的平方）。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 0 4 1 2&lt;/p&gt;
&lt;p&gt;　　选择排序思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次在区间0～N-1中，选出数组的最小值放到位置0上;&lt;/li&gt;
&lt;li&gt;第二次在在区间1～N-1中，选出最小值放到位置1上;&lt;/li&gt;
&lt;li&gt;依次选择，直到最后选择到最后的数值，放到N-1位置上;结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　这个图画得好看点儿了吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180124233553272-1559900579.png&quot; alt=&quot;&quot; width=&quot;274&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.3  插入排序&lt;/h2&gt;
&lt;p&gt;　　插入排序的时间复杂度为 O（n的平方）。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 0 4 1 2&lt;/p&gt;
&lt;p&gt;　　插入排序思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次，对第0和第1位置上的数字进行比较小放左边（前），大的方右边（后）;&lt;/li&gt;
&lt;li&gt;第二次，对第1位置和第2位置进行比较，选出较小值放到位置1上，较大值也就到了第2位置;这个时候需要对第1位置和第2位置再次进行比较，最小的放到最前;&lt;/li&gt;
&lt;li&gt;依次比较下去，直到最后比较到最后的第N-1位置的数值和第N-2位置大的数值比较，较小的依次与前面的各个位置比较置换，比较到第0和第1位置之后结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　画图好麻烦啊！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180124235713834-129170454.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.4  归并排序&lt;/h2&gt;
&lt;p&gt;　　归并排序的时间复杂度为  O（ n 乘 log N）。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 8 4 1 2&lt;/p&gt;
&lt;p&gt;　　归并排序思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一次，把划分成为N个小区间;相邻两两区间进行合并，得到N/2个有序区间&lt;/li&gt;
&lt;li&gt;第二次，把相邻的区间再次合并，得到N/4个有序区间;&lt;/li&gt;
&lt;li&gt;依次类推，直到把最后两个有序区间合并成一个区间，结束;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180125002615131-2140229362.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;364&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.5  快速排序（划重点！！！很重要）&lt;/h2&gt;
&lt;p&gt;　　快速排序的时间复杂度为 O（ n 乘 log N）。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 0 4 1 2&lt;/p&gt;
&lt;p&gt;　　快速排序思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随机选择数组中的一个元素，把小于等于该数的元素统一放在数组的左边，大于该数的元素放在数组的右边;&lt;/li&gt;
&lt;li&gt;分别对左右两个部分，再次采用快排思路，随机在期间找一个元素，同样，大于的右侧，小于等于的放在左侧;&lt;/li&gt;
&lt;li&gt;依次递归下去，完成排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　画图好麻烦啊！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180125004500147-1098218991.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.6  堆排序&lt;/h2&gt;
&lt;p&gt;　　堆排序的时间复杂度为 O（ n 乘 log N）。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 0 4 1 2&lt;/p&gt;
&lt;p&gt;　　堆排序思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将堆写成由大到小的堆分支;堆顶为最大值&lt;/li&gt;
&lt;li&gt;将堆顶元素提出，堆顶元素放到右侧，脱离堆;&lt;/li&gt;
&lt;li&gt;将新的堆（N-1个元素）进行调整，重复步骤1、2，直到完成最后一个元素，结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　画图好麻烦啊！！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180125023621912-266289688.png&quot; alt=&quot;&quot; width=&quot;377&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.7  希尔排序&lt;/h2&gt;
&lt;p&gt;　　希尔排序的时间复杂度为 O（ n 乘 log N）。希尔排序是插入排序的一种改良做法。&lt;/p&gt;
&lt;p&gt;　　插入排序前面已经介绍过了，可以知道，插入排序是1位一位往前比较的（步长为1）。而希尔排序初始步长为 &amp;gt;1,遍历结束之后步长减少1，直到最后步长为1时遍历完成，这样结束。&lt;/p&gt;
&lt;p&gt;　　例如一个数组：    7 3 5 6 0 4 1 2&lt;/p&gt;
&lt;p&gt;　　希尔排序思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;假设初始步长为3（自己设置的），从第四位元素和第一位元素进行比较，大小为逆序则交换两者位置，大小为顺序则保留原位置;&lt;/li&gt;
&lt;li&gt;接着比较第5位和第2位（5往前跑步长3啊），同理，大小为逆序则交换两者位置，大小为顺序则保留原位置;&lt;/li&gt;
&lt;li&gt;依次类推，完成这一轮次的比较;&lt;/li&gt;
&lt;li&gt;接着降低步长变为2，同样的方法&lt;/li&gt;
&lt;li&gt;最后步长为1，遍历完成后结束排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 　　下面这个图做的是步长为3的，降低步长方法一致，这里不画了～&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180125031532725-1487500093.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.8  计数排序（源于桶排序思想）&lt;/h2&gt;
&lt;p&gt;　　时间复杂度为O（N）。举个例子说明他的思想。&lt;/p&gt;
&lt;p&gt;　　例如：对   张三（168）  李四（178）  王五（188）  的身高排序;&lt;/p&gt;
&lt;p&gt;　　其思路是，建立N个桶，比如100，101，102,...,199(共100个桶)，接着将张三，李四，王五放入自己对应的桶中。最后，依次将100～199桶中的数倒出来，也就得到了他们的身高顺序了。&lt;/p&gt;
&lt;p&gt;　　看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180125033406897-1485447599.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;155&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.9  基数排序 （源于桶排序思想）&lt;/h2&gt;
&lt;p&gt;　　数组元素本身，先按照个位进行排序，放入0～9号桶中;再按照十位排序，放到桶中，依次上升百位...&lt;/p&gt;
&lt;p&gt;　　例如： 对  011   014   023   072   084   101  进行排序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1194681/201801/1194681-20180125035953131-2080676377.png&quot; alt=&quot;&quot; width=&quot;564&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;



&lt;p&gt;　　空间复杂度：&lt;/p&gt;
&lt;table border=&quot;3&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;空间复杂度&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;O（1）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;插入排序、选择排序、冒泡排序、堆排序、希尔排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;O（log N）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;快速排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;O（N）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;归并排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;O（M）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;计数排序、基数排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; 　　稳定性：（是否破坏相邻性，破坏则不稳定）&lt;/p&gt;
&lt;table border=&quot;3&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;稳定的排序算法&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;插入排序、冒泡排序、归并排序、计数排序、基数排序、桶排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;不稳定的排序算法&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;希尔排序、选择排序、快速排序、堆排序&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

</description>
<pubDate>Wed, 24 Jan 2018 20:35:00 +0000</pubDate>
<dc:creator>Mairr</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mairr/p/8047905.html</dc:identifier>
</item>
<item>
<title>内核知识第12讲,SSDT表.以用户模式到系统模式的两种方式. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/8345598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/8345598.html</guid>
<description>

&lt;h2&gt;一丶IDT解析.&lt;/h2&gt;
&lt;p&gt;我们知道.IDT表中存放着各种中断信息.比如当我们调用int 3的时候,则会调用IDT表中的第三项来进行调用. 而函数地址则是操作系统给的.&lt;/p&gt;
&lt;p&gt;因为中断是CPU和操作系统通信的一种方式.&lt;/p&gt;
&lt;p&gt;查看IDTR  (IDT表)第三项.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124222325709-1117572429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDT首地址给出了,其中表项是7ff&lt;/p&gt;
&lt;p&gt;我们每一项是8个字节,所以 7ff/8 = 255 项.也就是IDT表中是0-256&lt;/p&gt;
&lt;p&gt;其中重要的是有个int 3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124222441412-614041977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对其 u,则可以看int 3的指令的.&lt;/p&gt;
&lt;p&gt;当然,我们也可以自己计算.不用通过  !idt 3给.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124222615006-699179467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们说过,IDT表中存放的是门描述符号,也就是说真正的函数地址我们要自己查分.拆分开和上面一样.&lt;/p&gt;
&lt;p&gt; ,可以简单看下下面这张表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124222821709-2091576735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中微软以前用到的是 2E的区域, 也就是说. 2E的表项是微软放函数地址的地方.&lt;/p&gt;
&lt;h2&gt;二丶查看int 2E 区域. 对其反汇编.&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124223030475-240096968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;API,是我们的 KiSystemService&lt;/p&gt;
&lt;p&gt;我们可以看一下 zw系列的API,其内部调用的就是这个.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124223135084-695540474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这个函数的作用,就是查表.取0环的函数地址.  上面的push 8就是函数的下表.&lt;/p&gt;
&lt;h3&gt;1.反汇编KiSystemService&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124223503928-1264070479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先通过汇编代码得出. 操作了FS,&lt;/p&gt;
&lt;p&gt;1.保存FS&lt;/p&gt;
&lt;p&gt;2.取得_KPRCB结构体中的第四项. 也就是CurrentThread.&lt;/p&gt;
&lt;p&gt;3.取得_KThread的 CPU运行模式.&lt;/p&gt;
&lt;p&gt;核心代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124224150365-165376282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 其中 EDI是我们传入的调用函数的序号.&lt;/p&gt;
&lt;p&gt;首先EDI右移8位. 并且and 30h,但是其实.微软这样做,主要是有两个表. 先看第一个表把.&lt;/p&gt;
&lt;p&gt;ESI + 0E0的位置.&lt;/p&gt;
&lt;p&gt;ESI =  当前的CurretThread, 当ESI + 0E0的时候,则会找到 KThread结构体的SSDT表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124224523444-313630555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;,我们进去内存查看.则可以看到SSDT表. 注意,是当前线程的SSDT表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124224624006-804128228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中第一项,是函数地址指针数组表,这里面存储的都是函数的地址, 而11c,则是函数指针数组的大小.  11c = 284项.&lt;/p&gt;
&lt;h3&gt;2.显示SSDT函数的反汇编.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180124230556053-182005197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进去函数指针表中,随便取出函数地址,则是一个函数.那么这个函数则是NT开头的函数.&lt;/p&gt;
&lt;p&gt;也就是说,我们的函数调用ZW函数的时候.会调用NT函数.&lt;/p&gt;
&lt;h2&gt;三丶快速调用&lt;/h2&gt;
&lt;p&gt;Syseneter指令, 我们从3环调用API的时候,底层会调用这个API指令.&lt;/p&gt;
&lt;p&gt;我们知道,ring3调用API的时候,会用INT 2E指令进行切换. 也就是说调用IDT表中的第2E项,也就是我们上面介绍的那个函数.&lt;/p&gt;
&lt;p&gt;但是这样现在不用这给了.原因是太慢了.&lt;/p&gt;
&lt;p&gt;int 2E调用图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180125004613787-1201194167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当切换函数的是否,会保存三环的栈,SS EIP CS 等等.而这些保存和恢复的时候.都会造成大量的内存访问.&lt;/p&gt;
&lt;p&gt;int 2E 切换图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1197364/201801/1197364-20180125004745365-285892438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是为了减少内存访问.所以CPU添加了新的指令以及新的寄存器.来保存这些内容.&lt;/p&gt;
&lt;p&gt;添加的寄存器:&lt;/p&gt;
&lt;p&gt;　　 MSR 174&lt;/p&gt;
&lt;p&gt;　　MSR  175&lt;/p&gt;
&lt;p&gt;　　MSR  176&lt;/p&gt;
&lt;p&gt; 174MSR寄存器,保存了0环的代码段.  而三环的代码段没有保存,原因是,采用GDT表的相邻结构.所以当切换的时候只需要加10或者-xx即可.&lt;/p&gt;
&lt;p&gt; 176MSR寄存器则保存了EIP&lt;/p&gt;
&lt;p&gt;至于参数,当返回的是时候则会放到EDX和ECX中.&lt;/p&gt;
&lt;h2&gt;四丶SSDT表,以及Show SSDT表.&lt;/h2&gt;
&lt;p&gt;什么事ShowSSDT表?&lt;/p&gt;
&lt;p&gt;在SSDT表中,API都是没有和UI相关的.但是微软为了支持UI,所以放到showSSDT表中了.&lt;/p&gt;

&lt;p&gt;首先SSDT表在XP中,是导出的. 到处的是一个全局变量.&lt;/p&gt;
&lt;p&gt;KeServicePescriPtorTable;&lt;/p&gt;
&lt;p&gt;我们可以在WinDbg中直接输入. u 或者dd一下都可以查看的.&lt;/p&gt;

&lt;p&gt;而SSDT表 -0x30,也就是就是全局的SSDT表.&lt;/p&gt;
&lt;p&gt;而全局的SSDT表+0x10就是ShowSSDT表了.&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jan 2018 17:16:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/8345598.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——25. 将源文件限制为单个顶级类 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8345179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8345179.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然Java编译器允许在单个源文件中定义多个顶级类，但这样做没有任何好处，并且存在重大风险。 风险源于在源文件中定义多个顶级类使得为类提供多个定义成为可能。 使用哪个定义会受到源文件传递给编译器的顺序的影响。&lt;/p&gt;
&lt;p&gt;为了具体说明，请考虑下面源文件，其中只包含一个引用其他两个顶级类（&lt;code&gt;Utensil&lt;/code&gt;和&lt;code&gt;Dessert&lt;/code&gt;类）的成员的&lt;code&gt;Main&lt;/code&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Main {

    public static void main(String[] args) {

        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在假设在&lt;code&gt;Utensil.java&lt;/code&gt;的源文件中同时定义了&lt;code&gt;Utensil&lt;/code&gt;和&lt;code&gt;Dessert&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Two classes defined in one file. Don't ever do this!

class Utensil {

    static final String NAME = &quot;pan&quot;;

}

class Dessert {

    static final String NAME = &quot;cake&quot;;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，main方法会打印&lt;code&gt;pancake&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在假设你不小心创建了另一个名为&lt;code&gt;Dessert.java&lt;/code&gt;的源文件，它定义了相同的两个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Two classes defined in one file. Don't ever do this!

class Utensil {

    static final String NAME = &quot;pot&quot;;

}

class Dessert {

    static final String NAME = &quot;pie&quot;;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你足够幸运，使用命令&lt;code&gt;javac Main.java Dessert.java&lt;/code&gt;编译程序，编译将失败，编译器会告诉你，你已经多次定义了类&lt;code&gt;Utensil&lt;/code&gt;和&lt;code&gt;Dessert&lt;/code&gt;。 这是因为编译器首先编译&lt;code&gt;Main.java&lt;/code&gt;，当它看到对&lt;code&gt;Utensil&lt;/code&gt;的引用（它在&lt;code&gt;Dessert&lt;/code&gt;的引用之前）时，它将在&lt;code&gt;Utensil.java&lt;/code&gt;中查找这个类并找到&lt;code&gt;Utensil&lt;/code&gt;和&lt;code&gt;Dessert&lt;/code&gt;。 当编译器在命令行上遇到&lt;code&gt;Dessert.java&lt;/code&gt;时，它也将拉入该文件，导致它遇到&lt;code&gt;Utensil&lt;/code&gt;和&lt;code&gt;Dessert&lt;/code&gt;的定义。&lt;/p&gt;
&lt;p&gt;如果使用命令&lt;code&gt;javac Main.java&lt;/code&gt;或&lt;code&gt;javac Main.java Utensil.java&lt;/code&gt;编译程序，它的行为与在编写&lt;code&gt;Dessert.java&lt;/code&gt;文件（即打印&lt;code&gt;pancake&lt;/code&gt;）之前的行为相同。 但是，如果使用命令&lt;code&gt;javac Dessert.java Main.java&lt;/code&gt;编译程序，它将打印&lt;code&gt;potpie&lt;/code&gt;。 程序的行为因此受到源文件传递给编译器的顺序的影响，这显然是不可接受的。&lt;/p&gt;
&lt;p&gt;解决这个问题很简单，将顶层类（如我们的例子中的&lt;code&gt;Utensil&lt;/code&gt;和&lt;code&gt;Dessert&lt;/code&gt;）分割成单独的源文件。 如果试图将多个顶级类放入单个源文件中，请考虑使用静态成员类（条目 24）作为将类拆分为单独的源文件的替代方法。 如果这些类从属于另一个类，那么将它们变成静态成员类通常是更好的选择，因为它提高了可读性，并且可以通过声明它们为私有（条目 15）来减少类的可访问性。下面是我们的例子看起来如何使用静态成员类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Static member classes instead of multiple top-level classes

public class Test {

    public static void main(String[] args) {

        System.out.println(Utensil.NAME + [Dessert.NAME](http://Dessert.NAME));

    }

    private static class Utensil {

        static final String NAME = &quot;pan&quot;;

    }

    private static class Dessert {

        static final String NAME = &quot;cake&quot;;

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个教训很清楚：&lt;strong&gt;永远不要将多个顶级类或接口放在一个源文件中&lt;/strong&gt;。 遵循这个规则保证在编译时不能有多个定义。 这又保证了编译生成的类文件以及生成的程序的行为与源文件传递给编译器的顺序无关。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 17:04:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8345179.html</dc:identifier>
</item>
<item>
<title>Hadoop 发行版本 Hortonworks 安装详解（二） 安装Ambari - 路过打个酱油</title>
<link>http://www.cnblogs.com/pandalee-oct/p/8344091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pandalee-oct/p/8344091.html</guid>
<description>&lt;p&gt;由于&lt;a href=&quot;http://www.cnblogs.com/pandalee-oct/p/8215298.html&quot; target=&quot;_blank&quot;&gt;上一步&lt;/a&gt;我们搭建了本地源，实际上yum是通过本地源安装的ambari-server，虽然也可以直接通过官方源在线安装，不过体积巨大比较费时。&lt;/p&gt;
&lt;p&gt;这里我选择头结点1作为安装ambari的服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y ambari-server
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ambari-server setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装过程大致需要4个步骤&lt;/p&gt;
&lt;p&gt;1.选择是否自定义守护用户账号，选否&lt;/p&gt;
&lt;p&gt;2.选择JDK版本，选哪个应该问题不大，选1（会自动下载安装包并安装，由于我之前手动下载过所以省去了下载的步骤）&lt;/p&gt;
&lt;p&gt;3.是否进行数据库高级配置，选否（随后会自动安装PostgreSQL数据库，而且很容易出现数据库安装完启动比较慢导致ambari-server设置程序报错退出，重来几次就好了）&lt;/p&gt;
&lt;p&gt;4.输入管理密码，用途不明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1307613/201801/1307613-20180124233247850-970062628.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面的错误很容易遇到，等设置程序报错退出之后重来就好了，见下图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1307613/201801/1307613-20180124233532490-316783366.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这步安装和设置结束，可以启动 ambari-server 服务了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ambari-server start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1307613/201801/1307613-20180124233319287-2100499111.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;相关文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/pandalee-oct/p/8215298.html&quot; target=&quot;_blank&quot;&gt; Hadoop 发行版本 Hortonworks 安装详解（一） 准备工作&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jan 2018 16:13:00 +0000</pubDate>
<dc:creator>路过打个酱油</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pandalee-oct/p/8344091.html</dc:identifier>
</item>
<item>
<title>vue引入新版 vue-awesome-swiper填坑 - CodingHot</title>
<link>http://www.cnblogs.com/stephentian/p/8344258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stephentian/p/8344258.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;为什么我的vue-awesome-swiper组件pagination小圆点不显示问题?&lt;/li&gt;
&lt;li&gt;为什么我的vue-awesome-swiper不会自动播放？&lt;/li&gt;
&lt;li&gt;为什么我的vue-awesome-swiper没有？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;h3 id=&quot;引入前面的步骤和往常一样&quot;&gt;引入（前面的步骤和往常一样）&lt;/h3&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li&gt;&lt;code&gt;npm install vue-awesome-swiper --save&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 main,js 里引入（全局）:&lt;br/&gt;&lt;code&gt;import VueAwesomeSwiper from 'vue-awesome-swiper'&lt;/code&gt;&lt;br/&gt;&lt;code&gt;Vue.use(VueAwesomeSwiper)&lt;/code&gt;&lt;br/&gt;&lt;code&gt;import 'swiper/dist/css/swiper.css'&lt;/code&gt;&lt;strong&gt;(css 不显示的问题可能就在这)&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;组件里引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import 'swiper/dist/css/swiper.css'    //在全局没引入，这里记得要！
import { swiper, swiperSlide } from 'vue-awesome-swiper'

export default {
  components: {
    swiper,
    swiperSlide
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;template：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;swiper :options=&quot;swiperOption&quot;&amp;gt;
&amp;lt;swiper-slide&amp;gt;I'm Slide 1&amp;lt;/swiper-slide&amp;gt;
&amp;lt;swiper-slide&amp;gt;I'm Slide 2&amp;lt;/swiper-slide&amp;gt;
&amp;lt;swiper-slide&amp;gt;I'm Slide 3&amp;lt;/swiper-slide&amp;gt;
&amp;lt;div class=&quot;swiper-pagination&quot;  slot=&quot;pagination&quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/swiper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;script：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default {
data() {
  return {
    swiperOption: {
      // 所有的参数同 swiper 官方 api 参数一样
      // 
    }
  }
},
...
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重点在于 swiperOption 里面的变化&lt;/strong&gt;，区别看下图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1186800/201801/1186800-20180125001115553-554250296.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;原来 pagination 和 autoplay 要这样配置！&lt;/strong&gt;&lt;br/&gt;我原来就是在这两处错了，导致 pagination 不显示，图片不轮播。&lt;/p&gt;
&lt;p&gt;出错前：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1186800/201801/1186800-20180125001123412-317281551.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;纠正后：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1186800/201801/1186800-20180125001129725-1017038565.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;vue-awesome-swiper官网其实早放出说明来了，但自己一看全是英文，就没想看下去。后来发其实很容易看懂得，吸取教训自己多去看看文档，不要找 demo 去抄。&lt;/li&gt;
&lt;li&gt;还是少依靠插件，有些插件随时更新，等有能力，自己造！&lt;br/&gt;弄到晚上12点，才弄明白原来 Swiper 版本区分了组件和普通版本，不能看照原来的经验写了。&lt;br/&gt;发现网上关于最新 vue-awesome-swiper就两三篇，而且没说清楚。于是写下这篇，希望对大家有帮助。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 24 Jan 2018 16:13:00 +0000</pubDate>
<dc:creator>CodingHot</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stephentian/p/8344258.html</dc:identifier>
</item>
<item>
<title>TCP协议中三次握手 - 吴贤强</title>
<link>http://www.cnblogs.com/wuxianqiang/p/8344138.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuxianqiang/p/8344138.html</guid>
<description>&lt;p&gt;TCP/IP是互联网相关的各类协议族的总称&lt;/p&gt;

&lt;p&gt;TCP/IP协议族分为：应用层，传输层，网络层，数据链路层&lt;/p&gt;

&lt;p&gt;应用层：向用户提供应用服务时的通讯的活动&lt;/p&gt;
&lt;p&gt;传输层：提供处于网络连接中的两台计算机之间的数据传输&lt;/p&gt;
&lt;p&gt;网络层：处理网络上的流动数据包&lt;/p&gt;
&lt;p&gt;数据链路层：处理连接网络的硬件部分&lt;/p&gt;

&lt;p&gt;TCP位于传输层，提供可靠的字节流服务（字节流服务：将大块的数据分割成以报文段为单位的数据包进行管理），可靠的传输服务是指能够把数据可靠的传给对方&lt;/p&gt;
&lt;p&gt;，&lt;/p&gt;
&lt;p&gt;TCP协议的三次握手&lt;/p&gt;
&lt;p&gt;发送端标有SYN标志的数据包发送给接收端，接收端发送标志SYN/ACk的数据包给发送端（确认信息），发送端然后发送标志ACK的数据包给接收端（握手结束）&lt;/p&gt;

&lt;p&gt;TCP协议保证数据通讯的可靠性&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 16:01:00 +0000</pubDate>
<dc:creator>吴贤强</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuxianqiang/p/8344138.html</dc:identifier>
</item>
<item>
<title>012 继承和聚合的区别 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8344113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8344113.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;https://github.com/nnngu&quot;&gt;nnngu&lt;/a&gt;&lt;br/&gt;GitHub：&lt;a href=&quot;https://github.com/nnngu&quot; class=&quot;uri&quot;&gt;https://github.com/nnngu&lt;/a&gt;&lt;br/&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/nnngu/&quot;&gt;http://www.cnblogs.com/nnngu&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;https://www.jianshu.com/users/1df20d76ea5c&quot; class=&quot;uri&quot;&gt;https://www.jianshu.com/users/1df20d76ea5c&lt;/a&gt;&lt;br/&gt;知乎：&lt;a href=&quot;https://www.zhihu.com/people/nnngu/posts&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/people/nnngu/posts&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;p&gt;指的是一个类继承另外的一个类的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516808461696.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;聚合&quot;&gt;聚合&lt;/h2&gt;
&lt;p&gt;聚合体现的是整体与部分、拥有的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期；比如计算机与CPU、公司与员工的关系等；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.github.com/nnngu/FigureBed/raw/master/2018/1/24/1516808836569.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 15:51:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8344113.html</dc:identifier>
</item>
<item>
<title>用于 C&amp;sharp; 图像识别的轮廓分析技术 - GPA</title>
<link>http://www.cnblogs.com/academy/p/contour-analysis-for-image-recognition-in-csharp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/academy/p/contour-analysis-for-image-recognition-in-csharp.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;供稿：Conmajia&lt;/p&gt;
&lt;p&gt;标题：Contour Analysis for Image Recognition in C#&lt;/p&gt;
&lt;p&gt;作者：Pavel Torgashov&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此中文版翻译已获作者本人授权.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Jan. 23rd，2018&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231308772-944086904.png&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图 1 本文提供的范例程序截图&lt;/center&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文阐述了轮廓分析 (Contour Analysis，以下简称 CA) 的理论基础以及它在图像识别方面的实际应用. 文章末尾提供了一个处理 CA 的库文件和一个范例 (参见图 1).&lt;/p&gt;
&lt;p&gt;文章第一部分给出了 CA 的定义和相关定理. 笔者尝试尽量用精简的语言对 CA 进行概要说明，以使读者能尽快理解 CA 的理论基础并加以应用. 同时，笔者提出了一些自己的思考，试图将文章核心聚焦于 CA 理论的部分方面和算法优化上. 第二部分在此基础上对算法进行了阐述.&lt;/p&gt;
&lt;p&gt;第三部分是对 C♯ 专用库 &lt;code&gt;ContourAnalysis&lt;/code&gt; 的说明.&lt;/p&gt;
&lt;h2 id=&quot;第一部分-轮廓分析基础&quot;&gt;第一部分 轮廓分析基础&lt;/h2&gt;
&lt;h3 id=&quot;为什么需要轮廓分析&quot;&gt;为什么需要轮廓分析&lt;/h3&gt;
&lt;p&gt;CA 允许对物体呈现的外部边界——即轮廓——进行描述、存储、比较和查找. 它假定此轮廓已包含有物体形状的必要信息，而不考虑物体内部的点. 对于图像，CA 将分析从 2 维空间限定到轮廓空间上可降低计算强度及算法的复杂性. 由此，CA 便可高效地解决模式识别的主要问题：图像物体的换位、旋转及重设大小. 对这些变换而言，CA 方法是不变的.&lt;/p&gt;
&lt;h3 id=&quot;主要概念&quot;&gt;主要概念&lt;/h3&gt;
&lt;p&gt;首先，定义物体的轮廓.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;轮廓&lt;/strong&gt;是物体的边界，一组可将物体从背景中分离出来的点 (像素) 的集合.&lt;/p&gt;
&lt;p&gt;在计算机视觉系统中，经常用到多种编码格式来记录轮廓，如 Freeman 编码、2 维编码、多项式编码等. 但在本文讲述的轮廓分析中，不使用上述任何一种编码.&lt;/p&gt;
&lt;p&gt;作为替代，笔者使用一组复数序列对轮廓进行编码. 对某一轮廓而言，假定其上一点为&lt;em&gt;起点&lt;/em&gt;，将该点固定. (顺时针或逆时针地) 遍历轮廓上的点，记录每个点相对于它前一个点偏移量，用复数 &lt;span class=&quot;math inline&quot;&gt;\(a+\mathbf{i}b​\)&lt;/span&gt; 表示&lt;em&gt;偏移向量&lt;/em&gt;，&lt;span class=&quot;math inline&quot;&gt;\(a​\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(x​\)&lt;/span&gt; 轴方向上的偏移量，&lt;span class=&quot;math inline&quot;&gt;\(b​\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(y​\)&lt;/span&gt; 轴方向上的偏移量. 图 2 展示了一个简单的例子.&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231251475-281031777.jpg&quot;/&gt;&lt;/center&gt;
&lt;center&gt;图 2 使用复数表示偏移向量&lt;/center&gt;
&lt;p&gt;考虑到 3 维物体的物理实际，它们的轮廓不会内交，并且轮廓的最后一点总是与起点重合. 这保证了上述编码方法可以唯一地表示一个轮廓.&lt;/p&gt;
&lt;p&gt;在这里，定义轮廓上的一个偏移向量为&lt;em&gt;基础向量&lt;/em&gt; (elementary vector)，简称 EV，用小写希腊字母表示；由 EV 所组成的复数序列称为&lt;em&gt;向量轮廓&lt;/em&gt; (vector contour)，简称 VC，用大写希腊字母表示.&lt;/p&gt;
&lt;p&gt;这样，长度为 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的向量轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 可以表示为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Gamma=(\gamma_0,\gamma_1,\cdots,\gamma_{k-1}) \]&lt;/span&gt;&lt;br/&gt;之所以采用复数编码，是因为对向量进行运算相对于其他直接计算轮廓的编码方式，在不增加额外计算负担和复杂性的基础上，可以保留可观的轮廓数学信息.&lt;/p&gt;
&lt;p&gt;基本上，复数编码非常接近 2 维编码，后者将轮廓定义为一组 2 维空间中的坐标. 然而在处理点积上二者是不同的.&lt;/p&gt;
&lt;h3 id=&quot;轮廓的性质&quot;&gt;轮廓的性质&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;闭合轮廓的所有 EV，其和为零. EV 最终指向起点，它们的和是一个零向量.&lt;/li&gt;
&lt;li&gt;轮廓向量不依赖于源图像的平行换位. 由于轮廓是相对于起点编码的，所以这种编码方式不会因初始轮廓而改变.&lt;/li&gt;
&lt;li&gt;图像旋转相当于对轮廓上所有 EV 旋转同一角度.&lt;/li&gt;
&lt;li&gt;改变起点不会改变 VC. EV 是相对于它之前的一点而编码，显然改变起点后，整个轮廓的 EV 序列除了起点位置外不会有任何改变.&lt;/li&gt;
&lt;li&gt;源图像缩放可认为是对轮廓中每个 EV 与缩放因子的乘积.&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;轮廓的点积&quot;&gt;轮廓的点积&lt;/h3&gt;
&lt;p&gt;考虑轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 和轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 的点积，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \eta=(\Gamma,N)=\sum_{n=0}^{k-1}(\gamma_n,\upsilon_n) \tag{1} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 是向量轮廓 VC 的维数；&lt;span class=&quot;math inline&quot;&gt;\(\gamma_n\)&lt;/span&gt; 是轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 的第 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 EV；&lt;span class=&quot;math inline&quot;&gt;\(\upsilon_n\)&lt;/span&gt; 是轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 的第 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个 EV. 复数点积 &lt;span class=&quot;math inline&quot;&gt;\((\gamma_n,\upsilon_n)\)&lt;/span&gt; 计算方法为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ (a+\mathbf{i}b,c+\mathbf{i}d)=(a+\mathbf{i}b)\cdot(c-\mathbf{i}d)=ac+bd+\mathbf{i}(bc-ad) \tag{2} \]&lt;/span&gt;&lt;br/&gt;需要注意，在 CA 中计算轮廓的点积时，各轮廓维数必须一致，即 EV 的数量应相等.&lt;/p&gt;
&lt;p&gt;将两个 EV 作为简单向量相乘，其点积为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left((a,b),(c,d)\right)=ac+bd \tag{3} \]&lt;/span&gt;&lt;br/&gt;比较式 &lt;span class=&quot;math inline&quot;&gt;\((2)\)&lt;/span&gt; 和式 &lt;span class=&quot;math inline&quot;&gt;\((3)\)&lt;/span&gt;，可以发现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;向量的点积结果为实数，复数的乘积为复数.&lt;/li&gt;
&lt;li&gt;复数点积的实数部分与对应向量的点积相等.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据线性代数知识，向量的点积等于其夹角的余弦. 这意味着两个垂直的向量其点积总是为零，同向的两个向量其点积最大.&lt;/p&gt;
&lt;p&gt;向量乘积的这些性质，使得它可以用来衡量向量之间的接近程度. 乘积值越大，说明向量间夹角越小，即它们&lt;em&gt;越接近&lt;/em&gt;. 互相垂直的向量其乘积为零，随着夹角继续增大，其乘积为负值，直到&lt;em&gt;再次平行时&lt;/em&gt;得到最大值 (绝对值). 式 &lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt; 显然也具有与此相同的性质.&lt;/p&gt;
&lt;p&gt;接下来引入&lt;strong&gt;归一化点积&lt;/strong&gt; (Normalized Scalar Product，NSP) 的概念：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \eta=\frac{(\Gamma,N)}{|\Gamma||N|} \tag{4} \]&lt;/span&gt;&lt;br/&gt;模 &lt;span class=&quot;math inline&quot;&gt;\(|\Gamma|\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(|N|\)&lt;/span&gt; 计算方法为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ |\Gamma|=\left(\sum_{n=0}^{k-1}|\gamma_n|^2\right)^{\frac{1}{2}} \tag{5} \]&lt;/span&gt;&lt;br/&gt;复数空间中的 NSP 亦为复数.&lt;/p&gt;
&lt;p&gt;于是，NSP 归一化的最大可能值为单位向量 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt; (|&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}|=1\)&lt;/span&gt;)，且仅在&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Gamma=\mu N \tag{6} \]&lt;/span&gt;&lt;br/&gt;时成立. 式中 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; 为任意复数.&lt;/p&gt;
&lt;p&gt;我们知道，两个复数相乘，相当于它们的长度相乘 (缩放)，幅角相加 (旋转). 式 &lt;span class=&quot;math inline&quot;&gt;\((6)\)&lt;/span&gt; 中轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\mu N\)&lt;/span&gt; 即表示轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 被旋转和缩放 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; 后的结果.&lt;/p&gt;
&lt;p&gt;所以对 NSP 而言，当且仅当轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 和轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 为相同轮廓时——可以按一定系数旋转或缩放——其模达到最大.&lt;/p&gt;
&lt;p&gt;如表 1 所示例子. 假设两个同样的轮廓进行点积运算，可得 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=1\)&lt;/span&gt;. 将其中一个旋转 &lt;span class=&quot;math inline&quot;&gt;\(90^\circ\)&lt;/span&gt;，可得 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=0+\mathbf{i}\)&lt;/span&gt;. 旋转 &lt;span class=&quot;math inline&quot;&gt;\(180^\circ\)&lt;/span&gt; 则得 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=-1\)&lt;/span&gt;. 于是，NSP 的实数部分给出了轮廓夹角的余弦值，而模 &lt;span class=&quot;math inline&quot;&gt;\(|\mathrm{NSP}|\)&lt;/span&gt; 恒等于 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;.&lt;/p&gt;
&lt;center&gt;表 1 轮廓归一化点积的性质&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231226475-1191236655.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;类似的，由式 &lt;span class=&quot;math inline&quot;&gt;\((4)\)&lt;/span&gt; 可知，如果增加某个向量轮廓的缩放因数，仍有 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}=1\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论 1&lt;/strong&gt; NSP 的模不随换位、旋转或缩放而改变.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;故而仅当两个轮廓在旋转方向和缩放大小均相同时，其 NSP 为 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt;，否则均小于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt;. 实际上，NSP 的模与其换位、旋转或缩放等变换均无关. 类似的，如果轮廓处于变化中，则它们的 NSP 必小于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{E}\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论 2&lt;/strong&gt; NSP 的模体现了轮廓之间的接近程度.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;轮廓的相关函数&quot;&gt;轮廓的相关函数&lt;/h3&gt;
&lt;p&gt;上一节，我们确立了 NSP 在轮廓相似性判断中的作用. 然而要使用这一性质，取决于对起点的选取.&lt;/p&gt;
&lt;p&gt;式 &lt;span class=&quot;math inline&quot;&gt;\((6)\)&lt;/span&gt; 仅当轮廓的起点一致时成立. 如果轮廓唯一，但 EV 所参考的起点不同，则其 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{NSP}\ne\mathbf{E}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;下面引入一个新的概念，两个轮廓的&lt;strong&gt;内相关函数&lt;/strong&gt; (intercorrelation function，ICF)：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tau(m)=(\Gamma,N^{(m)}), \qquad m=0,1,\cdots,k-1 \tag{7} \]&lt;/span&gt;&lt;br/&gt;式中 &lt;span class=&quot;math inline&quot;&gt;\(N^{(m)}\)&lt;/span&gt; 是轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 循环移位 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次得到的 EV.&lt;/p&gt;
&lt;p&gt;例如，&lt;span class=&quot;math inline&quot;&gt;\(N=(n_1,n_2,n_3,n_4)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(N^{(1)}=(n_2,n_3,n_4,n_1)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(N^{(2)}=(n_3,n_4,n_1,n_2)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;ICF 揭示了轮廓 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma\)&lt;/span&gt; 和轮廓 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 在移位 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 次时的相似程度. 它是 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的周期函数，所以我们限制 &lt;span class=&quot;math inline&quot;&gt;\(m\in[0,k-1]\)&lt;/span&gt;. 显然有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tau_{\mathrm{max}}=\max\left(\frac{\tau(m)}{|\Gamma||N|}\right),\qquad m=0,1,\cdots,k-1 \tag{8} \]&lt;/span&gt;&lt;br/&gt;综上，模 &lt;span class=&quot;math inline&quot;&gt;\(|\tau_{\mathrm{max}}|\)&lt;/span&gt; 表示了两个轮廓的相似度，并当轮廓相同时，&lt;span class=&quot;math inline&quot;&gt;\(|\tau_{\mathrm{max}}|=\mathbf{E}\)&lt;/span&gt;. 夹角 &lt;span class=&quot;math inline&quot;&gt;\(\arg(\tau_{\mathrm{max}})\)&lt;/span&gt; 给出了一个轮廓相对另一个的夹角.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;结论 3&lt;/strong&gt; ICF 模最大值表示了两个轮廓的相似度.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论 4&lt;/strong&gt; ICF 模的最大值不受换位、缩放、旋转或起点移位的影响.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另一个新概念是&lt;strong&gt;自相关函数&lt;/strong&gt; (autocorrelation function，ACF). ACF 实际是 ICF 在 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma=N\)&lt;/span&gt; 时的特例，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \upsilon(m)=(\Gamma,\Gamma^{(m)}),\qquad m=0,1,\cdots,k-1 \tag{9} \]&lt;/span&gt;&lt;br/&gt;下面考察 ACF 的性质.&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231333365-306541320.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;图 3 自相关函数的性质&lt;/center&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ACF 与轮廓起点选取无关. 由式 &lt;span class=&quot;math inline&quot;&gt;\((1)\)&lt;/span&gt; 可知，起点的变化不会导致 &lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt; 改变，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ACF 由轮廓 EV 两两相乘得到，在 &lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 范围内对称分布，对称点为 &lt;span class=&quot;math inline&quot;&gt;\(k/2\)&lt;/span&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(N=(n_1,n_2,n_3,n_4)\)&lt;/span&gt;，可以写出其对不同 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 的 ACF：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(0)=(n_1,n_1)+(n_2,n_2)+(n_3,n_3)+(n_4,n_4)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(1)=(n_1,n_2)+(n_2,n_3)+(n_3,n_4)+(n_4,n_1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(2)=(n_1,n_3)+(n_2,n_4)+(n_3,n_1)+(n_4,n_2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(3)=(n_1,n_4)+(n_2,n_1)+(n_3,n_2)+(n_4,n_3)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(4)=(n_1,n_1)+(n_2,n_2)+(n_3,n_3)+(n_4,n_4)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可知 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{ACF}(1)=\mathrm{ACF}(3)^*\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\because |a^*|=|a|\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\therefore |\mathrm{ACF}(1)|=|\mathrm{ACF}(3)|\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;类似的，&lt;span class=&quot;math inline&quot;&gt;\(|\mathrm{ACF}(0)|=|\mathrm{ACF}(4)|\)&lt;/span&gt;.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由图 4 可以看出，除最后一幅图像外，前 3 幅图像其 ACF——用蓝色表示——均关于 &lt;span class=&quot;math inline&quot;&gt;\(k/2\)&lt;/span&gt; 对称.&lt;/li&gt;
&lt;/ol&gt;&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1108150/201801/1108150-20180124231346959-840354992.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;br/&gt;&lt;center&gt;&lt;br/&gt;图 4 轮廓 ACF 示例&lt;/center&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在某种意义上，可以认为轮廓的 ACF 代表了轮廓的形状特性.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对 ACF 取模无关于其缩放、位置、旋转或是起点的选取.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上即是 CA 的理论部分. 在这一部分，笔者为了引入下一部分模式识别，只介绍了较为重要的相关概念和理论计算.&lt;/p&gt;
&lt;h2 id=&quot;第二部分-轮廓分析的实际应用&quot;&gt;第二部分 轮廓分析的实际应用&lt;/h2&gt;
&lt;h3 id=&quot;通用识别算法&quot;&gt;通用识别算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(未完待续)&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 15:33:00 +0000</pubDate>
<dc:creator>GPA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/academy/p/contour-analysis-for-image-recognition-in-csharp.html</dc:identifier>
</item>
<item>
<title>LockSupport理解 - chen_yong</title>
<link>http://www.cnblogs.com/hupu-jr/p/8344009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hupu-jr/p/8344009.html</guid>
<description>&lt;p&gt;一、背景&lt;/p&gt;
&lt;p&gt;在看并发包源码的时候看见过LockSupport,今天恰巧看到LockSupport字眼,于是看下jdk1.7中的源码结构。想着它应该是运用多线程的锁工具的，到底似乎怎么实现的呢？&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二、使用&lt;/p&gt;
&lt;p&gt;于是自己写个demo对比下synchronized&lt;/p&gt;
&lt;p&gt;场景：main线程中创建一个线程A,想让threadA 循环完毕的时候先阻塞，然后再main线程中释放。&lt;/p&gt;
&lt;p&gt;1.控制多线程并发：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        generalSync(obj);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        obj.notifyAll();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         System.out.println(&quot;主线程执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; generalSync(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object obj) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;　　　　　　　　　　　　　System.out.println(i);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 System.out.println(&quot;循环完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    obj.wait();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 System.out.println(&quot;线程A执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        threadA.start();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个最终结果是什么呢情？&lt;strong&gt;会以异常结束：java.lang.IllegalMonitorStateException，&lt;/strong&gt; &lt;strong&gt;产生的原因是Object的wait,notify,notifyAll方法必须在同步块中执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.使用synchronized但主线程接触阻塞在threadA阻塞执行之前&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Object obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        generalSync(obj);&lt;br/&gt;　　　　　　　// Thread.sleep(1000);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (obj) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            obj.notifyAll();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;主线程执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; generalSync(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object obj) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    System.out.println(i);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 System.out.println(&quot;循环完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (obj) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                        obj.wait();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 System.out.println(&quot;线程A执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        threadA.start();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面会导致一直阻塞，因为主线程在第3行开启一个threadA后，就往下执行4~7代码，而threadA需要循环所用的时间更久。因此会先调用obj.notifyAll()，然后再obj.wait()导致&lt;strong&gt;调用顺序错误一直阻塞&lt;/strong&gt;。想要达到我们预期的目的，根据threadA时间，可以在第4行添加Thread.sleep(1000)使主线程中的obj.notifyAll()晚于obj.wait()执行。&lt;/p&gt;
&lt;p&gt;3.使用LockSupport来实现同步&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Thread threadA =&lt;span&gt; generalSync();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        LockSupport.unpark(threadA);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         System.out.println(&quot;主线程执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Thread generalSync() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Runnable runnable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    System.out.println(i);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 System.out.println(&quot;循环完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                LockSupport.park();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 System.out.println(&quot;线程A执行完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(runnable);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        threadA.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; threadA;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过LockSupport无需关于阻塞和释放的调用先后问题，仅仅通过park/unpark即可阻塞或释放。&lt;strong&gt;park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;三、阅读源码&lt;/p&gt;
&lt;p&gt;通过类注释介绍，LockSupport是JDK中比较底层的类，&lt;strong&gt;用来创建锁和其他同步工具类的基本线程阻塞原语&lt;/strong&gt;。java锁和同步器框架的核心 AQS: AbstractQueuedSynchronizer，就是通过调用 LockSupport .park()和 LockSupport .unpark()实现线程的阻塞和唤醒 的，下面重点关注着2个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockSupport {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LockSupport() {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot be instantiated.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hotspot implementation via intrinsics API&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Unsafe unsafe =&lt;span&gt; Unsafe.getUnsafe();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; parkBlockerOffset;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.根据上面的类定义，内部构造方法私有化，外部类无法实例，作为工具类使用的意图。类中实例化了一个Unsafe这个可直接操作内存的本地API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; park(Object blocker) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Thread t =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        setBlocker(t, blocker);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         unsafe.park(&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         setBlocker(t, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.阻塞是通过park方法，第2行获取当前线程；第3行执行setBlocker(Thread t, Object arg)，setBlocker从名字感觉设置阻塞的地方；第4行调用Unsafe中public native void park(boolean paramBoolean, long paramLong)产生阻塞；第5行调用setBlocker(Thread t, Object arg)，但是Object参数是null，此处应该是去除阻塞点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LockSupport {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LockSupport() {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cannot be instantiated.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hotspot implementation via intrinsics API&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Unsafe unsafe =&lt;span&gt; Unsafe.getUnsafe();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; parkBlockerOffset;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             parkBlockerOffset =&lt;span&gt; unsafe.objectFieldOffset
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 (java.lang.Thread.&lt;span&gt;class&lt;/span&gt;.getDeclaredField(&quot;parkBlocker&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (Exception ex) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(ex); }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBlocker(Thread t, Object arg) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Even though volatile, hotspot doesn't need a write barrier here.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        unsafe.putObject(t, parkBlockerOffset, arg);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.setBlocker是调用Unsafe中public native void putObject(Object paramObject1, long paramLong, Object paramObject2)方法，这个long类型paramLong传的是Thread在内存中的偏移量。通过8~13可以看出在静态代码块中通过Unsafe中public native long objectFieldOffset(Field paramField)来得到内存中位置（之前原子操作类也是通过此方法来获取偏移量）这个偏移量属性名称是&quot;&lt;strong&gt;parkBlocker&lt;/strong&gt;&quot;,类型从第11行可以知道&lt;strong&gt;parkBlocker是&lt;/strong&gt;&lt;strong&gt;java.lang.Thread&lt;/strong&gt;类中的一个属性，&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Thread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Make sure registerNatives is the first thing &amp;lt;clinit&amp;gt; does. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerNatives();
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        registerNatives();
    }

    ... ...
 &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The argument supplied to the current call to
     * java.util.concurrent.locks.LockSupport.park.
     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; Object parkBlocker;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个&lt;strong&gt;parkBlocker&lt;/strong&gt;应该是Thread&lt;strong&gt;类变量。&lt;/strong&gt;首先LockSupport 是构造方法私有化，类似一个工具类，而且parkBlockerOffset是static类型的，所以即使在多个场景下的多线程环境，不同的多个Thread调用setBlocker方法都只是针对Thread的类变量进行赋值（类变量只有一个）所以是多对一的关系。并且通过getBlocker源码注释可以看出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Returns the blocker object supplied to the most recent
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * invocation of a park method that has not yet unblocked, or null
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * if not blocked.  The value returned is just a momentary
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * snapshot -- the thread may have since unblocked or blocked on a
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * different blocker object.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t the thread
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the blocker
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if argument is null
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.6
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getBlocker(Thread t) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; unsafe.getObjectVolatile(t, parkBlockerOffset);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从注释看出“返回的是最近被阻塞的对象，类似一个瞬间的快照”，那么我理解Thread中Object parkBlocker属性可能会被多个线程赋值。这个属性跟并发阻塞并无关系，只是起到记录阻塞对象的作用。&lt;/p&gt;
&lt;p&gt; 至于Unsafe类中native方法，就没有去追究。看其他博客理解到的是：在hotspot里每个java线程都有一个Parker实例，Parker里使用了一个无锁的队列在分配释放Parker实例。Parker里面有个变量，&lt;span class=&quot;keyword&quot;&gt;volatile &lt;span class=&quot;datatypes&quot;&gt;int _counter 相当于许可，二元信号量（类似0和1）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;datatypes&quot;&gt;当调用park时，先尝试直接能否直接拿到“许可”（即_counter&amp;gt;0时）如果成功，则把_counter设置为0,并返回；如果不成功，则构造一个ThreadBlockInVM，然后检查_counter是不是&amp;gt;0，如果是，则把_counter设置为0&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;datatypes&quot;&gt;当unpark时，则简单多了，直接设置_counter为1，如果_counter之前的值是0，则还要调用唤醒在park中等待的线程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>chen_yong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hupu-jr/p/8344009.html</dc:identifier>
</item>
</channel>
</rss>