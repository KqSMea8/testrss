<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>回顾4180天在腾讯使用C#的历程，开启新的征途 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/9405102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/9405102.html</guid>
<description>&lt;p&gt;今天是2018年8月8日，已经和腾讯解除劳动关系，我的公司正式开始运营，虽然还有很多事情需要理清，公司官网也没有做，接下来什么事情都需要自己去完成了，需要一步一个脚印去完善，开启一个新的征途,我将在博客和公众号更新我的动态。&lt;/p&gt;
&lt;p&gt;昨天是星期二，我在腾讯这家优秀的公司工作的第4180天，这天我离开了腾讯。这次的离开是为了下次更好的相遇，每一次相遇都是久别重逢，只有离别，才会相思，有了相思，才会有激情，有了激情，才有了我们下次一见如故的感觉。回首整个职业生涯，见证了腾讯从小到大、从大到强的整个过程，个人非常幸运大部分职业生涯都在腾讯度过，也把最好的一段时间奉献给了腾讯这家伟大的公司。我也要说我为自己曾经为这家公司服务过而自豪，腾讯是那种你想为之工作的最优秀的公司。&lt;/p&gt;
&lt;p&gt;.NET如日中天时加入腾讯&lt;/p&gt;
&lt;p&gt;从大学毕业后，就开始接触C#这门优秀的语言，从一个菜鸟逐步成长为一个熟练使用C#语言的程序员，我在微软的技术社区里比较独具一格，我一直推广的是开源技术，我的引路人是大名鼎鼎的Linux桌面Gnome的创始人米格尔&lt;a href=&quot;https://en.wikipedia.org/wiki/Miguel_de_Icaza&quot;&gt;Miguel de Icaza&lt;/a&gt;，早在2000年米格尔为了Gnome 桌面寻找编程模型，开始了&lt;a href=&quot;https://zh.wikipedia.org/wiki/Mono&quot;&gt;Mono&lt;/a&gt;开源项目，我正是从Mono项目认识了C#，从此开始了Mono项目在中国的宣传，平时喜欢在博客上分享跟踪Mono项目进展，同时也进入了.NET开发社区，在2006年成为微软最有价值专家（MVP），那时腾讯也有几位微软最有价值专家，在社区活动中结识，2006年底通过toby的介绍，2007年2月26日在春节过后第一天入职腾讯。随后几年一直和toby 一起打造腾讯OA基础服务，简称TOF，我和TOF一起度过了8年时光。&lt;/p&gt;
&lt;p&gt;.NET的衰败中打造TOF&lt;/p&gt;
&lt;p&gt;我从参加工作以来就对C#有深度认同，它真是一门非常优秀的语言，从2007年加入公司到现在，我使用的主要开发语言都是C#，2007年的腾讯主要的开发语言是c/c++,C#。那时候大量的内网办公，运营系统使用.net构建的，一直持续到2009年后，公司的大规模扩展，逐步加入了大量的其他语言，比如Python，PHP，Java。大量新系统逐步采用这些新语言构建，因为大家认为c#只能跑在windows上，我还是坚持使用C#持续优化TOF，因为我所认为的C#是完全可以跑在Linux等非windows系统上的，当年主要是通过Mono项目来完成这一目标的，但是Mono项目是个完全开源社区的项目，当年公司还没有自己的tlinux，公司使用的Novell 的 Suse 企业版Linux，里面默认自带了Mono 运行环境的，公司的idc服务器上可能还存量少许的这类系统，大家可以输入命令mono瞧一瞧。Mono项目孕育了著名的游戏引擎Unity3D，IEG的大量手游都是基于Unity3D打造&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2010年开始已经出现一种迹象是，新的业务系统都使用新的语言开发，使用C#语言的系统逐渐减少，旧的系统也不断被重写替代了C#，在公司的2013年度代码报告中&lt;a href=&quot;http://code.oa.com/v2/report/2013&quot;&gt;http://code.oa.com/v2/report/2013&lt;/a&gt; ,前十已经找不到C#的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/510/201609/510-20160928083642781-1348992875.jpg&quot; alt=&quot;clip_image002&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而在2014年度的代码报告中&lt;a title=&quot;http://tech.it168.com/a2015/0310/1709/000001709985.shtml&quot; href=&quot;http://tech.it168.com/a2015/0310/1709/000001709985.shtml&quot;&gt;http://tech.it168.com/a2015/0310/1709/000001709985.shtml&lt;/a&gt; ，C#突然之间前进到了第八位置，代码量增长了2.2倍，主角就是基于Mono平台的Unity 游戏开发，是手游让C# 爆发了，也就是在2014年我完成了TOF的第三个版本的重构，把原来的多个版本逐步统一为一个版本，代码量删除了好几万行，性能提升到满足当前公司规模的应用水平，到2016年我转岗到FIT 时，TOF日均请求量已经超过5000W，公司有3000多个应用系统接入，服务于公司3W+员工，在转岗交接工作时，我写了一篇《&lt;a href=&quot;http://km.oa.com/group/TOF/articles/show/277366&quot;&gt;C# 在腾讯的发展&lt;/a&gt;》对大家了解C#这个语言有个更好的了解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/510/201609/510-20160928083643656-1551051430.jpg&quot; alt=&quot;clip_image004&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迎接.NET Core新时代&lt;/p&gt;
&lt;p&gt;2014年微软公司开始转型，鲍尔默退休，2014 年 2 月 4 日，微软宣布云计算部门副总裁萨蒂亚·纳德拉 (Satya Nadella) 出任公司首席执行官，在他看来未来将是移动和云时代，上任第一天的内部邮件中就明确的表示了自己的观点，未来希望通过软件驱动微软这艘大船，在云计算时代帮助微软取得更好的成绩。2014年11月微软宣布了.NET开源，不是简单的将原来绑定于windows的.NET 开放源代码，而是针对云原生应用重新设计的模块化，跨平台的.NET, 经过1年多的打造，在2016年6月发布了1.0版本。2016年9月我转岗到了FIT，我在这里和小伙伴们使用C#构建了几个.NET Core系统，完全跑在tlinux上面，从此我很少使用.net, 我都是使用.NET Core, 公司全面转向2B市场，年初有机会加入FIT金融云团队，耕耘保险行业，这半年时间里我依然使用.NET Core构建了好几个小系统。也就是这半年微软的市值攀升到了8200亿市值。在这3年时间里，我业余也运营了一个《dotnet跨平台》微信公众号，粉丝数3.9W，最近半年收到了更多积极的使用.NET Core的反馈，欢迎你来关注我的微信公众号。.NET Core能干的事情更多了，刚在2018年5月30日发布的.NET Core 2.1,性能得到进一步的提升，接近C++效率。 yuke在2016年12月写的这篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/12SuZw1m9DUZxdXLNsHvxA&quot;&gt;用.net core 写后端—— c++外的另一种选择？》&lt;/a&gt; ，有兴趣的同学可以看看，现今主流的平台都可以使用C#进行开发，俗称拥有七龙珠，我去召唤神龙：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/510/201808/510-20180807205215496-131777688.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/510/201808/510-20180807205216247-1484082199.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;441&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;离开腾讯召唤神龙&lt;/p&gt;
&lt;p&gt;我们已经完全进入云时代，国外AWS，Azure ，GCloud等都对.NET Core有一流的支持，然而众观国内无论是Aliyun，还是TencentCloud对.NET Core的支持体验都是完全不及格水平，这里面有很大的改进空间，在我离开腾讯的最后时间，有幸参与改进腾讯云 API 3.0的 .NET SDK, 昨天晚上同事zhiqiangfan已经把它开源发布到了github：&lt;a href=&quot;https://github.com/TencentCloud/tencentcloud-sdk-dotnet&quot;&gt;https://github.com/TencentCloud/tencentcloud-sdk-dotnet&lt;/a&gt; ，腾讯云 3.0 API的C# 版本将是支持跨平台的，可以完美运行于linux上，就像我在鹅厂所打造的系统都运行在tlinux上一样，我希望看到这篇文章的同事，能够认识到新的一代.NET Core是跨平台的，不是绑定Windows的。在腾讯有幸目睹了腾讯开源自下往上的工程师文化，接着我在离开腾讯会继续和腾讯开源合作, 第一个项目将是mig的tars： &lt;a href=&quot;https://github.com/Tencent/Tars&quot;&gt;https://github.com/Tencent/Tars&lt;/a&gt;， 公司最好用的rpc+管理平台，让它支持.netcore, 绝对是个出门创业的好东西，和大家透露一下，目前我们已经组建了社区6人团队在进行这项工作，6位分布在北京，广州，成都，深圳的.NET社区成员将在几个月内完成Tars支持.netcore的工作，到时欢迎大家加入一起完善 。&lt;/p&gt;
&lt;p&gt;离开腾讯的想法其实也很简单，人生需要不停刷新，这半年自从看了微软CEO Satya写的那本书《&lt;a href=&quot;https://item.jd.com/12260025.html&quot;&gt;刷新：重新发现商业与未来&lt;/a&gt;》，给我带来很大的心灵的震撼，他提出自我刷新的三个关键步骤：拥抱同理心，培养“无所不学”的求知欲，以及建立成长型思维。在此和兄弟姐妹分享这本书的两个公式：&lt;/p&gt;
&lt;p&gt;信任公式：&lt;br/&gt;同理心 + 共同的价值观 + 安全可靠 = 信任&lt;/p&gt;
&lt;p&gt;技术透明、安全共治、保卫云安全以及用户至上，是微软写就的技术道德。在书中，纳德拉列举了包括斯诺登棱镜门、2013年12月的毒品案、2015年12月加州恐怖袭击等在内的实例，以及微软与苹果等对手因为用户数据面临安全威胁时并肩站在同一个立场，从他细腻的描述中，我们似乎感受到了作为一家巨头公司CEO面临的压力及胆识、果敢&lt;/p&gt;
&lt;p&gt;成长公式:&lt;br/&gt;∑(教育+创新) x 科技使用强度 = 经济增长&lt;/p&gt;
&lt;p&gt;实现人人获益的经济增长，最近卖假货的拼多多上市了，有文章分析这才是真正的中国，充斥着假货，这就是现实，但我们更需要实现人人获益的经济增长，也就是在IT圈也是一样，在BATJ之外还有大量的普通的程序员，他们更需要高效好用的开发平台。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 23:01:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shanyou/p/9405102.html</dc:identifier>
</item>
<item>
<title>Python网络编程（socket模块、缓冲区、http协议） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9440561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9440561.html</guid>
<description>

&lt;p&gt;&lt;strong&gt;网络的概念&lt;/strong&gt;：主机   端口  IP  协议&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;          服务器:&lt;/li&gt;
&lt;li&gt;      localhost/127.0.0.1&lt;/li&gt;
&lt;li&gt;  客户端:&lt;/li&gt;
&lt;li&gt;      只是在本机启动客户端，用127.0.0.1访问&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;div&gt;
&lt;ul&gt;&lt;li&gt;  服务器:&lt;/li&gt;
&lt;li&gt;      0.0.0.0&lt;/li&gt;
&lt;li&gt;  客户端：&lt;/li&gt;
&lt;li&gt;      可以在本机用127.0.0.1、192.168.0.1&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;  服务器：&lt;/li&gt;
&lt;li&gt;      192.168.0.1&lt;/li&gt;
&lt;li&gt;  客户端：&lt;/li&gt;
&lt;li&gt;      局域网内用192.168.0.1&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;socket&lt;/strong&gt;（创建套接字） ---&amp;gt;&lt;strong&gt; bind&lt;/strong&gt;（绑定地址） ---&amp;gt; &lt;strong&gt;listen&lt;/strong&gt;（设置监听）---&amp;gt; &lt;strong&gt;accept&lt;/strong&gt;（等待链接） ---&amp;gt; &lt;strong&gt;recv/send&lt;/strong&gt;（收/发消息） ---&amp;gt; &lt;strong&gt;close&lt;/strong&gt; （）&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;收发函数特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt;recv&lt;/span&gt;&lt;/strong&gt;特征：&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;如果&lt;/strong&gt;建立的&lt;strong&gt;另一端链接被断开&lt;/strong&gt;， 则recv立即&lt;strong&gt;返回空字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;recv&lt;strong&gt;是&lt;/strong&gt;从&lt;strong&gt;接受缓冲区&lt;/strong&gt;取出&lt;strong&gt;内容&lt;/strong&gt;，当&lt;strong&gt;缓冲区为空则阻塞&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;recv如果&lt;strong&gt;一次接受不完&lt;/strong&gt;缓冲区的&lt;strong&gt;内容&lt;/strong&gt;，&lt;strong&gt;下次&lt;/strong&gt;执行&lt;strong&gt;会自动接受&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt;send&lt;/span&gt;特征：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;        如果发送的&lt;strong&gt;另一端不存在&lt;/strong&gt;则会&lt;strong&gt;产生Pipe Broken异常&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;send&lt;strong&gt;是&lt;/strong&gt;从&lt;strong&gt;发送缓冲区&lt;/strong&gt;发送&lt;strong&gt;内容，&lt;/strong&gt;当&lt;strong&gt;缓冲&lt;/strong&gt;区&lt;strong&gt;为满则堵塞&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;网络的收发缓存区：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;在内存&lt;/strong&gt;中开辟区域，用于&lt;strong&gt;发送和接受的缓冲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;        &lt;strong&gt;协调数据&lt;/strong&gt;的收发（&lt;strong&gt;接受和处理&lt;/strong&gt;）&lt;strong&gt;速度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;        &lt;strong&gt;减少&lt;/strong&gt;和&lt;strong&gt;磁盘的交互&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;sendall（date）：&lt;/p&gt;
&lt;p&gt;   功能：&lt;strong&gt;tcp&lt;/strong&gt;套接字发送消息&lt;/p&gt;
&lt;p&gt;   参数：同&lt;strong&gt;send&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   返回值：如果&lt;strong&gt;发送成功&lt;/strong&gt;则&lt;strong&gt;返回None&lt;/strong&gt;   &lt;strong&gt;否则返回异常&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;tcp粘包：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;产生原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        1.&lt;strong&gt;tcp&lt;/strong&gt;传输以&lt;strong&gt;字节流&lt;/strong&gt;的方式&lt;strong&gt;发送&lt;/strong&gt;消息，&lt;strong&gt;消息之间没有边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.发送比&lt;strong&gt;接受的速度快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   影响：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        对每次发送的内容是一个独立的意识需要单独识别时 容易使用原文件被更改&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;  如何处理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        1.每次发送后&lt;strong&gt;追加一个结尾标志&lt;/strong&gt;，代表本次发送完毕&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;发送&lt;/strong&gt;一个&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;每次&lt;/strong&gt;发送有一个&lt;strong&gt;时间间隔&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于udp的服务端编程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;1.创建套接字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        sockfd = socket（AF_INET，SOCK_DGRAM）&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;  2.绑定地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        sockfd.bind()&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;3.消息收发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        data, addr = sockfd.&lt;strong&gt;&lt;span&gt;recvfrom&lt;/span&gt;&lt;/strong&gt;(buffersize)&lt;/p&gt;
&lt;p&gt;         功能：接受udp消息&lt;/p&gt;
&lt;p&gt; 参数：接受消息的大小&lt;/p&gt;
&lt;p&gt; 返回值：&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt;data &lt;/span&gt;接受到的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;addr &lt;/strong&gt;消息发送的地址&lt;/p&gt;

&lt;p&gt;recvfrom每次接受一个报文，&lt;strong&gt;如果没有接受到的内容则直接丢弃&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        sockfd.&lt;strong&gt;&lt;span&gt;sendto&lt;/span&gt;&lt;/strong&gt;(data, addr)&lt;/p&gt;
&lt;p&gt;  功能：udp消息发送&lt;/p&gt;
&lt;p&gt;  参数：&lt;/p&gt;
&lt;p&gt;      data 要发送的内容 bytes&lt;/p&gt;
&lt;p&gt;      addr 目标地址&lt;/p&gt;
&lt;p&gt;  返回：发送字节数&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;  4.关闭套接字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        socket.close()&lt;/p&gt;


&lt;p&gt;import &lt;strong&gt;sys&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;sys.argv&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   作用：&lt;/p&gt;
&lt;p&gt;      获取从命令行获取的参数内容&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt; Python3 demo.py &lt;/strong&gt;参数1， 参数2.....&lt;/p&gt;

&lt;p&gt;      &lt;strong&gt;sys.argv[0] &lt;/strong&gt;是命令本身（程序本身）&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;tcp流式套接字和udp数据报套接字区别：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;    1.流式套接字采用&lt;strong&gt;字节流&lt;/strong&gt;的方式进行传输，&lt;/li&gt;
&lt;li&gt;       而数据报套接字使用&lt;strong&gt;数据报&lt;/strong&gt;形式传输数据&lt;/li&gt;
&lt;li&gt;    2.tcp套接字会产生&lt;strong&gt;粘包&lt;/strong&gt;，udp不会&lt;/li&gt;
&lt;li&gt;    3.tcp编程可以保证消息的&lt;strong&gt;完整性&lt;/strong&gt;，udp则不一定&lt;/li&gt;
&lt;li&gt;    4.tcp需要&lt;strong&gt;listen、accept、udp&lt;/strong&gt;不用&lt;/li&gt;
&lt;li&gt;    5.tcp消息的发送接收使用&lt;strong&gt;recv、send、sendall、&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;       udp使用&lt;strong&gt;recvfrom，sendto&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;socket模块&lt;/strong&gt;和&lt;strong&gt;套接字属性&lt;/strong&gt;（s为套接字）&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;  s.&lt;strong&gt;&lt;span&gt;type&lt;/span&gt;&lt;/strong&gt;：表示&lt;strong&gt;套接字类型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;  s.&lt;strong&gt;&lt;span&gt;family&lt;/span&gt;&lt;/strong&gt;：&lt;strong&gt;地址类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;  &lt;strong&gt;套接字属性方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;&lt;span&gt; s.fileno（）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;获取&lt;/strong&gt;套接字的&lt;strong&gt;文件描述符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;文件描述符：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     每一个IO事件 操作系统都会分配一个不同的的正整数，&lt;/p&gt;
&lt;p&gt;     该正整数即为此IO操作的文件描述符&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;默认开启的描述符：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;         sys.stdin      0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;         sys.stdout   1&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;         sys.stderr    2&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;  s.&lt;span&gt;getsockname&lt;/span&gt;（）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     功能：&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;获取套结字&lt;/strong&gt;绑定&lt;strong&gt;的地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  s.&lt;strong&gt;&lt;span&gt;getpeername&lt;/span&gt;&lt;/strong&gt;（）&lt;/p&gt;
&lt;p&gt;     功能：&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt; 获取&lt;/strong&gt;链接套接字&lt;strong&gt;客户端的地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  s.&lt;span&gt;setsockopt&lt;/span&gt;（level，optname， value）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       （# &lt;strong&gt;设置端口可立即重用&lt;/strong&gt; 必须在链接端口前设置&lt;/p&gt;
&lt;p&gt;        s.setsockopt(SOL_SOcKET, SO_REUSEADDR)）&lt;/p&gt;
&lt;p&gt;     功能：设置套接字选项&lt;/p&gt;
&lt;p&gt;     参数：&lt;/p&gt;
&lt;p&gt;        level：设置&lt;strong&gt;选项的类型&lt;/strong&gt;（大类型）  常用：SOL_SOCKET&lt;/p&gt;
&lt;p&gt;optname：&lt;strong&gt;子类选项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;value：&lt;strong&gt;要设置的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;s.&lt;span&gt;getsockopt&lt;/span&gt;（&lt;/strong&gt;level&lt;strong&gt;， optname）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     功能：&lt;strong&gt;获取套接字选项值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     参数：&lt;/p&gt;
&lt;p&gt;        level：选项的类型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;udp&lt;/strong&gt;套接字应用---&amp;gt;  &lt;strong&gt;广播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    一点发送多点接收&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;目标地址&lt;/strong&gt;：广播地址 172.18.32&lt;span&gt;&lt;strong&gt;.255&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;tcp应用---&amp;gt; http传输&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;http协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   超文本传输协议&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;  用途：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      网站中浏览器&lt;strong&gt;网页的获取&lt;/strong&gt;，基于&lt;strong&gt;网站&lt;/strong&gt;事物&lt;strong&gt;数据传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      编写基于http协议的&lt;strong&gt;数据传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; 特点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      1.&lt;strong&gt;应用层协议&lt;/strong&gt;，传输层使用tcp服务&lt;/p&gt;
&lt;p&gt;      2.&lt;strong&gt;简单、灵活&lt;/strong&gt;，可以使用&lt;strong&gt;多种编程语言&lt;/strong&gt;操作&lt;/p&gt;
&lt;p&gt;      3.无状态的协议，既不用记录用户的输入内容&lt;/p&gt;
&lt;p&gt;      4.&lt;strong&gt;http1.1&lt;/strong&gt;  ---&amp;gt; http2.0（还没发布）  &lt;strong&gt;技术的成熟和稳定性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;http请求（&lt;span&gt;request&lt;/span&gt;）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;请求格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt; 1.请求行：说明&lt;/strong&gt;具体的&lt;strong&gt;请求类别和内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          GET    /index.html    /HTTP/1.1&lt;/p&gt;
&lt;p&gt;                请求类别   请求内容    协议版本&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt; 请求类别：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;GET：&lt;/strong&gt;              &lt;strong&gt;获取&lt;/strong&gt;网络&lt;strong&gt;资源&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST：&lt;/strong&gt;           &lt;strong&gt;提交&lt;/strong&gt;一定的&lt;strong&gt;附加数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HEAD：          &lt;strong&gt;获取响应头&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PUT： &lt;/strong&gt;            &lt;strong&gt;更新&lt;/strong&gt;服务器&lt;strong&gt;资源&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DELETE：&lt;/strong&gt;        &lt;strong&gt;删除&lt;/strong&gt;服务器&lt;strong&gt;资源&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;CONNECT：   未使用&lt;/li&gt;
&lt;li&gt;TRACE：         用于&lt;strong&gt;测试&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;OPTIONS：    获取服务器&lt;strong&gt;性能信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;2.请求头：&lt;/strong&gt;对&lt;strong&gt;请求的具体描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     Accept：text/html&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;每一个键值对占一行，描述了一个特定信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;3.空行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4.请求体： 具体&lt;/strong&gt;的&lt;strong&gt;参数或&lt;/strong&gt;提交的&lt;strong&gt;内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;get参数或者post提交的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; http响应（&lt;span&gt;response&lt;/span&gt;）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;响应格式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         &lt;strong&gt;1.响应行&lt;/strong&gt;:&lt;strong&gt;反馈&lt;/strong&gt;具体的&lt;strong&gt;响应情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          HTTP/1.1     20       OK&lt;/p&gt;
&lt;p&gt;  版本协议   响应码   附加信息&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;响应码：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;       &lt;strong&gt;1xx：&lt;/strong&gt;提示信息，表示&lt;strong&gt;请求已&lt;/strong&gt;经&lt;strong&gt;接收&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;      &lt;strong&gt; 2xx：响应成功&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;       &lt;strong&gt;3xx：响应需要定向（重新记载链接第三方链接）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;       &lt;strong&gt;4xx：客户端错误&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;      &lt;strong&gt; 5xx：服务器端错误&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;   &lt;strong&gt; 常见响应码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;200  成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;404&lt;/strong&gt;  请求&lt;strong&gt;内容不存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;401 &lt;/strong&gt; 没有访问&lt;strong&gt;权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;500&lt;/strong&gt;  服务器&lt;strong&gt;未知错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;503&lt;/strong&gt;  &lt;strong&gt;服务器&lt;/strong&gt;暂时&lt;strong&gt;无法执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt; 2.响应头&lt;/strong&gt;：对响应&lt;strong&gt;内容的具体描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      3.空行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      4.响应体：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         &lt;strong&gt;将客户端请求内容进行返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201808/1430617-20180807234157214-377848043.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201808/1430617-20180807234259750-1877448409.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201808/1430617-20180807234746507-2083371907.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这里这个图就看了一眼 没特意去记  凭印象画的  可能不对 但是大体逻辑应该没错 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我去百度搜了 什么也没搜到 不知道是不是我的打开方式不对还是什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只搜到了上面的两张图..........&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tcp，udp协议的区别和编程实现上的差异：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;          tcp：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;               tcp是一种可靠的、面向有链接数据传输服务&lt;/li&gt;
&lt;li&gt;               tcp能够保证数据的完整性、顺序性、无重复以及无差错&lt;/li&gt;
&lt;li&gt;               tcp是一种以文件流的形式传输数据的服务 文件流之间是没有边界&lt;/li&gt;
&lt;li&gt;               的所以基友可能会产生粘包的情况 粘包是因为接受速度没有传输速度快&lt;/li&gt;
&lt;li&gt;               导致缓存区的数据拥堵 下次取出数据时从而产生非独立数据的链接 这种情况&lt;/li&gt;
&lt;li&gt;               叫做粘包  粘包只有传输多个数据时才会出现&lt;/li&gt;
&lt;li&gt;               tcp的编程需要监听套接字 和 等待链接过程 只有链接成功才能发送数据&lt;/li&gt;
&lt;li&gt;               这种情况叫做三次握手、还有断开时的四次挥手&lt;/li&gt;
&lt;li&gt;               三次挥手：客户端请求链接、服务器返回报文、客户端完成链接&lt;/li&gt;
&lt;li&gt;               四次挥手：客户端请求断开、服务器接受请求、服务器准备完毕可以断开、客户端断开&lt;/li&gt;
&lt;li&gt;               tcp收发送消息需要使用recv、send、sendall方法&lt;/li&gt;
&lt;li&gt;               sendall比特殊 功能和send一样 但sendall有事务  若发送成功返回None 否则触发异常&lt;/li&gt;
&lt;li&gt;              链接时必须先运行服务器端后运行客户端&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;         udp：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;             udp就比较简单了  是面向无连接的不可靠的数据传输服务&lt;/li&gt;
&lt;li&gt;             udp没有数据流  接受大小取决于接收方&lt;/li&gt;
&lt;li&gt;             若数据超出接收方接受范围则丢掉所有超出范围的内容&lt;/li&gt;
&lt;li&gt;             udp不存在粘包的情况&lt;/li&gt;
&lt;li&gt;             udp不需要等待链接 没有挥手过程 先发就发 想收就收 自由度比较高&lt;/li&gt;
&lt;li&gt;             udp编程时收发消息使用recvfrom、sendto方法&lt;/li&gt;
&lt;li&gt;             udp可用于广播可以随时断开或链接&lt;/li&gt;
&lt;li&gt;             客户端和服务器端可以随时运行&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div readability=&quot;74&quot;&gt;

&lt;p&gt;什么是http？&lt;/p&gt;

&lt;p&gt;       http 是超文本传输协议&lt;/p&gt;
&lt;p&gt;               一种网络数据传输的协议&lt;/p&gt;
&lt;p&gt;              没错就是  协议&lt;/p&gt;
&lt;p&gt;             并且所有的www文件都必须遵守这个标准&lt;/p&gt;
&lt;p&gt;http作用是什么？&lt;/p&gt;

&lt;p&gt;      可以用力来网站中浏览器网页获取，基于网站上的一些数据传输 例如目前我正在打的字......&lt;/p&gt;
&lt;p&gt;      编写基于http协议的数据传输  &lt;/p&gt;

&lt;p&gt;http协议 请求和响应的格式以及每一部分做什么&lt;/p&gt;
&lt;p&gt;      请求部分：&lt;/p&gt;
&lt;p&gt;               请求行：请求的具体类别和内容   比如说  类别、内容、版本协议&lt;/p&gt;
&lt;p&gt;               请求头：请求具体描述&lt;/p&gt;
&lt;p&gt;               空行：就是空行&lt;/p&gt;
&lt;p&gt;               请求体：请求具体参数或内容&lt;/p&gt;
&lt;p&gt;      响应部分：&lt;/p&gt;
&lt;p&gt;               响应行：具体响应情况     比如说  版本协议 、响应码 、附加信息  &lt;/p&gt;
&lt;p&gt;               响应头：响应具体描述&lt;/p&gt;
&lt;p&gt;               空行&lt;/p&gt;
&lt;p&gt;               响应体：响应具体参数或内容&lt;/p&gt;
&lt;p&gt;http协议中请求的基本类型和作用：&lt;/p&gt;
&lt;p&gt;        GET：获取网络资源&lt;/p&gt;
&lt;p&gt;        POST：提交一定的附加数据&lt;/p&gt;
&lt;p&gt;        HEAD：获取响应头 响应返回的文件信息&lt;/p&gt;
&lt;p&gt;        PUT：更新服务器资源&lt;/p&gt;
&lt;p&gt;        DELETE：删除服务器资源&lt;/p&gt;
&lt;p&gt;        TRACE：用于测试&lt;/p&gt;
&lt;p&gt;         OPIONS：获取服务器性能信息&lt;/p&gt;
&lt;p&gt;        CONNECT：备用&lt;/p&gt;
&lt;p&gt;http协议响应码的类型和表达含义：&lt;/p&gt;
&lt;p&gt;          以1开头的表示请求已经链接&lt;/p&gt;
&lt;p&gt;          以2开头的表示成功接收、提示&lt;/p&gt;
&lt;p&gt;          以3开头的代表重新定向进一步处理 第三方&lt;/p&gt;
&lt;p&gt;          以4开头的客户端错误&lt;/p&gt;
&lt;p&gt;          以5开头的服务器错误&lt;/p&gt;
&lt;p&gt;http协议请求网页的流程：&lt;/p&gt;
&lt;p&gt;           建立连接、发送请求、响应请求、断开链接&lt;/p&gt;
&lt;p&gt;           这样的一个过程称为一个事物&lt;/p&gt;



&lt;/div&gt;
</description>
<pubDate>Tue, 07 Aug 2018 19:09:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9440561.html</dc:identifier>
</item>
<item>
<title>Pyhon3实现机器学习经典算法（二）KNN实现简单OCR - DawnSwallow</title>
<link>http://www.cnblogs.com/DawnSwallow/p/9440516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DawnSwallow/p/9440516.html</guid>
<description>&lt;p&gt;一、前言&lt;/p&gt;
&lt;p&gt;　　1、ocr概述&lt;/p&gt;
&lt;p&gt;　　　　OCR （Optical Character Recognition，&lt;span&gt;&lt;span&gt;光学字符识别&lt;/span&gt;&lt;/span&gt;）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；即，针对印刷体字符，采用光学的方式将纸质文档中的文字转换成为黑白点阵的图像文件，并通过识别软件将图像中的文字转换成文本格式，供文字处理软件进一步编辑加工的技术（摘自百度百科：&lt;a href=&quot;https://baike.baidu.com/item/%E5%85%89%E5%AD%A6%E5%AD%97%E7%AC%A6%E8%AF%86%E5%88%AB/4162921?fromtitle=OCR&amp;amp;fromid=25995&amp;amp;fr=aladdin&quot; target=&quot;_blank&quot;&gt;光学字符识别&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;　　　　KNN在OCR的识别过程中能发挥作用的地方在于将图像中的文字转换为文本格式，而OCR的其他部分，比如图像预处理、二值化等操作将其丢给OpenCV去操作。&lt;/p&gt;
&lt;p&gt;　　2、训练集简介&lt;/p&gt;
&lt;p&gt;　　　　由于我们采用的是KNN来转换图像中的文字为文本格式，需要一个庞大的手写字符训练集来支撑我们的算法。这里我使用的是《机器学习实战》2.3实例：手写识别系统中使用的数据集，其下载地址为：https://www.manning.com/books/machine-learning-in-action，在Source Code\Ch02\digits\trainingDigits中的两千多个手写字符既是我所使用的训练集。&lt;/p&gt;
&lt;p&gt;　　　　这个训练集配合上它所提供的测试集，提供了一个准确度非常高的分类器：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234048870-1882474655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　训练集是由0~9十个数字组成的，每个数字有两百个左右的训练样本。&lt;span&gt;所有的训练样本统一被处理为一个32*32的0/1矩阵，其中所有值为1的连通区域构成了形象上的数字&lt;/span&gt;，如下所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234338861-48124025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　所以，在构造我们的测试集的时候，所有的手写数字图片必须被处理为这样的格式才能够使得分类算法正确地进行，这也是KNN的局限所在。&lt;/p&gt;
&lt;p&gt;二、算法实现&lt;/p&gt;
&lt;p&gt;　　1、构建测试集&lt;/p&gt;
&lt;p&gt;　　　　上面已经提到，要想算法正确地进行，测试集的样式应该和训练集相同，也就是说我们要把一张包含有手写数字的图像，转换为一个32*32的0/1点阵。&lt;/p&gt;
&lt;p&gt;　　　　测试集使用我自己手写的10个数字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234904828-1318108124.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234910605-636949701.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234916216-1992097145.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234922135-253737105.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234927335-1608030579.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234931791-2143757635.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234935525-444637686.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234939296-1679909869.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234943026-1584566531.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180807234947440-2004814109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这里存在一个非常大的问题：这个数据集的作者是土耳其人，他们书写数字的习惯和我们有诸多不同，比如上面的数字4和数字8，下面这样子的数字就无法识别：4/8。哈哈，也就是说它连印刷体都无法识别，这是这个训练集的一大缺陷之一。&lt;/p&gt;
&lt;p&gt;　　　　1）图像预处理&lt;/p&gt;
&lt;p&gt;　　　　　图像预处理的过程是一个数字图像处理（DIP）的过程，观察上面的10个数字，可以发现每张图像的大小/对比度的差距都非常大，所以图像预处理应该消除这些差距。&lt;/p&gt;
&lt;p&gt;　　　　　第一步是进行图像的放大/缩小。由于我们很难产生一个小于32*32像素的手写数字图像，所以这里主要是缩小图像：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; readImage(imagePath):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     image =&lt;span&gt; cv2.imread(imagePath,cv2.IMREAD_GRAYSCALE)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     image = cv2.resize(image,(32,32),interpolation =&lt;span&gt; cv2.INTER_AREA)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; image
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这里我没有去实现图像重采样的方法（实现在后面的博客会写），而是采用的OpenCV，通过area来确定取样点的灰度值（推荐用bicubic interpolation，对应的插入函数应该是INTER_CUBIC），在读入图像的时候读入方式位IMRAD_GRAYSCALE，因为我们需要的是识别手写字符，灰度图对比彩色图能更好的突出重点。&lt;/p&gt;
&lt;p&gt;　　　　进行图像的缩放是不够的，因为观察上面的图片可以发现：拍摄环境对于对比度的影响非常大，所以我们应该突出深色区域（数字部分），来保证后面的工作顺利进行，这里采用的是伽马变换（也可以采用对数变换）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; imageGamma(image):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             image[i][j]=3*pow(image[i][j],0.8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; image
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;　　　　2）图像二值化&lt;/p&gt;
&lt;p&gt;　　　　　　缩小/放大后的图像已经是一个32*32的图像了，下一步则是将非数字区域填充0，数字区域填充1，这里我采用的是阈值二值化处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; imageThreshold(image):
    ret,image &lt;/span&gt;= cv2.threshold(image,150,255&lt;span&gt;,cv2.THRESH_BINARY)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; image
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　经过二值化处理，数字部分的灰度值应该为0，而非数字部分的连通区域的灰度值应该为255，如下所示：&lt;/p&gt;
&lt;p&gt;                     &lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808001120428-915569620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3）去噪&lt;/p&gt;
&lt;p&gt;　　　　　　图像去噪的方式有很多种，这里建立使用自适应中值滤波器进行降噪，因为我们的图像在传输过程中可能出现若干的椒盐噪声，这个噪声在上述的二值化处理中有时候是非常棘手的。&lt;/p&gt;
&lt;p&gt;　　　　　　到目前为止，一副手机摄像的手写数字图像就可以转换为一个32*32的二值图像。&lt;/p&gt;
&lt;p&gt;　　　　4）生成训练样本&lt;/p&gt;
&lt;p&gt;　　　　　　如何将这个32*32的二值图像转换为0/1图像，这个处理非常简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; imageProcess(image):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         with open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits\6_0.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; image[i][j] == 255&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                     file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;                     file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             file.writelines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　这里我的代码在扫描这个图像的同时，将其保存为一个训练样本，命名和训练集的明明要求一样为N_M.txt，其中N代表这个训练样本的实际分类是什么数字，M代表这是这个数字的第几个样本。这里对图像进行灰度变换已经是多此一举了，我所需要的是0/1矩阵而非一个0/1图像，所以在扫描过程中一并生成训练样本更加省时直观。&lt;/p&gt;
&lt;p&gt;　　　　5）形成训练集&lt;/p&gt;
&lt;p&gt;　　　　　　上面的示例只是生成一个图像的训练样本的，而实际上我们往往需要一次性生成一个训练集，这就要求这个图像预处理、二值化并且生成0/1矩阵的过程是自动的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; os &lt;span&gt;import&lt;/span&gt;&lt;span&gt; listdir
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; imProcess(imagePath):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     testDigits =&lt;span&gt; listdir(imagePath)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(testDigits)):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         imageName = testDigits[i]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;图像命名格式为N_M.png，NM含义见4）生成训练样本&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;#imageClass = int((imageName.split('.')[0]).split('_')[0])#这个图像的数字是多少&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         image =&lt;span&gt; cv2.imread(imageName,cv2.IMREAD_GRAYSCALE)  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         image = cv2.resize(image, (32, 32), interpolation=&lt;span&gt;cv2.INTER_AREA)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         ret, image = cv2.threshold(image, 150, 255&lt;span&gt;, cv2.THRESH_BINARY)     
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         with open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+imageName.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; image[i][j] == 255&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 file.writelines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　这个函数将imagePath文件夹中所有的N_M命名的手写数字图像读取并经过预处理、二值化、最后保存为对应的0/1矩阵，命名为N_M.txt，这就构成一个训练集了。&lt;/p&gt;

&lt;p&gt;　　2、构建分类器&lt;/p&gt;
&lt;p&gt;　　　　分类器使用上一节的分类器（&lt;a href=&quot;https://www.cnblogs.com/DawnSwallow/p/9428132.html&quot; target=&quot;_blank&quot;&gt;classify&lt;/a&gt;）：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; classify(vector,dataSet,labels,k):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     distance = sqrt(abs(((tile(vec,(dataSet.shape[0],1)) - dataSet) ** 2).sum(axis = 1))); &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算距离&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     sortedDistance =&lt;span&gt; distance.argsort()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     dict=&lt;span&gt;{}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         label =&lt;span&gt; labels[sortedDistance[i]]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; label &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dict:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              dict[label] = 1
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;              dict[label]+=1
&lt;span&gt;11&lt;/span&gt;    sortedDict = sorted(dict,key = operator.itemgetter(1),reverse =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sortedDict[0][0]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; dict2list(dic:dict):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将字典转换为list类型&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     keys=&lt;span&gt;dic.keys()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     values=&lt;span&gt;dic.values()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     lst=[(key, value)&lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(keys,values)]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; lst
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　distance的计算和dict2list函数的详解在上一节，戳上面的classify既可以跳转过去。&lt;/p&gt;
&lt;p&gt;　　分类器已经构建完成，下一步是提取每一个测试样本，提取训练集，提取label的过程：（这个过程大部分用的是《机器学习实战》中的代码，对于难以理解的代码在下文中做了解释：）&lt;/p&gt;
&lt;p&gt;　　1）读取0/1矩阵文件：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; img2vector(filename):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     returnvec = numpy.zeros((1,1024&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     file =&lt;span&gt; open(filename)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         line =&lt;span&gt; file.readline()
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(32&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             returnvec[0,32*i+j] =&lt;span&gt; int(line[j])
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; returnvec
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里要注意：&lt;span&gt;构造一个32*32的全零矩阵的时候，应该是numpy.zeros((1,1024))，双层括号！双层括号！双层括号！代表构造的是一个二维矩阵！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2）读取训练集和测试集并求解准确率：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; handWritingClassifyTest():
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     labels=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     trainingFile = listdir(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\trainingDigits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     m =&lt;span&gt; len(trainingFile)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     trainingMat = numpy.zeros((m,1024&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         file =&lt;span&gt; trainingFile[i]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         filestr = file.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         classnum = int(filestr.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        labels.append(classnum)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         trainingMat[i,:] = img2vector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trainingDigits/%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; file)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     testFileList = listdir(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     error = 0.0
&lt;span&gt;14&lt;/span&gt;     testnum =&lt;span&gt; len(testFileList)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(testnum):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         file_test =&lt;span&gt; testFileList[i]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         filestr_test = file_test.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         classnum_test = int(filestr_test.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         vector_test = img2vector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testDigits/%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;file_test)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         result = classify(vector_test,trainingMat,labels,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(result!=classnum_test):error+=1.0
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;准确率：%f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(1.0-(error/float(testnum))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　代码其实没有很难懂的地方，主要任务就是读取文件，通过img2vctor函数转换为矩阵，还有切割文件名获取该测试样本的类别和该训练样本的类别，通过对比获得准确率。&lt;/p&gt;
&lt;p&gt;　　3、使用分类器&lt;/p&gt;
&lt;p&gt;　　　　现在为止，我们的分类器已经构建完成，下面就是测试和使用阶段：&lt;/p&gt;
&lt;p&gt;　　　　1）测试《机器学习实战》中给出的训练集：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808004910944-1698141644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　2）测试手写训练集：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808005242337-303110738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　emmm果然学不出来大佬写字，附上几张无法识别的0/1数字矩阵：(0，4，6无法识别的原因是比划太细哈哈，8无法识别的原因……太端正了吧)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808005421192-447842586.png&quot; alt=&quot;&quot; width=&quot;159&quot; height=&quot;352&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808005426748-1653996600.png&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;353&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808005431055-2039761861.png&quot; alt=&quot;&quot; width=&quot;159&quot; height=&quot;353&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1447556/201808/1447556-20180808005434705-1131001573.png&quot; alt=&quot;&quot; width=&quot;159&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4、完整代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; os import listdir
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import numpy
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; import &lt;span&gt;operator&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import cv2
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;def imProcess(imagePath):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     testDigits =&lt;span&gt; listdir(imagePath)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(testDigits)):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         imageName =&lt;span&gt; testDigits[i]#图像命名格式为N_M.png，NM含义见4）生成训练样本
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         #imageClass = &lt;span&gt;int&lt;/span&gt;((imageName.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])#这个图像的数字是多少
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         image =&lt;span&gt; cv2.imread(imageName,cv2.IMREAD_GRAYSCALE)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         image = cv2.resize(image, (&lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;), interpolation=&lt;span&gt;cv2.INTER_AREA)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         ret, image = cv2.threshold(image, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;, cv2.THRESH_BINARY)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         with open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits\\&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+imageName.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; file:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; image[i][j] == &lt;span&gt;255&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                         file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 file.writelines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;def img2vector(filename):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     returnvec = numpy.zeros((&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     file =&lt;span&gt; open(filename)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         line =&lt;span&gt; file.readline()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             returnvec[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;*i+j] = &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(line[j])
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; returnvec
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;def handWritingClassifyTest():
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     labels=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     trainingFile = listdir(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\trainingDigits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     m =&lt;span&gt; len(trainingFile)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     trainingMat = numpy.zeros((m,&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         file =&lt;span&gt; trainingFile[i]
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         filestr = file.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         classnum = &lt;span&gt;int&lt;/span&gt;(filestr.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        labels.append(classnum)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         trainingMat[i,:] = img2vector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trainingDigits/%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; file)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     testFileList = listdir(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     error = &lt;span&gt;0.0&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     testnum =&lt;span&gt; len(testFileList)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(testnum):
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         file_test =&lt;span&gt; testFileList[i]
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         filestr_test = file_test.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         classnum_test = &lt;span&gt;int&lt;/span&gt;(filestr_test.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         vector_test = img2vector(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;testDigits/%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;file_test)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         result = classify(vector_test,trainingMat,labels,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(result!=classnum_test):error+=&lt;span&gt;1.0&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;准确率：%f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(&lt;span&gt;1.0&lt;/span&gt;-(error/&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(testnum))))
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;def classify(inX,dataSet,labels,k):
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     size = dataSet.shape[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     distance = (((numpy.tile(inX,(size,&lt;span&gt;1&lt;/span&gt;))-dataSet)**&lt;span&gt;2&lt;/span&gt;).sum(axis=&lt;span&gt;1&lt;/span&gt;))**&lt;span&gt;0.5&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     sortedDistance =&lt;span&gt; distance.argsort()
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     count =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k):
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         label =&lt;span&gt; labels[sortedDistance[i]]
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         count[label]=count.&lt;span&gt;get&lt;/span&gt;(label,&lt;span&gt;0&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;     sortedcount = sorted(dict2list(count),key=&lt;span&gt;operator&lt;/span&gt;.itemgetter(&lt;span&gt;1&lt;/span&gt;),reverse=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; sortedcount[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;def dict2list(dic:dict):#将字典转换为list类型
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     keys=&lt;span&gt;dic.keys()
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     values=&lt;span&gt;dic.values()
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;     lst=[(key, value)&lt;span&gt;for&lt;/span&gt; key,value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(keys,values)]
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lst
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;# def imProcess(image):
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; #     image = cv2.resize(image, (&lt;span&gt;32&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;), interpolation=&lt;span&gt;cv2.INTER_AREA)
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; #     ret, image = cv2.threshold(image, &lt;span&gt;150&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;, cv2.THRESH_BINARY)
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; #     cv2.imshow(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,image)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; #     cv2.waitKey(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; #     with open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits\6_0.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; file:
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; #         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; #             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;32&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; #                 &lt;span&gt;if&lt;/span&gt; image[i][j] == &lt;span&gt;255&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; #                     file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; #                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; #                     file.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; #             file.writelines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; 
&lt;span&gt;86&lt;/span&gt; 
&lt;span&gt;87&lt;/span&gt; 
&lt;span&gt;88&lt;/span&gt; # iamge = cv2.imread(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\yang\Desktop\6.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,cv2.IMREAD_GRAYSCALE)
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; # image =&lt;span&gt; imProcess(iamge)
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; imProcess(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:\Users\yang\PycharmProjects\OCR_KNN\testDigits&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; handWritingClassifyTest()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、github：https://github.com/hahahaha1997/OCR&lt;/p&gt;
&lt;p&gt;三、总结&lt;/p&gt;
&lt;p&gt;　　　　KNN还是不适合用来做OCR的识别过程的，虽然《机器学习实战》的作者提到这个系统是美国的邮件分拣系统实际运行的一个系统，但是它肯定无法高准确率地识别中国人写的手写文字就对了，毕竟中国有些地方的“9”还会写成“p”的样子的。这一节主要是将KNN拓展到实际运用中的，结合上一节的理论，KNN的执行效率还是太低了，比如这个系统，要识别一个手写数字，它需要和所有的训练样本做距离计算，每个距离计算又有1024个(a-b)²，还有运行效率特别低下的sqrt()，如果是一个非常大的测试集，需要的时间就更加庞大，如果训练集非常庞大，在将0/1矩阵读入内存中的时候，内存开销是非常巨大的，所以整个程序可能会非常耗时费力。不过KNN仍旧是一个精度非常高的算法，并且也是机器学习分类算法中最简单的算法之一。下一节将带来机器学习经典算法——ID3决策树。转载注明出处哦～&lt;/p&gt;

</description>
<pubDate>Tue, 07 Aug 2018 17:03:00 +0000</pubDate>
<dc:creator>DawnSwallow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DawnSwallow/p/9440516.html</dc:identifier>
</item>
<item>
<title>一份关于 Java、Kotlin 与 Android 的学习笔记 - 叶应是叶</title>
<link>http://www.cnblogs.com/leavesC/p/9440447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leavesC/p/9440447.html</guid>
<description>[unable to retrieve full-text content]Java_Kotlin_Android_Learn 这是一份关于 Java 、Kotlin 、Android 的学习笔记，既包含对基础知识点的介绍，也包含对一些重要知识点的源码解析，笔记的大纲如下所示： &quot;Java&quot; &quot;重拾Java（0） 基础知识点&quot; &quot;重拾Java（1） 基本数据类型与字面值&quot; </description>
<pubDate>Tue, 07 Aug 2018 16:15:00 +0000</pubDate>
<dc:creator>叶应是叶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leavesC/p/9440447.html</dc:identifier>
</item>
<item>
<title>Chromium CEF 2623 -- 支持 xp 的最后一个版本源码下载和编译步骤 - hejiangyuan</title>
<link>http://www.cnblogs.com/luckbird/p/CEF_2623_Compile.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luckbird/p/CEF_2623_Compile.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;因为项目需要在客户端中内嵌浏览器，需要支持 xp 操作系统和播放视频，但 CEF 2623 以后的版本已经不支持 xp 操作系统，也不再提供 2623 版本的二进制发布包下载，只好自己手动编译。编译结果要求达到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以在 xp 及以上操作系统运行&lt;/li&gt;
&lt;li&gt;可以播放 mp4 视频&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在参考了很多文档，反复尝试很多次以后，终于编译成功并在项目中投入使用了。&lt;/p&gt;
&lt;p&gt;因为直接从 CEF 代码库 2623 分支获取的代码编译会报错，需要进行多处修改才能编译成功。 这里把修改好的源码分享出来，只要根据下面的操作步骤配置编译环境，下载解压源代码直接编译应该就可以成功。&lt;/p&gt;
&lt;p&gt;总的操作步骤是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装编译环境&lt;/li&gt;
&lt;li&gt;下载源码压缩包解压&lt;/li&gt;
&lt;li&gt;编译得到 CEF 的二进制发布包&lt;/li&gt;
&lt;li&gt;有了二进制发布包以后，就可以再轻松的编译各种版本的 dll（各种版本 vs, x86, 64, 静态, 动态）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装编译环境&quot;&gt;安装编译环境：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;OS: Win7 64bit 以上系统, 至少8G内存，60G以上硬盘，最好是SSD&lt;/li&gt;
&lt;li&gt;Visual Studio: VS2015u3 + Win10.0.14393 SDK + Ninja&lt;/li&gt;
&lt;li&gt;Python 2.7+&lt;/li&gt;
&lt;li&gt;安装VS2015u3的时候，默认是不会安装Win10.0.14393 SDK的，需要手动勾选；&lt;/li&gt;
&lt;li&gt;安装python后需要将python的执行环境加入到环境变量中；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;下载源码&quot;&gt;下载源码&lt;/h2&gt;
&lt;h2 id=&quot;编译&quot;&gt;编译&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;编译前需要保证磁盘空间至少 60G 的可用空间，最后编译完我用了 54.8G(而且只是编译 Release)如果 Release 和 Debug 同时编译，可能需要准备 120G 的空间&lt;/li&gt;
&lt;li&gt;编辑 E:\cef\automate\build_cef_2623.bat 文件，根据需要编译的版本（Releae 或 Debug），打开或屏蔽相应的行，然后保存&lt;/li&gt;
&lt;li&gt;进入命令行模式，切换到 E:\cef\automate 目录， 执行 build_cef_2623.bat 即开始编译&lt;/li&gt;
&lt;li&gt;编译大概需要 4 个小时，编译过程中大部分时间，命令行窗口不会有变化，详细日志会写入 E:\cef\2623 文件夹，Release 版本大概日志写到 400 M 就快编译完了&lt;/li&gt;
&lt;li&gt;编译完成后的二进制发布包在 E:\cef\2623\chromium\src\cef\binary_distrib 文件夹可以找到&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;根据二进制发布包编译-dll&quot;&gt;根据二进制发布包编译 dll&lt;/h2&gt;
&lt;p&gt;后续会把 vs2015 x86 环境下编译好的动态库 dll 发上来，如果你用的也是 vs2015 x86 可以直接使用&lt;/p&gt;
&lt;p&gt;如果有问题可以加 QQ 群讨论，群号：599320555&lt;/p&gt;
&lt;p&gt;转载请注明来自博客园 TerryHe 的微博 &lt;a href=&quot;https://www.cnblogs.com/luckbird/p/CEF_2623_Compile.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/luckbird/p/CEF_2623_Compile.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;几篇参考文档&quot;&gt;几篇参考文档&lt;/h2&gt;
</description>
<pubDate>Tue, 07 Aug 2018 15:52:00 +0000</pubDate>
<dc:creator>hejiangyuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luckbird/p/CEF_2623_Compile.html</dc:identifier>
</item>
<item>
<title>JAVAEE——宜立方商城13：订单系统实现、订单生成、Mycat数据库分片 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/9440242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/9440242.html</guid>
<description>&lt;p&gt;1、订单系统实现&lt;/p&gt;
&lt;p&gt;2、订单生成&lt;/p&gt;
&lt;p&gt;3、Mycat数据库分片&lt;/p&gt;


&lt;h2&gt;2.1. 功能分析&lt;/h2&gt;
&lt;p&gt;1、&lt;span&gt;在购物车页面点击&lt;/span&gt;“去结算”按钮，跳转到订单确认页面&lt;/p&gt;
&lt;p&gt;a) 必须要求用户登录&lt;/p&gt;
&lt;p&gt;b) 使用拦截器实现。&lt;/p&gt;
&lt;p&gt;c) 如果用户未登录跳转到登录页面。&lt;/p&gt;
&lt;p&gt;d) 如果用户已经登录，放行。展示确认页面。&lt;/p&gt;
&lt;p&gt;e) &lt;span&gt;判断&lt;/span&gt;cookie&lt;span&gt;中是否有购物车数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;f) 如果有同步到服务端。&lt;/p&gt;
&lt;p&gt;2、订单确认页面中选择收货地址，选择支付方式，确认商品列表。&lt;/p&gt;
&lt;p&gt;a) &lt;span&gt;根据用户&lt;/span&gt;id&lt;span&gt;查询收货地址列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;b) 展示支付方式列表。&lt;/p&gt;
&lt;p&gt;c) 从购物车中取商品列表，从服务端取购物车列表。&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;订单确认页面点击&lt;/span&gt;“提交”，生成订单。&lt;/p&gt;
&lt;p&gt;4、展示订单生成完成，或者跳转到支付页面。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h2&gt;2.2. 工程搭建&lt;/h2&gt;
&lt;p&gt;E3-order&lt;/p&gt;
&lt;p&gt;  |--E3-order-interface&lt;span&gt;（&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  |--E3-order-service&lt;span&gt;（&lt;/span&gt;&lt;span&gt;war&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;E3-order-web&lt;span&gt;（&lt;/span&gt;&lt;span&gt;war&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.3. 展示订单确认页面&lt;/h2&gt;
&lt;h3&gt;2.3.1. 功能分析&lt;/h3&gt;
&lt;p&gt;1、&lt;span&gt;根据&lt;/span&gt;id&lt;span&gt;查询用户的收货地址列表（使用静态数据）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、从购物车中取商品列表，展示到页面。调用购物车服务查询。&lt;/p&gt;

&lt;h3&gt;2.3.2. Dao&lt;span&gt;层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;直接从&lt;/span&gt;redis&lt;span&gt;中取购车商品列表。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.3.3. Service&lt;span&gt;层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;收货地址静态数据，没有&lt;/span&gt;server&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用购物车的&lt;/span&gt;service&lt;span&gt;查询购物车商品列表。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.3.4. Controller&lt;/h3&gt;
&lt;p&gt;引用购物车服务&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232416413-313539393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232422202-2092165365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;请求的&lt;/span&gt;url&lt;span&gt;：&lt;/span&gt;&lt;span&gt;/order/order-cart&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数：没有参数&lt;/p&gt;
&lt;p&gt;返回值：逻辑视图&lt;/p&gt;

&lt;p&gt;Controller&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderCartController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CartService cartService;
    
    @RequestMapping(&lt;/span&gt;&quot;/order/order-cart&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String showOrderCart(HttpServletRequest request) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取用户信息&lt;/span&gt;
        TbUser user = (TbUser) request.getAttribute(&quot;user&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取购物车商品列表&lt;/span&gt;
        List&amp;lt;TbItem&amp;gt; cartList =&lt;span&gt; cartService.getCartList(user.getId());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把商品列表传递给jsp&lt;/span&gt;
        request.setAttribute(&quot;cartList&quot;&lt;span&gt;, cartList);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回逻辑视图&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &quot;order-cart&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;2.4. 登录拦截器&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;2.4.1. 功能分析&lt;/h3&gt;
&lt;p&gt;1、&lt;span&gt;从&lt;/span&gt;cookie&lt;span&gt;中取&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;如果没有取到，没有登录，跳转到&lt;/span&gt;sso&lt;span&gt;系统的登录页面。拦截&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;如果取到&lt;/span&gt;token&lt;span&gt;。判断登录是否过期，需要调用&lt;/span&gt;&lt;span&gt;sso&lt;/span&gt;&lt;span&gt;系统的服务，根据&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;取用户信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、如果没有取到用户信息，登录已经过期，重新登录。跳转到登录页面。拦截&lt;/p&gt;
&lt;p&gt;5、&lt;span&gt;如果取到用户信息，用户已经是登录状态，把用户信息保存到&lt;/span&gt;request&lt;span&gt;中。放行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;span&gt;判断&lt;/span&gt;cookie&lt;span&gt;中是否有购物车信息，如果有合并购物车&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.4.2. 拦截器实现&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 用户登录判断拦截器
 * &amp;lt;p&amp;gt;Title: LoginInterceptor&amp;lt;/p&amp;gt;
 * &amp;lt;p&amp;gt;Description: &amp;lt;/p&amp;gt;
 * &amp;lt;p&amp;gt;Company: www.itcast.cn&amp;lt;/p&amp;gt; 
 * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; HandlerInterceptor {

    @Value(&lt;/span&gt;&quot;${COOKIE_TOKEN_KEY}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String COOKIE_TOKEN_KEY;
    @Value(&lt;/span&gt;&quot;${COOKIE_CART_KEY}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String COOKIE_CART_KEY;
    @Value(&lt;/span&gt;&quot;${SSO_URL}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String SSO_URL;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CartService cartService;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、从cookie中取token&lt;/span&gt;
        String token =&lt;span&gt; CookieUtils.getCookieValue(request, COOKIE_TOKEN_KEY);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、如果没有取到，没有登录，跳转到sso系统的登录页面。拦截&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isBlank(token)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳转到登录页面&lt;/span&gt;
            response.sendRedirect(SSO_URL + &quot;/page/login?redirect=&quot; +&lt;span&gt; request.getRequestURL());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、如果取到token。判断登录是否过期，需要调用sso系统的服务，根据token取用户信息&lt;/span&gt;
        E3Result e3Result =&lt;span&gt; userService.getUserByToken(token);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、如果没有取到用户信息，登录已经过期，重新登录。跳转到登录页面。拦截&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (e3Result.getStatus() != 200&lt;span&gt;) {
            response.sendRedirect(SSO_URL &lt;/span&gt;+ &quot;/page/login?redirect=&quot; +&lt;span&gt; request.getRequestURL());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5、如果取到用户信息，用户已经是登录状态，把用户信息保存到request中。放行&lt;/span&gt;
        TbUser user =&lt;span&gt; (TbUser) e3Result.getData();
        request.setAttribute(&lt;/span&gt;&quot;user&quot;&lt;span&gt;, user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6、判断cookie中是否有购物车信息，如果有合并购物车&lt;/span&gt;
        String json = CookieUtils.getCookieValue(request, COOKIE_CART_KEY, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isNotBlank(json)) {
            cartService.mergeCart(user.getId(), JsonUtils.jsonToList(json, TbItem.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除cookie中的购物车数据&lt;/span&gt;
            CookieUtils.setCookie(request, response, COOKIE_CART_KEY, &quot;&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放行&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;2.4.3. Springmvc&lt;/span&gt;&lt;span&gt;配置&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截器配置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:mapping &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;/**&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cn.e3mall.order.interceptor.LoginInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.4.4. &lt;span&gt;实现&lt;/span&gt;sso&lt;span&gt;系统的回调&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232510825-481994230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.5. 提交订单&lt;/h2&gt;
&lt;h3&gt;2.5.1. 功能分析&lt;/h3&gt;
&lt;p&gt;1、&lt;span&gt;在订单确认页面点击&lt;/span&gt;“提交订单”按钮生成订单。&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;请求的&lt;/span&gt;url&lt;span&gt;：&lt;/span&gt;&lt;span&gt;/order/create&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、参数：提交的是表单的数据。保存的数据：订单、订单明细、配送地址。&lt;/p&gt;
&lt;p&gt;a) &lt;span&gt;向&lt;/span&gt;tb_order&lt;span&gt;中插入记录。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;订单号需要手动生成。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;要求订单号不能重复。&lt;/p&gt;
&lt;p&gt;订单号可读性号。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用&lt;/span&gt;redis&lt;span&gt;的&lt;/span&gt;&lt;span&gt;incr&lt;/span&gt;&lt;span&gt;命令生成订单号。订单号需要一个初始值。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Payment&lt;span&gt;：表单数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;payment_type&lt;span&gt;：表单数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;user_id&lt;span&gt;：用户信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;buyer_nick&lt;span&gt;：用户名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;其他字段&lt;/span&gt;null&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;b) &lt;span&gt;向&lt;/span&gt;tb_order_item&lt;span&gt;订单明细表插入数据。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Id&lt;span&gt;：使用&lt;/span&gt;&lt;span&gt;incr&lt;/span&gt;&lt;span&gt;生成&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;order_id&lt;span&gt;：生成的订单号&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;其他的都是表单中的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;c) tb_order_shipping&lt;span&gt;，订单配送信息&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;order_id&lt;span&gt;：生成的订单号&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;其他字段都是表单中的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;d) &lt;span&gt;使用&lt;/span&gt;pojo&lt;span&gt;接收表单的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以扩展&lt;/span&gt;TbOrder&lt;span&gt;，在子类中添加两个属性一个是商品明细列表，一个是配送信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把&lt;/span&gt;pojo&lt;span&gt;放到&lt;/span&gt;e3-order-interface&lt;span&gt;工程中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderInfo &lt;span&gt;extends&lt;/span&gt; TbOrder &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;TbOrderItem&amp;gt;&lt;span&gt; orderItems;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TbOrderShipping orderShipping;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TbOrderItem&amp;gt;&lt;span&gt; getOrderItems() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderItems;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setOrderItems(List&amp;lt;TbOrderItem&amp;gt;&lt;span&gt; orderItems) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderItems =&lt;span&gt; orderItems;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TbOrderShipping getOrderShipping() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; orderShipping;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setOrderShipping(TbOrderShipping orderShipping) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderShipping =&lt;span&gt; orderShipping;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;业务逻辑： &lt;/p&gt;
&lt;p&gt;1、接收表单的数据&lt;/p&gt;
&lt;p&gt;2、&lt;span&gt;生成订单&lt;/span&gt;id&lt;/p&gt;
&lt;p&gt;3、向订单表插入数据。&lt;/p&gt;
&lt;p&gt;4、向订单明细表插入数据&lt;/p&gt;
&lt;p&gt;5、向订单物流表插入数据。&lt;/p&gt;
&lt;p&gt;6、返回e3Result&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;返回值：e3Result&lt;/p&gt;

&lt;h3&gt;2.5.2. Dao&lt;span&gt;层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;可以使用逆向工程。&lt;/p&gt;

&lt;h3&gt;2.5.3. Service&lt;span&gt;层&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;OrderInfo&lt;/p&gt;
&lt;p&gt;返回值：e3Result&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OrderService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TbOrderMapper orderMapper;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TbOrderItemMapper orderItemMapper;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TbOrderShippingMapper orderShippingMapper;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JedisClient jedisClient;
    
    @Value(&lt;/span&gt;&quot;${ORDER_GEN_KEY}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ORDER_GEN_KEY;
    @Value(&lt;/span&gt;&quot;${ORDER_ID_BEGIN}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ORDER_ID_BEGIN;
    @Value(&lt;/span&gt;&quot;${ORDER_ITEM_ID_GEN_KEY}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ORDER_ITEM_ID_GEN_KEY;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; e3Result createOrder(OrderInfo orderInfo) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、接收表单的数据
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、生成订单id&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;jedisClient.exists(ORDER_GEN_KEY)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置初始值&lt;/span&gt;
&lt;span&gt;            jedisClient.set(ORDER_GEN_KEY, ORDER_ID_BEGIN);
        }
        String orderId &lt;/span&gt;=&lt;span&gt; jedisClient.incr(ORDER_GEN_KEY).toString();
        orderInfo.setOrderId(orderId);
        orderInfo.setPostFee(&lt;/span&gt;&quot;0&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、未付款，2、已付款，3、未发货，4、已发货，5、交易成功，6、交易关闭&lt;/span&gt;
        orderInfo.setStatus(1&lt;span&gt;);
        Date date &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        orderInfo.setCreateTime(date);
        orderInfo.setUpdateTime(date);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、向订单表插入数据。&lt;/span&gt;
&lt;span&gt;        orderMapper.insert(orderInfo);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、向订单明细表插入数据&lt;/span&gt;
        List&amp;lt;TbOrderItem&amp;gt; orderItems =&lt;span&gt; orderInfo.getOrderItems();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TbOrderItem tbOrderItem : orderItems) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成明细id&lt;/span&gt;
            Long orderItemId =&lt;span&gt; jedisClient.incr(ORDER_ITEM_ID_GEN_KEY);
            tbOrderItem.setId(orderItemId.toString());
            tbOrderItem.setOrderId(orderId);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入数据&lt;/span&gt;
&lt;span&gt;            orderItemMapper.insert(tbOrderItem);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5、向订单物流表插入数据。&lt;/span&gt;
        TbOrderShipping orderShipping =&lt;span&gt; orderInfo.getOrderShipping();
        orderShipping.setOrderId(orderId);
        orderShipping.setCreated(date);
        orderShipping.setUpdated(date);
        orderShippingMapper.insert(orderShipping);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6、返回e3Result。&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e3Result.ok(orderId);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;  &lt;/p&gt;
&lt;h3&gt;2.5.4. Controller&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;请求的&lt;/span&gt;url&lt;span&gt;：&lt;/span&gt;&lt;span&gt;/order/create&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数：使用&lt;/span&gt;OrderInfo&lt;span&gt;接收&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;返回值：逻辑视图。&lt;/p&gt;
&lt;p&gt;业务逻辑：&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;接收表单提交的数据&lt;/span&gt;OrderInfo&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、补全用户信息。&lt;/p&gt;
&lt;p&gt;3、&lt;span&gt;调用&lt;/span&gt;Service&lt;span&gt;创建订单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、返回逻辑视图展示成功页面&lt;/p&gt;
&lt;p&gt;a) &lt;span&gt;需要&lt;/span&gt;Service&lt;span&gt;返回订单号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;b) 当前日期加三天。&lt;/p&gt;

&lt;p&gt;在拦截器中添加用户处理逻辑：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232555576-2078921098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@RequestMapping(value=&quot;/order/create&quot;, method=&lt;span&gt;RequestMethod.POST)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String createOrder(OrderInfo orderInfo, HttpServletRequest request) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、接收表单提交的数据OrderInfo。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、补全用户信息。&lt;/span&gt;
        TbUser user = (TbUser) request.getAttribute(&quot;user&quot;&lt;span&gt;);
        orderInfo.setUserId(user.getId());
        orderInfo.setBuyerNick(user.getUsername());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、调用Service创建订单。&lt;/span&gt;
        e3Result result =&lt;span&gt; orderService.createOrder(orderInfo);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取订单号&lt;/span&gt;
        String orderId =&lt;span&gt; result.getData().toString();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a)需要Service返回订单号&lt;/span&gt;
        request.setAttribute(&quot;orderId&quot;&lt;span&gt;, orderId);
        request.setAttribute(&lt;/span&gt;&quot;payment&quot;&lt;span&gt;, orderInfo.getPayment());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; b)当前日期加三天。&lt;/span&gt;
        DateTime dateTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DateTime();
        dateTime &lt;/span&gt;= dateTime.plusDays(3&lt;span&gt;);
        request.setAttribute(&lt;/span&gt;&quot;date&quot;, dateTime.toString(&quot;yyyy-MM-dd&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、返回逻辑视图展示成功页面&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;3. &lt;/span&gt;&lt;strong&gt;Mycat数据库分片&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如今随着互联网的发展，数据的量级也是撑指数的增长，从&lt;/span&gt;GB&lt;span&gt;到&lt;/span&gt;&lt;span&gt;TB&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;span&gt;PB&lt;/span&gt;&lt;span&gt;。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求。这个时候&lt;/span&gt;&lt;span&gt;NoSQL&lt;/span&gt;&lt;span&gt;的出现暂时解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，在有些场合&lt;/span&gt;NoSQL&lt;span&gt;一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候&lt;/span&gt;&lt;span&gt;NoSQL&lt;/span&gt;&lt;span&gt;肯定是无法满足的，所以还是需要使用关系性数据库。如果使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.1 &lt;strong&gt;什么是数据库分片&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据的切分（&lt;/span&gt;Sharding&lt;span&gt;）根据其切分规则的类型，可以分为两种切分模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）&lt;span&gt;一种是按照不同的表（或者&lt;/span&gt;Schema&lt;span&gt;）来切分到不同的数据库（主机）之上，这种切可以称之为数据的垂直（纵向）切分&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232730682-523586110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;

&lt;p&gt;（2）另外一种则是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232737063-602592971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.2 &lt;strong&gt;如何实现数据库分片&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当数据库分片后，数据由一个数据库分散到多个数据库中。此时系统要查询时需要切换不同的数据库进行查询，那么系统如何知道要查询的数据在哪个数据库中？当添加一条记录时要向哪个数据库中插入呢？这些问题处理起来都是非常的麻烦。&lt;/p&gt;
&lt;p&gt;这种情况下可以使用一个数据库中间件mycat&lt;span&gt;来解决相关的问题。接下来了解一下什么是&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.1 &lt;strong&gt;&lt;span&gt;什么是&lt;/span&gt;Mycat&lt;span&gt;？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Mycat &lt;span&gt;背后是阿里曾经开源的知名产品——&lt;/span&gt;&lt;span&gt;Cobar&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;Cobar&lt;/span&gt; &lt;span&gt;的核心功能和优势是&lt;/span&gt; &lt;span&gt;MySQL&lt;/span&gt; &lt;span&gt;数据库分片，此产品曾经广为流传，据说最早的发起者对&lt;/span&gt; &lt;span&gt;Mysql&lt;/span&gt; &lt;span&gt;很精通，后来从阿里跳槽了，阿里随后开源的&lt;/span&gt; &lt;span&gt;Cobar&lt;/span&gt;&lt;span&gt;，并维持到&lt;/span&gt; &lt;span&gt;2013&lt;/span&gt; &lt;span&gt;年年初，然后，就没有然后了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Cobar &lt;span&gt;的思路和实现路径的确不错。基于&lt;/span&gt; &lt;span&gt;Java&lt;/span&gt; &lt;span&gt;开发的，实现了&lt;/span&gt; &lt;span&gt;MySQL&lt;/span&gt; &lt;span&gt;公开的二进制传输协议，巧妙地将自己伪装成一个&lt;/span&gt; &lt;span&gt;MySQL Server&lt;/span&gt;&lt;span&gt;，目前市面上绝大多数&lt;/span&gt; &lt;span&gt;MySQL&lt;/span&gt; &lt;span&gt;客户端工具和应用都能兼容。比自己实现一个新的数据库协议要明智的多，因为生态环境在哪里摆着。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Mycat &lt;span&gt;是基于&lt;/span&gt; &lt;span&gt;cobar&lt;/span&gt; &lt;span&gt;演变而来，对&lt;/span&gt; &lt;span&gt;cobar&lt;/span&gt; &lt;span&gt;的代码进行了彻底的重构，使用&lt;/span&gt; &lt;span&gt;NIO&lt;/span&gt; &lt;span&gt;重构了网络模块，并且优化了&lt;/span&gt; &lt;span&gt;Buffer&lt;/span&gt; &lt;span&gt;内核，增强了聚合，&lt;/span&gt;&lt;span&gt;Join&lt;/span&gt; &lt;span&gt;等基本特性，同时兼容绝大多数数据库成为通用的数据库中间件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单的说，&lt;/span&gt;MyCAT&lt;span&gt;就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;·一个新颖的数据库中间件产品支持&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;集群，或者&lt;/span&gt;&lt;span&gt;mariadb cluster&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;提供高可用性数据分片集群。你可以像使用&lt;/span&gt;mysql&lt;span&gt;一样使用&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;。对于开发人员来说根本感觉不到&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;的存在。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232837400-1674830267.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2.2 &lt;strong&gt;Mycat&lt;span&gt;支持的数据库&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232848966-1691805970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 &lt;strong&gt;Mycat&lt;span&gt;的分片策略&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807232854580-1128526213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;2.4 &lt;strong&gt;概念说明&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;2.4.1 &lt;strong&gt;&lt;span&gt;逻辑库&lt;/span&gt;(schema) &lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;前面一节讲了数据库中间件，通常对实际应用来说，并不需要知道中间件的存在，业务开发人员只需要知道数据库的概念，所以数据库中间件可以被看做是一个或多个数据库集群构成的逻辑库。&lt;/p&gt;
&lt;h3&gt;2.4.2 &lt;strong&gt;&lt;span&gt;逻辑表（&lt;/span&gt;table&lt;span&gt;）：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;既然有逻辑库，那么就会有逻辑表，分布式数据库中，对应用来说，读写数据的表就是逻辑表。逻辑表，可以是数据切分后，分布在一个或多个分片库中，也可以不做数据切分，不分片，只有一个表构成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分片表：是指那些原有的很大数据的表，需要切分到多个数据库的表，这样，每个分片都有一部分数据，所有分片构成了完整的数据。&lt;/span&gt; &lt;span&gt;总而言之就是需要进行分片的表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非分片表：一个数据库中并不是所有的表都很大，某些表是可以不用进行切分的，非分片是相对分片表来说的，就是那些不需要进行数据切分的表。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.4.3 &lt;strong&gt;&lt;span&gt;分片节点&lt;/span&gt;(dataNode)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数据切分后，一个大表被分到不同的分片数据库上面，每个表分片所在的数据库就是分片节点（&lt;/span&gt;dataNode&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.4.4 &lt;strong&gt;&lt;span&gt;节点主机&lt;/span&gt;(dataHost)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数据切分后，每个分片节点（&lt;/span&gt;dataNode&lt;span&gt;）不一定都会独占一台机器，同一机器上面可以有多个分片数据库，这样一个或多个分片节点（&lt;/span&gt;&lt;span&gt;dataNode&lt;/span&gt;&lt;span&gt;）所在的机器就是节点主机（&lt;/span&gt;&lt;span&gt;dataHost&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;为了规避单节点主机并发数限制，尽量将读写压力高的分片节点（&lt;/span&gt;&lt;span&gt;dataNode&lt;/span&gt;&lt;span&gt;）均衡的放在不同的节点主机（&lt;/span&gt;&lt;span&gt;dataHost&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.4.5 &lt;strong&gt;&lt;span&gt;分片规则&lt;/span&gt;(rule)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难度。&lt;/p&gt;

&lt;h2&gt;3.1 &lt;strong&gt;安装环境&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1、jdk&lt;span&gt;：要求&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;必须是&lt;/span&gt;&lt;span&gt;1.7&lt;/span&gt;&lt;span&gt;及以上版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、Mysql&lt;span&gt;：推荐&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;5.5&lt;/span&gt;&lt;span&gt;以上版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、Mycat&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Mycat&lt;span&gt;的官方网站：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.mycat.org.cn/&quot;&gt;&lt;span&gt;http://www.mycat.org.cn/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MyCATApache/Mycat-download&quot;&gt;&lt;span&gt;https://github.com/MyCATApache/Mycat-download&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.2 &lt;strong&gt;安装步骤&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Mycat&lt;span&gt;有&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;多种版本。本教程为&lt;/span&gt;&lt;span&gt;linux&lt;/span&gt;&lt;span&gt;安装步骤，&lt;/span&gt;&lt;span&gt;windows&lt;/span&gt;&lt;span&gt;基本相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：下载&lt;/span&gt;Mycat-server-xxxx-linux.tar.gz&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：将压缩包解压缩。建议将&lt;/span&gt;mycat&lt;span&gt;放到&lt;/span&gt;&lt;span&gt;/usr/local/mycat&lt;/span&gt;&lt;span&gt;目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：进入&lt;/span&gt;mycat&lt;span&gt;目录，启动&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;./mycat start&lt;/p&gt;
&lt;p&gt;停止：&lt;/p&gt;
&lt;p&gt;./mycat stop&lt;/p&gt;
&lt;p&gt;mycat &lt;span&gt;支持的命令&lt;/span&gt;&lt;span&gt;{ console | start | stop | restart | status | dump }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mycat&lt;span&gt;的默认端口号为：&lt;/span&gt;&lt;span&gt;8066&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;4.1 &lt;strong&gt;需求&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;把商品表分片存储到三个数据节点上。&lt;/p&gt;

&lt;h2&gt;4.2 &lt;strong&gt;安装环境分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;两台&lt;/span&gt;mysql&lt;span&gt;数据库服务器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Host1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.25.134&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Host2&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.25.166&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;host1&lt;span&gt;环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作系统版本&lt;/span&gt; : centos6.4&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库版本&lt;/span&gt; : mysql-5.6&lt;/p&gt;
&lt;p&gt;mycat&lt;span&gt;版本 ：&lt;/span&gt;&lt;span&gt;1.4 release&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库名&lt;/span&gt; : db1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;db3&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;mysql&lt;span&gt;节点&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作系统版本&lt;/span&gt; : centos6.4&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库版本&lt;/span&gt; : mysql-5.6&lt;/p&gt;
&lt;p&gt;mycat&lt;span&gt;版本 ：&lt;/span&gt;&lt;span&gt;1.4 release&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据库名&lt;/span&gt; : db2&lt;/p&gt;

&lt;p&gt;MyCat&lt;span&gt;安装到节点&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;上（需要安装&lt;/span&gt;&lt;span&gt;jdk&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;4.3 &lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;schema.xml&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;4.3.1 &lt;strong&gt;Schema.xml&lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Schema.xml&lt;span&gt;作为&lt;/span&gt;&lt;span&gt;MyCat&lt;/span&gt;&lt;span&gt;中重要的配置文件之一，管理着&lt;/span&gt;&lt;span&gt;MyCat&lt;/span&gt;&lt;span&gt;的逻辑库、表、分片规则、&lt;/span&gt;&lt;span&gt;DataNode&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;DataSource&lt;/span&gt;&lt;span&gt;。弄懂这些配置，是正确使用&lt;/span&gt;&lt;span&gt;MyCat&lt;/span&gt;&lt;span&gt;的前提。这里就一层层对该文件进行解析。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;schema &lt;span&gt;标签用于定义&lt;/span&gt;&lt;span&gt;MyCat&lt;/span&gt;&lt;span&gt;实例中的逻辑库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Table &lt;span&gt;标签定义了&lt;/span&gt;&lt;span&gt;MyCat&lt;/span&gt;&lt;span&gt;中的逻辑表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;dataNode &lt;span&gt;标签定义了&lt;/span&gt;&lt;span&gt;MyCat&lt;/span&gt;&lt;span&gt;中的数据节点，也就是我们通常说所的数据分片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;dataHost&lt;span&gt;标签在&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;710&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;注意：若是&lt;span&gt;LINUX&lt;/span&gt;&lt;span&gt;版本的&lt;/span&gt;&lt;span&gt;MYSQL&lt;/span&gt;&lt;span&gt;，则需要设置为&lt;/span&gt;&lt;span&gt;Mysql&lt;/span&gt;&lt;span&gt;大小写不敏感，否则可能会发生表找不到的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;MySQL&lt;/span&gt;&lt;span&gt;的配置文件中&lt;/span&gt;&lt;span&gt;/etc/my.cnf [mysqld]&lt;/span&gt; &lt;span&gt;中增加一行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;lower_case_table_names=1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;4.3.2 &lt;strong&gt;Schema.xml&lt;span&gt;配置&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mycat:schema &lt;/span&gt;&lt;span&gt;xmlns:mycat&lt;/span&gt;&lt;span&gt;=&quot;http://org.opencloudb/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;schema &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;e3mall&quot;&lt;/span&gt;&lt;span&gt; checkSQLschema&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; sqlMaxLimit&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; auto sharding by id (long) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;tb_item&quot;&lt;/span&gt;&lt;span&gt; dataNode&lt;/span&gt;&lt;span&gt;=&quot;dn1,dn2,dn3&quot;&lt;/span&gt;&lt;span&gt; rule&lt;/span&gt;&lt;span&gt;=&quot;auto-sharding-long&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;schema&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn1&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn2&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;localhost2&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn3&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataHost &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;localhost1&quot;&lt;/span&gt;&lt;span&gt; maxCon&lt;/span&gt;&lt;span&gt;=&quot;1000&quot;&lt;/span&gt;&lt;span&gt; minCon&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; balance&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
                writeType&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; dbType&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; dbDriver&lt;/span&gt;&lt;span&gt;=&quot;native&quot;&lt;/span&gt;&lt;span&gt; switchType&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;  slaveThreshold&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;select user()&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi write hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;writeHost &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;hostM1&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;192.168.25.134:3306&quot;&lt;/span&gt;&lt;span&gt; user&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;
                        password&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi read hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;writeHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataHost &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;localhost2&quot;&lt;/span&gt;&lt;span&gt; maxCon&lt;/span&gt;&lt;span&gt;=&quot;1000&quot;&lt;/span&gt;&lt;span&gt; minCon&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; balance&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
                writeType&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; dbType&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; dbDriver&lt;/span&gt;&lt;span&gt;=&quot;native&quot;&lt;/span&gt;&lt;span&gt; switchType&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;  slaveThreshold&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;select user()&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi write hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;writeHost &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;hostM1&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;192.168.25.166:3306&quot;&lt;/span&gt;&lt;span&gt; user&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;
                        password&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi read hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;writeHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mycat:schema&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;4.4 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;server.xml&lt;/strong&gt; &lt;/p&gt;

&lt;h3&gt;4.4.1 &lt;strong&gt;Server.xml&lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;server.xml&lt;span&gt;几乎保存了所有&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;需要的系统配置信息。最常用的是在此配置用户名、密码及权限。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;4.4.2 &lt;strong&gt;Server.xml&lt;span&gt;配置&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;user &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;schemas&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;e3mall&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;readOnly&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;4.5 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;rule.xml&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;rule.xml&lt;span&gt;里面就定义了我们对表进行拆分所涉及到的规则定义。我们可以灵活的对表使用不同的分片算法，或者对表使用相同的算法但具体的参数不同。这个文件里面主要有&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;这两个标签。在具体使用过程中可以按照需求添加&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和&lt;/span&gt;function&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此配置文件可以不用修改，使用默认即可。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.6 &lt;strong&gt;测试分片&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;4.6.1 &lt;strong&gt;创建表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;配置完毕后，重新启动&lt;/span&gt;mycat&lt;span&gt;。使用&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;客户端连接&lt;/span&gt;&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;，创建表。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Table structure for tb_item&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; `tb_item`;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `tb_item` (
  `id` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品id，同时也是商品编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `title` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品标题&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `sell_point` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品卖点&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `price` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品价格，单位为：分&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `num` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;库存数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `barcode` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品条形码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;500&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品图片&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `cid` &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;所属类目，叶子类目&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `status` &lt;/span&gt;&lt;span&gt;tinyint&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品状态，1-正常，2-下架，3-删除&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `created` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;创建时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  `updated` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;更新时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `cid` (`cid`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `status` (`status`),
  &lt;/span&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; `updated` (`updated`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8 COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;br/&gt;4.6.2 &lt;/span&gt;&lt;strong&gt;插入数据&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;将此文件中的数据插入到数据库：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201808/1135185-20180807233013591-407261492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;4.6.3 &lt;strong&gt;分片测试&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于配置的分片规则为&lt;/span&gt;“auto-sharding-long”，所以&lt;span&gt;mycat&lt;/span&gt;&lt;span&gt;会根据此规则自动分片。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个&lt;/span&gt;datanode&lt;span&gt;中保存一定数量的数据。根据&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;进行分片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经测试&lt;/span&gt;id&lt;span&gt;范围为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Datanode1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;1~5000000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Datanode2&lt;span&gt;：&lt;/span&gt;&lt;span&gt;5000000~10000000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Datanode3&lt;span&gt;：&lt;/span&gt;&lt;span&gt;10000001~15000000&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当&lt;/span&gt;15000000&lt;span&gt;以上的&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;插入时报错：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;[Err] 1064 - can't find any valid datanode :TB_ITEM -&amp;gt; ID -&amp;gt; 15000001&lt;/p&gt;
&lt;p&gt;此时需要添加节点了。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 15:31:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/9440242.html</dc:identifier>
</item>
<item>
<title>AspNetCore+Swagger 生成Model 描述 - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/9440243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/9440243.html</guid>
<description>&lt;h2&gt; 前言：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇文章实现是基于上一篇文章，进下补充：多余的就不多说了，只是为了实现Model的描述生成：有兴趣的可以结合上一篇的进行实现：如有更好的办法希望可以告知谢谢大家！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一篇文章地址： &lt;a href=&quot;https://www.cnblogs.com/szlblog/p/8068311.html&quot;&gt;&lt;span&gt;https://www.cnblogs.com/szlblog/p/8068311.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; 内容：&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;1、：首先根据上一篇文章我们创建&lt;/span&gt;AspNetCoreApi&lt;span&gt;的项目，&lt;/span&gt;&lt;span&gt;OrderServices&lt;/span&gt; &lt;span&gt;如下如所示：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232322024-521974344.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;2、：创建&lt;/span&gt;Core&lt;span&gt;的类库项目并添加&lt;/span&gt;&lt;span&gt;Users&lt;/span&gt;&lt;span&gt;类如下图所示：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232444348-1824264559.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;打开类库的属性：修改输出项：如图所示&lt;/span&gt;：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232502567-1560367159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;点击生成后会自动创建&lt;/span&gt; BusinessBll.xml &lt;span&gt;文档：&lt;/span&gt;&lt;span&gt;BusinessBll.xml&lt;/span&gt; &lt;span&gt;属性修改如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232524451-1977564534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;Users&lt;span&gt;类中内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; BusinessBll
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Users
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户ID
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 密码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Pwd { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户基本信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; UserInfo userInfo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户的基本信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 地址信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt; 3、：&lt;span&gt;在控制器&lt;/span&gt;ValuesController &lt;span&gt;的&lt;/span&gt;Post &lt;span&gt;方法用引用进行引用，如下图所示：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232632358-300103894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;4、：在&lt;/span&gt;Startup&lt;span&gt;类中进行引用：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;项目生成后：会有两个XML&lt;span&gt;文档：所以要使用两个XML文档，如下图所示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　第一个是Web &lt;span&gt;项目生成的&lt;span&gt;SwaggerDesc.xml&lt;span&gt;文档内容如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　第二个文档是类库项目生成的 BusinessBll.xml &lt;span&gt;文档&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232830280-194205545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、：&lt;span&gt;运行项目：结果如下图所示：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1027558/201808/1027558-20180807232908320-436029842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;有不足之处&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;希望大家指出相互学习，&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;                             本文&lt;span&gt;&lt;strong&gt;原创：&lt;/strong&gt;转载请注明出处 谢谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 07 Aug 2018 15:31:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/9440243.html</dc:identifier>
</item>
<item>
<title>数据库之架构：主备+分库？主从+读写分离？ - 尜尜人物</title>
<link>http://www.cnblogs.com/littlecharacter/p/9084291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littlecharacter/p/9084291.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高性能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一致性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;扩展性&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;span&gt;方案一：主备架构，只有主库提供读写服务，备库冗余作故障转移用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201807/955136-20180726220519333-204643999.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://vip:3306/xxdb&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;高可用分析：&lt;/strong&gt;高可用，主库挂了，keepalive（只是一种工具）会自动切换到备库。这个过程对业务层是透明的，无需修改代码或配置。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;高性能分析：&lt;/strong&gt;读写都操作主库，很容易产生瓶颈。大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能。另外，备库只是单纯的备份，资源利用率50%，这点方案二可解决。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一致性分析：&lt;/strong&gt;读写都操作主库，不存在数据一致性问题。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;扩展性分析：&lt;/strong&gt;无法通过加从库来扩展读性能，进而提高整体性能。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;可落地分析：&lt;/strong&gt;两点影响落地使用。第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案。第二，扩展性差，这点可以通过&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/littlecharacter/p/9342129.html&quot; target=&quot;_blank&quot;&gt;分库分表&lt;/a&gt;&lt;/strong&gt;来扩展。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;方案二：双主架构，两个主库同时提供服务，负载均衡&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201807/955136-20180726220751485-1957339512.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;jdbc:mysql://vip:3306/xxdb&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;高可用分析：&lt;/strong&gt;高可用，一个主库挂了，不影响另一台主库提供服务。这个过程对业务层是透明的，无需修改代码或配置。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;高性能分析：&lt;/strong&gt;读写性能相比于方案一都得到提升，提升一倍。&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一致性分析：&lt;/strong&gt;存在数据一致性问题。请看，&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;一致性解决方案&lt;/a&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;扩展性分析：&lt;/strong&gt;当然可以扩展成三主循环，但笔者不建议（会多一层&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;数据同步&lt;/a&gt;&lt;/strong&gt;，这样同步的时间会更长）。如果非得在数据库架构层面扩展的话，扩展为方案四。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可落地分析：&lt;/strong&gt;两点影响落地使用。第一，数据一致性问题，&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;一致性解决方案&lt;/a&gt;&lt;/strong&gt;可解决问题&lt;strong&gt;。&lt;/strong&gt;第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;方案三：主从架构，一主多从，读写分离&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201807/955136-20180726221051131-308922608.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://master-ip:3306/xxdb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://slave1-ip:3306/xxdb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://slave2-ip:3306/xxdb&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;高可用分析：&lt;/strong&gt;主库单点，从库高可用。一旦主库挂了，写服务也就无法提供。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;高性能分析：&lt;/strong&gt;大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能。读的性能提高了，整体性能也提高了。另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引（线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一致性分析：&lt;/strong&gt;存在数据一致性问题。请看，&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;一致性解决方案&lt;/a&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;扩展性分析：&lt;/strong&gt;可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;数据同步&lt;/a&gt;&lt;/strong&gt;完成的时间也会更长）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可落地分析：&lt;/strong&gt;两点影响落地使用。第一，数据一致性问题，&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;一致性解决方案&lt;/a&gt;&lt;/strong&gt;可解决问题&lt;strong&gt;。&lt;/strong&gt;第二，主库单点问题，笔者暂时没想到很好的解决方案。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;注：思考一个问题，一台从库挂了会怎样？读写分离之读的负载均衡策略怎么容错？&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;方案四：双主+主从架构，看似完美的方案&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201807/955136-20180726221444793-662718571.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://vip:3306/xxdb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://slave1-ip:3306/xxdb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jdbc:mysql://slave2-ip:3306/xxdb&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;高可用分析：&lt;/strong&gt;高可用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;高性能分析：&lt;/strong&gt;高性能。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;一致性分析：&lt;/strong&gt;存在数据一致性问题。请看，&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;一致性解决方案&lt;/a&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;扩展性分析：&lt;/strong&gt;可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m2&quot;&gt;同方案二&lt;/a&gt;&lt;/strong&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;可落地分析：&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m2&quot;&gt;同方案二&lt;/a&gt;&lt;/strong&gt;，但&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m1&quot;&gt;数据同步&lt;/a&gt;&lt;/strong&gt;又多了一层，数据延迟更严重&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;第一类：主库和从库一致性解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201807/955136-20180727213418280-1930709441.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：图中圈出的是数据同步的地方，数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的，这个同步时间内主库和从库的数据会存在不一致的情况。如果同步过程中有读请求，那么读到的就是从库中的老数据。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201808/955136-20180802172847620-380680852.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然知道了数据不一致性产生的原因，有下面几个解决方案供参考：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;直接忽略，如果业务允许延时存在，那么就不去管它。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;强制读主，采用&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m3&quot;&gt;主备架构&lt;/a&gt;&lt;/strong&gt;方案，读写都走主库。用缓存来扩展数据库读性能 。有一点需要知道：如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201808/955136-20180802172143153-443159996.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。读请求时，同样的方式生成key先去查Cache，再判断是否命中。若命中，则读主库，否则读从库。代价是多了一次缓存读写，基本可以忽略。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201808/955136-20180802175043114-702506515.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;半同步复制，等主从同步完成，写请求才返回。就是大家常说的“半同步复制”semi-sync。这可以利用数据库原生功能，实现比较简单。代价是写请求时延增长，吞吐量降低。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;数据库中间件，引入开源（mycat等）或自研的数据库中间层。个人理解，思路同&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/littlecharacter/p/9084291.html#m5&quot;&gt;选择读主&lt;/a&gt;。&lt;/strong&gt;数据库中间件的成本比较高，并且还多引入了一层。&lt;strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201808/955136-20180802180602083-1526025202.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;第二类：DB和缓存一致性解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201808/955136-20180802190351707-2134900217.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看一下常用的缓存使用方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：淘汰缓存；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：写入数据库；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步：读取缓存？返回：读取数据库；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：读取数据库后写入缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果按照这种方式，图一，不会产生DB和缓存不一致问题；图二，会产生DB和缓存不一致问题，即4.read先于3.sync执行。&lt;/span&gt;&lt;span&gt;如果不做处理，缓存里的数据可能一直是脏数据。解决方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/955136/201808/955136-20180802191911475-1332840848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;架构演变&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;架构演变一：方案一 -&amp;gt; 方案一+分库分表 -&amp;gt; 方案二+分库分表 -&amp;gt; 方案四+分库分表；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;架构演变二：方案一 -&amp;gt; 方案一+分库分表 -&amp;gt; 方案三+分库分表 -&amp;gt; 方案四+分库分表；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;架构演变三：方案一 -&amp;gt; 方案二 -&amp;gt; 方案四 -&amp;gt; 方案四+分库分表；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;架构演变四：方案一 -&amp;gt; 方案三 -&amp;gt; 方案四 -&amp;gt; 方案四+分库分表；&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;个人见解&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;加缓存和索引是通用的提升数据库性能的方式；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;分库分表带来的好处是巨大的，但同样也会带来一些问题，详见&lt;strong&gt;&lt;a id=&quot;post_title_link_9342129&quot; href=&quot;https://www.cnblogs.com/littlecharacter/p/9342129.html&quot;&gt;数据库之分库分表-垂直？水平？&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不管是主备+分库分表还是主从+读写分离+分库分表，都要考虑具体的业务场景。&lt;/span&gt;&lt;span&gt;58到家发展四年，绝大部分的数据库架构还是采用方案一和方案一+分库分表，只有极少部分用方案三+读写分离+分库分表。另外，阿里云提供的数据库云服务也都是主备方案，要想主从+读写分离需要二次架构。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;记住一句话：不考虑业务场景的架构都是耍流氓。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 07 Aug 2018 15:30:00 +0000</pubDate>
<dc:creator>尜尜人物</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littlecharacter/p/9084291.html</dc:identifier>
</item>
<item>
<title>SocketIo+SpringMvc实现文件的上传下载 - charlyFeng</title>
<link>http://www.cnblogs.com/charlypage/p/9440226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlypage/p/9440226.html</guid>
<description>&lt;p&gt;socketIo不仅可以用来做聊天工具,也可以实现局域网(当然你如果有外网也可用外网)内实现文件的上传和下载,下面是代码的效果演示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1373932/201808/1373932-20180807232151828-2141167808.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GIT地址: https://github.com/fengcharly/sockeio-springMvcUpload.git&lt;/p&gt;
&lt;h2 id=&quot;部分代码如下&quot;&gt;部分代码如下:&lt;/h2&gt;
&lt;h5 id=&quot;服务端的代码&quot;&gt;服务端的代码:&lt;/h5&gt;
&lt;p&gt;ChuanServer:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.channels.FileChannel;

public class ChuanServer {
    public static void protServer(String po) throws IOException {
              int port = Integer.parseInt(po);
        ServerSocket serverSocket = new ServerSocket(port);
        while (true) {
            final Socket clientSocket = serverSocket.accept();

            new Thread() {
                @Override
                public void run() {
                    try {
                        BufferedReader br = new BufferedReader(
                                new InputStreamReader(clientSocket.getInputStream(), &quot;GBK&quot;)
                        );

                        InputStream is = clientSocket.getInputStream();

                        PrintStream pr = new PrintStream(
                                clientSocket.getOutputStream()
                        );

                        pr.println(&quot;我是服务端&quot;);

                        String str = br.readLine();
                        System.out.println(&quot;br.readLine():&quot; + str);
                        System.out.println(&quot;服务端来接收了!!&quot;);
                        out(is, str);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }.start();


        }

    }


    public static void out(InputStream is, String str) throws IOException {
        FileOutputStream fo = new FileOutputStream(&quot;C:\\Users\\Administrator\\Desktop\\upload\\&quot; + str);

        BufferedInputStream bi = new BufferedInputStream(is);
        BufferedOutputStream bo = new BufferedOutputStream(fo);
        int len = 0;
        while ((len=bi.read())!=-1){
            bo.write(len);
        }

        bi.close();
        bo.close();


    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;这里我固定了上传后保存的路径为cusersadministratordesktopupload&quot;&gt;这里我固定了上传后保存的路径为:&quot;C:\Users\Administrator\Desktop\upload\&quot;&lt;/h4&gt;
&lt;p&gt;PortController:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import socket.ChuanServer;
import java.io.IOException;

@Controller
public class PortController {
    @RequestMapping(&quot;/port&quot;)
    public  String port(String port,Model model){
        model.addAttribute(&quot;port&quot;,port);
        try {
            ChuanServer.protServer(port);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return &quot;success&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;再来看下上传的客户端的代码&quot;&gt;再来看下上传的客户端的代码:&lt;/h5&gt;
&lt;p&gt;UpLoadController:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@RequestMapping(&quot;/&quot;)
public class UpLoadController {

    @Autowired
    private UpService upService;


    private String zhuan=&quot;&quot;;

    @RequestMapping(&quot;/upload&quot;)
    public String upload(@RequestParam(value = &quot;file&quot;, required = false) MultipartFile file,
                         HttpServletRequest request, @RequestParam(&quot;iphost&quot;) String iphost,@RequestParam(&quot;port&quot;) String port,Model model) throws IOException {

        String fileName = file.getOriginalFilename();

        InputStream is = file.getInputStream();

        upService.upload(fileName,is,iphost,port);
        return &quot;success&quot;;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UpServiceImpl:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Service
public class UpServiceImpl  implements UpService {

    @Override
    public void upload(String fileName, InputStream is, String iphost, String port) {
        getClientSocket(is, fileName, iphost, port);
    }

//建立socket通信

    public void getClientSocket(InputStream is, String fileName, String iphost, String port) {
        int po = Integer.parseInt(port);
        try {
            Socket socket = new Socket(iphost, po);
            BufferedReader br = new BufferedReader(
                    new InputStreamReader(socket.getInputStream(), &quot;UTF-8&quot;)
            );

            PrintStream pr = new PrintStream(
                    socket.getOutputStream()
            );

            OutputStream os = socket.getOutputStream();

            System.out.println(&quot;客户端给你传文件了!&quot;);
            System.out.println(&quot;文件名为:&quot; + fileName);

            //读取服务器返回的消息
            String str = br.readLine();
            System.out.println(&quot;服务器发来的消息为:&quot; + str);


            pr.println(fileName);


            in(is, os);
            pr.close();
            br.close();
            System.out.println(&quot;客户端已关闭&quot;);

        } catch (Exception e) {
            e.printStackTrace();
        }


    }

    //上传文本
    public static void in(InputStream is, OutputStream os) throws IOException {
        //BIO
        BufferedInputStream bi = new BufferedInputStream(is);
        BufferedOutputStream bo = new BufferedOutputStream(os);
        int len = 0;
        while ((len=bi.read())!=-1){
            bo.write(len);
            System.out.println(len);
        }

        bi.close();
        bo.close();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;这里相应的访问路径为&quot;&gt;这里相应的访问路径为:&lt;/h5&gt;
&lt;p&gt;服务端:http://localhost:8080/&lt;/p&gt;
&lt;p&gt;客户端:http://localhost:8082/upload&lt;/p&gt;
&lt;p&gt;完整项目GIT地址:&lt;/p&gt;
&lt;p&gt;注意: https://github.com/fengcharly/sockeio-springMvcUpload.git&lt;/p&gt;
&lt;p&gt;传输过程中的我们用的是系统提供的BufferedInputStream和BufferedOutputStream缓冲流来传输文件,相对而言传输小文件比较合适,大文件比较慢,可以进一步优化,传输过程中传输速度如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1373932/201808/1373932-20180807232249184-1002900820.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 15:27:00 +0000</pubDate>
<dc:creator>charlyFeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlypage/p/9440226.html</dc:identifier>
</item>
<item>
<title>前端 - 曾经我爱的义无反顾 - 郭菊锋</title>
<link>http://www.cnblogs.com/padding1015/p/9439884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/9439884.html</guid>
<description>&lt;h3&gt;&lt;span&gt;感慨了几千字废话的本文背景：&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　大学毕业后这一年，我很明白作为前端小白所有的东西都要开始学、从头学，所以一年的时间都在埋头恶补。因为在大三开始就有意识的学习html+css布局，大四接过多个布局的项目，所以正式工作时，是以学javascript为入口开始提升，学了scss学pug，学了gulp搭webpack，学了小程序学vue......&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　好像自己一直都在急匆匆的和时间塞跑，但是最关键，也是最重要的，我没有停下来享受每一步的高效。只是像一个狗熊掰玉米似得，捡芝麻扔西瓜，用到西瓜再去找西瓜。没有去做复盘，也没有去做总结，更没有去做反思。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　这段时间又一次遇到了走入职场以来的第N次变故。一个很有前瞻性和远见性的，对我来说很好的技术leader离职了，留下我们这些虾兵蟹将天天的空空然对着电脑发呆。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　这种感觉就好像，一个孤独的人在荒无人烟的迷雾小路上奔跑，没有人给自己带路，只有自己埋头痛跑，但跑了一阵抬头时，才猛然发现已不知自己在什么地方，（面试的时候别人问自己）也不知道路上遇到了什么风景。更不知道接下来自己应该往那个方向跑、还要不要跑？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　加上刚好前段时间自己面试了n家技术岗又频频遭拒，颇受打击。独自走在正午12点北京中关村的大街上，真的是站在十字路口不知道该往哪个方向走。迷茫，彷徨，怀疑。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　明明这一年自己比别人还要努力的学习，为什么收效甚微？自己进步慢也就算了，更折磨人的是，整个前端的大环境还在迅猛的变化！新思想如涨潮的浪接二连三，新技术如雨后春笋层出不穷... ... 根本没有喘息的机会！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　当初毅然决然的转行又是不是错的呢？这条路上我能不能成功呢？我还该不该坚持下去？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　消极下来的我开始自暴自弃，止步不前。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　这是最可怕的，如果没有了方向，如果开始怀疑自己的努力。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　可悲的是，任凭我怎么在人生的黑暗里挣扎，我也只能自我救赎。连最亲最近的人都没有可以理解、帮助的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　我只能自己停下来好好思考人生了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;为什么选择做前端&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　当很多人知道我是设计专业的时候，就会很好奇地问我为什么同一个问题：为什么要像一个傻逼一样放弃自己的专业搞什么流行玩跨界？还是压上了自己的前程和身家性命。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　其实我自己也思考过，在我大三下选择毕设课题的时候我就开始在思考这个未来方向的问题。最终让我决定头也不回的走向前端的原因有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　【归根到底还是毕业的自己想走捷径，决定前端好混，现在看清了又知道自己没能力了，就开始后悔，垃圾。】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 设计艰难，起步低&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　设计艰难相对我自己来说，我虽然学了八年美术，基础底子很强，但是我这个人缺乏创意，缺乏想象力，如果让我做美术生做艺术研究还可以，做设计要事实出新稿想新意我是做不到的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　但不可否认的是，我想象力没那么差劲，只是因为眼界窄，乡巴佬什么也没见过，让我怎么想想高大上的海报效果？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　现在站在局外人的角度，理智分析，之所以错觉上感觉自己设计感很差。是对自己当时的处境非常不了解，对自己的了解不够全面，因此也没有一个改变自己的计划，就好像现在深处前端瓶颈，不知道该如何前进的自己一模一样。但凡当初对自己的处境有丁点前瞻性地认识，坚持下来，培养自己的长处（软件玩的溜就用软件作图），补齐自己的短处（没有设计感没有美感要培养啊），没准现在敢说自己是一个设计师了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　如果让现在的我告诉自己坚持设计，因为不是我审美差而是我没有天赋又没有努力，大学都在煲剧要不就兼职根本没把心思放在学习上，课堂作业随便做。典型的差生还不努力。曾经动画设计参加全国大赛也拿过校一等奖的，还是因为自己的剧本被老师发掘然后逼着我做的作品，所以没有差，只有不努力，不认真对待。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　当初目光短浅急于求成，面对找工作养家糊口的压力，怕自己找不到实习找不到工作，就不再坚持设计而是选了好入门一点并且自己有项目经验的前端。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　对于我来说，前端比设计好混。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2. 前端好混，见效快&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　前端好混不是说现在这个行业这个环境，而是当时相对于我的两个选择来说，我自己在哪个领域更加得心应手：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　之所以觉得前端对于我来说更简单（当时傻逼，别见笑），也是有几点说服自己的理由：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;　　自我感觉的天赋：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　说起这个就有必要追朔一把历史，当初作为一个从河北农村到浙江上学的土包子，初中开始就没再接触过电脑，高中上的美术专业学校不会学习计算机，连查分都是老师代操作。知道大学开学要靠计算机后，入学前暑假自己在家里拿硬纸板画键盘练习打字，借其他高中学校学生的计算机书来读，不过入学后不出意料的计算机基础还是没考及格。后来按学校要求重修计算机，自己去图书馆看书，去网吧练习计算机操作，愣是考了98高分过线。极大的鼓舞了士气。可把自己牛逼坏了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　但是现在想想当时考的都是类似ctrl+c ctrl+v，右键新建-保存这一类的东西，才明白自己当时没考满分真的是窝囊。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　大一下班学期，因为自己设计专业的缘故买了自己全家的第一台电脑，因为设计课学photoshop自己玩的比谁都溜，所有人都来向我请教，更加迷惑了我以为自己很聪明狠了不起的心。要知道他们可是浙江省的学子啊，他们高中计算机都是必修课。。。。（我也不知道我当初为什么会这么自不量力，自我满足，真能自嗨！）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　从小到大一直相信这一句话: 祸兮福所倚，我当初计算机基础挂科后我就有预感，我再靠一次会有不一样的收获。后来事实也印证了我这份感受，也是因为计算机基础挂科，我们就必需选修网页设计课。而这一门通识课，就是教的dreamweaver，也就是我和前端结下深厚友谊的起步。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　包括后来我因为早半年比同班同学接触dreamweaver，导致必修网页设计课、asp编程语言的时候，我的成绩在班里名列前茅。要知道我们都是学设计的啊，自己代码课牛逼真的是被同学仰视的啊！在美术生眼里，计算机学院穿着拖鞋裤衩带着厚眼镜胡子拉碴，但是张口闭口代码编程的小哥哥真的都是神啊（事实上他们都不是那样的，都是干干净净文质彬彬的小帅哥额）！原谅我小小的虚荣心吧，我也想当神。甚至一度想，转专业到计算机学院去。。。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　接触过前端的都知道，&lt;strong&gt;前端入门简单，&lt;/strong&gt;几行css就能实现自己设计图的效果让我有很大的错觉。觉得，嗷吆，，还不错哦！于是对前端产生了很大的兴趣。对于当时的我来说，是真的兴趣而不是骗骗面试官随便说的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　后来也是因为自己极大的兴趣，各种代码课都积极学习，潜心钻研，还不满足的去图书馆找课外书，自己做demo，接项目，以至于关于代码的专业成绩一直在班级名列前茅，提到班里代码好的同学们第一想到的就是我，才在专业老师接到数信学院老师的外包项目时，同学们推荐了我，也才会在班主任朋友找她揪同学去给外边企业做网站时选择了我。种种的一切，让我和前端结缘。这些项目作为我的一个敲门砖，也是我走上不归路的一大原因。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　任何事物，都是有因果联系的。现在回想起来，一切的这些阴差阳错，成就了今天的我。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　但殊不知，这些所谓成功的背后都是因为自己当时的勤学苦练啊。自己也是只看到了收获，忘记了室友们在空调房刷剧自己却跑去图书馆借书而流出的汗水。完全是因为勤能补拙。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　四年本科求学路上，除了兼职挣学费、然后拿着学费应付专业老师作业，除了刷剧支持奔跑吧兄弟，除了关心李晨范冰冰爱情，除了远程“参加”黄晓明baby婚礼，除了守护我的异地恋、除了网吧守卫我方防御塔以外！我是真的把很大的重心都放在研究前端css，研究怎么把自己的设计稿变成网页上去了。没错，这段就是讽刺，我大学四年真的浪费掉了。如果大学学四年前端，出来后我自己就造框架了！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　但事实也确实是我把中心放在了写网页上。最后毕业设计到我们那一年，好巧不巧的有网页设计选题，我选啥？我当然选网页，剩下几个选题：做动画（老师嫌弃我），拍电影（我自己嫌弃我自己），做二维动画（不是我的爱好不是我的菜）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　强势分析了一波如上的因果后，就可以得出，自己选择前端的另一个原因：自己大学的时候接触代码，并且在班级乃至系列“傲视群雄”（哎，别提多煞笔），加之项目加持，简历上写的好看。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　至于别的原因，就是不太重要的其一是自己的好奇心，好奇网页是怎么做成的，代码是怎么发布的，我们是怎么看到的效果。对这一行业饱含求知欲。对未知的憧憬和渴望麻醉了我那本来就不爱思考的大脑。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　还很有冲击力的是，心机的我在招聘网上对比过两个行业的薪资。无非前端钱相对来说多，纠其根本是目光短浅。现在才知道，前端起步高，上升难。而设计起步虽然平稳，但是上升很快。经验不是白积累的，有了作品很好说话。不像前端，拿着作品过去，还要被问底层原理。。。心痛！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　总之，各种机缘巧合吧，我顺着自己世界时代的潮流，一步一步走自己最想走的那一步，没有任何规划，走到了现在这个鬼样子。但凡我当时有点远见，坚持一下设计，没准我现在会在设计的社区里，写文章感叹自己为什么没有选前端，而是做苦逼的设计（设计师别打我）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果说我现在后悔了肯定是会后悔，因为我看到那些美到爆的设计图我也会想如果当初自己坚持一下说不定也可以做出来这样的人间精品。后悔归后悔，既然你选择了前端，也不能再变了。如果这条路上再闯不出一个头破血流，也对不起自己放弃的设计。成功这条路上，没有什么天赋不天赋的加持，后天培养和发奋才是王道。我只是没有静下心来沉淀自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　写到这里突然想问自己：&lt;/span&gt;&lt;span&gt;成功对于我来说是什么？竟没有一个答案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;span&gt;为什么现在坚持不下去了？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　那么，当初自己学习新知识的时候真的就跟打了鸡血一样。为什么现在萎了？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　最近处于低迷期，晚上看电视白天上班犯困，领导走了也不知道自己该干嘛。学习计划算有也算没有，是因为列的计划要不然是不去做要不然就是30%后换另一个去做，感学了觉没用，急于求成。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;总结一批：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　当初打鸡血的原因&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　有压力：毕业压力刺激、家庭困境压迫&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　有兴趣：很多东西都不知道，css简单实现布局很有趣，各种新知识很好奇&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　开心学习： 不知道要学那么多东西，html+css学的很开心，笔记做得很详细&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　无检验有成就感： 自己学的，只是表面上实现，没人问我怎么实现自己也不关心。只是看到自己做的很有成就感，不管内部原理工作机制。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　荣耀： 所有的同学都要向我请教作业问题，甚至抄我的代码。我当老师助手了可以&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　静心： 就想着学好了实现项目、实现自己的要的页面。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　现在萎靡的原因：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　无压力：工作稳定安逸、家庭美满，和谐幸福&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　无兴趣：基本工作项目都能应付，来回也就那么几件事，啰嗦、麻烦，没意思。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　痛苦： 一直在学一直在学，学了语言不算还有成千上万的库和框架推陈出新&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　有检验强烈的挫败感：明明是自己亲手独立承担的项目，为什么问原理自己都不知道？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　丢人： 面试一问三不知真的很丢人。工作中还要改bug解决难题到深夜。学了那么多为什么还是什么都不会，什么都解决补了？！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　心乱： 就想着赶紧学了跳槽。学习是着急的事吗？！&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;知道了原因就要&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;现在颓废主要是拉锯战皮了，针对这一点要去快乐的学习。不要跟拉开的工一样，张弛有度才能持久。玩也不要责备自己，不然把弦儿蹦的太紧反倒对自己长期发展不利。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span&gt;要该吃吃该喝喝该玩玩，但是真正该认真学习做项目的时候一定打起100%精神来，一定要认真对待，写好自己的每一行代码。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span&gt;不要怀疑自己，面试有答不上来很正常。记住自己不会的这个范围或者点，正好可以查漏补缺，就当考试一样对待，曾经最会应付考试了不是吗？！&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span&gt;平时要有意识地学原理知识，不要只停留在不会了查api的知其然不知其所以然的境地。做出的效果究竟是哪几个关键代码起的作用要搞明白。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;span&gt;不要急于求成，今天做的计划就尽善尽美的做完，但是不要列的太多，一扫而过费时间还记不住，就没什么意义。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt; &lt;span&gt;站起来继续走，但是要吃好喝好休息好，学的时候做好背好，最后才能收获好。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h3 align=&quot;justify&quot;&gt;&lt;span&gt;制定计划&lt;/span&gt;&lt;/h3&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;我还没想好，下文吧。。。其实就是想发发牢骚，记录一下现在的状态。也好给后边的计划一个分析的资料。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2018-08-07  22:22:23&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Aug 2018 14:18:00 +0000</pubDate>
<dc:creator>郭菊锋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/padding1015/p/9439884.html</dc:identifier>
</item>
</channel>
</rss>