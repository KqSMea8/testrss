<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第十五节：深入理解async和await的作用及各种适用场景和用法 - Yaopengfei</title>
<link>http://www.cnblogs.com/yaopengfei/p/9249390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopengfei/p/9249390.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. 同步VS异步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.   同步 VS 异步 VS 多线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;同步方法：&lt;/span&gt;需要等待返回结果，才可以继续往下执行业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;异步方法：&lt;/span&gt;无须等待返回结果，可以继续往下执行业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;开启新线程：&lt;/span&gt;在主线程之外开启一个新的线程去执行业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;同步方法和异步方法的本质区别：&lt;/span&gt; 是否需要等待返回结果才能继续执行业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 常见的异步方法（都以Async结尾）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① HttpClient类：PostAsync、PutAsync、GetAsync、DeleteAsync&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② EF中DbContext类：SaveChangesAsync&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 文件相关中的：WriteLineAsync&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701094039964-1694790042.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 引入异步方法的背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如我在后台要向另一台服务器中获取中的2个接口获取信息，然后将两个接口的信息拼接起来，一起输出，接口1耗时3s，接口2耗时5s，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;① 传统的同步方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要的时间大约为：3s + 5s =8s, 如下面 &lt;span&gt;&lt;strong&gt;【案例1】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先分享一个同步请求接口的封装方法，下同。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e4d73ce9-048e-45f8-8040-1d1481efcc23')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_e4d73ce9-048e-45f8-8040-1d1481efcc23&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e4d73ce9-048e-45f8-8040-1d1481efcc23&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e4d73ce9-048e-45f8-8040-1d1481efcc23',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e4d73ce9-048e-45f8-8040-1d1481efcc23&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpService
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 后台跨域请求发送代码
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;url&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;eg:&lt;/span&gt;&lt;span&gt;http://ac.guojin.org/jeesite/regist/saveAppAgentAccount&lt;/span&gt; &lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;param name=&quot;postData&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  参数格式（手拼Json） string postData = &quot;{\&quot;name\&quot;:\&quot;&quot; + vip.comName + &quot;\&quot;,\&quot;shortName\&quot;:\&quot;&quot; + vip.shortName + + &quot;\&quot;}&quot;;             
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PostData(&lt;span&gt;string&lt;/span&gt; postData, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台请求页面&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             Encoding encoding = Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意页面的编码，否则会出现乱码&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;byte&lt;/span&gt;[] requestBytes =&lt;span&gt; encoding.GetBytes(postData);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             req.Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             req.ContentType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             req.ContentLength =&lt;span&gt; requestBytes.Length;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             Stream requestStream =&lt;span&gt; req.GetRequestStream();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             requestStream.Write(requestBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, requestBytes.Length);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            requestStream.Close();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             HttpWebResponse res =&lt;span&gt; (HttpWebResponse)req.GetResponse();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             StreamReader sr = &lt;span&gt;new&lt;/span&gt; StreamReader(res.GetResponseStream(), System.Text.Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; backstr = sr.ReadToEnd();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以读取到从页面返回的结果，以数据流的形式。&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            sr.Close();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            res.Close();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; backstr;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后在分享服务上的耗时操作，下同。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('39bb56c5-2039-42d6-8c1a-2e6a28ced7de')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_39bb56c5-2039-42d6-8c1a-2e6a28ced7de&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_39bb56c5-2039-42d6-8c1a-2e6a28ced7de&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('39bb56c5-2039-42d6-8c1a-2e6a28ced7de',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_39bb56c5-2039-42d6-8c1a-2e6a28ced7de&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 耗时方法  耗时3s
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult GetMsg1()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Thread.Sleep(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Content(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 耗时方法  耗时5s
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult GetMsg2()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             Thread.Sleep(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Content(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面是案例1代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  　　　　　　&lt;span&gt;#region&lt;/span&gt; 案例1(传统同步方式 耗时8s左右)
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; t1 = HttpService.PostData(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; t2 = HttpService.PostData(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{t1},{t2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701095409174-1750600197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;② 开启新线程分别执行两个耗时操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要的时间大约为：Max(3s,5s) = 5s ,如下面&lt;span&gt;&lt;strong&gt;【案例2】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   　　　　　　&lt;span&gt;#region&lt;/span&gt; 案例2(开启新线程分别执行两个耗时操作 耗时5s左右)
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; task1 = Task.Run(() =&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; HttpService.PostData(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; task2 = Task.Run(() =&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; HttpService.PostData(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程进行等待&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                Task.WaitAll(task1, task2);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{task1.Result},{task2.Result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701095846349-1288567533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　既然②方式可以解决同步方法串行耗时间的问题，但这种方式存在一个弊端，一个业务中存在多个线程，且需要对线程进行管理，相对麻烦，从而引出了异步方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;这里的异步方法 我 特指：系统类库自带的以async结尾的异步方法。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;③ 使用系统类库自带的异步方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要的时间大约为：Max(3s,5s) = 5s ,如下面&lt;span&gt;&lt;strong&gt;【案例3】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 　　　　　　&lt;span&gt;#region&lt;/span&gt; 案例3(使用系统类库自带的异步方法 耗时5s左右)
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; r1 = http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; r2 = http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过异步方法的结果.Result可以是异步方法执行完的结果&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                Console.WriteLine(r1.Result.Content.ReadAsStringAsync().Result);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                Console.WriteLine(r2.Result.Content.ReadAsStringAsync().Result);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701100051266-1585118547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS：通过 .Result 来获取异步方法执行完后的结果。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二. 利用async和await封装异步方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 首先要声明几点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① async和await关键字是C# 5.0时代引入的，它是一种异步编程模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 它们本身并不创建新线程，但我可以在自行封装的async中利用Task.Run开启新线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 利用async关键字封装的方法中如果写全部都是一些串行业务, 且不用await关键字，那么即使使用async封装，也并没有什么&lt;/span&gt;&lt;span&gt;卵用，并起不了异步方法的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 需要的时间大约为：3s + 5s =8s, 如下面 &lt;span&gt;&lt;strong&gt;【案例4】&lt;/strong&gt;&lt;/span&gt;，并且封装的方法编译器会提示：“缺少关键字await，将以同步的方式调用，请使用await运算符等待&lt;/span&gt;&lt;span&gt;非阻止API或Task.Run的形式”（PS：非阻止API指系统类库自带的以Async结尾的异步方法）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('adebcccf-8167-47cb-bf17-91b75cd13d2f')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_adebcccf-8167-47cb-bf17-91b75cd13d2f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_adebcccf-8167-47cb-bf17-91b75cd13d2f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('adebcccf-8167-47cb-bf17-91b75cd13d2f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_adebcccf-8167-47cb-bf17-91b75cd13d2f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用async封装同步业务的方法&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; NewMethod5Async()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             Thread.Sleep(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它同步业务&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Msg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; NewMethod6Async()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             Thread.Sleep(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它同步业务&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Msg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;            &lt;span&gt;#region&lt;/span&gt; 案例4(async关键字封装的方法中如果写全部都是一些串行业务 耗时8s左右)
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t1 =&lt;span&gt; NewMethod5Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t2 =&lt;span&gt; NewMethod6Async();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{t1.Result},{t2.Result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701101442665-385640147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;观点结论1：从上面③中可以得出一个结论，async中必须要有await运算符才能起到异步方法的作用，且await 运算符只能加在 系统类库默认提供的异步方法或者新线程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;（如：Task.Run）前面。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 如：下面&lt;span&gt;&lt;strong&gt;【案例5】&lt;/strong&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;strong&gt;【案例6】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;需要的时间大约为：Max(3s,5s) = 5s&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f3b46f66-4754-4b8c-bcb0-f41934949bda')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_f3b46f66-4754-4b8c-bcb0-f41934949bda&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f3b46f66-4754-4b8c-bcb0-f41934949bda&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f3b46f66-4754-4b8c-bcb0-f41934949bda',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f3b46f66-4754-4b8c-bcb0-f41934949bda&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将系统类库提供的异步方法利用async封装起来&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;String&amp;gt;&lt;span&gt; NewMethod1Async()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r1.Content.ReadAsStringAsync().Result;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;String&amp;gt;&lt;span&gt; NewMethod2Async()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r1.Content.ReadAsStringAsync().Result;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将await关键字加在新线程的前面&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; NewMethod3Async()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg = &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; HttpService.PostData(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; NewMethod4Async()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; msg = &lt;span&gt;await&lt;/span&gt; Task.Run(() =&amp;gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; HttpService.PostData(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  　　　　　　&lt;span&gt;#region&lt;/span&gt; 案例5(将系统类库提供的异步方法利用async封装起来 耗时5s左右)
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且先输出“我是主业务”，证明t1和t2是并行执行的，且不阻碍主业务&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t1 =&lt;span&gt; NewMethod1Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t2 =&lt;span&gt; NewMethod2Async();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{t1.Result},{t2.Result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701101633905-1686938941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    　　　　&lt;span&gt;#region&lt;/span&gt; 案例6(将新线程利用async封装起来 耗时5s左右)
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且先输出“我是主业务”，证明t1和t2是并行执行的，且不阻碍主业务&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t1 =&lt;span&gt; NewMethod3Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t2 =&lt;span&gt; NewMethod4Async();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{t1.Result},{t2.Result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701101751717-1924703728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 几个规则和约定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① async封装的方法中，可以有多个await，这里的await代表等待该行代码执行完毕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 我们通常自己封装的方法也要以Async结尾，方便识别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 异步返回类型主要有三种：Task&amp;lt;T&amp;gt; 、Task、Void&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. 测试得出其他几个结论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 如果async封装的异步方法里既有同步业务又有异步业务(开启新线程或者系统类库提供异步方法)，那么同步方法那部分的时间在调用的时候是会阻塞主线程的，&lt;/span&gt;&lt;span&gt;即主线程要等待这部分同步业务执行完才能往下执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如&lt;span&gt;&lt;strong&gt;【案例7】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 耗时：同步操作之和 2s+2s + Max(3s,5s)=9s;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('96ae46fc-5d0f-4680-847c-05af1e46ff16')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_96ae46fc-5d0f-4680-847c-05af1e46ff16&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_96ae46fc-5d0f-4680-847c-05af1e46ff16&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('96ae46fc-5d0f-4680-847c-05af1e46ff16',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_96ae46fc-5d0f-4680-847c-05af1e46ff16&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步耗时操作和异步方法同时封装&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;String&amp;gt;&lt;span&gt; NewMethod7Async()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用异步方法之前还有一个耗时操作&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             Thread.Sleep(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作耗时3s&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r1.Content.ReadAsStringAsync().Result;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;String&amp;gt;&lt;span&gt; NewMethod8Async()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用异步方法之前还有一个耗时操作&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             Thread.Sleep(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作耗时5s&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r1.Content.ReadAsStringAsync().Result;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  　　　　 &lt;span&gt;#region&lt;/span&gt; 案例7(既有普通的耗时操作，也有系统本身的异步方法,耗时9s左右)
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;且大约4s后才能输出 “我是主业务”，证明同步操作Thread.Sleep(2000);  阻塞主线程&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t1 =&lt;span&gt; NewMethod7Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t2 =&lt;span&gt; NewMethod8Async();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{t1.Result},{t2.Result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701102015228-890844691.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;证明：async封装的异步方法里的同步业务的时间会阻塞主线程，再次证明 await只能加在 非阻止api和开启新线程的前面&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 如果封装的异步方法中存在等待的问题，而且不能阻塞主线程(不能用Thread.Sleep) , 这个时候可以用Task.Delay，并在前面加await关键字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如&lt;span&gt;&lt;strong&gt;【案例8】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 耗时：Max（2+3 , 5+2）=7s&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('17cf0477-7e5e-4869-948d-6d48e39f655b')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_17cf0477-7e5e-4869-948d-6d48e39f655b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_17cf0477-7e5e-4869-948d-6d48e39f655b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('17cf0477-7e5e-4869-948d-6d48e39f655b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_17cf0477-7e5e-4869-948d-6d48e39f655b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用Task.Delay(2000);等待&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;String&amp;gt;&lt;span&gt; NewMethod11Async()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用异步方法之前需要等待2s&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作耗时3s&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r1.Content.ReadAsStringAsync().Result;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;String&amp;gt;&lt;span&gt; NewMethod12Async()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用异步方法之前需要等待2s&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作耗时5s&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; r1.Content.ReadAsStringAsync().Result;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  　　　　　　 &lt;span&gt;#region&lt;/span&gt; 案例8(利用Task.Delay执行异步方法的等待操作)
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果是7s，且马上输出“我是主业务”，说明Task.Delay(),单独开启一个线程，不阻塞主线程。&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t1 =&lt;span&gt; NewMethod11Async();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; t2 =&lt;span&gt; NewMethod12Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{t1.Result},{t2.Result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701102238002-378491117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三. 异步方法返回类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Task&amp;lt;T&amp;gt;, 处理含有返回值的异步方法，通过 .Result 等待异步方法执行完，且获取到返回值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. Task：调用方法不需要从异步方法中取返回值，但是希望检查异步方法的状态，那么可以选择可以返回 Task 类型的对象。&lt;/span&gt;&lt;span&gt;不过，就算异步方法中包含 return 语句，也不会返回任何东西。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如&lt;strong&gt;&lt;span&gt;【案例9】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bc4566f7-7512-46e3-a36a-39c96baa36b7')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_bc4566f7-7512-46e3-a36a-39c96baa36b7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bc4566f7-7512-46e3-a36a-39c96baa36b7&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bc4566f7-7512-46e3-a36a-39c96baa36b7',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bc4566f7-7512-46e3-a36a-39c96baa36b7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值为Task的方法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task NewMethod9Async()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作耗时3s&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewMethod9Async执行完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  　　　　　　&lt;span&gt;#region&lt;/span&gt; 案例9(返回值为Task的异步方法)
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果是5s，说明异步方法和主线程的同步方法 在并行执行&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Task t =&lt;span&gt; NewMethod9Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{nameof(t.Status)}: {t.Status}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务状态&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{nameof(t.IsCompleted)}: {t.IsCompleted}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务完成状态标识&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{nameof(t.IsFaulted)}: {t.IsFaulted}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务是否有未处理的异常标识
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行其他耗时操作，与此同时NewMethod9Async也在工作&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 Thread.Sleep(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      
&lt;span&gt;16&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                t.Wait();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{nameof(t.Status)}: {t.Status}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务状态&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{nameof(t.IsCompleted)}: {t.IsCompleted}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务完成状态标识&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{nameof(t.IsFaulted)}: {t.IsFaulted}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务是否有未处理的异常标识&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;所有业务执行完成了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701102703073-605996762.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;PS：对于Task返回值的异步方法，可以调用Wait(),等 待该异步方法执行完，他和await不同，await必须出现在async关键字封装的方法中。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. void：调用异步执行方法，不需要做任何交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如&lt;span&gt;&lt;strong&gt;【案例10】&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3e67b3ea-fde0-4781-b059-307f97cb96fd')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_3e67b3ea-fde0-4781-b059-307f97cb96fd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3e67b3ea-fde0-4781-b059-307f97cb96fd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3e67b3ea-fde0-4781-b059-307f97cb96fd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3e67b3ea-fde0-4781-b059-307f97cb96fd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值是Void的方法&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; NewMethod10Async()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的操作耗时5s&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             HttpClient http = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; httpContent = &lt;span&gt;new&lt;/span&gt; StringContent(&lt;span&gt;&quot;&quot;&lt;/span&gt;, Encoding.UTF8, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行业务，假设这里主需要请求，不需要做任何交互&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; r1 = &lt;span&gt;await&lt;/span&gt; http.PostAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:2788/Home/GetMsg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, httpContent);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewMethod10Async执行完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   　　　　　　&lt;span&gt;#region&lt;/span&gt; 案例10(返回值为Void的异步方法)
&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果是5s，说明异步方法和主线程的同步方法 在并行执行&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 Stopwatch watch =&lt;span&gt; Stopwatch.StartNew();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                NewMethod10Async();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行其他耗时操作，与此同时NewMethod9Async也在工作&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 Thread.Sleep(&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是主业务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;所有业务执行完成了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                watch.Stop();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时：{watch.ElapsedMilliseconds}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1031302/201807/1031302-20180701103051062-1620102944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四. 几个结论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 异步方法到底开不开起新线程？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span id=&quot;mt98&quot; class=&quot;sentence&quot; data-guid=&quot;2ae6180e4fcd8fa9b0d80b08a00a5578&quot; data-source=&quot;The async and await keywords don't cause additional threads to be created.&quot;&gt;异步和等待关键字不会导致其他线程创建。 &lt;span id=&quot;mt99&quot; class=&quot;sentence&quot; data-guid=&quot;33390e9e92729145cf685aae4df79cb4&quot; data-source=&quot;Async methods don't require multithreading because an async method doesn't run on its own thread.&quot;&gt;因为异步方法本身并不会运行的线程，异步方法不需要多线程。 &lt;span id=&quot;mt100&quot; class=&quot;sentence SentenceHover&quot; data-guid=&quot;e1cd3a1660c3a175768b91d2258ea05c&quot; data-source=&quot;The method runs on the current synchronization context and uses time on the thread only when the method is active.&quot;&gt;只有 + 当方法处于活动状态，则方法在当前同步上下文中运行并使用在线程的时间。 &lt;span id=&quot;mt101&quot; class=&quot;sentence&quot; data-guid=&quot;c681fb528c79c59804a5dbf1a87a5504&quot; data-source=&quot;You can use &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;Task&amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; xmlns=&amp;quot;&amp;quot;&amp;gt;.Run to move CPU-bound work to a background thread, but a background thread doesn't help with a process that's just waiting for results to become available.&quot;&gt;可以使用 &lt;span&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.threading.tasks.task.run(v=vs.110).aspx&quot;&gt;Task&lt;span&gt;.Run&lt;/span&gt;&lt;/a&gt; 移动 CPU 工作移到后台线程，但是，后台线程不利于等待结果变得可用处理。（来自MSDN原话）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2. async和await是一种异步编程模型，它本身并不能开启新线程，多用于将一些非阻止API或者开启新线程的操作封装起来，使其调用的时候像同步方法一样使用。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五. 参考资料&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　1. 反骨仔：http://www.cnblogs.com/liqingwen/p/5831951.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　 http://www.cnblogs.com/liqingwen/p/5844095.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. MSDN：https://msdn.microsoft.com/library/hh191443(vs.110).aspx&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PS：如果你想了解多线程的其他知识，请移步：&lt;/span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/yaopengfei/p/9206924.html&quot;&gt;那些年我们一起追逐的多线程(Thread、ThreadPool、委托异步调用、Task/TaskFactory、Parallerl、async和await)&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;






&lt;div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;作       者 : &lt;span&gt;Yaopengfei(姚鹏飞)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;博客地址 : &lt;a href=&quot;http://www.cnblogs.com/yaopengfei/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yaopengfei/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;声     明1 : 本人才疏学浅，用郭德纲的话说“我是一个小学生”，如有错误，欢迎讨论，请勿谩骂^_^。&lt;/li&gt;
&lt;li&gt;声     明2 : 原创博客请在转载时保留原文链接或在文章开头加上本人博客地址，如需代码请加我QQ：604649488 （备注：评论的博客名）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Sun, 01 Jul 2018 23:53:00 +0000</pubDate>
<dc:creator>Yaopengfei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaopengfei/p/9249390.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 的 3D 工业互联网展示方案 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/9244445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/9244445.html</guid>
<description>&lt;p&gt;通用电气（GE）、IBM、英特尔等公司主推的“工业互联网”正在经历“产品－数据分析平台－应用－生态”的演进。这主要得益于 Predix 数据分析平台对工业互联网应用的整合能力。Predix 就像工业数据领域的 iOS 或者安卓系统一样，能够让工程师自己建立模型和应用，打通前方数以万计的传感器和后方每天增加超过 5000 万条的数据库。&lt;/p&gt;&lt;p&gt;在实际应用中，东方航空公司在 Predix 上使用工业互联网应用搜集了 500 多台 CFM56 发动机的高压涡轮叶片保修数据，结合远程诊断纪录和第三方数据，建立了叶片损伤分析预测模型。从前，航空公司需要定期强制飞机“休病假”，把微型摄像头伸入发动机内进行检查。现在，只要根据数据分析平台上的结果就可以预测发动机的运行情况，定制科学的重复检查间隔，提升运营效率。除去航空领域，工厂仓库的监管也是非常需要互联网的介入，不仅能够实时监控仓库当前的数据和信息，还能够降低仓库监管人员的数量，更能够预测仓库故障信息并提前告知工作人员采取对应的措施，能够有效地避免工厂运营暂停导致的损失。&lt;/p&gt;&lt;p&gt;这个例子是采用 es6 的模块化的方式部署的。打开 index.html 进入 lib/index.js，源码是在 src 文件夹中，我们直接进 src/view 下的 index.js &lt;/p&gt;&lt;div readability=&quot;388.24413710162&quot;&gt;
&lt;h2&gt;场景布局&lt;/h2&gt;
&lt;p&gt;我们将页面上的每个部分分开来放在不同的 js 文件中，就是上面加载的 js export 的部分，根层容器 BorderLayout（整体最外层的 div），整张图上的部分都是基于 borderLayout 的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201807/591709-20180701225345274-1370123635.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最外层容器 BorderLayout 是在 src/view/common 下的 BorderLayout.js 中自定义的类，其中 ht.Default.def(className, superClass, methods) 是 HT 中封装的自定义类的函数，其中 className 为自定义类名， superClass 为要继承的父类，methods 为方法和变量声明，要使用这个方法要先在外部定义这个函数变量，通过 functionName.superClass.constructor.call(this) 方法继承。BorderLayout 自定义类继承了 ht.ui.drawable.BorderLayout 布局组件，此布局器将自身空间划分为上、下、左、右、中间五个区域，每个区域可以放置一个子组件。为了能正常交互，重写 getSplitterAt 函数将 splitterRect 的宽度修改为 10，以及为了调整左侧 splitterCanvas 的尺寸，以便挡住子组件而重写的 layoutSplitterCanvas 两个方法：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
let BorderLayout = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    BorderLayout.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setContinuous(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setSplitterSize(0&lt;span&gt;);
};

ht.Default.def(BorderLayout, ht.ui.BorderLayout, {&lt;/span&gt;&lt;span&gt;// &lt;/span&gt;&lt;span&gt;自定义类&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * splitter 宽度都为 0，为了能正常交互，重写此函数将 splitterRect 的宽度修改为 10
     * @override
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    getSplitterAt: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; (event) {&lt;span&gt;// &lt;/span&gt;&lt;span&gt;获取事件对象下分隔条所在的区域&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; leftRect = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._leftSplitterRect, lp;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (leftRect) {
            leftRect &lt;/span&gt;=&lt;span&gt; ht.Default.clone(leftRect);
            leftRect.width &lt;/span&gt;= 10&lt;span&gt;;
            leftRect.x &lt;/span&gt;-= 5&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Event)
                lp &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lp(event);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                lp &lt;/span&gt;=&lt;span&gt; event;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ht.Default.containsPoint(leftRect, lp)) &lt;span&gt;return&lt;/span&gt; 'left'&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; BorderLayout.superClass.getSplitterAt.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, event);
    },
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 调整左侧 splitterCanvas 的尺寸，以便挡住子组件
     * @override
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    layoutSplitterCanvas: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(canvas, x, y, width, height, region) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (region === 'left'&lt;span&gt;) {
            canvas.style.pointerEvents &lt;/span&gt;= ''&lt;span&gt;;
            canvas.style.display &lt;/span&gt;= 'block'&lt;span&gt;;
            ht.Default.setCanvas(canvas, &lt;/span&gt;10&lt;span&gt;, height);
            canvas.style.left &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.getContentLeft() + &lt;span&gt;this&lt;/span&gt;.tx() + x - 5 + 'px'&lt;span&gt;;
            canvas.style.top &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.getContentTop() + &lt;span&gt;this&lt;/span&gt;.ty() + y + 'px'&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            BorderLayout.superClass.layoutSplitterCanvas.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, canvas, x, y, width, height, region);
        }
    }
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; BorderLayout;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;左侧栏&lt;/h3&gt;
&lt;p&gt;左侧栏 sidebar，分为 8 个部分：顶部 logo、货位统计表格、进度条、分割线、货物表格、图表、管理组、问题反馈按钮等。&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171121115331790-1519663347.png&quot; alt=&quot;&quot; width=&quot;134&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以查看 src/view 下的 sidebar.js 文件，这个 js 文件中同样加载了  src/view/common 下的TreeHoverBackgroundDrawable.js 和 ProgressBarSelectBarDrawable.js 中的  TreeHoverBackgroundDrawable 和 ProgressBarSelectBarDrawable 变量，以及 src/controller 下的 sidebar.js 中的 controller 变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import TreeHoverBackgroundDrawable from './common/TreeHoverBackgroundDrawable.js'&lt;span&gt;;
import ProgressBarSelectBarDrawable from './common/ProgressBarSelectBarDrawable.js'&lt;span&gt;;
import controller from '../controller/sidebar.js';&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HT 封装了一个 ht.ui.VBoxLayout 函数，用来将子组件放置在同一垂直列中，我们可以将左侧栏要显示的部分都放到这个组件中，这样所有的部分都是以垂直列排布：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let vBoxLayout = &lt;span&gt;new&lt;/span&gt; ht.ui.VBoxLayout();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此布局器将子组件放置在同一垂直列中；&lt;/span&gt;
vBoxLayout.setBackground('#17191a'); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顶部 logo 是根据在 Label 标签上添加 icon 的方法来实现的，并将这个 topLabel 添加进垂直列 vBoxLayout 中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201807/591709-20180701225724236-1797746463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let topLabel = &lt;span&gt;new&lt;/span&gt; ht.ui.Label(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标签组件&lt;/span&gt;
topLabel.setText('Demo-logo');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文字内容&lt;/span&gt;
topLabel.setIcon('imgs/logo.json');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置图标，可以是颜色或者图片等&lt;/span&gt;
topLabel.setIconWidth(41&lt;span&gt;);
topLabel.setIconHeight(&lt;/span&gt;37&lt;span&gt;);
topLabel.setTextFont(&lt;/span&gt;'18px arial, sans-serif'&lt;span&gt;);
topLabel.setTextColor(&lt;/span&gt;'#fff'&lt;span&gt;);
topLabel.setPreferredSize(&lt;/span&gt;1, 64);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件自身最合适的尺寸&lt;/span&gt;
topLabel.setBackground('rgb(49,98,232)'&lt;span&gt;);
vBoxLayout.addView(topLabel, {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将子组件加到容器中&lt;/span&gt;
    width: 'match_parent'&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 填满父容器 &lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于“货位统计表格”，我们采用的是 HT 封装的 TreeTableView 组件，以树和表格的组合方式呈现 DataModel 中数据元素属性及父子关系，并将这个“树表”添加进垂直列 vBoxLayout 中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201807/591709-20180701225811548-464082539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
let shelfTreeTable = &lt;span&gt;new&lt;/span&gt; ht.ui.TreeTableView();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树表组件，以树和表格的组合方式呈现 DataModel 中数据元素属性及父子关系&lt;/span&gt;
shelfTreeTable.setHoverBackgroundDrawable(&lt;span&gt;new&lt;/span&gt; TreeHoverBackgroundDrawable('#1ceddf', 2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 hover 状态下行选中背景的 Drawable 对象&lt;/span&gt;
shelfTreeTable.setSelectBackgroundDrawable(&lt;span&gt;new&lt;/span&gt; TreeHoverBackgroundDrawable('#1ceddf', 2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置行选中背景的 Drawable 对象 参数为“背景&lt;/span&gt;
shelfTreeTable.setBackground(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
shelfTreeTable.setIndent(&lt;/span&gt;20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置不同层次的缩进值&lt;/span&gt;
shelfTreeTable.setColumnLineVisible(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置列线是否可见&lt;/span&gt;
shelfTreeTable.setRowLineVisible(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
shelfTreeTable.setExpandIcon(&lt;/span&gt;'imgs/expand.json');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置展开图标图标，可以是颜色或者图片等&lt;/span&gt;
shelfTreeTable.setCollapseIcon('imgs/collapse.json');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置合并图标图标，可以是颜色或者图片等&lt;/span&gt;
shelfTreeTable.setPreferredSizeRowCountLimit();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置计算 preferredSize 时要限制的数据行数&lt;/span&gt;
shelfTreeTable.setId('shelfTreeTable'&lt;span&gt;);
vBoxLayout.addView(shelfTreeTable, {
    width: &lt;/span&gt;'match_parent'&lt;span&gt;,
    height: &lt;/span&gt;'wrap_content',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件自身首选高度&lt;/span&gt;
    marginTop: 24&lt;span&gt;,
    marginLeft: &lt;/span&gt;4&lt;span&gt;, 
    marginRight: &lt;/span&gt;4&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在设置“行选中”时背景传入了一个 TreeHoverBackgroundDrawable 对象，这个对象是在 src\view\common 下的 TreeHoverBackgroundDrawable.js 文件中定义的，其中 ht.Default.def(className, superClass, methods) 是 HT 中封装的自定义类的函数，其中 className 为自定义类名， superClass 为要继承的父类，methods 为方法和变量声明，要使用这个方法要先在外部定义这个函数变量，通过 functionName.superClass.constructor.call(this) 方法继承。TreeHoverBackgroundDrawable 自定义类继承了 ht.ui.drawable.Drawable 组件用于绘制组件背景、图标等，只重写了 draw 和 getSerializableProperties 两个方法，我们在 draw 方法中重绘了 shelfTreeTable 的行选中背景色，并重载了  getSerializableProperties 序列化组件函数，并将 TreeHoverBackgroundDrawable 传入的参数作为 map 中新添加的属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
let TreeHoverBackgroundDrawable = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(color, width) {
    TreeHoverBackgroundDrawable.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setColor(color);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setWidth(width);
};
ht.Default.def(TreeHoverBackgroundDrawable, ht.ui.drawable.Drawable, {
    ms_ac: [&lt;/span&gt;'color', 'width'&lt;span&gt;],
    draw: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(x, y, width, height, data, view, dom) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
            g &lt;/span&gt;=&lt;span&gt; view.getRootContext(dom),
            color &lt;/span&gt;=&lt;span&gt; self.getColor();
       
        g.beginPath();
        g.fillStyle &lt;/span&gt;=&lt;span&gt; color;
        g.rect(x, y, self.getWidth(), height);
        g.fill();
    },
    getSerializableProperties: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parentProperties = TreeHoverBackgroundDrawable.superClass.getSerializableProperties.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; addMethod(parentProperties, {
            color: &lt;/span&gt;1, width: 1&lt;span&gt;
        });
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记住要导出 TreeHoverBackgroundDrawable ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; TreeHoverBackgroundDrawable;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HT 还封装了非常好用的 ht.ui.ProgressBar 组件，可直接绘制进度条：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201807/591709-20180701225922924-450119355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
let progressBar = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.ProgressBar();
progressBar.setId(&lt;/span&gt;'progressBar'&lt;span&gt;);
progressBar.setBackground(&lt;/span&gt;'#3b2a00');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件的背景，可以是颜色或者图片等&lt;/span&gt;
progressBar.setBar('rgba(0,0,0,0)');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置进度条背景，可以是颜色或者图片等&lt;/span&gt;
progressBar.setPadding(5&lt;span&gt;);
progressBar.setSelectBarDrawable(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ProgressBarSelectBarDrawable('#c58348', '#ffa866')); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置前景(即进度覆盖区域)的 Drawable 对象，可以是颜色或者图片等&lt;/span&gt;
progressBar.setValue(40);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置当前进度值&lt;/span&gt;
progressBar.setBorderRadius(0&lt;span&gt;);
vBoxLayout.addView(progressBar, {
    marginTop: &lt;/span&gt;24&lt;span&gt;,
    width: &lt;/span&gt;'match_parent'&lt;span&gt;,
    height: &lt;/span&gt;28&lt;span&gt;,
    marginBottom: &lt;/span&gt;24&lt;span&gt;,
    marginLeft: &lt;/span&gt;14&lt;span&gt;,
    marginRight: &lt;/span&gt;14&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在 设置“前景”的时候传入了一个 ProgressBarSelectBarDrawable 对象，这个对象在 src\view\common 下的 ProgressBarSelectBarDrawable.js 中定义的。具体定义方法跟上面的 TreeHoverBackgroundDrawable 函数对象类似，这里不再赘述。&lt;/p&gt;
&lt;p&gt;分割线的制作最为简单，只要将一个矩形的高度设置为 1 即可，我们用 ht.ui.View() 组件来制作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let separator = &lt;span&gt;new&lt;/span&gt; ht.ui.View();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有视图组件的基类，所有可视化组件都必须从此类继承&lt;/span&gt;
separator.setBackground('#666'&lt;span&gt;);
vBoxLayout.addView(separator, {
    width: &lt;/span&gt;'match_parent'&lt;span&gt;,
    height: &lt;/span&gt;1&lt;span&gt;,
    marginLeft: &lt;/span&gt;14&lt;span&gt;, 
    marginRight: &lt;/span&gt;14&lt;span&gt;,
    marginBottom: &lt;/span&gt;24&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;货物表格的操作几乎和货位统计表格相同，这里不再赘述。&lt;/p&gt;
&lt;p&gt;我们将一个 json 的图表文件当做图片传给图表的组件容器作为背景，也能很轻松地操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let chartView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.View();
chartView.setBackground(&lt;/span&gt;'imgs/chart.json'&lt;span&gt;);
vBoxLayout.addView(chartView, {
    width: &lt;/span&gt;173&lt;span&gt;,
    height: &lt;/span&gt;179&lt;span&gt;,
    align: &lt;/span&gt;'center'&lt;span&gt;,
    marginBottom: &lt;/span&gt;10&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;管理组和顶部 logo 的定义方式类似，这里不再赘述。&lt;/p&gt;
&lt;p&gt;问题反馈按钮，我们将这个部分用 HT 封装的 ht.ui.Button 组件来制作，并将这个部分添加进垂直列 vBoxLayout 中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171121162941321-2020856671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let feedbackButton = &lt;span&gt;new&lt;/span&gt; ht.ui.Button();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按钮类&lt;/span&gt;
feedbackButton.setId('feedbackButton'&lt;span&gt;);
feedbackButton.setText(&lt;/span&gt;'问题反馈：service@hightopo.com'&lt;span&gt;);
feedbackButton.setIcon(&lt;/span&gt;'imgs/em.json'&lt;span&gt;);
feedbackButton.setTextColor(&lt;/span&gt;'#fff'&lt;span&gt;);
feedbackButton.setHoverTextColor(shelfTreeTable.getHoverLabelColor());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 hover 状态下文字颜色&lt;/span&gt;
feedbackButton.setActiveTextColor(feedbackButton.getHoverTextColor());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 active 状态下文字颜色&lt;/span&gt;
feedbackButton.setIconWidth(16&lt;span&gt;);
feedbackButton.setIconHeight(&lt;/span&gt;16&lt;span&gt;);
feedbackButton.setIconTextGap(&lt;/span&gt;10&lt;span&gt;);
feedbackButton.setAlign(&lt;/span&gt;'left'&lt;span&gt;);
feedbackButton.setBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
feedbackButton.setHoverBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
feedbackButton.setActiveBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
vBoxLayout.addView(feedbackButton, {
    width: &lt;/span&gt;'match_parent'&lt;span&gt;,
    marginTop: &lt;/span&gt;5&lt;span&gt;,
    marginBottom: &lt;/span&gt;10&lt;span&gt;,
    marginLeft: &lt;/span&gt;20&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;交互&lt;/h2&gt;
&lt;p&gt;视图部分做好了，在模块化开发中，controller 就是做交互的部分，shelfTreeTable 货位统计表格， cargoTreeTable 货物表格， feedbackButton 问题反馈按钮， progressBar  进度条四个部分的交互都是在在 src/controller 下的 sidebar.js 中定义的。通过 findViewById(id, recursive) 根据id查找子组件，recursive 表示是否递归查找。&lt;/p&gt;
&lt;p&gt;shelfTreeTable 货位统计表格的数据绑定传输方式与 cargoTreeTable 货物表格类似，这里我们只对 shelfTreeTable 货位统计表格的数据绑定进行解析。shelfTreeTable 一共有三列，其中不同的部分只有“已用”和“剩余”两个部分，所以我们只要将这两个部分进行数据绑定即可，先创建两列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let column = &lt;span&gt;new&lt;/span&gt; ht.ui.Column();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 列数据，用于定义表格组件的列信息&lt;/span&gt;
column.setName('used');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置数据元素名称&lt;/span&gt;
column.setAccessType('attr');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在这里 name 为 used，采用 getAttr('used') 和 setAttr('used', 98) 的方式存取 set/getAttr 简写为 a&lt;/span&gt;
column.setWidth(65&lt;span&gt;);
column.setAlign(&lt;/span&gt;'center'&lt;span&gt;);
columnModel.add(column);

column &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.Column();
column.setName(&lt;/span&gt;'remain'&lt;span&gt;);
column.setAccessType(&lt;/span&gt;'attr'&lt;span&gt;);
column.setWidth(&lt;/span&gt;65&lt;span&gt;);
column.setAlign(&lt;/span&gt;'center'&lt;span&gt;);
columnModel.add(column);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着遍历 json 文件，将 json 文件中对应的 used、remain以及 labelColors 通过 set/getAttr 或 简写 a 的方式进行数据绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; json.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row = json[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 json 中的属性&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Data();
    data.setIcon(row.icon);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 json 中的 icon 传过来&lt;/span&gt;
&lt;span&gt;    data.setName(row.name);
    data.a(&lt;/span&gt;'used'&lt;span&gt;, row.used);
    data.a(&lt;/span&gt;'remain'&lt;span&gt;, row.remain);
    data.a(&lt;/span&gt;'labelColors'&lt;span&gt;, row.colors);
    data.setIcon(row.icon);
    treeTable.dm().add(data);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在树表组件的数据模型中添加这个 data 节点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; children =&lt;span&gt; row.children;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (children) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; children.length; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; child =&lt;span&gt; children[j];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; childData = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Data();
            childData.setName(child.name);
            childData.setIcon(child.icon);
            childData.a(&lt;/span&gt;'used'&lt;span&gt;, child.used);
            childData.a(&lt;/span&gt;'remain'&lt;span&gt;, child.remain);
            childData.a(&lt;/span&gt;'labelColors'&lt;span&gt;, child.colors);
            childData.setParent(data);
            treeTable.dm().add(childData);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后在 controller 函数对象中调用 这个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
initTreeTableDatas(shelfTreeTable, json);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; json 为 ../model/shelf.json 传入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;progressBar 进度条的变化是通过设置定时器改变 progressBar 的 value 值来动态改变的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
setInterval(() =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (progressBar.getValue() &amp;gt;= 100&lt;span&gt;) {
        progressBar.setValue(&lt;/span&gt;0&lt;span&gt;);
    }
    progressBar.setValue(progressBar.getValue() &lt;/span&gt;+ 1&lt;span&gt;);
}, &lt;/span&gt;50);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;feedbackButton 问题反馈按钮，通过增加 View 事件监听器来监听按钮的点击事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
feedbackButton.addViewListener(e =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.kind === 'click') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HT 自定义的事件属性，具体查看 http://hightopo.com/guide/guide/core/beginners/ht-beginners-guide.html&lt;/span&gt;
        window.location.href = &quot;mailto:service@www.hightopo.com&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前页面打开URL页面&lt;/span&gt;
&lt;span&gt;    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;右侧容器splitLayout&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171121115445680-1296456808.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接用的分割组件 ht.ui.SplitLayout 进行分割布局：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let splitLayout = &lt;span&gt;new&lt;/span&gt; ht.ui.SplitLayout();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此布局器将自身空间划分为上、下两个区域或左、右两个区域，每个区域可以放置一个子组件&lt;/span&gt;
splitLayout.setSplitterVisible(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
splitLayout.setPositionType(&lt;/span&gt;'absoluteFirst'&lt;span&gt;);
splitLayout.setOrientation(&lt;/span&gt;'v');
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;右侧头部 header&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        &lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171121115532305-2129048603.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个 header 是从 src/view 下的 header.js 中获取的对象，为 ht.ui.RelativeLayout 相对定位布局器，分为 5 个部分：searchField 搜索框、titleLabel 主标题、temperatureLabel1 温度、humidityLabel1 湿度以及 airpressureLabel1 气压。&lt;/p&gt;
&lt;p&gt;这里我们没有对“搜索框” searchField 进行数据绑定，以及搜索的功能，这只是一个样例，不涉及业务部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
let searchField = &lt;span&gt;new&lt;/span&gt; ht.ui.TextField();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本框组件&lt;/span&gt;
searchField.setBorder(&lt;span&gt;new&lt;/span&gt; ht.ui.border.LineBorder(1, '#d8d8d8'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在组件的画布上绘制直线边框&lt;/span&gt;
searchField.setBorderRadius(12&lt;span&gt;);
searchField.setBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
searchField.setIcon(&lt;/span&gt;'imgs/search.json'&lt;span&gt;);
searchField.setIconPosition(&lt;/span&gt;'left'&lt;span&gt;);
searchField.setPadding([&lt;/span&gt;2, 16, 2, 16&lt;span&gt;]);
searchField.setColor(&lt;/span&gt;'rgb(138, 138, 138)'&lt;span&gt;);
searchField.setPlaceholder(&lt;/span&gt;'Find everything...'&lt;span&gt;);
searchField.getView().className &lt;/span&gt;= 'search'&lt;span&gt;;
header.addView(searchField, {
    width: &lt;/span&gt;180&lt;span&gt;,
    marginLeft: &lt;/span&gt;20&lt;span&gt;,
    vAlign: &lt;/span&gt;'middle'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 titleLabel 主标题比较简单，和温度、湿度以及气压类似，我就只说明一下主标题 titleLabel 的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
let titleLabel = &lt;span&gt;new&lt;/span&gt; ht.ui.Label();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标签组件&lt;/span&gt;
titleLabel.setId('title'&lt;span&gt;);
titleLabel.setIcon(&lt;/span&gt;'imgs/expand.json'&lt;span&gt;);
titleLabel.setTextColor(&lt;/span&gt;'rgb(138, 138, 138)'&lt;span&gt;);
titleLabel.setText(&lt;/span&gt;'杭州仓库'&lt;span&gt;);
titleLabel.setHTextPosition(&lt;/span&gt;'left');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文字在水平方向相对于图标的位置，默认值为 'right'&lt;/span&gt;
titleLabel.setIconTextGap(10);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置图标和文字之间的间距&lt;/span&gt;
titleLabel.setBorder(&lt;span&gt;new&lt;/span&gt; ht.ui.border.IndividualLineBorder(0, 0, 3, 0, '#3162e8'))&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在组件的画布上绘制直线边框；与 LineBorder 不同的是，此边框可以单独绘制某一个或几个方向的边框&lt;/span&gt;
titleLabel.setTextFont('16px arial'&lt;span&gt;);

header.addView(titleLabel, {
    height: &lt;/span&gt;'match_parent'&lt;span&gt;,
    width: &lt;/span&gt;'wrap_content'&lt;span&gt;,
    align: &lt;/span&gt;'center'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后交互部分在 src/controller 下的 header.js 中做了右键点击出现菜单栏以及单击 titleLabel 的位置出现下拉菜单两种交互，通过控制鼠标的点击事件来控制事件的交互：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;let title, contextMenu;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; controller (view) {
    title &lt;/span&gt;= view.findViewById('title'&lt;span&gt;);

    contextMenu &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.ui.ContextMenu();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右键菜单组件&lt;/span&gt;
    contextMenu.setLabelColor('rgb(138, 138, 138)'&lt;span&gt;);
    contextMenu.setHoverRowBackground(&lt;/span&gt;'#3664e4'&lt;span&gt;);
    contextMenu.setItems([
        {
            label: &lt;/span&gt;'北京仓库'&lt;span&gt;
        },
        {
            label: &lt;/span&gt;'上海仓库'&lt;span&gt;
        },
        {
            label: &lt;/span&gt;'厦门仓库'&lt;span&gt;
        }
    ]);

    contextMenu.addViewListener((e) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.kind === 'action') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HT 自定义的事件类型&lt;/span&gt;
&lt;span&gt;            title.setText(e.item.label);
        }
    });

    title.getView().addEventListener(&lt;/span&gt;'mousedown', e =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contextMenu.isInDOM()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断组件是否在 DOM 树中&lt;/span&gt;
            contextMenu.hide();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 隐藏菜单&lt;/span&gt;
            document.removeEventListener('mousedown', handleWindowClick);&lt;span&gt;// &lt;/span&gt;&lt;span&gt;移除mousedown监听事件&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有右键点击过&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; items =&lt;span&gt; contextMenu.getItems();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; items.length; i++&lt;span&gt;) {
                items[i].width &lt;/span&gt;=&lt;span&gt; title.getWidth();
            }

            let windowInfo &lt;/span&gt;= ht.Default.getWindowInfo(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前窗口left|top|width|height的参数信息&lt;/span&gt;
                titleRect =&lt;span&gt; title.getView().getBoundingClientRect();
            contextMenu.show(windowInfo.left &lt;/span&gt;+ titleRect.left, windowInfo.top + titleRect.top +&lt;span&gt; titleRect.height);

            document.addEventListener(&lt;/span&gt;'mousedown'&lt;span&gt;, handleWindowClick);
        }
    });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; handleWindowClick(e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!contextMenu.getView().contains(e.target) &amp;amp;&amp;amp; !title.getView().contains(e.target)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断元素是否在数组中&lt;/span&gt;
&lt;span&gt;        contextMenu.hide();
        document.removeEventListener(&lt;/span&gt;'mousedown'&lt;span&gt;, handleWindowClick);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;右侧下部分 RelativeLayout 相对布局器（相对于右侧下部分最根层 div），包含中间显示 3d 部分 graph3dView、双击货柜或货物才会出现的 shelfPane、以及出现在右下角的图表 chartPane，将这三部分添加进 RelativeLayout 相对布局容器：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;           &lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201711/591709-20171121115837055-1200527140.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
let relativeLayout = &lt;span&gt;new&lt;/span&gt; ht.ui.RelativeLayout();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建相对布局器&lt;/span&gt;
relativeLayout.setId('contentRelative'&lt;span&gt;);
relativeLayout.setBackground(&lt;/span&gt;'#060811'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; htView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.HTView(graph3dView);
htView.setId(&lt;/span&gt;'contentHTView'&lt;span&gt;);
relativeLayout.addView(htView, {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 3d 组件添加进relativeLayout 相对布局器&lt;/span&gt;
    width: 'match_parent'&lt;span&gt;,
    height: &lt;/span&gt;'match_parent'&lt;span&gt;
});

relativeLayout.addView(shelfPane, {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将双击出现的详细信息 shelfPane 组件添加进relativeLayout 相对布局器&lt;/span&gt;
    width: 220&lt;span&gt;,
    height: &lt;/span&gt;'wrap_content'&lt;span&gt;,
    align: &lt;/span&gt;'right'&lt;span&gt;,
    marginRight: &lt;/span&gt;30&lt;span&gt;,
    marginTop: &lt;/span&gt;30&lt;span&gt;
});

relativeLayout.addView(chartPane, {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将图表 chartPane 组件添加进relativeLayout 相对布局器&lt;/span&gt;
    width: 220&lt;span&gt;,
    height: &lt;/span&gt;200&lt;span&gt;,
    align: &lt;/span&gt;'right'&lt;span&gt;,
    vAlign: &lt;/span&gt;'bottom'&lt;span&gt;,
    marginRight: &lt;/span&gt;30&lt;span&gt;,
    marginBottom: &lt;/span&gt;30&lt;span&gt;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将右侧相对布局器 relativeLayout 和右侧头部 header 添加进右侧底部容器 splitLayout：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let splitLayout = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.SplitLayout();
splitLayout.setSplitterVisible(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
splitLayout.setPositionType(&lt;/span&gt;'absoluteFirst'&lt;span&gt;);
splitLayout.setOrientation(&lt;/span&gt;'v'&lt;span&gt;);
splitLayout.addView(header, {
    region: &lt;/span&gt;'first'&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定组件所在的区域，可选值为：'first'|'second'&lt;/span&gt;
&lt;span&gt;});
splitLayout.addView(relativeLayout, {
    region: &lt;/span&gt;'second'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再将左侧部分的 sidebar 和右侧部分的所有也就是 splitLayout 添加进整个底部容器 borderLayout，再将底部容器添加进 html body 体中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
let borderLayout = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BorderLayout();
borderLayout.setLeftWidth(&lt;/span&gt;250&lt;span&gt;);
borderLayout.addView(sidebar, {
    region: &lt;/span&gt;'left',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定组件所在的区域，可选值为：'top'|'right'|'bottom'|'left'|'center'&lt;/span&gt;
    width: 'match_parent'&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件自身首选宽度 &lt;/span&gt;
&lt;span&gt;});
borderLayout.addView(splitLayout, {
    region: &lt;/span&gt;'center'&lt;span&gt;
});

borderLayout.addToDOM();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 borderLayout 添加进 body 体中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们具体说说这个相对布局器内部包含的 3d 部分 graph3dView、双击货柜或货物才会出现的 shelfPane、以及出现在右下角的图表 chartPane。&lt;/p&gt;
&lt;h3&gt;3D 场景&lt;/h3&gt;
&lt;p&gt;从 src\view\3d 文件夹中的 index.js 中获取 graph3dView 的外部接口被 src/view 中的 index.js 调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import graph3dView from './3d/index';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201807/591709-20180701230151978-346117761.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这个 3d 场景中可以看到，我们需要“地板”、“墙面”、“货架”、“叉车”、“货物”以及 3d 场景。&lt;/p&gt;
&lt;p&gt;在 3d 文件夹下的 index.js 中，我们从文件夹中导入所有需要的接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里导入的都是一些基础数据&lt;/span&gt;
&lt;span&gt;  sceneWidth, sceneHeight, sceneTall,
  toShelfList, randomCargoType
} from &lt;/span&gt;'./G.js'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟数据接口&lt;/span&gt;
&lt;span&gt;import {
  stockinout,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出入库&lt;/span&gt;
  initiate,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
  inoutShelf&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上下架&lt;/span&gt;
} from './interfaces'&lt;span&gt;;

import { Shelf } from &lt;/span&gt;'./shelf';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 货架&lt;/span&gt;
import { Floor } from './floor';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 地板&lt;/span&gt;
import { Wall } from './wall';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 墙面&lt;/span&gt;
import { Car } from './car';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 叉车&lt;/span&gt;
import { g3d } from './g3d';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3d场景&lt;/span&gt;
import { getCargoById } from './cargo';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 货物&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;g3d.js 文件中只设置了场景以及对部分事件的监听：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
g3d.mi((e) =&amp;gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听事件 addInteractorListener&lt;/span&gt;
  const kind =&lt;span&gt; e.kind;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (kind === 'doubleClickData') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双击图元事件&lt;/span&gt;
    let data = e.data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件相关的数据元素&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; Shelf) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是货架&lt;/span&gt;
      data.setTransparent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

      eventbus.fire({ type: &lt;/span&gt;'cargoBlur' });&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 派发事件，依次调用所有的监听器函数&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      data &lt;/span&gt;= data.a('cargo'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!data) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      data.transparent &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

      eventbus.fire({ type: &lt;/span&gt;'cargoFocus'&lt;span&gt;, data: data });
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = shelfList.length - 1; i &amp;gt;= 0; i--) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 除了双击的图元，其他的图元都设置透明&lt;/span&gt;
      const shelf =&lt;span&gt; shelfList[i];
      shelf.setTransparent(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, data);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (kind === 'doubleClickBackground') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双击背景事件&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (let i = shelfList.length - 1; i &amp;gt;= 0; i--) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双击背景，所有的图元都不透明&lt;/span&gt;
      const shelf =&lt;span&gt; shelfList[i];
      shelf.setTransparent(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }

    eventbus.fire({ type: &lt;/span&gt;'cargoBlur'&lt;span&gt; });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们在 G.js 中定义了一些基础数据，其他引用的 js 中都会反复调用这些变量，所以我们先来解析这个文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
const sceneWidth = 1200;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 场景宽度&lt;/span&gt;
const sceneHeight = 800;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 场景高度&lt;/span&gt;
const sceneTall = 410;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 场景的深度&lt;/span&gt;
&lt;span&gt;
const globalOpacity &lt;/span&gt;= 0.3;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 透明度&lt;/span&gt;
&lt;span&gt;
const cargoTypes &lt;/span&gt;= {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 货物类型，分为四种&lt;/span&gt;
  'cask': {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 木桶&lt;/span&gt;
    'name': 'bucket'&lt;span&gt;
  },
  &lt;/span&gt;'carton': {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 纸箱&lt;/span&gt;
    'name': 'carton'&lt;span&gt;
  },
  &lt;/span&gt;'woodenBox1': {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 木箱1&lt;/span&gt;
    'name': 'woodenBox1'&lt;span&gt;
  },
  &lt;/span&gt;'woodenBox2': {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 木箱2&lt;/span&gt;
    'name': 'woodenBox2'&lt;span&gt;
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面有三个函数，分别是“货架的 obj 分解”、“加载模型”、“随机分配货物的类型”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; toShelfList(list) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将货架的 obj 分解，&lt;/span&gt;
  const obj =&lt;span&gt; {};
  list.forEach((o) &lt;/span&gt;=&amp;gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这边的参数o具体内容可以查看 view/3d/interface.js&lt;/span&gt;
    const strs = o.cubeGeoId.split('-'&lt;span&gt;);

    let rs &lt;/span&gt;=&lt;span&gt; obj[o.rackId];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;rs) {
      rs &lt;/span&gt;= obj[o.rackId] =&lt;span&gt; [];
    }

    const ri &lt;/span&gt;= parseInt(strs[2].substr(1)) - 1&lt;span&gt;;
    let ps &lt;/span&gt;=&lt;span&gt; rs[ri];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ps) {
      ps &lt;/span&gt;= rs[ri] =&lt;span&gt; [];
    }

    let type &lt;/span&gt;= 'cask'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o.inventoryType === 'Import'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((type = randomCargoType()) === 'cask'&lt;span&gt;) {}
    }

    const pi &lt;/span&gt;= parseInt(strs[3].substr(1)) - 1&lt;span&gt;;
    ps[pi] &lt;/span&gt;=&lt;span&gt; {
      id: o.cubeGeoId,
      type: type
    };
  });

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; loadObj(shape3d, fileName, cbFunc) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载模型&lt;/span&gt;
  const path = './objs/' +&lt;span&gt; fileName;
  ht.Default.loadObj(path &lt;/span&gt;+ '.obj', path + '.mtl'&lt;span&gt;, {
    shape3d: shape3d,
    center: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    cube: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    finishFunc: cbFunc
  });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; randomCargoType() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机分配“货物”的类型&lt;/span&gt;
  const keys =&lt;span&gt; Object.keys(cargoTypes);
  const i &lt;/span&gt;= Math.floor(Math.random() *&lt;span&gt; keys.length);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[i];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个 3d 场景中还有不可缺少的“货物”和“货架”以及“叉车”，三者的定义方式类似，这里只对“货架”进行解释。我们直接在“货物”的 js 中引入底下的“托盘”的 js 文件，将它们看做一个整体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import { Pallet } from './pallet'&lt;span&gt;;
import {
  cargoTypes,
  loadObj,
  globalOpacity
} from &lt;/span&gt;'./G';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 src\view\3d\cargo.js 文件中，定义了一个“货物”类，这个类中声明了很多方法，比较基础，有需要的自己可以查看这个文件，这里我不过多解释。主要讲一下如何加载这个“货物”的 obj，我们在 G.js 文件中有定义一个 loadObj 函数，我们在代码顶部也有引入，导入 obj 文件之后就在“货物”的库存增加这个“货物”：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (let type &lt;span&gt;in&lt;/span&gt; cargoTypes) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历 cargoTypes 数组， G.js 中定义的&lt;/span&gt;
  const cargo =&lt;span&gt; cargoTypes[type];
  loadObj(type, cargo.name, (map, array, s3) &lt;/span&gt;=&amp;gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loadObj(shape3d, fileName, cbFunc) cbFunc 中的参数可以参考 obj 手册&lt;/span&gt;
    cargo.s3 = s3;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 cargo 的 s3 设置原始大小&lt;/span&gt;
&lt;span&gt;
    updateCargoSize();
  });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; updateCargoSize() {
  let c, obj;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = cargoList.length - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
    c &lt;/span&gt;=&lt;span&gt; cargoList[i];

    obj &lt;/span&gt;=&lt;span&gt; cargoTypes[c.type];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!obj.s3) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
    c.boxS3 &lt;/span&gt;=&lt;span&gt; obj.s3;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 还有就是界面上“货物”的进出库的动画，主要用的方法是 HT 封装的 ht.Default.startAnim 函数（&lt;a href=&quot;http://hightopo.com/guide/guide/plugin/animation/ht-animation-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 动画手册&lt;/a&gt;），出的动画与进的动画类似，这里不赘述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 货物进&lt;/span&gt;
&lt;span&gt;in&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (anim) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有值，就停止动画&lt;/span&gt;
      anim.stop(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;this&lt;/span&gt;.basicX +&lt;span&gt; moveDistance;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.opacity = 1&lt;span&gt;;

    anim &lt;/span&gt;=&lt;span&gt; ht.Default.startAnim({
      duration: &lt;/span&gt;1500&lt;span&gt;,
      finishFunc: () &lt;/span&gt;=&amp;gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画结束之后调用这个函数，将anim设置为空停止动画&lt;/span&gt;
        anim = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      },
      action: (v, t) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;this&lt;/span&gt;.basicX + (1 - v) * moveDistance;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变x坐标，看起来像向前移动&lt;/span&gt;
&lt;span&gt;      }
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;墙和地板也是比较简单的，简单地继承 ht.Node 和 ht.Shape，这里以“墙”进行解释，继承之后直接在构造函数中进行属性的设置即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
class Wall extends ht.Shape {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 继承 ht.Shape 类&lt;/span&gt;
&lt;span&gt;  constructor(points, segments, tall, thickness, elevation) {
    super();

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setPoints(points);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“点”&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.setSegments(segments);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“点之间的连接方式”&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.setTall(tall);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 控制Node图元在y轴的长度&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.setThickness(thickness);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置“厚度”&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.setElevation(elevation);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 控制Node图元中心位置所在3D坐标系的y轴位置&lt;/span&gt;

    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.s({
      &lt;/span&gt;'all.transparent': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 六面透明&lt;/span&gt;
      'all.opacity': 0.3,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 透明度为 0.3&lt;/span&gt;
      'all.reverse.flip': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 六面的反面显示正面的内容&lt;/span&gt;
      'bottom.visible': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 底面不可见&lt;/span&gt;
&lt;span&gt;    });
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;floor、wall、shelf 以及 car 这四个类都准备完毕，只需要在 src\view\3d\index.js 中 new 一个新的对象并加入到数据模型 dataModel 中即可，这里只展示 car “叉车”的初始化代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; init Car&lt;/span&gt;
const car = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Car();
car.addToDataModel(dm);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于“货物”，我们在这个 js 上是采用定时器调用 in 和 out 方法，这里有一个模拟的数据库 interfaces.js 文件，有需求的可以看一下，这里我们只当数据来调用（进出库和上下架类似，这里只展示进出库的设置方法）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 轮训掉用出入库接口&lt;/span&gt;
setInterval(() =&amp;gt;&lt;span&gt; {
  const obj &lt;/span&gt;= stockinout();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出入库&lt;/span&gt;
  let type = 'cask'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj.inventoryType === 'Import'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;((type = randomCargoType()) === 'cask') {}&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果为“货物”类型为“木桶”&lt;/span&gt;
&lt;span&gt;  }
  car.cargoType &lt;/span&gt;=&lt;span&gt; type;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj.inOutStatus === 'I')&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果值为 “I”，则进库&lt;/span&gt;
    car.&lt;span&gt;in&lt;/span&gt;&lt;span&gt;();
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则为“o”，出库&lt;/span&gt;
&lt;span&gt;    car.out();
}, &lt;/span&gt;30000);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;货架&lt;/h3&gt;
&lt;p&gt;从 src\view\common 文件夹中的 shelfPane.js 中获取 graph3dView 的外部接口被 src/view 中的 index.js 调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import shelfPane from './common/shelfPane.js';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201711/591709-20171128221442987-1542412311.png&quot; alt=&quot;&quot; width=&quot;218&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;shelfPane 是基于 Pane 类的，在 shelfPane.js 文件中引入这个类和事件派发器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import Pane from './Pane.js'&lt;span&gt;;
import eventbus from '../../controller/eventbus';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pane 类继承于 HT 封装的 ht.ui.TabLayout 类， 并做了一些特定的属性设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Pane extends ht.ui.TabLayout {
    constructor() {
        super();

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setBorder(&lt;span&gt;new&lt;/span&gt; ht.ui.border.LineBorder(1, 'rgb(150,150,150)'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件的边框&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setTabHeaderBackground(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置标签行背景，可以是颜色或者图片等&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setHoverTabBackground(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 Hover 状态下的标签背景，可以是颜色或者图片等&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setActiveTabBackground(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 Active 状态下的标签背景，可以是颜色或者图片等&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setTitleColor('rgb(184,184,184)');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置正常状态下标签文字的颜色&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setActiveTitleColor('rgb(255,255,255)');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 Active 状态下标签文字的颜色&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setTabHeaderLineSize(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置标签行分割线宽度&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setMovable(&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置标签是否可拖拽调整位置，默认为 true&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setTabHeaderBackground('#1c258c');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置标签行背景，可以是颜色或者图片等&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.setTabGap(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置标签之间的距离&lt;/span&gt;
&lt;span&gt;    }
    getTabWidth(child) {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定子组件的标签宽度&lt;/span&gt;
        const children = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getChildren(),
            size &lt;/span&gt;=&lt;span&gt; children.size();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (size === 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getContentWidth();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取内容宽度，即组件宽度减去边框宽度和左右内边距宽度&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getContentWidth() /&lt;span&gt; size;
        }
    }
    drawTab(g, child, x, y, w, h) {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制标签&lt;/span&gt;
        const children = &lt;span&gt;this&lt;/span&gt;.getChildren(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取子组件列表&lt;/span&gt;
            size =&lt;span&gt; children.size(),
            color &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.getCurrentTitleColor(child),&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据参数子组件的状态(normal、hover、active、move)，获取标签文字颜色&lt;/span&gt;
            font = &lt;span&gt;this&lt;/span&gt;.getTitleFont(child),&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取标签文字字体&lt;/span&gt;
            title = &lt;span&gt;this&lt;/span&gt;.getTitle(child);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定子组件的标签文本&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (size === 1&lt;span&gt;) {
            ht.Default.drawText(g, title, font, color, x, y, w, h, &lt;/span&gt;'left');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制文字&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            ht.Default.drawText(g, title, font, color, x, y, w, h, &lt;/span&gt;'center'&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (children.indexOf(child) &amp;lt;  size - 1&lt;span&gt;) {
            g.beginPath();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开始绘制&lt;/span&gt;
            g.rect(x + w - 1, y + 4, 1, h - 8&lt;span&gt;);
            g.fillStyle &lt;/span&gt;= 'rgb(150,150,150)'&lt;span&gt;;
            g.fill();
        }
    }
    show() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setVisible(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件是否可见&lt;/span&gt;
&lt;span&gt;    }
    hide() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setVisible(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们这个例子中的“信息”列表是一个表格组件，HT 通过 ht.ui.TableLayout 函数定义一个表格，然后通过 ht.ui.TableRow 向表格中添加行，这个例子中的“备注”、“编号”、“来源”、“入库”、“发往”以及“出库”都是文本框，这里拿“备注”作为举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
let tableLayout = &lt;span&gt;new&lt;/span&gt; ht.ui.TableLayout();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此布局器将自身空间按照行列数划分为 row * column 个单元格&lt;/span&gt;
tableLayout.setColumnPreferredWidth(0, 45);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置列首选宽度&lt;/span&gt;
tableLayout.setColumnWeight(0, 0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置列宽度权重；如果布局器的总宽度大于所有列的首选宽度之和，那么剩余的宽度就根据权重分配&lt;/span&gt;
tableLayout.setColumnPreferredWidth(1, 150&lt;span&gt;);
tableLayout.setPadding(&lt;/span&gt;8);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件内边距，参数如果是数字，说明四边使用相同的内边距；如果是数组，则格式为：[上边距, 右边距, 下边距, 左边距]&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 备注&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; tableRow1 = &lt;span&gt;new&lt;/span&gt; ht.ui.TableRow();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TableLayout 中的一行子组件；&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; label = &lt;span&gt;new&lt;/span&gt; ht.ui.Label();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标签组件&lt;/span&gt;
label.setText('备注');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文字内容&lt;/span&gt;
label.setAlign('left');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文字和图标在按钮水平方向的整体对齐方式，默认为 'center'&lt;/span&gt;
label.setTextColor('rgb(255,255,255)');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文字颜色&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; textField = &lt;span&gt;new&lt;/span&gt; ht.ui.TextField();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本框组件&lt;/span&gt;
textField.setFormDataName('remark');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件在表单中的名称&lt;/span&gt;
textField.setBackground(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件的背景，可以是颜色或者图片等；此值最终会被转换为 Drawable 对象&lt;/span&gt;
textField.setBorderRadius(0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 CSS 边框圆角&lt;/span&gt;
textField.setColor('rgb(138,138,138)');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置文字颜色&lt;/span&gt;
textField.setPlaceholder('无');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置输入提示&lt;/span&gt;
textField.setBorder(&lt;span&gt;new&lt;/span&gt; ht.ui.border.IndividualLineBorder(0, 0, 1, 0, 'rgb(138,138,138)'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件的边框&lt;/span&gt;
&lt;span&gt;
tableRow1.addView(label);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加子组件&lt;/span&gt;
&lt;span&gt;tableRow1.addView(textField);

tableLayout.addView(tableRow1);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将子组件加到容器中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“归类”和“模型”类似，都是下拉框，我们用 HT 封装的 ht.ui.ComboBox 组合框组件，跟 ht.ui.TextField 也是异曲同工，只是具体操作不同而已，HT 这样做使用上更简便更容易上手，这里我们以“模型”进行解析，在设置“下拉数据”的时候我们利用了 HT 中的数据绑定：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模型&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; tableRow4 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.TableRow();
label &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.Label();
label.setText(&lt;/span&gt;'模型'&lt;span&gt;);
label.setAlign(&lt;/span&gt;'left'&lt;span&gt;);
label.setTextColor(&lt;/span&gt;'rgb(255,255,255)'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; comboBox = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.ComboBox();
comboBox.setFormDataName(&lt;/span&gt;'model'&lt;span&gt;);
comboBox.setBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
comboBox.setColor(&lt;/span&gt;'rgb(232,143,49)'&lt;span&gt;);
comboBox.setDatas([&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下拉数据数组&lt;/span&gt;
  { label: '纸箱', value: 'carton'&lt;span&gt; },
  { label: &lt;/span&gt;'木箱1', value: 'woodenBox1'&lt;span&gt; },
  { label: &lt;/span&gt;'木箱2', value: 'woodenBox2'&lt;span&gt; },
  { label: &lt;/span&gt;'木桶', value: 'cask'&lt;span&gt; }
]); 
comboBox.setIcon(&lt;/span&gt;'imgs/combobox_icon.json'&lt;span&gt;);
comboBox.setHoverIcon(&lt;/span&gt;'imgs/combobox_icon_hover.json'&lt;span&gt;);
comboBox.setActiveIcon(&lt;/span&gt;'imgs/combobox_icon_hover.json'&lt;span&gt;);
comboBox.setBorderRadius(&lt;/span&gt;0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 CSS 边框圆角&lt;/span&gt;
comboBox.setBorder(&lt;span&gt;new&lt;/span&gt; ht.ui.border.IndividualLineBorder(0, 0, 1, 0, 'rgb(138,138,138)'&lt;span&gt;));

tableRow4.addView(label);
tableRow4.addView(comboBox);

tableLayout.addView(tableRow4);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个“染色”，HT 封装了 ht.ui.ColorPicker 颜色选择器组件，组件从 ht.ui.ComboBox 继承并使用 ht.ui.ColorDropDown 作为下拉模板，跟上面的下拉列表很类似，只是下拉的模板变了而已：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 染色&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; tableRow9 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.TableRow();
label &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.ui.Label();
label.setText(&lt;/span&gt;'染色'&lt;span&gt;);
label.setAlign(&lt;/span&gt;'left'&lt;span&gt;);
label.setTextColor(&lt;/span&gt;'rgb(255,255,255)'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; comboBox = &lt;span&gt;new&lt;/span&gt; ht.ui.ColorPicker();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色选择器组件&lt;/span&gt;
comboBox.setFormDataName('blend');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置组件在表单中的名称&lt;/span&gt;
comboBox.getView().className = 'content_colorpicker'&lt;span&gt;;
comboBox.setBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
comboBox.setPreviewBackground(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置预览背景；可以是颜色或者图片等&lt;/span&gt;
comboBox.getInput().style.visibility = 'visible';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取组件内部的 input 框的 style 样式&lt;/span&gt;
comboBox.setReadOnly(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置只读&lt;/span&gt;
comboBox.setColor('rgba(0,0,0,0)'&lt;span&gt;);
comboBox.setPlaceholder(&lt;/span&gt;'修改货箱颜色'&lt;span&gt;);
comboBox.setIcon(&lt;/span&gt;'imgs/combobox_icon.json'&lt;span&gt;);
comboBox.setHoverIcon(&lt;/span&gt;'imgs/combobox_icon_hover.json'&lt;span&gt;);
comboBox.setActiveIcon(&lt;/span&gt;'imgs/combobox_icon_hover.json'&lt;span&gt;);
comboBox.setBorderRadius(&lt;/span&gt;0&lt;span&gt;);
comboBox.setBorder(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ht.ui.border.IndividualLineBorder(0, 0, 1, 0, 'rgb(138,138,138)'&lt;span&gt;));
comboBox.setInstant(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置即时模式；在这种模式下，每输入一个字符 value 属性变化事件就会立即被派发，否则只有失去焦点或敲回车时才被派发&lt;/span&gt;
&lt;span&gt;
tableRow9.addView(label);
tableRow9.addView(comboBox);

tableLayout.addView(tableRow9);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后通过 ht.ui.Form 组件的 addChangeListener 事件监听函数监听 JSON 整体变化事件和 JSON 中单条数据变化事件，这两种事件的解释如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201711/591709-20171128182302269-1714236080.png&quot; alt=&quot;&quot; width=&quot;793&quot; height=&quot;526&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体监听方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
form.addChangeListener((e) =&amp;gt;&lt;span&gt; {
  const cargo &lt;/span&gt;=&lt;span&gt; form.__cargo__;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.kind === 'formDataValueChange') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JSON 中单条数据值变化事件&lt;/span&gt;
    const name =&lt;span&gt; e.name;
    let value &lt;/span&gt;=&lt;span&gt; e.newValue;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (name === 'blend'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;amp;&amp;amp; value.startsWith('rgba'&lt;span&gt;)) {
        const li &lt;/span&gt;= value.lastIndexOf(','&lt;span&gt;);
        value &lt;/span&gt;= 'rgb' + value.substring(value.indexOf('('), li) + ')'&lt;span&gt;;
      }
    }
    cargo.setValue(name, value);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后通过 HT 封装的事件派发器 ht.Notifier 将界面中不同区域的组件之间通过事件派发进行交互，根据不同的事件类型进行不同的动作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
eventbus.add((e) =&amp;gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加监听器 事件总线；界面中不同区域的组件之间通过事件派发进行交互&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (e.type === 'cargoFocus'&lt;span&gt;) {
    shelfPane.show();

    const cargo &lt;/span&gt;=&lt;span&gt; e.data;
    form.__cargo__ &lt;/span&gt;=&lt;span&gt; cargo;
    const json &lt;/span&gt;= form.getJSON();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取由表单组件的名称和值组装成的 JSON 数据&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (let k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json) {
      form.setItem(k, cargo.getValue(k));
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.type === 'cargoBlur'&lt;span&gt;) {
    shelfPane.hide();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 图表&lt;/h3&gt;
&lt;/div&gt;&lt;p&gt; 从 src\view\common 文件夹中的 chartPane.js 中获取 graph3dView 的外部接口被 src/view 中的 index.js 调用：&lt;/p&gt;</description>
<pubDate>Sun, 01 Jul 2018 23:22:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/9244445.html</dc:identifier>
</item>
<item>
<title>JS 异步系列 —— Promise 札记 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/9252027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/9252027.html</guid>
<description>&lt;h3 id=&quot;promise&quot;&gt;Promise&lt;/h3&gt;
&lt;p&gt;研究 Promise 的动机大体有以下几点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对其 api 的不熟悉以及对实现机制的好奇;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;很多库(比如 fetch)是基于 Promise 封装的，那么要了解这些库的前置条件得先熟悉 Promise;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;要了解其它更为高级的异步操作得先熟悉 Promise;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于这些目的，实践了一个符合 Promise/A+ 规范的 &lt;a href=&quot;https://github.com/MuYunyun/repromise&quot;&gt;repromise&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本札记系列总共三篇文章，作为之前的文章 &lt;a href=&quot;https://github.com/MuYunyun/blog/issues/7&quot;&gt;Node.js 异步异闻录&lt;/a&gt; 的拆分和矫正。&lt;/p&gt;
&lt;h3 id=&quot;promisea-核心&quot;&gt;Promise/A+ 核心&lt;/h3&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/e1a0c15c44f9b014aa78d7b7620db474.jpg-200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实现一个符合 Promise/A+ 规范的 promise 之前，先了解下 Promise/A+ 核心，想更全面地了解可以阅读 &lt;a href=&quot;https://segmentfault.com/a/1190000002452115&quot;&gt;Promise/A+规范&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Promise 操作只会处在 3 种状态的一种：未完成态(pending)、完成态(resolved) 和失败态(rejected);&lt;/li&gt;
&lt;li&gt;Promise 的状态只会出现从未完成态向完成态或失败态转化;&lt;/li&gt;
&lt;li&gt;Promise 的状态一旦转化，将不能被更改;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;repromise-api-食用手册&quot;&gt;repromise api 食用手册&lt;/h3&gt;
&lt;h4 id=&quot;promise.resolve&quot;&gt;Promise.resolve()&lt;/h4&gt;
&lt;p&gt;Promise.resolve() 括号内有 4 种情况&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/* 跟 Promise 对象 */
Promise.resolve(Promise.resolve(1))
// Promise {state: &quot;resolved&quot;, data: 1, callbackQueue: Array(0)}

/* 跟 thenable 对象 */
var thenable = {
  then: function(resolve, reject) {
    resolve(1)
  }
}

Promise.resolve(thenable)
// Promise {state: &quot;resolved&quot;, data: 1, callbackQueue: Array(0)}

/* 普通参数 */
Promise.resolve(1)
// Promise {state: &quot;resolved&quot;, data: 1, callbackQueue: Array(0)}

/* 不跟参数 */
Promise.resolve()
// Promise {state: &quot;resolved&quot;, data: undefined, callbackQueue: Array(0)}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;promise.reject&quot;&gt;Promise.reject()&lt;/h4&gt;
&lt;p&gt;相较于 Promise.resolve()，Promise.reject() 原封不动地返回参数值&lt;/p&gt;
&lt;h4 id=&quot;promise.allarr&quot;&gt;Promise.all(arr)&lt;/h4&gt;
&lt;p&gt;对于 Promise.all(arr) 来说，在参数数组中所有元素都变为决定态后，然后才返回新的 promise。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 以下 demo，请求两个 url，当两个异步请求返还结果后，再请求第三个 url
const p1 = request(`http://some.url.1`)
const p2 = request(`http://some.url.2`)

Promise.all([p1, p2])
  .then((datas) =&amp;gt; { // 此处 datas 为调用 p1, p2 后的结果的数组
    return request(`http://some.url.3?a=${datas[0]}&amp;amp;b=${datas[1]}`)
  })
  .then((data) =&amp;gt; {
    console.log(msg)
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;promise.racearr&quot;&gt;Promise.race(arr)&lt;/h4&gt;
&lt;p&gt;对于 Promise.race(arr) 来说，只要参数数组有一个元素变为决定态，便返回新的 promise。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// race 译为竞争，同样是请求两个 url，当且仅当一个请求返还结果后，就请求第三个 url
const p1 = request(`http://some.url.1`)
const p2 = request(`http://some.url.2`)

Promise.race([p1, p2])
  .then((data) =&amp;gt; { // 此处 data 取调用 p1, p2 后优先返回的结果
    return request(`http://some.url.3?value=${data}`)
  })
  .then((data) =&amp;gt; {
    console.log(data)
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;promise.wrapfn-回调函数转-promise&quot;&gt;Promise.wrap(fn) —— 回调函数转 Promise&lt;/h4&gt;
&lt;p&gt;通过下面这个案例，提供回调函数 Promise 化的思路。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function foo(a, b, cb) {
  ajax(
    `http://some.url?a=${a}&amp;amp;b=${b}`,
    cb
  )
}

foo(1, 2, function(err, data) {
  if (err) {
    console.log(err)
  } else {
    console.log(data)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上是一个传统回调函数使用案例，只要使用 Promise.wrap() 包裹 foo 函数就对其完成了 promise 化，使用如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const promiseFoo = Promise.wrap(foo)

promiseFoo(1, 2)
  .then((data) =&amp;gt; {
    console.log(data)
  })
  .catch((err) =&amp;gt; {
    console.log(err)
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Promise.wrap 的实现逻辑也顺带列出来了：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Promise.wrap = function(fn) {
  return funtion() {
    const args = [].slice.call(arguments)
    return new Promise((resolve, reject) =&amp;gt; {
      fn.apply(null, args.concat((err, data) =&amp;gt; {
        if (err) {
          reject(err)
        } else {
          resolve(data)
        }
      }))
    })
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;thencatchdone&quot;&gt;then/catch/done&lt;/h4&gt;
&lt;p&gt;这几个 api 比较简单，合起来一起带过&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Promise.resolve(1)
  .then((data) =&amp;gt; {console.log(data)}, (err) =&amp;gt; {console.log(err)}) // 链式调用，可以传一个参数(推荐)，也可以传两个参数
  .catch((err) =&amp;gt; {console.log(err)}) // 捕获链式调用中抛出的错误 || 捕获变为失败态的值
  .done()                             // 能捕获前面链式调用的错误(包括 catch 中)，可以传两个参数也可不传&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实践过程总结&quot;&gt;实践过程总结&lt;/h3&gt;
&lt;h4 id=&quot;坑点-1事件循环&quot;&gt;坑点 1：事件循环&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;事件循环：同步队列执行完后，在指定时间后再执行异步队列的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之所以要单列事件循环，因为代码的执行顺序与其息息相关，此处用 setTimeout 来模拟事件循环；&lt;/p&gt;
&lt;p&gt;下面代码片段中，① 处执行完并不会马上执行 setTimeout() 中的代码(③)，而是此时有多少次 then 的调用，就会重新进入 ② 处多少次后，再进入 ③&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;excuteAsyncCallback(callback, value) {
  const that = this
  setTimeout(function() {
    const res = callback(value) // ③
    that.excuteCallback('fulfilled', res)
  }, 4)
}

then(onResolved, onRejected) {
  const promise = new this.constructor()
  if (this.state !== 'PENDING') {
    const callback = this.state === 'fulfilled' ? onResolved : onRejected
    this.excuteAsyncCallback.call(promise, callback, this.data)              // ①
  } else {
    this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // ②
  }
  return promise
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;坑点-2this-的指向问题&quot;&gt;坑点 2：this 的指向问题&lt;/h4&gt;
&lt;p&gt;this.callbackArr.push() 中的 this 指向的是 ‘上一个’ promise，所以类 CallbackItem 中，this.promise 存储的是'下一个' promise(then 对象)。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class Promise {
  ...
  then(onResolved, onRejected) {
    const promise = new this.constructor()
    if (this.state !== 'PENDING') {        // 第一次进入 then，状态是 RESOLVED 或者是 REJECTED
      const callback = this.state === 'fulfilled' ? onResolved : onRejected
      this.excuteAsyncCallback.call(promise, callback, this.data)  // 绑定 this 到 promise
    } else {                               // 从第二次开始以后，进入 then，状态是 PENDING
      this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected)) // 这里的 this 也是指向‘上一个’ promise
    }
    return promise
  }
  ...
}

class CallbackItem {
  constructor(promise, onResolve, onReject) {
    this.promise = promise // 相应地，这里存储的 promise 是来自下一个 then 的
    this.onResolve = typeof(onResolve) === 'function' ? onResolve : (resolve) =&amp;gt; {}
    this.onReject = typeof(onRejected) === 'function' ? onRejected : (rejected) =&amp;gt; {}
  }
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;more&quot;&gt;more&lt;/h3&gt;
&lt;p&gt;实践的更多过程可以参考&lt;a href=&quot;https://github.com/MuYunyun/repromise/tree/master/test&quot;&gt;测试用例&lt;/a&gt;。有好的意见欢迎交流。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 17:48:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/9252027.html</dc:identifier>
</item>
<item>
<title>EntityFramework Core进行读写分离最佳实践方式，了解一下？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/9241523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/9241523.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本来打算写ASP.NET Core MVC基础系列内容，看到有园友提出如何实现读写分离，这个问题提的好，大多数情况下，对于园友在评论中提出的问题，如果是值得深究或者大多数同行比较关注的问题我都会私下去看看，然后进行对应解答，若有叙述不当之处，还请海涵。我们稍微过一下事务，本文略长，请耐心阅读。&lt;/p&gt;
&lt;h2&gt;事务&lt;/h2&gt;
&lt;p&gt;什么是事务呢？有关事务详解可参看我写的SQL Server基础系列，我们可归结为一句话：多个提交要么全部成功，要么全部失败即同生共死，没有临阵脱逃者。那么问题来了，用了事务有什么作用或者说有什么优点呢？事务允许我们将相关操作组合打包，以确保应用程序数据的一致性。那么使用事务又有何缺点呢？使用事务虽然确保了数据一致性等等，但是会影响性能，可能会造成死锁。那么问题又来了，既然有其优缺点，那么我们是否可以手写逻辑实现数据一致性呢？当然可以，我们可以模拟事务回滚、提交的效果，但是这也无法百分百保证。&lt;/p&gt;
&lt;h3&gt;调用SaveChanges是否在一个事务内？&lt;/h3&gt;
&lt;p&gt;首先我们在控制台中进行如下数据添加，然后添加日志打印。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog()
                {
                    IsDeleted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/createmyslef&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                };
                context.Add(blog);
                context.SaveChanges();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggerFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerFactory();
            loggerFactory.AddConsole(LogLevel.Debug);
            optionsBuilder.UseLoggerFactory(loggerFactory);
            optionsBuilder.UseSqlServer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=WANGPENG;User Id=sa;Pwd=sa123;initial catalog=Demo1;integrated security=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201806/589642-20180630203819305-1694255453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过打印日志得知在调用SaveChanges方法时则包含在事务中进行提交，所以请那些可在项目中用到多表添加担心出现问题就加上了如下开启事务，这很显然是多此一举。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext())
            {

                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; transaction =&lt;span&gt; context.Database.BeginTransaction())
                {

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog()
                    {
                        IsDeleted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                        CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                        ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                        Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/createmyslef&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    context.Add(blog);
                    context.SaveChanges();

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        transaction.Commit();
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
                    {
                       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;
&lt;span&gt;                    }
                }              
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看到如上日志信息还不是更加确定是不是，我们再来看看在上下文中的 &lt;span class=&quot;cnblogs_code&quot;&gt;context.Database.AutoTransactionsEnabled&lt;/span&gt; 方法，详细解释如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Gets or sets a value indicating whether or not a transaction will be created
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     automatically by Microsoft.EntityFrameworkCore.DbContext.SaveChanges if none
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     of the 'BeginTransaction' or 'UseTransaction' methods have been called.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Setting this value to false will also disable the Microsoft.EntityFrameworkCore.Storage.IExecutionStrategy
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     for Microsoft.EntityFrameworkCore.DbContext.SaveChanges
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     The default value is true, meaning that SaveChanges will always use a transaction
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     when saving changes.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     Setting this value to false should only be done with caution since the database
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     could be left in a corrupted state if SaveChanges fails.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过AutoTransactionsEnabled方法解释得知：&lt;span&gt;其默认值为True，也就意味着当调用SaveChanges方法将使用事务性提交。&lt;/span&gt;当然我们可以在上下文构造函数中设置是否全局禁用事务，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFCoreDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EFCoreDbContext()
        {
            Database.AutoTransactionsEnabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在EF Core中我们什么时候会用到事务呢？如果是单一上下文，单一数据库，那么事务跟我们没啥关系，压根不用管事务。如果是在单一数据库使用多个上下文（跨上下文）或者多个数据库，这个时候事务就闪亮登场了。比如对于电商中的商品、购物车、订单管理、支付、物流，我们完全可以实例化五个不同的上下文，此时将涉及到跨上下文操作使用事务保持数据一致性，当然这是针对在同一关系数据库中。或者是实例化同一上下文多次来使用事务保持数据一致性。可以参看官网的介绍《&lt;a title=&quot;EntityFramework Core Transactions&quot; href=&quot;https://docs.microsoft.com/en-us/ef/core/saving/transactions&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/ef/core/saving/transactions&lt;/a&gt;》，没什么看头，都是针对同一数据库操作，无非还是我所说的跨上下文、使用上下文结合底层DbConnection来使用事务共享连接等等 ，稍微大一点的看点则是在EF Core 2.1中引入了System.Transactions，可指定隔离级别以及使用ambient transactions（查资料作用是存在多个事务，事务之间存在连接，如此一来将显得整个作用域非常冗长，通过使用此事务则在特定范围内，所有连接都将包含在该事务中），在此就不占用篇幅介绍了，和大家一样我们最关心的是分布式事务，也就是使用不同上下文针对多个数据库，但是遗憾的是直到EF Core 2.1还不支持分布式事务，因为.NET Core中相关APi也还不完善，继续等待吧。&lt;/p&gt;
&lt;h2&gt;读写分离&lt;/h2&gt;
&lt;p&gt;随着流量的进入，数据库将承受不可抗拒的压力，单一数据库将不再适用，这都是随着项目的演变所带来架构的迭代改变，这个时候就涉及到分库，对于查询的数据单独作为一个数据库，作为数据的更改也单独用一个数据库，再结合那些什么负载均衡等等，数据库压力也就减弱了许多。只作查询的数据库我们称之为从数据库，对于数据库更改的数据库称之为主数据库，主-从数据库（Master-Slave）数据的同步方式也有很多，虽然我也没接触过，我们就利用SQL Server中的复制进行发布-订阅来模拟演示还是可以的。我们来看看.NET Core Web应用程序如何实现读写分离，额外加一句，项目中我也未用到，都是我私下的研究，方案行不行，合不合理可以一起探讨。我们创建了两个Demo数据库，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201806/589642-20180630215508824-416189139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将Demo1作为主数据库，Demo2作为从数据库，接下来用一张动态图演示创建复制发布-订阅（每隔10秒发布一次）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201806/589642-20180630224335803-639857003.gif&quot; alt=&quot;&quot;/&gt;我们给出Demo1上下文，Demo2和其一样，按照正常做法接下来我们应该在.NET Core Web应用程序中注入Demo1和Demo2上下文，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1DbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Demo1DbContext(DbContextOptions&amp;lt;Demo1DbContext&amp;gt; options) :&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo2DbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Demo2DbContext(DbContextOptions&amp;lt;Demo2DbContext&amp;gt; options) :&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            services.AddDbContext&amp;lt;Demo1DbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                options.UseSqlServer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=WANGPENG;User Id=sa;Pwd=sa123;initial catalog=Demo1;integrated security=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }).AddDbContext&lt;/span&gt;&amp;lt;Demo2DbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                options.UseSqlServer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=WANGPENG;User Id=sa;Pwd=sa123;initial catalog=Demo2;integrated security=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们创建Demo控制器，通过Demo1上下文添加数据，Demo2上下文读取数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Demo1DbContext _demo1DbContext;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Demo2DbContext _demo2DbContext;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DemoController(Demo1DbContext demo1DbContext, Demo2DbContext demo2DbContext)
        {
            _demo1DbContext &lt;/span&gt;=&lt;span&gt; demo1DbContext;
            _demo2DbContext &lt;/span&gt;=&lt;span&gt; demo2DbContext;
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blogs =&lt;span&gt; _demo2DbContext.Blogs.ToList();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(blogs);
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult CreateDemo1Blog()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blog()
            {
                IsDeleted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                CreatedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                ModifiedTime &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demoBlog1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.cnblogs.com/createmyslef&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            };
            _demo1DbContext.Blogs.Add(blog);
            _demo1DbContext.SaveChanges();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; RedirectToAction(nameof(Index));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}

@model IEnumerable&lt;/span&gt;&amp;lt;EFCore.Blog&amp;gt;

&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;panel panel-primary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;panel-heading panel-head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;博客列表&amp;lt;/div&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;panel-body&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;table &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;margin: 4px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;th&amp;gt;&lt;span&gt;
                    @Html.DisplayNameFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.Id)
                &lt;/span&gt;&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;&lt;span&gt;
                    @Html.DisplayNameFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.Name)
                &lt;/span&gt;&amp;lt;/th&amp;gt;
                &amp;lt;th&amp;gt;&lt;span&gt;
                    @Html.DisplayNameFor(model &lt;/span&gt;=&amp;gt;&lt;span&gt; model.Url)
                &lt;/span&gt;&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;&lt;span&gt;
            @if (Model &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Model)
                {
                    &lt;/span&gt;&amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt;&lt;span&gt;
                            @Html.DisplayFor(modelItem &lt;/span&gt;=&amp;gt;&lt;span&gt; item.Id)
                        &lt;/span&gt;&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;&lt;span&gt;
                            @Html.DisplayFor(modelItem &lt;/span&gt;=&amp;gt;&lt;span&gt; item.Name)
                        &lt;/span&gt;&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;&lt;span&gt;
                            @Html.DisplayFor(modelItem &lt;/span&gt;=&amp;gt;&lt;span&gt; item.Url)
                        &lt;/span&gt;&amp;lt;/td&amp;gt;
                    &amp;lt;/tr&amp;gt;&lt;span&gt;
                }
            }
        &lt;/span&gt;&amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201807/589642-20180701003910564-1659049027.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到通过Demo1上下文添加数据后重定向到Demo2上下文查询到的列表页面，到了10秒自动同步到Demo2数据库，通过刷新可以看到数据显示。虽然结果如我们所期望，但是实现的路径却令我们不是那么如意，因为所用实体都是一样的，只是说所连接数据库不一样而已，但是我们需要创建两个不同的上下文实例，很显然这不是最佳实践方式，那么我们如何做才是最佳实践方式呢？接下来我们再来创建一个Demo3数据库，表结构和Demo1、Demo2一致，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201807/589642-20180701001154210-1111511024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们在.NET Core Web应用程序Demo1、Demo2上下文所在的类库中创建如下扩展方法（方便有同行需要学习，给出Demo项目基本结构）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201807/589642-20180701001331849-1193394867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChangeDatabase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChangeToDemo3Db(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; DbContext context)
        {
            context.Database.GetDbConnection().ConnectionString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=WANGPENG;User Id=sa;Pwd=sa123;initial catalog=Demo3;integrated security=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们暂且不去看为何这样设置，我们只是添加上下文扩展方法，更改连接为Demo3的数据库，然后接下来我们获取博客列表时，调用上述扩展方法，请问：是否可以获取到Demo3的数据或者说是否会抛出异常呢？我们依然通过动态图来进行演示，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/589642/201807/589642-20180701004632405-1920272849.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一直以来我们认为利用 &lt;span class=&quot;cnblogs_code&quot;&gt;context.Database.GetDbConnection()&lt;/span&gt; 方法可以回到ADO.NET进行查询，但是我们通过实际证明，我们可以设置其他数据库连接从而达到读写分离最佳实践方式，免去再实例化一个上下文。所以对于上述我们配置的Demo1和Demo2上下文，我们大可只需要Demo1上下文即主数据库，对于从数据库进行查询，我们只需在Demo1上下文的基础上更该连接字符串即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChangeDatabase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChangeToDemo2Db(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; DbContext context)
        {
            context.Database.GetDbConnection().ConnectionString &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data source=WANGPENG;User Id=sa;Pwd=sa123;initial catalog=Demo2;integrated security=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
    {
        _demo1DbContext.ChangeToDemo2Db();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blogs =&lt;span&gt; _demo1DbContext.Blogs.ToList();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(blogs);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来问题来了，那么为何更改Demo1上下文连接字符串就能转移到其他数据库查询呢？就是为了解决读写分离免去实例化上下文即Demo2的情况，但是内部是如何实现的呢？&lt;span&gt;因为EF Core内部添加了方法实现IRelationalConnection接口，使得我们可以在已存在的上下文实例上重新设置连接字符串即更换数据库，但是其前提是必须保证当前上下文连接已关闭，也就是说比如我们在同一个事务中利用当前上下文进行更改操作，然后更改连接字符串进行更改操作，最后提交事务，因为在此事务内，当前上下文连接还未关闭，所以再更改连接字符串后进行数据库更改操作，将必定会抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;花了两天时间研究研究，本文比较详细讲解了对于读写分离后，如何进行数据查询和更改操作最佳实践方式，不知道算不算最好的解决方案，若您有更好的方案，欢迎一起探讨或者说还有其他理解和疑问，也欢迎在评论中提出。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 16:57:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/9241523.html</dc:identifier>
</item>
<item>
<title>【深度学习】--DCGAN从入门到实例应用 - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/9251977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/9251977.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、前述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DCGAN就是Deep Concolutions应用到GAN上，但是和传统的卷积应用还有一些区别，最大的区别就是没有池化层。本文将详细分析卷积在GAN上的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、具体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、DCGAN和传统GAN区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.将pooling层convolutions替代（对于判别模型：容许网络学习自己的空间下采样 ，因为没有池化层，所以让判别网络自习学习。对于生成模型：容许它学习自己的空间上采样，即改变原先卷积策略，通过图片提取特征，而生成模型通过特征生成图片。）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    2.在generator和discriminator上都使用batchnorm：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      解决初始化差的问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      帮助梯度传播到每一层&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      防止generator把所有的样本都收敛到同一个点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3.在CNN中移除全连接层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4.在generator的除了输出层外的所有层使用ReLU，输出层采用tanh。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   5.在discriminator的所有层上使用LeakyReLU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、生成网络生成图像过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201807/1250469-20180701232228462-1464599735.png&quot; alt=&quot;&quot; width=&quot;1060&quot; height=&quot;449&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201807/1250469-20180701232301568-292364448.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、判别网络过程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201807/1250469-20180701232348228-2138958553.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 4、代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 代码部分详见git地址：&lt;a href=&quot;https://github.com/LhWorld/DCGAN&quot; target=&quot;_blank&quot;&gt;https://github.com/LhWorld/DCGAN&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 16:39:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/9251977.html</dc:identifier>
</item>
<item>
<title>Python学习：11.Python装饰器讲解（二） - BD-ld-2017</title>
<link>http://www.cnblogs.com/liudi2017/p/9251971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liudi2017/p/9251971.html</guid>
<description>&lt;p&gt;&lt;span&gt;回顾&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上一节我们进行了Python简单装饰器的讲解，但是python的装饰器还有一部分高级的使用方式，这一节就针对python装饰器高级部分进行讲解。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为一个函数添加多个装饰器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　今天，老板又交给你一个任务，老板说：&quot;之前的装饰器用用起来挺好，但是这次我需要再次添加更多的参数，这个任务就交给你了，好好干。&quot;，这种时候，我们就可以针对一个函数使用多个装饰器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        r &lt;/span&gt;= func(*args,**&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bye&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel1(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start time:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; datetime.datetime.now())
        r &lt;/span&gt;= func(*args,**&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end time:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;datetime.datetime.now())
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  r
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  inner

@hel1
@hel
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)

name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
f1(name)

执行结果：
start time:&lt;/span&gt;2018-07-01 10:36:02.085027&lt;span&gt;
hello
alexsel
bye
end time:&lt;/span&gt;2018-07-01 10:36:02.086027
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次我们在对之前代码添加数据的时候，我们写了第二个装饰器，我们使用这个装饰器针对之前的函数再次增加新的功能，输出了开始结束时间。&lt;/p&gt;
&lt;h3&gt;代码及输出问题解析&lt;/h3&gt;
&lt;p&gt;针对刚才多个装饰器，我们需要了解的是在进行输出的时候是怎么进行输出的，首先装饰器函数hel首先对f1函数进行装饰，然后装饰器函数hel1在对被hel装饰过函数进行装饰，最后执行两次装饰过的函数。在新添加的装饰器中（hel1）的func所指的函数是已经被hel装饰过的函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;带参数的装饰器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　装饰器在调用的时候可以传入相应的参数，传入参数以后我们可以根据不同的参数，针对函数进行相应信息输出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; use_log(level):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hel(func):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; inner(*args,**&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; level == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;warning&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The current function:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
            r &lt;/span&gt;= func(*args,**&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; r
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inner
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hel

@use_log(level &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;warning&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f1(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)


f1(name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alexsel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

输出结果：
The current function:f1
hello
alexsel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码就是可以带有参数的装饰器，就是将以前我们使用简单的装饰器进行了一次封装，当我们调用函数的时候，python可以将我们定义的装饰器的参数传入函数中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于类的装饰器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　讲解python的类装饰器需要用到python类的知识，python的类我们还没有进行学习，就先简单了解一下。&lt;/p&gt;
&lt;p&gt;　　根据我们刚才对装饰器的学习，我们发现装饰器如果需要正常运行，装饰器所接受的对象必须是可调用的，然后在装饰器内部在返回一个可调用的对象，一般情况下，可调用的对象都是函数，特殊情况是对象中写入了__call__()方法就也是可以调用的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

te &lt;/span&gt;=&lt;span&gt; Test()
te()

输出结果：
test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们是有类装饰器的时候，可以让类的构造函数__init__()接受一个函数，然后重载一个__call__()并且返回一个函数，来达到装饰器的目的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,func):
        self.func &lt;/span&gt;=&lt;span&gt; func

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self,*args,**&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;The current function:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % self.func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  self.func()

@Test
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tes():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;obj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

tes()


输出结果：
The current function:tes
tes&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;装饰器就是对原来函数、对象功能的扩展，相当于对函数重新封装，重点需要理解的是装饰器中返回的是函数，而且装饰器所装饰器的对象也需要是可调用的。今天装饰器的高级部分就到这里。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 16:34:00 +0000</pubDate>
<dc:creator>BD-ld-2017</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liudi2017/p/9251971.html</dc:identifier>
</item>
<item>
<title>react初探（二）之父子组件通信、封装公共组件 - 你假装没察觉</title>
<link>http://www.cnblogs.com/heavenYJJ/p/9215021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heavenYJJ/p/9215021.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在组件方面react和Vue一样的，核心思想玩的就是组件，下面举两个组件常用的情景。&lt;/p&gt;
&lt;p&gt;场景一：假如我们现在有一个页面包含表格以及多个弹框，这种时候如果将这个页面的业务代码写在一个组件中，那么这一块的代码会看着非常恶心。如果这个时候我们将这个页面的表格以及弹框这些单独的模块分别写成组件的形式，然后再在这个页面中将这些组件引入进来，那样我们的代码会看着非常整洁。这样做会需要使用到父子组件之间的通信，下面会详细解释。&lt;/p&gt;
&lt;p&gt;场景二：日常项目中我们会经常遇到某一个功能会在不同地方使用，但是每次使用的时候都会有一些小差别。比如在一个页面中我们有一个地方叫 “上传头像”，在另外一个地方叫 “上传证书” 。这种情况我们封装一个公共的上传图片的组件，但是这个组件在使用的时候在不同的地方展示的文案或者样式不同。react提供一种类似于Vue的插槽（slot）的功能，自定义的组件使用children属性将子元素传递到输出，具体用法下面会详细解释。 &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、定义组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;目前有两种常用的方法定义组件：函数式组件、类组件。&lt;/p&gt;
&lt;p&gt;（1） 函数式组件：这种组件表示每一个函数就是一个组件，组件具体的内容由return的值决定。这种组件主要用于纯展示性组件，不存在state的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
function&lt;span&gt; Name() {
    return&lt;span&gt; (
        &amp;lt;div&amp;gt;我是Name组件&amp;lt;/div&amp;gt;
&lt;span&gt;    )
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 优点：结构简单、写法简单。&lt;/p&gt;
&lt;p&gt; 缺点：不能使用生命周期的钩子函数、不能进行复杂的操作、只能通过函数传参的形式传递props。&lt;/p&gt;

&lt;p&gt;（2）类组件：一般一个jsx文件就是一个类组件，该写法为es6的写法（PS：es5也有一种React.createClass组件写法，但是官方现在主推es6这种写法，所以本文不讲es5的这种写法）。使用类组件可以在constructor钩子函数中初始化一个state，相当于Vue中的data，具体关于state的操作可以看我的&lt;a title=&quot;react初探（一）之JSX、状态（state）管理、条件渲染、事件处理&quot; href=&quot;https://www.cnblogs.com/heavenYJJ/p/9211470.html&quot; target=&quot;_blank&quot;&gt;Reacr初探（一）&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Age extends Component {
    render() {
        return&lt;span&gt; (
            &amp;lt;div&amp;gt;我是Age组件&amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优点：可以进行复杂的操作、具有生命周期钩子函数、拥有state。&lt;/p&gt;
&lt;p&gt;缺点：和函数式组件比起来写法要复杂一点。&lt;/p&gt;
&lt;p&gt;PS：后面使用的组件均为类组件&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、&lt;/strong&gt;父组件 =&amp;gt; 子组件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们将引入props的概念了，官方描述：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code class=&quot;gatsby-code-text&quot;&gt;props&lt;/code&gt;是React组件的输入内容。 它们是从父组件传递给子组件的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 说白了props就是一个对象，是由父子件的属性提供。父组件提供的属性值可以为变量、常量（变量和常量可以用于 父组件 =&amp;gt; 子组件）、函数（可以用于 子组件 =&amp;gt; 父组件）、react元素（可以用于封装公共组件），在子组件中使用this.props就可以访问到props对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;父组件中：
&amp;lt;Age num=&quot;18&quot;&amp;gt;&amp;lt;/Age&amp;gt;&lt;span&gt;

子组件中：
render() {
　　return (
　　　　&amp;lt;div&amp;gt;我是Age组件，我今年{this.props.num}岁了&amp;lt;/div&amp;gt;&lt;span&gt;
　　)
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：props为只读的，所以不能修改props的值，如果修改会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217259/201807/1217259-20180701212154697-1388379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是如果传入props的某一个属性的值是一个对象，在子组件中可以改变传入的该对象的属性或者方法是不会报错的。同时父组件的该对象的值也会改变，但是由于不是使用setState改变的状态，所以组件不会重新渲染。好像有点绕口，我们来举个例子看看。&lt;/p&gt;
&lt;p&gt;父组件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　constructor(props) {
        super(props)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            userInfo: {
                name: &lt;/span&gt;'yjj'&lt;span&gt;,
                age: &lt;/span&gt;18&lt;span&gt;
            }
        }
    }
    render() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div className=&quot;App&quot;&amp;gt;
                &amp;lt;Person info={&lt;span&gt;this&lt;/span&gt;.state.userInfo}&amp;gt;&amp;lt;/Person&amp;gt;
                &amp;lt;div onClick={()=&amp;gt; console.log(&lt;span&gt;this&lt;/span&gt;.state.userInfo)}&amp;gt;点我打印userinfo对象&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        );
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子组件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　render() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.props.info.age = 25
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;div&amp;gt;姓名：{&lt;span&gt;this&lt;/span&gt;.props.info.name}&amp;lt;/div&amp;gt;
                &amp;lt;div&amp;gt;年龄：{&lt;span&gt;this&lt;/span&gt;.props.info.age}&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 父组件中定义了一个userInfo对象，并且将该对象的值作为info属性传入到子组件。子组件中对this.props.info对象的age属性重新赋值，由于子组件的this.props.info对象指向的指针和父组件中的userInfo对象的指针是一样的。所以父组件中的userInfo对象的age属性实际上也是改变了的，等于25。但是在react中state的值需要使用setState()方法修改，所以不会重新渲染对应的组件。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、子&lt;/strong&gt;组件 =&amp;gt; 父组件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;子组件 =&amp;gt; 父组件的通信实际上就是通过父组件给子组件传递的属性值为函数，子组件在相应的情况下调用该函数。&lt;/p&gt;
&lt;p&gt;父组件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　constructor(props) {
        super(props)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            age: &lt;/span&gt;18&lt;span&gt;
        }
    }
    changeAge &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            age: &lt;/span&gt;20&lt;span&gt;
        })
    }
    render() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div className=&quot;App&quot;&amp;gt;
                &amp;lt;Person changeAgeEvent={&lt;span&gt;this&lt;/span&gt;.changeAge}&amp;gt;&amp;lt;/Person&amp;gt;
                &amp;lt;div&amp;gt;当前年龄：{&lt;span&gt;this&lt;/span&gt;.state.age}&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        );
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子组件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    render() {&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div&amp;gt;
                &amp;lt;div onClick={() =&amp;gt; {&lt;span&gt;this&lt;/span&gt;.props.changeAgeEvent()}}&amp;gt;点我改变年龄的值&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
&lt;span&gt;        )
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件的changeAgeEvent的值为this.changeAge函数，在子组件中使用this.props.changeEvent（）调用父组件的函数。&lt;/p&gt;

&lt;p&gt;如果要子组件给父组件传参，只需要在调用函数的时候加上需要的参数即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;父组件中：
changeAge = (age) =&amp;gt; {
    this.setState({
        age
    })
}

子组件中：
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;onClick&lt;/span&gt;&lt;span&gt;={() =&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; {this.props.changeAge(100)}}&amp;gt;点我改变年龄的值为100&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;  // 子组件给父组件传参&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、封装公共组件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在前言中提到的场景二的问题，我们希望可以像使用普通的div标签一样使用自定义的组件。例如： &amp;lt;UploadImg&amp;gt;&amp;lt;h4&amp;gt;上传头像&amp;lt;/h4&amp;gt;&amp;lt;/UploadImg&amp;gt;。如果这样我们就不用考虑封装的UploadImg组件是在 “上传头像” 还是 “上传证书” 的情况下使用UploadImg组件的时候根据使用的场景传入不同的文案即可。例如：上传头像时使用：&amp;lt;UploadImg&amp;gt;&amp;lt;h4&amp;gt;上传头像&amp;lt;/h4&amp;gt;&amp;lt;/UploadImg&amp;gt;； 上传证书时使用：&amp;lt;UploadImg&amp;gt;&amp;lt;h4&amp;gt;上传证书&amp;lt;/h4&amp;gt;&amp;lt;/UploadImg&amp;gt;。&lt;/p&gt;
&lt;p&gt;在子组件中使用this.props.children就可以获取父组件通过&amp;lt;UploadImg&amp;gt;&amp;lt;h4&amp;gt;上传头像&amp;lt;/h4&amp;gt;&amp;lt;/UploadImg&amp;gt;传递过来的 “&amp;lt;h4&amp;gt;上传头像&amp;lt;/h4&amp;gt;” 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;父组件中：
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UploadImg&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;上传头像&amp;lt;/h4&amp;gt;/&lt;/span&gt;&lt;span&gt;UploadImg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

子组件中：
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;父组件传递过来的：{this.props.children}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 使用this.props.children时，父组件只有一个入口。有的时候使用父组件时有的时候我们需要有多个入口，这种情况我们就需要约定自己的属性而不是使用children。&lt;strong&gt;实际上children也是表示是父组件中的一个属性，父组件的属性值不仅限于常量、变量、函数，还可以为react元素。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;父组件中：
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UploadImg &lt;/span&gt;&lt;span&gt;btnText&lt;/span&gt;&lt;span&gt;={&amp;lt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;上传头像&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;} btnNum={&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;}&amp;gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;UploadImg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

子组件中：
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;父组件传递过来的btnText：{this.props.btnText}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;父组件传递过来的btnNum：{this.props.btnNum}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;父组件中的 btnText属性和btnNum属性的值都是为react元素，在子组件中使用this.props.btnText和this.props.btnNum就可以取得对应的react元素。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;写了一些demo发现，一个项目说白了就是一个根组件组成，但是这个根组件又由很多子组件组成，这些子组件又是由这些子组件的子组件组成。就这样层层嵌套下去，最终形成的就是一个完整的项目。目前react初探差不多就到此为止，更多深入的知识需要后面在实际项目中使用react后再来总结。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 16:08:00 +0000</pubDate>
<dc:creator>你假装没察觉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heavenYJJ/p/9215021.html</dc:identifier>
</item>
<item>
<title>【MBSE】系统工程的本质 - 胖仔</title>
<link>http://www.cnblogs.com/nelson2013/p/9251917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nelson2013/p/9251917.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;本篇博文是基于模型的系统工程（MBSE）的开篇，主要对系统工程进行简要的介绍，并随着后续文章的深入，逐步揭开MBSE的神秘面纱。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中的部分内容其实也是作者的一些读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系统的本质&quot;&gt;2. 系统的本质&lt;/h3&gt;
&lt;p&gt;我们基于这样一个论点：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;系统思想是系统理论的基石&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在认识系统理论之前我们有必要先了解 “系统思想” 的含义。基于辩证唯物主义的哲学观点，系统是客观存在的，系统思想也是客观存在的。系统思想的产生远在科学的系统理论诞生之前，系统思想的出现从古代先贤的思想中便端倪可见。我们从两个维度去剖析系统思想：朴素系统思想和科学系统思想。&lt;/p&gt;
&lt;h4 id=&quot;朴素的系统思想&quot;&gt;2.1 朴素的系统思想&lt;/h4&gt;
&lt;p&gt;朴素系统思想主要来源于人类与自然地长期融合，而自发的形成冲一种关于系统的思想。这些思想可能是随机的、灵感式的出现，并未以科学化的方式形成统一的系统理论。体现朴素的系统思想的例子很多，例如，古希腊哲学家德谟克利特提出的 “宇宙大系统” 的概念，赫拉克利特认为 “世界是包括一切的整体”。又如，中国古代东汉时期张衡的 “浑天说”，春秋时期的思想家老子关于自然界统一性的阐述，西周时期的“五行说”等等。以上这些都是早期的系统思想的提现。同时，古人同样会基于系统的思想应用于实践。例如中国古代的“都江堰”、长城等都是典型的系统思想的实践案例。至此，我们将朴素的系统思想总结为：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;朴素的系统思想主要是人们对世界的整体性和统一性的认识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;朴素的系统思想是片段式的、灵感式的，在当时的自然科学发展的条件限制下，无法也不可能对系统思想建立一套专门的科学方法体系。&lt;/p&gt;
&lt;h4 id=&quot;科学的系统思想&quot;&gt;2.2 科学的系统思想&lt;/h4&gt;
&lt;p&gt;科学系统思想比朴素的系统思想产生的要晚，主要伴随着19世纪自然科学的发展，科学系统思想才应运而生。科学的系统思想的本质是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;世界是由无数相互关联、相互依赖、相互操作的过程所形成的的统一整体。这种普遍联系和整体性思想就是科学系统思想的实质。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;系统理论的出现&quot;&gt;3. 系统理论的出现&lt;/h3&gt;
&lt;p&gt;系统理论的出现以贝塔朗菲的“一般系统论”为典型代表。一般系统论包括了系统的科学、系统的技术以及系统的工程三个方面，从其组成可见一般系统论涵盖范围非常广泛。&lt;/p&gt;
&lt;h3 id=&quot;系统工程的研究对象&quot;&gt;4. 系统工程的研究对象&lt;/h3&gt;
&lt;p&gt;系统工程研究的对象是“系统”，那么，什么才是“系统”呢？一架飞机是系统，一辆汽车是系统，一个水杯也可以称之为系统。下面我们将从更为普遍的定义去阐述系统的定义。&lt;/p&gt;
&lt;h4 id=&quot;什么是系统&quot;&gt;4.1 什么是系统？&lt;/h4&gt;
&lt;p&gt;如下定义&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;系统是由两个以上有机联系、相互作用的要素所组成，具有特定功能、结构和环境的整体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;系统及其要素&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;系统并不是独立的，其由两个以上要素组成。要素可以是单个事务，也可以是一组事务。我们也可以这样描述，系统又可以开分为子系统，而子系统又可以继续拆分。系统和子系统是一个相对概念，这和我们描述系统的大小和范围相关。我们说，系统具有“统则唯一，分则无限”的特点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;系统和环境&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;任何一个系统又归属于更大的一个系统，并与其相互作用和联系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;系统的结构&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;构成系统的多要素间相互联系，在系统内部构成一定的结构和秩序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;系统的功能&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;系统的功能是系统的价值和目的所在&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;系统的一般属性&quot;&gt;4.2 系统的一般属性&lt;/h4&gt;
&lt;ol&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整体性&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;系统的整体性是系统最核心的属性之一。系统各要素基于系统的整体功能和逻辑性要求协调于系统中，要素间的相互关系也是服从于系统的整体性功能要求。系统所表现出来的功能特性是各个要素间的相互作用和联系产生的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关联性&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;构成系统的要素不是相互独立的，而是相互联系、相互作用的。正是基于要素间的相互作用才构成了整体系统的功能特性。要素间的关联性构成了系统结构的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;环境适应性&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;任何一个系统都不是孤立存在的，它必然是存在于一个更大的系统中，并与这个外部系统存在物质、能量或信息的交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;系统工程&quot;&gt;5. 系统工程&lt;/h3&gt;
&lt;p&gt;我们聊到了系统思想和系统，那么，到底什么是“系统工程”呢？&lt;/p&gt;
&lt;h4 id=&quot;什么是系统工程&quot;&gt;5.1 什么是系统工程&lt;/h4&gt;
&lt;p&gt;关于“系统工程”的定义不同的专家或组织有着不同的阐述，例如：&lt;br/&gt;著名科学家钱学森指出：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;系统工程是组织管理系统的规划、研究、设计、制造、试验和使用的科学方法，是一种对所有系统具有普遍意义的科学方法。系统工程是一种组织管理的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;日本工业标准JIS界定：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;系统工程是为了更好的达到系统目标，而对系统的构成要素、组织结构、信息流动和控制机制等进行分析和设计的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总之，系统工程是一项工程学科：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;系统工程是用定性和定量相结合的系统思想和方法处理大型复杂系统问题的一类工程实践。系统工程是一门交叉科学，系统工程的对象不限于某一特定的工程领域，任一种物质系统都可以作为系统工程的研究对象。它可以适用于自然系统、社会经济系统、经营管理系统、军事指挥等等工程领域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人们更为普遍的认识是：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;系统工程以大规模复杂问题为研究对象，在运筹学、系统理论、管理科学等学科的基础上发展起来的一门交叉学科。系统工程的理论基础是由一般系统论以及大系统理论、经济控制论、运筹学等学科相互渗透、交叉发展而形成的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总结&quot;&gt;5. 总结&lt;/h3&gt;
&lt;p&gt;系统工程的核心思想是“系统思想”，系统工程研究的对象是“系统”，系统“可大可小”，具有整体性、关联性和环境适应性一般属性。系统工程是一门工程科学，也是一门多学科交叉科学。系统工程的理论基础由一般系统论、大系统理论、经济控制论、运筹学等诸多学科交叉发展而成。&lt;/p&gt;
&lt;p&gt;补充：&lt;br/&gt;关于 “什么是系统”：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;关于“什么是系统 ” 是一个相对的认识。系统既可以是复杂大系统，例如导弹、卫星、航天飞机、登月工程，也可以是简单系统，如水杯、手机壳等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于“整体性”：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;系统的“整体性”是关键特性。我们可以这样说，虽然系统由多要素组成，但“系统”更为关注的是系统整体所呈现出来的特性。这写系统整体特性并不是简单的构成要素功能特性的并集。而多数情况下，是这些要素相互作用而形成的 “新”的特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后续将对系统工程方法论、系统模型与系统工程进行介绍。&lt;/p&gt;
&lt;p&gt;更多请关注微信公众号&lt;br/&gt;&lt;img src=&quot;https://github.com/nixxyahoocn/resources/blob/master/imgs/common/weixin.png?raw=true&quot; alt=&quot;SystemEngineeringLab&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 15:59:00 +0000</pubDate>
<dc:creator>胖仔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nelson2013/p/9251917.html</dc:identifier>
</item>
<item>
<title>跟浩哥学自动化测试Selenium -- Selenium简介 (1) - JackTester</title>
<link>http://www.cnblogs.com/jacktest/p/9074939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jacktest/p/9074939.html</guid>
<description>&lt;p&gt;&lt;span&gt;    Selenium 是一款开源的web自动化测试工具，用来模拟对浏览器的操作(主要是对页面元素的操作)，简单来讲，其实就是一个jar包。&lt;/span&gt;&lt;span&gt;Selenium早期的版本比如1.0市场占有率很小，主要原因都是因为1.0采用的是js注入的方式，带来得问题比如跨域的问题，安全性的问题。2.0版本已经解决这个问题，主要采用浏览器的原生组件来操作浏览器，所以针对不同的浏览器需要相应的 native component 把WebDriver 的API 转化成浏览器的 native invoke。3.0 版本的主要变化是支持w3c。至于各个版本之间到底有什么不同，如果有兴趣可以参考Selenium官方网站。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    版本选择：不管你是初学者还是之前了解过，还是建议直接使用Selenium3.0以上版本，必定新的版本稳定性，性能，兼容性更好一些&lt;/span&gt;&lt;span&gt;(除了Firefox需要显示设置 geckodriver.exe之外几乎和以前没什么不同，当然2.0也是需要驱动的只不过Selenium内部帮你设置了)&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;下载地址: &lt;a href=&quot;https://www.seleniumhq.org/download/&quot; target=&quot;_blank&quot;&gt;https://www.seleniumhq.org/download/&lt;/a&gt; 选择 Selenium Standalone Server下的 Download version 链接即可，目前 最新版本 3.12.0 (下载记得用代理)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;驱动：同页面下有相应的浏览器驱动，例如火狐的 GeckoDriver，google的 Chrome Driver ，注意IE 驱动分为32位和64位版本&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;版本升级：如果浏览器提示你升级，建议等一等，因为有可能相应的Selenium驱动版本还未更新，老的驱动在新版本的浏览器执行时可能会有兼容问题，这种问题几乎无法解决，所以升级要慎重(不说了，全是泪)，建议等2-3周再更新并下载新的驱动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    对于无法使用代理的同学，提供另一个种方式，也是比较推荐的方式，如果你是java的项目，可以搭建maven项目(如何搭建不在详细讲述，可自行百度，非常简单，python 程序请参考自动化教程之Selenium python版本)。简单分为如下三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;打开maven 仓库地址：&lt;a href=&quot;https://mvnrepository.com/&quot; target=&quot;_blank&quot;&gt;https://mvnrepository.com/&lt;/a&gt;，在搜索栏中输入Selenium，点击&quot;search&quot;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;点击第一个黑体链接 Selenium Java，点击最新版本3.12.0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;拷贝页面中间 dependency部分到你的项目的pom依赖中(maven会自行下载jar到你的maven仓库中)，下载成功后你的pom中dependency依赖会变成黑色(表示下载成功，否则为红色)，且在项目的External Libraries中会显示有关Selenium的jar，由于网速不同，下载有时会稍慢，可耐心等待，如下图：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1372635/201805/1372635-20180523224035776-651209432.png&quot; alt=&quot;&quot;/&gt;下载成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1372635/201805/1372635-20180523224322986-21000869.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;221&quot;/&gt;External Libraries显示的jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;Selenium 驱动无法通过Maven来下载，必须使用代理，所以需要驱动的同学可以联系我，到时候发给大家。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   当Selenium的jar和驱动都下载并配置完成后，我们就可以使用 Selenium 的api 进行第一个脚本了。什么，不知道怎么配置，没关系，详见 Selenium 教程第二篇《我的第一个Demo》。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   转载请注明作者与出处，谢谢！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 15:38:00 +0000</pubDate>
<dc:creator>JackTester</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jacktest/p/9074939.html</dc:identifier>
</item>
<item>
<title>数据准备:变量筛选-理论篇 - hbsygfz</title>
<link>http://www.cnblogs.com/hbsygfz/p/9251695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hbsygfz/p/9251695.html</guid>
<description>&lt;blockquote readability=&quot;7.4285714285714&quot;&gt;
&lt;p&gt;&lt;span&gt;在上一篇文章&lt;a href=&quot;http://www.cnblogs.com/hbsygfz/p/9026998.html&quot;&gt;《数据准备&amp;lt;3&amp;gt;：数据预处理》&lt;/a&gt;中，我们提到降维主要包括两种方式：基于特征选择的降维和基于维度转换的降维，其中基于特征选择的降维通俗的讲就是特征筛选或者变量筛选，是指从多个特征（变量）中筛选出显著的特征（变量），在分类预测问题中，就是筛选出对目标变量有预测能力的特征（变量）。本篇主要介绍特征（变量）筛选的基本思路与方法，为简洁，下文均使用“变量筛选”指代。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量筛选主要有&lt;strong&gt;三种方法&lt;/strong&gt;：&lt;strong&gt;基于经验的方法（比如专家法）、基于统计的方法（比如信息增益、区分度）和基于机器学习的方法（比如决策树算法）&lt;/strong&gt;。下面将分别具体介绍：&lt;/p&gt;
&lt;h2 id=&quot;基于经验的方法&quot;&gt;1.基于经验的方法&lt;/h2&gt;
&lt;p&gt;根据业务专家或者数据专家的以往经验、实际数据情况、业务理解程度等进行综合考虑。业务专家依靠的是业务背景，从众多维度变量中选择对结果影响较大的变量；而数据专家依靠的则是数据工作经验，基于数据的基本特征以及对后期数据处理和建模的影响来选择或者排除，比如删除缺失值较多的变量。&lt;/p&gt;
&lt;h2 id=&quot;基于统计的方法&quot;&gt;2.基于统计的方法&lt;/h2&gt;
&lt;p&gt;构建统计指标，对变量的预测能力进行度量，选择其中预测能力较大的变量。&lt;br/&gt;首先，从&lt;strong&gt;香农的信息熵&lt;/strong&gt;说起。&lt;br/&gt;香农（Claude Elwood Shannon，1916年4月30日—2001年2月24日）是美国数学家、信息论的创始人，他在1948年发表的《通信的数学理论》论文中提出了信息熵的概念，认为信息是用来减少随机不确定的东西，使用信息熵对信息进行定量度量。&lt;br/&gt;定义任意一个随机事件&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;，其发生的可能情况有&lt;span class=&quot;math inline&quot;&gt;\(x_1,x_2……,x_n\)&lt;/span&gt;，对应的概率分别为&lt;span class=&quot;math inline&quot;&gt;\(p_1,p_2,……,p_n\)&lt;/span&gt;，它的信息熵&lt;span class=&quot;math inline&quot;&gt;\(H(X)\)&lt;/span&gt;定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H(X)=-\sum_{i=1}^n{p_i*log(p_i)} \]&lt;/span&gt;信息熵反映了消除这个随机事件不确定性所需要的信息量的大小，换言之，信息熵度量了一个随机事件不确定程度的大小。&lt;br/&gt;信息熵越大，代表一个随机事件不确定程度越高，消除这个随机事件不确定性所需要的信息就越多。&lt;br/&gt;&lt;strong&gt;例1：&lt;/strong&gt;现在要基于历史样本集预测一个新用户是否会换机，提供了三个样本集：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231312944-152896541.png&quot;/&gt;&lt;br/&gt;对于一个用户来说，是否会换机是一个随机事件，其取值有两种情况：换、不换。&lt;br/&gt;在三个样本集下，该随机事件的概率分布分别为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231332544-506143500.png&quot;/&gt;&lt;br/&gt;对应的，在三个样本集下，这个随机事件的信息熵分别为：&lt;br/&gt;样本集1：H=1&lt;br/&gt;样本集2：H=0.88&lt;br/&gt;样本集3：H=0.47&lt;br/&gt;可以看到，随机事件的概率分布越均匀，它的不确定程度就越大，信息熵就越大。&lt;br/&gt;下面我们回到变量筛选的话题中。&lt;br/&gt;&lt;strong&gt;变量筛选是筛选出对目标变量的预测有帮助的变量，那么又如何定义一个变量对目标变量的预测有帮助？&lt;/strong&gt;&lt;br/&gt;可以认为，如果引入一个变量后，这个变量能够一定程度上消除目标变量这个随机事件的不确定性，那么就说这个变量对目标变量的预测有帮助，换言之，这个变量具有对目标变量的预测能力。如果消除不确定性的程度越大，那么这个变量就越重要、预测能力就越强。&lt;br/&gt;明白这一点后，事情就变得简单起来。我们可以通过评估引入某个变量前后，目标变量这个随机事件的不确定性的变化大小，来度量一个变量对目标变量的预测能力强弱。&lt;/p&gt;
&lt;h3 id=&quot;信息增益&quot;&gt;2.1 信息增益&lt;/h3&gt;
&lt;p&gt;信息增益的概念非常简单，就是引入一个变量前后，一个随机事件的信息熵的变化值，通俗的说，就是不确定性消除的大小。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gain(A) = H(X) - H(X,A) \]&lt;/span&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(H(X)\)&lt;/span&gt;为引入变量A之前随机事件X的信息熵，&lt;span class=&quot;math inline&quot;&gt;\(H(X,A)\)&lt;/span&gt;为引入变量A之后随机事件X的信息熵。&lt;br/&gt;显然，信息增益越大，代表引入变量A之后，消除随机事件X不确定性的程度越大，说明变量A对目标变量X的预测能力就越强。&lt;br/&gt;另外，我们称&lt;span class=&quot;math inline&quot;&gt;\(H(X,A)\)&lt;/span&gt;为条件熵，即随机变量X在条件A下的信息熵。其计算方法为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ H(X,A)=-\sum_{j=1}^m{pa_j}\sum_{i=1}^n{(p_i|pa_j)*log(p_i|pa_j)} \]&lt;/span&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(p_i|pa_j\)&lt;/span&gt;为条件A取值为j的情况下随机变量X的取值概率，&lt;span class=&quot;math inline&quot;&gt;\(pa_j\)&lt;/span&gt;为随机变量A取值为j的概率。&lt;br/&gt;&lt;strong&gt;例2：&lt;/strong&gt;使用经典的AllElectronics数据集，用于预测一个顾客是否会购买电脑。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231359329-2090350071.png&quot;/&gt;&lt;br/&gt;从样本总体上看：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231411566-700055109.png&quot;/&gt;&lt;br/&gt;如果引入age变量，如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231420497-896654581.png&quot;/&gt;&lt;br/&gt;如果引入income变量，如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231431940-101822698.png&quot;/&gt;&lt;br/&gt;可以得到：&lt;br/&gt;H(X)=0.9403&lt;br/&gt;H(X,'age')=0.6935，Gain(X,'age')=0.2468&lt;br/&gt;H(X,'income')=0.9111，Gain(X,'income')=0.0292&lt;br/&gt;由于Gain(X,'age')&amp;gt;Gain(X,'income')，所以变量age比变量income对目标变量buy_computer的预测能力要强。&lt;/p&gt;
&lt;h3 id=&quot;基尼指数&quot;&gt;2.2 基尼指数&lt;/h3&gt;
&lt;p&gt;基尼指数（Gini Index），是另一个用来度量随机事件不确定程度的指标，其定义&lt;strong&gt;Gini(X)&lt;/strong&gt;为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gini(X)=\sum_{i=1}^n{p_i*(1-p_i)=1-\sum_{i=1}^n{p_i^2}} \]&lt;/span&gt;针对例1，分别计算基尼指数：&lt;br/&gt;情况1：Gini=0.50&lt;br/&gt;情况2：Gini=0.42&lt;br/&gt;情况3：Gini=0.18&lt;br/&gt;可以看出，基尼指数越大，随机事件的不确定程度就越大。&lt;br/&gt;类似于信息增益的定义，定义指标“基尼指数降低值”：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Delta{Gini}(A) = Gini(X) - Gini(X,A) \]&lt;/span&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(Gini(X)\)&lt;/span&gt;为引入变量A之前随机事件X的基尼指数，&lt;span class=&quot;math inline&quot;&gt;\(Gini(X,A)\)&lt;/span&gt;为引入变量A之后随机事件X的基尼指数。&lt;br/&gt;同样，基尼指数降低值越大，代表引入变量A之后，消除随机事件X不确定程度越大，说明变量A对目标变量X的预测能力就越强。&lt;br/&gt;针对例2，计算基尼指数及其降低值：&lt;br/&gt;Gini(X)=0.4592&lt;br/&gt;Gini(X,'age')=0.3429，&lt;span class=&quot;math inline&quot;&gt;\(\Delta\)&lt;/span&gt;Gini('age')=0.1163&lt;br/&gt;Gini(X,'income')=0.4405，&lt;span class=&quot;math inline&quot;&gt;\(\Delta\)&lt;/span&gt;Gini('income')=0.0187&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta\)&lt;/span&gt;Gini('age')&amp;gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta\)&lt;/span&gt;Gini('income')，因此变量“age”比变量“income”对目标变量的预测能力要强。&lt;/p&gt;
&lt;h3 id=&quot;区分度&quot;&gt;2.3 区分度&lt;/h3&gt;
&lt;p&gt;在二分类问题中，可以使用区分度这个指标，它是从另一个角度来评估随机事件不确定程度的指标。&lt;br/&gt;上文中，信息增益和基尼指数降低值，都是从引入变量A后随机事件X不确定性的消除程度来评估变量A对X的预测能力的。由于引入变量A前，随机事件X的不确定程度是确定的，消除程度越大，说明引入变量A后随机事件X的不确定程度越小，所以也可以直接通过度量引入变量A后随机事件X的不确定程度来评估变量A对X的预测能力。区分度正是这样的指标。&lt;br/&gt;在上文中，我们还知道，随机事件的概率分布越均匀，它的不确定程度越大。&lt;br/&gt;因此，基于这两点，定义“区分度”如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ 区分度=max_{j=1}^m(pa_j/p) \]&lt;/span&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;为引入变量A以前随机变量X取值为响应值的概率，&lt;span class=&quot;math inline&quot;&gt;\(pa_j\)&lt;/span&gt;为引入变量A之后，在变量A取值为j时，随机变量X取值为响应值的概率。&lt;br/&gt;区分度反映了引入变量A后随机事件X发生概率的均匀程度，取值越大，代表越不均匀，不确定程度就越小，变量A的预测能力就越强。&lt;br/&gt;针对例2，它属于一个二分类问题，buy_computer='yes'为响应值。&lt;br/&gt;区分度('age')=1.56&lt;br/&gt;区分度('income')=1.17&lt;br/&gt;区分度('age')&amp;gt;区分度('income')，因此变量“age”比变量“income”对目标变量的预测能力要强。&lt;br/&gt;&lt;strong&gt;一般的，将区分度=1.5作为筛选阈值，选择区分度大于1.5的变量。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;信息值iv&quot;&gt;2.4 信息值（IV）&lt;/h3&gt;
&lt;p&gt;在二分类问题中，也可以使用信息值（Information Value，IV）度量变量A对随机事件X的预测能力。&lt;br/&gt;定义如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ woe_j=ln(\frac{{cov_Y}_j}{{cov_N}_j})=ln(\frac{\frac{Y_j}{Y}}{\frac{N_j}{N}}) \]&lt;/span&gt;&lt;span class=&quot;math display&quot;&gt;\[ IV=\sum_{j=1}^m{({cov_Y}_j-{cov_N}_j)*woe_j}=\sum_{j=1}^m{({\frac{Y_j}{Y}}-{\frac{N_j}{N}})*woe_j} \]&lt;/span&gt;其中，woe（Weight of Evidence，证据权重），它是根据变量A的取值将随机事件样本集进行分组，分成m组，每组分别计算woe取值。&lt;br/&gt;woe等于每一组内响应样本的覆盖率（&lt;span class=&quot;math inline&quot;&gt;\({cov_Y}_j\)&lt;/span&gt;）与非响应样本的覆盖率（&lt;span class=&quot;math inline&quot;&gt;\({cov_N}_j\)&lt;/span&gt;）的比值的取对数，从这个定义上可以理解成，woe考察的是每个分组内，响应样本相对非响应样本的分布差异，如果二者没有差异，说明与总体分布完全相同，此时woe取值为0。当响应样本分布多于非响应样本，woe&amp;gt;0；反之，woe&amp;lt;0。&lt;br/&gt;由于woe的取值有正有负，同时，衡量变量A的预测能力是一个样本全集概念，而不是某一个样本子集，因此，将每一组内响应样本的覆盖率与非响应样本的覆盖率的差值作为权重，对woe进行加权求和得到的值，定义为IV，既可以得到一个整体指标，也可以将指标值调和成正值。&lt;br/&gt;针对例2，buy_computer='yes'为响应值，buy_computer='no'为非响应值。&lt;br/&gt;IV('age')=2.0358&lt;br/&gt;IV('income')=0.1773&lt;br/&gt;IV('age')&amp;gt;IV('income')，因此变量“age”比变量“income”对目标变量的预测能力要强。&lt;br/&gt;&lt;strong&gt;一般的：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201807/554583-20180701231448833-1151426232.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;将0.10作为筛选阈值，选择IV大于等于0.10的变量。&lt;/strong&gt;&lt;br/&gt;需要说明的：关于&lt;strong&gt;分组中的响应值或者非响应值为0&lt;/strong&gt;时的处理方式：&lt;br/&gt;1）重新分组，尽量不出现这种情况；&lt;br/&gt;2）手工调整这个值，将其调整为1。&lt;/p&gt;
&lt;h2 id=&quot;基于机器学习的方法&quot;&gt;3.基于机器学习的方法&lt;/h2&gt;
&lt;p&gt;基于机器学习的方法进行变量筛选，是指构建一个或者多个机器学习模型，来判断每个变量的重要程度，得到最重要的变量。与基于统计的方法相比，基于机器学习的方法同时考虑了所有变量，而不是对单个变量进行独立度量。&lt;/p&gt;
&lt;h3 id=&quot;单一算法&quot;&gt;3.1 单一算法&lt;/h3&gt;
&lt;p&gt;基于单一算法的方法，是指构建一个有监督的机器学习模型，这个模型不需要用于最终的模型构建，模型自动为每个变量提供某种重要性度量，进而通过这个度量进行重要性排序，比如使用决策树、随机森林等，算法内部包含有变量重要性度量指标。&lt;/p&gt;
&lt;h3 id=&quot;迭代&quot;&gt;3.2 迭代&lt;/h3&gt;
&lt;p&gt;基于迭代的方法，其实就是基于多个模型甚至是一系列模型来进行判断。它主要有两种思路：前向筛选和后向筛选，即开始时没有变量，然后逐个添加变量，直到满足某个终止条件；或者从所有变量开始，然后逐个删除变量，直到满足某个终止条件。相比基于单一算法的方法，基于迭代的变量筛选的结果更好。&lt;br/&gt;&lt;strong&gt;由于涉及到具体的实现环境，这一部分将在下一篇《数据准备&amp;lt;5&amp;gt;:变量筛选-实战篇》结合sklearn环境进行具体介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考与感谢&quot;&gt;4. 参考与感谢&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://book.douban.com/subject/2038599/&quot;&gt;数据挖掘概念与技术&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://book.douban.com/subject/30147778/&quot;&gt;Python机器学习基础教程&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;https://book.douban.com/subject/27608466/&quot;&gt;Python数据分析与数据化运营&lt;/a&gt;&lt;br/&gt;[4] &lt;a href=&quot;https://baike.baidu.com/item/%E5%85%8B%E5%8A%B3%E5%BE%B7%C2%B7%E8%89%BE%E5%B0%94%E4%BC%8D%E5%BE%B7%C2%B7%E9%A6%99%E5%86%9C/10588593?fromtitle=%E9%A6%99%E5%86%9C&amp;amp;fromid=1146248&amp;amp;fr=aladdin&quot;&gt;百度百科:香农&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 01 Jul 2018 15:31:00 +0000</pubDate>
<dc:creator>hbsygfz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hbsygfz/p/9251695.html</dc:identifier>
</item>
</channel>
</rss>