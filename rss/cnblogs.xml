<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>优先队列 Rust实现 - 弱冠</title>
<link>http://www.cnblogs.com/kwebi/p/9631773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kwebi/p/9631773.html</guid>
<description>&lt;p&gt;优先队列是用来维护一组元素集合的数据结构&lt;/p&gt;
&lt;p&gt;一个最小优先队列支持下列操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;heap_insert_key(i, key)&lt;/code&gt;把key插入键i的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_extract_min()&lt;/code&gt;删除并返回堆的最小值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以用堆来实现优先队列&lt;br/&gt;关于建堆的操作，之前的文章已经介绍过了&lt;/p&gt;
&lt;pre class=&quot;rust&quot;&gt;
&lt;code&gt;pub struct MinHeap {
    size: usize,
    array: Vec&amp;lt;i32&amp;gt;,
}

impl MinHeap {
    pub fn new(array: Vec&amp;lt;i32&amp;gt;) -&amp;gt; MinHeap {
        MinHeap {
            size: array.len(),
            array,
        }
    }
    fn parent(i: usize) -&amp;gt; usize {
        i / 2
    }
    fn left(i: usize) -&amp;gt; usize {
        2 * i
    }
    fn right(i: usize) -&amp;gt; usize {
        2 * i + 1
    }
    fn heap_size(&amp;amp;self) -&amp;gt; usize {
        self.size
    }
    fn swap(&amp;amp;mut self, a: usize, b: usize) {
        self.array.swap(a, b);
    }
    fn min_heapify(&amp;amp;mut self, mut i: usize) {
        loop {
            let l = MinHeap::left(i);
            let r = MinHeap::right(i);
            let mut min;
            if l &amp;lt;= self.size &amp;amp;&amp;amp; self.array[i - 1] &amp;gt; self.array[l - 1] {
                min = l;
            } else {
                min = i;
            }
            if r &amp;lt;= self.size &amp;amp;&amp;amp; self.array[min - 1] &amp;gt; self.array[r - 1] {
                min = r;
            }
            if min == i {
                break;
            } else {
                self.swap(i - 1, min - 1);
            }
            i = min;
        }
    }
    pub fn build_min_heap(&amp;amp;mut self) {
        for i in (1..self.size + 1).rev() {
            self.min_heapify(i);
        }
    }
    fn heap_exterct_min(&amp;amp;mut self) -&amp;gt; i32 {
        let size = self.size;
        if size &amp;lt; 1 {
            panic!(&quot;heap underflow&quot;);
        }
        let max = self.array[0];
        self.swap(0, size - 1);
        self.size -= 1;
        self.min_heapify(1);
        max
    }
    pub fn heap_insert_key(&amp;amp;mut self, mut i: usize, key: i32) {
        if key &amp;gt; self.array[i - 1] {
            panic!(&quot;the new key is larger&quot;);
        }
        self.array[i - 1] = key;
        let mut parent = MinHeap::parent(i);
        while i &amp;gt; 1 &amp;amp;&amp;amp; self.array[i - 1] &amp;lt; self.array[parent - 1] {
            self.swap(i - 1, parent - 1);
            i = parent;
            parent = MinHeap::parent(i);
        }
    }
    pub fn min_heap_insert(&amp;amp;mut self, key: i32) {
        self.size += 1;
        self.array.push(i32::max_value());
        let i = self.size;
        self.heap_insert_key(i, key);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Sep 2018 15:46:00 +0000</pubDate>
<dc:creator>弱冠</dc:creator>
<og:description>优先队列 优先队列是用来维护一组元素集合的数据结构 一个最小优先队列支持下列操作： + 把key插入键i的值 + 删除并返回堆的最小值 可以用堆来实现优先队列 关于建堆的操作，之前的文章已经介绍过了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kwebi/p/9631773.html</dc:identifier>
</item>
<item>
<title>mac终端不好用?用brew神器代替 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9631769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9631769.html</guid>
<description>&lt;h3 id=&quot;一概念&quot;&gt;一、概念&lt;/h3&gt;
&lt;p&gt;Brew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。&lt;/p&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://brew.sh/&quot; class=&quot;uri&quot;&gt;https://brew.sh&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二安装&quot;&gt;二、安装&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安装方法:命令行输入&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;它的用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;brew update&lt;/code&gt;: 更新brew；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;brew install 模块名&lt;/code&gt;安装软件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;brew cask install {应用名，如git}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;也是下载安装，与上面的区别，请查看https://www.zhihu.com/question/22624898&lt;/p&gt;
&lt;p&gt;更多用法请 brew help&lt;/p&gt;
&lt;p&gt;神器好不好，用了才知道，自己去试吧&lt;/p&gt;
&lt;blockquote readability=&quot;1.9512195121951&quot;&gt;
&lt;p&gt;内容转载于:&lt;a href=&quot;https://www.cnblogs.com/zoulifeng2017/p/7514139.html&quot;&gt;《mac安装神器brew》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 11 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、概念 Brew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。 官</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9631769.html</dc:identifier>
</item>
<item>
<title>MongoDB 提升性能的18原则 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9631761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9631761.html</guid>
<description>&lt;p&gt;MongoDB 是高性能数据，但是在使用的过程中，大家偶尔还会碰到一些性能问题。MongoDB和其它关系型数据库相比，例如 SQL Server 、MySQL 、Oracle 相比来说，相对较新，很多人对其不是很熟悉，所以很多开发、DBA往往是注重功能的实现，而忽视了性能的要求。其实，MongoDB和 SQL Server 、MySQL 、Oracle 一样，一个 数据库对象的设计调整、索引的创建、语句的优化，都会对性能产生巨大的影响。&lt;/p&gt;
&lt;p&gt;为了充分挖掘MongoDB性能，现简单总计了以下18条，欢迎大家一起来持续总结完善。&lt;/p&gt;

&lt;p&gt;（1）  文档中的_id键推荐使用默认值，禁止向_id中保存自定义的值。&lt;/p&gt;
&lt;p&gt;    解读：MongoDB文档中都会有一个“_id”键，默认是个ObjectID对象（标识符中包含时间戳、机器ID、进程ID和计数器）。MongoDB在指定_id与不指定_id插入时      速度相差很大，指定_id会减慢插入的速率。&lt;/p&gt;

&lt;p&gt;（2）  推荐使用短字段名。&lt;/p&gt;
&lt;p&gt;           解读：与关系型数据库不同，MongoDB集合中的每一个文档都需要存储字段名，长字段名会需要更多的存储空间。&lt;/p&gt;

&lt;p&gt;（3）  MongoDB索引可以提高文档的查询、更新、删除、排序操作，所以结合业务需求，适当创建索引。&lt;/p&gt;

&lt;p&gt;（4）  每个索引都会占用一些空间，并且导致插入操作的资源消耗，因此，建议每个集合的索引数尽量控制在5个以内。&lt;/p&gt;

&lt;p&gt;（5）  对于包含多个键的查询，创建包含这些键的复合索引是个不错的解决方案。复合索引的键值顺序很重要，理解索引最左前缀原则。&lt;/p&gt;

&lt;p&gt;解读：例如在test集合上创建组合索引{a:1,b:1,c:1}。执行以下7个查询语句：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;db.test.find({a:”hello”})&lt;/li&gt;
&lt;li&gt;db.test.find({b:”sogo”, a:”hello”})&lt;/li&gt;
&lt;li&gt;db.test.find({a:”hello”,b:”sogo”, c:”666”})&lt;/li&gt;
&lt;li&gt;db.test.find({c:”666”, a:”hello”})&lt;/li&gt;
&lt;li&gt;db.test.find({b:”sogo”, c:”666”})&lt;/li&gt;
&lt;li&gt;db.test.find({b:”sogo” })&lt;/li&gt;
&lt;li&gt;db.test.find({c:”666”})&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;以上查询语句可能走索引的是1、2、3、4&lt;/li&gt;
&lt;li&gt;查询应包含最左索引字段，以索引创建顺序为准，与查询字段顺序无关。&lt;/li&gt;
&lt;li&gt; 最少索引覆盖最多查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（6） TTL 索引（time-to-live index，具有生命周期的索引），使用TTL索引可以将超时时间的文档老化，一个文档到达老化的程度之后就会被删除。&lt;/p&gt;
&lt;p&gt;解读：创建TTL的索引必须是日期类型。TTL索引是一种单字段索引，不能是复合索引。TTL删除文档后台线程每60s移除失效文档。不支持定长集合。&lt;/p&gt;

&lt;p&gt;（7） 需要在集合中某字段创建索引，但集合中大量的文档不包含此键值时，建议创建稀疏索引。&lt;/p&gt;
&lt;p&gt;解读：索引默认是密集型的，这意味着，即使文档的索引字段缺失，在索引中也存在着一个对应关系。在稀疏索引中，只有包含了索引键值的文档才会出现。&lt;/p&gt;

&lt;p&gt;（8）  创建文本索引时字段指定text，而不是1或者-1。每个集合只有一个文本索引，但是它可以为任意多个字段建立索引。&lt;/p&gt;
&lt;p&gt;解读：文本搜索速度快很多，推荐使用文本索引替代对集合文档的多字段的低效查询。&lt;/p&gt;

&lt;p&gt;（9）  使用findOne在数据库中查询匹配多个项目，它就会在自然排序文件集合中返回第一个项目。如果需要返回多个文档，则使用find方法。&lt;/p&gt;

&lt;p&gt;（10） 如果查询无需返回整个文档或只是用来判断键值是否存在，可以通过投影（映射）来限制返回字段，减少网络流量和客户端的内存使用。&lt;/p&gt;
&lt;p&gt;解读：既可以通过设置{key:1}来显式指定返回的字段，也可以设置{key:0}指定需要排除的字段。&lt;/p&gt;

&lt;p&gt;（11）  除了前缀样式查询，正则表达式查询不能使用索引，执行的时间比大多数选择器更长，应节制性地使用它们。&lt;/p&gt;

&lt;p&gt;（12） 在聚合运算中，$match 要在 $ group前面，通过 $match 前置，可以减少$ group 操作符要处理的文档数量。&lt;/p&gt;

&lt;p&gt;（13） 通过操作符对文档进行修改，通常可以获得更好的性能，因为，不需要往返服务器来获取并修改文档数据，可以在序列化和传输数据上花费更少的时间。&lt;/p&gt;

&lt;p&gt;（14） 批量插入（batchInsert）可以减少数据向服务器的提交次数，提高性能。但是批量提交的BSON Size不超过48MB。&lt;/p&gt;

&lt;p&gt;（15） 禁止一次取出太多的数据进行排序，MongoDB目前支持对32M以内的结果集进行排序。如果需要排序，请尽量限制结果集中的数据量。&lt;/p&gt;

&lt;p&gt;（16） 查询中的某些$操作符可能会导致性能低下，如$ne，$not，$exists，$nin，$or，尽量在业务中不要使用。&lt;/p&gt;
&lt;p&gt;a)   $exist:因为松散的文档结构导致查询必须遍历每一个文档；&lt;/p&gt;
&lt;p&gt;b)   $ne:如果当取反的值为大多数，则会扫描整个索引；&lt;/p&gt;
&lt;p&gt;c)   $not:可能会导致查询优化器不知道应当使用哪个索引，所以会经常退化为全表扫描；&lt;/p&gt;
&lt;p&gt;d)   $nin:全表扫描；&lt;/p&gt;
&lt;p&gt;e)   $or:有多个条件就会查询多少次，最后合并结果集，应该考虑装换为$in。&lt;/p&gt;

&lt;p&gt;（17） 固定集合可以用于记录日志，其插入数据更快，可以实现在插入数据时，淘汰最早的数据。需求分析和设计时，可考虑此特性，即提高了性能，有省去了删除动作。&lt;/p&gt;
&lt;p&gt;     解读：固定集合需要显式创建，指定Size的大小，还能够指定文档的数量。集合不管先达到哪一个限制，之后插入的新文档都会把最老的文档移出。&lt;/p&gt;

&lt;p&gt;（18） 集合中文档的数据量会影响查询性能，为保持适量，需要定期归档。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>MongoDB 是高性能数据，但是在使用的过程中，大家偶尔还会碰到一些性能问题。MongoDB和其它关系型数据库相比，例如 SQL Server 、MySQL 、Oracle 相比来说，相对较新，很多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9631761.html</dc:identifier>
</item>
<item>
<title>XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Khamovniki Problem J Stairways解题报告（分块+维护凸壳） - zbh2047</title>
<link>http://www.cnblogs.com/zbh2047/p/9631762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zbh2047/p/9631762.html</guid>
<description>&lt;p&gt;首先ORZ一发Claris聚聚的题解：&lt;a title=&quot;题解&quot; href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=5901&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/clrs97/p/8689215.html&lt;/a&gt;，不然我可能没机会补过这道神题了。&lt;/p&gt;
&lt;p&gt;这里写一个更详细的题解吧（我还是太菜了啊）。&lt;/p&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有\(n(n \le10^5)\)个人依次进入一个入口，要到一个出口。入口到出口有两条同样长的路。每个人都有一个速度，用通行时间\(a_i(1\le a_i \le 10^6)\)表示，他可以选择任一条路走。但是，若走这条路的前面的人比他慢的话，他只能降到和前面所有人最慢的那个人同样的速度（从而会多花时间）。现在请规划每个人选哪条路，使得每个人因等前面的人而浪费的时间尽可能少。&lt;/p&gt;
&lt;p&gt;Sample Input&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;100&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sample Output&lt;/p&gt;

&lt;h2&gt;详细题解&lt;/h2&gt;
&lt;p&gt;此题很容易用DP来做。考虑前\(i\)个人，则两个楼梯必有一个的通行时间变为前\(i\)个人最慢的那个，我们设\(dp[i][j]\)表示前i个人另一个楼梯当前通行时间是\(j\)（\(j\)从小到大离散化）时的最优答案，则考虑\(dp[i+1]\)和\(dp[i]\)的关系：&lt;/p&gt;
&lt;p&gt;（1）若\(a[i+1]&amp;gt;=max(a[1..i])\)，则显然\(dp[i+1][j]=dp[i][j]\)；&lt;/p&gt;
&lt;p&gt;（2）若\(a[i+1]&amp;lt;max(a[1..i])\)，则：&lt;/p&gt;
&lt;p&gt;情况1：\(j\)对应状态快的那个楼梯比\(a[i+1]\)时间短，且选这个楼梯，于是\(dp[i+1][k]=min(dp[i][j],j&amp;lt;=k)\)，其中\(k\)为\(a[i+1]\)离散化的结果；&lt;/p&gt;
&lt;p&gt;情况2：\(j\)对应状态快的那个楼梯比\(a[i+1]\)时间短，但选最慢的楼梯，于是\(dp[i+1][j]=dp[i][j]+max(a[1..i])-a[i+1]\)，其中\(j&amp;lt;k\)；&lt;/p&gt;
&lt;p&gt;情况3：\(j\)对应状态快的那个楼梯比\(a[i+1]\)的时间长，那必然选这个楼梯，于是\(dp[i+1][j]=dp[i][j]+f[j]-a[i+1]\)，其中\(j&amp;gt;k\)，\(f[j]\)表示第\(j\)小的值。&lt;/p&gt;
&lt;p&gt;这样状态数和转移复杂度均为\(n^2\)。下面考虑数据结构优化。&lt;/p&gt;
&lt;p&gt;我们需要维护的dp要支持区间最小值查询，单点修改，区间增加，和区间\(dp[i][j]+=f[j]\)。&lt;/p&gt;
&lt;p&gt;如果没有最后的操作此题直接用线段树就简单多了。&lt;/p&gt;
&lt;p&gt;加上了这种操作，考虑分块。每块首先要维护增量tag，该tag对最值无影响。下面主要考虑\(dp[i][j]+=f[j]\)。&lt;/p&gt;
&lt;p&gt;注意到一个性质：若\((dp[i][j+1]-dp[i][j])/(f[j+1]-f[j])&amp;lt;(dp[i][j]-dp[i][j-1])/(f[j]-f[j-1])\)，那么无论再怎么增加\(dp[i][j]\)也不可能最优。所以将\(j\)下标看做二维点\((f[j],dp[i][j])\)后，所有可能的最优值形成一个下凸壳。当整块\(dp[i][j]+=f[j]\)后，凸壳上仍是这些点，但最小值点可能将向左移动。于是我们只要不断删除凸壳右边的点，就可以每一块均摊\(O(1)\)的修改和查询最小值。&lt;/p&gt;
&lt;p&gt;对于单点修改，只需要重构凸壳，复杂度为块大小。&lt;/p&gt;
&lt;p&gt;现在考虑分块后从\(dp[i]\)转移到\(dp[i+1]\)的总复杂度，设块大小\(b\)。由于单点修改仅一个点\(k\)，故复杂度\(b\)；取最小值复杂度\(b+n/b\)；区间加复杂度\(b+n/b\)；区间\(dp[i][j]+=f[j]\)复杂度\(b+n/b\)。当\(b\)取\(\sqrt n\) 时复杂度最优，为\(\sqrt n \)。考虑到重构凸壳较慢，应在求最值时如需要再重构凸壳。&lt;/p&gt;
&lt;p&gt;总时间复杂度\(O(n \sqrt n)\)&lt;/p&gt;
&lt;h2&gt;AC代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include&amp;lt;cmath&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include&amp;lt;algorithm&amp;gt;
&lt;span&gt;  4&lt;/span&gt; #include&amp;lt;cstring&amp;gt;
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LL long long
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Block{
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     LL a[&lt;span&gt;400&lt;/span&gt;&lt;span&gt;], tag, delta;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; order[&lt;span&gt;400&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; pos[&lt;span&gt;400&lt;/span&gt;&lt;span&gt;], back, n;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; flag;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; init(&lt;span&gt;int&lt;/span&gt; b[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size){
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         n = size; flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         memcpy(order, b, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)*&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         memset(a, &lt;span&gt;0x3f&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(LL)*&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; check(&lt;span&gt;int&lt;/span&gt; j1, &lt;span&gt;int&lt;/span&gt; j, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j2){
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (a[j2] - a[j]) * (order[j] - order[j1]) &amp;lt;= (a[j] - a[j1]) * (order[j2] -&lt;span&gt; order[j]);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     LL &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i){ &lt;span&gt;return&lt;/span&gt; a[i] + tag * order[i] +&lt;span&gt; delta; }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(){
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             a[i] = &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(i);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         tag = delta = &lt;span&gt;0&lt;/span&gt;; back = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (back&amp;gt;&lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; check(pos[back - &lt;span&gt;1&lt;/span&gt;], pos[back], i))back--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             pos[++back] =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (back &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;get&lt;/span&gt;(pos[back - &lt;span&gt;1&lt;/span&gt;]) &amp;lt;= &lt;span&gt;get&lt;/span&gt;(pos[back]))back--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, LL val){
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         a[i] += val - &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(i);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; d){
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r == n - &lt;span&gt;1&lt;/span&gt;)delta +=&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = l; i &amp;lt;= r; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 a[i] +=&lt;span&gt; d;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; add2(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r == n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             tag++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (back &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;get&lt;/span&gt;(pos[back - &lt;span&gt;1&lt;/span&gt;]) &amp;lt;= &lt;span&gt;get&lt;/span&gt;(pos[back]))back--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = l; i &amp;lt;= r; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 a[i] +=&lt;span&gt; order[i];
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     LL queryMin(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r == n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)update();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(pos[back]);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         LL ret = 1LL &amp;lt;&amp;lt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = l; i &amp;lt;= r; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             ret = min(ret, &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(i));
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; }b[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;100002&lt;/span&gt;], order[&lt;span&gt;100002&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; belong[&lt;span&gt;100002&lt;/span&gt;], offset[&lt;span&gt;100002&lt;/span&gt;&lt;span&gt;], blockSize;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; delta){
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; start = l / blockSize, end = r /&lt;span&gt; blockSize;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= end; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         b[i].add(i == start ? offset[l] : &lt;span&gt;0&lt;/span&gt;, i == end ? offset[r] : b[i].n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, delta);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add2(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; start = l / blockSize, end = r /&lt;span&gt; blockSize;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= end; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         b[i].add2(i == start ? offset[l] : &lt;span&gt;0&lt;/span&gt;, i == end ? offset[r] : b[i].n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; LL queryMin(&lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; start = l / blockSize, end = r /&lt;span&gt; blockSize;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     LL ret = 1LL &amp;lt;&amp;lt; &lt;span&gt;60&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = start; i &amp;lt;= end; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         ret = min(ret, b[i].queryMin(i == start ? offset[l] : &lt;span&gt;0&lt;/span&gt;, i == end ? offset[r] : b[i].n - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;n);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;a[i]);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         order[i] =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     order[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     sort(order, order + n + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; cnt = unique(order, order + n + &lt;span&gt;1&lt;/span&gt;) -&lt;span&gt; order;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     blockSize =&lt;span&gt; sqrt(cnt);
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;, k = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cnt; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         belong[i] =&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         offset[i] = j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (j ==&lt;span&gt; blockSize){
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             b[k].init(order + i - j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, j);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             j = &lt;span&gt;0&lt;/span&gt;; k++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (j)b[k].init(order + cnt -&lt;span&gt; j, j);
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     b[&lt;span&gt;0&lt;/span&gt;].&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mpos = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pos = lower_bound(order, order + cnt, a[i]) -&lt;span&gt; order;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pos &amp;gt;= mpos)mpos =&lt;span&gt; pos;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;             LL val = queryMin(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, pos);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             b[belong[pos]].&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(offset[pos], val);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;             add(&lt;span&gt;0&lt;/span&gt;, pos - &lt;span&gt;1&lt;/span&gt;, order[mpos] -&lt;span&gt; order[pos]);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             add(pos + &lt;span&gt;1&lt;/span&gt;, mpos, -&lt;span&gt;order[pos]);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             add2(pos + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, mpos);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, queryMin(&lt;span&gt;0&lt;/span&gt;, cnt - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 11 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>zbh2047</dc:creator>
<og:description>首先ORZ一发Claris聚聚的题解：http://www.cnblogs.com/clrs97/p/8689215.html，不然我可能没机会补过这道神题了。 这里写一个更详细的题解吧（我还是太菜了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zbh2047/p/9631762.html</dc:identifier>
</item>
<item>
<title>一起学Hadoop——二次排序算法的实现 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9631718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9631718.html</guid>
<description>&lt;p&gt;二次排序，从字面上可以理解为在对key排序的基础上对key所对应的值value排序，也叫辅助排序。一般情况下，MapReduce框架只对key排序，而不对key所对应的值排序，因此value的排序经常是不固定的。但是我们经常会遇到同时对key和value排序的需求，例如Hadoop权威指南中的求一年的高高气温，key为年份，value为最高气温，年份按照降序排列，气温按照降序排列。还有水果电商网站经常会有按天统计水果销售排行榜的需求等等，这些都是需要对key和value同时进行排序。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/110616/201809/110616-20180911232638522-1518240573.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何设计一个MapReduce程序解决对key和value同时排序的需求呢？这就需要用到组合键、分区、分组的概念。在这里又看到分区的影子，可知分区在MapReduce是多么的重要，一定要好好掌握，是优化的重点。&lt;/p&gt;
&lt;p&gt;按照上图中数据流转的方向，我们首先设计一个Fruit类，有三个字段，分别是日期、水果名和销量，将日期、水果名和销量作为一个复合键；接着设计一个自定义Partition类，根据Fruit的日期字段分区，让相同日期的数据流向同一个partition分区中；最后定义一个分组类，实现同一个分区内的数据分组，然后按照销量字段进行二次排序。&lt;/p&gt;
&lt;p&gt;具体实现思路：&lt;br/&gt;1、定义Fruit类，实现WritableComparable接口，并且重写compareTo、equal和hashcode方法以及序列化和反序列化方法readFields和write方法。Java类要在网络上传输必须序列化和反序列化。在Map端的map函数中将Fruit对象当做key。compareTo方法用于比较两个key的大小，在本文中就是比较两个Fruit对象的排列顺序。&lt;/p&gt;
&lt;p&gt;2、自定义第一次排序类，继承WritableComparable或者WritableComparator接口，重写compareTo或者compare方法，。就是在Map端对Fruit对象的第一个字段进行排序&lt;/p&gt;
&lt;p&gt;3、自定义Partition类，实现Partitioner接口，并且重写getPartition方法，将日期相同的Fruit对象分发到同一个partition中。&lt;/p&gt;
&lt;p&gt;4、定义分组类，继承WritableComparator接口，并且重写compare方法。用于比较同一分组内两个Fruit对象的排列顺序，根据销量字段比较。日期相同的Fruit对象会划分到同一个分组。通过setGroupingComparatorClass方法设置分组类。如果不设置分组类，则按照key默认的compare方法来对key进行排序。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.conf.Configured;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.io.WritableComparable;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.DataInput;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.DataOutput;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.apache.hadoop.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Partitioner;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Mapper;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Reducer;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.conf.Configuration;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.fs.FileSystem;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.fs.Path;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.Job;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.util.Tool;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.hadoop.util.ToolRunner;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SecondrySort &lt;span&gt;extends&lt;/span&gt; Configured &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Tool {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Fruit &lt;span&gt;implements&lt;/span&gt; WritableComparable&amp;lt;Fruit&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(Fruit.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String date;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer sales;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Fruit(){
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Fruit(String date,String name,Integer sales){
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.date =&lt;span&gt; date;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.sales =&lt;span&gt; sales;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDate(){
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.date;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName(){
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getSales(){
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sales;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readFields(DataInput in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.date =&lt;span&gt; in.readUTF();
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; in.readUTF();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.sales =&lt;span&gt; in.readInt();
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(DataOutput out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             out.writeUTF(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.date);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             out.writeUTF(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            out.writeInt(sales);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Fruit other) {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; result1 = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.date.compareTo(other.getDate());
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(result1 == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; result2 = &lt;span&gt;this&lt;/span&gt;.sales -&lt;span&gt; other.getSales();
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (result2 == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                     &lt;span&gt;double&lt;/span&gt; result3 = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.compareTo(other.getName());
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(result3 &amp;gt; 0) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(result3 &amp;lt; 0) &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(result2 &amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(result2 &amp;lt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(result1 &amp;gt; 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode(){
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.date.hashCode() * 157 + &lt;span&gt;this&lt;/span&gt;.sales + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name.hashCode();
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object object){
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (object == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; object)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (object &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Fruit){
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 Fruit r =&lt;span&gt; (Fruit) object;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                if(r.getDate().toString().equals(this.getDate().toString())){&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; r.getDate().equals(&lt;span&gt;this&lt;/span&gt;.getDate()) &amp;amp;&amp;amp; r.getName().equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getName())
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                         &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.getSales() ==&lt;span&gt; r.getSales();
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.date + &quot; &quot; + &lt;span&gt;this&lt;/span&gt;.name + &quot; &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.sales;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FruitPartition &lt;span&gt;extends&lt;/span&gt; Partitioner&amp;lt;Fruit, NullWritable&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getPartition(Fruit key, NullWritable value,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; numPartitions){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Math.abs(Integer.parseInt(key.getDate()) * 127) %&lt;span&gt; numPartitions;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GroupingComparator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; WritableComparator{
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; GroupingComparator(){
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;super&lt;/span&gt;(Fruit.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(WritableComparable w1, WritableComparable w2){
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             Fruit f1 =&lt;span&gt; (Fruit) w1;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             Fruit f2 =&lt;span&gt; (Fruit) w2;
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;f1.getDate().equals(f2.getDate())){
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; f1.getDate().compareTo(f2.getDate());
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; f1.getSales().compareTo(f2.getSales());
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Map &lt;span&gt;extends&lt;/span&gt; Mapper&amp;lt;LongWritable, Text, Fruit, NullWritable&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; map(LongWritable key, Text value, Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             String line =&lt;span&gt; value.toString();
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             String str[] = line.split(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             Fruit fruit = &lt;span&gt;new&lt;/span&gt; Fruit(str[0],str[1],&lt;span&gt;new&lt;/span&gt; Integer(str[2&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fruit fruit = new Fruit();
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fruit.set(str[0],str[1],new Integer(str[2]));&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;            context.write(fruit, NullWritable.get());
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Reduce &lt;span&gt;extends&lt;/span&gt; Reducer&amp;lt;Fruit, NullWritable, Text, NullWritable&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reduce(Fruit key, Iterable&amp;lt;NullWritable&amp;gt; values, Context context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, InterruptedException {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;             String str = key.getDate() + &quot; &quot; + key.getName() + &quot; &quot; +&lt;span&gt; key.getSales();
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             context.write(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Text(str), NullWritable.get());
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; run(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         Configuration conf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration();
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断路径是否存在，如果存在，则删除&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt;         Path mypath = &lt;span&gt;new&lt;/span&gt; Path(args[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         FileSystem hdfs =&lt;span&gt; mypath.getFileSystem(conf);
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hdfs.isDirectory(mypath)) {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;             hdfs.delete(mypath, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; 
&lt;span&gt;169&lt;/span&gt;         Job job = Job.getInstance(conf, &quot;Secondry Sort app&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置主类&lt;/span&gt;
&lt;span&gt;171&lt;/span&gt;         job.setJarByClass(SecondrySort.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入路径&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         FileInputFormat.setInputPaths(job, &lt;span&gt;new&lt;/span&gt; Path(args[0&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出路径&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt;         FileOutputFormat.setOutputPath(job, &lt;span&gt;new&lt;/span&gt; Path(args[1&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mapper&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         job.setMapperClass(Map.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reducer&lt;/span&gt;
&lt;span&gt;181&lt;/span&gt;         job.setReducerClass(Reduce.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分区函数&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;         job.setPartitionerClass(FruitPartition.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; 
&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分组函数&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;         job.setGroupingComparatorClass(GroupingComparator.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; map输出key类型&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt;         job.setMapOutputKeyClass(Fruit.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; map输出value类型&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;         job.setMapOutputValueClass(NullWritable.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reduce输出key类型&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt;         job.setOutputKeyClass(Text.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reduce输出value类型&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;         job.setOutputValueClass(NullWritable.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入格式&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt;         job.setInputFormatClass(TextInputFormat.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出格式&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt;         job.setOutputFormatClass(TextOutputFormat.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; 
&lt;span&gt;204&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; job.waitForCompletion(&lt;span&gt;true&lt;/span&gt;) ? 0 : 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; 
&lt;span&gt;207&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; exitCode = ToolRunner.run(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecondrySort(), args);
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;        System.exit(exitCode);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试数据：&lt;/p&gt;
&lt;p&gt;20180906 Apple 200&lt;br/&gt;20180904 Apple 200&lt;br/&gt;20180905 Banana 100&lt;br/&gt;20180906 Orange 300&lt;br/&gt;20180906 Banana 400&lt;br/&gt;20180904 Orange 100&lt;br/&gt;20180905 Apple 400&lt;br/&gt;20180904 Banana 300&lt;br/&gt;20180905 Orange 500&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;20180906 Banana 400&lt;br/&gt;20180906 Orange 300&lt;br/&gt;20180906 Apple 200&lt;br/&gt;20180905 Orange 500&lt;br/&gt;20180905 Apple 400&lt;br/&gt;20180905 Banana 100&lt;br/&gt;20180904 Banana 300&lt;br/&gt;20180904 Apple 200&lt;br/&gt;20180904 Orange 100&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1、在使用实现WritableComparable接口的方式实现自定义比较器时，必须有一个无参的构造函数。否则会报Unable to initialize any output collector的错误。&lt;br/&gt;2、readFields和write方法中处理字段的顺序必须一致，否则会报MapReduce Error: java.io.EOFException at java.io.DataInputStream.readFully(DataInputStream.java:197)的错误。&lt;/p&gt;

&lt;p&gt;了解更多大数据的知识请关注我的微信公众号：&lt;span&gt;&lt;strong&gt;summer_bigdata&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎可以扫码关注本人的公众号：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/110616/201809/110616-20180911233316088-67997682.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 11 Sep 2018 15:34:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>二次排序，从字面上可以理解为在对key排序的基础上对key所对应的值value排序，也叫辅助排序。一般情况下，MapReduce框架只对key排序，而不对key所对应的值排序，因此value的排序经常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9631718.html</dc:identifier>
</item>
<item>
<title>js闭包 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9631686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9631686.html</guid>
<description>&lt;p&gt;&lt;span&gt;先展示两段代码块看看到底有什么区别&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(x) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (y) {
        alert(x &lt;/span&gt;+ y + (++&lt;span&gt;tmp));
    }
}
foo(&lt;/span&gt;2)(10);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(x) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(y) {
        alert(x &lt;/span&gt;+ y + (++&lt;span&gt;tmp));
    }
    bar(&lt;/span&gt;10&lt;span&gt;);
}
foo(&lt;/span&gt;2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这两段代码都是alert(16)，区别到底在哪。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码块①出现了闭包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准确来说&lt;img src=&quot;https://images2018.cnblogs.com/blog/1158451/201809/1158451-20180911230848946-1029121316.png&quot; alt=&quot;&quot;/&gt; 这块就是一个闭包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包是基于正常的垃圾回收处理机制下的。也就是说，一般情况一个函数（函数作用域）执行完毕，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面声明的变量会全部释放，被垃圾回收器回收。但闭包利用一个技巧，&lt;strong&gt;让作用域里面的变量，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在函数执行完之后依旧保存没有被垃圾回收处理掉。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者说一下我现在的一个需求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我需要在for循环里面进行事件的绑定，这个应该怎么操作？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一反应是这样（原生js）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
window.onload&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; list){
        document.getElementById(list[i]).onclick&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            alert(list[i]);
        }
    }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;a&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aaa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;bbb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以尝试一下，绝对都是alert(b)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因就是执行完之后变量i被回收了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以换另一中方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
window.onload&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; i &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; list){
        (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(j){
            document.getElementById(list[j]).onclick&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                alert(list[j]);
            }
        })(i)
    }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;a&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aaa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;bbb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用闭包来解决。nice！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的low逼见解，前端了解就是。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 15:26:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<og:description>先展示两段代码块看看到底有什么区别 这两段代码都是alert(16)，区别到底在哪。 代码块①出现了闭包。 准确来说 这块就是一个闭包。 闭包是基于正常的垃圾回收处理机制下的。也就是说，一般</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9631686.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之六 ----- 组合模式和过滤器模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9630850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9630850.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9545272.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了结构型模式的外观模式和装饰器模式。本篇则来学习下组合模式和过滤器模式。&lt;/p&gt;
&lt;h2 id=&quot;组合模式&quot;&gt;组合模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;组合模式是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说的话，就是根据树形结构把相似的对象进行组合，然后表示该部分是用来做啥的。在&amp;lt;大话设计模式&amp;gt;中有个很形象的例子，就是电脑中的 &lt;strong&gt;文件系统&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。按照这种方式，计算机的文件系统就是以递归结构来组织的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，这里我们也可以使用一个简单的示例来对组合模式进行讲解。&lt;/p&gt;
&lt;p&gt;在学校中，有很多学生，但是这些学生中又有不同的身份，有的学生是学生会主席，有的是学生会委员，有的是班长，有的是体育委员等等， 当然大部分都是普通的学生，并没有担当其它的职位。这时我们就可以使用组合模式来进行组合。&lt;/p&gt;
&lt;p&gt;按照管理层来看，学生职位中最大的是学生会主席，学生会主席下有学生会委员，然后学生会委员又管理着普通的学生，他们之间相互独立，可以成为一个部分，也可以最终成为一个整体。可以说非常符合组合模式中的&lt;code&gt;树形结构以表示‘部分-整体’的层次结构&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;废话不在多说了，下面进行代码的开发。&lt;br/&gt;首先定义一个学生类，有学生姓名和职位属性。&lt;br/&gt;然后在学生类中在添加 add()、remove()、get()方法，最后进行层级调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Student{
    private String name;
    
    private String position;
    
    private List&amp;lt;Student&amp;gt; students;

    public Student(String name, String position) {
        this.name = name;
        this.position = position;
        students=new ArrayList&amp;lt;Student&amp;gt;();
    }
    
    
    public void add(Student student){
        students.add(student);
    }
    
    public void remove(Student student){
        students.remove(student);
    }
    
    public List&amp;lt;Student&amp;gt; get(){
        return students;
    }
    
    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, position=&quot; + position + &quot;]&quot;;
    }   
}


public class CompositeTest {

    public static void main(String[] args) {

        Student studentLeader=new Student(&quot;小明&quot;,&quot;学生会主席&quot;);

        Student committeeMember=new Student(&quot;小刚&quot;,&quot;学生会委员&quot;);
        
        Student student=new Student(&quot;小红&quot;,&quot;学生&quot;);
        
        committeeMember.add(student);
        studentLeader.add(committeeMember);
        
        System.out.println(&quot;-&quot;+studentLeader);
        studentLeader.get().forEach(sl-&amp;gt;{
            System.out.println(&quot;--&quot;+sl);
            sl.get().forEach(cm-&amp;gt;{
                System.out.println(&quot;---&quot;+cm);
            });
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    -Student [name=小明, position=学生会主席]
    --Student [name=小刚, position=学生会委员]
    ---Student [name=小红, position=学生]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上述示例中，我们添加了三个学生(更多也一样，主要是思路)，在学校中分别扮演 学生会主席、学生会委员以及学生。其中学生会主席管理着学生会委员，学生会委员管理着学生，他们之间属于层级关系，一层层的包含。在这之中，我们也发现一点，其实组合模式就是把某个对象去包含另一个对象，然后通过组合的方式来进行一些布局。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组合模式的优点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;高层模块调用较为简单，增加某个节点方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;组合模式的缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因为其子节点的声明都是实现类，而不是接口，违反了依赖倒置原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景:&lt;/strong&gt;&lt;br/&gt;可以表示为 ‘&lt;strong&gt;部分-整体&lt;/strong&gt;’的层级结构。&lt;/p&gt;
&lt;h2 id=&quot;过滤器模式&quot;&gt;过滤器模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;过滤器模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的来说该模式的功能就是如其名，做一个过滤的作用。我们在一般在进行后台接口开发的时候，也会根据过滤掉一些请求。其实过滤器模式主要实现也是这种功能，废话不多说，开始用代码进行相应的说明。&lt;/p&gt;
&lt;p&gt;这里依旧用学生来进行讲解，学校的学生中有男生和女生，学校又有不同的年级，这时我们相统计下学生的相关信息，就可以使用过滤器模式来进行分组了。比如，统计该学校有多少男生，一年级的女生有多少，三年级的学生或者女生有多少之类等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例:&lt;/strong&gt;&lt;br/&gt;由于代码有点多，这里就分开进行讲解。&lt;br/&gt;首先定义一个实体类，有姓名、性别、年级这三个属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Student{
    private String name; 
    private String gender; 
    private Integer grade;
    public Student(String name, String gender, Integer grade) {
        super();
        this.name = name;
        this.gender = gender;
        this.grade = grade;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getGender() {
        return gender;
    }
    
    public void setGender(String gender) {
        this.gender = gender;
    }
    
    public Integer getGrade() {
        return grade;
    }
    
    public void setGrade(Integer grade) {
        this.grade = grade;
    }

    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, gender=&quot; + gender + &quot;, grade=&quot; + grade + &quot;]&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再定义一个公用的接口，指定实现的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface FilterinGrule {
    List&amp;lt;Student&amp;gt;  filter(List&amp;lt;Student&amp;gt; students);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再实现该接口，制定不同的过滤规则。这里主要是三种规则，普通的过滤，且过滤，或过滤。&lt;br/&gt;具体实现的方法如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MaleStudents implements FilterinGrule{
    @Override
    public List&amp;lt;Student&amp;gt; filter(List&amp;lt;Student&amp;gt; students) {
        List&amp;lt;Student&amp;gt; maleStudents = new ArrayList&amp;lt;Student&amp;gt;(); 
        students.forEach(student-&amp;gt;{
             if(student.getGender().equalsIgnoreCase(&quot;male&quot;)){
                 maleStudents.add(student);
             }
        });
        return maleStudents;
    }
}

class FemaleStudents implements FilterinGrule{
    @Override
    public List&amp;lt;Student&amp;gt; filter(List&amp;lt;Student&amp;gt; students) {
        List&amp;lt;Student&amp;gt; femaleStudents = new ArrayList&amp;lt;Student&amp;gt;(); 
        students.forEach(student-&amp;gt;{
             if(student.getGender().equalsIgnoreCase(&quot;female&quot;)){
                 femaleStudents.add(student);
             }
        });
        return femaleStudents;
    }
}

class SecondGrade implements FilterinGrule{
    @Override
    public List&amp;lt;Student&amp;gt; filter(List&amp;lt;Student&amp;gt; students) {
        List&amp;lt;Student&amp;gt; secondGradeStudents = new ArrayList&amp;lt;Student&amp;gt;(); 
        students.forEach(student-&amp;gt;{
             if(student.getGrade() == 2){
                 secondGradeStudents.add(student);
             }
        });
        
        return secondGradeStudents;
    }
}


class And implements FilterinGrule{
     private FilterinGrule filter;
     private FilterinGrule filter2;
    
     public And(FilterinGrule filter,FilterinGrule filter2) {
         this.filter=filter;
         this.filter2=filter2;
     }
    
    @Override
    public List&amp;lt;Student&amp;gt; filter(List&amp;lt;Student&amp;gt; students) {
        List&amp;lt;Student&amp;gt; students2=filter.filter(students);
        return filter2.filter(students2);
    }
}

class Or implements FilterinGrule{
     private FilterinGrule filter;
     private FilterinGrule filter2;
    
     public Or(FilterinGrule filter,FilterinGrule filter2) {
         this.filter=filter;
         this.filter2=filter2;
     }
    
    @Override
    public List&amp;lt;Student&amp;gt; filter(List&amp;lt;Student&amp;gt; students) {
        List&amp;lt;Student&amp;gt; students1=filter.filter(students);
        List&amp;lt;Student&amp;gt; students2=filter2.filter(students);
        students2.forEach(student-&amp;gt;{
             if(!students1.contains(student)){
                 students1.add(student);
             }
        });
        return students1;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来进行调用测试，添加一些学生，并且指定性别以及班级。然后根据不同的条件来进行过滤。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FilterTest {

    public static void main(String[] args) {
        List&amp;lt;Student&amp;gt; list=new ArrayList&amp;lt;Student&amp;gt;();
        list.add(new Student(&quot;小明&quot;, &quot;male&quot;, 1));
        list.add(new Student(&quot;小红&quot;, &quot;female&quot;, 2));
        list.add(new Student(&quot;小刚&quot;, &quot;male&quot;, 2));
        list.add(new Student(&quot;小霞&quot;, &quot;female&quot;, 3));
        list.add(new Student(&quot;小智&quot;, &quot;male&quot;, 3));
        list.add(new Student(&quot;虚无境&quot;, &quot;male&quot;, 1));
        
        
        FilterinGrule male = new MaleStudents();
        FilterinGrule female = new FemaleStudents();
        FilterinGrule secondGrade = new SecondGrade();
        FilterinGrule secondGradeMale = new And(secondGrade, male);
        FilterinGrule secondGradeOrFemale = new Or(secondGrade, female);
        
        System.out.println(&quot;男生:&quot;+male.filter(list));
        System.out.println(&quot;女生:&quot;+female.filter(list));
        System.out.println(&quot;二年级学生:&quot;+secondGrade.filter(list));
        System.out.println(&quot;二年级男生:&quot;+secondGradeMale.filter(list));
        System.out.println(&quot;二年级的学生或女生:&quot;+secondGradeOrFemale.filter(list));      
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;男生:[Student [name=小明, gender=male, grade=1], Student [name=小刚, gender=male, grade=2], Student [name=小智, gender=male, grade=3], Student [name=虚无境, gender=male, grade=1]]
女生:[Student [name=小红, gender=female, grade=2], Student [name=小霞, gender=female, grade=3]]
二年级学生:[Student [name=小红, gender=female, grade=2], Student [name=小刚, gender=male, grade=2]]
二年级男生:[Student [name=小刚, gender=male, grade=2]]
二年级的学生或女生:[Student [name=小红, gender=female, grade=2], Student [name=小刚, gender=male, grade=2], Student [name=小霞, gender=female, grade=3]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述示例，我们发现过滤器模式其实很简单，制定过滤规则，然后再根据制定的标准来进行过滤，得到符合条件的数据。过滤器模式虽然简单，但是在构建过滤规则的时候，有点繁琐，不过在jdk1.8之后，我们可以使用&lt;strong&gt;stream&lt;/strong&gt;流更方便的进行规则的制定（这一点留在以后再讲）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过滤器模式的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;简单，解耦，使用方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;过滤器模式的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;好像没有。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要进行筛选的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;其实边听音乐便看博客很享受的~_~&lt;/p&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 14:36:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9630850.html</dc:identifier>
</item>
<item>
<title>Mysql读写分离——主从数据库+Atlas - NinWoo</title>
<link>http://www.cnblogs.com/NinWoo/p/9630803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NinWoo/p/9630803.html</guid>
<description>&lt;p&gt;最近在参加项目开发微信小程序后台，由于用户数量巨大，且后台程序并不是很完美，所以对用户的体验很是不友好（简单说就是很卡）。赶巧最近正在翻阅《大型网站系统与Java中间件实践》。&lt;br/&gt;所以，先是使用Docker swarm构建了负载均衡集群，然后使用Atlas做了数据库的读写分离，尽可能对用户进行分流，降低对单机服务器的负载，提高访问体验。本片随笔仅对数据库的读写分离部分进行介绍。&lt;/p&gt;
&lt;p&gt;目标：实现mysql数据库集群，一个主节点负责写入数据，多个从节点负责读取数据&lt;/p&gt;
&lt;h2 id=&quot;实验环境&quot;&gt;实验环境&lt;/h2&gt;
&lt;p&gt;服务器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阿里云服务器：centos7（10.0.0.1）&lt;/li&gt;
&lt;li&gt;腾讯云服务器：ubuntu:16.04（10.0.0.2)&lt;/li&gt;
&lt;li&gt;京东云服务器：ubuntu:16.04 (10.0.0.3)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;mysql:5.7&lt;/p&gt;
&lt;p&gt;docker:18.03&lt;/p&gt;
&lt;h2 id=&quot;实现方案&quot;&gt;实现方案&lt;/h2&gt;
&lt;p&gt;mysql 主从数据库 + Atlas读写分离&lt;/p&gt;
&lt;h2 id=&quot;步骤&quot;&gt;步骤：&lt;/h2&gt;
&lt;h3 id=&quot;进入master服务器进行配置&quot;&gt;进入Master服务器进行配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用Docker，在服务器上创建MySQL服务&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker run -p 3306:3306 --name mysql3306 -v /opt/mysql/data/data3306:/var/lib/mysql  -v /opt/mysql/logs/logs3306:/logs -e MYSQL_ROOT_PASSWORD=hello -d mysql:5.7&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;进Master服务器的MySQL数据库中，创建用户&quot;niwoo&quot;设置密码为&quot;hello&quot;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql -h 127.0.0.1 -uroot -phello

mysql&amp;gt; grant all on *.* to ninwoo@'127.0.0.1' identified by &quot;hello&quot;;
Query OK, 0 rows affected, 1 warning (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改niwoo的访问权限&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; use mysql
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql&amp;gt; update user set host = '%' where user = 'ninwoo';
Query OK, 0 rows affected (0.00 sec)
Rows matched: 0  Changed: 0  Warnings: 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;确认是否修改成功&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; update user set host = '%' where user = 'ninwoo';
Query OK, 1 row affected (0.02 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&amp;gt; select user, host from user;
+---------------+-----------+
| user          | host      |
+---------------+-----------+
| ninwoo        | %         |
| root          | %         |
| mysql.session | localhost |
| mysql.sys     | localhost |
| root          | localhost |
+---------------+-----------+
5 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;更新数据库,是配置生效&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; flush privileges;
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Master，Slave1的MySQL数据库上创建CampusHire数据库&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入Slave1执行相同1,2,3,4操作&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;配置主从数据库连接&quot;&gt;配置主从数据库连接&lt;/h3&gt;
&lt;p&gt;进入Master服务器进行配置&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入mysql容器内部，修改配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker exec -it mysql3306 bash&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;默认没有vim，无法修改文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# 更新软件源
apt update
# 安装vim
apt install vim&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改mysql配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;vim /etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加如下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#主从复制配置  
innodb_flush_log_at_trx_commit=1  
sync_binlog=1  
#需要备份的数据库  
binlog-do-db=test
#不需要备份的数据库  
binlog-ignore-db=mysql  
  
#启动二进制文件  
log-bin=mysql-bin  
  
#服务器ID  
server-id=1 &lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;退出容器，重启docker应用&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker restart mysql3306&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;进入数据库，配置主从复制的权限&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql -h 127.0.0.1 -uroot -phello
mysql&amp;gt; grant replication slave on *.* to 'ninwoo'@'127.0.0.1' identified by 'hello';
Query OK, 0 rows affected, 1 warning (0.01 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;锁定数据库&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; flush tables with read lock;
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;查看主数据库信息，记住下面的“File”与“Position”的信息&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show master status;
+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      439 | CampusHire   | mysql            |                   |
+------------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;进入slave服务器，进入mysql容器内部&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# 更新软件源
apt update
# 安装vim
apt install vim&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;修改从数据库的配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;vim /etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加&lt;code&gt;server-id=2&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重启Slave数据库&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;docker restart mysql3306&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;进入数据库，输入刚刚记录下来的File和Position&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;MySQL [(none)]&amp;gt; change master to master_host='10.0.0.1',
    -&amp;gt;
    -&amp;gt; master_user='ninwoo',
    -&amp;gt; master_password='hello',
    -&amp;gt; master_port=3306,
    -&amp;gt; master_log_file='mysql-bin.000001',
    -&amp;gt; master_log_pos=439,
    -&amp;gt; master_connect_retry=10;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动Slave进程&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; start slave;
Query OK, 0 rows affected (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;查看复制状态&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show slave status \G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 139.199.194.49
                  Master_User: ninwoo
                  Master_Port: 3306
                Connect_Retry: 10
              Master_Log_File: mysql-bin.000001
          Read_Master_Log_Pos: 439
               Relay_Log_File: 2a8a4abdcf68-relay-bin.000002
                Relay_Log_Pos: 320
        Relay_Master_Log_File: mysql-bin.000001
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 439
              Relay_Log_Space: 534
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
                  Master_UUID: 4a0187fa-b0a5-11e8-a7e7-0242ac110003
             Master_Info_File: /var/lib/mysql/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for more up                                                                                                                                                                                               dates
           Master_Retry_Count: 86400
                  Master_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Master_SSL_Crl:
           Master_SSL_Crlpath:
           Retrieved_Gtid_Set:
            Executed_Gtid_Set:
                Auto_Position: 0
         Replicate_Rewrite_DB:
                 Channel_Name:
           Master_TLS_Version:
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里主从数据的配置就已经完成，在向主库写入数据的同时，将在从库进行自动的备份。但在实际测试中遇到了配置完成之后无法向主数据库写入的问题，初步&lt;br/&gt;判断是由于主库加锁而未解锁的问题，所以这里采用比较暴力的方法，重启主数据库容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# master节点
docker restart mysql3306&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置atlas&quot;&gt;配置Atlas&lt;/h2&gt;
&lt;p&gt;Atlas是有360团队优化mysqlproxy而衍生出的版本，性能更好更稳定。&lt;/p&gt;
&lt;p&gt;Atlas有两个版本，这里我选择普通版本，即不分表。&lt;/p&gt;
&lt;p&gt;在阿里云主机（centos7)上进行一下安装步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下载安装&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# cd /home/
[root@localhost home]# wget https://github.com/Qihoo360/Atlas/releases/download/2.2.1/Atlas-2.2.1.el6.x86_64.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost home]# rpm -ivh Atlas-2.2.1.el6.x86_64.rpm &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装目录位于&lt;code&gt;/usr/local/mysql-proxy/&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用安装目录下的&lt;code&gt;bin/encrypt&lt;/code&gt;程序加密数据库密码&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost bin]# ./encrypt hello&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置Atlas&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost conf]# cd /usr/local/mysql-proxy/conf/
[root@localhost conf]# vim test.cnf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改以下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
#管理接口的用户名
admin-username = user

#管理接口的密码
admin-password = pwd

...

#Atlas后端连接的MySQL主库的IP和端口，可设置多项，用逗号分隔
proxy-backend-addresses = 10.0.0.1:3306

#Atlas后端连接的MySQL从库的IP和端口，@后面的数字代表权重，用来作负载均衡，若省略则默认为1，可设置多项，用逗号分隔
proxy-read-only-backend-addresses = 10.0.0.2:3306@1

...

#用户名与其对应的加密过的MySQL密码，密码使用PREFIX/bin目录下的加密程序encrypt加密，下行的user1和user2为示例，将其替换为你的MySQL的用户名和加密密码！
pwds = buck:RePBqJ+5gI4=

...

#Atlas监听的工作接口IP和端口
proxy-address = 0.0.0.0:1234

#Atlas监听的管理接口IP和端口
admin-address = 0.0.0.0:2345&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读者需要根据自己的实际情况修改以上配置&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动Atlas&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost bin]# /etc/init.d/mysqld status
OK: MySQL-Proxy of test is started&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用mysql命令连接数据库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中2345端口是管理端口，用户可以在该管理数据库中修改数据库代理服务器的相关配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost bin]# mysql -h127.0.0.1 -P2345 -uuser -ppwd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中1234端口是数据库代理服务器的端口，用户可以直接访问该端口进行数据库的访问和更新&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost bin]# mysql -h127.0.0.1 -P1234 -ubuck -phello&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用软件连接Atlas数据库代理服务器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里发现，之前使用的mysql workbench无法正常使用，更换Navicat可以正常使用。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用jdbc连接数据库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用方法与普通数据库一样。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;到这里，配置就已经全部完成。有心的读者或者已经发现，还有一台服务器未使用，这台服务器将在以后接入到现有的mysql数据库集群当中，充当新的slave节点。该实验将在以后补上。&lt;/p&gt;
&lt;p&gt;理论上说，我所做的这些或许会对负载过大的问题有所解决。但最近并未出现太高的访问现象，所以短期也没有看到效果。具体效果，将在实际场景中验证后补充上，敬请期待。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Sep 2018 14:25:00 +0000</pubDate>
<dc:creator>NinWoo</dc:creator>
<og:description>mysql集群 最近在参加项目开发微信小程序后台，由于用户数量巨大，且后台程序并不是很完美，所以对用户的体验很是不友好（简单说就是很卡）。赶巧最近正在翻阅《大型网站系统与Java中间件实践》。 所以，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NinWoo/p/9630803.html</dc:identifier>
</item>
<item>
<title>Laya资源加载小记 - chiguozi</title>
<link>http://www.cnblogs.com/chiguozi/p/9630543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiguozi/p/9630543.html</guid>
<description>&lt;ul&gt;&lt;li&gt;Laya.Loader负责资源的加载逻辑，被LoaderManager管理。&lt;/li&gt;
&lt;li&gt;Laya支持多种类型资源加载，也支持自定义类型加载。不同类型的加载方式可能不同。&lt;/li&gt;
&lt;li&gt;Laya.Loader缓存已经被加载过得资源，减少资源重复加载。&lt;/li&gt;
&lt;li&gt;提供清理资源接口，由LoaderManager封装接口。&lt;/li&gt;
&lt;li&gt;部分资源加载包含多步加载，如Atlas和Font都包含文本下载和图片下载。&lt;/li&gt;
&lt;li&gt;注意：Laya.loader是LoaderManager的实例，是Laya对外的通用加载接口。Laya.Loader由LoaderManager统一管理，一般情况下，开发是不需要自己创建Loader实例。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;内置类型&quot;&gt;内置类型&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Laya内部支持的文件类型有：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        /** 文本类型，加载完成后返回文本。*/
        public static const TEXT:String = &quot;text&quot;;
        /** JSON 类型，加载完成后返回json数据。*/
        public static const JSON:String = &quot;json&quot;;
        /** XML 类型，加载完成后返回domXML。*/
        public static const XML:String = &quot;xml&quot;;
        /** 二进制类型，加载完成后返回arraybuffer二进制数据。*/
        public static const BUFFER:String = &quot;arraybuffer&quot;;
        /** 纹理类型，加载完成后返回Texture。*/
        public static const IMAGE:String = &quot;image&quot;;
        /** 声音类型，加载完成后返回sound。*/
        public static const SOUND:String = &quot;sound&quot;;
        /** 图集类型，加载完成后返回图集json信息(并创建图集内小图Texture)。*/
        public static const ATLAS:String = &quot;atlas&quot;;
        /** 位图字体类型，加载完成后返回BitmapFont。*/
        public static const FONT:String = &quot;font&quot;;
        /** TTF字体类型，加载完成后返回null。*/
        public static const TTF:String = &quot;ttf&quot;;
        /**@private */
        public static const PKM:String = &quot;pkm&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Laya3D扩展类型：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        /**@private 层级文件资源标记。*/
        private static const HIERARCHY:String = &quot;SPRITE3DHIERARCHY&quot;;
        /**@private 网格的原始资源标记。*/
        private static const MESH:String = &quot;MESH&quot;;
        /**@private 材质的原始资源标记。*/
        private static const MATERIAL:String = &quot;MATERIAL&quot;;
        /**@private PBR材质资源标记。*/
        private static const PBRMATERIAL:String = &quot;PBRMTL&quot;;
        /**@private TextureCube原始资源标记。*/
        private static const TEXTURECUBE:String = &quot;TEXTURECUBE&quot;;
        /**@private Terrain原始资源标记。*/
        private static const TERRAIN:String = &quot;TERRAIN&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;这几种类型通过扩展的方式，在Laya3D初始化时，注册了对应的加载函数。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Laya文件后缀与文件类型的映射：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    //Laya内置类型
    {&quot;png&quot;: &quot;image&quot;,&quot;jpg&quot;: &quot;image&quot;,&quot;jpeg&quot;: &quot;image&quot;,
    &quot;txt&quot;: &quot;text&quot;,
    &quot;json&quot;: &quot;json&quot;,
    &quot;xml&quot;: &quot;xml&quot;,
    &quot;als&quot;: &quot;atlas&quot;,&quot;atlas&quot;: &quot;atlas&quot;,
    &quot;mp3&quot;: &quot;sound&quot;, &quot;ogg&quot;: &quot;sound&quot;, &quot;wav&quot;: &quot;sound&quot;, 
    &quot;part&quot;: &quot;json&quot;, 
    &quot;fnt&quot;: &quot;font&quot;, 
    &quot;pkm&quot;: &quot;pkm&quot;, 
    &quot;ttf&quot;: &quot;ttf&quot;};
    
    //Laya3D扩展  
    //通过扩展LoaderManager.createMap添加对应类型的解析。只对LoaderManager.create方法有效。
    createMap[&quot;lh&quot;] = [Sprite3D, Laya3D.HIERARCHY];
    createMap[&quot;ls&quot;] = [Scene, Laya3D.HIERARCHY];
    createMap[&quot;lm&quot;] = [Mesh, Laya3D.MESH];
    createMap[&quot;lmat&quot;] = [StandardMaterial, Laya3D.MATERIAL];
    createMap[&quot;lpbr&quot;] = [PBRMaterial, Laya3D.MATERIAL];
    createMap[&quot;ltc&quot;] = [TextureCube, Laya3D.TEXTURECUBE];
    createMap[&quot;jpg&quot;] = [Texture2D, &quot;nativeimage&quot;];
    createMap[&quot;jpeg&quot;] = [Texture2D, &quot;nativeimage&quot;];
    createMap[&quot;png&quot;] = [Texture2D, &quot;nativeimage&quot;];
    createMap[&quot;pkm&quot;] = [Texture2D, Loader.BUFFER];
    createMap[&quot;lsani&quot;] = [AnimationTemplet, Loader.BUFFER];
    createMap[&quot;lrani&quot;] = [AnimationTemplet, Loader.BUFFER];
    createMap[&quot;raw&quot;] = [DataTexture2D, Loader.BUFFER];
    createMap[&quot;mipmaps&quot;] = [DataTexture2D, Loader.BUFFER];
    createMap[&quot;thdata&quot;] = [TerrainHeightData, Loader.BUFFER];
    createMap[&quot;lt&quot;] = [TerrainRes, Laya3D.TERRAIN];
    createMap[&quot;lani&quot;] = [AnimationClip, Loader.BUFFER];
    createMap[&quot;lav&quot;] = [Avatar, Loader.JSON];
    createMap[&quot;ani&quot;] = [AnimationTemplet, Loader.BUFFER];//兼容接口&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;资源加载基础流程&quot;&gt;资源加载基础流程&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public function load(url:String, type:String = null, cache:Boolean = true, group:String = null, ignoreCache:Boolean = false):void
加载资源。加载错误会派发 Event.ERROR 事件，参数为错误信息。

Parameters

url:String — 资源地址。
 
type:String (default = null) — (default = null)资源类型。可选值为：Loader.TEXT、Loader.JSON、Loader.XML、Loader.BUFFER、Loader.IMAGE、Loader.SOUND、Loader.ATLAS、Loader.FONT。如果为null，则根据文件后缀分析类型。
 
cache:Boolean (default = true) — (default = true)是否缓存数据。
 
group:String (default = null) — (default = null)分组名称。
 
ignoreCache:Boolean (default = false) — (default = false)是否忽略缓存，强制重新加载。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;缓存url、type、cache等数据，供加载完成或者后续加载使用。&lt;/li&gt;
&lt;li&gt;如果资源已经加载过，并且没有设置ignoreCache则直接出发COMPLETE事件，通知加载完成。&lt;/li&gt;
&lt;li&gt;如果定制了加载方法，如Laya3D中注册的方法，则直接使用对应方法进行加载。&lt;/li&gt;
&lt;li&gt;根据type选择对应加载方法加载资源，如果没有传type，则会根据资源后缀名确定类型。&lt;/li&gt;
&lt;li&gt;资源加载完成后，触发onLoaded方法，将加载完的数据根据类型进行封装或者后续加载（如atlas类型加载完资源后，会解析配置，再去加载对应的图片）。&lt;/li&gt;
&lt;li&gt;调用complete方法，将data缓存在loader中，再将loader放入到完成队列。&lt;/li&gt;
&lt;li&gt;执行endload方法，缓存资源，通知COMPLETE事件，LoaderManager触发传入的complete方法。&lt;/li&gt;
&lt;li&gt;如果累计回调时长大于100毫秒时，延时一帧再执行后续loader的endload方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        /**
         * 加载完成。
         * @param   data 加载的数据。
         */
        protected function complete(data:*):void {
            this._data = data;
            if (_customParse) {
                event(Event.LOADED, data is Array ? [data] : data);
            } else {
                _loaders.push(this);
                if (!_isWorking) checkNext();
            }
        }
        
        /** @private */
        private static function checkNext():void {
            _isWorking = true;
            var startTimer:Number = Browser.now();
            var thisTimer:Number = startTimer;
            while (_startIndex &amp;lt; _loaders.length) {
                thisTimer = Browser.now();
                _loaders[_startIndex].endLoad();
                _startIndex++;
                //@防止单次回调事件太长，卡进程
                if (Browser.now() - startTimer &amp;gt; maxTimeOut) {
                    console.warn(&quot;loader callback cost a long time:&quot; + (Browser.now() - startTimer) + &quot; url=&quot; + _loaders[_startIndex - 1].url);
                    Laya.timer.frameOnce(1, null, checkNext);
                    return;
                }
            }
            
            _loaders.length = 0;
            _startIndex = 0;
            _isWorking = false;
        }
        
        /**
         * 结束加载，处理是否缓存及派发完成事件 &amp;lt;code&amp;gt;Event.COMPLETE&amp;lt;/code&amp;gt; 。
         * @param   content 加载后的数据
         */
        public function endLoad(content:* = null):void {
            content &amp;amp;&amp;amp; (this._data = content);
            if (this._cache) cacheRes(this._url, this._data);
            
            event(Event.PROGRESS, 1);
            event(Event.COMPLETE, data is Array ? [data] : data);
        
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;图片资源加载&quot;&gt;图片资源加载&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;后缀为png、jpg、jpeg以及类型为htmlimage或者nativeimage的资源，是使用图片类型加载。&lt;/li&gt;
&lt;li&gt;图片类型的加载使用过使用H5的&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/Image&quot;&gt;Browser.window.Image&lt;/a&gt;方式加载。
&lt;ul&gt;&lt;li&gt;创建一个Browser.window.Image的实例。&lt;/li&gt;
&lt;li&gt;设置src、onload、onerror方法。&lt;/li&gt;
&lt;li&gt;使用imgCache缓存image对象，防止被gc掉。&lt;/li&gt;
&lt;li&gt;当图片被加载完时，会触发onload回调，清理image的onerror和onload方法，传递给下级。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;nativeimage类型的图片，会直接将Image的数据传递下去。其他类型图片会使用HtmlImage（Canvas模式下）/WebGLImage（WebGL模式下）将原生Image数据包装，然后再传递给后续调用。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        /**
         * @private
         * 加载图片资源。
         * @param   url 资源地址。
         */
        protected function _loadImage(url:String):void {
            url = URL.formatURL(url);
            var _this:Loader = this;
            var image:*;
            function clear():void {
                image.onload = null;
                image.onerror = null;
                delete imgCache[url]
            }
            
            var onload:Function = function():void {
                clear();
                _this.onLoaded(image);
            };
            var onerror:Function = function():void {
                clear();
                _this.event(Event.ERROR, &quot;Load image failed&quot;);
            }
            
            if (_type === &quot;nativeimage&quot;) {
                image = new Browser.window.Image();
                image.crossOrigin = &quot;&quot;;
                image.onload = onload;
                image.onerror = onerror;
                image.src = url;
                //增加引用，防止垃圾回收
                imgCache[url] = image;
            } else {
                new HTMLImage.create(url, {onload: onload, onerror: onerror, onCreate: function(img:*):void {
                    image = img;
                    //增加引用，防止垃圾回收
                    imgCache[url] = img;
                }});
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;文本类型加载&quot;&gt;文本类型加载&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;简单类型如json、buffer等类型，直接通过http请求下载。&lt;/li&gt;
&lt;li&gt;Atlas/Font类型，会先通过这种方式下载配置文件，再执行后续操作。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;            var contentType:String;
            switch (type) {
            case ATLAS: 
                contentType = JSON;
                break;
            case FONT: 
                contentType = XML;
                break;
            case PKM: 
                contentType = BUFFER;
                break
            default: 
                contentType = type;
            }
            if (preLoadedMap[url])
            {
                onLoaded(preLoadedMap[url]);
            }else
            {
                if (!_http) 
                {
                    _http = new HttpRequest();
                    _http.on(Event.PROGRESS, this, onProgress);
                    _http.on(Event.ERROR, this, onError);
                    _http.on(Event.COMPLETE, this, onLoaded);
                }
                _http.send(url, null, &quot;get&quot;, contentType);
            }
            &lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;声音类型加载&quot;&gt;声音类型加载&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;对声音资源的加载，Laya封装到Sound类里面。Laya支持三种sound类型:H5方式、web audio api方式、微信小游戏方式。&lt;/li&gt;
&lt;li&gt;H5方式通过原生audio标签去加载声音。&lt;/li&gt;
&lt;li&gt;web audio方式是通过http请求方式下载。&lt;/li&gt;
&lt;li&gt;微信小游戏是微信提供方式下载。&lt;/li&gt;
&lt;li&gt;声音加载完成后，外部接受的为Sound对象，而不是语音的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;        /**
         * @private
         * 加载声音资源。
         * @param   url 资源地址。
         */
        protected function _loadSound(url:String):void {
            var sound:Sound = (new SoundManager._soundClass()) as Sound;
            var _this:Loader = this;
            
            sound.on(Event.COMPLETE, this, soundOnload);
            sound.on(Event.ERROR, this, soundOnErr);
            sound.load(url);
            
            function soundOnload():void {
                clear();
                _this.onLoaded(sound);
            }
            function soundOnErr():void {
                clear();
                sound.dispose();
                _this.event(Event.ERROR, &quot;Load sound failed&quot;);
            }
            function clear():void {
                sound.offAll();
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;图集加载&quot;&gt;图集加载&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;图集类型一般包含一份配置文件和一张或多张贴图。&lt;/li&gt;
&lt;li&gt;先用Http方式下载配置文件。并且设置当前类型为ATLAS类型。&lt;/li&gt;
&lt;li&gt;当配置文件下载完成后，解析meta字段，获取需要下载的图片地址，使用下载图片的方式下载对应图片。&lt;/li&gt;
&lt;li&gt;所有图片下载完成后，解析配置的frames，解析图集内包含的图片信息，为每个图片创建一个Texture，并将Texture放入到loadedMap中，key为图片原始路径。即使图片在图集中，也可以通过设置单张图片的url来获取图片资源。&lt;/li&gt;
&lt;li&gt;将图集里所有的图片的url已数组的形式存入atlasmap中，key为图集地址。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;if (type === ATLAS) {
                //处理图集
                if (!data.src &amp;amp;&amp;amp; !data._setContext) {
                    //@处理.atlas文件
                    if (!_data) {
                        this._data = data;
                        //构造加载图片信息
                        if (data.meta &amp;amp;&amp;amp; data.meta.image) {
                            //带图片信息的类型
                            var toloadPics:Array = data.meta.image.split(&quot;,&quot;);
                            var split:String = _url.indexOf(&quot;/&quot;) &amp;gt;= 0 ? &quot;/&quot; : &quot;\\&quot;;
                            var idx:int = _url.lastIndexOf(split);
                            var folderPath:String = idx &amp;gt;= 0 ? _url.substr(0, idx + 1) : &quot;&quot;;
                            //idx = _url.indexOf(&quot;?&quot;);
                            //var ver:String;
                            //ver = idx &amp;gt;= 0 ? _url.substr(idx) : &quot;&quot;;
                            for (var i:int = 0, len:int = toloadPics.length; i &amp;lt; len; i++) {
                                toloadPics[i] = folderPath + toloadPics[i];
                            }
                        } else {
                            //不带图片信息
                            toloadPics = [_url.replace(&quot;.json&quot;, &quot;.png&quot;)];
                        }
                        
                        //保证图集的正序加载
                        toloadPics.reverse();
                        data.toLoads = toloadPics;
                        data.pics = [];
                    }
                    event(Event.PROGRESS, 0.3 + 1 / toloadPics.length * 0.6);
                    return _loadImage(toloadPics.pop());
                } else {
                    //处理图片
                    _data.pics.push(data);
                    if (_data.toLoads.length &amp;gt; 0) {
                        event(Event.PROGRESS, 0.3 + 1 / _data.toLoads.length * 0.6);
                        //有图片未加载
                        return _loadImage(_data.toLoads.pop());
                    }
                    var frames:Object = this._data.frames;
                    var cleanUrl:String = this._url.split(&quot;?&quot;)[0];
                    var directory:String = (this._data.meta &amp;amp;&amp;amp; this._data.meta.prefix) ? this._data.meta.prefix : cleanUrl.substring(0, cleanUrl.lastIndexOf(&quot;.&quot;)) + &quot;/&quot;;
                    var pics:Array = _data.pics;
                    var atlasURL:String = URL.formatURL(this._url);
                    var map:Array = atlasMap[atlasURL] || (atlasMap[atlasURL] = []);
                    map.dir = directory;
                    var scaleRate:Number = 1;
                    if (this._data.meta &amp;amp;&amp;amp; this._data.meta.scale &amp;amp;&amp;amp; this._data.meta.scale != 1)
                    {
                        scaleRate = parseFloat(this._data.meta.scale);
                        for (var name:String in frames) {
                            var obj:Object = frames[name];//取对应的图
                            var tPic:Object = pics[obj.frame.idx ? obj.frame.idx : 0];//是否释放
                            var url:String = URL.formatURL(directory + name);
                            tPic.scaleRate = scaleRate;
                            cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
                            loadedMap[url].url = url;
                            map.push(url);
                        }
                    }else{
                        for (name in frames) {
                            obj = frames[name];//取对应的图
                            tPic = pics[obj.frame.idx ? obj.frame.idx : 0];//是否释放
                            url = URL.formatURL(directory + name);
                            cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
                            loadedMap[url].url = url;
                            map.push(url);
                        }
                    }
                    delete _data.pics;
                    
                    /*[IF-FLASH]*/
                    map.sort();
                    complete(this._data);
                }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;字体资源&quot;&gt;字体资源&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Laya有两种字体，一种是TTF字体一种是bitmapfont。&lt;/li&gt;
&lt;li&gt;加载bitmapfont是先加载配置文件，再将.fnt改为.png去加载图片。资源都加在完成后，使用BitmapFont去解析图集字体信息。&lt;/li&gt;
&lt;li&gt;TTF字体使用TTFLoader去加载，通过根据情况有多种加载方式，有使用FontFace方式，也有通过CSS等方式等。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;            var tArr:Array = fontPath.split(&quot;.ttf&quot;)[0].split(&quot;/&quot;);
            fontName = tArr[tArr.length - 1];
            if (Browser.window.conch)
            {
                _loadConch();
            }else
            if (Browser.window.FontFace) {
                this._loadWithFontFace()
            }
            else {
                this._loadWithCSS();
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;资源清理方式&quot;&gt;资源清理方式&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        /**
         * 清理指定资源地址的缓存。
         * 如果是Texture，则采用引用计数方式销毁，【注意】如果图片本身在自动合集里面（默认图片小于512*512），内存是不能被销毁的，此图片会被大图合集管理器管理
         * @param   url 资源地址。
         * @param   forceDispose 是否强制销毁，有些资源是采用引用计数方式销毁，如果forceDispose=true，则忽略引用计数，直接销毁，比如Texture，默认为false
         */
        public static function clearRes(url:String, forceDispose:Boolean = false):void {
            url = URL.formatURL(url);
            //删除图集
            var arr:Array = getAtlas(url);
            if (arr) {
                for (var i:int = 0, n:int = arr.length; i &amp;lt; n; i++) {
                    var resUrl:String = arr[i];
                    var tex:Texture = getRes(resUrl);
                    delete loadedMap[resUrl];
                    if (tex) tex.destroy(forceDispose);
                    
                }
                arr.length = 0;
                delete atlasMap[url];
                delete loadedMap[url];
            } else {
                var res:* = loadedMap[url];
                if (res) {
                    delete loadedMap[url];
                    if (res is Texture &amp;amp;&amp;amp; res.bitmap) Texture(res).destroy(forceDispose);               
                }
            }
        }
        
        /**
         * 销毁Texture使用的图片资源，保留texture壳，如果下次渲染的时候，发现texture使用的图片资源不存在，则会自动恢复
         * 相比clearRes，clearTextureRes只是清理texture里面使用的图片资源，并不销毁texture，再次使用到的时候会自动恢复图片资源
         * 而clearRes会彻底销毁texture，导致不能再使用；clearTextureRes能确保立即销毁图片资源，并且不用担心销毁错误，clearRes则采用引用计数方式销毁
         * 【注意】如果图片本身在自动合集里面（默认图片小于512*512），内存是不能被销毁的，此图片被大图合集管理器管理
         * @param   url 图集地址或者texture地址，比如 Loader.clearTextureRes(&quot;res/atlas/comp.atlas&quot;); Loader.clearTextureRes(&quot;hall/bg.jpg&quot;);   
         */
        public static function clearTextureRes(url:String):void {
            url = URL.formatURL(url);
            //删除图集
            var arr:Array = Loader.getAtlas(url);
            var res:* = (arr &amp;amp;&amp;amp; arr.length&amp;gt;0) ? Loader.getRes(arr[0]) : Loader.getRes(url);
            if (res &amp;amp;&amp;amp; res.bitmap) {
                if (Render.isConchApp) {
                    //兼容老版本
                    if (res.bitmap.source.releaseTexture) {
                        res.bitmap.source.releaseTexture();
                    }
                } else if (res.bitmap._atlaser == null) {
                    res.bitmap.releaseResource(true);
                }
            }
        }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Sep 2018 13:39:00 +0000</pubDate>
<dc:creator>chiguozi</dc:creator>
<og:description>Laya.Loader负责资源的加载逻辑，被LoaderManager管理。 Laya支持多种类型资源加载，也支持自定义类型加载。不同类型的加载方式可能不同。 Laya.Loader缓存已经被加载过得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chiguozi/p/9630543.html</dc:identifier>
</item>
<item>
<title>IO模型浅析-阻塞、非阻塞、IO复用、信号驱动、异步IO、同步IO - yearsj</title>
<link>http://www.cnblogs.com/yearsj/p/9630440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yearsj/p/9630440.html</guid>
<description>&lt;p&gt;最近看到OVS用户态的代码，在接收内核态信息的时候，使用了Epoll多路复用机制，对其十分不解，于是从网上找了一些资料，学习了一下《UNIX网络变成卷1：套接字联网API》这本书对应的章节，网上虽然关于该主题的博文很多，并且讲解的很详细，但是在这里还是做一个学习笔记，记录一下自己的想法。&lt;/p&gt;
&lt;h2 id=&quot;io模型&quot;&gt;IO模型&lt;/h2&gt;
&lt;p&gt;在《UNIX网络变成卷1：套接字联网API》这本书中，提到了五种I/O模型，分别为：阻塞式I/O、非阻塞式I/O、I/O复用（Epoll、select都是一种I/O复用机制），信息驱动式I/O、异步I/O，下面具体的一一介绍。&lt;/p&gt;
&lt;h3 id=&quot;阻塞式io模型&quot;&gt;阻塞式I/O模型&lt;/h3&gt;
&lt;p&gt;阻塞，顾名思义，当进程在等待数据时，若该数据一直没有产生，则该进程将一直等待，直到等待的数据产生为止，这个过程中进程的状态是阻塞的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1470567/201809/1470567-20180911212150626-466712910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，在linux中，用户态进程调用recvfrom系统调用接收数据，当前内核中并没有准备好数据，该用户态进程将一直在此等待，不会进行其他的操作，待内核态准备好数据，将数据从内核态拷贝到用户空间内存，然后recvfrom返回成功的指示，此时用户态进行才解除阻塞的状态，处理收到的数据。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从上述过程可以看出，用户态接收内核态数据的时候，主要有两个过程：内核态获得数据--&amp;gt;将数据从内核态的内存空间中复制到用户态进程的缓冲区中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;非阻塞式io模型&quot;&gt;非阻塞式I/O模型&lt;/h3&gt;
&lt;p&gt;在非阻塞式I/O模型中，当进程等待内核的数据，而当该数据未到达的时候，进程会不断询问内核，直到内核准备好数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1470567/201809/1470567-20180911212211998-1577621768.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，用户态进程调用recvfrom接收数据，当前并没有数据报文产生，此时recvfrom返回EWOULDBLOCK，用户态进程会一直调用recvfrom询问内核，待内核准备好数据的时候，之后用户态进程不再询问内核，待数据从内核复制到用户空间，recvfrom成功返回，用户态进程开始处理数据。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;需要注意的是，当数据从内核复制到用户空间中的这一段时间中，用户态进程是处于阻塞的状态的。&lt;/p&gt;
&lt;p&gt;非阻塞式I/O模型，个人觉得这个名字可能有点混淆，并不是和阻塞式模型是完全对立的，不是说进程等不到数据，就去做别的事情，恰恰进程这个时候一直在原地等待数据的到来，与阻塞式模型不同的是，非阻塞相当于进程一直在敲门问“数据好了么，快给我”，然后房门后的人说“没有准备好，请稍后！”，这个过程是一种轮询的状态，而阻塞式是佛系的态度，敲了一次门，房门后的人没有给任何回应，于是就去睡觉，啥都不做，直到房门后的人做出响应叫醒他，进程才去做下一步动作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;io复用模型&quot;&gt;I/O复用模型&lt;/h3&gt;
&lt;p&gt;在ovs的用户态源码里，就用到了I/O复用模型，在计算机网络里面，有很多关于“复用”的用法，比如多路复用，意思就是本来一条链路上一次只能传输一个数据流，如果要实现两个源之间多条数据流同时传输，那就得需要多条链路了，但是复用技术可以通过将一条链路划分频率，或者划分传输的时间，使得一条链路上可以同时传输多条数据流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1470567/201809/1470567-20180911212233268-507747906.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;套用到I/O复用模型上，可以对应到如下应用场景：如果一个进程需要等到多种不同的消息，那么一般的做法就是开启多条线程，每个线程接收一类消息，如果每个线程都是采用阻塞式I/O模型，那么每个线程在消息未产生的时候就会阻塞，也就是说在多线程中使用阻塞式I/O。I/O复用就是基于上述的场景中，无需采用多线程监听消息的方式，进程直接监听所有的消息类型，这其中就涉及到select、poll、epoll等不同的方法。&lt;/p&gt;
&lt;p&gt;如上图所示，用户态进程采用select的方法，通过select可以等待多个不同类型的消息，如果其中有一个类型的消息准备好，则select会返回信息，然后用户态进程调用recvfrom接收数据。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;可以将select复用机制看作是一个描述符集合的管理，进程通过向这个集合中放入不同的描述符，用来等待不同的消息产生，然后通过select统一的进行管理，让其可以同时等待这个集合中任意一个事件的产生。&lt;/p&gt;
&lt;p&gt;I/O复用和阻塞式I/O很相似，不同的是，I/O复用等待多类事件，阻塞式I/O只等待一类事件，另外，在I/O复用中，会产生两个系统调用（如上图，select和recvfrom），而阻塞式I/O只产生一个系统调用。那么这就涉及到具体的性能问题，当只存在一类事件的时候，使用阻塞式I/O模型的性能会更好，当存在多种不同类型的事件时，I/O复用的性能要好的多，因为阻塞式I/O模型只能监听一类事件，所以这个时候需要使用多线程进行处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;信号驱动式io模型&quot;&gt;信号驱动式I/O模型&lt;/h3&gt;
&lt;p&gt;在信号驱动式I/O模型中，与阻塞式和非阻塞式有了一个本质的区别，那就是用户态进程不再等待内核态的数据准备好，直接可以去做别的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1470567/201809/1470567-20180911212247565-1745374446.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，当需要等待数据的时候，首先用户态会向内核发送一个信号，告诉内核我要什么数据，然后用户态就不管了，做别的事情去了，而当内核态中的数据准备好之后，内核立马发给用户态一个信号，说”数据准备好了，快来查收“，用户态进程收到之后，立马调用recvfrom，等待数据从内核空间复制到用户空间，待完成之后recvfrom返回成功指示，用户态进程才处理别的事情。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过上面的图，可以看出信号驱动式I/O模型有种异步操作的赶脚，但是在将数据从内核复制到用户空间这段时间内用户态进程是阻塞的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异步io模型&quot;&gt;异步I/O模型&lt;/h3&gt;
&lt;p&gt;异步I/O模型相对于信号驱动式I/O模型就更彻底了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1470567/201809/1470567-20180911212303743-33188013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，首先用户态进程告诉内核态需要什么数据（上图中通过aio_read），然后用户态进程就不管了，做别的事情，内核等待用户态需要的数据准备好，然后将数据复制到用户空间，此时才告诉用户态进程，”数据都已经准备好，请查收“，然后用户态进程直接处理用户空间的数据。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在复制数据到用户空间这个时间段内，用户态进程也是不阻塞的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;同步io&quot;&gt;同步I/O&lt;/h3&gt;
&lt;p&gt;《UNIX网络变成卷1：套接字联网API》这本书中，并没有把同步I/O作为一种单独的I/O模型来说明，在没有阅读这些资料之前，我一直认为阻塞式I/O等同于同步I/O，非阻塞式I/O等同于异步I/O，可见不能单纯的通过字面意思就进行判断。&lt;/p&gt;
&lt;p&gt;通过对上述几种I/O模型的描述中，可以得到一个结论：阻塞式I/O、非阻塞式I/O、I/O复用模型是同步I/O模型，因为在等待数据的过程中，这三种模型中的进程都没有去做别的事情，即便是非阻塞式的轮询，也可以看作是一种同步。&lt;/p&gt;
&lt;p&gt;同时书中也认为信号驱动式I/O模型是同步I/O，书中说到：POSIX将同步IO操作定义为“导致请求进程阻塞，直到I/O操作完成”，而书中认为在信号驱动式I/O模型中等待数据的那段时间不算是真正的I/O操作（因为没有调用I/O相关的系统调用），而数据从内核复制到用户空间才是真正的I/O操作（这个时候调用了recvfrom系统调用）。&lt;/p&gt;
&lt;h2 id=&quot;io模型比较&quot;&gt;I/O模型比较&lt;/h2&gt;
&lt;p&gt;书中的这张图表述的非常清楚，从等待数据和数据复制这两个时间段，指出了不同I/O模型的区别，这里不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1470567/201809/1470567-20180911212315919-1077504877.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;从网上看了很多资料，不同的博主对这五个模型总结的情况不同，无一例外，基本都采用一个生活场景来描述他们的不同，但是我个人觉得有些场景描述太过简单，没有将不同模型的区别描述完全，在这里我也举一个生活中的场景作为总结，当然这只是我自己的想法，不妥之处评论区可以指出。&lt;/p&gt;
&lt;p&gt;我们去餐厅吃饭，会经过以下几个步骤：首先根据菜单点菜，然后等待厨房准备好，接着服务员上菜。在这个场景中，等待厨房准备菜肴等同于等待数据，服务员上菜等同于将数据从内核复制到用户空间，你就是用户态进程了，服务员和饭店看作是内核态的进程。&lt;/p&gt;
&lt;p&gt;阻塞式I/O模型：只点一个菜，然后在餐桌上开始等待，在这个过程中什么事都不干，等服务员把菜上到桌子上之后才开始大快朵颐。&lt;/p&gt;
&lt;p&gt;非阻塞式I/O模型：只点一个菜，然后开始等待，啥事都不做，等了一会儿然后就去问服务员，“我的菜好了吗？”，没好接着等待，过了一会儿然后又跑去问....重复这个过程，直到服务员说“亲，你的菜好了，我现在给您送桌上去”，然后你坐在桌子上，等待服务员把饭菜送到你的餐桌上，才开始吃饭。&lt;/p&gt;
&lt;p&gt;I/O复用模型：你点了很多菜，然后开始等待，某个时刻其中一个菜或者多个菜厨房里同时好了，服务员跑过来说，“亲，您的有些菜好了，要现在上桌么？”， 你回答，现在就上，于是服务员上一个菜（服务员一次只能上一个菜），你就吃完一个，上一个你就吃完一个。。。&lt;/p&gt;
&lt;p&gt;信号驱动式I/O模型：只点一个菜，然后给服务员留下手机，告诉他菜准备好了打个电话给你，先不要上菜，然后你就出去玩耍了，等到菜好了，服务员手机通知你，你立马回到了餐厅，对服务员说“你现在可以上菜了”，于是你在餐桌上等待服务员把菜送上来，然后吃饭。&lt;/p&gt;
&lt;p&gt;异步I/O模型：只点一个菜，然后给服务员留下手机，告诉他菜准备好了先上菜，菜上桌了打电话给你，然后你就出去玩耍了，等到菜上桌了，服务员手机通知你，你立马回到了餐桌，开始吃饭。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;UNIX网络变成卷1：套接字联网API&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Anker/p/3254269.html&quot;&gt;网络IO之阻塞、非阻塞、同步、异步总结&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/historyasamirror/article/details/5778378&quot;&gt;IO - 同步，异步，阻塞，非阻塞 （亡羊补牢篇）&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.2077922077922&quot;&gt;
&lt;p&gt;segmentfault对应该博文页面 &lt;a href=&quot;https://segmentfault.com/a/1190000016359495&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000016359495&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 11 Sep 2018 13:25:00 +0000</pubDate>
<dc:creator>yearsj</dc:creator>
<og:description>最近看到OVS用户态的代码，在接收内核态信息的时候，使用了Epoll多路复用机制，对其十分不解，于是从网上找了一些资料，学习了一下《UNIX网络变成卷1：套接字联网API》这本书对应的章节，网上虽然关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yearsj/p/9630440.html</dc:identifier>
</item>
</channel>
</rss>