<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【转】空间分析的三个传统：从三份讣告谈起 - 秋意正寒</title>
<link>http://www.cnblogs.com/onsummer/p/8463955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onsummer/p/8463955.html</guid>
<description>&lt;p&gt;&lt;strong&gt;2012年11月于美国凤凰城&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原文出处：http://blog.sina.com.cn/s/blog_643115fc010139m4.html，已征得作者同意转载。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;原博主按：&lt;/strong&gt;美国《纽约时报》是世界级的大报，其中有一个很特别的版面——“讣告版”(obituaries)，这个版面会发表有成就的人物去世的悼念文章，死后能够上《纽约时报》讣告版是一种哀荣。读者通过讣告可以快速了解逝者的人生经历和成就，这些讣告通常文笔生动、夹叙夹议，广受读者欢迎。本文希望从最近几年逝世的三位世界著名科学家的一生来反思在我国GIS发展过程中所遗失或者忽视的空间分析的三大传统，分别是&lt;strong&gt;Charles ReVelle教授所代表的空间分析的&lt;span&gt;工程学传统&lt;/span&gt;、Walter Isard教授所代表的空间分析的&lt;span&gt;经济学传统&lt;/span&gt;、Reginald Golledge教授所代表的空间分析的&lt;span&gt;心理学传统&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/showpic.html#blogid=643115fc010139m4&amp;amp;url=http://s9.sinaimg.cn/orignal/643115fcgcee06bcc5208&amp;amp;690&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;空间分析的三个传统：从三份讣告谈起&quot; src=&quot;http://s9.sinaimg.cn/small/643115fcgcee06bcc5208&amp;amp;690&quot; alt=&quot;空间分析的三个传统：从三份讣告谈起&quot; name=&quot;image_operate_91961353363719189&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;http://photo.blog.sina.com.cn/showpic.html#blogid=643115fc010139m4&amp;amp;url=http://s5.sinaimg.cn/orignal/643115fcgcee06d1a0824&amp;amp;690&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;空间分析的三个传统：从三份讣告谈起&quot; src=&quot;http://s5.sinaimg.cn/small/643115fcgcee06d1a0824&amp;amp;690&quot; alt=&quot;空间分析的三个传统：从三份讣告谈起&quot; name=&quot;image_operate_22421353363719874&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;http://photo.blog.sina.com.cn/showpic.html#blogid=643115fc010139m4&amp;amp;url=http://s14.sinaimg.cn/orignal/643115fcgcee06d299f0d&amp;amp;690&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;空间分析的三个传统：从三份讣告谈起&quot; src=&quot;http://s14.sinaimg.cn/small/643115fcgcee06d299f0d&amp;amp;690&quot; alt=&quot;空间分析的三个传统：从三份讣告谈起&quot; name=&quot;image_operate_68291353363731670&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://www.nytimes.com/2005/08/25/national/25revelle.html?_r=0&quot; target=&quot;_blank&quot;&gt;Charles ReVelle教授&lt;/a&gt;   &lt;a href=&quot;http://en.wikipedia.org/wiki/Walter_Isard&quot; target=&quot;_blank&quot;&gt;Walter Isard教授&lt;/a&gt;   &lt;a href=&quot;http://en.wikipedia.org/wiki/Reginald_Golledge&quot; target=&quot;_blank&quot;&gt;Reginald Golledge教授&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;（1938－2005）       (1919-2010)        (1937－2009)&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;三位近年逝世的科学大家，他们代表了空间分析的三个传统！&lt;/span&gt;&lt;/strong&gt; &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;    GIS是一个新兴的领域，过去十多年经历了飞速的甚至是野蛮的增长。但实际上在目前也是一个门槛很低的专业，任何人不管是那个领域的，只要学一本ArcGIS教程就可以声称是搞GIS的。一方面，由于历史原因，教授GIS课程的老师自己没有系统学习过GIS，无法开出有影响力的GIS理论与方法课程；另一方面，由于实用主义作祟，学生们也希望学一技之长以应付迫在眉睫的就业压力，根据无暇攻读艰深的理论与方法课程。这种缺乏严谨的理论与方法训练的快餐式的技能培养方式很难培养出GIS学生的核心竞争力，GIS久而久之逐渐称为一种地理学、测量学、计算机科学的混搭产品，学科视野严重束窄，这种发展倾向也导致很多GIS专业人士自己也轻视或低估了GIS在方法论与思维养成方面的巨大作用，这不能不说是GIS人的悲哀。目前，教育部已经将“地理信息系统”专业改为“地理信息科学”，这至少表明地理信息科学的学科地位在逐渐上升，作为科学本身，理论与方法不可或缺。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    理论与方法的发展是一个学科发展的基石，中国地理信息系统协会(CAGIS)每年也会举办理论与方法专门委员会的学术研讨会，这个研讨会目前已经发展成为中国GIS界最具学术声誉的会议，这对于普及与促进中国GIS理论与方法研究有着非常积极的推动作用。但是中国GIS界很多有识之士也清楚地意识到中国GIS界与国际水平之间的差距。按照GIS界知名教授汤国安先生2009年初的说法，中国GIS研究与美国GIS研究差距大概为15年。我觉得此言不虚，虽然近十年来我们中国的GIS界伴随着我们整个中国的发展以及中国政府对科学研究的大力推动与巨额投入，取得了非常迅猛的增长，在很多领域中国也取得了世界级的研究成果，卫星上天、航母下海、蛟龙潜水、高速铁路等等，但美国麻省理工学院(MIT)斯隆商学院华裔教授黄亚生最近领导完成的一项研究认为“没有找到特别强的证据，来证明过去30年中国政府对科技大规模的投资是划算的、有效的。这种大规模的投资，看到的最终结果是数量的增加，质量的增加十分有限，甚至在某些领域的研究还落后于中国在上世纪80年代的科研效率。这简直太让人吃惊了。”(&lt;a href=&quot;http://huangyasheng.blog.sohu.com/137359257.html&quot; target=&quot;_blank&quot;&gt;黄亚生，2009&lt;/a&gt;)。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    这绝非危言耸听，我们应正视繁荣背后的危机！ &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;   对照GIS界,表面上一片繁荣。在新闻中、在报纸上，我们已经习惯了每天的好消息，高分卫星、数字城市、智慧城市、天地图、地理国情监测，不一而足，我们完成了一个又一个成果，取得了一项又一项成就。但是繁荣背后依然隐藏了不少的危机：第一，教学方面，我们的GIS教科书是全世界最多的，但是几乎每本书都有南京大学1989年黄杏元教授《地理信息系统概论》的影子，课堂上充斥着过时的内容和时髦的技术，大学GIS教学沦落为职业技术培养所，缺乏学理的坚守；第二，科研方面，我们的GIS科研项目是全世界最多的，经费额度我们已经完全可以跟欧美各国媲美，作为应用型很强的学科，我们的教授却生产着大量实业部门不感兴趣的论文，很多低水平重复的研究对于中国这样一个发展中国家来说是一种巨大的浪费；第三，产业方面，我相信我们的GIS企业也是全世界最多的，央企、国企的不公平竞争，政府部门、事业单位的资源控制，使得民营GIS企业很难发展起来,现在发展得好的企业,很多与政府部门有着密切的联系。    &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    中国作为后发国家，过去我们一直强调后发优势，实际上反过来很重要的一点是后发劣势(&lt;a href=&quot;http://view.news.qq.com/a/20080222/000022.htm&quot; target=&quot;_blank&quot;&gt;杨小凯，2002&lt;/a&gt;)。后发劣势的意思就是说，落后国家由于发展比较迟，所以有很多东西可以模仿发达国家。模仿有两种形式，一种是模仿制度，另一种是模仿技术和工业化的模式。由于是后发国家，所以可以在没有在基础制度的情况下通过技术模仿实现快速发展。但是，落后国家虽然可以在短期内取得非常好的发展，但是会给长期的发展留下许多隐患，甚至长期发展可能失败。忠言逆耳，我们都喜欢讲中国的“后发优势”，不愿意相信中国的“后发劣势”。我们总是相信发展就是硬道理，政府部门高度参与到经济、社会、科技等各项事业的运营。上行下效，大大助长了政府部门的机会主义、大大强化了政府部门的资源控制。美国著名参议员Barry Goldwater有一句名言：“如果一个政府大到足以给你所有你要的东西，它也就大到了足以拿走你的所有东西。” &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    大规模的科研投资的效果立竿见影，我们的政府部门也陶醉于干预经济发展的胜利，享受发展超英赶美的跃进冲动。我们的大量投资用于跟踪国外先进技术，我们模仿ArcGIS,我们有了一系列平台GIS软件，我们模仿Google Earth,我们有了天地图，我们模仿IKONOS，我们就有了高分卫星⋯⋯，是的，我们做得很好，我们的投资很多，我们的进步也非常快。科研人员为了迎合发展获取资助，自觉不自觉地参与到政府主导的这场科研赛跑中。但是夜深人静的时候，我们扪心自问，我们的科研水平真正提高了吗？我们的人才培养能适应社会需求吗？我们的科研成果真正经得起历史考验吗？这种梦幻的情景会不会是一个美丽的肥皂泡？ &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;    GIS的发展无疑得益于信息技术的快速发展，但是过分依赖信息技术的发展也给GIS本身发展制造了障碍，让人感觉只要紧跟IT主流，就能发展好中国的GIS一样。当代信息技术的发展实际上也给人很大的误解，让人感觉技术发展日新月异，但现实中我们很多时候是被加速了。二战以后，因为美国特殊的国际地位、雄厚的综合国力和坚实的人才储备，第三次科技革命在美国首先兴起，这次科技革命的标志就是“以原子能技术、航天技术、电子计算机的应用为代表，还包括人工合成材料、分子生物学和遗传工程等高新技术。”整个美国社会因为第三次科技革命，获得了巨大的发展。但是很多科学史的专家的研究也表明：半个多世纪以后，新的科技革命还没有发生，虽然在过去几十年中很多学科领域被寄予下一波科技革命的厚望，例如纳米技术、生物技术、认知科学等等，但是这些新的技术虽然投资巨大，却是雷声大雨点小，至今并没有获得突破性的进展。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    所以，我们应该冷静地看到除了以电子计算机和互联网为代表的信息技术的发展以外，其它诸如航天、材料、能源、生物等领域虽然或多或少取得了很多成就，但并没有获得太多突破性乃至革命性的进展。很多学科的发展并不是很快，缺乏更新换代的理论方法，这些学科近年的发展绝大部分是信息技术背后推动的。我们也必须清楚地认识到信息技术的局限性，也即信息技术对于各个学科的理论方法本身并没有太大的改变，我们有必要去发展各个学科作为本原的理论与方法。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    GIS学科也是如此，其推动是一种外延型的推动，而非内涵式的基于基础理论与方法上的突破。我们的精力完全被信息技术所吸引，如空间数据库、组件开发、WebGIS等技术的发展带动了学科的巨大进步，但是我们也科研明显地感觉到地理学或者说地理信息科学本身的理论与方法创新则基本上被忽视，我们的发展光环完全来之于信息技术的罂粟似的疯涨。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;     理论与方法的创新是未来领域可持续发展的基石。欧美国家在GIS发展历史上经历过20世纪50年代激动人心的“计量地理学革命”，计量革命的发展是GIS发展的重要理论与方法准备。位于美国西雅图的华盛顿大学作为计量革命的风暴中心，当时云集了William Garrison,Edward Ullmand等杰出的地理学者和以Richard Morrill, Brian J.L. Berry, Waldo Tobler, John Nystuen, William Bunge, Duane Marble和Michael Dacey等一批天赋异常的研究生(&lt;strong&gt;Tobler, 2002；Velikonja,1994&lt;/strong&gt;)，这些人成为后来GIS乃至空间分析学科发展的中流砥柱。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    但是中国地理界因为种种原因到现在为止还缺乏对欧美50年代的“计量革命”缺乏深入的研究，我们看到商务印书馆组织从上世纪50年代开始翻译出版《汉译世界学术名著丛书》，而这套丛书中绝大部分地理学著作也是在80年代以后才陆续出版，很可惜的是这批地理学著作中很少有计量革命的译著出版。原因一方面是因为解放后我国地理界与欧美地理界的交流中断，错过了“计量革命”的黄金时期，等到醒悟过来已经是文革以后，耽误了二十年时间；另一方面，我国的地理学者普遍缺乏严格的科学和数学训练，在80年代以后我们追赶西方地理学发展的过程中，知识储备无法适应计量地理学以及后续的GIS理论方法研究的较高要求，所以当时的地理学者很难翻译出学理性、数学性非常强的计量地理学著作。1980年代我国学者编著的计量地理学著作虽然过于简单但却是奠基性的著作，后来出版的计量地理学著作也没有太大的突破，基本上没有反映1980年代以后这一领域特别是与GIS、空间分析结合的巨大发展。这一状况导致了我国GIS与空间分析领域落后美国大约20年，很多美国80年代已经成熟的理论与方法我们到现在仍然知之甚少，如地理学第一定律、地理学第二定律、空间计量经济学、最大覆盖模型、行为地理学、地理加权回归等超越以往理论框架的空间分析方法，国内学者知之甚少或者知之不深。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    举例来说，Berry and Marble曾经在1968年编撰了一部&amp;lt;空间分析(Spatial Analysis)&amp;gt;的书,到40多年后的今天大部分的中国GIS学人还无法真正了解这本奠基性著作的前瞻性，2008年，在Berry and Marble这部书出版40年的综述论文中，Berry等(2008)不无自豪地认为当时的很多文章在40后的今天仍然有极大的学术价值，这从一个侧面佐证了理论与方法在学科发展方面的重要性。确实，信息技术过几年就有很大变化，但是学科发展的主线和脉络并不是那么容易改变的。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;   要想发展中国GIS的理论与方法研究，我觉得我们必须要恢复欧美地理界自上实际50年代“计量革命”的定量研究传统，认清西欧美地理学特别是GIS和空间分析的发展脉络，至少需要恢复GIS乃至空间分析的三个传统。   &lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;   空间分析是GIS的重要功能，也是GIS区别于自助制图系统最为重要的功能。在国际GIS学界，空间分析已经发展了一整套分析方法，诞生了不少创新性的空间分析方法,这些方法对于GIS的发展影响深远。博主将之总结归纳为空间分析的三个传统：&lt;strong&gt;C&lt;/strong&gt;&lt;strong&gt;harles ReVelle教授所代表的空间分析的&lt;span&gt;工程学传统&lt;/span&gt;、Walter Isard教授所代表的空间分析的&lt;span&gt;经济学传统&lt;/span&gt;、Reginald Golledge教授所代表的空间分析的&lt;span&gt;心理学传统&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;http://photo.blog.sina.com.cn/showpic.html#blogid=643115fc010139m4&amp;amp;url=http://s9.sinaimg.cn/orignal/643115fcgcee06bcc5208&amp;amp;690&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;空间分析的三个传统：从三份讣告谈起&quot; src=&quot;http://s9.sinaimg.cn/small/643115fcgcee06bcc5208&amp;amp;690&quot; alt=&quot;空间分析的三个传统：从三份讣告谈起&quot; name=&quot;image_operate_91961353363719189&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;http://photo.blog.sina.com.cn/showpic.html#blogid=643115fc010139m4&amp;amp;url=http://s5.sinaimg.cn/orignal/643115fcgcee06d1a0824&amp;amp;690&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;空间分析的三个传统：从三份讣告谈起&quot; src=&quot;http://s5.sinaimg.cn/small/643115fcgcee06d1a0824&amp;amp;690&quot; alt=&quot;空间分析的三个传统：从三份讣告谈起&quot; name=&quot;image_operate_22421353363719874&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;http://photo.blog.sina.com.cn/showpic.html#blogid=643115fc010139m4&amp;amp;url=http://s14.sinaimg.cn/orignal/643115fcgcee06d299f0d&amp;amp;690&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;空间分析的三个传统：从三份讣告谈起&quot; src=&quot;http://s14.sinaimg.cn/small/643115fcgcee06d299f0d&amp;amp;690&quot; alt=&quot;空间分析的三个传统：从三份讣告谈起&quot; name=&quot;image_operate_68291353363731670&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;a href=&quot;http://www.nytimes.com/2005/08/25/national/25revelle.html?_r=0&quot; target=&quot;_blank&quot;&gt;Charles ReVelle教授&lt;/a&gt;  &lt;a href=&quot;http://en.wikipedia.org/wiki/Walter_Isard&quot; target=&quot;_blank&quot;&gt;Walter Isard教授&lt;/a&gt;   &lt;a href=&quot;http://en.wikipedia.org/wiki/Reginald_Golledge&quot; target=&quot;_blank&quot;&gt;Reginald Golledge教授&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;（1938－2005）       (1919-2010)           (1937－2009)&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;三位近年逝世的科学大家，他们代表了空间分析的三个传统！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;  这些创新型的思想的出现并不是偶然的，它是以西方科学严格的科学规范为基础的，同时不可或缺的是这三位科学家的天才。这三位科学大家在生前和逝世后都获得学术界非常崇高的评价，前两位教授登上了纽约时报的讣告(&lt;a href=&quot;http://www.nytimes.com/2005/08/25/national/25revelle.html?_r=0&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Charles ReVelle教授的纽约时报讣告&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://www.nytimes.com/2010/11/11/business/economy/11isard.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Walter Isard教授的纽约时报讣告&lt;/strong&gt;&lt;/a&gt;），后一位教授逝世后Nature杂志的登载了一篇访谈(&lt;a href=&quot;http://www.nature.com/naturejobs/science/articles/10.1038/nj7248-877a&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Reginald Golledge教授的Nature杂志访谈&lt;/strong&gt;&lt;/a&gt;)。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    三位科学家都是各自领域的奠基者，我个人认为他们完全是各自新开创了一个学派，也培养了众多研究生，这些研究生现已成为GIS与空间分析研究的中坚。这一组文章也是我近年思考的一些结果，正好这几年&lt;a href=&quot;http://blog.sina.com.cn/s/blog_643115fc010138ls.html&quot; target=&quot;_blank&quot;&gt;我爱人在美国亚利桑那州立大学(ASU)GeoDa空间分析与计算中心攻读博士研究生&lt;/a&gt;，使我们有机会接触到世界前沿的空间分析研究，我们也非常受教于与ASU的GeoDa中心的Alan Murray教授、Luc Anselin院士、Sergie Rey教授等的交流，同时也受教于诸如学术界的GISciene双年会(GISciene2012，&lt;a href=&quot;http://www.giscience.org/&quot;&gt;http://www.giscience.org/&lt;/a&gt;)、美国地理学会年会(AAG，&lt;a href=&quot;http://www.aag.org/&quot;&gt;http://www.aag.org&lt;/a&gt;)、北美区域科学年会(NARSC,&lt;a href=&quot;http://www.narsc.org/newsite/&quot;&gt;http://www.narsc.org/newsite/&lt;/a&gt;)、美国运筹学和管理科学研究协会(INFORMS，&lt;a href=&quot;http://meetings2.informs.org/phoenix2012/&quot;&gt;http://meetings2.informs.org/phoenix2012/&lt;/a&gt;)、美国计算机学会主办的ACM-GIS(&lt;a href=&quot;http://acmgis2012.cs.umd.edu/&quot;&gt;http://acmgis2012.cs.umd.edu/&lt;/a&gt;)以及产业界的ESRI用户大会(&lt;a href=&quot;http://blog.sina.com.cn/s/blog_643115fc01010xge.html&quot; target=&quot;_blank&quot;&gt;我的ESRI2012年大会观感&lt;/a&gt;)等会议的学术报告的启发。   &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    我本人进入GIS这门学科，已经有超过15年，教书也已经超过5年，很多时候都在思考我们学科的未来，思考我们如何教我们的学生、如何做我们的研究。我觉得最根本的还是先要了解别人做了什么，特别是应该要在学习了理论方法以后再去做研究，否则不可能做出一流的研究&lt;strong&gt;。&lt;/strong&gt;在科研领域，因为科研评价体系的影响，中国的很多研究人员包括研究生受论文发表的压力普遍希望做一些短平快的研究，普遍只要利用软件进行数据处理即可写出论文，缺乏理论方法的创新。科研评价体系的扭曲导致我国科技界做了太多低水平重复的工作，因此也很难诞生超越以往理论框架的创新。如果这种科研价值的评定体系不能改变，那我们在科研领域的投资结果注定多数将有去无回、事倍功半(&lt;a href=&quot;http://huangyasheng.blog.sohu.com/137359257.html&quot; target=&quot;_blank&quot;&gt;黄亚生，2009&lt;/a&gt;)。我越来越感觉最根本的是，是必须有我们的理论与方法，就是要注意面向应用开发理论与方法，真切提高地理空间数据的潜在价值，这也是一个学科长远发展的根本。  &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;    在理论与方法研究方面，科学研究没有捷径可走，别人走过的路你还必须要走。下面几篇博文将依次介绍三位教授及其开创的空间分析的工程学传统、经济学传统、心理学传统，希望对大家有所启发，也欢迎大家的意见和建议。&lt;/p&gt;

&lt;ol readability=&quot;4.0974025974026&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;Brian Berry，Duane Marble,Spatial Analysis: A Reader in Statistical Geography.Prentice Hall, Englewood Cliffs, 1968，512pp.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;Brian J. L. Berry,Daniel A. Griffith, Michael R. Tiefelsdorf,2008,From Spatial Analysis to Geospatial Science,Geographical Analysis, 40(3):229–238.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;div align=&quot;left&quot; readability=&quot;14&quot;&gt;
&lt;p align=&quot;center&quot;&gt;W. Tobler, 2002, “Ma Vie: Growing Up in America and Europe”, in Geographical Voices, W. Pitts and P. Gould, eds., University of Syracuse Press; Syracuse; pages 292-322.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;

&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 23 Feb 2018 18:45:00 +0000</pubDate>
<dc:creator>秋意正寒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onsummer/p/8463955.html</dc:identifier>
</item>
<item>
<title>R语言-主成分分析 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8463929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8463929.html</guid>
<description>&lt;p&gt;1.PCA&lt;/p&gt;
&lt;p&gt;使用场景:主成分分析是一种数据降维,可以将大量的相关变量转换成一组很少的不相关的变量,这些无关变量称为主成分&lt;/p&gt;
&lt;p&gt;　　步骤:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据预处理(保证数据中没有缺失值)&lt;/li&gt;
&lt;li&gt;选择因子模型(判断是PCA还是EFA)&lt;/li&gt;
&lt;li&gt;判断要选择的主成分/因子数目&lt;/li&gt;
&lt;li&gt;选择主成分&lt;/li&gt;
&lt;li&gt;旋转主成分&lt;/li&gt;
&lt;li&gt;解释结果&lt;/li&gt;
&lt;li&gt;计算主成分或因子的得分&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　 案例:从USJudgeRatings数据集中有11个变量,如何去减化数据(单个主成分分析)&lt;/p&gt;
&lt;p&gt;　　　　1.使用碎石图确定需要提取的主成分个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;library(psych)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.做出碎石图确定主成分的个数&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; fa.parallel(USJudgeRatings[,-1],fa=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,n.iter = 100,show.legend = F,main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Scree plot with parallel analysis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180223235949251-1274694085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:在特征值大于1的的点附近,都表明保留1个主成分即可&lt;/p&gt;
&lt;p&gt;　　2.提取主成分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.第一个参数是关系矩阵&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.nfactors指定主成分的个数&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.rotate指定旋转方法,默认varimax&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.scores表示是否需要计算主成分得分,默认不需要&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; pc &amp;lt;- principal(USJudgeRatings[,-1],nfactors = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; pc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224000715556-568018380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:第一主成分与每一个变量高度相关&lt;/p&gt;
&lt;p&gt;　　3.获取主成分得分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; pc &amp;lt;- principal(USJudgeRatings[,-1],nfactors = 1,scores =&lt;span&gt; T)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;head(pc$scores)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; cor(USJudgeRatings$CONT,pc$scores)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224001111420-898628632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.获取相关系数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cor(USJudgeRatings$CONT,pc$scores)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224001231629-286749358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:律师和法官的私交和律师的评级没有关系&lt;/p&gt;
&lt;p&gt;　　案例2:减少女孩身体指标的主成分分析(多个主成分分析)&lt;/p&gt;
&lt;p&gt;　　1.判断个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fa.parallel(Harman23.cor$cov,n.obs = 203,fa=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,n.iter = 100,show.legend =&lt;span&gt; F,
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Scree plot with parallel analysis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224001734297-1627107199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:有2个点在水平线1上,所以需要2个主成分&lt;/p&gt;
&lt;p&gt;　　2.主成分分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
pc2 &amp;lt;- principal(Harman23.cor$cov,nfactors = 2,rotate = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
pc2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224002108723-889456311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需要对数据旋转作进一步分析&lt;/p&gt;
&lt;p&gt;　　3.主成分旋转(尽可能对成分去噪)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; rc &amp;lt;- principal(Harman23.cor$cov,nfactors = 2,rotate = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;varimax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; rc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224002352143-1436292503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.获取主成分的得分系数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; round(unclass(rc$weights),2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224002624312-452014608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:可以通过系数*数值来计算出主成分得分&lt;/p&gt;
&lt;p&gt;2.EFA&lt;/p&gt;
&lt;p&gt;使用场景:探索因子分析发掘数据下一组较少的,无法观测的变量来解释一组可观测变量的相关性&lt;/p&gt;
&lt;p&gt;　　案例:使用EFA对6个心理学测试来检测参与者的得分&lt;/p&gt;
&lt;p&gt;　　1.判断需要提取的因子数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; covariances &amp;lt;-&lt;span&gt; ability.cov$cov
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; correlations &amp;lt;-&lt;span&gt; cov2cor(covariances)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; fa.parallel(correlations,n.obs = 112,fa=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;both&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,n.iter=100,main = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Scree plots with parallel analysis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224003418865-620109003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需要提取2个因子,因为图形在拐点之上有2个分布&lt;/p&gt;
&lt;p&gt;　　2.提取公共因子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fa &amp;lt;- fa(correlations,nfactors = 2,rotate = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fm=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224003743479-1552630323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:2个因子解释了6个心理学测试的60%方差,需要进一步旋转&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fa.varimax &amp;lt;- fa(correlations,nfactors=2,rotate=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;varimax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fm=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fa.varimax
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224003930300-1388817214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:阅读和词汇在第一个因子占比较大,画图,积木在第二个因子上成分较大,如果想进一步判断这个各因子是否相关,需要使用斜交旋转提取因子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fa.promax &amp;lt;- fa(correlations,nfactors=2,rotate=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Promax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fm=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fa.promax
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224004222794-1861724575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:相关性为0.57,相关性很大,如果相关性不大,使用正交旋转即可&lt;/p&gt;
&lt;p&gt;　　3.计算得分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; fsm &amp;lt;-&lt;span&gt; function(oblique) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;class&lt;/span&gt;(oblique)[2]==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp; &lt;span&gt;is&lt;/span&gt;&lt;span&gt;.null(oblique$Phi)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     warning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Object doesn't look like oblique EFA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     P &amp;lt;-&lt;span&gt; unclass(oblique$loading)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     F &amp;lt;- P %*%&lt;span&gt; oblique$Phi
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     colnames(F) &amp;lt;- c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PA1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PA2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(F)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; fsm(fa.promax)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224004533405-1266736442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5.正交旋转所得因子得分图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224004800758-392677000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　结论:词汇和阅读在第一因子上载荷较大,图片,迷宫,积木在第二个因子上载荷较大,普通智力检测在二者的分布较为平均&lt;/p&gt;
&lt;p&gt;　　6.斜交旋转所生成的因子图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; fa.diagram(fa.promax,simple = F)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201802/1173792-20180224005142465-1922262101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:显示了因子之间的关系,该图比上一张图更为准确&lt;/p&gt;


</description>
<pubDate>Fri, 23 Feb 2018 16:53:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8463929.html</dc:identifier>
</item>
<item>
<title>pygame写贪吃蛇 - ansver</title>
<link>http://www.cnblogs.com/ansver/p/8438830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ansver/p/8438830.html</guid>
<description>&lt;p&gt;python小白尝试写游戏..&lt;/p&gt;
&lt;p&gt;学了点pygame不知道那什么练手好,先拿贪吃蛇开刀吧.&lt;/p&gt;
&lt;p&gt;一个游戏可以粗略的分为两个部分:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据(变量)&lt;/li&gt;
&lt;li&gt;处理数据(函数,方法)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;设计变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先预想下,画面的那些部分需要存储在变量里&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;贪吃蛇假想图&quot; src=&quot;https://images2017.cnblogs.com/blog/1287691/201802/1287691-20180210133049154-1000127275.jpg&quot; alt=&quot;&quot; width=&quot;167&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个画面上只会有矩形,而且这些矩形整整齐齐,大小相等,原本一个矩形需要四个变量表示位置,这里,只需要两个变量(行数,列数)就能表示方块的位置&lt;/p&gt;
&lt;p&gt;蛇头,食物可以用二元元组表示,蛇身的数量不确定,只能用包含数个元组的列表表示&lt;/p&gt;
&lt;p&gt;另外设定窗口大小800x600,每个方块都是50x50&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pygame
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

pygame.init()
screen &lt;/span&gt;= pygame.display.set_mode((800, 600&lt;span&gt;))
pygame.display.set_caption(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;贪吃蛇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

food &lt;/span&gt;= (4, 5&lt;span&gt;)
body &lt;/span&gt;= [(1, 1&lt;span&gt;),(1,2)]
head &lt;/span&gt;= (1, 3&lt;span&gt;)

BLOCK &lt;/span&gt;=&lt;span&gt; 0, 0, 0
GREEN &lt;/span&gt;= 0, 255&lt;span&gt;, 0
RED &lt;/span&gt;= 255&lt;span&gt;, 0, 0
BLUE &lt;/span&gt;= 0, 0, 255&lt;span&gt;
WHITE &lt;/span&gt;= 255, 255, 255

&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; event &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pygame.event.get():
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.type ==&lt;span&gt; pygame.QUIT:
            sys.exit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;变量设定好了,游戏已经完成了一半(￣▽￣)~*&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下一步&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量到画面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;pygame.draw.rect()是根据矩形四元数组绘制图像的,那就写个函数&quot;对接&quot;下我的二元坐标&lt;/p&gt;
&lt;p&gt;这里就成数学的问题了...&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_draw_rect(zb, color,screen):
    pygame.draw.rect(screen,color,((zb[&lt;/span&gt;1]-1)*50+1,(zb[0]-1)*50+1,48,48))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;鉴于50x50时相邻方块们会&quot;粘&quot;在一起,方块向里收一下成48x48        ↑&lt;/p&gt;
&lt;p&gt;绘制图形,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...&lt;br/&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; event &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pygame.event.get():
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.type ==&lt;span&gt; pygame.QUIT:
            sys.exit()

    screen.fill(WHITE)
    new_draw_rect(food, RED, screen)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
        new_draw_rect(i, BLUE, screen)
    new_draw_rect(head, GREEN, screen)
    
    pygame.display.update()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 由静到动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 两个问题:&lt;/p&gt;
&lt;p&gt;1.什么时候动&lt;/p&gt;
&lt;p&gt;2.怎么动&lt;/p&gt;
&lt;p&gt;问题1,什么时候动,这里有两个思路,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;间隔固定时间(1秒),动一次&lt;/li&gt;
&lt;li&gt;按一次键动一次,无操作一定时间(1秒)后,重复最后一次操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看起来第一种方案 &lt;span&gt;简单&lt;/span&gt; 不错&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先,先用pygame的clock类限制帧率(100帧),以方便计时&lt;/p&gt;
&lt;p&gt;再者,加入新变量times,times每次加1,超过一百就&quot;动一动&quot;&lt;/p&gt;
&lt;p&gt;加入新变量direction,表示蛇头朝向,衔接键盘操作和&quot;怎么动&quot;&lt;/p&gt;
&lt;p&gt; PS:程序结束之前,很难知道要用多少变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pygame
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

pygame.init()
screen &lt;/span&gt;= pygame.display.set_mode((800, 600&lt;span&gt;))
pygame.display.set_caption(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;贪吃蛇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

fclock &lt;/span&gt;=&lt;span&gt; pygame.time.Clock()


food &lt;/span&gt;= (4, 5&lt;span&gt;)
body &lt;/span&gt;= [(1, 1&lt;span&gt;)]
head &lt;/span&gt;= (1, 2&lt;span&gt;)
times &lt;/span&gt;=&lt;span&gt; 0
direction &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

BLOCK &lt;/span&gt;=&lt;span&gt; 0, 0, 0
GREEN &lt;/span&gt;= 0, 255&lt;span&gt;, 0
RED &lt;/span&gt;= 255&lt;span&gt;, 0, 0
BLUE &lt;/span&gt;= 0, 0, 255&lt;span&gt;
WHITE &lt;/span&gt;= 255, 255, 255

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_draw_rect(zb, color,screen):
    pygame.draw.rect(screen,color,((zb[&lt;/span&gt;1]-1)*50+1,(zb[0]-1)*50+1,48,48&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; event &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pygame.event.get():
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.type ==&lt;span&gt; pygame.QUIT:
            sys.exit()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; pygame.KEYDOWN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_LEFT:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_DOWN:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_RIGHT:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; times &amp;gt;= 100&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;动一动&lt;/span&gt;
        times =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        times &lt;/span&gt;+= 1&lt;span&gt;

    screen.fill(WHITE)
    new_draw_rect(food, RED, screen)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
        new_draw_rect(i, BLUE, screen)
    new_draw_rect(head, GREEN, screen)

    fclock.tick(&lt;/span&gt;100&lt;span&gt;)
    pygame.display.update()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 蛇头的运动规律 : 向临近的格子移动,上下左右具体那个格子由键盘确定&lt;/p&gt;
&lt;p&gt;那就写个新函数去生成蛇头的新位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_front(head,direction):
    x, y &lt;/span&gt;=&lt;span&gt; head
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x-1&lt;span&gt;, y
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x, y-1
    &lt;span&gt;elif&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x+1&lt;span&gt;, y
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x, y+1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;p&gt;head = get_front(head,direction)&lt;/p&gt;
&lt;p&gt;但是蛇蛇一头扎墙里怎么办.......&lt;/p&gt;
&lt;p&gt;你的好友【front : 临时记下蛇头前方的位置】已上线&lt;/p&gt;
&lt;p&gt;你的好友【alive : 记录存活信息】已上线&lt;/p&gt;
&lt;p&gt;PS:front可以不是全局变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ask_alive(front,body):
    x, y &lt;/span&gt;=&lt;span&gt; front
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; x &amp;gt; 12 &lt;span&gt;or&lt;/span&gt; y &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; y &amp;gt;16&lt;span&gt; :
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; front &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后这样用&lt;/p&gt;
&lt;p&gt;front = get_front(head,direction)&lt;br/&gt;alive = ask_alive(front,body)&lt;br/&gt;if alive:&lt;br/&gt;　　head = front&lt;/p&gt;
&lt;p&gt;人话 :先看看蛇头前面是否有危险,有危险就死了 , 不动啦&lt;/p&gt;
&lt;p&gt;另外alive得加到前面的if里面当限制条件,死了就不能乱动啦~~~~~&lt;/p&gt;

&lt;p&gt;蛇身动的规律 : 近头端跟头走,尾端也跟着走--&lt;span&gt;向程序靠拢&lt;/span&gt;--&amp;gt;&amp;gt;用过的head加入body,同时删去body最老的成员&lt;/p&gt;
&lt;p&gt;这里可以看出body必须有序,可变.python里面就用列表了&lt;/p&gt;
&lt;p&gt;如果使用list的append方法,head加在body的末尾,那么body[0]就会是&quot;最老的成员&quot;就得使用pop(0)删去&lt;/p&gt;
&lt;p&gt;PS. body.append(head)得写在head=front前面,在head更新前加进body&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; times &amp;gt;= 100 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; alive:
        front &lt;/span&gt;=&lt;span&gt; get_front(head,direction)
        alive &lt;/span&gt;=&lt;span&gt; ask_alive(front,body)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; alive:
            body.append(head)
            head &lt;/span&gt;=&lt;span&gt; front
            body.pop(0)
        times &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        times &lt;/span&gt;+= 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 食物的运动规律:被吃掉后,随机位置再出现 --&lt;span&gt;向程序靠拢&lt;/span&gt;--&amp;gt;&amp;gt; 当head== food为真时 food随机选择一个蛇之外的地方出现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_food(head,body):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
        x &lt;/span&gt;= random.randint(1, 12&lt;span&gt;)
        y &lt;/span&gt;= random.randint(1, 16&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x, y) != head &lt;span&gt;and&lt;/span&gt; (x, y) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x, y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里存在一个隐式BUG,要是蛇充满了每一个角落,那这就是死循环 ...........然后整个程序卡在这里....&lt;/p&gt;
&lt;p&gt;版本1 : 我选择没看见,不会有什么人能吃到&quot;全屏&quot;的(´⊙ω⊙`)    --来自开发者的懒惰&lt;/p&gt;
&lt;p&gt;版本2 【我的选择】: 修了这个BUG&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_food(head,body):
    i &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; i &amp;lt; 100&lt;span&gt;:
        x &lt;/span&gt;= random.randint(1, 12&lt;span&gt;)
        y &lt;/span&gt;= random.randint(1, 16&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x, y) != head &lt;span&gt;and&lt;/span&gt; (x, y) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (x, y), True
        i &lt;/span&gt;+= 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (0, 0), False

food, alive &lt;/span&gt;= new_food()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 100次机会 否则就死(￣へ￣)     --来自开发者的恶意&lt;/p&gt;
&lt;p&gt;另外,蛇吃了食物就要长一格====&amp;gt;&amp;gt;蛇头前进一格,蛇尾不动,蛇就因此长了一格====&amp;gt;&amp;gt;当head = food 为真时body.pop(0)不用执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; alive:
            body.append(head)
            head &lt;/span&gt;=&lt;span&gt; front
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; food ==&lt;span&gt; head:
                food &lt;/span&gt;=&lt;span&gt; new_food(head, body)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                body.pop(0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;完结撒花&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细节优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么?游戏结束了?&lt;/p&gt;
&lt;p&gt;黑个屏,提醒下&lt;/p&gt;
&lt;p&gt;你的好友【back_color】已上线&lt;/p&gt;
&lt;p&gt;back_color一开始等于WHITE , alive为假时变为BLOCK&lt;/p&gt;
&lt;p&gt;标题栏变成&quot;游戏结束&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; times &amp;gt;= 100 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; alive:&lt;/span&gt;&lt;span&gt;
        front &lt;/span&gt;=&lt;span&gt; get_front(head, direction)
        alive &lt;/span&gt;=&lt;span&gt; ask_alive(front, body)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; alive:
            body.append(head)
            head &lt;/span&gt;=&lt;span&gt; front
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; food ==&lt;span&gt; head:
                food, alive &lt;/span&gt;=&lt;span&gt; new_food(head, body)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                body.pop(0)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            back_color &lt;/span&gt;=&lt;span&gt; BLOCK
            pygame.display.set_caption(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;游戏结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        times &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        times &lt;/span&gt;+= 1
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;2,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;贪吃蛇假想图&quot; src=&quot;https://images2017.cnblogs.com/blog/1287691/201802/1287691-20180210133049154-1000127275.jpg&quot; alt=&quot;&quot; width=&quot;167&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要是一开始按了一下left......&lt;/p&gt;
&lt;p&gt;恭喜你获得技能【撞脖子自杀】&lt;/p&gt;
&lt;p&gt;要么那就&lt;/p&gt;
&lt;p&gt;你的好友【old_direction】已上线&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
old_direction = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; direction_yes_no(direction,old_direction):
    d &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; d[direction] ==&lt;span&gt; old_direction:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; old_direction
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; direction
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;PS : 字典代替if-elif结构省心省时&lt;/p&gt;
&lt;p&gt;然后 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　if&lt;/span&gt; times &amp;gt;= 100 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; alive:
        direction &lt;/span&gt;=&lt;span&gt; direction_yes_no(direction, old_direction)
        old_direction &lt;/span&gt;=&lt;span&gt; direction
        front &lt;/span&gt;=&lt;span&gt; get_front(head, direction)
        alive &lt;/span&gt;= ask_alive(front, body)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;人话 : 添加一个变量记录上一次有效的输入,两个方向关系不正确时,以老变量为准--&lt;span&gt;向人靠拢&lt;/span&gt;--&amp;gt;&amp;gt;向右跑时,不准向左!!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : direction也可以在按键事件处理时限制呀,例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; pygame.KEYDOWN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                   &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;改为&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; pygame.KEYDOWN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; direction != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt;:在发现这个方法的BUG之前,我也是这样想的&lt;/p&gt;
&lt;p&gt;还是上面的例子&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;贪吃蛇假想图&quot; src=&quot;https://images2017.cnblogs.com/blog/1287691/201802/1287691-20180210133049154-1000127275.jpg&quot; alt=&quot;&quot; width=&quot;167&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接按left行不通,right--XX--&amp;gt;left&lt;/p&gt;
&lt;p&gt;先按down,迅速再按left ,,right --&lt;span&gt;pass&lt;/span&gt;--&amp;gt;&amp;gt; down --&lt;span&gt;pass&lt;/span&gt;--&amp;gt;&amp;gt; left&lt;/p&gt;
&lt;p&gt;恭喜你获得技能【绕过开发者防护,高水平撞脖子自杀】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 我要暂停!!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 好好玩游戏,不要动不动就暂停&lt;/p&gt;
&lt;p&gt;你的好友【pause】已上线&lt;/p&gt;
&lt;p&gt;逻辑值,P键控制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pause =&lt;span&gt; False

            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_p:
                pause &lt;/span&gt;= &lt;span&gt;not&lt;/span&gt;&lt;span&gt; pause    

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; times &amp;gt;= 100 &lt;span&gt;and&lt;/span&gt; alive &lt;span&gt;and&lt;/span&gt; (&lt;span&gt;not&lt;/span&gt;&lt;span&gt; pause):
    ....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;下面我发一下全部的代码,代码包含上面的优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;↓↓↓↓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;完结撒花&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;89&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pygame
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

pygame.init()
screen &lt;/span&gt;= pygame.display.set_mode((800, 600&lt;span&gt;))
pygame.display.set_caption(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;贪吃蛇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

fclock &lt;/span&gt;=&lt;span&gt; pygame.time.Clock()


food &lt;/span&gt;= (4, 5&lt;span&gt;)
body &lt;/span&gt;= [(1, 1&lt;span&gt;)]
head &lt;/span&gt;= (1, 2&lt;span&gt;)&lt;br/&gt;times &lt;/span&gt;=&lt;span&gt; 0
direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
old_direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
alive &lt;/span&gt;=&lt;span&gt; True
pause &lt;/span&gt;=&lt;span&gt; False

BLOCK &lt;/span&gt;=&lt;span&gt; 0, 0, 0
GREEN &lt;/span&gt;= 0, 255&lt;span&gt;, 0
RED &lt;/span&gt;= 255&lt;span&gt;, 0, 0
BLUE &lt;/span&gt;= 0, 0, 255&lt;span&gt;
WHITE &lt;/span&gt;= 255, 255, 255&lt;span&gt;
back_color &lt;/span&gt;=&lt;span&gt; WHITE


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_draw_rect(zb, color,screen):
    pygame.draw.rect(screen,color,((zb[&lt;/span&gt;1]-1)*50+1,(zb[0]-1)*50+1,48,48&lt;span&gt;))


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_front(head, direction):
    x, y &lt;/span&gt;=&lt;span&gt; head
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x-1&lt;span&gt;, y
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x, y-1
    &lt;span&gt;elif&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x+1&lt;span&gt;, y
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; direction == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x, y+1


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; ask_alive(front, body):
    x, y &lt;/span&gt;=&lt;span&gt; front
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; x &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; x &amp;gt; 12 &lt;span&gt;or&lt;/span&gt; y &amp;lt; 0 &lt;span&gt;or&lt;/span&gt; y &amp;gt;16&lt;span&gt; :
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; front &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; new_food(head, body):
    i &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; i &amp;lt; 100&lt;span&gt;:
        x &lt;/span&gt;= random.randint(1, 12&lt;span&gt;)
        y &lt;/span&gt;= random.randint(1, 16&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x, y) != head &lt;span&gt;and&lt;/span&gt; (x, y) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (x, y), True
        i &lt;/span&gt;+= 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (0, 0), False


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; direction_yes_no(direction, old_direction):
    d &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; d[direction] ==&lt;span&gt; old_direction:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; old_direction
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt; direction&lt;p&gt;#food = new_food(head,body)

&lt;/p&gt;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; 1&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; event &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pygame.event.get():
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.type ==&lt;span&gt; pygame.QUIT:
            sys.exit()
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; pygame.KEYDOWN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_LEFT:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_DOWN:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_RIGHT:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_p:
                pause &lt;/span&gt;= &lt;span&gt;not&lt;/span&gt;&lt;span&gt; pause
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; times &amp;gt;= 100 &lt;span&gt;and&lt;/span&gt; alive &lt;span&gt;and&lt;/span&gt; (&lt;span&gt;not&lt;/span&gt;&lt;span&gt; pause):
        direction &lt;/span&gt;=&lt;span&gt; direction_yes_no(direction, old_direction)
        old_direction &lt;/span&gt;=&lt;span&gt; direction
        front &lt;/span&gt;=&lt;span&gt; get_front(head, direction)
        alive &lt;/span&gt;=&lt;span&gt; ask_alive(front, body)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; alive:
            body.append(head)
            head &lt;/span&gt;=&lt;span&gt; front
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; food ==&lt;span&gt; head:
                food, alive &lt;/span&gt;=&lt;span&gt; new_food(head, body)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                body.pop(0)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            back_color &lt;/span&gt;=&lt;span&gt; BLOCK
            pygame.display.set_caption(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;游戏结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        times &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        times &lt;/span&gt;+= 1&lt;span&gt;

    screen.fill(back_color)
    new_draw_rect(food, RED, screen)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; body:
        new_draw_rect(i, BLUE, screen)
    new_draw_rect(head, GREEN, screen)

    fclock.tick(&lt;/span&gt;100&lt;span&gt;)
    pygame.display.update()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;↑↑↑↑&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;↑↑↑↑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;↑↑↑↑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 游戏结束或者暂停后因为times &amp;gt;= 100 and alive and (not pause)始终为假&lt;/p&gt;
&lt;p&gt;times += 1 一直运行,,,,会不会不太妥当&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 又不会溢出,,,,,,,,取消暂停时蛇能迅速跑起来要是time==100那问题就大了,,幸亏当初留了些余地写成 &amp;gt;=  &lt;/p&gt;
&lt;p&gt;(～￣▽￣)～ &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 蛇跑的太慢我想加速&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 上面的times&amp;gt;=100的100随便改一下就行&lt;/p&gt;
&lt;p&gt;0-&amp;gt;100动一动   变成    0-&amp;gt;80 动一动&lt;/p&gt;
&lt;p&gt;或者动前面的数&lt;/p&gt;
&lt;p&gt;0-&amp;gt;100动一动   变成    20-&amp;gt;100动一动&lt;/p&gt;
&lt;p&gt;或者将它设置成变量让它随蛇的长度变化而变化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打字太累,,&lt;/p&gt;
&lt;p&gt;direction那里可以使用0,1,2,3&lt;/p&gt;
&lt;p&gt;代替 up left down right&lt;/p&gt;
&lt;p&gt;键盘事件和get_front()得用同一套词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 第一个food的位置是固定的,不能&quot;动&quot;吗?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 因为我是先定义变量,再定义函数&lt;/p&gt;
&lt;p&gt;food = new_food(head,body)&lt;/p&gt;
&lt;p&gt;就得写在定义函数后面,&lt;span&gt;我不忍心让它一个变量孤单,,,&lt;/span&gt;,怕你看不到(写了但注释掉了)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动手术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面说过&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;问题1,什么时候动,这里有两个思路,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;间隔固定时间(1秒),动一次&lt;/li&gt;
&lt;li&gt;按一次键动一次,无操作一定时间(1秒)后,重复最后一次操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看起来第一种方案 &lt;span&gt;简单&lt;/span&gt; 不错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当初我以为第二种方案很难,,,&lt;/p&gt;
&lt;p&gt;写了这个博客后实力大增ᕦ( ᴼ ڡ ᴼ )ᕤ&lt;/p&gt;
&lt;p&gt;现在我不怕了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一个方法,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;处理按键事件后times = 100 ,例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
        direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        times &lt;/span&gt;= 100
    &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_LEFT:
        direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        times &lt;/span&gt;= 100  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;while循环当轮就能动一动&lt;/p&gt;
&lt;p&gt;隐藏操作 : 在0.01s内按下两个键,第一个按的不会&quot;生效&quot;&lt;/p&gt;
&lt;p&gt;pygame : 我得跑完事件列表的每个元素&lt;/p&gt;
&lt;p&gt;这是假的第二方案!!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二个方法,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把&quot;动一动&quot;的全部代码,打包成函数或者直接写在按键处理的后面&lt;/p&gt;
&lt;p&gt;就是上面times = 100的位置 例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
        direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;动一动&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_LEFT:
        direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;动一动&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;记住关键的一点times = 0也算&quot;动一动&quot;的内容,第二方案里,按键后计时需要清零!!!&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;if&lt;/span&gt; times &amp;gt;= 100 &lt;span&gt;and&lt;/span&gt; alive &lt;span&gt;and&lt;/span&gt; (&lt;span&gt;not&lt;/span&gt;&lt;span&gt; pause):
        direction &lt;/span&gt;=&lt;span&gt; direction_yes_no(direction, old_direction)
        old_direction &lt;/span&gt;=&lt;span&gt; direction
        front &lt;/span&gt;=&lt;span&gt; get_front(head, direction)
        alive &lt;/span&gt;=&lt;span&gt; ask_alive(front, body)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; alive:
            body.append(head)
            head &lt;/span&gt;=&lt;span&gt; front
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; food ==&lt;span&gt; head:
                food, alive &lt;/span&gt;=&lt;span&gt; new_food(head, body)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                body.pop(0)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            back_color &lt;/span&gt;=&lt;span&gt; BLOCK
            pygame.display.set_caption(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;游戏结束&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        times &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        times &lt;/span&gt;+= 1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了防止&quot;诈尸&quot;&lt;/p&gt;
&lt;p&gt;&quot;动一动&quot;前还得加上&lt;strong&gt;if alive and (not pause):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;times没必要加&lt;/p&gt;
&lt;p&gt;我就懒得管了(╥╯^╰╥)&lt;span&gt;这篇文章写了太长时间,现在已经看不懂当初的代码了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 不知道你是不是记得我,优化2就是我问的.....是这样的,我对我的方法还不死心....&quot;动手术&quot;改第二方案后能用吗?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; pygame.KEYDOWN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
                direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                   &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;改为&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; event.type ==&lt;span&gt; pygame.KEYDOWN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; event.key ==&lt;span&gt; pygame.K_UP:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; direction != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    direction &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 对于第一方法实现的第二方案还是会有小毛病&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;while循环当轮就能动一动&lt;/p&gt;
&lt;p&gt;隐藏操作 : 在0.01s内按下两个键,第一个按的不会&quot;生效&quot;&lt;/p&gt;
&lt;p&gt;pygame : 我得跑完事件列表的每个元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在0.01s内,按下两个键,就可以照旧触发【秘技: 撞脖子自杀】&lt;/p&gt;
&lt;p&gt;第二方法实现的应该没问题.......&lt;/p&gt;
&lt;p&gt; &lt;span&gt;完结撒花✿✿ヽ(°▽°)ノ✿&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 我想在加宽屏幕在右侧显示一下时间分数之类的信息,你还有什么&quot;交待&quot;吗?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 在pygame显示字体比较有难度....我只能祝你程序不出BUG...另外点(800,0)到点(800,600)别忘了画到线,提醒玩家&quot;边界&quot;还是存在的,让玩家摔键盘动怒就不好了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 我就是对你的颜色搭配有意见,颜色有点扎眼....&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : 我又不是美工,,,,,,,,,,,,颜色搭配的问题,应该,,,,,,,,,应该可以原谅,,,,,,,,,,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt; : 游戏太没挑战性,加点障碍物呗~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A&lt;/strong&gt; : walls 会在ask_alive()和new_food()用到,加个if的问题,,,,另外绘制屏幕那里多加个for,,,,,&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我就懒得管了(╥╯^╰╥)这篇文章写了太长时间,现在已经看不懂当初的代码了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完结撒花✿✿ヽ(°▽°)ノ✿&lt;/p&gt;
&lt;p&gt;这次真没了..✿✿ヽ(°▽°)ノ✿&lt;/p&gt;
&lt;p&gt;如有疏漏,欢迎补充&lt;/p&gt;
</description>
<pubDate>Fri, 23 Feb 2018 15:58:00 +0000</pubDate>
<dc:creator>ansver</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ansver/p/8438830.html</dc:identifier>
</item>
<item>
<title>word-wrap:break-word;和word-break:break-all;的区别 - 码上码出一片天</title>
<link>http://www.cnblogs.com/lshdashi/p/8463883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lshdashi/p/8463883.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　刚看到了这两个属性,心里一万句草泥马,怎么还有这么像的属性,不仅像还拗口,死记硬背肯定记混.所以就问了度娘把我的理解整理一下.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;首先&lt;/span&gt; 总说一下这两个属性的作用:&lt;span&gt;断句&lt;/span&gt;!&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　这两个属性作用于英文还有数字 ,浏览器把数字和长串的英文包括url地址会当做一个单词处理,如果该单词所在的行显示不下的话,就会整体换行处理.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   如果对于特别长单词不加上面的属性的样式,显示文本的区域就会溢出.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;像下面这样&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1257925/201802/1257925-20180223232049106-414903015.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1257925/201802/1257925-20180223232121451-1405677460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们来看看这个属性的具体作用.&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;word-wrap:break-word;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这个属性的意思就是:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果一个字符串太长,在第一行的文本后面显示不下,&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;则会另起一行,从第二行开始显示这个长字符串,第二行如果还显示不下,就会从区域边界处断开,把剩余的字符串显示到第三行.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不知道这么说能不能理解,简单写了一个的代码例子,参考着理解.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    p&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    word-wrap&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;break-word&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    hello 1111111111111111111111111111111
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码的执行效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1257925/201802/1257925-20180223232756100-1372014161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来不加&lt;span&gt;word-wrap:break-word;&lt;/span&gt;的效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1257925/201802/1257925-20180223232121451-1405677460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;break-word:break-all;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果遇到一个节俭的项目经理看见上面hello后面还有那么大的空间,他肯定不满意,说你浪费......没事不怕&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;现在来看看&lt;span&gt;break-word:break-all;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这个属性:如果该行的空间不够,仍然在该行显示,把超出的部分显示到下一行.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;话不多说上代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    p&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;word-wrap:break-word;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    word-break&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;break-all&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;orange&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    hello 1111111111111111111111111111111
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码的执行效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1257925/201802/1257925-20180223234334203-1686943759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来不加&lt;span&gt;word-break:break-all;的效果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1257925/201802/1257925-20180223232121451-1405677460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果那个节俭的项目经理看到你这样一定会表扬你的!(@-@)&lt;/p&gt;
&lt;h3&gt;至此,不知道各位大家是否明白了&lt;span&gt;word-wrap:break-word;&lt;/span&gt;和&lt;span&gt;word-break;break-all;&lt;/span&gt;的区别!&lt;/h3&gt;

&lt;h3&gt;小小总结!如有不正确之处,望大家留言指正!感谢!&lt;/h3&gt;

&lt;h3&gt;尊重原创!转载请注明出处!&lt;/h3&gt;

</description>
<pubDate>Fri, 23 Feb 2018 15:53:00 +0000</pubDate>
<dc:creator>码上码出一片天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lshdashi/p/8463883.html</dc:identifier>
</item>
<item>
<title>6.C++初步分析类 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8463881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8463881.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面向对象的意义在于&lt;/span&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;-&lt;span&gt;将日常生活中&lt;/span&gt;&lt;span&gt;习惯的思维方式引入程序设计中&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-&lt;span&gt;将需求中的慨念&lt;/span&gt;&lt;span&gt;直观的映射&lt;/span&gt;到解决方案中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-&lt;span&gt;以&lt;/span&gt;&lt;span&gt;模块为中心&lt;/span&gt;构建可复用的软件系统&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;-&lt;span&gt;提高软件产品的&lt;/span&gt;&lt;span&gt;可维护性和可扩展性&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其中&lt;span&gt;类和对象&lt;/span&gt;是面向对象中的两个基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;指的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;一类事物&lt;/strong&gt;&lt;/span&gt;,&lt;span&gt;里面包括不同对象实体&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是一个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;抽象的概念&lt;/strong&gt;&lt;/span&gt;,&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;程序语言&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-&lt;span&gt;对象&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;指的是类里的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;具体实体&lt;/strong&gt;&lt;/span&gt;,&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;程序语言&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;)-&amp;gt;java(&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;C#(&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-类&lt;/span&gt;&lt;/strong&gt;用于抽象的&lt;span&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/span&gt;一类事物所共有的&lt;span&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;strong&gt;行为&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;电脑&lt;/span&gt;,&lt;span&gt;都拥有&lt;/span&gt;&lt;span&gt;CPU/&lt;/span&gt;&lt;span&gt;主板&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;硬盘&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;共有属性&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;并且可以运行程序&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;共有行为&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-对象&lt;/strong&gt;&lt;/span&gt;指类里的具体事物&lt;/span&gt;,&lt;span&gt;并且拥有描述类中的一切共有属性和行为&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;神舟电脑G50-F5型号,CPU&lt;span&gt;是酷睿&lt;/span&gt;&lt;span&gt;i5,&lt;/span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;span&gt;8G,&lt;/span&gt;&lt;span&gt;硬盘&lt;/span&gt;&lt;span&gt;1TB&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;神舟电脑G60-F7型号,CPU&lt;span&gt;是酷睿&lt;/span&gt;&lt;span&gt;i7,&lt;/span&gt;&lt;span&gt;内存&lt;/span&gt;&lt;span&gt;16G,&lt;/span&gt;&lt;span&gt;硬盘&lt;/span&gt;&lt;span&gt;1TB+128GB(&lt;/span&gt;&lt;span&gt;固态硬盘&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;类下面&lt;strong&gt;&lt;span&gt;不一定&lt;/span&gt;&lt;/strong&gt;存在实际对象&lt;/span&gt;,&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;恐龙&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;对象已经灭绝&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;没有一个对象&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;类的对象&lt;strong&gt;&lt;span&gt;数目不确定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;,&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;电脑&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;该对象数目不确定&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;美国总统&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;该对象当今只有一个&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;类&lt;strong&gt;&lt;span&gt;不一定都来源&lt;/span&gt;&lt;/strong&gt;于现实生活&lt;/span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;类不是独立的&lt;/span&gt;,&lt;span&gt;&lt;strong&gt;&lt;span&gt;类与类&lt;/span&gt;&lt;/strong&gt;之间也&lt;strong&gt;&lt;span&gt;存在关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;电脑&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;包括了&lt;/span&gt;&lt;span&gt;CPU(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;主板&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;对象&lt;span&gt;&lt;strong&gt;不一定&lt;/strong&gt;&lt;/span&gt;只属于一个类&lt;/span&gt;,&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;二哈&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;既属于哺乳动物&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt;又属于犬科&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;类与类之间的关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;父类&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;子类&lt;/span&gt;&lt;/strong&gt;之间具有&lt;strong&gt;&lt;span&gt;继承关系&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;车&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;父类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;包括了汽车&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;子类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以这么理解&lt;/span&gt;,&lt;span&gt;汽车一定是车&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;但是车不一定是汽车&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;继承的&lt;strong&gt;&lt;span&gt;子类&lt;/span&gt;&lt;/strong&gt;拥有&lt;span&gt;&lt;strong&gt;父类&lt;/strong&gt;&lt;/span&gt;的&lt;strong&gt;&lt;span&gt;所有属性和行为&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;组合&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一些类的存在必须&lt;strong&gt;&lt;span&gt;依赖于其它的类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;这种关系&lt;strong&gt;&lt;span&gt;叫组合&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;比如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;电脑&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;包括了&lt;/span&gt;&lt;span&gt;CPU(&lt;/span&gt;&lt;span&gt;类&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;组合的类在某个局部上由其它的类组成&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;继承实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以现实生活中的生物类&lt;span&gt;为例&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201802/1182576-20180223233420138-1568020172.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;405&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如上图&lt;/strong&gt;&lt;strong&gt;,&lt;span&gt;在&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;又如何通过程序来表达出来呢&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;strong&gt;&lt;span&gt;struct&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;表达&lt;span&gt;&lt;strong&gt;类&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;,通过&lt;strong&gt;&lt;span&gt;:&lt;/span&gt;&lt;/strong&gt;表达&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;继承&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;所以可以将上图改进为&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1182576/201802/1182576-20180223233433644-607568236.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;144&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;又通过&lt;span&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/span&gt;表达&lt;strong&gt;&lt;span&gt;属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;,&lt;span&gt;通过&lt;strong&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/strong&gt;表达&lt;strong&gt;&lt;span&gt;行为&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最终将生活中的例子体现在&lt;/span&gt;C++&lt;span&gt;代码中&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;struct&lt;/span&gt; Biology { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生物类&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; living;
};
 
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Animal : Biology {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动物类继承于: 生物类&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; movable;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; findFood() { }
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Plant : Biology {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;植物类继承于: 生物类&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; growable;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Beast : Animal {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;禽兽继承于: 动物类&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sleep() { }
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Human : Animal {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;人类继承于: 动物类&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sleep() { }
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() { }
};
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;未完待续&lt;/span&gt;,&lt;span&gt;下章学习类与封装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Feb 2018 15:50:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8463881.html</dc:identifier>
</item>
<item>
<title>Spring基础篇——通过Java注解和XML配置装配bean - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/8457700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/8457700.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;自动化装配的确有很大的便利性，但是却并不能适用在所有的应用场景，比如需要装配的组件类不是由自己的应用程序维护，而是引用了第三方的类库，这个时候自动装配便无法实现，Spring对此也提供了相应的解决方案，那就是通过显示的装配机制——Java配置和XML配置的方式来实现bean的装配。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　Java配置类装配bean&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　我们还是借助上篇博文中的老司机开车的示例来讲解。Car接口中有开车的drive方法，该接口有两个实现——QQCar和BenzCar&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QQCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive() {
        System.out.println(&lt;/span&gt;&quot;开QQ车&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　既然是通过Java代码来装配bean,那就是不是我们上一篇讲的通过组件扫描的方式来发现应用程序中的bean的自动装配机制了，而是需要我们自己通过配置类来声明我们的bean。我们先通过@Configuration注解来创建一个Spring的配置类，该类中包含了bean的创建细节——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.QQCar;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Configuration 表明该类是Spring的一个配置类，该类中会包含应用上下文创建bean的具体细节
 * @Bean 告诉Spring该方法会返回一个要注册成为应用上下文中的bean的对象
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarConfig {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car laoSiJi() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QQCar();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;以上类中创建的bean实例默认情况下和方法名是一样的，我们也可以通过@Bean注解的name属性自定义ID,例如 &lt;span class=&quot;cnblogs_code&quot;&gt;@Bean(name = &quot;chenbenbuyi&quot;)&lt;/span&gt; ，那么在获取bean的时候根据你自己定义的ID获取即可。接着我们测试&lt;/span&gt;&lt;span&gt;——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.AnnotationConfigApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.config.CarConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarTest {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; carTest() {
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(CarConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据ID从容器容获取bean&lt;/span&gt;
        Car car = (Car) context.getBean(&quot;&lt;span&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;chenbenbuyi&lt;/span&gt;&lt;/span&gt;&quot;&lt;span&gt;);
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　以上测试能够成功输出，这就表明我们能够获取到QQCar的实例对象的，而这也是最简单的基于Java配置类来装配bean的示例了。但是你可能会说，明明是我们自己创建的Car的实例，怎么就成了Spring为我们创建的呢？好吧，我们把@Bean注解拿开，测试当然是无法通过，会抛NoSuchBeanDefinitionException异常。这里，你可能需要好好理解&lt;strong&gt;控制反转&lt;/strong&gt;的思想了：因为现在对于bean创建的控制权我们是交给了Spring容器的，如果没有@Bean注解，方法就只是一个普通方法，方法体返回的实例对象就不会注册到应用上下文（容器）中，也就说，Spring不会为我们管理该方法返回的实例对象，当我们在测试类中向容器伸手要对象的时候，自然就找不到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述示例过于简单，现在，我们要更进一步，给简单的对象添加依赖，来完成稍微复杂一点的业务逻辑。车是需要老司机来开的，于是我们同上篇一样定义一个Man类，Man的工作就是开车——&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man(Car car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;Car的对象实例是通过构造器注入，而Car的实例对象在配置类中通过方法laoSiJi()返回,所以我们在配置类中可以直接调用laoSiJi方法获取bean注入到Man的实例对象——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.BenzCar;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarConfig {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car laoSiJi() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BenzCar();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man work() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man(laoSiJi());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　测试类中通过上下文对象的getBean(&quot;work&quot;)方法就可以获取到Man的实例对象，从而完成对老司机开车的测试。或许，你会觉得，work方法是通过调用laoSiJi方法才获取的Car的实例的，实际上并非如此。因为有了@Bean注解&lt;/span&gt;&lt;span&gt;，&lt;strong&gt;Spring会拦截所有对该注解方法的调用，直接返回该方法创建的bean，也即容器中的管理的bean&lt;/strong&gt;。也就是说，laoSiJi方法返回的bean交给了Spring容器管理后，当其他地方需要实例对象的时候，是直接从容器中获取的第一次调用方法产生的实例对象，而不会重复的调用laoSiJi方法。我们可以如下测试——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.BenzCar;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;

@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarConfig {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car laoSiJi() {
        System.out.println(&lt;/span&gt;&quot;方法调用&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BenzCar();
    }

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man work() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man(laoSiJi());
    }

    @Bean   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man work2() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man(laoSiJi());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如上测试你会发现，虽然我定义了两个方法来获取Man实例，但是控制台只输出了一次调用打印，即证明方法只在最初返回bean的时候被调用了一次，而后的实例获取都是直接从容器中获取的。这也就是默认情况下Spring返回的实例都是单例的原因：一旦容器中注册了实例对象，应用程序需要的时候，就直接给予，不用重复创建。当然，很多情况下我们不会如上面的方式去引入依赖的bean,而可能会通过参数注入的方式，这样你就可以很灵活的使用不同的装配机制来满足对象之间的依赖关系，比如下面这种自动装配的方式给Man的实例注入依赖的Car对象——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;

@Configuration
@ComponentScan(&lt;/span&gt;&quot;spring.impl&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarConfig {

    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man work(Car car) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man(car);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;当然，如果你喜欢去简就繁，也可以通过XML配置文件配置依赖的bean。下面再来看看XML的方式如何装配bean。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　XML配置文件装配bean&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　使用XML配置文件的方式装配bean，首要的就是要创建一个基于Spring配置规范的XML文件，该配置文件以&amp;lt;beans&amp;gt;为根元素（相当于Java配置的@Configuration注解），包含一个或多个&amp;lt;bean&amp;gt;元素(相当于配置类中@Bean注解)。针对上文的汽车示例，如果改成XML配置就是这样——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过类的全限定名来声明要创建的bean&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，从基于XML的配置文件中加载上下文定义，我们就能根据ID获取到对应的bean了——&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarTest {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; carTest() {
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;resource/applicationContext.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;XML的方式如果没有明确给定ID，默认bean的ID会根据类的全限定名来命名，以#加计数序号的方式命名。&lt;/span&gt;
        Car car = (Car)context.getBean(&quot;spring.impl.BenzCar#0&quot;&lt;span&gt;);
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;当然，示例中使用自动化的命名ID看起来逼格满满，但其实并不实用，如果需要引用bean的实例就有点操蛋了，实际应用中当然还是要借助&amp;lt;bean&amp;gt;的id属性来自定义命名。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　　构造器注入&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　给&amp;lt;bean&amp;gt;元素设置id属性，在构建另外的对象实例的时候，就可以很方便的引用，譬如上面基于Java的配置中的构造器注入，XML中的同样这样实现——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过Man的构造器注入Car的实例对象&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;而有时候我们并不一定都是将对象的引用装配到依赖对象中，也可以简单的注入字面值——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String str;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man(String str ,Car car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.str =&lt;span&gt; str;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(str);
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;分别注入字面值和对象的应用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;陈本布衣&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;接着，我们继续对已有代码做些改动，将注入的参数改为Car的List集合——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; Man(List&amp;lt;Car&amp;gt;&lt;span&gt; cars) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cars =&lt;span&gt; cars;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　  那么配置文件就可以这样配置——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;qqCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.QQCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过&amp;lt;list&amp;gt;子元素实现List集合对象的装配&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;qqCar&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;如果是需要注入集合中的字面值，写法如下——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;qqCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.QQCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过&amp;lt;list&amp;gt;子元素实现List集合字面值的装配&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这里直接填写字面值&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;陈本布衣&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们可以采用同样的方式装配Set集合，只是&lt;strong&gt;Set集合会忽略掉重复的值，而且顺序也不保证&lt;/strong&gt;。此处不做演示。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　　属性注入&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　构造器注入是一种强依赖注入，而很多时候我们并不倾向于写那种依赖性太强的代码，而属性的Setter方法注入作为一种可选性依赖，在实际的开发中是应用得非常多的。上面Man类如果要通过属性注入的方式注入Car的实例，就该是这样子——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCar(Car car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;qqCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.QQCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通过属性注入的方式注入Car的实例&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;car&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　以上示例中，XML配置文件中属性注入的属性名必须要和Java类中Setter方法对应的属性名一致。而对于字面量的注入，和上面构造器的方式类似，只不过使用的元素名换成了&amp;lt;property&amp;gt;而已，下面仅做展示——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;str&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;字面量的注入&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;集合的字面量注入1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;集合的字面量注入2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.BenzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;qqCar&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.QQCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;属性注入的方式注入集合&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;cars&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;qqCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;benzCar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt; 　 三种装配方式的混合使用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 　　&lt;span&gt;在同一个应用程序中，Spring常见的这三种装配方式我们可能都会用到，而对于不同的装配方式，他们之间如何实现相互引用从而整合到一起的呢？我们先看看Java配置类的引用问题。试想如果Java配置类中的bean数量过多，我们可能会考虑拆分。在本文的示例中，Man类实例的创建必须通过构造器注入Car的实例，如果把两个实例的产生分成两个配置类，那么在依赖注入的配置类中可以通过@Import注解引入被依赖的配置类——&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Import;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;

@Configuration
@Import(CarConfig.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过@Import注解引入产生Car实例的配置类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ManConfig {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man work(Car car) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man(car);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　但是如果Car的实例不是通过Java类配置的，而是通过XML方式配置的方式配置，我们只需通过@ImportResource注解将配置bean的XML文件引入即可，只不过这个时候要保证XML中被依赖的bean的id要和Java配置类中的形参保持一致——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Bean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ImportResource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;

@Configuration
@ImportResource(&lt;/span&gt;&quot;classpath:resource/applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ManConfig {
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man work(Car car) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Man(car);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　&lt;span&gt;而如果bean是采用XML进行装配，如果需要装配的bean过多，我们当然还是会根据业务拆分成不同的配置文件，然后使用&amp;lt;improt&amp;gt;元素进行不同XML配置文件之间的引入，形如： &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;lt;&lt;span&gt;import&lt;/span&gt; resource=&quot;classpath:xxx.xml&quot; /&amp;gt;&lt;/span&gt; ；而如果要在XML中引入Java配置，只需将Java配置类当成普通的bean在XML中进行声明即可，但是在测试的时候要注意开启组件扫描，因为加载XML配置的上下文对象只会加载XML配置文件中的bean定义，无法让基于Java配置类产生bean的装配机制自动生效——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd &lt;br/&gt;　　　　http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;开启组件扫描，在测试的时候配置类才能向容器中注册类中声明的bean&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;spring&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;XML中引入Java配置类：将配置类声明为bean&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;spring.config.CarConfig&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;man&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;spring.impl.Man&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;laoSiJi&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　最后说一点，不管是Java配置还是XML配置，有个通常的做法就是创建一个比所有配置都更高层次的根配置类/文件，该配置不声明任何的bean，只用来将多个配置组合在一起，从而让配置更易于维护和扩展。好了，以上便是两种bean的装配方式的简单讲解，如有纰漏，欢迎指正，不胜感激。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Feb 2018 15:44:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/8457700.html</dc:identifier>
</item>
<item>
<title>python  路飞模块一考核总结 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8456010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8456010.html</guid>
<description>&lt;p&gt;1. 分别解释&quot;=&quot;,&quot;==&quot;,&quot;+=&quot;的含义（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
=为赋值语句，把一个变量值赋予另一个值
== 为条件判断，判断两个值是否相等
+= 为赋值   a+=1  意思就是a=a+1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.两个变量值的关系？（口述）&lt;br/&gt;　　n1 = 123456&lt;br/&gt;　　n2 = n1&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
将123456赋予n1，  然后将n1赋予n2, 意思就是n1 n2指向123456这个地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 请写出 “路飞学城” 分别用 utf-8 和 gbk 编码所占的位数（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
一个中文用utf-8 表示占3字节 GBK占2字节  
所以路飞学城用utf-8表示占12字节 GBK占8字节
其中12字节相当于96位 8字节64位
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 简述Python中的几种数据类型（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
数据类型分为：基本类型、数据集。
基本类型包括：数字类型（整形、长整型、浮点型、复数）、字符串类型、布尔类型。
数据集类型包括：列表、元祖、字典、集合。&lt;br/&gt;总体来说，数据类型分为数字，字符串，列表，字典，元祖，布尔，集合
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. 数据类型的可变与不可变分别有哪些？（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
可变：字符串、列表、集合、字典value
 不可变：数字、字符串、布尔、元祖、字典key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.元祖，列表，字典有没有长度的限制?（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
没有，根据内存大小定义。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7. 解释'and','or','not'（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
和C语音的与或非类似，and,or,not都为逻辑运算符
and表示两者都为TRUE，则为TRUE
or表示两者有一个判断为布尔TRUE 则结果为TRUE 反之则False
not 表示取反 如x为True，not x 则为False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;8. 元组和列表的区别（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
 元组又叫只读列表，不可改变，且无序。
 列表有序，并且可以修改。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9.列举一堆布尔值为False的情况（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
空列表 [],
空字典{},
空元祖(),
空字符串“”
0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10.python2和python3对于long（长整形）的区别。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
 python2中有整形int和long，int 32位系统最多只有32位，超出32位则为long。64位系统为64位。
 python3中全部为int。
 long在python中没有指定位宽。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;11.变量命名规范 ？（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
首字母不能是数字，并且变量名只能含有英文，数字，和下划线_&lt;br/&gt;1.变量名只能是 字母、数字或下划线的任意组合。&lt;br/&gt;2.变量名的第一个字符不能是数字。&lt;br/&gt;3.关键字不能声明为变量名。&lt;br/&gt;变量名不要过长，最好不要使用中文和拼音，还有不能乱起变量名，比如名不搭意。&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;12.阐述一下unicode和utf-8的区别（或者unicode在python3的作用）（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
 unicode又叫万国码，涵盖全世界的编码，所有字符和符号最少由16位（2个字节）表示，和别的编码有对应映射关系。
 utf-8对unicode进行了优化，uft-8对于英文只占用1个字节，欧洲字符2个字节，东亚字符3个字节，特殊字符4个字节。
 在python3中默认在内存存储代码的形式就是unicode，为了方便不同国家的人查看代码。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;13.深浅copy-引用和copy(),deepcopy()的区别（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
1.引用赋值的时候，指向同一个列表地址，如果a列表重新赋予别的列表，b还是指向之前的地址，b列表不改变，如果a列表里的值改变，那么b也会跟着改变。
2.当使用copy()的时候，相当于整个列表包括里面的东西一起完整拷贝给你，不是指向同一个地址，a里面的值改变，b列表不跟着改变。但是如果a列表是嵌套列表，嵌套列表里的值发生变化，拷贝的列表b里的嵌套
列表也会跟着改变，因为列表里的列表是指向同一个地址，相当于1.的情况
3.使用deepcopy()的话，列表里的数地址也会不一样，所以改变列表a里的嵌套列表的数，b也不会跟着改变。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;14.python2和python3的默认字符编码（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
python2默认字符编码是ASCII
python3默认编码是unicode
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;15.集合的特性（口述）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
确定性：元素必须可以hash。互异性：元素不可相同。无序性。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;16.列表['alex','egon','yuan','wusir','666']（编程）&lt;/p&gt;&lt;p&gt;   1.把666替换成999&lt;br/&gt;   2.获取&quot;yuan&quot;索引&lt;br/&gt;   3.假设不知道前面有几个元素，分片得到最后的三个元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
16.列表['alex','egon','yuan','wusir','666']（编程）

   1.把666替换成999
   2.获取&quot;yuan&quot;索引
   3.假设不知道前面有几个元素，分片得到最后的三个元素

li =['alex','egon','yuan','wusir','666']
li[-1] = '999'
print(li)
print(li.index('yuan'))
last3 = li[-3:]
print(last3)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17.对字典进行增删改查（编程）&lt;br/&gt;　　{&quot;Development&quot;:&quot;开发小哥&quot;,&quot;OP&quot;:&quot;运维小哥&quot;,&quot;Operate&quot;:&quot;运营小仙女&quot;,&quot;UI&quot;:&quot;UI小仙女&quot;}&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
dic = {&quot;Development&quot;:&quot;开发小哥&quot;,&quot;OP&quot;:&quot;运维小哥&quot;,&quot;Operate&quot;:&quot;运营小仙女&quot;,&quot;UI&quot;:&quot;UI小仙女&quot;}
#增
dic['manage']='alex'
print(dic)
#删
del dic['Development']
print(dic)
#改
dic['manage'] = 'oldboys'
print(dic)
#查看
find = dic.get(&quot;UI&quot;)
print(find)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;18.计算1+2+3...+98+99+100 （编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
#18.计算1+2+3...+98+99+100 （编程题）
# count = 1
# counts =0
# while count&amp;lt;=100:
#     counts=count+counts
#     print(counts)
#     count +=1
count =0
for i in range(1,101):
    count = count+i
print(count)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;19. 制作趣味模板程序（编程题）&lt;br/&gt;    需求：等待用户输入名字、地点、爱好，根据用户的名字和爱好进行任意现实&lt;br/&gt;    如：敬爱可爱的xxx，最喜欢在xxx地方干xxx&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 19. 制作趣味模板程序（编程题）
#     需求：等待用户输入名字、地点、爱好，根据用户的名字和爱好进行任意现实
#     如：敬爱可爱的xxx，最喜欢在xxx地方干xxx
#  
username = input(&quot;请输入名字&amp;gt;&amp;gt;&quot;)
userpalce = input(&quot;请输入地点&amp;gt;&amp;gt;&quot;)
userhobby = input(&quot;请输入爱好&amp;gt;&amp;gt;&quot;)
print(&quot;敬爱可爱的%s，最喜欢在%s地方干%s&quot;%(username,userpalce,userhobby))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;20.写一个三次认证（编程）&lt;br/&gt;实现用户输入用户名和密码,当用户名为 seven 或 alex 且 密码为 123 时,显示登陆成功,否则登陆失败,失败时允许重复输入三次&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 20.写一个三次认证（编程）
# 实现用户输入用户名和密码,当用户名为 seven 或 alex 且 密码为 123 时,显示登陆成功,
# 否则登陆失败,失败时允许重复输入三次
#  

_username1 = 'seven'
_username2 = 'alex'
_password = '123'

count =0
while count&amp;lt;3:
    username = input(&quot;名字&amp;gt;&amp;gt;&quot;)
    password = input(&quot;密码&amp;gt;&amp;gt;&quot;)
    if (username==_username1 or username==_username2) and password ==_password:
        print(&quot;登陆成功&quot;)
        break
    else:
        print(&quot;登陆失败&quot;)
    count+=1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;21.切割字符串&quot;luffycity&quot;为&quot;luffy&quot;,&quot;city&quot;（编程）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 21.切割字符串&quot;luffycity&quot;为&quot;luffy&quot;,&quot;city&quot;（编程）
info = &quot;luffycity&quot;
print(info[0:5])
print(info[5:])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;22.猜年龄游戏（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 22.猜年龄游戏（编程题）
age =20
count = 0
while count&amp;lt;3:
    user_age = input(&quot;请输入年龄&amp;gt;&amp;gt;&quot;)
    if user_age.isdigit() is True:
        if age == int(user_age):
            print(&quot;恭喜&quot;)
            break
        elif int(user_age) &amp;gt;age:
            print(&quot;猜大了，请重试&quot;)
        else:
            print(&quot;猜小了，再试试&quot;)
    else:
        print(&quot;请输入数字&quot;)
        pass
    count+=1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;23.求1～100间所有偶数的和（亦可奇数和，使用while循环写）（编程题）。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 23.求1～100间所有偶数的和（亦可奇数和，使用while循环写）（编程题）。
count =0
sumn=0
while count&amp;lt;=100:
    if count%2==0:
        sumn =count+sumn
    count+=1
print(sumn)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;24.从键盘接收一百分制成绩（0~100），要求输出其对应的成绩等级A~E。其中，90分以上为'A'，80~89分为'B'，70~79分为'C'，60~69分为'D'，60分以下为'E'。（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 24.从键盘接收一百分制成绩（0~100），要求输出其对应的成绩等级A~E。
# 其中，90分以上为'A'，80~89分为'B'，
# 70~79分为'C'，60~69分为'D'，
# 60分以下为'E'。（编程题）

usergrade = input(&quot;请输入成绩&amp;gt;&amp;gt;&quot;)
if usergrade.isdigit() is True:
    if int(usergrade)&amp;gt;=90:
        print(&quot;A&quot;)
    elif int(usergrade)&amp;gt;=80:
        print(&quot;B&quot;)
    elif int(usergrade)&amp;gt;=70:
        print(&quot;C&quot;)
    elif int(usergrade)&amp;gt;=60:
        print(&quot;D&quot;)
    else:
        print(&quot;E&quot;)
else:
    print(&quot;请输入数字&quot;)
    pass
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;25.输入一年份，判断该年份是否是闰年并输出结果。（该程序可以重复使用 使用while True）（编程题）&lt;br/&gt;     注：凡符合下面两个条件之一的年份是闰年。 （1） 能被4整除但不能被100整除。 （2） 能被400整除。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 25.输入一年份，判断该年份是否是闰年并输出结果。（该程序可以重复使用 使用while True）（编程题）
#      注：凡符合下面两个条件之一的年份是闰年。 （1） 能被4整除但不能被100整除。 （2） 能被400整除。
#  

while True:
    year_input = input(&quot;请输入年份&amp;gt;&amp;gt;&quot;)
    if year_input.isdigit() is True:
        if (int(year_input)%4 ==0 and int(year_input)%100!=0) or int(year_input)%400==0:
            print(&quot;闰年&quot;)
        else:
            print(&quot;平年&quot;)
    elif year_input == 'q':
        break
    else:
        pass
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;26.有如下字符串：n = &quot;路飞学城&quot;（编程题）&lt;/p&gt;&lt;p&gt;    - 将字符串转换成utf-8的字符编码，再将转换的字节重新转换为utf-8的字符编码&lt;br/&gt;    - 将字符串转换成gbk的字符编码，再将转换的字节重新转换为utf-8的字符编码&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 26.有如下字符串：n = &quot;路飞学城&quot;（编程题）
#
#     - 将字符串转换成utf-8的字符编码，再将转换的字节重新转换为utf-8的字符编码
#     - 将字符串转换成gbk的字符编码，再将转换的字节重新转换为utf-8的字符编码
#  
n = &quot;路飞学城&quot;
n8 = n.encode(encoding='utf-8')
print(&quot;转码为utf8&amp;gt;&amp;gt;%s&quot;%n8)
n9 = n8.decode(encoding='utf-8')
print(&quot;解码为utf8&amp;gt;&amp;gt;%s&quot;%n9)
ngbk = n.encode(encoding='gbk')
print(ngbk)
ndgbk = ngbk.decode(encoding='gbk')
print(ndgbk)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;27.将列表['alex', 'steven', 'egon'] 中的每一个元素使用 ‘\_’ 连接为一个字符串（编程）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 27.将列表['alex', 'steven', 'egon'] 中的每一个元素使用 ‘\_’ 连接为一个字符串（编程）
#  
li =['alex', 'steven', 'egon']
# a = (&quot;\_&quot;).join(li)
# print(a)
s ='\_'
print(s.join(li))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;28.自定义两个，并求交集，合集，差集。（编程）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
a1 ={3,4,5,6}
a2 ={1,2,3,4}
jiao =a1|a2
print(jiao)
cha = a1-a2
print(cha)
bing = a1&amp;amp;a2
print(bing)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;29.求100以内不能被3整除的所有数，并把这些数字放在列表sum3=[]里，并求出这些数字的总和和平均数。(计算的时候告诉学员，sum是一个关键词，不能当作变量)（编程）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 29.求100以内不能被3整除的所有数，并把这些数字放在列表sum3=[]里，
# 并求出这些数字的总和和平均数。(计算的时候告诉学员，sum是一个关键词，不能当作变量)（编程）
sum3 =[]
count =0
sums =0
while count&amp;lt;=100:
    if count%3!=0:
        sum3.append(count)
        sums =sums+count
    count+=1
print(sums)
print(sum3)
print(sums/len(sum3))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;30.根据字典内容打印出下面的形式（编程）&lt;br/&gt;可以不打印工整对齐的效果,主要是让学员获取key和value。&lt;br/&gt;{&quot;Development&quot;:&quot;开发小哥&quot;,&quot;OP&quot;:&quot;运维小哥&quot;,&quot;Operate&quot;:&quot;运营小仙女&quot;,&quot;UI&quot;:&quot;UI小仙女&quot;}&lt;br/&gt;效果如下：&lt;br/&gt;1. 删除了UI&lt;br/&gt;2. 修改了Operate&lt;/p&gt;&lt;p&gt;```&lt;br/&gt;Development --- 开发小哥&lt;br/&gt;OP --- 运维小哥&lt;br/&gt;Operate --- 小仙女&lt;br/&gt;```&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 30.根据字典内容打印出下面的形式（编程）
# 可以不打印工整对齐的效果,主要是让学员获取key和value。
# {&quot;Development&quot;:&quot;开发小哥&quot;,&quot;OP&quot;:&quot;运维小哥&quot;,&quot;Operate&quot;:&quot;运营小仙女&quot;,&quot;UI&quot;:&quot;UI小仙女&quot;}
# 效果如下：
# 1. 删除了UI
# 2. 修改了Operate
#
# ```
# Development --- 开发小哥
# OP --- 运维小哥
# Operate --- 小仙女
# ```
info ={&quot;Development&quot;:&quot;开发小哥&quot;,&quot;OP&quot;:&quot;运维小哥&quot;,&quot;Operate&quot;:&quot;运营小仙女&quot;,&quot;UI&quot;:&quot;UI小仙女&quot;}
del info['UI']
print(info)
info[&quot;Operate&quot;]='小仙女'
print(info)
# for items in info.items():
#     print(items)
for i in info:
    print(i+'----------'+info[i])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;31.假设一年期定期利率为3.25%，计算一下需要过多少年，一万元的一年定期存款连本带息能翻番？（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 31.假设一年期定期利率为3.25%，计算一下需要过多少年，一万元的一年定期存款连本带息能翻番？（编程题）
money = 10000
money = 10000
interest = money
count = 0
while True:
    count += 1
    interest = interest * (1 + 3.25 / 100)
    if interest // money == 2:
        print(count)
        break

money =10000
rate = 0.0324
years =0
while money&amp;lt;20000:
    years+=1
    money =money*(1+rate)
print(years)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;32.对列表进行增删改查（查可以是索引，值是否存在列表当中）。（编程）&lt;/p&gt;&lt;p&gt;['alex', 'egon', 'wusir', 'wen', 'jing']&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 32.对列表进行增删改查（查可以是索引，值是否存在列表当中）。（编程）
#
# ['alex', 'egon', 'wusir', 'wen', 'jing']
li =['alex', 'egon', 'wusir', 'wen', 'jing']
#增
li.append('wang')
print(li)
#删
li.remove('wang')
print(li)
del li[-1]
print(li)
#改
li[1] ='eeee'
print(li)
#查
print(li.index('alex'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;33.猜数游戏。预设一个0~9之间的整数，让用户猜一猜并输入所猜的数，如果大于预设的数，显示“太大”；小于预设的数，显示“太小”，如此循环，直至猜中该数，显示“恭喜！你猜中了！（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 33.猜数游戏。预设一个0~9之间的整数，让用户猜一猜并输入所猜的数，
# 如果大于预设的数，显示“太大”；小于预设的数，显示“太小”，
# 如此循环，直至猜中该数，显示“恭喜！你猜中了！（编程题）
the_number = 9
while 1:
    user_guess = input(&quot;猜猜 年龄》》&quot;)
    if user_guess.isdigit() is True:
        if the_number ==int(user_guess):
            print(&quot;祝贺&quot;)
            break
        elif int(user_guess) &amp;gt;the_number:
            print(&quot;太大&quot;)
        else:
            print(&quot;太小 &quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;34.编写一个python程序，输入两个数，比较它们的大小并输出其中较大者。（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 34.编写一个python程序，输入两个数，比较它们的大小并输出其中较大者。（编程题）
number1 = input(&quot;请输入一个数字》》&quot;)
number2 = input(&quot;请输入一个数字》》&quot;)
if number1.isdigit() is True and number2.isdigit() is True:
    if number1&amp;gt;number2:
        print(number1)
    else:
        print(number2)
else:
    print(&quot;输入错误，请重输&quot;)
    pass
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;35.有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？（编程题）&lt;br/&gt;      程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去 掉不满足条件的排列。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 35.有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数？各是多少？（编程题）
#       程序分析：可填在百位、十位、个位的数字都是1、2、3、4。
#             组成所有的排列后再去 掉不满足条件的排列。
nums =[]
for index1 in range(1,5):
    for index2 in range(1,5):
        for index3 in range(1,5):
            if index1!=index2 and index2 != index3 and index3 != index1:
                num = 100*index1 +10*index2 +index3
                if num not in nums:
                    nums.append(num)
print(nums)
print(len(nums))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;36.某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5, 然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 36.某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，
# 加密规则如下：每位数字都加上5, 然后用和除以10的余数代替该数字，
# 再将第一位和第四位交换，第二位和第三位交换。（编程题）
data = input(&quot;输入4个数字&amp;gt;&amp;gt;&quot;)
data =list(''.join(data))
print(data)
for index,i in enumerate(data):
    print(data[index])
    data[index] =(int(i)+5)%10

print(data)
data.reverse()
print(data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;37.求100以内的素数和。（编程题）&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
# 37.求100以内的素数和。（编程题）
# 素数：素数又称质数， 质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数的数称为质数。
# 思路：1.先将1~100的数量进行遍历，获得这个数是不是素数
#           2.除以这个小的整数（除了1和本身），获得余数，根据余数判断是否是素数
for i in range(1,100):
    a =1
    for j in range(int(i/2)):
        if (1+i)%(2+j) ==0:
            a =0
            break
    if a ==1:
        print(i+1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;38.二进制，十进制，十六进制互相转换（计算题，让学员使用计算器，别用编程的内置方法）&lt;br/&gt;十进制转二进制：bin()&lt;br/&gt;十进制转十六进制：hex()&lt;br/&gt;十进制转八进制：oct()&lt;br/&gt;二进制转10进制：如1010： 相当于8+2=10&lt;br/&gt;十六进制转二进制：如0x9a:相当于10011010 再转10进制就是 对应&lt;br/&gt;1 1 1 1 1 1 1 1&lt;br/&gt;128 64 32 16 8 4 2 1 10011010=128+16+8+2=154&lt;/p&gt;

&lt;p&gt;39.企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；&lt;br/&gt;　　利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；&lt;br/&gt;　　20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；&lt;br/&gt;　　60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，&lt;br/&gt;　　从键盘输入当月利润I，求应发放奖金总数？（编程）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;collapse:true;;gutter:true;&quot;&gt;
while True:
     money = input('利润：')
     if money.isdigit() == True:
          if int(money) &amp;lt;= 100000:
               print(&quot;奖金为：%s&quot;%(int(money)*10/100))
          elif int(money) &amp;lt;= 200000:
               print(&quot;奖金为：%s&quot;%(((int(money)-100000)*7.5/100)+100000*10/100))
          elif int(money) &amp;lt;= 400000:
               print(&quot;奖金为：%s&quot; % (((int(money) - 200000) * 5 / 100)))
          elif int(money) &amp;lt;= 600000:
               print(&quot;奖金为：%s&quot; % (((int(money) - 400000) * 3/ 100)))
          elif int(money) &amp;lt;= 1000000:
               print(&quot;奖金为：%s&quot; % (((int(money) - 600000) * 1.5/ 100)))
          else :
               print(&quot;奖金为：%s&quot; % (((int(money) - 600000) * 1/ 100)))
          break
     else:
          money = input('输入错误，请重新输入：')
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 23 Feb 2018 15:18:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8456010.html</dc:identifier>
</item>
<item>
<title>【css3】旋转倒计时 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/8463684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/8463684.html</guid>
<description>&lt;p&gt;很多答题的H5界面上有旋转倒计时的效果，一个不断旋转减少的动画，类似于下图的这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201802/417688-20180223215943309-576612275.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天研究了下，可以通过border旋转得到。一般我们可以通过border得到一个四段圆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201802/417688-20180223230655283-338666359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;rJrrjZ&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;stoneniqiu&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;circle&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/stoneniqiu/pen/rJrrjZ/&quot;&gt;circle&lt;/a&gt; by stoneniqiu (&lt;a href=&quot;https://codepen.io/stoneniqiu&quot;&gt;@stoneniqiu&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt; 接下来接可以通过旋转的方式形成一个倒计时的效果：&lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;oEMMpN&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;stoneniqiu&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;circle-rotate&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/stoneniqiu/pen/oEMMpN/&quot;&gt;circle-rotate&lt;/a&gt; by stoneniqiu (&lt;a href=&quot;https://codepen.io/stoneniqiu&quot;&gt;@stoneniqiu&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt; 一开始旋转45度是为了让半圆刚好立起来。然后旋转一百八十度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  .rightcircle&lt;/span&gt;{&lt;span&gt;
                border-top&lt;/span&gt;:&lt;span&gt; .4rem solid #8731fd&lt;/span&gt;;&lt;span&gt;
                border-right&lt;/span&gt;:&lt;span&gt; .4rem solid #8731fd&lt;/span&gt;;&lt;span&gt;
                right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;&lt;span&gt;
                transform&lt;/span&gt;:&lt;/span&gt;&lt;span&gt;&lt;span&gt; rotate(45deg&lt;/span&gt;)
            &lt;/span&gt;}&lt;span&gt;
 .right_cartoon &lt;/span&gt;{&lt;span&gt;
                -webkit-animation&lt;/span&gt;:&lt;span&gt; circleProgressLoad_right 10s linear infinite forwards&lt;/span&gt;;&lt;span&gt;
                animation&lt;/span&gt;:&lt;span&gt; circleProgressLoad_right 10s linear infinite forwards&lt;/span&gt;;
            }&lt;span&gt;
 @keyframes circleProgressLoad_right &lt;/span&gt;{&lt;span&gt;
                0% {
                    -webkit-transform&lt;/span&gt;:&lt;span&gt; rotate(46deg)&lt;/span&gt;;&lt;span&gt;
                    transform&lt;/span&gt;:&lt;span&gt; rotate(46deg)
                &lt;/span&gt;}&lt;span&gt;
                50%,to &lt;/span&gt;{&lt;span&gt;
                    -webkit-transform&lt;/span&gt;:&lt;span&gt; rotate(-136deg)&lt;/span&gt;;&lt;span&gt;
                    transform&lt;/span&gt;:&lt;span&gt; rotate(-136deg)
                &lt;/span&gt;}&lt;span&gt;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;毕竟不是真正的减少，要出现一种颜色占大多数就可以通过两个半圆来拼凑。&lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;RQBBEo&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;stoneniqiu&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;circle-timer&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/stoneniqiu/pen/RQBBEo/&quot;&gt;circle-timer&lt;/a&gt; by stoneniqiu (&lt;a href=&quot;https://codepen.io/stoneniqiu&quot;&gt;@stoneniqiu&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot;&gt;CodePen&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;codepen&quot; data-height=&quot;265&quot; data-theme-id=&quot;0&quot; data-slug-hash=&quot;RQBBEo&quot; data-default-tab=&quot;css,result&quot; data-user=&quot;stoneniqiu&quot; data-embed-version=&quot;2&quot; data-pen-title=&quot;circle-timer&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201802/417688-20180223230843791-686257820.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @keyframes circleProgressLoad_left &lt;/span&gt;{&lt;span&gt;&lt;span&gt;
                0%,50%&lt;/span&gt; {
                    -webkit-transform&lt;/span&gt;:&lt;span&gt; rotate(46deg)&lt;/span&gt;;&lt;span&gt;
                    transform&lt;/span&gt;:&lt;span&gt; rotate(46deg)
                &lt;/span&gt;}&lt;span&gt;
            
                to &lt;/span&gt;{&lt;span&gt;
                    -webkit-transform&lt;/span&gt;:&lt;span&gt; rotate(-136deg)&lt;/span&gt;;&lt;span&gt;
                    transform&lt;/span&gt;:&lt;span&gt; rotate(-136deg)
                &lt;/span&gt;}&lt;span&gt;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到是右边线转5秒，然后左边再等五秒，这里css动画的效果略有不同，右边是0%开始，50%,to。左边是0%,50%，然后to，这样实现的5秒等待。这就是旋转倒计时的效果，最后还可以通过修改左半环border-left的颜色，来凸显最后几秒钟的紧急情况。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Feb 2018 15:03:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/8463684.html</dc:identifier>
</item>
<item>
<title>OpenCV角点检测源代码分析（Harris和ShiTomasi角点） - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/8463763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/8463763.html</guid>
<description>&lt;p&gt;&lt;span&gt;OpenCV中常用的角点检测为Harris角点和ShiTomasi角点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以OpenCV源代码文件 .\opencv\sources\samples\cpp\tutorial_code\TrackingMotion\cornerDetector_Demo.cpp为例，主要分析其中的这两种角点检测源代码。角点检测&lt;strong&gt;数学原理&lt;/strong&gt;请参考我之前转载的一篇博客 &lt;a href=&quot;http://www.cnblogs.com/riddick/p/7645904.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/riddick/p/7645904.html&lt;/a&gt;，分析的很详细，不再赘述。本文主要分析其源代码：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1. Harris角点检测&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　根据数学上的推导，可以根据图像中某一像素点邻域内构建的协方差矩阵获取特征值和特征向量，根据特征值建立特征表达式，如下：&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
(αβ) - k(α+β)^&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　可以根据上式的值得大小来判断该像素点是平坦区域内点、边界点还是角点。下面说一下怎么在原图像中建立协方差矩阵并求取特征值α和β和特征向量t1, t2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该&lt;/span&gt;&lt;span&gt;例程代码中调用cornerEigenValsAndVecs（）函数计算特征值和特征向量。函数原型如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; cv::cornerEigenValsAndVecs( InputArray _src, OutputArray _dst, &lt;span&gt;int&lt;/span&gt; blockSize, &lt;span&gt;int&lt;/span&gt; ksize, &lt;span&gt;int&lt;/span&gt; borderType )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　src为输入灰度图像，dst为输出（6通道 CV_32FC(6)，依次保存的是α， t1,  β， t2），blockSize为邻域大小，ksize为sobel求取微分时的窗口大小。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该函数内部调用cornerEigenValsVecs（）函数，原型如下：&lt;/span&gt;　             &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  cornerEigenValsVecs( &lt;span&gt;const&lt;/span&gt; Mat&amp;amp; src, Mat&amp;amp; eigenv, &lt;span&gt;int&lt;/span&gt; block_size,&lt;span&gt;int&lt;/span&gt; aperture_size, &lt;span&gt;int&lt;/span&gt; op_type, &lt;span&gt;double&lt;/span&gt; k=&lt;span&gt;0&lt;/span&gt;.,&lt;span&gt;int&lt;/span&gt; borderType=BORDER_DEFAULT )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;　&lt;span&gt;　主要介绍一下op_type这个参数，该参数是一个枚举值，有三个值可以选择（MINEIGENVAL， HARRIS， EIGENVALSVECS）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;①MINEIGENVAL用于ShiTomasi角点检测中获取两个特征值中较小的那个值，用以获取强角点，随后介绍；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　②HARRIS在cornerHarris（）函数中用到，用于直接利用协方差矩阵获取特征表达式值的大小，k值在此时会被设置，通常为0.04，其他情况下设置为0；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　③EIGENVALSVECS就是本例程中设置的，求取两个特征值和特征向量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　在cornerEigenValsVecs（）函数中，先利用sobel算子求水平方向和竖直方向的微分，窗口大小为前述，如下代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Mat Dx, Dy;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( aperture_size &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
    {
        Sobel( src, Dx, CV_32F, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, aperture_size, scale, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, borderType );
        Sobel( src, Dy, CV_32F, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, aperture_size, scale, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, borderType );
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Scharr( src, Dx, CV_32F, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, scale, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, borderType );
        Scharr( src, Dy, CV_32F, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, scale, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, borderType );
    }&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　然后初始化协方差矩阵cov（三通道，依次保存dx*dx, dx*dy, dy*dy），如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;( ; j &amp;lt; size.width; j++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; dx =&lt;span&gt; dxdata[j];
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; dy =&lt;span&gt; dydata[j];

            cov_data[j&lt;/span&gt;*&lt;span&gt;3&lt;/span&gt;] = dx*&lt;span&gt;dx;
            cov_data[j&lt;/span&gt;*&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = dx*&lt;span&gt;dy;
            cov_data[j&lt;/span&gt;*&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;] = dy*&lt;span&gt;dy;
        }&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来对协方差矩阵进行在前述设定窗口内进行均值（盒式）滤波：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    boxFilter(cov, cov, cov.depth(), Size(block_size, block_size),
        Point(&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, borderType );

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( op_type ==&lt;span&gt; MINEIGENVAL )
        calcMinEigenVal( cov, eigenv );
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( op_type ==&lt;span&gt; HARRIS )
        calcHarris( cov, eigenv, k );
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( op_type ==&lt;span&gt; EIGENVALSVECS )
        calcEigenValsVecs( cov, eigenv );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;然后就是利用滤波后的协方差矩阵求取特征值和特征向量了，根据设定不同的op_type调用不同的函数计算，本例程中为调用最后一个calcEigenValsVecs（）函数，该函数如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; calcEigenValsVecs( &lt;span&gt;const&lt;/span&gt; Mat&amp;amp; _cov, Mat&amp;amp;&lt;span&gt; _dst )
{
    Size size &lt;/span&gt;=&lt;span&gt; _cov.size();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( _cov.isContinuous() &amp;amp;&amp;amp;&lt;span&gt; _dst.isContinuous() )
    {
        size.width &lt;/span&gt;*=&lt;span&gt; size.height;
        size.height &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size.height; i++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;* cov = _cov.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* dst = _dst.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);&lt;br/&gt;&lt;span&gt;
        //调用该函数计算2x2协方差矩阵的特征值和特征向量&lt;/span&gt;
        eigen2x2(cov, dst, size.width);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　该函数中调用eigen2x2（）函数计算每个像素点处协方差矩阵的2个特征值和2个特征向量， 该函数如下：2x2矩阵特征值和特征向量的计算，有线性代数基础的都学过，就不再赘述&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; eigen2x2( &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;* cov, &lt;span&gt;float&lt;/span&gt;* dst, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n )
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; n; j++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a = cov[j*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b = cov[j*&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; c = cov[j*&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; u = (a + c)*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; v = std::sqrt((a - c)*(a - c)*&lt;span&gt;0.25&lt;/span&gt; + b*&lt;span&gt;b);&lt;br/&gt;　　　　　&lt;br/&gt;　　　　　&lt;span&gt;//计算两个特征值l1,l2
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; l1 = u +&lt;span&gt; v;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; l2 = u -&lt;span&gt; v;&lt;br/&gt;　　　　　&lt;span&gt;//计算特征值l1对应的特征向量
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x =&lt;span&gt; b;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = l1 -&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; e =&lt;span&gt; fabs(x);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( e + fabs(y) &amp;lt; 1e-&lt;span&gt;4&lt;/span&gt;&lt;span&gt; )
        {
            y &lt;/span&gt;=&lt;span&gt; b;
            x &lt;/span&gt;= l1 -&lt;span&gt; c;
            e &lt;/span&gt;=&lt;span&gt; fabs(x);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( e + fabs(y) &amp;lt; 1e-&lt;span&gt;4&lt;/span&gt;&lt;span&gt; )
            {
                e &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;./(e + fabs(y) +&lt;span&gt; FLT_EPSILON);
                x &lt;/span&gt;*= e, y *=&lt;span&gt; e;
            }
        }

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d = &lt;span&gt;1&lt;/span&gt;./std::sqrt(x*x + y*y +&lt;span&gt; DBL_EPSILON);&lt;br/&gt;&lt;span&gt;//保存特征值l1及其对应的特征向量&lt;/span&gt;
        dst[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;*j] = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)l1;
        dst[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;*j + &lt;span&gt;2&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;)(x*&lt;span&gt;d);
        dst[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;*j + &lt;span&gt;3&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;)(y*&lt;span&gt;d);&lt;br/&gt;&lt;span&gt; //计算特征值l2对应的特征向量&lt;/span&gt;
        x &lt;/span&gt;=&lt;span&gt; b;
        y &lt;/span&gt;= l2 -&lt;span&gt; a;
        e &lt;/span&gt;=&lt;span&gt; fabs(x);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( e + fabs(y) &amp;lt; 1e-&lt;span&gt;4&lt;/span&gt;&lt;span&gt; )
        {
            y &lt;/span&gt;=&lt;span&gt; b;
            x &lt;/span&gt;= l2 -&lt;span&gt; c;
            e &lt;/span&gt;=&lt;span&gt; fabs(x);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( e + fabs(y) &amp;lt; 1e-&lt;span&gt;4&lt;/span&gt;&lt;span&gt; )
            {
                e &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;./(e + fabs(y) +&lt;span&gt; FLT_EPSILON);
                x &lt;/span&gt;*= e, y *=&lt;span&gt; e;
            }
        }

        d &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;./std::sqrt(x*x + y*y +&lt;span&gt; DBL_EPSILON);&lt;br/&gt;&lt;span&gt;//保存特征值l2及其对应的特征向量&lt;/span&gt;
        dst[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;*j + &lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)l2;
        dst[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;*j + &lt;span&gt;4&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;)(x*&lt;span&gt;d);
        dst[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;*j + &lt;span&gt;5&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;)(y*&lt;span&gt;d);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;span&gt;　　求得2个特征值α、β和2个特征向量之后，就是要利用特征值构建特征表达式，通过表达式的值（  (αβ) - k(α+β)^2   ）来区分角点，k的值通常设置为0.04：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; calculate Mc &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; src_gray.rows; j++&lt;span&gt; )
     { &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; src_gray.cols; i++&lt;span&gt; )
          {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; lambda_1 = myHarris_dst.at&amp;lt;Vec6f&amp;gt;(j, i)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; lambda_2 = myHarris_dst.at&amp;lt;Vec6f&amp;gt;(j, i)[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            Mc.at&lt;/span&gt;&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(j,i) = lambda_1*lambda_2 - &lt;span&gt;0.04f&lt;/span&gt;*pow( ( lambda_1 + lambda_2 ), &lt;span&gt;2&lt;/span&gt;&lt;span&gt; );
          }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;代码中利用 &lt;span class=&quot;cnblogs_code&quot;&gt;minMaxLoc( Mc, &amp;amp;myHarris_minVal, &amp;amp;myHarris_maxVal, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, Mat() );&lt;/span&gt; 函数获取特征表达式的最大值min和最小值max，通过选取不同的阈值min&amp;lt;=thresh&amp;lt;=max，来指定大于阈值thresh的表达式值对应的点为检测出的角点。并利用circle（）函数显示出来。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
circle( myHarris_copy, Point(i,j), &lt;span&gt;4&lt;/span&gt;, Scalar( rng.uniform(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;), rng.uniform(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;), rng.uniform(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;255&lt;/span&gt;) ), -&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt; ); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt; 至此，Harris角点检测完成！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt; 2. ShiTomasi角点检测&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;ShiTomasi角点提取是获取harris角点中的强角点，怎么获取强角点呢，那就是只选取两个特征值中&lt;strong&gt;较小的那个特征值&lt;/strong&gt;构建特征表达式，如果较小的特征值都能够满足设定的阈值条件，那么该角点就视为强角点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;调用  &lt;span class=&quot;cnblogs_code&quot;&gt;cornerMinEigenVal( src_gray, myShiTomasi_dst, blockSize, apertureSize, BORDER_DEFAULT );&lt;/span&gt; 函数来获取较小的特征值，其实该函数内部依然调用上面所述的函数 &lt;span class=&quot;cnblogs_code&quot;&gt;cornerEigenValsVecs( src, dst, blockSize, ksize, MINEIGENVAL, &lt;span&gt;0&lt;/span&gt;, borderType );&lt;/span&gt; ，然后将op_type设置为MINEIGENVAL枚举值，进而调用 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; calcMinEigenVal( &lt;span&gt;const&lt;/span&gt; Mat&amp;amp; _cov, Mat&amp;amp; _dst )&lt;/span&gt; 函数计算较小的特征值。该函数代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; calcMinEigenVal( &lt;span&gt;const&lt;/span&gt; Mat&amp;amp; _cov, Mat&amp;amp;&lt;span&gt; _dst )
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j;
    Size size &lt;/span&gt;=&lt;span&gt; _cov.size();
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; CV_TRY_AVX
    &lt;span&gt;bool&lt;/span&gt; haveAvx =&lt;span&gt; CV_CPU_HAS_SUPPORT_AVX;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;#if&lt;/span&gt; CV_SIMD128
    &lt;span&gt;bool&lt;/span&gt; haveSimd =&lt;span&gt; hasSIMD128();
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt;( _cov.isContinuous() &amp;amp;&amp;amp;&lt;span&gt; _dst.isContinuous() )
    {
        size.width &lt;/span&gt;*=&lt;span&gt; size.height;
        size.height &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size.height; i++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;* cov = _cov.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* dst = _dst.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; CV_TRY_AVX
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;( haveAvx )
            j &lt;/span&gt;=&lt;span&gt; calcMinEigenValLine_AVX(cov, dst, size.width);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CV_TRY_AVX&lt;/span&gt;&lt;span&gt;
            j &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; CV_SIMD128
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;( haveSimd )
        {
            v_float32x4 half &lt;/span&gt;= v_setall_f32(&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( ; j &amp;lt;= size.width - v_float32x4::nlanes; j +=&lt;span&gt; v_float32x4::nlanes )
            {
                v_float32x4 v_a, v_b, v_c, v_t;
                v_load_deinterleave(cov &lt;/span&gt;+ j*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, v_a, v_b, v_c);
                v_a &lt;/span&gt;*=&lt;span&gt; half;
                v_c &lt;/span&gt;*=&lt;span&gt; half;
                v_t &lt;/span&gt;= v_a -&lt;span&gt; v_c;
                v_t &lt;/span&gt;= v_muladd(v_b, v_b, (v_t *&lt;span&gt; v_t));
                v_store(dst &lt;/span&gt;+ j, (v_a + v_c) -&lt;span&gt; v_sqrt(v_t));
            }
        }
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CV_SIMD128&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt;( ; j &amp;lt; size.width; j++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; a = cov[j*&lt;span&gt;3&lt;/span&gt;]*&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; b = cov[j*&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; c = cov[j*&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;]*&lt;span&gt;0.5f&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;;&lt;p&gt;&lt;span&gt;//求根公式计算较小的根，即为较小的特征值&lt;/span&gt;
            dst[j] &lt;/p&gt;&lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)((a + c) - std::sqrt((a - c)*(a - c) + b*&lt;span&gt;b));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;所有像素点处较小的特征值求出后利用 &lt;span class=&quot;cnblogs_code&quot;&gt;minMaxLoc( Mc, &amp;amp;myHarris_minVal, &amp;amp;myHarris_maxVal, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, Mat() );&lt;/span&gt; 函数选取最小的min和最大的max，通过调整阈值thresh来设定大于阈值thresh的为显示出来的强角点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 至此，ShiTomasi角点检测完成！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Feb 2018 14:50:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/8463763.html</dc:identifier>
</item>
<item>
<title>超级简便的容器化部署工具（使用 ASP.NET Core 演示） - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/8463663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/8463663.html</guid>
<description>&lt;p&gt;Docker 改变了我们部署网站的方式，从原先的手动编译打包上传，到现在的构建镜像然后推送部署，让我们在配置环境上所花费的时间大大减少了。不仅如此，通过一系列相关的工具配合，可以很轻松的实现 CI、CD。本文即将介绍的就是这么一款非常简便的工具——captainduckduck，使用 captainduckduck 只需要很少的 Docker 知识。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;原先，我们的部署流程可能是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;拉取代码 -&amp;gt; 构建镜像 -&amp;gt; 启动容器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，还需要配置 HTTPS，配置反向代理，如果要更新应用的话，还需要手动去执行一遍部署流程，先不说一遍一遍执行这些个东西挺枯燥的，再一个，当同一台服务器上托管的网站多了，时间一长，可能反向代理的端口号都记不清，之后再部署新的网站，还得把 nginx 配置文件看一遍。&lt;/p&gt;
&lt;p&gt;幸运的是，我无意间发现了 captainduckduck， 这是一个能够极大的简化我们使用 Docker 部署 Web 服务步骤的工具，完美的击中了上面提到的痛点，而且使用起来非常的简单。captainduckduck 是对 Docker swarm 技术一个较好的封装，提供了一个 Web 面板以及一个客户端命令行工具，即使用户完全没有接触过 Docker Swarm 甚至没怎么用过 nginx、Docker，也能够轻松的部署网站。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;首先需要准备这些东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个支持泛解析的域名&lt;/li&gt;
&lt;li&gt;一台安装好了 Docker 17.06.x 的 Linux 服务器（最低配置 1核1G）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在校大学生可以使用腾讯云或者阿里云提供的学生套餐，其中包含不少于 1G 内存的服务器跟一年的域名，也不贵，每月支出一两顿饭钱而已。&lt;/p&gt;
&lt;h2 id=&quot;安装-captain-服务端&quot;&gt;安装 Captain 服务端&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /captain
docker run -v /var/run/docker.sock:/var/run/docker.sock dockersaturn/captainduckduck&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上面的两条 shell 命令并等待执行结束，就完成了服务端的部署，啊，就是这么简单。然后你就可以在浏览器里访问：&lt;code&gt;http://[IP_OF_YOUR_SERVER]:3000&lt;/code&gt; Web 面板了。使用默认密码登陆后，就可以来配置服务端了。&lt;/p&gt;
&lt;h2 id=&quot;配置服务端&quot;&gt;配置服务端&lt;/h2&gt;
&lt;p&gt;首先在你的域名解析处添加一个 A 记录：&lt;code&gt;*.something&lt;/code&gt;，IP 指向安装了 captainduckduck 的服务器。然后在 Web 面板的 Dashboard 页面设置 &lt;strong&gt;Captain Root Domain&lt;/strong&gt;：&lt;code&gt;something.example.com&lt;/code&gt;。同时，你还可以启用 HTTPS，captainduckduck 会自动的使用 Let's Encrypt 给你的域名加上一个 HTTPS 证书。添加好根域名后，captainduckduck 会给 Web 面板分配一个用来直接访问的域名：&lt;code&gt;captain.something.example.com&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至此，captainduckduck 就已经部署完毕了，让我们测试一下，切换到 Apps 页面，点击 &lt;strong&gt;OneClick Apps/Databases&lt;/strong&gt;，在下拉列表中选择 WordPress，然后按照表单填写数据库相关的信息，稍等几分钟，就可以一键部署一个 WordPress 站点了。这里是我运行好的：&lt;a href=&quot;https://test-wp.app.gianthard.rocks/&quot; class=&quot;uri&quot;&gt;https://test-wp.app.gianthard.rocks/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署-asp.net-core-网站&quot;&gt;部署 ASP.NET Core 网站&lt;/h2&gt;
&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;
&lt;p&gt;captainduckduck 默认并不支持 ASP.NET Core 网站的一键部署，需要自己动手写一个 &lt;code&gt;Dockerfile&lt;/code&gt;，不过好在微软已经给了标准样例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Sample contents of Dockerfile&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Stage 1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; microsoft/aspnetcore-build AS builder
&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /source

&lt;span class=&quot;co&quot;&gt;# caches restore result by copying csproj file separately&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; ./src/*.csproj .
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; cd ./src &amp;amp;&amp;amp; dotnet restore

&lt;span class=&quot;co&quot;&gt;# copies the rest of your code&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; ./src/ .
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; cd ./src &amp;amp;&amp;amp; dotnet publish --output /app/ --configuration Release

&lt;span class=&quot;co&quot;&gt;# Stage 2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; microsoft/aspnetcore
&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /app
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; --from=builder /app .
&lt;span class=&quot;kw&quot;&gt;ENTRYPOINT&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;dotnet&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;myapp.dll&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的网站使用了现代前端框架的服务端渲染技术，你可以使用下面的 &lt;code&gt;Dockerfile&lt;/code&gt; 样例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Sample contents of Dockerfile&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# Stage 1&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; microsoft/aspnetcore-build AS builder
&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /source

&lt;span class=&quot;co&quot;&gt;# caches restore result by copying csproj file separately&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; ./src/*.csproj .
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; ./src/package.json .
&lt;span class=&quot;co&quot;&gt;# 如果你的服务器网络不好，请自行在这里修改 npm 仓库&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; cd ./src &amp;amp;&amp;amp; dotnet restore &amp;amp;&amp;amp; npm i

&lt;span class=&quot;co&quot;&gt;# copies the rest of your code&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; ./src/ .
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; cd ./src &amp;amp;&amp;amp; dotnet publish --output /app/ --configuration Release

&lt;span class=&quot;co&quot;&gt;# Stage 2&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; microsoft/aspnetcore:2.0.5
&lt;span class=&quot;kw&quot;&gt;ENV&lt;/span&gt; NODE_VERSION 9.3.0

&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; curl -SLO &lt;span class=&quot;st&quot;&gt;&quot;https://mirrors.ustc.edu.cn/node/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz&quot;&lt;/span&gt; \
  &amp;amp;&amp;amp; curl -SLO --compressed &lt;span class=&quot;st&quot;&gt;&quot;https://mirrors.ustc.edu.cn/node/v$NODE_VERSION/SHASUMS256.txt&quot;&lt;/span&gt; \
  &amp;amp;&amp;amp; grep &lt;span class=&quot;st&quot;&gt;&quot; node-v$NODE_VERSION-linux-x64.tar.gz\$&quot;&lt;/span&gt; SHASUMS256.txt | sha256sum -c - \
  &amp;amp;&amp;amp; tar -xf &lt;span class=&quot;st&quot;&gt;&quot;node-v$NODE_VERSION-linux-x64.tar.gz&quot;&lt;/span&gt; -C /usr/local --strip-components=1 --no-same-owner \
  &amp;amp;&amp;amp; rm &lt;span class=&quot;st&quot;&gt;&quot;node-v$NODE_VERSION-linux-x64.tar.gz&quot;&lt;/span&gt; SHASUMS256.txt \
  &amp;amp;&amp;amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs

&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; /app
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; --from=builder /app .
&lt;span class=&quot;kw&quot;&gt;ENTRYPOINT&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;dotnet&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;myapp.dll&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;captain-definition&quot;&gt;captain-definition&lt;/h3&gt;
&lt;p&gt;虽然上面介绍了 &lt;code&gt;Dockerfile&lt;/code&gt;，但最终要使用的是 &lt;code&gt;captain-definition&lt;/code&gt; 这个文件，这个文件的详细说明请看：&lt;a href=&quot;https://github.com/githubsaturn/captainduckduck/wiki/Captain-Definition-File&quot; class=&quot;uri&quot;&gt;https://github.com/githubsaturn/captainduckduck/wiki/Captain-Definition-File&lt;/a&gt;，不过 captainduckduck 的作者提供了一个在线转换工具：&lt;a href=&quot;https://githubsaturn.github.io/dockerfile-to-captain/&quot; class=&quot;uri&quot;&gt;https://githubsaturn.github.io/dockerfile-to-captain/&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;转换后的结果如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;schemaVersion&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;dockerfileLines&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;# Sample contents of Dockerfile&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;# Stage 1&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;FROM microsoft/aspnetcore-build AS builder&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;WORKDIR /source&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;# caches restore result by copying csproj file separately&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;COPY ./src/*.csproj .&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;COPY ./src/package.json .&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;# 如果你的服务器网络不好，请自行在这里修改 npm 仓库&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;RUN dotnet restore &amp;amp;&amp;amp; npm i&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;# copies the rest of your code&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;COPY ./src/ .&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;RUN dotnet publish --output /app/ --configuration Release&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;# Stage 2&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;FROM microsoft/aspnetcore:2.0.5&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;ENV NODE_VERSION 9.3.0&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;RUN curl -SLO &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;https://mirrors.ustc.edu.cn/node/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;  &amp;amp;&amp;amp; curl -SLO --compressed &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;https://mirrors.ustc.edu.cn/node/v$NODE_VERSION/SHASUMS256.txt&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;  &amp;amp;&amp;amp; grep &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; node-v$NODE_VERSION-linux-x64.tar.gz&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; SHASUMS256.txt | sha256sum -c - &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;  &amp;amp;&amp;amp; tar -xf &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;node-v$NODE_VERSION-linux-x64.tar.gz&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; -C /usr/local --strip-components=1 --no-same-owner &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;  &amp;amp;&amp;amp; rm &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;node-v$NODE_VERSION-linux-x64.tar.gz&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; SHASUMS256.txt &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;  &amp;amp;&amp;amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;WORKDIR /app&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;COPY --from=builder /app .&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;ENTRYPOINT [&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;dotnet&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;myapp.dll&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;]&quot;&lt;/span&gt;
  &lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是，即使 &lt;code&gt;captain-definition&lt;/code&gt; 文件位于项目根目录，但在服务端构建的时候，项目文件夹的内容会被克隆到 &lt;code&gt;./src&lt;/code&gt;，而由 captainduckduck 生成的 &lt;code&gt;Dockerfile&lt;/code&gt; 会位于 &lt;code&gt;./Dockerfile&lt;/code&gt;，所以在编写 Dockerfile 的时候，就应该考虑到这个情况。&lt;/p&gt;
&lt;h3 id=&quot;客户端命令行工具&quot;&gt;客户端命令行工具&lt;/h3&gt;
&lt;p&gt;captainduckduck 命令行工具可以用来让我们不用打开 Web 面板就来部署网站，命令行工具安装起来也很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm i -g captainduckduck
# 或者
# yarn global add captainduckduck&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来让我们连接到 captainduckduck 服务端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;captainduckduck login&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署一个试试&quot;&gt;部署一个试试&lt;/h3&gt;
&lt;p&gt;部署网站之前需要先创建一个 App，首先登陆 Web 面板，切换到 App 页面，输入 App 的名字：&lt;code&gt;react&lt;/code&gt;，然后点击 &lt;strong&gt;Create A New App&lt;/strong&gt;。这样，一个 App 就创建完成了，现在我们可以关掉网站，接着在本地创建一个样例项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir myapp
cd myapp
dotnet new react
yarn # Or npm i&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把上面的 &lt;code&gt;caption-definition&lt;/code&gt; 文件添加到项目根目录。接着执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git init
git add .
git commit -m 'init commit'
captainduckduck deploy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍等几分钟，你就可以打开 &lt;code&gt;http://react.something.example.com&lt;/code&gt; 来访问这个样例网站了。这里给出我的例子：&lt;a href=&quot;http://aspnetcore.app.gianthard.rocks/&quot;&gt;http://react.app.gianthard.rocks/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;更多功能&quot;&gt;更多功能&lt;/h2&gt;
&lt;p&gt;captainduckduck 还能跟代码托管系统，例如：Github、Gitlab 通过 WebHook 集成，实现持续的部署，关于更详细的介绍，请看项目 Wiki：&lt;a href=&quot;https://github.com/githubsaturn/captainduckduck/wiki&quot; class=&quot;uri&quot;&gt;https://github.com/githubsaturn/captainduckduck/wiki&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考列表：&lt;/p&gt;
</description>
<pubDate>Fri, 23 Feb 2018 14:11:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/8463663.html</dc:identifier>
</item>
</channel>
</rss>