<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Duilib XML嵌套 - karllen</title>
<link>http://www.cnblogs.com/Forever-Kenlen-Ja/p/7854357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Forever-Kenlen-Ja/p/7854357.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;duilib使用嵌套xml可以简化代码的书写，有利于模块化的页面布局分解，duilib库的xml嵌套主要有两种方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;方式一、以创建控件的方式嵌套xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在CreateControl(LPCTSTR pstrClassname )中创建自定义的控件，并绑定到xml文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; CControlUI* FrameWnd&lt;span&gt;::CreateControl( LPCTSTR pstrClassName )
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (_tcsicmp(pstrClassName, _T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wnd_Xml_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        CDialogBuilder builder;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         CControlUI* pUI = builder.Create(_T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wnd_Xml_2.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pUI;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (_tcsicmp(pstrClassName, _T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wnd_Xml_2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        CDialogBuilder builder;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         CControlUI* pUI = builder.Create(_T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wnd_Xml_2.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pUI;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FrameWnd的XML文件使用时&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &amp;lt;Wnd_Xml_1 height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;520&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
 &amp;lt;Wnd_Xml_2 height=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;521&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Wnd_Xml_1和Wnd_Xml_2则只需安装Window的方式来实现即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;方式二、使用TableLayout嵌套xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;       &amp;lt;TabLayout name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wizard_setup_tab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &amp;gt;
&lt;span&gt;2&lt;/span&gt;           &amp;lt;Include source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configpage.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;3&lt;/span&gt;         &amp;lt;Include source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;installingpage.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;        
&lt;span&gt;4&lt;/span&gt;           &amp;lt;Include source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;finishpage.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;5&lt;/span&gt;           &amp;lt;Include source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uninstallpage.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;6&lt;/span&gt;         &amp;lt;Include source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uninstallingpage.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;        
&lt;span&gt;7&lt;/span&gt;           &amp;lt;Include source=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;uninstallfinishpage.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;span&gt;8&lt;/span&gt;     &amp;lt;/TabLayout&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用的时候需要在指定具体的xml进行加载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如使用finishpage.xml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用时需要如下操作：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
CTabLayoutUI * setup_tab = static_cast &amp;lt;CTabLayoutUI*&amp;gt;(m_PaintManager.FindControl(_T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wizard_setup_tab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
    setup_tab&lt;/span&gt;-&amp;gt;SelectItem(&lt;span&gt;2&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;方式三、以创建Frame的方式嵌套Frame从而达到嵌套xml的目的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     g_pWordManagerFrame-&amp;gt;Create(NULL, _T(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WordManagerWnd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), UI_WNDSTYLE_DIALOG, WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;直接定义一个Frame来加载独立的xml&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 16:56:00 +0000</pubDate>
<dc:creator>karllen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Forever-Kenlen-Ja/p/7854357.html</dc:identifier>
</item>
<item>
<title>一篇文章让你明白python的装饰器 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/7854278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/7854278.html</guid>
<description>&lt;p&gt;在看闭包问题之前先来看看关于python中作用域的问题&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;变量作用域&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235130656-2113167992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于上述代码中出现错误，肯定没什么疑问了，毕竟b并没有定义和赋值，当我们把代码更改如下后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235155171-616265314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看一个例子：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235221140-1604711026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先这个错误已经非常明显：说在赋值之前引用了局部变量b&lt;/p&gt;
&lt;p&gt;可能很多人觉得会打印10然后打印6，其实这里就是涉及到变量作用域的问题&lt;br/&gt;当Python编译函数的的定义体的时候，它判断b是局部变量，毕竟在函数中有b = 9表示给b赋值了，所以python会从本地环境获取b，当我们调用方法执行的时候，定义体会获取并打印变量a的值，但是当尝试获取b的值的时候发现b没有绑定值，所以要想让上述代码运行还可以把b设置为全局变量，或者把b赋值放到调用之前&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235237171-1039665902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235246093-1929143137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;函数对象的作用域&lt;/h2&gt;
&lt;p&gt;python中一切皆对象，同其他对象一样,函数对象也有其使用的范围即函数对象的作用域。&lt;br/&gt;在python中我们通过def定义函数，函数对象的作用域与def所在的层级相同，&lt;br/&gt;通过下面代码进行理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(x):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2*&lt;span&gt;x
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func2(5&lt;span&gt;))

func1()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(func2(5))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中我们在def func1函数内可以调用fun2,但是我们在外面是无法调用到func2的，所以结果为看到如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235325171-1684348962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;闭包&lt;/h2&gt;
&lt;p&gt;关于闭包主要有下面两种说法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;闭包是符合一定条件的函数，定义为：闭包是在其词法上下文中引用了自由变量的函数&lt;/li&gt;
&lt;li&gt;闭包是由函数与其相关的引用环境组合而成的实体。定义为：在实现绑定时，需要创建一个能显示表示引用环境的东西，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体称为闭包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;个人觉得第二种说法更准确，闭包只是在形式上表现像函数，实际不是函数。&lt;br/&gt;我们对函数的定义是：一些可执行的代码，这些代码在函数定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。&lt;/p&gt;
&lt;p&gt;闭包在运行的时候可以有多个实例，不同的引用环境和相同的环境组合可以产生不同的实例。&lt;/p&gt;
&lt;p&gt;这里有一个词：引用环境，其实引用环境就是在执行运行的某个时间点，所有处于活跃状态的变量所组成的集合，这里的变量是指变量的名字和其所代表的对象之间的联系。&lt;/p&gt;
&lt;p&gt;可以使用闭包语言的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数可以作为另外一个函数的返回值或者参数，还可以作为一个变量的值。&lt;/li&gt;
&lt;li&gt;函数可以嵌套使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而认为闭包是函数的有一句话是：&lt;br/&gt;闭包是指延伸了作用域的函数，其中包含函数定义体中引用。但是不在定义体中定义的非全局变量。&lt;/p&gt;
&lt;p&gt;上面这种说法个人觉得也是一种理解方式&lt;/p&gt;
&lt;p&gt;相信看了这些概念也还是不好理解，还是通过下面例子更好理解：&lt;/p&gt;
&lt;p&gt;先实现一种计算平均值的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235344171-334543737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从结果我们可以看出这里保存了每次的历史值&lt;br/&gt;换一种方法实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235401781-68287159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现了第一种相同的效果，对这种方法分析：&lt;br/&gt;通常我们会认为我们调用avg(10)的时候make_averager函数已经返回了，而它的本地作用域也一去不复返，但这里其实series是自由变量，是指未在本地作用域绑定的变量&lt;br/&gt;我们可以通过print(dir(avg)),看到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235422906-1761709340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这里面保存着均布变量和自由变量的名称，我们可以通过下面方法查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235445984-1622618193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;eries的绑定在返回的avg函数的__closure__属性中这或许就是有的人会认为闭包一种函数。闭包会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不能用了，但是仍能使用那些绑定&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;关于nonlocal&lt;/h3&gt;
&lt;p&gt;刚开始了解闭包之后，如果尝试使用这种编程方式容易出现以下错误使用例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_averager():
    count &lt;/span&gt;=&lt;span&gt; 0
    total &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; averager(new_value):
        count &lt;/span&gt;+= 1&lt;span&gt;
        total &lt;/span&gt;+=&lt;span&gt; new_value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total /&lt;span&gt; count
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; averager
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先来看一下错误提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201711/997599-20171117235522906-1371806326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个例子中和我们上面使用的不同之处是：这里的count和total是数字，是不可变类型，而之前的例子中series是一个列表是可变类型&lt;br/&gt;所以这里重新回到了最开始说的作用域问题了，当我们在averager中使用&lt;br/&gt;count += 1的时候其实就是count = count + 1,这样就是在averager函数定义体中对count进行赋值，count就变成了局部变量。&lt;/p&gt;
&lt;p&gt;问题小结：当时数字，字符串，元组等不可变类型时，只能读取不能更新，如果使用类似count += 1就会隐式的把count变成局部变量，所以开始例子中使用series，我们后面的操作是append并且列表还是可变对象&lt;/p&gt;
&lt;p&gt;不过python3引入了一个新的关键词nonlocal，通过它把变量标记为自由变量，这样我们把上面这个错误的例子简单更改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; make_averager():
    count &lt;/span&gt;=&lt;span&gt; 0
    total &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; averager(new_value):
        nonlocal count,total
        count &lt;/span&gt;+= 1&lt;span&gt;
        total &lt;/span&gt;+=&lt;span&gt; new_value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; total /&lt;span&gt; count
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; averager
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里装饰器的前奏就说完了，下面就是装饰器，我个人觉得装饰器只是闭包的一种应用，闭包在很多情况下都是一种非常好的变成技巧&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;装饰器&lt;/h2&gt;
&lt;p&gt;关于装饰器本来是想重新整理一下，看了自己之前整理的博客，已经挺详细的，就把连接直接放这里了&lt;br/&gt;&lt;a href=&quot;http://www.pythonsite.com/?p=113&quot;&gt;http://www.pythonsite.com/?p=113&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 15:57:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/7854278.html</dc:identifier>
</item>
<item>
<title>8. 理解ZooKeeper的内部工作原理 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/7854114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/7854114.html</guid>
<description>&lt;p&gt;到目前为止，我们已经讨论了ZooKeeper服务的基础知识，并详细了解了数据模型及其属性。 我们也熟悉了ZooKeeper 监视（watch）的概念，监视就是在ZooKeeper命名空间中的znode发生任何变化时完成的事件机制。 我们通过公开一组与znodes相关联的ACL来读取身份验证和基本安全模型。&lt;/p&gt;
&lt;p&gt;在本节中，我们将通过介绍ZooKeeper session的概念来讨论和了解客户端与ZooKeeper服务交互的生命周期。 我们还将详细阅读ZooKeeper如何在内部描述协议。 了解以及深入理解内部工作原理非常重要，这有助于使用ZooKeeper设计分布式应用程序，并了解与之相关的错综复杂的事情。&lt;/p&gt;
&lt;p&gt;我们先来看看客户端如何与ZooKeeper服务进行交互。 为了使分布式应用程序能够使用ZooKeeper服务，他们必须通过客户端类库来使用API。 ZooKeeper客户端库对几乎所有流行的编程语言都有语言绑定。 客户端库类库负责应用程序与ZooKeeper服务的交互。&lt;/p&gt;
&lt;p&gt;下图显示了应用程序与ZooKeeper服务的交互过程：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-8587987121b4ef55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;应用程序通过客户端类库与ZooKeeper服务进行交互&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ZooKeeper服务可以以两种模式运行：独立（standalone）模式和仲裁（quorum）模式。 在独立模式下，有一个ZooKeeper服务器。 另一方面，quorum模式意味着ZooKeeper以复制模式运行在一组机器上，也称为ensemble。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Note&lt;br/&gt;独立模式仅用于评估和测试应用程序代码，但不能在生产中使用，因为这是潜在的单点故障。 在仲裁模式下，ZooKeeper通过复制实现高可用性，只要ensemble中大部分机器启动，都可以提供服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一-quorum模式&quot;&gt;一 quorum模式&lt;/h3&gt;
&lt;p&gt;ZooKeeper quorum构成了复制节点的大部分，这些复制节点将ZooKeeper服务的最新状态存储在ensemble中的所有服务器中。 这基本上是必须启动并运行的服务器节点的最小数量，并且可用于客户端请求。 客户端对ZooKeeper树进行的任何更新都必须永久存储在此quorum的节点中，以便事务成功完成。&lt;/p&gt;
&lt;p&gt;例如，在一个五个节点ensemble中，任何两台机器都可能失败，并且我们可以拥有三台服务器的quorum，ZooKeeper服务仍然可以工作。 稍后，如果其他两个失败节点出现，则可以通过从现有quorum中获取最新状态来同步ZooKeeper服务状态。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;调整ZooKeeper服务中服务器节点的数量对于ZooKeeper正确运行非常重要。 由于所有的事务提交都依赖于多数共识的概念，所以建议ZooKeeper集合中应该有奇数个机器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们来看一个例子，看看为什么这是有道理的。 假设我们有一个由五台服务器组成的ZooKeeper ensemble。 如果任何两台服务器发生故障，ensemble仍然可以运行，因为可以在其余三个节点之外形成quorum。 因此，五节点ZooKeeper ensemble可以容忍多达两个节点的故障。&lt;/p&gt;
&lt;p&gt;现在，对于六节点ensemble，ZooKeeper服务可以容忍最多只有两个节点的故障。 这是因为有三个节点失败，无法形成quorum。 在那里不能达到多数的共识。 同样，ZooKeeper quorum必须保证任何成功承认客户端的事务都应该是持久的，并在形成quorum的节点上可见。&lt;/p&gt;
&lt;p&gt;如果ZooKeeper quorum不是由ensemble中的大多数节点组成的，ZooKeeper命名空间的状态可能会有不一致，从而导致错误的结果。 除了节点故障之外，集合中节点之间的网络分区可能会导致不一致的操作，因为quorum成员之间将无法传递更新。 这导致在分布式群集中出现的共同问题，称为脑裂（split-brain）。&lt;/p&gt;
&lt;p&gt;脑裂是ensemble中的两个服务器子集独立运作的场景。 这会导致整个ZooKeeper服务中的状态不一致，并且不同的客户端根据相同的请求获得不同的结果，具体取决于它们所连接的服务器。 通过使用奇数个节点运行ZooKeeper集群，我们可以将此类错误的概率降至概率最小。&lt;/p&gt;
&lt;h3 id=&quot;二-客户端与zookeeper服务建立session会话&quot;&gt;二 客户端与ZooKeeper服务建立session会话&lt;/h3&gt;
&lt;p&gt;连接到ZooKeeper的客户端可以配置一个构成ZooKeeper ensemble的服务器列表。 客户端尝试通过从列表中选择一个随机服务器来连接到列表中的服务器。 如果连接失败，则尝试连接到下一个服务器，依此类推。 此过程直到列表中的所有服务器都被尝试或建立了成功的连接。&lt;/p&gt;
&lt;p&gt;一旦客户端和ZooKeeper服务器之间建立连接，就在客户端和服务器之间建立一个会话（session），表示为分配给客户端的64位数字。 会话的概念对于ZooKeeper的运行非常重要。 会话与客户在ZooKeeper服务中执行的每个操作相关联。&lt;/p&gt;
&lt;p&gt;会话在ZooKeeper中扮演着非常重要的角色。 例如，ephemeral节点的整个概念是基于客户端和ZooKeeper服务器之间会话的概念。 ephemeral znode在客户端和ZooKeeper之间有会话的生命周期; 当这个会话结束时，这些节点将被ZooKeeper服务自动删除。&lt;/p&gt;
&lt;p&gt;会话有一个超时期限，在连接到ZooKeeper服务时由应用程序或客户端指定。 客户端发送一个请求的超时作为创建连接调用中的参数来创建一个以毫秒为单位指定的ZooKeeper。 如果连接保持空闲超过超时时间，则会话可能会过期。 会话到期由ZooKeeper集群本身管理，而不是由客户端管理。 当前的实现要求超时至少是tickTime的两倍，最多为tickTime的20倍。&lt;/p&gt;
&lt;p&gt;指定正确的会话超时取决于各种因素，如网络拥塞，应用程序逻辑的复杂性，甚至ZooKeeper ensemble的大小。 例如，在一个非常繁忙和拥挤的网络中，如果延迟很高，那么会话超时会非常低，会导致会话过期。 同样，如果你的ensemble很大，建议有一个更大的超时时间。 此外，如果应用程序看到频繁的连接丢失，增加会话超时可能会有用。 然而，另一个警告是它不应该对应用程序的核心逻辑产生不经意的影响。&lt;/p&gt;
&lt;p&gt;客户端通过向ZooKeeper服务发送ping请求（心跳）来保持活动。 这些心跳是由客户端类库自动发送的，因此，应用程序员不必担心会话保持活跃状态。 客户端和ZooKeeper服务器之间的会话使用TCP连接进行维护。 两个连续的心跳之间的间隔应该保持低，这样客户端和ZooKeeper服务器之间的连接失败可以很早被检测到，并且可以进行重新连接尝试。 重新连接到另一个ZooKeeper服务器通常由客户端类库以透明方式完成。 当重新连接到同一个ensemble的不同服务器时，客户端创建的现有会话和关联的ephemeral znode仍然有效。 对于在客户端和服务器之间维护的单个会话，ZooKeeper保证通常按照FIFO顺序的排序。&lt;/p&gt;
&lt;p&gt;如前一节所述，应用程序使用客户端类库与ZooKeeper服务建立会话。 表示连接对象的句柄由ZooKeeper客户端API返回给应用程序。 这个ZooKeeper连接对象在其创建和结束之间的时间内通过不同的状态转换。 连接对象会持续到客户端程序的连接正常关闭或会话由于超时而终止。&lt;/p&gt;
&lt;p&gt;一旦连接对象被创建，它就从&lt;code&gt;CONNECTING&lt;/code&gt;状态开始，客户端库尝试连接到ZooKeeper ensemble中的一个服务器。 当连接到ZooKeeper服务时，对象转换到&lt;code&gt;CONNECTED&lt;/code&gt;状态。 由于事件（如会话到期和身份验证失败），或者应用程序正常关闭使用库调用的连接，对象的状态将转到&lt;code&gt;CLOSED&lt;/code&gt;状态。&lt;/p&gt;
&lt;p&gt;下图显示了ZooKeeper客户端会话的状态转换：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ed4e22e6f51d6432.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ZooKeeper客户端状态转换&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三-zookeeper事务的实现&quot;&gt;三 ZooKeeper事务的实现&lt;/h3&gt;
&lt;p&gt;在前面的章节中，我们看到了ZooKeeper如何在服务器上运行，以及客户端如何连接到这些服务器，建立会话并在ZooKeeper服务中执行操作。 在服务器ensemble中，服务器被选为领导者，剩下的所有服务器都成为追随者。 领导处理所有更改ZooKeeper服务的请求。 追随者收到领导者的更新，并通过多数共识机制，在整个ensemble中保持一致的状态。 ZooKeeper服务负责替换失败的领导者，并将跟随者与领导者同步，整个过程对于客户端应用程序是完全透明的。&lt;/p&gt;
&lt;p&gt;该服务依靠复制机制来确保所有更新在构成ensemble的所有服务器中都是永久的。 每个服务器都维护着一个核心数据库，它代表了ZooKeeper命名空间的整个状态。 为了确保更新是持久的，并在服务器崩溃时可以恢复，更新记录到本地磁盘。 此外，写入操作在序列化到磁盘之后才会应用到内存数据库。&lt;/p&gt;
&lt;p&gt;ZooKeeper使用一个称为 ZooKeeper Atomic Broadcast (ZAB)的特定原子消息广播协议。 该协议确保ensemble中的本地副本永不分离。 此外，ZAB协议是原子的，所以协议保证更新要不全部成功，或者全部失败。&lt;/p&gt;
&lt;p&gt;复制的数据库、ZAB协议与领导者选举机制一起构成了ZooKeeper服务实现的核心。 ZooKeeper服务名称空间中的更新或写入以及读取操作由这些核心组件处理，如下图所示，也可以在&lt;a href=&quot;http://zookeeper.apache.org/doc/r3.4.6/zookeeperOver.html#fg_zkComponents&quot; class=&quot;uri&quot;&gt;http://zookeeper.apache.org/doc/r3.4.6/zookeeperOver.html#fg_zkComponents&lt;/a&gt;中找到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-95e7b6b639bc534c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ZooKeeper服务组件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ZooKeeper实现中，读取请求（如&lt;code&gt;exists&lt;/code&gt;，&lt;code&gt;getData&lt;/code&gt;和&lt;code&gt;getChildren&lt;/code&gt;）由客户端连接的ZooKeeper服务器本地处理。 这使得ZooKeeper中的读操作非常快。 写入或更新请求，例如&lt;code&gt;create&lt;/code&gt;，&lt;code&gt;delete&lt;/code&gt;和&lt;code&gt;setData&lt;/code&gt;被转发给ensemble中的领导者。 领导者执行客户请求作为一个事务。 这个事务类似于数据库管理系统中事务的概念。&lt;/p&gt;
&lt;p&gt;ZooKeeper事务也包含成功执行请求所需的所有步骤作为单个工作单元，并且以原子方式应用更新。 此外，事务满足隔离性，这意味着任何事务都不会受到任何其他事务的干扰。 ZooKeeper服务中的事务是幂等的。 事务通过一个事务标识符（zxid）来标识，它是一个64位整数，分为两部分：纪元和计数器，每个部分都是32位。&lt;/p&gt;
&lt;p&gt;事务处理包括ZooKeeper的两个步骤：领导选举和原子消息广播协议。 这类似于两阶段提交协议，也包括领导者选举和原子消息广播协议。&lt;/p&gt;
&lt;h3 id=&quot;四-第一阶段领导者选举&quot;&gt;四 第一阶段——领导者选举&lt;/h3&gt;
&lt;p&gt;ensemble中的服务器经过一个选举主服务器的过程，称为领导者。 ensemble中的其他服务器被称为追随者。&lt;/p&gt;
&lt;p&gt;参与领导选举算法的每个服务器都有一个名为“LOOKING”的状态。如果一个领导者已经存在于整个系统中，那么对等服务器将通知新的参与者服务器关于现有的领导者。在了解领导者后，新的服务器与领导者保持同步状态。&lt;/p&gt;
&lt;p&gt;一个领导者不存在于ensemble中时，ZooKeeper在服务器ensemble中运行领导者选举算法。 在这种情况下，首先，所有服务器都处于LOOKING状态。 该算法指示服务器交换消息以选举领导者。 当参与者服务器汇聚在一个特定服务器的共同选择上时，该算法就会停止，这个服务器就成为领导者。 赢得这次选举的服务器进入LEADING状态，而ensemble中的其他服务器进入FOLLOWING状态。&lt;/p&gt;
&lt;p&gt;参与者服务器与他们的对等服务器交换的消息，包含服务器的标识符(sid)和它所执行的最近事务ID(zxid)。每个参与服务器在接收到对等服务器的消息后，将自己的sid和zxid与它所接收的消息进行比较。如果接收到的zxid大于服务器所持有的zxid，则服务器接受接收到的zxid，否则，它将自己的zxid设置并将其自己的zxid设置为ensemble中的对等服务器。&lt;/p&gt;
&lt;p&gt;在这个算法的最后，拥有最近事务ID(zxid)的服务器赢得了领导选举算法。在算法完成之后，追随者服务器将其状态与所选出的领导者同步。&lt;/p&gt;
&lt;p&gt;领导者选举的下一步是领导者激活。 新当选的领导者提出了&lt;code&gt;NEW_LEADER&lt;/code&gt;建议，并且只有在&lt;code&gt;NEW_LEADER&lt;/code&gt;提案被ensemble中的大多数服务器（quorum）确认之后，领导才会被激活。在新领导人的&lt;code&gt;NEW_LEADER&lt;/code&gt;提议被提交之前，新领导人不会接受新提议。&lt;/p&gt;
&lt;h3 id=&quot;五-第二阶段原子消息广播协议&quot;&gt;五 第二阶段——原子消息广播协议&lt;/h3&gt;
&lt;p&gt;ZooKeeper中的所有写入请求都被转发给领导者。 领导者向ensemble的追随者广播其更新。 只有在大多数追随者承认他们坚持这个变化之后，领导者才会进行更新。 ZooKeeper使用ZAB协议来实现共识，这被设计为原子的。 因此，更新成功或失败。 在领导失败时，ensemble中的其他服务器进入领导者选举算法，以选出其中的新领导者。&lt;/p&gt;
&lt;blockquote readability=&quot;12.986206896552&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;ZAB: High-performance broadcast for primary-backup systems by Junqueira, F.P; Reed, &amp;gt; B.C; Serafini. M&lt;/p&gt;
&lt;p&gt;(LADIS 2008, in: Proceedings of the 2nd Workshop on Large-Scale Distributed Systems &amp;gt; and Middleware)&lt;/p&gt;
&lt;p&gt;可以通过以下链接访问IEEE Xplore上的ZAB文章：&lt;a href=&quot;http://bit.ly/1v3N1NN&quot; class=&quot;uri&quot;&gt;http://bit.ly/1v3N1NN&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ZAB保证了在递送事务和提交事务时的严格顺序。通过原子消息处理事务可以如下图所示:&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-f72bb1368851dbc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ZooKeeper的事务提交协议&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两阶段提交保证了事务的顺序。 在协议中，一旦quorum确认一个事务，领导者就提交，而追随者将其确认记录在磁盘上。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;除了领导者和追随者之外，ZooKeeper ensemble中的服务器还有第三个特征，称为观察者。 观察者和追随者在概念上是相似的，因为他们都承诺领导者的建议。 然而，与追随者不同，观察者不参与两阶段提交过程的投票过程。 观察者有助于ZooKeeper服务中读取请求的可伸缩性，并有助于在跨越多个数据中心的ZooKeeper集成中传播更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;六-本地存储和快照&quot;&gt;六 本地存储和快照&lt;/h3&gt;
&lt;p&gt;ZooKeeper服务器使用本地存储来保存事务。 事务记录到事务日志中，类似于在数据库系统中使用的顺序附加日志文件的方法。 ZooKeeper服务器使用预先分配的文件将事务刷新到磁盘介质上。 在ZooKeeper事务处理的两阶段协议中，只有在强制将事务写入事务日志后，服务器才会确认提议。 由于ZooKeeper事务日志的写入速度很快，所以在一个与服务器的引导设备分开的磁盘中配置事务日志是非常重要的。&lt;/p&gt;
&lt;p&gt;ZooKeeper服务中的服务器还保存ZooKeeper树或命名空间的时间点副本或快照到本地文件系统。 服务器不需要与ensemble的其他成员协调来保存这些快照。 此外，快照处理与ZooKeeper服务器的正常运行进行异步操作。&lt;/p&gt;
&lt;p&gt;ZooKeeper快照文件和事务日志能够在发生灾难性故障或用户错误时恢复数据。 数据目录由ZooKeeper配置文件中的dataDir参数指定，数据日志目录由dataLogDir参数指定。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 15:03:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/7854114.html</dc:identifier>
</item>
<item>
<title>Unity3D跨平台动态库编译---记kcp基于CMake的各平台构建实践 - SChivas</title>
<link>http://www.cnblogs.com/SChivas/p/7854100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SChivas/p/7854100.html</guid>
<description>&lt;p&gt;1、为什么需要动态库&lt;/p&gt;
&lt;p&gt;　　a）提供原生代码（native code）的支持，也叫原生插件，但是我实践的是c/cpp跨平台动态库，这里不具体涉及安卓平台java库和ios平台的objectc库构建。&lt;/p&gt;
&lt;p&gt;　　b）某些开源库是c/cpp编写，没有对应c#版本&lt;/p&gt;
&lt;p&gt;　　c）或者有c#版本实现，但是效率或者gc达不到期望效果，特别是GC，一般的开源库c#版本的作者，对gc优化得大多不好&lt;/p&gt;
&lt;p&gt;　　d）追求效率，比如A*寻路等开销比较大的算法，想做下优化&lt;/p&gt;
&lt;p&gt;　　e）某些模块，如网络模块，需要Unity客户端和后端跑一份相同的逻辑代码，而不想维护两份语言的实现&lt;/p&gt;

&lt;p&gt;2、示例demo选择&lt;/p&gt;
&lt;p&gt;　　前阵子由于项目需要，编译了一下kcp库，这里拿kcp编译到Unity的各平台动态库来做一次总结，kcp的github地址：&lt;span&gt;&lt;a href=&quot;https://github.com/skywind3000/kcp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/skywind3000/kcp&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;有关这个库的其它信息这里不做介绍，它本质就是一个可靠UDP的网络库，我们项目是用在了一款多人实时射击类游戏中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;3、编译工具选择&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里使用的是CMake，官网地址为：&lt;a href=&quot;https://cmake.org/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://cmake.org/&lt;/span&gt;&lt;/a&gt;。有关CMake的使用资料自行网络获取，我这里只说一点，这是一个跨平台的构建工具，针对不同的平台，只需要一份描述文件，很方便，不需要每个平台去写makefile。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;4、工程目录结构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171117213001718-1595756581.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　其中：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　1）cmke目录：包含CMake在安卓、iOS平台进行构建时需要要到的两个文件：android.toolchain.cmake、iOS.cmake&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　2）Plugins目录：各平台构建的输出目录，构建完成后可以直接放置到Unity项目Assdets目录下使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　3）CMakeLists.txt文件：主要要由我们自己编写的一个文件，cmake根据CMakeLists生成各个平台编译的中间文件以及makefile文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　4）目标库源代码：kcp.h、kcp.c&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　5）make_xxx：各平台执行构建脚本文件，这些文件基本是固定的，不需要做什么修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;5、项目简要说明&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1）kcp项目需要做的调整：kcp.c不需要动，kcp.h修改部分如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifdef DLL_EXPORTS
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; KCPDLL _declspec(dllexport)
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; KCPDLL
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; interface
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------------------------------------------
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create a new kcp control object, 'conv' must equal in two endpoint
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; from the same connection. 'user' will be passed to the output callback
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; output callback can be setup like this: 'kcp-&amp;gt;output = my_udp_output'&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     KCPDLL ikcpcb* ikcp_create(IUINT32 conv, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;user);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它导出接口省略&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#ifdef __cplusplus
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）CMakeLists文件编写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; cmake_minimum_required(VERSION &lt;span&gt;2.8&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( WIN32 AND NOT CYGWIN AND NOT ( CMAKE_SYSTEM_NAME STREQUAL &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WindowsStore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ) )
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     set(CMAKE_C_FLAGS_RELEASE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CMAKE_C_FLAGS_RELEASE} /MT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CACHE STRING &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     set(CMAKE_C_FLAGS_DEBUG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CMAKE_C_FLAGS_DEBUG} /MTd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CACHE STRING &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     set(CMAKE_CXX_FLAGS_RELEASE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CMAKE_CXX_FLAGS_RELEASE} /MT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CACHE STRING &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     set(CMAKE_CXX_FLAGS_DEBUG &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CMAKE_CXX_FLAGS_DEBUG} /MTd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; CACHE STRING &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;endif ()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;project(kcp)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( IOS )
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         set(CMAKE_CXX_FLAGS &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CMAKE_CXX_FLAGS} -fembed-bitcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         set(CMAKE_C_FLAGS &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CMAKE_C_FLAGS} -fembed-bitcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;endif ()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;find_path(KCP_PROJECT_DIR NAMES SConstruct
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    PATHS 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    ${CMAKE_SOURCE_DIR}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    NO_DEFAULT_PATH
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;MARK_AS_ADVANCED(KCP_PROJECT_DIR)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;set ( KCP_CORE
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    kcp.c
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;macro(source_group_by_dir proj_dir source_files)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(MSVC OR APPLE)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        get_filename_component(sgbd_cur_dir ${proj_dir} ABSOLUTE)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        foreach(sgbd_file ${${source_files}})
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            get_filename_component(sgbd_abs_file ${sgbd_file} ABSOLUTE)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;file&lt;/span&gt;&lt;span&gt;(RELATIVE_PATH sgbd_fpath ${sgbd_cur_dir} ${sgbd_abs_file})
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;(REGEX REPLACE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\(.*\)/.*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; \\&lt;span&gt;1&lt;/span&gt;&lt;span&gt; sgbd_group_name ${sgbd_fpath})
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;&lt;span&gt;(COMPARE EQUAL ${sgbd_fpath} ${sgbd_group_name} sgbd_nogroup)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;(REPLACE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; sgbd_group_name ${sgbd_group_name})
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(sgbd_nogroup)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 set(sgbd_group_name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            endif(sgbd_nogroup)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            source_group(${sgbd_group_name} FILES ${sgbd_file})
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        endforeach(sgbd_file)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    endif(MSVC OR APPLE)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;endmacro(source_group_by_dir)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;source_group_by_dir(${CMAKE_CURRENT_SOURCE_DIR} KCP_CORE)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (APPLE)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IOS)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         set(CMAKE_OSX_ARCHITECTURES &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(ARCHS_STANDARD)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        add_library(kcp STATIC
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;           ${KCP_CORE}
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; ()
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         set(CMAKE_OSX_ARCHITECTURES &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(ARCHS_STANDARD_32_64_BIT)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        add_library(kcp MODULE
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            ${KCP_CORE}
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        set_target_properties ( kcp PROPERTIES BUNDLE TRUE )
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        #set_target_properties ( kcp PROPERTIES FRAMEWORK TRUE )
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        #set_target_properties ( kcp PROPERTIES MACOSX_RPATH TRUE )
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    endif ()
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt; ( )
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    add_library(kcp SHARED
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;        ${KCP_CORE}
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;endif ( )
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( WIN32 AND NOT CYGWIN )
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    target_compile_definitions (kcp PRIVATE DLL_EXPORTS)
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; endif ( )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　a）第10行：指定项目名称为kcp&lt;/p&gt;
&lt;p&gt;　　　　b）第26行：指定要编译的c/cpp文件&lt;/p&gt;
&lt;p&gt;　　　　c）第70行：指定预定义宏DLL_EXPORTS，这个宏只有在window平台编译dll动态库才需要，其它平台不需要&lt;/p&gt;
&lt;p&gt;　　　　d）其它没什么好说的，在构建你自己的项目时，只需要注意的带有“kcp”字样的地方替换为你自己对应的项目名称即可，有关CMakeLists语法的东西，自行谷歌吧。&lt;/p&gt;
&lt;p&gt;　　3）各平台构建脚本：&lt;/p&gt;
&lt;p&gt;　　　　a）window32位系统：make_win32.bat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; build32 &amp;amp;&lt;span&gt; pushd build32
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cmake -G &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Visual Studio 14 2015&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ..
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;popd
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; cmake --build build32 --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;md Plugins\x86
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; copy /&lt;span&gt;Y build32\Release\kcp.dll Plugins\x86\kcp.dll
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;rmdir&lt;/span&gt; /S /&lt;span&gt;Q build32
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; pause
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　b）windows64位系统：make_win64.bat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; build64 &amp;amp;&lt;span&gt; pushd build64
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cmake -G &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Visual Studio 14 2015 Win64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ..
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;popd
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; cmake --build build64 --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;md Plugins\x86_64
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; copy /&lt;span&gt;Y build64\Release\kcp.dll Plugins\x86_64\kcp.dll
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;rmdir&lt;/span&gt; /S /&lt;span&gt;Q build64
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; pause
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　c）linux32位系统：make_linux32.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p build_linux32 &amp;amp;&amp;amp;&lt;span&gt; cd build_linux32
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cmake -DCMAKE_C_FLAGS=-m32 -DCMAKE_CXX_FLAGS=-m32 -DCMAKE_SHARED_LINKER_FLAGS=-m32 ../
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;cd ..
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; cmake --build build_linux32 --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; build_linux32/kcp.so Plugins/x86/&lt;span&gt;kcp.so
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;rm&lt;/span&gt; -rf build_linux32
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　d）linux64位系统：make_linux64.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p build_linux64 &amp;amp;&amp;amp;&lt;span&gt; cd build_linux64
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cmake ../
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;cd ..
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; cmake --build build_linux64 --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; build_linux64/kcp.so Plugins/x86_64/&lt;span&gt;kcp.so
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;rm&lt;/span&gt; -rf build_linux64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　e）Mac系统：make_osx.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p build_osx &amp;amp;&amp;amp;&lt;span&gt; cd build_osx
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cmake -GXcode ../
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;cd ..
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; cmake --build build_osx --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p Plugins/kcp.bundle/Contents/MacOS/
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; build_osx/Release/kcp.bundle/Contents/MacOS/kcp Plugins/kcp.bundle/Contents/MacOS/&lt;span&gt;kcp
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;rm&lt;/span&gt; -rf build_osx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　f）android系统：make_android.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$ANDROID_NDK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     export ANDROID_NDK=~/android-ndk-&lt;span&gt;r10e
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p build_v7a &amp;amp;&amp;amp;&lt;span&gt; cd build_v7a
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; cmake -DANDROID_ABI=armeabi-v7a -DCMAKE_TOOLCHAIN_FILE=../cmake/android.toolchain.cmake -DANDROID_TOOLCHAIN_NAME=arm-linux-androideabi-clang3.&lt;span&gt;6&lt;/span&gt; -DANDROID_NATIVE_API_LEVEL=android-&lt;span&gt;9&lt;/span&gt; ../
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;cd ..
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; cmake --build build_v7a --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p Plugins/Android/libs/armeabi-v7a/
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; build_v7a/libkcp.so Plugins/Android/libs/armeabi-v7a/&lt;span&gt;libkcp.so
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;rm&lt;/span&gt; -&lt;span&gt;rf build_v7a
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p build_x86 &amp;amp;&amp;amp;&lt;span&gt; cd build_x86
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; cmake -DANDROID_ABI=x86 -DCMAKE_TOOLCHAIN_FILE=../cmake/android.toolchain.cmake -DANDROID_TOOLCHAIN_NAME=x86-clang3.&lt;span&gt;5&lt;/span&gt; -DANDROID_NATIVE_API_LEVEL=android-&lt;span&gt;9&lt;/span&gt; ../
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;cd ..
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; cmake --build build_x86 --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p Plugins/Android/libs/x86/
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; build_x86/libkcp.so Plugins/Android/libs/x86/&lt;span&gt;libkcp.so
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;rm&lt;/span&gt; -rf build_x86
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　g）iOS系统：make_ios.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p build_ios &amp;amp;&amp;amp;&lt;span&gt; cd build_ios
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; cmake -DCMAKE_TOOLCHAIN_FILE=../cmake/iOS.cmake  -GXcode ../
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;cd ..
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; cmake --build build_ios --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; -p Plugins/iOS/
&lt;span&gt; 6&lt;/span&gt; exist_armv7=`lipo -&lt;span&gt;info&lt;/span&gt; build_ios/Release-iphoneos/libkcp.a | &lt;span&gt;grep&lt;/span&gt; armv7 | &lt;span&gt;wc&lt;/span&gt; -&lt;span&gt;l`
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; exist_arm64=`lipo -&lt;span&gt;info&lt;/span&gt; build_ios/Release-iphoneos/libkcp.a | &lt;span&gt;grep&lt;/span&gt; arm64 | &lt;span&gt;wc&lt;/span&gt; -&lt;span&gt;l`
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ $[exist_armv7] -eq &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;** ERROR **: No support for armv7, maybe XCode version is to high, use manual_build_ios instead!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;elif&lt;/span&gt; [ $[exist_arm64] -eq &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;** ERROR ** : No support for arm64, maybe XCode version is to high, use manual_build_ios instead!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;cp&lt;/span&gt; build_ios/Release-iphoneos/libkcp.a Plugins/iOS/&lt;span&gt;libkcp.a
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;rm&lt;/span&gt; -&lt;span&gt;rf build_io
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　h）Windows Phone系统：make_uwp.bat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; build_uwp &amp;amp;&lt;span&gt; pushd build_uwp
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; cmake -G &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Visual Studio 14 2015&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -DCMAKE_SYSTEM_NAME=WindowsStore -DCMAKE_SYSTEM_VERSION=&lt;span&gt;10.0&lt;/span&gt;&lt;span&gt; ..
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;popd
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; cmake --build build_uwp --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;md Plugins\WSA\x86
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; copy /&lt;span&gt;Y build_uwp\Release\kcp.dll Plugins\WSA\x86\kcp.dll
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;rmdir&lt;/span&gt; /S /&lt;span&gt;Q build_uwp
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; build_uwp64 &amp;amp;&lt;span&gt; pushd build_uwp64
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; cmake -G &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Visual Studio 14 2015 Win64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -DCMAKE_SYSTEM_NAME=WindowsStore -DCMAKE_SYSTEM_VERSION=&lt;span&gt;10.0&lt;/span&gt;&lt;span&gt; ..
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;popd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; cmake --build build_uwp64 --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;md Plugins\WSA\x64
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; copy /&lt;span&gt;Y build_uwp64\Release\kcp.dll Plugins\WSA\x64\kcp.dll
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;rmdir&lt;/span&gt; /S /&lt;span&gt;Q build_uwp64
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;mkdir&lt;/span&gt; build_uwp_arm &amp;amp;&lt;span&gt; pushd build_uwp_arm
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; cmake -G &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Visual Studio 14 2015 ARM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -DCMAKE_SYSTEM_NAME=WindowsStore -DCMAKE_SYSTEM_VERSION=&lt;span&gt;10.0&lt;/span&gt;&lt;span&gt; ..
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;popd
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; cmake --build build_uwp_arm --&lt;span&gt;config Release
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;md Plugins\WSA\ARM
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; copy /&lt;span&gt;Y build_uwp_arm\Release\kcp.dll Plugins\WSA\ARM\kcp.dll
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;rmdir&lt;/span&gt; /S /&lt;span&gt;Q build_uwp_arm
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; pause
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　i）这些脚本都很简单明了，像需要的VS版本、安卓的NDK版本等等，一看便知。要移植到你自己的构建项目也很简单，基本只需要修改项目名称即可，这里不再做更多说明。&lt;/p&gt;

&lt;p&gt;6）各平台构建环境简要说明&lt;/p&gt;
&lt;p&gt;　　a）以下各平台，均需要安装CMake，安装教程，包括各平台环境变量等的配置自行谷歌，很多相关帖子。&lt;/p&gt;
&lt;p&gt;　　b）window系统和windows phone系统：在window系统中执行对应的.bat脚本即可，windows phone的编译需要相关SDK。本帖使用VS2015，windows phone暂时不需要，所以没有构建测试过。&lt;/p&gt;
&lt;p&gt;　　c）linux系统：在linux系统中执行对应的.sh脚本即可&lt;/p&gt;
&lt;p&gt;　　d）mac系统：在mac系统中执行对应的.sh脚本即可&lt;/p&gt;
&lt;p&gt;　　e）iOS系统：在mack系统中执行对应的.sh脚本即可。需要xcode版本8.1，版本太高会有问题，可以进行手动构建，参考博文：&lt;a href=&quot;http://blog.csdn.net/dreamermjs/article/details/52127530&quot; target=&quot;_blank&quot;&gt;iOS代码封装成.a文件(封装SDK)&lt;/a&gt;。真机上的.a动态库需要同时支持armv7,ram64架构，查看你编译出来的.a是否是正确架构可使用lipo -info kcp.a&lt;/p&gt;
&lt;p&gt;　　f）android系统：安卓系统可以在各个平台编译，我这里是在linux系统中编译的，执行对应的.sh脚本即可，andorid SDK版本为：android-ndk-r10e。关于SDK安装以及环境变量配置自行谷歌。&lt;/p&gt;
&lt;p&gt;　　g）可能根据各位自己的情况，编译过程会遇到各种小问题，但是这些问题几乎都是出在环境上，如环境变量、SDK版本、xcode版本等，我这里已经对环境信息给了足够的说明，如果你实践当中问题解决不了，可以参考我这里列举的环境。&lt;/p&gt;
&lt;p&gt;　　h）.sh文件在window下编辑可能会存在文件结束符问题，使用doc2unix命令转换就好，遇到权限问题使用chmod命令就好，其它可能遇到的细节问题自己耐心多多摸索，问题都不大。&lt;/p&gt;

&lt;p&gt;7）Unity项目动态库配置简要说明&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　a）输出目录结构：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171117223819327-1201351315.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　由于我们公司全部在window下开发，所以没有编译linux下的动态库，如果你们需要，将在x86、x86_64目录下存在libkcp.so文件。同样，window phone平台也没实测。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　b）window平台：x86、x86_64下的.dll文件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171117224301765-831522313.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　c）Mac平台：kcp.bundle，配置时选择osx系统，任意cpu&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　d）linux平台：x86、x86_64下的.so文件，相应配置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　e）andorid平台：Android子目录下的.so文件，选择Android Platform，cpu架构做对应勾选，很简单，不再截图&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　f）iOS平台：选择iOS Platform&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;8）动态库项目使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　编写对应kcp.cs文件，声明外部函数，脚本如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; KCP
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; kcp
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; UNITY_IPHONE &amp;amp;&amp;amp; !UNITY_EDITOR
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; KcpDLL = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__Internal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#else&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; KcpDLL = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kcp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         [DllImport(KcpDLL, CallingConvention=&lt;span&gt;CallingConvention.Cdecl)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;uint&lt;/span&gt; ikcp_check(IntPtr kcp, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; current);、
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其它接口省略&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　a）函数调用约定指明为cdecl&lt;/p&gt;
&lt;p&gt;　　b）所有接口以静态外部函数导出&lt;/p&gt;
&lt;p&gt;　　c）DllIport在iOS上和其它平台导出使用的参数不一样&lt;/p&gt;
&lt;p&gt;　　d）在构建你自己的动态库时依葫芦画瓢就好，没啥太多要说的&lt;/p&gt;

&lt;p&gt;9）kcp_build完整构建工程github地址：&lt;a href=&quot;https://github.com/smilehao/kcp_bulild&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/smilehao/kcp_bulild&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 17 Nov 2017 14:58:00 +0000</pubDate>
<dc:creator>SChivas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SChivas/p/7854100.html</dc:identifier>
</item>
<item>
<title>比特币区块结构Merkle树及简单支付验证分析 - Tiny熊</title>
<link>http://www.cnblogs.com/tinyxiong/p/7854079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyxiong/p/7854079.html</guid>
<description>&lt;p&gt;在比特币网络中，不是每个节点都有能力储存完整的区块链数据，受限于存储空间的的限制，很多节点是以SPV（Simplified Payment Verification简单支付验证）钱包接入比特币网络，通过简单支付验证可以在不必存储完整区块链下对交易进行验证，本文将分析区块结构Merkle树及如何进行交易验证。&lt;/p&gt;
&lt;h2 id=&quot;区块结构&quot;&gt;区块结构&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://learnblockchain.cn/2017/11/04/bitcoin-pow/&quot;&gt;工作量证明&lt;/a&gt;中出现过一个区块信息截图：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/block_info_493050.jpg&quot; alt=&quot;区块#493050&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细心的同学一定已经在里面发现了很多未讲的其他信息，如：时间戳，版本号，交易次数，二进制哈希树根(Merkle根)等。&lt;/p&gt;
&lt;p&gt;我们来看看一个区块结构到底是怎样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://learnblockchain.cn/images/block_structure.jpeg&quot; alt=&quot;区块结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图（下文称：区块结构图）所示：每个数据区块包含区块头和区块体。&lt;br/&gt;区块头封装了当前版本号、前一区块哈希值、当前区块PoW要求的随机数(Nonce)、时间戳、以及Merkle根信息。&lt;br/&gt;区块体则包括当前区块经过验证的、 区块创建过程中生成的所有交易记录。这些记录通过 Merkle树的哈希过程生成唯一的Merkle根并记入区块头.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;区块哈希值实际上并不包含在区块的数据结构里，其实区块打包时只有区块头被用于计算哈希（从网络被接收时由每个节点计算出来），常说的区块哈希值实际是区块头哈希值，它可以用来唯一、明确地标识一个区块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块包含2000个交易。因此，包含完整交易的区块比区块头的4千倍还要大。&lt;br/&gt;SPV节点只下载区块头，不下载包含在每个区块中的交易信息。这样的不含交易信息的区块链，大小只有完整区块链的几千分之1，那SPV节点是如何验证交易的呢？&lt;/p&gt;
&lt;h2 id=&quot;哈希验证&quot;&gt;哈希验证&lt;/h2&gt;
&lt;p&gt;上面先留一个引子，先来回顾下哈希函数，&lt;a href=&quot;https://learnblockchain.cn/2017/10/25/whatbc/&quot;&gt;记账原理&lt;/a&gt;我们知道原始信息任何微小的变化都会哈希完全不同的哈希值。&lt;/p&gt;
&lt;h3 id=&quot;简单文件验证&quot;&gt;简单文件验证&lt;/h3&gt;
&lt;p&gt;我们通常用哈希来检验下载的文件是否完整，我经常看到这样的下载页面：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/ex_check_file.jpeg&quot; alt=&quot;下载hash&quot;/&gt;&lt;br/&gt;可以看到下载链接后面提供了一个MD5（MD5也是一种Hash算法），这样我们可以在下载之后对文件计算MD5，如果MD5与提供的MD5相等，说明文件有没有被损坏，这个验证过程相信大家都能理解。&lt;/p&gt;
&lt;h3 id=&quot;多点文件验证哈希列表&quot;&gt;多点文件验证(哈希列表)&lt;/h3&gt;
&lt;p&gt;现在复杂度提高一点，在P2P网络中下载时，会把大文件切成小文件，同时从多个机器上下载数据，这个时候怎么验证数据呢？&lt;/p&gt;
&lt;p&gt;以BT下载为例，在下载真正的数据之前，我们会先下载一个哈希列表的（每个下小块计算出一个哈希），如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，这时有一个问题就出现了，那么多的哈希，怎么保证它们本身(哈希列表中的哈希值)都是正确地呢？&lt;/p&gt;
&lt;p&gt;答案是把每个小块数据的哈希值拼到一起，然后对这个长字符串在作一次哈希运算，得到哈希列表的根哈希。只要根哈希校对比一样就说明验哈希列表是正确的，再通过哈希列表校验小数据块，如果所有的小数据块验证通过则说明大文件没有被损坏。&lt;/p&gt;
&lt;h2 id=&quot;merkle树&quot;&gt;Merkle树&lt;/h2&gt;
&lt;p&gt;验证交易的过程和文件验证很相似，可以人为每个交易是一个小数据块，但比特币使用Merkle树的方式进行验证，相对于哈希列表，Merkle树是一种哈希二叉树，它的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，更加高效。&lt;/p&gt;
&lt;p&gt;我们回看下上面的区块结构图，区块体就包含这样一个Merkle树,Merkle树被用来归纳一个区块中的所有交易。&lt;/p&gt;
&lt;p&gt;每个叶子节点是每个交易信息的哈希，往上对相邻的两个哈希合并成字符串再哈希，继续类似的操作直到只剩下顶部的一个节点，即Merkle根，存入区块头。&lt;/p&gt;
&lt;p&gt;因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。&lt;/p&gt;
&lt;h3 id=&quot;简化支付验证&quot;&gt;简化支付验证&lt;/h3&gt;
&lt;p&gt;SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头，我们来看看它是如何对交易数据进行验证的。&lt;/p&gt;
&lt;p&gt;假如要验证区块结构图中交易6，SPV节点会通过向相邻节点索要（通过Merkleblock消息）包括从交易6哈希值沿Merkle树上溯至区块头根哈希处的哈希序列 (即哈希节点6, 5, 56, 78, 5678, 1234 1~8 - 称为认证路径) 来确认交易的存在性和正确性。（在N个交易组成的区块中确认任一交易只需要计算log2(N)个字节的哈希值，非常快速高效）&lt;/p&gt;
&lt;p&gt;大家明白了吗？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://learnblockchain.cn/&quot;&gt;深入浅出区块链&lt;/a&gt; - 系统学习区块链，打造最好的区块链技术博客&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 14:52:00 +0000</pubDate>
<dc:creator>Tiny熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyxiong/p/7854079.html</dc:identifier>
</item>
<item>
<title>Maven依赖解析 - 水木竹水</title>
<link>http://www.cnblogs.com/shuimuzhushui/p/7835158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuimuzhushui/p/7835158.html</guid>
<description>&lt;p&gt; 本文将记录Maven工程中依赖解析机制，内容包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Maven依赖基本结构&lt;/li&gt;
&lt;li&gt;从仓库解析依赖的机制&lt;/li&gt;
&lt;li&gt;依赖传递性解析实例&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;1. Maven依赖基本结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上篇文章记录了Maven依赖的聚合与继承，POM中依赖的声明通过dependency进行定义，并且通过groupId、artifactId及version三项定位Maven库中的唯一依赖。除了这三项外，还有其他属性进行限制，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;optional&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;...&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;groupId、artifactId&lt;/strong&gt;及&lt;strong&gt;version&lt;/strong&gt;三项不再叙说；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;type&lt;/strong&gt;：依赖类型，对应于项目坐标定义的packaging，默认为jar；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scope&lt;/strong&gt;：依赖范围，包括compile、test、runtime、import、provided、system；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;optional&lt;/strong&gt;：标记依赖为可选，即依赖没有传递性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exclusions&lt;/strong&gt;：排除传递性依赖&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.1 依赖范围&lt;/h3&gt;
&lt;p&gt;　　我们知道，Maven工程约定具有固定的目录结构，以便于Maven各插件对工程处理，如编译（compile）插件，会将src/main/java中的类编译到target/classes目录下，则编译对应的classpath即为target/classes。依赖范围就是控制依赖于编译classpath（target/classes）、测试classpath（target/test-classes）和运行classpath（以Web工程为例，WEB-INF/classes）的关系。具体依赖范围的讲述可参考官网文档，在此仅进行稍微总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;compile：编译依赖范围，对编译、测试、运行classpath都有效，为默认范围；&lt;/li&gt;
&lt;li&gt;test：测试依赖范围，仅对测试classpath有效；&lt;/li&gt;
&lt;li&gt;runtime：运行时依赖范围，对测试和运行classpath有效，对编译无效，如JDBC的依赖引入，因为JDK中值声明了JDBC接口，具体实现由各厂家决定；&lt;/li&gt;
&lt;li&gt;import：导入依赖范围，对三种classpath不产生实际影响，一般是导入pom类型的依赖，聚合情况下需要声明打包类型为pom，其中可包含dependencyManagement（如上一篇文章），此时对引入该依赖的工程不产生影响；&lt;/li&gt;
&lt;li&gt;provided：已提供依赖范围，对测试和编译classpath有效，对运行时无效，如servlet-api在测试或编译的时候需要，在运行的时候由容器提供，故不需要重复引入；&lt;/li&gt;
&lt;li&gt;system：系统依赖范围，与provided范围一致，需要明确指定该jar包，其不在Maven仓库中，感觉不太常用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.2 依赖传递性&lt;/h3&gt;
&lt;p&gt;依赖传递性，举例说明，比如A引用B，B引用C，正常情况下，A也会引用C依赖，即A经过传递间接引用了C（依赖为可选时，需另行处理）。具体不同范围的依赖经过传递后，其依赖范围的变化如下边（从官网扣下来的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171114223414031-737348409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖传递的准则&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;路径最近这优先，即在引用传递链上，获取出离本POM最近的传递性依赖；&lt;/li&gt;
&lt;li&gt;如果路径距离相同，则以取POM中的声明顺序靠前的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.3 可选依赖&lt;/h3&gt;
&lt;p&gt; 　　可选依赖不被传递。假设项目A依赖于B，B依赖于X和Y，并且X和Y声明为可选，则X和Y对A就不具有传递性了。如果A需要依赖于X或Y，则需要直接引用。&lt;/p&gt;
&lt;h3&gt;1.4 依赖排除&lt;/h3&gt;
&lt;p&gt; 　　假设项目A依赖于B，B依赖于C（版本为1.0），此时A会传递性依赖于C（1.0）。如果A需要引用C（2.0版本），存在两种情况：&lt;/p&gt;
&lt;p&gt;　　（1）A直接引用C（2.0），则可以不对B依赖添加exclusions元素；&lt;/p&gt;
&lt;p&gt;　　（2）A在引用B的同时，还引用D（D引用C（2.0）），则可以在引用B的时候使用exclusions元素将C（1.0）排除，也可以将D依赖声明在B之前。&lt;/p&gt;
&lt;h2&gt;2. 从仓库解析依赖的机制&lt;/h2&gt;
&lt;p&gt; 　　依赖解析的基本过程：当本地仓库中没有依赖构件，则Maven从远程仓库中下载；当依赖版本为快照版本时，Maven会自动计算最新的快照，并引用。&lt;/p&gt;
&lt;p&gt;　　背后的依赖解析机制概括如下：&lt;/p&gt;
&lt;p&gt;　　（1）当依赖的范围为system，则从本机文件系统中解析构件；&lt;/p&gt;
&lt;p&gt;　　（2）根据依赖坐标计算定位依赖位置后，尝试从本地仓库寻找依赖，若找到，则解析成功；&lt;/p&gt;
&lt;p&gt;　　（3）若本地仓库没有对应构件，则遍历所有远程仓库，发现后解析下载；&lt;/p&gt;
&lt;p&gt;　　（4）如果依赖的版本为RELEASE或LATEST，则读取所有远程仓库的元数据groupId/artifactId/version/maven-metadata.xml，与本地元数据合并后，计算出RELEASE或LATEST的真实值，然后基于真实值检查本地仓库和远程仓库，如步骤（2）（3）；&lt;/p&gt;
&lt;p&gt;　　（5）如果依赖的版本为SNAPSHOT，类似的，读取远程仓库的元数据，并与本地元数据合并，计算出最新版本的快照，再从本地仓库和远程仓库检索。&lt;/p&gt;
&lt;p&gt; 下边为一个快照版本依赖的元数据maven-metadata-local.xml，包括最近更新时间戳，以及存在的不同版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;C&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;versioning&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;versions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;versions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lastUpdated&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;20171113125841&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lastUpdated&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;versioning&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;metadata&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 对应文件目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117212125624-514626631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3. 依赖传递性解析实例&lt;/h2&gt;
&lt;p&gt; 　　创建3个Maven工程A、B、C（命令mvn archetype:generate）。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）编辑各自的POM文件，使其依赖关系如下图所示&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;                    &lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117213021062-495242052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中B为A的直接依赖，C具有传递性，为A的传递性依赖，分析其依赖树可以直观的看出依赖关系（mvn dependency:tree），如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;B依赖于C（1.0）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117213457406-1474080052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; A依赖于B（1.0），间接依赖C（1.0）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117213536687-786866654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）将B对的C的依赖改为optional，即可选的，此时A的依赖树如下，不包括C：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117214924327-425545072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）修改POM文件，使其依赖关系如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117213603484-62349889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 看A的依赖树，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1012728/201711/1012728-20171117213710359-665992521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 综上，正常情况下依赖是具有传递性，除非声明为optional。&lt;/p&gt;
&lt;h2&gt;总结：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;声明依赖时，除了常用的三项位置元素，还具有包括范围、类型、可选和排除等；&lt;/li&gt;
&lt;li&gt;依赖具有传递性，具有路径优先的约定；&lt;/li&gt;
&lt;li&gt;当引用多个工程时，会潜在的引用其他依赖，需要注意是否会引错包，或者冲突；&lt;/li&gt;
&lt;li&gt;Maven依赖解析，对于本地库中没有的构件，Maven会综合远程仓库与本地仓库的元数据，计算最新版本后，再引用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考：&lt;/h2&gt;
</description>
<pubDate>Fri, 17 Nov 2017 14:01:00 +0000</pubDate>
<dc:creator>水木竹水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shuimuzhushui/p/7835158.html</dc:identifier>
</item>
<item>
<title>Hive 学习笔记（启动方式，内置服务） - NetUML大数据搜索</title>
<link>http://www.cnblogs.com/netuml/p/7841387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/netuml/p/7841387.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Hive介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Hive是基于Hadoop的一个数据仓库，Hive能够将SQL语句转化为MapReduce任务进行运行。&lt;/p&gt;
&lt;p&gt;　　Hive架构图分为以下四部分。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/93998/201711/93998-20171116205206937-1496676969.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;231&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;1、用户接口&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　 Hive有三个用户接口：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;命令行接口（CLI）:以命令行的形式输入SQL语句进行数据数据操作&lt;/li&gt;
&lt;li&gt;Web界面：通过Web方式进行访问。　　　　　&lt;/li&gt;
&lt;li&gt;Hive的远程服务方式：通过JDBC等方式进行访问。　　　　　　　　　　　　　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;2、元数据存储&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　 将元数据存储在关系数据库中（MySql、Derby），元数据包括表的属性、表的名称、表的列、分区及其属性以及表数据所在的目录等。&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;3、解释器、编译器、优化器&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　 分别完成SQL查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在HDFS中，并在随后由MapReduce调用执行。&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;4、数据存储&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　 Hive没有专门的数据存储格式，也没有为数据建立索引，Hive中所有数据都存储在HDFS中。&lt;/p&gt;
&lt;p&gt;　　　 Hive包含以下数据模型：表、外部表、分区和桶&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Metadata，Metastore 的作用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;em&gt;Metadata即元数据:&lt;/em&gt;&lt;/strong&gt;   元数据包含用Hive创建的database、tabel等的元信息。元数据存储在关系型数据库中。如Derby、MySQL等。&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;Metastore的作用是:&lt;/strong&gt;&lt;/em&gt;  客户端连接metastore服务，metastore再去连接MySQL数据库来存取元数据。&lt;/p&gt;
&lt;p&gt;　　有了metastore服务，就可以有多个客户端同时连接，而且这些客户端不需要知道MySQL数据库的用户名和密码，只需要连接metastore 服务即可。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、Hive的元数据存储(Metastore三种配置方式)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;由于元数据不断地修改、更新，所以Hive元数据不适合存储在HDFS中，一般存在RDBMS中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　 &lt;em&gt;&lt;strong&gt;1、内嵌模式（Embedded）&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　  &lt;span&gt;hive服务和metastore服务运行在同一个进程中，derby服务也运行在该进程中.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　  内嵌模式使用的是内嵌的Derby数据库来存储元数据，也不需要额外起Metastore服务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　  这个是默认的，配置简单，但是一次只能一个客户端连接，适用于用来实验，不适用于生产环境。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;em&gt;&lt;strong&gt;2、本地模式（Local）:本地安装mysql 替代derby存储元数据&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　这种安装方式和嵌入式的区别在于，不再使用内嵌的Derby作为元数据的存储介质，而是使用其他数据库比如MySQL来存储元数据。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;hive服务和metastore服务运行在同一个进程中，mysql是单独的进程，可以同一台机器，也可以在远程机器上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　这种方式是一个多用户的模式，运行多个用户client连接到一个数据库中。这种方式一般作为公司内部同时使用Hive。&lt;/p&gt;
&lt;p&gt;　　　　每一个用户必须要有对MySQL的访问权利，即每一个客户端使用者需要知道MySQL的用户名和密码才行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;javax.jdo.option.ConnectionURL&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql://127.0.0.1:3306/hive? createDatabaseIfNotExit=true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;javax.jdo.option.ConnectionDriverName&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mysql.jdbc.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;javax.jdo.option.ConnectionUserName&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;javax.jdo.option.ConnectionPassword&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hive.metastore.uris&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;指向的是运行metastore服务的主机,这是hive客户端配置，metastore服务不需要配置&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  　&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hive.metastore.warehouse.dir&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/user/hive/warehouse&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    　　&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;hive表的默认存储路径,为HDFS的路径&lt;/span&gt;location of default database for the warehouse&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;3、远程模式（Remote）: 远程安装mysql 替代derby存储元数据&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;Hive服务和metastore在不同的进程内，可能是不同的机器&lt;/span&gt;，该模式需要将hive.metastore.local设置为false，将hive.metastore.uris设置为metastore服务器URL，&lt;/p&gt;
&lt;p&gt;　　　　如果有多个metastore服务器，将URL之间用逗号分隔，metastore服务器URL的格式为thrift://127.0.0.1:9083。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;远程元存储需要单独起metastore服务，然后每个客户端都在配置文件里配置连接到该metastore服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　将metadata作为一个单独的服务进行启动。各种客户端通过beeline来连接，连接之前无需知道数据库的密码。&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;仅连接远程的mysql并不能称之为“远程模式”，是否远程指的是metastore和hive服务是否在同一进程内.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　hive metastore 服务端启动命令：&lt;br/&gt;&lt;code&gt;　　　　&lt;strong&gt;hive --service metastore -p &amp;lt;port_num&amp;gt;&lt;/strong&gt;&lt;/code&gt;&lt;br/&gt;　　　　如果不加端口默认启动：&lt;code&gt;hive --service metastore&lt;/code&gt;，则默认监听端口是：9083 。&lt;/p&gt;
&lt;p&gt;　　　　注意客户端中的端口配置需要和启动监听的端口一致。服务端启动正常后，客户端就可以执行hive操作了。&lt;/p&gt;
&lt;p&gt;　　 　  &lt;em&gt;客户端连接metastore服务配置如下&lt;/em&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hive.metastore.uris&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;thrift://127.0.0.1:9083，thrift://127.0.0.1:9084&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;指向的是运行metastore服务的主机&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;在服务器端启动一个MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer访问元数据库。如下图：&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/93998/201711/93998-20171117212235718-2061466074.png&quot; alt=&quot;&quot; width=&quot;327&quot; height=&quot;112&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、Thrift 服务 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过hiveServer/hiveServer2启动Thrift服务，客户端连接Thrift服务访问Hive数据库（JDBC，JAVA等连接Thrift服务访问Hive）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　&lt;strong&gt;&amp;lt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hive.server2.thrift.port&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Port number of HiveServer2 Thrift interface when hive.server2.transport.mode is 'binary'.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hive.server2.thrift.bind.host&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;127.0.0.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Bind host on which to run the HiveServer2 Thrift service.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hive.server2.enable.doAs&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      Setting this property to true will have HiveServer2 execute
      Hive operations as the user making the calls to it.&lt;br/&gt;　　　 如果为True：Hive Server会以提交用户的身份去执行语句&lt;br/&gt;　　　 如果为False：会以hive server daemon的admin user来执行语句&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;启动Thrift服务：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;hive --service hiveserver2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 测试Thrift服务：&lt;/p&gt;
&lt;p&gt;　　 新开一个命令行窗口，执行beeline命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;shuwendeMBP:~ shuwen$ beeline
Beeline version 1.2.1.spark2 by Apache Hive
beeline&amp;gt; !&lt;strong&gt;connect jdbc:hive2://127.0.0.1:10000&lt;/strong&gt;
Connecting to jdbc:hive2://127.0.0.1:10000
Enter username for jdbc:hive2://127.0.0.1:10000: shuwen
Enter password for jdbc:hive2://127.0.0.1:10000: ******
log4j:WARN No appenders could be found for logger (org.apache.hive.jdbc.Utils).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
Connected to: Apache Hive (version 1.2.2)
Driver: Hive JDBC (version 1.2.1.spark2)
Transaction isolation: TRANSACTION_REPEATABLE_READ
0: jdbc:hive2://127.0.0.1:10000&amp;gt; show databases;
+----------------+--+
| database_name  |
+----------------+--+
| db_2_1         |
| default        |
| netuml         |
+----------------+--+
3 rows selected (1.941 seconds)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、Hive的三种启动方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;1、hive 命令行模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　进入hive安装目录，输入bin/hive的执行程序，或者输入 hive –service cli，用于linux平台命令行查询，查询语句基本跟mysql查询语句类似&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;2、hive web界面的启动方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;Hive 2.0 以后才支持Web UI的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　bin/hive –service hwi （&amp;amp; 表示后台运行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　用于通过浏览器来访问hive，感觉没多大用途，浏览器访问地址是：127.0.0.1:9999/hwi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;3、hive 远程服务 (端口号10000) 启动方式 （Thrift服务）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  bin/hive –service hiveserver2 &amp;amp;（&amp;amp;表示后台运行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  用java，python等程序实现通过jdbc等驱动的访问hive就用这种起动方式了，这个是程序员最需要的方式了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、Hive几种内置服务 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　执行bin/hive --service help 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
shuwendeMBP:~ shuwen$ hive --&lt;span&gt;service help
Usage .&lt;/span&gt;/hive &amp;lt;parameters&amp;gt; --service serviceName &amp;lt;service parameters&amp;gt;&lt;span&gt;
Service List: beeline cli help hiveburninclient hiveserver hiveserver2 hwi jar lineage metastore metatool orcfiledump rcfilecat schemaTool version 
Parameters parsed:
  &lt;/span&gt;--&lt;span&gt;auxpath : Auxillary jars 
  &lt;/span&gt;--&lt;span&gt;config : Hive configuration directory
  &lt;/span&gt;--service : Starts specific service/component. cli &lt;span&gt;is&lt;/span&gt; &lt;span&gt;default&lt;/span&gt;&lt;span&gt;
Parameters used:
  HADOOP_HOME or HADOOP_PREFIX : Hadoop install directory
  HIVE_OPT : Hive options
For help on a particular service:
  .&lt;/span&gt;/hive --service serviceName --&lt;span&gt;help
Debug help:  .&lt;/span&gt;/hive --debug --help
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们可以看到上边输出项Server List，里边显示出Hive支持的服务列表，beeline cli help hiveserver2 hiveserver hwi jar lineage metastore metatool orcfiledump rcfilecat。&lt;/p&gt;
&lt;p&gt;　　下面介绍最有用的一些服务&lt;/p&gt;
&lt;p&gt;　　1、cli：是Command Line Interface 的缩写，是Hive的命令行界面，用的比较多，是默认服务，直接可以在命令行里使用。&lt;/p&gt;
&lt;p&gt;　　3、hwi：其实就是hive web interface的缩写它是hive的web借口，是hive cli的一个web替代方案。&lt;/p&gt;
&lt;p&gt;　　2、hiveserver：这个可以让Hive以提供Thrift服务的服务器形式来运行，可以允许许多个不同语言编写的客户端进行通信，使用需要启动HiveServer服务以和客户端联系，&lt;/p&gt;
&lt;p&gt;　　　 我们可以通过设置HIVE_PORT环境变量来设置服务器所监听的端口，在默认情况下，端口号为10000，这个可以通过以下方式来启动Hiverserver：&lt;/p&gt;
&lt;p&gt;　　　 bin/hive --service hiveserver -p 10002&lt;/p&gt;
&lt;p&gt;　　　 其中-p参数也是用来指定监听端口的&lt;br/&gt;　　&lt;br/&gt;　　4、jar：与hadoop jar等价的Hive接口，这是运行类路径中同时包含Hadoop 和Hive类的Java应用程序的简便方式&lt;/p&gt;
&lt;p&gt;　　5、metastore：在默认的情况下，metastore和hive服务运行在同一个进程中，使用这个服务，可以让metastore作为一个单独的进程运行。&lt;/p&gt;
&lt;p&gt;　　　 我们可以通过METASTOE——PORT来指定监听的端口号&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 七、问题总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;Could not create ServerSocket on address 0.0.0.0/0.0.0.0:9083&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇到这种情况大家都找不到头绪，是因为你开始运行了hive的metastore，可以输入jps&lt;br/&gt;查看有没有RunJar&lt;br/&gt;然后再输入&lt;br/&gt;hive --service metastore启动&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;16.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Hive在spark2.0.0启动时无法访问spark-assembly-*.jar的解决办法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ls: /usr/local/share/spark-2.0.0-bin-hadoop2.7/lib/spark-assembly-*.jar: No such file or directory&lt;br/&gt;发现主要原因是：在/&amp;lt;PathToHive&amp;gt;/bin/hive文件中，有这样的命令：加载spark中相关的JAR包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; [[ -n &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$SPARK_HOME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]]
then
sparkAssemblyPath&lt;/span&gt;=`ls ${SPARK_HOME}/lib/spark-assembly-*&lt;span&gt;.jar`
CLASSPATH&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${CLASSPATH}:${sparkAssemblyPath}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是spark升级到spark2以后，原有lib目录下的大JAR包被分散成多个小JAR包，原来的spark-assembly-*.jar已经不存在，所以hive没有办法找到这个JAR包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法:修改/&amp;lt;PathToHive&amp;gt;/bin/hive文件，将加载原来的lib/spark-assembly-*.jar`替换成jars/*.jar，就不会出现这样的问题。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;1.hive.metastore.uris指向的是运行metastore服务的主机，并不是指向运行hiveserver的主机，那台主机不用启动hiveserver也ok；&lt;/p&gt;
&lt;p&gt;2.直接使用hive命令启动shell环境时，其实已经顺带启动了hiveserver，所以远程模式下其实只需要单独启动metastore，然后就可以进入shell环境正常使用&lt;/p&gt;
&lt;p&gt;3.hiveserver和metastore进程名都叫RunJar。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Fri, 17 Nov 2017 13:42:00 +0000</pubDate>
<dc:creator>NetUML大数据搜索</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/netuml/p/7841387.html</dc:identifier>
</item>
<item>
<title>【概率论与数理统计】小结6 - 大数定理与中心极限定理 - 昕-2008</title>
<link>http://www.cnblogs.com/Belter/p/7750745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Belter/p/7750745.html</guid>
<description>&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：这两个定理可以说是概率论中最重要的两个定理。也是由于中心极限定理的存在，使得正态分布从其他众多分布中脱颖而出，成为应用最为广泛的分布。这两个定理在概率论的历史上非常重要，因此对于它们的研究也横跨了几个世纪（始于18世纪初），众多耳熟能详的大数学家都对这两个定理有自己的贡献。因此，这两个定理都不是单一的定理。不同的大数定理和中心极限定理从不同的方面对相同的问题进行了阐述，它们条件各不相同，得到的结论的强弱程度也不一样。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 大数定理（law of large numbers，LLN）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201710/1035701-20171029171104023-1921352023.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1-1，伯努利（1655-1705）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大数定律可以说是整个数理统计学的一块基石，最早的大数定律由伯努利在他的著作《推测术》中提出并给出了证明。这本书出版于伯努利去世后的1713年。数理统计学中包含两类重要的问题——对概率p的检验与估计。大数定律的本质是一类极限定理，它是由概率的统计定义“频率收敛于概率”引申而来的。简单来说就是n个独立同分布的随机变量的观察值的均值$\bar{X}$依概率收敛于这些随机变量所属分布的理论均值，也就是总体均值。&lt;/p&gt;

&lt;p&gt;举一个古典概率模型的例子：拿一个盒子，里面装有大小、质地一样的球a+b个，其中白球a个，黑球b个。这时随机地从盒子中抽出一球(意指各球有同等可能被抽出)，则“抽出的球为白球”这一事件A的概率p=a/(a+b).但是如果不知道a、b的比值，则p也不知道。但我们可以反复从此盒子中抽球(每次抽出记下其颜色后再放回盒子中)。设抽了N次，发现白球出现了m次，则用m/N去估计p。这个估计含有其程度不确定的误差，但我们直观上会觉得，抽取次数N越大，误差一般会缩小。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从实用的角度看，概率的统计定义无非是一种通过实验去估计事件概率的方法。&lt;/span&gt;大数定律为这种后验地认识世界的方式提供了坚实的理论基础。正如伯努利在结束《推测术》时就其结果的意义作的表述：“如果我们能把一切事件永恒地观察下去，则我们终将发现：世间的一切事物都受到因果律的支配，而我们也注定会在种种极其纷纭杂乱的现象中认识到某种必然。”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设$X_1, X_2, ..., X_n$是独立同分布的随机变量，记它们的公共均值为$\mu$。又设它们的方差存在并记为$\sigma^2$。则对任意给定的$\varepsilon &amp;gt; 0$，有&lt;/p&gt;
&lt;p&gt;$$\displaystyle \lim_{ n \to \infty } P(| \bar{X}_n - \mu| \geq \varepsilon) = 0 \hspace{ 10pt } \ldots (1-1)$$&lt;/p&gt;
&lt;p&gt;这个式子指出了“当n很大时，$\bar{X}_n$接近$\mu$”的确切含义。这里的“接近”是概率上的，也就是说虽然概率非常小，但还是有一定的概率出现意外情况（例如上面的式子中概率大于$\varepsilon$）。只是这样的可能性越来越小，这样的收敛性，在概率论中叫做“$\bar{X}_n$依概率收敛于$\mu$”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 Python模拟抛硬币&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面用程序模拟抛硬币的过程来辅助说明大数定律：&lt;/p&gt;
&lt;p&gt;用random模块生成区间[0,1)之间的随机数，如果生成的数小于0.5，就记为硬币正面朝上，否则记为硬币反面朝上。由于random.random()生成的数可以看做是服从区间[0,1)上的均匀分布，所以以0.5为界限，随机生成的数中大于0.5或小于0.5的概率应该是相同的(相当于硬币是均匀的)。这样就用随机数模拟出了实际的抛硬币试验。理论上试验次数越多(即抛硬币的次数越多)，正反面出现的次数之比越接近于1(也就是说正反面各占一半).&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; flip_plot(minExp, maxExp):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    Assumes minExp and maxExp positive integers; minExp &amp;lt; maxExp
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    Plots results of 2**minExp to 2**maxExp coin flips
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两个参数的含义，抛硬币的次数为2的minExp次方到2的maxExp次方，也就是一共做了(2**maxExp - 2**minExp)批次实验，每批次重复抛硬币2**n次&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     ratios =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     xAxis =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; exp &lt;span&gt;in&lt;/span&gt; range(minExp, maxExp + 1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         xAxis.append(2**&lt;span&gt;exp)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; numFlips &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xAxis:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         numHeads = 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化，硬币正面朝上的计数为0&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(numFlips):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; random.random() &amp;lt; 0.5:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; random.random()从[0, 1)随机的取出一个数&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 numHeads += 1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当随机取出的数小于0.5时，正面朝上的计数加1&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         numTails = numFlips - numHeads  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到本次试验中反面朝上的次数&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         ratios.append(numHeads/float(numTails))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;正反面计数的比值&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Heads/Tails Ratios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number of Flips&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Heads/Tails&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    plt.plot(xAxis, ratios)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     plt.hlines(1, 0, xAxis[-1], linestyles=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dashed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, colors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; flip_plot(4, 16)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201710/1035701-20171029173633023-85850968.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;435&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1-2，随着实验次数的增加，正反面出现次数之比越来越接近于1&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2. 中心极限定理（central limit theorem，CLT）&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;与大数定理描述某个值的收敛趋势不同，中心极限定理描述的是某种形式的随机变量之和的分布。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;2.1 从大数定理到中心极限定理&lt;/strong&gt;&lt;/h4&gt;
&lt;h5&gt;2.1.1 对于这两个定理之间的联系与区别，知乎上的Detian Deng有如下回答：&lt;/h5&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;简单来说，大数定律（LLN）和中心极限定理（CLT）的联系与区别在于：&lt;/p&gt;
&lt;p&gt;共同点：都是用来描述独立同分布（i.i.d）的随机变量的和的渐进表现（asymptotic behavior)&lt;/p&gt;
&lt;p&gt;区别：首先，它们描述的是在不同的收敛速率（convergence rate）之下的表现，其次LLN前提条件弱一点：$E(|X|) &amp;lt; \infty$ , CLT成立条件强一点：$E(X^2) &amp;lt; \infty$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的描述中，$E(X^2) &amp;lt; \infty$相当于表示随机变量$X$的二阶原点矩存在，即方差存在；$E(|X|) &amp;lt; \infty$表示$X$的一阶原点矩存在，即期望存在。方差存在可以推出期望存在，但是反之则不行。&lt;/p&gt;

&lt;h5&gt;2.1.2 我自己的理解：&lt;/h5&gt;
&lt;p&gt;利用大数定理我们可以用样本均值估计总体分布的均值。例如抛硬币，假如我们有一枚不均匀的硬币，事先并不知道正面朝上的概率$P_h$。那么我们可以大量重复抛这枚硬币，统计正面朝上的次数，用这个值除以抛硬币的总次数，就可以近似的得到一个比值，例如$P_1$。这个值就是对$P_h$的估计，根据大数定理，我们可以保证抛硬币的总次数越多这个估计的误差就越小（即$P_1$依概率收敛于$P_h$）。对于大数定理，故事到这里就结束了。&lt;/p&gt;
&lt;p&gt;此时，如果我们将每次抛硬币都看成是一次伯努利试验，即$X \sim B(1, P_h)$，其中正面朝上记为1，概率为$P_h$。由于是同一个人进行的试验，可以将每次试验都看作是独立同分布。对于充分大的n，根据中心极限定理可得：&lt;/p&gt;
&lt;p&gt;$$X_1 + X_2 + \cdots + X_n \sim N(nP_h, nP_h(1-P_h)) \hspace{ 10pt } \ldots (2-1)$$&lt;/p&gt;
&lt;p&gt;上式表示所有试验结果之和，也就是硬币正面朝上的总次数，服从均值为$nP_h$，方差为$nP_h(1-P_h)$的正态分布。这里的分布是&lt;span&gt;近似分布&lt;/span&gt;。严格意义上来说，n次伯努利试验之和服从二项分布$B(n, P_h)$，近似的正态分布中的均值和方差与对应的二项分布相同。式2-1是&lt;span&gt;利用正态分布近似估计二项分布&lt;/span&gt;的理论基础（在$n$很大的前提下：$p$固定，$np$也很大时常用正态分布逼近；当$p$很小，$np$不太大时常用泊松分布逼近）。该式也是历史上最早的中心极限定理的表述形式。1716年棣莫弗讨论了p=1/2的情况，后来拉普拉斯将其推广到了一般p的情形。因此式2-1又叫做&lt;span&gt;&lt;strong&gt;棣莫弗-拉普拉斯中心极限定理&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;到这里，故事还没有结束。&lt;/p&gt;
&lt;p&gt;假如此时又来了一个人，他不相信前一个人的试验结果，自己重新做了一次试验：大量的重复抛这枚硬币，他的估计值是$P_2$。接着又来了第三个人，第四个人，...，这些人每个人都做了一次这样的试验，每个人都得到了一个估计值$P_i$。那么这些不同的估计值之间有什么联系呢？类似上面一个人抛硬币的过程，如果将每个人抛硬币的试验看做是二项分布$B(n, P_h)$，正面记为1，背面记为0。那么每个人的试验结果之和都相当于一个具体的观察值，表示其试验中硬币正面朝上的总次数$X$。正面朝上的概率可以用$X/n$来估计。&lt;/p&gt;
&lt;p&gt;由大数定理可得$X - n*P_h$依概率收敛于0（也就是说如果每个人的重复次数都非常多的话，每个人的结果都是依概率收敛于二项分布的期望），中心极限定理进一步给出了下面的结论：&lt;/p&gt;
&lt;p&gt;值得注意的一点是，此时需要区分两个不同的量：一个是每个人重复伯努利试验的次数，还是取为$n$；另一个是参与试验的人数，这里取为$m$。&lt;/p&gt;
&lt;p&gt;$$X_1 + X_2 + \cdots + X_m \sim N(\mu, \sigma^2) \hspace{ 10pt } \ldots (2-2)$$&lt;/p&gt;
&lt;p&gt;也就是说，这m个不同的人的试验结果之和也是属于正态分布的。由于每个人的试验都相当于是一个二项分布，假如将每个二项分布都用式2-1逼近，那么这里的和就相当于服从式子2-1中正态分布的随机变量之和（这些不同的随机变量之间相互独立），也就不难求出这里的均值和方差分别为：$\mu = mnP_h, \sigma^2 = mnP_h(1-P_h)$。由于这些随机变量之间是相互独立的，因此求和以后均值和方差都扩大了m倍。&lt;/p&gt;
&lt;p&gt;此外，&lt;/p&gt;
&lt;p&gt;$$\bar{X} \sim N(nP_h, nP_h(1-P_h)/m) \hspace{ 10pt } \ldots (2-3)$$&lt;/p&gt;
&lt;p&gt;其中，$\bar{X} = \frac{1}{m} \displaystyle \sum_{i=1}^{m}X_i$。同样本均值的均值和方差，m个人的结果均值的均值没变，方差缩小了m倍。&lt;/p&gt;
&lt;p&gt;这里还有一个很好的问题是，m取多少比较合适。如果只取1，上面三个式子都是等价的，随着人数的增加，式2-3的方差越来越小，也就是说用多人的均值来估计的结果也越来越准确（不确定性减小了），而式2-2的方差会越来越大（所有人的试验结果之和）。对于式2-2，和式中的每一项都是一个二项分布，而不是式2-1中的伯努利分布。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么和式中的每一项可以是其他分布吗？&lt;/span&gt;其实和式中的每一项可以是任意分布，只要每一项都是独立同分布且该分布的方差存在，那么当$m$趋近于无穷大时，它们的和就服从正态分布：&lt;/p&gt;
&lt;p&gt;$$X_1 + X_2 + \cdots + X_m \sim N(m\mu, m\sigma^2) \hspace{ 10pt } \ldots (2-4)$$&lt;/p&gt;
&lt;p&gt;其中$\mu$与$\sigma$是和式中每一项所属分布的期望和标准差。 式2-4是2-1的进一步推广，条件更弱，适用范围更加广泛。这就是独立同分布下的中心极限定理也叫作&lt;strong&gt;&lt;span&gt;林德伯格-莱维（Lindeberg-Levi中心极限定理）&lt;/span&gt;&lt;/strong&gt;。这里的服从也是近似服从。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;2.2 用Python程序模拟中心极限定理&lt;/strong&gt;&lt;/h4&gt;
&lt;h5&gt;2.2.1 模拟服从伯努利分布的随机变量之和&lt;/h5&gt;
&lt;p&gt;这就相当于一个人做抛硬币的试验（正面朝上为1，反面朝上为0），这些试验结果之和就表示这个人的试验中出现正面朝上的总次数。&lt;/p&gt;
&lt;p&gt;设单次伯努利试验服从$B(1, p)$，单次试验抛硬币n次（这n次试验结果合起来为该试验条件下的一个样本），那么这些试验结果之和近似服从$N(np, np(1-p))$。其中$np$表示均值$\mu$，$np(1-p)$表示方差$\sigma^2$。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201711/1035701-20171116101323452-1806045019.png&quot; alt=&quot;&quot; width=&quot;966&quot; height=&quot;725&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2-1，n依次等于1, 4, 20, 80, 200, 1000；p等于0.4的伯努利分布之和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上图红色曲线表示用于逼近&quot;多个取自伯努利分布的随机变量之和&quot;的正态分布的概率密度曲线。由上图可以看到，当n（单次试验抛硬币的次数）等于20的时候，随机变量和的分布和对应的近似正态分布的形状已经高度重合。但是当n继续增大时，拟合程度反而有所下降，这是由于试验次数（下面代码中，函数sampling2pmf的参数t，相当于总的试验次数）和在x轴上分割的区间数（代码中第49行的bins）太小造成的。&lt;/p&gt;
&lt;p&gt;t的大小就是最终&quot;随机变量之和&quot;这个新随机变量的取样个数（因此总共抛硬币$t*n$次）。&lt;/p&gt;
&lt;p&gt;当n=1时，该随机变量就是伯努利分布本身，这时只有两个可能的取值：0和1，因此1出现了$tp$次，0出现了$t(1-p)$次。&lt;/p&gt;
&lt;p&gt;当n=20时，该随机变量是20个服从伯努利分布的随机变量之和。这时的可能取值为[0, 20]的整数。0就表示这20次试验全都背面朝上，20就表示这20次试验全都正面朝上。每次试验都可以得到一个位于区间[0, 20]的整数，试验结束后，最终得到了t个这样的整数，这些整数的直方图的形状也近似为正态分布的形状。&lt;/p&gt;
&lt;p&gt;下面是代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; stats
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Created on Sun Nov 12 08:44:37 2017
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@author: Belter
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; sampling2pmf(n, dist, t=10000&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    n: sample size for each experiment
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    t: how many times do you do experiment, fix in 10000
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    dist: frozen distribution
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     ber_dist =&lt;span&gt; dist
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     sum_of_samples =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(t):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         samples = ber_dist.rvs(size=&lt;span&gt;n)  &lt;span&gt;# 与每次取一个值，取n次效果相同
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        sum_of_samples.append(np.sum(samples))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     val, cnt = np.unique(sum_of_samples, return_counts=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     pmf = cnt /&lt;span&gt; len(sum_of_samples)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; val, pmf
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; plot(n, dist, subplot, plt_handle):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    :param n: sample size
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    :param dist: distribution of each single sample
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    :param subplot: location of sub-graph, such as 221, 222, 223, 224
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    :param plt_handle: plt object
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    :return: plt object
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     bins = 10000
&lt;span&gt;38&lt;/span&gt;     plt =&lt;span&gt; plt_handle
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    plt.subplot(subplot)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     mu = n *&lt;span&gt; dist.mean()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     sigma = np.sqrt(n *&lt;span&gt; dist.var())
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     samples = sampling2pmf(n=n, dist=&lt;span&gt;dist)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     plt.vlines(samples[0], 0, samples[1&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                colors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, linestyles=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, lw=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Probability&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sum of bernoulli dist. (n={})&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; normal distribution&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     norm_dis =&lt;span&gt; stats.norm(mu, sigma)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     norm_x = np.linspace(mu - 3 * sigma, mu + 3 *&lt;span&gt; sigma, bins)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     pdf1 =&lt;span&gt; norm_dis.pdf(norm_x)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     plt.plot(norm_x, pdf1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; plt
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt; size = [1, 4, 20, 80, 200, 1000&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sum of bernoulli distribution&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; dist_type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bern&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; bern_para = [0.4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; single_sample_dist = stats.bernoulli(p=bern_para[0])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个伯努利分布&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面是利用matplotlib画图&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; plt.figure(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; plt = plot(n=size[0], dist=single_sample_dist, subplot=321, plt_handle=&lt;span&gt;plt)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; plt = plot(n=size[1], dist=single_sample_dist, subplot=322, plt_handle=&lt;span&gt;plt)
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; plt = plot(n=size[2], dist=single_sample_dist, subplot=323, plt_handle=&lt;span&gt;plt)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; plt = plot(n=size[3], dist=single_sample_dist, subplot=324, plt_handle=&lt;span&gt;plt)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; plt = plot(n=size[4], dist=single_sample_dist, subplot=325, plt_handle=&lt;span&gt;plt)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; plt = plot(n=size[5], dist=single_sample_dist, subplot=326, plt_handle=&lt;span&gt;plt)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;plt.tight_layout()
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum_of_{}_dist.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(dist_type), dpi=200)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;将上面代码中第13行的t和37行的bins都从10,000增加到1,000,000，可以得到下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201711/1035701-20171116102406999-1969182468.png&quot; alt=&quot;&quot; width=&quot;883&quot; height=&quot;662&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图2-2，增加试验次数和在x轴上的分割区间，其他参数同2-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，增加试验次数和在x轴上分割区间的个数后，随机变量之和与正态分布之间的重合度随着样本量（在代码的54行定义）的增加而升高。这也很容易解释：对于随机变量和的分布，抽样次数（试验次数）越多，最终画出来的图越能代表整个分布。但是抽样次数本身却不影响该分布的类型和参数，就像在学校研究全体同学的身高，抽样的人数不会影响身高的真实分布，只会影响我们利用所得的样本描绘出来的分布的形状。&lt;/p&gt;
&lt;p&gt;此外，还有一个因素对随机变量和的分布也有极大的影响：单次试验所在分布的参数，这里是指伯努利分布中的参数$p$，下面是将$p$从$0.4$增加到$0.99$后的图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201711/1035701-20171116103947687-1783914277.png&quot; alt=&quot;&quot; width=&quot;948&quot; height=&quot;711&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;图2-3，n依次等于1, 4, 20, 80, 200, 1000；p等于0.99的伯努利分布之和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 由上图可以看到，由于单个样本所在的伯努利分布严重不均匀（如果这个试验表示抛硬币且正面朝上记为1，那就意味着99%的情况下都只出现正面），导致后面随机变量之和的图形都出现了偏斜。但是，偏斜程度随着样本量的增加而降低。如果样本量继续增加，就会基本消除这种偏斜。&lt;/p&gt;

&lt;h5&gt;2.2.2 模拟服从二项分布的随机变量之和&lt;/h5&gt;
&lt;p&gt;这就相当于多个人做抛硬币的试验（正反面朝上还是分别记为1和0），这些试验结果之和就表示所有人的试验中出现正面朝上的总次数。&lt;/p&gt;
&lt;p&gt;设单次二项试验服从$B(m, p)$，参与人数为n，那么这些试验结果之和近似服从$N(nmp, nmp(1-p))$。其中$nmp$表示均值$\mu$，$nmp(1-p)$表示方差$\sigma^2$。&lt;/p&gt;
&lt;p&gt;只需要将上面代码中的57-59行替换成下面的代码就可以模拟出二项分布之和的情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; dist_type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bino&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; bino_para = [20, 0.4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; single_sample_dist = stats.binom(n=bino_para[0], p=bino_para[1])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个二项分布&lt;/span&gt;
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201711/1035701-20171116150142874-1760963733.png&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;681&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2-4，n依次等于1, 4, 20, 80, 200, 1000；参数为(20, 0.4)的二项分布之和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图片中的n表示每次试验参加的人数，一个人做一次试验，试验服从$B(20， 0.4)$。&lt;/p&gt;
&lt;p&gt;当n=1时，就相当于图2-1中n=20的情况：都是一个人重复&quot;抛20次硬币&quot;这一试验，正面朝上的概率也相同。&lt;/p&gt;
&lt;p&gt;当n=80时，就相当于有80个人同时做服从参数为(20, 0.4)的二项分布试验，&lt;span&gt;这些人之间的试验是相互独立的&lt;/span&gt;，然后将这些人的实验结果相加：所以此时的均值为80*20*0.4=640，标准差为$\sqrt{80*20*0.4*(1-0.4)} \approx 19.6$，且最大值为80*20=1600（相当于所有人的试验结果全部都是1），最小值为0（相当于所有人的试验结果都是0）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;宏观解释&lt;/span&gt;：当非常多的人一起重复结果服从该二项分布的试验时，每次抛硬币最可能得到正面朝上的概率始终都是$p$，因此这些人完成一次试验的结果之和的期望就是：人数 * 每人单次试验抛硬币数 * 硬币正面朝上的概率，即$n * 20 * 0.4$。得到硬币正面朝上的结果小于这个概率，会导致试验结果之和小于平均值；反之则会使试验结果之和大于平均值。但是这两种情况都没有以概率$p$出现更常见，因此就产生了取到均值的概率最大，越往两边概率越小的钟型概率密度曲线。&lt;/p&gt;

&lt;h5&gt;2.2.3 模拟服从均匀分布的随机变量之和&lt;/h5&gt;
&lt;p&gt;还是假设每次有n个人参与服从$U[a, b]$的均匀分布，则求和就相当于将这些人的试验结果相加，那么这些试验结果之和近似服从$N(\frac{n(b-a)}{2}, \frac{n(b-a)^2}{12})$。其中$\frac{n(b-a)}{2}$表示均值$\mu$，$\frac{n(b-a)^2}{12}$表示方差$\sigma^2$。&lt;/p&gt;
&lt;p&gt;取参数为[3, 5]的均匀分布，可得：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1035701/201711/1035701-20171117193727124-1674125737.png&quot; alt=&quot;&quot; width=&quot;866&quot; height=&quot;606&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;图2-5，服从均匀分布$U[3, 5]$的随机变量之和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 使用上面模拟离散型随机变量和的方法无法模拟连续型随机变量和的极限分布，这是因为连续型随机变量的取值是无穷多的，单个点的概率等于0，即使大量重复取样每个结果的概率都还是会非常小（因为每个值都不同），根本无法看到累积的效果。可以将x轴进行分区，将出现在同一个区域的观察值当做相同的值来对待，这样就跟离散型随机变量的情况一样了（将无穷多的可能取值转化成了有限个区域的取值）。下面使用hist函数实现了这一方式，并且将bins设置为100。&lt;/p&gt;
&lt;p&gt;对于本次试验的均匀分布，每次取值为区间$[3, 5]$上的任意实数，且取到这些实数的概率是相等的。&lt;/p&gt;
&lt;p&gt;当n=1时，相当于只有一个人进行服从该均匀分布的试验，试验次数为函数“sampling2pmf”中的参数“t”，即100000次。由于将区间$[3, 5]$等分为100份，因此这些观察值也应该均匀的分布在这100个区间内，即每个小区间中会有大约1000个观察值。由于总长度为2，此时整个矩形区域的面积为$1000*2 = 2000$，如果标准化为频率可得到每个小区间中观察值出现的频率为观察值个数除以总面积，即$1000/2000 = 0.5$。最终结果就得到了左上角的图形。此时相当于均值和方差都相同的正态分布和均匀分布的比较，相差还是非常大的。&lt;/p&gt;
&lt;p&gt;当n=8时，相当于有8个人同时做该试验，每次试验完成后将这些人的观察值相加，试验$t$次，就可以得到$t$个相加的观察值。由于每次试验从均匀分布中取值，这8个人的试验结果也应该大致服从均匀分布，这些值几乎均匀的分布在区间$[3, 5]$上。因此其和约等于人数乘以均匀分布的均值，即$8*4 = 32$，这也是n=8时，随机变量和的期望值。该期望值是这8个人的结果之和最有可能出现的值，因此概率最大；大于该值或小于该值的概率表示这些人的取值会偏向均值的右侧或左侧，因此概率会减小。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;宏观解释&lt;/span&gt;：多人试验时，有些人取到较大的值，有些人取到较小的值，因此总的来说这些值的和接近人数乘以均匀分布的均值，得到这个位置的值的概率最大，为图形中的顶点。所有人的取值同时小于或大于均值的概率是比较小的，因此顶点两侧的概率降低了，且越往两侧概率越小。取到极小值（极大值）表示所有人都取到了均匀分布中的最小值3（最大值5），这几乎是不可能的。&lt;/p&gt;
&lt;p&gt;下面是代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scipy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; stats
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Created on Sun Nov 17 18:44:37 2017
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@author: Belter
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; sampling2pmf(n, dist, t=100000&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    n: sample size for each experiment
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    t: how many times do you do experiment, fix in 100000
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    dist: frozen distribution
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     current_dist =&lt;span&gt; dist
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     sum_of_samples =&lt;span&gt; np.zeros(t)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(t):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         samples =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(n):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; n次独立的试验&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            samples.append(current_dist.rvs())
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         sum_of_samples[i] =&lt;span&gt; np.sum(samples)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sum_of_samples
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; plot(n, dist, subplot):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    :param n: sample size
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    :param dist: distribution of each single sample
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    :param subplot: location of sub-graph, such as 221, 222, 223, 224
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     plt.subplot(3, 2&lt;span&gt;, subplot)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     mu = n *&lt;span&gt; dist.mean()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     sigma = np.sqrt(n *&lt;span&gt; dist.var())
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     samples = sampling2pmf(n=n, dist=&lt;span&gt;dist)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; normed参数可以对直方图进行标准化，从而使纵坐标表示概率而不是次数&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     plt.hist(samples, normed=True, bins=100, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#348ABD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;              label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{} RVs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(n))
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Probability&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; normal distribution&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     norm_dis =&lt;span&gt; stats.norm(mu, sigma)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     norm_x = np.linspace(mu - 3 * sigma, mu + 3 * sigma, 10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     pdf =&lt;span&gt; norm_dis.pdf(norm_x)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     plt.plot(norm_x, pdf, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, alpha=0.6, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;N(${0:.0f}, {1:.2f}^2$)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(mu, sigma))
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     plt.legend(loc=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;upper left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, prop={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 8&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; size = [1, 2, 3, 4, 8, 10&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sum of uniform distribution&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; dist_type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;uniform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; uniform_para = [3, 2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; single_sample_dist = stats.uniform(loc=uniform_para[0], scale=uniform_para[1])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个均匀分布&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面是利用matplotlib画图&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt; plt.figure(figsize=(10, 7))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; bigger size&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; plt.suptitle(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sum of {} dist. random variables (RVs) converge to a Gaussian distribution (CLT)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(dist_type),
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;              fontsize=16&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(size)):
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     plot(n=size[s], dist=single_sample_dist, subplot=s+1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sum_of_{}_dist.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(dist_type), dpi=200)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码参考了&lt;a href=&quot;https://rajeshrinet.github.io/blog/2014/central-limit-theorem/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;，整体上也更加简洁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;写到这里，似乎任何分布之和（只要项数足够多）都服从正态分布。但是就是在上面链接的末尾处看到了一个例外：任意多的服从柯西分布的随机变量之和还是服从原来的柯西分布。后面查了一些资料证实了这一点，可以参考&lt;a href=&quot;https://stats.stackexchange.com/questions/238246/what-is-the-distribution-of-sample-means-of-a-cauchy-distribution&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。有了这一个例外，可能就无法排除还有其他的例外，只是这种情况应该很少见，平时的数据分析中也很少会遇到服从柯西分布的数据（物理学除外）。因此也不用担心中心极限定理突然失灵。大数定理部分，写于大约两年前，当时发布在新浪博客（reference中最后一个链接），转载时做了一些小的修改。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;http://skhdh.blog.163.com/blog/static/279661392013126402728/&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/22913867&lt;/p&gt;
&lt;p&gt;https://www.zhihu.com/question/22913867/answer/35058403&lt;/p&gt;
&lt;p&gt;https://www.quora.com/What-is-the-difference-between-the-Weak-Law-of-Large-Numbers-and-the-Central-Limit-Theorem/answer/Michael-Hochster?srid=uIoGQ&lt;/p&gt;
&lt;p&gt;https://math.stackexchange.com/questions/2521380/using-python-simulate-central-limit-theorem-bigger-n-worse-fitting&lt;/p&gt;
&lt;p&gt;https://rajeshrinet.github.io/blog/2014/central-limit-theorem/&lt;/p&gt;
&lt;p&gt;http://blog.sina.com.cn/s/blog_6a6c136d0102wvrc.html&lt;/p&gt;

</description>
<pubDate>Fri, 17 Nov 2017 13:07:00 +0000</pubDate>
<dc:creator>昕-2008</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Belter/p/7750745.html</dc:identifier>
</item>
<item>
<title>源码阅读技巧篇 - 匠心零度</title>
<link>http://www.cnblogs.com/lirenzuo/p/7852801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lirenzuo/p/7852801.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载请注明原创出处，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;说在前面&quot;&gt;说在前面&lt;/h2&gt;
&lt;p&gt;本人水平有限，下面的一些都是本人的思考与理解，如果有那里不对，希望各位大佬积极指出，欢迎在留言区进行评论交流、探讨。&lt;/p&gt;
&lt;h2 id=&quot;主题&quot;&gt;主题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;为什么要读源码&lt;/li&gt;
&lt;li&gt;读什么样的源码&lt;/li&gt;
&lt;li&gt;有什么技巧&lt;/li&gt;
&lt;li&gt;思考、交流&lt;/li&gt;
&lt;li&gt;坚持&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么要源码&quot;&gt;为什么要源码&lt;/h2&gt;
&lt;p&gt;说到读源码，让我想起来了读书，古语有云：“读破万卷书，下笔如有神”。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多读读大师的想法技巧&lt;/li&gt;
&lt;li&gt;通过大量阅读进行积累&lt;/li&gt;
&lt;li&gt;把一些零碎的知识点整合起来&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就拿RocketMQ来说，它是如何实现高性能、高可用。之前写过&lt;a href=&quot;https://mp.weixin.qq.com/s/PAmnccpvxxQ6aNjFl1gbvw&quot;&gt;高可用的一些思考和理解&lt;/a&gt;里面的特性他应该都满足，RocketMQ就是把这些很多零散的知识点整合运用之后写出的非常牛逼的项目。&lt;/p&gt;
&lt;h2 id=&quot;读什么样的源码&quot;&gt;读什么样的源码&lt;/h2&gt;
&lt;p&gt;依旧拿读书来说，我们应该读什么书呢？ 读名著，读大师的书。那么读源码在我看来是一样的，尽量进行选择，如果不选择有时候还会浪费时间等。只要是优秀的从那个开始无所谓。&lt;/p&gt;
&lt;h2 id=&quot;有什么技巧&quot;&gt;有什么技巧&lt;/h2&gt;
&lt;p&gt;个人常用的有如下，欢迎留言区补充。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先让项目可以跑起来（&lt;strong&gt;很重要的一点&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;debug&lt;/li&gt;
&lt;li&gt;打印日志以及修改log4j日志级别&lt;/li&gt;
&lt;li&gt;查看调用栈&lt;/li&gt;
&lt;li&gt;全文搜索&lt;/li&gt;
&lt;li&gt;大胆猜测再验证&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在多线程以及网络方面阅读调试应该是最难的（关于多线程我的&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247483727&amp;amp;idx=1&amp;amp;sn=51b987a789cb7312619a41b037a92629&amp;amp;scene=19#wechat_redirect&quot;&gt;史上最难的一道Java面试题 (分析篇)&lt;/a&gt;这篇文章最后也提到了一些小技巧），通常断点有时候不好使，所以通过打印日志，搜索等比较方便，有些由于为了代码的灵活性，高度抽象很不好找，通过日志里面的一些关键词搜索，在加猜测，对不对可以加注释（可能就不执行了那么表示是对的），可以加日志等进行验证。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;备注：&lt;/strong&gt;欢迎关注我的公众号【匠心零度】，后续源码类分析的时候会运用上述技巧进行说明等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思考交流&quot;&gt;思考、交流&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;多思考是很有必要的，这样理解大师的代码也好理解，并且我们不仅仅是看，可能以后在自己的项目中就会用这种思想这种技巧，所以需要多思考。&lt;/li&gt;
&lt;li&gt;多与一些大佬交流，我学习jvm就是遇到问题大佬们帮助我解决、交流学习的，所以交流也是重要途径。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看阿里RocketMQ的时候，发现开源的不支持&lt;strong&gt;消息轨迹&lt;/strong&gt;查询，也是由于之前看过了解过，经过自己的思考，感觉如果需要加上应该不难（前提是需要把RocketMQ源码整体看懂，可以在指定地方加埋点），其实apm产品已经很多了，比如鹰眼、CAT、pinpoint等，其实他们都是基于Google Dapper思想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5479db43c6f72f27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5fb164e70a75cfe1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RocketMQ的MessageID就是一个特别好的东西，用于将调用链的各个调用重新关联起来。之后在结合Hbase的rowkey特性直接一拉整个调用链就都出来了，如果在好点，可以根据消息内容、时间各各条件通过es或者solr查询得到MessageID，之后在通过Hbase把整个拉出来即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以看出来了吧，如果RocketMQ源码读的差不多，想加进来很容易啊，所以重要吧！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;坚持&quot;&gt;坚持&lt;/h2&gt;
&lt;p&gt;上面的都是次要的，这条是最重要的：&lt;strong&gt;坚持&lt;/strong&gt;，滴水穿石、持之以恒，可能在短期看不出来效果，因为需要一个量变到质变以及破茧成蝶的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞加关注。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;个人公众号，欢迎关注，查阅更多精彩历史！！！&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7849276-5f48f1430e958383.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;匠心零度公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 10:04:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lirenzuo/p/7852801.html</dc:identifier>
</item>
<item>
<title>Dubbo源码学习--环境搭建及基础准备(ServiceLoader、ExtensionLoader) - YGingko</title>
<link>http://www.cnblogs.com/hthuang/p/7852428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hthuang/p/7852428.html</guid>
<description>&lt;ol readability=&quot;0.91481481481481&quot;&gt;&lt;li&gt;Github上下载&lt;a href=&quot;https://github.com/alibaba/dubbo&quot;&gt;Dubbo最新发布版本&lt;/a&gt;，楼主下载版本为2.5.7。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;cd到源码解压目录，maven编译，命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn clean install -Dmaven.test.skip&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;生成Intellij idea相关配置文件，命令为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn idea:idea&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;双击运行生成的&lt;code&gt;dubbo-parent.ipr&lt;/code&gt;文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SPI是Service Provider Interfaces的简称，是Java中定义的一个很重要的规范，SPI使得应用之间变得更灵活、程序间更解耦。&lt;/p&gt;
&lt;p&gt;一般在应用中会定义一个接口，具体的实现由对应的实现类去完成，即服务提供者（Service Provider）。模块与模块之间基于接口编程，模块之间不能对实现类进行硬编码、不能在代码里写具体的实现类，否则就违反了“可插拔原则”，如果要替换一种实现，就需要修改代码。此时，SPI提供了一种服务发现机制，完美解决了这个问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SPI机制基本思路是通过JDK提供的&lt;code&gt;java.util.ServiceLoader&lt;/code&gt;类去主动发现服务，不需要硬编码具体的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当服务接口有多个实现类（即服务提供者）时，在jar包的META-INF/services/目录下创建一个以服务接口命名的文件，文件内容是该服务接口的具体实现类的全类名，一行记录是一个实现类的全类名。当外部程序装配这个模块时，通过jar包的META-INF/services/目录里的配置文件就可以找到具体的实现类名，从而进行实例化、完成模块的注入。&lt;/p&gt;

&lt;p&gt;定义服务接口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package jdkspi;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; WorkerService {
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;work&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该服务接口的两个实现类如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package jdkspi.impl;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import jdkspi.WorkerService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; WorkerServiceA &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; WorkerService {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;work&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;work hard ......&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package jdkspi.impl;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import jdkspi.WorkerService;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; WorkerServiceB &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; WorkerService {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;work&lt;/span&gt;() {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;work lazy ......&quot;&lt;/span&gt;);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在resources下新建目录META-INF/services/，在目录下新建文件。文件名为服务接口全名&lt;code&gt;jdkspi.WorkerService&lt;/code&gt;，具体内容如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;jdkspi.impl.WorkerServiceA      //服务接口实现类全名
jdkspi.impl.WorkerServiceB      //服务接口实现类全名&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试示例执行入口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package jdkspi;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.Iterator;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ServiceLoader;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        ServiceLoader&amp;lt;WorkerService&amp;gt; serviceLoader = ServiceLoader.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(WorkerService.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        WorkerService service = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        Iterator&amp;lt;WorkerService&amp;gt; iterator = serviceLoader.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();

        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (iterator.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
            service = iterator.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            service.&lt;span class=&quot;fu&quot;&gt;work&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行测试示例后，结果如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;work hard ......
work lazy ......

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ServiceLoader是一个final类，不能被继承，实现了Iterable接口，可以遍历，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ServiceLoader&amp;lt;S&amp;gt; &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Iterable&amp;lt;S&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServiceLoader属性如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String PREFIX = &lt;span class=&quot;st&quot;&gt;&quot;META-INF/services/&quot;&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;// The class or interface representing the service being loaded&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Class&amp;lt;S&amp;gt; service;

    &lt;span class=&quot;co&quot;&gt;// The class loader used to locate, load, and instantiate providers&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ClassLoader loader;

    &lt;span class=&quot;co&quot;&gt;// The access control context taken when the ServiceLoader is created&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AccessControlContext acc;

    &lt;span class=&quot;co&quot;&gt;// Cached providers, in instantiation order&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; LinkedHashMap&amp;lt;String,S&amp;gt; providers = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();

    &lt;span class=&quot;co&quot;&gt;// The current lazy-lookup iterator&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; LazyIterator lookupIterator;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;PREFIX： 定义了配置文件的路径，是一个final类型常量，不能设置不能更改。表面Java SPI配置文件默认放在&lt;code&gt;META-INF/services/&lt;/code&gt;路径下&lt;/li&gt;
&lt;li&gt;service： 定义服务接口类，final类型变量，一旦被赋值便不能修改，由load方法传入&lt;/li&gt;
&lt;li&gt;loader： 类加载器，一旦被赋值便不能修改&lt;/li&gt;
&lt;li&gt;acc： 访问控制上下文，一旦被赋值比昂不修改&lt;/li&gt;
&lt;li&gt;providers： 存储服务提供者，也即具体实现类。存储的顺序为配置文件中实现类的排列先后顺序&lt;/li&gt;
&lt;li&gt;lookupIterator： 迭代器，实现延迟加载的效果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ServiceLoader只有一个构造器，且是内部构造器。不能再外部直接通过new命令创建实例对象。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ServiceLoader(Class&amp;lt;S&amp;gt; svc, ClassLoader cl) {
        service = Objects.&lt;span class=&quot;fu&quot;&gt;requireNonNull&lt;/span&gt;(svc, &lt;span class=&quot;st&quot;&gt;&quot;Service interface cannot be null&quot;&lt;/span&gt;);
        loader = (cl == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? ClassLoader.&lt;span class=&quot;fu&quot;&gt;getSystemClassLoader&lt;/span&gt;() : cl;
        acc = (System.&lt;span class=&quot;fu&quot;&gt;getSecurityManager&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) ? AccessController.&lt;span class=&quot;fu&quot;&gt;getContext&lt;/span&gt;() : &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;fu&quot;&gt;reload&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ServiceLoader提供了三种静态类方法来创建实例对象。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; &lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(Class&amp;lt;S&amp;gt; service, ClassLoader loader) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ServiceLoader&amp;lt;&amp;gt;(service, loader);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; &lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(Class&amp;lt;S&amp;gt; service) {
        ClassLoader cl = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getContextClassLoader&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ServiceLoader.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(service, cl);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; &lt;span class=&quot;fu&quot;&gt;loadInstalled&lt;/span&gt;(Class&amp;lt;S&amp;gt; service) {
        ClassLoader cl = ClassLoader.&lt;span class=&quot;fu&quot;&gt;getSystemClassLoader&lt;/span&gt;();
        ClassLoader prev = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (cl != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            prev = cl;
            cl = cl.&lt;span class=&quot;fu&quot;&gt;getParent&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; ServiceLoader.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(service, prev);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;load(Class&amp;lt;S&amp;gt; service)&lt;/code&gt;: 利用当前线程持有的ClassLoader创建实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load(Class&amp;lt;S&amp;gt; service, ClassLoader loader)&lt;/code&gt;: 利用指定的ClassLoader创建实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loadInstalled(Class&amp;lt;S&amp;gt; service)&lt;/code&gt;: 利用系统顶级ClassLoader创建实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ServiceLoader提供iterator()方法用以生成迭代器。迭代器中方法内部具体由lookupIterator实现。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Iterator&amp;lt;S&amp;gt; &lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Iterator&amp;lt;S&amp;gt;() {

            Iterator&amp;lt;Map.&lt;span class=&quot;fu&quot;&gt;Entry&lt;/span&gt;&amp;lt;String,S&amp;gt;&amp;gt; knownProviders
                = providers.&lt;span class=&quot;fu&quot;&gt;entrySet&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();

            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (knownProviders.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;())
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; lookupIterator.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;();
            }

            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; S &lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (knownProviders.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;())
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; knownProviders.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; lookupIterator.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            }

            &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;() {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UnsupportedOperationException();
            }

        };
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lookupIterator是LazyIterator的对象实例，LazyIterator是一个内部类，实现了Iterator接口，源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; LazyIterator
        &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Iterator&amp;lt;S&amp;gt;
    {

        Class&amp;lt;S&amp;gt; service;
        ClassLoader loader;
        Enumeration&amp;lt;URL&amp;gt; configs = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        Iterator&amp;lt;String&amp;gt; pending = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        String nextName = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;LazyIterator&lt;/span&gt;(Class&amp;lt;S&amp;gt; service, ClassLoader loader) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;service&lt;/span&gt; = service;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;loader&lt;/span&gt; = loader;
        }

        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hasNextService&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nextName != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (configs == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    String fullName = PREFIX + service.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;();
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loader == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                        configs = ClassLoader.&lt;span class=&quot;fu&quot;&gt;getSystemResources&lt;/span&gt;(fullName);
                    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                        configs = loader.&lt;span class=&quot;fu&quot;&gt;getResources&lt;/span&gt;(fullName);
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException x) {
                    &lt;span class=&quot;fu&quot;&gt;fail&lt;/span&gt;(service, &lt;span class=&quot;st&quot;&gt;&quot;Error locating configuration files&quot;&lt;/span&gt;, x);
                }
            }
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; ((pending == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) || !pending.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!configs.&lt;span class=&quot;fu&quot;&gt;hasMoreElements&lt;/span&gt;()) {
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                }
                pending = &lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(service, configs.&lt;span class=&quot;fu&quot;&gt;nextElement&lt;/span&gt;());
            }
            nextName = pending.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }

        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; S &lt;span class=&quot;fu&quot;&gt;nextService&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;hasNextService&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NoSuchElementException();
            String cn = nextName;
            nextName = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            Class&amp;lt;?&amp;gt; c = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                c = Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(cn, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, loader);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException x) {
                &lt;span class=&quot;fu&quot;&gt;fail&lt;/span&gt;(service,
                     &lt;span class=&quot;st&quot;&gt;&quot;Provider &quot;&lt;/span&gt; + cn + &lt;span class=&quot;st&quot;&gt;&quot; not found&quot;&lt;/span&gt;);
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!service.&lt;span class=&quot;fu&quot;&gt;isAssignableFrom&lt;/span&gt;(c)) {
                &lt;span class=&quot;fu&quot;&gt;fail&lt;/span&gt;(service,
                     &lt;span class=&quot;st&quot;&gt;&quot;Provider &quot;&lt;/span&gt; + cn  + &lt;span class=&quot;st&quot;&gt;&quot; not a subtype&quot;&lt;/span&gt;);
            }
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                S p = service.&lt;span class=&quot;fu&quot;&gt;cast&lt;/span&gt;(c.&lt;span class=&quot;fu&quot;&gt;newInstance&lt;/span&gt;());
                providers.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(cn, p);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; p;
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable x) {
                &lt;span class=&quot;fu&quot;&gt;fail&lt;/span&gt;(service,
                     &lt;span class=&quot;st&quot;&gt;&quot;Provider &quot;&lt;/span&gt; + cn + &lt;span class=&quot;st&quot;&gt;&quot; could not be instantiated&quot;&lt;/span&gt;,
                     x);
            }
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error();          &lt;span class=&quot;co&quot;&gt;// This cannot happen&lt;/span&gt;
        }

        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (acc == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hasNextService&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                PrivilegedAction&amp;lt;Boolean&amp;gt; action = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Boolean&amp;gt;() {
                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Boolean &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hasNextService&lt;/span&gt;(); }
                };
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; AccessController.&lt;span class=&quot;fu&quot;&gt;doPrivileged&lt;/span&gt;(action, acc);
            }
        }

        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; S &lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (acc == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nextService&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                PrivilegedAction&amp;lt;S&amp;gt; action = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;S&amp;gt;() {
                    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; S &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() { &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nextService&lt;/span&gt;(); }
                };
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; AccessController.&lt;span class=&quot;fu&quot;&gt;doPrivileged&lt;/span&gt;(action, acc);
            }
        }

        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; UnsupportedOperationException();
        }

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面源码中，不难发现：服务提供者的实例化过程是在具体调用时进行的，延迟加载。&lt;br/&gt;Java SPI机制的ServiceLoader缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每次获取一个实现类都必须遍历加载所有的实现类，即使是不想使用的实现类也加载了，造成了资源的浪费。&lt;/li&gt;
&lt;li&gt;不能定向获取对应的实现类，必须iterator遍历查找，比较慢&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Dubbo拓展机制应用的就是Java SPI的思想。Java SPI配置文件中一条记录是一个实现类全名，但Dubbo配置文件中存储的是key-value键值对，value存储的是实现类全名。示例如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;ls=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.ListTelnetHandler
ps=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.PortTelnetHandler
cd=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.ChangeTelnetHandler
pwd=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.CurrentTelnetHandler
invoke=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.InvokeTelnetHandler
trace=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.TraceTelnetHandler
count=com.alibaba.dubbo.rpc.protocol.dubbo.telnet.CountTelnetHandler&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似Java SPI机制的ServiceLoader，Dubbo中也有一个拓展加载器ExtensionLoader。ExtensionLoader中定义了配置文件的存储路径：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String SERVICES_DIRECTORY = &lt;span class=&quot;st&quot;&gt;&quot;META-INF/services/&quot;&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String DUBBO_DIRECTORY = &lt;span class=&quot;st&quot;&gt;&quot;META-INF/dubbo/&quot;&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + &lt;span class=&quot;st&quot;&gt;&quot;internal/&quot;&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ExtensionLoader构造器也是内部构造器，在外部不能直接通过new命令来创建对象实例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ExtensionLoader&lt;/span&gt;(Class&amp;lt;?&amp;gt; type) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;type&lt;/span&gt; = type;
        objectFactory = (type == ExtensionFactory.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; : ExtensionLoader.&lt;span class=&quot;fu&quot;&gt;getExtensionLoader&lt;/span&gt;(ExtensionFactory.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;getAdaptiveExtension&lt;/span&gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，ExtensionLoader提供静态类方法getExtensionLoader来生成实例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; ExtensionLoader&amp;lt;T&amp;gt; &lt;span class=&quot;fu&quot;&gt;getExtensionLoader&lt;/span&gt;(Class&amp;lt;T&amp;gt; type) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (type == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Extension type == null&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!type.&lt;span class=&quot;fu&quot;&gt;isInterface&lt;/span&gt;()) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Extension type(&quot;&lt;/span&gt; + type + &lt;span class=&quot;st&quot;&gt;&quot;) is not interface!&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;withExtensionAnnotation&lt;/span&gt;(type)) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Extension type(&quot;&lt;/span&gt; + type +
                    &lt;span class=&quot;st&quot;&gt;&quot;) is not extension, because WITHOUT @&quot;&lt;/span&gt; + SPI.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getSimpleName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot; Annotation!&quot;&lt;/span&gt;);
        }

        ExtensionLoader&amp;lt;T&amp;gt; loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(type);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (loader == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            EXTENSION_LOADERS.&lt;span class=&quot;fu&quot;&gt;putIfAbsent&lt;/span&gt;(type, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ExtensionLoader&amp;lt;T&amp;gt;(type));
            loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(type);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; loader;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用getExtension方法可以根据name值获取指定的拓展实现类，实例化后的拓展实现类以Holder类封装存储在cachedInstances中，cachedInstances是&lt;code&gt;ConcurrentMap&amp;lt;String, Holder&amp;lt;Object&amp;gt;&amp;gt;&lt;/code&gt;变量。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 返回指定名字的扩展。如果指定名字的扩展不存在，则抛异常 &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{@link IllegalStateException}&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     *&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param name&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * @return&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;getExtension&lt;/span&gt;(String name) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (name == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || name.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Extension name == null&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(name)) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getDefaultExtension&lt;/span&gt;();
        }
        Holder&amp;lt;Object&amp;gt; holder = cachedInstances.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(name);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (holder == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            cachedInstances.&lt;span class=&quot;fu&quot;&gt;putIfAbsent&lt;/span&gt;(name, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Holder&amp;lt;Object&amp;gt;());
            holder = cachedInstances.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(name);
        }
        Object instance = holder.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (holder) {
                instance = holder.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    instance = &lt;span class=&quot;fu&quot;&gt;createExtension&lt;/span&gt;(name);
                    holder.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(instance);
                }
            }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (T) instance;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;getExtension方法中采用了double-check机制，拓展实现类的实例化是在createExtension方法中完成的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;createExtension&lt;/span&gt;(String name) {
        Class&amp;lt;?&amp;gt; clazz = &lt;span class=&quot;fu&quot;&gt;getExtensionClasses&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(name);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (clazz == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;findException&lt;/span&gt;(name);
        }
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            T instance = (T) EXTENSION_INSTANCES.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(clazz);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                EXTENSION_INSTANCES.&lt;span class=&quot;fu&quot;&gt;putIfAbsent&lt;/span&gt;(clazz, (T) clazz.&lt;span class=&quot;fu&quot;&gt;newInstance&lt;/span&gt;());
                instance = (T) EXTENSION_INSTANCES.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(clazz);
            }
            &lt;span class=&quot;fu&quot;&gt;injectExtension&lt;/span&gt;(instance);
            Set&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; wrapperClasses = cachedWrapperClasses;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wrapperClasses != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; wrapperClasses.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; wrapperClass : wrapperClasses) {
                    instance = &lt;span class=&quot;fu&quot;&gt;injectExtension&lt;/span&gt;((T) wrapperClass.&lt;span class=&quot;fu&quot;&gt;getConstructor&lt;/span&gt;(type).&lt;span class=&quot;fu&quot;&gt;newInstance&lt;/span&gt;(instance));
                }
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; instance;
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable t) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalStateException(&lt;span class=&quot;st&quot;&gt;&quot;Extension instance(name: &quot;&lt;/span&gt; + name + &lt;span class=&quot;st&quot;&gt;&quot;, class: &quot;&lt;/span&gt; +
                    type + &lt;span class=&quot;st&quot;&gt;&quot;)  could not be instantiated: &quot;&lt;/span&gt; + t.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;(), t);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法实现大体流程为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;name作为key值，获取对应的class。在getExtensionClasses中是有做同步处理的&lt;/li&gt;
&lt;li&gt;根据得到的class创建实例&lt;/li&gt;
&lt;li&gt;对实例化对象进行依赖注入&lt;/li&gt;
&lt;li&gt;对依赖注入后的实例化对象进行包装&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;依赖注入及包装源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; T &lt;span class=&quot;fu&quot;&gt;injectExtension&lt;/span&gt;(T instance) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (objectFactory != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Method method : instance.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMethods&lt;/span&gt;()) {
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;startsWith&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;set&quot;&lt;/span&gt;)
                            &amp;amp;&amp;amp; method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
                            &amp;amp;&amp;amp; Modifier.&lt;span class=&quot;fu&quot;&gt;isPublic&lt;/span&gt;(method.&lt;span class=&quot;fu&quot;&gt;getModifiers&lt;/span&gt;())) {
                        Class&amp;lt;?&amp;gt; pt = method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;()[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];
                        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                            String property = method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; ? method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;toLowerCase&lt;/span&gt;() + method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) : &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;;
                            Object object = objectFactory.&lt;span class=&quot;fu&quot;&gt;getExtension&lt;/span&gt;(pt, property);
                            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (object != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                                method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(instance, object);
                            }
                        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                            logger.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fail to inject via method &quot;&lt;/span&gt; + method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;()
                                    + &lt;span class=&quot;st&quot;&gt;&quot; of interface &quot;&lt;/span&gt; + type.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;: &quot;&lt;/span&gt; + e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;(), e);
                        }
                    }
                }
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            logger.&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;(), e);
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; instance;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此即是Dubbo拓展机制的大体流程，跟Java SPI机制非常类似，可看作Java SPI机制的一个优化与拓展。下一节将&lt;a href=&quot;http://blog.ygingko.top/2017/11/16/Dubbo-source-1/&quot;&gt;探讨provider服务的发布过程&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Nov 2017 08:57:00 +0000</pubDate>
<dc:creator>YGingko</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hthuang/p/7852428.html</dc:identifier>
</item>
</channel>
</rss>