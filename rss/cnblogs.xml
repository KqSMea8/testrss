<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Docker &amp; ASP.NET Core (5)：Docker Compose - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/10040590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/10040590.html</guid>
<description>&lt;p&gt;第一篇：&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9985656.html&quot; target=&quot;_blank&quot;&gt;把代码连接到容器&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;第二篇：&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9997124.html&quot; target=&quot;_blank&quot;&gt;定制Docker镜像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三篇：&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/10011677.html&quot; target=&quot;_blank&quot;&gt;发布镜像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第四篇：&lt;a href=&quot;https://www.cnblogs.com/cgzl/p/10022797.html&quot; target=&quot;_blank&quot;&gt;容器间的连接&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;Compose是一个用来定义和运行多容器Docker应用的工具。使用Compose的时候，你可以使用一个YAML文件来配置你应用的服务。然后根据配置，使用一个命令即可创建并运行所有的服务。&lt;/p&gt;
&lt;p&gt;使用Compose的时候通常分三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用Dockerfile定义你的环境&lt;/li&gt;
&lt;li&gt;在docker-compose.yml文件里定义你的服务，这样就可以让他们在隔离的环境中一起运行了。&lt;/li&gt;
&lt;li&gt;运行docker-compose up 命令，来启动和运行整个应用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Docker Compose的特点&lt;/h2&gt;
&lt;p&gt;Docker Compose可以做很多事情，但是如果只考虑在开发环境里，它可以做下面这些事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;管理整个应用的生命周期：启动、停止、重构建服务，而服务呢，其实就是运行的容器而已。&lt;/li&gt;
&lt;li&gt;查看在运行的服务的状态，包括输出日志。&lt;/li&gt;
&lt;li&gt;可以在单个容器上运行一次性命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;为什么要使用Docker Compose&lt;/h2&gt;
&lt;p&gt;通常来说，如果你的应用稍微有点规模，例如你的Web应用需要使用Web服务器，缓存服务器，数据库服务器。。。如果你手动管理这样的docker应用，就很繁琐，也很容易出错。&lt;/p&gt;
&lt;p&gt;而如果使用Docker Compose的话，它可以定义一个docker-compose.yml文件，在这个文件里，你可以定义所有的这些服务，以及它们之间的关系。&lt;/p&gt;


&lt;p&gt;docker-compose.yml文件就是用来配置服务的，这里有一个官网给出的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181129194514041-1622563098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个文件写好之后，就可以开始Docker Compose的构建过程了。&lt;/p&gt;
&lt;p&gt;这个构建的过程实际上会生成镜像，然后使用这些镜像就可以创建容器了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181129195523419-1795364436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再使用一个简单的命令，就可以让这些服务启动并运行了。&lt;/p&gt;

&lt;p&gt;下面简单讲一下这个docker-compose.yml文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181129200732532-1886904366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一行是版本。&lt;/p&gt;
&lt;p&gt;下面services，就是服务。&lt;/p&gt;
&lt;p&gt;在services里，可以定义当构建docker-compose.yml文件时想要运行的服务，然后把这些镜像以容器运行。这里可以定义ASP.NET Core，node，数据库，缓存等等。&lt;/p&gt;
&lt;p&gt;看一下服务里的东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;build，里面可以定义构建的上下文，例如在哪个文件见来进行构建；还可以指定使用的dockerfile。&lt;/li&gt;
&lt;li&gt;在这里也可以定义环境变量。&lt;/li&gt;
&lt;li&gt;image，定义镜像。&lt;/li&gt;
&lt;li&gt;networks，可以把服务和定义好的网络联系起来。&lt;/li&gt;
&lt;li&gt;ports，定义端口。&lt;/li&gt;
&lt;li&gt;volumes，定义卷。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也可以在里面定义networks等等。&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;docker-compose build&lt;/strong&gt;&lt;/span&gt; 把服务构建成镜像。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;docker-compose up&lt;/strong&gt;&lt;/span&gt;，一旦镜像准备好了，那就就执行该命令，启动那些镜像，使之成为容器运行。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;docker-compose down&lt;/strong&gt;&lt;/span&gt;，可以使用该命令停止、删除由up命令建立的一切东西。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外还有这些常用形式的命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;docker-compose logs&lt;/li&gt;
&lt;li&gt;docker-compose ps&lt;/li&gt;
&lt;li&gt;docker-compose stop&lt;/li&gt;
&lt;li&gt;docker-compose start&lt;/li&gt;
&lt;li&gt;docker-compose rm&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;docker-compose build&lt;/h2&gt;
&lt;p&gt;这个命令会构建/重新构建定义在docker-compose.yml文件里的所有的服务，使用这一个命令就会一次性把所有服务需要的镜像都创建好。&lt;/p&gt;

&lt;p&gt;此外还可以构建单独的服务，例如: &lt;strong&gt;docker-compose build mongo&lt;/strong&gt;。有时候你不想把所有的东西都重新构建一遍，你只想构建其中的一个服务。&lt;/p&gt;

&lt;h2&gt;docker-compose up&lt;/h2&gt;
&lt;p&gt;一切都构建好之后，就可以启动并运行了。这时就会使用docker-compose up这个命令。&lt;/p&gt;
&lt;p&gt;它会自动创建容器，并运行这些容器。&lt;/p&gt;

&lt;p&gt;该命令还可以加一些参数，例如 &lt;strong&gt;docker-compose up --no-deps node&lt;/strong&gt;，它表示重新构建node镜像，停止、销毁重新创建node，但不重新创建node所依赖的服务。&lt;/p&gt;

&lt;h2&gt;docker-compose down&lt;/h2&gt;
&lt;p&gt;该命令会停止所有的容器，然后删除它们。&lt;/p&gt;
&lt;p&gt;如果只想停止容器，并不删除，那么应该使用docker-compose stop。&lt;/p&gt;

&lt;p&gt;此外如果你还想同时删除所有的镜像和volumes，你可以：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker-compose down --rmi all --volumes&lt;/strong&gt;。&lt;/p&gt;


&lt;p&gt;前面文章里，我通过手动输入命令实现了一套ASP.NET Core 和 PostgreSQL的docker 应用。尽管该应用很简单，只有两部分组成，但当时还是输入了不少命令，也遇到了几次错误，相对还是繁琐一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130061228323-870559385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我把这两个容器删掉(包括相应的镜像和网络都删掉吧)，然后使用docker-compose来实现。&lt;/p&gt;

&lt;h2&gt;建立docker-compose.yml文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130062048283-1726633367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，我还没写完。&lt;/p&gt;
&lt;p&gt;这里我指定了版本为‘3’，当前也就是这个版本。&lt;/p&gt;
&lt;p&gt;然后在services里，我定义了coreweb服务（ASP.NET Core Web应用），它的构建的上下文环境 context是.，也就是当前目录；使用的dockerfile是标准的Dockerfile；端口是映射到8080，内部端口是5000；使用的网络是aspcore-network。&lt;/p&gt;
&lt;p&gt;最后边定义了网络，名为aspcore-network，类型是bridge桥接网络。&lt;/p&gt;

&lt;p&gt;然后继续写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130065753850-733559810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又添加了postgres-server这个服务，它是直接使用的官方镜像postgres，网络还是同一个网络，但是这里设置了一个环境变量，是数据库的密码。&lt;/p&gt;

&lt;h2&gt;执行docker-compose build&lt;/h2&gt;
&lt;p&gt;定义好docker-compose.yml之后，就可以进行构建了，执行&lt;strong&gt;docker-compose build&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130062805827-129970469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很快就完成了。&lt;/p&gt;

&lt;p&gt;然后看一下镜像列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130063049266-219901600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个就是我建立的coreweb，其实我们可以自定义它的名称。&lt;/p&gt;
&lt;p&gt;而postgres这个镜像我早就下载下来了，所以它的创建时间比较早。&lt;/p&gt;

&lt;h2&gt;执行docker-compose up&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;docker-compose up&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130063517591-1954916438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130063554196-824244607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里出现了一些问题：这是我第一次运行该项目，运行项目的同时，代码里会做数据库的自动迁移，但是ASP.NET Core Web应用先跑起来了，它开始做迁移，然后发现数据库服务还没跑起来呢，所以ASP.NET Core项目就报错了，它的容器就停掉了。而过了一会postgres的服务才启动完成。。。&lt;/p&gt;

&lt;p&gt;这也很好办，现在postgres的服务起来了，那么，我再手动启动一下ASP.NET Core Web的容器就可以了。docker-compose start coreweb：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130063919569-1586410355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后访问http://localhost:8080：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064002446-537525043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网站就可以正常访问了。&lt;/p&gt;

&lt;p&gt;现在这种操作还有一点瑕疵，因为docker-compose up之后，终端里都是log，我们处在log模式下，无法做其它操作。需要再打开一个终端来执行其它命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064151291-1065236863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;执行docker-compose down&lt;/h2&gt;
&lt;p&gt;所以我想重新搞一下，先把这套东西拆了：&lt;strong&gt;docker-compose down&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064307333-421072271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;试验其它命令&lt;/h2&gt;
&lt;p&gt;为了避免上述问题，这次我们使用daemon mode 守护进程模式，&lt;strong&gt;docker-compose up&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;-d&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064452287-1434776589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后我们这次使用这个命令来看进程，&lt;strong&gt;docker-compose ps&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064618390-1040966488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这两个容器，然后Web应用又发生前面的问题了，我在单独跑一下它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064739450-620017150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次就OK了。&lt;/p&gt;

&lt;p&gt;再次访问网站：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064813234-1971132883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还是可以正常运行的。&lt;/p&gt;

&lt;p&gt;下面看一下log，&lt;strong&gt;docker-compose logs&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130064901407-889570671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后销毁这套东西，这次我把相应的镜像也删掉 &lt;strong&gt;docker-compose down --rmi all&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181130065604976-104575323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;能删的都删除了，但这里postgres这个镜像无法删除是因为我还有其它容器使用该镜像。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 23:00:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>第一篇：把代码连接到容器 第二篇：定制Docker镜像 第三篇：发布镜像 第四篇：容器间的连接 Docker Compose简介 Compose是一个用来定义和运行多容器Docker应用的工具。使用C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/10040590.html</dc:identifier>
</item>
<item>
<title>“若干分布式事务框架”与“我的偏见” - YOYO&amp;#</title>
<link>http://www.cnblogs.com/skyesx/p/10041923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyesx/p/10041923.html</guid>
<description>&lt;p&gt;本文来谈谈我对若干分布式事务框架的看法，只谈设计时导致无法轻易改变的硬伤（或者说我的偏见），其优点应该已表现在其文档中，不再赘述。至于我的偏见能不能成为你的偏见，请自行思考核实，仅供大家选型时开拓思路使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/317990/201811/317990-20181130003628576-1762760356.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以下我略有了解的框架将成为靶子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TransactionsEssentials(atomikos免费版)&lt;/li&gt;
&lt;li&gt;tcc-transaction&lt;/li&gt;
&lt;li&gt;ByteTCC&lt;/li&gt;
&lt;li&gt;hmily&lt;/li&gt;
&lt;li&gt;tx-lcn&lt;/li&gt;
&lt;li&gt;GTS&lt;/li&gt;
&lt;li&gt;EasyTransaction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其是atomikos公司的两阶段提交事务的免费版本，说到两阶段提交大家第一印象应该都是慢，第二印象应该就是很方便，编码少。&lt;/p&gt;
&lt;p&gt;但实际上有多慢呢？可能大家都不太确定，我这里有一组数字供大家参考，相同业务场景，两个服务有数据协同需求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若两个服务在同一库中，单库事务可达600TPS+&lt;/li&gt;
&lt;li&gt;但Atomikos速度为40-70TPS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，这里没有给出具体的场景与配置，确实差值也有点大，我当时也是不太相信的。但我从多个不同测试数据源获得的数据都较为类似，大家有空可以协助验证下，然后评论给下数据。&lt;/p&gt;
&lt;p&gt;所以对于TransactionsEssentials这个框架，我的偏见就是，太慢。&lt;/p&gt;

&lt;p&gt;这是一个在GITHUB上开源了很久的框架了，其STAR数量接近3K，其代码简洁易懂。但其有三个缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;慢&lt;/li&gt;
&lt;li&gt;应用Crash时有几率导致持久化的事务状态不正确&lt;/li&gt;
&lt;li&gt;不支持框架幂&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;慢的原因&quot;&gt;慢的原因&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;事务日志使用一个数据库的变长字段存储&lt;/li&gt;
&lt;li&gt;会多次更新该字段&lt;/li&gt;
&lt;li&gt;该字段存储的内容不断变长，使其不能在磁盘中原地更新，导致页的分裂，或者导致该字段从页中移除，涉及大量IO&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;crash不一致的原因&quot;&gt;CRASH不一致的原因&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;其CRASH后纯粹依赖事务日志判断全局事务状态（Trying,Confirming,Canceling）&lt;/li&gt;
&lt;li&gt;然而该事务日志记录的事务状态是无法与业务数据库的事务状态保持强一致的（若能，则需要引入2PC等手段，是不是很矛盾）&lt;/li&gt;
&lt;li&gt;因此在Crash时导致事务日志状态不正确时，按照目前的设计是需要人工介入排查问题的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;不支持框架幂等&quot;&gt;不支持框架幂等&lt;/h2&gt;
&lt;p&gt;这会导致业务开发工作量大大增加。&lt;/p&gt;

&lt;p&gt;ByteTCC是一个兼容JTA规范的基于TCC机制的分布式事务管理器。&lt;/p&gt;
&lt;p&gt;其实个人觉得基JTA规范扩展的TCC实现并非一个特别好的想法,其&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强制Spring的PlatformTransactionManager要支持JTA，需要用户修改原有的PlatformTransactionManager&lt;/li&gt;
&lt;li&gt;使用了ByteTCC自行实现的UserTransaction（JTA相关接口），并在里层整合&quot;TCC&quot;及“真JTA”的控制逻辑，这违反了编程里的开闭原则
&lt;ul&gt;&lt;li&gt;用自定义实现类替换掉了客户原有实现中可能更为可靠的JTA/JDBC事务，即单机事务的代码逻辑也被改了&lt;/li&gt;
&lt;li&gt;在JTA接口中整合“真JTA”及“TCC”的逻辑交错在整个实现中，没有很好地分离逻辑，不利于阅读，也不利于修改&lt;/li&gt;
&lt;li&gt;限制了使用其他的JTA实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不知道大家有没有听懂我上面说了什么，其实就是说，如果让我来设计，我是尽量不会对原有逻辑进行修改，而是对逻辑进行扩展，这样才能最大程度的程序的安全性，也能更好地与原有逻辑整合。&lt;/p&gt;
&lt;p&gt;举个例子，EasyTransaction里就是基于扩展实现了各种功能，其能保证原有事务处理逻辑完全不变，仅仅只是外挂了TCC、可靠消息等等的实现，同等情况下，其实现的理论风险会更小，并且EasyTransaction能无缝兼容JTA事务以及EasyTransaction内的各种事务，并协调一起工作，而ByteTCC则由于其实现形式，难以简单做到。&lt;/p&gt;
&lt;p&gt;另外一个方面是其代码变得过于复杂，至少对我来说有理解难度，需要一些额外的知识支撑，不知道其他人的看法是怎样的。&lt;/p&gt;
&lt;p&gt;同时关于幂等，ByteTCC只支持Confirm及Cancel操作的幂等，不过这比很多框架都要强了。&lt;/p&gt;

&lt;p&gt;这个框架的主要描述是“高性能分布式事务tcc方案开源框架”，个人感觉其之所以这么声称是因为“采用disruptor框架进行事务日志的异步读写，与RPC框架的性能毫无差别”。&lt;/p&gt;
&lt;p&gt;这里有两个个人认为的硬伤（也许是偏见吧）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步写入事务日志就等于TCC是不可靠的&lt;/li&gt;
&lt;li&gt;持久化IO瓶颈才是一个分布式事务框架的主要瓶颈，其并非Disruptor框架主要针对的CPU瓶颈&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;为什么不可靠&quot;&gt;为什么不可靠&lt;/h2&gt;
&lt;p&gt;就一个简单的问题吧，事务日志存储连接不上（网络断掉/掉电了），这时异步写入的日志放到内存了，然后远程的访问请求TRY发出去了，这个时候应用CRASH了。这就会导致TCC日志不完整，从而导致事务无法恢复。&lt;/p&gt;
&lt;p&gt;有一些观点认为这些情况极其少见，不需处理，那我们并发编程时volatile之类的同步手段还需要用么？&lt;/p&gt;
&lt;p&gt;并且异常都是连锁的，它并不是孤立出现的，我们无法预判会出现什么异常情况，也有墨菲定律说，越担心的事情越有可能发生，因此我们对于这类情况必然是虽然我们不能保证实现完美，但是我们的理论至少要使完美的。&lt;/p&gt;
&lt;h2 id=&quot;异步的disruptor并不能解决矛盾的主要方面&quot;&gt;异步的Disruptor并不能解决矛盾的主要方面&lt;/h2&gt;
&lt;p&gt;我们知道，CPU的速度会比持久化IO的速度高很多个数量级，因此，基本上涉及持久化时，IO必然才是主要优化的目标。&lt;/p&gt;
&lt;p&gt;因此我们做优化时，仿照KAFKA等，批量汇集数据，批量IO才是正确的解决之道。不做这个而去优化CPU性能这有点本末倒置,同时据我了解的多个测试结果中，hmily的性能都大幅不及EasyTransaction。&lt;/p&gt;
&lt;h2 id=&quot;也不支持框架幂等&quot;&gt;也不支持框架幂等&lt;/h2&gt;
&lt;p&gt;同上Tcc-transaction&lt;/p&gt;

&lt;p&gt;这个框架本质上是一个BestEffors 1PC的框架，是什么意思呢，也就是大多数情况下，只要应用不Crash就不会导致不一致。&lt;/p&gt;
&lt;p&gt;这里带来什么矛盾呢?除非你不关心不一致，允许数据出错不修复，但一旦出现数据不一致一定要修复的情况的话，就要走人工补偿处理，或者调用相关的修复程序。&lt;/p&gt;
&lt;p&gt;而人工补偿处理，实际上，也就相当于人肉写了一遍修复程序，而且人肉执行还没留下代码，下次出问题还要人工再分析处理一遍。&lt;/p&gt;
&lt;p&gt;因此，结论很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于允许数据不一致的数据来说
&lt;ul&gt;&lt;li&gt;用BestEffors 1PC挺好的，性能高于2PC，代码量与2PC一样。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;但是对于数据出现不一致时，必须修复的情况
&lt;ul&gt;&lt;li&gt;我们必须要写对应的修复程序&lt;/li&gt;
&lt;li&gt;这实际上跟TCC/补偿等工作量一样了&lt;/li&gt;
&lt;li&gt;为啥不切换到TCC/补偿等性能更加高的形式&lt;/li&gt;
&lt;li&gt;并且使用BestEffors1PC写的业务代码在出现数据异常时，并不能保证其后续的补偿是可执行的。&lt;/li&gt;
&lt;li&gt;举个例子，转账，出现了给别人加钱了，但是自己没有扣钱的数据异常，此时两位客户就有可能立马把钱取出来用掉&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tx-lcn这个框架是有适用场景的，但是我个人觉得最好把相关的厉害关系放到险要位置，不然有巨多小白无脑就用了，而不知道其中的坑，我觉得不太好。&lt;/p&gt;

&lt;p&gt;这个框架的偏见嘛,主要就是脏读了。贴一段之前写过的文字。&lt;/p&gt;
&lt;p&gt;GTS确实很赞，其核心原理是补偿。&lt;/p&gt;
&lt;p&gt;但这个补偿做得很屌，补偿操作由框架自动生成，无需业务干预，框架会记录修改前的记录值到上面的txc_undo_log里，若需要回滚，则拿出undo_log的记录覆盖回原有记录&lt;/p&gt;
&lt;p&gt;同时这里存在一个事务隔离级别的问题，GTS的做法是默认脏读，那么就可以直接拿数据库记录展示（但个人觉得应该可以不做脏读，直接拿undo_log里的记录做mvcc,只要undo_log记录不大，都可以加载到内存里）。&lt;/p&gt;
&lt;p&gt;还有另外一个问题是如何禁止其他事务对进行中的全局事务记录的更新，GTS的做法是需要接管APP中的数据源，这样就可以解析控制业务要执行的SQL，对于update操作（或者select for update），予以禁止或等待。&lt;/p&gt;
&lt;p&gt;不过整体的做法相当于魔改数据库，将数据库的部分功能拉到了业务APP里进行，并修改了默认隔离级别（脏读，如果业务有用数据库记录乐观锁来控制并发的话，将会失效），还有就是，不通过GTS的定制数据源访问会访问修改到未提交数据&lt;/p&gt;

&lt;p&gt;这个嘛，是我自己写的框架，上面出现的偏见，在我这里都不会有，这篇文章本质是个软文，哈哈，所以ET在我这没有偏见，但我汇总下ET的优点把：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;真正的高性能，对IO做了大量优化，多个独立三方公司横向评测分布式事务框架时，同等场景及同等可靠性保证下性能最佳（可自行验证测试）&lt;/li&gt;
&lt;li&gt;理论上只要外部组件不丢数据，在ET内部是不会出现事务不完整的情况（相对于上面一些框架，其原理就不可靠，运行出现异常可以说是必然的）&lt;/li&gt;
&lt;li&gt;支持框架幂等，业务程序程序不再需要接管 幂等、调用时序错乱处理等繁琐重复逻辑（这个是一个繁琐重复的工作，貌似只有ET对本项进行了完整支持）&lt;/li&gt;
&lt;li&gt;基于扩展的实现，而非基于修改的实现，更易理解，风险更小，功能更强大&lt;/li&gt;
&lt;li&gt;支持多种事务形态（TCC,补偿，可靠消息，SAGAs等）混合使用，可按照最适合业务的选择最贴切的事务形态（这时ET创建之初的理念及特点，也是其他框架所不具有的特性）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/317990/201811/317990-20181130003645596-1635149513.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上的偏见是不成熟的小想法，若有不正确，各位大佬尽管在评论区拍砖。同时本文仅供各位大佬选型时开拓思路，我认为的偏见不一定就是你的偏见，可能仅仅只是考虑角度、设计理念不一样而已。&lt;/p&gt;
&lt;p&gt;个人认为EasyTransaction的理念、设计、可靠性、性能等都不会比上面的框架差，但ET的STAR数量却不及上面的各个开源框架，我觉得一定是ET有什么我自己没有察觉到的缺陷，请大家拍砖以促进本框架进步，可以直接评论，或者到GITHUB上提ISSUE，感谢你的改进建议！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/QNJR-GROUP/EasyTransaction&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 29 Nov 2018 16:37:00 +0000</pubDate>
<dc:creator>YOYO&amp;amp;#</dc:creator>
<og:description>本文来谈谈我对若干分布式事务框架的看法，只谈设计时导致无法轻易改变的硬伤（或者说我的偏见），其优点应该已表现在其文档中，不再赘述。至于我的偏见能不能成为你的偏见，请自行思考核实，仅供大家选型时开拓思路</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyesx/p/10041923.html</dc:identifier>
</item>
<item>
<title>[UWP] 用 AudioGraph 来增强 UWP 的音频处理能力 - cjw1115</title>
<link>http://www.cnblogs.com/cjw1115/p/10041894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjw1115/p/10041894.html</guid>
<description>&lt;p&gt;AudioGraph 是 Windows.Media.Audio 命名空间下提供的音频处理接口之一。&lt;/p&gt;
&lt;p&gt;可以通过 AudioGraph 的静态方法 CreateAsync 来实例化一个 AudioGraph 对象，实例化的时候需要传入一个参数 AudioGraphSettings 来配置 AudioGraph。 Windows把系统中的音频分成了大概12种类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum AudioRenderCategory
{
    Other = 0,
    ForegroundOnlyMedia = 1,
    BackgroundCapableMedia = 2,
    Communications = 3,
    Alerts = 4,
    SoundEffects = 5,
    GameEffects = 6,
    GameMedia = 7,
    GameChat = 8,
    Speech = 9,
    Movie = 10,
    Media = 11
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造 AudioGraph 的时候选择一种类别，可以应用 Windows 的一些优化措施（具体不知道）&lt;/p&gt;
&lt;p&gt;创建 AudioGraph 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private async Task InitAudioGraph()
{
    AudioGraphSettings settings = new AudioGraphSettings(Windows.Media.Render.AudioRenderCategory.Media);
    CreateAudioGraphResult result = await AudioGraph.CreateAsync(settings);
    if (result.Status == AudioGraphCreationStatus.Success)
    {
        audioGraph = result.Graph;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;audio-graph-如何工作&quot;&gt;Audio Graph 如何工作&lt;/h2&gt;
&lt;p&gt;在 Audio Graph 中，可以包含各种音频节点，包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;音频输入节点(Input Node), DeviceInputNode, FileInputNode, MediaSourceInputNode,AudioFrameInputNode&lt;/li&gt;
&lt;li&gt;音频输出节点(Output Node), AudioSubmixNode&lt;/li&gt;
&lt;li&gt;中间节点(Submix Node), DeviceOutputNode, FileOutputNode, MediaSourceOutputNode,AudioFrameOutputNode&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三种类型的节点可以按照&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入节点---&amp;gt;中间节点---&amp;gt;输出节点&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种顺序来组合,其中中间节点可以有多个，用来完成多级的音频数据处理。&lt;/p&gt;
&lt;p&gt;AudioGraph 中各个节点在处理音频数据的时候，是分段处理的，把完整的音频数据切分成一小段一小段来处理。&lt;/p&gt;
&lt;p&gt;数字音乐存在采样率的概念，比如48Khz,表示一秒采样48000次，因此每一次采样会有一个采样得到采样值Sample。&lt;/p&gt;
&lt;p&gt;AudioGraph 在处理这些采样值的时候，会将其分组，每一个分组为一个 Quantum，默认每一个Quantum 代表10ms, 因此针对48K采样率的音频，每一个Quantum会有480个Sample，也就是说每一次每个音频节点只需要处理480个采样值，针对这480个采样值做各种处理，比如保存，比如变换效果等。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;音频输入节点input-node&quot;&gt;音频输入节点(Input Node)&lt;/h2&gt;
&lt;p&gt;音频输入节点是为了获取音频数据，可以通过麦克风录音，也可以直接从文件读取，也可以从一个网络流里获取，甚至可以直接自己生成一个AudioFrame，自己往里面填音频数据&lt;/p&gt;
&lt;h4 id=&quot;deviceinputnode&quot;&gt;1.DeviceInputNode&lt;/h4&gt;
&lt;p&gt;设备输入节点，实际上就是麦克风。&lt;/p&gt;
&lt;p&gt;值得注意的是同一台电脑上可能有多个音频输入设备，如果在创建输入节点时不指定使用的输入设备，将采用系统默认的。&lt;br/&gt;Windows.Devices.Enumeration.DeviceInformation 下面的接口可以帮助我们选择音频输入设备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IAsyncOperation&amp;lt;CreateAudioDeviceInputNodeResult&amp;gt; CreateDeviceInputNodeAsync(MediaCategory category,AudioEncodingProperties encodingProperties, DeviceInformation device);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;fileinputnode&quot;&gt;2.FileInputNode&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public IAsyncOperation&amp;lt;CreateAudioFileInputNodeResult&amp;gt; CreateFileInputNodeAsync(IStorageFile file);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持的音频格式有 MP3,wav,wma,m4a&lt;/p&gt;
&lt;p&gt;在文件输入节点里面，可以控制播放音频的速度，音量和播放进度&lt;/p&gt;
&lt;h4 id=&quot;mediasourceinputnode&quot;&gt;3.MediaSourceInputNode&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;IAsyncOperation&amp;lt;CreateMediaSourceAudioInputNodeResult&amp;gt; CreateMediaSourceAudioInputNodeAsync(MediaSource mediaSource);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MediaSource可以从多个途径获得，比如文件，比如网络流等，MediaSource类有许多的静态方法可以创建MediaSource对象，比如文件，好处是播放稳定，网络流的话会受网络影响，可能中断&lt;/p&gt;
&lt;h4 id=&quot;audioframeinputnode&quot;&gt;4.AudioFrameInputNode&lt;/h4&gt;
&lt;p&gt;个人认为这个输入节点非常实用，用于创建音频资源和编辑音频会特别方便，因为它允许我们自己填充需要播放的音频数据，接口本身不难，难点是如何生成可以播放的音频数据。&lt;/p&gt;
&lt;p&gt;想要读写一个AudioFrame中数据，需要使用 COM 接口IMemoryBufferByteAccess&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ComImport]
[Guid(&quot;5B0D3235-4DBA-4D44-865E-8F1D0E4FD04D&quot;)]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
unsafe interface IMemoryBufferByteAccess
{
    void GetBuffer(out byte* buffer, out uint capacity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 UWP 本质上就是 各种COM接口组成，在这种场景下直接使用 COM 可能有效率方面的考虑&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;音频输出节点output-node&quot;&gt;音频输出节点(Output Node)&lt;/h2&gt;
&lt;p&gt;与输入节点对应，存在各自的输入节点（MediaSourceInputNode除外）&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;DeviceInputNode, 代表扬声器&lt;/li&gt;
&lt;li&gt;FileInputNode， 代表文件，输出音频数据到文件&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;AudioFrameOutputNode， 这个应用场景我不是很明白，MSDN上这么说：&lt;/p&gt;
&lt;p&gt;“An example scenario for this is performing signal analysis on the audio output”&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2 id=&quot;中间节点混音节点-submix-node&quot;&gt;中间节点（混音节点 Submix Node）&lt;/h2&gt;
&lt;p&gt;所有的输入节点，都有一个接口叫做：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void AddOutgoingConnection(IAudioNode destination);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个接口，可以把输入节点和输出节点连接起来，最简单的，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fileInputNode.AddOutgoingConnection(deviceOutputNode);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么简单一句，就实现了音乐播放，但是如果想做一些混音的话，就不是很方便了，所以需要 Submix Node.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fileInputNode.AddOutgoingConnection(submixNode);

deviceInputNode.AddOutgoingConnection(submixNode);

submixNode.AddOutgoingConnection(deviceOutputNode);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三句代码，可以实现把音乐文件和录音直接混合输出到扬声器，当然也可以输出到文件中。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;Audio Graph 对 UWP 处理音频的能力是一次不错的拓展，基于 Audio Graph，有很多好玩的使用场景，比如官方文档里面介绍到的空间音效 Spatial Audio.&lt;/p&gt;
&lt;p&gt;目前我自己最简单能想到到就是可以用这个做一个简单的电台主播助手APP，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/cjw1115/964491/o_tempsnip.png&quot; alt=&quot;简易电台主播助手&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;本文基本来自于微软官方文档：&lt;/p&gt;
&lt;h3 id=&quot;audio-graph-1&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/audio-video-camera/audio-graphs#audio-frame-output-node&quot;&gt;Audio Graph&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;其中 Spatial Audio 部分的应用本文没有介绍到，这部分需要一定的声学知识才能玩得转！&lt;/p&gt;
&lt;h2 id=&quot;后续会继续把自己对-uwp-audio-的学习记录在博客园&quot;&gt;后续会继续把自己对 UWP Audio 的学习记录在博客园&lt;/h2&gt;
</description>
<pubDate>Thu, 29 Nov 2018 16:31:00 +0000</pubDate>
<dc:creator>cjw1115</dc:creator>
<og:description>Audio Graph AudioGraph 是 Windows.Media.Audio 命名空间下提供的音频处理接口之一。 可以通过 AudioGraph 的静态方法 CreateAsync 来实例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjw1115/p/10041894.html</dc:identifier>
</item>
<item>
<title>Linux磁盘分区，挂载 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10041874.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10041874.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;分区基础知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分区的方式：&lt;/p&gt;

&lt;p&gt;1) mbr分区:&lt;/p&gt;
&lt;p&gt;    1.最多支持四个主分区&lt;/p&gt;
&lt;p&gt;    2.系统只能安装在主分区&lt;/p&gt;
&lt;p&gt;    3.扩展分区要占一个主分区&lt;/p&gt;
&lt;p&gt;    4.MBR最大只支持2TB，但拥有最好的兼容性&lt;/p&gt;

&lt;p&gt;2) gtp分区:&lt;/p&gt;
&lt;p&gt;    1.支持无限多个主分区（但操作系统可能限制，比如 windows下最多128个分区）&lt;/p&gt;
&lt;p&gt;    2.最大支持18EB的大容量（1EB=1024 PB，1PB=1024 TB ）&lt;/p&gt;
&lt;p&gt;    3.windows7 64位以后支持gtp&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001007967-847424511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001014804-540998774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬盘说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1) Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘&lt;/p&gt;

&lt;p&gt;2) 对于IDE硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指&lt;/p&gt;
&lt;p&gt;    IDE硬盘了。“x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属&lt;/p&gt;
&lt;p&gt;    盘）,“~”代表分区，前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就&lt;/p&gt;
&lt;p&gt;    是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为&lt;/p&gt;
&lt;p&gt;    第二个IDE硬盘上的第二个主分区或扩展分区。&lt;/p&gt;

&lt;p&gt;3) 对于SCSI硬盘则标识为“sdx~”，SCSI硬盘是用“sd”来表示分区所在设备的类型的，其余&lt;/p&gt;
&lt;p&gt;    则和IDE硬盘的表示方法一样&lt;/p&gt;

&lt;p&gt;查看分区：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lsblk -f&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001054277-2010297709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001059424-1348669231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;挂在的案例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给Linux增加一块新的硬盘，在/home/newdisk&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;下面我们以增加一块硬盘为例来熟悉下磁盘的相关指令和深入理解磁盘分区、挂&lt;/p&gt;
&lt;p&gt;载、卸载的概念。&lt;/p&gt;
&lt;p&gt;如何增加一块硬盘&lt;/p&gt;
&lt;p&gt;1) 虚拟机添加硬盘&lt;/p&gt;
&lt;p&gt;2) 分区&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    fdisk /dev/sdb&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3) 格式化&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     mkfs -t ext4 /dev/sdb1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4) 挂载&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    mount /dev/sdb  /home/newdisk&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5) 设置可以自动挂载&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 虚拟机添加硬盘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001138416-1264270692.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001148608-2046239451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001152960-1782914015.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001202733-711504403.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001213270-31537565.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 2) 分区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001250213-293649250.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001325254-1540869240.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001332293-1338010556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001338492-961643238.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001347470-1172519595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)格式化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;    mkfs -t ext4 /dev/sdb1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001402645-843658615.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）挂载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001423483-1879927616.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5) 设置可以自动挂载&lt;/p&gt;
&lt;p&gt;不然关机之后之前的设置就完全没有&lt;/p&gt;
&lt;p&gt;设置之后可以都可以使用&lt;/p&gt;
&lt;p&gt;在  etc/fstab文件中就是设置   自动挂在的文件&lt;/p&gt;
&lt;p&gt;vim /etc/fstab&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; mount -a  之后立即执行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001448016-1023721551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001455259-897860668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 重启之后自动分区依然 存在&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; 断掉挂载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001520856-1032152733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;磁盘情况查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询系统整体磁盘使用情况&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    df -h&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    df -lh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181130001540991-1953365969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询指定目录的磁盘占用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 基本语法&lt;/p&gt;
&lt;p&gt;    du -h /目录&lt;/p&gt;
&lt;p&gt;查询指定目录的磁盘占用情况，默认为当前目录&lt;/p&gt;
&lt;p&gt;    -s 指定目录占用大小汇总&lt;/p&gt;
&lt;p&gt;    -h 带计量单位&lt;/p&gt;
&lt;p&gt;    -a 含文件&lt;/p&gt;
&lt;p&gt;    --max-depth=1 子目录深度&lt;/p&gt;
&lt;p&gt;    -c 列出明细的同时，增加汇总值&lt;/p&gt;
&lt;p&gt;• 应用实例&lt;/p&gt;
&lt;p&gt;查询 /opt 目录的磁盘占用情况，深度为1&lt;/p&gt;

</description>
<pubDate>Thu, 29 Nov 2018 16:16:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>分区基础知识 分区的方式： 1) mbr分区: 1.最多支持四个主分区 2.系统只能安装在主分区 3.扩展分区要占一个主分区 4.MBR最大只支持2TB，但拥有最好的兼容性 2) gtp分区: 1.支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10041874.html</dc:identifier>
</item>
<item>
<title>使用IIS调试ASP.NET网站程序 - firefox逍遥一下</title>
<link>http://www.cnblogs.com/xu-yi/p/10041844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xu-yi/p/10041844.html</guid>
<description>&lt;p&gt;在实际的开发当中，相信很多的开发者在开发调试ASP.NET网站时候都是直接通过Visual Studio工具的编译运行来调试的。&lt;/p&gt;
&lt;p&gt;一般情况下，这种调试方式也不会有多少问题，但有时候我们会发现这样的一个情况，就是明明在本地调试运行都没有问题的网站，部署到服务器IIS上，就出现无法描述的线上问题。这时候，就要排除服务器环境是否跟本地环境一样，其中一点还要涉及到IIS的配置的排除。&lt;/p&gt;
&lt;p&gt;那问题来了，我们能不能在开发的时候，就部署在IIS上调试，而不是直接使用Visual Studio的运行调试，这样涉及到IIS配置的相关问题就能及早的暴露出来，比如IIS用户的权限调用等。举个很典型的例子，如我们调用微软的Office Excel组件导出Excel的时候，就需要设置IIS用户组对Com组件的调用权限。&lt;/p&gt;
&lt;p&gt;在开发阶段就通过IIS对网站进行调试，可以避开很多因为IIS设置问题而导致的问题。&lt;/p&gt;
&lt;p&gt;下面来说下配置IIS调试的步骤。&lt;/p&gt;
&lt;p&gt;第一步   打开你的IIS管理器，没有安装IIS服务器的请上网百度如何安装，此处不再阐述。在IIS中新建一个网站，给定一个主机域名为test.com，并将网站目录指向你web项目的根目录，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181129235947791-895027071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二步  网站配置的应用程序池很关键，上图中的应用程序池的名字叫testWeb，那这个应用程序池的.NetFrameWork的版本号应该跟你项目中使用的版本一致。我们点击上图左侧的菜单【应用程序池】，打开应用程序池列表，选中testWeb名称的应用程序池，确认编辑好该程序池的版本号。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181129233641093-359091953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步  确保你的IIS的状态为正在运行而非停止的状态，并且确认你网站的状态以及网站对应应用程序池的状态为正在运行。&lt;/p&gt;
&lt;p&gt;第四步  设置本地电脑的Host文件，配置本地域名test.com。让浏览器识别test.com域名的指向是本地计算机。(此步骤非常关键，不然你在浏览器中输入test.com会告知你无法解析)&lt;/p&gt;
&lt;p&gt;我们在电脑的C盘中查找系统的Host文件，Host文件一般在以下路径中：C:\Windows\System32\drivers\etc。&lt;/p&gt;
&lt;p&gt;找到Host文件后，用文本编辑器打开host文件，推荐使用notepad++文本编辑器。打开后，我们在最后一行加入127.0.0.1   test.com即可，配置完成后保存(Win10系统可能无法编辑保存，我们一般采取复制文件出来，编辑完成后覆盖回原文件)，在浏览器中输入test.com即可指向本地IIS中的网站，即你刚才配置的网站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181129234400632-276631727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第五步  此时配置完毕后，我们在自己本地电脑的浏览器中输入test.com的时候，就会指向你本地IIS配置的test.com网站中，即你当前开发的网站。&lt;/p&gt;

&lt;p&gt;第六步  如果test.com网站测试中发现相应的问题，我们就可以通过附加IIS进程的方式对网站进行调试。当然调试的方式与之前不同了，此时就不是直接点击Visual Studio中的调试按钮或者F5进行调试了。我们可以通过下面的方式进入调试模式，选择菜单栏上的调试，打开子菜单选中附加到进程，如下图(当然可以通过快捷键Ctrl+Alt+P直接调取出附加界面)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181129235219559-2001212255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开后的附加界面如下图，我们找到w3wp.exe进程，然后点击附加按钮即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466191/201811/466191-20181130000022940-1031715499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;附加完成后，你就可在代码中加入相应的断点调试了，在前台浏览器中输入test.com访问出现的错误，你可在Visual Studio中找到对应代码段加入断点。&lt;/p&gt;
&lt;p&gt;通过上述步骤，即可很好的进行网站的调试，IIS相应的配置问题也能及早发现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后，附上我的IT技术学习群，欢迎各位同行入群指导交流。技术群：872894940&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 29 Nov 2018 16:06:00 +0000</pubDate>
<dc:creator>firefox逍遥一下</dc:creator>
<og:description>在实际的开发当中，相信很多的开发者在开发调试ASP.NET网站时候都是直接通过Visual Studio工具的编译运行来调试的。 一般情况下，这种调试方式也不会有多少问题，但有时候我们会发现这样的一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xu-yi/p/10041844.html</dc:identifier>
</item>
<item>
<title>Asp.net Core 使用Jenkins + Dockor 实现持续集成、自动化部署（一）：Jenkins安装 - 乔达摩</title>
<link>http://www.cnblogs.com/xiaxiaolu/p/10041788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaxiaolu/p/10041788.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234042290-2122189149.png&quot; alt=&quot;Related image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实园子里很多大佬都写过，我也是一个搬运工很多东西不是原创的，不过还是想把自己安装的过程，记录下来如果能帮到大家的忙，也是一件功德无量的事；&lt;/p&gt;

&lt;p&gt;centos：7.2&lt;br/&gt;cpu:1核 2G内存 1M带宽&lt;br/&gt;其实用的腾讯云&lt;/p&gt;

&lt;p&gt;这里的jenkins就不从docker hub里面直接pull镜像安装了，为什么呢，我这里引用大佬的原话：&lt;/p&gt;
&lt;blockquote readability=&quot;8.5714285714286&quot;&gt;
&lt;p&gt;首先不直接从Docker Store上直接Pull Jenkins 的 Image 文件，因为待会需要进行dotnet core 的 Docker自动部署，需要对宿主机上的Docker进行直接操作，那么需要挂载 Docker 给 Jenkins Image，所以现在需要自己动手编写 Dockerfile 构建自定义的Jenkins。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LongJiangXie/p/7517909.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/LongJiangXie/p/7517909.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构建自定义的dockerfile&quot;&gt;1、构建自定义的Dockerfile&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# touch Dockerfile
# vim Dockerfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM jenkins

USER root
#清除了基础镜像设置的源，切换成腾讯云的jessie源
#使用非腾讯云环境的需要将 tencentyun 改为 aliyun
RUN echo '' &amp;gt; /etc/apt/sources.list.d/jessie-backports.list \
  &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tencentyun.com/debian jessie main contrib non-free&quot; &amp;gt; /etc/apt/sources.list \
  &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tencentyun.com/debian jessie-updates main contrib non-free&quot; &amp;gt;&amp;gt; /etc/apt/sources.list \
  &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tencentyun.com/debian-security jessie/updates main contrib non-free&quot; &amp;gt;&amp;gt; /etc/apt/sources.list
#更新源并安装缺少的包
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y libltdl7 &amp;amp;&amp;amp; apt-get update

ARG dockerGid=999

RUN echo &quot;docker:x:${dockerGid}:jenkins&quot; &amp;gt;&amp;gt; /etc/group 

# 安装 docker-compose 因为等下构建环境的需要
RUN curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose

RUN chmod +x /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;build镜像&quot;&gt;2、build镜像&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker build . -t auto-jenkins&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234041599-1056173322.png&quot; alt=&quot;1539831424590&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到Successfully 莫名的心情愉悦。这就代表构建成功了；&lt;/p&gt;
&lt;h2 id=&quot;创建jenkins项目文件的挂载目录&quot;&gt;3、创建jenkins项目文件的挂载目录&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /var/jenkins_home&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改目录权限&quot;&gt;4、修改目录权限&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这一步必不可少！会导致权限不足报错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;chown -R 1000 /var/jenkins_home&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;run我们自定义jenkins镜像-auto-jenkins&quot;&gt;5、run我们自定义jenkins镜像 auto-jenkins&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我用7080作为对外的jenkins ip（因为我的8080被占用了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;docker run --name jenkins -p 7080:8080 -p 50000:50000 \
-v /var/run/docker.sock:/var/run/docker.sock \
-v $(which docker):/bin/docker \
-v /var/jenkins_home:/var/jenkins_home \
-d auto-jenkins&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run之后使用&lt;code&gt;docker ps&lt;/code&gt; 查看运行中的容器，如看到如下图，表示jenkins已正常启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234041089-274228027.png&quot; alt=&quot;1539832220978&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、完成jenkins安装&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8ip:7080&quot; class=&quot;uri&quot;&gt;http://你的服务器ip:7080&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234040697-609274436.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要安装密码，证明这是你的服务器，进入容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it jenkins /bin/bash
cat /var/jenkins_home/secrets/initialAdminPassword&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制密码填好，点击继续；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234040138-1404589877.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，点击Install suggested plugins，安装jenkins常用插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234039470-1250485053.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完毕后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234038881-503695539.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来到这里，其实安装结束了，填写完管理员信息后，开始你的自动化部署之旅吧！&lt;/p&gt;
&lt;p&gt;接下来，请继续看我的另一篇文章 &lt;a href=&quot;https://www.cnblogs.com/xiaxiaolu/p/10041800.html&quot;&gt;Asp.net Core 使用Jenkins + Dockor 实现持续集成、自动化部署（二）：部署&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LongJiangXie/p/7517909.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/LongJiangXie/p/7517909.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>乔达摩</dc:creator>
<og:description>﻿ 写在前面 其实园子里很多大佬都写过，我也是一个搬运工很多东西不是原创的，不过还是想把自己安装的过程，记录下来如果能帮到大家的忙，也是一件功德无量的事； 运行环境 centos：7.2 cpu:1核</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaxiaolu/p/10041788.html</dc:identifier>
</item>
<item>
<title>设计模式之单例模式 - Eurekaa</title>
<link>http://www.cnblogs.com/zuanzuan/p/10041705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/10041705.html</guid>
<description>&lt;p&gt;本篇博客归类于设计模式，单例模式算是我了解的不多的设计模式之一，在某些应用场景下为了节省资源，常常使用单例模式来编写代码。&lt;/p&gt;
&lt;p&gt;单例模式（Singleton Pattert）是一种常用的软件设计模式，该模式的主要目的是确保在某一个类中能且只能产生一个实例。当在某些场景下希望某个类只能产生一个实例时，就可以使用单例模式了。&lt;/p&gt;

&lt;p&gt;单例模式也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。&lt;/p&gt;
&lt;p&gt;实现单例模式的思路是：一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。&lt;/p&gt;
&lt;p&gt;单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建实例方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例惟一的原则。解决这个问题的办法是为指示是否已经实例化的变量提供一个互斥锁（虽然这样会降低效率）。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，学习了使用某一个类来创建多个不同的对象，那么如何使得该类只能产生一个对象呢？&lt;/p&gt;
&lt;p&gt;在Python 中，可以使用多种方法来实现单例模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用模块&lt;/li&gt;
&lt;li&gt;使用魔术方法__new__&lt;/li&gt;
&lt;li&gt;使用装饰器&lt;/li&gt;
&lt;li&gt;使用元类&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;使用模块&quot;&gt;使用模块&lt;/h2&gt;
&lt;p&gt;python 中的模块就是天然的单例模式，因为模块只会在第一次导入的时候加载，会生成一个 &lt;strong&gt;.pyc&lt;/strong&gt;文件，第二次导入时，就会直接加载 &lt;strong&gt;.pyc&lt;/strong&gt;文件，而不会再次执行模块代码。因此，可以把相关的代码和数据定义在一个模块中，就可以获得一个单例对象了。然后要用的话导入就可以，我可以保证这样做的话肯定只有一个单例对象。代码就不演示了。&lt;/p&gt;
&lt;h2 id=&quot;使用特殊方法__new__&quot;&gt;使用特殊方法__new__&lt;/h2&gt;
&lt;p&gt;在使用类实例化一个对象时，其实python 解释器做了两步操作:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 object 的__new__方法创建一个空对象；&lt;/li&gt;
&lt;li&gt;调用类本身的__init__方法进行初始化（这都是通过元类的__call__来间接调用的）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么是不是可以在调用__new__的时候做一些判断来使得只能创建一个单例对象呢？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Singleinstance:
    _instance = None
    def __new__(cls, *arg, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleinstance, cls).__new__(cls, *args, **kwargs)
        return cls._instance
class MyClass(Singleinstance):
    a = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，将类的__new__方法和一个类的属性关联起来，如果 cls._instance 为 None 则创建一个对象，否则的话直接返回cls._instance。&lt;/p&gt;
&lt;h2 id=&quot;使用装饰器&quot;&gt;使用装饰器&lt;/h2&gt;
&lt;p&gt;装饰器可以动态的修改一个类或者函数的功能。所以可以使用装饰器来装饰某各类，使其只能生成一个实例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps

def singleinstance(cls):
    instances = {}
    @wraps(cls)
    def getinstance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return getinstance

@singleinstance
class MyClass:
    a = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面，定义了一个装饰器 singleinstance，它返回了一个内部函数getinstance，该函数会判断某个类是否在字典 instance 中，如果不存在，则会将 cls 作为 key，cls(*args, **kwargs)作为 value存到 instances 中，否则，直接返回 instances[cls]。该装饰器可以装饰所有只需要产生一个实例的类上。&lt;/p&gt;

&lt;p&gt;元类 metaclass 可以通过自定义__new__方法和__init__方法来控制类的创建过程，它主要做三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拦截类的创建&lt;/li&gt;
&lt;li&gt;修改类的定义&lt;/li&gt;
&lt;li&gt;返回修改后的类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用元类实现单例的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyMetaClass(type):

    # def __init__(self):
    #     pass

    instance = None
    def __call__(cls, *args, **kwargs):
        # 判断对象有没有创建过
        if not MyMetaClass.instance:
            # 创建空对象
            MyMetaClass.instance = object.__new__(cls)
            print(cls.__name__)
            print(cls.__dict__)
            print(&quot;创建新的播放器对象!&quot;)
            # 初始化对象
            MyMetaClass.instance.__init__(*args,**kwargs)
            print(type(MyMetaClass.instance))
            # 返回对象
        return MyMetaClass.instance

class CDPlayer(metaclass=MyMetaClass):
    pass     &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 29 Nov 2018 15:25:00 +0000</pubDate>
<dc:creator>Eurekaa</dc:creator>
<og:description>前言 本篇博客归类于设计模式，单例模式算是我了解的不多的设计模式之一，在某些应用场景下为了节省资源，常常使用单例模式来编写代码。 单例模式（Singleton Pattert）是一种常用的软件设计模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/10041705.html</dc:identifier>
</item>
<item>
<title>Charles--/安装/破解/支持https抓包 - jack.cx</title>
<link>http://www.cnblogs.com/Jack-cx/p/10041579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-cx/p/10041579.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 一、安装破解Charles&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.下载charles4.0.2版本，下面的jar包需要和charles版本对应&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.&lt;span&gt;下载地址：&lt;/span&gt;&lt;a href=&quot;https://www.cr173.com/soft/494576.html&quot;&gt;&lt;span&gt;https://www.cr173.com/soft/494576.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.1&lt;span&gt;这里下的是破解版里面有破解的&lt;/span&gt;&lt;span&gt;Charles.jar&lt;/span&gt;&lt;span&gt;和注册名以及&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.2&lt;span&gt;如果本地有了&lt;/span&gt;&lt;span&gt;4.0.2&lt;/span&gt;&lt;span&gt;版本的&lt;/span&gt;&lt;span&gt;charles&lt;/span&gt;&lt;span&gt;也可以在这个网盘下载破解的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包 &lt;/span&gt;&lt;span&gt;https://pan.baidu.com/s/1Pe3nNLqmYDKM2f15HoNMdw&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.3.&lt;span&gt;点击&lt;/span&gt;charles&lt;span&gt;完成安装&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.1&lt;span&gt;在访达中选择此应用显示包内容，找到&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;目录把破解的&lt;/span&gt;&lt;span&gt;Charles.jar&lt;/span&gt;&lt;span&gt;替换进去&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230157593-1441525345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;3.2 &lt;span&gt;打开&lt;/span&gt;&lt;span&gt;charles,&lt;/span&gt;&lt;span&gt;导航&lt;/span&gt;&lt;span&gt;--help--register charles&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230236269-116973962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;3.3 &lt;span&gt;输入&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;xclient   key&lt;span&gt;：&lt;/span&gt;18e69f6d5bc820d4d3  &lt;span&gt;点击&lt;/span&gt;register&lt;span&gt;重启即破解成功&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230317770-262560565.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、配置代理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  1.1&lt;span&gt;导航栏&lt;/span&gt;&lt;span&gt;--Proxy---Proxy Settings  &lt;/span&gt;&lt;span&gt;默认端口&lt;/span&gt;&lt;span&gt;8888&lt;/span&gt; &lt;span&gt;可以自定义，点击&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;后重启&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230504734-1854364034.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1.2&lt;span&gt;手机配置代理，保存后&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;打开&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;访问接口即可&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230544629-462167898.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看请求&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230627720-1135978482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 这样就配置好了，但是不能抓取https接口，所以现在配置下ssl&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、配置安装ssl抓取https&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.&lt;span&gt;打卡&lt;/span&gt;charles--&amp;gt;help--&amp;gt;ssl proxying---&amp;gt;install charles root certificate....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230824087-929926540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1.&lt;span&gt;下载证书，手机浏览器打开&lt;/span&gt;chls.pro/ssl &lt;span&gt;下载证书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230903263-1410568028.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2.&lt;span&gt;安装到手机&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ios&lt;span&gt;：设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;通用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;描述文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;选择下载的文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;设置&lt;/span&gt;--&amp;gt;&lt;span&gt;通用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;关于本机&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;证书信任设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;选择安装的证书信任&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;安卓：设置&lt;/span&gt;--&amp;gt;&lt;span&gt;设置和隐私&lt;/span&gt;&lt;span&gt;-&amp;gt;-&lt;/span&gt;&lt;span&gt;更多安全设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;SD&lt;/span&gt;&lt;span&gt;卡安装&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;选择下载的文件会弹出命名下即可（以华为为例）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.&lt;span&gt;可以选择性设置抓取指定的&lt;/span&gt;https&lt;span&gt;域名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129231022187-1165106367.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 重启抓取https接口验证&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129231118647-1922455087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Charles安装和配置代理抓包就完成了！！！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 29 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>jack.cx</dc:creator>
<og:description>一、安装破解Charles 1.下载charles4.0.2版本，下面的jar包需要和charles版本对应 2.下载地址：https://www.cr173.com/soft/494576.html</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jack-cx/p/10041579.html</dc:identifier>
</item>
<item>
<title>一文让你完全弄懂Stegosaurus - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/10041534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/10041534.html</guid>
<description>&lt;p&gt;国内关于 &lt;code&gt;Stegosaurus&lt;/code&gt; 的介绍少之又少，一般只是单纯的工具使用的讲解之类的，并且本人在学习过程中也是遇到了很多的问题，基于此种情况下写下此文，也是为我逝去的青春时光留个念想吧~&lt;/p&gt;
&lt;h3 id=&quot;stegosaurus是什么&quot;&gt;Stegosaurus是什么？&lt;/h3&gt;
&lt;p&gt;在了解 &lt;code&gt;Stegosaurus&lt;/code&gt; 是什么之前，我们首先需要弄清楚的一个问题是：什么是隐写术？&lt;/p&gt;
&lt;p&gt;隐写术，从字面上来理解，隐是隐藏，所以我们从字面上可以知道，隐写术是一类可以隐藏自己写的一些东西的方法，可能我们所写的这些东西是一些比较重要的信息，不想让别人看到，我们会考虑采取一些办法去隐藏它，比如对所写的文件加解密，用一些特殊的纸张(比如纸张遇到水后，上面的字才会显示出来)之类的。隐写术这种手段在日常生活中用的十分广泛，我相信部分小伙伴们小时候曾经有过写日记的习惯，写完的日记可能不想让爸爸妈妈知道(青春期萌动的内心，咱们都是过来人，都懂这个2333)，所以以前常常会买那种上了把锁的那种日记本，这样就不怕自己的小秘密被爸爸妈妈知道啦。&lt;/p&gt;
&lt;p&gt;事实上，隐写术是一门关于信息隐藏的技巧与科学，专业一点的讲，就是指的是采取一些不让除预期的接收者之外的任何人知晓信息的传递事件或者信息的内容的方法。隐写术的英文叫做 &lt;code&gt;Steganography&lt;/code&gt; ，根据维基百科的解释，这个英文来源于特里特米乌斯的一本讲述密码学与隐写术的著作 &lt;code&gt;Steganographia&lt;/code&gt; ，该书书名源于希腊语，意为“隐秘书写”。(这个不是重点)&lt;/p&gt;
&lt;p&gt;所以今天呢，我们要给大家介绍的是隐写术的其中一个分支(也就是其中一种隐写的方法)，也就是 &lt;code&gt;Stegosaurus&lt;/code&gt; ， &lt;code&gt;Stegosaurus&lt;/code&gt; 是一款隐写工具，它允许我们在 &lt;code&gt;Python&lt;/code&gt; 字节码文件( &lt;code&gt;pyc&lt;/code&gt; 或 &lt;code&gt;pyo&lt;/code&gt; )中嵌入任意 &lt;code&gt;Payload&lt;/code&gt; 。由于编码密度较低，因此我们嵌入 &lt;code&gt;Payload&lt;/code&gt; 的过程既不会改变源代码的运行行为，也不会改变源文件的文件大小。 &lt;code&gt;Payload&lt;/code&gt; 代码会被分散嵌入到字节码之中，所以类似 &lt;code&gt;strings&lt;/code&gt; 这样的代码工具无法查找到实际的 &lt;code&gt;Payload&lt;/code&gt; 。 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;dis&lt;/code&gt; 模块会返回源文件的字节码，然后我们就可以使用 &lt;code&gt;Stegosaurus&lt;/code&gt; 来嵌入 &lt;code&gt;Payload&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;为了方便维护，我将此项目移至 &lt;code&gt;Github&lt;/code&gt; 上：https://github.com/AngelKitty/stegosaurus&lt;/p&gt;
&lt;p&gt;首先讲到一个工具，不可避免的，我们需要讲解它的用法，我并不会像文档一样工整的把用法罗列在一起，如果需要了解更加细节的部分请参考 &lt;a href=&quot;https://github.com/AngelKitty/stegosaurus&quot;&gt;&lt;code&gt;Github&lt;/code&gt;&lt;/a&gt;上的详细文档，我会拿一些实际的案例去给大家讲解一些常见命令的用法，在后续的文章中，我会大家深入理解 &lt;code&gt;python&lt;/code&gt; 反编译的一些东西。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Stegosaurus&lt;/code&gt; 仅支持 &lt;code&gt;Python3.6&lt;/code&gt; 及其以下版本&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到一个工具，我们一般会看看它的基本用法：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 stegosaurus.py -h&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ python3 -m stegosaurus -h
usage: stegosaurus.py [-h] [-p PAYLOAD] [-r] [-s] [-v] [-x] carrier

positional arguments:
  carrier               Carrier py, pyc or pyo file

optional arguments:
  -h, --help            show this help message and exit
  -p PAYLOAD, --payload PAYLOAD
                        Embed payload in carrier file
  -r, --report          Report max available payload size carrier supports
  -s, --side-by-side    Do not overwrite carrier file, install side by side
                        instead.
  -v, --verbose         Increase verbosity once per use
  -x, --extract         Extract payload from carrier file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224148815-224587391.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到有很多参数选项，我们就以一道赛题来讲解部分参数命令吧~&lt;/p&gt;
&lt;p&gt;我们此次要讲解的这道题是来自 &lt;code&gt;Bugku&lt;/code&gt; 的 &lt;code&gt;QAQ&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;赛题链接如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://ctf.bugku.com/files/447e4b626f2d2481809b8690613c1613/QAQ
http://ctf.bugku.com/files/5c02892cd05a9dcd1c5a34ef22dd9c5e/cipher.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先拿到这道题，用 &lt;code&gt;010Editor&lt;/code&gt; 乍一眼看过去，我们可以看到一些特征信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224147720-2014371843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以判断这是个跟 &lt;code&gt;python&lt;/code&gt; 有关的东西，通过查阅相关资料可以判断这是个 &lt;code&gt;python&lt;/code&gt; 经编译过后的 &lt;code&gt;pyc&lt;/code&gt; 文件。这里可能很多小伙伴们可能不理解了，什么是 &lt;code&gt;pyc&lt;/code&gt; 文件呢？为什么会生成 &lt;code&gt;pyc&lt;/code&gt; 文件？ &lt;code&gt;pyc&lt;/code&gt; 文件又是何时生成的呢？下面我将一一解答这些问题。&lt;/p&gt;
&lt;p&gt;简单来说， &lt;code&gt;pyc&lt;/code&gt; 文件就是 &lt;code&gt;Python&lt;/code&gt; 的字节码文件，是个二进制文件。我们都知道 &lt;code&gt;Python&lt;/code&gt; 是一种全平台的解释性语言，全平台其实就是 &lt;code&gt;Python&lt;/code&gt; 文件在经过解释器解释之后(或者称为编译)生成的 &lt;code&gt;pyc&lt;/code&gt; 文件可以在多个平台下运行，这样同样也可以隐藏源代码。其实， &lt;code&gt;Python&lt;/code&gt; 是完全面向对象的语言， &lt;code&gt;Python&lt;/code&gt; 文件在经过解释器解释后生成字节码对象 &lt;code&gt;PyCodeObject&lt;/code&gt; ， &lt;code&gt;pyc&lt;/code&gt; 文件可以理解为是 &lt;code&gt;PyCodeObject&lt;/code&gt; 对象的持久化保存方式。而 &lt;code&gt;pyc&lt;/code&gt; 文件只有在文件被当成模块导入时才会生成。也就是说， &lt;code&gt;Python&lt;/code&gt; 解释器认为，只有 &lt;code&gt;import&lt;/code&gt; 进行的模块才需要被重用。 生成 &lt;code&gt;pyc&lt;/code&gt; 文件的好处显而易见，当我们多次运行程序时，不需要重新对该模块进行重新的解释。主文件一般只需要加载一次，不会被其他模块导入，所以一般主文件不会生成 &lt;code&gt;pyc&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;我们举个例子来说明这个问题：&lt;/p&gt;
&lt;p&gt;为了方便起见，我们事先创建一个test文件夹作为此次实验的测试：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir test &amp;amp;&amp;amp; cd test/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们现在有个 &lt;code&gt;test.py&lt;/code&gt; 文件，文件内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def print_test():
    print('Hello,Kitty!')

print_test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不用说，想必大家都知道打印出的结果是下面这个：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Hello,Kitty!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过下面命令查看下当前文件夹下有哪些文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ls -alh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224146423-502302143.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现，并没有 &lt;code&gt;pyc&lt;/code&gt; 文件生成。&lt;/p&gt;
&lt;p&gt;‘我们再去创建一个文件为 &lt;code&gt;import_test.py&lt;/code&gt; 文件，文件内容如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注： &lt;code&gt;test.py&lt;/code&gt; 和 &lt;code&gt;import_test.py&lt;/code&gt; 应当放在同一文件夹下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import test

test.print_test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 import_test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Hello,Kitty!
Hello,Kitty!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诶，为啥会打印出两句相同的话呢？我们再往下看，我们通过下面命令查看下当前文件夹下有哪些文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ls -alh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;总用量 20K
drwxr-xr-x 3 python python 4.0K 11月  5 20:38 .
drwxrwxr-x 4 python python 4.0K 11月  5 20:25 ..
-rw-r--r-- 1 python python   31 11月  5 20:38 import_test.py
drwxr-xr-x 2 python python 4.0K 11月  5 20:38 __pycache__
-rw-r--r-- 1 python python   58 11月  5 20:28 test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诶，多了个 &lt;code&gt;__pycache__&lt;/code&gt; 文件夹，我们进入文件夹下看看有什么？&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd __pycache__ &amp;amp;&amp;amp; ls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224145422-875160291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到生成了一个 &lt;code&gt;test.cpython-36.pyc&lt;/code&gt; 。为什么是这样子呢？&lt;/p&gt;
&lt;p&gt;我们可以看到，我们在执行 &lt;code&gt;python3 import_test.py&lt;/code&gt; 命令的时候，首先开始执行的是 &lt;code&gt;import test&lt;/code&gt; ，即导入 &lt;code&gt;test&lt;/code&gt; 模块，而一个模块被导入时， &lt;code&gt;PVM(Python Virtual Machine)&lt;/code&gt; 会在后台从一系列路径中搜索该模块，其搜索过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在当前目录下搜索该模块&lt;/li&gt;
&lt;li&gt;在环境变量 &lt;code&gt;PYTHONPATH&lt;/code&gt; 中指定的路径列表中依次搜索&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;python&lt;/code&gt; 安装路径中搜索&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;事实上， &lt;code&gt;PVM&lt;/code&gt; 通过变量 &lt;code&gt;sys.path&lt;/code&gt; 中包含的路径来搜索，这个变量里面包含的路径列表就是上面提到的这些路径信息。&lt;/p&gt;
&lt;p&gt;模块的搜索路径都放在了 &lt;code&gt;sys.path&lt;/code&gt; 列表中，如果缺省的 &lt;code&gt;sys.path&lt;/code&gt; 中没有含有自己的模块或包的路径，可以动态的加入 &lt;code&gt;(sys.path.apend)&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;事实上， &lt;code&gt;Python&lt;/code&gt; 中所有加载到内存的模块都放在 &lt;code&gt;sys.modules&lt;/code&gt; 。当 &lt;code&gt;import&lt;/code&gt; 一个模块时首先会在这个列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用 &lt;code&gt;import&lt;/code&gt; 的模块的 &lt;code&gt;Local&lt;/code&gt; 名字空间中。如果没有加载则从 &lt;code&gt;sys.path&lt;/code&gt; 目录中按照模块名称查找模块文件，模块文件可以是 &lt;code&gt;py&lt;/code&gt; 、 &lt;code&gt;pyc&lt;/code&gt; 、 &lt;code&gt;pyd&lt;/code&gt; ，找到后将模块载入内存，并加入到 &lt;code&gt;sys.modules&lt;/code&gt; 中，并将名称导入到当前的 &lt;code&gt;Local&lt;/code&gt; 名字空间。&lt;/p&gt;
&lt;p&gt;可以看出来，&lt;strong&gt;一个模块不会重复载入&lt;/strong&gt;。多个不同的模块都可以用 &lt;code&gt;import&lt;/code&gt; 引入同一个模块到自己的 &lt;code&gt;Local&lt;/code&gt; 名字空间，其实背后的 &lt;code&gt;PyModuleObject&lt;/code&gt; 对象只有一个。&lt;/p&gt;
&lt;p&gt;在这里，我还要说明一个问题，&lt;strong&gt;&lt;code&gt;import&lt;/code&gt; 只能导入模块，不能导入模块中的对象(类、函数、变量等)。&lt;/strong&gt;例如像上面这个例子，我在 &lt;code&gt;test.py&lt;/code&gt; 里面定义了一个函数 &lt;code&gt;print_test()&lt;/code&gt; ，我在另外一个模块文件 &lt;code&gt;import_test.py&lt;/code&gt;不能直接通过 &lt;code&gt;import test.print_test&lt;/code&gt; 将 &lt;code&gt;print_test&lt;/code&gt; 导入到本模块文件中，只能用 &lt;code&gt;import test&lt;/code&gt; 进行导入。如果我想只导入特定的类、函数、变量，用 &lt;code&gt;from test import print_test&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224144386-1313733869.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然说到了 &lt;code&gt;import&lt;/code&gt; 导入机制，再提一提嵌套导入和 &lt;code&gt;Package&lt;/code&gt; 导入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;import&lt;/code&gt; 嵌套导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嵌套，不难理解，就是一个套着一个。小时候我们都玩过俄罗斯套娃吧，俄罗斯套娃就是一个大娃娃里面套着一个小娃娃，小娃娃里面还有更小的娃娃，而这个嵌套导入也是同一个意思。假如我们现在有一个模块，我们想要导入模块 &lt;code&gt;A&lt;/code&gt; ，而模块 &lt;code&gt;A&lt;/code&gt; 中有含有其他模块需要导入，比如模块 &lt;code&gt;B&lt;/code&gt; ，模块 &lt;code&gt;B&lt;/code&gt; 中又含有模块 &lt;code&gt;C&lt;/code&gt; ，一直这样延续下去，这种方式我们称之为 &lt;code&gt;import&lt;/code&gt; 嵌套导入。&lt;/p&gt;
&lt;p&gt;对这种嵌套比较容易理解，我们需要注意的一点就是各个模块的 &lt;code&gt;Local&lt;/code&gt; 名字空间是独立的，所以上面的例子，本模块 &lt;code&gt;import A&lt;/code&gt; 完了后，本模块只能访问模块 &lt;code&gt;A&lt;/code&gt; ，不能访问 &lt;code&gt;B&lt;/code&gt; 及其它模块。虽然模块 &lt;code&gt;B&lt;/code&gt; 已经加载到内存了，如果要访问，还必须明确在本模块中导入 &lt;code&gt;import B&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;那如果我们有以下嵌套这种情况，我们该怎么处理呢？&lt;/p&gt;
&lt;p&gt;比如我们现在有个模块 &lt;code&gt;A&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# A.py
from B import D
class C:
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有个模块 &lt;code&gt;B&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# B.py
from A import C
class D:
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们简单分析一下程序，如果程序运行，应该会去从模块B中调用对象D。&lt;/p&gt;
&lt;p&gt;我们尝试执行一下 &lt;code&gt;python A.py&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224143517-1778488256.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报 &lt;code&gt;ImportError&lt;/code&gt; 的错误，似乎是没有加载到对象 &lt;code&gt;D&lt;/code&gt; ，而我们将 &lt;code&gt;from B import D&lt;/code&gt; 改成 &lt;code&gt;import B&lt;/code&gt; ，我们似乎就能执行成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224142796-1461623914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是怎么回事呢？这其实是跟 &lt;code&gt;Python&lt;/code&gt; 内部 &lt;code&gt;import&lt;/code&gt; 的机制是有关的，具体到 &lt;code&gt;from B import D&lt;/code&gt; ， &lt;code&gt;Python&lt;/code&gt; 内部会分成以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;sys.modules&lt;/code&gt; 中查找符号 &lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果符号 &lt;code&gt;B&lt;/code&gt; 存在，则获得符号 &lt;code&gt;B&lt;/code&gt; 对应的 &lt;code&gt;module&lt;/code&gt; 对象 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 。从 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 的 &lt;code&gt;__dict__&lt;/code&gt; 中获得符号 &lt;code&gt;D&lt;/code&gt; 对应的对象，如果 &lt;code&gt;D&lt;/code&gt; 不存在，则抛出异常&lt;/li&gt;
&lt;li&gt;如果符号 &lt;code&gt;B&lt;/code&gt; 不存在，则创建一个新的 &lt;code&gt;module&lt;/code&gt; 对象 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; ，注意，此时 &lt;code&gt;module&lt;/code&gt; 对象的 &lt;code&gt;__dict__&lt;/code&gt; 为空。执行 &lt;code&gt;B.py&lt;/code&gt; 中的表达式，填充 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 的 &lt;code&gt;__dict__&lt;/code&gt; 。从 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 的 &lt;code&gt;__dict__&lt;/code&gt; 中获得 &lt;code&gt;D&lt;/code&gt; 对应的对象。如果 &lt;code&gt;D&lt;/code&gt; 不存在，则抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，这个例子的执行顺序如下：&lt;/p&gt;
&lt;p&gt;1、执行 &lt;code&gt;A.py&lt;/code&gt; 中的 &lt;code&gt;from B import D&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：由于是执行的 &lt;code&gt;python A.py&lt;/code&gt; ，所以在 &lt;code&gt;sys.modules&lt;/code&gt; 中并没有 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 存在，首先为 &lt;code&gt;B.py&lt;/code&gt; 创建一个 &lt;code&gt;module&lt;/code&gt; 对象( &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; )，注意，这时创建的这个 &lt;code&gt;module&lt;/code&gt; 对象是空的，里边啥也没有，在 &lt;code&gt;Python&lt;/code&gt; 内部创建了这个 &lt;code&gt;module&lt;/code&gt; 对象之后，就会解析执行 &lt;code&gt;B.py&lt;/code&gt; ，其目的是填充 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 这个 &lt;code&gt;dict&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、执行 &lt;code&gt;B.py&lt;/code&gt; 中的 &lt;code&gt;from A import C&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：在执行 &lt;code&gt;B.py&lt;/code&gt; 的过程中，会碰到这一句，首先检查 &lt;code&gt;sys.modules&lt;/code&gt; 这个 &lt;code&gt;module&lt;/code&gt; 缓存中是否已经存在 &lt;code&gt;&amp;lt;module A&amp;gt;&lt;/code&gt; 了，由于这时缓存还没有缓存 &lt;code&gt;&amp;lt;module A&amp;gt;&lt;/code&gt; ，所以类似的， &lt;code&gt;Python&lt;/code&gt; 内部会为 &lt;code&gt;A.py&lt;/code&gt; 创建一个 &lt;code&gt;module&lt;/code&gt; 对象( &lt;code&gt;&amp;lt;module A&amp;gt;&lt;/code&gt; )，然后，同样地，执行 &lt;code&gt;A.py&lt;/code&gt; 中的语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、再次执行 &lt;code&gt;A.py&lt;/code&gt; 中的 &lt;code&gt;from B import D&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：这时，由于在第 &lt;code&gt;1&lt;/code&gt; 步时，创建的 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 对象已经缓存在了 &lt;code&gt;sys.modules&lt;/code&gt; 中，所以直接就得到了 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; ，但是，注意，从整个过程来看，我们知道，这时 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 还是一个空的对象，里面啥也没有，所以从这个 &lt;code&gt;module&lt;/code&gt; 中获得符号 &lt;code&gt;D&lt;/code&gt; 的操作就会抛出异常。如果这里只是 &lt;code&gt;import B&lt;/code&gt; ，由于 &lt;code&gt;B&lt;/code&gt; 这个符号在 &lt;code&gt;sys.modules&lt;/code&gt; 中已经存在，所以是不会抛出异常的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以从下图很清楚的看到 &lt;code&gt;import&lt;/code&gt; 嵌套导入的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224141887-1531061124.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Package&lt;/code&gt; 导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包 &lt;code&gt;(Package)&lt;/code&gt; 可以看成模块的集合，只要一个文件夹下面有个 &lt;code&gt;__init__.py&lt;/code&gt; 文件，那么这个文件夹就可以看做是一个包。包下面的文件夹还可以成为包(子包)。更进一步的讲，多个较小的包可以聚合成一个较大的包。通过包这种结构，我们可以很方便的进行类的管理和维护，也方便了用户的使用。比如 &lt;code&gt;SQLAlchemy&lt;/code&gt; 等都是以包的形式发布给用户的。&lt;/p&gt;
&lt;p&gt;包和模块其实是很类似的东西，如果查看包的类型： &lt;code&gt;import SQLAlchemy type(SQLAlchemy)&lt;/code&gt; ，可以看到其实也是 &lt;code&gt;&amp;lt;type 'module'&amp;gt;&lt;/code&gt; 。 &lt;code&gt;import&lt;/code&gt; 包的时候查找的路径也是 &lt;code&gt;sys.path&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;包导入的过程和模块的基本一致，只是导入包的时候会执行此包目录下的 &lt;strong&gt;&lt;code&gt;__init__.py&lt;/code&gt;&lt;/strong&gt; ，而不是模块里面的语句了。另外，如果只是单纯的导入包，而包的 &lt;code&gt;__init__.py&lt;/code&gt; 中又没有明确的其他初始化操作，那么此包下面的模块是不会自动导入的。&lt;/p&gt;
&lt;p&gt;假设我们有如下文件结构：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;.
└── PA
    ├── __init__.py
    ├── PB1
    │   ├── __init__.py
    │   └── pb1_m.py
    ├── PB2
    │   ├── __init__.py
    │   └── pb2_m.py
    └── wave.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224140878-350095984.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wave.py&lt;/code&gt; ， &lt;code&gt;pb1_m.py&lt;/code&gt; ， &lt;code&gt;pb2_m.py&lt;/code&gt; 文件中我们均定义了如下函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def getName():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt; 文件内容均为空。&lt;/p&gt;
&lt;p&gt;我们新建一个 &lt;code&gt;test.py&lt;/code&gt; ，内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
import PA.wave #1
import PA.PB1 #2
import PA.PB1.pb1_m as m1 #3
import PA.PB2.pb2_m #4
PA.wave.getName() #5
m1.getName() #6
PA.PB2.pb2_m.getName() #7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行以后，可以看出是成功执行成功了，我们再看看目录结构：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;.
├── PA
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── PB1
│   │   ├── __init__.py
│   │   ├── __init__.pyc
│   │   ├── pb1_m.py
│   │   └── pb1_m.pyc
│   ├── PB2
│   │   ├── __init__.py
│   │   ├── __init__.pyc
│   │   ├── pb2_m.py
│   │   └── pb2_m.pyc
│   ├── wave.py
│   └── wave.pyc
└── test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224140068-2085643088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一下这个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当执行&lt;code&gt;#1&lt;/code&gt; 后， &lt;code&gt;sys.modules&lt;/code&gt; 会同时存在 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 两个模块，此时可以调用 &lt;code&gt;PA.wave&lt;/code&gt; 的任何类或函数了。但不能调用 &lt;code&gt;PA.PB1(2)&lt;/code&gt; 下的任何模块。当前 &lt;code&gt;Local&lt;/code&gt; 中有了 &lt;code&gt;PA&lt;/code&gt; 名字。&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;#2&lt;/code&gt; 后，只是将 &lt;code&gt;PA.PB1&lt;/code&gt; 载入内存， &lt;code&gt;sys.modules&lt;/code&gt; 中会有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 、 &lt;code&gt;PA.PB1&lt;/code&gt; 三个模块，但是 &lt;code&gt;PA.PB1&lt;/code&gt; 下的任何模块都没有自动载入内存，此时如果直接执行 &lt;code&gt;PA.PB1.pb1_m.getName()&lt;/code&gt; 则会出错，因为 &lt;code&gt;PA.PB1&lt;/code&gt; 中并没有 &lt;code&gt;pb1_m&lt;/code&gt; 。当前 &lt;code&gt;Local&lt;/code&gt; 中还是只有 &lt;code&gt;PA&lt;/code&gt; 名字，并没有 &lt;code&gt;PA.PB1&lt;/code&gt; 名字。&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;#3&lt;/code&gt; 后，会将 &lt;code&gt;PA.PB1&lt;/code&gt; 下的 &lt;code&gt;pb1_m&lt;/code&gt; 载入内存， &lt;code&gt;sys.modules&lt;/code&gt; 中会有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 、 &lt;code&gt;PA.PB1&lt;/code&gt; 、 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 四个模块，此时可以执行 &lt;code&gt;PA.PB1.pb1_m.getName()&lt;/code&gt; 了。由于使用了 &lt;code&gt;as&lt;/code&gt; ，当前 &lt;code&gt;Local&lt;/code&gt; 中除了 &lt;code&gt;PA&lt;/code&gt; 名字，另外添加了 &lt;code&gt;m1&lt;/code&gt; 作为 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 的别名。&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;#4&lt;/code&gt; 后，会将 &lt;code&gt;PA.PB2&lt;/code&gt; 、 &lt;code&gt;PA.PB2.pb2_m&lt;/code&gt; 载入内存， &lt;code&gt;sys.modules&lt;/code&gt; 中会有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 、 &lt;code&gt;PA.PB1&lt;/code&gt; 、 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 、 &lt;code&gt;PA.PB2&lt;/code&gt; 、 &lt;code&gt;PA.PB2.pb2_m&lt;/code&gt; 六个模块。当前 &lt;code&gt;Local&lt;/code&gt; 中还是只有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;m1&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;下面的 &lt;code&gt;#5&lt;/code&gt; ，&lt;code&gt;#6&lt;/code&gt; ， &lt;code&gt;#7&lt;/code&gt; 都是可以正确运行的。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：需要注意的问题是如果 &lt;code&gt;PA.PB2.pb2_m&lt;/code&gt; 想导入 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 是可以直接成功的。最好是采用明确的导入路径，对于 &lt;code&gt;../..&lt;/code&gt; 相对导入路径还是不推荐使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然我们已经知道 &lt;code&gt;pyc&lt;/code&gt; 文件的产生，再回到那道赛题，我们尝试将 &lt;code&gt;pyc&lt;/code&gt; 文件反编译回 &lt;code&gt;python&lt;/code&gt; 源码。我们使用在线的开源工具进行尝试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224139190-493105890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部分代码没有反编译成功？？？我们可以尝试分析一下，大概意思就是读取 &lt;code&gt;cipher.txt&lt;/code&gt; 那个文件，将那个文件内容是通过 &lt;code&gt;base64&lt;/code&gt; 编码的，我们的目的是将文件内容解码，然后又已知 &lt;code&gt;key&lt;/code&gt; ，通过 &lt;code&gt;encryt&lt;/code&gt; 函数进行加密的，我们可以尝试将代码补全：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def encryt(key, plain):
    cipher = ''
    for i in range(len(plain)):
        cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i]))

    return cipher


def getPlainText():
    plain = ''
    with open('cipher.txt') as (f):
        while True:
            line = f.readline()
            if line:
                plain += line
            else:
                break

    return plain.decode('base_64')


def main():
    key = 'LordCasser'
    plain = getPlainText()
    cipher = encryt(key, plain)
    with open('xxx.txt', 'w') as (f):
        f.write(cipher)


if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;YOU ARE FOOLED
THIS IS NOT THAT YOU WANT
GO ON DUDE
CATCH THAT STEGOSAURUS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示告诉我们用 &lt;code&gt;STEGOSAURUS&lt;/code&gt; 工具进行隐写的，我们直接将隐藏的payload分离出来即可。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 stegosaurus.py -x QAQ.pyc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224138449-497760819.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们得到了最终的 &lt;code&gt;flag&lt;/code&gt; 为：&lt;strong&gt;&lt;code&gt;flag{fin4lly_z3r0_d34d}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然都说到这个份子上了，我们就来分析一下我们是如何通过 &lt;code&gt;Stegosaurus&lt;/code&gt; 来嵌入 &lt;code&gt;Payload&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们仍然以上面这个代码为例子，我们设置脚本名称为 &lt;code&gt;encode.py&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;第一步，我们使用 &lt;code&gt;Stegosaurus&lt;/code&gt; 来查看在不改变源文件 &lt;code&gt;(Carrier)&lt;/code&gt; 大小的情况下，我们的 &lt;code&gt;Payload&lt;/code&gt; 能携带多少字节的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3 -m stegosaurus encode.py -r&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224137902-1756455640.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们可以安全地嵌入最多24个字节的 &lt;code&gt;Payload&lt;/code&gt; 了。如果不想覆盖源文件的话，我们可以使用 &lt;code&gt;-s&lt;/code&gt; 参数来单独生成一个嵌入了 &lt;code&gt;Payload&lt;/code&gt; 的 &lt;code&gt;py&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 -m stegosaurus encode.py -s --payload &quot;flag{fin4lly_z3r0_d34d}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224137398-503319738.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以用 &lt;code&gt;ls&lt;/code&gt; 命令查看磁盘目录，嵌入了 &lt;code&gt;Payload&lt;/code&gt; 的文件( &lt;code&gt;carrier&lt;/code&gt; 文件)和原始的字节码文件两者大小是完全相同的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224136786-114718507.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：如果没有使用 &lt;code&gt;-s&lt;/code&gt; 参数，那么原始的字节码文件将会被覆盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以通过向 &lt;code&gt;Stegosaurus&lt;/code&gt; 传递 &lt;code&gt;-x&lt;/code&gt; 参数来提取出 &lt;code&gt;Payload&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 -m stegosaurus __pycache__/encode.cpython-36-stegosaurus.pyc -x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224135808-1025476130.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们构造的 &lt;code&gt;Payload&lt;/code&gt; 不一定要是一个 &lt;code&gt;ASCII&lt;/code&gt; 字符串， &lt;code&gt;shellcode&lt;/code&gt; 也是可以的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224134986-1367540570.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们重新编写一个 &lt;code&gt;example.py&lt;/code&gt; 模块，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
import os
import math
def add(a,b):
    return int(a)+int(b)
def sum1(result):
    return int(result)*3

def sum2(result):
    return int(result)/3

def sum3(result):
    return int(result)-3

def main():
    a = 1
    b = 2
    result = add(a,b)
    print(sum1(result))
    print(sum2(result))
    print(sum3(result))

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们让它携带 &lt;code&gt;Payload&lt;/code&gt; 为 &lt;code&gt;flag_is_here&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224133950-311455782.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以查看嵌入 &lt;code&gt;Payload&lt;/code&gt; 之前和之后的 &lt;code&gt;Python&lt;/code&gt; 代码运行情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224133240-1779084107.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;strings&lt;/code&gt; 查看 &lt;code&gt;Stegosaurus&lt;/code&gt; 嵌入了 &lt;code&gt;Payload&lt;/code&gt; 之后的文件输出情况( &lt;code&gt;payload&lt;/code&gt; 并没有显示出来)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224131418-1962374587.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来使用 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;dis&lt;/code&gt; 模块来查看 &lt;code&gt;Stegosaurus&lt;/code&gt; 嵌入 &lt;code&gt;Payload&lt;/code&gt; 之前和之后的文件字节码变化情况：&lt;/p&gt;
&lt;p&gt;嵌入payload之前：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#( 11/29/18@ 5:14下午 )( python@Sakura ):~/桌面
   python3 -m dis example.py 
  1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (sys)
              6 STORE_NAME               0 (sys)

  2           8 LOAD_CONST               0 (0)
             10 LOAD_CONST               1 (None)
             12 IMPORT_NAME              1 (os)
             14 STORE_NAME               1 (os)

  3          16 LOAD_CONST               0 (0)
             18 LOAD_CONST               1 (None)
             20 IMPORT_NAME              2 (math)
             22 STORE_NAME               2 (math)

  4          24 LOAD_CONST               2 (&amp;lt;code object add at 0x7f90479778a0, file &quot;example.py&quot;, line 4&amp;gt;)
             26 LOAD_CONST               3 ('add')
             28 MAKE_FUNCTION            0
             30 STORE_NAME               3 (add)

  6          32 LOAD_CONST               4 (&amp;lt;code object sum1 at 0x7f9047977810, file &quot;example.py&quot;, line 6&amp;gt;)
             34 LOAD_CONST               5 ('sum1')
             36 MAKE_FUNCTION            0
             38 STORE_NAME               4 (sum1)

  9          40 LOAD_CONST               6 (&amp;lt;code object sum2 at 0x7f9047977ae0, file &quot;example.py&quot;, line 9&amp;gt;)
             42 LOAD_CONST               7 ('sum2')
             44 MAKE_FUNCTION            0
             46 STORE_NAME               5 (sum2)

 12          48 LOAD_CONST               8 (&amp;lt;code object sum3 at 0x7f9047977f60, file &quot;example.py&quot;, line 12&amp;gt;)
             50 LOAD_CONST               9 ('sum3')
             52 MAKE_FUNCTION            0
             54 STORE_NAME               6 (sum3)

 15          56 LOAD_CONST              10 (&amp;lt;code object main at 0x7f904798c300, file &quot;example.py&quot;, line 15&amp;gt;)
             58 LOAD_CONST              11 ('main')
             60 MAKE_FUNCTION            0
             62 STORE_NAME               7 (main)

 23          64 LOAD_NAME                8 (__name__)
             66 LOAD_CONST              12 ('__main__')
             68 COMPARE_OP               2 (==)
             70 POP_JUMP_IF_FALSE       78

 24          72 LOAD_NAME                7 (main)
             74 CALL_FUNCTION            0
             76 POP_TOP
        &amp;gt;&amp;gt;   78 LOAD_CONST               1 (None)
             80 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嵌入 &lt;code&gt;payload&lt;/code&gt; 之后：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#( 11/29/18@ 5:31下午 )( python@Sakura ):~/桌面
   python3 -m dis example.py                                 
  1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (sys)
              6 STORE_NAME               0 (sys)

  2           8 LOAD_CONST               0 (0)
             10 LOAD_CONST               1 (None)
             12 IMPORT_NAME              1 (os)
             14 STORE_NAME               1 (os)

  3          16 LOAD_CONST               0 (0)
             18 LOAD_CONST               1 (None)
             20 IMPORT_NAME              2 (math)
             22 STORE_NAME               2 (math)

  4          24 LOAD_CONST               2 (&amp;lt;code object add at 0x7f146e7038a0, file &quot;example.py&quot;, line 4&amp;gt;)
             26 LOAD_CONST               3 ('add')
             28 MAKE_FUNCTION            0
             30 STORE_NAME               3 (add)

  6          32 LOAD_CONST               4 (&amp;lt;code object sum1 at 0x7f146e703810, file &quot;example.py&quot;, line 6&amp;gt;)
             34 LOAD_CONST               5 ('sum1')
             36 MAKE_FUNCTION            0
             38 STORE_NAME               4 (sum1)

  9          40 LOAD_CONST               6 (&amp;lt;code object sum2 at 0x7f146e703ae0, file &quot;example.py&quot;, line 9&amp;gt;)
             42 LOAD_CONST               7 ('sum2')
             44 MAKE_FUNCTION            0
             46 STORE_NAME               5 (sum2)

 12          48 LOAD_CONST               8 (&amp;lt;code object sum3 at 0x7f146e703f60, file &quot;example.py&quot;, line 12&amp;gt;)
             50 LOAD_CONST               9 ('sum3')
             52 MAKE_FUNCTION            0
             54 STORE_NAME               6 (sum3)

 15          56 LOAD_CONST              10 (&amp;lt;code object main at 0x7f146e718300, file &quot;example.py&quot;, line 15&amp;gt;)
             58 LOAD_CONST              11 ('main')
             60 MAKE_FUNCTION            0
             62 STORE_NAME               7 (main)

 23          64 LOAD_NAME                8 (__name__)
             66 LOAD_CONST              12 ('__main__')
             68 COMPARE_OP               2 (==)
             70 POP_JUMP_IF_FALSE       78

 24          72 LOAD_NAME                7 (main)
             74 CALL_FUNCTION            0
             76 POP_TOP
        &amp;gt;&amp;gt;   78 LOAD_CONST               1 (None)
             80 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注： &lt;code&gt;Payload&lt;/code&gt; 的发送和接受方法完全取决于用户个人喜好， &lt;code&gt;Stegosaurus&lt;/code&gt; 只提供了一种向 &lt;code&gt;Python&lt;/code&gt; 字节码文件嵌入或提取 &lt;code&gt;Payload&lt;/code&gt; 的方法。但是为了保证嵌入之后的代码文件大小不会发生变化，因此 &lt;code&gt;Stegosaurus&lt;/code&gt; 所支持嵌入的 &lt;code&gt;Payload&lt;/code&gt; 字节长度十分有限。因此 ，如果你需要嵌入一个很大的 &lt;code&gt;Payload&lt;/code&gt; ，那么你可能要将其分散存储于多个字节码文件中了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了在不改变源文件大小的情况下向其嵌入 &lt;code&gt;Payload&lt;/code&gt; ，我们需要识别出字节码中的无效空间( &lt;code&gt;Dead Zone&lt;/code&gt; )。这里所谓的无效空间指的是那些即使被修改也不会改变原 &lt;code&gt;Python&lt;/code&gt; 脚本正常行为的那些字节数据。&lt;/p&gt;
&lt;p&gt;需要注意的是，我们可以轻而易举地找出 &lt;code&gt;Python3.6&lt;/code&gt; 代码中的无效空间。 &lt;code&gt;Python&lt;/code&gt; 的引用解释器 &lt;code&gt;CPython&lt;/code&gt; 有两种类型的操作码：即无参数的和有参数的。在版本号低于 &lt;code&gt;3.5&lt;/code&gt; 的 &lt;code&gt;Python&lt;/code&gt; 版本中，根据操作码是否带参，字节码中的操作指令将需要占用 &lt;code&gt;1&lt;/code&gt; 个字节或 &lt;code&gt;3&lt;/code&gt; 个字节。在 &lt;code&gt;Python3.6&lt;/code&gt; 中就不一样了， &lt;code&gt;Python3.6&lt;/code&gt; 中所有的指令都占用 &lt;code&gt;2&lt;/code&gt; 个字节，并会将无参数指令的第二个字节设置为 &lt;code&gt;0&lt;/code&gt; ，这个字节在其运行过程中将会被解释器忽略。这也就意味着，对于字节码中每一个不带参数的操作指令， &lt;code&gt;Stegosaurus&lt;/code&gt; 都可以安全地嵌入长度为 &lt;code&gt;1&lt;/code&gt; 个字节的 &lt;code&gt;Payload&lt;/code&gt; 代码。&lt;/p&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;Stegosaurus&lt;/code&gt; 的 &lt;code&gt;-vv&lt;/code&gt; 选项来查看 &lt;code&gt;Payload&lt;/code&gt; 是如何嵌入到这些无效空间之中的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#( 11/29/18@10:35下午 )( python@Sakura ):~/桌面
   python3 -m stegosaurus example.py -s -p &quot;ABCDE&quot; -vv          
2018-11-29 22:36:26,795 - stegosaurus - DEBUG - Validated args
2018-11-29 22:36:26,797 - stegosaurus - INFO - Compiled example.py as __pycache__/example.cpython-36.pyc for use as carrier
2018-11-29 22:36:26,797 - stegosaurus - DEBUG - Read header and bytecode from carrier
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_SUBTRACT (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_TRUE_DIVIDE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_MULTIPLY (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_ADD (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - INFO - Found 14 bytes available for payload
Payload embedded in carrier
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (65) ----A
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (66) ----B
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (67) ----C
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (68) ----D
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_SUBTRACT (69) ----E
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_TRUE_DIVIDE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_MULTIPLY (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_ADD (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - Creating new carrier file name for side-by-side install
2018-11-29 22:36:26,799 - stegosaurus - INFO - Wrote carrier file as __pycache__/example.cpython-36-stegosaurus.pyc&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;https://bitbucket.org/jherron/stegosaurus/src&lt;/li&gt;
&lt;li&gt;https://github.com/AngelKitty/stegosaurus&lt;/li&gt;
&lt;li&gt;https://www.freebuf.com/sectool/129357.html&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 29 Nov 2018 14:52:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>国内关于 的介绍少之又少，一般只是单纯的工具使用的讲解之类的，并且本人在学习过程中也是遇到了很多的问题，基于此种情况下写下此文，也是为我逝去的青春时光留个念想吧~ Stegosaurus是什么？ 在了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/10041534.html</dc:identifier>
</item>
<item>
<title>javascript基础修炼(10)——VirtualDOM和基本DFS - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10030036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10030036.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201811/24/d29248a27ce274c3e79a3719b06e9217.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;virtual-dom是什么&quot;&gt;1. Virtual-DOM是什么&lt;/h2&gt;
&lt;p&gt;Virtual-DOM，即虚拟DOM树。浏览器在解析文件时，会将&lt;code&gt;html&lt;/code&gt;文档转换为&lt;code&gt;document&lt;/code&gt;对象，在浏览器环境中运行的脚本文件都可以获取到它，通过操作&lt;code&gt;document&lt;/code&gt;对象暴露的接口可以直接操作页面上的DOM节点。但是DOM读写是非常耗性能的，很容易触发不必要的重绘和重排，为了更好地处理DOM操作，&lt;code&gt;Virtual-DOM&lt;/code&gt;技术就诞生了。&lt;code&gt;Virtual-DOM&lt;/code&gt;就是在javascript中模拟真实DOM的结构，通过数据追踪和状态对比来减少对于真实DOM的操作，以此来提高程序的效率的一种技术。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Virtual-DOM&lt;/code&gt;技术是前端高性能的基石，它是真实&lt;code&gt;document&lt;/code&gt;对象的抽象，通过对比新旧&lt;code&gt;Virtual-DOM&lt;/code&gt;的区别，找出发生变化的DOM节点，再利用算法得到相对更合理的DOM节点修改方案，最终再将方案应用在&lt;code&gt;document&lt;/code&gt;对象上来改变页面的展示内容。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主流前端SPA框架都离不开【&lt;code&gt;Virtual-DOM&lt;/code&gt;模型 + &lt;code&gt;DOM-Diff&lt;/code&gt;算法 + 生命周期钩子】这样的核心模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;virtual-dom的基本结构&quot;&gt;2. Virtual-DOM的基本结构&lt;/h2&gt;
&lt;p&gt;在上一篇博文&lt;a href=&quot;https://%C3%97%C3%97%C3%97w.cnblogs.com/dashnowords/p/9955460.html&quot;&gt;《javascript基础修炼(9)——MVVM中双向数据绑定的基本原理》&lt;/a&gt;中，我们通过&lt;code&gt;document.getElementById()&lt;/code&gt;从真实DOM中获得了带有自定义属性的待解析结构，这里是有一些问题的，实际的过程是先解析模板字符串得到虚拟DOM树，最后生成真实的DOM树。&lt;/p&gt;
&lt;p&gt;实际上我们在使用SPA框架时所编写的&lt;code&gt;html&lt;/code&gt;模板，并没有被直接当做DOM片段加载到页面上使用，而是将文件当做字符串读入到程序中，然后通过解析来生成&lt;code&gt;Virtual-DOM&lt;/code&gt;树，接着通过SPA框架的渲染函数来生成必要的片段后才生成真实的DOM节点。例如我们要生成下文示例的&lt;code&gt;HTML&lt;/code&gt;片段（为了方便演示，示例中只涉及了类名和文本节点）:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body class=&quot;main&quot;&amp;gt;
   &amp;lt;div class=&quot;sideBar&quot;&amp;gt;
       &amp;lt;ul class=&quot;sideBarContainer&quot;&amp;gt;
           &amp;lt;li class=&quot;sideBarItem&quot;&amp;gt;sidebar-1&amp;lt;/li&amp;gt;
           &amp;lt;li class=&quot;sideBarItem&quot;&amp;gt;sidebar-2&amp;lt;/li&amp;gt;
           &amp;lt;li class=&quot;sideBarItem&quot;&amp;gt;sidebar-3&amp;lt;/li&amp;gt;
       &amp;lt;/ul&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;mainContent&quot;&amp;gt;
        &amp;lt;div class=&quot;header&quot;&amp;gt;header-zone&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;coreContent&quot;&amp;gt;core-content&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;footer&quot;&amp;gt;footer-zone&amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;rightSide&quot;&amp;gt;暂未开发&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要构建出一个简易模型来表达上面的结构：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;virtualDom = {
    name:&quot;body&quot;,
    props:{
        className:&quot;main&quot;
    },
    children:[{
        name:&quot;div&quot;,
        props:{...},
        children:[...]
      },{
        name:&quot;div&quot;,
        props:{...},
        children:[...]
      },{
        name:&quot;div&quot;,
        props:{...},
        children:[...]
      }]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个生成虚拟节点的辅助函数:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//构建DOM节点的辅助函数
function h(name, props, children) {
    return {
        name:name,
        props:props,
        children:children
    }
}
//手动生成virtual-DOM
var tree = h('body',{className:'main'},[
       h('div',{className:'sideBar'},[
          h('ul',{className:'sideBarContainer'},[
               h('li',{className:'sideBarItem'},['sidebar-1']),
               h('li',{className:'sideBarItem'},['sidebar-2']),
               h('li',{className:'sideBarItem'},['sidebar-3']),
            ])
        ]),
       h('div',{className:'mainContent'},[
           h('div',{className:'header'},['header-zone']),
           h('div',{className:'coreContent'},['core-content']),
           h('div',{className:'footer'},['footer-zone']),
        ]),
       h('div',{className:'rightSide'},['暂未开发'])
    ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的方法得到的&lt;code&gt;tree&lt;/code&gt;对象就涵盖了模板片段中的结构和关键信息。实际开发中并不需要像上面一样手动来填写DOM结构，可以将模板字符串挂载到离线DOM节点上，然后在递归解析的同时来构建&lt;code&gt;Virtual-DOM&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;h2 id=&quot;使用dfs从virtual-dom生成dom&quot;&gt;3. 使用DFS从Virtual-DOM生成DOM&lt;/h2&gt;
&lt;p&gt;至此我们完成了模板的编译，也得到了&lt;code&gt;Virtual-DOM&lt;/code&gt;对象，但它似乎并没有什么用处，毕竟我们已经完成了对模板的解析，渲染出页面没什么问题，其实&lt;code&gt;Virtual-DOM&lt;/code&gt;对于首屏来说并没有什么特别重要的意义，它的价值在模型和视图发生变化时才会体现。上一篇博文的末尾我们已经提到了更新视图时的效率问题，当数据模型发生变化后，我们需要一个方法来收集所有需要修改的DOM，并为之提供高效的修改方式（你总不能一有变化就把整个网页重新渲染，或者让数据模型各自去修改各自绑定的DOM吧）。那么为了能够收集所有DOM节点的变化，我们就需要遍历所有节点。&lt;/p&gt;
&lt;p&gt;对数据结构和算法有一定了解的读者很容易想到，遍历解析一个&lt;code&gt;Virtual-DOM&lt;/code&gt;实际上就是对其进行先序深度优先遍历(Pre-Order Depth-First-Search)，本节中，我们先预热一下，使用这种方式来复现一下DOM结构。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function dfswalking(tree) {
    var _childrenLength;
    //执行动作
    if (typeof tree.children[0] === 'string') {
        console.log(`&amp;lt;${tree.name} class=&quot;${tree.props.className}&quot;&amp;gt;${tree.children[0]}&amp;lt;/${tree.name}&amp;gt;`);
    } else {
        console.log(`&amp;lt;${tree.name} class=&quot;${tree.props.className}&quot;&amp;gt;  --&amp;gt;`);
        for(var i = 0, _childrenLength = tree.children.length; i &amp;lt; _childrenLength; i++){
            dfswalking(tree.children[i]);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本例中仅打印出字符串的方式来展示，可以在控制台看到输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201811/24/17c96d1c30de7e2aef6d9f02ae69a827.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一篇博文中将分析如何通过&lt;code&gt;domDiff(oldTree, newTree)&lt;/code&gt;的方法通过同样的遍历方法来收集变化并批量更新视图。&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;4. 声明&lt;/h2&gt;
&lt;p&gt;本篇只是部分原理的学习笔记，并不代表框架真实源码的实现逻辑。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:26:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>1. Virtual DOM是什么 Virtual DOM，即虚拟DOM树。浏览器在解析文件时，会将 文档转换为 对象，在浏览器环境中运行的脚本文件都可以获取到它，通过操作 对象暴露的接口可以直接操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10030036.html</dc:identifier>
</item>
</channel>
</rss>