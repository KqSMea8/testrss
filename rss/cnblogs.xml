<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>公司内网离线环境搭建Android Studio - 魔法瞬间</title>
<link>http://www.cnblogs.com/yxliu/p/10004765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxliu/p/10004765.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;缘由何起 &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;↓&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么要在离线环境里搭建？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、搭建过程中所需SDK、Gradle等资源下载速度太慢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、公司内部环境不允许使用外网。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以下是我在公司内网环境搭建的辛酸历程，特此总结于此！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、离线搭建Android Studio开发环境：安装过程详细步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lilang_9920/article/details/81005345&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/lilang_9920/article/details/81005345&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、AndroidStudio中的内网开发离线配置：解决Gradle编译不通过问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yuhaihua529/article/details/77651301#commentBox&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/yuhaihua529/article/details/77651301#commentBox&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、解决包文件夹路径转换问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Could not download javassist.jar(org.javassist:javassist:3.23.1-GA):No cached version available.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wannaconquer/article/details/83041756&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/wannaconquer/article/details/83041756&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、解决虚拟机安装问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&amp;gt;&lt;span class=&quot;pln&quot;&gt;emulator&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; ERROR&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; x86 emulation currently requires hardware acceleration&lt;span class=&quot;pun&quot;&gt;!&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;span class=&quot;typ&quot;&gt;Please&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;ensure&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;typ&quot;&gt;Intel&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; HAXM&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;is&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; properly installed&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;and&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; usable&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;pun&quot;&gt;&amp;gt;&lt;span class=&quot;pln&quot;&gt;CPU acceleration status&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; HAX kernel&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;module&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;is&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span class=&quot;kwd&quot;&gt;not&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; installed&lt;span class=&quot;pun&quot;&gt;!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/springxie/p/4742100.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/springxie/p/4742100.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;对此特别感谢以上四位博主分享的经验，以此来借花献佛，希望能帮助到需要的人以节省大量的时间做更有意义事！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如有得罪请多多包涵！&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 15:37:00 +0000</pubDate>
<dc:creator>魔法瞬间</dc:creator>
<og:description>缘由何起 ↓ 为什么要在离线环境里搭建？ 1、搭建过程中所需SDK、Gradle等资源下载速度太慢。 2、公司内部环境不允许使用外网。 以下是我在公司内网环境搭建的辛酸历程，特此总结于此！ 一、离线搭</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxliu/p/10004765.html</dc:identifier>
</item>
<item>
<title>js动态改变css伪类样式 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/10004654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/10004654.html</guid>
<description>&lt;p&gt;首先我们来看下页面上需要实现的基本效果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230249676-204350526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们可以使用如下js代码来试试看，是否能使用js改变伪类？如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  $(&lt;/span&gt;'.listnav li').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).index();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset = 11; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左侧偏移 11像素&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgWidth = 240; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片的宽度是240&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; pos = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此第一个tab项的居中位置就是 240/2 + 11&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (index === 0&lt;span&gt;) {
      pos &lt;/span&gt;= imgWidth / 2 + offset + 'px'&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        如果不是第一个tab项的话，那么计算方式就变为如下:
        pos = imgWidth / 2 + offset + imgWidth * index + 33 * index
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      pos &lt;/span&gt;= imgWidth / 2 + offset + imgWidth * index + 33 *&lt;span&gt; index;
    }
    console.log(pos);
    $(&lt;/span&gt;&quot;.tab-content:before, .tab-content:after&quot;).css({ &quot;left&quot;&lt;span&gt;: pos });
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码并不生效，因此可以断定使用 jquery这样单纯的改变伪类样式是行不通的。 如上有一个定位的计算方式，如上代码，下面我们来简单的分析下，为什么可以这样计算，请看如下图所示：&lt;/p&gt;
&lt;p&gt;第一个tab项的时候，小三角形的定位如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230357234-3631760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击第二个tab项的时候，小三角形的定位如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230422325-296828208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击第三个tab项的时候，小三角形的定位变为如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230440110-405530979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然使用如上方式行不通，我们肯定需要查找资料了，正好看到有一篇文章 能解决改变css伪类样式, &lt;a href=&quot;https://stackoverflow.com/questions/4481485/changing-css-pseudo-element-styles-via-javascript&quot; target=&quot;_blank&quot;&gt;请点击查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因此我这边来详细总结一下，如何做？那么这边肯定需要分二种情况，第一种是使用css内联style样式写的css，第二种是外链的css，也就是html和css分离的那种，因为做项目的时候，分离css还是很有必要的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;一：JS动态改变style内联css写的伪类样式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  $(&lt;/span&gt;'.listnav li').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).index();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset = 11; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左侧偏移 11像素&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgWidth = 240; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片的宽度是240&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; pos = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此第一个tab项的居中位置就是 240/2 + 11&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (index === 0&lt;span&gt;) {
      pos &lt;/span&gt;= imgWidth / 2 + offset + 'px'&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        如果不是第一个tab项的话，那么计算方式就变为如下:
        pos = imgWidth / 2 + offset + imgWidth * index + 33 * index
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      pos &lt;/span&gt;= imgWidth / 2 + offset + imgWidth * index + 33 *&lt;span&gt; index;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; styleSheetObject = document.getElementById('colorFlipFlop'&lt;span&gt;);
    console.log(pos);
    changeStyle(styleSheetObject, &lt;/span&gt;'left'&lt;span&gt;, pos);
  });
});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * @param styleSheetObject style标签的id
 * @param attr 需要改变的style属性
 * @param pos 需要改变的值
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; changeStyle(styleSheetObject, attr, pos) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; beforeIndex = 7;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定位到style标签中的第几行&lt;/span&gt;
&lt;span&gt;  console.log(styleSheetObject.sheet);
  console.log(styleSheetObject.sheet.cssRules[beforeIndex]);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(styleSheetObject.sheet.cssRules[beforeIndex].style[attr])&lt;/span&gt;
  styleSheetObject.sheet.cssRules[beforeIndex].style[attr] = pos + 'px'&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们首先来分析下，上面的代码的含义； 在分析之前我们首先看下css的样式代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style type=&quot;text/css&quot; id=&quot;colorFlipFlop&quot;&amp;gt;
  * &lt;/span&gt;{&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt; padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;}&lt;span&gt;
  .operating-report-container &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 1000px&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 1px solid #ccc&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .listnav &lt;/span&gt;{&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; 14px&lt;/span&gt;;&lt;span&gt;
    margin-top&lt;/span&gt;:&lt;span&gt; 24px&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .listnav li &lt;/span&gt;{&lt;span&gt;
    float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 240px&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; 33px&lt;/span&gt;;&lt;span&gt;
    cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;&lt;span&gt;
    overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .listnav li .pic &lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 240px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 160px&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; #f6f6f6&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .listnav li .desc &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 15px&lt;/span&gt;;&lt;span&gt;
    color&lt;/span&gt;:&lt;span&gt; #616161&lt;/span&gt;;&lt;span&gt;
    margin-top&lt;/span&gt;:&lt;span&gt; 8px&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .tab-content &lt;/span&gt;{&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 24px 30px&lt;/span&gt;;&lt;span&gt;
    border-top&lt;/span&gt;:&lt;span&gt; 1px solid #e6e5e5&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .tab-content:before, 
  .operating-report-container .tab-content:after &lt;/span&gt;{&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 131px&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; solid transparent&lt;/span&gt;;&lt;span&gt;
    content&lt;/span&gt;:&lt;span&gt; &quot; &quot;&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    pointer-events&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .tab-content:before &lt;/span&gt;{&lt;span&gt;
    border-bottom-color&lt;/span&gt;:&lt;span&gt; #e6e5e5&lt;/span&gt;;&lt;span&gt;
    border-width&lt;/span&gt;:&lt;span&gt; 11px&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; -11px&lt;/span&gt;;
  }&lt;span&gt;
  .operating-report-container .tab-content:after &lt;/span&gt;{&lt;span&gt;
    border-bottom-color&lt;/span&gt;:&lt;span&gt; #fff&lt;/span&gt;;&lt;span&gt; 
    border-width&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; -10px&lt;/span&gt;;
  }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先js代码 var styleSheetObject = document.getElementById('colorFlipFlop'); 这句代码是获取 style标签的，因为style标签上有一个id元素叫 'colorFlipFlop'。&lt;/p&gt;
&lt;p&gt;然后我们看下打印下 console.log(styleSheetObject.sheet);这个；看看他有哪些属性，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230802646-1341754105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打印 console.log(styleSheetObject.sheet.cssRules[beforeIndex]);，代码中 beforeIndex 为什么等于7呢？因此 tab-content:before 的样式在 style标签的第八行，因此为了找到 style标签的中的具体元素的位置。因为是从0开始的。如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230833453-1047759487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此最后一句代码，找到对应的元素对应的属性重新赋值，如代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
styleSheetObject.sheet.cssRules[beforeIndex].style[attr] = pos + 'px';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122230906655-2080441685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tugenhua0707.github.io/html-css-demo/css%E4%BC%AA%E7%B1%BB/index.html&quot; target=&quot;_blank&quot;&gt;查看效果请点击我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：JS动态改变使用link标签引入的伪类样式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1）理解 insertRule 方法的使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先我们先要来理解下 insertRule() 和 addRule() 这两个方法，可能很多人之前对这js中这两个方法并不熟悉，其实在研究之前，我也并不知道这两个方法的，这两个方法的作用是：向现有的样式表中添加新规则，在firefox，safari,opera和chrome中使用 insertRule()方法，该方法接收两个参数，规则文本 和 表示在哪里插入规则的索引。比如下面简单的demo：&lt;br/&gt;&lt;strong&gt;insertRule.html 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./css/insertRule.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;./js/jquery.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      欢迎光临
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;./js/insertRule.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;/css/insertRule.css 中的代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;* &lt;/span&gt;{&lt;span&gt;margin&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt; padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;js/insertRule.js 代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getStyleSheet(element) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; element.sheet ||&lt;span&gt; element.styleSheet;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; link = document.getElementsByTagName(&quot;link&quot;)[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sheet =&lt;span&gt; getStyleSheet(link);
console.log(sheet)
sheet.insertRule(&lt;/span&gt;&quot;body { background-color: red }&quot;, 0);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DOM方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上js代码，先获取到页面上第一个link标签，然后对代码进行插入body的背景色的样式即可：在firefox下的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231356486-1833365051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看看firefox下的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231412656-1839497153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在safari下查看下效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231426542-1953699406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上js代码，console.log(sheet) 打印的信息在firefox如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231440130-1297590105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前我们说过 insertRule 该方法在 firefox，safari，opera 和 chrome是支持的，但是在mac电脑下(我电脑目前是mac电脑)，Chrome 66 以后的版本是不支持该属性的。如下是在我chrome中的情况，如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231507797-844009705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者也可以请看这篇文章说的(&lt;a href=&quot;https://www.noxxxx.com/uncaught-domexception-failed-to-execute-insertrule-on-cssstylesheet.html&quot; target=&quot;_blank&quot;&gt;https://www.noxxxx.com/uncaught-domexception-failed-to-execute-insertrule-on-cssstylesheet.html&lt;/a&gt;), 我现在chrome版本是70版本的，那也是不支持，如下我的chrome版本：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231614633-1396109498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章中说需要手动创建 style 标签插入。 因此我们的 insertRule.js 代码变为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
function getStyleSheet(element) {
    return element.sheet || element.styleSheet;
}
var link = document.getElementsByTagName(&quot;link&quot;)[0];
var sheet = getStyleSheet(link);
console.log(sheet);
sheet.insertRule(&quot;body { background-color: red }&quot;, 0);  //DOM方法
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; stylesheet =&lt;span&gt; createStyleSheet();
stylesheet.insertRule(&lt;/span&gt;&quot;body { background-color: red }&quot;, 0);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DOM方法&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createStyleSheet() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; style = document.createElement('style'&lt;span&gt;);
  style.appendChild(document.createTextNode(&lt;/span&gt;&quot;&quot;&lt;span&gt;));
  document.head.appendChild(style);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; style.sheet;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们继续运行下，现在在firefox，safari，和 chrome浏览器下都支持了。chrome浏览器下的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181122231650154-1900852051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2）理解 addRule() 方法的使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;addRule方法是IE支持的一个类似的方法，该方法也是接收两个必选参数和一个可选参数：&lt;br/&gt;第一个参数为：选择符文本。第二个参数为：css样式信息，第三个参数是可选的，表示的含义是：插入规则的位置，和insertRule()方法中的第二个参数类似。&lt;/p&gt;
&lt;p&gt;基本使用方式如下：&lt;strong&gt;sheet.addRule(&quot;body&quot;, &quot;background-color: red&quot;, 0);&lt;/strong&gt; // 仅仅对IE有效&lt;/p&gt;
&lt;p&gt;因此为了跨浏览器支持向样式表中插入规则，我们可以封装一个方法，既支持IE，也支持标准浏览器，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
function getStyleSheet(element) {
    return element.sheet || element.styleSheet;
}
var link = document.getElementsByTagName(&quot;link&quot;)[0];
var sheet = getStyleSheet(link);
console.log(sheet);
sheet.insertRule(&quot;body { background-color: red }&quot;, 0);  //DOM方法
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
var stylesheet = createStyleSheet();
stylesheet.insertRule(&quot;body { background-color: red }&quot;, 0);  //DOM方法

function createStyleSheet() {
  var style = document.createElement('style');
  style.appendChild(document.createTextNode(&quot;&quot;));
  document.head.appendChild(style);
  return style.sheet;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createStyleSheet() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; style = document.createElement('style'&lt;span&gt;);
  style.appendChild(document.createTextNode(&lt;/span&gt;&quot;&quot;&lt;span&gt;));
  document.head.appendChild(style);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; style.sheet;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; insertRule(selectorText, cssText, position) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stylesheet =&lt;span&gt; createStyleSheet();
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stylesheet.insertRule) {
    stylesheet.insertRule(selectorText &lt;/span&gt;+ &quot;{&quot; + cssText + &quot;}&quot;&lt;span&gt;, position);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stylesheet.addRule) {
    stylesheet.addRule(selectorText, cssText, position);
  }
}
insertRule(&lt;/span&gt;&quot;body&quot;, &quot;background-color: red&quot;, 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://tugenhua0707.github.io/html-css-demo/css%E4%BC%AA%E7%B1%BB/insertRule.html&quot; target=&quot;_blank&quot;&gt;请点击查看效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我们现在可以使用如上的知识点，去做那个切换的demo了，index2.html代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Insert title here&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./css/index2.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;./js/jquery.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;operating-report-container&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;operating-report&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;listnav&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;desc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;铜板街2018年度各月运营报告&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;desc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;铜板街2018年度各月运营报告&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;pic&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;desc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;铜板街2018年度各月运营报告&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tab-content&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;tab-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;./js/index2.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index2.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  $(&lt;/span&gt;'.listnav li').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = $(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).index();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset = 11; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左侧偏移 11像素&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgWidth = 240; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 图片的宽度是240&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; pos = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因此第一个tab项的居中位置就是 240/2 + 11&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (index === 0&lt;span&gt;) {
      pos &lt;/span&gt;= imgWidth / 2 +&lt;span&gt; offset;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        如果不是第一个tab项的话，那么计算方式就变为如下:
        pos = imgWidth / 2 + offset + imgWidth * index + 33 * index
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      pos &lt;/span&gt;= imgWidth / 2 + offset + imgWidth * index + 33 *&lt;span&gt; index;
    }
    addRule(&lt;/span&gt;&quot;.operating-report-container .tab-content:before&quot;&lt;span&gt;, {
      left: pos &lt;/span&gt;+ 'px'&lt;span&gt;
    });
    addRule(&lt;/span&gt;&quot;.operating-report-container .tab-content:after&quot;&lt;span&gt;, {
      left: pos &lt;/span&gt;+ 'px'&lt;span&gt;
    });
  });
});
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createStyleSheet() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; style = document.createElement('style'&lt;span&gt;);
  style.appendChild(document.createTextNode(&lt;/span&gt;&quot;&quot;&lt;span&gt;));
  document.head.appendChild(style);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; style.sheet;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stylesheet =&lt;span&gt; createStyleSheet();
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addRule(selector, css) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; propText = &lt;span&gt;typeof&lt;/span&gt; css === &quot;string&quot; ? css : Object.keys(css).map(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (p) {
      console.log(p)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; p + &quot;:&quot; + (p === &quot;content&quot; ? &quot;'&quot; + css[p] + &quot;'&quot;&lt;span&gt; : css[p]);
  }).join(&lt;/span&gt;&quot;;&quot;&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stylesheet.insertRule) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标准浏览器支持的&lt;/span&gt;
    stylesheet.insertRule(selector + &quot;{&quot; + propText + &quot;}&quot;&lt;span&gt;, stylesheet.cssRules.length);

  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(stylesheet.addRule) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IE支持的&lt;/span&gt;
&lt;span&gt;    stylesheet.addRule(selector, propText, stylesheet.cssRules.length);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码封装好了的，&lt;a href=&quot;https://tugenhua0707.github.io/html-css-demo/css%E4%BC%AA%E7%B1%BB/index2.html&quot; target=&quot;_blank&quot;&gt;点击查看效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：如上demo目前在mac电脑上的firfox，safari，chrome测试过的，因为是mac电脑，所以在IE下还没有测试过，如果有问题可以留言哦！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/html-css-demo/tree/master/css%E4%BC%AA%E7%B1%BB&quot; target=&quot;_blank&quot;&gt;查看github代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 15:22:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>js动态改变css伪类样式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/10004654.html</dc:identifier>
</item>
<item>
<title>快速上手多机多卡的分布式tensorflow - ywwhxxtw</title>
<link>http://www.cnblogs.com/yunke-ws/p/9998674.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunke-ws/p/9998674.html</guid>
<description>&lt;p&gt;终于又有时间和成果拿出来和大家分享，实在不容易，之前由于临时更换任务加上入职事情多断更了很久，现在主要在做一些KG和KGQA方面的工作。今天要和大家分享的是最近在工作中实现的分布式tensorflow。(BTW打个广告~NLP和DL讨论欢迎加群~二维码在末尾~）&lt;/p&gt;
&lt;p&gt;理论在这里就不详细介绍了，说说对一些概念自己的理解吧：&lt;/p&gt;
&lt;p&gt;（1）task-&amp;gt;server-&amp;gt;cluster：&lt;/p&gt;
&lt;p&gt;这里其实应该也是分布式计算的一些基本概念，在分布式tensorflow中，采用的主从模式，即master-slave模式。有一个总控服务器来负责传递数据和调度，若干从节点服务器负责计算。在这里，我们所说的每一个服务器也就对应一个server。在tensorflow中，总控服务器其实叫做参数服务器（Parameter Server），在实际操作中负责参数的更新，但是并不负责图的计算。那么负责计算的是什么呢？在这里就是工作节点（工作服务器）。在每个工作服务器上，tensorflow都会保存整张计算图并且独立的进行计算。不过值得注意的是，尽管叫server级别，但是不一定一个节点就只能是一个服务器，他仅仅对应服务器上的一个端口，使用某个服务器的一部分资源（或者所有资源），同时若干个工作节点也可以放在一个资源足够的服务器上，在后面的代码中你会看到我就是这么做的。注意到之前说的参数服务器和工作服务器都是server级别的，在这个级别下，每个服务器可以有若干个task，每个task对应一个具体的计算操作。在这个级别之上，若干个工作节点可以构成一个计算集群，而若干个参数服务器可以构成一个参数服务器集群。&lt;/p&gt;
&lt;p&gt;（2）gRPC：&lt;/p&gt;
&lt;p&gt;这里主要放一些干货，介绍一些谷歌自己开发的通信协议gRPC，这也是分布式tensorflow用来做多机进程间通信的协议。额外想提以下的其实是一些tradeoff，由于现在只是跑通了demo而没有在大的模型上做实验，有一个需要验证的问题就是：在没有足够多台服务器的情况下，到底是使用两台服务器，将参数更新和图计算分开，降低整个服务器的压力，还是应该单机多卡，减少任务之间的通信开销，这个问题需要在后面的工作中验证，也希望有经验的同学给出意见。&lt;/p&gt;
&lt;p&gt;gRPC是一个高性能、开源和通用的RPC框架，面向移动和HTTP/2设计。目前提供C、Java和Go语言版本，分别是grpc、grpc-java、grpc-go。gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。gRPC由google开发，是一款语言中立、平台中立、开源的远程过程调用系统。在gRPC里客户端应用可以像调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得你能够更容易地创建分布式应用和服务。与许多RPC系统类似，gRPC也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包括参数和返回类型）。在服务端实现这个接口，并运行一个gRPC服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。&lt;/p&gt;
&lt;p&gt;（3）同步更新和异步更新&lt;/p&gt;
&lt;p&gt;在下面的demo里面其实没有明确的实现同步或异步更新，因为这个例子实在太小，即使实现了也没有太大区别。在异步更新中，没有任何设备等待来自任何其他设备的模型更新。这些设备可以独立运行并与对等设备共享结果，或者通过一个或多个参数服务器进行通信。在同步更新中，每个工作节点需要等待其他工作节点的结果然后一起发送到参数服务器进行更新。在这里的tradeoff就是同步更新可能会拖慢整个训练的速度因为要等待最慢的一个节点，异步更新很快，但是很有可能刚刚学到的正确梯度又被接着来的错误梯度抵消。下面的图简要描述了这两种更新模式的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497229/201811/1497229-20181122224817490-618718230.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，理论说完了，现在要展现我和其他博主不一样的地方了：直接上能跑的代码！对于代码的解释直接见注释部分。注意：运行代码需要在每一个节点分别运行一次，并不是一劳永逸的哦（虽然我最开始也是这么觉得的）运行的命令如下：（demo修改自https://github.com/TracyMcgrady6/Distribute_MNIST，特别感谢&lt;span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
python distributed.py --job_name=ps --task_index=&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在参数服务器上运行，启动参数服务器&lt;/span&gt;
python distributed.py --job_name=worker --task_index=&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在工作节点上运行，启动工作节点0&lt;/span&gt;
python distributed.py --job_name=worker --task_index=1
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在工作节点上运行，启动工作节点1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上代码~这个代码其实是用来训练minist的，我用的是两个RTX2080（有木有很羡慕~），速度有多快呢？大概不到30秒就训练完了10000步，差点没来得及给同事看~如果有同学跑下面的代码遇到问题可以找我要源码~邮箱见上一条~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;104&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; encoding:utf-import math&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
os.environ[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CUDA_DEVICE_ORDER&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PCI_BUS_ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tempfile
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.examples.tutorials.mnist &lt;span&gt;import&lt;/span&gt;&lt;span&gt; input_data
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

flags &lt;/span&gt;=&lt;span&gt; tf.app.flags
IMAGE_PIXELS &lt;/span&gt;= 28
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义默认训练参数和数据路径&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;tf.flags其实就是定义一些命令行参数&lt;/span&gt;
&lt;span&gt;
flags.DEFINE_string(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data_dir&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/mnist-data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Directory  for storing mnist data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
flags.DEFINE_integer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hidden_units&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number of units in the hidden layer of the NN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
flags.DEFINE_integer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;train_steps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 10000, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number of training steps to perform&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
flags.DEFINE_integer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;batch_size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 100, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Training batch size &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
flags.DEFINE_float(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;learning_rate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0.01, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Learning rate&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义分布式参数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 参数服务器parameter server节点&lt;/span&gt;
flags.DEFINE_string(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps_hosts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.6.156:22223&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Comma-separated list of hostname:port pairs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 两个worker节点&lt;/span&gt;
flags.DEFINE_string(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;worker_hosts&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.6.164:22221,192.168.6.164:22220&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Comma-separated list of hostname:port pairs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置job name参数&lt;/span&gt;
flags.DEFINE_string(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;job name: worker or ps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置任务的索引&lt;/span&gt;
flags.DEFINE_integer(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_index&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, None, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Index of task within the job&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择异步并行，同步并行，在本程序中其实没有用到&lt;/span&gt;
flags.DEFINE_integer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;issync&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是否采用分布式的同步模式，1表示同步模式，0表示异步模式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

FLAGS &lt;/span&gt;=&lt;span&gt; flags.FLAGS


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(unused_argv):
    mnist &lt;/span&gt;= input_data.read_data_sets(FLAGS.data_dir, one_hot=&lt;span&gt;True)

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; FLAGS.job_name &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; FLAGS.job_name == &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Must specify an explicit job_name !&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;job_name : %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; FLAGS.job_name)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; FLAGS.task_index &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; FLAGS.task_index == &lt;span&gt;''&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Must specify an explicit task_index!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task_index : %d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; FLAGS.task_index)

    ps_spec &lt;/span&gt;= FLAGS.ps_hosts.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    worker_spec &lt;/span&gt;= FLAGS.worker_hosts.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建集群&lt;/span&gt;
    num_worker =&lt;span&gt; len(worker_spec)
    cluster &lt;/span&gt;= tf.train.ClusterSpec({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: ps_spec, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;worker&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: worker_spec})
    server &lt;/span&gt;= tf.train.Server(cluster, job_name=FLAGS.job_name, task_index=&lt;span&gt;FLAGS.task_index)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; FLAGS.job_name == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ps&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        server.join()

    is_chief &lt;/span&gt;= (FLAGS.task_index ==&lt;span&gt; 0)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; worker_device = '/job:worker/task%d/cpu:0' % FLAGS.task_index&lt;/span&gt;
　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt;难点其实在这里，通过worker_device指定在同一台服务器上的不同显卡作为工作节点&lt;/span&gt;
&lt;span&gt;    with tf.device(tf.train.replica_device_setter(
            worker_device &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/job:worker/task:%d/gpu:%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(FLAGS.task_index, FLAGS.task_index),

                ps_device &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/job:ps/cpu:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            cluster&lt;/span&gt;=&lt;span&gt;cluster
    )):
        global_step &lt;/span&gt;= tf.Variable(0, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;global_step&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, trainable=False)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建纪录全局训练步数变量&lt;/span&gt;
&lt;span&gt;
        hid_w &lt;/span&gt;= tf.Variable(tf.truncated_normal([IMAGE_PIXELS *&lt;span&gt; IMAGE_PIXELS, FLAGS.hidden_units],
                                                stddev&lt;/span&gt;=1.0 / IMAGE_PIXELS), name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hid_w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        hid_b &lt;/span&gt;= tf.Variable(tf.zeros([FLAGS.hidden_units]), name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hid_b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        sm_w &lt;/span&gt;= tf.Variable(tf.truncated_normal([FLAGS.hidden_units, 10&lt;span&gt;],
                                               stddev&lt;/span&gt;=1.0 / math.sqrt(FLAGS.hidden_units)), name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sm_w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        sm_b &lt;/span&gt;= tf.Variable(tf.zeros([10]), name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sm_b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        x &lt;/span&gt;= tf.placeholder(tf.float32, [None, IMAGE_PIXELS *&lt;span&gt; IMAGE_PIXELS])
        y_ &lt;/span&gt;= tf.placeholder(tf.float32, [None, 10&lt;span&gt;])

        hid_lin &lt;/span&gt;=&lt;span&gt; tf.nn.xw_plus_b(x, hid_w, hid_b)
        hid &lt;/span&gt;=&lt;span&gt; tf.nn.relu(hid_lin)

        y &lt;/span&gt;=&lt;span&gt; tf.nn.softmax(tf.nn.xw_plus_b(hid, sm_w, sm_b))
        cross_entropy &lt;/span&gt;= -tf.reduce_sum(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0&lt;span&gt;)))

        opt &lt;/span&gt;=&lt;span&gt; tf.train.AdamOptimizer(FLAGS.learning_rate)

        train_step &lt;/span&gt;= opt.minimize(cross_entropy, global_step=&lt;span&gt;global_step)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成本地的参数初始化操作init_op&lt;/span&gt;
        init_op =&lt;span&gt; tf.global_variables_initializer()
        train_dir &lt;/span&gt;=&lt;span&gt; tempfile.mkdtemp()
        sv &lt;/span&gt;= tf.train.Supervisor(is_chief=is_chief, logdir=train_dir, init_op=init_op, recovery_wait_secs=1&lt;span&gt;,
                                 global_step&lt;/span&gt;=&lt;span&gt;global_step)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; is_chief:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Worker %d: Initailizing session...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; FLAGS.task_index)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Worker %d: Waiting for session to be initaialized...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; FLAGS.task_index)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;sess = sv.prepare_or_wait_for_session(server.target)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二个坑在这里，必须要设置allow_soft_placement为True让tensorflow可以自动找到最适合的设备，否则会说不存在gpu的kernel,同时建议运行时只安装tensorflow_gpu&lt;/span&gt;
&lt;span&gt;
        config &lt;/span&gt;= tf.ConfigProto(allow_soft_placement =&lt;span&gt; True)
        sess &lt;/span&gt;= sv.prepare_or_wait_for_session(server.target, config=&lt;span&gt;config)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Worker %d: Session initialization  complete.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; FLAGS.task_index)

        time_begin &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Traing begins @ %f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; time_begin)

        local_step &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            batch_xs, batch_ys &lt;/span&gt;=&lt;span&gt; mnist.train.next_batch(FLAGS.batch_size)
            train_feed &lt;/span&gt;=&lt;span&gt; {x: batch_xs, y_: batch_ys}

            _, step &lt;/span&gt;= sess.run([train_step, global_step], feed_dict=&lt;span&gt;train_feed)
            local_step &lt;/span&gt;+= 1&lt;span&gt;

            now &lt;/span&gt;=&lt;span&gt; time.time()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%f: Worker %d: traing step %d dome (global step:%d)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (now, FLAGS.task_index, local_step, step))

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; step &amp;gt;=&lt;span&gt; FLAGS.train_steps:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

        time_end &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Training ends @ %f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; time_end)
        train_time &lt;/span&gt;= time_end -&lt;span&gt; time_begin
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Training elapsed time:%f s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; train_time)

        val_feed &lt;/span&gt;=&lt;span&gt; {x: mnist.validation.images, y_: mnist.validation.labels}
        val_xent &lt;/span&gt;= sess.run(cross_entropy, feed_dict=&lt;span&gt;val_feed)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After %d training step(s), validation cross entropy = %g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (FLAGS.train_steps, val_xent))
    sess.close()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    tf.app.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你喜欢博主的分享或者觉得这个分享对你有用，可以支持博主一下，以便他写出更好的文章~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497229/201811/1497229-20181122230341850-1874754409.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NLP讨论群二维码~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497229/201811/1497229-20181122231215303-1955365553.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>ywwhxxtw</dc:creator>
<og:description>木有摘要，内容如题，赶紧戳进去看吧哥！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunke-ws/p/9998674.html</dc:identifier>
</item>
<item>
<title>Go基础系列：Go实现工作池的两种方式 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10004620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10004620.html</guid>
<description>&lt;h2 id=&quot;worker-pool简介&quot;&gt;worker pool简介&lt;/h2&gt;
&lt;p&gt;worker pool其实就是线程池thread pool。对于go来说，直接使用的是goroutine而非线程，不过这里仍然以线程来解释线程池。&lt;/p&gt;
&lt;p&gt;在线程池模型中，&lt;strong&gt;有2个队列一个池子：任务队列、已完成任务队列和线程池&lt;/strong&gt;。其中已完成任务队列可能存在也可能不存在，依据实际需求而定。&lt;/p&gt;
&lt;p&gt;只要有任务进来，就会放进任务队列中。只要线程执行完了一个任务，就将任务放进已完成任务队列，有时候还会将任务的处理结果也放进已完成队列中。&lt;/p&gt;
&lt;p&gt;worker pool中包含了一堆的线程(worker，对go而言每个worker就是一个goroutine)，这些线程嗷嗷待哺，等待着为它们分配任务，或者自己去任务队列中取任务。取得任务后更新任务队列，然后执行任务，并将执行完成的任务放进已完成队列。&lt;/p&gt;
&lt;p&gt;下图来自wiki：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181122210742741-546550981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Go中有两种方式可以实现工作池：传统的互斥锁、channel。&lt;/p&gt;
&lt;h2 id=&quot;传统互斥锁机制的工作池&quot;&gt;传统互斥锁机制的工作池&lt;/h2&gt;
&lt;p&gt;假设Go中的任务的定义形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Task struct {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次有任务进来时，都将任务放在任务队列中。&lt;/p&gt;
&lt;p&gt;使用传统的互斥锁方式实现，任务队列的定义结构大概如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Queue struct{
    M     sync.Mutex
    Tasks []Task
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在执行任务的函数中加上Lock()和Unlock()。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Worker(queue *Queue) {
    for {
        // Lock()和Unlock()之间的是critical section
        queue.M.Lock()
        // 取出任务
        task := queue.Tasks[0]
        // 更新任务队列
        queue.Tasks = queue.Tasks[1:]
        queue.M.Unlock()
        // 在此goroutine中执行任务
        process(task)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如在线程池中激活了100个goroutine来执行Worker()。Lock()和Unlock()保证了在同一时间点只能有一个goroutine取得任务并随之更新任务列表，取任务和更新任务队列都是critical section中的代码，它们是具有原子性。然后这个goroutine可以执行自己取得的任务。于此同时，其它goroutine可以争夺互斥锁，只要争抢到互斥锁，就可以取得任务并更新任务列表。当某个goroutine执行完process(task)，它将因为for循环再次参与互斥锁的争抢。&lt;/p&gt;
&lt;p&gt;上面只是给出了一点主要的代码段，要实现完整的线程池，还有很多额外的代码。&lt;/p&gt;
&lt;p&gt;通过互斥锁，上面的一切操作都是线程安全的。但问题在于加锁/解锁的机制比较重量级，当worker(即goroutine)的数量足够多，锁机制的实现将出现瓶颈。&lt;/p&gt;
&lt;h2 id=&quot;通过buffered-channel实现工作池&quot;&gt;通过buffered channel实现工作池&lt;/h2&gt;
&lt;p&gt;在Go中，也能用&lt;strong&gt;buffered channel&lt;/strong&gt;实现工作池。&lt;/p&gt;
&lt;p&gt;示例代码很长，所以这里先拆分解释每一部分，最后给出完整的代码段。&lt;/p&gt;
&lt;p&gt;在下面的示例中，每个worker的工作都是计算每个数值的位数相加之和。例如给定一个数值234，worker则计算&lt;code&gt;2+3+4=9&lt;/code&gt;。这里交给worker的数值是随机生成的[0,999)范围内的数值。&lt;/p&gt;
&lt;p&gt;这个示例有几个核心功能需要先解释，也是通过channel实现线程池的一般功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;创建一个task buffered channel，并通过allocate()函数将生成的任务存放到task buffered channel中&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建一个goroutine pool，每个goroutine监听task buffered channel，并从中取出任务&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;goroutine执行任务后，将结果写入到result buffered channel中&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从result buffered channel中取出计算结果并输出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，创建Task和Result两个结构，并创建它们的通道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type Task struct {
    ID      int
    randnum int
}

type Result struct {
    task    Task
    result  int
}

var tasks = make(chan Task, 10)
var results = make(chan Result, 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，每个Task都有自己的ID，以及该任务将要被worker计算的随机数。每个Result都包含了worker的计算结果result以及这个结果对应的task，这样从Result中就可以取出任务信息以及计算结果。&lt;/p&gt;
&lt;p&gt;另外，两个通道都是buffered channel，容量都是10。每个worker都会监听tasks通道，并取出其中的任务进行计算，然后将计算结果和任务自身放进results通道中。&lt;/p&gt;
&lt;p&gt;然后是计算位数之和的函数process()，它将作为worker的工作任务之一。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func process(num int) int {
    sum := 0
    for num != 0 {
        digit := num % 10
        sum += digit
        num /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个计算过程其实很简单，但随后还睡眠了2秒，用来假装执行一个计算任务是需要一点时间的。&lt;/p&gt;
&lt;p&gt;然后是worker()，它监听tasks通道并取出任务进行计算，并将结果放进results通道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func worker(wg *WaitGroup){
    defer wg.Done()
    for task := range tasks {
        result := Result{task, process(task.randnum)}
        results &amp;lt;- result
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码很容易理解，只要tasks channel不关闭，就会一直监听该channel。需要注意的是，该函数使用指针类型的&lt;code&gt;*WaitGroup&lt;/code&gt;作为参数，不能直接使用值类型的&lt;code&gt;WaitGroup&lt;/code&gt;作为参数，这样会使得每个worker都有一个自己的WaitGroup。&lt;/p&gt;
&lt;p&gt;然后是创建工作池的函数createWorkerPool()，它有一个数值参数，表示要创建多少个worker。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func createWorkerPool(numOfWorkers int) {
    var wg sync.WaitGroup
    for i := 0; i &amp;lt; numOfWorkers; i++ {
        wg.Add(1)
        go worker(&amp;amp;wg)
    }
    wg.Wait()
    close(results)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建工作池时，首先创建一个WaitGroup的值wg，这个wg被工作池中的所有goroutine共享，每创建一个goroutine都wg.Add(1)。创建完所有的goroutine后等待所有的groutine都执行完它们的任务，只要有一个任务还没有执行完，这个函数就会被Wait()阻塞。当所有任务都执行完成后，关闭results通道，因为没有结果再需要向该通道写了。&lt;/p&gt;
&lt;p&gt;当然，这里是否需要关闭results通道，是由稍后的range迭代这个通道决定的，不关闭这个通道会一直阻塞range，最终导致死锁。&lt;/p&gt;
&lt;p&gt;工作池部分已经完成了。现在需要使用allocate()函数分配任务：生成一大堆的随机数，然后将Task放进tasks通道。该函数有一个代表创建任务数量的数值参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func allocate(numOfTasks int) {
    for i := 0; i &amp;lt; numOfTasks; i++ {
        randnum := rand.Intn(999)
        task := Task{i, randnum}
        tasks &amp;lt;- task
    }
    close(tasks)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，最后需要关闭tasks通道，因为所有任务都分配完之后，没有任务再需要分配。当然，这里之所以需要关闭tasks通道，是因为worker()中使用了range迭代tasks通道，如果不关闭这个通道，worker将在取完所有任务后一直阻塞，最终导致死锁。&lt;/p&gt;
&lt;p&gt;再接着的是取出results通道中的结果进行输出，函数名为getResult()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func getResult(done chan bool) {
    for result := range results {
        fmt.Printf(&quot;Task id %d, randnum %d , sum %d\n&quot;, result.task.id, result.task.randnum, result.result)
    }
    done &amp;lt;- true
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getResult()中使用了一个done参数，这个参数是一个信号通道，用来表示results中的所有结果都取出来并处理完成了，这个通道不一定要用bool类型，任何类型皆可，它不用来传数据，仅用来返回可读，所以上面直接close(done)的效果也一样。通过下面的main()函数，就能理解done信号通道的作用。&lt;/p&gt;
&lt;p&gt;最后还差main()函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    // 记录起始终止时间，用来测试完成所有任务耗费时长
    startTime := time.Now()
    
    numOfWorkers := 20
    numOfTasks := 100
    // 创建任务到任务队列中
    go allocate(numOfTasks)
    // 创建工作池
    go createWorkerPool(numOfWorkers)
    // 取得结果
    var done = make(chan bool)
    go getResult(done)

    // 如果results中还有数据，将阻塞在此
    // 直到发送了信号给done通道
    &amp;lt;- done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println(&quot;total time taken &quot;, diff.Seconds(), &quot;seconds&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面分配了20个worker，这20个worker总共需要处理的任务数量为100。但注意，无论是tasks还是results通道，容量都是10，意味着任务队列最长只能是10个任务。&lt;/p&gt;
&lt;p&gt;下面是完整的代码段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

type Task struct {
    id      int
    randnum int
}
type Result struct {
    task   Task
    result int
}

var tasks = make(chan Task, 10)
var results = make(chan Result, 10)

func process(num int) int {
    sum := 0
    for num != 0 {
        digit := num % 10
        sum += digit
        num /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}
func worker(wg *sync.WaitGroup) {
    defer wg.Done()
    for task := range tasks {
        result := Result{task, process(task.randnum)}
        results &amp;lt;- result
    }
}
func createWorkerPool(numOfWorkers int) {
    var wg sync.WaitGroup
    for i := 0; i &amp;lt; numOfWorkers; i++ {
        wg.Add(1)
        go worker(&amp;amp;wg)
    }
    wg.Wait()
    close(results)
}
func allocate(numOfTasks int) {
    for i := 0; i &amp;lt; numOfTasks; i++ {
        randnum := rand.Intn(999)
        task := Task{i, randnum}
        tasks &amp;lt;- task
    }
    close(tasks)
}
func getResult(done chan bool) {
    for result := range results {
        fmt.Printf(&quot;Task id %d, randnum %d , sum %d\n&quot;, result.task.id, result.task.randnum, result.result)
    }
    done &amp;lt;- true
}
func main() {
    startTime := time.Now()
    numOfWorkers := 20
    numOfTasks := 100

    var done = make(chan bool)
    go getResult(done)
    go allocate(numOfTasks)
    go createWorkerPool(numOfWorkers)
    // 必须在allocate()和getResult()之后创建工作池
    &amp;lt;-done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println(&quot;total time taken &quot;, diff.Seconds(), &quot;seconds&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Task id 19, randnum 914 , sum 14
Task id 9, randnum 150 , sum 6
Task id 15, randnum 215 , sum 8
............
Task id 97, randnum 315 , sum 9
Task id 99, randnum 641 , sum 11
total time taken  10.0174705 seconds&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总共花费10秒。&lt;/p&gt;
&lt;p&gt;可以试着将任务数量、worker数量修改修改，看看它们的性能比例情况。例如，将worker数量设置为99，将需要4秒，将worker数量设置为10，将需要20秒。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 15:12:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>worker pool简介 worker pool其实就是线程池thread pool。对于go来说，直接使用的是goroutine而非线程，不过这里仍然以线程来解释线程池。 在线程池模型中， 有2个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10004620.html</dc:identifier>
</item>
<item>
<title>容器云平台在传统企业落地的一些思考和探索 - SammyLiu</title>
<link>http://www.cnblogs.com/sammyliu/p/10004446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sammyliu/p/10004446.html</guid>
<description>
&lt;p&gt;本文内容是我今天在一个云原生论坛上演讲的材料，加上一些备注，现在分享给大家。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221530909-1008013457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220725834-163183007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220740225-1219109218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220806645-510054727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从应用的承载和部署方式这一角度看，一共经历了传统的物理机架构、虚拟化架构、和现在的容器化三种架构。但是，容器并不是一种虚拟化技术，它与虚拟机有实质性区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122223449975-2132770527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220842643-985472935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然把云分为IaaS、PaaS 和 SaaS 已经好多年了，但是，它们只有的差别，一直是想得出但摸不到。对我个人来说，只有在搞了OpenStack 后才算了解了一些IaaS，只有在用了 OpenShift 后才算了解了一些PaaS。这两个产品，对我都有云启蒙性的帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220900382-1466865162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;容器云平台 CaaS 到底在左边还是在右边，这是一个问题，而且讨论了不少年。至少对我来说，我之前是习惯性地把它归到左边，因为把容器类比为虚拟机。但是现在，我认为它更应该归到右边，成为企业PaaS平台的支撑平台。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220916190-331040875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220932164-1167242905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过去的两三年，容器相关的东西非常火热。和所有新生事物一样，一开始也是杂乱无章。&lt;/p&gt;
&lt;p&gt;开源项目上，从 Docker，Swarm，Mesos，到 Kubernetes，再到 OpenShift，各种以容器为基础的技术和产品层出不穷。&lt;/p&gt;
&lt;p&gt;技术使用选型上，大家对于怎么用容器也是各有千秋。以阿里为例，他们主推的是富容器Pounch Container，而大家普遍采用的是 Docker 容器，还有 OpenStack 社区力推的 Kata。关于阿里的 Pounch Container，我个人很是疑问，他们是想成为主流呢，还是会被主流淹没呢？会不会重走一遍用KVM 替代 Xen 的路子呢？&lt;/p&gt;
&lt;p&gt;而对传统企业来说，虽然越来越多的企业对它在感兴趣，但是容器云落地更是问题多多，我这里列出的只是我接触过的一些比较典型的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122220948015-1114657965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我认为人们在为新事物做选择题的时候，往往会用老的思维模式。以容器云平台为例，就比较自然地把它归类到已经熟悉了的虚拟化和IaaS这一类的资源型平台。这种做法就会产生很多问题。我认为这是一种错位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221004005-218889290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要解决这些问题，我认为需要将容器云平台提升到 PaaS 层面。这里面有两点需要提一下：&lt;/p&gt;
&lt;p&gt;一是企业CIO在这里面的关键作用。当然了，在有些企业是别的类似的角色。只有这个角色，才能统一地将企业的开发和运维统一纳入考虑范围。&lt;/p&gt;
&lt;p&gt;二是咨询方案供应商。现在，随着新的技术的层出不穷，有些企业已经有了一些无所适从，既想用，又不知道怎么用。这时候，咨询公司就有了用武之地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221016810-1102377505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对企业用户来说，他们更看重的是 PaaS 部分的功能，因为这些功能能直接对软件开发和公司业务产生价值；对基于 Kubernetes 或 OpenShift 做产品化的公司来说，他们也应该更加聚焦 PaaS 部分。而 CaaS 部分，我认为，应该由相应的社区来主导。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221048881-1633282066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到了问题症结和解决方法，那回答问题就相对容易了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221102687-1264758569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221119374-135148073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221135063-1592790113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221152247-1271889139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221208184-276524567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我之前看过一份麦肯锡关于企业数字化转型的一个报告。报告里面提到，科技公司的两个关键所在，就是流程标准化和工具赋能。那结合 PaaS 平台能给用户带来的优势，其实正好，PaaS 平台给企业所带来的，正好就是流程标准化，包括开发流程、软件架构、应用管理等，以及充分利用各种工具和平台所带来的工具赋能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221222792-1299911730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;普遍认为，传统企业数字化转型需要经历三个阶段，分别是 云IT，云 DT，和云 DI 三个阶段。 这和将云分为 IaaS、PaaS 和 SaaS 三个层面有些巧合。&lt;br/&gt;而在云IT阶段，可以大概地认为是IaaS 阶段，它的任务是向企业提供弹性云资源。&lt;br/&gt;云DT阶段，是 PaaS 在企业中起关键作用的阶段。PaaS 能带来IT基础设施、应用架构、开发流程、组织结构的互联网化。&lt;br/&gt;云DI阶段，是SaaS服务发挥关键作用的阶段。AI 作为这一阶段的主要驱动力之一，将以SaaS的形式，被嵌入到各种业务系统之中，来驱动业务创新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221238028-946654259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在和过去的混合云，我想把他们称为混合云1.0，因为主要是网络和存储打通，但是在应用层面没有打通。没打通是有原因的，那是因为没法打通，有很多原因，其中一条是因为格式不同。现在有了容器云PaaS 之后，以容器为应用的统一载体，那打通就相对容易了。&lt;/p&gt;
&lt;p&gt;另外，随着混合云和多云概念的火热，云管理平台（CMP）的热度似乎一下子上来了。我认为，在当前存在多种不同IT环境的时期，CMP 的价值是明显的。但是，随着容器云部署在各种IT环境之上，它自己就会承担起部分CMP的功能，到那个时候，CMP 主要就会是PaaS平台的CMP了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221251109-1986351427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221303960-1985381851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;阶段1：孤岛式 IT 环境。问题是资源浪费；不能满足有快速需求的业务。&lt;/p&gt;
&lt;p&gt;阶段2：能解决阶段1 的问题，但产生了新的问题，那就是无法满足互联网业务要求。当传统行业不再满足于在本行业的领先地位，希望能够对接到互联网业务的时候，上面的模式就会出现新的痛点。对接互联网所面临的最大的问题，就是巨大的用户量所带来的请求量和数据量，会是原来的N倍，能不能撑得住，大家都心里没底。例如有的客户推出互联网理财秒杀抢购，原来的架构无法承载近百倍的瞬间流量。&lt;br/&gt;阶段3：解决之道&lt;/p&gt;
&lt;p&gt;落地是一个非常复杂的问题，甚至都不完全是技术问题。它牵扯到IT架构、应用架构、组织架构多个方面。这不单单是一个技术问题，更是一个组织问题。在推动过程中，更加能够感觉到康威定律的作用，需要更高层次管理者的介入，方能够推动这些在企业的落地。&lt;/p&gt;
&lt;p&gt;微服务和容器化的改造，更加容易发生在一个扁平化的组织里面，由一个能够体会到基层技术细节的痛的CIO，高瞻远瞩地推动这件事情。这也是为什么微服务的落地一般率先落地在互联网公司，因为互联网公司的组织架构很平台，哪怕是高层，也离一线非常的近，了解一线的痛。另一个原因是互联网业务强大的驱动力。&lt;/p&gt;
&lt;p&gt;在一些相对先进的企业，会在运维组和开发组之间，有个中间件组，或者叫做架构组，来负责推动微服务化改造的事情，架构组就既需要负责劝说业务开发实施微服务化，也要劝说运维组实施容器化，如果架构组的权威性不足，推动往往也会比较困难。&lt;/p&gt;
&lt;p&gt;备注：这里有采纳网易云刘超的一些观点，特此感谢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221318992-82651504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目标很明确，也有有价值，但是道路的困难大家都知道，那么还是从第一步做起吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221334462-1364615100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一、OpenShift 作为 PaaS 平台为红帽带来了很高的溢价。其实，从功能而论，OpenShift 相比 Kubernetes 并没有新增多少新的功能。但是，它第一次打造了面向DevOps的PaaS平台的产品，这是具有开创性的。就像新打开一扇大门一样，门并没有多少价值，但是门后的风景才是真正的价值。&lt;/p&gt;
&lt;p&gt;二、根据前面的分析，PaaS 平台在企业的落地需要有咨询商这一角色的存在，而无疑IBM深谙这个领域。因此我对红帽的PaaS产品和IBM的咨询服务能力会怎么结合充满期待。&lt;/p&gt;
&lt;p&gt;三、IBM发的公告里面特意提到了混合云，不知道IBM 会不会利用 OpenShift 来实现我前面画的那种混合云2.0。&lt;/p&gt;
&lt;p&gt;另外，有时候我会想，为什么只有红帽能推出OpenShift 这种PaaS平台呢？我认为这和只有 Google 能推出 Kubernetes 是一样的，那就是公司的基因。正是因为他们自己长期使用容器，长期实践DevOps，才能比较自然地做出大家普遍能接受的产品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221347774-1027045190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201811/697113-20181122221401360-9194535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 22 Nov 2018 15:06:00 +0000</pubDate>
<dc:creator>SammyLiu</dc:creator>
<og:description>本文内容是我今天在一个云原生论坛上演讲的材料，加上一些备注，现在分享给大家。 从应用的承载和部署方式这一角度看，一共经历了传统的物理机架构、虚拟化架构、和现在的容器化三种架构。但是，容器并不是一种虚拟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sammyliu/p/10004446.html</dc:identifier>
</item>
<item>
<title>大华门禁SDK二次开发（二） - 我打农村来</title>
<link>http://www.cnblogs.com/zhangdk/p/SignalR.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangdk/p/SignalR.html</guid>
<description>&lt;p&gt;经过与大华技术支持的沟通，门禁服务程序已经开发好了，可以正常接收门禁开关事件，可以发送开门命令。基于项目实时性要求，这里使用SignalR实现门禁状态、控制命令的实时传送。&lt;/p&gt;
&lt;h3 id=&quot;几种场景需求&quot;&gt;几种场景需求&lt;/h3&gt;
&lt;p&gt;根据SignalR的设计规则，Client端可以主动调用服务端Hub的多个方法，但是客户端被动接收消息的方法&lt;strong&gt;只能有一个&lt;/strong&gt;。&lt;br/&gt;根据门禁功能需求，我们将Client分为两组：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;doorclient:指Web客户端&lt;/li&gt;
&lt;li&gt;doorserver:指门禁服务端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样便于服务端区分Web客户端和门禁服务端这两类client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/aizaiyishunjian/534158ce/41ee85ca.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目中主要实现以下几个场景：&lt;/p&gt;
&lt;h4 id=&quot;web客户端初始加载刷新全部门禁状态&quot;&gt;Web客户端初始加载，刷新全部门禁状态&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/aizaiyishunjian/f1e9df9a/03d5a5fe.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A. 浏览器主动请求初始化门禁状态；&lt;/li&gt;
&lt;li&gt;B. web服务端接收信息，并转发到doorserver组；&lt;/li&gt;
&lt;li&gt;C. 门禁服务查询门禁状态，主动发送门禁状态列表；&lt;/li&gt;
&lt;li&gt;D. web服务端接收消息，并根据connectId转发给指定浏览器。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//web客户端
chat.server.sendMessageByBrowser();

// 定义AddMessage供服务器调用
chat.client.AddMessage = function (result) {
    for (var i = 0; i &amp;lt; result.length; i++) {
        try {
            //前端响应门禁状态变化
        } catch (error) {
        }
    }
};

//web服务端
/// &amp;lt;summary&amp;gt;
/// 浏览器发送消息，向doorServer请求所有门禁状态，用于初始化门禁状态
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
public void SendMessageByBrowser()
{
    var messageList = new List&amp;lt;DoorStateInfo&amp;gt;();
    var dc = new DoorStateInfo {ConnectId = Context.ConnectionId};
    messageList.Add(dc);
    Clients.Group(&quot;doorserver&quot;).AddMessage(messageList);
}


/// &amp;lt;summary&amp;gt;
/// 门禁服务发送多条开关门消息给某个浏览器，hubserver转发给浏览器
/// 浏览器id放在messagelist[0].ConnectId
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;messageList&quot;&amp;gt;&amp;lt;/param&amp;gt;
public void SendManyMessageByDoorServer(string name, List&amp;lt;DoorStateInfo&amp;gt; messageList)
{
    Clients.Client(messageList[0].ConnectId).AddMessage(messageList);
}

//门禁服务端
// 创建一个集线器代理对象
HubProxy = Connection.CreateHubProxy(&quot;DoorAlarmHub&quot;);

// 供服务端调用，将消息输出到消息列表框中
HubProxy.On&amp;lt;string, List&amp;lt;DoorStateInfo&amp;gt;&amp;gt;(&quot;AddMessage&quot;, (message) =&amp;gt;
{
    var alarmMsg = new AlarmMsg
    {
        Time = DateTime.Now.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;),
        AlarmInfo = message,
        AlarmType = EM_ALARM_TYPE.ALARM_SIGNALR_QUERY
    };
    if (message != null &amp;amp;&amp;amp; message.Count &amp;gt; 0) 
    {
        //无门禁状态，为门禁查询命令
        if (message[0].DoorState == EM_NET_DOOR_STATUS_TYPE.EM_NET_DOOR_STATUS_UNKNOWN)
        {
            alarmMsg.AlarmType = EM_ALARM_TYPE.ALARM_SIGNALR_QUERY;
        }
        //有门禁状态，为门禁控制命令
        else 
        {
            alarmMsg.AlarmType = EM_ALARM_TYPE.ALARM_SIGNALR_CONTROL;
        }
        m_AlarmMsgQueue.Enqueue(alarmMsg);                    
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;web端请求打开某个门&quot;&gt;Web端请求打开某个门&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/aizaiyishunjian/0771f803/719e60a8.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A. 浏览器主动请求开门；&lt;/li&gt;
&lt;li&gt;B. web服务端接收信息，并转发到doorserver组；&lt;/li&gt;
&lt;li&gt;C. 门禁服务发送开门命令，接收到门禁状态变化消息后，主动发送门禁状态变化信息；&lt;/li&gt;
&lt;li&gt;D. web服务端接收信息，并转发到doorclient组。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//web服务端
/// &amp;lt;summary&amp;gt;
/// 浏览器端调用，请求开门
/// &amp;lt;/summary&amp;gt;
public void SendOpenDoorByBrowser(/*业务参数用于标识门禁*/)
{
    
    var messageList = new List&amp;lt;DoorStateInfo&amp;gt;();
    
    //业务处理
    ...
    
    Clients.Group(&quot;doorserver&quot;).AddMessage(&quot;doorserver&quot;, messageList);
}


/// &amp;lt;summary&amp;gt;
/// 门禁服务发送开关门消息，hubserver转发给浏览器
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;message&quot;&amp;gt;&amp;lt;/param&amp;gt;
public void SendOneMessageByDoorServer(string name, DoorStateInfo message)
{
    
    //业务处理
    Clients.Group(&quot;doorclient&quot;).AddMessage(message);            
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;门禁服务发送门禁状态变化&quot;&gt;门禁服务发送门禁状态变化&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/aizaiyishunjian/8bb0e6d4/12d230a9.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A.这种情况主要发生在门禁刷卡等开门操作，引起的门禁状态变化，门禁服务接收到消息后，主动发送门禁状态变化信息；&lt;/li&gt;
&lt;li&gt;B.web服务端接收信息，并转发到doorclient组。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;几个问题说明&quot;&gt;几个问题说明&lt;/h2&gt;
&lt;h3 id=&quot;addmessage方法&quot;&gt;AddMessage方法&lt;/h3&gt;
&lt;p&gt;客户端使用&lt;code&gt;AddMessage&lt;/code&gt;接收server转发来的消息，由于client监听接收消息只能有一个方法，但是存在单个门禁状态变化消息和多个两种情况。因此&lt;code&gt;AddMessage&lt;/code&gt;的消息参数统一使用&lt;code&gt;List&amp;lt;Message&amp;gt;&lt;/code&gt;，然后在server端转发时相应加入业务标记，便于client端处理。&lt;/p&gt;
&lt;h3 id=&quot;门禁服务程序的事件机制&quot;&gt;门禁服务程序的事件机制&lt;/h3&gt;
&lt;p&gt;门禁服务程序采用事件机制&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;刷卡等开发事件接收到后，门禁服务会主动进行消息发送，通知所有浏览器更新相应门禁状态；&lt;/li&gt;
&lt;li&gt;浏览器初始化请求所有门禁状态时，由于消息通信是不能直接返回的，因此信息传递时携带connectId，用于下一条消息确认发送对象；&lt;/li&gt;
&lt;li&gt;与初始化请求一样，浏览器发送开门命令后，门禁服务接收到开门命令发送给大华门禁服务器后，会在收到门禁状态变化事件时，向doorclient组发送消息。两条消息是相对独立的。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 22 Nov 2018 14:53:00 +0000</pubDate>
<dc:creator>我打农村来</dc:creator>
<og:description>门禁服务程序已经调试完成，基于项目实时性要求，使用SignalR实现门禁状态实时获取和控制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangdk/p/SignalR.html</dc:identifier>
</item>
<item>
<title>React16.x特性剪辑 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/10004464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/10004464.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673bcf829ddb05c?w=640&amp;amp;h=280&amp;amp;f=jpeg&amp;amp;s=12258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文整理了 React 16.x 出现的耳目一新的概念与 api 以及应用场景。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5121951219512&quot;&gt;
&lt;p&gt;更多 React 系列文章可以订阅&lt;a href=&quot;https://github.com/MuYunyun/blog&quot;&gt;blog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;fiber&quot;&gt;16.0 Fiber&lt;/h3&gt;
&lt;p&gt;在 16 之前的版本的渲染过程可以想象成一次性潜水 30 米，在这期间做不了其它事情(Stack Reconciler);&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673bcf829e99859?w=270&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=5327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;痛点概括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一次性渲染到底&lt;/li&gt;
&lt;li&gt;中途遇到优先级更高的事件无法调整相应的顺序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 16 版本上, React 带来了 Fiber 的架构, 接着拿上面的潜水例子为例，现在变为可以每次潜 10 米，分 3 个 chunk 进行; chunk 和 chunk 之间通过链表连接; chunk 间插入优先级更高的任务, 先前的任务被抛弃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/22/1673bcf82aab2282?w=279&amp;amp;h=200&amp;amp;f=jpeg&amp;amp;s=7075&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;开启 Fiber 后，获取异步数据的方法应放到 render 后面的生命周期钩子里(phase 2 阶段)进行, 因为 render 前面的生命周期钩子(phase 1阶段)会被执行多次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意: 并没有缩短原先组件的渲染时间(甚至还加长了)，但用户却能感觉操作变流畅了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;render&quot;&gt;render()&lt;/h3&gt;
&lt;p&gt;在 React16 版本中 render() 增加了一些返回类型，到目前为止支持的返回类型如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React elements.&lt;/li&gt;
&lt;li&gt;Arrays and fragments.&lt;/li&gt;
&lt;li&gt;Portals.&lt;/li&gt;
&lt;li&gt;String and numbers.&lt;/li&gt;
&lt;li&gt;Booleans or null.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/react-component.html#render&quot;&gt;render&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中 render() 支持返回 Arrays 能让我们少写一个父节点, 如下所示:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const renderArray = () =&amp;gt; [
  &amp;lt;div&amp;gt;A&amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;B&amp;lt;/div&amp;gt;
]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;4.3382352941176&quot;&gt;
&lt;p&gt;个人认为 render() 支持返回数组完全可以取代 &lt;a href=&quot;https://reactjs.org/docs/fragments.html&quot;&gt;Fragments&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;portals传送门&quot;&gt;Portals(传送门)&lt;/h3&gt;
&lt;p&gt;将 react 子节点渲染到指定的节点上&lt;/p&gt;
&lt;p&gt;案例：实现一个 Modal 组件，&lt;a href=&quot;https://codepen.io/gaearon/pen/yzMaBd&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外关于 Portals 做到冒泡到父节点的兄弟节点这个现象, &lt;a href=&quot;https://codepen.io/gaearon/pen/jGBWpE&quot;&gt;demo&lt;/a&gt;, 我想可以这样子实现：如果组件返回是 Portal 对象，则将该组件的父组件的上的事件 copy 到该组件上。其实并不是真的冒泡到了父节点的兄弟节点上。&lt;/p&gt;
&lt;h3 id=&quot;error-boundaries&quot;&gt;Error Boundaries&lt;/h3&gt;
&lt;p&gt;React 16 提供了一个新的错误捕获钩子 &lt;code&gt;componentDidCatch(error, errorInfo)&lt;/code&gt;, 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。&lt;a href=&quot;https://codepen.io/gaearon/pen/wqvxGa?editors=0010&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;componentDidCatch 并不会捕获以下几种错误&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件机制抛出的错误(事件里的错误并不会影响渲染)&lt;/li&gt;
&lt;li&gt;Error Boundaries 自身抛出的错误&lt;/li&gt;
&lt;li&gt;异步产生的错误&lt;/li&gt;
&lt;li&gt;服务端渲染&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;服务端渲染&quot;&gt;服务端渲染&lt;/h3&gt;
&lt;p&gt;服务端渲染一般是作为最后的优化手段, 这里浅显(缺乏经验)谈下 React 16 在其上的优化。&lt;/p&gt;
&lt;p&gt;在 React 16 版本中引入了 &lt;code&gt;React.hydrate()&lt;/code&gt;, 它的作用主要是将相关的事件&lt;code&gt;注水&lt;/code&gt;进 &lt;code&gt;html&lt;/code&gt; 页面中, 同时会比较前端生成的 &lt;code&gt;html&lt;/code&gt; 和服务端传到前端的 &lt;code&gt;html&lt;/code&gt; 的文本内容的差异, 如果两者不一致将前端产生的文本内容替换服务端生成的(忽略属性)。&lt;/p&gt;
&lt;h3 id=&quot;支持自定义属性&quot;&gt;支持自定义属性&lt;/h3&gt;
&lt;p&gt;在 React 16 版本中, 支持自定义属性(推荐 &lt;code&gt;data-xxx&lt;/code&gt;), 因而 React 可以少维护一份 attribute 白名单, 这也是 React 16 体积减少的一个重要因素。&lt;/p&gt;
&lt;h3 id=&quot;life-cycle&quot;&gt;life cycle&lt;/h3&gt;
&lt;p&gt;在 React 16.3 的版本中，新加入了两个生命周期：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;getDerivedStateFromProps(nextProps, prevState)&lt;/code&gt;: 更加语义化, 用来替代 componentWillMount、componentWillReceiveProps(nextProps);&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;getSnapshotBeforeUpdate(prevProps, prevState)&lt;/code&gt;: 可以将结果传入 componentDidUpdate 里, 从而达到 dom 数据统一。用来替代 componentWillUpdate()（缺点是 React 开启异步渲染后，componentWillUpdate() 与 componentDidUpdate() 间获取的 dom 会不统一;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hooks&quot;&gt;16.7 Hooks&lt;/h3&gt;
&lt;p&gt;在 React 16.7 之前，React 有两种形式的组件，有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件，让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程。&lt;/p&gt;
&lt;p&gt;接下来梳理 Hooks 中最核心的 2 个 api, &lt;code&gt;useState&lt;/code&gt; 和 &lt;code&gt;useEffect&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;usestate&quot;&gt;useState&lt;/h4&gt;
&lt;p&gt;useState 返回状态和一个更新状态的函数&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const [count, setCount] = useState(initialState)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function App() {
  const [count, setCount] = useState(0)

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;You clicked {count} times&amp;lt;/p&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; setCount(count + 1)}&amp;gt;
        Click me
      &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;useeffectfn&quot;&gt;useEffect(fn)&lt;/h4&gt;
&lt;p&gt;在每次 render 后都会执行这个钩子。可以将它当成是 &lt;code&gt;componentDidMount&lt;/code&gt;、&lt;code&gt;componentDidUpdate&lt;/code&gt;、&lt;code&gt;componentWillUnmount&lt;/code&gt; 的合集。因此使用 useEffect 比之前优越的地方在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以避免在 &lt;code&gt;componentDidMount、componentDidUpdate&lt;/code&gt; 书写重复的代码;&lt;/li&gt;
&lt;li&gt;可以将关联逻辑写进一个 &lt;code&gt;useEffect&lt;/code&gt;;(在以前得写进不同生命周期里);&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在上述提到的生命周期钩子之外，其它的钩子是否在 hooks 也有对应的方案或者舍弃了其它生命周期钩子, 后续进行观望。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 22 Nov 2018 14:34:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<og:description>本文整理了 React 16.x 出现的耳目一新的概念与 api 以及应用场景。 更多 React 系列文章可以订阅</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/10004464.html</dc:identifier>
</item>
<item>
<title>Vue源码解析之nextTick - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/10001264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/10001264.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;nextTick是Vue的一个核心功能，在Vue内部实现中也经常用到nextTick。但是，很多新手不理解nextTick的原理，甚至不清楚nextTick的作用。&lt;/p&gt;
&lt;p&gt;那么，我们就先来看看nextTick是什么。&lt;/p&gt;
&lt;h3 id=&quot;nexttick功能&quot;&gt;nextTick功能&lt;/h3&gt;
&lt;p&gt;看看官方文档的描述：&lt;/p&gt;
&lt;p&gt;在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。&lt;/p&gt;
&lt;p&gt;再看看官方示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})

// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
  .then(function () {
    // DOM 更新了
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。&lt;/p&gt;
&lt;p&gt;可以看到，nextTick主要功能就是改变数据后让回调函数作用于dom更新后。很多人一看到这里就懵逼了，为什么需要在dom更新后再执行回调函数，我修改了数据后，不是dom自动就更新了吗？&lt;/p&gt;
&lt;p&gt;这个和JS中的Event Loop有关，网上教程不计其数，在此就不再赘述了。建议明白Event Loop后再继续向下阅读本文。&lt;/p&gt;
&lt;p&gt;举个实际的例子：&lt;/p&gt;
&lt;p&gt;我们有个带有分页器的表格，每次翻页需要选中第一项。正常情况下，我们想的是点击翻页器，向后台获取数据，更新表格数据，操纵表格API选中第一项。&lt;/p&gt;
&lt;p&gt;但是，你会发现，表格数据是更新了，但是并没有选中第一项。因为，你选中第一项时，虽然数据更新了，但是DOM并没有更新。此时，你可以使用nextTick，在DOM更新后再操纵表格第一项的选中。&lt;/p&gt;
&lt;p&gt;那么，nextTick到底做了什么了才能实现在DOM更新后执行回调函数？&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;nextTick的源码位于src/core/util/next-tick.js，总计118行，十分的短小精悍，十分适合初次阅读源码的同学。&lt;/p&gt;
&lt;p&gt;nextTick源码主要分为两块：&lt;/p&gt;
&lt;p&gt;1.能力检测&lt;/p&gt;
&lt;p&gt;2.根据能力检测以不同方式执行回调队列&lt;/p&gt;
&lt;h4 id=&quot;能力检测&quot;&gt;能力检测&lt;/h4&gt;
&lt;p&gt;这一块其实很简单，众所周知，Event Loop分为宏任务（macro task）以及微任务（ micro task），不管执行宏任务还是微任务，完成后都会进入下一个tick，并在两个tick之间执行UI渲染。&lt;/p&gt;
&lt;p&gt;但是，宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，使用宏任务；但是，各种宏任务之间也有效率的不同，需要根据浏览器的支持情况，使用不同的宏任务。&lt;/p&gt;
&lt;p&gt;nextTick在能力检测这一块，就是遵循的这种思想。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
// 如果浏览器不支持Promise，使用宏任务来执行nextTick回调函数队列
// 能力检测，测试浏览器是否支持原生的setImmediate（setImmediate只在IE中有效）
if (typeof setImmediate !== 'undefined' &amp;amp;&amp;amp; isNative(setImmediate)) {
  // 如果支持，宏任务（ macro task）使用setImmediate
  macroTimerFunc = () =&amp;gt; {
    setImmediate(flushCallbacks)
  }
  // 同上
} else if (typeof MessageChannel !== 'undefined' &amp;amp;&amp;amp; (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () =&amp;gt; {
    port.postMessage(1)
  }
} else {
  /* istanbul ignore next */
  // 都不支持的情况下，使用setTimeout
  macroTimerFunc = () =&amp;gt; {
    setTimeout(flushCallbacks, 0)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，检测浏览器是否支持setImmediate，不支持就使用MessageChannel，再不支持只能使用效率最差但是兼容性最好的setTimeout了。&lt;/p&gt;
&lt;p&gt;之后，检测浏览器是否支持Promise，如果支持，则使用Promise来执行回调函数队列，毕竟微任务速度大于宏任务。如果不支持的话，就只能使用宏任务来执行回调函数队列。&lt;/p&gt;
&lt;h4 id=&quot;执行回调函数队列&quot;&gt;执行回调函数队列&lt;/h4&gt;
&lt;p&gt;执行回调函数队列的代码刚好在一头一尾&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数队列
const callbacks = []
// 异步锁
let pending = false

// 执行回调函数
function flushCallbacks () {
  // 重置异步锁
  pending = false
  // 防止出现nextTick中包含nextTick时出现问题，在执行回调函数队列前，提前复制备份，清空回调函数队列
  const copies = callbacks.slice(0)
  callbacks.length = 0
  // 执行回调函数队列
  for (let i = 0; i &amp;lt; copies.length; i++) {
    copies[i]()
  }
}

...

// 我们调用的nextTick函数
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  // 将回调函数推入回调队列
  callbacks.push(() =&amp;gt; {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  // 如果异步锁未锁上，锁上异步锁，调用异步函数，准备等同步函数执行完后，就开始执行回调函数队列
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  // $flow-disable-line
  // 2.1.0新增，如果没有提供回调，并且支持Promise，返回一个Promise
  if (!cb &amp;amp;&amp;amp; typeof Promise !== 'undefined') {
    return new Promise(resolve =&amp;gt; {
      _resolve = resolve
    })
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总体流程就是，接收回调函数，将回调函数推入回调函数队列中。&lt;/p&gt;
&lt;p&gt;同时，在接收第一个回调函数时，执行能力检测中对应的异步方法（异步方法中调用了回调函数队列）。&lt;/p&gt;
&lt;p&gt;如何保证只在接收第一个回调函数时执行异步方法？&lt;/p&gt;
&lt;p&gt;nextTick源码中使用了一个异步锁的概念，即接收第一个回调函数时，先关上锁，执行异步方法。此时，浏览器处于等待执行完同步代码就执行异步代码的情况。&lt;/p&gt;
&lt;p&gt;打个比喻：相当于一群旅客准备上车，当第一个旅客上车的时候，车开始发动，准备出发，等到所有旅客都上车后，就可以正式开车了。&lt;/p&gt;
&lt;p&gt;当然执行flushCallbacks函数时有个难以理解的点，即：为什么需要备份回调函数队列？执行的也是备份的回调函数队列？&lt;/p&gt;
&lt;p&gt;因为，会出现这么一种情况：nextTick套用nextTick。如果flushCallbacks不做特殊处理，直接循环执行回调函数，会导致里面nextTick中的回调函数会进入回调队列。这就相当于，下一个班车的旅客上了上一个班车。&lt;/p&gt;
&lt;h3 id=&quot;实现一个简易的nexttick&quot;&gt;实现一个简易的nextTick&lt;/h3&gt;
&lt;p&gt;说了这么多，我们来实现一个简单的nextTick：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let callbacks = []
let pending = false

function nextTick (cb) {
    callbacks.push(cb)

    if (!pending) {
        pending = true
        setTimeout(flushCallback, 0)
    }
}

function flushCallback () {
    pending = false
    let copies = callbacks.slice()
    callbacks.length = 0
    copies.forEach(copy =&amp;gt; {
        copy()
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在简易版的nextTick中，通过nextTick接收回调函数，通过setTimeout来异步执行回调函数。通过这种方式，可以实现在下一个tick中执行回调函数，即在UI重新渲染后执行回调函数。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 14:34:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>Vue源码解析之nextTick 前言 nextTick是Vue的一个核心功能，在Vue内部实现中也经常用到nextTick。但是，很多新手不理解nextTick的原理，甚至不清楚nextTick的作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/karthuslorin/p/10001264.html</dc:identifier>
</item>
<item>
<title>python 爬虫 入门 commit by commit -- commit1 - 一心一怿</title>
<link>http://www.cnblogs.com/ZXYloveFR/p/10004420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZXYloveFR/p/10004420.html</guid>
<description>&lt;p data-key=&quot;1867&quot;&gt;&lt;span data-key=&quot;1866&quot;&gt;&lt;span data-offset-key=&quot;1866-0&quot;&gt;&quot;F12才是爬虫开发的最好的朋友&quot; -- by 我自己&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1869&quot;&gt;&lt;span data-key=&quot;1868&quot;&gt;&lt;span data-offset-key=&quot;1868-0&quot;&gt;既然叫commit by commit，那就要按照自己给自己定下的规矩来写。在把代码clone到本地之后，你可以用git reset --hard 6fda96eae来退回到代码的第一个版本。别担心回不去后面的版本，这commit都在github都能看到，即使你不知道一些奇技淫巧的git命令也没啥，大胆干。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1869&quot;&gt;&lt;span data-key=&quot;1868&quot;&gt;&lt;span data-offset-key=&quot;1868-0&quot;&gt;首先，我觉得我应该说这个commit我想干嘛，第一个commit，我是想作为熟悉的门槛，所以这个commit最开始我的本意是想获得京东图书编程语言第一页上面的书名，链接。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1871&quot;&gt;&lt;span data-key=&quot;1870&quot;&gt;&lt;span data-offset-key=&quot;1870-0&quot;&gt;对于这个commit，当你输入如下命令开始运行时：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1874&quot;&gt;&lt;span data-key=&quot;1938&quot;&gt;&lt;span data-offset-key=&quot;1938-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222249573-839311495.png&quot; alt=&quot;&quot;/&gt;&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1937-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1878&quot;&gt;&lt;span data-key=&quot;1875&quot;&gt;&lt;span data-offset-key=&quot;1875-0&quot;&gt;你应该能看到如下的结果：&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1940-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span data-key=&quot;1939&quot;&gt;&lt;span data-key=&quot;1939&quot;&gt;&lt;span data-offset-key=&quot;1939-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;&lt;span data-key=&quot;1941&quot;&gt;&lt;span data-offset-key=&quot;1941-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222342997-2098566000.png&quot; alt=&quot;&quot; width=&quot;746&quot; height=&quot;150&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p data-key=&quot;1880&quot;&gt;&lt;span data-key=&quot;1879&quot;&gt;&lt;span data-offset-key=&quot;1879-0&quot;&gt;前面已经扯了两篇了，那么从这篇开始步入技术的正轨了，其实从骨子里我是很讨厌那种教程里敲半个小时代码，最后发现就是一个输出了一个星号组成的图案。我觉得，入门级别的代码得用不超过10分钟的时间干出一点你能看得到，有成就感的正事才能吸引大部分的注意力。可惜啊，C++在这方面确实很难做到，而python在这方面绝对是擅长。所以，第一个commit虽然我的comment是ugly commit，但是绝对能干活。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1882&quot;&gt;&lt;span data-key=&quot;1881&quot;&gt;&lt;span data-offset-key=&quot;1881-0&quot;&gt;既然是入门级别的文章，那么就从最基本的部分开始，当你浏览一个网页的时候，实际上，你在浏览什么？实际上你在浏览的是服务器传回来的一系列文件，这一系列文件由浏览器解析，然后呈现给你。比如我想看看京东图书编程语言下面的所有图书，我只要用鼠标一点一点的点到我想要的地方就可以看到我需要的网页。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1886&quot;&gt;&lt;span data-key=&quot;1943&quot;&gt;&lt;span data-offset-key=&quot;1943-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222415804-998170761.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;234&quot;/&gt;​&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1942-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;span data-key=&quot;1939&quot;&gt;&lt;span data-key=&quot;1939&quot;&gt;&lt;span data-offset-key=&quot;1939-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;&lt;span data-key=&quot;1941&quot;&gt;&lt;span data-offset-key=&quot;1941-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;&lt;span data-key=&quot;1885&quot;&gt;&lt;span data-offset-key=&quot;1885-0&quot;&gt;但是作为一个程序员，GUI并算是一个高效的交互方式，一个简单的例子，对于文本可以一目十行，GUI除非你眼睛传感器异于常人或者大脑CPU比一般人要性能好，不然很难做到。对于爬虫，他不会关心GUI，它的食物只有一种，各类带格式的文件。所以，我们需要看到界面背后的源码。市面上只要你能见到的浏览器，在右键菜单里一定会有让你看到源码的菜单。但是，在现代网页越来越丰富的情况下，一个页面的源码文件实在是太丰富了，按照我最开始的说法，我想找到书名和价格，咋办？不能用ctrl+f吧，低效不是程序员的作为。在这个时候，职业的本能应该驱使你去寻找工具。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;p data-key=&quot;1888&quot;&gt;&lt;span data-key=&quot;1887&quot;&gt;&lt;span data-offset-key=&quot;1887-0&quot;&gt;开心的是，主流浏览器都带有这种工具，而且获取这一组工具的方法都是只要简单的按下F12就可以了，我敢保证，当你按下这个键的时候，你有一种打开了新世界的感觉。比如我用的火狐，按下F12之后在最左边，你会看到这样一个图标:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1892&quot;&gt;&lt;span data-key=&quot;1945&quot;&gt;&lt;span data-offset-key=&quot;1945-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222442430-1751789758.png&quot; alt=&quot;&quot;/&gt;&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1944-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1894&quot;&gt;&lt;span data-key=&quot;1893&quot;&gt;&lt;span data-offset-key=&quot;1893-0&quot;&gt;点击一下这个图标再移到界面上，你会发现你可以以矩形的方式选择页面上的元素。根据人的本能，点击一下，你会发现图标下面的html会自动定义到选中的元素！这样，拿到什么信息，你只要负责选择就好了，浏览器自带的工具会自动帮你定位。比如，我想要的图书的名字和价格，我选中某一格的图书，就会看到这样的输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1897&quot;&gt;&lt;span data-key=&quot;1947&quot;&gt;&lt;span data-offset-key=&quot;1947-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222501846-1551488376.png&quot; alt=&quot;&quot;/&gt;&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1946-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span data-key=&quot;1898&quot;&gt;&lt;span data-offset-key=&quot;1898-0&quot;&gt;html是一种格式化并且是带有层级的语言，这样就会自然引申出一个问题，当我选取一个元素时候，到底采用怎样的粒度？比如说，就以这个图书的名字来说，他是在一个列表(li)元素中的一个div中的一个text中的，那么完全可以直接选取这个text，第二个是通过父级别一点一点的选取。这其实就是一个数据结构大小取舍的问题，而写程序，我觉得要考虑到扩展性和人思维的自然认知性，以便于升级和维护。所以，我一般都是从我自己最自然的认知出发，当我的眼睛看到这个网页时，我的呆脑，哦不，是大脑会自然把每个图的一个缩略图，名称和价格组成的这个方块归类为一个小组，于是，我选择的粒度就是遵从我的内心。&lt;/span&gt;&lt;/span&gt;
&lt;p data-key=&quot;1905&quot;&gt;&lt;span data-key=&quot;1904&quot;&gt;&lt;span data-offset-key=&quot;1904-0&quot;&gt;那么我就用上面说的小箭头选取到我决定的方块，可以得到标识这每一方块的元素是&amp;lt;li&amp;gt;。而在这个HTML中，有无数的li，我们怎么能定位到我们需要的这个li呢？这里，让我不得不想起一个谚语，叫赠人玫瑰手有余香。在前端程序员在开发他们的网页时，他们需要对元素进行标识，这样他们才能在代码中方便的写出想要的逻辑。而这个行为，给爬虫程序员们提供了便利，你可以用他们归类的标识来定位你需要的元素，当然，我这里说的是在代码里。而beautifulsoup这个包可以非常的方便的让你完成这件事情，你可以选择用id，class等等来找到你需要的元素。而在这里，如果你按照我说的使用箭头工具的话，会很容易的看到在这个网页中gl-item这样的class来标识每一个列表块。那么剩下的就是按照已经发现的，翻译成为程序语言了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1907&quot;&gt;&lt;span data-key=&quot;1906&quot;&gt;&lt;span data-offset-key=&quot;1906-0&quot;&gt;在第一个commit里面，代码一共22行，我都忍不住用截图的方式展示一下以便于说明。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1910&quot;&gt;&lt;span data-key=&quot;1950&quot;&gt;&lt;span data-offset-key=&quot;1950-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1949-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222520156-945254258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1912&quot;&gt;&lt;span data-key=&quot;1911&quot;&gt;&lt;span data-offset-key=&quot;1911-0&quot;&gt;这个代码前7行都是shebang，coding的设置和import包。这里你不知道shebang也一点也不影响你对于这一系列问斩的阅读理解。所以说，正文从第九行看起就行了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1914&quot;&gt;&lt;span data-key=&quot;1913&quot;&gt;&lt;span data-offset-key=&quot;1913-0&quot;&gt;首先python提供了非常方便的方法获取网页的源码，我以前最开始的时候使用C++写过爬虫，怎么形容呢？如果python爬虫的给力程度是他娘的意大利炮，那么c++就是纯物理攻击了。你只需要使用urllib中的request.urlopen就能直接获取到网页源码。而需要的参数仅仅是网页的url。一如第九行所示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1916&quot;&gt;&lt;span data-key=&quot;1915&quot;&gt;&lt;span data-offset-key=&quot;1915-0&quot;&gt;当有了源码之后，按照前面介绍的逻辑，就是寻找对应的元素了，而这个时候就是BeautifulSoup包上场的时候了，把得到的源码字符串作为参数传给BeautifulSoup库，你就会得到一个强大的方便解析的BeautifulSoup对象。而在BeautifulSoup中，使用findAll你就可以找到全部的带有某种标识的某种元素。比如说，在我们要爬取的页面上，有很多的书，而我们又知道每个书所存在的块是以gl-item的class来标识的列表，那么只要对findAll传入元素名称和标识规则就行了。而BeautifulSoup还提供一个find函数，用来找到第一个符合标识的对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1918&quot;&gt;&lt;span data-key=&quot;1917&quot;&gt;&lt;span data-offset-key=&quot;1917-0&quot;&gt;既然已经得到需要的一大块了，剩下的就是在这一大块中找到自己想要的信息，比如我想要的书名和链接地址。其实这后面的过程就是前面描述的过程的重复。大致就是找到页面-&amp;gt;按下F12-&amp;gt;使用选择工具-&amp;gt;找到对应的元素块。但是程序员嘛，都很懒，能少动几下鼠标是几下，所以，如果一个块中元素规模不大的并且基本都相像的情况下，我会使用这样的一种办法：把一大块的html片段输出到一个文件里。如果你觉得我说的有点绕了，那么其实我想表达的就是第12行语句的意思，虽然我这里用的是print，但是你可以使用重定向的功能将这个输出到一个文件中，也就是&quot;&amp;gt; item.txt&quot;类似的语句。而如果你查看这个commit的目录结构，你就会看到这么一个文件。如果好奇心仍驱使你打开它，那么你就可以看到一个li中的所有内容。这样就省去了前面那四个步骤的烦恼，而且你可以反复查看，而不用反复的打开浏览器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1921&quot;&gt;&lt;span data-key=&quot;1953&quot;&gt;&lt;span data-offset-key=&quot;1953-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;img src=&quot;https://img2018.cnblogs.com/blog/159614/201811/159614-20181122222625099-1454225841.png&quot; alt=&quot;&quot;/&gt;&lt;span data-slate-void=&quot;true&quot;&gt;&lt;span&gt;&lt;span data-offset-key=&quot;1952-0&quot;&gt;&lt;span data-slate-zero-width=&quot;true&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1923&quot;&gt;&lt;span data-key=&quot;1922&quot;&gt;&lt;span data-offset-key=&quot;1922-0&quot;&gt;当然，这是在我下面的循环还没有写出来的时候先输出的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1925&quot;&gt;&lt;span data-key=&quot;1924&quot;&gt;&lt;span data-offset-key=&quot;1924-0&quot;&gt;谈到这个while循环，在这里你可以完全忽略，或者说你可能会揣测这到底有什么深意。其实没啥深意，就是为了后面用的，而且还是比较后面的commit中才会用到。我只是有点懒，懒得删除。实际上，这个程序的第15,16以及22行完全可以删除，对于最后的结果完全没有任何影响。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1929&quot;&gt;&lt;span data-key=&quot;1926&quot;&gt;&lt;span data-offset-key=&quot;1926-0&quot;&gt;而这里的for循环是肯定必要的。python的语法，按照其cookbook上说，已经非常接近自然语言了，从有的方面看真的是这样的，比如说第17行，表示是依次取出allItem中的所有元素，对于每一个元素就是一个li块，剩下的只要从这些li块中再继续寻找需要的信息就可以了。比如，书的标题实在class为p-name的div元素之中。而在这个页面上，真正的标题文字是放在强调标签&amp;lt;em&amp;gt;之中。这都不能难住强大的BeautifulSoup库，其对象可以像访问结构中成员一般一层一层的找到需要的元素。如果想要获得某个标签中的文字，只需要使用get_text函数就可以获得。用代码说话的话就是18,19行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1931&quot;&gt;&lt;span data-key=&quot;1930&quot;&gt;&lt;span data-offset-key=&quot;1930-0&quot;&gt;而有的时候我们不是要获取某个标签中的元素，而是要获取某个标签中的属性怎么办？BeautifulSoup用近乎完全符合自然思维的方式实现了这一点。比如超链接，一般都是在&amp;lt;a&amp;gt;标签中href属性之中，那么href就是a这个成员（字典）的一个关键词，通过这个关键词，你就可以取得其中的值，一如你看到的href=&quot;xxx&quot;一样，典型的key，value结构。也就是程序的第20行，通过这样的方式，就可以取得每个图书的链接。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1933&quot;&gt;&lt;span data-key=&quot;1932&quot;&gt;&lt;span data-offset-key=&quot;1932-0&quot;&gt;剩下来，就是你怎么呈现这个数据的部分了，我这里就简单大方而又明了的输出，keep it simple，stupid。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-key=&quot;1935&quot;&gt;&lt;span data-key=&quot;1934&quot;&gt;&lt;span data-offset-key=&quot;1934-0&quot;&gt;这里，第一个commit就结束了，去掉不需要while循环，一共就19行代码，在环境配好的情况下，无脑敲完不需要5分钟，运行python myGAND.py,你就可以看到京东图书编程语言第一页的书名和链接打印在控制台或者文件中。说实话，如果是C++，你可能还在写各种字符串解析函数的过程中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 14:27:00 +0000</pubDate>
<dc:creator>一心一怿</dc:creator>
<og:description>&quot;每一个commit都是程序员的心酸，哦不，心路历程的最好展示。&quot; -- by 我自己 最近写好了一组文章，来这里，当然一如我以前一样，主要是宣传。但是，最近发现gitbook老是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZXYloveFR/p/10004420.html</dc:identifier>
</item>
<item>
<title>Kz.layedit-layui.layedit富文本编辑器拓展 - KnifeZ</title>
<link>http://www.cnblogs.com/KnifezZZ/p/10004407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KnifezZZ/p/10004407.html</guid>
<description>&lt;p&gt;&lt;span&gt;摘要：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本插件基于layui.layedit,增加了HTML源码模式，片插入功能添加alt属性（layupload），视频插入功能，全屏功能，段落格式，字体颜色设置，右键菜单操作，插入锚点，水平线功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有拓展功能菜单按钮图标均引用自layui自带图标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;演示地址：&lt;a href=&quot;http://knifez.gitee.io/kz.layedit/index.html&quot; target=&quot;_blank&quot;&gt;kz.layedit&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 tool: [
                    'html', 'code', 'strong', 'italic', 'underline', 'del', 'addhr', '|', 'fontFomatt', 'colorpicker', 'face'
                    , '|', 'left', 'center', 'right', '|', 'link', 'unlink', 'image_alt', 'video', 'anchors'
                    , '|', 'fullScreen'
                ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　html=&amp;gt; html源码模式（弹窗显示），&lt;/p&gt;
&lt;p&gt;　　addhr=&amp;gt;添加水平线&amp;lt;hr&amp;gt;，&lt;/p&gt;
&lt;p&gt;　　fontFomatt =&amp;gt;段落格式设置，设置当前行为p,h1~4,div等格式，&lt;/p&gt;
&lt;p&gt;　　colorpicker=&amp;gt;字体颜色设置，&lt;/p&gt;
&lt;p&gt;　　image_alt=&amp;gt;带alt属性，宽高设置的图片上传，（&lt;span&gt;image原版图片上传依旧支持&lt;/span&gt;），&lt;/p&gt;
&lt;p&gt;　　video =&amp;gt;视频上传，带封面上传，&lt;/p&gt;
&lt;p&gt;　　anchors=&amp;gt; 添加锚点，通过样式在编辑器内展示，不带样式无法展示，待修复，&lt;/p&gt;
&lt;p&gt;　　fullScreen=&amp;gt;全屏设置&lt;/p&gt;



&lt;p&gt;&lt;span&gt;　　　　HTML源码模式引用第三方插件ace,优化源码展示样式，&lt;/span&gt;引用ace编辑器仅保留了html源码样式和tomorrow主题，如有需要可自行更换，目录为/Content/ace/ace.js，指路--&amp;gt; &lt;a href=&quot;https://github.com/ajaxorg/ace&quot; target=&quot;_blank&quot;&gt;ace官网&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　　　图片视频上传需要配置相应的后台接口，同时也可以设置上传附件格式，附件大小等，该参数继承自layui.layupload。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传图片参数设置               &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; uploadImage: {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                     url: '/Attachment/LayUploadFile',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台上传方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;                     accept: 'image',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;限制上传类型&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;                     acceptMime: 'image/*'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                     exts: 'jpg|png|gif|bmp|jpeg',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拓展名限制&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;                     size: '10240'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大小限制&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传视频参数设置--同图片&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;uploadVideo: {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                     url: '/Attachment/LayUploadFile'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                     accept: 'video'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                     acceptMime: 'video/*'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                     exts: 'mp4|flv|avi|rm|rmvb'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;                     size: '20480'
&lt;span&gt;8&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;该参数用于右键选中图片或视频进行删除时调用，根据提供的后台方法进行删除，返回的参数图片路径为imgpath,视频路径为 filepath，后台可根据接受的文件路径进行删除或其他操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右键删除图片/视频时的回调参数，post到后台删除服务器文件等操作，&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递参数：&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片： imgpath --图片路径&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;视频： filepath --视频路径 imgpath --封面路径&lt;/span&gt;
&lt;span&gt;                , calldel: {
                    url: &lt;/span&gt;'/Attachment/DeleteFile'&lt;span&gt;
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　　　该参数可配置也可不配置，根据自己的实际需求出发，如不配置，则为原版的效果，配置hide为true时，会根据defalut设置的语言格式进行插入&amp;lt;pre&amp;gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入代码设置&lt;/span&gt;
&lt;span&gt;                , codeConfig: {
                    hide: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否显示编码语言选择框&lt;/span&gt;
                    &lt;span&gt;default&lt;/span&gt;: 'javascript' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;hide为true时的默认语言格式&lt;/span&gt;
                }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　--未完待续&lt;/p&gt;
</description>
<pubDate>Thu, 22 Nov 2018 14:25:00 +0000</pubDate>
<dc:creator>KnifeZ</dc:creator>
<og:description>摘要： 本插件基于layui.layedit,增加了HTML源码模式，片插入功能添加alt属性（layupload），视频插入功能，全屏功能，段落格式，字体颜色设置，右键菜单操作，插入锚点，水平线功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KnifezZZ/p/10004407.html</dc:identifier>
</item>
</channel>
</rss>