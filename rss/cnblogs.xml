<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>容器中使用iptables报错can't initialize iptables table Permission denied (you must be root) - BookShu</title>
<link>http://www.cnblogs.com/styshoo/p/7690430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/styshoo/p/7690430.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;　　在docker容器中部署了一微服务，该服务需要docker push镜像到docker registry。因此，docker容器中需要安装docker服务。但在启动容器的时候，却报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;can't initialize iptables table `filter': Permission denied (you must be root)
Perhaps iptables or your kernel needs to be upgraded.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原因&quot;&gt;原因　　　　&lt;/h2&gt;
&lt;p&gt;　　在容器中部署docker服务，而docker服务又会使用到iptables，因此在启动容器时，也会同时启动容器内的iptables。但iptables必须工作在容器的privileged模式下，否则就会如上报错。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;　　在启动容器时加上对应的privileged参数。&lt;/p&gt;
&lt;h3 id=&quot;docker中启动容器&quot;&gt;docker中启动容器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;docker run -privileged [imageName]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;marathon中启动容器&quot;&gt;Marathon中启动容器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;{
  ...
  &quot;instances&quot;: 1,
  &quot;container&quot;: {
    &quot;type&quot;: &quot;DOCKER&quot;,
    &quot;volumes&quot;: [],
    &quot;docker&quot;: {
      &quot;image&quot;: &quot;imageName&quot;,
      &quot;network&quot;: &quot;BRIDGE&quot;, 
      &quot;privileged&quot;: true,
      &quot;parameters&quot;: [],
    }
  }
  ...
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 18 Oct 2017 23:03:00 +0000</pubDate>
<dc:creator>BookShu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/styshoo/p/7690430.html</dc:identifier>
</item>
<item>
<title>JMS 基础 - loveincode</title>
<link>http://www.cnblogs.com/loveincode/p/JMS_Basics.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveincode/p/JMS_Basics.html</guid>
<description>&lt;p&gt;JMS(Java Message Service) 即Java消息服务。它提供标准的产生、发送、接收消息的接口简化企业应用的开发。&lt;br/&gt;它支持两种消息通信模型：&lt;span&gt;&lt;strong&gt;点到点（point-to-point）&lt;/strong&gt;&lt;/span&gt;（P2P）&lt;strong&gt;&lt;span&gt;模型和发布/订阅&lt;/span&gt;&lt;/strong&gt;（Pub/Sub）模型。&lt;br/&gt;P2P 模型规定了一个消息只能有一个接收者;Pub/Sub 模型允许一个消息可以有多个接收者。&lt;/p&gt;&lt;p&gt;对于点到点模型，消息生产者产生一个消息后，把这个消息发送到一个Queue（队列）中，然后消息接收者再从这个Queue中读取，&lt;br/&gt;一旦这个消息被一个接收者读取之后，它就在这个Queue中消失了，所以一个消息只能被一个接收者消费。&lt;/p&gt;&lt;p&gt;与点到点模型不同，发布/订阅模型中，消息生产者产生一个消息后，把这个消息发送到一个Topic中，这个Topic可以同时有多个接收者在监听，&lt;br/&gt;当一个消息到达这个Topic之后，所有消息接收者都会收到这个消息。&lt;/p&gt;&lt;p&gt;简单的讲，点到点模型和发布/订阅模型的区别就是前者是&lt;span&gt;&lt;strong&gt;一对一&lt;/strong&gt;&lt;/span&gt;，后者是&lt;strong&gt;&lt;span&gt;一对多&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Destination&lt;/strong&gt;: 消息发送的目的地，也就是前面说的Queue和Topic。创建好一个消息之后，只需要把这个消息发送到目的地，消息的发送者就可以继续做自己的事情，而不用等待消息被处理完成。至于这个消息什么时候，会被哪个消费者消费，完全取决于消息的接受者。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt;: 从字面上就可以看出是被发送的消息。它有下面几种类型：&lt;br/&gt;　　&lt;strong&gt;StreamMessage&lt;/strong&gt;: Java 数据流消息，用标准流操作来顺序的填充和读取。&lt;br/&gt;　　&lt;strong&gt;MapMessage&lt;/strong&gt;：一个Map类型的消息；名称为 string 类型，而值为 Java 的基本类型。&lt;br/&gt;　　&lt;strong&gt;TextMessage&lt;/strong&gt;：普通字符串消息，包含一个String。&lt;br/&gt;　　&lt;strong&gt;ObjectMessage&lt;/strong&gt;：对象消息，包含一个可序列化的Java 对象&lt;br/&gt;　　&lt;strong&gt;BytesMessage&lt;/strong&gt;：二进制数组消息，包含一个byte[]。&lt;br/&gt;　　&lt;strong&gt;XMLMessage&lt;/strong&gt;: 一个XML类型的消息。&lt;br/&gt;最常用的是&lt;strong&gt;TextMessage&lt;/strong&gt;和&lt;strong&gt;ObjectMessage&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Session&lt;/strong&gt;: 与JMS提供者所建立的会话，通过Session我们才可以创建一个Message。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;: 与JMS提供者建立的一个连接。可以从这个连接创建一个会话，即Session。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ConnectionFactory&lt;/strong&gt;: 那如何创建一个Connection呢？这就需要下面讲到的ConnectionFactory了。通过这个工厂类就可以得到一个与JMS提供者的连接，即Conection。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Producer&lt;/strong&gt;:消息的生产者，要发送一个消息，必须通过这个生产者来发送。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;MessageConsumer&lt;/strong&gt;:与生产者相对应，这是消息的消费者或接收者，通过它来接收一个消息。&lt;/p&gt;&lt;p&gt;前面多次提到JMS提供者，因为JMS给我们提供的只是一系列接口，当我们使用一个JMS的时候，还是需要一个第三方的提供者，&lt;br/&gt;它的作用就是真正管理这些Connection，Session，Topic和Queue等。&lt;/p&gt;
&lt;p&gt;通过下面这个简图可以看出上面这些概念的关系。&lt;/p&gt;
&lt;p&gt;ConnectionFactory-----&amp;gt;Connection-----&amp;gt;Session-----&amp;gt;Message&lt;br/&gt;Destination + Session-----------------------------&amp;gt;Producer&lt;br/&gt;Destination + Session-----------------------------&amp;gt;MessageConsumer&lt;/p&gt;&lt;p&gt;那么可能有人会问: ConnectionFactory 和 Destination 从哪儿得到?&lt;br/&gt;这就和JMS提供者有关了. 如果在一个JavaEE环境中, 可以通过&lt;strong&gt;&lt;span&gt;JNDI(&lt;span data-bm=&quot;44&quot;&gt;&lt;span class=&quot;01&quot;&gt;Java命名和目录接口（the &lt;span class=&quot;01&quot;&gt;Java naming and directory interface，JNDI）是一组在Java应用中访问命名和目录服务的&lt;span class=&quot;01&quot;&gt;API。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/strong&gt;查找得到, 如果在一个非JavaEE环境中, 那只能通过JMS提供者提供给我们的接口得到了.&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://blog.itpub.net/10742815/viewspace-578446/&quot; target=&quot;_blank&quot;&gt;http://blog.itpub.net/10742815/viewspace-578446/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 22:55:00 +0000</pubDate>
<dc:creator>loveincode</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loveincode/p/JMS_Basics.html</dc:identifier>
</item>
<item>
<title>PE格式第七讲,重定位表 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7690069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7690069.html</guid>
<description>&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
&lt;h2&gt;一丶何为重定位(注意,不是重定位表格)&lt;/h2&gt;
&lt;p&gt;首先,我们先看一段代码,比如调用Printf函数,使用OD查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019000321256-227953286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么大家有没有想过这么一个问题,函数的字符串偏移是00407030位置,函数Call的地址是00401020的位置&lt;/p&gt;
&lt;p&gt;但是如果模块首地址申请不到了,变为了00100000的位置,那么此时的偏移是不是都是错的了?&lt;/p&gt;
&lt;p&gt;首先说下,一般重定位表格都是DLL中的,因为满足不了模块首地址的需求,所以会遇到函数的重定位问题.&lt;/p&gt;
&lt;p&gt;那么如果磨坏地址变为了00100000的位置,那么对应的字符串位置是不是也要变为00107030的位置,而Call的地址,是不是也要变为00101020的位置&lt;/p&gt;
&lt;p&gt;那么这个就叫做重定位,我们要把偏移,以及各种需要修正的位置,变为正确的.&lt;/p&gt;
&lt;h2&gt;二丶重定位表格如何设计?&lt;/h2&gt;
&lt;p&gt;首先我们自己先想一下,重定位的表格要如何设计?&lt;/p&gt;
&lt;p&gt;我猜想,你要保存模块的地址  ,修改地址,偏移, 以及大小.&lt;/p&gt;
&lt;p&gt;新的模块 ImageBase&lt;/p&gt;
&lt;p&gt;旧的模块 iMageBase&lt;/p&gt;
&lt;p&gt;修改的地址 &lt;/p&gt;
&lt;p&gt;偏移&lt;/p&gt;
&lt;p&gt;修改的大小&lt;/p&gt;
&lt;p&gt;那么如果这样设计会不会出现问题?&lt;/p&gt;
&lt;p&gt;会出现很多问题,比如占得字节太多了,如果是Kerner32.dll里面都是这样设计,那么得要多少内存.&lt;/p&gt;
&lt;p&gt;那么进一步的优化&lt;/p&gt;
&lt;p&gt;可不可以一个分页,保存修改的偏移,以及长度&lt;/p&gt;
&lt;p&gt;分页: page  (DWORD) 占4个字节&lt;/p&gt;
&lt;p&gt;大小: size (DWORD)     偏移:offset(DWORD)&lt;/p&gt;
&lt;p&gt;表格设计为上面的,&lt;/p&gt;
&lt;p&gt;感觉这样可以了.但是感觉还可以进一步的优化,大小,以及偏移都占4个字节,是不是浪费了&lt;/p&gt;
&lt;p&gt;而且如果记录一个分页中的重定位的数据,那么偏移是不会超过12位的(二进制12位,转为10进制是1024),  那么如果一个DWORD存储文件偏移,那么高4位是没有用的.&lt;/p&gt;
&lt;p&gt;而且我们发现,大小也是很占位置的.大小一个字节就可以表示了,比如0 做对齐使用,1修改高16位的偏移,2修改低16位的偏移,3修改4个字节大小&lt;/p&gt;
&lt;p&gt;那么是不是可以合并了&lt;/p&gt;
&lt;p&gt;page  (DWORD)&lt;/p&gt;
&lt;p&gt;sizeofoffset&lt;/p&gt;
&lt;p&gt;0x3005　　　　代表的意思就是看高位,3代表我要修改4个字节,005代表修改的当前页的偏移位置.&lt;/p&gt;
&lt;h2&gt;三丶真正的重定位表格&lt;/h2&gt;
&lt;p&gt;看下重定位表格的真正的结构体吧.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019001739990-491018873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;　　　　　　　　　　　　页存储的RVA
    DWORD   SizeOfBlock;　　　　　　　　　　　　　　word类型数组的个数,也就是下面注释的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  WORD    TypeOffset[1];&lt;/span&gt;
&lt;span&gt;} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION UNALIGNED &lt;/span&gt;* PIMAGE_BASE_RELOCATION;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么看看是不是和我们猜想的一样,我们随便找个DLL,在数据目录中定位重定位表格&lt;/p&gt;
&lt;h3&gt;1.寻找数据目录RVA偏移&lt;/h3&gt;
&lt;p&gt;我们首先要找到数据目录中重定位表格的RVA偏移然后判断属于哪个节,通过公式转化,得到在文件中的实际偏移位置.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019002301443-519167639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出RVA = 6000h&lt;/p&gt;
&lt;h3&gt;2.判断属于哪个节&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019002405599-1180681703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现,新增加了一个节,这个节就是重定位的节然后虚拟地址是6000位置,而且在文件偏移的位置也是6000h&lt;/p&gt;
&lt;p&gt;那么我们就得出 FA = RVA了,那么就不用算了,可以确定,文件偏移位置就是6000就是重定位表的位置&lt;/p&gt;

&lt;h3&gt;3.定位文件偏移处,查看排列&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019002722256-1276358009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后可以看出 前八个字节分别保存页的RVA偏移,以及大小,.我们使用计算器计算一下,看看有多大&lt;/p&gt;
&lt;p&gt;计算的出 160h,这个大小,保存的是数组大小+上我们八个字节的总大小,也就是说160 - 8 = 数组的大小了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019003024896-1967351804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出确实是怎么大,然后就到记录下一个分页了.&lt;/p&gt;
&lt;h2&gt;四丶数组解析查看&lt;/h2&gt;
&lt;p&gt; 那么按照我们的想法看上面重定位表中的数组的第一个,按照小尾方式读取则是&lt;/p&gt;
&lt;p&gt;0x3005  那么高位是3那么就是要修改大小是4个字节,005则是代表偏移.&lt;/p&gt;
&lt;p&gt;至于高位怎么查看,VC++6.0中的宏已经定义了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019012036006-1549362385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_ABSOLUTE         0x0000  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reference is absolute, no relocation is necessary&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_DIR16            0x0001  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Direct 16-bit reference to the symbols virtual address&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_REL16            0x0002  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PC-relative 16-bit reference to the symbols virtual address&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_DIR32            0x0006  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Direct 32-bit reference to the symbols virtual address&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_DIR32NB          0x0007  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Direct 32-bit reference to the symbols virtual address, base not included&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_SEG12            0x0009  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_SECTION          0x000A
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_SECREL           0x000B
&lt;span&gt;#define&lt;/span&gt; IMAGE_REL_I386_REL32            0x0014  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PC-relative 32-bit reference to the symbols virtual address&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只需要知道0 1 2 代表的意思即可,因为0x3005的高位是 用位运算 | 上去的,所以3代表的是1 和 2的组合&lt;/p&gt;
&lt;p&gt;0  对齐使用&lt;/p&gt;
&lt;p&gt;1.修改高16位  &lt;/p&gt;
&lt;p&gt;2.修改低16位&lt;/p&gt;
&lt;p&gt;1和2 使用位运算|起来就是修改4个字节.&lt;/p&gt;
&lt;h3&gt;1.定位修改位置&lt;/h3&gt;
&lt;p&gt;那么怎么定位要修改的位置那?&lt;/p&gt;
&lt;p&gt; 公式:&lt;/p&gt;
&lt;p&gt;现在的ImageBase(模块地址) +  当前分页大小的虚拟地址 +5的位置等于要修改的位置:&lt;/p&gt;
&lt;p&gt;比如假设我们的现在的模块地址是00400000位置,而DLL以前的位置是10000000  而它以前的字符串的偏移是   10003045&lt;/p&gt;
&lt;p&gt;首先定位修改地址:&lt;/p&gt;
&lt;p&gt;00400000 + 1000 + 005 = 401005  那么在401005的位置就是你要修改的位置&lt;/p&gt;
&lt;p&gt;比如我们在写一个&lt;/p&gt;
&lt;p&gt;0x3096 =  400000 + 1000 + 96 = 401096  那么定位的位置就是401096是你要修改的偏移,大小是4个字节,高位为3  为什么是4个字节,一会看下内部存储&lt;/p&gt;
&lt;h3&gt;2.修改的偏移计算&lt;/h3&gt;
&lt;p&gt;比如我们调用一个printf &lt;/p&gt;
&lt;p&gt;push 10003096    &quot;HelloWorld&quot;&lt;/p&gt;
&lt;p&gt;call    10004086  &lt;/p&gt;
&lt;p&gt;那么我们要修正他的偏移&lt;/p&gt;
&lt;p&gt;我们现在得知,以前的DLL偏移是  10000000    以前的字符串偏移是  10003096 ,不过因为DLL的模块地址没有满足,那么现在的模块地址变为了00400000的位置&lt;/p&gt;
&lt;p&gt;那么我们要修正偏移&lt;/p&gt;
&lt;p&gt;公式:&lt;/p&gt;
&lt;p&gt;现在的ImageBase (00400000) - 以前的ImageBase(10000000) + 以前的偏移(10003096)&lt;/p&gt;
&lt;p&gt;这样写汇编代码好写,如果便于理解的话,可以写成下面那样,只不过你需要知道的是汇编代码就是上面这种写法就行&lt;/p&gt;
&lt;p&gt;以前的偏移(10003096)  - 以前的ImageBase(10000000) + 现在的ImageBase(00400000)  &lt;/p&gt;
&lt;p&gt;= 3096 + 400000&lt;/p&gt;
&lt;p&gt;= 403096  (计算出来的偏移)&lt;/p&gt;
&lt;p&gt;那么push的位置就成了 403096了,已经重定位了.&lt;/p&gt;

&lt;h2&gt;五丶实战演练查看&lt;/h2&gt;
&lt;p&gt; 因为DLL中的重定位表中的项太多,所以这里使用一个EXE(没有导出函数的EXE),然后注入这个DLL,那么这个EXE就有重定位表格了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019005401927-958337747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们先看DLL, 3005的位置要重定位&lt;/p&gt;
&lt;p&gt;按照公式我们得出,要修改的位置是&lt;/p&gt;
&lt;p&gt;现在模块地址 + 当前表中记录分页 + 数组中后三位的偏移(上面说过,如果按照分页存储,那么3位就可以表达一个分页需要记录的了)&lt;/p&gt;
&lt;p&gt;那么现在  我们的EXE的模块地址是00500000 + 1000(重定位表中第一项成员) + 005  (这是一个数组,第一个成员是0x3005  取出后三位则是005)&lt;/p&gt;
&lt;p&gt;得出修改的位置是  00501005的位置,我们OD中CTRL+ G看看这个位置是不是要修正.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019005709584-1252828027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码乱了,那么我们可能断掉指令了,那么此时CTRL + A重新分析一下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019005756756-1232289458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看出,我们修正的位置是501005的位置,不过汇编代码在501004才能显示出来,501005后面正好是要修正的地址,那么只需要计算偏移填进去就可以了,大小是按照高4个字节, 现在0x3005 高位是3那么代表了要修正4个字节的偏移.&lt;/p&gt;
&lt;p&gt;算出偏移位置:&lt;/p&gt;
&lt;p&gt;偏移位置我们要进行反推了&lt;/p&gt;
&lt;p&gt;因为OD已经帮我们重定位好了.&lt;/p&gt;
&lt;p&gt;503000 = 现在的ImageBase - 以前的ImageBase + 以前的偏移 = 现在的偏移(503000)&lt;/p&gt;
&lt;p&gt;那么现在计算以前的偏移&lt;/p&gt;
&lt;p&gt;以前的偏移 = 现在的偏移 - 现在的ImageBase + 以前的ImageBase &lt;/p&gt;
&lt;p&gt;=  503000 - 50000 + 60000000 &lt;/p&gt;
&lt;p&gt;= 3000 + 60000000&lt;/p&gt;
&lt;p&gt;= 60003000 (以前的偏移)&lt;/p&gt;
&lt;p&gt;那么算出了以前的偏移,我们就计算这4个字节要填写的偏移,也就是503000怎么得出来的&lt;/p&gt;
&lt;p&gt;公式上面说了:&lt;/p&gt;
&lt;p&gt; Cur (缩写,代表当前的意思)  Old(代表旧的意思)  offset(代表偏移的意思)&lt;/p&gt;
&lt;p&gt;CurImageBase - OldImageBase + OldOffset = 要填入的偏移&lt;/p&gt;
&lt;p&gt;代入公式:&lt;/p&gt;
&lt;p&gt;00500000  -  60000000  + 60030000 = 00503000 (要填写的文件偏移)&lt;/p&gt;
&lt;p&gt;看下我们当前的模块地址:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171019011723631-796860453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Inject是我们当前的EXE的名称,模块地址在00500000的位置&lt;/p&gt;
&lt;p&gt;DLL的模块地址是60000000  这个地址是我们通过修改DLL中的选项头中的ImageBase得到的.&lt;/p&gt;

&lt;h2&gt; 六丶总结&lt;/h2&gt;
&lt;p&gt; 上面讲的很细致&lt;/p&gt;
&lt;p&gt;今天主要就是结构体会看,偏移会算即可.&lt;/p&gt;
&lt;p&gt;总结一下公式&lt;/p&gt;
&lt;h3&gt;1.定位重定位的地址  (也就是在哪里修改)&lt;/h3&gt;
&lt;p&gt;首先从数组取出一项,(2个字节大小)&lt;/p&gt;
&lt;p&gt;比如0x3005&lt;/p&gt;
&lt;p&gt;公式:&lt;/p&gt;
&lt;p&gt;定位修改地址  = 现在模块 + 当前结构记录分页的RVA  + 取出数组的2个字节的低3位&lt;/p&gt;
&lt;p&gt;例子: 00401000 + 1000 + 005 = 世纪你要修改的地址,修改大小和取出word自己的第一位有关&lt;/p&gt;
&lt;h3&gt;2.计算出偏移地址,填写到定位地址的位置,使其偏移正确&lt;/h3&gt;
&lt;p&gt;现在的模块地址  - DLL模块地址 + 以前的偏移 = 实际修改的偏移&lt;/p&gt;
&lt;p&gt;便于理解的公式:&lt;/p&gt;
&lt;p&gt;以前的偏移 - DLL模块地址 + 现在模块地址 &lt;/p&gt;
&lt;h3&gt;3.计算出以前偏移&lt;/h3&gt;
&lt;p&gt;要计算出以前的偏移,你首先要得出现在的偏移,好在OD已经写好了,其实文件中也有存储的.(自己找吧)&lt;/p&gt;
&lt;p&gt;以前的偏移 = 现在的偏移 - 现在模块地址 + DLL模块地址&lt;/p&gt;

&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 17:30:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7690069.html</dc:identifier>
</item>
<item>
<title>【机器学习实战】第6章 支持向量机 - 片刻</title>
<link>http://www.cnblogs.com/jiangzhonglian/p/7690033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangzhonglian/p/7690033.html</guid>
<description></description>
<pubDate>Wed, 18 Oct 2017 16:44:00 +0000</pubDate>
<dc:creator>片刻</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangzhonglian/p/7690033.html</dc:identifier>
</item>
<item>
<title>（@WhiteTaken）设计模式学习——享元模式 - WhiteTaken</title>
<link>http://www.cnblogs.com/WhiteTaken/p/7690021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WhiteTaken/p/7690021.html</guid>
<description>
&lt;p&gt;&lt;span&gt;继续学习享元模式。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;乍一看到享元的名字，一头雾水，学习了以后才觉得，这个名字确实比较适合这个模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;享元，即共享对象的意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　举个例子，如果制作一个五子棋的游戏，如果每次落子都实例化一个对象的话，那么一个多人在线的游戏，要实例化的对象就无穷无尽，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了避免这种情况的发生，我们可以怎么做呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　试想一下，如果有个盛放对象的容器，用到什么对象就拿出来，如果容器中没有要用到的对象，那么就创建新的对象，并放入容器中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样资源就会得到充分的利用，也避免频繁的创建对象，造成内存的浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　享元模式，就是做到了对象的重复使用，减小内存占用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面直接上代码。依然是Java实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Person基类，定义一些人的基本信息。可以被其他关于人的类继承。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String name = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String sex = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Person(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String sex)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(String sex) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Student类，继承了Person基类，拥有自己独立的方法，并加入了字段id。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student extends Person{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; String id = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Student(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String sex, String id){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        super(name, age, sex);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        super();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; studentSpeak()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我的学号是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; id);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;StudentFactory类，享元模式的核心类，有容器pool，有对象拿出来用，没有对象就创建对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import java.util.HashMap;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import java.util.Map;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentFactory {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Student&amp;gt;&lt;span&gt; pool;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StudentFactory() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         pool = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Student&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student getStudent(String id){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Student student = pool.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(id);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; student){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             student = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            student.setId(id);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            pool.put(id, student);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; student;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MainClass测试主类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainClass {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         StudentFactory studentFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StudentFactory();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Student student1 = studentFactory.getStudent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Student student2 = studentFactory.getStudent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Student student3 = studentFactory.getStudent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Student student4 = studentFactory.getStudent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        student1.studentSpeak();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        student2.studentSpeak();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        student3.studentSpeak();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        student4.studentSpeak();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(student1 ==&lt;span&gt; student3){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=======同一个对象======&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--------不同对象-------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1088633/201710/1088633-20171019003012021-1001797779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由此可见，student1和student3是同一个对象。&lt;/p&gt;
&lt;p&gt;此外还有一个概念需要注意一下，就是人们口中的对象池，对象池是享元模式的一个分支，但是和上边的享元模式还是有区别的。&lt;/p&gt;
&lt;p&gt;区别就在于，对象池中的对象都是相同的，而以上的享元模式的对象是不同的，并用id做了区分。需要好好体会一下。&lt;/p&gt;
&lt;p&gt;希望大家共同进步，每天学到一点，积少成多。&lt;/p&gt;
&lt;p&gt;Sweet Dream！！！&lt;/p&gt;
</description>
<pubDate>Wed, 18 Oct 2017 16:34:00 +0000</pubDate>
<dc:creator>WhiteTaken</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WhiteTaken/p/7690021.html</dc:identifier>
</item>
<item>
<title>Delphi实现电脑端微信图片文件解密 - 吾八哥</title>
<link>http://www.cnblogs.com/5bug/p/7688994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5bug/p/7688994.html</guid>
<description>&lt;p&gt;电脑端微信收到图片后是存在了“C:\Users\系统用户名\Documents\WeChat Files\微信帐号\Data”目录下的，但文件不能直接使用图片浏览器打开的，因为做了一些加密，之前有个朋友问我这些文件怎么解密，就抽空研究了下。参考了一篇文章：http://share.iclient.ifeng.com/news/shareNews?forward=1&amp;amp;aid=117431304&amp;amp;from=timeline&amp;amp;isappinstalled=1&amp;amp;forward=1#backhead，文章里提到的是加密值：ox5，其实现在改了，是根据不同的图片格式采用不同的加密值了，今天这里使用Delphi来实现这个图片文件的解密，教你找到被撤回的微信图片或者存储被撤回的图片，哈哈。直接上代码吧！&lt;/p&gt;&lt;div readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:delphi;gutter:true;&quot;&gt;
uses
  System.SysUtils, System.Classes, Winapi.Windows, System.Math, System.StrUtils;

// 计算MagicCode以及图片类型
function CalcMagicCode(const AHeadCode: Word; var AMagicCode: Word; var AFileExt: string): Boolean;
const
  C_TypeCodeArr: array of Word = [$4D42, $D8FF, $4947, $5089];
  C_TypeExtArr: array of string = ['.bmp', '.jpeg', '.gif', '.png'];
var
  I: Integer;
  LByte1, LByte2: Byte;
  LMagicCode: Word;
begin
  Result := False;
  LByte1 := Byte(AHeadCode);
  LByte2 := HiByte(AHeadCode);
  for I := Low(C_TypeCodeArr) to High(C_TypeCodeArr) do
  begin
    LMagicCode := Byte(C_TypeCodeArr[I]) xor LByte1;
    if LMagicCode = (HiByte(C_TypeCodeArr[I]) xor LByte2) then
    begin
      AMagicCode := LMagicCode;
      AFileExt := C_TypeExtArr[I];
      Result := True;
    end;
  end;
end;

procedure MakeFileList(const Path, FileExt: string; AFileList: TStrings);
var
  sch: TSearchRec;
  tmpPath: string;
begin
  if RightStr(Trim(Path), 1) &amp;lt;&amp;gt; '\' then
    tmpPath := Trim(Path) + '\'
  else
    tmpPath := Trim(Path);
  if not DirectoryExists(tmpPath) then
    Exit;
  if FindFirst(tmpPath + '*', faAnyFile, sch) = 0 then
  begin
    repeat
      if ((sch.Name = '.') or (sch.Name = '..')) then
        Continue;
      if (UpperCase(ExtractFileExt(tmpPath + sch.Name)) = UpperCase(FileExt)) or (FileExt = '.*') then
        AFileList.Add(tmpPath + sch.Name);
    until FindNext(sch) &amp;lt;&amp;gt; 0;
    System.SysUtils.FindClose(sch);
  end;
end;

procedure DecryptWXImgFile(const ASrcFile, ASavePath: string);
var
  LSrcStream: TMemoryStream;
  LDesStream: TFileStream;
  LFilesize, LPos: Integer;
  LBuffer: Word;
  LSrcByte, LDesByte: Byte;
  LMagicCode: Word;
  LFileExt, LFileName: string;
begin
  LSrcStream := TMemoryStream.Create;
  try
    LSrcStream.LoadFromFile(ASrcFile);
    LSrcStream.Position := 0;
    LSrcStream.ReadBuffer(LBuffer, 2);
    if CalcMagicCode(LBuffer, LMagicCode, LFileExt) then
    begin
      LFileName := ASavePath + ChangeFileExt(ExtractFileName(ASrcFile), LFileExt);
      LDesStream := TFileStream.Create(LFileName, fmCreate);
      try
        LPos := 0;
        LFilesize := LSrcStream.Size;
        // 此处效率低，需要优化
        while LPos &amp;lt; LFilesize do
        begin
          LSrcStream.Position := LPos;
          LSrcStream.ReadBuffer(LSrcByte, 1);
          LDesByte := LSrcByte xor LMagicCode;
          LDesStream.WriteBuffer(LDesByte, 1);
          Inc(LPos);
        end;
      finally
        LDesStream.Free;
      end;
    end;
  finally
    LSrcStream.Free;
  end;
end;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;DecryptWXImgFile(‘C:\Users\5bug\Documents\WeChat Files\Wubug5\Data\1383774871197177544.dat’, ‘C:\Users\5bug\Desktop\test\’);&lt;/p&gt;&lt;p&gt;以上代码里有一处自行优化吧，否则效率非常低下！只要监控这个存储目录，就可以实现找到被撤回的微信图片或者存储被撤回的图片了，还可以实现一些小工具了，比如微信防撤回图片存储器，微信图片整理工具等了。&lt;/p&gt;&lt;p&gt;另外爱好Delphi的而且正在学习Python的同学可以加群一起交流啊QQ群643829693！&lt;/p&gt;</description>
<pubDate>Wed, 18 Oct 2017 16:24:00 +0000</pubDate>
<dc:creator>吾八哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5bug/p/7688994.html</dc:identifier>
</item>
<item>
<title>客户懂点代码是最致命的毒药 - 郎中令</title>
<link>http://www.cnblogs.com/Sientuo/p/7688257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sientuo/p/7688257.html</guid>
<description>&lt;p&gt;       这里绝对不是吐槽，只是记录一个非常搞笑的事情。&lt;/p&gt;
&lt;p&gt;       台企业向来以绝对的服务称道，即使客户是 Naive ，Simple。作为银行的网站，在项目快上线的时候，一声惊雷传来，&lt;span&gt;将所有逻辑实现类的代码拷贝至 一个logic.cs类中，将所有实体类拷贝至Model.cs类中。&lt;span&gt;没错,没有听错，老夫驰骋项目多年，第一次听过如此奇葩的要求！！！给出的理由绝对惊讶： 客户懂代码，逻辑类分开写看的不舒服！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 这个荒唐的理由下，需要做的处理：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ①原来面向各个界面的逻辑实现类的类名以序列编号重命名的形式全部拷贝至Logic.cs中 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ②所有实体类拷贝至Model.cs类中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ③所有的控制器中调用的方法全部重新设置路径&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ④所有视图中引用的实体类文件路径重新设置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ⑤对翻新后的文件进行测试&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 完成之后，整个项目简洁明了（光秃秃），尤其是逻辑层就两个类文件，无任何文件夹，仅仅只有一个Logic.cs 和 Model.cs 两个文件，后期的维护怎么做？哦，不是，客户懂点代码，想着是，文件个数，以后维护可以自行动手，不用再花钱。这算盘。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 粗略算了下，负重的Logic.cs文件 里面会有近20K行的代码。整个项目翻新一遍，加上测试，两个人差不多需要四到五天的时间，说不准，一个星期之后，客户又觉得不好，还能再改回来，毕竟这样的事情经常发生，一步一注释，十步一备注，步步才能走的稳呐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     作为一名开发人员，尽量以最优、最简明的目的去对待项目。如果客户什么都不懂，那么我们给出各种方案，客户认可的标准就是 运行正常、（高效）、简单操作。恰恰如果客户懂点代码，但是有时那种什么都不知道的门外行，那真是叫痛苦，想来什么就是什么，需求没有不合理之说，界面管，代码结构管，实现方式管，这都是开发文档中明确的事情，无可厚非，如果客户连这种傻逼都都知道是荒谬的需求还要一意孤行的去执行。sa又向来弱势，那么坑爹的就是程序员；大家普遍对台企印象不好，或者说很差，其实也是有道理的。我在这家台企工作快两年，算大公司，所在的研发分部就有不下1000人，不加班，双休，5天七小时，13薪，年涨薪20% ，日常工作轻松自由，可以磨洋工，去楼顶吹风，去楼下花园散散步，时间自由轻松。看来还算不错。弊端也有，员工无积极性。企业的态度是唯用户至上，如客户仅仅提供几个思路，实际是无稽之谈，完全不可行，但是也要开发人员短时间内给出一定的开发测试。在客户面前，台湾的sa毫无主见（反正也不是他们开发）,照单全收，然后统统转交至开发部，当开发人员在请求确认的时候，往往一两个星期都得不到反馈，甚至更久，看看人家强哥的24小时必回邮件制度。出了问题，还被强行背锅，有一次一个简单的需求，就是改下存储过程中X表的一栏位，结果sa描述成其它的意思，最后用户发现不对，质问sa，于是陆陆续续出现了A、B、C、D、E、F 六个版本，结果sa仍然没有搞清楚用户的需求。最后小组长被强行背锅，理由也是十分荒唐，一个运行十年的项目，维护的时候开发人员不能正确理解sa的要求。这强加的理由也是醉了，作为开发人员，按照需求来维护项目，更改的需求本身就是错的，还能怪到开发身上。大公司中很多项目都能拖上个一两年才出来一个版本，项目管理有时候很混乱，部门繁杂，流程拖沓。毕竟不差钱，养的起人，交的起电费。除了台企，也真是没谁了。长此以往，也导致了很多开发人员离职。然后长时间又招收不到合适的替补人员，用大量的实习生来做技术储备，水平又参差不齐，有的毕业了还培训过的却连断点都不知道怎么打，想想真是可笑。这么说来，实力，提升自身实力是第一目标，只有自己强大，才能有底气的强势些，证明自己的存在感，只管糊墙不看图纸的泥瓦匠不是一个好的程序员。   &lt;/p&gt;
&lt;p&gt;     岁月悠悠，每天两点一线的生活，公司-住处，下班闲暇之余买些专业书来啃，唯恐被淘汰，毕竟对公司来说，创造价值与成本比是第一位的。多读书，理想还是要有的，说不定那天就实现了呢，保持一份简单的心，毕竟我们每天都在做着改变世界的事情！！！&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:32:00 +0000</pubDate>
<dc:creator>郎中令</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Sientuo/p/7688257.html</dc:identifier>
</item>
<item>
<title>用FastDFS一步步搭建文件管理系统 - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/fastdfs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/fastdfs.html</guid>
<description>&lt;h2&gt; 一、FastDFS介绍&lt;/h2&gt;
&lt;p&gt;FastDFS开源地址：&lt;a href=&quot;https://github.com/happyfish100&quot; target=&quot;_blank&quot;&gt;https://github.com/happyfish100&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://blog.chinaunix.net/uid-20196318-id-4058561.html&quot; target=&quot;_blank&quot;&gt;分布式文件系统FastDFS设计原理&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/Leo_wl/p/6731647.html&quot; target=&quot;_blank&quot;&gt;FastDFS分布式文件系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;个人封装的FastDFS Java API：&lt;a href=&quot;https://github.com/bojiangzhou/lyyzoo-fastdfs-java&quot; target=&quot;_blank&quot;&gt;https://github.com/bojiangzhou/lyyzoo-fastdfs-java&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1、简介&lt;/h3&gt;
&lt;p&gt;FastDFS 是一个开源的高性能分布式文件系统（DFS）。 它的主要功能包括：文件存储，文件同步和文件访问，以及高容量和负载平衡。主要解决了海量数据存储问题，特别适合以中小文件（建议范围：4KB &amp;lt; file_size &amp;lt;500MB）为载体的在线服务。&lt;/p&gt;
&lt;p&gt;FastDFS 系统有三个角色：跟踪服务器(Tracker Server)、存储服务器(Storage Server)和客户端(Client)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Tracker Server&lt;/strong&gt;：跟踪服务器，主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Storage Server&lt;/strong&gt;：存储服务器，主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Client&lt;/strong&gt;：客户端，上传下载数据的服务器，也就是我们自己的项目所部署在的服务器。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011144153840-1185141903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、FastDFS的存储策略&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。&lt;/p&gt;
&lt;p&gt;在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、FastDFS的上传过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。&lt;/p&gt;
&lt;p&gt;Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。&lt;/p&gt;
&lt;p&gt;当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012121639387-1574147926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4、FastDFS的文件同步&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至同group内其他的storage server。&lt;/p&gt;
&lt;p&gt;每个storage写文件后，同时会写一份binlog，binlog里不包含文件数据，只包含文件名等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有server的时钟保持同步。&lt;/p&gt;
&lt;p&gt;storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5、FastDFS的文件下载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;客户端uploadfile成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/380252/201704/380252-20170415090611017-204910775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟upload file一样，在downloadfile时客户端可以选择任意tracker server。tracker发送download请求给某个tracker，必须带上文件名信息，tracke从文件名中解析出文件的group、大小、创建时间等信息，然后为该请求选择一个storage用来服务读请求。&lt;/p&gt;

&lt;h2&gt;二、安装FastDFS环境&lt;/h2&gt;
&lt;h3&gt;0、前言&lt;/h3&gt;
&lt;p&gt;操作环境：CentOS7 X64，以下操作都是单机环境。&lt;/p&gt;
&lt;p&gt;我把所有的安装包下载到/softpackages/下，解压到当前目录。&lt;/p&gt;
&lt;p&gt;先做一件事，修改hosts，将文件服务器的ip与域名映射(单机TrackerServer环境)，因为后面很多配置里面都需要去配置服务器地址，ip变了，就只需要修改hosts即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/hosts

增加如下一行，这是我的IP
192.168.51.128 file.ljzsg.com

如果要本机访问虚拟机，在C:\Windows\System32\drivers\etc\hosts中同样增加一行
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1、下载安装 libfastcommon&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;libfastcommon是从 FastDFS 和 FastDHT 中提取出来的公共 C 函数库，基础环境，安装即可 。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 下载libfastcommon&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tar -zxvf V1.0.7.tar.gz
# cd libfastcommon-1.0.7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 编译、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# ./make.sh
# ./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ libfastcommon.so 安装到了/usr/lib64/libfastcommon.so，但是FastDFS主程序设置的lib目录是/usr/local/lib，所以需要创建软链接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so
# ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so
# ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so
# ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、下载安装FastDFS&lt;/h3&gt;
&lt;p&gt;① 下载FastDFS&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tar -zxvf V5.05.tar.gz
# cd fastdfs-5.05
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 编译、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# ./make.sh
# ./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;④ 默认安装方式安装后的相应文件与目录&lt;br/&gt;　　A、服务脚本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/init.d/fdfs_storaged
/etc/init.d/fdfs_tracker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　B、配置文件（这三个是作者给的样例配置文件） :&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/fdfs/client.conf.sample
/etc/fdfs/storage.conf.sample
/etc/fdfs/tracker.conf.sample
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　C、命令工具在 /usr/bin/ 目录下：&lt;span class=&quot;fontstyle0&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
fdfs_appender_test
fdfs_appender_test1
fdfs_append_file
fdfs_crc32
fdfs_delete_file
fdfs_download_file
fdfs_file_info
fdfs_monitor
fdfs_storaged
fdfs_test
fdfs_test1
fdfs_trackerd
fdfs_upload_appender
fdfs_upload_file
stop.sh
restart.sh 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ &lt;span class=&quot;fontstyle0&quot;&gt;FastDFS 服务脚本设置的 bin 目录是 /usr/local/bin， 但实际命令安装在 /usr/bin/ 下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　》 一是修改&lt;span class=&quot;fontstyle0&quot;&gt;FastDFS 服务脚本中相应的命令路径，也就是把 &lt;span class=&quot;fontstyle0&quot;&gt;/etc/init.d/fdfs_storaged &lt;span class=&quot;fontstyle0&quot;&gt;和 &lt;span class=&quot;fontstyle0&quot;&gt;/etc/init.d/fdfs_tracker &lt;span class=&quot;fontstyle0&quot;&gt;两个脚本中的 &lt;span class=&quot;fontstyle0&quot;&gt;/usr/local/bin &lt;span class=&quot;fontstyle0&quot;&gt;修改成 &lt;span class=&quot;fontstyle0&quot;&gt;/usr/bin。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;span class=&quot;fontstyle0&quot;&gt;# &lt;span class=&quot;fontstyle0&quot;&gt;vim fdfs_trackerd&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　使用查找替换命令进统一修改:&lt;span class=&quot;fontstyle0&quot;&gt;%s+/usr/local/bin+/usr/bin&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　# &lt;span class=&quot;fontstyle0&quot;&gt;vim fdfs_storaged&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　使用查找替换命令进统一修改:&lt;span class=&quot;fontstyle0&quot;&gt;%s+/usr/local/bin+/usr/bin&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011104718043-576731412.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;140&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　》 二是建立 /usr/bin 到 /usr/local/bin 的软链接，我是用这种方式。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ln -s /usr/bin/fdfs_trackerd   /usr/local/bin
# ln -s /usr/bin/fdfs_storaged   /usr/local/bin
# ln -s /usr/bin/stop.sh         /usr/local/bin
# ln -s /usr/bin/restart.sh      /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、配置FastDFS跟踪器(Tracker)&lt;/h3&gt;
&lt;p&gt;配置文件详细说明参考：&lt;a id=&quot;thread_subject&quot; href=&quot;http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;amp;tid=1941456&amp;amp;extra=page%3D1%26filter%3Ddigest%26digest%3D1&quot; target=&quot;_blank&quot;&gt;FastDFS 配置文件详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;① 进入 /etc/fdfs，复制 FastDFS 跟踪器样例配置文件 tracker.conf.sample，并重命名为 tracker.conf。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /etc/fdfs
# cp tracker.conf.sample tracker.conf
# vim tracker.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 编辑&lt;span class=&quot;fontstyle0&quot;&gt;tracker.conf ，标红的需要修改下，其它的默认即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# 配置文件是否不生效，false 为生效
disabled=false&lt;br/&gt;# 提供服务的端口
port=22122&lt;br/&gt;# Tracker 数据和日志目录地址(根目录必须存在,子目录会自动创建)
&lt;span&gt;base_path=/ljzsg/fastdfs/tracker&lt;br/&gt;&lt;/span&gt;
# HTTP 服务端口
&lt;span&gt;http.server_port=80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 创建tracker基础数据目录，即base_path对应的目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# mkdir -p /ljzsg/fastdfs/tracker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 防火墙中打开跟踪端口（默认的22122）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/sysconfig/iptables&lt;br/&gt;添加如下端口行：
-A INPUT -m state --state NEW -m tcp -p tcp --dport 22122 -j ACCEPT&lt;br/&gt;重启防火墙：
# service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ 启动Tracker&lt;/p&gt;
&lt;p&gt;初次成功启动，会在 /ljzsg/fdfsdfs/tracker/ (配置的base_path)下创建 data、logs 两个目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
可以用这种方式启动
# /etc/init.d/fdfs_trackerd start

也可以用这种方式启动，前提是上面创建了软链接，后面都用这种方式
# service fdfs_trackerd start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;查看 FastDFS Tracker 是否已成功启动 ，22122端口正在被监听，则算是Tracker服务安装成功。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# netstat -unltp|grep fdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011121344184-1089101646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关闭Tracker命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# service fdfs_trackerd stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 设置Tracker开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# chkconfig fdfs_trackerd on&lt;p&gt;或者：&lt;br/&gt;# vim /etc/rc.d/rc.local&lt;br/&gt;加入配置：&lt;br/&gt;/etc/init.d/fdfs_trackerd start 
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ &lt;span class=&quot;fontstyle0&quot;&gt;tracker server &lt;span class=&quot;fontstyle2&quot;&gt;目录及文件结构&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Tracker服务启动成功后，会在base_path下创建data、logs两个目录。目录结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
${base_path}
  |__data
  |   |__storage_groups.dat：存储分组信息
  |   |__storage_servers.dat：存储服务器列表
  |__logs
  |   |__trackerd.log： tracker server 日志文件 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、&lt;span class=&quot;fontstyle0&quot;&gt;配置 FastDFS 存储 (Storage)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;① 进入 /etc/fdfs 目录，&lt;span class=&quot;fontstyle0&quot;&gt;复制 FastDFS 存储器样例配置文件 storage.conf.sample，并重命名为 storage.conf&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /etc/fdfs
# cp storage.conf.sample storage.conf&lt;br/&gt;# vim storage.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 编辑storage.conf&lt;/p&gt;
&lt;p&gt;标红的需要修改，其它的默认即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# 配置文件是否不生效，false 为生效
disabled=false 

# 指定此 storage server 所在 组(卷)
group_name=group1

# storage server 服务端口
port=23000

# 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳)
heart_beat_interval=30

# Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)
&lt;span&gt;base_path=/ljzsg/fastdfs/storage&lt;/span&gt;

# 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。
store_path_count=1


# 逐一配置 store_path_count 个路径，索引号基于 0。
# 如果不配置 store_path0，那它就和 base_path 对应的路径一样。
&lt;span&gt;store_path0=/ljzsg/fastdfs/file&lt;/span&gt;

# FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 
# 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。
subdir_count_per_path=256

# tracker_server 的列表 ，会主动连接 tracker_server
# 有多个 tracker server 时，每个 tracker server 写一行
&lt;span&gt;tracker_server=file.ljzsg.com:22122&lt;/span&gt;# 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。&lt;br/&gt;&lt;span class=&quot;fontstyle0&quot;&gt;sync_start_time=00:00&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;sync_end_time=23:59&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
# 访问端口&lt;br/&gt;&lt;span&gt;http.server_port=80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 创建Storage基础数据目录，对应base_path目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# mkdir -p /ljzsg/fastdfs/storage

# 这是配置的store_path0路径
# mkdir -p /ljzsg/fastdfs/file
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ &lt;span class=&quot;fontstyle0&quot;&gt;防火墙中打开存储器端口（默认的 23000）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/sysconfig/iptables

添加如下端口行：
-A INPUT -m state --state NEW -m tcp -p tcp --dport 23000 -j ACCEPT

重启防火墙：
# service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011133233777-1903096242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ 启动 Storage&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;启动Storage前确保Tracker是启动的。初次启动成功，会在 /ljzsg/fastdfs/storage 目录下创建 data、 logs 两个目录。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
可以用这种方式启动
# /etc/init.d/fdfs_storaged start

也可以用这种方式，后面都用这种
# service fdfs_storaged start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 Storage 是否成功启动，23000 端口正在被监听，就算 Storage 启动成功。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# netstat -unltp|grep fdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011134723387-604894314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关闭Storage命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# service fdfs_storaged stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看Storage和Tracker是否在通信：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/bin/fdfs_monitor /etc/fdfs/storage.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171016093815615-757608481.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;420&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑥ 设置 Storage 开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# chkconfig fdfs_storaged on&lt;/pre&gt;
&lt;pre&gt;
或者：&lt;br/&gt;# vim /etc/rc.d/rc.local&lt;br/&gt;加入配置：&lt;br/&gt;/etc/init.d/fdfs_storaged start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ Storage 目录&lt;/p&gt;
&lt;p&gt;同 Tracker，Storage 启动成功后，在base_path 下创建了data、logs目录，记录着 Storage Server 的信息。&lt;/p&gt;
&lt;p&gt;在 store_path0 目录下，创建了N*N个子目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011135658074-1715166829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、文件上传测试&lt;/h3&gt;
&lt;p&gt;① 修改 Tracker &lt;span class=&quot;fontstyle0&quot;&gt;服务器中的客户端配置文件 &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /etc/fdfs
# cp client.conf.sample client.conf
# vim client.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改如下配置即可，其它默认。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# Client 的数据和日志目录
&lt;span&gt;base_path=/ljzsg/fastdfs/client&lt;/span&gt;

# Tracker端口
&lt;span&gt;tracker_server=file.ljzsg.com:22122&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 上传测试&lt;/p&gt;
&lt;p&gt; 在linux内部执行如下命令上传 namei.jpeg 图片&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf namei.jpeg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上传成功后返回文件ID号：group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011142634105-1857091563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回的文件ID由&lt;span class=&quot;kwd&quot;&gt;group&lt;span class=&quot;pun&quot;&gt;、存储目录、两级子目录、&lt;span class=&quot;pln&quot;&gt;fileid&lt;span class=&quot;pun&quot;&gt;、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011151728965-914197096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、安装Nginx&lt;/h2&gt;
&lt;p&gt;上面将文件上传成功了，但我们无法下载。因此安装Nginx作为服务器以支持Http方式访问文件。同时，后面安装FastDFS的Nginx模块也需要Nginx环境。&lt;/p&gt;
&lt;p&gt;Nginx只需要安装到StorageServer所在的服务器即可，用于访问文件。我这里由于是单机，TrackerServer和StorageServer在一台服务器上。&lt;/p&gt;
&lt;h3&gt;1、安装nginx所需环境　　&lt;/h3&gt;
&lt;p&gt;① gcc 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# yum install gcc-c++
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② PCRE pcre-devel 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# yum install -y pcre pcre-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ zlib 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# yum install -y zlib zlib-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ OpenSSL 安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# yum install -y openssl openssl-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、安装Nginx&lt;/h3&gt;
&lt;p&gt;① 下载nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# wget -c https://nginx.org/download/nginx-1.12.1.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tar -zxvf nginx-1.12.1.tar.gz
# cd nginx-1.12.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 使用默认配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# ./configure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 编译、安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# make
# make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤ 启动nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# cd /usr/local/nginx/sbin/
# ./nginx 

其它命令
# ./nginx -s stop
# ./nginx -s quit
# ./nginx -s reload
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 设置开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# vim /etc/rc.local

添加一行：
/usr/local/nginx/sbin/nginx&lt;p&gt;# 设置执行权限&lt;br/&gt;# &lt;span class=&quot;hljs-keyword&quot;&gt;chmod &lt;span class=&quot;hljs-number&quot;&gt;755 rc.&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑦ 查看nginx的版本及模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/usr/local/nginx/sbin/nginx -V
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011165300730-1693050013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑧ &lt;span class=&quot;fontstyle0&quot;&gt;防火墙中打开Nginx端口（默认的 80） &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;添加后就能在本机使用80端口访问了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# vim /etc/sysconfig/iptables

添加如下端口行：
-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT

重启防火墙：
# service iptables restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011172121746-2118138931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、访问文件&lt;/h3&gt;
&lt;p&gt;简单的测试访问文件&lt;/p&gt;
&lt;p&gt;① 修改nginx.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# vim /usr/local/nginx/conf/nginx.conf

添加如下行，将 /group1/M00 映射到 /ljzsg/fastdfs/file/data
location /group1/M00 {
    alias /ljzsg/fastdfs/file/data;
}&lt;p&gt;# 重启nginx&lt;br/&gt;# /usr/local/nginx/sbin/nginx -s reload
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011180543746-937678567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② 在浏览器访问之前上传的图片、成功。&lt;/p&gt;
&lt;p&gt;http://file.ljzsg.com/group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg&lt;/p&gt;

&lt;h2&gt;四、FastDFS 配置 Nginx 模块&lt;/h2&gt;
&lt;h3&gt;1、安装配置Nginx模块&lt;/h3&gt;
&lt;p&gt;① fastdfs-nginx-module 模块说明&lt;/p&gt;
&lt;p&gt;　　FastDFS 通过 Tracker 服务器，将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进行文件复制， 有同步延迟的问题。&lt;/p&gt;
&lt;p&gt;　　假设 Tracker 服务器将文件上传到了 192.168.51.128，上传成功后文件 ID已经返回给客户端。&lt;/p&gt;
&lt;p&gt;　　此时 FastDFS 存储集群机制会将这个文件同步到同组存储 192.168.51.129，在文件还没有复制完成的情况下，客户端如果用这个文件 ID 在 192.168.51.129 上取文件,就会出现文件无法访问的错误。&lt;/p&gt;
&lt;p&gt;　　而 fastdfs-nginx-module 可以重定向文件链接到源服务器取文件，避免客户端由于复制延迟导致的文件无法访问错误。&lt;/p&gt;
&lt;p&gt;② 下载 fastdfs-nginx-module、解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# 这里为啥这么长一串呢，因为最新版的master与当前nginx有些版本问题。
# wget https://github.com/happyfish100/fastdfs-nginx-module/archive/5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip

# 解压
# unzip 5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip

# 重命名
# mv fastdfs-nginx-module-5e5f3566bbfa57418b5506aaefbe107a42c9fcb1  fastdfs-nginx-module-master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 配置Nginx&lt;/p&gt;
&lt;p&gt;在nginx中添加模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
# 先停掉nginx服务&lt;br/&gt;# /usr/local/nginx/sbin/ngix -s stop&lt;p&gt;进入解压包目录
# cd /softpackages/nginx-1.12.1/

# 添加模块
# ./configure --add-module=../fastdfs-nginx-module-master/src

重新编译、安装
# make &amp;amp;&amp;amp; make install
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ④ 查看Nginx的模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# /usr/local/nginx/sbin/nginx -V
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有下面这个就说明添加模块成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011224125574-1739252073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑤ 复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
# cd /softpackages/fastdfs-nginx-module-master/src&lt;p&gt;# cp mod_fastdfs.conf /etc/fdfs/
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改如下配置，其它默认&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# 连接超时时间&lt;/span&gt;&lt;br/&gt;connect_timeout=10&lt;/span&gt;

# Tracker Server
&lt;span&gt;tracker_server=file.ljzsg.com:22122&lt;/span&gt;
&lt;br/&gt;# StorageServer 默认端口
storage_server_port=23000

# 如果文件ID的uri中包含/group**，则要设置为true
&lt;span&gt;url_have_group_name = true&lt;/span&gt;

# Storage 配置的store_path0路径，必须和storage.conf中的一致
&lt;span&gt;store_path0=/ljzsg/fastdfs/file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 复制 FastDFS 的部分配置文件到/etc/fdfs 目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# cd /softpackages/fastdfs-5.05/conf/

# cp anti-steal.jpg http.conf mime.types /etc/fdfs/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ⑦ 配置nginx，修改nginx.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# vim /usr/local/nginx/conf/nginx.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改配置，其它的默认&lt;/p&gt;
&lt;p&gt;在80端口下添加fastdfs-nginx模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
location ~/group([0-9])/M00 {
    ngx_fastdfs_module;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011184247777-40074297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　listen 80 &lt;span class=&quot;fontstyle0&quot;&gt;端口值是要与 &lt;span class=&quot;fontstyle0&quot;&gt;/etc/fdfs/storage.conf &lt;span class=&quot;fontstyle0&quot;&gt;中的 &lt;span class=&quot;fontstyle0&quot;&gt;http.server_port=80 (前面改成80了)&lt;span class=&quot;fontstyle0&quot;&gt;相对应。如果改成其它端口，则需要统一，同时在防火墙中打开该端口。&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;　　location 的配置，如果有多个group则配置&lt;span class=&quot;fontstyle0&quot;&gt;location &lt;span class=&quot;fontstyle0&quot;&gt;~/group([0-9])/M00 ，没有则不用配group。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑧ &lt;span class=&quot;fontstyle0&quot;&gt;在/ljzsg/fastdfs/file 文件存储目录下创建软连接，将其链接到实际存放数据的目录，这一步可以省略。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# ln -s /ljzsg/fastdfs/file/data/ /ljzsg/fastdfs/file/data/M00 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑨ 启动nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# /usr/local/nginx/sbin/nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印处如下就算配置成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171011230509512-654301113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑩ 在地址栏访问。&lt;/p&gt;
&lt;p&gt;能下载文件就算安装成功。注意和第三点中直接使用nginx路由访问不同的是，这里配置 fastdfs-nginx-module 模块，可以重定向文件链接到源服务器取文件。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;http://file.ljzsg.com/group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;最终部署结构图(盗的图)：可以按照下面的结构搭建环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012180511480-692747720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、Java客户端&lt;/h2&gt;
&lt;p&gt;前面文件系统平台搭建好了，现在就要写客户端代码在系统中实现上传下载，这里只是简单的测试代码。&lt;/p&gt;
&lt;h3&gt;1、首先需要搭建 FastDFS 客户端Java开发环境&lt;/h3&gt;
&lt;p&gt;① 项目中使用maven进行依赖管理，可以在pom.xml中引入如下依赖即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;net.oschina.zcx7878&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;fastdfs-client-java&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.27.0.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它的方式，参考官方文档：https://github.com/happyfish100/fastdfs-client-java&lt;/p&gt;
&lt;p&gt;② 引入配置文件&lt;/p&gt;
&lt;p&gt;可直接复制包下的 fastdfs-client.properties.sample 或者 fdfs_client.conf.sample，到你的项目中，去掉.sample。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012112805371-395330483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里直接复制 fastdfs-client.properties.sample 中的配置到项目配置文件 config.properties 中，修改tracker_servers。只需要加载这个配置文件即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/856154/201710/856154-20171012120004199-247798219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、客户端API&lt;/h3&gt;
&lt;p&gt;个人封装的FastDFS Java API以同步到github：&lt;a href=&quot;https://github.com/bojiangzhou/lyyzoo-fastdfs-java.git&quot; target=&quot;_blank&quot;&gt;https://github.com/bojiangzhou/lyyzoo-fastdfs-java.git&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;六、权限控制&lt;/h3&gt;
&lt;p&gt;前面使用nginx支持http方式访问文件，但所有人都能直接访问这个文件服务器了，所以做一下权限控制。&lt;/p&gt;
&lt;p&gt;FastDFS的权限控制是在服务端开启token验证，客户端根据文件名、当前unix时间戳、秘钥获取token，在地址中带上token参数即可通过http方式访问文件。&lt;/p&gt;
&lt;p&gt;① 服务端开启token验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
修改http.conf
# vim /etc/fdfs/http.conf

设置为true表示开启token验证
&lt;span readability=&quot;2&quot;&gt;http.anti_steal.check_token=true&lt;p&gt;&lt;span&gt;设置token失效的时间单位为秒(s)&lt;/span&gt;&lt;br/&gt;http.anti_steal.token_ttl=1800&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
密钥，跟客户端配置文件的fastdfs.http_secret_key保持一致
&lt;span&gt;http.anti_steal.secret_key=FASTDFS1234567890&lt;/span&gt;

如果token检查失败，返回的页面
&lt;span&gt;http.anti_steal.token_check_fail=/ljzsg/fastdfs/page/403.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得重启服务。&lt;/p&gt;
&lt;p&gt;② 配置客户端&lt;/p&gt;
&lt;p&gt;客户端只需要设置如下两个参数即可，两边的密钥保持一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# token 防盗链功能
fastdfs.http_anti_steal_token=true
# 密钥
fastdfs.http_secret_key=FASTDFS1234567890
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 客户端生成token&lt;/p&gt;
&lt;p&gt;访问文件需要带上生成的token以及unix时间戳，所以返回的token是token和时间戳的拼接。&lt;/p&gt;
&lt;p&gt;之后，将token拼接在地址后即可访问：file.ljzsg.com/group1/M00/00/00/wKgzgFnkaXqAIfXyAAEoRmXZPp878.jpeg?token=078d370098b03e9020b82c829c205e1f&amp;amp;ts=1508141521&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 获取访问服务器的token，拼接到地址后面
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; filepath 文件路径 group1/M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; httpSecretKey 密钥
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回token，如： token=078d370098b03e9020b82c829c205e1f&amp;amp;ts=1508141521
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getToken(String filepath, String httpSecretKey){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unix seconds&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; ts = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) Instant.now().getEpochSecond();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; token&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         String token = &quot;null&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             token =&lt;span&gt; ProtoCommon.getToken(getFilename(filepath), ts, httpSecretKey);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnsupportedEncodingException e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchAlgorithmException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (MyException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         StringBuilder sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         sb.append(&quot;token=&quot;&lt;span&gt;).append(token);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         sb.append(&quot;&amp;amp;ts=&quot;&lt;span&gt;).append(ts);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.toString();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 注意事项&lt;/p&gt;
&lt;p&gt;如果生成的token验证无法通过，请进行如下两项检查：&lt;br/&gt;　　A. 确认调用token生成函数(ProtoCommon.getToken)，传递的文件ID中没有包含group name。传递的文件ID格式形如：M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg&lt;/p&gt;
&lt;p&gt;　　B. 确认服务器时间基本是一致的，注意服务器时间不能相差太多，不要相差到分钟级别。&lt;/p&gt;
&lt;p&gt;⑤ 对比下发现，如果系统文件隐私性较高，可以直接通过fastdfs-client提供的API去访问即可，不用再配置Nginx走http访问。配置Nginx的主要目的是为了快速访问服务器的文件(如图片)，如果还要加权限验证，则需要客户端生成token，其实已经没有多大意义。&lt;/p&gt;
&lt;p&gt;关键是，这里我没找到FastDFS如何对部分资源加token验证，部分开放。有知道的还请留言。&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;OK，以上就是单机中使用FastDFS搭建文件系统并上传下载的过程。&lt;/p&gt;
&lt;p&gt;完！！！&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:24:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chiangchou/p/fastdfs.html</dc:identifier>
</item>
<item>
<title>Java集合源码分析（二）Linkedlist - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7688304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7688304.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面一篇我们分析了ArrayList的源码，这一篇分享的是LinkedList。我们都知道它的底层是由链表实现的，所以我们要明白什么是链表？&lt;/p&gt;

&lt;h2&gt;1.1、LinkedList概述&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018185451506-2136799134.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　LinkedList是一种可以在&lt;span&gt;任何位置进行高效地插入和移除操作的有序序列，它是基于双向链表实现的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。&lt;br/&gt;　　LinkedList 实现 List 接口，能对它进行队列操作。&lt;br/&gt;　　LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。&lt;br/&gt;　　LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。&lt;br/&gt;　　LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。&lt;br/&gt;　　LinkedList 是非同步的。&lt;/p&gt;
&lt;h2&gt;1.2、LinkedList的数据结构&lt;/h2&gt;
&lt;p&gt;　　1）基础知识补充&lt;/p&gt;
&lt;p&gt;　　　　1.1）单向链表：&lt;/p&gt;
&lt;p&gt;　　　　　　element：用来存放元素&lt;/p&gt;
&lt;p&gt;　　　　　　next：用来指向下一个节点元素&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;span&gt;通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018163705615-546509635.png&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.2）单向循环链表&lt;/p&gt;
&lt;p&gt;　　　　　　element、next 跟前面一样&lt;/p&gt;
&lt;p&gt;　　　　　　在&lt;span&gt;单向链表的最后一个节点的next会指向头节点，而不是指向null，这样存成一个环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018163849318-946854643.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.3）双向链表&lt;/p&gt;
&lt;p&gt;　　　　　　element：存放元素&lt;/p&gt;
&lt;p&gt;　　　　　　pre：用来指向前一个元素&lt;/p&gt;
&lt;p&gt;　　　　　　next：指向后一个元素&lt;/p&gt;
&lt;p&gt;　　　　　　双向链表是&lt;span&gt;包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018164025990-1035906814.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.4）双向循环链表&lt;/p&gt;
&lt;p&gt;　　　　　　element、pre、next 跟前面的一样&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;　第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018164246521-25397602.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）LinkedList的数据结构&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018164511396-1020210450.png&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　如上图所示，&lt;span&gt;LinkedList底层使用的双向链表结构&lt;/span&gt;，有一个头结点和一个尾结点，双向链表意味着我们可以从头开始正向遍历，或者是从尾开始逆向遍历，并且可以针对头部和尾部进行相应的操作。&lt;/p&gt;
&lt;h2&gt;1.3、LinkedList的特性&lt;/h2&gt;
&lt;p&gt;　　在我们平常中我们只知道一些常识性的特点：&lt;/p&gt;
&lt;p&gt;　　　　1）是通过链表实现的，&lt;/p&gt;
&lt;p&gt;　　　　2）如果在频繁的插入，或者删除数据时，就用linkedList性能会更好。&lt;/p&gt;
&lt;p&gt;　　那我们通过API去查看它的一些特性&lt;/p&gt;
&lt;p&gt;　　　　1）Doubly-linked list implementation of the &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Deque&lt;/code&gt; interfaces. Implements all optional list operations, and permits all elements (including &lt;code&gt;null&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;　　　　　　这告诉我们，&lt;span&gt;linkedList是一个双向链表，并且实现了List和Deque接口中所有的列表操作&lt;/span&gt;，&lt;span&gt;并且能存储任何元素，包括null&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　　　这里我们可以知道linkedList除了可以&lt;span&gt;当链表使用，还可以当作队列使用&lt;/span&gt;，并能进行相应的操作。&lt;/p&gt;
&lt;p&gt;　　　　2）All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.&lt;/p&gt;
&lt;p&gt;　　　　　　这个告诉我们，&lt;span&gt;linkedList在执行任何操作的时候，都必须先遍历此列表来靠近通过index查找我们所需要的的值&lt;/span&gt;。通俗点讲，这就告诉了我们这个是&lt;span&gt;顺序存取，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　每次操作必须先按开始到结束的顺序遍历，随机存取，就是arrayList，能够通过index。随便访问其中的任意位置的数据，这就是随机列表的意思&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　3）api中接下来讲的一大堆，就是说明&lt;span&gt;linkedList是一个非线程安全的(异步)&lt;/span&gt;，其中在操作Interator时，如果改变列表结构(add\delete等)，会发生fail-fast。&lt;/p&gt;
&lt;p&gt;　　通过API再次总结一下LinkedList的特性：　　&lt;/p&gt;
&lt;p&gt;　　　　1）异步，也就是非线程安全&lt;/p&gt;
&lt;p&gt;　　　　2）双向链表。由于实现了list和Deque接口，能够当作队列来使用。&lt;/p&gt;
&lt;p&gt;　　　　　　链表：查询效率不高，但是插入和删除这种操作性能好。&lt;/p&gt;
&lt;p&gt;　　　　3）是顺序存取结构（注意和随机存取结构两个概念搞清楚）&lt;/p&gt;

&lt;h2&gt;2.1、LinkedList的继承结构以及层次关系&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018170001771-1514436408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　我们可以看到，linkedList在最底层，说明他的功能最为强大，并且细心的还会发现，arrayList只有四层，这里多了一层AbstractSequentialList的抽象类，为什么呢？&lt;/p&gt;
&lt;p&gt;　　　　通过API我们会发现：&lt;/p&gt;
&lt;p&gt;　　　　　　1）减少实现顺序存取（例如LinkedList）这种类的工作，通俗的讲就是方便，抽象出类似LinkedList这种类的一些共同的方法&lt;/p&gt;
&lt;p&gt;　　　　　　2）既然有了上面这句话，那么以后如果自己想&lt;span&gt;实现顺序存取这种特性的类(就是链表形式)，那么就继承这个AbstractSequentialList抽象类&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果想像&lt;span&gt;数组那样的随机存取的类，那么就去实现AbstracList抽象类&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　　　3）这样的分层，就很符合我们抽象的概念，&lt;span&gt;越在高处的类，就越抽象，往在底层的类，就越有自己独特的个性&lt;/span&gt;。自己要慢慢领会这种思想。&lt;/p&gt;
&lt;p&gt;　　　　　　4）LinkedList的类继承结构很有意思，我们着重要看是&lt;span&gt;Deque接口，Deque接口表示是一个双端队列，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　那么也意味着LinkedList是双端队列的一种实现，所以，基于双端队列的操作在LinkedList中全部有效&lt;/span&gt;。　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7be78dd2-b633-49d5-943c-9659bf688715')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_7be78dd2-b633-49d5-943c-9659bf688715&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7be78dd2-b633-49d5-943c-9659bf688715&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7be78dd2-b633-49d5-943c-9659bf688715',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7be78dd2-b633-49d5-943c-9659bf688715&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractSequentialList&amp;lt;E&amp;gt;&lt;span&gt;
extends AbstractList&lt;/span&gt;&amp;lt;E&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里第一段就解释了这个类的作用，这个类为实现list接口提供了一些重要的方法，
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尽最大努力去减少实现这个“顺序存取”的特性的数据存储(例如链表)的什么鬼，对于
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机存取数据(例如数组)的类应该优先使用AbstractList
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从上面就可以大概知道，AbstractSwquentialList这个类是为了减少LinkedList这种顺&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序存取的类的代码复杂度而抽象的一个类，&lt;/span&gt;
This &lt;span&gt;class&lt;/span&gt; provides a skeletal implementation of the List &lt;span&gt;interface&lt;/span&gt; to minimize the effort required to implement &lt;span&gt;this&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; backed by a &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sequential access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data store (such &lt;span&gt;as&lt;/span&gt; a linked list). For random access data (such &lt;span&gt;as&lt;/span&gt; an array), AbstractList should be used &lt;span&gt;in&lt;/span&gt; preference to &lt;span&gt;this&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一段大概讲的就是这个AbstractSequentialList这个类和AbstractList这个类是完全&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相反的。比如get、add这个方法的实现&lt;/span&gt;
This &lt;span&gt;class&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; the opposite of the AbstractList &lt;span&gt;class&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; the sense that it implements the &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;random access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; methods (&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index), &lt;span&gt;set&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element), add(&lt;span&gt;int&lt;/span&gt; index, E element) and remove(&lt;span&gt;int&lt;/span&gt; index)) on top of the list&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s list iterator, instead of the other way around.&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就是讲一些我们自己要继承该类，该做些什么事情，一些规范。&lt;/span&gt;
To implement a list the programmer needs only to extend &lt;span&gt;this&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; and provide implementations &lt;span&gt;for&lt;/span&gt; the listIterator and size methods. For an unmodifiable list, the programmer need only implement the list iterator&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s hasNext, next, hasPrevious, previous and index methods.&lt;/span&gt;
&lt;span&gt;
For a modifiable list the programmer should additionally implement the list iterator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s set method. For a variable-size list the programmer should additionally implement the list iterator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s remove and add methods.

The programmer should generally provide a &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (no argument) and collection constructor, &lt;span&gt;as&lt;/span&gt; per the recommendation &lt;span&gt;in&lt;/span&gt; the Collection &lt;span&gt;interface&lt;/span&gt; specification.
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;AbstractSequentialList&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　实现接口分析：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018171102756-1197666604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　1）List接口：列表，add、set、等一些对列表进行操作的方法&lt;/p&gt;
&lt;p&gt;　　　　　　2）Deque接口：有队列的各种特性，&lt;/p&gt;
&lt;p&gt;　　　　　　3）Cloneable接口：能够复制，使用那个copy方法。&lt;/p&gt;
&lt;p&gt;　　　　　　4）Serializable接口：能够序列化。&lt;/p&gt;
&lt;p&gt;　　　　　　5）应该注&lt;span&gt;意到没有RandomAccess：那么就推荐使用iterator，在其中就有一个foreach，增强的for循环，其中原理也就是iterator，我们在使用的时候，使用foreach或者iterator都可以&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;2.2、类的属性　　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt;
    extends AbstractSequentialList&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt;
    implements List&lt;/span&gt;&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实际元素个数&lt;/span&gt;
    transient &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头结点&lt;/span&gt;
    transient Node&amp;lt;E&amp;gt;&lt;span&gt; first;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾结点&lt;/span&gt;
    transient Node&amp;lt;E&amp;gt;&lt;span&gt; last;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　LinkedList的属性非常简单，&lt;span&gt;一个头结点、一个尾结点、一个表示链表中实际元素个数的变量&lt;/span&gt;。注意，&lt;span&gt;头结点、尾结点都有transient关键字修饰，这也意味着在序列化时该域是不会序列化的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.3、LinkedList的构造方法&lt;/h2&gt;
&lt;p&gt;　　两个构造方法(两个构造方法都是规范规定需要写的）&lt;/p&gt;
&lt;p&gt;　　1）空参构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Constructs an empty list.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedList() {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）有参构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param  c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;   //&lt;/span&gt;&lt;span&gt;将集合c中的各个元素构建成LinkedList链表。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedList(Collection&amp;lt;? extends E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
     // 调用无参构造函数
        this();
        // 添加集合中所有的元素
        addAll(c);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：会调用无参构造函数，并且会把集合中所有的元素添加到LinkedList中。　　　&lt;/p&gt;
&lt;h2&gt;2.4、内部类（Node）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
//根据前面介绍双向链表就知道这个代表什么了，linkedList的奥秘就在这里。
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据域（当前节点的值）&lt;/span&gt;
        Node&amp;lt;E&amp;gt; next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后继（指向当前一个节点的后一个节点）&lt;/span&gt;
        Node&amp;lt;E&amp;gt; prev; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱（指向当前节点的前一个节点）
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数，赋值前驱后继&lt;/span&gt;
        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　说明：内部类Node就是实际的结点，用于存放实际元素的地方。　　　　　&lt;/p&gt;
&lt;h2&gt; 2.5、核心方法&lt;/h2&gt;
&lt;h3&gt;　　2.5.1、add()方法&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018180421865-139109156.png&quot; alt=&quot;&quot; width=&quot;288&quot; height=&quot;126&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　1）add(E)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 　　 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean add(E e) {
       　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加到末尾&lt;/span&gt;
&lt;span&gt;        　　linkLast(e);
        　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  　　  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：add函数&lt;span&gt;用于向LinkedList中添加一个元素，并且添加到链表尾部。具体添加到尾部的逻辑是由linkLast函数完成的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　分析：&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;　LinkLast(XXXXX)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Links e as last element.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; l = last;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;临时节点l(L的小写)保存last，也就是l指向了最后一个节点&lt;/span&gt;
        final Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将e封装为节点，并且e.prev指向了最后一个节点&lt;/span&gt;
        last = newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newNode成为了最后一个节点，所以last指向了它&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是不是一开始链表中就什么都没有，如果没有，则newNode就成为了第一个节点，first和last都要指向它&lt;/span&gt;
            first =&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常的在最后一个节点后追加，那么原先的最后一个节点的next就要指向现在真正的最后一个节点，原先的最后一个节点就变成了倒数第二个节点&lt;/span&gt;
            l.next =&lt;span&gt; newNode;
        size&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个节点，size自增&lt;/span&gt;
        modCount++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：对于&lt;span&gt;添加一个元素至链表中会调用add方法 -&amp;gt; linkLast方法&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　举例一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　List&amp;lt;Integer&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
　　　　lists.add(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
　　　　lists.add(&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　首先调用无参构造函数，之后添加元素5，之后再添加元素6。具体的示意图如下：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018180943006-1444550237.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　上图的表明了在执行每一条语句后，链表对应的状态。&lt;/p&gt;
&lt;h3&gt;　　2.5.2、addAll方法&lt;/h3&gt;
&lt;p&gt;　　　　addAll有两个重载函数，addAll(Collection&amp;lt;? extends E&amp;gt;)型和addAll(int, Collection&amp;lt;? extends E&amp;gt;)型，我们平时习惯调用的addAll(Collection&amp;lt;? extends E&amp;gt;)型会转化为addAll(int, Collection&amp;lt;? extends E&amp;gt;)型。&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;　1）addAll(c);&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; boolean addAll(Collection&amp;lt;? extends E&amp;gt;&lt;span&gt; c) {
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继续往下看&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; addAll(size, c);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;　　2）addAll(size，c)：这个方法，能包含三种情况下的添加，我们这里分析的只是构造方法，空链表的情况(情况一)看的时候只需要按照不同的情况分析下去就行了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;真正核心的地方就是这里了，记得我们传过来的是size，c&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; boolean addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? extends E&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查index这个是否为合理。这个很简单，自己点进去看下就明白了。&lt;/span&gt;
&lt;span&gt;        checkPositionIndex(index);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将集合c转换为Object数组 a&lt;/span&gt;
        Object[] a =&lt;span&gt; c.toArray();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组a的长度numNew，也就是由多少个元素&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; numNew =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numNew == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集合c是个空的，直接返回false，什么也不做。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;集合c是非空的，定义两个节点(内部类)，每个节点都有三个属性，item、next、prev。注意：不要管这两个什么含义，就是用来做临时存储节点的。这个Node看下面一步的源码分析，Node就是linkedList的最核心的实现，可以直接先跳下一个去看Node的分析&lt;/span&gt;
        Node&amp;lt;E&amp;gt;&lt;span&gt; pred, succ;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法中传过来的就是index==size&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;linkedList中三个属性：size、first、last。 size：链表中的元素个数。 first：头节点  last：尾节点，就两种情况能进来这里

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况一、：构造方法创建的一个空的链表，那么size=0，last、和first都为null。linkedList中是空的。什么节点都没有。succ=null、pred=last=null

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况二、：链表中有节点，size就不是为0，first和last都分别指向第一个节点，和最后一个节点，在最后一个节点之后追加元素，就得记录一下最后一个节点是什么，所以把last保存到pred临时节点中。&lt;/span&gt;
            succ = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            pred &lt;/span&gt;=&lt;span&gt; last;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;情况三、index！=size，说明不是前面两种情况，而是在链表中间插入元素，那么就得知道index上的节点是谁，保存到succ临时节点中，然后将succ的前一个节点保存到pred中，这样保存了这两个节点，就能够准确的插入节点了
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;举个简单的例子，有2个位置，1、2、如果想插数据到第二个位置，双向链表中，就需要知道第一个位置是谁，原位置也就是第二个位置上是谁，然后才能将自己插到第二个位置上。如果这里还不明白，先看一下文章开头对于各种链表的删除，add操作是怎么实现的。&lt;/span&gt;
            succ =&lt;span&gt; node(index);
            pred &lt;/span&gt;=&lt;span&gt; succ.prev;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面的准备工作做完了，将遍历数组a中的元素，封装为一个个节点。&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : a) {
            @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) E e =&lt;span&gt; (E) o;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pred就是之前所构建好的，可能为null、也可能不为null，为null的话就是属于情况一、不为null则可能是情况二、或者情况三&lt;/span&gt;
            Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(pred, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果pred==null，说明是情况一，构造方法，是刚创建的一个空链表，此时的newNode就当作第一个节点，所以把newNode给first头节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                first &lt;/span&gt;=&lt;span&gt; newNode;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果pred！=null，说明可能是情况2或者情况3，如果是情况2，pred就是last，那么在最后一个节点之后追加到newNode，如果是情况3，在中间插入，pred为原index节点之前的一个节点，将它的next指向插入的节点，也是对的&lt;/span&gt;
                pred.next =&lt;span&gt; newNode;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后将pred换成newNode，注意，这个不在else之中，请看清楚了。&lt;/span&gt;
            pred =&lt;span&gt; newNode;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (succ == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果succ==null，说明是情况一或者情况二，&lt;/span&gt;
情况一、构造方法，也就是刚创建的一个空链表，pred已经是newNode了，last=&lt;span&gt;newNode，所以linkedList的first、last都指向第一个节点。
情况二、在最后节后之后追加节点，那么原先的last就应该指向现在的最后一个节点了，就是newNode。
            last &lt;/span&gt;=&lt;span&gt; pred;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果succ！=null，说明可能是情况三、在中间插入节点，举例说明这几个参数的意义，有1、2两个节点，现在想在第二个位置插入节点newNode，根据前面的代码，pred=newNode，succ=2，并且1.next=newNode，&lt;/span&gt;
1已经构建好了，pred.next=succ，相当于在newNode.next = &lt;span&gt;2&lt;/span&gt;； succ.prev = pred，相当于 &lt;span&gt;2&lt;/span&gt;.prev =&lt;span&gt; newNode， 这样一来，这种指向关系就完成了。first和last不用变，因为头节点和尾节点没变
            pred.next &lt;/span&gt;=&lt;span&gt; succ;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;。。&lt;/span&gt;
            succ.prev =&lt;span&gt; pred;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加了几个元素，就把 size = size +numNew 就可以了&lt;/span&gt;
        size +=&lt;span&gt; numNew;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：参数中的index表示在索引下标为index的结点（实际上是第index + 1个结点）的前面插入。　　　　　&lt;/p&gt;
&lt;p&gt;　　　　　　　在addAll函数中，addAll函数中还会调用到node函数，get函数也会调用到node函数，此函数是根据索引下标找到该结点并返回，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断插入的位置在链表前半段或者是后半段&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入位置在前半段&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; first; 
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从头结点开始正向遍历&lt;/span&gt;
                x =&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该结点&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入位置在后半段&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; last; 
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从尾结点开始反向遍历&lt;/span&gt;
                x =&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回该结点&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　说明：在根据索引查找结点时，会有一个小优化，结点在前半段则从头开始遍历，在后半段则从尾开始遍历，这样就保证了只需要遍历最多一半结点就可以找到指定索引的结点。&lt;/p&gt;
&lt;p&gt;　　　　举例说明调用addAll函数后的链表状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
　　　　List&amp;lt;Integer&amp;gt; lists = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
　　　　lists.add(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
　　　　lists.addAll(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, Arrays.asList(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　上述代码内部的链表结构如下：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018183422099-2095962383.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　addAll()中的一个问题&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　　　在addAll函数中，传入一个集合参数和插入位置，然后将集合转化为数组，然后再遍历数组，挨个添加数组的元素，但是问题来了，为什么要先转化为数组再进行遍历，而不是直接遍历集合呢？&lt;/p&gt;
&lt;p&gt;　　　　从效果上两者是完全等价的，都可以达到遍历的效果。关于为什么要转化为数组的问题，我的思考如下：1. 如果直接遍历集合的话，那么在遍历过程中需要插入元素，在堆上分配内存空间，修改指针域，&lt;/p&gt;
&lt;p&gt;　　　　这个过程中就会一直占用着这个集合，考虑正确同步的话，其他线程只能一直等待。2. 如果转化为数组，只需要遍历集合，而遍历集合过程中不需要额外的操作，&lt;/p&gt;
&lt;p&gt;　　　　所以占用的时间相对是较短的，这样就利于其他线程尽快的使用这个集合。说白了，就是有利于提高多线程访问该集合的效率，尽可能短时间的阻塞。&lt;/p&gt;
&lt;h3&gt;　　2.5.3、remove(Object o)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Removes the first occurrence of the specified element from this list,
     * if it is present.  If this list does not contain the element, it is
     * unchanged.  More formally, removes the element with the lowest index
     * {@code i} such that
     * &amp;lt;tt&amp;gt;(o==null&amp;amp;nbsp;?&amp;amp;nbsp;get(i)==null&amp;amp;nbsp;:&amp;amp;nbsp;o.equals(get(i)))&amp;lt;/tt&amp;gt;
     * (if such an element exists).  Returns {@code true} if this list
     * contained the specified element (or equivalently, if this list
     * changed as a result of the call).
     *
     * @param o element to be removed from this list, if present
     * @return {@code true} if this list contained the specified element
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先通过看上面的注释，我们可以知道，如果我们要移除的值在链表中存在多个一样的值，那么我们会移除index最小的那个，也就是最先找到的那个值，如果不存在这个值，那么什么也不做&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean remove(Object o) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以看到，linkedList也能存储null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历链表，直到找到null值，然后使用unlink移除该值。下面的这个else中也一样&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　unlink(xxxx)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Unlinks non-null node x.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能传一个null值过，注意，看之前要注意之前的next、prev这些都是谁。&lt;/span&gt;
    E unlink(Node&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert x != null;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到节点x的三个属性&lt;/span&gt;
        final E element =&lt;span&gt; x.item;
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        final Node&lt;/span&gt;&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里开始往下就进行移除该元素之后的操作，也就是把指向哪个节点搞定。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明移除的节点是头节点，则first头节点应该指向下一个节点&lt;/span&gt;
            first =&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是头节点，prev.next=next：有1、2、3，将1.next指向3&lt;/span&gt;
            prev.next =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后解除x节点的前指向。&lt;/span&gt;
            x.prev = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明移除的节点是尾节点&lt;/span&gt;
            last =&lt;span&gt; prev;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是尾节点，有1、2、3，将3.prev指向1. 然后将2.next=解除指向。&lt;/span&gt;
            next.prev =&lt;span&gt; prev;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x的前后指向都为null了，也把item为null，让gc回收它&lt;/span&gt;
        x.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除一个节点，size自减&lt;/span&gt;
        modCount++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; element;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于一开始已经保存了x的值到element，所以返回。&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.5.4、get(index)&lt;/h3&gt;
&lt;p&gt;　　　&lt;span&gt;　get(index)查询元素的方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns the element at the specified position in this list.
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException {@inheritDoc}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里没有什么，重点还是在node(index)中&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　　node(index)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Returns the (non-null) Node at the specified element index.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里查询使用的是先从中间分一半查找&lt;/span&gt;
    Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;&amp;lt;&amp;lt;&quot;:*2的几次方 “&amp;gt;&amp;gt;”:/2的几次方，例如：size&amp;lt;&amp;lt;1：size*2的1次方，
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个if中就是查询前半部分&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index&amp;lt;size/2&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; index; i++&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前半部分没找到，所以找后半部分&lt;/span&gt;
            Node&amp;lt;E&amp;gt; x =&lt;span&gt; last;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - &lt;span&gt;1&lt;/span&gt;; i &amp;gt; index; i--&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2.5.5、indexOf(Object o)&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个很简单，就是通过实体元素来查找到该元素在链表中的位置。跟remove中的代码类似，只是返回类型不一样。&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在LinkedList中除了有一个Node的内部类外，应该还能看到另外两个内部类，那就是ListItr，还有一个是DescendingIterator。&lt;/p&gt;
&lt;h2&gt;　　3.1、ListItr内部类&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018184723521-1419677680.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;23&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　看一下他的继承结构，发现只继承了一个ListIterator，到ListIterator中一看：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018184923443-1278868049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　看到方法名之后，就发现不止有向后迭代的方法，还有向前迭代的方法，所以我们就知道了这个ListItr这个内部类干嘛用的了，就是能让linkedList不光能像后迭代，也能向前迭代。&lt;/p&gt;
&lt;p&gt; 　　　　看一下ListItr中的方法，可以发现，在迭代的过程中，还能移除、修改、添加值得操作。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171018184651412-1550358605.png&quot; alt=&quot;&quot; width=&quot;281&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　3.2、DescendingIterator内部类　　　　&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * Adapter to provide descending iterators via ListItr.previous
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
　　　　&lt;span&gt;看一下这个类，还是调用的ListItr，作用是封装一下Itr中几个方法，让使用者以正常的思维去写代码，例如，在从后往前遍历的时候，也是跟从前往后遍历一样，使用next等操作，而不用使用特殊的previous。
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DescendingIterator implements Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; final ListItr itr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(size());
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.hasPrevious();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.previous();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            itr.remove();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　1）linkedList本质上是&lt;span&gt;一个双向链表，通过一个Node内部类实现的这种链表结构&lt;/span&gt;。&lt;br/&gt;　　2）能&lt;span&gt;存储null值&lt;/span&gt;&lt;br/&gt;　　3）跟&lt;span&gt;arrayList相比较，就真正的知道了，LinkedList在删除和增加等操作上性能好，而ArrayList在查询的性能上好&lt;/span&gt;&lt;br/&gt;　　4）从源码中看，&lt;span&gt;它不存在容量不足的情况&lt;/span&gt;&lt;br/&gt;　　5）linkedList不光&lt;span&gt;能够向前迭代，还能像后迭代，并且在迭代的过程中，可以修改值、添加值、还能移除值&lt;/span&gt;。&lt;br/&gt;　　6）linkedList不光能&lt;span&gt;当链表，还能当队列使用，这个就是因为实现了Deque接口&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;喜欢就点个“推荐”！&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:18:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7688304.html</dc:identifier>
</item>
<item>
<title>JavaScript中的this基本问题 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7689783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7689783.html</guid>
<description>&lt;p&gt;在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。 &lt;/p&gt;
&lt;p&gt;执行上下文环境 ：&lt;/p&gt;
&lt;p&gt; **定义**：执行函数的时候，会产生一个上下文的对象，里面保存变量，函数声明和this。&lt;/p&gt;
&lt;p&gt; **作用**：用来保存本次运行时所需要的数据&lt;/p&gt;
&lt;p&gt;当你在代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。&lt;/p&gt;
&lt;p&gt;关于 this 的取值，大体上可以分为以下几种情况：&lt;/p&gt;
&lt;h2&gt;情况一：全局 &amp;amp; 调用普通函数&lt;/h2&gt;
&lt;p&gt;在全局环境中，this 永远指向 window。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(&lt;span&gt;this&lt;/span&gt; === window);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。&lt;/p&gt;
&lt;p&gt;但是如果在严格模式下调用的话会报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
function first(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught TypeError: Cannot read property 'x' of undefined&lt;/span&gt;
&lt;span&gt;}
first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;情况二：构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;First {x:1}&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; First();
console.log(first.x);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。&lt;/p&gt;
&lt;p&gt;但是如果直接调用 First函数，而不是 new First()，那就变成情况1，这时候 First() 就变成普通函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =1&lt;span&gt;;
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first =&lt;span&gt; First();
console.log(first.x);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;情况三：对象方法&lt;/h2&gt;
&lt;p&gt;如果函数作为对象的方法时，方法中的 this 指向该对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;
        console.log(&lt;span&gt;this&lt;/span&gt;.x);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;    }
};
obj.first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;意：若是在对象方法中定义函数，那么情况就不同了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        function second(){
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;
            console.log(&lt;span&gt;this&lt;/span&gt;.x);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;span&gt;        }
        second();
    }
}
obj.first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这么理解：函数 second虽然是在 obj.first 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。&lt;/p&gt;
&lt;p&gt;在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x:1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        function second(){
            console.log(self);      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{x: 1}&lt;/span&gt;
            console.log(self.x);    &lt;span&gt;//1&lt;/span&gt;
&lt;span&gt;        }
        second();
    }
}
obj.first();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果 first 函数不作为对象方法被调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    first: function () {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Window&lt;/span&gt;
        console.log(&lt;span&gt;this&lt;/span&gt;.x);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;span&gt;    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fn =&lt;span&gt; obj.first;
fn();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;obj.first 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。&lt;/p&gt;
&lt;h2&gt;情况四：构造函数 prototype 属性&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function First(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}
First.prototype.getX &lt;/span&gt;=&lt;span&gt; function () {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;First {x: 1, getX: function}&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; first= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; First();
first.getX();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 First.prototype.getX 函数中，this 指向的first 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。&lt;/p&gt;
&lt;h2&gt;情况五：函数用 call&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    x:1&lt;/span&gt;&lt;span&gt;
}
function first(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{x: 1}&lt;/span&gt;
    console.log(&lt;span&gt;this&lt;/span&gt;.x);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;}
first.call(obj);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当一个函数被 call调用时，this 的值就取传入的对象的值。&lt;/p&gt;
&lt;p&gt;来源：知乎&lt;/p&gt;
&lt;p&gt;链接：https://zhuanlan.zhihu.com/p/25294187?utm_source=com.youdao.note&amp;amp;utm_medium=social&lt;/p&gt;
&lt;p&gt;作者：&lt;a class=&quot;PostIndex-authorName&quot; href=&quot;https://www.zhihu.com/people/lindongzhou&quot; target=&quot;_blank&quot;&gt;林东洲&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Oct 2017 15:17:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7689783.html</dc:identifier>
</item>
</channel>
</rss>