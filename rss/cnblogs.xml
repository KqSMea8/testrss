<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WebAPI接口设计：SwaggerUI文档 / 统一响应格式 / 统一异常处理 / 统一权限验证 - CodeL</title>
<link>http://www.cnblogs.com/codelir/p/9977667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codelir/p/9977667.html</guid>
<description>&lt;p&gt;为什么还要写这类文章？因为我看过网上很多讲解的都不够全面，而本文结合实际工作讲解了swaggerui文档，统一响应格式，异常处理，权限验证等常用模块，并提供一套完善的案例源代码，在实际工作中可直接参考使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、先看看最终效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是最后生成的swagerui文档，大家可以直接访问这个地址体验：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://sapi.daimali.com/swagger/ui/index&quot; target=&quot;_blank&quot;&gt;http://sapi.daimali.com/swagger/ui/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(若无法访问，请公众号CodeL联系)&lt;/p&gt;
&lt;p&gt;git源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/daimali/WebApiDemo&quot; target=&quot;_blank&quot;&gt;https://gitee.com/daimali/WebApiDemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132008935-783330465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132025357-1550960974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132041284-1668947800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;我觉得大部分人阅读到这里就可以了，剩下的时间去看看源码，需要用的时候边用边学就好了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、接口文档 - SwaggerUI注意点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;swagger汉化，注意swagger_lang.js 属性生成操作需要选择&quot;&lt;strong&gt;嵌入的资源&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;项目右键-属性-生成：输出项&lt;strong&gt;勾选XML文档文件&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132102687-953376905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、统一响应格式说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过 ApiResultFilterAttribute 类实现响应参数的统一封装：&lt;/p&gt;
&lt;p&gt;这里封装的响应格式为：&lt;/p&gt;
&lt;p&gt;{  &lt;/p&gt;
&lt;p&gt;    &quot;code&quot;: 200, &lt;/p&gt;
&lt;p&gt;     &quot;msg&quot;: &quot;OK&quot;, &lt;/p&gt;
&lt;p&gt;     &quot;data&quot;: null&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132210177-754056302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、自定义异常信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对于所有的异常信息，接口也会返回对应的code，msg，data的格式：&lt;/p&gt;
&lt;p&gt;通过CustomException和CustomExceptionFilterAttribute实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132253817-867395919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/882581/201811/882581-20181118132259814-1850216990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;看源码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要说的东西太多，直接看源码更方便：&lt;/p&gt;
&lt;p&gt;接口预览地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://sapi.daimali.com/swagger/ui/index&quot; target=&quot;_blank&quot;&gt;http://sapi.daimali.com/swagger/ui/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(若无法访问，请公众号联系)&lt;/p&gt;

&lt;p&gt;git源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/daimali/WebApiDemo&quot; target=&quot;_blank&quot;&gt;https://gitee.com/daimali/WebApiDemo&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;相关资源获取或其他疑问可在公众号CodeL留言。&lt;/p&gt;

</description>
<pubDate>Sun, 18 Nov 2018 23:07:00 +0000</pubDate>
<dc:creator>CodeL</dc:creator>
<og:description>为什么还要写这类文章？因为我看过网上很多讲解的都不够全面，而本文结合实际工作讲解了swaggerui文档，统一响应格式，异常处理，权限验证等常用模块，并提供一套完善的案例源代码，在实际工作中可直接参考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codelir/p/9977667.html</dc:identifier>
</item>
<item>
<title>python 历险记(五）—— python 中的模块 - ReyCG</title>
<link>http://www.cnblogs.com/reycg-blog/p/9976078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reycg-blog/p/9976078.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;这次我们继续探险，来搞定 python 中的模块(module)。&lt;strong&gt;兵马未动，粮草先行&lt;/strong&gt;，开工之前先看看基础是否补齐了^_^。&lt;/p&gt;

&lt;p&gt;模块的概念你一定不会陌生吧，这是一个非常宽泛的概念，在各行各业都会用到。这里我们涉及的只是软件中的模块概念。说到模块，就得先了解下模块化程序设计的概念。(如果您对模块化程序设计的概念已经烂熟于心，尽可以略过，而直接跳到下一节)&lt;/p&gt;
&lt;h2 id=&quot;模块化程序设计&quot;&gt;模块化程序设计&lt;/h2&gt;
&lt;blockquote readability=&quot;6.7209302325581&quot;&gt;
&lt;p&gt;模块化程序设计是指进行程序设计时将一个大程序按照功能划分为若干小程序模块，每个小程序模块完成一个确定的功能，并且在这些模块之间建立必要的联系，通过模块的相互协作完成整个功能的程序设计方法。&lt;/p&gt;
&lt;p&gt;——&lt;a href=&quot;https://baike.baidu.com/item/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1154869&quot;&gt;百度百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子，假如我们要造一辆汽车，就可以先将汽车分成四个部件：发动机、底盘、电气设备、车身。每个部件都是一个模块，都会完成自己专属的功能，同时也预留了和其他部件配合的接口。当这几部分建造完成时，就可以组合在一起，从而完成了整个汽车的建造。&lt;/p&gt;
&lt;p&gt;类比一下,汽车就是整个程序，而像发动机，底盘等就是程序中各个小的模块。只有当各个模块正常工作，并且暴露的接口和其他模块的接口完全契合，才能组合成一个完整且正常工作的程序。&lt;/p&gt;
&lt;h2 id=&quot;模块化有哪些好处&quot;&gt;模块化有哪些好处?&lt;/h2&gt;
&lt;p&gt;当然，如果不将程序分解成一个个独立的部分，而是整个一大坨，也能够完成所要的功能。那么为什么教科书还有实际使用中都会提倡模块化程序设计？这样做有什么好处呢？&lt;/p&gt;
&lt;ol readability=&quot;4.4173469387755&quot;&gt;&lt;li readability=&quot;3.8454935622318&quot;&gt;
&lt;p&gt;控制程序设计的复杂度&lt;/p&gt;
&lt;p&gt;不知你看过&lt;a href=&quot;https://book.douban.com/subject/1951158/&quot;&gt;《代码大全》&lt;/a&gt;没有，里面有一句非常著名的格言：&lt;strong&gt;软件的首要使命就是管理复杂度&lt;/strong&gt;。完整的软件功能复杂度是非常高的，如果不使用有效的方法加以管理，很可能会陷入复杂的泥潭中不可自拔。而将程序分解成模块，则会将整体功能的复杂度有效的下分到各个模块中。每个模块只要能够管理好自己的复杂度就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;提高代码的重用性&lt;/p&gt;
&lt;p&gt;还是以造汽车为例，假设我造了一个很牛的发动机，多款车型都可以使用它。程序设计也一样，如果一个模块能够完成特定的功能，且与父程序耦合度较小，多个程序都可以使用它。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;易于维护和扩展&lt;/p&gt;
&lt;p&gt;小 A 写了一个程序，并将各个部分划分的非常明确，再加以人性化的函数命名和注释。即使有一天小 A 离职了，小 B 要接过来维护以及在此基础上再开发新的功能也不难。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;既然模块化就这么多好处， 强大的 python 当然也会吸收这个优秀的设计思想，并且在语言中有所体现，那就是 python 的模块(module)。&lt;/p&gt;

&lt;p&gt;先来看一个示例：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;创建 python 文件 &lt;em&gt;a.py&lt;/em&gt;，并在文件中定义函数 &lt;code&gt;sum&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def sum(a, b):
    return a + b&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建 python 文件 &lt;em&gt;b.py&lt;/em&gt;, 并调用 &lt;code&gt;sum&lt;/code&gt; 函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from a import sum

print(sum(1, 2)) # 3&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;文件 &lt;code&gt;a.py&lt;/code&gt; 就是一个模块(module)，&lt;code&gt;b.py&lt;/code&gt;就是一个主模块(main module)。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;b.py&lt;/code&gt; 中有这么一句 &lt;code&gt;from a import sum&lt;/code&gt; ，是指将模块 a 中的 &lt;code&gt;sum&lt;/code&gt; 函数导入到当前模块中。我们定义的文件名是 &lt;em&gt;a.py&lt;/em&gt; ，而模块名就是去掉后缀后得到的 模块 &lt;em&gt;a&lt;/em&gt;。那么能不能再多导入几个函数或者导入模块 a 的全部函数呢？当然可以，这个我们后面讲。&lt;/p&gt;
&lt;p&gt;调用模块时，通过文件名就可以确定模块的名字，那么在模块(module)内部，能知道自己姓甚名谁吗？还真能。&lt;/p&gt;
&lt;p&gt;每个模块都有一个全局变量 &lt;code&gt;__name__&lt;/code&gt; ，它就是模块的名字。上面 &lt;em&gt;a.py&lt;/em&gt; 的内容不变，修改下 &lt;code&gt;b.py&lt;/code&gt; 的内容。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import a

print(a.__name__)  # a
print(a.sum(1, 2))  # 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来，一起总结下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;python 模块(module) 是指包含 python 定义（包括 类，函数，变量）和语句的文件(&lt;em&gt;.py&lt;/em&gt;做后缀)&lt;/li&gt;
&lt;li&gt;模块名就是模块文件名称去掉&lt;em&gt;.py&lt;/em&gt; 后缀&lt;/li&gt;
&lt;li&gt;在模块内部，可以通过全局变量 &lt;code&gt;__name__&lt;/code&gt; 得到模块名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要导入模块并调用，前提要导入的 python 模块中有料（函数，变量，class）才可以。先来定义一个 python 模块 &lt;em&gt;calc&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def plus(a, b):
    return a + b


def subtract(a, b):
    return a - b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再创建一个 &lt;em&gt;main.py&lt;/em&gt; 文件，在其中做引入操作。okay，准备好了，那我们来逐个看下可以引入模块的方式吧。&lt;/p&gt;
&lt;ul readability=&quot;16&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;引入整个模块，调用时需要加上模块名&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import calc

print(calc.plus(1, 2)) # 3

print(calc.subtract(2, 1)) # 1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;引入模块特定的函数或变量，调用时无需加模块名&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from calc import plus, subtract

print(plus(1, 2))  # 3

print(subtract(2, 1))  # 1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;引入整个模块，调用时无需加上模块名&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from calc import *

print(plus(1, 2))  # 3

print(subtract(2, 1))  # 1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;引入整个模块，并对模块重命名，调用时加上重命名后的模块名&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import calc as calculator

print(calculator.plus(1, 2))  # 3

print(calculator.subtract(2, 1))  # 1&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;引入模块特定的函数或变量，并对其重命名，调用时无需加模块名&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from calc import plus as add, subtract as sub

print(add(1, 2))  # 3

print(sub(2, 1))  # 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数一下，一共是 6 种方式，归纳一下就是 &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;import&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 这些符号的组合而已。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上几篇文章中已经用了如 &lt;em&gt;os&lt;/em&gt;，&lt;em&gt;shutils&lt;/em&gt;，&lt;em&gt;json&lt;/em&gt; 等多个模块 ，这些模块都是 python 的内置模块。相比之下，我们刚才使用的 &lt;code&gt;calc&lt;/code&gt; 模块就是自定义模块。&lt;/p&gt;
&lt;p&gt;假设我们使用 &lt;code&gt;import calc&lt;/code&gt; 导入 &lt;code&gt;calc&lt;/code&gt; 模块， python 在启动时按照什么样的顺序来查找这个模块呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先查找内置(built-in)模块中有没有,如果没有转到 2&lt;/li&gt;
&lt;li&gt;查找 &lt;code&gt;sys.path&lt;/code&gt; 变量指定的路径下有没有, 有的话就使用，没有就报错&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;sys.path&lt;/code&gt; 变量中存储了那些路径呢？&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当前运行的 python 脚本所在的目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;环境变量 &lt;code&gt;PYTHONPATH&lt;/code&gt; 中的路径，它和 shell 环境变量 &lt;code&gt;PATH&lt;/code&gt; 差不多&lt;/p&gt;
&lt;p&gt;这个变量可以使用 python 脚本在运行时修改它&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;默认的 python 安装包的路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;想要看下你的电脑当前 &lt;code&gt;sys.path&lt;/code&gt; 有哪些路径吗？运行下面代码就可以&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
print(sys.path)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找模块的顺序是从前向后，只要查到就使用，因此这个变量存储路径的顺序很重要。&lt;/p&gt;

&lt;p&gt;如果引入的模块中包含一些执行语句，那么在导入模块时这些语句就会执行。但是即使同样的模块被导入了两次，这些语句也只能执行一次。&lt;/p&gt;
&lt;p&gt;来看下面的例子, 定义 &lt;code&gt;calc&lt;/code&gt; 模块&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print('I am clac module')


def plus(a, b):
    return a + b


def subtract(a, b):
    return a - b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且在 &lt;em&gt;main.py&lt;/em&gt; 中定义导入两次 &lt;code&gt;calc&lt;/code&gt; 模块的函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from calc import plus
from calc import subtract


print(plus(1, 2))
print(subtract(1, 2))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是 &lt;code&gt;'I am clac module'&lt;/code&gt; 只会被打印一次。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dir()&lt;/code&gt; 函数是 python 的内置函数，可用来获取模块的属性，方法等信息，当我们刚接触一个模块，不清楚它由哪些有用的属性和方法时，就可以用 &lt;code&gt;dir()&lt;/code&gt; 来一探究竟。&lt;/p&gt;
&lt;p&gt;以常用的 &lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9967865.html&quot;&gt;json模块&lt;/a&gt; 为例，我们来展示下它的属性和方法&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import json

print(dir(json))
# ['JSONDecodeError', 'JSONDecoder', 'JSONEncoder', '__all__', '__author__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', '__version__', '_default_decoder', '_default_encoder', 'codecs', 'decoder', 'detect_encoding', 'dump', 'dumps', 'encoder', 'load', 'loads', 'scanner']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中以双下划线开头的变量，如 &lt;code&gt;__name__&lt;/code&gt; 并非是模块自己定义的，而是与模块相关的默认属性。&lt;/p&gt;
&lt;p&gt;如果我想查看当前模块内的所有属性和方法呢？去掉 &lt;code&gt;dir()&lt;/code&gt; 函数的参数就可以。拿上节的代码为例来看下。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from calc import plus
from calc import subtract


print(plus(1, 2))
print(subtract(1, 2))
print(dir())
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'plus', 'subtract']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们会看到 &lt;em&gt;calc&lt;/em&gt; 模块的 &lt;code&gt;plus&lt;/code&gt; 和 &lt;code&gt;substract&lt;/code&gt; 方法也展示了出来，那么 &lt;code&gt;dir&lt;/code&gt; 函数究竟是从哪里获取的数据，背后的机理是什么呢？&lt;/p&gt;
&lt;p&gt;其实每个模块内部都有一个子集的私有符号表，它就是模块内所有函数和方法共享的全局符号表。当模块 B 导入模块 A 时，就会把要导入的模块 A 或者特定的方法，属性放置到模块 B 的全局符号表中，&lt;code&gt;dir()&lt;/code&gt; 函数也就是从模块中的全局符号表中获取出的值。&lt;/p&gt;

&lt;p&gt;python 的内置模块太丰富了，几乎可以满足我们日常的任何需求。既然有轮子就在那里，而且这轮子又快又好，又何必再造轮子呢？快来看下它的常用内置模块有哪些。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;calendar&lt;/td&gt;
&lt;td&gt;与日期相关&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;处理日期和时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;csv&lt;/td&gt;
&lt;td&gt;读写 csv 文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;json&lt;/td&gt;
&lt;td&gt;读写 json 格式数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;collections&lt;/td&gt;
&lt;td&gt;提供有用的数据结构&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;io&lt;/td&gt;
&lt;td&gt;处理 I/O 流&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;os&lt;/td&gt;
&lt;td&gt;基本的操作系统函数访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;shutil&lt;/td&gt;
&lt;td&gt;高级文件处理&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;tempfile&lt;/td&gt;
&lt;td&gt;创建临时文件和目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;logging&lt;/td&gt;
&lt;td&gt;日志功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;random&lt;/td&gt;
&lt;td&gt;生成伪随机数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;copy&lt;/td&gt;
&lt;td&gt;复制数据相关&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;codec&lt;/td&gt;
&lt;td&gt;编解码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;re&lt;/td&gt;
&lt;td&gt;正则表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;uuid&lt;/td&gt;
&lt;td&gt;全局唯一标识符 （UUID）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;multiprocessing&lt;/td&gt;
&lt;td&gt;运行多个子进程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;threading&lt;/td&gt;
&lt;td&gt;线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;concurrent&lt;/td&gt;
&lt;td&gt;异步&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;argparse&lt;/td&gt;
&lt;td&gt;解析命令行参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;atexit&lt;/td&gt;
&lt;td&gt;注册在程序退出时调用的函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;signal&lt;/td&gt;
&lt;td&gt;处理 POSIX 信号&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;光常用的模块就这么一大堆，确实是很难都记住，记不住也没关系，当需要用到的时候随用随查就可以了。&lt;/p&gt;

&lt;p&gt;本篇中主要介绍了模块化的定义，引入模块化的方式，模块的查找顺序，常用的内置模块简介等内容，通过使用模块化，能够更好的实践模块化程序设计的思想。但本篇并没有涉及 package 的概念，会在后续章节讲述。&lt;/p&gt;
&lt;p&gt;下篇会讲述 python 中正则表达式，敬请期待。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3.7/tutorial/modules.html&quot;&gt;python modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/1154869&quot;&gt;模块化程序设计—百度百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/1951158/&quot;&gt;《代码大全》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.douban.com/subject/26389274/&quot;&gt;《Python高手之路》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sun, 18 Nov 2018 22:53:00 +0000</pubDate>
<dc:creator>ReyCG</dc:creator>
<og:description>这次我们继续探险，来搞定 python 中的模块(module)。**兵马未动，粮草先行**，开工之前先看看基础是否补齐了。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reycg-blog/p/9976078.html</dc:identifier>
</item>
<item>
<title>Java链接Mysql数据库 - !'0=0'</title>
<link>http://www.cnblogs.com/NMSL-Official/p/9981174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NMSL-Official/p/9981174.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1518190/201811/1518190-20181119012033196-1801172626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意要下载最新的JDBC的jar包，并正确导入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1518190/201811/1518190-20181119012157511-858680180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以成功连接本地数据库&lt;/p&gt;
&lt;p&gt;然后可以调用ResultSet里面的方法对数据库进行增删改查的操作了&lt;/p&gt;
&lt;p&gt;往数据库当前记录集插入新行的操作流程如下： &lt;br/&gt;1 调用moveToInsertRow()方法； &lt;br/&gt;2 调用updateXXX()方法指定插入行各列的值； &lt;br/&gt;3 调用insertRow()方法往数据库中插入新的行。 &lt;/p&gt;&lt;p&gt;更新数据库中某个记录的值(某行的值)的方法是： &lt;br/&gt;1 定位到需要修改的行(使用absolute()relative()等方法定位)； &lt;br/&gt;2 使用相应updateXXX()方法设定某行某列的新值；XXX 所代表的Java数据类型，必须可以映射为某列的JDBC数据类型，如果希望rollback 该项操作，请在调用updateRow()方法以前，使用cancelRowUpdates()方法，这个方法可以将某行某列的值复原； &lt;br/&gt;3 使用updateRow()方法完成UPDATE的操作。 &lt;/p&gt;&lt;p&gt;删除记录集中某行(亦即删除某个记录)的方法： &lt;br/&gt;1 定位到需要修改的行(使用absolute()relative()等方法定位)； &lt;br/&gt;2 使用deleteRow()&lt;/p&gt;
&lt;p&gt;删除记录集中某行(亦即删除某个记录)的方法： &lt;br/&gt;1 定位到需要修改的行(使用absolute()relative()等方法定位)； &lt;br/&gt;2 使用deleteRow()方法.&lt;/p&gt;

</description>
<pubDate>Sun, 18 Nov 2018 17:27:00 +0000</pubDate>
<dc:creator>!&amp;#39;0=0&amp;#39;</dc:creator>
<og:description>注意要下载最新的JDBC的jar包，并正确导入 可以成功连接本地数据库 然后可以调用ResultSet里面的方法对数据库进行增删改查的操作了 往数据库当前记录集插入新行的操作流程如下： 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NMSL-Official/p/9981174.html</dc:identifier>
</item>
<item>
<title>shiro权限配置的细节问题&amp;认证 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9980910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9980910.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;细节：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;---[urls]部分配置，其格式是    &lt;span&gt;url=拦截器【参数】&lt;/span&gt; ，拦截器【参数】&lt;/p&gt;
&lt;p&gt;---如果当前请求的 url 匹配 【urls】 部分或者某个url模式，将会执行配置的拦截器&lt;/p&gt;
&lt;p&gt;---anon（anonymous）拦截器表示匿名访问（即不需要登陆验证）&lt;/p&gt;
&lt;p&gt;---authc（authentication）拦截器的表示需要身份认证之后才能访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterChainDefinitions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;value&amp;gt;
           &lt;span&gt;     /login.jsp = anon
                # everything else requires authentication:
                /*&lt;/span&gt;&lt;span&gt;&lt;span&gt;* = authc&lt;/span&gt;
            &amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119000845610-262429054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119000857325-967082666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
               /login.jsp =&lt;span&gt; anon
                # everything &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; requires authentication:
                &lt;/span&gt;&lt;span&gt;/** = authc
                /user.jsp = anon&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 此时上面的会覆盖下面的user.jsp 无法访问&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt; 认证：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.获取当前subject，&lt;span&gt;SecurityUtils.getSubject();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.测试当前用户是否已经被认证，即是否已经登陆， currentUser.isAuthenticated()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.若没有认证则/把用户名和密码封装为UsernamePasswordToken对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    -创建一个表单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    -把请求提交到spriingmvc 的handler&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    -获取用户和密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.执行登陆&lt;span&gt; currentUser.login(token);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.自定义Relam方法，从数据库中获取相应的记录，返回给Shiro&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    -实际上是需要集成org.apache.shiro.realm.AuthenticatingRealm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    -实现&lt;span&gt;doGetAuthenticationInfo（）&lt;/span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.有shiro完成对密码的比对&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 测试使用到的文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119001231247-1244340787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下面开始代码过程：&lt;/p&gt;
&lt;p&gt;login.jsp页面的登陆标志代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    login
    &lt;/span&gt;&amp;lt;form action=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shiro/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
          username:&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
          password:&lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
          &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在application中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterChainDefinitions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;value&amp;gt;
                /login.jsp =&lt;span&gt; anon
                  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;/shiro/login =&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; anon&lt;/span&gt;&lt;/strong&gt;
                # everything &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; requires authentication:
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* = authc
            &amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; ShiroHandler.java&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
@RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/shiro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShiroHandler {
     @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String login(&lt;strong&gt;&lt;span&gt;@RequestParam(&quot;username&quot;)String  username,@RequestParam(&quot;password&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;) String password&lt;/span&gt;&lt;/strong&gt;){

             Subject currentUser &lt;/span&gt;=&lt;span&gt; SecurityUtils.getSubject();
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;currentUser.isAuthenticated()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把用户名和密码封装为UsernamePasswordToken对象&lt;/span&gt;
                 UsernamePasswordToken token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;  UsernamePasswordToken(username, password);
                 token.setRememberMe(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                 &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行登陆&lt;/span&gt;
&lt;span&gt;                     currentUser.login(token);
                 }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException ae) {
                     System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登陆失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;  ae.getMessage());
                 }
             }

           成功之后做重定向
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redirect:/list.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在applicationContext中需要扫描这个类的包&lt;/p&gt;

&lt;p&gt; ShiroRealm.java&lt;/p&gt;
&lt;p&gt;做登陆验证实现下面的接口即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;doGetAuthenticationInfo(AuthenticationToken arg0)的arg0是指就是UsernamePasswordToken token = new  UsernamePasswordToken(username, password);&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShiroRealm extends AuthenticatingRealm {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;doGetAuthenticationInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; arg0);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.把AuthenticationToken转为UsernamePasswordToken&lt;/span&gt;
        UsernamePasswordToken  upToken =&lt;span&gt; (UsernamePasswordToken) arg0;
        
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.从UsernamePasswordToken获取username&lt;/span&gt;
        String username =&lt;span&gt; upToken.getUsername();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.调用数据库的方法，从数据库查询username对应的用户记录&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;从数据库中获取username：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; username);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.若用户不存在可以抛出异常 UnKnownAccountException异常&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unknow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(username)){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnknownAccountException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username 不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.根据用户信息的清空决定是否需要抛出其他的异常&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;monster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.equals(username)){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockedAccountException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户被锁定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.根据用户的情况来构建AuthenticationInfo并且返回
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下信息是从数据库中获取的
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;principal：认证的实体信息，可以是username，也可以是数据表对应的实体对象&lt;/span&gt;
        Object principal =&lt;span&gt; username;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;credentials:密码&lt;/span&gt;
        Object credentials = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;realmName:当前realm对象为name，调用父类的getName()方法即可&lt;/span&gt;
        String realmName =&lt;span&gt; getName();
        SimpleAuthenticationInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleAuthenticationInfo(principal, credentials, realmName);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; info;
    }
}&lt;/span&gt;
&lt;/pre&gt;

&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119001605454-1005982284.png&quot; alt=&quot;&quot; width=&quot;930&quot; height=&quot;467&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119001616039-225884458.png&quot; alt=&quot;&quot; width=&quot;920&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我们输入密码为1234，以及其他为username（除了上图的两个）&lt;/p&gt;
&lt;p&gt;此时我们就有权限对其他的页面进行测试&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119001721150-323028997.png&quot; alt=&quot;&quot; width=&quot;389&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出错之后的异常还是会打印的&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181119001739355-1326358456.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 此时我们需要登出的操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;list.jsp&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;&lt;span&gt;
    list.
    
    &lt;/span&gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shiro/logout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Logout&amp;lt;/a&amp;gt;
  &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 在applicationContext.xml文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;!--&lt;span&gt;
            配置那些页面需要受保护，以及访问这些页面需要的的权限
            
            &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）anon 可以被匿名访问
            &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）authc 必须认证即登陆后才可以访问的页面
            &lt;/span&gt;&lt;span&gt;&lt;strong&gt;3).logout登出
        &lt;/strong&gt;&lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filterChainDefinitions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;value&amp;gt;
                /login.jsp =&lt;span&gt; anon
                  &lt;/span&gt;/shiro/login =&lt;span&gt; anon
                  &lt;/span&gt;&lt;strong&gt;&lt;span&gt;/shiro/logout =&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; logout&lt;/span&gt;&lt;/strong&gt;
                  
                # everything &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; requires authentication:
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* = authc
            &amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 但我们点击这个超链接的 时候就会立马退出来到login.jsp页面中&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 16:20:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>细节： [urls]部分配置，其格式是 url=拦截器【参数】 ，拦截器【参数】 如果当前请求的 url 匹配 【urls】 部分或者某个url模式，将会执行配置的拦截器 anon（anonymous</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9980910.html</dc:identifier>
</item>
<item>
<title>[python] 溜了，溜了，七牛云图片资源批量下载 &amp;&amp; 自建图床服务器 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9975527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9975527.html</guid>
<description>&lt;h3 id=&quot;故事背景&quot;&gt;故事背景：&lt;/h3&gt;
&lt;p&gt;七牛云最近一波测试域名操作真是把我坑死了！这简直和百度赠送你2T网盘，之后再限速一样骚操作。于是，痛定思痛自己买个云主机、自己搭图床应用！&lt;/p&gt;

&lt;h3 id=&quot;七牛图片批量下载到本地&quot;&gt;1、七牛图片批量下载到本地&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.1 曲折尝试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当测试链接不能用的时候，我想依次用到下面几个方法尝试download图片：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用七牛之前的传图工具qshell，看看有啥办法（行不通）&lt;/li&gt;
&lt;li&gt;找七牛图片资源处看看有没有批量打包下载（NO）&lt;/li&gt;
&lt;li&gt;自己写个前端爬虫将图片爬下来（没下载链接...)&lt;/li&gt;
&lt;li&gt;绑定一个自己的域名（需要实名认证+域名备案）&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后发现一个神器：&lt;strong&gt;qfetch&lt;/strong&gt;，是根据七牛云存储API实现的一个简易命令行辅助工具。覆盖七牛云存储开发者网站包含的大部分甚至更高级的功能。开发者在对七牛云存储 API 有基本了解的情况下，此工具将会非常适用。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;1.2 qfetch基本操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-按照如下指令，输入自己七牛云的账号和密码&lt;strong&gt;登录&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./qrstcl login &amp;lt;your username&amp;gt; &amp;lt;your password&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我之前所有图片是在七牛云对象存储中的bucket中，运行如下代码&lt;strong&gt;查看&lt;/strong&gt;目前我建立的所有bucket：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./qrsctl buckets&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我里面只有一个buckets：beautifulzzzz&lt;/p&gt;
&lt;p&gt;可以用下列命令查看该buckets下的&lt;strong&gt;所有资源&lt;/strong&gt;：（注意最后是两个英文单引号）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./qrsctl listprefix beautifulzzzz ''&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到资源列表后，可以调用下列命令&lt;strong&gt;下载&lt;/strong&gt;一个资源：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qrsctl get &amp;lt;Bucket&amp;gt; &amp;lt;Key&amp;gt; &amp;lt;DestFile&amp;gt;
比如./qrsctl get beautifulzzzz 1.jpg ./1.jpg可以将picture中的1.jpg下载到本地机器当前路径下的1.jpg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;1.3 自动化脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;综上几步，可以写一个自动化脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qiniuyun (master) ✗ cat download.sh 
#!/bin/bash
imgs=`./qrsctl listprefix beautifulzzzz ''`

i=0 
echo $imgs | tr &quot; &quot; &quot;\n&quot; | while read line
do
    if(($i&amp;gt;0))
    then
    echo $line
    path=`dirname $line`
    echo $path
    if [ ! -d &quot;$path&quot; ];then
        mkdir -p $path
    fi

    ./qrsctl get beautifulzzzz $line ./$line
    fi
    i=$(($i+1))
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;该脚本相对于 chensonglu 分享的《七牛云测试域名失效导致图片外链失效的解决办法》，增加了多级目录文件下载功能。&lt;/p&gt;

&lt;h3 id=&quot;python-图床服务器搭建&quot;&gt;2、python 图床服务器搭建&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1 python3环境搭建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装python:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install python2.7-dev python3-dev
wget https://bootstrap.pypa.io/get-pip.py
sudo python get-pip.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装python虚拟环境virtualenv virtualenvwrapper:（用虚拟开发环境可以为每个工程提供独立的python开发环境、独立的包、独立的版本，每个独立的环境会在~/.virtualenvs/下形成资源包～）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo pip install virtualenv virtualenvwrapper
sudo rm -rf ~/.cache/pip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后在～/.profile文件最后添加下面几行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# virtualenv and virtualenvwrapper
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后如果想用python虚拟环境，在每次打开一个新的terminal就要执行一次source ~/.profile&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ source ~/.profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们生成一个python虚拟环境来用于python_pic_server的开发提供环境：（这里不讲python2，强烈建议用python3)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkvirtualenv python_pic_server -p python3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;再次说明python虚拟环境是完全独立的，也就是说在python_pic_server的环境下安装的python包，步适用于全局；在全局安装的包，不适合python_pic_server。&lt;/p&gt;
&lt;p&gt;如何验证你如何将python_pic_server环境生成好了呢？——新开一个terminal，执行下列命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ source ~/.profile
$ workon python_pic_server&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果terminal前面的文字变成了(python_pic_server)表明成功创建了名为python_pic_server的python虚拟环境，在接下来的操作中都要保持在python_pic_server环境中！&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;2.2 安装Sanic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sanic 是一个比较新的，但是发展比较快的框架。其特征是速度非常快。据他们官方网站自己说，sanic 是最快的 python 框架。&lt;/p&gt;
&lt;p&gt;Sanic is a Flask-like Python 3.5+ web server that’s written to go fast. It’s based on the work done by the amazing folks at magicstack, and was inspired by this article.&lt;/p&gt;
&lt;p&gt;在python_pic_server中安装sanic：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install sanic&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sanic用法比较简单，具体可以参考：&lt;a href=&quot;https://sanic.readthedocs.io/en/latest/sanic/getting_started.html#install-sanic&quot;&gt;[6].sanic getting started page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;2.3 写图床服务器程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在/root/App/python_pic_server目录下创建run.py：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(python_pic_server) ➜  python_pic_server cat run.py 
#!/usr/bin/env python
# -*- coding: UTF-8 -*-
from sanic import Sanic
from sanic.log import logger
from sanic.response import json, text, file
import os, sys
import hashlib
import base64

app = Sanic()
# 图片存储目录
baseDir = sys.path[0] + '/image/'
# 校验 Token 写死就成，反正自己用的嘛
token = 'SheIsABeautifulGirl'
# 允许的域名列表
allowHost = [
        '127.0.0.1:8000',
        'localhost',
        'pic.phage.com'
    ]

# 成功返回方法
def ok(data):
    if type(data) == list:
    return json({&quot;data&quot;: {&quot;list&quot;: data}, &quot;status&quot;: 0})
    else:
    return json({&quot;data&quot;: data, &quot;status&quot;: 0})
# 失败返回方法
def fail(data):
    return json({&quot;data&quot;: data, &quot;status&quot;: 1})

# 获取图片后缀名
def getSuffix(filename):
    tempArr = filename.split('.')
    suffix = tempArr[-1]
    fileType = ['jpg', 'jpeg', 'gif', 'png']
    if len(tempArr) &amp;lt; 2:
    return 'error name'
    elif suffix not in fileType:
    return 'error type'
    else:
    return suffix
# 检查请求地址是否授权
def checkHost(host):
    for i in allowHost:
    if i in host:
        return True
    return False

# 上传图片文件接口
@app.route('/api/v1/upimg', methods=['POST'])
async def upimg(request):
    # 判断用户是否具有上传权限
    if request.headers.get('token') != token:
    return fail('您没有使用本服务的权限')
    image = request.files.get('file').body
    # 判断文件是否支持
    imageName = request.files.get('file').name
    imageSuffix = getSuffix(imageName)
    if 'error' in imageSuffix:
    return fail(imageSuffix)
    # 组织图片存储路径
    m1 = hashlib.md5()
    m1.update(image)
    md5Name = m1.hexdigest()

    # 用 md5 的前两位来建文件夹，防止单个文件夹下图片过多，又或者根目录下建立太多的文件夹
    saveDir = baseDir + md5Name[0:2] + '/'
    savePath = saveDir + md5Name[2:] + '.' + imageSuffix
    resPath = '/' + md5Name[0:2] + '/' + md5Name[2:] + '.' + imageSuffix

    # 如果文件夹不存在，就创建文件夹
    if not os.path.exists(saveDir):
    os.makedirs(saveDir)

    # 将文件写入到硬盘
    tempFile = open(savePath, 'wb')
    tempFile.write(image)
    tempFile.close()

    # 给客户端返回结果
    return ok({&quot;path&quot;: resPath})

# 请求图片接口
@app.route('/', methods=['GET'])
async def img(request):
    # 判断是否为网站请求，否则就加上自定义的字符串（允许本地访问）
    host = request.headers.get('host') or 'no_host'
    # 判断请求接口是否带参数，否则加上自定义字符串（没有这个文件夹，返回404）
    args = request.args.get('path') or 'no_file'
    # 拼接文件地址
    path = baseDir + args
    #logger.info(request.headers)
    #logger.info(path)
    #logger.info(host)
    # 如果不在允许列表，则展示 401 图片
    if not checkHost(host):
    path = baseDir + '/cb/fea262f9b861c6fce14d3c3c8ba9a1.png'
    # 如果文件不存在，则展示 404 图片
    if not os.path.exists(path):
    path = baseDir + '/b4/dcd9ad1068ae6aa41ce486fa7f2739.png'
    # 返回文件
    logger.info(path)
    return await file(path)
# 启动服务
if __name__ == &quot;__main__&quot;:
    app.run(host=&quot;127.0.0.1&quot;, port=8000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;2.4 nginx配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vim /etc/nginx/nginx.conf 编辑配置文件，在http模块的最后添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 3000;
    server_name tuchuang.beautifulzzzz.com;
    location / {
        proxy_pass  http://127.0.0.1:8000;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改好之后relaod一下nginx：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nginx -s reload&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样访问 tuchuang.beautifulzzzz.com:3000 就相当于访问本机的8000端口，正好是我们的图床服务器端口！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;别忘了在你购买域名的地方设置一下A解析！我没备案，因此就用了3000端口。&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;2.5 运行图床并使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将第1步下载的七牛云图片放在image目录下，然后将run.py设置为可执行，并执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chmod +x run.py
./run.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;想在后台执行可以用：nohup ./run.py &amp;amp;&lt;/p&gt;
&lt;p&gt;此时，&lt;strong&gt;访问&lt;/strong&gt;图片可以通过 （/image/20180926/flygame.png）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://tuchuang.beautifulzzzz.com:3000/?path=/20180926/flygame.png &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上传&lt;/strong&gt;图片可以通过：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://tuchuang.beautifulzzzz.com:3000/api/v1/upimg -F &quot;file=@a.png&quot; -H &quot;token: SheIsABeautifulGirl&quot; -v&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;shell脚本批量替换某文件夹下文件中的域名字串&quot;&gt;3、shell脚本批量替换某文件夹下文件中的域名字串&lt;/h3&gt;
&lt;p&gt;现在，准备写一个批处理脚本进行善后。我首先想到的是用下面命令直接搞定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sed -i &quot;s/A/B/g&quot; `grep -rl A`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可是发现grep出来的文件目录中带有空格，这样这条命令就处理不到！&lt;/p&gt;
&lt;p&gt;于是自己写了一个循环查找替换的批处理脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;doc (master) ✗ cat change.sh 
#!/bin/bash
#bash change.sh &quot;odff1d90v.bkt.cloudd
#n.com&quot; &quot;tuchuang.beautifulzzzz.com:3000\/?path=&quot;

#bash change.sh &quot;sed src string&quot; &quot;sed dst string&quot;
IFS=$'\n'

if [ &quot;$1&quot; = &quot;&quot; ] &amp;amp;&amp;amp; [ &quot;$2&quot; = &quot;&quot; ];then
    echo &quot;params 2&quot;
    exit
fi

for element in `grep -rl &quot;$1&quot;`
do
    #echo $element
    cmd=&quot;s/$1/$2/g&quot;
    echo $cmd
    sed -i $cmd $element
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;这里IFS=$'\n'是为了让FOR循环的时候以换行作为分割&lt;/p&gt;
&lt;p&gt;使用的时候只要将该文件放置在对应的ROOT目录中，执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bash change.sh &quot;odff1d90v.bkt.clouddn.com&quot; &quot;tuchuang.beautifulzzzz.com:3000\/?path=&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：change.sh的两个参数就是sed的被替换对象和替换对象，注意转译符！&lt;/p&gt;

&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lkj345/article/details/83382636&quot;&gt;[1].七牛云测试域名失效导致图片外链失效的解决办法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.qiniu.com/kodo/tools/1300/qrsctl#1&quot;&gt;[2].命令行辅助工具(qrsctl)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/ljianhui/article/details/43128465&quot;&gt;[3].Linux shell 之 提取文件名和目录名的一些方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/dwdxdy/archive/2012/07/25/2608816.html&quot;&gt;[4].逐行处理文本文件-一点心青-cnblog&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/apache0554/article/details/47006609&quot;&gt;[5].shell中的特殊变量IFS- __Cheny-csdn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://sanic.readthedocs.io/en/latest/sanic/getting_started.html#install-sanic&quot;&gt;[6].sanic getting started page&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/FungLeo/article/details/80690367&quot;&gt;[7].Python3 初学实践案例（14）打造一个私人图床服务器-FungLeo-csdn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/FungLeo/article/details/80885907&quot;&gt;[8].Python 打造自己的图床升级篇 - PIL 为图片添加水印-FungLeo-csdn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/baby123/p/6477429.html&quot;&gt;[9].nohup和&amp;amp;后台运行，进程查看及终止-弥尘-cnblog&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 18 Nov 2018 16:13:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>故事背景： 七牛云最近一波测试域名操作真是把我坑死了！这简直和百度赠送你2T网盘，之后再限速一样骚操作。于是，痛定思痛自己买个云主机、自己搭图床应用！ 1、七牛图片批量下载到本地 1.1 曲折尝试 当</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9975527.html</dc:identifier>
</item>
<item>
<title>Wireshark抓包分析TCP.IP.UDP.ICMP报文格式 - sakamoto</title>
<link>http://www.cnblogs.com/yuxijun/p/9980838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuxijun/p/9980838.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP 报文格式分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118171337411-931080961.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TCP 报文段的报头有 10 个必需的字段和 1 个可选字段。报头至少为 20 字节。&lt;/p&gt;

&lt;p&gt;1）源端口（16位）：标识发送报文的计算机端口或进程。一个 TCP 报文段必须包括源端口号，使目的主机知道应该向何处发送确认报文。&lt;/p&gt;
&lt;p&gt;2）目的端口（16位）：标识接收报文的目的主机的端口或进程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231136275-2063156920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由抓包数据可得源端口号为12762，目的端口号为30&lt;/p&gt;

&lt;p&gt;3） 序号（也叫序列号）（32位）：用于标识每个报文段，使目的主机可确认已收到指定报文段中的数据。当源主机用于多个报文段发送一个报文时，即使这些报文到达目的主机的顺序不一样，序列号也可以使目的主机按顺序排列它们。在建立连接时发送的第一个报文段中，双方都提供一个初始序列号。TCP 标准推荐使用以 4ms 间隔递增 1 的计数器值作为这个初始序列号的值。使用计数器可以防止连接关闭再重新连接时出现相同的序列号。序列号表达达到2^32 - 1后又从0开始， 当建立一个新的连接时，SYN标志为1，系列号将由主机随机选择一个顺序号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231219746-1299440194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由图可得现序列号为25e4d8a8&lt;/p&gt;

&lt;p&gt;4）确认号（32位）:目的主机返回确认号，使源主机知道某个或几个报文段已被接收。如果 ACK 控制位被设置为 1，则该字段有效。确认号等于顺序接收到的最后一个报文段的序号加 1，这也是目的主机希望下次接收的报文段的序号值。返回确认号后，计算机认为已接收到小于该确认号的所有数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231308123-1712720645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由图可得现确认号为59eafa0c&lt;/p&gt;

&lt;p&gt;5） 数据偏移（首部长度）（4位）&lt;/p&gt;
&lt;p&gt;TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，即首部长度。 由于 TCP 报头的长度随 TCP 选项字段内容的不同而变化，因此报头中包含一个指定报头字段的字段。该字段以 32 比特为单位，所以报头长度一定是 32 比特的整数倍，有时需要在报头末尾补 0 。由抓包图有偏移量在0x50中，占4bit,0x50转化为二进制数0101 0000 所以偏移量是 0101=5，所以TCP报文首部长度为5* 4 = 20字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231338479-1054480047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;6）保留位（6位）：由跟在数据偏移字段后的 6 位构成&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231402006-1217072699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;7）窗口（16位）&lt;/p&gt;

&lt;p&gt;此字段用来进行流量控制，这个值是本机期望一次接收的字节数，即发送数据的窗口大小。告诉对方在不等待确认的情况下，可以发来多大的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231428139-1851862696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;8）校验和（16位）：源主机和目的主机根据 TCP 报文段以及伪报头的内容计算校验和。在伪报头中存放着来自 IP 报头以及 TCP 报文段长度信息。与 UDP 一样，伪报头并不在网络中传输，并且在校验和中包含伪报头的目的是为了防止目的主机错误地接收存在路由的错误数据报&lt;/p&gt;
&lt;p&gt;￼&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231502745-1443159644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;9）紧急指针（16位）：仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231519500-359976631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP报文格式分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118174353552-1313883318.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231709682-1111949217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由图可知源端口号为4242，目的端口号为4242，用户数据报长度为283比特，校验和为0xb4c6，数据大小为275bytes。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;IP 报文格式分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118175556457-1263061979.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231832674-1719905517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;版本：IP协议的版本，目前的IP协议版本号为4。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118175722740-922081480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118175813783-1001017307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总长度：IP报文的总长度。报头的长度和数据部分的长度之和。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231913339-1149435601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。由图得出这是第18958个分片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118231936934-687078460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232009504-1416849858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;片位移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232023854-326939664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232037434-1517057406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232047796-1546523219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首部校验和：计算IP头部的校验和，检查IP报头的完整性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232101848-623878831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;源IP地址：标识IP数据报的源端设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232119975-764528754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;目的IP地址：标识IP数据报的目的地址。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232129633-874284149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;ICMP 报文格式分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118181033593-1309585067.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118182050176-1480420164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型：占一字节，标识ICMP报文的类型，目前已定义了14种，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232318399-1366458049.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;代码：占一字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232353714-2091570243.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;校验和：这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错。其计算方法与在我们介绍IP报头中的校验和计算方法是一样的。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232407819-1357468308.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;标识：占两字节，用于标识本ICMP进程，但仅适用于回显请求和应答ICMP报文，对于目标不可达ICMP报文和超时ICMP报文等，该字段的值为0。&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118232421429-1480302140.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;TCP协议的连接管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118235658426-764123189.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181118235741474-578371611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次握手：客户端向服务器端发送连接请求包SYN（syn=j），等待服务器回应；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181119000249538-1843026881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次握手：服务器端收到客户端连接请求包SYN（syn=j）后，将客户端的请求包SYN（syn=j）放入到自己的未连接队列，此时服务器需要发送两个包给客户端；&lt;/p&gt;
&lt;p&gt;　　（1）向客户端发送确认自己收到其连接请求的确认包ACK（ack=j+1），向客户端表明已知道了其连接请求&lt;/p&gt;
&lt;p&gt;　　（2）向客户端发送连接询问请求包SYN（syn=k），询问客户端是否已经准备好建立连接，进行数据通信；&lt;/p&gt;
&lt;p&gt;　　即在第二次握手时服务器向客户端发送ACK（ack=j+1）和SYN（syn=k）包，此时服务器进入SYN_RECV状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1517321/201811/1517321-20181119000601475-1179427322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三次握手：客户端收到服务器的ACK（ack=j+1）和SYN（syn=k）包后，知道了服务器同意建立连接，此时需要发送连接已建立的消息给服务器；&lt;/p&gt;
&lt;p&gt;　　向服务器发送连接建立的确认包ACK（ack=k+1），回应服务器的SYN（syn=k）告诉服务器，我们之间已经建立了连接，可以进行数据通信。&lt;/p&gt;
&lt;p&gt;　　ACK（ack=k+1）包发送完毕，服务器收到后，此时服务器与客户端进入ESTABLISHED状态，开始进行数据传送。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：通过利用&lt;strong&gt;wireshark工具对互联网进行抓包分析，我们小组对互联网的连接有了更进一步的了解和认识，对课本上学的基础知识也有更深一步 的理解。&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 16:10:00 +0000</pubDate>
<dc:creator>sakamoto</dc:creator>
<og:description>TCP 报文格式分析： TCP 报文段的报头有 10 个必需的字段和 1 个可选字段。报头至少为 20 字节。 1）源端口（16位）：标识发送报文的计算机端口或进程。一个 TCP 报文段必须包括源端口</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuxijun/p/9980838.html</dc:identifier>
</item>
<item>
<title>团队项目第六周——Alpha阶段项目复审 - 林泽楷0</title>
<link>http://www.cnblogs.com/linzk/p/9980795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linzk/p/9980795.html</guid>
<description>&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;排名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;队名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;项目名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;小谷围驻广东某工业719电竞大队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;广工生活社区&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;功能多样，设计完整，实用，界面美观，切合生活实际需求&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;界面风格不够统一，当前时间系统尚未发布&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;大猪蹄子队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;四六级背单词游戏&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;功能开发出来了，界面简洁美观。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;还未完成整个程序。页面还是比较简洁，但是测试的地方可以对中文再进一步细化，去掉某些重复的单词，同一个单词分成不同的意思来测试感觉会更好。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;中午吃啥队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;系统很完善，题材也很贴近生活，是一个优秀的程序&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;app界面出现错位，支付方面情况未知。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;天冷了记得穿秋裤队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;离线下载器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;已形成完整应用系统，想法较新颖，离线下载也为网上资源的下载，实现完整&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;不支持超大文件下载，不稳定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;Running Duck&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;汉字2048&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;界面简洁美观；下落的汉字随机变换颜色；有一个hold功能可以存一个字&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;汉字颜色有时候太浅使得字不好认；如果不小心黑屏或者回到主界面，游戏还会继续而不是暂停&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;江山代有才人秃队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;玩法新颖，游戏过程流畅，大部分功能正常。项目流程规范。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;游戏结束界面暂未完成。打包时无法加载图片资源&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;只会嘤嘤嘤队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;背单词的形式有趣实用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;部分浏览器无法兼容&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;江山代有才人秃队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;双球游戏&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;游戏简单易懂易上手，玩法新颖&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;游戏模式比较单调&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;9&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;苏察哈尔灿队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;电影院订票管理系统&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;界面美观清晰，功能较完备&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;注册界面有些单调，可以改进。活动类别方面可以多增加一些，如社团对外活动等&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;10&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;冲鸭队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;游戏相对完整。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;本游戏暂时无法对字块结合进行记分统计游戏结束后未出现相应的提示信息或者页面跳转&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;11&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;盐酸队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;坦克大战&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;容易上手的小游戏。游戏流畅，没有巨大的bug。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;基本功能已经实现，但是存在着小的bug，如坦克子弹的发射速度。页面有一点粗糙，但是对于alpha版本来说是可以的&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;五饭来了吗队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;汉字 2048 游戏&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;键盘控制 界面简洁看着较舒适，有积分&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;创新很小，网页版大小超出浏览器，游戏中页面移动导致数字被浏览器挡住&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;13&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;菜就完事了队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;连连看&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;基本功能实现，简单易玩&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;输入规定时间实现倒计时功能只能从150秒开始 ，要求在安装有JDK的PC上才能运行&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;14&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;名字好难想队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;坦克大战&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;基本玩法实现。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;界面不够美观，玩法单一&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;15&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;GG队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;音乐游戏&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;容易上手&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;游戏过程有卡顿，图像超出网页&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;16&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;深海划水队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;俄罗斯方块&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;实现经典的俄罗斯方块&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;没有新玩法，新元素出现&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;17&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;小小大佬带飞队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;验单识别&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;图片识别功能比较完善，神经网络运用也比较好&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;未能形成一个完整的系统&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt;18&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;菜鸡互啄队&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;汉字版2048&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;span&gt;有待发现&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;功能不完整。BUG清单：无法生成新方块（已修复）,合成算法尚未实现,汉字版的尚未实现&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;</description>
<pubDate>Sun, 18 Nov 2018 15:59:00 +0000</pubDate>
<dc:creator>林泽楷0</dc:creator>
<og:description>排名 队名 项目名 优点 缺点 1 小谷围驻广东某工业719电竞大队 广工生活社区 功能多样，设计完整，实用，界面美观，切合生活实际需求 界面风格不够统一，当前时间系统尚未发布 2 大猪蹄子队 四六级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linzk/p/9980795.html</dc:identifier>
</item>
<item>
<title>Kotlin 最佳实践 - 白季飞龙</title>
<link>http://www.cnblogs.com/baijifeilong/p/9980779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baijifeilong/p/9980779.html</guid>
<description>&lt;h2 id=&quot;为什么写此文&quot;&gt;为什么写此文&lt;/h2&gt;
&lt;p&gt;Kotlin很烦，Gralde很烦，还都是升级狂，加一块更烦。几个月不接触Kotlin，再次上手时便一片迷茫。所以记录此文，以便再次上手时查阅。&lt;/p&gt;
&lt;h2 id=&quot;使用gradle创建kotlin项目&quot;&gt;使用Gradle创建Kotlin项目&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;mkdir hellokt&lt;/code&gt; 创建项目文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd hellokt&lt;/code&gt; 切换到项目根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gradle init --type java-application&lt;/code&gt; 使用Gradle初始化Java项目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -rf src/main/java src/test/java gradle gradlew gradlew.bat&lt;/code&gt; 删除Java目录和GradleWrapper配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vim build.gradle&lt;/code&gt; 编辑Gradle项目配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir -p src/main/kotlin src/test/kotlin&lt;/code&gt; 创建Kotlin目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vim src/main/kotlin/App.kt&lt;/code&gt; 编写Kotlin版HelloWorld&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gradle clean build run&lt;/code&gt; 使用Gradle清理、构建、运行，直接运行也可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idea .&lt;/code&gt; 用IntelliJ IDEA 打开项目，所有选项均选择默认，开始用IDE进行开发&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为什么要用命令行创建项目&quot;&gt;为什么要用命令行创建项目?&lt;/h3&gt;
&lt;p&gt;用图形化界面创建项目变量太多，人品不好容易掉坑里。用命令行创建项目，可以明确每个文件、每行代码的用途，整个过程可重现、可控制，还可以避免在IDE里某个步骤卡死半天没反应又结束不掉的尴尬。&lt;/p&gt;
&lt;h3 id=&quot;为什么要删除gradlewrapper&quot;&gt;为什么要删除GradleWrapper&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;很烦、很烦、很烦 我想安静一会儿&lt;/li&gt;
&lt;li&gt;很大、很大、很大 我硬盘不够你折腾&lt;/li&gt;
&lt;li&gt;很慢、很慢、很慢 我知道有堵墙，不用你三天两头提醒&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我不Care你的Gradle版本。编译不过我自然会升级Gradle构建脚本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;build.gradle&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;// 注意，这个文件是Gradle构建脚本，是脚本，里面的代码是先后执行的。至少`buildscript`要放在`apply plugin`的前面。
// 构建脚本
buildscript {
    // 插件依赖
    dependencies {
        // Kotlin插件对应的包
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.10&quot;
    }

    // 插件仓库。墙外人可直接用`mavencentral`、`jcenter`
    repositories {
        // 阿里的Maven中心仓库镜像
        maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
        // 阿里的jCenter镜像
        maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
    }
}

// 此插件添加了 `gradle run` 命令，通过Gradle运行项目
apply plugin: 'application'
// 此插件对Kotlin语言提供了支持，可以编译Kotlin文件
apply plugin: 'kotlin'

// application插件run的入口class
mainClassName = 'App'

// 项目依赖
dependencies {
    // Kotlin分为两部分，语言部分和库部分。kotlin插件对语言部分提供支持，`kotlin-stdlib`对库部分提供支持。哪怕HelloWorld中使用的`println`也在库中。所以是Kotlin项目的必选依赖
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;
}

// 项目仓库 
repositories {
    // Maven中心仓库墙内版
    maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
    // jCenter中心仓库墙内版
    maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;App.kt&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;class App {
    companion object {
        @JvmStatic
            fun main(args: Array&amp;lt;String&amp;gt;) {
                println(&quot;hello kt&quot;)
            }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以将代码放到类里头，是为了支持application插件，他需要指定一个含有JVM入口静态main方法的入口类。&lt;/p&gt;
&lt;p&gt;也可以用带main函数的app.kt，此时mainClassName应配置为&quot;AppKt&quot;&lt;/p&gt;
&lt;h2 id=&quot;用gradle构建kotlin版的springboot应用&quot;&gt;用Gradle构建Kotlin版的SpringBoot应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.gradle&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;buildscript {
    repositories {
        maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
        maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
    }
    dependencies {
        classpath 'org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.10'
        classpath 'org.springframework.boot:spring-boot-gradle-plugin:2.0.3.RELEASE'
    }
}
apply plugin: 'application'
apply plugin: 'kotlin'

// SpringBoot插件。Kotlin默认一切final，Spring又需要各种代理，所以需要特殊处理。同时提供`spring:bootRun`命令
apply plugin: 'org.springframework.boot'
// Spring依赖管理。自动选择依赖版本。Gradle中没有Maven那样内建的依赖管理(通过Parent POM 实现)，需要插件处理。
apply plugin: 'io.spring.dependency-management'

mainClassName = 'bj.App'

dependencies {
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib&quot; // Kotlin是要在JVM里跑的。那么多语言特性，没有依赖库怎么跑
    compile &quot;org.jetbrains.kotlin:kotlin-reflect&quot; // 无反射不Spring。反射不在Kotlin标准库，需单独添加
    compile 'org.springframework.boot:spring-boot-starter' // 创建单机应用所需要的最基本的Starter
}
repositories {
    maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
    maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bj/App.kt&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;package bj
import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.event.ApplicationReadyEvent
import org.springframework.context.ApplicationListener
/**
 * Created by BaiJiFeiLong@gmail.com at 18-6-27 下午10:08
 */
@SpringBootApplication
open class App : ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt; {
    override fun onApplicationEvent(event: ApplicationReadyEvent?) {
        println(&quot;Ready.&quot;)
    }
    companion object {
        @JvmStatic
        fun main(args: Array&amp;lt;String&amp;gt;) {
            SpringApplication.run(App::class.java, *args);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意:&lt;/p&gt;
&lt;p&gt;主类一定要放在包里头(不能用root或者说default)，否则报java.lang.ClassNotFoundException: org.springframework.dao.DataAccessException&lt;/p&gt;
&lt;h2 id=&quot;创建ktor应用&quot;&gt;创建Ktor应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.gradle&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;buildscript {
    dependencies {
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.10&quot;
    }
    repositories {
        maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
        maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
    }
}

apply plugin: 'application'
apply plugin: 'kotlin'

mainClassName = 'App'

dependencies {
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;
    // 2. 添加Ktor依赖
    compile &quot;io.ktor:ktor-server-netty:1.0.0-beta-3&quot;
    // 3.  添加Logback依赖。Ktor只依赖了Slf4J，没有Slf4J的具体实现。如果不导入一个Slf4J的实现，将打印不出日志来
    compile &quot;ch.qos.logback:logback-classic:1.2.3&quot;
}

repositories {
    maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
    maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
    // 1. 添加Ktor仓库。没出正式版，所以Maven中心仓没有最新版本
    maven { url &quot;https://dl.bintray.com/kotlin/ktor&quot; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bj/App.kt&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;import io.ktor.application.call
import io.ktor.http.ContentType
import io.ktor.response.respondText
import io.ktor.routing.get
import io.ktor.routing.routing
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty

class App {
    companion object {
        @JvmStatic
        fun main(args: Array&amp;lt;String&amp;gt;) {
            val server = embeddedServer(Netty, port = 8080) {
                routing {
                    get(&quot;/&quot;) {
                        call.respondText(&quot;xx&quot;, ContentType.Text.Plain)
                    }
                }
            }
            server.start(wait = true)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ktor应用打包&quot;&gt;Ktor应用打包&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.gradle&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gradle build&lt;/code&gt; 默认打包的jar不带Manifest，也不是FatJar，不能直接运行。添加&lt;code&gt;shadow&lt;/code&gt;插件后，将多打包出一个可以直接运行的FatJar&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;buildscript {
    dependencies {
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.10&quot;
        // 1. 添加shadow插件的依赖
        classpath &quot;com.github.jengelman.gradle.plugins:shadow:4.0.2&quot;
    }
    repositories {
        maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
        maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
    }
}

apply plugin: 'application'
apply plugin: 'kotlin'

// 2. 应用shadow插件
apply plugin: 'com.github.johnrengelman.shadow'

// 需要带main函数的kotlin文件main.kt或Main.kt
mainClassName = 'MainKt'

dependencies {
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;
    compile &quot;io.ktor:ktor-server-netty:1.0.0-beta-3&quot;
    // 用于组装HTML。非必选依赖
    compile &quot;io.ktor:ktor-html-builder:1.0.0-beta-3&quot;
    compile &quot;ch.qos.logback:logback-classic:1.2.3&quot;
}

repositories {
    maven { url &quot;https://maven.aliyun.com/repository/central&quot;  }
    maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot;  }
    maven { url &quot;https://dl.bintray.com/kotlin/ktor&quot; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ktor应用安装到docker&quot;&gt;Ktor应用安装到Docker&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;gradle build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vim Dockerfile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker build --tag=hellokt .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;docker run -it --rm -p 8080:8080 hellokt&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;Dockerfile&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;docker&quot;&gt;
&lt;code&gt;FROM openjdk:8-jre-alpine
RUN mkdir /app
COPY ./build/libs/hellokt-all.jar /app
WORKDIR /app
CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;hellokt-all.jar&quot; ]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ktor使用配置文件application.conf&quot;&gt;Ktor使用配置文件(application.conf)&lt;/h2&gt;
&lt;p&gt;Ktor使用配置文件，需要更改Application入口类，并在配置文件中指明模块，最后通过&lt;code&gt;gradle run&lt;/code&gt;命令运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main.kt&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;import io.ktor.application.Application
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.features.CallLogging
import io.ktor.features.DefaultHeaders
import io.ktor.response.respondText
import io.ktor.routing.Routing
import io.ktor.routing.get

/**
 * Created by BaiJiFeiLong@gmail.com at 18-11-18 下午12:10
 */

fun Application.main() {
    install(DefaultHeaders)
    install(CallLogging)
    install(Routing) {
        get(&quot;/&quot;) {
            call.respondText(&quot;Hello &quot;)
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;application.conf&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;放到Resources根目录&lt;/p&gt;
&lt;pre class=&quot;hocon&quot;&gt;
&lt;code&gt;ktor {
  deployment {
    port = 8088
  }

  application {
    modules = [MainKt.main]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在gradle构建脚本中更改mainClassName&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;mainClassName = 'io.ktor.server.netty.EngineMain'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在ktor项目中使用jwt&quot;&gt;在Ktor项目中使用JWT&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;build.gradle&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;buildscript {
    dependencies {
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.3.10&quot;
        classpath &quot;com.github.jengelman.gradle.plugins:shadow:4.0.2&quot;
    }
    repositories {
        maven { url &quot;https://maven.aliyun.com/repository/central&quot; }
        maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot; }
    }
}

apply plugin: 'application'
apply plugin: 'kotlin'
apply plugin: 'com.github.johnrengelman.shadow'

mainClassName = 'io.ktor.server.netty.EngineMain'

dependencies {
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;
    compile &quot;io.ktor:ktor-server-netty:1.0.0-beta-3&quot;
    compile &quot;io.ktor:ktor-html-builder:1.0.0-beta-3&quot;
    compile &quot;io.ktor:ktor-jackson:1.0.0-beta-3&quot;
    compile &quot;io.ktor:ktor-auth:1.0.0-beta-3&quot;
    compile &quot;io.ktor:ktor-auth-jwt:1.0.0-beta-3&quot;
    compile &quot;ch.qos.logback:logback-classic:1.2.3&quot;
}

repositories {
    maven { url &quot;https://maven.aliyun.com/repository/central&quot; }
    maven { url &quot;https://maven.aliyun.com/repository/jcenter&quot; }
    maven { url &quot;https://dl.bintray.com/kotlin/ktor&quot; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;main.kt&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;import com.auth0.jwt.JWT
import com.auth0.jwt.algorithms.Algorithm
import com.fasterxml.jackson.databind.SerializationFeature
import io.ktor.application.Application
import io.ktor.application.call
import io.ktor.application.install
import io.ktor.auth.Authentication
import io.ktor.auth.UserIdPrincipal
import io.ktor.auth.authenticate
import io.ktor.auth.jwt.jwt
import io.ktor.auth.principal
import io.ktor.features.CORS
import io.ktor.features.ContentNegotiation
import io.ktor.features.StatusPages
import io.ktor.http.HttpHeaders
import io.ktor.http.HttpMethod
import io.ktor.http.HttpStatusCode
import io.ktor.jackson.jackson
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.routing.get
import io.ktor.routing.post
import io.ktor.routing.route
import io.ktor.routing.routing
import java.util.*

/**
 * Created by BaiJiFeiLong@gmail.com at 18-11-18 下午12:10
 */

class InvalidCredentialsException(message: String) : RuntimeException(message)

data class Snippet(val user: String, val text: String)

data class PostSnippet(val snippet: Text) {
    data class Text(val text: String)
}

open class SimpleJwt(val secret: String) {
    private val algorithm = Algorithm.HMAC256(secret)
    val verifier = JWT.require(algorithm).build()
    fun sign(name: String): String = JWT.create().withClaim(&quot;name&quot;, name).sign(algorithm)
}

class User(val name: String, val password: String)

val users = Collections.synchronizedMap(
        listOf(User(&quot;test&quot;, &quot;test&quot;)).associateBy { it.name }.toMutableMap()
)

class LoginRegister(val user: String, val password: String)

val snippets = Collections.synchronizedList(mutableListOf(
        Snippet(&quot;demo&quot;, &quot;hello&quot;),
        Snippet(&quot;demo&quot;, &quot;world&quot;)
))

fun Application.main() {
//    install(DefaultHeaders)
//    install(CallLogging)
    val simpleJwt = SimpleJwt(&quot;my-super-secret-for-jwt&quot;)

    install(ContentNegotiation) {
        jackson {
            enable(SerializationFeature.INDENT_OUTPUT)
        }
    }
    install(Authentication) {
        jwt {
            verifier(simpleJwt.verifier)
            validate {
                UserIdPrincipal(it.payload.getClaim(&quot;name&quot;).asString())
            }
        }
    }
    install(StatusPages) {
        exception&amp;lt;InvalidCredentialsException&amp;gt; {
            call.respond(HttpStatusCode.Unauthorized, mapOf(&quot;OK&quot; to false, &quot;error&quot; to (it.message ?: &quot;&quot;)))
        }
    }
    install(CORS) {
        method(HttpMethod.Options)
        method(HttpMethod.Get)
        method(HttpMethod.Post)
        method(HttpMethod.Put)
        method(HttpMethod.Delete)
        method(HttpMethod.Patch)
        header(HttpHeaders.Authorization)
        allowCredentials = true
        anyHost()
    }
    routing {
        route(&quot;/snippets&quot;) {
            authenticate {
                get {
                    call.respond(mapOf(&quot;snippets&quot; to synchronized(snippets) {
                        snippets.toList()
                    }))
                }
            }
            authenticate {
                post {
                    val post = call.receive&amp;lt;PostSnippet&amp;gt;()
                    val principal = call.principal&amp;lt;UserIdPrincipal&amp;gt;() ?: error(&quot;No principle&quot;)
                    snippets += Snippet(principal.name, post.snippet.text)
                    call.respond(mapOf(&quot;OK&quot; to true))
                }
            }
        }

        post(&quot;/login-register&quot;) {
            val post = call.receive&amp;lt;LoginRegister&amp;gt;()
            val user = users.getOrPut(post.user) { User(post.user, post.password) }
            if (user.password != post.password) throw InvalidCredentialsException(&quot;Invalid credentials&quot;)
            call.respond(mapOf(&quot;token&quot; to simpleJwt.sign(user.name)))
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ktor与websocket&quot;&gt;Ktor与Websocket&lt;/h2&gt;
&lt;p&gt;需要添加Websocket的feature:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;compile &quot;io.ktor:ktor-websockets:1.0.0-beta-3&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main.kt&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;import io.ktor.application.Application
import io.ktor.application.install
import io.ktor.http.cio.websocket.DefaultWebSocketSession
import io.ktor.http.cio.websocket.Frame
import io.ktor.http.cio.websocket.readText
import io.ktor.routing.routing
import io.ktor.websocket.WebSockets
import io.ktor.websocket.webSocket
import java.util.*
import java.util.concurrent.atomic.AtomicInteger
import kotlin.collections.LinkedHashSet

/**
 * Created by BaiJiFeiLong@gmail.com at 18-11-18 下午12:10
 */

class ChatClient(val session: DefaultWebSocketSession) {
    companion object {
        var lastId = AtomicInteger(0)
    }

    val id = lastId.getAndIncrement()
    val name = &quot;user$id&quot;
}

fun Application.main() {
    install(WebSockets)

    routing {
        val wsConnections = Collections.synchronizedSet(LinkedHashSet&amp;lt;ChatClient&amp;gt;())

        webSocket(&quot;/chat&quot;) {
            val client = ChatClient(this)
            wsConnections += client
            try {
                while (true) {
                    val frame = incoming.receive()
                    when (frame) {
                        is Frame.Text -&amp;gt; {
                            val text = frame.readText()
                            for (conn in wsConnections) {
                                val txt = wsConnections.map { it.name }.joinToString(&quot;, &quot;)
                                conn.session.outgoing.send(Frame.Text(txt))
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                println(&quot;Exception: ${e.message}&quot;)
            } finally {
                println(&quot;A connection has gone&quot;)
                wsConnections -= client
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码实现的功能：广播消息到每个WS客户端&lt;/p&gt;
&lt;p&gt;文章首发: &lt;a href=&quot;http://baijifeilong.github.io/2018/11/18/kotlin-best-practice/&quot; class=&quot;uri&quot;&gt;http://baijifeilong.github.io/2018/11/18/kotlin-best-practice/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 15:57:00 +0000</pubDate>
<dc:creator>白季飞龙</dc:creator>
<og:description>为什么写此文 Kotlin很烦，Gralde很烦，还都是升级狂，加一块更烦。几个月不接触Kotlin，再次上手时便一片迷茫。所以记录此文，以便再次上手时查阅。 使用Gradle创建Kotlin项目 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baijifeilong/p/9980779.html</dc:identifier>
</item>
<item>
<title>synchronized基础 - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/9980604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/9980604.html</guid>
<description>&lt;h2&gt;synchronized 例子&lt;/h2&gt;
&lt;p&gt;例1，没有同步的时候运行同一个对象的同一个方法的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSyn {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestSyn testSyn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestSyn();
        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(10&lt;span&gt;);
        Runnable runnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn.showMsg();
            }
        };
        Runnable runnable2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn.showMsg();
            }
        };
        executorService.execute(runnable);
        executorService.execute(runnable2);
        executorService.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181118231418824-34801601.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，是同时在执行一个方法里面的内容，没有进行同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例2，当我们其它不变，只是在方法上加synchronized后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSyn {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181118231734655-791389923.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到是一个方法执行完后再执行下一次，已经进行了同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例3，我们在添加另外一个synchronized后观察运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSyn {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg2() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestSyn testSyn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestSyn();
        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(10&lt;span&gt;);
        Runnable runnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn.showMsg();
            }
        };
        Runnable runnable2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn.showMsg2();
            }
        };
        executorService.execute(runnable);
        executorService.execute(runnable2);
        executorService.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181118233020665-608582862.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;161&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发不同的两个方法依然进行了同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们重新新建一个对象，执行相同的同步函数观察结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSyn {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestSyn testSyn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestSyn();
        TestSyn testSyn2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestSyn();
        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(10&lt;span&gt;);
        Runnable runnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn.showMsg();
            }
        };
        Runnable runnable2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn2.showMsg();
            }
        };
        executorService.execute(runnable);
        executorService.execute(runnable2);
        executorService.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181118233811656-1940775743.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;168&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现不同对象的同一个方法没有进行同步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 例4，我们换成一个static方法添加synchronized后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSyn {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized static &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg2() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; i);
                Thread.sleep(&lt;/span&gt;200&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestSyn testSyn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestSyn();
        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(10&lt;span&gt;);
        Runnable runnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                testSyn.showMsg();
            }
        };
        Runnable runnable2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                TestSyn.showMsg2();
            }
        };
        executorService.execute(runnable);
        executorService.execute(runnable2);
        executorService.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201811/738818-20181118233402053-877129611.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发现又没有进行同步了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.某个对象实例内，synchronized aMethod(){}关键字可以防止多个线程访问对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法&lt;/p&gt;
&lt;p&gt;2.是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用&lt;/p&gt;
&lt;p&gt;3.如果同一对象两个synchronized方法一个是非static方法和static方法，是不相干扰的&lt;/p&gt;
&lt;p&gt;4.synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法&lt;/p&gt;

</description>
<pubDate>Sun, 18 Nov 2018 15:41:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>synchronized 例子 例1，没有同步的时候运行同一个对象的同一个方法的结果： 结果： 可以看到，是同时在执行一个方法里面的内容，没有进行同步 例2，当我们其它不变，只是在方法上加synchr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/9980604.html</dc:identifier>
</item>
<item>
<title>【11.18总结】从SAML出发在重定向中发现的XSS漏洞 - zoe宇</title>
<link>http://www.cnblogs.com/zz0eyu/p/9978447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zz0eyu/p/9978447.html</guid>
<description>&lt;p&gt;Write-up地址：&lt;a href=&quot;https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/&quot;&gt;How I Discovered XSS that Affects around 20 Uber Subdomains&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://twitter.com/Fady_Othman&quot;&gt;fady mohammed osman&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总算回家了，完全没想到这次要外出一个月，今天开始恢复更新。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;前几天忘记在哪里看到了这个write up的中文翻译了，当时也没看，今天打算写总结的时候刚好发现了这篇write-up，决定就是这篇了。&lt;/p&gt;
&lt;p&gt;这个在uber发现的漏洞实现上是&lt;span&gt;由logout时重定向引起的反射型XSS&lt;/span&gt;，是作者在分析uber的SAML功能时发现的，本来作者是打算做bypass SAML authentication的，但是没有成功，之后才转向分析其他可能的漏洞。&lt;/p&gt;
&lt;h2&gt;什么是SAML&lt;/h2&gt;
&lt;p&gt;在说SAML(Security Assertion Markup Language)之前，要先说一下什么是SSO(Single Sign-On)，SAML是SSO的一种解决方案。&lt;/p&gt;
&lt;p&gt;所有使用互联网的用户应该都知道登录是怎么回事，通过注册并登录一个网站应用，你就可以享受专门针对你个人的网站应用服务了。由于HTTP的无状态性，为了避免对一个网站应用的多次登录，网站应用会使用session ID(例如cookies)来标识用户，这样你只要登录一次该网站应用，在session ID有效期间就不需要再次登录了。但存在一个问题——cookies只在同一个domain下才有效。对于一个大型的网站，它可能有多个应用，而不同应用有不用的domain，这个时候使用cookies就不合适了。&lt;/p&gt;
&lt;p&gt;于是就出现了一个解决办法，网站单独建立一个身份提供者(Identity Provider)，该应用创建、维护并管理用户认证，而不同的应用作为服务提供者(Service Provider)，当用户登录一个应用时，应用会根据用户的origin将其重定向到身份提供者那里，身份提供者验证用户身份，返回一个响应，告诉服务提供者用户是否验证通过，若验证通过，用户就可以使用该应用了。提供一个典型的应用场景，打开淘宝(https://www.taobao.com/)和天猫(https://www.tmall.com/)页面，这时候两个都是未登录状态，如果你这时候登陆淘宝，再刷新天猫页面，会发现天猫页面也是登陆状态。&lt;/p&gt;
&lt;p&gt;实现SSO有多重方式，OpenID、Oauth和SAML等，这里要说的就是SAML，顾名思义，SAML是一个基于XML的开源标准数据格式，它规定了身份提供者和服务提供者之间交换认证信息等数据的数据格式，也就是说使用SAML，在应用向身份提供者请求验证用户时，两者之间是通过xml传递信息的。&lt;/p&gt;
&lt;h2&gt;漏洞发现过程&lt;/h2&gt;
&lt;p&gt; 在作者对uber的子域名进行扫描收集时，发现很多内部域名都会被重定向到&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;进行身份验证，onelogin是一个统一访问管理平台，提供基于SAML的SSO，而之前在使用SAML的应用中&lt;span&gt;已经存在一些身份认证绕过的漏洞&lt;/span&gt;，所以作者尝试寻找uber中是否存在这些漏洞，但是发现已经有人提交过了。&lt;/p&gt;
&lt;p&gt;根据上面对于SSO的介绍，我们知道当用户访问一个uber的内部网站(&lt;a href=&quot;https://carbon-prototype.uberinternal.com/&quot; target=&quot;_blank&quot;&gt;https://carbon-prototype.uberinternal.com:443/&lt;/a&gt;)时，会被重定向到&lt;code&gt;&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;，即有一个请求发向&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;，而登陆后&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;又会向内部网站返回一个响应，作者观察了发向&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;的请求，里面有一个使用base64编码&lt;code&gt;SAMLRequest的参数，通过解码可以获得接收响应的URL(&lt;a href=&quot;https://carbon-prototype.uberinternal.com/oidauth/saml_consume&quot; target=&quot;_blank&quot;&gt;https://carbon-prototype.uberinternal.com:443/oidauth/saml_consume&lt;/a&gt;)，这时作者再一次试图绕过身份认证，但是失败了，因此作者&lt;span&gt;对oidauth/这个目录进行扫描&lt;/span&gt;，想看一下有没有其他有趣的文件或目录&lt;/code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./dirsearch.py -u https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;carbon-prototype.uberinternal.com:443/oidauth/ -ejson&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://carbon-prototype.uberinternal.com:443/oidauth/logout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个页面吸引了作者的注意力，&lt;span&gt;因为logout功能通常会伴随着一个重定向，而这个过程中可能存在XSS漏洞&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;打开上面的页面，会被重定向到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=&lt;span&gt;https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&lt;/span&gt;&amp;amp;return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&amp;amp;splash_disabled=1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意里面的base参数，是一个URL，当作者把它修改为&lt;code&gt;javascript:alert(123);&lt;/code&gt;后，成功实现了反射型的XSS。&lt;/p&gt;
&lt;p&gt;最后作者通过脚本，找到所有接收SAML响应的网址，然后请求该域名下的&lt;code&gt;oidauth/prompt&lt;/code&gt;目录，看是否存在该反射型XSS漏洞&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1. 对一个新的应用进行测试时，可以看是否存在在其他应用中已经发现的漏洞&lt;/p&gt;
&lt;p&gt;2. 为什么会想到目录扫描：在请求包的数据中发现一个oidauth/目录&lt;/p&gt;
&lt;p&gt;3. logout功能可能存在XSS漏洞，值得进一步测试&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 15:36:00 +0000</pubDate>
<dc:creator>zoe宇</dc:creator>
<og:description>Write-up地址：How I Discovered XSS that Affects around 20 Uber Subdomains 作者：fady mohammed osman 总算回家了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zz0eyu/p/9978447.html</dc:identifier>
</item>
</channel>
</rss>