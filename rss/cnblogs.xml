<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>go 利用orm简单实现接口分布式锁 - 熔遁丶螺旋手里剑</title>
<link>http://www.cnblogs.com/baiyb/p/9352018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baiyb/p/9352018.html</guid>
<description>&lt;p&gt;&lt;span&gt;在开发中有些敏感接口，例如用户余额提现接口，需要考虑在并发情况下接口是否会发生问题。如果用户将自己的多条提现请求同时发送到服务器，代码能否扛得住呢？一旦没做锁，那么就真的会给用户多次提现，给公司带来损失。我来简单介绍一下在这种接口开发过程中，我的做法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一阶段:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用的orm为xorm，提现表对应的结构体如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type Participating struct {
        ID      uint          `xorm:&quot;autoincr id&quot; json:&quot;id,omitempty&quot;`
        Openid  string        `xorm:&quot;openid&quot; json:&quot;openid&quot;`
        Hit     uint          `xorm:&quot;hit&quot; json:&quot;hit&quot;`
        Orderid string        `xorm:&quot;order_id&quot; json:&quot;order_id&quot;`
        Redpack uint          `xorm:&quot;redpack&quot; json:&quot;redpack&quot;`
        Status  uint          `xorm:&quot;status&quot; json:&quot;status&quot;`
        Ctime   tool.JsonTime `xorm:&quot;ctime&quot; json:&quot;ctime,omitempty&quot;`
        Utime   tool.JsonTime `xorm:&quot;utime&quot; json:&quot;utime,omitempty&quot;`
        PayTime tool.JsonTime `xorm:&quot;pay_time&quot; json:&quot;pay_time,omitempty&quot;`
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在Participating表中，是以Openid去重的，当一个Openid对应的Hit为1时，可以按照Redpack的数额提现，成功后将Status改为1，简单来说这就是提现接口的业务逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;起初我并没有太在意并发的问题，我在MySQL的提现表中设置一个字段status来记录提现状态，我只是在提现时将状态修改为2(体现中)，提现完成后将status修改为1(已提现)。然后事实证明，我太天真了，用ab做了测试1s发送了1000个请求到服务器，结果。。。成功提现了6次。部分代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
p_info := &amp;amp;Participating{}&lt;br/&gt;// 查找具体提现数额
has, _ := db.Dalmore.Where(&quot;openid = ? and hit = 1 and status = 0&quot;, openid).Get(p_info)
if !has {
        resp.Error(errcode.NO_REDPACK_FOUND, nil, nil)
        return
}

// 改status为提现中
p_info.Status = 2
db.Dalmore.Cols(&quot;status&quot;).Where(&quot;openid = ? and hit = 1 and status = 0&quot;, openid).Update(p_info)

// 提现p_info.Redpack
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二阶段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然出现了并发问题，那第一反应肯定的加锁啊，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type Set struct {
        m map[string]bool
        sync.RWMutex
}

func New() *Set {
        return &amp;amp;Set{
                m: map[string]bool{},
        }
}

var nodelock = set.New()

// 加锁
nodelock.Lock()

p_info := &amp;amp;Participating{}
// 查找具体提现数额
has, _ := db.Dalmore.Where(&quot;openid = ? and hit = 1 and status = 0&quot;, openid).Get(p_info)
if !has {
        resp.Error(errcode.NO_REDPACK_FOUND, nil, nil)
        return
}

// 改status为提现中
p_info.Status = 2
db.Dalmore.Cols(&quot;status&quot;).Where(&quot;openid = ? and hit = 1 and status = 0&quot;, openid).Update(p_info)

// 释放锁
nodelock.Unlock()

// 提现p_info.Redpack
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;加了锁以后。。。emem，允许多次提现的问题解决了，但是这个锁限制的范围太多了，直接让这段加锁代码变成串行，这大大降低了接口性能。而且，一旦部署多个服务端，这个锁又会出现多次提现的问题，因为他只能拦住这一个服务的并发。看来得搞一个不影响性能的分布式才是王道啊。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三阶段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用redis，设置一个key为openid的分布式锁，并设置一个过期时间可以解决当前的这个问题。但是难道就没别的办法了吗？当然是有的，golang的xorm中Update函数其实是有返回值的：num,err，我就是利用num做了个分布式锁。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
//记录update修改条数
num, err := db.Dalmore.Cols(&quot;status&quot;).Where(&quot;openid = ? and status = 0 and hit = 1&quot;, openid).Update(p_update)
if err != nil {
        logger.Runtime().Debug(map[string]interface{}{&quot;error&quot;: err.Error()}, &quot;error while updating&quot;)
        resp.Error(errcode.INTERNAL_ERROR, nil, nil)
        return
}

// 查看update操作到底修改了多少条数据，起到了分布式锁的作用
if num != 1 {
        resp.Error(errcode.NO_REDPACK_FOUND, nil, nil)
        return
}

p_info := &amp;amp;Participating{}
_, err := db.Dalmore.Where(&quot;openid = ? and status = 2&quot;, openid).Get(p_info)
if err != nil {
        logger.Runtime().Debug(map[string]interface{}{&quot;error&quot;: err.Error()}, &quot;error while selecting&quot;)
        resp.Error(errcode.INTERNAL_ERROR, nil, nil)
        return
}

// 提现p_info.Redpack
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;其实有点投机取巧的意思，利用xorm的Update函数，我们将核对并发处理请求下数据准确性的问题抛给了MySQL，毕竟MySQL是经过千锤百炼的。再用ab测试，嗯，锁成功了只有，只提现了一次，大功告成～&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;希望对大家有所帮助，祝大家每天开心～&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 15:22:00 +0000</pubDate>
<dc:creator>熔遁丶螺旋手里剑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baiyb/p/9352018.html</dc:identifier>
</item>
<item>
<title>golang 重构博客统计服务 - haifeiWu</title>
<link>http://www.cnblogs.com/haifeiWu/p/9351976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifeiWu/p/9351976.html</guid>
<description>&lt;p&gt;欢迎关注楼主与他的小伙伴们的小站，每周分享一些技术文章，让我们在技术上一起成长------&amp;gt; &lt;a href=&quot;http://www.hchstudio.cn/&quot; title=&quot;戳这里，欢迎光临小站 -_-&quot;&gt;戳这里，欢迎光临小站 -_-&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作为一个后端开发，在docker，etcd，k8s等新技术不断涌现的今天，其背后的功臣golang在语言排行榜上持续走高，因此楼主也就开了这次使用golang自己开发的基础功能的二次装逼之旅。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;源于spring-boot&quot;&gt;源于Spring Boot&lt;/h2&gt;
&lt;p&gt;感兴趣的小伙伴可以看看楼主的上一篇，基于Spring Boot实现的功能，请移步&lt;a href=&quot;http://www.hchstudio.cn/article/2018/6f25/&quot; title=&quot;使用Spring Boot实现博客统计服务&quot;&gt;使用Spring Boot实现博客统计服务&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现redis存储逻辑&quot;&gt;实现redis存储逻辑&lt;/h2&gt;
&lt;p&gt;选择redis而没选择数据库的原因是redis提供了丰富的数据结构与数据持久化策略，另外redis是基于内存的，相对于数据库来说，快了不止一个数量级。而统计阅读次数的场景对接口处理的速度还是有一定的要求的，因此楼主选择了redis作为阅读次数统计的db。&lt;br/&gt;下面就是redis操作的基础代码，比较简单楼主贴一下代码，不做进一步的阐述。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;redigo依赖下载&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;go get github.com/gomodule/redigo/redis&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;redis操作的工具类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func initRedisPool() {
    // 建立连接池
    RedisClient = &amp;amp;redis.Pool{
        // 从配置文件获取maxidle以及maxactive，取不到则用后面的默认值
        MaxIdle:     1,
        MaxActive:   10,
        IdleTimeout: 180 * time.Second,
        Dial: func() (redis.Conn, error) {
            c, err := redis.Dial(&quot;tcp&quot;, RedisAddress)
            if err != nil {
                return nil, err
            }
            // 选择db
            c.Do(&quot;SELECT&quot;, RedisDb)
            return c, nil
        },
    }
}

/**
 * 设置redis的对应key的value
 */
func redisSet(key string, value string) {
    c, err := RedisClient.Dial()
    if err != nil {
        fmt.Println(&quot;Connect to redis error&quot;, err)
        return
    }
    _, err = c.Do(&quot;SET&quot;, key, value)
    if err != nil {
        fmt.Println(&quot;redis set failed:&quot;, err)
    }
}

/**
 * 获取redis的对应key的value
 */
func redisGet(key string) (value string) {
    c, err := RedisClient.Dial()
    if err != nil {
        fmt.Println(&quot;Connect to redis error&quot;, err)
        return
    }
    val, err := redis.String(c.Do(&quot;GET&quot;, key))
    if err != nil {
        fmt.Println(&quot;redis get failed:&quot;, err)
        return &quot;&quot;
    } else {
        fmt.Printf(&quot;Got value is %v \n&quot;, val)
        return val
    }
}

/**
 * redis使得对应的key的值自增
 */
func redisIncr(key string) (value string) {
    c, err := RedisClient.Dial()
    _, err = c.Do(&quot;INCR&quot;, key)
    if err != nil {
        fmt.Println(&quot;incr error&quot;, err.Error())
    }

    incr, err := redis.String(c.Do(&quot;GET&quot;, key))
    if err == nil {
        fmt.Println(&quot;redis key after incr is : &quot;, incr)
    }
    return incr
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;博客阅读次数统计接口实现&quot;&gt;博客阅读次数统计接口实现&lt;/h2&gt;
&lt;p&gt;博客阅读次数统计的基本业务逻辑就是，对应每篇博客的blogId作为redis的key，而访问次数就是这个key所对应的value，每访问一次该接口就要将对应的blogId自增一次，并返回对应的value。这里楼主选择的redis的数据结构是redis的Stirng，下面是楼主实现该逻辑的主要代码：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;github.com/garyburd/redigo/redis&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;time&quot;
    &quot;strings&quot;
)

const RedisAddress = &quot;127.0.0.1:6379&quot;
const RedisDb = 0

const AllowRequestUrlH = &quot;*&quot;
const  AllowRequestUrlW = &quot;*&quot;
const  IllegalCharacters = &quot;?&quot;
const  DefaultReadCount = &quot;1&quot;

var (
    // 定义常量
    RedisClient *redis.Pool
)

func main() {
    // 初始化redis连接池
    initRedisPool()

    // 启动web服务监听
    http.HandleFunc(&quot;/*-*/*/&quot;, blogReadCountIncr)       //设置访问的路由
    err := http.ListenAndServe(&quot;:9401&quot;, nil) //设置监听的端口
    if err != nil {
        log.Fatal(&quot;ListenAndServe: &quot;, err)
    }
}

func blogReadCountIncr(responseWriter http.ResponseWriter, request *http.Request) {

    // 解析参数，默认不解析
    request.ParseForm()

    blogId := request.Form.Get(&quot;blogId&quot;)

    log.Println(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; method blogReadCountIncr exec , request params is : &quot;,blogId)

    // 判断请求参数是否为空
    if &quot;&quot; == blogId {
        result := ResultCode{
            Code: 200,
            Msg:  &quot;success&quot;,
        }

        ret, _ := json.Marshal(result)
        fmt.Fprintf(responseWriter, string(ret)) //这个写入到w的是输出到客户端的
    }
    
    readCount := redisGet(blogId)
    if &quot;&quot; == readCount {
        // 不符合规则，直接返回
        flag := strings.Index(blogId, AllowRequestUrlH) != 0 ||strings.Index(blogId, AllowRequestUrlW) != 0||strings.Contains(blogId, IllegalCharacters)
        if  !flag {
            result := ResultCode{
                Code: 200,
                Msg:  &quot;success&quot;,
            }

            ret, _ := json.Marshal(result)
            fmt.Fprintf(responseWriter, string(ret)) //这个写入到w的是输出到客户端的
        }

        redisSet(blogId, DefaultReadCount)
        readCount = DefaultReadCount
    } else {
        readCount = redisIncr(blogId)
    }
    log.Println(&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; readCount is : &quot;,readCount)
    result := ResultCode{
        Code: 200,
        Msg:  &quot;success&quot;,
        Data: readCount,
    }
    ret, _ := json.Marshal(result)
    fmt.Fprintf(responseWriter, string(ret)) //这个写入到w的是输出到客户端的
}
// 结构体定义返回值
type ResultCode struct {
    Msg  string `json:&quot;msg&quot;`
    Code int    `json:&quot;code&quot;`
    Data string `json:&quot;data&quot;`
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现过程中遇到的坑&quot;&gt;实现过程中遇到的坑&lt;/h2&gt;
&lt;h3 id=&quot;出现的问题&quot;&gt;出现的问题&lt;/h3&gt;
&lt;p&gt;使用golang原生的json工具序列化时，出现序列化失败的问题，如下所示的结构体定义，乍一看是没啥问题的，然而使用&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;ret, _ := json.Marshal(result)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;序列化时，出现无法序列化成json串的问题，另外还不报错，这让楼主很是头疼。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type ResultCode struct {
    msg  string `json:&quot;msg&quot;`
    code int    `json:&quot;code&quot;`
    data string `json:&quot;data&quot;`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题解决&quot;&gt;问题解决&lt;/h3&gt;
&lt;p&gt;最终楼主通过各种姿势的排查，发现是结构体定义有问题，当定义结构体时首字母必须大写才能序列化成功，这个特点在golang里面很是明显，在函数调用时首字母小写的函数在其他文件里面是调不到的。下面给出正确的结构体定义&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type ResultCode struct {
    Msg  string `json:&quot;msg&quot;`
    Code int    `json:&quot;code&quot;`
    Data string `json:&quot;data&quot;`
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;目前很多大佬都写过关于golang web的教程，如有雷同，请略过不看，本文通过自己的亲身实战以及楼主自己踩到的坑完成的，另外本文是基于go内置的&lt;strong&gt;net/http&lt;/strong&gt;库实现的web服务。&lt;/p&gt;
&lt;h2 id=&quot;号外&quot;&gt;号外&lt;/h2&gt;
&lt;p&gt;楼主造了一个轮子，LIGHTCONF 是一个基于Netty实现的一个配置管理平台，其核心设计目标是“为业务提供统一的配置管理服务”，可以做到开箱即用。感兴趣的给个star支持一下。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 15:14:00 +0000</pubDate>
<dc:creator>haifeiWu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifeiWu/p/9351976.html</dc:identifier>
</item>
<item>
<title>Hystrix降级逻辑中如何获取触发的异常 - 程序猿DD</title>
<link>http://www.cnblogs.com/didispace/p/9351981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/didispace/p/9351981.html</guid>
<description>&lt;p&gt;通过之前Spring Cloud系列教程中的&lt;a href=&quot;http://blog.didispace.com/spring-cloud-starter-dalston-4-1/&quot;&gt;《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》&lt;/a&gt;一文，我们已经知道如何通过Hystrix来保护自己的服务不被外部依赖方拖垮的情况。但是实际使用过程中经常碰到开发反应“莫名”触发了降级逻辑的情况。为了更精准的定位触发原因，或是在降级逻辑中需要根据不同的异常做不同的处理时，在降级方法中，我们希望可以获取到主逻辑中抛出的异常信息。接下来就来介绍一下Hystrix两种不同实现方式中如何在降级逻辑中获取异常信息的方法。&lt;/p&gt;
&lt;h3 id=&quot;注解方式&quot;&gt;注解方式&lt;/h3&gt;
&lt;p&gt;先介绍一下用注解方式定义的Hystrix命令是如何在降级逻辑中获取异常的，实现非常简单，先看下面的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@HystrixCommand(fallbackMethod = &quot;fallback&quot;)
User getUserById(String id) {
    throw new RuntimeException(&quot;getUserById command failed&quot;);
}

User fallback(String id, Throwable throwable) {
    return new User(&quot;def&quot;, &quot;def&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了一个主逻辑函数&lt;code&gt;getUserById&lt;/code&gt;，主逻辑中会主动抛出一个异常，从而触发该主逻辑的降级函数&lt;code&gt;fallback&lt;/code&gt;。重点看&lt;code&gt;fallback&lt;/code&gt;函数中的最后一个传参&lt;code&gt;Throwable throwable&lt;/code&gt;。通过这样的简单定义，开发人员就可以很方便的获取触发降级逻辑的异常信息，用作日志记录或者其它复杂的业务逻辑了。&lt;/p&gt;
&lt;h3 id=&quot;继承方式&quot;&gt;继承方式&lt;/h3&gt;
&lt;p&gt;在继承方式中要获取触发异常也非常简单，具体如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static class UserCommand extends HystrixCommand&amp;lt;User&amp;gt; {

    protected UserCommand() {
        super(HystrixCommandGroupKey.Factory.asKey(&quot;UserCommand&quot;));
    }

    @Override
    protected User run() throws Exception {
        throw new RuntimeException(&quot;getUserById command failed&quot;);
    }

    @Override
    protected User getFallback() {
        System.out.println(getFailedExecutionException().getMessage());
        return new User(&quot;def&quot;, &quot;def&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的实现同上一节注解方式的实现一样，在使用继承方式的时候通过&lt;code&gt;getFailedExecutionException&lt;/code&gt;方法就可以获取到触发降级的异常信息了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;我们在实际使用Hystrix的时候，有时候一些业务异常或者内部RPC由服务提供方抛出的异常在消费方没能考虑周到，会触发一些意料之外的降级。所以在降级逻辑中，建议每一段都加入触发异常的日志记录，以方便定位问题原因。&lt;/p&gt;
&lt;h4 id=&quot;以下专题教程也许您会有兴趣&quot;&gt;以下专题教程也许您会有兴趣&lt;/h4&gt;
</description>
<pubDate>Sun, 22 Jul 2018 15:14:00 +0000</pubDate>
<dc:creator>程序猿DD</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/didispace/p/9351981.html</dc:identifier>
</item>
<item>
<title>【原创】一个安卓程序媛的人生经验 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9351626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9351626.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;博主有一个差不多认识了9年的程序媛朋友，从09年读大一开始认识的，现在已经毕业五年，所以相识是九年。目前她就职于网龙、是一个做安卓组件开发的程序媛，&lt;strong&gt;已婚&lt;/strong&gt;。本文基本上反应了她的心酸血泪史，经其同意，整理成文。为了方便描述，下面的第一人称&quot;我&quot;指的就是该妹纸本人。&lt;/p&gt;
&lt;h2 id=&quot;糊里糊涂的大学生涯&quot;&gt;糊里糊涂的大学生涯&lt;/h2&gt;
&lt;p&gt;高考毕业后，也不知道自己的兴趣是啥，稀里糊涂的报了一个专业，最后阴差阳错的来了一个电子类专业。来了这个专业后，发现了一个现象。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;大部分就读工科专业的妹纸，都是瞎选的，要么就是调剂。基本上，对本专业都缺乏一个了解。而且大部分抱着一个混学历的心态来读，都不知道自己将来要做什么&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(博主ps：博主明白强迫自己学一个自己不敢兴趣的科目是件多无聊的事情。所以针对这个现象，并不是很排斥，毕竟有些人的家境，并不需要太努力的奋斗。)&lt;/p&gt;
&lt;p&gt;大一上，无外乎就是一些公共课什么的，计算机一级考的是一些关于word、excel等操作，和编程没有什么关系。所以严格算起来，第一次接触到编程，是在大一下学期的C语言课程。非常有意思的是，没接触过编程的我，最后计算机二级考试居然考了满分。当时，我就明白，我在编程方面有着一种天赋，起码不会排斥。&lt;br/&gt;俗话说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;兴趣是最好的老师&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对编程有兴趣的我，本来应该在这个领域继续深造。然而在大二和大三并没有接触到其他语言，因此水平一直停滞不前。或许你会说，你可以去自学啊。这里要说一下，我在大学期间的性格是属于一种&lt;strong&gt;需要外界给予一定压力和指导，才会去学习。&lt;/strong&gt; 换句话说，如果当初大一下的C语言不需要参加计算机二级考试，我就不会那么努力学习，不会发现自己在编程方面的天赋。因此大二和大三，仅仅满足于上课所传授的知识，沉溺于奖学金的优越感之中。&lt;br/&gt;转眼间到了大四，那会是12年。记得11年的时候，NOKIA的塞班机基本上已经退出市场，android那会的火热程度就和现在的微服务一样，于是当时就想着毕业从事一个和android开发相关的工作。由于自己性格的原因，选了一个android的项目作为自己的毕业设计。前面也说了，我需要一定压力来逼迫自己，才会有动力去做。所以在自己没有任何JAVA基础的情况下，选android项目作为自己的毕业设计，也是希望逼迫自己学有所成。这里有一点需要注意，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;自学过程中最大的敌人，就是寂寞&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;坦白说，在学习过程中，不止一次怕来不及，怕做不出来毕设，怕毕不了业，不止一次动过要去某宝买一个的念头。而且一个人默默的学习，遇到不会的，容易浮躁。当时只有一个信念,我一定能做出来。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;当一个人的心中有着更高的山峰想去攀登时,他就不会在意脚下的泥沼,他才可能用最平静的方式去面对一般人难以承受的痛苦&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后的结果就是，我做出来了，是一个支持各种格式的手机端阅读器。有意思的是，这个项目当时拿到了优秀毕业设计。也因为这个项目找到了工作。(大家想想，面试的时候，直接掏出手机晒自己的项目，比简历上写一堆经验有意义的多了。)&lt;/p&gt;
&lt;h2 id=&quot;懵懵懂懂的工作生涯&quot;&gt;懵懵懂懂的工作生涯&lt;/h2&gt;
&lt;p&gt;工作时第一家公司，是一家创业小公司，做的是影城里头的那种，订票的APP。这里有几条经验其实需要和大家进行分享。&lt;br/&gt;千万不要有如下想法&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;因为我是女生，所以我编程水平不好也很正常。&lt;br/&gt;我是安卓端的，不懂后端知识也没关系&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;坦白说，我很讨厌女生有这种想法。人一旦有了这种想法，就给自己套上了一层枷锁，无法发挥出自己的潜力。我们必须承认一点，人都是有惰性的。而且经常会给自己的懒惰，找寻各种各样的合理的理由。比如，把这个电视剧看完，再开始学习，等等。总之，你只要给自己找了一个这样的理由，每次你偷懒的时候，都会以这种理由给自己洗脑。从此，技术水平止步不前，它会成为你不思进取的借口。&lt;br/&gt;或许正是因为，自己没有给自己套上这层枷锁，在毕业后的一年内努力学习，于是跳槽进入了网龙。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;女程序员在工作过程中，受到优待。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上有一个图很出名，如下所示&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1248587/o_nvchengxuyuan.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个情况在工作中，确实还是存在的。其实可能是因为开发行业，男生比较多的原因，女生会受到优待一些。基本上女程序员遇到问题，一些男程序员会加班给你调BUG，当然加班程度取决于颜值。至于男程序员们遇到问题，那就真的只能靠自己了。但是，大家要注意&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;一些能百度到的问题，就不要去咨询同事&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里就不得不说了，有些同事，特别是女同事吧。反正总爱问一些，比如环境怎么搭建这种问题。坦白说，这些问题，你问出去了，只会耽误老员工的时间。人家脾气好，跟你说。遇到一些脾气差的，索性就直接不理你了。总之，予人方便就是予己方便。像一些业务上的知识就是可以去问老员工，千万不要去问一些什么语法啊、环境搭建的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;做好自己的职业规划&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;男生和女生还是存在着很大的体力差距的，这个不得不承认。包括在很多长辈眼里，都是觉得:&quot;女生嘛，找一个轻松的工作，将来嫁人就好了。&quot;&lt;br/&gt;这里我想说的是在当程序员的时候，还是要保持一种学习的热情。就我来说，目前还是这种学习的热情还是没有褪去。如果一旦发现自己的学习热情褪去，就可以思考一下自己是否能在开发的路上走的更远，是不是做管理会更合适呢？不过，不可否认，肯定会有一些直男癌患者，跟你说:&quot;你们女生体力不行啊，什么什么的，就应该去切切图，做做产品啊，什么什么的。&quot;对于这一切质疑，我们要要走自己的路。&lt;br/&gt;有一句话叫做&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;行亦禅,坐亦禅,语默动静体安然。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大致意思就是，不论你在做什么事,心中感到自在安然，这就是禅。人生有很多痛苦都是因为别人的&quot;中伤&quot;，我们都避免不了心中会有疑虑，只要拥有一颗安详的心，别人就不可能在此作怪。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意护发&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当程序员后，一定要注意自己的发际线。女生也不例外，大家要注意保养。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 14:52:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9351626.html</dc:identifier>
</item>
<item>
<title>PostgreSQL&gt;窗口函数的用法 - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/9311281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/9311281.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PostgreSQL之窗口函数的用法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;转载请注明出处:&lt;span&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: PostgreSQL==&amp;amp;gt;窗口函数的用法&quot; href=&quot;https://www.cnblogs.com/funnyzpc/p/9311281.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/funnyzpc/p/9311281.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;PostgreSQL的高级特性本准备三篇的(&lt;strong&gt;递归、窗口函数、JSON&lt;/strong&gt;)，结果中间一直一直加班 和遗忘 拖到现在才写到中篇，欸，加班真不是一件好事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　谈谈我对加班的看法吧=&amp;gt; 如果加班能控制在一个小时内，这样会比较好(当然如果不加班的话更好)，偶尔适当的加班能提高工作进度，对创业公司来说尤为重要；但，糟糕的地方也不少，加班时间长了容易造成思维缓慢，这对脑子本来就不快的人来说伤害尤其的大(我就是个例子)，也容易造成&lt;span&gt;颈椎病、高血压、过劳。。。&lt;/span&gt;等等可怕的疾病，尤其还是做IT的一定要注意到这个问题，以上这些话可能有童鞋不会在意，那我就在这里说说我见过的真实的例子，我上一家公司的CTO有比较严重的脊椎病，(他说)坐的时间久了背部尤其的难受，上一家公司总监也经常加班，可能再加上本身体质的原因，心脏现在已经装上了起搏器，同样是上一家公司，我的一同事，也就比我大三岁左右，头发已经有相当部分白了哎，每见到这样的事儿都很难受，人一辈子，&lt;span&gt;如果没有足够的时间去关注生活，关注健康，我们生活内容还剩下什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这次我就简单的讲讲PostgreSQL的高级特性&amp;gt;&lt;strong&gt;&lt;span&gt;窗口函数&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我先用表格列出PostgreSQL里面的窗口函数，(源文档在这里&amp;gt;&lt;a href=&quot;http://www.postgres.cn/docs/9.3/functions-window.html&quot; target=&quot;_blank&quot;&gt;http://www.postgres.cn/docs/9.3/functions-window.html&lt;/a&gt;，推荐去postgre的中文社区看看)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722215233411-946735430.png&quot; alt=&quot;&quot; width=&quot;1130&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　讲第一个问题之前我先扔出一个需求&amp;gt;&lt;span&gt;如何给查询出来的数据添加一列序号，用最简单的方式实现？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;Oracle&amp;gt;使用&lt;code&gt;rownum快速生成&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　MySql&amp;gt;使用变量定义:(@i:=@i+1)  as row&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　SqlServer&amp;gt;通过定义存储过程的方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　PostgreSQL&amp;gt;通过函数generate_series(start_value,end_value)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;额，以上方式我大概都用过，对于Oracle的方式虽然语句简单，但是涉及到排序的时候可就乱了，mysql的方式也还算可以，但是这样并没有通用性，子查询的时候会相当麻烦,同时个人觉得这更像是存储过程和sql的结合体，也破坏了Sql本该有的形式，PostgreSQL的方式虽然不错，但是总要指定起始和终止值，这个在生成测试数据的时候还好用，具体业务开发用起来可就麻烦多了；这里，当然有更好的实现方式&amp;gt;窗口函数，这个属性在主流的数据库系统中都有实现(以前用oracle的时候竟然没发现这么好用的东西，好遗憾)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里我先放出表结构语句&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;107&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&quot;.&quot;products&quot;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&quot;.&quot;products&quot; (
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &quot;id&quot; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) COLLATE &quot;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &quot;name&quot; &lt;span&gt;text&lt;/span&gt; COLLATE &quot;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    &quot;price&quot; numeric,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &quot;uid&quot; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;14&lt;/span&gt;) COLLATE &quot;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &quot;type&quot; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;) COLLATE &quot;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;WITH&lt;/span&gt; (OIDS&lt;span&gt;=&lt;/span&gt;&lt;span&gt;FALSE);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0006&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;iPhone X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;9600&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;电器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0012&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;电视&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3299&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;电器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0004&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;辣条&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;零食&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0007&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;薯条&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;零食&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0009&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;方便面&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;零食&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0005&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;铅笔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;文具&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0014&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;作业本&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;文具&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;鞋子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;衣物&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;外套&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;110.9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;衣物&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0013&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;围巾&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;衣物&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0008&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;香皂&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;17.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;日用品&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0010&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;水杯&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;日用品&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0015&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;洗发露&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;日用品&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0011&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;毛巾&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;日用品&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;手表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1237.55&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;电器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0016&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;绘图笔&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;文具&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; &quot;&lt;span&gt;public&lt;/span&gt;&quot;.&quot;products&quot; &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0017&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;汽水&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;零食&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;COMMIT&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这我先用第一个函数&lt;strong&gt;&lt;span&gt;row_number()&lt;/span&gt;&lt;/strong&gt; ,一句即可实现&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;select&lt;/span&gt; type,name,price,&lt;span&gt;row_number() over(order by price asc)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; idx &lt;span&gt;from&lt;/span&gt; products ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722200836747-1526044110.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;572&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用窗口函数的好处不仅仅可实现序号列，还可以在&lt;span&gt;over()内按指定的列排序&lt;/span&gt;,上图是按照price列升序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里，对于以上提到的一个问题，根据上面的数据 我再做个扩充&amp;gt;&lt;span&gt;如果需要在类别(type)内按照价格(price) 升序排列(就是在类别内做排序)，该怎么做呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然也很简单，只需要在窗口(over())中声明分隔方式 &lt;span&gt;Partition&lt;/span&gt; .&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分类排序序号，&lt;span&gt;&lt;strong&gt;row_number()&lt;/strong&gt;&lt;/span&gt; 实现&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;select&lt;/span&gt; type,name,price,&lt;span&gt;&lt;strong&gt;row_number&lt;/strong&gt;() over(&lt;strong&gt;PARTITION by type&lt;/strong&gt; order by price asc)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; idx &lt;span&gt;from&lt;/span&gt; products ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　查询结果&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722201834884-294564251.png&quot; alt=&quot;&quot; width=&quot;689&quot; height=&quot;580&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　上面的问题这里需求完美实现，额，这里其实还可以做个扩充，你可以注意到零食类别内的 方便面和汽水价格是一样的，如何将零食和汽水并列第一呢？答案是：用窗口函数&amp;gt;rank()&lt;/p&gt;
&lt;p&gt;　　 分类排序序号并列, &lt;span&gt;&lt;strong&gt;rank()&lt;/strong&gt;&lt;/span&gt; 实现&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; type,name,price,&lt;span&gt;&lt;strong&gt;rank&lt;/strong&gt;() over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　SQL输出&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722202449769-927619589.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;570&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需求又完美的实现了，但，注意到没，零食类别中的第三个 辣条 排到第三了，如果这里需要在类别里面能保持序号不重不少(将辣条排名至第二)，如何实现呢？答案&amp;gt;使用窗口函数 dense_rank()&lt;/p&gt;
&lt;p&gt;　　分类排序序号并列顺序，&lt;span&gt;&lt;strong&gt;dense_rank()&lt;/strong&gt;&lt;/span&gt; 实现&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; type,name,price,&lt;span&gt;&lt;strong&gt;dense_rank&lt;/strong&gt;() over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　SQL输出&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722202948595-702088249.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;611&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　OK,以上的几个窗口函数已经能实现大多数业务需求了，如果有兴趣可以看看一些特殊业务可能用到的功能，&lt;span&gt;比如说如何限制序号在0到1之间排序呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　限制序号在0~1之间(0作为第一个序),窗口函数 &lt;span&gt;&lt;strong&gt;percernt_rank&lt;/strong&gt;()&lt;/span&gt; &amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; type,name,price,&lt;span&gt;&lt;strong&gt;percent_rank&lt;/strong&gt;() over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　 SQL语句输出&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722203531042-741263884.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;544&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意:上面的percernt_rank()函数默认是从0开始排序的，如果需要使用相对0~1之间的排名，需要这样：&lt;/p&gt;
&lt;p&gt;　　限制序号在0~1之间相对排名，窗口函数 &lt;strong&gt;&lt;span&gt;cume_dist()&lt;/span&gt;&lt;/strong&gt; 实现&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; type,name,price,&lt;span&gt;&lt;strong&gt;cume_dist&lt;/strong&gt;() over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL语句输出&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722204113279-1476362126.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;563&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意:上面的序号是相对于0开始排序的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于排序序号还可以限制最大序号，这样做：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　限制最大序号为&lt;span&gt;指定数字序号&lt;/span&gt; &lt;span&gt;&lt;strong&gt;ntile(val1)&lt;/strong&gt;&lt;/span&gt; 实现 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; type,name,price,&lt;span&gt;&lt;strong&gt;ntile&lt;/strong&gt;(&lt;span&gt;2&lt;/span&gt;) over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL语句输出 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722204551406-1005087275.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;551&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;窗口函数还可以实现在子分类排序的情况下取偏移值，这样实现&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　获取到排序数据的每一项的偏移值(&lt;span&gt;向下偏移&lt;/span&gt;) , &lt;span&gt;l&lt;strong&gt;ag(val1,val2,val3)&lt;/strong&gt;&lt;/span&gt; 函数实现&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; id,type,name,price,&lt;span&gt;&lt;strong&gt;lag&lt;/strong&gt;(id,&lt;span&gt;1&lt;/span&gt;,'') over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; topid &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL语句输出 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722205114874-1710627913.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意:&lt;span&gt;函数lag(val1,val2,val3) 中的三个参数分别为-&amp;gt;(&lt;strong&gt;输出的上一条记录的字段,偏移值,无偏移值的默认值&lt;/strong&gt;)；以上这里的偏移值为1，偏移字段为id，无偏移默认值为空('')&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　若获取数据项偏移值(向上偏移) , &lt;strong&gt;&lt;span&gt;lead(val1,val2,val3)&lt;/span&gt;&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
SELECT id,type,name,price,&lt;span&gt;&lt;strong&gt;lead&lt;/strong&gt;(id,&lt;span&gt;1&lt;/span&gt;,'') over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; downid &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　 SQL 语句输出 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722205847916-280176052.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;546&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;当然，窗口函数还可以实现每个子类排序中的第一项的某个字段的值，可以这样实现:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　获取分类子项排序中的第一条记录的某个字段的值， &lt;strong&gt;&lt;span&gt;first_value(val1)&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; id,type,name,price,&lt;span&gt;&lt;strong&gt;first_value&lt;/strong&gt;(name) over(partition by type order by price asc)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL语句输出&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722210214318-552576761.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意:以上函数取的是排序子类记录中的第一条记录的name字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然也可以向下取分类排序中的最后一条记录的某个字段, &lt;strong&gt;&lt;span&gt;last_value(val1)&lt;/span&gt;&lt;/strong&gt;实现&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;SELECT&lt;/span&gt; id,type,name,price,&lt;span&gt;&lt;strong&gt;last_value&lt;/strong&gt;(name) over(partition by type order by price&lt;strong&gt; range between unbounded preceding and unbounded following&lt;/strong&gt;)&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; order by type asc ;-- ,price asc;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL 语句输出 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722210553875-961375241.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;511&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;额，这里需要说明的是，当取分类在最后一条记录的时候 自然排序下不可以在over() 使用排序字段，不然取得的值为相对于当前记录的值，故这里按价格(price) 升序的时候指定 排序字段 -&amp;gt; &lt;strong&gt;&lt;span&gt;range&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;&lt;strong&gt;between unbounded preceding and unbounded following&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　窗口函数还能在分类排序下取得指定序号记录的某个字段，这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　取得排序字段项目中指定序号记录的某个字段值, &lt;strong&gt;&lt;span&gt;nth_value(val1,val2)&lt;/span&gt;&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; id,type,name,price,&lt;span&gt;&lt;strong&gt;nth_value&lt;/strong&gt;(name,&lt;span&gt;2&lt;/span&gt;) OVER(partition by type order by price range between unbounded preceding and unbounded following )&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; products;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL语句输出 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722211440839-1766737939.png&quot; alt=&quot;&quot; width=&quot;768&quot; height=&quot;552&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　额，窗口函数在单独使用的时候能省略很多不必要的查询 ，比如子查询、聚合查询，当然窗口函数能做得更多(配合聚合函数使用的时候) ,额，这里我给出一个示例 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SQL查询语句 ，&lt;strong&gt;&lt;span&gt;窗口函数+聚合函数&lt;/span&gt;&lt;/strong&gt; 实现 &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt; (partition &lt;span&gt;by&lt;/span&gt;&lt;span&gt; type) 类别金额合计,
(&lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt; (&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; type))&lt;span&gt;/&lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt;&lt;span&gt;() 类别总额占所有品类商品百分比,
&lt;/span&gt;&lt;span&gt;round&lt;/span&gt;(price&lt;span&gt;/&lt;/span&gt;(&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt; (partition &lt;span&gt;by&lt;/span&gt; type rows &lt;span&gt;between&lt;/span&gt; unbounded preceding &lt;span&gt;and&lt;/span&gt; unbounded following)),&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 子除类别百分比,
rank() &lt;/span&gt;&lt;span&gt;over&lt;/span&gt; (partition &lt;span&gt;by&lt;/span&gt; type &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; price &lt;span&gt;desc&lt;/span&gt;&lt;span&gt;) 排名,
&lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt;&lt;span&gt;() 金额总计
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; products &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; type,price &lt;span&gt;asc&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　SQL 语句输出&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1161789/201807/1161789-20180722212031908-1570182872.png&quot; alt=&quot;&quot; width=&quot;1630&quot; height=&quot;556&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;上面的语句看起来会有点儿晕，查询语句子项就像是在输出参数项里面直接写子查询的感觉，事实上为使语句有更好的可读性，&lt;span&gt;窗口条件可以放在from后面&lt;/span&gt; ,这样子&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; 
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    id,type,name,price,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt;&lt;span&gt; w1 类别金额合计,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     (&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt; (&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; type))&lt;span&gt;/&lt;/span&gt;&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt;&lt;span&gt;() 类别总额占所有品类商品百分比,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;round&lt;/span&gt;(price&lt;span&gt;/&lt;/span&gt;(&lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt; w2),&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 子除类别百分比,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     rank() &lt;span&gt;over&lt;/span&gt;&lt;span&gt; w3 排名,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;sum&lt;/span&gt;(price) &lt;span&gt;over&lt;/span&gt;&lt;span&gt;() 金额总计
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    products 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;WINDOW 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;w1 as (partition by type),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;w2 as (partition by type rows between unbounded preceding and unbounded following),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;w3 as (partition by type order by price desc)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     type,price &lt;span&gt;asc&lt;/span&gt;; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;现在是 2018-07-22 21:59:31 ，各位晚安~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 14:20:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/9311281.html</dc:identifier>
</item>
<item>
<title>java,让debug出色 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/9351309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/9351309.html</guid>
<description>&lt;p&gt;虽然我们不喜欢bug，但是bug永远都存在。&lt;br/&gt;虽然我们牛逼，但是仍然有不知道的东西，解决不了的问题。&lt;br/&gt;so，还得借助工具，让咱效率提起来扛扛的。&lt;br/&gt;解决的问题如是：由于某种原因，其他系统发送的mq，我这边说没收到，他那边说发了。然后，一愁不展，咋办呢？好吧，肯定是抓包确认问题咯。嘿，这不是本文的重点，请自行脑补抓包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722210229869-1521275185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从对方系统的mq记录里，取出消息体，放到mq后台，直接发送到消费服务器。然后就遇到报错了，苦思不得结果后，当然了，只能使用终级绝招，就用本机来代替debug吧。&lt;br/&gt;本地服务起来之后，同样，mq后台发送消息。不出意外地，和测试服务器上报了不一样的错。这就尴尬了。和测试环境不一样，咋整呢？&lt;br/&gt;不怕，咱一步步来。按照堆栈指示的代码行，很快定位了有问题的代码。原因为某个jar包中的值报了空指针异常。咋整呢，咱们的本机环境不像测试环境呢。解决办法1：将本机模拟成测试环境一样的情况，太难，至少linux和windows环境就是不一样的。方法2：想办法让这个变量的变得和测试环境一样。方法3：想办法跳过报错的代码，使其继续后面的程序，2个问题，1是程序做不到跳过不执行功能，2是跳过执行后后续可能使用这里的值，会导致其他错误。故此，只有改变变量值一法了。&lt;br/&gt;案例1：改变一个基本类型变量的值&lt;br/&gt;直接setvalue即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String var1 &lt;/span&gt;= &quot;var1&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;var1:&quot; + var1);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 var1:changed&lt;/span&gt;
&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722214937763-2021117425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722215357757-1835365830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例2：改变一个hashmap变量的值&lt;/p&gt;
&lt;p&gt;hashmap是个复杂类型，不能直接值。需要使用 add to watches功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 2&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;map:&quot; + map);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 map:{name:hello}&lt;/span&gt;
&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722220148271-1859015659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722220642140-184343290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722220533304-902067253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例3：改变一个实体对象值&lt;br/&gt;可以使用set value 方式直接改变值，也可以使用add to watches操作代码来设置 。 总之你想要都能给你变出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        UserInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 3&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;info:&quot; +  info);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出info:UserInfo{id='123', name='null', sex='null', age=null, address='golden street'}&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722221100206-132897583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/830731/201807/830731-20180722221444844-1505399465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报的错是找不到某个处理方法，但是实际上我自认为已经写了某个方法。那么到底怎么回事呢。&lt;br/&gt;第一次跟踪，到某一行后，退出了程序。debug往下调整。进入方法再进行单步调试。再次发现某一次代码退出。最后定位到反射调用的这一行。原因是之时的入参类型，与现有入参类型不一致。再往前分析，是因为在调用转换器的时候，并没有进行相应的转换，而是以原来的二进制格式返回了。分析程序，知道里面某参数需要包含某值，转换器才会起作用。对症下药，给他这个参数，果然进入到了转换流程。然而，进入后又转换成另一个不可预料的参数了，没办法，getmapper方法不好模拟出来，还是算了，直接模拟转换结果吧，add to watch，改变值。这下，终于进入方法了，代码不再报错。测试通过了。&lt;br/&gt;弄清原理之后，解决就简单了，如果对方没有设置某属性值，让其设置就ok了。如果一定以结构参数进行接收处理，那变写一个对应的处理方法即可。小case。&lt;br/&gt;debug，单步调试，进入，退出，计算变量值能debug基础，必备。 让问题变得简单！&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 14:19:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/9351309.html</dc:identifier>
</item>
<item>
<title>javaScript设计模式之面向对象编程（object-oriented programming，OOP）(二） - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9311331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9311331.html</guid>
<description>&lt;p&gt;接上一篇&lt;/p&gt;
&lt;p&gt;面向对象编程的理解？&lt;/p&gt;
&lt;p&gt;答：面向对象编程，就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性）与动作（方法）。这个对象我们称之为类。面向对象编程思想其中一个特点就是封装，就是把你需要的功能放在一个对象里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1创建一个类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在javascript中创建一个类，很容易，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;首先，声明一个函数保存在变量里，然后，在这个函数内部通过this（函数内部自带的一个变量，用于指向当前这个对象）变量添加属性或者方法，来实现对类的添加属性或方法。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Book = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(id,bookname,price){
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bookname =&lt;span&gt; bookname;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;      
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：可以通过类的原型添加属性或方法，有两种方法，不要混用&lt;/p&gt;
&lt;p&gt;(1)为原型对象属性赋值的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Book.prototype.display = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;展示这本书&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)将对象赋值给类的原型对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Book.prototype =&lt;span&gt; {
    display:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){}
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们需要的方法和属性都封装在我们抽象的Book类里，当使用功能方法时，我们不能直接使用这个Book类，需要用关键字new来实例化新的对象。使用实例化对象的属性或者方法时，可以通过&lt;strong&gt;点语法&lt;/strong&gt;来访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; book = &lt;span&gt;new&lt;/span&gt; Book(10,'javascript课本'，50&lt;span&gt;)；
console.log(book.bookname);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的，通过此特性即可创建类的私有变量以及私有方法。然而在函数内部通过this创建的属性和方法，在类创建对象时时，每一个对象自身都拥有一份并且可以外部访问的。因此通过this创建，不但可以访问这些对象的共有属性与共有方法，而且还可以访问到类或者对象自身的私有属性和私有方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//私有属性，私有方法；特权方法，对象公有属性，对象公有方法；构造器&lt;br/&gt;var&lt;/span&gt; Book = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(id,name,price){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有属性&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; num = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有方法&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkId(){};
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;特权方法&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getPrice = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setPrice = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象公有属性&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象公有方法&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.copy = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setName(name);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setPrice(price);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用原生的prototype对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态类公有属性（对象不能访问）&lt;/span&gt;
Book.isChinese = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类静态公有方法（对象不能访问）&lt;/span&gt;
Book.resetTime = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;'new time'&lt;span&gt;);
};

Book.prototype &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有属性&lt;/span&gt;
    isJSBook:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公有方法&lt;/span&gt;
    display:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){}
}        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过new关键字创建的对象时对新对象this的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过&lt;strong&gt;点语法&lt;/strong&gt;定义的属性方法是不会添加到新创建的对象上去的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; b = &lt;span&gt;new&lt;/span&gt; Book(11,'JavaScript设计'，50&lt;span&gt;);
console.log(b.num);  //undefined
console.log(b.isJSBook);  //false
console.log(b.id);   //11
console.log(b.isChinese);    //undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类的&lt;strong&gt;私有属性&lt;/strong&gt;num，以及&lt;strong&gt;静态公有属性&lt;/strong&gt;isChinese在新创建的b对象里访问不到。而类的&lt;strong&gt;公有属性&lt;/strong&gt;isJSBook在b对象中却可以通过点语法访问到。&lt;/p&gt;
&lt;p&gt;但是类的&lt;strong&gt;静态公有属性&lt;/strong&gt;isChinese可以通过类的自身访问。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(Book.isChinese);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
Book.resetTime();    &lt;span&gt;//&lt;/span&gt;new time
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.2闭包实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你对闭包的理解？&lt;/p&gt;
&lt;p&gt;答：&lt;strong&gt;闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数&lt;/strong&gt;。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例化对象的函数，即可访问到类函数作用域的变量，这个变量叫静态私有变量，静态私有方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结类： 发现每一个类都有3个部分：&lt;/p&gt;
&lt;p&gt;1、第一部分是&lt;strong&gt;构造函数内的，&lt;/strong&gt;供实例化对象复制用的；&lt;/p&gt;
&lt;p&gt;2、第二部分是&lt;strong&gt;构造函数外的&lt;/strong&gt;，直接通过点语法添加的，这是供类使用的，实例化对象时访问不到的；&lt;/p&gt;
&lt;p&gt;3、第三部分是&lt;strong&gt;类的原型中的&lt;/strong&gt;，实例化对象可以通过其原型链间接的访问到，也是为供所有的实例化对象所共有的。&lt;/p&gt;
&lt;p&gt;JavaScript中没有继承这一个现有的机制，该如何实现呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（一）子类的原型对象--类式继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如：常见的类式继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类式继承&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;声明父类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClass(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.superValue = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为父类添加共有方法&lt;/span&gt;
SuperClass.prototype.getSuperValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.superValue;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明子类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subValue = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类&lt;/span&gt;
SubClass.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperClass();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为子类添加共有方法&lt;/span&gt;
SubClass.prototype.getSubValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subValue;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刚才封装，对比，继承里面声明了2个类，而且第二个类的原型prototype被赋予第一个类的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类式继承需要将第一个类的实例赋值给第二个类的原型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继承原理：&lt;strong&gt;新创建的对象不仅仅可以访问父类原型上的属性和方法，同样可以访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型，那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubClass();
console.log(instance.getSuperValue());   //true
console.log(instance.getSubValue());     //false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在js中，有一个关键字instanceof 来判断某一个对象是否为某一个类的实例，或者说某一个对象是否继承了某个类，这样可以&lt;strong&gt;判断对象和类之间的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;instanceof如何知道对象和类之间的继承关系呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答;instanceof是通过判断对象的prototype链来确定这个对象是否是某一个类的实例，而不关心对象与类的自身结构。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(instance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SuperClass);   //true
console.log(instance &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; SubClass);　　　//true
console.log(SubClass &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt; SuperClass);　　//false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为啥最后是false，SubClass继承SuperClass，为啥还是false；记住：&lt;strong&gt;instanceof是判断前面的对象是否是后边类（对象）的实例，它并不是表示两者的继承。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(SubClass.prototype &lt;span&gt;instanceof&lt;/span&gt; SuperClass); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;类式继承的一个&lt;strong&gt;特点&lt;/strong&gt;：你所创建的所有的对象都是谁的实例？&lt;/p&gt;
&lt;p&gt;Object，正式JavaScript为我们提供的原生对象Object。&lt;strong&gt;创建的所有的对象都是Object的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(instance &lt;span&gt;instanceof&lt;/span&gt; Object); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类式继承有两个缺点：&lt;/p&gt;
&lt;p&gt;1、由于子类是通过其原型prototype对父类实例化，继承了父类。所以说父类中共有属性要是引用类型，就会在子类中被所有实例共用，因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类。&lt;/p&gt;
&lt;p&gt;2、由于子类实现的继承是靠原型的prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的，因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（二）创造即继承--构造函数继承&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;除了类式继承以外还有构造函数继承&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数式继承&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;声明父类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SuperClass(id){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用类型共有属性&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.books = ['JavaScript','html','css'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值类型共有属性&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类声明原型的方法&lt;/span&gt;
SuperClass.prototype.showBooks = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.books);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明子类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass(id){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;继承父类    &lt;/span&gt;
    SuperClass.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,id);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第一个子类的实例&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; instance1 = &lt;span&gt;new&lt;/span&gt; SubClass(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第二个子类的实例&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; instance2 = &lt;span&gt;new&lt;/span&gt; SubClass(11&lt;span&gt;);

instance1.books.push(&lt;/span&gt;'设计模式'&lt;span&gt;); 
console.log(instance1.books);  //[&quot;JavaScript&quot;, &quot;html&quot;, &quot;css&quot;, &quot;设计模式&quot;]
console.log(instance1.id);　　　//10
console.log(instance2.books);　　//[&quot;JavaScript&quot;, &quot;html&quot;, &quot;css&quot;]
console.log(instance2.id);　　　　//11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：SuperClass.call(this.id);这个语句是构造函数式继承的精华，&lt;strong&gt;由于call这个方法可以更改函数的作用域&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;由于这种类型的继承没有涉及到原型prototype，所以父类的原型方法自然就不会被子类继承，而如果想被子类继承就必须放在构造函数中，这样创造出来的每一个实例都会拥有一份而不能共用，这样就违背了代码复用的原则。&lt;/p&gt;
&lt;p&gt;综上这两种模式优点，后来就有了组合式的继承&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（三）集合优点--组合继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;p&gt;（1）类式继承，通过子类的原型prototype对父类实例化来实现的&lt;/p&gt;
&lt;p&gt;（2）构造函数继承，通过子类的构造函数作用环境执行一下父类的构造函数来实现的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组合式的继承&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;声明父类&lt;/span&gt;
&lt;span&gt;function SuperClass(name){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值类型共有属性&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引用类型共有属性&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.books = ['html','css','JavaScript'&lt;span&gt;];
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类原型共有方法&lt;/span&gt;
SuperClass.prototype.getName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明子类&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SubClass(name,time){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;构造函数式继承&lt;/strong&gt;&lt;/span&gt;父类name属性&lt;/span&gt;
    SuperClass.call(&lt;span&gt;this,&lt;/span&gt;&lt;span&gt;name);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类中新增共有属性&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;类式继承&lt;/strong&gt;&lt;/span&gt; 子类原型继承父类&lt;/span&gt;
SubClass.prototype = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperClass();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类原型方法&lt;/span&gt;
SubClass.prototype.getTime = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.time);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组合模式：在子类构造函数中执行父类构造函数，在子类原型上实例化父类。&lt;/p&gt;
&lt;p&gt;这样就融合了类式继承和构造函数继承的优点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; instance1 = &lt;span&gt;new&lt;/span&gt; SubClass('js book',2014&lt;span&gt;);
instance1.books.push(&lt;/span&gt;'设计模式'&lt;span&gt;);
console.log(instance1.books); //[&quot;html&quot;, &quot;css&quot;, &quot;JavaScript&quot;, &quot;设计模式&quot;]
instance1.getName();  //js book
instance1.getTime();   //2014

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance2 = &lt;span&gt;new&lt;/span&gt; SubClass('css book',2013&lt;span&gt;);
console.log(instance2.books);  //[&quot;html&quot;, &quot;css&quot;, &quot;JavaScript&quot;]
instance2.getName();   //css book
instance2.getTime();   //2013&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子类的实例中更改父类继承下来的引用类型属性如books，根本就不会影响到其他实例。&lt;/p&gt;
&lt;p&gt;但是我们在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类的构造器。&lt;strong&gt;因此父类构造函数调用了两遍&lt;/strong&gt;，还不是最完美的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（四）洁净的继承者--原型式继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;借助原型的prototype可以根据已有的对象创建一个新对象，同时不必创建新的自定义对象类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; inheritObject(item){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个过渡函数对象&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; F(){};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过渡对象的原型继承父对象&lt;/span&gt;
    F.prototype =&lt;span&gt; item;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回过渡对象的一个实例，该实例的原型继承了父对象&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; F();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;他是对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现，目的是为了创建要返回新的实例化对象。&lt;/p&gt;
&lt;p&gt;当然如果你感觉有必要可以将F过渡缓存起来，不必每次都创建一个新过渡类F，随后就出现了Object.create()的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; book =&lt;span&gt; {
    name: &lt;/span&gt;'js book'&lt;span&gt;,
    alikeBook: [&lt;/span&gt;'css book','html book'&lt;span&gt;],
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newBook =&lt;span&gt; inheritObject(book);
newBook.name &lt;/span&gt;= 'ajax book'&lt;span&gt;;
newBook.alikeBook.push(&lt;/span&gt;'xml book'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; otherBook =&lt;span&gt; inheritObject(book);
otherBook.name &lt;/span&gt;= 'flash book'&lt;span&gt;;
otherBook.alikeBook.push(&lt;/span&gt;'as book'&lt;span&gt;);

console.log(newBook.name);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ajax book&lt;/span&gt;
console.log(newBook.alikeBook);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;['css book','html book','xml book','as book']&lt;/span&gt;
&lt;span&gt;
console.log(otherBook.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;flash book&lt;/span&gt;
console.log(otherBook.alikeBook);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;['css book','html book','xml book','as book']&lt;/span&gt;
&lt;span&gt;
console.log(book.name);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js book&lt;/span&gt;
console.log(book.alikebook); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;['css book','html book','xml book','as book']  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟类式继承一样，父类对象book中的值类型的属性被复制，引用类型的属性被共用。&lt;/p&gt;

</description>
<pubDate>Sun, 22 Jul 2018 13:50:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9311331.html</dc:identifier>
</item>
<item>
<title>干货——详解Java中的关键字 - Janti</title>
<link>http://www.cnblogs.com/superfj/p/7900998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/superfj/p/7900998.html</guid>
<description>&lt;p&gt;在平时编码中，我们可能只注意了这些static，final，volatile等关键字的使用，忽略了他们的细节，更深层次的意义。&lt;/p&gt;
&lt;p&gt;本文总结了Java中所有常见的关键字以及一些例子。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;static 关键字&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当static修饰类的属性或者方法时，那么就可以在没有创建对象的情况下使用该属性或方法。&lt;/p&gt;
&lt;p&gt;静态块也是static的一个应用，用于初始化类时的一些操作。&lt;/p&gt;

&lt;h3&gt;静态方法和静态变量&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;划重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被static修饰后的属性或者方法，使用时不需要new 一个类，用&lt;strong&gt;&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;.&lt;span&gt;&lt;strong&gt;属性名或方法名&lt;/strong&gt;&lt;/span&gt;访问.&lt;/p&gt;
&lt;p&gt;比如java.lang.Math就存放了很多静态资源，可以直接使用Math.random（）来获取随机数.&lt;/p&gt;

&lt;p&gt;一些需要注意的地方&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;非静态方法是可以访问静态资源的，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;静态方法是不能引用非静态资源的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来看一个代码实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestStatic {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        System.out.println(i);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在以上代码，编译的时候会出错，main方法是静态方法，变量i是非静态的。&lt;/p&gt;
&lt;p&gt;解决办法是，将变量i加上static修饰。&lt;/p&gt;

&lt;p&gt;不经就要提出一个问题，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么非静态方法可以访问静态资源，而静态方法不能访问非静态资源呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 从类加载机制上讲，&lt;strong&gt;静态资源是类初始化的时候加载的&lt;/strong&gt;，然后非静态资源是new一个该类的对象的时候加载的。&lt;/p&gt;

&lt;p&gt;这就带来一个问题：&lt;/p&gt;
&lt;p&gt;加载类时默认先加载静态资源的，当new一个对象之后，才会加载其他资源，所以在new对象之前，静态资源是不知道类有哪些非静态资源的，&lt;/p&gt;
&lt;p&gt;但是当对象new出来之后，该类的所有属性和方法都知道。&lt;/p&gt;

&lt;p&gt;还有需要注意的是：&lt;/p&gt;
&lt;p&gt;1.静态属性和方法可以通过&lt;strong&gt;&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;.&lt;span&gt;&lt;strong&gt;属性名或方法名&lt;/strong&gt;&lt;/span&gt;，而且，该类的对象也是访问静态属性和变量的。&lt;/p&gt;
&lt;p&gt;2.Java的语法规定，static不能修饰局部变量。没有为什么，这就是规定。&lt;/p&gt;

&lt;h3&gt;静态块&lt;/h3&gt;
&lt;p&gt;静态块和静态变量、静态方法是没什么区别的，也是在类加载的时候执行，而且只执行一次。&lt;/p&gt;
&lt;p&gt;关于静态块有两点需要注意：&lt;/p&gt;
&lt;p&gt;1.静态资源的加载顺序严格按照静态资源的定义顺序加载的&lt;/p&gt;
&lt;p&gt;2.静态块，对于定义在它之后的静态变量，可以赋值但不能访问。&lt;/p&gt;
&lt;h3&gt;static的题目&lt;/h3&gt;
&lt;p&gt;下面main（）方法的输出结果是什么：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InstanceClass &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ParentClass{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String subStaticField = &quot;子类静态变量&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String subField = &quot;子类非静态变量&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; StaticClass staticClass = &lt;span&gt;new&lt;/span&gt; StaticClass(&quot;子类&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;子类 静态块初始化&quot;&lt;span&gt;);
    }

    {
        System.out.println(&lt;/span&gt;&quot;子类 [非]静态块初始化&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InstanceClass(){
        System.out.println(&lt;/span&gt;&quot;子类构造器初始化&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String args[]) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InstanceClass();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParentClass{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String parentStaticField = &quot;父类静态变量&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String parentField = &quot;父类[非]静态变量&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; StaticClass staticClass = &lt;span&gt;new&lt;/span&gt; StaticClass(&quot;父类&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;父类 静态块初始化&quot;&lt;span&gt;);
    }

    {
        System.out.println(&lt;/span&gt;&quot;父类 [非]静态块初始化&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ParentClass(){
        System.out.println(&lt;/span&gt;&quot;父类  构造器初始化&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; StaticClass{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StaticClass(String name){
        System.out.println(name&lt;/span&gt;+&quot; 静态变量加载&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('536384c2-68f3-4da9-99e6-0687e35422d1')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_536384c2-68f3-4da9-99e6-0687e35422d1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_536384c2-68f3-4da9-99e6-0687e35422d1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('536384c2-68f3-4da9-99e6-0687e35422d1',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_536384c2-68f3-4da9-99e6-0687e35422d1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;父类 静态变量加载
父类 静态块初始化
子类 静态变量加载
子类 静态块初始化
父类 [非]静态块初始化
父类  构造器初始化
子类 [非]静态块初始化
子类构造器初始化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;下面是我总结类加载流程，可以对照着这个流程，可以再重新看一下上面的例子，会有新的理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;1. 加载父类静态
    1.1 为静态属性分配存储空间并赋初始值
    1.2 执行静态初始化块和静态初始化语句（从上至下）

2. 加载子类静态
    2.1 为静态属性分配存储空间
    2.2 执行静态初始化块和静态初始化语句（从上至下）

3. 加载父类非静态
    3.1 为非静态块分配空间　　
    3.2 执行非静态块

4. 加载子类非静态
    4.1 为非静态块分配空间　　
    4.2 执行非静态块

5. 加载父类构造器
    5.1 为实例属性分配存数空间并赋初始值
    5.2 执行实例初始化块和实例初始化语句
    5.3 执行构造器内容

6. 加载子类构造器
    6.1 为实例属性分配存数空间并赋初始值
    6.2 执行实例初始化块和实例初始化语句
    6.3 执行构造器内容&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对照着刚才的规则，再看一下这个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestStaticLoad {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Person person = &lt;span&gt;new&lt;/span&gt; Person(&quot;TestStaticLoad&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         System.out.println(&quot;TestStaticLoad static&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestStaticLoad() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         System.out.println(&quot;TestStaticLoad constructor&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; God();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         System.out.println(&quot;person static&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String str) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;person &quot;+&lt;span&gt;str);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; God &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestStaticLoad {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     Person person = &lt;span&gt;new&lt;/span&gt; Person(&quot;&lt;span&gt;God&lt;/span&gt;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         System.out.println(&quot;God static&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; God() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         System.out.println(&quot;God constructor&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0c0b79bd-f92d-4f0e-8f12-86e2fe828cc8')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_0c0b79bd-f92d-4f0e-8f12-86e2fe828cc8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c0b79bd-f92d-4f0e-8f12-86e2fe828cc8&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0c0b79bd-f92d-4f0e-8f12-86e2fe828cc8',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c0b79bd-f92d-4f0e-8f12-86e2fe828cc8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; TestStaticLoad &lt;span&gt;static&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; God &lt;span&gt;static&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; person &lt;span&gt;static&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;person TestStaticLoad
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;TestStaticLoad constructor
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;person God
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; God constructor
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;一步一步地解析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;span&gt;TestStaticLoad&lt;/span&gt; 的main方法中，执行了new God()，那就就会去加载God类，在这之前会先加载它的父类：&lt;span&gt;TestStaticLoad&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;第一步：加载父类静态，执行System.out.println(&quot;TestStaticLoad static&quot;&lt;span&gt;);&lt;/span&gt;  &lt;span&gt;输出：TestStaticLoad static，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;第二步：加载子类静态，执行System.out.println(&quot;God static&quot;&lt;span&gt;);&lt;/span&gt;，输出God static&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;第三步：加载父类非静态，Person person = &lt;span&gt;new Person(&quot;TestStaticLoad&quot;&lt;span&gt;);，这里实例化了&lt;span&gt;&lt;span&gt;Person&lt;/span&gt;&lt;/span&gt; 对象，那就会去加载Person类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第四步：加载Person类，首先看有没有父类，没有。好，加载静态块，执行System.out.println(&quot;person static&quot;&lt;span&gt;);输出person static&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第五步：Pernson类静态块加载完毕，加载构造器，new一个Person对象，输出person TestStaticLoad。这时&lt;span&gt;TestStaticLoad&lt;/span&gt; 类非静态块加载完毕&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第六步：加载God 父类（&lt;span&gt;TestStaticLoad&lt;/span&gt; ）构造器，输出TestStaticLoad constructor&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;第七步：God父类全部加载完毕，加载God的非静态块，Person person = &lt;span&gt;new Person(&quot;&lt;span&gt;God&quot;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;span&gt;这时又会去加载Person类，需要注意的是，static块只加载一次，因为之前在父类已经加载过了，这时只加载构造器，输出person God&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;最后一步：加载本类God 的构造器，输出God constructor。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt; static关键字的总结：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;static关键字 可以再没有创建对象的时候进行调用类的元素&lt;/li&gt;
&lt;li&gt;static 可以修饰类的方法 以及类的变量， 以及静态代码块&lt;/li&gt;
&lt;li&gt;被static修饰的成为静态方法，静态方法是没有this的，静态方法不能访问同一个类中的非静态方法和静态变量，但是非静态方法 可以可以访问静态变量&lt;/li&gt;
&lt;li&gt;类的构造器 也是静态的&lt;/li&gt;
&lt;li&gt;静态变量被所有的内存所有的对象共享，在内存中只有一个副本。非静态变量是是在创建对象的时候初始化的，存在多个副本，每个副本不受影响。&lt;/li&gt;
&lt;li&gt;static 静态代码块，static 代码块可以放在类中的任何地方，类加载的时候会按照static代码块的顺序来加载代码块，并且只会执行一次。&lt;/li&gt;
&lt;li&gt;枚举类和静态代码块 赋值静态代码块的变量&lt;/li&gt;
&lt;li&gt;非静态方法能够通过this访问静态变量&lt;/li&gt;
&lt;li&gt;静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问。&lt;/li&gt;
&lt;li&gt;static不可以修饰局部变量（java语法规定）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;没想到static能有这么多需要注意的，可以说Java中的语法还是有很多可以深究的.&lt;/p&gt;

&lt;h2&gt;final 关键字&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;概述：&lt;/p&gt;
&lt;p&gt;final关键字，在平时的过程中也是很常见的，在这里进行一下深入的学习，加深对final关键字的理解。&lt;/p&gt;
&lt;p&gt; 使用注意点：&lt;/p&gt;
&lt;p&gt;1.在java中final可以用来修饰类、方法、和变量（包括成员变量和局部变量）&lt;/p&gt;
&lt;p&gt;2.final修饰类的时候，这个类将永远不会被继承，类中的成员方法也会被隐式的修饰为final(尽量不要用final修饰类)&lt;/p&gt;
&lt;p&gt;3.如果不想方法被继承，可以用final修饰，private也会隐式的将方法指定为final&lt;/p&gt;
&lt;p&gt;4.final修饰变量的时候，如果是基本类型的变量，那么他的值在初始化之后就不能更改&lt;/p&gt;
&lt;p&gt;5.final在修饰对象的时候，在其初始化之后就不能指向其他对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.被static和final修饰的变量，将会占据一段不能改变的存储空间，将会被看做编译期常量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.&lt;span&gt;&lt;strong&gt;&lt;span&gt;不可变的是变量的引用而非引用指向对象的内容&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几个例子：&lt;/p&gt;
&lt;p&gt;1.final变量和普通变量的区别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestFinal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
        String a &lt;/span&gt;= &quot;test1&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String b = &quot;test&quot;&lt;span&gt;;
        String d &lt;/span&gt;= &quot;test&quot;&lt;span&gt;;
        String c &lt;/span&gt;= b + 1&lt;span&gt;; 
        String e &lt;/span&gt;= d + 1&lt;span&gt;;
        System.out.println((a &lt;/span&gt;==&lt;span&gt; c));
        System.out.println((a.equals(e)));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5f39186a-b087-4ae0-9413-f831c4c55930')&quot;&gt;&lt;img id=&quot;code_img_closed_5f39186a-b087-4ae0-9413-f831c4c55930&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5f39186a-b087-4ae0-9413-f831c4c55930&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5f39186a-b087-4ae0-9413-f831c4c55930',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;因为final变量是基本类型以及String时，在编译期的时候就把它当做常量来使用，不需要在运行时候使用。“==”是&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;335&quot;&gt;对比两个对象基于内存引用，如果两个对象的引用完全相同，则返回true,所以这里b是用访问常量的方式去访问，d是链接的方式，所以a的内存引用和c的内存引用是相等的，所以结果为true，a和e两个对象的值是相等的，所以结果为true&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;335&quot;&gt;2.final在修饰对象的时候&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestFinal {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; TestFinal obj1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestFinal();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; TestFinal obj2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestFinal();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         
&lt;span&gt;6&lt;/span&gt;         obj1 =&lt;span&gt; obj2;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在编译的时候，或报错， 不能指向一个final对象。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;volatile关键字&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;缓存一致性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先来看看线程的内存模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201807/1167080-20180714154218213-558737763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当执行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
i = i + 1；
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;首先从主存中读取i的值，&lt;/li&gt;
&lt;li&gt;然后复制I到Cache中，&lt;/li&gt;
&lt;li&gt;CPU执行指令对i进行加1&lt;/li&gt;
&lt;li&gt;将加1后的值写入到Cache中&lt;/li&gt;
&lt;li&gt;最后将Cache中i的值刷新到主存中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个在单线程的环境中是没有问题的，但是运行到多线程中就存在问题了。&lt;/p&gt;
&lt;p&gt;问题出在主存中的变量，因为有可能其他线程读的值，线程的Cache还没有同步到主存中，每个线程中的Cahe中的值副本不一样，可能会造成&quot;脏读&quot;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存一致性协议解决了这样的问题，它规定每个线程中的Cache使用的共享变量副本是一样的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心内容是当CPU写数据时，如果发现操作的变量式共享变量，它将通知其他CPU该变量的缓存行为无效，&lt;/p&gt;
&lt;p&gt;所以当其他CPU需要读取这个变量的时候，发现自己的缓存行为无效，那么就会从主存中重新获取。&lt;/p&gt;

&lt;h3&gt;三个概念&lt;/h3&gt;
&lt;p&gt;Jvm定义了内存规范，试图做到各个平台对内存访问的差异，但是依旧会发生缓存一致性的问题。&lt;/p&gt;
&lt;p&gt;首先了解三个概念，原子性，可见性，有序性。&lt;/p&gt;

&lt;p&gt;原子性：指某个操作，一个或者多个，要么全部执行并且执行的过程中不会被任何因素打断，要么都不执行。&lt;/p&gt;
&lt;p&gt;在JVM中，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。看一个例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
x = 70;         &lt;span&gt;//&lt;span&gt;语句1
y = x;         &lt;span&gt;//&lt;span&gt;语句2
y++;           &lt;span&gt;//&lt;span&gt;语句3
y = x + 1;     &lt;span&gt;//&lt;span&gt;语句4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面四个语句中，只有语句1是原子性，其他都不是。&lt;/p&gt;

&lt;p&gt;可见性：当多个线程访问一个变量时，一个线程修改了这个变量的值，其他线程能够看得到。&lt;/p&gt;
&lt;p&gt;未加volatile变量修饰的变量，在被修改之后，什么时候写入到主存是不确定的，因此其他线程读取该变量的值可能还是未被修改的值。&lt;/p&gt;
&lt;p&gt;如果改变了被volatile关键字修饰了，那么JVM将会标记它为共享变量，共享变量一经修改，就会立即同步到主存中，并且通知其他线程（CPU缓存）中值生效，请去主存中读取该值。&lt;/p&gt;

&lt;p&gt;有序性：程序的执行顺序按照代码的先后顺序执行。但是JVM在执行语句的过程会对代码进行重排序（重排序：CPU为了提高程序运行效率，可能会对输入代码进行优化，但是不保证程序的执行先后顺序和代码中的顺序一致，但是会保证程序最终执行结果和代码顺序执行的结果是一致的）。&lt;/p&gt;
&lt;p&gt;在多线程的环境下，原有的顺序执行会发生错误。&lt;/p&gt;
&lt;p&gt;在JVM中保证了一定的有序性，比如被volatile修饰后的变量，那么该变量的写操作先行发生于后面对这个变量的读操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以要想程序在多线程环境下正确运行，必须保证原子性，可见性，有序性。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;volatile的作用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当一个变量（类的普通变量，静态变量）被volatile修饰之后，那么将具备两个属性：&lt;/p&gt;
&lt;p&gt;1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。&lt;/p&gt;
&lt;p&gt;2）禁止进行指令重排序&lt;/p&gt;

&lt;p&gt;下面来看看线程池中一些变量的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private &lt;span&gt;volatile&lt;span&gt; ThreadFactory threadFactory;

    &lt;span&gt;private &lt;span&gt;volatile&lt;span&gt; RejectedExecutionHandler handler;

    &lt;span&gt;private &lt;span&gt;volatile &lt;span&gt;long&lt;span&gt; keepAliveTime;

    &lt;span&gt;private &lt;span&gt;volatile &lt;span&gt;boolean&lt;span&gt; allowCoreThreadTimeOut;

    &lt;span&gt;private &lt;span&gt;volatile &lt;span&gt;int&lt;span&gt; corePoolSize;

    &lt;span&gt;private &lt;span&gt;volatile &lt;span&gt;int maximumPoolSize;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 可以看到线程工厂&lt;span&gt;threadFactory，拒绝策略&lt;span&gt;handler，没有任务时的活跃时间&lt;span&gt;keepAliveTime，keepAliveTime的开关&lt;span&gt;allowCoreThreadTimeOut，核心池大小&lt;span&gt;corePoolSize，最大线程数maximumPoolSize&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;都是被volatile修饰中，因为在线程池中有若干个线程，这些变量必需保持对线程可见性，不然会引起线程池运行不正确。&lt;/p&gt;

&lt;h3&gt;volatile不能保证原子性&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;i++；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是非原子性的，当变量i被volatile修饰时，是否能保证原子性呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做个试验：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public &lt;span&gt;class&lt;span&gt; TestAtomVolatile {
    &lt;span&gt;public &lt;span&gt;volatile &lt;span&gt;int i = 0&lt;span&gt;;

    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; increase() {
        i++&lt;span&gt;;
    }

    &lt;span&gt;public &lt;span&gt;static &lt;span&gt;void main(String[] args) &lt;span&gt;throws&lt;span&gt; InterruptedException {
        &lt;span&gt;final TestAtomVolatile test = &lt;span&gt;new&lt;span&gt; TestAtomVolatile();
        &lt;span&gt;for(&lt;span&gt;int i=0;i&amp;lt;10;i++&lt;span&gt;){
            &lt;span&gt;new&lt;span&gt; Thread(){
                &lt;span&gt;public &lt;span&gt;void&lt;span&gt; run() {
                    &lt;span&gt;for(&lt;span&gt;int j=0;j&amp;lt;1000;j++&lt;span&gt;)
                        test.increase();
                    System.out.println(test.i);
                };
            }.start();
        }

    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;以上代码就是10个线程，分别对变量i进行自增操作，预期结果应该是10000，但是总会存在着小于10000的情况。输出结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1167080/201807/1167080-20180717100223234-1318702911.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 对于这种情况，可以使用锁，synchronize，Lock，也可以使用原子变量。&lt;/p&gt;
&lt;p&gt;原子变量的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_870eaabb-a8ee-4990-9023-f4f9c4ee4a89&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; volatile的原理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 下面这段话摘自《深入理解Java虚拟机》：

“”观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”

lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

1&lt;span&gt;）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

2&lt;span&gt;）它会强制将对缓存的修改操作立即写入主存；

3）如果是写操作，它会导致其他CPU中对应的缓存行无效。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span class=&quot;RichText CopyrightRichText-richText&quot; data-reactid=&quot;335&quot;&gt;assert关键字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;assert断言&lt;/p&gt;
&lt;p&gt;在目前的java编码中，是不推荐使用的，这里只是稍微了解一下：&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、assert &amp;lt;boolean表达式&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;boolean表达式&amp;gt;为true，则程序继续执行。&lt;/p&gt;
&lt;p&gt;如果为false，则程序抛出AssertionError，并终止执行。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、assert &amp;lt;boolean表达式&amp;gt; : &amp;lt;错误信息表达式&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果&amp;lt;boolean表达式&amp;gt;为true，则程序继续执行。&lt;/p&gt;
&lt;p&gt;如果为false，则程序抛出java.lang.AssertionError，并输入&amp;lt;错误信息表达式&amp;gt;。&lt;/p&gt;

&lt;p&gt;如果要开启断言检查，则需要用开关-enableassertions或-ea来开启，java中IDE工具默认支持开启-ea&lt;/p&gt;
&lt;p&gt;下面是一个例子：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LearnAssert {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
        assert &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;断言1成功执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        assert &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;断言2成功执行&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; assert是为了在调试程序时候使用的，默认不推荐使用，测试程序可以使用junit。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;synchronized关键字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;关于锁关键字，有以下几个总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。&lt;/li&gt;
&lt;li&gt;每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。&lt;/li&gt;
&lt;li&gt;实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面介绍一个锁的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ManyThread {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; autoIncrement() {
        count&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]) {
        ManyThread manyThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ManyThread();
        Runnable runnable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable2(manyThread);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(runnable, &quot;a&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(runnable, &quot;b&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(runnable, &quot;c&quot;&lt;span&gt;).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(runnable, &quot;d&quot;&lt;span&gt;).start();
    }


}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyRunnable2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  ManyThread manyThread;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyRunnable2(ManyThread manyThread) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.manyThread =&lt;span&gt; manyThread;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10000; i++&lt;span&gt;) {
            manyThread.autoIncrement();
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 执行中 &quot; + &quot;count:&quot; +&lt;span&gt; manyThread.count);
        }
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;用synchronized修饰后的&lt;span&gt;autoIncrement&lt;/span&gt;()方法，会被加锁，确保它每次执行的时候都能保证只有一个线程在运行。&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;transient关键字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; Java中，一个类想要序列化，可以通过实现Serilizable接口的方式来实现，实现该接口之后，该类所有属性和方法都会自动序列化。&lt;/p&gt;
&lt;p&gt;但是如果属性或方法被&lt;span&gt;transient&lt;span&gt;修饰，那么将不会被序列化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Jul 2018 13:41:00 +0000</pubDate>
<dc:creator>Janti</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/superfj/p/7900998.html</dc:identifier>
</item>
<item>
<title>Java的内存模型（1） - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9351281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9351281.html</guid>
<description>&lt;p&gt;　　今天周末，闲来无事，干嘛呢？当然看书啊，总结啊！读完书光回想是没用的，必须有个自己的第一遍理解，第二遍理解.....，就比如简简单单的JMM说来轻松，网上博客虽多，图文代码加以解释的甚少，并没有给读者一种层次感。所以我想写这么一篇博客，算是总结自己的第一遍理解，同时尽自己最大的可能让大家理解的时候有一种层次感。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;整篇博客都是参考《深入理解Java虚拟机》加上自己读了两遍之后的理解完成的，创作不易，望转载告之，谢谢！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先在记录此篇博客之前，给一个大概的目录结构方便读者留意：&lt;/p&gt;
&lt;p&gt;1、Java内存模型介绍&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是内存模型？-------对比Cache存储层次结构&lt;/li&gt;
&lt;li&gt;工作内存与主内存是什么？-----------结合线程理解&lt;/li&gt;
&lt;li&gt;工作与主内存之间的交互-----------线程之间的交互（有图）&lt;/li&gt;
&lt;li&gt;如何保证线程一致性？-------------八种操作的协议规定　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、Volatile关键字规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Volatile的两层含义-----------可见性与禁止重排序（代码举例）&lt;/li&gt;
&lt;li&gt;关于Volatile的误解----------Volatile在高并发条件下不一定是安全的+Volatile并非原子性的（代码举例）&lt;/li&gt;
&lt;li&gt;Volatile与Synchronized简单比较--------------Volatile大部分情况下比Synchronized性能高&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、double与long的非原子性&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;　　第一次见到Java的内存模型，正如《深入理解JVM》中那样提到Cache与主存的关系，我也第一时间想起来了这个，于是便画了如下的存储系统的层次结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201807/1352849-20180722180300944-1580904960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Cache与主内存之间为了能保持一致性，会不断跟Cache进行交互，也就是地址映像，主要有直接映像、全相联映像、组相联映像，emmmm...打住，这不是正题，只是顺便给自己个机会看《操作系统》就当做复习下，好了接下来是正题，先画出JMM图如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201807/1352849-20180722181242332-1936102350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从图中可以看出要学好Java线程（高并发）是必须要知道JMM的，同时工作内存就好比Cache，与主内存之间进行交互，需要注意的的是这里的工作内存与主内存并不是我们所知道的内存这个概念，也不只是简单的Java Heap与Java Stack那样简单的概念，为了进一步知道工作内存与主内存是什么，接下来先了解它们，此时你可以先不用看图，了解后再看更佳。&lt;/p&gt;
&lt;h2&gt;　　1、工作内存与主内存是什么？它们有什么规定？&lt;/h2&gt;
&lt;p&gt;　　　　　　（1）工作内存：&lt;strong&gt;每条线程都有自己的内存&lt;/strong&gt;，这就是工作内存，在工作内存中主要是保存使用到的变量在主内存的拷贝（即存放主内存中工作内存用到的变量拷贝）；&lt;/p&gt;
&lt;p&gt;　　　　　　（2）主内存：&lt;strong&gt;VM内存的一部分，是新增变量的地方以及每个线程中所有变量来源之处，是可以被共享的数据元素。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（3）内存模型中的变量：是指实例字段与静态字段构成数组对象的元素，即&lt;strong&gt;能被共享的数据元素&lt;/strong&gt;，而&lt;strong&gt;不是被线程私有的局部变量与方法参数&lt;/strong&gt;等。&lt;strong&gt;&lt;span&gt;所有的变量都会存储在主内存（&lt;/span&gt;VM&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;内存的一部分）中&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（4）&lt;/span&gt;&lt;strong&gt;每条线程对变量的操作都必须在工作内存中进行，而不能直接操作主内存&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;　　　　　　（5）每条线程之间的工作内存是不能被共享的，不能相互访问各自的变量，&lt;strong&gt;&lt;span&gt;线程之间的变量&lt;/span&gt;“交流”只能通过主内存来实现&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;　　　　　　（6）&lt;span&gt;如果非要将&lt;/span&gt;JMM&lt;span&gt;中的主内存与工作内存跟&lt;/span&gt;&lt;span&gt;Java Heap&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Java Stack&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Method Area&lt;/span&gt;&lt;span&gt;做比较（实则两者不是一个概念），那么&lt;/span&gt;&lt;strong&gt;&lt;span&gt;可以认为工作内存就是&lt;/span&gt;Java Stack&lt;span&gt;（很好理解，这是因为&lt;/span&gt;Java Stack&lt;span&gt;是线程私有的，线程之间不能共享），&lt;/span&gt;&lt;span&gt;主内存就是&lt;/span&gt;Java Heap&lt;span&gt;中实例数据&lt;/span&gt;&lt;span&gt;（很好理解，&lt;/span&gt;Java Heap&lt;span&gt;中对象的实例数据是可以共享的）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt; 　　2、工作内存与主内存之间的交互&lt;/h2&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;这是理解多线程最重要的部分，多线程必然会涉及到内存之间的交互&lt;/strong&gt;，Java&lt;span&gt;的多线程之间的交互实则就是工作内存与主内存之间的交互&lt;/span&gt;，那么它们之间肯定要有相互交互的规定（即协议），主要分为八种：&lt;/p&gt;
&lt;p&gt;　　　　　　（1） Lock&lt;span&gt;：作用于主内存的变量，将该变量标识为某一条线程独占的资源，其他线程不能占用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;（2） Unlock&lt;span&gt;：与&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;相反，作用于主内存变量，释放被&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（3）Read&lt;span&gt;：作用于主内存的变量，将该变量从主内从中取出，传到线程的工作内存中。之后&lt;/span&gt;&lt;span&gt;Load&lt;/span&gt;&lt;span&gt;加载到工作内存的变量副本中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（4） Load&lt;span&gt;：将&lt;/span&gt;&lt;span&gt;Read&lt;/span&gt;&lt;span&gt;取到的变量放入工作内存的变量副本中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（5） Use&lt;span&gt;：将工作内存中变量传递给执行引擎，听从&lt;/span&gt;&lt;span&gt;VM&lt;/span&gt;&lt;span&gt;指令的安排（被使用到时会有相关指令）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（6）Assign&lt;span&gt;：接受执行引擎返回&lt;/span&gt;&lt;span&gt;Use&lt;/span&gt;&lt;span&gt;之后执行的结果值，将该值赋值给工作内存中对应的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（7）Store&lt;span&gt;：将功能内存中的值传递到主内存中，之后&lt;/span&gt;&lt;span&gt;Write&lt;/span&gt;&lt;span&gt;放入主内存的变量中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　（8） Write&lt;span&gt;：将&lt;/span&gt;&lt;span&gt;Store&lt;/span&gt;&lt;span&gt;的值放入主内存的变量中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　好了，突然一下子要记住八种操作，头也会而且可能还记不住，那么结合图总结下吧：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（1）&lt;/span&gt;&lt;strong&gt; &lt;span&gt;要把一个变量从主内存&lt;/span&gt;copy&lt;span&gt;到工作内存，只需要&lt;/span&gt;&lt;span&gt;Read-&amp;gt;Load&lt;/span&gt;&lt;span&gt;顺序即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201807/1352849-20180722183727891-76417706.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　（其中Variable Duplicate变量拷贝是属于工作内存Working Memory的，这里主要是为了能更好的展示，所以分离了，希望不要误解！）&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（2）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;如果把工作内存的变量同步回主内存，只需要&lt;/span&gt;Store-&amp;gt;Write&lt;span&gt;顺序即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1352849/201807/1352849-20180722183727888-1212145575.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　（其中Variable是属于Main Memory的，这里主要是为了能更好的展示，所以分离了，希望不要误解！）&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;　　　　　　（3） &lt;strong&gt;&lt;span&gt;如果&lt;/span&gt;VM&lt;span&gt;用到这个变量（即有关的操作指令），则执行&lt;/span&gt;&lt;span&gt;Use-&amp;gt;Assign&lt;/span&gt;&lt;span&gt;即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　这里就不画图了，简单来说就是我们在程序中用到变量，对变量初始化、更新等，也就是只要在VM中有相关操作该变量的指令，就会从工作内存中被Use，之后Assign赋值会写回公共内存，如i++，先拿到i，之后i+1,最后赋值i=i。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;　　　　注意：这些操作之间并不要求一定要连续，只要保证前后顺序即可，比如&lt;/span&gt;Read A, Read B, Load A, Load B&lt;span&gt;即可，而不需要&lt;/span&gt;&lt;span&gt;Read A, Load A, Read B, Load B&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;　　3、如何保证线程的一致性？&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　&lt;strong&gt;微观上讲我们需要实现线程的一致性这个目标，而宏观上就是如何确保在高并发下是安全的&lt;/strong&gt;，其实主要是通过八种操作之间的规定，才能保证多线程下一致性：&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　　&lt;span&gt;　（1）&lt;strong&gt; &lt;span&gt;不允许&lt;/span&gt;read&lt;span&gt;和&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;store&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;中单一操作出现&lt;/span&gt;&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（2）&lt;span&gt;不允许最近的赋值动作即&lt;/span&gt;assgin&lt;span&gt;被丢弃（&lt;/span&gt;&lt;strong&gt;工作内存中变量改变了必须同步回主内存中&lt;/strong&gt;）；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（3） &lt;span&gt;不允许线程中变量没有改变（即没有&lt;/span&gt;assign&lt;span&gt;操作），就把该变量数据同步回主内存（&lt;/span&gt;&lt;strong&gt;不接受毫无理由的同步回主内存&lt;/strong&gt;）；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（4） &lt;span&gt;&lt;strong&gt;一个变量的产生只能在主内存中，不允许工作内存使用一个未被初始化&lt;/strong&gt;（即未被&lt;/span&gt;assgin&lt;span&gt;赋值或&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;&lt;span&gt;加载&lt;/span&gt;）的变量&lt;span&gt;，即一个新的变量产生必须在主内存中，再&lt;/span&gt;read-&amp;gt;load&lt;span&gt;到工作内存变量副本中，之后进行中Use-&amp;gt;Assign&lt;/span&gt;&lt;span&gt;赋值，最后才有可能&lt;/span&gt;&lt;span&gt;stroe-&amp;gt;write&lt;/span&gt;&lt;span&gt;同步回主存，&lt;/span&gt;&lt;span&gt;换句话说就是对一个变量进行&lt;/span&gt;use/store&lt;span&gt;之前必须先进行&lt;/span&gt;&lt;span&gt;assign/load&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（5&lt;strong&gt;）Lock&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;span&gt;操作是成对出现的&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，一个变量只能被一个&lt;/span&gt;lock&lt;span&gt;操作，一个线程可以多次&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（6） &lt;strong&gt;&lt;span&gt;一个线程的&lt;/span&gt;lock&lt;span&gt;与&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;操作要对应&lt;/strong&gt;，不允许线程&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;线程&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;的变量。同理，如果没有&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;，那么不允许&lt;/span&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　（7） &lt;strong&gt;&lt;span&gt;一个变量执行&lt;/span&gt;lock&lt;span&gt;操作，会将工作内存中对应的变量清空，在执行引擎获取这个变量之前，必须&lt;/span&gt;&lt;span&gt;load/assgin&lt;/span&gt;&lt;span&gt;初始化这个变量&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这是因为执行引擎要获取的变量必须是最新的值，在&lt;/span&gt;lock-unlock&lt;span&gt;过程中该变量可能发生改变，所以必须重新初始化保证获得最新的值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　实际上，我们在程序中操作的变量是工作内存的变量副本，那么每次变量被改变（Use-&amp;gt;Assign）后，都会同步回（Store-&amp;gt;Write）主内存中，保持了变量的一致性，但是这只是单线程的情况下，那么在多线程情况下呢？比如线程A已经改变了变量的值，还没来的及同步回主内存，线程B就已经从主内存中将旧的变量值Read-&amp;gt;Load到工作内存。&lt;strong&gt;这就造成了被线程A修改后的变量值对线程B不可见的问题，导致变量不一致。最轻量的能解决此问题就是利用好Volatile关键字，&lt;/strong&gt;那么Volatile是如何实现的呢？&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　简单来说被Volatile关键字的变量一旦被改变后就会立即同步回内存中，保证其他线程能获得最新的当前变量值，而普遍变量不会立即同步回内存（事实上什么时候同步回内存是不确定的），所以导致不可见性。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　（1）&lt;strong&gt;保证此变量对所有线程的可见性：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　&lt;span&gt;① &lt;span&gt;线程的可见性并不是误认为&lt;/span&gt;“&lt;span&gt;Volatile&lt;/span&gt;&lt;span&gt;对所有线程的立即可见，也就是对某个变量写操作立马能反映到所有线程中，因此在高并发的情况下是安全的”，“&lt;/span&gt;&lt;strong&gt;Volatile&lt;span&gt;在高并发下是安全的”这个最后的结论是不成立的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　② &lt;strong&gt;Java&lt;span&gt;中相关的操作并不是原子操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，比如&lt;/span&gt;i++&lt;span&gt;，其实是分为两步（可以使用&lt;/span&gt;&lt;span&gt;Javap&lt;/span&gt;&lt;span&gt;反编译查看指令代码）的：先&lt;/span&gt;&lt;span&gt;i+1&lt;/span&gt;&lt;span&gt;，之后&lt;/span&gt;&lt;span&gt;i=i+1&lt;/span&gt;&lt;span&gt;。所以&lt;/span&gt;&lt;span&gt;Volatile&lt;/span&gt;&lt;span&gt;在高并发情况下并不是安全的。&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 演示使用Volatile在高并发下状态的不安全性：
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Jian
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VolatileDemo {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; THREAD_NUM = 10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程数目&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; AWAIT_TIME = 5*1000;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待时间&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  counter = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; increase() { counter++&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         ExecutorService exe =&lt;span&gt; Executors.newFixedThreadPool(THREAD_NUM);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; THREAD_NUM; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             exe.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; 1000; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                        increase();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测ExecutorService线程池任务结束并且是否关闭：一般结合shutdown与awaitTermination共同使用
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;shutdown停止接收新的任务并且等待已经提交的任务&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        exe.shutdown();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;awaitTermination等待超时设置，监控ExecutorService是否关闭&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;exe.awaitTermination(AWAIT_TIME, TimeUnit.SECONDS)) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 System.out.println(&quot;线程池没有关闭&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        System.out.println(counter);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;span&gt;按道理说最后变量i的结果应该是10*1000=10000，但是运行后你会发现输出结果都是小于10000且各不相同的值，造成这样的结果实则不是Volatile的锅，而是Java的非原子性，只是希望我们在关注并使用Volatile关键字的时候需要知道在高并发下不一定是安全的。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;Volatile&lt;span&gt;可以禁止指令重排序优化：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　也就是一般普通变量（未被&lt;/span&gt;Volatile&lt;span&gt;修饰）只能保证最后的变量结果是对的，但是&lt;strong&gt;不会保证变量涉及到的程序代码中顺序与底层执行指令顺序是一致。&lt;/strong&gt;需要注意的是重排序是一种编译过程中的一种优化手段。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　下列只能用伪代码的形式举例，因为指令重排序涉及到反编译指令码等（我并不了解，实际上一点也不）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VolatileDemo2 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否已经完成初始化标志&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; initialized = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; taskA = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         ExecutorService exe = Executors.newFixedThreadPool(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程A&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         exe.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A线程的任务是加1，完成初始化&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 taskA++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;initialized初始化完成，赋值为true，必须是先执行+1操作，才能赋值true
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是由于重排序这里可能先于taskA++执行，导致读取到的结果可能为0。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 initialized = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         exe.execute(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程B的任务是等待线程A初始化完成后，再读取taskA的值&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;initialized) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         System.out.println(&quot;线程A还未初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                System.out.println(taskA);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        exe.shutdown();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!exe.awaitTermination(5*1000&lt;span&gt;, TimeUnit.SECONDS)) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 System.out.println(&quot;线程池没有关闭&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;需要主要的就是下面的代码，&lt;strong&gt;虽然线程A中是保证了有序执行，再标志初始化完成，但是在指令中可能是先赋initialized为true，然后线程B这时候“抢先一步”先读initialized，那么变量taskA的值就可能为0&lt;/strong&gt;（实际业务中可能会是致命错误！）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
taskA++&lt;span&gt;;
initialized &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不使用volatile关键字，那么只有当明确赋值了initialized的方法被调用，接下来的任务才能不会出错（只要结果是true就行，不用管指令顺序）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; initialized;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setInitialized(){
    initialized &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; otherWorks(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化完成方法被明确调用，强制initialized结果为true，不用管指令顺序&lt;/span&gt;
&lt;span&gt;  setInitialized();  
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;initialized){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;other thread's tasks&lt;/span&gt;
&lt;span&gt;    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　（3）&lt;strong&gt;Volatile&lt;span&gt;与&lt;/span&gt;&lt;span&gt;Synchronized性能对比&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：一般情况下&lt;/span&gt;&lt;span&gt;Volatile&lt;/span&gt;&lt;span&gt;的同步机制要优于&lt;/span&gt;&lt;span&gt;Synchronized&lt;/span&gt;&lt;span&gt;（但是&lt;/span&gt;&lt;span&gt;VM&lt;/span&gt;&lt;span&gt;对&lt;/span&gt;&lt;span&gt;Synchronized&lt;/span&gt;&lt;span&gt;做了很多优化，所以其实也是说不准的），但是&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Volatile&lt;/span&gt;&lt;span&gt;好就好在读取变量跟普通变量的读取几乎没啥差别，但是写操作会慢一点（这是因为会在代码中加入内存屏障，保证指令不会乱序）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;　4&lt;span&gt;、&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;型变量非原子性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;的非原子性：&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;JMM&lt;span&gt;中规定&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;这样的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;位并且没有被&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;修饰数据可以划分为两部分&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;位来进行操作&lt;/strong&gt;，即&lt;/span&gt;&lt;span&gt;VM&lt;/span&gt;&lt;span&gt;允许对&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;位的数据类型的&lt;/span&gt;&lt;span&gt;load&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;store&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;read&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;write&lt;/span&gt;&lt;span&gt;不保证其原子性。&lt;/span&gt;&lt;span&gt;因为非原子性的存在，按理论上来说某个线程在极小的概率下可能会存在读到&lt;/span&gt;“半个变量”的情况。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　（&lt;/span&gt;2&lt;span&gt;）虽然由于&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;非原子性存在，&lt;strong&gt;但是&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;VM&lt;/span&gt;&lt;span&gt;对其的操作是具有原子性的，&lt;/span&gt;即对操作原子性，对数据非原子性&lt;/strong&gt;&lt;span&gt;。所以&lt;/span&gt;long&lt;span&gt;与&lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt;不需要被要求加&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;关键字。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 12:31:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9351281.html</dc:identifier>
</item>
<item>
<title>koa源码阅读[0] - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/9351234.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/9351234.html</guid>
<description>&lt;p&gt;Node.js也是写了两三年的时间了，刚开始学习&lt;code&gt;Node&lt;/code&gt;的时候，&lt;code&gt;hello world&lt;/code&gt;就是创建一个&lt;code&gt;HttpServer&lt;/code&gt;，后来在工作中也是经历过&lt;code&gt;Express&lt;/code&gt;、&lt;code&gt;Koa1.x&lt;/code&gt;、&lt;code&gt;Koa2.x&lt;/code&gt;以及最近还在研究的结合着&lt;code&gt;TypeScript&lt;/code&gt;的&lt;code&gt;routing-controllers&lt;/code&gt;（驱动依然是&lt;code&gt;Express&lt;/code&gt;与&lt;code&gt;Koa&lt;/code&gt;）。&lt;br/&gt;用的比较多的还是&lt;code&gt;Koa&lt;/code&gt;版本，也是对它的洋葱模型比较感兴趣，所以最近抽出时间来阅读其源码，正好近期可能会对一个&lt;code&gt;Express&lt;/code&gt;项目进行重构，将其重构为&lt;code&gt;koa2.x&lt;/code&gt;版本的，所以，阅读其源码对于重构也是一种有效的帮助。&lt;/p&gt;

&lt;p&gt;首先需要确定，Koa是什么。&lt;br/&gt;任何一个框架的出现都是为了解决问题，而Koa则是为了更方便的构建http服务而出现的。&lt;br/&gt;可以简单的理解为一个HTTP服务的中间件框架。&lt;/p&gt;
&lt;h2 id=&quot;使用http模块创建http服务&quot;&gt;使用http模块创建http服务&lt;/h2&gt;
&lt;p&gt;相信大家在学习Node时，应该都写过类似这样的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const http = require('http'&lt;span&gt;)

const serverHandler &lt;/span&gt;= (request, response) =&amp;gt;&lt;span&gt; {
  response.end(&lt;/span&gt;'Hello World') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回数据&lt;/span&gt;
&lt;span&gt;}

http
  .createServer(serverHandler)
  .listen(&lt;/span&gt;8888, _ =&amp;gt; console.log('Server run as http://127.0.0.1:8888'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一个最简单的示例，脚本运行后访问&lt;code&gt;&lt;a class=&quot;vglnk&quot; href=&quot;http://127.0.0.1:8888/&quot; rel=&quot;nofollow&quot;&gt;http://127.0.0.1:8888&lt;/a&gt;&lt;/code&gt;即可看到一个&lt;code&gt;Hello World&lt;/code&gt;的字符串。&lt;br/&gt;但是这仅仅是一个简单的示例，因为我们不管访问什么地址（甚至修改请求的Method），都总是会获取到这个字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt; curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8888&lt;/span&gt;
&amp;gt; curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8888/sub&lt;/span&gt;
&amp;gt; curl -X POST http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8888&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以我们可能会在回调中添加逻辑，根据路径、Method来返回给用户对应的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const serverHandler = (request, response) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; default&lt;/span&gt;
  let responseData = '404'

  &lt;span&gt;if&lt;/span&gt; (request.url === '/'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.method === 'GET'&lt;span&gt;) {
      responseData &lt;/span&gt;= 'Hello World'&lt;span&gt;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (request.method === 'POST'&lt;span&gt;) {
      responseData &lt;/span&gt;= 'Hello World With POST'&lt;span&gt;
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (request.url === '/sub'&lt;span&gt;) {
    responseData &lt;/span&gt;= 'sub page'&lt;span&gt;
  }

  response.end(responseData) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回数据&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;类似Express的实现&quot;&gt;类似Express的实现&lt;/h2&gt;
&lt;p&gt;但是这样的写法还会带来另一个问题，如果是一个很大的项目，存在N多的接口。&lt;br/&gt;如果都写在这一个&lt;code&gt;handler&lt;/code&gt;里边去，未免太过难以维护。&lt;br/&gt;示例只是简单的针对一个变量进行赋值，但是真实的项目不会有这么简单的逻辑存在的。&lt;br/&gt;所以，我们针对&lt;code&gt;handler&lt;/code&gt;进行一次抽象，让我们能够方便的管理路径：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class App {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlers =&lt;span&gt; {}

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.get = &lt;span&gt;this&lt;/span&gt;.route.bind(&lt;span&gt;this&lt;/span&gt;, 'GET'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.post = &lt;span&gt;this&lt;/span&gt;.route.bind(&lt;span&gt;this&lt;/span&gt;, 'POST'&lt;span&gt;)
  }

  route(method, path, handler) {
    let pathInfo &lt;/span&gt;= (&lt;span&gt;this&lt;/span&gt;.handlers[path] = &lt;span&gt;this&lt;/span&gt;.handlers[path] ||&lt;span&gt; {})

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; register handler&lt;/span&gt;
    pathInfo[method] =&lt;span&gt; handler
  }

  callback() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (request, response) =&amp;gt;&lt;span&gt; {
      let { url: path, method } &lt;/span&gt;=&lt;span&gt; request

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlers[path] &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlers[path][method]
        &lt;/span&gt;? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlers[path][method](request, response)
        : response.end(&lt;/span&gt;'404'&lt;span&gt;)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后通过实例化一个Router对象进行注册对应的路径，最后启动服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
const app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; App()

app.get(&lt;/span&gt;'/', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (request, response) {
  response.end(&lt;/span&gt;'Hello World'&lt;span&gt;)
})

app.post(&lt;/span&gt;'/', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (request, response) {
  response.end(&lt;/span&gt;'Hello World With POST'&lt;span&gt;)
})

app.get(&lt;/span&gt;'/sub', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (request, response) {
  response.end(&lt;/span&gt;'sub page'&lt;span&gt;)
})

http
  .createServer(app.callback())
  .listen(&lt;/span&gt;8888, _ =&amp;gt; console.log('Server run as http://127.0.0.1:8888'))
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;Express中的中间件&quot;&gt;Express中的中间件&lt;/h3&gt;
&lt;p&gt;这样，就实现了一个代码比较整洁的&lt;code&gt;HttpServer&lt;/code&gt;，但功能上依旧是很简陋的。&lt;br/&gt;如果我们现在有一个需求，要在部分请求的前边添加一些参数的生成，比如一个请求的唯一ID。&lt;br/&gt;将代码重复编写在我们的&lt;code&gt;handler&lt;/code&gt;中肯定是不可取的。&lt;br/&gt;所以我们要针对&lt;code&gt;route&lt;/code&gt;的处理进行优化，使其支持传入多个&lt;code&gt;handler&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;route(method, path, ...handler) {
  let pathInfo &lt;/span&gt;= (&lt;span&gt;this&lt;/span&gt;.handlers[path] = &lt;span&gt;this&lt;/span&gt;.handlers[path] ||&lt;span&gt; {})

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; register handler&lt;/span&gt;
  pathInfo[method] =&lt;span&gt; handler
}

callback() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (request, response) =&amp;gt;&lt;span&gt; {
    let { url: path, method } &lt;/span&gt;=&lt;span&gt; request

    let handlers &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.handlers[path] &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlers[path][method]

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (handlers) {
      let context &lt;/span&gt;=&lt;span&gt; {}
      &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; next(handlers, index = 0&lt;span&gt;) {
        handlers[index] &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
          handlers[index].call(context, request, response, () &lt;/span&gt;=&amp;gt;&lt;span&gt;
            next(handlers, index &lt;/span&gt;+ 1&lt;span&gt;)
          )
      }

      next(handlers)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      response.end(&lt;/span&gt;'404'&lt;span&gt;)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后针对上边的路径监听添加其他的handler：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; generatorId(request, response, next) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id = 123&lt;span&gt;
  next()
}

app.get(&lt;/span&gt;'/', generatorId, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(request, response) {
  response.end(`Hello World ${&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.id}`)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样在访问接口时，就可以看到&lt;code&gt;Hello World 123&lt;/code&gt;的字样了。&lt;br/&gt;这个就可以简单的认为是在&lt;code&gt;Express&lt;/code&gt;中实现的 &lt;strong&gt;中间件&lt;/strong&gt;。&lt;br/&gt;中间件是&lt;code&gt;Express&lt;/code&gt;、&lt;code&gt;Koa&lt;/code&gt;的核心所在，一切依赖都通过中间件来进行加载。&lt;/p&gt;
&lt;h2 id=&quot;更灵活的中间件方案-洋葱模型&quot;&gt;更灵活的中间件方案-洋葱模型&lt;/h2&gt;
&lt;p&gt;上述方案的确可以让人很方便的使用一些中间件，在流程控制中调用&lt;code&gt;next()&lt;/code&gt;来进入下一个环节，整个流程变得很清晰。&lt;br/&gt;但是依然存在一些局限性。&lt;br/&gt;例如如果我们需要进行一些接口的耗时统计，在&lt;code&gt;Express&lt;/code&gt;有这么几种可以实现的方案：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; beforeRequest(request, response, next) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requestTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()

  next()
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案1. 修改原handler处理逻辑，进行耗时的统计，然后end发送数据&lt;/span&gt;
app.get('/a', beforeRequest, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(request, response) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求耗时的统计&lt;/span&gt;
&lt;span&gt;  console.log(
    `${request.url} duration: ${&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Date().valueOf() - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestTime}`
  )

  response.end(&lt;/span&gt;'XXX'&lt;span&gt;)
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方案2. 将输出数据的逻辑挪到一个后置的中间件中&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; afterRequest(request, response, next) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求耗时的统计&lt;/span&gt;
&lt;span&gt;  console.log(
    `${request.url} duration: ${&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Date().valueOf() - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requestTime}`
  )

  response.end(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body)
}

app.get(
  &lt;/span&gt;'/b'&lt;span&gt;,
  beforeRequest,
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(request, response, next) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.body = 'XXX'&lt;span&gt;

    next() &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记得调用，不然中间件在这里就终止了&lt;/span&gt;
&lt;span&gt;  },
  afterRequest
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;无论是哪一种方案，对于原有代码都是一种破坏性的修改，这是不可取的。&lt;br/&gt;因为&lt;code&gt;Express&lt;/code&gt;采用了&lt;code&gt;response.end()&lt;/code&gt;的方式来向接口请求方返回数据，调用后即会终止后续代码的执行。&lt;br/&gt;而且因为当时没有一个很好的方案去等待某个中间件中的异步函数的执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; a(_, _, next) {
  console.log(&lt;/span&gt;'before a'&lt;span&gt;)
  let results &lt;/span&gt;=&lt;span&gt; next()
  console.log(&lt;/span&gt;'after a'&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; b(_, _, next) {
  console.log(&lt;/span&gt;'before b'&lt;span&gt;)
  setTimeout(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.body = 123456&lt;span&gt;
    next()
  }, &lt;/span&gt;1000&lt;span&gt;)
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; c(_, response) {
  console.log(&lt;/span&gt;'before c'&lt;span&gt;)
  response.end(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.body)
}

app.get(&lt;/span&gt;'/', a, b, c)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就像上述的示例，实际上log的输出顺序为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;before a
before b
after a
before c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这显然不符合我们的预期，所以在&lt;code&gt;Express&lt;/code&gt;中获取&lt;code&gt;next()&lt;/code&gt;的返回值是没有意义的。&lt;/p&gt;
&lt;p&gt;所以就有了&lt;code&gt;Koa&lt;/code&gt;带来的洋葱模型，在&lt;code&gt;Koa1.x&lt;/code&gt;出现的时间，正好赶上了Node支持了新的语法，&lt;code&gt;Generator&lt;/code&gt;函数及&lt;code&gt;Promise&lt;/code&gt;的定义。&lt;br/&gt;所以才有了&lt;code&gt;co&lt;/code&gt;这样令人惊叹的库，而当我们的中间件使用了&lt;code&gt;Promise&lt;/code&gt;以后，前一个中间件就可以很轻易的在后续代码执行完毕后再处理自己的事情。&lt;br/&gt;但是，&lt;code&gt;Generator&lt;/code&gt;本身的作用并不是用来帮助我们更轻松的使用&lt;code&gt;Promise&lt;/code&gt;来做异步流程的控制。&lt;br/&gt;所以，随着Node7.6版本的发出，支持了&lt;code&gt;async&lt;/code&gt;、&lt;code&gt;await&lt;/code&gt;语法，社区也推出了&lt;code&gt;Koa2.x&lt;/code&gt;，使用&lt;code&gt;async&lt;/code&gt;语法替换之前的&lt;code&gt;co&lt;/code&gt;+&lt;code&gt;Generator&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Koa&lt;/code&gt;也将&lt;code&gt;co&lt;/code&gt;从依赖中移除（2.x版本使用&lt;a href=&quot;https://github.com/koajs/convert&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;koa-convert&lt;/a&gt;将&lt;code&gt;Generator&lt;/code&gt;函数转换为&lt;code&gt;promise&lt;/code&gt;，在3.x版本中将直接不支持&lt;code&gt;Generator&lt;/code&gt;）&lt;br/&gt;&lt;em&gt;ref: &lt;a href=&quot;https://github.com/koajs/koa/blob/162a5b3e78bf0838cee67119804f066d6e38bf02/lib/application.js#L108&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;remove generator supports&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;由于在功能、使用上&lt;code&gt;Koa&lt;/code&gt;的两个版本之间并没有什么区别，最多就是一些语法的调整，所以会直接跳过一些&lt;code&gt;Koa1.x&lt;/code&gt;相关的东西，直奔主题。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Koa&lt;/code&gt;中，可以使用如下的方式来定义中间件并使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; log(ctx, next) {
  let requestTime &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
  await next()

  console.log(`${ctx.url} duration: ${&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Date().valueOf() -&lt;span&gt; requestTime}`)
}

router.get(&lt;/span&gt;'/', log, ctx =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something...&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为一些语法糖的存在，遮盖了代码实际运行的过程，所以，我们使用&lt;code&gt;Promise&lt;/code&gt;来还原一下上述代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; log() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    let requestTime &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().valueOf()
    next().then(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      console.log(`${ctx.url} duration: ${&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Date().valueOf() -&lt;span&gt; requestTime}`)
    }).then(resolve)
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大致代码是这样的，也就是说，调用&lt;code&gt;next&lt;/code&gt;会给我们返回一个&lt;code&gt;Promise&lt;/code&gt;对象，而&lt;code&gt;Promise&lt;/code&gt;何时会&lt;code&gt;resolve&lt;/code&gt;就是&lt;code&gt;Koa&lt;/code&gt;内部做的处理。&lt;br/&gt;可以简单的实现一下（关于上边实现的App类，仅仅需要修改&lt;code&gt;callback&lt;/code&gt;即可）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;callback() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (request, response) =&amp;gt;&lt;span&gt; {
    let { url: path, method } &lt;/span&gt;=&lt;span&gt; request

    let handlers &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.handlers[path] &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handlers[path][method]

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (handlers) {
      let context &lt;/span&gt;=&lt;span&gt; { url: request.url }
      &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; next(handlers, index = 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!handlers[index]) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resolve()

          handlers[index](context, () &lt;/span&gt;=&amp;gt; next(handlers, index + 1&lt;span&gt;)).then(
            resolve,
            reject
          )
        })
      }

      next(handlers).then(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结束请求&lt;/span&gt;
        response.end(context.body || '404'&lt;span&gt;)
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      response.end(&lt;/span&gt;'404'&lt;span&gt;)
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每次调用中间件时就监听&lt;code&gt;then&lt;/code&gt;，并将当前&lt;code&gt;Promise&lt;/code&gt;的&lt;code&gt;resolve&lt;/code&gt;与&lt;code&gt;reject&lt;/code&gt;处理传入&lt;code&gt;Promise&lt;/code&gt;的回调中。&lt;br/&gt;也就是说，只有当第二个中间件的&lt;code&gt;resolve&lt;/code&gt;被调用时，第一个中间件的&lt;code&gt;then&lt;/code&gt;回调才会执行。&lt;br/&gt;这样就实现了一个洋葱模型。&lt;/p&gt;
&lt;p&gt;就像我们的&lt;code&gt;log&lt;/code&gt;中间件执行的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取当前的时间戳&lt;code&gt;requestTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;next()&lt;/code&gt;执行后续的中间件，并监听其回调&lt;/li&gt;
&lt;li&gt;第二个中间件里边可能会调用第三个、第四个、第五个，但这都不是&lt;code&gt;log&lt;/code&gt;所关心的，&lt;code&gt;log&lt;/code&gt;只关心第二个中间件何时&lt;code&gt;resolve&lt;/code&gt;，而第二个中间件的&lt;code&gt;resolve&lt;/code&gt;则依赖他后边的中间件的&lt;code&gt;resolve&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;等到第二个中间件&lt;code&gt;resolve&lt;/code&gt;，这就意味着后续没有其他的中间件在执行了（全都&lt;code&gt;resolve&lt;/code&gt;了），此时&lt;code&gt;log&lt;/code&gt;才会继续后续代码的执行&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以就像洋葱一样一层一层的包裹，最外层是最大的，是最先执行的，也是最后执行的。（在一个完整的请求中，&lt;code&gt;next&lt;/code&gt;之前最先执行，&lt;code&gt;next&lt;/code&gt;之后最后执行）。&lt;br/&gt;&lt;img src=&quot;https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小记&quot;&gt;小记&lt;/h2&gt;
&lt;p&gt;最近抽时间将&lt;code&gt;Koa&lt;/code&gt;相关的源码翻看一波，看得挺激动的，想要将它们记录下来。&lt;br/&gt;应该会拆分为几段来，不一篇全写了，上次写了个装饰器的，太长，看得自己都困了。&lt;br/&gt;先占几个坑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;核心模块 koa与koa-compose&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;热门中间件 koa-router与koa-views&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;杂七杂八的轮子 koa-bodyparser/multer/better-body/static&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Jiasm/notebook/tree/master/labs/demo/node/learning-koa&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;示例代码仓库地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/Jiasm/notebook/blob/master/notes/koa%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/readme.md&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;源码阅读仓库地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 12:16:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/9351234.html</dc:identifier>
</item>
</channel>
</rss>