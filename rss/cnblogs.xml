<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>订单号生成的一些想法 - .Zing</title>
<link>http://www.cnblogs.com/wangwansong/p/9468443.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangwansong/p/9468443.html</guid>
<description>&lt;h4&gt;背景&lt;/h4&gt;
&lt;p&gt;　　早上QA小姐姐发现线上有个报错，过去一看，采购单号生成异常，后台duplicate key，也就是说生成了重复单号。这个模块之前不是我写的（这个哥们刚离职了），而后来的领料单号的生成我重新写了下，规则比较简单，重复率也比较低，大家有好的方案也可以分享下。&lt;/p&gt;
&lt;h4&gt;正文&lt;/h4&gt;
&lt;p&gt;　　首先，背景是我们这里需要一个18位的单号（有多种类型：采购、发货、领料等），订单号之类的基本规则：唯一、无序（特殊情况会要求排序、增量等），我们这里定了相应的格式：4位shopId + 2位订单类型编码 + 8位年月日 + 4位字符，&lt;/p&gt;
&lt;p&gt;例如：0004CK201805080005。而原来哥们最后四位是用递增来生成的，0001之类的，而且是从数据库读取最新生成的单号，截取最后四位然后加1，这样的问题很明显：多机器（集群）时，或者有并发时很容易生成重复单号导致报错，由于我们这里是内部管理系统，并发量不大，但还是发生报错。还有连续生成的规则，容易被恶意爬取推算出每日的单量等。&lt;/p&gt;
&lt;p&gt;　　然后，基于原来的规则，我把最后的4为字符改为随机，加入了0-9、A-Z共36个字符，方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String[] chars = &lt;span&gt;new&lt;/span&gt; String[] { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Z&quot;&lt;span&gt; };

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 
     * @Description:生成指定位数随机字符
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; length
     *            位数
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; String
     * &lt;/span&gt;&lt;span&gt;@exception&lt;/span&gt;&lt;span&gt;:
     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt;: wws
     * @time:2018年5月8日 下午4:18:58
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String generateCode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length) {
        StringBuilder shortBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        String uuid &lt;/span&gt;= UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
            String str &lt;/span&gt;= uuid.substring(i * 4, i * 4 + 4&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = Integer.parseInt(str, 16&lt;span&gt;);
            shortBuffer.append(chars[x &lt;/span&gt;%&lt;span&gt; chars.length]);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; shortBuffer.toString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们生成的4位数的组合理论上重复的概率是很低的，适合中小的系统使用。&lt;/p&gt;
&lt;h4&gt;其他生成方法&lt;/h4&gt;
&lt;p&gt;　　1. 使用mysql自增id，优点：简单、保证唯一性；缺点：过于简单、且数据日渐增加、没有区分度（不同业务订单类型无法分辨）等&lt;/p&gt;
&lt;p&gt;　　2. UUID存储，优点：生成简单、无消耗；缺点：长度过长、没区分度、无序（数据位置无规则，可能影响到索引）、不安全（基于mac地址生成，可能导致泄露）等&lt;/p&gt;
&lt;p&gt;　　3. snowflake（Twitter），优点：不依赖数据库、性能好、单机递增；缺点：强依赖机器时钟、分布式下可能不同步等&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4. 美团的leaf（https://tech.meituan.com/MT_Leaf.html）。美团这里提供的思路很清晰，针对取号、时钟回拨等问题进行了分析，也提供了相应的解决（预警）方案，推荐大家看下。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 07:47:00 +0000</pubDate>
<dc:creator>.Zing</dc:creator>
<og:description>背景 早上QA小姐姐发现线上有个报错，过去一看，采购单号生成异常，后台duplicate key，也就是说生成了重复单号。这个模块之前不是我写的（这个哥们刚离职了），而后来的领料单号的生成我重新写了下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangwansong/p/9468443.html</dc:identifier>
</item>
<item>
<title>C#.NET使用Task,await,async,异步执行控件耗时事件(event),不阻塞UI线程和不跨线程执行UI更新,以及其他方式比较 - JasNature</title>
<link>http://www.cnblogs.com/NatureSex/p/9468079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NatureSex/p/9468079.html</guid>
<description>&lt;p&gt;使用Task,await,async,异步执行事件(event),不阻塞UI线程和不跨线程执行UI更新&lt;/p&gt;
&lt;p&gt;　　使用Task,await,async 的异步模式 去执行事件(event) 解决不阻塞UI线程和不夸跨线程执行UI更新报错的最佳实践&lt;span&gt;&lt;strong&gt;,附加几种其他方式比较&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于是Winform代码和其他原因&lt;/strong&gt;，本文章只做代码截图演示，不做界面UI展示，当然所有代码都会在截图展示。&lt;/p&gt;

&lt;p&gt;1：封装异步按钮（为了比较放了3个按钮）和进度条的控件，包含基本文件演示截图&lt;/p&gt;
&lt;p&gt;1.1 演示工程截图&lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813151208142-1105495767.png&quot; alt=&quot;&quot;/&gt; 1.2按钮和进度条控件演示 &lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813151238026-34523488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2：定义异步委托和事件和几种演示封装&lt;/p&gt;
&lt;p&gt;2.1 定义相关事件&lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813151430967-1708515723.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;span&gt;解析：最前面的是普通的事件定义，后面2行是异步定义。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2.2 &lt;strong&gt;按钮名称[Task]&lt;/strong&gt;执行普通异步Task&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813151718717-865515523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析调用过程：当用户点击按钮时会加载所有用户注册的事件进行多线程分发，单独每一个委托进行执行，最后单独使用线程进行等待，这样不阻塞UI线程。&lt;/p&gt;
&lt;p&gt;但是用户注册的事件方法如果有更新UI会报错，需要额外的Invoke进行处理。&lt;/p&gt;


&lt;p&gt;2.3 &lt;strong&gt;按钮名称[BeginInvoke]&lt;/strong&gt;执行普通异步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813151825663-1324326789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析调用过程：这个调用过程和Task一样，但是简单，这个也可以写成多事件注册，多多领会异步编程模型的好处(原理：异步执行，内部等待信号通知结束)。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2.4&lt;/span&gt; &lt;strong&gt;&lt;span&gt;(推荐)&lt;/span&gt;&lt;span&gt;按钮名称[Task await]&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;执行方便的异步耗时操作和简单的UI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813152001889-1730890871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析调用过程：推荐的方式附加调用流程&lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813153255825-1504725827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这个全是优点啊：&lt;strong&gt;&lt;span&gt;代码精简，异步执行方法可以像同步的方式来调用，用户注册的事件方法可以随意更新UI，无需invoke，稍微改造一下就能多事件注册。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3：其他用户调用封装好的异步按钮执行耗时操作&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/274368/201808/274368-20180813152035857-1292753950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;

&lt;p&gt;大家有时间的可以自己根据截图去敲打代码试试，总结如下：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;按钮名称[Task]   : &lt;/strong&gt;可以实现多个事件注册，但是代码比较多，&lt;strong&gt;需要额外的线程等待来结束进度条&lt;/strong&gt;，而且用户注册的事件的方法更新UI时会报错，提示跨线程操作UI，需要invoke方法调用到UI线程执行。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;按钮名称[BeginInvoke] : &lt;/strong&gt; 简单方便的异步编程模型，&lt;strong&gt;不需要额外的线程&lt;/strong&gt;等待结束来结束进度条,缺点和&lt;strong&gt;按钮名称[Task]&lt;/strong&gt;一样，用户注册的事件的方法更新UI时会报错，提示跨线程操作UI，需要invoke方法调用到UI线程执行.&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;按钮名称[Task await] : 稍微有一点点绕，但是简单呀，不需要额外的线程等待UI更新进度条，像同步方法放在await后面即可，而且用户注册的事件方法 更新UI时不需要invoke方法回到UI线程执行。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 13 Aug 2018 07:44:00 +0000</pubDate>
<dc:creator>JasNature</dc:creator>
<og:description>使用Task,await,async,异步执行事件(event),不阻塞UI线程和不跨线程执行UI更新 使用Task,await,async 的异步模式 去执行事件(event) 解决不阻塞UI线程和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NatureSex/p/9468079.html</dc:identifier>
</item>
<item>
<title>Mysql系列六：Mycat常用分片规则介绍和对应源码 - 小不点啊</title>
<link>http://www.cnblogs.com/leeSmall/p/9462658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leeSmall/p/9462658.html</guid>
<description>&lt;p&gt;1. 时间类：按天分片、自然月分片、单月小时分片&lt;/p&gt;
&lt;p&gt;2. 哈希类：Hash固定分片、日期范围Hash分片、截取数字Hash求模范围分片、截取数字Hash分片、一致性Hash分片&lt;/p&gt;
&lt;p&gt;3. 取模类：取模分片、取模范围分片、范围求模分片&lt;/p&gt;
&lt;p&gt;4. 其他类：枚举分片、范围约定分片、应用指定分片、冷热数据分片&lt;/p&gt;
&lt;p&gt;下面基于源码来介绍Mycat的常用分片规则，&lt;a href=&quot;https://github.com/MyCATApache/Mycat-Server&quot; target=&quot;_blank&quot;&gt;源码地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/strong&gt;分片规则都定义在rule.xml文件里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &amp;lt;!--&lt;/span&gt;&lt;span&gt;
        tableRule标签:定义table分片策略
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rule1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
        rule标签:策略定义标签
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            columns标签:对应的分片字段
            &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            algorithm标签:tableRule分片策略对应的function名称
            &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;func1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;    &amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义分片函数 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;func1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByLong&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1,1,2,3,1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 分片数 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionLength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;128,128,128,128,128&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 分片长度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1. 自动范围分片&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;auto-sharding-long&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rang-long&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rang-long&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.AutoPartitionByLong&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapFile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;autopartition-long.txt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有3个分片，第1个分片存储的是1-500000的数据，第2个分片存储的是500001-1000000的数据，第3个分片存储的是1000001-1500000的数据&lt;/p&gt;
&lt;p&gt;insert into employee(id, name) value(1,Tom);在第1个分片&lt;/p&gt;
&lt;p&gt;insert into employee(id, name) value(500002,Jack);在第2个分片&lt;/p&gt;
&lt;p&gt;insert into employee(id, name) value(1000002,Lucy);在第3个分片&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_131035ee-81b7-43c1-9ae4-4c040c5fe326&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_131035ee-81b7-43c1-9ae4-4c040c5fe326&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_131035ee-81b7-43c1-9ae4-4c040c5fe326&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * auto partition by Long ,can be used in auto increment primary key partition
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wuzhi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AutoPartitionByLong &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String mapFile;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LongRange[] longRongs;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; defaultNode = -1&lt;span&gt;;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {

        initialize();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMapFile(String mapFile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapFile =&lt;span&gt; mapFile;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        columnValue = NumberParseUtil.eliminateQoute(columnValue);&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; value =&lt;span&gt; Long.parseLong(columnValue);
            Integer rst &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (LongRange longRang : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.longRongs) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;lt;= longRang.valueEnd &amp;amp;&amp;amp; value &amp;gt;=&lt;span&gt; longRang.valueStart) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; longRang.nodeIndx;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据超过范围，暂时使用配置的默认节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (rst == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; defaultNode &amp;gt;= 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultNode;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rst;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please eliminate any quote and non number within it.&quot;&lt;span&gt;).toString(),e);
        }
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer[] calculateRange(String beginValue, String endValue)  {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; AbstractPartitionAlgorithm.calculateSequenceRange(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, beginValue, endValue);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPartitionNum() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        int nPartition = longRongs.length;&lt;/span&gt;
        
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * fix #1284 这里的统计应该统计Range的nodeIndex的distinct总数
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Set&lt;/span&gt;&amp;lt;Integer&amp;gt; distNodeIdxSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Integer&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(LongRange range : longRongs) {
            distNodeIdxSet.add(range.nodeIndx);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nPartition =&lt;span&gt; distNodeIdxSet.size();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nPartition;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize() {
        BufferedReader in &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; FileInputStream fin = new FileInputStream(new File(fileMapPath));&lt;/span&gt;
            InputStream fin = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().getClassLoader()
                    .getResourceAsStream(mapFile);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fin == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;can't find class resource file &quot;
                        +&lt;span&gt; mapFile);
            }
            in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(fin));
            LinkedList&lt;/span&gt;&amp;lt;LongRange&amp;gt; longRangeList = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;LongRange&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String line = &lt;span&gt;null&lt;/span&gt;; (line = in.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
                line &lt;/span&gt;=&lt;span&gt; line.trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (line.startsWith(&quot;#&quot;) || line.startsWith(&quot;//&quot;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ind = line.indexOf('='&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ind &amp;lt; 0&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot; warn: bad line int &quot; + mapFile + &quot; :&quot;
                            +&lt;span&gt; line);
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                    String pairs[] &lt;/span&gt;= line.substring(0, ind).trim().split(&quot;-&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; longStart = NumberParseUtil.parseLong(pairs[0&lt;span&gt;].trim());
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; longEnd = NumberParseUtil.parseLong(pairs[1&lt;span&gt;].trim());
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nodeId = Integer.parseInt(line.substring(ind + 1&lt;span&gt;)
                            .trim());
                    longRangeList
                            .add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LongRange(nodeId, longStart, longEnd));

            }
            longRongs &lt;/span&gt;= longRangeList.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LongRange[longRangeList
                    .size()]);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) e;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
            }

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                in.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e2) {
            }
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getDefaultNode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultNode;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setDefaultNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultNode) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.defaultNode =&lt;span&gt; defaultNode;
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LongRange {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nodeIndx;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueStart;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueEnd;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LongRange(&lt;span&gt;int&lt;/span&gt; nodeIndx, &lt;span&gt;long&lt;/span&gt; valueStart, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueEnd) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nodeIndx =&lt;span&gt; nodeIndx;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.valueStart =&lt;span&gt; valueStart;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.valueEnd =&lt;span&gt; valueEnd;
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;2. 枚举分片&lt;/h2&gt;
&lt;p&gt;把数据分类存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-intfile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sharding_id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hash-int&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hash-int&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByFileMap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mapFile&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;partition-hash-int.txt&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultNode&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 找不到分片时设置容错规则，把数据插入到默认分片0里面 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;找不到分片时设置容错规则，把数据插入到默认分片&lt;/span&gt;0&lt;span&gt;里面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_eb44109b-af6d-450f-ae48-3ed5bf635209&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eb44109b-af6d-450f-ae48-3ed5bf635209&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eb44109b-af6d-450f-ae48-3ed5bf635209&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; mycat
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByFileMap &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String mapFile;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;Object, Integer&amp;gt;&lt;span&gt; app2Partition;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Map&amp;lt;Object, Integer&amp;gt; app2Partition中key值的类型：默认值为0，0表示Integer，非零表示String
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; type;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认节点在map中的key
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DEFAULT_NODE = &quot;DEFAULT_NODE&quot;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认节点:小于0表示不设置默认节点，大于等于0表示设置默认节点
     * 
     * 默认节点的作用：枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点
     *                如果不配置默认节点（defaultNode值小于0表示不配置默认节点），碰到
     *                不识别的枚举值就会报错，
     *                like this：can't find datanode for sharding column:column_name val:ffffffff    
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; defaultNode = -1&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {

        initialize();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMapFile(String mapFile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapFile =&lt;span&gt; mapFile;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setType(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; type) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setDefaultNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultNode) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.defaultNode =&lt;span&gt; defaultNode;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Object value &lt;/span&gt;=&lt;span&gt; columnValue;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type == 0&lt;span&gt;) {
                value &lt;/span&gt;=&lt;span&gt; Integer.valueOf(columnValue);
            }
            Integer rst &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            Integer pid &lt;/span&gt;=&lt;span&gt; app2Partition.get(value);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pid != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                rst &lt;/span&gt;=&lt;span&gt; pid;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                rst &lt;/span&gt;=&lt;span&gt; app2Partition.get(DEFAULT_NODE);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rst;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please check if the format satisfied.&quot;&lt;span&gt;).toString(),e);
        }
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPartitionNum() {
        Set&lt;/span&gt;&amp;lt;Integer&amp;gt; set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Integer&amp;gt;&lt;span&gt;(app2Partition.values());
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; set.size();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize() {
        BufferedReader in &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; FileInputStream fin = new FileInputStream(new File(fileMapPath));&lt;/span&gt;
            InputStream fin = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().getClassLoader()
                    .getResourceAsStream(mapFile);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fin == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;can't find class resource file &quot;
                        +&lt;span&gt; mapFile);
            }
            in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(fin));
            
            app2Partition &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Object, Integer&amp;gt;&lt;span&gt;();
            
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String line = &lt;span&gt;null&lt;/span&gt;; (line = in.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
                line &lt;/span&gt;=&lt;span&gt; line.trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (line.startsWith(&quot;#&quot;) || line.startsWith(&quot;//&quot;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ind = line.indexOf('='&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ind &amp;lt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    String key &lt;/span&gt;= line.substring(0&lt;span&gt;, ind).trim();
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pid = Integer.parseInt(line.substring(ind + 1&lt;span&gt;).trim());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(type == 0&lt;span&gt;) {
                        app2Partition.put(Integer.parseInt(key), pid);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        app2Partition.put(key, pid);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置默认节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(defaultNode &amp;gt;= 0&lt;span&gt;) {
                app2Partition.put(DEFAULT_NODE, defaultNode);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) e;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
            }

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                in.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e2) {
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;3. Hash固定分片（固定分片Hash算法）&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;固定分片&lt;/span&gt;Hash&lt;span&gt;算法，最多有&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;个分片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;rule1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
        rule标签:策略定义标签
        &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            columns标签:对应的分片字段
            &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
            algorithm标签:tableRule分片策略对应的function名称
            &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;func1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;func1&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByLong&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionCount&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1,1,2,3,1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 分片数 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionLength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;128,128,128,128,128&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 分片长度 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1) partitionCount.length&lt;span&gt;必须等于&lt;/span&gt;&lt;span&gt;partitionLength.length&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2) sum((partitionCount[i]*partitionLength[j])) === 1024——&amp;gt;partitionCount[0]*partitionLength[0]+partitionCount[1]*partitionLength[1] === 1024&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即：&lt;/span&gt;1*128+1*128+2*128+3*128+1*128 === 1024&lt;/p&gt;
&lt;p&gt;eg：&lt;/p&gt;
&lt;p&gt;8&lt;span&gt;个分片表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第&lt;/span&gt;1&lt;span&gt;个分片表的下标为&lt;/span&gt;&lt;span&gt;0: 0-127&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第&lt;/span&gt;2&lt;span&gt;个分片表的下标为&lt;/span&gt;&lt;span&gt;1: 127-255&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;...................&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第&lt;/span&gt;8&lt;span&gt;个分片表的下标为&lt;/span&gt;&lt;span&gt;7: 896-1024&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何确定落在哪个分片上呢？分片&lt;/span&gt;id&lt;span&gt;的值与&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;取余可确定在哪个分片上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如&lt;/span&gt;id%1024 = 128 &lt;span&gt;则落在第&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个分片上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对应代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_e56061fd-b602-4ca4-99b7-0cec8f16847c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e56061fd-b602-4ca4-99b7-0cec8f16847c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e56061fd-b602-4ca4-99b7-0cec8f16847c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.route.util.PartitionUtil;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByLong &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] count;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] length;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; PartitionUtil partitionUtil;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] toIntArray(String string) {
        String[] strs &lt;/span&gt;= io.mycat.util.SplitUtil.split(string, ',', &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] ints = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[strs.length];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; strs.length; ++&lt;span&gt;i) {
            ints[i] &lt;/span&gt;=&lt;span&gt; Integer.parseInt(strs[i]);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ints;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPartitionCount(String partitionCount) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; toIntArray(partitionCount);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPartitionLength(String partitionLength) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.length =&lt;span&gt; toIntArray(partitionLength);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        partitionUtil &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionUtil(count, length);

    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        columnValue = NumberParseUtil.eliminateQoute(columnValue);&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; key =&lt;span&gt; Long.parseLong(columnValue);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; partitionUtil.partition(key);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please eliminate any quote and non number within it.&quot;&lt;span&gt;).toString(),e);
        }
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer[] calculateRange(String beginValue, String endValue)  {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; AbstractPartitionAlgorithm.calculateSequenceRange(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, beginValue, endValue);
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public int getPartitionCount() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        int nPartition = 0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        for(int i = 0; i &amp;lt; count.length; i++) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            nPartition += count[i];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return nPartition;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;4. 求模分片&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;分片字段&lt;/span&gt;id%&lt;span&gt;分片数&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;分片下标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;分片字段 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mod-long&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByMod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; how many data nodes &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;分片数 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_7981c749-ed52-424d-af09-89a3b6307113&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7981c749-ed52-424d-af09-89a3b6307113&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7981c749-ed52-424d-af09-89a3b6307113&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.math.BigInteger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * number column partion by Mod operator
 * if count is 10 then 0 to 0,21 to 1 (21 % 10 =1)
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wuzhih
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByMod &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm  {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
    
        
    }



    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        columnValue = NumberParseUtil.eliminateQoute(columnValue);&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            BigInteger bigNum &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BigInteger(columnValue).abs();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (bigNum.mod(BigInteger.valueOf(count))).intValue();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please eliminate any quote and non number within it.&quot;&lt;span&gt;).toString(),e);
        }

    }
    

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPartitionNum() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nPartition = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nPartition;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hashTest()  {
        PartitionByMod hash&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionByMod();
        hash.setCount(&lt;/span&gt;11&lt;span&gt;);
        hash.init();
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] bucket=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[hash.count];
        
        Map&lt;/span&gt;&amp;lt;Integer,List&amp;lt;Integer&amp;gt;&amp;gt; hashed=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total=1000_0000;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据量&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=100_0000;i&amp;lt;total+100_0000;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设分片键从100万开始&lt;/span&gt;
            c++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h=&lt;span&gt;hash.calculate(Integer.toString(i));
            bucket[h]&lt;/span&gt;++&lt;span&gt;;
            List&lt;/span&gt;&amp;lt;Integer&amp;gt; list=&lt;span&gt;hashed.get(h);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(list==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                list&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
                hashed.put(h, list);
            }
            list.add(i);
        }
        System.out.println(c&lt;/span&gt;+&quot;   &quot;+&lt;span&gt;total);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d=0&lt;span&gt;;
        c&lt;/span&gt;=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; idx=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;index    bucket   ratio&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i:bucket){
            d&lt;/span&gt;+=i/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)total;
            c&lt;/span&gt;+=&lt;span&gt;i;
            System.out.println(idx&lt;/span&gt;+++&quot;  &quot;+i+&quot;   &quot;+(i/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)total));
        }
        System.out.println(d&lt;/span&gt;+&quot;  &quot;+&lt;span&gt;c);
        
        System.out.println(&lt;/span&gt;&quot;****************************************************&quot;&lt;span&gt;);
        rehashTest(hashed.get(&lt;/span&gt;0&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rehashTest(List&amp;lt;Integer&amp;gt;&lt;span&gt; partition)  {
        PartitionByMod hash&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionByMod();
        hash.count&lt;/span&gt;=110;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分片数&lt;/span&gt;
&lt;span&gt;        hash.init();
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] bucket=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[hash.count];
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total=partition.size();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据量&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i:partition){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设分片键从100万开始&lt;/span&gt;
            c++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h=&lt;span&gt;hash.calculate(Integer.toString(i));
            bucket[h]&lt;/span&gt;++&lt;span&gt;;
        }
        System.out.println(c&lt;/span&gt;+&quot;   &quot;+&lt;span&gt;total);
        c&lt;/span&gt;=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; idx=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;index    bucket   ratio&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i:bucket){
            c&lt;/span&gt;+=&lt;span&gt;i;
            System.out.println(idx&lt;/span&gt;+++&quot;  &quot;+i+&quot;   &quot;+(i/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)total));
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)  {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        hashTest();&lt;/span&gt;
        PartitionByMod partitionByMod = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionByMod();
        partitionByMod.count&lt;/span&gt;=8&lt;span&gt;;
        partitionByMod.calculate(&lt;/span&gt;&quot;\&quot;6\&quot;&quot;&lt;span&gt;);
        partitionByMod.calculate(&lt;/span&gt;&quot;\'6\'&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;5. 自然月分片&lt;/h2&gt;
&lt;p&gt;按照自然月的方式进行分片&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-month&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;create_time&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;partbymonth&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partbymonth&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByMonth&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dateFormat&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yyyy-MM-dd&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sBeginDate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2015-01-01&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果月份超过了分片数，则通过设置&lt;/span&gt;sEndDated&lt;span&gt;的值来解决&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如有&lt;/span&gt;3&lt;span&gt;个分片，分别插入&lt;/span&gt;&lt;span&gt;2015-01-12&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;2015-02-12&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;2015-03-12&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;2016-11-12&lt;/span&gt;&lt;span&gt;，月份超过了分片数，此时设置&lt;/span&gt;&lt;span&gt;sEndDated= 2015-04-12&lt;/span&gt;&lt;span&gt;表示&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个月放一个分片，如下可知&lt;/span&gt;&lt;span&gt;2016-11-12&lt;/span&gt;&lt;span&gt;在分片&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;上&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;分片&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;分片&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;分片&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;1&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;5&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;9&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;2&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;6&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;10&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;3&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;7&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;11&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;4&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;8&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;236&quot;&gt;
&lt;p&gt;12&lt;span&gt;月&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;







&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_5e1a9ea4-01e5-4e72-a466-f1b0167eb560&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5e1a9ea4-01e5-4e72-a466-f1b0167eb560&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5e1a9ea4-01e5-4e72-a466-f1b0167eb560&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.ParseException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Calendar;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.log4j.Logger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 例子 按月份列分区 ，每个自然月一个分片，格式 between操作解析的范例
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wzh
 * 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByMonth &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;
        RuleAlgorithm {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = Logger.getLogger(PartitionByDate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sBeginDate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String dateFormat;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sEndDate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Calendar beginDate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Calendar endDate;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nPartition;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt;&lt;span&gt; formatter;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            beginDate &lt;/span&gt;=&lt;span&gt; Calendar.getInstance();
            beginDate.setTime(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(dateFormat)
                    .parse(sBeginDate));
            formatter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SimpleDateFormat initialValue() {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(dateFormat);
                }
            };
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(sEndDate!=&lt;span&gt;null&lt;/span&gt;&amp;amp;&amp;amp;!sEndDate.equals(&quot;&quot;&lt;span&gt;)) {
                endDate &lt;/span&gt;=&lt;span&gt; Calendar.getInstance();
                endDate.setTime(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(dateFormat).parse(sEndDate));
                nPartition &lt;/span&gt;= ((endDate.get(Calendar.YEAR) - beginDate.get(Calendar.YEAR)) * 12
                                + endDate.get(Calendar.MONTH) - beginDate.get(Calendar.MONTH)) + 1&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nPartition &amp;lt;= 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; java.lang.IllegalArgumentException(&quot;Incorrect time range for month partitioning!&quot;&lt;span&gt;);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                nPartition &lt;/span&gt;= -1&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; java.lang.IllegalArgumentException(e);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * For circulatory partition, calculated value of target partition needs to be
     * rotated to fit the partition range
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; reCalculatePartition(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; targetPartition) {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * If target date is previous of start time of partition setting, shift
         * the delta range between target and start date to be positive value
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (targetPartition &amp;lt; 0&lt;span&gt;) {
            targetPartition &lt;/span&gt;= nPartition - (-targetPartition) %&lt;span&gt; nPartition;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetPartition &amp;gt;=&lt;span&gt; nPartition) {
            targetPartition &lt;/span&gt;=  targetPartition %&lt;span&gt; nPartition;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetPartition;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; targetPartition;
            Calendar curTime &lt;/span&gt;=&lt;span&gt; Calendar.getInstance();
            curTime.setTime(formatter.get().parse(columnValue));
            targetPartition &lt;/span&gt;= ((curTime.get(Calendar.YEAR) -&lt;span&gt; beginDate.get(Calendar.YEAR))
                    &lt;/span&gt;* 12 +&lt;span&gt; curTime.get(Calendar.MONTH)
                    &lt;/span&gt;-&lt;span&gt; beginDate.get(Calendar.MONTH));

            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * For circulatory partition, calculated value of target partition needs to be
             * rotated to fit the partition range
              &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (nPartition &amp;gt; 0&lt;span&gt;) {
                targetPartition &lt;/span&gt;=&lt;span&gt; reCalculatePartition(targetPartition);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetPartition;

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please check if the format satisfied.&quot;&lt;span&gt;).toString(),e);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer[] calculateRange(String beginValue, String endValue) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; startPartition, endPartition;
            Calendar partitionTime &lt;/span&gt;=&lt;span&gt; Calendar.getInstance();
            SimpleDateFormat format &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(dateFormat);
            partitionTime.setTime(format.parse(beginValue));
            startPartition &lt;/span&gt;= ((partitionTime.get(Calendar.YEAR) -&lt;span&gt; beginDate.get(Calendar.YEAR))
                    &lt;/span&gt;* 12 +&lt;span&gt; partitionTime.get(Calendar.MONTH)
                    &lt;/span&gt;-&lt;span&gt; beginDate.get(Calendar.MONTH));
            partitionTime.setTime(format.parse(endValue));
            endPartition &lt;/span&gt;= ((partitionTime.get(Calendar.YEAR) -&lt;span&gt; beginDate.get(Calendar.YEAR))
                    &lt;/span&gt;* 12 +&lt;span&gt; partitionTime.get(Calendar.MONTH)
                    &lt;/span&gt;-&lt;span&gt; beginDate.get(Calendar.MONTH));

            List&lt;/span&gt;&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (startPartition &amp;lt;=&lt;span&gt; endPartition) {
                Integer nodeValue &lt;/span&gt;=&lt;span&gt; reCalculatePartition(startPartition);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Collections.frequency(list, nodeValue) &amp;lt; 1&lt;span&gt;)
                    list.add(nodeValue);
                startPartition&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; list.size();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (list.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer[size]));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
            LOGGER.error(&lt;/span&gt;&quot;error&quot;&lt;span&gt;,e);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Integer[0&lt;span&gt;];
        }
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPartitionNum() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nPartition = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nPartition;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nPartition;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setsBeginDate(String sBeginDate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sBeginDate =&lt;span&gt; sBeginDate;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDateFormat(String dateFormat) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dateFormat =&lt;span&gt; dateFormat;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setsEndDate(String sEndDate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sEndDate =&lt;span&gt; sEndDate;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;6. 匹配求模分片&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据&lt;/span&gt;prefixLength&lt;span&gt;截取&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;个字符&lt;/span&gt;&lt;span&gt;并&lt;/span&gt;charAt(i)&lt;span&gt;每个字符的值进行累加得到一个整数&lt;/span&gt;&lt;span&gt;，然后和分区长度&lt;/span&gt;&lt;span&gt;patternValue&lt;/span&gt;&lt;span&gt;进行求模，得出的值就是分区编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionbyprefixpattern&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;partitionbyprefixpattern&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;partitionbyprefixpattern&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByPrefixPattern&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;patternValue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 分区长度/分区数量 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefixLength&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 截取多少字符串 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有下面这种类型的数据&lt;/p&gt;
&lt;p&gt;&lt;span&gt;年月&lt;/span&gt;+&lt;span&gt;大区&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;流水编号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;201801 01   10001&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就可以采用匹配求模分片，把分片字段&lt;/span&gt;columns&lt;span&gt;取前&lt;/span&gt;6&lt;span&gt;个字符串&lt;/span&gt;&lt;span&gt;201801&lt;/span&gt;&lt;span&gt;并&lt;/span&gt;&lt;span&gt;charAt(i)&lt;/span&gt;&lt;span&gt;每个字符的值进行累加得到一个整数，然后和分区长度&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;进行求模，得出的值就是分区编号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_35a5b255-76a1-42d7-b6dc-fbaff81d6277&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35a5b255-76a1-42d7-b6dc-fbaff81d6277&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35a5b255-76a1-42d7-b6dc-fbaff81d6277&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.route.function.AutoPartitionByLong.LongRange;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * partition by Prefix length ,can be used in String partition
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hexiaobin
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByPrefixPattern &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PARTITION_LENGTH = 1024&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; patternValue = PARTITION_LENGTH;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分区长度，取模数值(默认为1024)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; prefixLength;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符前几位进行ASCII码取和&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String mapFile;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LongRange[] longRongs;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {

        initialize();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMapFile(String mapFile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapFile =&lt;span&gt; mapFile;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPatternValue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; patternValue) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.patternValue =&lt;span&gt; patternValue;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPrefixLength(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prefixLength) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prefixLength =&lt;span&gt; prefixLength;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Length =&lt;span&gt; Integer.valueOf(prefixLength);

            Length &lt;/span&gt;= columnValue.length() &amp;lt; Length ?&lt;span&gt; columnValue.length() : Length;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; Length; i++&lt;span&gt;) {
                sum &lt;/span&gt;= sum +&lt;span&gt; columnValue.charAt(i);
            }
            Integer rst &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (LongRange longRang : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.longRongs) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; hash = sum %&lt;span&gt; patternValue;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hash &amp;lt;= longRang.valueEnd &amp;amp;&amp;amp; hash &amp;gt;=&lt;span&gt; longRang.valueStart) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; longRang.nodeIndx;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rst;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NumberFormatException e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please eliminate any quote and non number within it.&quot;&lt;span&gt;).toString(),e);
        }
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPartitionNum() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        int nPartition = this.longRongs.length;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * fix #1284 这里的统计应该统计Range的nodeIndex的distinct总数
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Set&lt;/span&gt;&amp;lt;Integer&amp;gt; distNodeIdxSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;Integer&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(LongRange range : longRongs) {
            distNodeIdxSet.add(range.nodeIndx);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nPartition =&lt;span&gt; distNodeIdxSet.size();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nPartition;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize() {
        BufferedReader in &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; FileInputStream fin = new FileInputStream(new File(fileMapPath));&lt;/span&gt;
            InputStream fin = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().getClassLoader()
                    .getResourceAsStream(mapFile);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fin == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;can't find class resource file &quot;
                        +&lt;span&gt; mapFile);
            }
            in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(fin));
            LinkedList&lt;/span&gt;&amp;lt;LongRange&amp;gt; longRangeList = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;LongRange&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String line = &lt;span&gt;null&lt;/span&gt;; (line = in.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
                line &lt;/span&gt;=&lt;span&gt; line.trim();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (line.startsWith(&quot;#&quot;) || line.startsWith(&quot;//&quot;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ind = line.indexOf('='&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ind &amp;lt; 0&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot; warn: bad line int &quot; + mapFile + &quot; :&quot;
                            +&lt;span&gt; line);
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                    String pairs[] &lt;/span&gt;= line.substring(0, ind).trim().split(&quot;-&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; longStart = NumberParseUtil.parseLong(pairs[0&lt;span&gt;].trim());
                    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; longEnd = NumberParseUtil.parseLong(pairs[1&lt;span&gt;].trim());
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nodeId = Integer.parseInt(line.substring(ind + 1&lt;span&gt;)
                            .trim());
                    longRangeList
                            .add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LongRange(nodeId, longStart, longEnd));

            }
            longRongs &lt;/span&gt;= longRangeList.toArray(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LongRange[longRangeList
                    .size()]);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) e;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
            }

        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                in.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e2) {
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LongRange {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nodeIndx;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueStart;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueEnd;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LongRange(&lt;span&gt;int&lt;/span&gt; nodeIndx, &lt;span&gt;long&lt;/span&gt; valueStart, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; valueEnd) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nodeIndx =&lt;span&gt; nodeIndx;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.valueStart =&lt;span&gt; valueStart;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.valueEnd =&lt;span&gt; valueEnd;
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;7. 冷热数据分片&lt;/h2&gt;
&lt;p&gt;根据日期查询日志数据冷热数据分布 ，最近 n 个月的到实时交易库查询，超过 n 个月的按照 m 天分片&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-date&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;create_time&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sharding-by-hotdate&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-hotdate&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.opencloudb.route.function.PartitionByHotDate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dateFormat&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yyyy-MM-dd&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义日期格式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sLastDay&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 热库存储多少天数据 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sPartionDay&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 超过热库期限的数据按照多少天来分片 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_2ca28c96-8690-476a-9b99-649de4a4d186&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2ca28c96-8690-476a-9b99-649de4a4d186&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2ca28c96-8690-476a-9b99-649de4a4d186&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.ParseException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Calendar;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 根据日期查询日志数据 冷热数据分布 ，最近n个月的到实时交易库查询，超过n个月的按照m天分片
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; sw
 * 
 * &amp;lt;tableRule name=&quot;sharding-by-date&quot;&amp;gt;
      &amp;lt;rule&amp;gt;
        &amp;lt;columns&amp;gt;create_time&amp;lt;/columns&amp;gt;
        &amp;lt;algorithm&amp;gt;sharding-by-hotdate&amp;lt;/algorithm&amp;gt;
      &amp;lt;/rule&amp;gt;
   &amp;lt;/tableRule&amp;gt;  
&amp;lt;function name=&quot;sharding-by-hotdate&quot; class=&quot;org.opencloudb.route.function.PartitionByHotDate&quot;&amp;gt;
    &amp;lt;property name=&quot;dateFormat&quot;&amp;gt;yyyy-MM-dd&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;sLastDay&quot;&amp;gt;10&amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;sPartionDay&quot;&amp;gt;30&amp;lt;/property&amp;gt;
  &amp;lt;/function&amp;gt;
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByHotDate &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(PartitionByHotDate.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String dateFormat;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sLastDay;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sPartionDay;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; sLastTime;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; partionTime;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt;&lt;span&gt; formatter;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; beginDate;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; oneDay = 86400000&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            formatter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SimpleDateFormat initialValue() {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(dateFormat);
                }
            };
            sLastTime &lt;/span&gt;=&lt;span&gt; Integer.valueOf(sLastDay);
            partionTime &lt;/span&gt;= Integer.parseInt(sPartionDay) *&lt;span&gt; oneDay;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; java.lang.IllegalArgumentException(e);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue)  {
        Integer targetPartition &lt;/span&gt;= -1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; targetTime =&lt;span&gt; formatter.get().parse(columnValue).getTime();
            Calendar now &lt;/span&gt;=&lt;span&gt; Calendar.getInstance();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nowTime =&lt;span&gt; now.getTimeInMillis();
            
            beginDate &lt;/span&gt;= nowTime - sLastTime *&lt;span&gt; oneDay;
            
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; diffDays = (nowTime - targetTime) / (1000 * 60 * 60 * 24) + 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(diffDays-sLastTime &amp;lt;= 0 || diffDays&amp;lt;0&lt;span&gt; ){
                targetPartition &lt;/span&gt;= 0&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                targetPartition &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;) ((beginDate - targetTime) / partionTime) + 1&lt;span&gt;;
            }
            
            LOGGER.debug(&lt;/span&gt;&quot;PartitionByHotDate calculate for &quot; + columnValue + &quot; return &quot; +&lt;span&gt; targetPartition);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetPartition;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;columnValue:&quot;).append(columnValue).append(&quot; Please check if the format satisfied.&quot;&lt;span&gt;).toString(),e);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer[] calculateRange(String beginValue, String endValue)  {
        Integer[] targetPartition &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; formatter.get().parse(beginValue).getTime();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; endTime =&lt;span&gt; formatter.get().parse(endValue).getTime();
            Calendar now &lt;/span&gt;=&lt;span&gt; Calendar.getInstance();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nowTime =&lt;span&gt; now.getTimeInMillis();
            
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; limitDate = nowTime - sLastTime *&lt;span&gt; oneDay;
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; diffDays = (nowTime - startTime) / (1000 * 60 * 60 * 24) + 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(diffDays-sLastTime &amp;lt;= 0 || diffDays&amp;lt;0&lt;span&gt; ){
                Integer [] re &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Integer[1&lt;span&gt;];
                re[&lt;/span&gt;0] = 0&lt;span&gt;;
                targetPartition &lt;/span&gt;=&lt;span&gt; re ;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                Integer [] re &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                Integer begin &lt;/span&gt;= 0, end = 0&lt;span&gt;;
                end &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.calculate(beginValue);
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasLimit = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(endTime-limitDate &amp;gt; 0&lt;span&gt;){
                    endTime &lt;/span&gt;=&lt;span&gt; limitDate;
                    hasLimit &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                begin &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.calculate(formatter.get().format(endTime));
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(begin == &lt;span&gt;null&lt;/span&gt; || end == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; re;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;gt;=&lt;span&gt; begin) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len = end-begin+1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(hasLimit){
                        re &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Integer[len+1&lt;span&gt;];
                        re[&lt;/span&gt;0] = 0&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i =0;i&amp;lt;len;i++&lt;span&gt;){
                            re[i&lt;/span&gt;+1]=begin+&lt;span&gt;i;
                        }
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        re &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer[len];
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;){
                            re[i]&lt;/span&gt;=begin+&lt;span&gt;i;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; re;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; re;
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span&gt;new&lt;/span&gt; StringBuilder().append(&quot;endValue:&quot;).append(endValue).append(&quot; Please check if the format satisfied.&quot;&lt;span&gt;).toString(),e);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetPartition;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setsPartionDay(String sPartionDay) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sPartionDay =&lt;span&gt; sPartionDay;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDateFormat(String dateFormat) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dateFormat =&lt;span&gt; dateFormat;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getsLastDay() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sLastDay;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setsLastDay(String sLastDay) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sLastDay =&lt;span&gt; sLastDay;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;8. 一致性哈希分片&lt;/h2&gt;
&lt;p&gt;1）首先求出mysql服务器（节点）的哈希值，并将其配置到0～2^32的圆（continuum）上。&lt;/p&gt;
&lt;p&gt;2）为每台mysql服务器物理节点虚拟出多个虚拟节点，并计算hash值映射到相同的圆上。&lt;/p&gt;
&lt;p&gt;3）然后从数据映射到的mysql服务器虚拟节点的位置开始顺时针查找，将数据保存到找到的第一个mysql服务器上。如果超过2&lt;sup&gt;32&lt;/sup&gt;仍然找不到服务器，就会保存到第一台mysql服务器上。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180812182820612-1726495515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特点：解决数据均匀分布&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在rule.xml里面的配置：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tableRule &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sharding-by-murmur&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;id&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;murmur&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;algorithm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tableRule&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;function &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;murmur&quot;&lt;/span&gt;&lt;span&gt;
        class&lt;/span&gt;&lt;span&gt;=&quot;io.mycat.route.function.PartitionByMurmurHash&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;seed&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 默认是0 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;count&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 要分片的数据库节点数量，必须指定，否则没法分片 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;virtualBucketTimes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;160&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;property name=&quot;weightMapFile&quot;&amp;gt;weightMapFile&amp;lt;/property&amp;gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;property name=&quot;bucketMapPath&quot;&amp;gt;/etc/mycat/bucketMapPath&amp;lt;/property&amp;gt; 
            用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对应代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_a7146475-bb80-4b91-a2cd-6481801218c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a7146475-bb80-4b91-a2cd-6481801218c9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a7146475-bb80-4b91-a2cd-6481801218c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.mycat.route.function;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.BufferedReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ByteArrayInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.ByteArrayOutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileNotFoundException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileOutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStreamReader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.OutputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.SortedMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeMap;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.hash.HashFunction;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.hash.Hashing;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.config.model.rule.RuleAlgorithm;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.mycat.util.exception.MurmurHashException;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * consistancy hash, murmur hash
 * implemented by Guava
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; wuzhih
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PartitionByMurmurHash &lt;span&gt;extends&lt;/span&gt; AbstractPartitionAlgorithm &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RuleAlgorithm  {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_VIRTUAL_BUCKET_TIMES=160&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_WEIGHT=1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Charset DEFAULT_CHARSET=Charset.forName(&quot;UTF-8&quot;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; seed;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; virtualBucketTimes=&lt;span&gt;DEFAULT_VIRTUAL_BUCKET_TIMES;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;Integer,Integer&amp;gt; weightMap=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private String bucketMapPath;&lt;/span&gt;
    
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HashFunction hash;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; SortedMap&amp;lt;Integer,Integer&amp;gt;&lt;span&gt; bucketMap;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init()  {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            bucketMap&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            boolean serializableBucketMap=bucketMapPath!=null &amp;amp;&amp;amp; bucketMapPath.length()&amp;gt;0;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if(serializableBucketMap){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                File bucketMapFile=new File(bucketMapPath);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                if(bucketMapFile.exists() &amp;amp;&amp;amp; bucketMapFile.length()&amp;gt;0){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    loadBucketMapFile();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    return;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }&lt;/span&gt;
&lt;span&gt;            generateBucketMap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if(serializableBucketMap){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                storeBucketMap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }&lt;/span&gt;
        }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MurmurHashException(e);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; generateBucketMap(){
        hash&lt;/span&gt;=Hashing.murmur3_32(seed);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算一致性哈希的对象&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;count;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造一致性哈希环，用TreeMap表示&lt;/span&gt;
            StringBuilder hashName=&lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;SHARD-&quot;&lt;span&gt;).append(i);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; n=0,shard=virtualBucketTimes*getWeight(i);n&amp;lt;shard;n++&lt;span&gt;){
                bucketMap.put(hash.hashUnencodedChars(hashName.append(&lt;/span&gt;&quot;-NODE-&quot;&lt;span&gt;).append(n)).asInt(),i);
            }
        }
        weightMap&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private void storeBucketMap() throws IOException{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try(OutputStream store=new FileOutputStream(bucketMapPath)){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Properties props=new Properties();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            for(Map.Entry entry:bucketMap.entrySet()){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                props.setProperty(entry.getKey().toString(), entry.getValue().toString());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            props.store(store,null);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private void loadBucketMapFile() throws FileNotFoundException, IOException{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        try(InputStream in=new FileInputStream(bucketMapPath)){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            Properties props=new Properties();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            props.load(in);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            for(Map.Entry entry:props.entrySet()){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                bucketMap.put(Integer.parseInt(entry.getKey().toString()), Integer.parseInt(entry.getValue().toString()));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 得到桶的权重，桶就是实际存储数据的DB实例
     * 从0开始的桶编号为key，权重为值，权重默认为1。
     * 键值必须都是整数
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bucket
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getWeight(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; bucket){
        Integer w&lt;/span&gt;=&lt;span&gt;weightMap.get(bucket);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(w==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            w&lt;/span&gt;=&lt;span&gt;DEFAULT_WEIGHT;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; w;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建murmur_hash对象的种子，默认0
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; seed
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSeed(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; seed){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.seed=&lt;span&gt;seed;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 节点的数量
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; count
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCount(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; count;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 虚拟节点倍数，virtualBucketTimes*count就是虚拟结点数量
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; virtualBucketTimes
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setVirtualBucketTimes(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; virtualBucketTimes){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.virtualBucketTimes=&lt;span&gt;virtualBucketTimes;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。
     * 所有权重值必须是正整数，否则以1代替
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; weightMapPath
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setWeightMapFile(String weightMapPath) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        Properties props&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(BufferedReader reader=&lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().getClassLoader().getResourceAsStream(weightMapPath), DEFAULT_CHARSET))){
            props.load(reader);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Map.Entry entry:props.entrySet()){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; weight=&lt;span&gt;Integer.parseInt(entry.getValue().toString());
                weightMap.put(Integer.parseInt(entry.getKey().toString()), weight&lt;/span&gt;&amp;gt;0?weight:1&lt;span&gt;);
            }
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    /**
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     * 保存一致性hash的虚拟节点文件路径。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     * 如果这个文件不存在或是空文件就按照指定的count, weightMapFile等构造新的MurmurHash数据结构并保存到这个路径的文件里。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     * 如果这个文件已存在且不是空文件就加载这个文件里的内容作为MurmurHash数据结构，此时其它参数都忽略。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     * 除第一次以外在之后增加节点时可以直接修改这个文件，不过不推荐这么做。如果节点数量变化了，推荐删除这个文件。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     * 可以不指定这个路径，不指定路径时不会保存murmur hash
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     * @param bucketMapPath
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     */
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void setBucketMapPath(String bucketMapPath){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        this.bucketMapPath=bucketMapPath;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer calculate(String columnValue) {
        SortedMap&lt;/span&gt;&amp;lt;Integer, Integer&amp;gt; tail =&lt;span&gt; bucketMap.tailMap(hash.hashUnencodedChars(columnValue).asInt());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tail.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bucketMap.get(bucketMap.firstKey());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tail.get(tail.firstKey());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPartitionNum() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nPartition = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.count;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nPartition;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; hashTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        PartitionByMurmurHash hash&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionByMurmurHash();
        hash.count&lt;/span&gt;=10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分片数&lt;/span&gt;
&lt;span&gt;        hash.init();

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] bucket=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[hash.count];

        Map&lt;/span&gt;&amp;lt;Integer,List&amp;lt;Integer&amp;gt;&amp;gt; hashed=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total=1000_0000;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据量&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=100_0000;i&amp;lt;total+100_0000;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设分片键从100万开始&lt;/span&gt;
            c++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h=&lt;span&gt;hash.calculate(Integer.toString(i));
            bucket[h]&lt;/span&gt;++&lt;span&gt;;
            List&lt;/span&gt;&amp;lt;Integer&amp;gt; list=&lt;span&gt;hashed.get(h);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(list==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                list&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
                hashed.put(h, list);
            }
            list.add(i);
        }
        System.out.println(c&lt;/span&gt;+&quot;   &quot;+&lt;span&gt;total);
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; d=0&lt;span&gt;;
        c&lt;/span&gt;=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; idx=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;index    bucket   ratio&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i:bucket){
            d&lt;/span&gt;+=i/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)total;
            c&lt;/span&gt;+=&lt;span&gt;i;
            System.out.println(idx&lt;/span&gt;+++&quot;  &quot;+i+&quot;   &quot;+(i/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)total));
        }
        System.out.println(d&lt;/span&gt;+&quot;  &quot;+&lt;span&gt;c);

        Properties props&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Map.Entry entry:hash.bucketMap.entrySet()){
            props.setProperty(entry.getKey().toString(), entry.getValue().toString());
        }
        ByteArrayOutputStream out&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
        props.store(out, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        props.clear();
        props.load(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(out.toByteArray()));
        System.out.println(props);
        System.out.println(&lt;/span&gt;&quot;****************************************************&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        rehashTest(hashed.get(0));&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rehashTest(List&amp;lt;Integer&amp;gt;&lt;span&gt; partition){
        PartitionByMurmurHash hash&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PartitionByMurmurHash();
        hash.count&lt;/span&gt;=12;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分片数&lt;/span&gt;
&lt;span&gt;        hash.init();
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] bucket=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[hash.count];
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; total=partition.size();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据量&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i:partition){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设分片键从100万开始&lt;/span&gt;
            c++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h=&lt;span&gt;hash.calculate(Integer.toString(i));
            bucket[h]&lt;/span&gt;++&lt;span&gt;;
        }
        System.out.println(c&lt;/span&gt;+&quot;   &quot;+&lt;span&gt;total);
        c&lt;/span&gt;=0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; idx=0&lt;span&gt;;
        System.out.println(&lt;/span&gt;&quot;index    bucket   ratio&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i:bucket){
            c&lt;/span&gt;+=&lt;span&gt;i;
            System.out.println(idx&lt;/span&gt;+++&quot;  &quot;+i+&quot;   &quot;+(i/(&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)total));
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        hashTest();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 13 Aug 2018 07:15:00 +0000</pubDate>
<dc:creator>小不点啊</dc:creator>
<og:description>一、Mycat常用分片规则 1. 时间类：按天分片、自然月分片、单月小时分片 2. 哈希类：Hash固定分片、日期范围Hash分片、截取数字Hash求模范围分片、截取数字Hash分片、一致性Hash分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leeSmall/p/9462658.html</dc:identifier>
</item>
<item>
<title>Windows Community Toolkit 3.0 - UniformGrid - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/9281068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/9281068.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;UniformGrid 控件是一个响应式的布局控件，允许把 items 排列在一组均匀分布的行或列中，以填充整体的可用显示空间，形成均匀的多个网格。默认情况下，网格中的每个单元格大小相同。&lt;/p&gt;
&lt;p&gt;这是一个非常实用的控件，比如相册应用中多行多列均匀排列图片，比如新闻类应用中排列新闻，再比如我们在来画视频中展示用户作品封面和简要信息等，因为它支持响应布局，所以在应用尺寸变化时显示会很友好。&lt;/p&gt;
&lt;p&gt;下面是 Windows Community Toolkit Sample App 的示例截图和 code/doc 地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180812155725239-1164440700.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/communitytoolkit/controls/infinitecanvashttps://docs.microsoft.com/zh-cn/windows/communitytoolkit/controls/uniformgrid&quot; target=&quot;_blank&quot;&gt;Windows Community Toolkit Doc - UniformGrid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Microsoft/WindowsCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/UniformGrid&quot; target=&quot;_blank&quot;&gt;Windows Community Toolkit Source Code - UniformGrid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Namespace: &lt;strong&gt;&lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls;&lt;/em&gt;&lt;/strong&gt; Nuget: &lt;em&gt;&lt;strong&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/strong&gt;&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码结构分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先来看 UniformGrid 控件的代码结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TakenSpotsReferenceHolder.cs - 获取和设置点数组，标识布局中的 item 是否固定；&lt;/li&gt;
&lt;li&gt;UniformGrid.Helpers.cs - UniformGrid 控件帮助类，主要处理控件的行列布局和排列逻辑；&lt;/li&gt;
&lt;li&gt;UniformGrid.Properties.cs - UniformGrid 控件的依赖属性类；&lt;/li&gt;
&lt;li&gt;UniformGrid.cs - UniformGrid 控件的主要处理逻辑类；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201808/306530-20180812160829932-539729517.png&quot; alt=&quot;&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UniformGrid 控件的代码实现比较简单，我们来看几个类中重要的方法：&lt;/p&gt;
&lt;p&gt;1. UniformGrid.Helpers.cs&lt;/p&gt;
&lt;p&gt;1). GetFreeSpot()&lt;/p&gt;
&lt;p&gt;获取目前 UniformGrid 控件中可用的点，分为上下和左右两个方向，分别处理行和列的数据；以行为例，遍历每列的所有行，返回是否可用于放置元素的标识；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;(&lt;span&gt;int&lt;/span&gt; row, &lt;span&gt;int&lt;/span&gt; column)&amp;gt; GetFreeSpot(TakenSpotsReferenceHolder arrayref, &lt;span&gt;int&lt;/span&gt; firstcolumn, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; topdown)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (topdown)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rows = arrayref.SpotsTaken.GetLength(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Layout spots from Top-Bottom, Left-Right (right-left handled automatically by Grid with Flow-Direction).
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Effectively transpose the Grid Layout.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; arrayref.SpotsTaken.GetLength(&lt;span&gt;1&lt;/span&gt;); c++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = (c == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; firstcolumn &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; firstcolumn &amp;lt; rows) ? firstcolumn : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; r = start; r &amp;lt; rows; r++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;arrayref.SpotsTaken[r, c])
                {
                    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (r, c);
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
       // 省略列处理代码 &lt;br/&gt;　　　　...&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2). GetDimensions()&lt;/p&gt;
&lt;p&gt;获取 UniformGrid 控件在行和列的数值；先计算目前所有 item 所需的格数，分为 row = 0，column = 0 和两个值都为 0 处理，分别计算 row column 的值；如果两个值有一个为 0，则根据不为 0 的值和 item 数量来判断另一个值；如果两个值都为 0，则定义为方形；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; rows, &lt;span&gt;int&lt;/span&gt; columns) GetDimensions(FrameworkElement[] visible, &lt;span&gt;int&lt;/span&gt; rows, &lt;span&gt;int&lt;/span&gt; cols, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; firstColumn)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If a dimension isn't specified, we need to figure out the other one (or both).&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (rows == &lt;span&gt;0&lt;/span&gt; || cols == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Calculate the size &amp;amp; area of all objects in the grid to know how much space we need.&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; count = Math.Max(&lt;span&gt;1&lt;/span&gt;, visible.Sum(item =&amp;gt; GetRowSpan(item) *&lt;span&gt; GetColumnSpan(item)));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cols &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Bound check&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; first = (firstColumn &amp;gt;= cols || firstColumn &amp;lt; &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt;&lt;span&gt; : firstColumn;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we have columns but no rows, calculate rows based on column offset and number of children.&lt;/span&gt;
                rows = (count + first + (cols - &lt;span&gt;1&lt;/span&gt;)) /&lt;span&gt; cols;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (rows, cols);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Otherwise, determine square layout if both are zero.&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; size = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)Math.Ceiling(Math.Sqrt(count));

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Figure out if firstColumn is in bounds&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; first = (firstColumn &amp;gt;= size || firstColumn &amp;lt; &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt;&lt;span&gt; : firstColumn;

                rows &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)Math.Ceiling(Math.Sqrt(count +&lt;span&gt; first));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (rows, rows);
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cols == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
　　　　　　　...&lt;/span&gt;&lt;span&gt;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (rows, cols);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3). SetupRowDefinitions()&lt;/p&gt;
&lt;p&gt;SetupRowDefinitions() 和 SetupColumnDefinitions() 实现类似，我们看其中一个；先初始化行定义，遍历行列表，如果有行的布局方式不为自动布局，先把这些布局删掉，再重新以自动布局的方式加入到行定义中；这样实现的目标，是保证行布局能对 item 自适应，缩放时可以自动响应；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetupRowDefinitions(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rows)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark initial definitions so we don't erase them.&lt;/span&gt;
    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; rd &lt;span&gt;in&lt;/span&gt;&lt;span&gt; RowDefinitions)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GetAutoLayout(rd) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            SetAutoLayout(rd, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove non-autolayout rows we've added and then add them in the right spots.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (rows !=&lt;span&gt; RowDefinitions.Count)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; r = RowDefinitions.Count - &lt;span&gt;1&lt;/span&gt;; r &amp;gt;= &lt;span&gt;0&lt;/span&gt;; r--&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GetAutoLayout(RowDefinitions[r]) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                RowDefinitions.RemoveAt(r);
            }
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; r = &lt;span&gt;this&lt;/span&gt;.RowDefinitions.Count; r &amp;lt; rows; r++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rd = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RowDefinition();
            SetAutoLayout(rd, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.RowDefinitions.Insert(r, rd);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. UniformGrid.Properties.cs&lt;/p&gt;
&lt;p&gt;该类定义了 UniformGrid 控件所需的依赖属性，主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AutoLayout - 获取和设置自动布局属性，包括对行和列的操作；&lt;/li&gt;
&lt;li&gt;Columns - UniformGrid 的列属性；&lt;/li&gt;
&lt;li&gt;FirstColumn - UniformGrid 的首列属性，获取的是首行元素距离第一列的偏移量；&lt;/li&gt;
&lt;li&gt;Orientation - UniformGrid 的排列方式，包括横向和纵向两种；&lt;/li&gt;
&lt;li&gt;Rows - UniformGrid 的行属性；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. UniformGrid.cs &lt;/p&gt;
&lt;p&gt;该类主要是 UnifromGrid 在 Grid 类基础上的处理，主要处理测量和排列的方法，我们来看一下功能比较复杂的 MeasureOverride() 方法，ArrangeOverride() 方法实现很简单，这里不做分析。&lt;/p&gt;
&lt;p&gt;1). MeasureOverride()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先根据可见元素集合，获取控件的行列数量，设置行列定义；&lt;/li&gt;
&lt;li&gt;遍历所有可见元素，根据每个元素的行列和行列跨度属性，设置自动布局，填充 spotsTaken；&lt;/li&gt;
&lt;li&gt;计算行和列的空白空间总数值，再根据总空间数值和行列数，计算出一个元素的尺寸；&lt;/li&gt;
&lt;li&gt;遍历所有可见元素，找出元素中最大的宽度和高度；再用这个最大尺寸，乘上行列数，加上空白空间数值，得到控件所需尺寸；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Size MeasureOverride(Size availableSize)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get all Visible FrameworkElement Children&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; visible = Children.Where(item =&amp;gt; item.Visibility != Visibility.Collapsed &amp;amp;&amp;amp; item &lt;span&gt;is&lt;/span&gt; FrameworkElement).Select(item =&amp;gt; item &lt;span&gt;as&lt;/span&gt;&lt;span&gt; FrameworkElement).ToArray();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; (rows, columns) =&lt;span&gt; GetDimensions(visible, Rows, Columns, FirstColumn);

    SetupRowDefinitions(rows);
    SetupColumnDefinitions(columns);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; spotref = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TakenSpotsReferenceHolder(rows, columns);
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; child &lt;span&gt;in&lt;/span&gt;&lt;span&gt; visible)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; row =&lt;span&gt; GetRow(child);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; col =&lt;span&gt; GetColumn(child);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rowspan =&lt;span&gt; GetRowSpan(child);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colspan =&lt;span&gt; GetColumnSpan(child);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((row == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; col == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; GetAutoLayout(child) == &lt;span&gt;null&lt;/span&gt;) || GetAutoLayout(child) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            SetAutoLayout(child, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            SetAutoLayout(child, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            spotref.SpotsTaken.Fill(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, row, col, colspan, rowspan); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; row, col, width, height&lt;/span&gt;
&lt;span&gt;        }
    }

    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; columnSpacingSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; rowSpacingSize = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_hasGridSpacing)
    {
        columnSpacingSize &lt;/span&gt;= ColumnSpacing * (columns - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        rowSpacingSize &lt;/span&gt;= RowSpacing * (rows - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }

    Size childSize &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(
        (availableSize.Width &lt;/span&gt;- columnSpacingSize) /&lt;span&gt; columns,
        (availableSize.Height &lt;/span&gt;- rowSpacingSize) /&lt;span&gt; rows);

    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; maxWidth = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; maxHeight = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; freespots = GetFreeSpot(spotref, FirstColumn, Orientation ==&lt;span&gt; Orientation.Vertical).GetEnumerator();
    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; child &lt;span&gt;in&lt;/span&gt;&lt;span&gt; visible)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GetAutoLayout(child) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (freespots.MoveNext())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; (row, column) =&lt;span&gt; freespots.Current;

                SetRow(child, row);
                SetColumn(child, column);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rowspan =&lt;span&gt; GetRowSpan(child);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colspan =&lt;span&gt; GetColumnSpan(child);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rowspan &amp;gt; &lt;span&gt;1&lt;/span&gt; || colspan &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    spotref.SpotsTaken.Fill(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, row, column, GetColumnSpan(child), GetRowSpan(child)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; row, col, width, height&lt;/span&gt;
&lt;span&gt;                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                child.Measure(Size.Empty);
                _overflow.Add(child);
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GetRow(child) &amp;lt; &lt;span&gt;0&lt;/span&gt; || GetRow(child) &amp;gt;= rows ||&lt;span&gt;
                    GetColumn(child) &lt;/span&gt;&amp;lt; &lt;span&gt;0&lt;/span&gt; || GetColumn(child) &amp;gt;=&lt;span&gt; columns)
        {
            child.Measure(Size.Empty);

            _overflow.Add(child);

            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        child.Measure(childSize);

        maxWidth &lt;/span&gt;=&lt;span&gt; Math.Max(child.DesiredSize.Width, maxWidth);
        maxHeight &lt;/span&gt;=&lt;span&gt; Math.Max(child.DesiredSize.Height, maxHeight);
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; desiredSize = &lt;span&gt;new&lt;/span&gt; Size((maxWidth * (&lt;span&gt;double&lt;/span&gt;)columns) + columnSpacingSize, (maxHeight * (&lt;span&gt;double&lt;/span&gt;)rows) +&lt;span&gt; rowSpacingSize);
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.MeasureOverride(desiredSize);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desiredSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;调用示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UniformGrid 控件的调用非常简单，下面看看 XAML 中的调用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Page
    &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:controls&lt;/span&gt;&lt;span&gt;=&quot;using:Microsoft.Toolkit.Uwp.UI.Controls&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:d&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:mc&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;&lt;/span&gt;&lt;span&gt;
    mc:Ignorable&lt;/span&gt;&lt;span&gt;=&quot;d&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:UniformGrid 
        &lt;/span&gt;&lt;span&gt;FirstColumn&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
        Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;
        Rows&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
        Columns&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;AliceBlue&quot;&lt;/span&gt;&lt;span&gt; 
            Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; 
            Grid.RowSpan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; 
            Grid.ColumnSpan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Cornsilk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;DarkSalmon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Gainsboro&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;LightBlue&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;MediumAquamarine&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;MistyRose&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;7&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;LightCyan&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Salmon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;9&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Goldenrod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Pink&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;11&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:UniformGrid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里我们就把 Windows Community Toolkit 3.0 中的 UniformGrid 的源代码实现过程讲解完成了，希望能对大家更好的理解和使用这个功能有所帮助。&lt;/p&gt;
&lt;p&gt;最后，再跟大家安利一下 WindowsCommunityToolkit 的官方微博：&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://weibo.com/u/6506046490&quot; target=&quot;_blank&quot;&gt;https://weibo.com/u/6506046490&lt;/a&gt;, &lt;/strong&gt;&lt;/em&gt;大家可以通过微博关注最新动态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衷心感谢 WindowsCommunityToolkit 的作者们杰出的工作，感谢每一位贡献者，Thank you so much, ALL WindowsCommunityToolkit AUTHORS !!!&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 07:06:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<og:description>概述 UniformGrid 控件是一个响应式的布局控件，允许把 items 排列在一组均匀分布的行或列中，以填充整体的可用显示空间，形成均匀的多个网格。默认情况下，网格中的每个单元格大小相同。 这是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/9281068.html</dc:identifier>
</item>
<item>
<title>Volatile - KristinLee</title>
<link>http://www.cnblogs.com/Hangtutu/p/9465770.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hangtutu/p/9465770.html</guid>
<description>&lt;h2&gt;什么是volatile&lt;/h2&gt;
&lt;p&gt;1.Java语言规范第3版中对volatile的定义如下:&lt;/p&gt;
&lt;p&gt;　　Java编程语言允许线程访问共享变量,为了确保共享变量能够被准确和一致的更新,线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值一致。&lt;/p&gt;
&lt;p&gt;2.通俗理解:&lt;/p&gt;
&lt;p&gt;　　volatile就是Java的一个关键字，单词volatile本身具有不稳定的意思。volatile关键字表示被修饰的变量的值容易变化，不稳定。volatile变量的不稳定性意味着对这种变量的读和写操作都必须从高速缓存或者主内存中读取，以读取变量相对新的值。&lt;/p&gt;
&lt;h2&gt;volatile的作用&lt;/h2&gt;
&lt;h3&gt;1.保障读操作、写操作本身的原子性&lt;/h3&gt;
&lt;p&gt;1. 原理：volatile关键字在原子性方面仅保障对被修饰的变量的读操作、写操作本身的原子性，如果要保障对volatile变量的赋值操作的原子性，那么这个赋值操作不能涉及任何共享变量（包括被赋值的volatile变量本身）的访问。&lt;/p&gt;
&lt;p&gt;例子1：num1=num2+1；&lt;/p&gt;
&lt;p&gt;如果变量num2也是一个共享变量，那么赋值操作实际上是一个read-modify-write操作。其执行过程中其他线程可能已经更新了num2的值，因此该操作不具备不可分割性，也就不是原子操作。如果变量num2是一个局部变量，那么赋值操作就是一个原子操作。&lt;/p&gt;
&lt;p&gt;例子2：volatile Map map =new HashMap();&lt;/p&gt;
&lt;p&gt;该操作可以分解为如下伪代码所示的几个子操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
objRef = alllocate(HashMap.class);    // 子操作(1) : 分配对象所需的存储空间
invokeConstructor(objRef);    // 子操作(2) : 初始化objRef引用的对象
aMap = objRef;    // 子操作(3) : 将对象引用写入变量aMap　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然volatile关键字仅保障其中的子操作(3)是一个原子操作,但是由于子操作(1)和子操作(2)仅涉及局部变量而未涉及共享变量,因此对变量aMap的赋值操作仍然是一个原子操作.&lt;/p&gt;
&lt;p&gt;2.在Java语言中对long型和double型以外的任何类型的变量的写操作都是原子操作。考虑到32位Java虚拟机上对long/double型变量进行的写操作可能不具有原子性。Java语言规范特别的规定对long/double型volatile变量的写操作和读操作也具有原子性。&lt;/p&gt;
&lt;p&gt;那么，为什么32位Java虚拟机上对long/double型变量进行的写操作可能不具有原子性呢？&lt;/p&gt;
&lt;p&gt;Java中long/double型变量会占用64位的存储空间，而32位的Java虚拟机对这种变量的写操作可能会被分解为两个步骤来实施，比如先写低32位，再写高32位。那么在多个线程试图共享同一个这样的变量时就可能出现一个线程在写高32位的时候，另一个线程正在写低32位。所以最终结果可能就是一个线程对64位的long/double的低32位与另一个线程对该变量的高32位进行更新所混合出来的一个结果。&lt;/p&gt;
&lt;h3&gt;2.保障有序性&lt;/h3&gt;
&lt;p&gt;1.原理：Java内存屏障保障了读线程对写线程在更新volatile变量前对共享变量所执行的更新操作的感知顺序与相应的源代码顺序一致，即保障了有序性。&lt;/p&gt;
&lt;p&gt;2.JMM如何实现volatile写、读的内存语义：JMM通过限制重排序来保障有序性，重排序分为编译器重排序和处理器重排序。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.1 JMM限制编译器对volatile重排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201808/1173593-20180813091756865-184520141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                          表2-2  JMM针对编译器制定的volatile重排序规则表&lt;/p&gt;
&lt;p&gt;举例:对于第一个操作是普通读/写，第二个操作是volatile写，则编译器不能重排序这两个操作。&lt;/p&gt;
&lt;p&gt;总结以上表格：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当第二个操作是volatile写是，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。&lt;/li&gt;
&lt;li&gt;当第一个操作是volatile读时，不管第二个操作时什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。&lt;/li&gt;
&lt;li&gt;当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.2 JMM限制处理器对volatile重排序&lt;/p&gt;
&lt;p&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;/p&gt;
&lt;p&gt;下面是基于保守策略的JMM内存屏障插入策略：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201808/1173593-20180813101830423-88150897.png&quot; alt=&quot;&quot;/&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173593/201808/1173593-20180813101838606-788388057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       2.2-1 volatile写插入内存屏障后生成的指令序列示意图           2.2-2 volatile读插入内存屏障后生成的指令序列示意图 &lt;/p&gt;
&lt;p&gt;下面是4种屏障作用：&lt;/p&gt;
&lt;p&gt;StoreStore屏障：保障上面所有的普通写在volatile写之前刷新到主内存。&lt;/p&gt;
&lt;p&gt;StoreLoad屏障：避免volatile写与后面可能有的volatile读/写操作重排序。&lt;/p&gt;
&lt;p&gt;LoadLoad屏障：禁止处理器把上面的volatile写与下面的普通读重排序。&lt;/p&gt;
&lt;p&gt;LoadStore屏障：禁止处理器把上面的volatile读与下面的普通写重排序。&lt;/p&gt;
&lt;h3&gt;3.保障可见性&lt;/h3&gt;
&lt;p&gt; 有volatile修饰的共享变量进行写操作时汇编代码会多出Lock指令。&lt;/p&gt;
&lt;p&gt;Lock前缀的指令在多核处理器具有以下作用：&lt;/p&gt;
&lt;p&gt;1.将当前处理器缓存行的数据写回到系统内存中。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号，在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。&lt;/p&gt;
&lt;p&gt;2.这个写回的操作会使其他在CPU里缓存了该内存地址的数据无效。处理器能够使用嗅探技术保证它的内部缓存、系统内存与其他处理器的缓存的数据在总线上保持一致性。&lt;/p&gt;
&lt;p&gt;注意：volatile关键字在可见性方面仅仅是保证读线程能够读取到共享变量的相对新值，对于引用型变量，volatile关键字并不能保证线程能够读取到相应对象的字段（实例变量、静态变量）、元素的相对新值。&lt;/p&gt;
&lt;h2&gt;volatile的变量的开销&lt;/h2&gt;
&lt;p&gt;volatile的读、写操作都不会导致上下文切换，因此volatile的开销比锁要小。&lt;/p&gt;
&lt;p&gt;写一个volatile变量会使该操作以及该操作之前的任何写操作的结果对其他处理器是可同步的，因此volatile变量写操作的成本介于普通变量的写操作和在临界区内进行的写操作之间。&lt;/p&gt;
&lt;p&gt;volatile变量读操作的成本也介于普通变量的写操作和在临界区内进行的写操作之间。因为volatile变量的值每次都需要从高速缓存或者主内存中读取，而无法被暂存在寄存器中，从而无法发挥访问的高效性。&lt;/p&gt;
&lt;h2&gt;volatile的典型应用场景&lt;/h2&gt;
&lt;p&gt; 1.使用volatile变量作为状态标志。应用程序的某个状态由一个线程设置，其他线程会读取该状态并以该状态作为其计算的依据。此时使用volatile的好处是一个线程能够‘通知’另外一个线程某种事件的发生，而这些线程又无须因此而使用锁，从而避免了使用锁的开销。&lt;/p&gt;
&lt;p&gt;2.使用volatile保障可见性。在该场景中，多个线程共享一个可变状态变量，其中一个线程更新了该变量之后，其他线程无须加锁的情况下也能够看到该更新。&lt;/p&gt;
&lt;p&gt;3.使用volatile变量替代锁。volatile变量并非锁的替代品，但是在一定的条件下他比锁更合适。多个线程共享一组可变状态变量的时候，我们可以把一组可变状态变量封装成一个对象，那么对这些状态变量的更新操作就可以通过创建一个新的对象并将该对象引用赋值给相应的引用型变量来实现。&lt;/p&gt;
&lt;p&gt;4.使用volatile实现建议版读写锁。这种简易版读写锁仅涉及一个共享变量并且仅允许一个线程读取这个共享变量时其他线程可以更新该变量。因此，这种读写锁允许读线程可以读取&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;《Java并发编程的艺术》&lt;/p&gt;
&lt;p&gt;《Java多线程编程实战指南》&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 07:06:00 +0000</pubDate>
<dc:creator>KristinLee</dc:creator>
<og:description>什么是volatile 1.Java语言规范第3版中对volatile的定义如下: Java编程语言允许线程访问共享变量,为了确保共享变量能够被准确和一致的更新,线程应该确保通过排他锁单独获得这个变量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Hangtutu/p/9465770.html</dc:identifier>
</item>
<item>
<title>JAVA之消息中间件RabbitMq初探 - 队长给我球。</title>
<link>http://www.cnblogs.com/JJJ1990/p/9468167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JJJ1990/p/9468167.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;消息中间件目前已经在很多大型的项目上得到了运用，我们常见的有 RabbitMq， activitymq，kafka，rocketmq，其中rocketmq是阿里自己在kafka的基础上用java写的一个消息中间件。在我们使用的支付宝等应用中都有大量的使用。&lt;/p&gt;
&lt;p&gt;附几种常见的mq对比图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1063420/201808/1063420-20180813105350253-644001306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;环境搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们都知道大部分情况下都是在linux系统下部署服务。但是本篇的环境是在Windows下。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.安装Erlang &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;rabbitMQ是一个在AMQP协议标准基础上完整的，可服用的企业消息系统。它遵循Mozilla Public License开源协议，采用 Erlang 实现的工业级的消息队列(MQ)服务器，Rabbit MQ 是建立在Erlang OTP平台上。所以在安装rabbitMQ之前，需要先安装Erlang 。&lt;/p&gt;
&lt;p&gt;http://www.erlang.org/download/otp_win32_R16B03.exe，需要其他版本或者64位系统的，可以去&lt;a href=&quot;http://www.erlang.org/downloads&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;全部点击“下一步”就行。&lt;/p&gt;
&lt;p&gt;有的选择其他的安装方式，可能需要添加一下系统环境变量&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.安装RabbitMQ&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;下载运行 ：http://www.rabbitmq.com/releases/rabbitmq-server/v3.2.3/rabbitmq-server-3.2.3.exe   ，需要其他版本或者64位系统的，可以去&lt;a href=&quot;http://www.rabbitmq.com/download.html&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;依旧可以不改变默认进行安装。&lt;/p&gt;
&lt;p&gt;需要注意：默认安装的RabbitMQ 监听端口是5672&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.配置&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;激活 RabbitMQ's Management Plugin&lt;/h3&gt;
&lt;p&gt;使用RabbitMQ 管理插件，可以更好的可视化方式查看Rabbit MQ 服务器实例的状态。&lt;/p&gt;
&lt;p&gt;打开命令窗口：&lt;/p&gt;
&lt;p&gt;输入命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&quot;C:\Program Files\RabbitMQ Server\rabbitmq_server-3.2.3\sbin\rabbitmq-plugins.bat&quot; enable rabbitmq_management
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启服务才行，使用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
net stop RabbitMQ &amp;amp;&amp;amp; net start RabbitMQ
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候，也许会出现这种结果：&lt;/p&gt;
&lt;p&gt;“发生错误：发生系统错误&lt;span lang=&quot;EN-US&quot;&gt; 5。&lt;span lang=&quot;EN-US&quot;&gt;  拒绝访问。”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;问题解决方案：使用管理员打开&lt;span lang=&quot;EN-US&quot;&gt;cmd再执行此命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;在C:\Windows\System32 找到cmd.exe 双击执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;创建用户，密码，绑定角色&lt;/h3&gt;
&lt;p&gt;使用&lt;span lang=&quot;EN-US&quot;&gt;rabbitmqctl控制台命令（位于&lt;span lang=&quot;EN-US&quot;&gt;C:\Program Files\RabbitMQ Server\rabbitmq_server-xxx\sbin&amp;gt;）来创建用户，密码，绑定权限等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：安装路径不同的请看仔细啊。&lt;/p&gt;
&lt;p&gt;rabbitmq的用户管理包括增加用户，删除用户，查看用户列表，修改用户密码。&lt;/p&gt;
&lt;p&gt;新增一个用户：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rabbitmqctl.bat add_user username password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看已有用户及用户的角色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rabbitmqctl.bat list_users
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时来看下我们当前用户后面没有“[administrator]”&lt;/p&gt;
&lt;p&gt;这个administrator是干嘛用的呢？这就涉及到用户角色问题了：&lt;/p&gt;
&lt;p&gt;rabbitmq用户角色可分为五类：超级管理员, 监控者, 策略制定者, 普通管理者以及其他。&lt;/p&gt;
&lt;p&gt;(1) 超级管理员(administrator)&lt;/p&gt;
&lt;p&gt;可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。&lt;/p&gt;
&lt;p&gt;(2) 监控者(monitoring)&lt;/p&gt;
&lt;p&gt;可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) &lt;/p&gt;
&lt;p&gt;(3) 策略制定者(policymaker)&lt;/p&gt;
&lt;p&gt;可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。&lt;/p&gt;
&lt;p&gt;(4) 普通管理者(management)&lt;/p&gt;
&lt;p&gt;仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。&lt;/p&gt;
&lt;p&gt;(5) 其他的&lt;/p&gt;
&lt;p&gt;无法登陆管理控制台，通常就是普通的生产者和消费者&lt;/p&gt;

&lt;p&gt;我们也给新建的用户username 变成 “超级管理员” 角色：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rabbitmqctl.bat set_user_tags username administrator&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改密码：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; rabbitmqctl change_password userName newPassword&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除已存在的用户：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rabbitmqctl.bat delete_user username&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这样基本的配置就结束了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;然后我们打开浏览器 &lt;a href=&quot;http://localhost:15672/&quot; target=&quot;_blank&quot;&gt; http://localhost:15672&lt;/a&gt;&lt;a rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;访问Rabbit Mq的管理控制台，使用刚才创建的账号登陆系统：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1063420/201808/1063420-20180813141426117-758557492.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;设置虚拟主机和用户关系（默认虚拟主机名为 &quot;/”），选中admin菜单，然后选中右边的 virtual hosts 菜单，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1063420/201808/1063420-20180813141536474-400387861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在最下面有一个添加虚拟主机，我们自己起好名称点击 add virtual host 即可。&lt;/p&gt;
&lt;p&gt;然后再上面的列表中就可以看到你新添加的主机，再点击你新添加的虚拟主机，为其分配用户，我们首先可以分配我们前面创建的username 用户，然后也可以在admin→users页面添加新的用户后，再将其添加到当前新建的虚拟主机。&lt;/p&gt;
&lt;p&gt;对于这块虚拟主机和用户，我个人的理解就像是你买了一辆车（用户），我买了一辆车（用户）， 但是我们都得去交管所上拍照（虚拟主机）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; java代码编写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在环境搭好，开始进行code。&lt;/p&gt;
&lt;p&gt;新建一个maven工程，新手可参考 https://www.cnblogs.com/JJJ1990/p/8384386.html  前半部分。&lt;/p&gt;
&lt;p&gt;在pom文件中添加jar包引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.rabbitmq&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;amqp-client&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;3.6.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;发布者&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; publisher() 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Connection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Channel channel = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             factory.setHost(ConnectionFactory.DEFAULT_HOST&lt;span&gt;); //设置连接地址 默认 localhost
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             factory.setPort(ConnectionFactory.DEFAULT_AMQP_PORT&lt;span&gt;);    //监听端口 默认5672
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             factory.setUsername(&quot;username&quot;&lt;span&gt;);  //用户名
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             factory.setPassword(&quot;password&quot;&lt;span&gt;);  //密码
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             factory.setVirtualHost(&quot;test_vhosts&quot;&lt;span&gt;); // 虚拟主机
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建与RabbitMQ服务器的TCP连接&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             connection  =&lt;span&gt; factory.newConnection();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             channel =&lt;span&gt; connection.createChannel(); //创建通道/频道
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             channel.queueDeclare(&quot;JQueue&quot;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;); //参数中的 JQueue就是我们声明的队列名称
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             String message = &quot;First Message&quot;&lt;span&gt;;             //消息体
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             channel.basicPublish(&quot;&quot;, &quot;JQueue&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, message.getBytes());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             System.out.println(&quot;Send Message is:'&quot; + message + &quot;'&quot;&lt;span&gt;);            
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            ex.printStackTrace();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;finally&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(channel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    channel.close();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                    connection.close();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们先新建一个publisher()方法，在引入jar包的时候要特别注意，同样的名称有好几个包，我们统一都只引用 &lt;strong&gt;com.rabbitmq.client&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在queueDeclare方法中 除了队列名称外的其余4项参数意义如下&lt;/p&gt;
&lt;p&gt;* @param durable true if we are declaring a durable queue (the queue will survive a server restart)&lt;br/&gt;* @param exclusive true if we are declaring an exclusive queue (restricted to this connection)&lt;br/&gt;* @param autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)&lt;br/&gt;* @param arguments other properties (construction arguments) for the queue&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;消费者&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  consumer() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;          Connection connection = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;          Channel channel = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;          &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;              ConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;              factory.setHost(ConnectionFactory.DEFAULT_HOST&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              factory.setPort(ConnectionFactory.DEFAULT_AMQP_PORT&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;              factory.setUsername(&quot;jjj&quot;&lt;span&gt;);      //注意此处的用户名和发布者不同，但是我将他们分配到了同一个虚拟主机，同样可以获取发布的消息
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;              factory.setPassword(&quot;password&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;              factory.setVirtualHost(&quot;test_vhosts&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;              connection =&lt;span&gt; factory.newConnection();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;              channel =&lt;span&gt; connection.createChannel();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt;              Consumer consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConsumer(channel) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                 @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] body)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                          &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                      String message = &lt;span&gt;new&lt;/span&gt; String(body, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                      System.out.println(&quot; Consumer have received '&quot; + message + &quot;'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                 }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;             };
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;              channel.basicConsume(&quot;JQueue&quot;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, consumer);   //绑定消费者和队列
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;          &lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception ex)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;         {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;             ex.printStackTrace();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;em id=&quot;__mceDel&quot;&gt; 对比消费者和发布者的代码我们可以发现，我用了不同的用户连接同一个虚拟主机 &lt;em id=&quot;__mceDel&quot;&gt;test_vhosts&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新建main方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        publisher();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println( &quot;Hello World!消息已經发布&quot;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        consumer();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println( &quot;Hello World!正在监听接收&quot;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行代码后可以看到如下结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1063420/201808/1063420-20180813115645189-804135907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器打开rabbitmq界面。找到queues 菜单，点击后，就可以在列表中找到我们建立的队列，找到我刚才新建的jqueue队列，点进去后，找到下面的 publish message  目录&lt;/p&gt;
&lt;p&gt;在Payload 中我们随便输入一些文字 点击发布就可以看到代码的控制台已经收到了这些消息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1063420/201808/1063420-20180813120418083-1051105230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制台输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1063420/201808/1063420-20180813120426092-1598102843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这说明程序运行后，消费者一直在监听当前的队列，一旦有消息，就会立刻获取。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 07:02:00 +0000</pubDate>
<dc:creator>队长给我球。</dc:creator>
<og:description>前言 消息中间件目前已经在很多大型的项目上得到了运用，我们常见的有 RabbitMq， activitymq，kafka，rocketmq，其中rocketmq是阿里自己在kafka的基础上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JJJ1990/p/9468167.html</dc:identifier>
</item>
<item>
<title>深入理解跨域SSO原理与技术 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9468035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9468035.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一sso体系结构&quot;&gt;一：SSO体系结构&lt;/h2&gt;
&lt;h3 id=&quot;sso&quot;&gt;SSO&lt;/h3&gt;
&lt;p&gt;​ SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。&lt;/p&gt;
&lt;h3 id=&quot;体系结构&quot;&gt;体系结构&lt;/h3&gt;
&lt;p&gt;​ 当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－token；用户再访问别的应用的时候就会将这个token带上，作为自己认证的凭据，应用系统接受到请求之后会把token送到认证系统进行校验，检查token的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201808/1136672-20180813144535995-463848507.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;token令牌&quot;&gt;Token（令牌）&lt;/h3&gt;
&lt;p&gt;token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。&lt;/p&gt;
&lt;p&gt;当用户第一次登录后，服务器生成一个token并将此token返回给客户端，客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。 以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。&lt;/p&gt;
&lt;p&gt;简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计token的值可以有以下方式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用设备mac地址作为token&lt;/li&gt;
&lt;li&gt;用sessionid作为token&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;同域sso原理分析&quot;&gt;同域SSO原理分析&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;实际上，HTTP协议是无状态的，单个系统的会话由服务端Session进行维持，Session保持会话的原理是通过Cookie把sessionId写入浏览器，每次访问都会自动携带全部Cookie，在服务端读取其中的sessionId进行验证实现会话保持。同域下单点登录其实就是手写token代替sessionId进行会话认证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;token的生成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务端生成token后，将token与user对象存储在Map结构中，token为Key，user对象为value，response.addCookie()生成新的Cookie，名为token，值为token的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;token过期移除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将服务端的token从Map中移除，再删除浏览器端的名为token的Cookie。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;认证流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201808/1136672-20180813144558187-710912186.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;跨域sso原理分析&quot;&gt;跨域SSO原理分析&lt;/h3&gt;
&lt;p&gt;当有多个系统时，认证机制的流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提供用户登录界面，供用户进行身份认证&lt;/li&gt;
&lt;li&gt;用户验证通过后，生成新token&lt;/li&gt;
&lt;li&gt;将token&amp;lt;-&amp;gt;user 对存入全局MAP中供校验&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将token写入所有域的Cookie中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;页面重定向回原始请求URL&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当系统有多个并且在不同域(domain)时，Cookie只会作用在当前域下。&lt;/p&gt;
&lt;p&gt;将token写入所有域的Cookie中才是解决跨域SSO的核心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201808/1136672-20180813144612227-1463951613.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二cookie增删改查&quot;&gt;二：Cookie增删改查&lt;/h2&gt;
&lt;h3 id=&quot;如何读取cookie&quot;&gt;如何读取Cookie？&lt;/h3&gt;
&lt;p&gt;通过Servlet中的request对象可以读取到Cookie数组，然后foreach遍历读取，一般只是获取到nam和value，其他信息写入到浏览器后，浏览器不主动再发回来，读取并无意义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                System.out.println(
                        cookie.getName() +
                        cookie.getValue() +
                        cookie.getMaxAge() +
                        cookie.getPath() +
                        cookie.getDomain() +
                        cookie.getSecure() +
                        cookie.isHttpOnly()//客户端js是否可以获取
                );
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何写入cookie带浏览器&quot;&gt;如何写入Cookie带浏览器？&lt;/h3&gt;
&lt;p&gt;新建Cookie对象设置一系列属性，然后添加到response中去。需要注意的是，当设置path为“/”时，表示所有路径都会被该Cookie作用到，如果设置为&lt;code&gt;/path1&lt;/code&gt;那么由&lt;code&gt;/path2&lt;/code&gt;发起请求就不会携带该Cookie。默认不设置只作用在当前路径下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        Cookie cookie = new Cookie(&quot;myCookieName&quot;,&quot;myCookieValue&quot;);
        cookie.setHttpOnly(false);//Javascript不能处理
        //一个正值表示cookie将在经过许多秒之后过期。注意，值是cookie过期的最大时间，而不是cookie当前的时间。
        //负值表示cookie没有持久存储，在Web浏览器退出时将被删除。零值会导致删除cookie。
        cookie.setMaxAge(-1000);
        cookie.setSecure(false);//如果为true，仅支持HTTPS协议
        //cookie对指定目录中的所有页面以及该目录子目录中的所有页面都可见。
        cookie.setPath(&quot;/&quot;);
        //cookie.setDomain(&quot;www.a.com&quot;);//默认情况下，cookie只返回给发送cookie的服务器。
        response.addCookie(cookie);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改cookie&quot;&gt;修改Cookie&lt;/h3&gt;
&lt;p&gt;修改更新Cookie时，除了要保证Cookie的name是相同的，也要保证Cookie的一系列属性是相同的，否则浏览器会生成新的Cookie。&lt;/p&gt;
&lt;h3 id=&quot;删除cookie&quot;&gt;删除Cookie&lt;/h3&gt;
&lt;p&gt;只需要设置Cookie的MaxAge为负值，意味着是过去的Cookie，浏览器就会清除。&lt;/p&gt;
&lt;h2 id=&quot;三跨域读写cookie&quot;&gt;三：跨域读写Cookie&lt;/h2&gt;
&lt;h3 id=&quot;利用html的script标签跨域写cookie&quot;&gt;1.利用HTML的script标签跨域写Cookie&lt;/h3&gt;
&lt;p&gt;比如当前域是www.a.com,下面的script标签是跨域写cookie的核心，通过此标签实现了向www.b.com域写入cookie：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://www.b.com/setCookie?cname=token&amp;amp;cval=123456&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;p3p协议&quot;&gt;P3P协议&lt;/h4&gt;
&lt;p&gt;​ P3P是一种被称为个人隐私安全平台项目（the Platform for Privacy Preferences）的标准，能够保护在线隐私权，使Internet冲浪者可以选择在浏览网页时，是否被第三方收集并利用自己的个人信息。如果一个站点不遵守P3P标准的话，那么有关它的Cookies将被自动拒绝，并且P3P还能够自动识破多种Cookies的嵌入方式。p3p是由全球资讯联盟网所开发的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举个例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 我们在访问A网站时，理论上说，我们只能把Cookie信息保存到A站域名下，而不能写入到B网站下。如果想要跨域读写Cookie，只是通过script标签变相访问B网站在一些浏览器是行不通的，此时B网站的服务器应该告诉浏览器允许A网站写入Cookie，否则浏览器将会拒绝执行，这就是P3P协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端如何告诉浏览器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ P3P提供了一种简单的方式 ，来加载用户隐私策略，只要在http响应的头信息中增加 &lt;code&gt;response.setHeader(&quot;P3P&quot;,&quot;CP=NON DSP COR CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa CONa HISa TELa OTPa OUR UNRa IND UNI COM NAV INT DEM CNT PRE LOC);&lt;/code&gt;而无需指定隐私策略文件也可以达到指定隐私策略的目的。 CP=后面的字符串分别代表不同的策略信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为P3P协议所以不能保证所有浏览器都能通过script标签方式跨域写Cookie，有的浏览器本身就是拒绝跨域的。&lt;/p&gt;
&lt;p&gt;显然这种方式是不能保证跨域写cookie的成功性。&lt;/p&gt;
&lt;h3 id=&quot;通过url参数实现跨域信息传递&quot;&gt;2.通过URL参数实现跨域信息传递&lt;/h3&gt;
&lt;p&gt;我们要在A域实现写入token到B域，需要在A域设计一个servlet接收请求，代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(name = &quot;tg&quot;)
public class Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
        //获取请求的目标域
        String from = request.getParameter(&quot;from&quot;);
        //生成token，
        String token = &quot;123456&quot;;
        //重定向到目标域
        response.sendRedirect(from + &quot;?cname=token&amp;amp;cval=&quot; + token);
    }
    ...
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由a域发起请求，请求地址：&lt;code&gt;http://www.a.com/tg?from=http://www.b.com/set_cookie&lt;/code&gt;, 请求后该Servlet会获取&lt;code&gt;from&lt;/code&gt;参数的值并生成&lt;code&gt;token&lt;/code&gt;最后让客户端重定向到&lt;code&gt;http://www.b.com/set_cookie?cname=token&amp;amp;cval=123456&lt;/code&gt;，然后B域的Servlet(&quot;set_cookie&quot;)获取Url参数写入Cookie到客户端，代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //将要写入的cookie项，调用者通过参数传递
        String cookieName = request.getParameter(&quot;cname&quot;);
        String cookieValue = request.getParameter(&quot;cval&quot;);

        //生成cookie
        Cookie cookie = new Cookie(cookieName,cookieValue);
        cookie.setPath(&quot;/&quot;);
        //一般可以将domain设置到顶级域
        //cookie.setDomain(&quot;www.b.com&quot;);
        response.addCookie(cookie);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候再查看B域下的Cookie就可以发现(token=123456)已经被写入到浏览器。&lt;/p&gt;
&lt;h3 id=&quot;读取其它域的cookie&quot;&gt;3.读取其它域的Cookie&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;利用script标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用script标签执行另一个域实现的读取cookie方法，script标签返回结果将是变量定义形式的JS代码，每一个变量表示一个cookie项，这些代码加载后，此页面后续JS代码可以直接在script脚本中读取已定义的变量值，即各cookie值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://www.b.com/reaf_cookies&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;HTML页面读取&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
alert(token);
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;B域的url为&lt;code&gt;/read_cookies&lt;/code&gt;的Servlet是如何实现的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如图，首先我们先在request中获取cookie数组，然后for循环遍历拼接为类似&lt;code&gt;var token='test123';&lt;/code&gt;的字符串。最重要的是设置&lt;code&gt;ContentType&lt;/code&gt;为&lt;code&gt;application/javascript&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Cookie[] cookies = request.getCookies();
        StringBuilder stringBuilder = new StringBuilder();
        //一定要设置响应类型，否则可能导致IE不解析js直接进行下载操作
        response.setContentType(&quot;application/javascript&quot;);

        if (cookies != null) {
            for (Cookie cookie : cookies) {
                //结果类似于这样 var token='123456';
                stringBuilder.append(&quot;var &quot;)
                        .append(cookie.getName())
                        .append(&quot;=&quot;)
                        .append(&quot;'&quot;)
                        .append(cookie.getValue())
                        .append(&quot;'&quot;)
                        .append(&quot;;&quot;);
            }
            response.getWriter().append(stringBuilder.toString());
        }
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四跨域ajax请求&quot;&gt;四：跨域Ajax请求&lt;/h2&gt;
&lt;h3 id=&quot;jsonp的方式&quot;&gt;1.Jsonp的方式&lt;/h3&gt;
&lt;p&gt;跨域Ajax请求在浏览器阶段就会被阻止，我们可以通过script标签返回想要的json数据。如图：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://www.b.com/user_info_2&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台Servlet代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //要正确设置响应类型,避免IE出现下载
        response.setContentType(&quot;aaplication/javascript&quot;);

        String userInfo = &quot;{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;zhangsan\&quot;}&quot;;

        //返回拼接的javascript语句字符串，语句本身执行一个调用函数的操作
        String ret = &quot;showResult(&quot;+userInfo+&quot;)&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Servlet中设置返回类型为&lt;code&gt;javascript&lt;/code&gt;，并正常获取json格式的数据，最关键的是在最后拼接为js语句字符串，语句本身就是执行一个调用函数的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;showResult({&quot;id&quot;:1,&quot;name&quot;:&quot;zhangsan&quot;})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;showResult(ret)&lt;/code&gt;回调函数自然需要我们在之前就定义好：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;script&amp;gt;
        function showResult(ret){
            console.log(ret)
        }
    &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式，前端的回调函数和后端耦合度较高。前端可以在调用后端方法时带上回调函数名（?callback=xxxxx），后端优化后的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        //通过参数传递回调函数名，一定程度降低了前后端代码的耦合度
        String callback = request.getParameter(&quot;callback&quot;);

        //返回拼接的javascript语句字符串，语句本身执行一个调用函数的操作
        String ret = callback+&quot;(&quot;+userInfo+&quot;)&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;再优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML页面加载到我们定义的script标签时就会执行我们的回调方法，更多时候我们想要控制回调方法的执行时机。这个问题可以通过前端动态生成节点来解决，当我们执行完之后再移除节点即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;script&amp;gt;
        var script = document.createElement(&quot;script&quot;);
        script.src = &quot;http://www.b.com/user_info_2?callback=showResult&quot;;
        document.body.appendChild(script);

        script.onload = function () {
            document.body.removeChild(script);
        }
    &amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;JQuery&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以把这些封装到一个方法里，随时调用。这里可以使用Jquery封装好的API。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;                $.ajax({
                    url: &quot;http://localhost:9090/query&quot;,
                    type: &quot;GET&quot;,
                    dataType: &quot;jsonp&quot;,  //指定服务器返回的数据类型
                    jsonpCallback: &quot;showData&quot;,  //指定回调函数名称
                    success: function (data) {
                        console.info(&quot;调用success&quot;);
                    }
                });
                function showData(data){
                    var result = JSON.stringify(data);
                }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cors简介&quot;&gt;2.CORS简介&lt;/h3&gt;
&lt;p&gt;出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非使用CORS头文件。&lt;/p&gt;
&lt;p&gt;跨域资源共享（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。浏览器支持在 API 容器中（例如 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; 或 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET跨域请求原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当客户端浏览器发起一个跨域的HTTP请求，浏览器经过请求响应，如果没有看到&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;的header头部，会认为你的请求是不合法的。换句话说，我们只要在被请求的服务器上设置这个头部，浏览器就会允许我们进行请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于简单的请求，我们直接在服务端 设置就可以了。如图，只要请求的地址是&lt;code&gt;www.a.com&lt;/code&gt;就会被浏览器允许跨域。如果想要允许对于多个来源可以用&lt;code&gt;,&lt;/code&gt;号进行隔开；如果想要允许所有来源，设置为&lt;code&gt;*&lt;/code&gt;就可以，不过建议不要使用，这样会造成安全隐患。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //简单请求，直接设置Access-Control-Allow-Origin就可以了
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);
        //要正确设置响应类型,避免IE出现下载
        response.setContentType(&quot;aaplication/json&quot;);

        response.getWriter().write(&quot;{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;zhangsan\&quot;}&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于复杂的请求，比如POST，或者加入了自定义header头部，上面的方法就不适用了。下面继续看。&lt;/p&gt;
&lt;h4 id=&quot;cors流程&quot;&gt;CORS流程&lt;/h4&gt;
&lt;p&gt;请求发起时,浏览器先判断当前是否是跨域的AJAX;&lt;/p&gt;
&lt;p&gt;如果是,判断是否是普通类型请求(GET类型,无自定义头数据);&lt;/p&gt;
&lt;p&gt;普通请求,直接发起GET到服务端,在响应头中寻找 Access-Contro-Alow- Origin,如果有且允许,处理响应结果;&lt;/p&gt;
&lt;p&gt;不是普通请求(非GET类型,或有自定义头), 先 PreFlight(即发起一个 method= OPTIONS)的请求,&lt;/p&gt;
&lt;p&gt;要求返回 Access-Control-Allow- Methods和 Access-Control-Allow- Headers, 内容体为空&lt;/p&gt;
&lt;p&gt;PreFlight正确执行后, 再发起GET请求, 获得响应结果, 并处理结果.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;归根到我们的代码中的实现，只需要在servlet中定义options请求的处理方法即可。如图&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    protected void doOptions(HttpServletRequest req, HttpServletResponse response) {
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);
        response.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;GET,POST,OPTIONS,DELETE&quot;);
        response.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;reqid,xxx&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;是必需的。&lt;/p&gt;
&lt;h3 id=&quot;两种跨域ajax请求对比&quot;&gt;3.两种跨域AJax请求对比&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;兼容性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jsonp对所有浏览器兼容，CORS对现代浏览器兼容（IE8之后）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jsonp只支持GET方式，CORS支持GET，POST等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jsonp需要服务端封装返回信息，CORS更像原生AJax一样使用。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Create By yster@foxmail.com 转载注明出处！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 13 Aug 2018 06:48:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9468035.html</dc:identifier>
</item>
<item>
<title>MongoDB Change Stream：简介、尝试与应用 - xybaby</title>
<link>http://www.cnblogs.com/xybaby/p/9464328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xybaby/p/9464328.html</guid>
<description>&lt;p&gt;　　在MongoDB3.6引入的新feature中，&lt;a href=&quot;https://docs.mongodb.com/v3.6/changeStreams/#changestreams&quot; target=&quot;_blank&quot;&gt;change stream&lt;/a&gt;无疑是非常吸引人的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　Change streams allow applications to access real-time data changes without the complexity and risk of tailing the oplog.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Change stream允许应用实时获取mongodb数据的变更，这是个呼声很高的一个的需求，可以用于ETL、跨平台数据同步、通知服务等。以前没有change stream的时候，也可以通过tail oplog来追踪修改，但这是复杂、危险的野路子。&lt;/p&gt;
&lt;p&gt;　　本文地址：&lt;a href=&quot;https://www.cnblogs.com/xybaby/p/9464328.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xybaby/p/9464328.html&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Targeted changes&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Changes can be filtered to provide relevant and targeted changes to listening applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Resumablility&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Resumability was top of mind when building change streams to ensure that applications can see every change in a collection. resume token&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Total ordering&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　MongoDB 3.6 has a global logical clock that enables the server to order all changes across a sharded cluster.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Durability&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Change streams only include majority-committed changes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Security&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Change streams are secure – users are only able to create change streams on collections to which they have been granted read access.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ease of use&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Change streams are familiar – the API syntax takes advantage of the established MongoDB drivers and query language, and are independent of the underlying oplog format.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Idempotence&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　All changes are transformed into a format that’s safe to apply multiple times. Listening applications can use a resume token from any prior change stream event, not just the most recent one, because reapplying operations is safe and will reach the same consistent state.&lt;/p&gt;

&lt;p&gt;　　相比自动tail oplog，change stream 有以下优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果只有单个节点持久化，那么oplog对应的操作是可能被回滚的，而change stream有Durability特性&lt;/li&gt;
&lt;li&gt;在sharded cluster环境，change stream跨shards，可以通过mongos tail oplog，而不用去每一个replica set上分别tail&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　Change stream对MongoDB的部署有一些需求:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只对replica sets 或者sharded cluster（MongoDB3.6中shard必须是replica set）有用，这个不难理解，因为change stream也是利用了oplog。如果是sharded cluster，必须都过mongos连接。&lt;/li&gt;
&lt;li&gt;必须使用WiredTiger 引擎，使用replica set protocol version 1&lt;/li&gt;
&lt;/ul&gt;

&lt;div readability=&quot;7.575&quot;&gt;　　在文章&lt;a href=&quot;https://www.cnblogs.com/xybaby/p/9460634.html&quot; target=&quot;_blank&quot;&gt;免费试用MongoDB云数据库 （MongoDB Atlas）教程&lt;/a&gt;中，介绍了如何使用MongoDB Atlas提供的云数据库服务，免费提供的集群刚好是使用WiredTiger 引擎的Replica set，因此本文基于这个环境来测试。主要测试Change Stream所支持的所有事件（change event）、fullDocument特性、resume特性。&lt;/div&gt;
&lt;p&gt;　　change event包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;insert&lt;/li&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;li&gt;update&lt;/li&gt;
&lt;li&gt;invalidate&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　有意思的是，相比CRUD，多了一个replace事件。update 与 replace的区别在于&lt;/p&gt;
&lt;p&gt;　　A replace operation uses the update command, and consists of two stages:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Delete the original document with the documentKey and&lt;/li&gt;
&lt;li&gt;Insert the new document using the same documentkey&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　测试方法：启动两个Mongo shell，一个操作数据库，一个watch。为了方便区分，浅绿色背景为Operate，灰色背景为Watch&lt;/p&gt;
&lt;h2&gt;准备环境&lt;/h2&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; use engineering
switched to db engineering&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; use engineering
switched to db engineering
order &lt;/span&gt;2&lt;span&gt;
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt; cursor =&lt;span&gt; db.users.watch()
assert: command failed: {
        &lt;/span&gt;&quot;operationTime&quot; : Timestamp(1533888296, 2&lt;span&gt;),
        &lt;/span&gt;&quot;ok&quot; : 0&lt;span&gt;,
        &lt;/span&gt;&quot;errmsg&quot; : &quot;cannot open $changeStream for non-existent database: engineering&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;code&quot; : 26&lt;span&gt;,
        &lt;/span&gt;&quot;codeName&quot; : &quot;NamespaceNotFound&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;$clusterTime&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;clusterTime&quot; : Timestamp(1533888296, 2&lt;span&gt;),
                &lt;/span&gt;&quot;signature&quot;&lt;span&gt; : {
                        &lt;/span&gt;&quot;hash&quot; : BinData(0,&quot;fWTN4Kuv7cq9xCcC0vCF4AkTxuU=&quot;&lt;span&gt;),
                        &lt;/span&gt;&quot;keyId&quot; : NumberLong(&quot;6563302068054917121&quot;&lt;span&gt;)
                }
        }
} : aggregate failed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从watch报错可以看出，只能对已经存在的db watch，因此可以先插入一条数据，创建对应的DB、Collection&lt;/p&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.insert({'username': 'test1', age: 18, 'email':'test1@gmail.con'&lt;span&gt;})
WriteResult({ &lt;/span&gt;&quot;nInserted&quot; : 1 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; cursor =&lt;span&gt; db.users.watch()
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
&lt;/span&gt;2018-08-10T16:08:49.200+0800 E QUERY    [thread1] Error: error hasNext: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; :
DBCommandCursor.prototype.next@src&lt;/span&gt;/mongo/shell/query.js:853:1
@(shell):1:1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时已经创建好用于监听的cursor，此时还没有change event。&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;Insert &lt;/h2&gt;
&lt;div readability=&quot;14.5&quot;&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.insert({'username': 'test2', age: 19, 'email':'test2@gmail.con'})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WriteResult({ &quot;nInserted&quot; : 1 })&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;glttSC0AAAADRmRfaWQAZFttSCb45nBxa/FSsABaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;insert&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;fullDocument&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4826f8e670716bf152b0&quot;&lt;span&gt;),
                &lt;/span&gt;&quot;username&quot; : &quot;test2&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;age&quot; : 19&lt;span&gt;,
                &lt;/span&gt;&quot;email&quot; : &quot;test2@gmail.con&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4826f8e670716bf152b0&quot;&lt;span&gt;)
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;replace&lt;/h2&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.update({username: &quot;test1&quot;}, {age: 19&lt;span&gt;})
WriteResult({ &lt;/span&gt;&quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;glttSSMAAAACRmRfaWQAZFttR+r45nBxa/FSrwBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;&lt;strong&gt;&lt;span&gt;replace&lt;/span&gt;&lt;/strong&gt;&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;fullDocument&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d47eaf8e670716bf152af&quot;&lt;span&gt;),
                &lt;/span&gt;&quot;age&quot; : 19&lt;span&gt;
        },
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d47eaf8e670716bf152af&quot;&lt;span&gt;)
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　可以看到，操作的时候使用的是db.collection.update，但change event 却是replace，原因在&lt;a href=&quot;https://docs.mongodb.com/v3.6/reference/method/db.collection.update/index.html#replace-a-document-entirely&quot; target=&quot;_blank&quot;&gt;eplace-a-document-entirely&lt;/a&gt;中有介绍&lt;/p&gt;
&lt;blockquote readability=&quot;4.6644518272425&quot;&gt;
&lt;p&gt;If the &lt;code class=&quot;docutils literal&quot;&gt;&amp;lt;update&amp;gt;&lt;/code&gt; document contains &lt;em&gt;only&lt;/em&gt; &lt;code class=&quot;docutils literal&quot;&gt;field:value&lt;/code&gt; expressions, then:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;delete&lt;/h2&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.remove({ &quot;_id&quot; : ObjectId(&quot;5b6d47eaf8e670716bf152af&quot;&lt;span&gt;)})
WriteResult({ &lt;/span&gt;&quot;nRemoved&quot; : 1 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;glttSfAAAAAFRmRfaWQAZFttR+r45nBxa/FSrwBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;delete&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d47eaf8e670716bf152af&quot;&lt;span&gt;)
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;update&lt;/h2&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.insert({'username': 'test1', age: 18, 'email':'test1@gmail.con'&lt;span&gt;})
WriteResult({ &lt;/span&gt;&quot;nInserted&quot; : 1&lt;span&gt; })
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt; db.users.update({username: &quot;test1&quot;}, {$set: {age: 19&lt;span&gt;}})
WriteResult({ &lt;/span&gt;&quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;glttSmQAAAAERmRfaWQAZFttSlz45nBxa/FSsgBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;insert&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;fullDocument&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4a5cf8e670716bf152b2&quot;&lt;span&gt;),
                &lt;/span&gt;&quot;username&quot; : &quot;test1&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;age&quot; : 18&lt;span&gt;,
                &lt;/span&gt;&quot;email&quot; : &quot;test1@gmail.con&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4a5cf8e670716bf152b2&quot;&lt;span&gt;)
        }
}

MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;glttSn0AAAABRmRfaWQAZFttSlz45nBxa/FSsgBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;update&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4a5cf8e670716bf152b2&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;updateDescription&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;updatedFields&quot;&lt;span&gt; : {
                        &lt;/span&gt;&quot;age&quot; : 19&lt;span&gt;
                },
                &lt;/span&gt;&quot;removedFields&quot;&lt;span&gt; : [ ]
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;update fullDocument&lt;/h2&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.mongodb.com/v3.6/reference/method/db.collection.watch/index.html&quot; target=&quot;_blank&quot;&gt;db.collection.watch&lt;/a&gt; 可以设置选项fullDocument参数，这个在change event：update的时候就可以返回对用documents的完整信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; cursor = db.users.watch([], &lt;strong&gt;&lt;span&gt;{fullDocument:'updateLookup'}&lt;/span&gt;&lt;/strong&gt; )
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.update({username: &quot;test1&quot;}, {$set: {age: 29&lt;span&gt;}})
WriteResult({ &lt;/span&gt;&quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;glttS88AAAAERmRfaWQAZFttSlz45nBxa/FSsgBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;update&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;&lt;strong&gt;&lt;span&gt;fullDocument&lt;/span&gt;&lt;/strong&gt;&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4a5cf8e670716bf152b2&quot;&lt;span&gt;),
                &lt;/span&gt;&quot;username&quot; : &quot;test1&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;age&quot; : 29&lt;span&gt;,
                &lt;/span&gt;&quot;email&quot; : &quot;test1@gmail.con&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6d4a5cf8e670716bf152b2&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;updateDescription&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;updatedFields&quot;&lt;span&gt; : {
                        &lt;/span&gt;&quot;age&quot; : 29&lt;span&gt;
                },
                &lt;/span&gt;&quot;removedFields&quot;&lt;span&gt; : [ ]
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;resume change stream&lt;/h2&gt;
&lt;p&gt;　　Operate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; db.users.insert({&quot;username&quot;: &quot;test3&quot;, &quot;age&quot;: 14&lt;span&gt;})
WriteResult({ &lt;/span&gt;&quot;nInserted&quot; : 1&lt;span&gt; })
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt; db.users.insert({&quot;username&quot;: &quot;test3&quot;, &quot;age&quot;: 14&lt;span&gt;})
WriteResult({ &lt;/span&gt;&quot;nInserted&quot; : 1&lt;span&gt; })
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt; db.users.remove({&quot;username&quot;: &quot;test3&quot;&lt;span&gt;})
WriteResult({ &lt;/span&gt;&quot;nRemoved&quot; : 2 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; &lt;span&gt;&lt;strong&gt;ret&lt;/strong&gt;&lt;/span&gt; =&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;gltusJ4AAAABRmRfaWQAZFtusJ5f9Jy7Q0jALABaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;insert&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;fullDocument&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6eb09e5ff49cbb4348c02c&quot;&lt;span&gt;),
                &lt;/span&gt;&quot;username&quot; : &quot;test3&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;age&quot; : 14&lt;span&gt;
        },
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6eb09e5ff49cbb4348c02c&quot;&lt;span&gt;)
        }
}
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;gltusKAAAAABRmRfaWQAZFtusJ9f9Jy7Q0jALQBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;insert&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;fullDocument&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6eb09f5ff49cbb4348c02d&quot;&lt;span&gt;),
                &lt;/span&gt;&quot;username&quot; : &quot;test3&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;age&quot; : 14&lt;span&gt;
        },
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6eb09f5ff49cbb4348c02d&quot;&lt;span&gt;)
        }
}
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;gltusK8AAAABRmRfaWQAZFtusJ5f9Jy7Q0jALABaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;delete&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6eb09e5ff49cbb4348c02c&quot;&lt;span&gt;)
        }
}
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt;&lt;span&gt; cursor.next()
{
        &lt;/span&gt;&quot;_id&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_data&quot; : BinData(0,&quot;gltusK8AAAACRmRfaWQAZFtusJ9f9Jy7Q0jALQBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;&lt;span&gt;)
        },
        &lt;/span&gt;&quot;operationType&quot; : &quot;delete&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;ns&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;db&quot; : &quot;engineering&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;coll&quot; : &quot;users&quot;&lt;span&gt;
        },
        &lt;/span&gt;&quot;documentKey&quot;&lt;span&gt; : {
                &lt;/span&gt;&quot;_id&quot; : ObjectId(&quot;5b6eb09f5ff49cbb4348c02d&quot;&lt;span&gt;)
        }
}
Mongo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　Resume Watch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
MongoDB Enterprise free-shard-0:PRIMARY&amp;gt; resume_cursor = db.users.watch([], {&quot;resumeAfter&quot;: &lt;strong&gt;&lt;span&gt;ret['_id'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;]&lt;/span&gt;&lt;/strong&gt;})
{ &lt;/span&gt;&quot;_id&quot; : { &quot;_data&quot; : BinData(0,&quot;gltusKAAAAABRmRfaWQAZFtusJ9f9Jy7Q0jALQBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;) }, &quot;operationType&quot; : &quot;insert&quot;, &quot;fullDocument&quot; : { &quot;_id&quot; : ObjectId(&quot;5b6eb09f5ff49cbb4348c02d&quot;), &quot;username&quot; : &quot;test3&quot;, &quot;age&quot; : 14 }, &quot;ns&quot; : { &quot;db&quot; : &quot;5b6d2180df9db10e4ba91d60_engineering&quot;, &quot;coll&quot; : &quot;users&quot; }, &quot;documentKey&quot; : { &quot;_id&quot; : ObjectId(&quot;5b6eb09f5ff49cbb4348c02d&quot;&lt;span&gt;) } }
{ &lt;/span&gt;&quot;_id&quot; : { &quot;_data&quot; : BinData(0,&quot;gltusK8AAAABRmRfaWQAZFtusJ5f9Jy7Q0jALABaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;) }, &quot;operationType&quot; : &quot;delete&quot;, &quot;ns&quot; : { &quot;db&quot; : &quot;5b6d2180df9db10e4ba91d60_engineering&quot;, &quot;coll&quot; : &quot;users&quot; }, &quot;documentKey&quot; : { &quot;_id&quot; : ObjectId(&quot;5b6eb09e5ff49cbb4348c02c&quot;&lt;span&gt;) } }
{ &lt;/span&gt;&quot;_id&quot; : { &quot;_data&quot; : BinData(0,&quot;gltusK8AAAACRmRfaWQAZFtusJ9f9Jy7Q0jALQBaEAQMcjq0rdpL+LTQHXFkm7J7BA==&quot;) }, &quot;operationType&quot; : &quot;delete&quot;, &quot;ns&quot; : { &quot;db&quot; : &quot;5b6d2180df9db10e4ba91d60_engineering&quot;, &quot;coll&quot; : &quot;users&quot; }, &quot;documentKey&quot; : { &quot;_id&quot; : ObjectId(&quot;5b6eb09f5ff49cbb4348c02d&quot;&lt;span&gt;) } }
MongoDB Enterprise free&lt;/span&gt;-shard-0:PRIMARY&amp;gt;&lt;span&gt; resume_cursor.next()
&lt;/span&gt;2018-08-11T17:49:13.127+0800 E QUERY    [thread1] Error: error hasNext: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; :
DBCommandCursor.prototype.next@src&lt;/span&gt;/mongo/shell/query.js:853:1
@(shell):1:1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在resume_cursor中，resumeAfter的参数设置为了之前的watch document，在watch的时候会一次性返回已经被消费过的change event&lt;/p&gt;

&lt;h2&gt;DDIA cdc&lt;/h2&gt;
&lt;p&gt;　　在&lt;a href=&quot;https://dataintensive.net/&quot; target=&quot;_blank&quot;&gt;Designing Data-Intensive Applications&lt;/a&gt;一书中，有一节Change Data Capture（cdc），讲述得就是复制集（replica set）中replication log的使用，对于MongoDB， replication log其实就是oplog。书中提到：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The problem with most databases’ replication logs is that they have long been considered to be an internal implementation detail of the database, not a public API.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　也就是说，应用（client）只能按照db的约束来使用db，而不是直接读取、解析replication log。但直接使用replic log直接用来创建serach index,cache,data warehouse。如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/03730C70DBEA4E73A13320FFB6016B5F&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1089769/201808/1089769-20180812205825128-2097268960.png&quot; alt=&quot;&quot;/&gt; &lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　change data capture (CDC), which is the process of observing all data changes written to a database and extracting them in a form in which they can be replicated to other systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　CDC使得Search index， Data warehouse成为了派生数据系统（derived data systems），也可以理解为是DB数据的视图。另外，有意思的是，上图db、replication log、derived data system组成的系统看起来很像一个中心化复制集（single leader）：DB是leader（Primary），derived data system（cache, data warehouse）是follower（Secondary）。&lt;/p&gt;
&lt;p&gt;　　Change stream应用前景非常广泛，在 &lt;a href=&quot;http://mongoing.com/?s=change+stream&quot; target=&quot;_blank&quot;&gt;完美数据迁移-MongoDB Stream&lt;/a&gt;的应用 一文中，介绍了使用change stream来在服务化改造的时候做数据迁移，且给出了一个完整的示范。在&lt;a href=&quot;https://pusher.com/tutorials/mongodb-change-streams&quot; target=&quot;_blank&quot;&gt;USING MONGODB AS A REALTIME DATABASE WITH CHANGE STREAMS&lt;/a&gt;一文中，也结合NodeJs给出了一个简单的使用案列。&lt;/p&gt;

&lt;p&gt;官方对在Sharded Cluster上使用change stream有一些说明，可以参考&lt;a href=&quot;https://docs.mongodb.com/v3.6/administration/change-streams-production-recommendations/#sharded-clusters&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;，有以下几点值得注意：&lt;/p&gt;
&lt;p&gt;（1）&lt;/p&gt;
&lt;blockquote readability=&quot;6.7307692307692&quot;&gt;
&lt;p&gt;To guarantee total ordering of changes, for each change notification the &lt;a href=&quot;https://docs.mongodb.com/v3.6/reference/program/mongos/#bin.mongos&quot;&gt;mongos&lt;/a&gt; checks with each shard to see if the shard has seen more recent changes. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　不管有没有数据变更，mongos都需要在所有shards上check，影响了change steam的响应时间。如果网络延时大，如geographically distributed shard，问题会更明显。如果数据变更特别频繁，那么Change stream可能跟不上变化&lt;/p&gt;
&lt;p&gt;（2）　　&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;For sharded collections, update operations with multi : true may cause any change streams opened against that collection to send notifications for orphaned documents.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　对于update操作，如果设置 multi：True，那么操作也可能在 &lt;a href=&quot;https://docs.mongodb.com/v3.6/reference/glossary/#term-orphaned-document&quot;&gt;orphaned documents&lt;/a&gt;.上执行，这样也会产生多余的change stream，应用可能需要处理这种情侣。BTW，ofphaned document是很令人头疼的问题。&lt;/p&gt;

&lt;p&gt;　　另外，MongoDB3.6只能针对单个collection进行watch，这样如果要关注多个collection或者多个db的write event时，需要分别建立连接进行watch，在 MongoDB 3.6 Change Streams: A Nest Temperature and Fan Control Use Case一文中提到这可能带来性能问题&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　It’s estimated that after 1000 streams you will start to see very measurable performance drops&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　不过，在MongoDB4.0中，可以在db，甚至cluster这个级别watch stream，对应用来说方便了很多，也避免了性能问题。&lt;/p&gt;

&lt;p&gt;　　本文介绍了MongoDB Change Stream这一新特性，以及其在具体应用中需要注意到的一些问题，并基于MongoDB atlas进行了简单的尝试。毫无疑问，Change Stream是非常有前途的特性，能解决很多现在实现起来很别扭的问题。但是如果要用于线上业务，还需要大量的测试，尤其是容错性与性能。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/v3.6/changeStreams/#changestreams&quot; target=&quot;_blank&quot;&gt;MongoDB Change Stream&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mongodb.com/blog/post/an-introduction-to-change-streams&quot;&gt;an-introduction-to-change-streams&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xybaby/p/9460634.html&quot; target=&quot;_blank&quot;&gt;免费试用MongoDB云数据库 （MongoDB Atlas）教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dataintensive.net/&quot; target=&quot;_blank&quot;&gt;Designing Data-Intensive Applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mongoing.com/?s=change+stream&quot; target=&quot;_blank&quot;&gt; 完美数据迁移-MongoDB Stream&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pusher.com/tutorials/mongodb-change-streams&quot; target=&quot;_blank&quot;&gt;USING MONGODB AS A REALTIME DATABASE WITH CHANGE STREAMS&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 06:38:00 +0000</pubDate>
<dc:creator>xybaby</dc:creator>
<og:description>在MongoDB3.6引入的新feature中，change stream无疑是非常吸引人的。 Change streams allow applications to access real-tim</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xybaby/p/9464328.html</dc:identifier>
</item>
<item>
<title>微服务架构理论-扩展立方体篇 - zygfengyuwuzu</title>
<link>http://www.cnblogs.com/zhyg/p/9466998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhyg/p/9466998.html</guid>
<description>&lt;p&gt;　　近几年的的微服务概念大火特火，随之框架也变得大火起来，尤其是spring boot，可能是因为spring cloud火起来的原因 搞得沉寂多年的dubbo也开始更新变得火起来。&lt;/p&gt;
&lt;p&gt;说起微服务对于不了解整个系统架构历史的小伙伴可能有些迷惑，怎么就突然一下子就微服务了，有点摸不着头脑，到底咋回事那？听我娓娓道来！&lt;/p&gt;
&lt;p&gt;　　很久很久以前的程序员都很牛逼一不开心就自己写个操作系统自己玩，玩着玩着最后就剩下了几个，比如我们熟知的windows，linux，苹果OS，这是我们使用最底层的&lt;/p&gt;
&lt;p&gt;操作系统，在操作系统上面我们还要运行我们的应用软件，这个运行的应用软件就是我们今天重点讲解的，然而这个软件一般指企业级软件。&lt;/p&gt;
&lt;p&gt;　　企业级软件最初只想把那些纸质的数据进行电子化，但是不断的发展，不断的发展，不过也就几十年的时间就出现了如下的架构（原谅我上面墨迹了那么多没用的）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/560839/201808/560839-20180813093551384-1817987486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过上面的发展我们我不在一一讨论除微服务之外的各种优缺点，直奔主题，为什么要用微服务？？&lt;/p&gt;
&lt;p&gt;　　用三个字回答就是&lt;strong&gt;“可扩展”，&lt;/strong&gt;围绕可扩展我们最终实现了微服务化，以及实现了对应的实例框架 spring boot 等&lt;/p&gt;
&lt;p&gt;　　也就是说，如果 “可扩展” 是抽象类的话，那么微服务就是继承了可扩展并实例化了（原谅我的程序思维）！&lt;/p&gt;
&lt;p&gt;　　可扩展也是很直白，那就是可以根据实际需要进行扩展。最后很多牛叉的人和组织总结了一个AKF可扩展的立方体&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/560839/201808/560839-20180813100838081-1716905865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　X,Y,Z轴分别代表了不同的扩展方向，下面简单解释一下：&lt;/p&gt;
&lt;p&gt;　　　　X轴代表无差别的克隆服务和数据库。用一个人来说X轴的例子可能是公司很多相同的事情分给多个人来干，简单快捷&lt;/p&gt;
&lt;p&gt;　　在每个克隆实体间无差别的分配任务，每个克隆实体都可以完成其他克隆实体的任务，无论任务分配给了谁。&lt;/p&gt;
&lt;p&gt;　　每个克隆实体都有工具和资源来尽快完成所分配的任务。&lt;/p&gt;
&lt;p&gt;　　　　Y轴代表的是按照交易处理的数据类型，交易任务类型或两者组合分割的工作责任。我们一般用动词或资源进行分离，比如：&lt;/p&gt;
&lt;p&gt;　　登录，查询，结算等等。把同样的工作分割成流水线式的工作流或并行的处理流，Y轴代表的更多是对工作的“工业革命”，将耦合紧密的&lt;/p&gt;
&lt;p&gt;　　工作进行进行专门处理。Y轴实质代表责任、行动或数据。实施成本一般比X轴扩展代价高。假如有100个人造100辆车，每个人负责&lt;/p&gt;
&lt;p&gt;　　造一辆，完成造车全部的任务，不如让100个人执行子任务，如发送机的安装、喷漆、四轮定位。这样就会减少前后交互所需要的上下文&lt;/p&gt;
&lt;p&gt;　　信息，更专注做某件事情。&lt;/p&gt;
&lt;p&gt;　　　　Z轴通常基于请求或客户的信息进行分割。比如我们在分客户时会有 “普通会员”和“vip会员“之分，服务“普通会员”与服务“vip会员”可能&lt;/p&gt;
&lt;p&gt;　　会有不同。vip会员可能会特殊对待，会有单独的人在处理vip会员的事情。但是他们都是会员。再比如一些客户可能需要专门的账单、&lt;/p&gt;
&lt;p&gt;　　付款条件和基于业务量的特别互动。我们可能安排最好的财务代表、甚至特别的经理负责一个或多个客户，以专门处理他们的独特需求。&lt;/p&gt;
&lt;p&gt;　　这样将减少执行绝大多数的计费功能所需的知识量，从而服务好广大客户。&lt;/p&gt;
&lt;p&gt;　　Z轴分割是成本最高的分割方向，Z轴分割有助于提高交易和数据的可扩展性，如果实施得当也有助于扩展指令集和过程&lt;/p&gt;

&lt;p&gt;好下面列举一下按三个轴划分的例子&lt;/p&gt;
&lt;p&gt;　　X轴一般就是负载均衡，比如用F5等硬件设备进行端口轮训负载。&lt;/p&gt;
&lt;p&gt;　　Y轴主要体现在我们按业务拆分服务，比如登录服务，订单服务等&lt;/p&gt;
&lt;p&gt;　　Z轴主要是对一些有特殊要求的业务执行单独流程处理，比如按地区提供对应地区客户的服务，根据不同地区不同客户群的生活习惯等进行差异化服务。 &lt;/p&gt;
&lt;p&gt;　　下面的图会直观一点&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/560839/201808/560839-20180813111557018-63817486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　AKF扩展立方体XYZ三个轴可以根据实际情况酌情使用其中一个两个或三个都是用，并且三个轴既可以无限向下扩展也可以无限向上扩展。&lt;/p&gt;
&lt;p&gt;我们在设计系统架构的时候可以将AKF扩展立方体作为理论指导，设计完之后回过头来看看是否可以做相应的扩展。&lt;/p&gt;


</description>
<pubDate>Mon, 13 Aug 2018 06:37:00 +0000</pubDate>
<dc:creator>zygfengyuwuzu</dc:creator>
<og:description>近几年的的微服务概念大火特火，随之框架也变得大火起来，尤其是spring boot，可能是因为spring cloud火起来的原因 搞得沉寂多年的dubbo也开始更新变得火起来。 说起微服务对于不了解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhyg/p/9466998.html</dc:identifier>
</item>
<item>
<title>《React Native 精解与实战》书籍连载「React Native 底层原理」 - Parry</title>
<link>http://www.cnblogs.com/parry/p/react_native_book_react_native_principle.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/parry/p/react_native_book_react_native_principle.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_3f2f3f5e94fc9d492a63a436de553ac2.png&quot; alt=&quot;截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此文是我的出版书籍&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;《React Native 精解与实战》&lt;/a&gt;连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、React Native 组件布局、组件与 API 的介绍与代码实战，以及 React Native 与 iOS、Android 平台的混合开发底层原理讲解与代码实战演示，精选了大量实例代码，方便读者快速学习。&lt;/p&gt;
&lt;p&gt;书籍还配套了视频教程「80 节实战课精通 React Native 开发」，此视频课程建议配合书籍学习，书籍中原理性的东西讲解的比较清晰，而视频教程对于组件、API 等部分的代码实战开发讲解比较直观。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;书籍相关所有资料请访问：&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;http://rn.parryqiu.com&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本章将深入讲解 React Native 的底层原理，万丈高楼平地起，非常深入地理解 React Native 底层的实现，在你开发或遇到难题调试时非常有帮助。&lt;br/&gt;此部分包含 React Native 的框架构成、工作原理、UI 层的渲染与重绘以及组件间通信、React Native 与各个平台的通信实现以及 React Native 中的生命周期。&lt;br/&gt;如果需要直接开始 React Native 的开发与实战，请直接跳至第四章开始学习。&lt;/p&gt;

&lt;p&gt;React Native 框架内部已提供了很多的内置组件，如图 3-1 所示。如 View、Text 等基本组件，用于一些功能布局的 Button、Picker 等，用于列表展示的各种 List 组件和对应 iOS 平台与 Android 平台的特定组件、API 等。同时也提供了供编写与原生平台交互的接口，在后续的章节我们会进行与原生平台的混合实战开发实战。&lt;br/&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_0bba6b67b995c71fc7a571216ccd1697.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 3-1 React Native 框架构成&lt;/p&gt;

&lt;p&gt;在 React 框架介绍的章节，我们理解了如何将代码渲染至虚拟 DOM 并更新到真实 DOM 的过程。在 React Native 框架中，渲染到 iOS 平台与 Android 平台的过程如图 3-2 所示。&lt;br/&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_384ccb96356a5aa84af69507d387c12d.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 3-2 React Native 渲染&lt;br/&gt;在 React 框架中，JSX 源码通过 React 框架最终渲染到了浏览器的真实 DOM 中，而在 React Native 框架中，JSX 源码通过 React Native 框架编译后，通过对应平台的 Bridge 实现了与原生框架的通信。如果我们在程序中调用了 React Native 提供的 API，那么 React Native 框架就通过 Bridge 调用原生框架中的方法。&lt;br/&gt;因为 React Native 的底层为 React 框架，所以如果是 UI 层的变更，那么就映射为虚拟 DOM 后进行 diff 算法，diff 算法计算出变动后的 JSON 映射文件，最终由 Native 层将此 JSON 文件映射渲染到原生 App 的页面元素上，最终实现了在项目中只需要控制 state 以及 props 的变更来引起 iOS 与 Android 平台的 UI 变更。&lt;br/&gt;编写的 React Native代码最终会打包生成一个 main.bundle.js 文件供 App 加载，此文件可以在 App 设备本地，也可以存放于服务器上供 App 下载更新，后续章节讲解的热更新就会涉及到 main.bundle.js 位置的设置问题。&lt;/p&gt;

&lt;p&gt;在与原生框架通信中，如图 3-3 所示，React Native 采用了 JavaScriptCore 作为 JS VM，中间通过 JSON 文件与 Bridge 进行通信。而如果在使用 Chrome 浏览器进行调试时，那么所有的 JavaScript 代码都将运行在 Chrome 的 V8 引擎中，与原生代码通过 WebSocket 进行通信。&lt;br/&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_813802c7db7e31befd54e9b960cc6d15.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;图 3-3 React Native 与原生平台的通信&lt;br/&gt;关于 React Native 框架与原生平台的通信原理的详细介绍，后续的混合开发章节将会有详细的讲解与实战开发。&lt;/p&gt;

&lt;p&gt;React Native 开发最基本的元素就是组件，React Native 与 React 一样，也会涉及到组件之间的通信，用于数据在组件之间的传递，下面列出了几种常用的组件间通信的方式。&lt;/p&gt;
&lt;h2 id=&quot;父子组件的通信&quot;&gt;父子组件的通信&lt;/h2&gt;
&lt;p&gt;如同之前的章节介绍 React 组件间传递参数一样，在 React Native 中，父组件向子组件传递值，可以通过 props 的形式。&lt;br/&gt;在下例中，父组件通过调用子组件并赋值子组件的 name 为 React，子组件通过 this.props.name 获取父组件传递过来的 name 的字符串值 React。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;完整代码在本书配套源码的 03-04 文件夹。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
* 章节: 03-04
* 父子组件通信，在父组件中调用子组件
* FilePath: /03-04/parent-2-child.js
* @Parry
*/

&amp;lt;ChildComponent name='React'/&amp;gt;

/**
* 章节: 03-04
* 子组件实现，通过 props 获取父页面传递的值
* FilePath: /03-04/parent-2-child.js
* @Parry
*/

class ChildComponent extends Component {
    render() {
        return (
          &amp;lt;Text&amp;gt;Hello {this.props.name}!&amp;lt;/Text&amp;gt;
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;子父组件的通信&quot;&gt;子父组件的通信&lt;/h2&gt;
&lt;p&gt;在开发过程中，不仅有父子之间的通信，有时还会有子组件向父组件通信传递值的需求，比如当子组件的某个值变更后，需要通知到父组件做相应的变更与响应，那么就会需要子父组件之间的通信。&lt;br/&gt;示例代码如下，在父组件的定义中，在调用子组件时，同样向子组件传递了一个参数，不过这个参数是一个函数，此函数用于接收后续子组件向父组件传递过来的数据，与之前父组件向子组件传递数据不太一样。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;完整代码在本书配套源码的 03-04 文件夹。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
* 章节: 03-04
* 子父组件通信，父组件的实现
* FilePath: /03-04/child-2-parent.js
* @Parry
*/
import React, {Component} from 'react';
import ChildComponent from './ChildComponent'

class App extends Component {
  constructor(props) {
    super(props)
    this.state = {
      name: 'React'
    }
  }

  //传递到子组件的参数，不过参数是一个函数。
  handleChangeName(nickName) {
    this.setState({name: nickName})
  }

  render() {
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;父组件的 name：{this.state.name}&amp;lt;/p&amp;gt;
        &amp;lt;ChildComponent
          onChange={(val) =&amp;gt; {
          this.handleChangeName(val)
        }}/&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

export default App;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面为子组件的定义，子组件在页面中定义了一个按钮，点击此按钮后，调用自身的一个函数 handleChange，修改了自身 state 中的值 name 为 nickName 定义的值 Parry，那么此子组件的页面上的字符串将由之前的 Hello React! 变为 Hello Parry!，同时使用了 this.props.changeName，也就是父组件调用时传递过来的函数，向父组件传递了 nickName 的值 Parry。&lt;br/&gt;父组件在接收到子组件的调用后，调用了父组件自身的函数 handleChangeName 修改了自身的 state 中的 name 的值为 Parry，也就是子组件传递过来的 Parry，所以同时，父组件的页面上的值也同时由之前的 React 变更成了 Parry。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
* 章节: 03-04
* 子父组件通信，子组件的实现
* FilePath: /03-04/child-2-parent.js
* @Parry
*/

import React, {Component} from 'react'

export default class ChildComponent extends Component {
  constructor(props) {
    super(props)

    this.state = {
      name: 'React'
    }
  }

  handleChange() {
    const nickName = 'Parry';
    this.setState({name: nickName})
    //调用父组件传递过来的函数参数，传递值到父组件去。
    this
      .props
      .changeName(nickName)
  }

  render() {
    const {name} = this.state;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;Hello {name}!&amp;lt;/p&amp;gt;
        &amp;lt;Button
          onPress={this
          .handleChange
          .bind(this)}
          title=&quot;修改一下 name 为 Parry&quot;/&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多级组件之间的通信&quot;&gt;多级组件之间的通信&lt;/h2&gt;
&lt;p&gt;如果组件之间的父子层级非常多，需要进行组件之间的传递，这时候当然可以通过上面介绍的方法进行一级一级的传递，但是当这种组件间层级很深的时候，这样的传递方法不是一个太好的方法。&lt;br/&gt;解决的方法是首先要在设计 App 时，需要注意不能让组件之间的层级关系太深，一是为了避免组件之间通信的冗长，还有一个原因是太深的嵌套逻辑，用户体验上也不会很好，可以想象一下用户从最底层一层层操作返回到最顶层时的体验。&lt;br/&gt;第二就是可以使用如 context 对象或 global 等方式进行多级组件间的通信，但是这种方式不推荐。&lt;/p&gt;
&lt;h2 id=&quot;无直接关系组件间通信&quot;&gt;无直接关系组件间通信&lt;/h2&gt;
&lt;p&gt;前面提到的都是有层级关系的组件间的通信方式，而如果组件间没有层级的关系的话，可以通过如 AsyncStorage 或 JSON 文件等方式进行无直接关系组件间的通信。&lt;br/&gt;当然，还可以使用 EventEmitter / EventTarget / EventDispatcher继承或实现接口的方式、Signals 模式或 Publish / Subscribe 的广播形式，都可以达到无直接关系组件间的通信。&lt;br/&gt;这些组件间的通信方式使得组件之间的数据可以传递起来，后续的实战章节会有详细的代码实现，这里主要进行了理论部分的介绍。掌握这部分知识后才可以将 App 开发中的基本单位，也就是组件串联起来。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_cf4439fab2847223afa0ec56f777501b.png&quot; alt=&quot;截图&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Aug 2018 06:35:00 +0000</pubDate>
<dc:creator>Parry</dc:creator>
<og:description>此文是我的出版书籍[《React Native 精解与实战》](http://rn.parryqiu.com/)连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/parry/p/react_native_book_react_native_principle.html</dc:identifier>
</item>
</channel>
</rss>