<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>类加载机制与反射 - yumiaoxa</title>
<link>http://www.cnblogs.com/yumiaoxia/p/9043776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yumiaoxia/p/9043776.html</guid>
<description>&lt;h2&gt;一. 类的加载，连接，初始化&lt;/h2&gt;
&lt;h3&gt;  1.1. JVM和类&lt;/h3&gt;
&lt;p&gt;当调用Java命令运行某个Java程序时，该命令将会启动一个Java虚拟机进程。不管Java程序多么复杂，启动多少个线程，它们都处于该Java虚拟机进程里，都是使用同一个Java进程内存区。&lt;/p&gt;
&lt;p&gt;JVM程序终止的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序运行到最后正常结束&lt;/li&gt;
&lt;li&gt;程序运行到使用System.exit()或Runtime.getRuntime().exit()代码处结束程序&lt;/li&gt;
&lt;li&gt;程序执行过程中遇到未捕获的异常或错误而结束&lt;/li&gt;
&lt;li&gt;程序所在平台强制结束了JVM进程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM进程结束，该进程所在内存中的状态将会丢失&lt;/p&gt;
&lt;h3&gt;  1.2 类的加载&lt;/h3&gt;
&lt;p&gt;当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化三个步骤来对该类进行初始化。&lt;/p&gt;
&lt;p&gt;类的加载时将该类的class文件读入内存，并为之创建一个java.lang.Class对象，也就是说，当程序使用任何类时，系统都会为之建立一个java.lang.Class对象。&lt;/p&gt;
&lt;p&gt;系统中所有的类实际上也是实例，它们都是java.lang.Class的实例&lt;/p&gt;
&lt;p&gt;类的加载通过JVM提供的类加载器完成，类加载器时程序运行的基础，JVM提供的类加载器被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。&lt;/p&gt;
&lt;p&gt;通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从本地文件系统加载class文件，这是前面绝大部分实例程序的类加载方式&lt;/li&gt;
&lt;li&gt;从jar包加载class文件，这种方式也是很常见的，jdbc编程所用的驱动类就放在jar文件中，JVM可以直接从jar文件中加载该class文件。&lt;/li&gt;
&lt;li&gt;通过网络加载class文件&lt;/li&gt;
&lt;li&gt;把一个Java源文件动态编译，并执行加载&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;类加载器通常无需等到首次使用该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。&lt;/p&gt;
&lt;p&gt;  1.3 类的连接&lt;/p&gt;
&lt;p&gt;当类被加载后，系统会为之生成一个对应的Class对象，接着会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类的链接可分为如下三个阶段。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致&lt;/li&gt;
&lt;li&gt;准备：类准备阶段则负责为类的类变量分配内存，并设置默认初始值&lt;/li&gt;
&lt;li&gt;解释：将类的二进制数据中的变量进行符号引用替换成直接引用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  1.4 类的初始化&lt;/p&gt;
&lt;p&gt;再累舒适化阶段，虚拟机负责对类进行初始化，主要就是对类变量进行初始化。在Java类中对类变量指定初始值有两种方式：&lt;strong&gt;①声明类变量时指定初始值；②使用静态初始化块为类变量指定初始值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM初始化一个类包含如下步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加载并连接该类&lt;/li&gt;
&lt;li&gt;先初始化其直接父类&lt;/li&gt;
&lt;li&gt;依次执行初始化语句&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当执行第2步时，系统对直接父类的初始化也遵循1~3,以此类推&lt;/p&gt;
&lt;h3&gt;  1.5 类初始化时机&lt;/h3&gt;
&lt;p&gt;当Java程序首次通过下面6种方式使用某个类或接口时，系统会初始化该类或接口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建类的实例。创建类的实例包括new操作符来创建实例，通过反射来创建实例，通过反射实例化创建实例&lt;/li&gt;
&lt;li&gt;调用某个类的类方法（静态方法）&lt;/li&gt;
&lt;li&gt;访问某个类或接口的类变量或为该类变量赋值&lt;/li&gt;
&lt;li&gt;使用反射方式来强制来创建某个类或接口的java.lang.Class对象。例如代码“Class.forname(&quot;Person&quot;)”,如果系统还未初始化Person类，则这行代码会导致Person类被初始化，并返回person类的java.lang.Class对象&lt;/li&gt;
&lt;li&gt;初始化某个类的子类&lt;/li&gt;
&lt;li&gt;使用java.exe命令来运行某个主类。当运行某个主类时，程序会初始化该主类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;二. 类加载器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  2.1类加载器介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;类加载器负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。&lt;/p&gt;
&lt;p&gt;一个载入JVM的类有一个唯一的标识。在Java中，一个类使用全限定类名（包括包名和类名）作为标识；但在JVM中，一个类使用全限定类名和其类加载器作为唯一标识。&lt;/p&gt;
&lt;p&gt;当JVM启动时，会形成由三个类加载器组成的初始类加载器层次结构&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap ClassLoader：跟类加载器&lt;/li&gt;
&lt;li&gt;Extension ClassLoader：扩展类加载器&lt;/li&gt;
&lt;li&gt;System ClassLoader：系统类加载器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Bootrap ClassLoader被称为引导（也称为原始或跟）类加载器，它负责加载Java的核心类。跟类加载器不是java.lang.ClassLoader的子类，而是JVM自身实现的。&lt;/p&gt;
&lt;p&gt;Extension ClassLoader负责加载JRE拓展目录中的JAR包的类，它的父类加载器是跟类加载器&lt;/p&gt;
&lt;p&gt;System ClassLoader，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class,path系统属性，或CLASSPATH指定的jar包和类历经。系统可通过ClassLoader的静态方法或区该系统类加载器。如果没有特别指定，则用户自定义的类加载器都已类加载器作为父加载器&lt;/p&gt;
&lt;h3&gt;  2.2 类加载机制&lt;/h3&gt;
&lt;p&gt;JVM类加载机制主要有三种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全盘负责。就是当类加载器负责加载某个Class时，该Class所依赖的和所引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入&lt;/li&gt;
&lt;li&gt;父类委托。所谓父类委托，就是先让父类加载器试图加载该Class。只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类&lt;/li&gt;
&lt;li&gt;缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序需要使用时，先从缓存中搜索该Class，当缓存中不存在该Class，系统菜才读取该类对应的二进制数据，并将其转为Class对象，存入缓存区中。这就是为什么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类加载器加载Class大致经过8个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检测此Class是否载入过（即缓存区中是否有此Class),如果有则直接进入第8步，否者接着第2步&lt;/li&gt;
&lt;li&gt;如果父类加载器（父类      gt+ 加载器，要么Parent一定是跟类加载器，要么本身就是跟类加载器）不存在，则调到第4步执行&lt;/li&gt;
&lt;li&gt;请求使用父类加载器载入目标类，如果成功载入调到第8步&lt;/li&gt;
&lt;li&gt;请求使用跟类加载器来载入目标类&lt;/li&gt;
&lt;li&gt;当前类加载器尝试寻找Class文件（从与此ClassLoader相关的类路径中寻找），如果找到则执行第6步，如果找不到执行第7步&lt;/li&gt;
&lt;li&gt;从文件中载入Class，成功载入调到第8步&lt;/li&gt;
&lt;li&gt;抛出ClassNotFoundException异常&lt;/li&gt;
&lt;li&gt;返回对应的java.lang.Class对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中，第5、6步允许重写ClassLoader的findClass()方法来实现自己的载入策略，甚至重写loadClass()方法来实现自己的载入过程。&lt;/p&gt;
&lt;h3&gt;  2.3 创建并使用自定义的类加载器&lt;/h3&gt;
&lt;p&gt;JVM除跟类加载器之外的所有类加载器都是ClassLoader子类的实例，开发者可以通过拓展ClassLoader的子类，并重写该ClassLoader所包含的方法实现自定义的类加载器。ClassLoader有如下两个关键方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;loadClass(String name,boolean resolve)：该方法为ClassLoader的入口点，根据指定名称来加载类，系统就是调用ClassLoader的该方法来获取指定类的class对象&lt;/li&gt;
&lt;li&gt;findClass(String name):根据指定名称来查找类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要是实现自定义的ClassLoader,则可以通过重写以上两个方法来实现，通常推荐重写findClass()方法而不是loadClass()方法。&lt;/p&gt;
&lt;p&gt;classLoader()方法的执行步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;findLoadedClass():来检查是否加载类，如果加载直接返回。&lt;/li&gt;
&lt;li&gt;父类加载器上调用loadClass()方法。如果父类加载器为null，则使用跟类加载器加载。&lt;/li&gt;
&lt;li&gt;调用findClass(String)方法查找类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面看出，重写findClass()方法可以避免覆盖默认类加载器的父类委托，缓冲机制两种策略；如果重写loadClass()方法，则实现逻辑更为复杂。&lt;/p&gt;
&lt;p&gt;ClassLoader的一些方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class defineClass(String name,byte[] b,int off,int len)：负责将字节码分析成运行时数据结构，并检验有效性&lt;/li&gt;
&lt;li&gt;findSystemClass(String name):从本地文件系统装入文件。&lt;/li&gt;
&lt;li&gt;static getSystemClassLoader():返回系统类加载器&lt;/li&gt;
&lt;li&gt;getParent():获取该类加载器的父类加载器&lt;/li&gt;
&lt;li&gt;resolveClass(Class&amp;lt;?&amp;gt; c)：链接指定的类&lt;/li&gt;
&lt;li&gt;findClassLoader(String name)：如果加载器加载了名为name的类，则返回该类对用的Class实例，否则返回null。该方法是类加载缓存机制的体现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面程序开发了一个自定义的ClassLoader。该classLoader通过重写findClass()方法来实现自定义的类加载机制。这个ClassLoader可以在加载类之前先编译该类的源文件，从而实现运行Java之前先编译该程序的目标，这样即可通过该classLoader运行Java源文件。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.basic;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CompileClassLoader &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ClassLoader {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] getBytes(String fileName) {
    File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(fileName);
    Long len &lt;/span&gt;=&lt;span&gt; file.length();
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] raw = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)len];
    
        FileInputStream fin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一次读取class文件的二进制数据&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; fin.read(raw);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(r !=&lt;span&gt; len) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IOException(&quot;无法读取文件&quot;+r+&quot;!=&quot;+&lt;span&gt;raw);
        
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
}
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; compile(String javaFile) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        System.out.println(&lt;/span&gt;&quot;正在编译&quot;+javaFile+&quot;...&quot;&lt;span&gt;);
        Process p &lt;/span&gt;= Runtime.getRuntime().exec(&quot;javac&quot;+&lt;span&gt;javaFile);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他线程都等待这线程完成&lt;/span&gt;
&lt;span&gt;            p.waitFor();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException ie) {
            System.out.println(ie);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret =&lt;span&gt; p.exitValue();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ret == 0&lt;span&gt;;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
        Class clazz &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        String findStub &lt;/span&gt;= name.replace(&quot;.&quot;, &quot;/&quot;&lt;span&gt;);
        String javaFileName &lt;/span&gt;= findStub+&quot;.java&quot;&lt;span&gt;;
        String classFileName &lt;/span&gt;= findStub+&quot;.class&quot;&lt;span&gt;;
        File javaFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(javaFileName);
        File classFile &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(classFileName);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但指定Java源文件存在，class文件不存在，或者Java源文件的修改时间比class文件修改的时间更晚时，重新编译&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(javaFile.exists() &amp;amp;&amp;amp;&lt;span&gt; classFile.exists()
                &lt;/span&gt;|| javaFile.lastModified() &amp;gt;&lt;span&gt; classFile.lastModified()) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!compile(javaFileName)|| !&lt;span&gt;classFile.exists()) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(&quot;ClassNotFoundExcetion&quot;+&lt;span&gt;javaFileName);
            }
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException ie) {
                ie.printStackTrace();
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(classFile.exists()) {
            
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] raw =&lt;span&gt; getBytes(classFileName);
                
                clazz &lt;/span&gt;= defineClass(name,raw,0&lt;span&gt;,raw.length);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果clazz为null,表明加载失败，则抛出异常&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(clazz == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException(name);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clazz;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果运行该程序时没有参数，即没有目标类&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (args.length&amp;lt;1&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;缺少目标类，请按如下格式运行Java源文件：&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;java CompileClassLoader ClassName&quot;&lt;span&gt;);
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数是需要运行的类&lt;/span&gt;
        String progClass = args[0&lt;span&gt;];
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;剩下的参数将作为运行目标类时的参数，将这些参数复制到一个新数组中&lt;/span&gt;
        String[] progArgs = &lt;span&gt;new&lt;/span&gt; String[args.length - 1&lt;span&gt;];
        System.arraycopy(args, &lt;/span&gt;1,progArgs,0&lt;span&gt;, progArgs.length);
        
        CompileClassLoader ccl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompileClassLoader();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载需要运行的类&lt;/span&gt;
        Class&amp;lt;?&amp;gt; clazz =&lt;span&gt; ccl.loadClass(progClass);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取运行时的类的主方法&lt;/span&gt;
        Method main = clazz.getMethod(&quot;main&quot;, (&lt;span&gt;new&lt;/span&gt; String[0&lt;span&gt;]).getClass());
        Object argsArray[] &lt;/span&gt;=&lt;span&gt; {progArgs};
        main.invoke(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, argsArray);
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来可以提供任意一个简单的主类，该主类无需编译就可以使用上面的CompileClassLoader来运行他&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.basic;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hello {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String arg:args) {
            System.out.println(&lt;/span&gt;&quot;运行Hello的参数：&quot;+&lt;span&gt;arg);
        }

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;无需编译该Hello.java,可以直接运行下面命令来运行该Hello.java程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
java CompileClassLoader hello 疯狂Java讲义
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CompileClassLoader:正常编译 Hello.java...
运行hello的参数：疯狂Java讲义&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用自定义的类加载器，可以实现如下功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行代码前自动验证数字签名&lt;/li&gt;
&lt;li&gt;根据用户提供的密码解密代码，从而可以实现代码混淆器来避免反编译*.class文件&lt;/li&gt;
&lt;li&gt;根据应用需求把其他数据以字节码的形式加载到应用中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;    2.4 URLClassLoader类&lt;/p&gt;
&lt;p&gt;该类时系统类加载器和拓展类加载器的父类（此处的父类，是指类与类之间的的继承关系）。URLClassLoader功能比较强大，它可以从本地文件系统获取二进制文件来加载类，也可以从远程主机获取二进制文件加载类。&lt;/p&gt;
&lt;p&gt;该类提供两个构造器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;URLClassLoader(URL[] urls)：使用默认的父类加载器创建一个ClassLoader对象，该对象将从urls所指定的路径来查询并加载类&lt;/li&gt;
&lt;li&gt;URLClassLoader(URL[] urls,ClassLoader prarent)：使用指定的父类加载器创建一个ClassLoader对象，该对象将从urls所指定的路径来查询并加载类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面程序示范了如何从文件系统中加载MySQL驱动，并使用该驱动获取数据库连接。通过这种方式来获取数据库连接，无需将MySQL驱动添加到CLASSPATH中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.gdut;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URL;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URLClassLoader;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Connection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.Driver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; URLClassLoaderTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Connection conn;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Connection getConn(String url,String user,String pass)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(conn == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            URL[] urls &lt;/span&gt;= {&lt;span&gt;new&lt;/span&gt; URL(&quot;file:mysql-connection-java-5.1.46-bin.jar&quot;&lt;span&gt;)};
            URLClassLoader myClassLoader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URLClassLoader(urls);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载MySQL，并创建实例&lt;/span&gt;
            Driver driver = (Driver)myClassLoader.loadClass(&quot;com.mysql.jdbc.Driveer&quot;&lt;span&gt;).newInstance();

            Properties properties &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
            properties.setProperty(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
            properties.setProperty(&lt;/span&gt;&quot;pass&quot;&lt;span&gt;,pass);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用driver的connect方法来取得数据库连接&lt;/span&gt;
            conn =&lt;span&gt; driver.connect(url,properties);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(getConn(&lt;/span&gt;&quot;jdbc:mysql://localhost:3306/tb_test&quot;,&quot;sherman&quot;,&quot;a123&quot;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本程序类加载器的加载路径是当前路径下的mysql-connection-java-5.1.46-bin.jar文件，将MySQL驱动复制到该路径下，这样保证ClassLoader可以正常加载到驱动类&lt;/p&gt;
&lt;h2&gt;三. 通过反射查看类信息&lt;/h2&gt;
&lt;p&gt;Java程序中的许多对象在运行时都会出现收到外部传入的一个对象，该对象编译时类型是Object，但程序又需要调用该对象运行时的方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种做法是假设编译时和运行时都知道该对象的的类型的具体信息，这种情况下，可以先用instanceof()运算符进行判断，再利用强制类型转换将其转换成运行时类型的变量即可&lt;/li&gt;
&lt;li&gt;第二种做法是编译时根本无法知道该对象和类可能属于那些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;  3.1 获得class对象&lt;/h3&gt;
&lt;p&gt;每个类被加载后，系统会为该类生成一个对应的Class对象，通过该Class对象可以访问到JVM中的这个类。获得Class对象通常三种方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用Class类的forName(String clazz)静态方法。字符串参数传入全限定类名（必须添加包名），可能会抛出ClassNotFoundexception异常。&lt;/li&gt;
&lt;li&gt;调用某个类的class属性来获取该类的的Class对象。&lt;/li&gt;
&lt;li&gt;调用某个对象的getClass()方法，该方法是Object类的一个方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于第一种方式，第二种的优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码更安全。程序在编译阶段就可以检查需要访问的Class对象是否存在。&lt;/li&gt;
&lt;li&gt;程序性能更好。这的种方式无需调用方法，所以性能更好。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;  3.2 从Class中获取信息&lt;/h3&gt;
&lt;p&gt;Class类提供了大量的实例方法获取该Class对象所对应类的详细信息&lt;/p&gt;
&lt;p&gt;下面4个方法用于获取Class对象对应类的构造器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConStructor&amp;lt;T&amp;gt; getConStructor(Class&amp;lt;?&amp;gt; parameterTypes)：返回Class对象对应类的，带指定参数列表的public构造器&lt;/li&gt;
&lt;li&gt;ConStructor&amp;lt;?&amp;gt;[] getConStructor()：返回此Class对象对应类的所有public构造器&lt;/li&gt;
&lt;li&gt;ConStructor&amp;lt;T&amp;gt; getDeclaredConStructor(Class&amp;lt;?&amp;gt;... parameterTypes)：返回此Class对象对应类的、带指定参数列表的构造器，与构造器的访问权限无关&lt;/li&gt;
&lt;li&gt;ConStructor&amp;lt;?&amp;gt;[] getDeclaredConStructor()：返回此Class对象对应类的所有构造器，与构造器的访问权限无关&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面四个方法获取Class对象对应类所包含方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Method getMethod(String name,Class&amp;lt;?&amp;gt; parameterTypes)：返回Class对象对应类的,带指定形参列表的public方法&lt;/li&gt;
&lt;li&gt;Method[] getMethods()：返回Class对象对应类的所有public方法&lt;/li&gt;
&lt;li&gt;Method getDeclaredMethod(String name,Class&amp;lt;?&amp;gt; parameterTypes)：返回Class对象对应类的,带指定形参列表的方法,与访问权限无关&lt;/li&gt;
&lt;li&gt;Method[] getDeclaredMethods()：返回Class对象对应类的所有全部方法，与方法的访问权限无关&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面四个方法获取Class对象对应类所包含的成员变量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Field getField(String name)：返回Class对象对应类的,指定名称的public成员变量&lt;/li&gt;
&lt;li&gt;Field[] getFIelds()：返回Class对象对应类的所有public成员变量&lt;/li&gt;
&lt;li&gt;Field getDeclaredField(String name)：返回Class对象对应类的,指定名称的成员变量，与成员的访问权限无关&lt;/li&gt;
&lt;li&gt;Field[] getFIelds()：返回Class对象对应类的所有成员变量,与成员的访问权限无关&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下几个方法用于访问Class对应类的上所包含的Annotation.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&amp;lt;A extends Annotation&amp;gt;A getAnnotation(Class&amp;lt;A&amp;gt; annotationClass):尝试获取该Class对象对应类存在的，指定类型的Annotation；如果该类型的注解不存在，则返回null。&lt;/li&gt;
&lt;li&gt;&amp;lt;A extends Annotation&amp;gt;A getDeclaredAnnotation(Class&amp;lt;A&amp;gt; annotationClass):Java 8新增方法，尝试获取直接修饰该Class对象对应类存在的，指定类型的Annotation；如果该类型的注解不存在，则返回null。&lt;/li&gt;
&lt;li&gt;Annotation[] getAnnotations()：获取该Class对象对应类存在的所有Annotation&lt;/li&gt;
&lt;li&gt;Annotation[] getDiclaredAnnotations()：获取直接修饰该Class对象对应类存在的所有Annotation&lt;/li&gt;
&lt;li&gt;&amp;lt;A extends Annotation&amp;gt;A[] getAnnotationByType(Class&amp;lt;A&amp;gt; annotationClass):由于Java 8的新增了重复注解功能，因此需要使用该方法获取修饰该Class对象对应类，指定类型的多个Annotation&lt;/li&gt;
&lt;li&gt;&amp;lt;A extends Annotation&amp;gt;A[] getDeclaredAnnotationByType(Class&amp;lt;A&amp;gt; annotationClass):由于Java 8的新增了重复注解功能，因此需要使用该方法获取直接修饰该类的，指定类型的多个Annotation&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下方法用于访问Class对应类的内部类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class&amp;lt;?&amp;gt;[] getDeclaredClass()：返回该Class对象对应类里包含的内部类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下方法用于访问Class对应类的所在的外部类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class&amp;lt;?&amp;gt;[] getDeclaringClass()：返回该Class对象对应类所在的外部类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下方法用于访问Class对应类的所实现的接口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class&amp;lt;?&amp;gt;[] getInterfaces():返回该Class对象对应类的所实现的接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下方法用于访问Class对应类的所继承的父类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class&amp;lt;? super T&amp;gt; getSuperClass()：返回该Class对象对应类的超类的Class对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下方法用于访问Class对应类的修饰符，所在包，类名等基本信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;int getModifiers()：返回此类或接口的所有修饰符对应的常量，返回的整数需要Modifier工具类的方法来解码，才可以获取真正的修饰符&lt;/li&gt;
&lt;li&gt;Package getPackage()：获取此类的包&lt;/li&gt;
&lt;li&gt;String getName()：以字符串的形式返回该Class对象对应类的类名&lt;/li&gt;
&lt;li&gt;String getSimpleName()：以字符串的形式返回该Class对象对应类的简称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下几个方法来判断该类是否为接口、枚举、注解类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;boolean isAnnotation()：返回此Class对象是否表示一个注解类型（有@interface定义）&lt;/li&gt;
&lt;li&gt;boolean isAnnotationPresent(Class&amp;lt;? extends Annotation&amp;gt;annotationClass):判断此Class对象是否使用了注解修饰&lt;/li&gt;
&lt;li&gt;boolean isAnonymousClass()：返回此Class对象是否为匿名类&lt;/li&gt;
&lt;li&gt;boolean isArray()：返回此Class对象是否为数组类&lt;/li&gt;
&lt;li&gt;boolean isEnum()：返回此Class对象是否为枚举类&lt;/li&gt;
&lt;li&gt;boolean isInterface()：返回此Class对象是否为接口&lt;/li&gt;
&lt;li&gt;boolean isInstance(Object obj)：判断obj是否为该Class对象的实例，该方法可以替代instanceof操作符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上getMethod()方法和getConStructor()方法中，都需要传入多个类型为Class&amp;lt;?&amp;gt;的参数，用于获取指定的方法和构造器。要确定一个方法应该由方法名和形参列表确定。例如下面代码获取clazz对应类的带一个String参数的info方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
clazz.getMethods(&quot;info&quot;,String.&lt;span&gt;class&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  若要获取clazz对应类的带一个String参数，一个Integer参数的info方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
clazz.getMethods(&quot;info&quot;,String.&lt;span&gt;class&lt;/span&gt;,Integer.&lt;span&gt;class&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;  3.3 Java 8新增加的方法参数反射&lt;/h3&gt;
&lt;p&gt;Java 8新增了一个Executable抽象基类，该对象代表可执行的类成员，该类派生了Constructor和Method两个子类。&lt;/p&gt;
&lt;p&gt;Executable抽象基类提供了大量方法来获取修饰该方法或构造器的注解信息；还提供了is VarArgs()方法用于判断该方法或构造器是否包含数量可变的形参，以及通过getModifiers()方法获取该方法或构造器的修饰符。除此之外，还提供如下两个方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;int getParameterCount()：获取该构造器或方法的形参个数&lt;/li&gt;
&lt;li&gt;Parameter[] getParameters()：获取该构造器或方法的所有形参&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Parameter类是Java 8新增的api，提供了大量方法来获取声明该方法或参数个数的泛型信息，还提供了如下方法获取参数信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getModifiers()：获取修饰该形参的修饰符&lt;/li&gt;
&lt;li&gt;String getName()：获取形参名&lt;/li&gt;
&lt;li&gt;Type getParameterizedType()：获取带泛型的形参类型&lt;/li&gt;
&lt;li&gt;Class&amp;lt;?&amp;gt; getType()：获取形参类型&lt;/li&gt;
&lt;li&gt;boolean isNamePresent()：该方法返回该类的class文件中是否包含了方法的形参名信息&lt;/li&gt;
&lt;li&gt;boolean isVarArgs()：判断该参数是否为个数可变的形参&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要指出的是，使用javac命令编译Java源文件时，默认生成的class文件并不包含方法的形参名信息，因此调用isNamePresent()将返回false，调用getName()也不能得到该参数的形参名。需要编译时保留形参信息，则需要该命令指定-parameter选项。&lt;/p&gt;
&lt;p&gt;下面示范了Java 8的参数反射功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MethodParameterTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Class&lt;/span&gt;&amp;lt;Test&amp;gt; clazz = Test.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Method replace &lt;/span&gt;= clazz.getMethod(&quot;replace&quot;,String.&lt;span&gt;class&lt;/span&gt;,List.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;replace方法的参数个数为：&quot;+&lt;span&gt;replace.getParameterCount());

        Parameter[] parameters &lt;/span&gt;=&lt;span&gt; replace.getParameters();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Parameter parameter:parameters){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;parameter.isNamePresent()){
                System.out.println(&lt;/span&gt;&quot;-----第&quot;+index+&quot;行的参数信息-----&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;参数名：&quot;+&lt;span&gt;parameter.getName());
                System.out.println(&lt;/span&gt;&quot;形参类型：&quot;+&lt;span&gt;parameter.getType());
                System.out.println(&lt;/span&gt;&quot;泛型类型：&quot;+&lt;span&gt;parameter.getParameterizedType());
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157286/201805/1157286-20180516130050446-1379027305.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;  3.4 利用反射生成并操作对象&lt;/h3&gt;
&lt;p&gt;Class对象可以获得该类的方法，构造器，成员变量。程序可以通过Method对象来执行对应的方法，通过ConStructor对象调用对应的构造器创建实例，能通过Field对象直接访问并修改对象的成员变量值。&lt;/p&gt;
&lt;h4&gt;3.4.1 创建对象&lt;/h4&gt;
&lt;p&gt;通过反射生成对象有两种方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该Class对象的对应类有默认构造器。&lt;/li&gt;
&lt;li&gt;先使用Class对象获取指定的Constructor对象，在调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3.4.2 调用方法&lt;/h4&gt;
&lt;p&gt;可以通过Class对象的getMethods()方法和getMethod()方法来获取全部方法和指定方法。&lt;/p&gt;
&lt;p&gt;每个Method对象对应一个方法，可以通过它调用对应的方法，在Method里包含一个invoke()方法，该方法的签名如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Object invoke(Object obj,Object... args)：该方法中的obj是执行该方法的主调，后面的args是执行该方法时传入该方法的实参。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面程序是对象池工厂加强版，它允许在配置文件中增加配置对象的成员变量的值，对象池工厂会读取为该对象配置的成员变量值，并利用该对象的Setter方法设置成员变量的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gdut.test0516;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.FileInputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExtendedObjectPoolFactory {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个对象池，前面是对象名，后面是实际对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; objectPool = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Properties config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(String fileName)
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(FileInputStream fis = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(fileName))
        {
            config.load(fis);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(IOException ex){
            System.out.println(&lt;/span&gt;&quot;读取&quot;+fileName+&quot;异常&quot;&lt;span&gt;);
        }
    }

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Object createObject(String clazzName)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException,
           InstantiationException,IllegalAccessException{
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(clazzName);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用clazz默认构造器创建实例&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; clazz.newInstance();
   }


   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initPool()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException,
           InstantiationException,IllegalAccessException{
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name:config.stringPropertyNames())
       {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没取出一个key-value对。如果key中不包含百分号（%），即可认为该key用于
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 控制调用对象的setter方法设置值，%前半为对象名字，后半控制setter方法名&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;( !name.contains(&quot;%&quot;&lt;span&gt;)){
           objectPool.put(name,createObject(config.getProperty(name)));
       }
       }
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getObject(String name){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objectPool.get(name);
   }

   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initProperty()&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException,
   IllegalAccessException,InvocationTargetException {
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String name:config.stringPropertyNames()) {
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(name.contains(&quot;%&quot;&lt;span&gt;)){
               String[] objAndProp &lt;/span&gt;= name.split(&quot;%&quot;&lt;span&gt;);
               Object target &lt;/span&gt;= getObject(objAndProp[0&lt;span&gt;]);
               String mtdName &lt;/span&gt;= &quot;set&quot;+objAndProp[1].substring(1&lt;span&gt;);
               Class&lt;/span&gt;&amp;lt;?&amp;gt; targetClass =&lt;span&gt; target.getClass();
               Method mtd &lt;/span&gt;=&lt;span&gt; targetClass.getMethod(mtdName);
               mtd.invoke(target,config.getProperty(name));
           }
       }
   }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ExtendedObjectPoolFactory epf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtendedObjectPoolFactory();
        epf.init(&lt;/span&gt;&quot;com/gdut/test0516/extObj.txt&quot;&lt;span&gt;);
        epf.initPool();
        epf.initProperty();
        System.out.println(epf.getObject(&lt;/span&gt;&quot;a&quot;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;  3.4.3 访问成员变量&lt;/h4&gt;
&lt;p&gt;通过Class对象的getFields()方法和getField()方法可以获取该类包含的所有成员变量和指定成员变量。Field提供如下方法读取或设置成员变量值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getXxx(Object obj)：获取Object对象的成员变量值。此处的Xxx对应8种基本类型，如果该成员变量类型时引用类型，则取消get后面的Xxx。&lt;/li&gt;
&lt;li&gt;setXxx(Object obj,Xxx val)：将obj对象的该成员变量设置成val值。此处的Xxx对应8种基本类型，如果该成员变量类型时引用类型，则取消set后面的Xxx。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.4.4 操作数组&lt;/p&gt;
&lt;p&gt;在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用该类来创建数组，操作数组元素等。&lt;/p&gt;
&lt;p&gt;Array提供如下方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;static Object newInstance(Class&amp;lt;?&amp;gt;ComponentType,int... length)：创建一个具有指定的元素类型，指定维度的新数组&lt;/li&gt;
&lt;li&gt;static xxx getXxx(Object array,int index)：返回数组array的第index个元素。此处的xxx对应8种基本类型，如果数组元素是引用类型，则该方法变为get(Object array,int index)。&lt;/li&gt;
&lt;li&gt;static void setXxx(Object array,int index,Object val)：将数组array的第index个元素设置为val。此处的xxx对应8种基本类型，如果数组元素是引用类型，则该方法变为set(Object array,int index,Object val)。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Wed, 16 May 2018 07:22:00 +0000</pubDate>
<dc:creator>yumiaoxa</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yumiaoxia/p/9043776.html</dc:identifier>
</item>
<item>
<title>Java 的字节流文件读取（一） - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/9046178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/9046178.html</guid>
<description>&lt;p&gt;上篇文章我们介绍了抽象化磁盘文件的 File 类型，它仅仅用于抽象化描述一个磁盘文件或目录，却不具备访问和修改一个文件内容的能力。&lt;/p&gt;
&lt;p&gt;Java 的 IO 流就是用于读写文件内容的一种设计，它能完成将磁盘文件内容输出到内存或者是将内存数据输出到磁盘文件的数据传输工作。&lt;/p&gt;
&lt;p&gt;Java IO 流的设计并不是完美的，设计了大量的类，增加了我们对于 IO 流的理解，但无外乎为两大类，一类是针对二进制文件的字节流，另一类是针对文本文件的字符流。而本篇我们就先来学习有关字节流的相关类型的原理以及使用场景等细节，主要涉及的具体流类型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/05/14/CrJwZt.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基类字节流-inputoutputstream&quot;&gt;基类字节流 Input/OutputStream&lt;/h3&gt;
&lt;p&gt;InputStream 和 OutputStream 分别作为读字节流和写字节流的基类，所有字节相关的流都必然继承自他们中任意一个，而它们本身作为一个抽象类，也定义了最基本的读写操作，我们一起来看看：&lt;/p&gt;
&lt;p&gt;以 InputStream 为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract int read() throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个抽象的方法，并没有提供默认实现，要求子类必须实现。&lt;strong&gt;而这个方法的作用就是为你返回当前文件的下一个字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，你也会发现这个方法的返回值是使用的整型类型「int」来接收的，为什么不用「byte」？&lt;/p&gt;
&lt;p&gt;首先，read 方法返回的值一定是一个八位的二进制，而一个八位的二进制可以取值的值区间为：&lt;strong&gt;「0000 0000，1111 1111」&lt;/strong&gt;，也就是范围 [-128,127]。&lt;/p&gt;
&lt;p&gt;read 方法同时又规定当读取到文件的末尾，即文件没有下一个字节供读取了，将返回值 &lt;strong&gt;-1&lt;/strong&gt; 。所以如果使用 byte 作为返回值类型，那么当方法返回一个 -1 ，我们该判定这是文件中数据内容，还是流的末尾呢？&lt;/p&gt;
&lt;p&gt;而 int 类型占四个字节，高位的三个字节全部为 0，我们只使用它的最低位字节，当遇到流结尾标志时，返回四个字节表示的 -1（32 个 1），这就自然的和表示数据的值 -1（24 个 0 + 8 个 1）区别开来了。&lt;/p&gt;
&lt;p&gt;接下来也是一个 read 方法，但是 InputStream 提供默认实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}

public int read(byte b[], int off, int len) throws IOException{
    //为了不使篇幅过长，方法体大家可自行查看 jdk 源码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个方法本质上是一样的，第一个方法是第二个方法的特殊形态，它允许传入一个字节数组，并要求程序将文件中读到的字节从数组索引位置 0 开始填充，供填充数组长度个字节数。&lt;/p&gt;
&lt;p&gt;而第二个方法更加宽泛一点，它允许你指定起始位置和字节总数。&lt;/p&gt;
&lt;p&gt;InputStream 中还有其他几个方法，基本都没怎么具体实现，留待子类实现，我们简单看看。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public long skip(long n)：跳过 n 个字节，返回实际跳过的字节数&lt;/li&gt;
&lt;li&gt;public void close()：关闭流并释放对应的资源&lt;/li&gt;
&lt;li&gt;public synchronized void mark(int readlimit)&lt;/li&gt;
&lt;li&gt;public synchronized void reset()&lt;/li&gt;
&lt;li&gt;public boolean markSupported()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;mark 方法会在当前流读取位置打上一个标志，reset 方法即重置读取指针到该标志处。&lt;/p&gt;
&lt;p&gt;事实上，文件读取是不可能重置回头读取的，而一般都是将标志位置到重置点之间所有的字节临时保存了，当调用 reset 方法时，其实是从保存的临时字节集合进行重复读取，所以 readlimit 用于限制最大缓存容量。&lt;/p&gt;
&lt;p&gt;而 markSupported 方法则用于确定当前流是否支持这种「回退式」读取操作。&lt;/p&gt;
&lt;p&gt;OutputStream 和 InputStream 是类似的，只不过一个是写一个是读，此处我们不再赘述了。&lt;/p&gt;
&lt;h3 id=&quot;文件字节流-fileinputoutputstream&quot;&gt;文件字节流 FileInput/OutputStream&lt;/h3&gt;
&lt;p&gt;我们依然着重点于 FileInputStream，而 FileOutputStream 是类似的。&lt;/p&gt;
&lt;p&gt;首先 FileInputStream 有以下几种构造器实例化一个对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public FileInputStream(String name) throws FileNotFoundException {
    this(name != null ? new File(name) : null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public FileInputStream(File file) throws FileNotFoundException {
    String name = (file != null ? file.getPath() : null);
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkRead(name);
    }
    if (name == null) {
        throw new NullPointerException();
    }
    if (file.isInvalid()) {
        throw new FileNotFoundException(&quot;Invalid file path&quot;);
    }
    fd = new FileDescriptor();
    fd.attach(this);
    path = name;
    open(name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个构造器本质上也是一样的，前者是后者的特殊形态。其实你别看后者的方法体一大堆代码，大部分都只是在做安全校验，核心的就是一个 open 方法，用于打开一个文件。&lt;/p&gt;
&lt;p&gt;主要是这两种构造器，如果文件不存在或者文件路径和名称不合法，都将抛出 FileNotFoundException 异常。&lt;/p&gt;
&lt;p&gt;记得我们说过，基类 InputStream 中有一个抽象方法 read 要求所有子类进行实现，而 FileInputStream 使用本地方法进行了实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int read() throws IOException {
    return read0();
}

private native int read0() throws IOException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 read0 的具体实现我们暂时无从探究，但是你必须明确的是，这个 read 方法的作用，它用于返回流中下一个字节，返回 -1 说明读取到文件末尾，已无字节可读。&lt;/p&gt;
&lt;p&gt;除此之外，FileInputStream 中还有一些其他的读取相关方法，但大多采用了本地方法进行了实现，此处我们简单看看：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public int read(byte b[])：读取 b.length() 个长度的字节到数组中&lt;/li&gt;
&lt;li&gt;public int read(byte b[], int off, int len)：读取指定长度的字节数到数组中&lt;/li&gt;
&lt;li&gt;public native long skip(long n)：跳过 n 的字节进行读取&lt;/li&gt;
&lt;li&gt;public void close()：释放流资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FileInputStream 的内部方法基本就这么些，还有一些高级的复杂的，我们暂时用不到，以后再进行学习，下面我们简单看一个文件读取的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) throws IOException {
    FileInputStream input = new FileInputStream(&quot;C:\\Users\\yanga\\Desktop\\test.txt&quot;);
    byte[] buffer = new byte[1024];
    int len = input.read(buffer);
    String str = new String(buffer);
    System.out.println(str);
    System.out.println(len);
    input.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果很简单，会打印出我们 test 文件中的内容和实际读出的字节数，但细心的同学就会发现了，你怎么就能保证 test 文件中内容不会超过 1024 个字节呢？&lt;/p&gt;
&lt;p&gt;为了能够完整的读出文件中的内容，一种解决办法是：将 buffer 定义的足够大，以期望尽可能的能够存储下文件中的所有内容。&lt;/p&gt;
&lt;p&gt;这种方法显然是不可取的，因为我们根本不可能实现知道待读文件的实际大小，一味的创建过大的字节数组其本身也是一种很差劲的方案。&lt;/p&gt;
&lt;p&gt;第二种方式就是使用我们的动态字节数组流，它可以动态调整内部字节数组的大小，保证适当的容量，这一点我们后文中将详细介绍。&lt;/p&gt;
&lt;p&gt;关于 FileOutputStream，还需要强调一点的是它的构造器，其中有以下两个构造器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public FileOutputStream(String name, boolean append)

public FileOutputStream(File file, boolean append)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数 append 指明了，此流的写入操作是覆盖还是追加，true 表示追加，false 表示覆盖。&lt;/p&gt;
&lt;h3 id=&quot;字节数组流-bytearrayinputoutputstream&quot;&gt;字节数组流 ByteArrayInput/OutputStream&lt;/h3&gt;
&lt;p&gt;所谓的「字节数组流」就是围绕一个字节数组运作的流，它并不像其他流一样，针对文件进行流的读写操作。&lt;/p&gt;
&lt;p&gt;字节数组流虽然并不是基于文件的流，但却依然是一个很重要的流，因为它内部封装的字节数组并不是固定的，而是动态可扩容的，往往基于某些场景下，非常合适。&lt;/p&gt;
&lt;p&gt;ByteArrayInputStream 是读字节数组流，可以通过以下构造函数被实例化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected byte buf[];
protected int pos;
protected int count;

public ByteArrayInputStream(byte buf[]) {
    this.buf = buf;
    this.pos = 0;
    this.count = buf.length;
}

public ByteArrayInputStream(byte buf[], int offset, int length)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;buf 就是被封装在 ByteArrayInputStream 内部的一个字节数组，ByteArrayInputStream 的所有读操作都是围绕着它进行的。&lt;/p&gt;
&lt;p&gt;所以，实例化一个 ByteArrayInputStream 对象的时候，至少传入一个目标字节数组的。&lt;/p&gt;
&lt;p&gt;pos 属性用于记录当前流读取的位置，count 记录了目标字节数组最后一个有效字节索引的后一个位置。&lt;/p&gt;
&lt;p&gt;理解了这一点，有关它各种的 read 方法就不难了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//读取下一个字节
public synchronized int read() {
    return (pos &amp;lt; count) ? (buf[pos++] &amp;amp; 0xff) : -1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//读取 len 个字节放到字节数组 b 中
public synchronized int read(byte b[], int off, int len){
    //同样的，方法体较长，大家查看自己的 jdk
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，ByteArrayInputStream 还非常简单的实现了「重复读取」操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void mark(int readAheadLimit) {
    mark = pos;
}

public synchronized void reset() {
    pos = mark;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 ByteArrayInputStream 是基于字节数组的，所有重复读取操作的实现就比较容易了，基于索引实现就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ByteArrayOutputStream 是写的字节数组流，很多实现还是很有自己的特点的，我们一起来看看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，这两个属性是必须的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected byte buf[];

//这里的 count 表示的是 buf 中有效字节个个数
protected int count;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ByteArrayOutputStream() {
    this(32);
}
    
public ByteArrayOutputStream(int size) {
    if (size &amp;lt; 0) {
        throw new IllegalArgumentException(&quot;Negative initial size: &quot;+ size);
    }
    buf = new byte[size];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造器的核心任务是，初始化内部的字节数组 buf，允许你传入 size 显式限制初始化的字节数组大小，否则将默认长度 32 。&lt;/p&gt;
&lt;p&gt;从外部向 ByteArrayOutputStream 写内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void write(int b) {
    ensureCapacity(count + 1);
    buf[count] = (byte) b;
    count += 1;
}

public synchronized void write(byte b[], int off, int len){
    if ((off &amp;lt; 0) || (off &amp;gt; b.length) || (len &amp;lt; 0) ||
            ((off + len) - b.length &amp;gt; 0)) {
            throw new IndexOutOfBoundsException();
        }
        ensureCapacity(count + len);
        System.arraycopy(b, off, buf, count, len);
        count += len;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到没有，所有写操作的第一步都是 ensureCapacity 方法的调用，目的是为了确保当前流内的字节数组能容纳本次写操作。&lt;/p&gt;
&lt;p&gt;而这个方法也很有意思了，如果计算后发现，内部的 buf 不能够支持本次写操作，则会调用 grow 方法做一次扩容。扩容的原理和 ArrayList 的实现是类似的，扩大为原来的两倍容量。&lt;/p&gt;
&lt;p&gt;除此之外，ByteArrayOutputStream 还有一个 writeTo 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void writeTo(OutputStream out) throws IOException {
    out.write(buf, 0, count);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将我们内部封装的字节数组写到某个输出流当中。&lt;/p&gt;
&lt;p&gt;剩余的一些方法也很常用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public synchronized byte toByteArray()[]：返回内部封装的字节数组&lt;/li&gt;
&lt;li&gt;public synchronized int size()：返回 buf 的有效字节数&lt;/li&gt;
&lt;li&gt;public synchronized String toString()：返回该数组对应的字符串形式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意到，这两个流虽然被称作「流」，但是它们本质上并没有像真正的流一样去分配一些资源，所以我们无需调用它的 close 方法，调了也没用（人家官方说了，has no effect）。&lt;/p&gt;
&lt;p&gt;测试的案例就不放出来了，等会我会上传本篇文章用到的所有代码案例，大家自行选择下载即可。&lt;/p&gt;
&lt;p&gt;为了控制篇幅，余下流的学习，放在下篇文章。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章中的所有代码、图片、文件都云存储在我的 GitHub 上：&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/SingleYam/overview_java&quot; class=&quot;uri&quot;&gt;https://github.com/SingleYam/overview_java&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：扑在代码上的高尔基，所有文章都将同步在公众号上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/05/10/C094PJ.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 07:18:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/9046178.html</dc:identifier>
</item>
<item>
<title>Java 面试知识点解析(三)——JVM篇 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/9045972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/9045972.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-958b6a30c60032e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;在遨游了一番 Java Web 的世界之后，发现了自己的一些缺失，所以就着一篇深度好文：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;amp;mid=2650692240&amp;amp;idx=1&amp;amp;sn=dc39f07097656042344e7fee8a17259e&amp;amp;chksm=bea62b4389d1a255619238b869b0fc33c1c8fda9172f0da2b62da71524b4ea1b32989df6bc76&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=1225zdAW9iFdJ86OiBQSr8mP#rd&quot;&gt;知名互联网公司校招 Java 开发岗面试知识点解析&lt;/a&gt; ，来好好的对 Java 知识点进行复习和学习一番，大部分内容参照自这一篇文章，有一些自己补充的，也算是重新学习一下 Java 吧。&lt;/p&gt;
&lt;p&gt;前序文章链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/883260941da8&quot;&gt;Java 面试知识点解析(一)——基础知识篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7382c0a843ff&quot;&gt;Java 面试知识点解析(二)——高并发编程篇&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;一jvm-基础知识&quot;&gt;（一）JVM 基础知识&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;问题和答案都是自行整理的，所以仅供参考！欢迎指正！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;java-是如何实现跨平台的&quot;&gt;1）Java 是如何实现跨平台的？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。&lt;/p&gt;
&lt;p&gt;而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-10b94c75252f5e5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是-jvm&quot;&gt;2）什么是 JVM ？&lt;/h4&gt;
&lt;p&gt;解析：不仅仅是基本概念，还有 JVM 的作用。&lt;/p&gt;
&lt;p&gt;答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。&lt;/p&gt;
&lt;h4 id=&quot;jvm-由哪些部分组成&quot;&gt;3）JVM 由哪些部分组成？&lt;/h4&gt;
&lt;p&gt;解析：这是对 JVM 体系结构的考察&lt;/p&gt;
&lt;p&gt;答：JVM 的结构基本上由 4 部分组成：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f42e851debb0a070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;类加载器是有了解吗&quot;&gt;4）类加载器是有了解吗？&lt;/h4&gt;
&lt;p&gt;解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。&lt;/p&gt;
&lt;p&gt;答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。&lt;/p&gt;
&lt;p&gt;类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：Java 虚拟机是如何判定两个 Java 类是相同的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。&lt;/p&gt;
&lt;h4 id=&quot;类加载器是如何加载-class-文件的&quot;&gt;5）类加载器是如何加载 class 文件的？&lt;/h4&gt;
&lt;p&gt;答：下图所示是 ClassLoader 加载一个 class 文件到 JVM 时需要经过的步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-9b726ee9e5ed7e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个阶段是找到 .class 文件并把这个文件包含的字节码加载到内存中&lt;/p&gt;
&lt;p&gt;第二阶段又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配和最后的符号表的链接&lt;/p&gt;
&lt;p&gt;第三个阶段是类中静态属性和初始化赋值，以及静态块的执行等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：能详细讲讲吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过一个类的全限定名来获取其定义的二进制字节流。&lt;/li&gt;
&lt;li&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。&lt;/li&gt;
&lt;li&gt;在Java堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。&lt;/p&gt;
&lt;p&gt;加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;验证：确保被加载的类的正确性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件格式验证：&lt;/strong&gt;验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元数据验证：&lt;/strong&gt;对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节码验证：&lt;/strong&gt;通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号引用验证：&lt;/strong&gt;确保解析动作能正确执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备：为类的&lt;code&gt;静态变量&lt;/code&gt;分配内存，并将其初始化为默认值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。&lt;/li&gt;
&lt;li&gt;② 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设一个类变量的定义为： &lt;code&gt;public static int value = 3;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么变量value在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的&lt;code&gt;public static&lt;/code&gt;指令是在程序编译后，存放于类构造器 &lt;code&gt;&amp;lt;clinit&amp;gt;（）&lt;/code&gt;方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里还需要注意如下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。&lt;/li&gt;
&lt;li&gt;对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。&lt;/li&gt;
&lt;li&gt;对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。&lt;/li&gt;
&lt;li&gt;如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;③ 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设上面的类变量 value 被定义为： &lt;code&gt;public static final int value = 3;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解析：把类中的符号引用转换为直接引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。&lt;/p&gt;
&lt;p&gt;直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;① 声明类变量是指定初始值&lt;/li&gt;
&lt;li&gt;② 使用静态代码块为类变量指定初始值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM初始化步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、假如这个类还没有被加载和连接，则程序先加载并连接该类&lt;/li&gt;
&lt;li&gt;2、假如该类的直接父类还没有被初始化，则先初始化其直接父类&lt;/li&gt;
&lt;li&gt;3、假如类中有初始化语句，则系统依次执行这些初始化语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建类的实例，也就是new的方式&lt;/li&gt;
&lt;li&gt;访问某个类或接口的静态变量，或者对该静态变量赋值&lt;/li&gt;
&lt;li&gt;调用类的静态方法&lt;/li&gt;
&lt;li&gt;反射（如 Class.forName(“com.shengsiyuan.Test”)）&lt;/li&gt;
&lt;li&gt;初始化某个类的子类，则其父类也会被初始化&lt;/li&gt;
&lt;li&gt;Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;结束生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在如下几种情况下，Java虚拟机将结束生命周期&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行了 System.exit()方法&lt;/li&gt;
&lt;li&gt;程序正常执行结束&lt;/li&gt;
&lt;li&gt;程序在执行过程中遇到了异常或错误而异常终止&lt;/li&gt;
&lt;li&gt;由于操作系统出现错误而导致Java虚拟机进程终止&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1.0714285714286&quot;&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;amp;mid=2247483934&amp;amp;idx=1&amp;amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;amp;scene=21#wechat_redirect&quot;&gt;jvm系列(一):java类的加载机制 - 纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;双亲委派模型parent-delegation-model&quot;&gt;7）双亲委派模型（Parent Delegation Model）？&lt;/h4&gt;
&lt;p&gt;解析：类的加载过程采用双亲委派机制，这种机制能更好的保证 Java 平台的安全性&lt;/p&gt;
&lt;p&gt;答：类加载器 ClassLoader 是具有层次结构的，也就是父子关系，其中，Bootstrap 是所有类加载器的父亲，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-b4a569a5cc980a34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该模型要求除了顶层的 Bootstrap class loader 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：双亲委派模型的工作过程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;1.当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，&lt;br/&gt;等下次加载的时候就可以直接返回了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.当前 ClassLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;面试官：为什么这样设计呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析：这是对于使用这种模型来组织累加器的好处&lt;/p&gt;
&lt;p&gt;答：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException.&lt;/p&gt;
&lt;blockquote readability=&quot;1.0958904109589&quot;&gt;
&lt;p&gt;参考文章： &lt;a href=&quot;https://segmentfault.com/a/1190000002579346&quot;&gt;JVM 的 工作原理，层次结构 以及 GC工作原理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二jvm-内存管理&quot;&gt;（二）JVM 内存管理&lt;/h2&gt;
&lt;h4 id=&quot;jvm-内存划分&quot;&gt;1）JVM 内存划分：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-cf626e0e356e89d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;堆内存（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照8:1:1的比例来分配。根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;程序计数器： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;虚拟机栈（栈内存）：Java线程私有，虚拟机展描述的是Java方法执行的内存模型：每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息；每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本地方法栈 ：和Java虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 native 方法的服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;对象分配规则&quot;&gt;2）对象分配规则？&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;java-的内存模型&quot;&gt;3）Java 的内存模型：&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-d385883cf2bc0725.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model, JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。&lt;/p&gt;
&lt;p&gt;Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在主内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如上图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：两个线程之间是如何通信的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：在&lt;strong&gt;共享内存&lt;/strong&gt;的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-ef21427c586e224c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去&lt;/li&gt;
&lt;li&gt;2.然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7a3d44fd74ad5da8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;消息传递&lt;/strong&gt;的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 Java 中典型的消息传递方式就是 wait() 和 notify()。&lt;/p&gt;
&lt;h4 id=&quot;内存屏障&quot;&gt;5）内存屏障？&lt;/h4&gt;
&lt;p&gt;解析：在这之前应该对重排序的问题有所了解，这里我找到一篇很好的文章分享一下：&lt;a href=&quot;https://tech.meituan.com/java-memory-reordering.html&quot;&gt;Java内存访问重排序的研究&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;答：内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面试官：内存屏障为何重要？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。&lt;/p&gt;
&lt;h4 id=&quot;类似-xms-xmn这些参数的含义&quot;&gt;5）类似-Xms、-Xmn这些参数的含义：&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;堆内存分配：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JVM初始分配的内存由-Xms指定，默认是物理内存的1/64&lt;/li&gt;
&lt;li&gt;JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4&lt;/li&gt;
&lt;li&gt;默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。&lt;/li&gt;
&lt;li&gt;因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;非堆内存分配：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；&lt;/li&gt;
&lt;li&gt;由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。&lt;/li&gt;
&lt;li&gt;-Xmn2G：设置年轻代大小为2G。&lt;/li&gt;
&lt;li&gt;-XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;内存泄漏和内存溢出&quot;&gt;6）内存泄漏和内存溢出&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内存溢出指的是内存不够用了。&lt;/li&gt;
&lt;li&gt;内存泄漏是指对象可达，但是没用了。即本该被GC回收的对象并没有被回收&lt;/li&gt;
&lt;li&gt;内存泄露是导致内存溢出的原因之一；内存泄露积累起来将导致内存溢出。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;内存泄漏的原因分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;长生命周期的对象引用短生命周期的对象&lt;/li&gt;
&lt;li&gt;没有将无用对象置为null&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;小结：本小节涉及到 JVM 虚拟机，包括对内存的管理等知识，相对较深。除了以上问题，面试官会继续问你一些比较深的问题，可能也是为了看看你的极限在哪里吧。比如：内存调优、内存管理，是否遇到过内存泄露的实际案例、是否真正关心过内存等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;简述一下-java-中创建一个对象的过程&quot;&gt;7）简述一下 Java 中创建一个对象的过程？&lt;/h4&gt;
&lt;p&gt;解析：回答这个问题首先就要清楚类的生命周期&lt;/p&gt;
&lt;p&gt;答：下图展示的是类的生命周期流向：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-b1d7d32f1eb7e1c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于new关键字创建的普通Java对象，不包括数组对象的创建。&lt;/p&gt;
&lt;p&gt;大致过程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.检测类是否被加载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当虚拟机执行到new时，会先去常量池中查找这个类的符号引用。如果能找到符号引用，说明此类已经被加载到方法区（方法区存储虚拟机已经加载的类的信息），可以继续执行；如果找不到符号引用，就会使用类加载器执行类的加载过程，类加载完成后继续执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.为对象分配内存：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。&lt;/p&gt;
&lt;p&gt;具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为指针碰撞。&lt;/li&gt;
&lt;li&gt;对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为空闲列表。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分配内存的时候也需要考虑线程安全问题，有两种解决方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种是采用同步的办法，使用CAS来保证操作的原子性。&lt;/li&gt;
&lt;li&gt;另一种是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），分配内存的时候再TLAB上分配，互不干扰。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.为分配的内存空间初始化零值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.对对象进行其他设置：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的hashcode，GC分代年龄等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.执行 init 方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于Java程序来说还需要执行init方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了init方法之后，这个对象才真正能使用。&lt;/p&gt;
&lt;p&gt;到此为止一个对象就产生了，这就是new关键字创建对象的过程。过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-d3f0b79374e52e6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.6304347826087&quot;&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;http://cxis.me/2016/12/01/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/&quot;&gt;Java创建对象的过程简介&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;面试官：对象的内存布局是怎样的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：对象的内存布局包括三个部分：对象头，实例数据和对齐填充。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对象头：对象头包括两部分信息，第一部分是存储对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等。第二部分是类型指针，即对象指向类元数据的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实例数据：就是数据啦&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对齐填充：不是必然的存在，就是为了对齐的嘛&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;面试官：对象是如何定位访问的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：对象的访问定位有两种：句柄定位和直接指针&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;句柄定位：Java 堆会画出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-24ab9d16017066ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接指针访问：java堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-37413a4771387b81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较：使用直接指针就是速度快，使用句柄reference指向稳定的句柄，对象被移动改变的也只是句柄中实例数据的指针，而reference本身并不需要修改。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.875&quot;&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://troywu0.gitbooks.io/spark/content/java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B.html&quot;&gt;JAVA对象创建的过程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三gc-相关&quot;&gt;（三）GC 相关&lt;/h2&gt;
&lt;h4 id=&quot;如何判断一个对象是否已经死去&quot;&gt;1）如何判断一个对象是否已经死去？&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;垃圾回收算法有哪些&quot;&gt;2）垃圾回收算法有哪些？&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;引用计数：&lt;br/&gt;原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;标记-清除：&lt;br/&gt;此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-629206f5d8336bc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;复制算法：&lt;br/&gt;此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-45baf8ef2625fba4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标记-整理：&lt;br/&gt;此算法结合了 “标记-清除” 和 “复制” 两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了 “标记-清除” 的碎片问题，同时也避免了 “复制” 算法的空间问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-4b2c9593a91f5816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分代收集算法：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;分代收集算法并没有提出新的思想，只是根据对象存活周期的不同将内存划为几块。一般Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。&lt;/li&gt;
&lt;li&gt;在新生袋中每次垃圾手机时都会由大批对象死去，只有少量存活，那就用复制算法，只需要付出少量存活对象的复制成本就可以。老年代中对象存活率高、没有额外担保，所以必须使用“标记-清理”或者“标记整理算法。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;1&quot;&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;amp;mid=2247483952&amp;amp;idx=1&amp;amp;sn=ea12792a9b7c67baddfaf425d8272d33&amp;amp;chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&amp;amp;scene=21#wechat_redirect&quot;&gt;jvm系列(三):GC算法 垃圾收集器——纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;gc什么时候开始&quot;&gt;3）GC什么时候开始？&lt;/h4&gt;
&lt;p&gt;答：GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。大对象直接进入老年代，如很长的字符串数组，虚拟机提供一个-XX:PretenureSizeThreadhold参数，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看HandlePromotionFailure设置是否允许担保失败，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;引用的分类&quot;&gt;4）引用的分类？&lt;/h4&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;强引用：通过new出来的引用，只要强引用还存在，则不会回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;软引用：通过SoftReference类来实现，用来描述一些有用但非必须的对象。在系统将要发生内存溢出异常之前，会把这些对象回收了，如果这次回收还是内存不够的话，才抛出内存溢出异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;弱引用：非必须对象，通过WeakReference类来实现，被弱引用引用的对象，只要已发生GC就会把它干掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;虚引用：通过PhantomReference类来实现，无法通过徐引用获得对象的实例，唯一作用就是在这个对象被GC时会收到一个系统通知。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.4046242774566&quot;&gt;
&lt;p&gt;扩展阅读：&lt;a href=&quot;https://www.jianshu.com/p/39753aad9a38&quot;&gt;重新认识java（一） ---- 万物皆对象&lt;/a&gt; ，文章中有对这四个引用有详细的描述，还有一些典型的应用，这里就不摘过来啦...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;垃圾收集器&quot;&gt;5）垃圾收集器？&lt;/h4&gt;
&lt;p&gt;解析：如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Serial 收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会 Stop The World（服务暂停）&lt;/p&gt;
&lt;p&gt;参数控制： &lt;code&gt;-XX:+UseSerialGC&lt;/code&gt; 串行收集器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-ecea7511ae962fcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.ParNew 收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩&lt;/p&gt;
&lt;p&gt;参数控制：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseParNewGC&lt;/code&gt; ParNew收集器&lt;br/&gt;&lt;code&gt;-XX:ParallelGCThreads&lt;/code&gt; 限制线程数量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-82bf115baf89fdbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Parallel Scavenge收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩&lt;/p&gt;
&lt;p&gt;参数控制： &lt;code&gt;-XX:+UseParallelGC&lt;/code&gt; 使用Parallel收集器+ 老年代串行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.Parallel Old 收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Parallel Old是Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在 JDK 1.6 中才开始提供&lt;/p&gt;
&lt;p&gt;参数控制： &lt;code&gt;-XX:+UseParallelOldGC&lt;/code&gt; 使用Parallel收集器+ 老年代并行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.CMS收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。&lt;/p&gt;
&lt;p&gt;从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记（CMS initial mark）&lt;/li&gt;
&lt;li&gt;并发标记（CMS concurrent mark）&lt;/li&gt;
&lt;li&gt;重新标记（CMS remark）&lt;/li&gt;
&lt;li&gt;并发清除（CMS concurrent sweep）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。&lt;/p&gt;
&lt;p&gt;由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt; 并发收集、低停顿&lt;br/&gt;&lt;strong&gt;缺点:&lt;/strong&gt; 产生大量空间碎片、并发阶段会降低吞吐量&lt;/p&gt;
&lt;p&gt;参数控制：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt; 使用CMS收集器&lt;br/&gt;&lt;code&gt;-XX:+ UseCMSCompactAtFullCollection&lt;/code&gt; Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长&lt;br/&gt;&lt;code&gt;-XX:+CMSFullGCsBeforeCompaction&lt;/code&gt; 设置进行几次Full GC后，进行一次碎片整理&lt;br/&gt;&lt;code&gt;-XX:ParallelCMSThreads&lt;/code&gt; 设定CMS的线程数量（一般情况约等于可用CPU数量）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-d691b23585b39e9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.G1收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;空间整合&lt;/strong&gt;，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;可预测停顿&lt;/strong&gt;，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-8e8b4f853fd38684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。&lt;/p&gt;
&lt;p&gt;收集步骤：&lt;/p&gt;
&lt;p&gt;1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)&lt;/p&gt;
&lt;p&gt;2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。&lt;/p&gt;
&lt;p&gt;3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-6fb4792713799689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。&lt;/p&gt;
&lt;p&gt;5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-fbf007a6f9e8bc6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-8ef492a1c182ae1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1&quot;&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;amp;mid=2247483952&amp;amp;idx=1&amp;amp;sn=ea12792a9b7c67baddfaf425d8272d33&amp;amp;chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&amp;amp;scene=21#wechat_redirect&quot;&gt;jvm系列(三):GC算法 垃圾收集器——纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;四其他-jvm-相关面试题整理&quot;&gt;（四）其他 JVM 相关面试题整理&lt;/h2&gt;
&lt;h4 id=&quot;位-jvm-中int-的长度是多数&quot;&gt;1）64 位 JVM 中，int 的长度是多数？&lt;/h4&gt;
&lt;p&gt;答：Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。&lt;/p&gt;
&lt;h4 id=&quot;怎样通过-java-程序来判断-jvm-是-32-位-还是-64-位&quot;&gt;2）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？&lt;/h4&gt;
&lt;p&gt;答：Sun有一个Java System属性来确定JVM的位数：32或64：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;sun.&lt;span class=&quot;fu&quot;&gt;arch&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;model&lt;/span&gt;=&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 32 bit JVM&lt;/span&gt;
sun.&lt;span class=&quot;fu&quot;&gt;arch&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;model&lt;/span&gt;=&lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 64 bit JVM&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我可以使用以下语句来确定 JVM 是 32 位还是 64 位：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;System.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;sun.arch.data.model&quot;&lt;/span&gt;) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;位-jvm-和-64-位-jvm-的最大堆内存分别是多数&quot;&gt;3）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？&lt;/h4&gt;
&lt;p&gt;答：理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。&lt;/p&gt;
&lt;h4 id=&quot;你能保证-gc-执行吗&quot;&gt;4）你能保证 GC 执行吗？&lt;/h4&gt;
&lt;p&gt;答：不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC 的执行。&lt;/p&gt;
&lt;h4 id=&quot;怎么获取-java-程序使用的内存堆使用的百分比&quot;&gt;5）怎么获取 Java 程序使用的内存？堆使用的百分比？&lt;/h4&gt;
&lt;p&gt;答：可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。&lt;/p&gt;
&lt;h4 id=&quot;java-中堆和栈有什么区别&quot;&gt;6）Java 中堆和栈有什么区别？&lt;/h4&gt;
&lt;p&gt;答：JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-19ed61ccd60a57df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小结：JVM 是自己之前没有去了解过得知识，所以这次写这篇文章写了很久，也学到了很多东西；在考虑要不要开微信公众号来着...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;《深入理解 Java 虚拟机》&lt;/li&gt;
&lt;li&gt;《深入分析 Java Web技术内幕》&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6.0903225806452&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可能后期会开一个微信公众号吧...&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 16 May 2018 06:47:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/9045972.html</dc:identifier>
</item>
<item>
<title>Java基础系列--桶排序 - 唯一浩哥</title>
<link>http://www.cnblogs.com/V1haoge/p/9045967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V1haoge/p/9045967.html</guid>
<description>&lt;p&gt;原创作品，可以转载，但是请标注出处地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java基础系列--桶排序&quot; href=&quot;http://www.cnblogs.com/V1haoge/p/9045967.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/V1haoge/p/9045967.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、算法简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　桶排序可以算是最简单快速的排序算法了，只是限定条件要多一点，需要事先知晓待排序列的极限值或范围来准备足够的桶。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、算法原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　桶排序的原理就是准备足够数量的有序桶（一般用数组实现），用于标记待排序列的每个元素，用元素值对应桶下标，桶里的值代表的是元素对应的值出现的次数，有一次就在原值上加1（初始值为0）。当将所有的待排序列中的元素遍历一遍后，将其全部标记到桶中，这时候其实就已经排好序了。如果我们需要正序排序，则对桶进行正序遍历，排除值为0 的桶，按顺序和桶中值的个数输出桶的下标值，即为正序列，倒序反之。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、算法实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BusketSort {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] ints, Boolean isAsc) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] basket = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[101]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义足够大的数组桶&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i : ints) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       basket[i]++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应元素的桶下标自增&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isAsc) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; basket.length - 1; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (basket[i] &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 1; j &amp;lt;= basket[i]; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             System.out.print(i + &quot; &quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环输出桶元素不为0的下标值&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = basket.length - 1; i &amp;gt; 0; i--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (basket[i] &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 1; j &amp;lt;= basket[i]; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             System.out.print(i + &quot; &quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环输出桶元素不为0的下标值&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] ints = {2, 6, 4, 9, 12, 98, 5, 32, 90, 33, 24, 65, 37, 12, 4&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     sort(ints, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、算法解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先我们需要准备一个桶数组，桶数组的大小为已知的待排序列的范围，比如我们要对学生的单科成绩（满分100）进行排序，那么我们就要准备101个桶（即定义一个长度为101的数组）。&lt;/p&gt;
&lt;p&gt;　　然后遍历待排序列，将与待排元素值一致的桶下标对应的桶的值加1（初始值为0），遍历结束，其实排序也就完成了。&lt;/p&gt;
&lt;p&gt;　　最后，我们需要正序排序则，正序遍历桶输出桶下标，倒序则倒序遍历桶输出桶下标（需要注意的就是下标输出的次数为下标对应的桶值）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　桶排序的时间复杂度是O(m+n)，其中m为待排序元素个数，n为桶数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 空间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　桶排序的空间复杂度极大，与待排序的最大元素相关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从代码实现中我们也可以看出，桶排序是及其简单的，唯一的缺陷就是桶的存在及其占用空间，如果我们要排序的数列只有很少的个数，但是元素之间相差极大的话，那么我们就需要准备一个极大的桶，及其浪费空间资源。一般情况下我们会在一个桶中存放一个范围之内的元素，桶中的元素我们可以采用其他的排序算法实现排序。这样可以极大的降低空间消耗。&lt;/p&gt;
&lt;p&gt;　　桶排序一般适用于如下场景：&lt;/p&gt;
&lt;p&gt;　　　　 &lt;span&gt;&lt;em&gt;数据分布相对较为均匀或者数据范围不大的情况下&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;　　　　特殊场景，比如需要统计元素的个数的情况，或者希望通过哈希映射快速获取某些值的情况&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 16 May 2018 06:46:00 +0000</pubDate>
<dc:creator>唯一浩哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/V1haoge/p/9045967.html</dc:identifier>
</item>
<item>
<title>《深入理解计算机系统》阅读笔记--计算机系统漫游 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/9045830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/9045830.html</guid>
<description>&lt;p&gt;《深入理解计算机系统》，这本书，我多次想要好好完整的读一遍，每次都是没有坚持下去，但是作为一个开发者，自己想要成为为数不多的大牛之一，所以打算这次把这本书完整的好好读一遍，并整理为相关的博客！&lt;/p&gt;
&lt;p&gt;书的开头说了一句话：计算机系统是由硬件和系统软件组成，他们共同工作来运行应用程序。&lt;br/&gt;我们通常接触更多的是应用程序级别的，很少关注系统以及系统和硬件的交互，但是如果自己能完全理解计算机系统以及它对应用程序的影响，那将会让我们在软件开发的路上走的更远，也同时可以避免很多问题的发生。&lt;/p&gt;
&lt;p&gt;拿最简单的hello.c 程序来说，我们看到的代码文件内容是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello,world\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是对计算机来说其实就是由0和1组成的位（比特）序列，8个位组成一组，成为字节。&lt;/p&gt;
&lt;h2&gt;C程序的编译过程&lt;/h2&gt;
&lt;p&gt;通常我们写完C程序的代码，都会对程序进行编译，将代码文件编译成可执行程序，也就是我们在windows上通常看到的.exe文件，在Linux系统上我们通常通过gcc 来将c代码进行编译，其实当我们通过gcc 编译的时候，&lt;span&gt;执行了四个阶段：预处理阶段，编译阶段，汇编阶段，链接阶段&lt;/span&gt;&lt;br/&gt;执行这四个阶段的程序为：&lt;span&gt;预处理器，编译器，汇编器，链接器，一起构成了编译系统&lt;/span&gt;&lt;br/&gt;如下图是编译的过程表示：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516141758159-1317277876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预处理阶段：其实这个类似python中的import导入，将你要导入的代码文件放到这个文件中，而在C语言中，这里还是以hello.c 为例子，第一行的#include &amp;lt;stdio.h&amp;gt; 会告诉预处理器（cpp）读取系统的头文件中stdio.h的内容，并把它插入到程序文本中，结果是得到了另外一个C程序，生成的文件是以.i结尾&lt;/p&gt;
&lt;p&gt;编译阶段：编译器（ccl） 将hello.c 翻译成hello.s ，成为一个汇编语言程序&lt;/p&gt;
&lt;p&gt;汇编阶段：汇编器（as）将hello.s 翻译成机器指令，把这些指令打包成一个可重定位目标程序的格式，并将结果保存在hello.o中，hello.o文件其实已经是一个二进制文件。&lt;/p&gt;
&lt;p&gt;链接阶段： 我们通常在代码中都会调用到标准库中的一些函数，就像我们hello.c代码中我们调用了printf函数，其实printf函数存在于一个名为printf.o 的单独预编译好的目标文件中，连接器ld 其实就是讲这个文件合并到我们的hello.o程序中。最终得到我们编译好的hello文件中或hello.exe 文件中，这就成了我们通常看到的可执行文件&lt;/p&gt;
&lt;p&gt;了解这个编译过程对我们写代码来说的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;优化程序性能&lt;/li&gt;
&lt;li&gt;理解链接时出现的错误&lt;/li&gt;
&lt;li&gt;避免安全漏洞&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;系统硬件的组成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142008264-376662488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们从上图可以看出，整个系统是通过各种总线在连接，包括了：&lt;span&gt;I/O总线，内存总线，系统总线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通常总线被设计成传送定长的字节块，也就是字（word）,现在大多数及其的字长要么是4个字节（32位），要么是8个字节（64位），当然64为居多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I/O设备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个我们就比较熟悉了，主要就是用于系统和外部进行交互的，入鼠标键盘，显示器等&lt;/p&gt;
&lt;p&gt;每个I/O设备通过一个控制器或适配器与I/O 总线相连。&lt;/p&gt;
&lt;p&gt;控制器和适配器的区别：就是封装方式，控制器是主板上的芯片组，而适配器是一个插在主板插槽上的卡，如独立显卡和声卡等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主存是一组动态随机存储器DRAM 芯片组成&lt;/p&gt;
&lt;p&gt;主存是一个临时存储设备，用来存放程序和程序处理的数据&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU 是解释或执行存储在主存中指令的引擎&lt;/p&gt;
&lt;p&gt;处理器的核心是一个大小为一个字的存储设备或者寄存器，称为程序计数器（PC）&lt;/p&gt;
&lt;p&gt;寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字，算数/逻辑单元(ALU)计算新的数据和地址。CPU 可能执行的操作：&lt;/p&gt;
&lt;p&gt;加载： 从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的值&lt;/p&gt;
&lt;p&gt;存储： 从寄存器赋值一个字节或者一个字到主存的某个位置，以覆盖这个位置原来的内容&lt;/p&gt;
&lt;p&gt;操作： 把两个寄存器的内容复制到ALU,ALU对这两个字做算数运算，并将结果放到一个寄存器中，覆盖该寄存器中原来的值&lt;/p&gt;
&lt;p&gt;跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器PC中，以覆盖PC中原来的值&lt;/p&gt;

&lt;p&gt;上面大致理解了系统的各个组成部分，这次在回头看hello程序运行时在各个组件中传递过程&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142115227-1699405377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们开始通过键盘输入hello命令，程序就字符被逐一读到寄存器，然后放到内存中&lt;/p&gt;
&lt;p&gt;回车之后系统将磁盘上我们的程序文件加载到主存中，然后处理器就会开始执行程序中的机器指令，并最终在显示器显示hello world&lt;/p&gt;
&lt;h2&gt;高速缓存的重要性&lt;/h2&gt;
&lt;p&gt;其实通过上面也看到了系统花费了大量的事件在各个组件之间拷贝来拷贝去，其实这些拷贝也是一种开销&lt;/p&gt;
&lt;p&gt;并且在不同设备上运行的速度也是相差非常大，一般来说较大的存储设备要比较小的存储设备运行的慢，但是快速设备的造价会高很多比低速设备，这里就诞生了告诉缓存存储器cache memory&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142149891-2025329423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;现在的处理器一般有三级高速缓存：L1,L2,L3, 当然可能更多&lt;/p&gt;
&lt;p&gt;而这种高速缓存用的是一种叫做静态随机访问存储器（SRAM）的硬件技术实现的&lt;/p&gt;
&lt;p&gt;这样就有了下面这个存储设备的层次结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142205068-1945802158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存储器层次结构的主要思想是上一层的存储器作为低一层存储器的缓存&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;操作系统&lt;/h2&gt;
&lt;p&gt;当我们这会在回头来看操作系统，其实操作系统就是应用程序和硬件之间的中间层，应用程序通过操作系统来对硬件进行操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142239175-133129506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作系统的作用：防止硬件被失控的程序滥用；向应用程序提供一种机制用于操作硬件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而实现这两个功能是通过几个基本的抽象概念来实现：进程，虚拟内存和文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件是对I/O设备的抽象，虚拟内存是对主存和磁盘I/O 设备的抽象，进程则是对处理器、主存和IO设备的抽象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142253635-704623097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有几个关键词的概念需要理解：&lt;/p&gt;
&lt;p&gt;进程：进程是操作系统对一个正在运行的程序的一种抽象。&lt;/p&gt;
&lt;p&gt;并发运行：一个进程的指令和另外一个进程指令是交错执行&lt;/p&gt;
&lt;p&gt;操作系统实现叫做执行的机制成为上下文切换&lt;/p&gt;
&lt;p&gt;操作系统保持跟踪进程运行所需要的所有状态信息，就是上下文&lt;/p&gt;

&lt;p&gt;其实我们在shell命令下执行我们的hello程序就是个并发的场景，这里有两个进程：shell进程和hello进程，而执行的过程可以通过如下图表示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142307172-442882109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里也要知道从一个进程到另外一个进程是有操作系统内核管理的，内核代码是操作系统代码常驻主存的部分&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：内核不是一个独立的进程。它是系统管理全部进程所用代码和数据结构的集合&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;线程：一个进程通常可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据&lt;/p&gt;

&lt;p&gt;虚拟内存：虚拟内存是一个抽象概念，为每个进程提供了一个假象，好像每个进程都在独占的使用主存，每个进程看到的内存都是一致的，称为虚拟地址空间。下图是Linux的虚拟地址空间，地址是从下往上增大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142336254-434146718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这里先简单的对着几个概念进行理解：&lt;/p&gt;
&lt;p&gt;堆：代码和数据区在进程一开始运行就被指定了大小。同时堆可以在运行时动态的扩展和收缩&lt;/p&gt;
&lt;p&gt;共享库： 在地址空间的中间部分是一块用来存放C标准库数学库这样的共享库代码和数据区域&lt;/p&gt;
&lt;p&gt;栈：位于用户虚拟地址空间顶部的是用户栈，编译器用它实现函数的调用，同样栈在程序执行期间也可以动态的扩展和收缩&lt;/p&gt;
&lt;p&gt;如：当我们执行函数时，栈就会增长，一个函数返回时，栈就会收缩&lt;/p&gt;
&lt;p&gt;内核虚拟内存：地址空间的顶部区域是为内核保留的，不允许程序血祸者调用内核定义的函数，必须由内核来执行这些操作&lt;/p&gt;

&lt;h2&gt;Amdahl 定律&lt;/h2&gt;
&lt;p&gt;该定律的主要思想：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201805/997599-20180516142411978-1744386031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;书中有个例子非常贴切，系统的某个部分的耗时比例是60%,也就是a = 0.6  其加速比例因子为3 k=3,我们可以获得的加速比为：&lt;/p&gt;
&lt;p&gt;1/[0.4+0.6/3] = 1.67倍，即使对着一个部分做了重大概念，但获得系统加速比却明显小于这部分的加速比，所以想要显著加速整个系统，必须提升全系统中相当大的部分的速度&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 06:27:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/9045830.html</dc:identifier>
</item>
<item>
<title>MongoDb进阶实践之七 MongoDB的索引入门 - 可均可可</title>
<link>http://www.cnblogs.com/PatrickLiu/p/9045632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/9045632.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    　　好久没有写东西了，MongoDB系列的文章也丢下好长时间了。今天终于有时间了，就写了一篇有关&lt;span&gt;索引&lt;/span&gt;的文章。一说到“索引”，用过关系型数据库的人都应该知道它是一个什么东西。当我们要访问的数据量大了的时候，可以通过建立索引来提高查询速度。关系型数据库有“索引”的概念，我们的MongoDB数据库也有索引的概念，今天我就来抛砖引玉，简单的说一说MongoDB文档数据库中的“索引”的概念。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    　　索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构 。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、详细操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;&lt;span&gt; 1、索引创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        &lt;span&gt;&lt;strong&gt;1.1、语法：可以向指定集合中增加一个索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　ensureIndex()方法基本语法格式如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　&amp;gt;db.collectionName.ensureIndex({KEY:1,KEY2:1,...KEYN:1})&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;           　　 说明：语法中 Key-Keyn 值为你要创建的索引字段，1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;            ensureIndex() 接收可选参数，可选参数列表如下：&lt;/p&gt;&lt;p&gt;              Parameter        　　     Type                 Description&lt;/p&gt;&lt;p&gt;              background        　       Boolean           建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 &quot;background&quot; 可选参数。 &quot;background&quot; 默认值为false。&lt;/p&gt;&lt;p&gt;              unique       　　　　     Boolean           建立的索引是否唯一。指定为true创建唯一索引。默认值为false.&lt;/p&gt;&lt;p&gt;              name            　　　      string              索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。&lt;br/&gt;    &lt;br/&gt;              dropDups       　　       Boolean          在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.&lt;/p&gt;&lt;p&gt;              sparse        　　　       Boolean           对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档。默认值为 false.&lt;/p&gt;&lt;p&gt;              expireAfterSeconds     integer            指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。&lt;/p&gt;&lt;p&gt;                v            　　　　　　index&lt;br/&gt;                        　　　　　　　  version         索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。&lt;/p&gt;&lt;p&gt;              weights                        document       索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。&lt;/p&gt;&lt;p&gt;              default_language         string             对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语&lt;/p&gt;&lt;p&gt;              language_override       string              对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.&lt;/p&gt;&lt;p&gt;       &lt;span&gt;&lt;strong&gt; 1.2、代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始数据&lt;/span&gt;
            &amp;gt;db.school.find({},{_id:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;});
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liulei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hebei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangfei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanxi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guanyu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanxi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;diaochan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guangdong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向name字段增加升序索引&lt;/span&gt;
            &amp;gt;db.school.ensureIndex({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;})
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdCollectionAutomaticallly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numIndexesBefore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numIndexesAfter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ensureIndex() 方法中你也可以设置使用多个字段创建索引（关系型数据库中称作复合索引）。&lt;/span&gt;
            &amp;gt;db.school.ensureIndex({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;})
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;createdCollectionAutomaticallly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numIndexesBefore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numIndexesAfter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;   &lt;span&gt;&lt;strong&gt; 2、检索索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;       &lt;span&gt;&lt;strong&gt; 2.1、语法：检索当前指定集合所有的索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　getIndexes()方法基本语法格式如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　&amp;gt;db.collectionName.getIndexes()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　说明：会列出该集合内所有的索引。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;       2.2、代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始数据&lt;/span&gt;
            &amp;gt;db.school.find({},{_id:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;});
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liulei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hebei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangfei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanxi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guanyu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanxi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;diaochan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guangdong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前school集合里面所有的索引&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.getIndexes();
            [
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1_age_-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;3、删除索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &lt;span&gt;&lt;strong&gt;     3.1、语法：删除指定集合里面指定名称的索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　dropIndex(INDEX-NAME)方法基本语法格式如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　&amp;gt;db.collectionName.dropIndex(INDEX-NAME)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　说明：删除索引的时候必须指定索引的名称。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span&gt;&lt;strong&gt;3.2、语法：删除指定集合里面所有索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　dropIndexes()方法基本语法格式如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　&amp;gt;db.collectionName.dropIndexes()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　说明：该方法可以删除指定集合中所有的索引。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span&gt;&lt;strong&gt;3.3、代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始数据&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.getIndexes();
            [
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1_age_-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            ]

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除名称为是：name_1 的索引&lt;/span&gt;
            &amp;gt;db.school.dropIndex(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nIndexesWas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
    
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前索引数据&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.getIndexes();
            [
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1_age_-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            ]

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除所有索引数据&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.dropIndexes();
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nIndexesWas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;non-_id indexes dropped for collection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;}
    
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前的索引数据&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.getIndexes();
            [
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;4、重建索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;       &lt;span&gt;&lt;strong&gt; 4.1、语法：重新建立指定集合中所有的索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　reIndex()方法基本语法格式如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　&amp;gt;db.collectionName.reIndex();&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;            　　说明：重新建立指定集合的所有索引。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;     &lt;span&gt;&lt;strong&gt;   4.2、代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始数据&lt;/span&gt;
            &amp;gt;db.school.find({},{_id:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;});
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;liulei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hebei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangfei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanxi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guanyu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shanxi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;diaochan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;guangdong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新创建当前school集合里面所有的索引&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.reIndex();
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nIndexesWas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nIndexes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;indexes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:[
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_id_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                },
                {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name_1_age_-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;school.school&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }],
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;  5、统计指定集合索引文件的大小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span&gt;&lt;strong&gt;5.1、语法：统计指定集合中所有索引文件大大小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;           　　 totalIndexSize()方法基本语法格式如下所示：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;           　　 &amp;gt;db.collectionName.totalIndexSize();&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;           　　 说明：统计指定集合中所有索引文件大大小。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        &lt;span&gt;&lt;strong&gt;5.2、代码实例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计school集合中索引文件的大小&lt;/span&gt;
            &amp;gt;&lt;span&gt;db.school.totalIndexSize();
            &lt;/span&gt;&lt;span&gt;49152&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、使用索引的时候注意事项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;1、额外开销&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        每个索引占据一定的存储空间，在进行插入，更新和删除操作时也需要对索引进行操作。所以，如果你很少对集合进行读取操作，建议不使用索引。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;&lt;span&gt;2、内存(RAM)使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        由于索引是存储在内存(RAM)中,你应该确保该索引的大小不超过内存的限制。&lt;/p&gt;&lt;p&gt;        如果索引的大小大于内存的限制，MongoDB会删除一些索引，这将导致性能下降。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;3、查询限制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        索引不能被以下的查询使用：&lt;/p&gt;&lt;p&gt;                正则表达式及非操作符，如 $nin, $not, 等。&lt;/p&gt;&lt;p&gt;                算术运算符，如 $mod, 等。&lt;/p&gt;&lt;p&gt;                $where 子句&lt;/p&gt;&lt;p&gt;        所以，检测你的语句是否使用索引是一个好的习惯，可以用explain来查看。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;4、索引键限制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        从2.6版本开始，如果现有的索引字段的值超过索引键的限制，MongoDB中不会创建索引。&lt;/p&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;   5、插入文档超过索引键限制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;        如果文档的索引字段值超过了索引键的限制，MongoDB不会将任何文档转换成索引的集合。与mongorestore和mongoimport工具类似。&lt;/p&gt;&lt;p&gt;    &lt;span&gt;&lt;strong&gt;6、最大范围&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;            集合中索引不能超过64个，一般一个集合6-9索引就可以了&lt;/p&gt;&lt;p&gt;            索引名的长度不能超过128个字符&lt;/p&gt;&lt;p&gt;            一个复合索引最多可以有31个字段&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、结束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;    　　好了，就是这些了，我这个短短的文章只是起到了一个因子的作用，当然也希望对大家有帮助。我写的这些文章，也记录了我重拾记录的历史，争取在有时间的情况下，把自己的学习历程记录下来，为以后的自己铺平垫路。今天只是简单的讲了Mongodb的索引，如果以后有了新的学习心得，我在补充进来，不忘初心，继续努力吧。&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 05:49:00 +0000</pubDate>
<dc:creator>可均可可</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/9045632.html</dc:identifier>
</item>
<item>
<title>TCP连接和 time_wait、close_waite - vinter_he</title>
<link>http://www.cnblogs.com/vinter/p/9045639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vinter/p/9045639.html</guid>
<description>&lt;p&gt;tags:time_wait close_waite RST TCP&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;引言：前两天朋友公司的服务器垮掉了，最后查出的原因是发现大量的time_wait网络状态。被问起来time_wait是什么，当时就简单的给解释了两句，后来想想正好博客没有特别好的话题，拿来写一下也很不错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单的描述产生原因&quot;&gt;简单的描述产生原因&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;因为本文较长，如果没有耐心的可以简单了解一下，有耐心的请阅读全文。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP是面向连接的，即使不知道具体的过程，也都知道TCP的三次握手，四次挥手。挥手也就是关闭连接，关闭连接的时候，主动关闭的一方在接收到被动关闭方的回应前，处于time_wait状态，并保持一段时间。close_wait是被动关闭方接收到关闭链接请求后所处的状态。&lt;br/&gt;查看状态的代码：&lt;/p&gt;
&lt;pre class=&quot;linux&quot;&gt;
&lt;code&gt;$ netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'

&amp;gt;结果
$ netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
CLOSE_WAIT 134
ESTABLISHED 245   //已经建立连接，正在传输状态
TIME_WAIT 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tcp的三次握手和四次挥手的状态转换&quot;&gt;TCP的三次握手和四次挥手的状态转换&lt;/h2&gt;
&lt;p&gt;要说清楚这个状态，需要了解一定的TCP知识，我们在这里简单介绍一下&lt;/p&gt;
&lt;h3 id=&quot;三次握手建立连接&quot;&gt;三次握手建立连接&lt;/h3&gt;
&lt;p&gt;TCP必须经过三次握手来建立可靠连接才能彼此传输数数据。假设请求方为客户端与服务端建立TCP连接&lt;/p&gt;
&lt;p&gt;在握手前，TCP服务器进程已经创建传输控制块TCB（传输控制模块，记录TCP&lt;br/&gt;运行过程中的变量），准备接受客户连接请求，此时服务器进入LISTEN（监听）状态；&lt;br/&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;：TCP客户端先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，初始序列号 seq=x ，TCP客户端进程进入了SYN_SENT（同步已发送）状态。TCP协议中SYN报文段（SYN=1的报文段）不携带数据，但需要消耗掉一个序号（序号每次报文要递增）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;：服务端在收到客户端发过来的SYN请求报文后，如果同意连接，则发出确认报文。确认报文ACK=1，SYN=1，确认号是ack=x+1（这个ack是确认号，大写的ACK是标志位，文章最末尾有各个标志位的简单介绍），同时自己也初始化一个序列号 seq=y，此时，服务器TCP进程进入了SYN_RCVD（收到同步）状态。这个SYN同样不携带数据，且消耗一个序号。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;：客户端口收到服务端发过来的SYN和ACK确认报文后，还要向服务器给出确认，确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，客户端状态由原来的SYN_SENT状态变为ESTABLISHED（连接已确认建立）。TCP协议中ACK报文可以携带数据，携带数据的时候消耗序号&lt;/p&gt;
&lt;p&gt;服务端收到报文后，由原来的SYN_RCVD变为ESTABLISHED，双方开始通信&lt;/p&gt;
&lt;p&gt;三次握手有一个很形象的比喻&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//客户端和服务端打电话
客户端：服务端你能听见吗
服务端：哎，能听见，你能听见我说话吗
客户端：能听见，有点事找你(如果没有这一步，服务端并不知道客户端是否能听见)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四次挥手关闭连接&quot;&gt;四次挥手关闭连接&lt;/h3&gt;
&lt;p&gt;先来解释一个TCP连接到底是谁关闭的，一般来说，谁断开都可以，对于我们常用的http来说，一般情况下是这样的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于http1.0协议
&lt;ol&gt;&lt;li&gt;如果响应头中有content-length头，则以content-length的长度就可以知道body的长度了，客户端在接收body时，就可以依照这个长度来接收数据，接收完后，就表示这个请求完成了，客户端请求断开。&lt;/li&gt;
&lt;li&gt;如果没有content-length头，则客户端会一直接收数据，直到服务端主动断开连接，才表示body接收完了。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;对于http1.1协议
&lt;ol&gt;&lt;li&gt;如果响应头中的Transfer-encoding为chunked传输，则表示body是流式输出，body会被分成多个块，每块的开始会标识出当前块的长度，此时，body不需要通过长度来指定，客户端主动请求断开。&lt;/li&gt;
&lt;li&gt;如果是非chunked传输，而且有content-length，则按照content-length来接收数据，接收完成后客户端请求断开连接。&lt;/li&gt;
&lt;li&gt;如果是非chunked，并且没有content-length，则客户端接收数据，直到服务端主动断开连接。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;下面说四次挥手的过程&lt;/strong&gt;&lt;br/&gt;我们假设客户端是请求关闭连接的一方，服务端为被动关闭&lt;br/&gt;&lt;strong&gt;第一次挥手&lt;/strong&gt;：客户端进程发请求关闭（或称释放）连接报文，并且停止发送数据。数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT_1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。&lt;br/&gt;&lt;strong&gt;第二次挥手&lt;/strong&gt;：服务器收到请求关闭报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE_WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态持续的时间。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;客户端收到服务器的确认请求后，此时，客户端就进入FIN_WAIT_2（终止等待2）状态，等待服务器发送关闭连接报文（在这之前还需要接受服务器发送的最后的数据）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;第三次挥手&lt;/strong&gt;：服务器将最后的数据发送完毕后（或者没有需要发送的数据），就向客户端发送关闭连接报文，FIN=1，ack=u+1。由于服务器很可能又发送了一些数据，所以假定此时的序列号为seq=w，此时，服务器就进入了LAST_ACK（最后确认）状态，等待客户端的确认。&lt;br/&gt;&lt;strong&gt;第四次挥手&lt;/strong&gt;：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2MSL（最大报文段寿命）的时间，当客户端撤销相应的TCB后，才进入CLOSED状态。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;服务器只要收到了客户端发出的确认，立即进入CLOSED状态。撤销TCB后，就结束了这次的TCP连接。可以看到，服务器（被动断开方）结束TCP连接的时间要比客户端（主动断开方）早一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;//客户端和服务端打电话
客户端：我的事说完了，有事情你说我听着，没什么事挂了哈
服务端：好的知道了，（好的，我还要和你说个事，你妈叫你回家吃饭）
服务端：行了挂了吧
客户端：哦，知道了，那我挂了&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关于为什么要等待2msl&quot;&gt;关于为什么要等待2MSL：&lt;/h4&gt;
&lt;p&gt;MSL（Maximum Segment Lifetime），这是TCP 对TCP Segment 生存时间的限制。&lt;br/&gt;客户端发送最后一个ACK后，不能确保服务端一定能收到，假如ACK没有被服务端收到，超时后服务端重新进行第三次挥手，这时候如果A还在等待，又收到第三次挥手的FIN消息，证明ACK没有成功到达，这个时间至少是：服务端的超时时间 + FIN的传输时间，为了保证可靠，采用更加保守的等待时间2MSL。&lt;br/&gt;如果客户端此时没有在等待状态直接CLOSED，服务端超时后发送FIN消息到客户端，客户端表示并不知道这数据包是干什么的，所以响应一个RST（用来异常的关闭连接，请自行了解）,如果客户端有一个和服务端的新连接在这个端口上建立。这将可能导致后面建立的连接受到影响，TCP是可靠的连接，所以是不希望这种不靠谱的事情出现的。这种错误可以比喻为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//客户端和服务端打电话
客户端：我的事说完了，有事情你说我听着，没什么事挂了哈
服务端：好的知道了，（好的，我还要和你说个事，你妈叫你回家吃饭）
服务端：行了挂了吧
客户端：哦，知道了，那我挂了
（上面这一句因为信号不好等原因服务端没收到客户端就挂了电话）后面有事情又拨通了服务端电话（建立了新连接）
服务端：挂了吧
客户端：怎么回事，蛇精病啊，刚通了就让我挂&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tcp报文首部标志位&quot;&gt;TCP报文首部标志位&lt;/h2&gt;
&lt;p&gt;关于报文首部格式，网上有很多，而且大部分都是以正确的，下面只介绍和本文有关的，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;标志位：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SYN(synchronous建立联机)&lt;br/&gt;在连接建立时用来同步序号，当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意时，则应在响应的报文段中使SYN=1和ACK=1，因此，SYN置1就表示这是一个连接请求或连接接受报文。&lt;/li&gt;
&lt;li&gt;ACK(acknowledgement 确认)&lt;br/&gt;仅当ACK=1时确认号字段才有效，TCP规定，连接建立后所有传送的报文段都必须把ACK置1.&lt;/li&gt;
&lt;li&gt;PSH(push传送)&lt;br/&gt;当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送操作。&lt;/li&gt;
&lt;li&gt;FIN(finish结束)&lt;br/&gt;用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。&lt;/li&gt;
&lt;li&gt;RST(reset重置)&lt;br/&gt;当RST=1时，表明TCP连接中出现严重错误，必须释放连接，然后再重新建立运输连接。&lt;/li&gt;
&lt;li&gt;URG(urgent紧急)&lt;br/&gt;当URG=1时，表明紧急字段有效，告诉系统此报文中有紧急数据，应尽快传送。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;其他：
&lt;ol&gt;&lt;li&gt;Sequence number(顺序号码)&lt;br/&gt;seq是发送的数据包本身的序列号；&lt;/li&gt;
&lt;li&gt;Acknowledge number(确认号码)&lt;br/&gt;ack是对收到的数据包的确认，值是等待接收的数据包的序列号。即期望对方继续发送的那个数据包的序列号。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 16 May 2018 05:49:00 +0000</pubDate>
<dc:creator>vinter_he</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vinter/p/9045639.html</dc:identifier>
</item>
<item>
<title>博客园美化终极版-（自定义导航栏）----什么CSDN、简书、腾讯云专栏、个人博客和微信公众号都弱爆了 - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/9045404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/9045404.html</guid>
<description>&lt;h2&gt;自定义导航栏和背景图片&lt;/h2&gt;
&lt;p&gt;     &lt;span&gt;  上一篇：&lt;a href=&quot;http://www.cnblogs.com/derek1184405959/p/9018285.html&quot;&gt;博客园美化大全&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在上一篇博客中已经介绍了 自动生成目录、返回顶部、爱心特效、添加github图标、扩大和缩小、设置签名、添加分享和推荐反对功能，这一篇介绍怎么自定义导航栏。&lt;/p&gt;
&lt;p&gt; 效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180516123332677-221388382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1.自定义导航栏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 我的博客皮肤用的是AnotherEon001,假如你的博客用的是其它皮肤，样式需要自己修改，要想达到一样的效果，建议也用同款皮肤&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180516123547687-874636814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（1）把默认的导航栏给隐藏掉&lt;/p&gt;
&lt;p&gt;既然我们想要自定义导航栏，默认的导航栏就不能显示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;header{display:none;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）页首html代码&lt;/p&gt;
&lt;p&gt;里面一个ul包含很多div（一个div代表一个分类），div里面是下拉框（a标签，里面是你的博客文章地址），自己可以随意增加删除分类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;text-align: center;font-size:35px;margin-bottom:19px;margin-top:20px;opacity: 0.5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Zhang_derek&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;test33&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;margin-left:0px;margin-right: 0px;&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;test11&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
     
     

     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;https://www.cnblogs.com/&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;22px;opacity: 0.2;font-size: 18px&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;博客园&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;opacity: 0.2;font-size: 18px&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;我的首页&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;全部分类&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1131360.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;1.Python基础&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1214771.html&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;2.Django基础&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1174868.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;3.Django项目&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1192235.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;4.REST framework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1206098.html&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;5.CRM客户关系管理&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1214770.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;6.前端&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cuiqingcai.com/&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;7.数据库&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1212517.html&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;8.python进阶&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1214774.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;9.数据库&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1163820.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10.爬虫&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 


        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Flask基础&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/9027171.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;1.快速入门&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/9028895.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;2.请求扩展和数据库连接池&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/9031618.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;3.信号和wtforms&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/9032613.html&quot;&lt;/span&gt;  &lt;span&gt;&amp;gt;&lt;/span&gt;4.SQLAlchemy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 



      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Python基础&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8041517.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.简介&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8041926.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.数据类型&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8042679.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.文件操作&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8043411.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.迭代器生成器装饰器&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8044289.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.函数&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8065488.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.内置函数&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                       
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8078948.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7.常用模块&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1131360.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;更多&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   





        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Django基础&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8338229.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.安装与运行&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8351759.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.路由规则&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8377735.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.Model&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8421195.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.模板语言与分页&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8442120.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.Cookie&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8445045.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.Session&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8445842.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7.CSRF 中间件&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1214771.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;更多&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 





        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;项目相关&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8712206.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.REST framework 源码分析&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8567522.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.用户注册和登录系统&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8590360.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.在线教育平台&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8733194.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.生鲜超市&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1206098.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;5.CRM客户关系管理
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1215982.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;6.Flask构建微电影
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1174868.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;更多&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    



         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Python进阶&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/9005830.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.魔法函数&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/9011453.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.深入类和对象&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
             
         
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1212517.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;更多&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Python爬虫&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8448875.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.urllib和urllib2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8449159.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.Opener和Requests&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8449682.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.XPATH和BeautifulSoup4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8449923.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.利用多线程爬虫&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8450130.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.Selenium模拟用户操作&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8450342.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.Scrapy框架原理介绍&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8450457.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7.Spider类&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1163820.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;更多&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

       
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;前端知识&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8313575.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.HTML&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8322341.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.CSS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8324589.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.Javascript&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8324860.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.Dom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8331168.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.Jquery&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8331789.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.Jquery实例&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/p/8447397.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7.Ajax&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cnblogs.com/derek1184405959/category/1214770.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;更多&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

      
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;学习资源&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://docs.djangoproject.com/en/2.0/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.Django2.0官网&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.django-rest-framework.org/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.REST framework官网&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://docs.jinkan.org/docs/flask/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.Flask文档&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.runoob.com/bootstrap/bootstrap-tutorial.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.Bootstrap教程&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://blog.didiaoyuan.com/2017/04/18/%E6%80%BB%E6%9C%89%E4%BD%A0%E8%A6%81%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%A6%E5%8D%95(GitHub)/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.总有你要的书单&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.pythondoc.com&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.python中文学习大本营&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://cuiqingcai.com/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;7.爬虫学习博客&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://www.pythondoc.com/flask-mega-tutorial/index.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8.The Flask Mega-Tutorial &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://ondras.zarovi.cz/sql/demo/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;9.表设计工具 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://flask.pocoo.org/extensions/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10.Flask extensions&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;#&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;dropbtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;娱乐休闲&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;dropdown-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://weibo.com/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.微博&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://720yun.com/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.全景图片欣赏&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://yingyu.xdf.cn/list_907_1.html&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.双语阅读&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;http://china.nba.com/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.NBA&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://www.toutiao.com/&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.今日头条&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;menu&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;https://tieba.baidu.com/f?kw=%C4%DA%BA%AD%B6%CE%D7%D3&amp;amp;fr=ala0&amp;amp;tpl=5&quot;&lt;/span&gt;&lt;span&gt;  target&lt;/span&gt;&lt;span&gt;=&quot;_Blank&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.内涵段子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; （3）页面定制css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#test33 ul &lt;/span&gt;{&lt;span&gt;
margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
list-style-type&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;去除li前的标注&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
background-color&lt;/span&gt;:&lt;span&gt; #333&lt;/span&gt;;&lt;span&gt;
overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;隐藏溢出的部分，保持一行&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;


#test33 li &lt;/span&gt;{&lt;span&gt;
float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;左浮动&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}&lt;span&gt;


#test33 li a, .dropbtn &lt;/span&gt;{&lt;span&gt;
display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置成块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
color&lt;/span&gt;:&lt;span&gt; white&lt;/span&gt;;&lt;span&gt;
text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
padding&lt;/span&gt;:&lt;span&gt; 14px 16px&lt;/span&gt;;
}&lt;span&gt;


#test33 li a:hover, .dropdown:hover .dropbtn &lt;/span&gt;{ &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;鼠标移上去，改变背景颜色&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
background-color&lt;/span&gt;:&lt;span&gt; blue&lt;/span&gt;;
}&lt;span&gt;


#test33 .dropdown &lt;/span&gt;{
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;display:inline-block将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内，允许空格。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
display&lt;/span&gt;:&lt;span&gt; inline-block&lt;/span&gt;;
}&lt;span&gt;


#test33 .dropdown-content &lt;/span&gt;{&lt;span&gt;
display&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
background-color&lt;/span&gt;:&lt;span&gt; #f9f9f9&lt;/span&gt;;&lt;span&gt;
min-width&lt;/span&gt;:&lt;span&gt; 160px&lt;/span&gt;;&lt;span&gt;
box-shadow&lt;/span&gt;:&lt;span&gt; 0px 8px 16px 0px rgba(0,0,0,0.2)&lt;/span&gt;;
}&lt;span&gt;


#test33 .dropdown-content a &lt;/span&gt;{&lt;span&gt;
display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;&lt;span&gt;
color&lt;/span&gt;:&lt;span&gt; black&lt;/span&gt;;&lt;span&gt;
padding&lt;/span&gt;:&lt;span&gt; 8px 10px&lt;/span&gt;;&lt;span&gt;
text-decoration&lt;/span&gt;:&lt;span&gt;none&lt;/span&gt;;
}&lt;span&gt;


#test33 .dropdown-content a:hover &lt;/span&gt;{&lt;span&gt;
background-color&lt;/span&gt;:&lt;span&gt; #a1a1a1&lt;/span&gt;;
}&lt;span&gt;


#test33 .dropdown:hover .dropdown-content&lt;/span&gt;{&lt;span&gt;
display&lt;/span&gt;:&lt;span&gt; block&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2.设置背景图片&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;给自己的博客设置一个好看的背景图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）首先在设置----&amp;gt;&amp;gt;&amp;gt;相册里面添加一张背景图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180516125347192-327718202.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; （2）页面定制css代码&lt;/p&gt;
&lt;p&gt;background-image里面的地址就是你相册里面添加的图片地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body &lt;/span&gt;{&lt;span&gt; 
     background-color&lt;/span&gt;:&lt;span&gt; #efefef&lt;/span&gt;;&lt;span&gt;
    background-image&lt;/span&gt;:&lt;span&gt;url(http://images.cnblogs.com/cnblogs_com/today-happy/1214264/t_blog.jpg)&lt;/span&gt;;&lt;span&gt; 
     background-repeat&lt;/span&gt;:&lt;span&gt; no-repeat&lt;/span&gt;;&lt;span&gt; 
     background-attachment&lt;/span&gt;:&lt;span&gt; fixed&lt;/span&gt;;&lt;span&gt; 
     background-position&lt;/span&gt;:&lt;span&gt; center 0&lt;/span&gt;;&lt;span&gt; 
     background-size&lt;/span&gt;:&lt;span&gt; cover&lt;/span&gt;;&lt;span&gt; 
    padding-top&lt;/span&gt;:&lt;span&gt;0px&lt;/span&gt;;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3.一个好看的时钟&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上一篇介绍了添加时钟，但是又发现了一个更好看的时钟，就分享给大家了，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180516125815422-960724980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （1）公告栏里面&lt;/p&gt;
&lt;p&gt;时钟的宽高按可以自己设置合适的大小&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;clockdiv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dom&quot;&lt;/span&gt;&lt;span&gt; width&lt;/span&gt;&lt;span&gt;=&quot;120&quot;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;=&quot;120&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;时钟canvas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;https://files.cnblogs.com/files/siwuxie095/clock.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）页面定制css代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;公告栏时钟&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#clockdiv &lt;/span&gt;{&lt;span&gt;

text-align&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果对你有帮助，记得在右下角点个“&lt;span&gt;推荐&lt;/span&gt;”哦！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 05:05:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/9045404.html</dc:identifier>
</item>
<item>
<title>UUID那些事 - 轩脉刃</title>
<link>http://www.cnblogs.com/yjf512/p/9045341.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjf512/p/9045341.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;UUID&lt;/a&gt; 是一个全局唯一的通用识别码。它使用某种规则，而不是某种中心化的自增方式，来保证这个识别码的全局唯一性。UUID 有非常多的使用场景，比如在分布式系统中，需要生成全局唯一 ID 来进行日志记录。UUID 的生成规则由 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;rfc4122&lt;/a&gt; 来进行定义。&lt;/p&gt;

&lt;p&gt;其实是没有区别的，GUID 是微软按照 UUID 的规则实现的一套方法。它本质的目的也是为了保证全局唯一性。微软已经使用 GUID 在 Windows 的 COM，ActiveX 等技术上了。但是这里注意的一点是，UUID 本质是有多种版本的，GUID 也是在不同的使用场景实现的是不同的 UUID 版本，比如 COM 是使用 UUID 版本1 进行实现的。所以，在聊 UUID 和 GUID 是不是一样的时候，附带的信息应该了解清楚版本信息。&lt;/p&gt;

&lt;p&gt;UUID 是有不同的版本的，每个版本有不同的适用场景，比如，版本4 建议使用随机方式生成所有的可变因子。在很多场景下，这个其实是一个非常方便的实现方式。版本1 使用的是 时间戳＋时钟序列＋节点信息（机器信息）在一些分布式系统场景下是能严格保证全局唯一的。twitter 的 &lt;a href=&quot;https://github.com/twitter/snowflake&quot;&gt;snowflake&lt;/a&gt; 可以看作是是 UUID 版本1 的简化版。&lt;/p&gt;
&lt;p&gt;到现在为止，UUID 一共有5个实现版本:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;版本1: 严格按照 UUID 定义的每个字段的意义来实现，使用的变量因子是时间戳＋时钟序列＋节点信息（Mac地址）&lt;/li&gt;
&lt;li&gt;版本2: 基本和版本1一致，但是它主要是和 DCE（ IBM 的一套分布式计算环境）。但是这个版本在 ietf 中也没有具体描述，反而在&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9668899/chap1.htm&quot;&gt;DCE 1.1: Authentication and Security Services&lt;/a&gt;这篇文档中说到了具体实现。所以这个版本现在很少使用到，并且很多地方的实现也都忽略了它。&lt;/li&gt;
&lt;li&gt;版本3: 基于 name 和 namespace 的 hash 实现变量因子，版本3使用的是 md5 进行 hash 算法。&lt;/li&gt;
&lt;li&gt;版本4: 使用随机或者伪随机实现变量因子。&lt;/li&gt;
&lt;li&gt;版本5: 基于 name 和 namespace 的 hash 实现变量因子，版本5使用的是 sha1 进行 hash 算法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不管是 UUID 的哪个版本，它的结构都是一样的，这个结构是按照版本1进行定义的，只是在其他版本中，版本1中的几个变量因子都进行了变化。&lt;/p&gt;

&lt;p&gt;UUID 长度是128bit，换算为16进制数值(每4位代表一个数值)就是有32个16进制数值组成，中间使用4个-进行分隔，按照8-4-4-4-12的顺序进行分隔。加上中间的横杆，UUID有36个字符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.funaio.cn/18-5-15/9674481.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图是 UUID 的具体结构。它的可变因子有三个，Timestamp 时间戳，Clock Sequence时钟序列，node节点信息。然后由他们的不同部分组成这个 UUID。&lt;/p&gt;
&lt;h2 id=&quot;timestamp&quot;&gt;Timestamp&lt;/h2&gt;
&lt;p&gt;时间戳是其中一个可变因子。时间戳有长度为 60bit。它代表现在当前UTC时间（必须使用UTC时间，这样就统一了时区）和1582-10-15 00:00:000000000，每100纳米加一。对于无法获取UTC时间的系统，由于获取不到UTC，那么你可以统一采用 localtime。（实际上一个系统时区相同就可以了）。&lt;/p&gt;
&lt;p&gt;有了时间戳之后，结构图中的time_low，time_mid，time_hi就知道了&lt;/p&gt;
&lt;h3 id=&quot;time_low&quot;&gt;time_low&lt;/h3&gt;
&lt;p&gt;是 timestamp 60bit 中的 0～31bit，共32bit&lt;/p&gt;
&lt;h3 id=&quot;time_mid&quot;&gt;time_mid&lt;/h3&gt;
&lt;p&gt;是 timestamp 60bit 中的 32～47bit，共16bit&lt;/p&gt;
&lt;h3 id=&quot;time_hi_and_version&quot;&gt;time_hi_and_version&lt;/h3&gt;
&lt;p&gt;这个字段的意思很明确，就是包含两个部分，version 和 time_hi。version 占用 bit 数为4. 代表它最多可以支持31个版本。time_hi就是timestamp剩余的12bit，一共是16bit。&lt;/p&gt;
&lt;h2 id=&quot;clock-sequence&quot;&gt;Clock Sequence&lt;/h2&gt;
&lt;p&gt;如果计算 UUID 的机器进行了时间调整，或者是 nodeId 变化了（主机更换网卡），和其他的机器冲突了。那么这个时候，就需要有个变量因子进行变化来保证再次生成的 UUID 的唯一性。&lt;/p&gt;
&lt;p&gt;其实Clock Sequence的变化算法很简单，当时间调整，或者 nodeId 变化的时候，直接使用一个随机数，或者，在原先的Clock Sequence值上面自增加一也是可以的。&lt;/p&gt;
&lt;p&gt;Clock Sequence 一共是14bit&lt;/p&gt;
&lt;h3 id=&quot;clock_seq_low&quot;&gt;clock_seq_low&lt;/h3&gt;
&lt;p&gt;是 Clock Sequence 中的 0～7 bit 共8bit&lt;/p&gt;
&lt;h3 id=&quot;clock_seq_hi_and_reserved&quot;&gt;clock_seq_hi_and_reserved&lt;/h3&gt;
&lt;p&gt;包含两个部分，reserved 和 clock_seq_hi。其中 clock_seq_hi 为 Clock Sequence 中的 8～13 bit 共6个bit，reserved是2bit，reserved 一般设置为10。&lt;/p&gt;
&lt;h2 id=&quot;node&quot;&gt;node&lt;/h2&gt;
&lt;p&gt;node 这个变量因子由MAC地址组成，通常是IP地址。它有48bit大小。其中的 0-15填入node(0-1)的位置，16-47填入node(2-5)的位置。&lt;/p&gt;

&lt;p&gt;基本上，按照上节说的已经把 UUID 的结构构成说明清楚了。基本上这个结构构成是 UUID version1 的定义。我们可以看到，它有的变量因子是 timestamp， clock sequence, node。&lt;/p&gt;
&lt;p&gt;在不同版本中，这几个变量因子的含义是不同的。&lt;/p&gt;
&lt;h2 id=&quot;version4&quot;&gt;version4&lt;/h2&gt;
&lt;p&gt;在version4 中，timestamp，clock sequence, node都是随机或者伪随机的。&lt;/p&gt;
&lt;h2 id=&quot;version35&quot;&gt;version3&amp;amp;5&lt;/h2&gt;
&lt;p&gt;version3和5 叫做基于 name 和 namesapce 的 hash 结构生成。其中的name 和namespace 基本上和我们很多语言的命名空间，类名一样，它的基本要求就是，name + namespace 才是唯一确定hash串的标准。换句话说，一样的namespace + name 使用的hash算法（比如version3的md5）计算出来的结果必须是一样的，但是不同的 namespace 中的同样的 name 生成的结果是不一样的。&lt;/p&gt;
&lt;p&gt;version3 和 version5 中的三个变量因子都是由hash 算法保证的，version3是 md5, version5是sha1。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;wiki&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://wsfdl.com/algorithm/2013/09/05/%E7%90%86%E8%A7%A3UUID.html&quot;&gt;理解UUID&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.importnew.com/22211.html&quot;&gt;分布式UniqueID的生成方法一览&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/d77f3ef0868a&quot;&gt;关于UUID的二三事&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 16 May 2018 04:25:00 +0000</pubDate>
<dc:creator>轩脉刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjf512/p/9045341.html</dc:identifier>
</item>
<item>
<title>升讯威微信营销系统开发实践：（4）源代码结构说明 与 安装部署说明（ 完整开源于 Github） - sheng.chao</title>
<link>http://www.cnblogs.com/sheng_chao/p/9045337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng_chao/p/9045337.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/span&gt;：&lt;a href=&quot;https://github.com/iccb1013/Sheng.WeixinConstruction&quot; target=&quot;_blank&quot;&gt;https://github.com/iccb1013/Sheng.WeixinConstruction&lt;/a&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;因为个人精力时间有限，不会再对现有代码进行更新维护，不过微信接口比较稳定，经测试至今没有变化，功能依然全部可用，你可以在此基础上，二次开发，完成你的业务功能，也可以抽取本平台中的代码复用在你的项目中，请遵循 MIT 开源协议保留我的版权声明和网站链接即可。&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;/span&gt;：&lt;a href=&quot;https://github.com/iccb1013/Sheng.WeixinConstruction.WeixinContract&quot; target=&quot;_blank&quot;&gt;https://github.com/iccb1013/Sheng.WeixinConstruction.WeixinContract&lt;/a&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;微信协议包装的项目还有一个单独的工程，这个工程的版本稍新，我会进行一定的更新维护，如最近增加了几个小程序开发需要使用到的接口。但是注意因为代码结构经过优化调整，直接引用到升讯威微信平台中，需要修改一些类的引用和名称。&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;升讯威微信营销系统开发实践系列&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/0fb606f8-5def-4c10-9896-c53f1c7cb8ea&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（1）功能概要与架构设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/1acfa439-8fef-4609-8e74-7057c9f15a3b&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（2）中控服务器的详细设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/14f5737e-bd4a-4185-8ab1-65c269c62baa&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（3）功能介绍与此项目推广过程的一些体会&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/f4c1a78b-7f4f-4efd-bb05-57ff95a5834b&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（4）源代码结构说明 与 安装部署说明&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这是2015年到2016年间业余时间写的一个项目，最初的期望是实现一个微信云平台，类似于微盟，只需要商家扫码绑定即可提供整套的营销功能。&lt;/p&gt;
&lt;p&gt;我的定位是专门服务于线下商家，例如电影院、商业中心、各类线下门店等，线下商家的一些业务场景和业务流程是比较特殊的，和纯现上的公众号运营不尽相同。   这是我最初想找到的切入点，在系统初步上线后，自己也试着做了推广，包括百度关键词、线下陌拜都尝试过，在之前的博客中我也简单讨论过一些细节。&lt;/p&gt;&lt;p&gt;我在之前的博客中开源了全部工程源代码和数据库脚本，陆续有朋友问我怎样安装部署，因为时间的关系我只能有一搭没一搭的回答一些零散的问题，对不住大家。前些天帮一个小兄弟把整个系统完整的部署起来并运行成功，我想索性借着这个机会，把这个过程整理出来，写成博客分享，这样大家从 Github 上拿到工程就不会不知从何开始。&lt;/p&gt;
&lt;p&gt;要了解升讯威微信营销系统的架构设计，请参阅之前我发表的博客，帮助你快速了解代码实现层面的体系结构。&lt;/p&gt;
&lt;p&gt;本文不再对宏观结构进行赘述，只从代码细节方面介绍几个关键的地方，帮助你快速了解代码的具体实现。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;功能概要：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;78019-20160824013824636-1389859091.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20170823/6363909377207507706764479.png&quot; alt=&quot;78019-20160824013824636-1389859091.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;有关架构设计，和详细功能介绍，请参阅我之前的博客文章。&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/0fb606f8-5def-4c10-9896-c53f1c7cb8ea&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（1）功能概要与架构设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/1acfa439-8fef-4609-8e74-7057c9f15a3b&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（2）中控服务器的详细设计&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;微信端效果：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;更详细的功能介绍请参阅：&lt;br/&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/14f5737e-bd4a-4185-8ab1-65c269c62baa&quot; target=&quot;_blank&quot;&gt;升讯威微信营销系统开发实践：（3）功能介绍与此项目推广过程的一些体会&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180516/6366203069748840098110648.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;在本文中我将分为两个部分，第一部分详细介绍代码层面的主要结构，第二部分详细介绍安装部署的方法。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;一）代码结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 Github 上获取代码后，源代码目录结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198482965795789324401.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198495213327753774804.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.Admin.sln&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;超级管理员、系统运维人员使用的超级管理后台。&lt;/p&gt;
&lt;p&gt;此部分功能开发并未完成，目前只有基本框架和微主页模版的简单管理功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.Container.sln&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;鉴权中控服务服务。&lt;/p&gt;
&lt;p&gt;负责管理和维护第三方平台自己的 AccessToken 和对接过来的所有公众号的 AccessToken。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.FileService.sln&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件服务器。&lt;/p&gt;
&lt;p&gt;提供独立文件存储服务，并提供了部分与微信公众号素材管理的功能。&lt;/p&gt;
&lt;p&gt;可以部署多个不同的文件服务器实例，可以部署CDN内容分发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.sln&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;管理后台和微信端。&lt;/p&gt;
&lt;p&gt;管理后台用于向升讯威微信管理系统的一般用户提供服务，在此注册账户，对接自己的公众号，并使用升讯威微信营销系统的一系列功能。&lt;/p&gt;
&lt;p&gt;微信端用于向所对接的公众号提供服务，在微信公众号上访问的站点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.WindowsService.sln&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Windows 服务&lt;/p&gt;
&lt;p&gt;主要用来执行一些定时服务。&lt;/p&gt;

&lt;p&gt;下面主要对解决方案 Sheng.WeixinConstruction.sln 和 Sheng.WeixinConstruction.Container.sln 进行说明，其它几个解决方案都比较简单，不作赘述。&lt;/p&gt;

&lt;p&gt;打开 Sheng.WeixinConstruction.sln 之后，结构如图：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198502867199304589531.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.Management.Shell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后台站点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.Client.Shell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信端站点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1）Sheng.WeixinConstruction.Management.Shell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198505194494562315770.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于管理后台，一个重要的功能是在用户注册账号后，实现与微信公众号的对接。&lt;/p&gt;

&lt;p&gt;打开 Controllers 目录下的 SettingsController.cs ，并展开“对接”region。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;3.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198536309599866026081.JPG&quot; alt=&quot;3.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Docking 与 DockingDemo 对应着用户对接公众号的页面。 DockingDemo是发起授权页的体验URL：用于腾讯审核人员前往授权页体验，确认流程可用性。此为腾讯要求。&lt;/p&gt;

&lt;p&gt;AuthorizerEntity 表示授权公众号的信息，代码中有详细的注释，可自行查阅：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;4.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198537598395592288608.JPG&quot; alt=&quot;4.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在用户对接公众号时，需要先获取一个预授权码，打开 Areas /Api/ Controllers 目录下的 SettingsController.cs，找到 GetPreAuthCode 方法，此方法用于获取预授权码：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;5.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198538461987784782867.JPG&quot; alt=&quot;5.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Docking.cshtml 这个画面调用此接口，当成功获取预授权码之后，将页面转到腾讯要求的授权页面，并给出一个用于完成授权的回调页面，当公众号所有者通过授权时，腾讯将把页面转到此回调页面，并传回授权码：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;6.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198539209464319033085.JPG&quot; alt=&quot;6.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开 Controllers目录下的 SettingsController.cs，找到 AuthorizationCallback 这个授权回调方法，在此完成公众号的授权对接：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;7.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198539973640557699516.JPG&quot; alt=&quot;7.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里留意一个细节：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;8.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198540655002571252506.JPG&quot; alt=&quot;8.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在系统中创建公众号授权信息，并开始维护它的 AccessToken ，并不是在后台中完成，而是调用鉴权中控服务器的接口，通知鉴权中控服务器来实现的：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;9.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198541451015207416637.JPG&quot; alt=&quot;9.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;_createAuthorizerUrl 是鉴权中控服务器的地址：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;10.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198542306306698939081.JPG&quot; alt=&quot;10.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，就完成了微信第三方平台，向公众号提供服务的授权对接工作。&lt;/p&gt;
&lt;p&gt;管理后台的其它功能同其它管理系统后台并无太大差别，可自行查阅代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2） Sheng.WeixinConstruction.Client.Shell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198529095776106694008.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微信端除了向所对接的公众号提供服务外，还负责与微信官方后台行进消息通信，微信官方下发的消息，是发到Sheng.WeixinConstruction.Client.Shell，而不是 Sheng.WeixinConstruction.Management.Shell。&lt;/p&gt;

&lt;p&gt;所以最重要的是首先要处理好微信推送过来的消息，打开 Controllers 目录下的 ThirdPartyWeixinApiController.cs：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;11.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198543236598763061640.JPG&quot; alt=&quot;11.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Handler 接口用于接收公众号消息与事件推送。&lt;/p&gt;
&lt;p&gt;当普通微信用户向公众账号发消息时，微信服务器将POST消息的XML数据包到此接口。&lt;/p&gt;
&lt;p&gt;在微信用户和公众号产生交互的过程中，用户的某些操作会使得微信服务器通过事件推送的形式通知，在开发者中心处设置的服务器地址，从而开发者可以获取到该信息。其中，某些事件推送在发生后，是允许开发者回复用户的，某些则不允许。作为第三方平台运营时，AppId 会作为URL的一部分带过来，如：&lt;/p&gt;
&lt;p&gt;http://wxc.shengxunwei.com/ThirdPartyWeixinApi/Handler/$APPID$&lt;/p&gt;
&lt;p&gt;其中$APPID$在实际推送时会替换成所属的已授权公众号的appid。&lt;/p&gt;

&lt;p&gt;推送消息过来时，URL如下格式：&lt;/p&gt;
&lt;p&gt;http://wxc.shengxunwei.com/WeixinApi/Handler/F6AAD430-CA1F-4AFD-B2B0-6E0D2FABB622&lt;/p&gt;
&lt;p&gt;?signature=84001ea92e2f369642e861d557b9f4c6781db1ca&lt;/p&gt;
&lt;p&gt;&amp;amp;timestamp=1446393828&lt;/p&gt;
&lt;p&gt;&amp;amp;nonce=1291578710&lt;/p&gt;
&lt;p&gt;&amp;amp;encrypt_type=aes&lt;/p&gt;
&lt;p&gt;&amp;amp;msg_signature=3ed4a96dbc50d491664ec3f425eb7fc1f088ac9b&lt;/p&gt;

&lt;p&gt;在接收到POST过来的消息后，第一步需要先解密，然后找到这条消息应该归属哪个微信公众号，找到它对应的公众号上下文，把解密后的消息交给它处理。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;12.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198545936460787412988.JPG&quot; alt=&quot;12.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ClientDomainContext 是微信端使用的公众号上下文，有关公众号上下文的详细说明，请参阅：&lt;/p&gt;
&lt;p&gt;升讯威微信营销系统开发实践：（2）中控服务器的设计&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.shengxunwei.com/Home/Post/1acfa439-8fef-4609-8e74-7057c9f15a3b&quot;&gt;http://blog.shengxunwei.com/Home/Post/1acfa439-8fef-4609-8e74-7057c9f15a3b&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 ClientDomainContext 中，引用了一个 XMLMessageReceiverFactory 的工厂类用于处理微信推送过来的XML消息：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;13.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198548594622097592993.JPG&quot; alt=&quot;13.JPG&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;14.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198549229889309988732.JPG&quot; alt=&quot;14.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个工厂类中，_receiverList 保存了处理不同消息所需要的具体实现，这些消息接收器的实现，定义在Sheng.WeixinConstruction.Client.Core：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;15.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198551678670591541265.JPG&quot; alt=&quot;15.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么当收到微信推送的消息时，只需找到对应公众号的上下文对象，调用它的 Handle方法，根据消息的类型，找到对应的处理器类，交给它处理，就可以了，这就是消息处理的过程。&lt;/p&gt;

&lt;p&gt;在微信端，还有一件非常重要的工作，就是对公众号关注者的身份获取，OpenId和用户信息，例如：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;16.jpg&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198554742113687247734.jpg&quot; alt=&quot;16.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当公众号的关注者（粉丝）访问微信端的页面时，需要获取关注者的个人身份信息，OpenId和其它信息，在此基础之上，与我们自己后台的信息关联。&lt;/p&gt;

&lt;p&gt;打开 Controllers 目录下的 ClientBasalController，微信端视图控制器类都继承此基类：&lt;/p&gt;
&lt;p&gt;当公众号的关注者访问微信端的页面时，首先控制器基类会获取该关注者的会员信息上下文和对应的公众号上下文：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;17.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198557921379787565343.JPG&quot; alt=&quot;17.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在OnActionExecuting 方法中，按微信的协议要求完成对关注者身份的网页授权。&lt;/p&gt;
&lt;p&gt;这里要先了解所服务公众号的域名解析细节，假设我们将微信端的域名配置为 wxc.shengxunwei.com，理论上我们让所有的公众号直接使用此页面，在URL后跟上公众号的ID即可，但是这样有一个重要的缺陷，如果平台所服务的公众号，有一个公众号存在违规行为，被微信查封，会导致我们整个平台被封，微信会直接把 wxc.shengxunwei.com 这个域名查封。所以我们必须泛解析的方式，让所服务的公众号使用 appid.wxc.shengxunwei.com 这样的域名来避免这种情况。如何在安装部署升讯威微信营销系统时配置泛解析域名，请参阅安装部署相关的详细说明。&lt;/p&gt;

&lt;p&gt;网页授权的过程在 OnActionExecuting 方法中有详细的注释说明，可对照着代码来看：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;18.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198559371214089068845.JPG&quot; alt=&quot;18.JPG&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;19.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198560620069474389274.JPG&quot; alt=&quot;19.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意对关注者身份的网页授权是跳转到微信官方授权页面进行的，完成授权后，会跳转回指定的回调页面，在 Areas/Api/Controllers 目录下的 ThirdPartyWeixinApi/OAuthCallback，代码中有详细的注释，请自行查阅：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198563507631654667799.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;21.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198564086939299163716.JPG&quot; alt=&quot;21.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，对关注者身份的网页授权完成。&lt;/p&gt;

&lt;p&gt;还有一个前端页面 JS授权的方式，在微信支付时会涉及到，你可以找到 ClientDomainContext下的GetJsApiConfig方法来查阅：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;22.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198565986685286663197.JPG&quot; alt=&quot;22.JPG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，微信端也实现了微信支付功能，用于会员充值或积分商品购买商品：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;23.jpg&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198567201554313082271.jpg&quot; alt=&quot;23.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微信支付的流程简而言之，需要先调用微信提供的统一下单接口，在微信支付端实现一个下单操作，这个下单和我们系统自身的下单是两个概念，完成统一下单后，生成相关信息给前端页面，前端页面调用微信提供的 js sdk 完成支付，支付成功后，微信服务器会向我们指定的回调 url 地址发出支付结果的通知。详细的流程，请查阅微信官方的开发文档。&lt;/p&gt;

&lt;p&gt;我在 Areas/Api/Controllers/PayController.cs 中实现了相关功能：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img title=&quot;24.JPG&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198568879127956156875.JPG&quot; alt=&quot;24.JPG&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二）安装部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）微信开放平台配置说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注册申请微信开放平台&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://open.weixin.qq.com/&quot;&gt;https://open.weixin.qq.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在第三方平台中，创建第三方平台。创建成功后，获得所创建第三方平台的 AppId 和 AppSecret。&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;微信第三方后台配置2.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198671039085028025444.png&quot; alt=&quot;微信第三方后台配置2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并按提示配置好“授权登录相关”和“授权后实现业务”中的各项参数。&lt;/p&gt;
&lt;p&gt;关于几个 URL 的配置，需要先了解升讯威微信营销系统的架构，可以参考相关博客文章和下文的站点部署说明部分。&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;微信第三方后台配置.png&quot; src=&quot;http://blog.shengxunwei.com/ueditor/net/upload/image/20180515/6366198658093111589078419.png&quot; alt=&quot;微信第三方后台配置.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;登录授权的发起页域名：管理端域名，如 wxcm.shengxunwei.com，不需要填写协议部分 http 或 https。&lt;/p&gt;
&lt;p&gt;授权事件接收URL：http://鉴权中控服务域名/ThirdPartyAuth/Handler&lt;/p&gt;
&lt;p&gt;消息与事件接收URL：http://微信端域名/ThirdPartyWeixinApi/Handler/$APPID$&lt;/p&gt;
&lt;p&gt;公众号开发域名：管理端域名和微信端域名，如 wxcm.shengxunwei.com;wxc.shengxunwei.com&lt;/p&gt;
&lt;p&gt;白名单IP地址列表填写你的服务器IP地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2）安装Redis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;可以准备一台 Linux 服务器安装：&lt;/p&gt;
&lt;p&gt;https://redis.io/download&lt;/p&gt;
&lt;p&gt;也可以下载 Windows 版本安装在 Windows 服务器：&lt;/p&gt;
&lt;p&gt;https://github.com/MicrosoftArchive/redis&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;br/&gt;3）站点部署说明&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.Client.Shell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案：Sheng.WeixinConstruction.sln&lt;/p&gt;
&lt;p&gt;所对接过来的公众号所使用的站点。&lt;/p&gt;
&lt;p&gt;微信端在部署时使用的域名，必须在你的域名服务端后台开启泛解析，因为对接过来的公众号，会使用 appid 开始的二级或三级域名过时行访问。&lt;/p&gt;
&lt;p&gt;假设你的微信端域名是 wxc.shengxunwei.com ，那么对接过来的公众号将使用 $APPID$.wxc.shengxunwei.com 作为域名。这样避免因某个公众号出现违规内容被封，影响到其它公众号甚至整个平台。&lt;/p&gt;

&lt;p&gt;IIS绑定参考：&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr class=&quot;firstRow&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;主机名&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;端口&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;IP地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;wxc.shengxunwei.com&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;80&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;80&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;br/&gt;注意，要添加一个不指定主机名的绑定，并使用80端口，与泛解析对应。&lt;/p&gt;

&lt;p&gt;WebConfig的配置：&lt;/p&gt;
&lt;p&gt;connectionStrings节点下：&lt;/p&gt;
&lt;p&gt;DefaultConnection配置主数据库 WxConstruction 的连接串，LoggingConnection 配置日志库 WxLogging 的连接串。&lt;/p&gt;
&lt;p&gt;appSettings节点下：&lt;/p&gt;
&lt;p&gt;debug：false，正常运行发布模式，如果设置为true，则开始调试模式，不走微信鉴权，直接模拟一个访问者身份，方便本地开发调试。&lt;/p&gt;
&lt;p&gt;FileService：文件服务器的地址，如：http://wxcfile1.shengxunwei.com/&lt;/p&gt;
&lt;p&gt;ContainerService：鉴权中控服务的地址，可以使用内网地址，只要项目能访问到即可，如：&lt;a href=&quot;http://localhost:8013/&quot;&gt;http://localhost:8013/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ClientAddress：微信端的地址，注意必须加上 $APPID$，如：&lt;a href=&quot;http://%24appid%24.wxc.shengxunwei.com/&quot;&gt;http://$APPID$.wxc.shengxunwei.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IntranetIp：微信端自身的内网IP 地址，用于其它服务发起回调使用，使用公网地址也可以，只要能被其它服务，如文件服务访问到即可，如：127.0.0.1&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Sheng.WeixinConstruction.Container&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鉴权中控服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案：Sheng.WeixinConstruction.Container.sln&lt;/p&gt;
&lt;p&gt;鉴权中控服务的中提供的 API分为两部分，一部分开放给微信第三方平台调用，另一部分为升讯威微信营销系统自己使用，对于后者，我们使用内网IP地址加端口号的方式访问即可，同时在webconfig 中，配置上允许调用的IP地址白名单，防止未经许可的调用。&lt;/p&gt;

&lt;p&gt;IIS绑定参考：&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr class=&quot;firstRow&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;主机名&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;端口&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;IP地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;8013&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;wxauth.你的域名&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;80&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;WebConfig的配置：&lt;/p&gt;
&lt;p&gt;connectionStrings节点下：&lt;/p&gt;
&lt;p&gt;DefaultConnection配置主数据库 WxConstruction 的连接串，LoggingConnection 配置日志库 WxLogging 的连接串。&lt;/p&gt;
&lt;p&gt;appSettings节点下：&lt;/p&gt;
&lt;p&gt;Redis：Redis服务的地址和端口号。&lt;/p&gt;
&lt;p&gt;AllowedIPList：IP地址白名单，逗号分隔，只有从这些IP 地址发起的请求，才被允许访问中控服务器的全部接口。&lt;/p&gt;
&lt;p&gt;ContainerService：鉴权中控服务的地址，可以使用内网地址，只要项目能访问到即可，如：&lt;a href=&quot;http://localhost:8013/&quot;&gt;http://localhost:8013/&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Management.Shell&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案：Sheng.WeixinConstruction.sln&lt;/p&gt;
&lt;p&gt;升讯威微信营销系统的后台，用户在此注册账户后，对接到自己的公众号并使用相关功能。&lt;/p&gt;

&lt;p&gt;IIS绑定参考：&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr class=&quot;firstRow&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;主机名&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;端口&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;IP地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;wxcm.shengxunwei.com&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;80&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;WebConfig的配置：&lt;/p&gt;
&lt;p&gt;connectionStrings节点下：&lt;/p&gt;
&lt;p&gt;DefaultConnection配置主数据库 WxConstruction 的连接串，LoggingConnection 配置日志库 WxLogging 的连接串。&lt;/p&gt;
&lt;p&gt;appSettings节点下：&lt;/p&gt;
&lt;p&gt;debug：false，正常运行发布模式，如果设置为true，则开始调试模式。&lt;/p&gt;
&lt;p&gt;FileService：文件服务器的地址，用户从后台上传的文件，将被上传到文件服务器中进行存储，如：http://wxcfile1.shengxunwei.com/&lt;/p&gt;
&lt;p&gt;ContainerService：鉴权中控服务的地址，可以使用内网地址，只要项目能访问到即可，如：&lt;a href=&quot;http://localhost:8013/&quot;&gt;http://localhost:8013/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ClientAddress：微信端公众号所使用的域名地址，如http://$APPID$.wxc.shengxunwei.com/&lt;/p&gt;
&lt;p&gt;emailPassword：发邮件功能中邮件服务器的密码。&lt;/p&gt;
&lt;p&gt;Redis：Redis服务的地址和端口号。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;FileService&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方案：Sheng.WeixinConstruction.FileService.sln&lt;/p&gt;
&lt;p&gt;升讯威微信营销系统的文件服务器，可以部署多个实例，后台上传的文件将被存储在这里。同时，它还兼具与微信后台中的素材管理接口一部分互通和功能实现。&lt;/p&gt;

&lt;p&gt;IIS绑定参考：&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr class=&quot;firstRow&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;主机名&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;端口&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;IP地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;http&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;wxcfile1.shengxunwei.com&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;80&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;138&quot;&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;WebConfig的配置：&lt;/p&gt;
&lt;p&gt;connectionStrings节点下：&lt;/p&gt;
&lt;p&gt;DefaultConnection配置主数据库 WxConstruction 的连接串，LoggingConnection 配置日志库 WxLogging 的连接串，FileConnection配置文件数据库WxConstruction_File的连接串。&lt;/p&gt;
&lt;p&gt;appSettings节点下：&lt;/p&gt;
&lt;p&gt;ContainerService：鉴权中控服务的地址，可以使用内网地址，只要项目能访问到即可，如：&lt;a href=&quot;http://localhost:8013/&quot;&gt;http://localhost:8013/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ServerPath：部署的实际物理路径地址，如：D:\wwwroot\WeixinConstruction\FileService\&lt;/p&gt;
&lt;p&gt;Redis：Redis服务的地址和端口号。&lt;/p&gt;

&lt;p&gt;文件服务的 MIME类型需要添加：&lt;/p&gt;
&lt;p&gt;.mp4 - video/mpeg4&lt;/p&gt;

&lt;p&gt;至此，代码结构和安装部署说明结束，如有其它疑问，可以与我联系留言。&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;http://blog.shengxunwei.com/weixinGroupQrCode.jpg?t=1&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;507&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 16 May 2018 04:23:00 +0000</pubDate>
<dc:creator>sheng.chao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheng_chao/p/9045337.html</dc:identifier>
</item>
</channel>
</rss>