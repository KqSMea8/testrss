<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Effective Java 第三版——10. 重写equals方法时遵守通用约定 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8148667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8148667.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然&lt;code&gt;Object&lt;/code&gt;是一个具体的类，但它主要是为继承而设计的。它的所有非 final方法(equals、hashCode、toString、clone和finalize)都有清晰的通用约定（ general contracts），因为它们被设计为被子类重写。任何类都有义务重写这些方法，以遵从他们的通用约定；如果不这样做，将会阻止其他依赖于约定的类(例如HashMap和HashSet)与此类一起正常工作。&lt;/p&gt;
&lt;p&gt;本章论述何时以及如何重写&lt;code&gt;Object&lt;/code&gt;类的非final的方法。这一章省略了finalize方法，因为它在条目 8中进行了讨论。&lt;code&gt;Comparable.compareTo&lt;/code&gt;方法虽然不是&lt;code&gt;Object&lt;/code&gt;中的方法，因为具有很多的相似性，所以也在这里讨论。&lt;/p&gt;
&lt;p&gt;重写equals方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问题的最简单方法不是覆盖equals方法，在这种情况下，类的每个实例只与自身相等。如果满足以下任一下条件，则说明是正确的做法：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;每个类的实例都是固有唯一的。 对于像Thread这样代表活动实体而不是值的类来说，这是正确的。 Object提供的equals实现对这些类完全是正确的行为。&lt;/li&gt;
&lt;li&gt;类不需要提供一个“逻辑相等（logical equality）”的测试功能。例如&lt;code&gt;java.util.regex.Pattern&lt;/code&gt;可以重写equals 方法检查两个是否代表完全相同的正则表达式Pattern实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从Object继承的equals实现是最合适的。&lt;/li&gt;
&lt;li&gt;父类已经重写了equals方法，则父类行为完全适合于该子类。例如，大多数Set从AbstractSet继承了equals实现、List从AbstractList继承了equals实现，Map从AbstractMap的Map继承了equals实现。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;类是私有的或包级私有的，可以确定它的equals方法永远不会被调用。如果你非常厌恶风险，可以重写equals方法，以确保不会被意外调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
throw new AssertionError(); // Method is never called
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那什么时候需要重写 equals 方法呢？如果一个类包含一个逻辑相等（ logical equality）的概念，此概念有别于对象标识（object identity），而且父类还没有重写过equals 方法。这通常用在值类（ value classes）的情况。值类只是一个表示值的类，例如Integer或String类。程序员使用equals方法比较值对象的引用，期望发现它们在逻辑上是否相等，而不是引用相同的对象。重写 equals方法不仅可以满足程序员的期望，它还支持重写过equals 的实例作为Map 的键（key），或者 Set 里的元素，以满足预期和期望的行为。&lt;/p&gt;
&lt;p&gt;一种不需要equals方法重写的值类是使用实例控制（instance control）（条目 1）的类，以确保每个值至多存在一个对象。 枚举类型（条目 34）属于这个类别。 对于这些类，逻辑相等与对象标识是一样的，所以Object的equals方法作用逻辑equals方法。&lt;/p&gt;
&lt;p&gt;当你重写equals方法时，必须遵守它的通用约定。Object的规范如下：&lt;br/&gt;equals方法实现了一个等价关系（equivalence relation）。它有以下这些属性:&lt;br/&gt;•自反性：对于任何非空引用x，&lt;code&gt;x.equals(x)&lt;/code&gt;必须返回true。&lt;br/&gt;•对称性：对于任何非空引用x和y，如果且仅当&lt;code&gt;y.equals(x)&lt;/code&gt;返回true时&lt;code&gt;x.equals(y)&lt;/code&gt;必须返回true。&lt;br/&gt;•传递性：对于任何非空引用x、y、z，如果&lt;code&gt;x.equals(y)&lt;/code&gt;返回true，&lt;code&gt;y.equals(z)&lt;/code&gt;返回true，则&lt;code&gt;x.equals(z)&lt;/code&gt;必须返回true。&lt;br/&gt;•一致性：对于任何非空引用x和y，如果在equals比较中使用的信息没有修改，则&lt;code&gt;x.equals(y)&lt;/code&gt;的多次调用必须始终返回true或始终返回false。&lt;br/&gt;•对于任何非空引用x，&lt;code&gt;x.equals(null)&lt;/code&gt;必须返回false。&lt;/p&gt;
&lt;p&gt;除非你喜欢数学，否则这看起来有点吓人，但不要忽略它！如果一旦违反了它，很可能会发现你的程序运行异常或崩溃，并且很难确定失败的根源。套用约翰·多恩(John Donne)的说法，没有哪个类是孤立存在的。一个类的实例常常被传递给另一个类的实例。许多类，包括所有的集合类，都依赖于传递给它们遵守equals约定的对象。&lt;/p&gt;
&lt;p&gt;既然已经意识到违反equals约定的危险，让我们详细地讨论一下这个约定。好消息是，表面上看，这并不是很复杂。一旦你理解了，就不难遵守这一约定。&lt;/p&gt;
&lt;p&gt;那么什么是等价关系？ 笼统地说，它是一个运算符，它将一组元素划分为彼此元素相等的子集。 这些子集被称为等价类（equivalence classes）。 为了使equals方法有用，每个等价类中的所有元素必须从用户的角度来说是可以互换（interchangeable）的。 现在让我们依次看下这个五个要求：&lt;/p&gt;
&lt;p&gt;自反性（Reflexivity）——第一个要求只是说一个对象必须与自身相等。 很难想象无意中违反了这个规定。 如果你违反了它，然后把类的实例添加到一个集合中，那么&lt;code&gt;contains&lt;/code&gt;方法可能会说集合中没有包含刚添加的实例。&lt;/p&gt;
&lt;p&gt;对称性（Symmetry）——第二个要求是，任何两个对象必须在是否相等的问题上达成一致。与第一个要求不同的是，我们不难想象在无意中违反了这一要求。例如，考虑下面的类，它实现了不区分大小写的字符串。字符串被toString保存，但在equals比较中被忽略：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.util.Objects;

public final class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }

    // Broken - violates symmetry!
    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString)
            return s.equalsIgnoreCase(
                    ((CaseInsensitiveString) o).s);
        if (o instanceof String)  // One-way interoperability!
            return s.equalsIgnoreCase((String) o);
        return false;
    }
    ...// Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面类中的 equals 试图与正常的字符串进行操作，假设我们有一个不区分大小写的字符串和一个正常的字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CaseInsensitiveString cis = new CaseInsensitiveString(&quot;Polish&quot;);
String s = &quot;polish”;

System.out.println(cis.equals(s)); // true
System.out.println(s.equals(cis)); // false&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如所料，&lt;code&gt;cis.equals(s)&lt;/code&gt;返回true。 问题是，尽管&lt;code&gt;CaseInsensitiveString&lt;/code&gt;类中的equals方法知道正常字符串，但String类中的equals方法却忽略了不区分大小写的字符串。 因此，&lt;code&gt;s.equals(cis&lt;/code&gt;)返回false，明显违反对称性。 假设把一个不区分大小写的字符串放入一个集合中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;CaseInsensitiveString&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
list.add(cis);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;list.contains(s)&lt;/code&gt;返回了什么？谁知道呢？在当前的OpenJDK实现中，它会返回false，但这只是一个实现构件。在另一个实现中，它可以很容易地返回true或抛出运行时异常。一旦违反了equals约定，就不知道其他对象在面对你的对象时会如何表现了。&lt;/p&gt;
&lt;p&gt;要消除这个问题，只需删除equals方法中与String类相互操作的恶意尝试。这样做之后，可以将该方法重构为单个返回语句:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean equals(Object o) {
    return o instanceof CaseInsensitiveString &amp;amp;&amp;amp;
            ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传递性（Transitivity）——equals 约定的第三个要求是，如果第一个对象等于第二个对象，第二个对象等于第三个对象，那么第一个对象必须等于第三个对象。同样，也不难想象，无意中违反了这一要求。考虑子类的情况， 将新值组件（ value component）添加到其父类中。换句话说，子类添加了一个信息，它影响了equals方法比较。让我们从一个简单不可变的二维整数类型Point类开始：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof Point))
            return false;
        Point p = (Point) o;
        return p.x == x &amp;amp;&amp;amp; p.y == y;
    }

    ...  // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设想继承这个类，将表示颜色的Color类添加到Point类中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ColorPoint extends Point {
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        super(x, y);
        this.color = color;
    }

    ...  // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;equals方法应该是什么样子?如果完全忽略，则实现是从Point类上继承的，颜色信息在equals方法比较中被忽略。虽然这并不违反equals约定，但这显然是不可接受的。假设你写了一个equals方法，它只在它的参数是另一个具有相同位置和颜色的ColorPoint实例时返回true：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Broken - violates symmetry!
@Override public boolean equals(Object o) {
    if (!(o instanceof ColorPoint))
        return false;
    return super.equals(o) &amp;amp;&amp;amp; ((ColorPoint) o).color == color;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你比较Point对象和ColorPoint对象时，可以会得到不同的结果，反之亦然。前者的比较忽略了颜色属性，而后者的比较会一直返回 false，因为参数的类型是错误的。为了让问题更加具体，我们创建一个Point对象和ColorPoint对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Point p = new Point(1, 2);
ColorPoint cp = new ColorPoint(1, 2, Color.RED);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;p.equals(cp)返回 true，但是 cp.equals(p)返回 false。你可能想使用ColorPoint.equals 通过混合比较的方式来解决这个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean equals(Object o) {
    if (!(o instanceof Point))
        return false;

    // If o is a normal Point, do a color-blind comparison
    if (!(o instanceof ColorPoint))
        return o.equals(this);

    // o is a ColorPoint; do a full comparison
    return super.equals(o) &amp;amp;&amp;amp; ((ColorPoint) o).color == color;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法确实提供了对称性，但是丧失了传递性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
Point p2 = new Point(1, 2);
ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，&lt;code&gt;p1.equals(p2)&lt;/code&gt;和&lt;code&gt;p2.equals(p3)&lt;/code&gt; 返回了 true，但是&lt;code&gt;p1.equals(p3)&lt;/code&gt;却返回了 false，很明显违背了传递性的要求。前两个比较都是不考虑颜色信息的，而第三个比较时却包含颜色信息。&lt;/p&gt;
&lt;p&gt;此外，这种方法可能导致无限递归：假设有两个Point的子类，比如ColorPoint和SmellPoint，每个都有这种equals方法。 然后调用&lt;code&gt;myColorPoint.equals(mySmellPoint)&lt;/code&gt;将抛出一个StackOverflowError异常。&lt;/p&gt;
&lt;p&gt;那么解决方案是什么？ 事实证明，这是面向对象语言中关于等价关系的一个基本问题。 除非您愿意放弃面向对象抽象的好处，否则无法继承可实例化的类，并在保留 equals 约定的同时添加一个值组件。&lt;/p&gt;
&lt;p&gt;你可能听说过，可以继承一个可实例化的类并添加一个值组件，同时通过在equals方法中使用一个getClass测试代替instanceof测试来保留equals约定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean equals(Object o) {
    if (o == null || o.getClass() != getClass())
        return false;
    Point p = (Point) o;
    return p.x == x &amp;amp;&amp;amp; p.y == y;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有当对象具有相同的实现类时，才会产生相同的效果。这看起来可能不是那么糟糕，但是结果是不可接受的:一个Point类子类的实例仍然是一个Point的实例，它仍然需要作为一个Point来运行，但是如果你采用这个方法，就会失败！假设我们要写一个方法来判断一个Point 对象是否在unitCircle集合中。我们可以这样做：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static final Set&amp;lt;Point&amp;gt; unitCircle = Set.of(
        new Point( 1,  0), new Point( 0,  1),
        new Point(-1,  0), new Point( 0, -1));

public static boolean onUnitCircle(Point p) {
    return unitCircle.contains(p);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这可能不是实现功能的最快方法，但它可以正常工作。假设以一种不添加值组件的简单方式继承 Point 类，比如让它的构造方法跟踪记录创建了多少实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CounterPoint extends Point {
    private static final AtomicInteger counter =
            new AtomicInteger();

    public CounterPoint(int x, int y) {
        super(x, y);
        counter.incrementAndGet();
    }

    public static int numberCreated() {
        return counter.get();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里氏替代原则（ Liskov substitution principle）指出，任何类型的重要属性都应该适用于所有的子类型，因此任何为这种类型编写的方法都应该在其子类上同样适用[Liskov87]。 这是我们之前声明的一个正式陈述，即Point的子类（如CounterPoint）仍然是一个Point，必须作为一个Point类来看待。 但是，假设我们将一个CounterPoint对象传递给onUnitCircle方法。 如果Point类使用基于getClass的equals方法，则无论CounterPoint实例的x和y坐标如何，onUnitCircle方法都将返回false。 这是因为大多数集合（包括onUnitCircle方法使用的HashSet）都使用equals方法来测试是否包含元素，并且CounterPoint实例并不等于任何Point实例。 但是，如果在Point上使用了适当的基于&lt;code&gt;instanceof&lt;/code&gt;的equals方法，则在使用CounterPoint实例呈现时，同样的onUnitCircle方法可以正常工作。&lt;/p&gt;
&lt;p&gt;虽然没有令人满意的方法来继承一个可实例化的类并添加一个值组件，但是有一个很好的变通方法：按照条目18的建议，“优先使用组合而不是继承”。取代继承Point类的ColorPoint类，可以在ColorPoint类中定义一个私有Point属性，和一个公共的试图（view）（条目6）方法，用来返回具有相同位置的ColorPoint对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Adds a value component without violating the equals contract
public class ColorPoint {
    private final Point point;
    private final Color color;

    public ColorPoint(int x, int y, Color color) {
        point = new Point(x, y);
        this.color = Objects.requireNonNull(color);
    }
    
    /**
     * Returns the point-view of this color point.
     */
    public Point asPoint() {
        return point;
    }

    @Override public boolean equals(Object o) {
        if (!(o instanceof ColorPoint))
            return false;
        ColorPoint cp = (ColorPoint) o;
        return cp.point.equals(point) &amp;amp;&amp;amp; cp.color.equals(color);
    }
    
    ...    // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java平台类库中有一些类可以继承可实例化的类并添加一个值组件。 例如，&lt;code&gt;java.sql.Timestamp&lt;/code&gt;继承了&lt;code&gt;java.util.Date&lt;/code&gt;并添加了一个nanoseconds字段。 Timestamp的等价equals确实违反了对称性，并且如果Timestamp和Date对象在同一个集合中使用，或者以其他方式混合使用，则可能导致不稳定的行为。 Timestamp类有一个免责声明，告诫程序员不要混用Timestamp和Date。 虽然只要将它们分开使用就不会遇到麻烦，但没有什么可以阻止你将它们混合在一起，并且由此产生的错误可能很难调试。 Timestamp类的这种行为是一个错误，不应该被仿效。&lt;/p&gt;
&lt;p&gt;你可以将值组件添加到抽象类的子类中，而不会违反equals约定。这对于通过遵循第23个条目中“优先考虑类层级（class hierarchies）来代替标记类（tagged classes）”中的建议而获得的类层级，是非常重要的。例如，可以有一个没有值组件的抽象类Shape，子类Circle有一个radius属性，另一个子类Rectangle包含length和width属性 。 只要不直接创建父类实例，就不会出现前面所示的问题。&lt;/p&gt;
&lt;p&gt;一致性——equals 约定的第四个要求是，如果两个对象是相等的，除非一个（或两个）对象被修改了， 那么它们必须始终保持相等。 换句话说，可变对象可以在不同时期可以与不同的对象相等，而不可变对象则不会。 当你写一个类时，要认真思考它是否应该设计为不可变的（条目 17）。 如果你认为应该这样做，那么确保你的equals方法强制执行这样的限制：相等的对象永远相等，不相等的对象永远都不会相等。&lt;/p&gt;
&lt;p&gt;不管一个类是不是不可变的，都不要写一个依赖于不可靠资源的equals方法。 如果违反这一禁令，满足一致性要求是非常困难的。 例如，java.net.URL类中的equals方法依赖于与URL关联的主机的IP地址的比较。 将主机名转换为IP地址可能需要访问网络，并且不能保证随着时间的推移会产生相同的结果。 这可能会导致URL类的equals方法违反equals 约定，并在实践中造成问题。 URL类的equals方法的行为是一个很大的错误，不应该被效仿。 不幸的是，由于兼容性的要求，它不能改变。 为了避免这种问题，equals方法应该只对内存驻留对象执行确定性计算。&lt;/p&gt;
&lt;p&gt;非空性（Non-nullity）——最后equals 约定的要求没有官方的名称，所以我冒昧地称之为“非空性”。意思是说说所有的对象都必须不等于 null。虽然很难想象在调用 &lt;code&gt;o.equals(null)&lt;/code&gt;的响应中意外地返回true，但不难想象不小心抛出&lt;code&gt;NullPointerException&lt;/code&gt;异常的情况。通用的约定禁止抛出这样的异常。许多类中的 equals方法都会明确阻止对象为null的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
    if (o == null)
        return false;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个判断是不必要的。 为了测试它的参数是否相等，equals方法必须首先将其参数转换为合适类型，以便调用访问器或允许访问的属性。 在执行类型转换之前，该方法必须使用instanceof运算符来检查其参数是否是正确的类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override public boolean equals(Object o) {
    if (!(o instanceof MyType))
        return false;
    MyType mt = (MyType) o;
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果此类型检查漏掉，并且equals方法传递了错误类型的参数，那么equals方法将抛出&lt;code&gt;ClassCastException&lt;/code&gt;异常，这违反了equals约定。 但是，如果第一个操作数为 null，则指定instanceof运算符返回false，而不管第二个操作数中出现何种类型[JLS，15.20.2]。 因此，如果传入null，类型检查将返回false，因此不需要 明确的 null检查。&lt;/p&gt;
&lt;p&gt;综合起来，以下是编写高质量equals方法的配方（recipe）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用= =运算符检查参数是否为该对象的引用。如果是，返回true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;instanceof&lt;/code&gt;运算符来检查参数是否具有正确的类型。 如果不是，则返回false。 通常，正确的类型是equals方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如Set，List，Map和Map.Entry）具有此特性。&lt;/li&gt;
&lt;li&gt;参数转换为正确的类型。因为转换操作在instanceof中已经处理过，所以它肯定会成功。&lt;/li&gt;
&lt;li&gt;对于类中的每个“重要”的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回true，否则返回false。如果步骤2中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于类型为非float或double的基本类型，使用= =运算符进行比较；对于对象引用属性，递归地调用equals方法；对于float 基本类型的属性，使用静态&lt;code&gt;Float.compare(float, float)&lt;/code&gt;方法；对于double 基本类型的属性，使用&lt;code&gt;Double.compare(double, double)&lt;/code&gt;方法。由于存在&lt;code&gt;Float.NaN&lt;/code&gt;，&lt;code&gt;-0.0f&lt;/code&gt;和类似的double类型的值，所以需要对float和double属性进行特殊的处理；有关详细信息，请参阅JLS 15.21.1或Float.equals方法的详细文档。 虽然你可以使用静态方法Float.equals和Double.equals方法对float和double基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的Arrays.equals方法。&lt;/p&gt;
&lt;p&gt;某些对象引用的属性可能合法地包含null。 为避免出现NullPointerException异常，请使用静态方法 Objects.equals(Object, Object)检查这些属性是否相等。&lt;/p&gt;
&lt;p&gt;对于一些类，例如上的&lt;code&gt;CaseInsensitiveString&lt;/code&gt;类，属性比较相对于简单的相等性测试要复杂得多。在这种情况下，你想要保存属性的一个规范形式（ canonical form），这样 equals 方法就可以基于这个规范形式去做开销很小的精确比较，来取代开销很大的非标准比较。这种方式其实最适合不可变类（条目 17）。一旦对象发生改变，一定要确保把对应的规范形式更新到最新。&lt;/p&gt;
&lt;p&gt;equals方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同的属性，开销比较小的属性，或者最好是两者都满足（derived fields）。 你不要比较不属于对象逻辑状态的属性，例如用于同步操作的lock 属性。 不需要比较可以从“重要属性”计算出来的派生属性，但是这样做可以提高equals方法的性能。 如果派生属性相当于对整个对象的摘要描述，比较这个属性将节省在比较失败时再去比较实际数据的开销。 例如，假设有一个Polygon类，并缓存该区域。 如果两个多边形的面积不相等，则不必费心比较它们的边和顶点。&lt;/p&gt;
&lt;p&gt;当你完成编写完equals方法时，问你自己三个问题：它是对称的吗?它是传递吗?它是一致的吗?除此而外，编写单元测试加以排查，除非使用AutoValue框架(第49页)来生成equals方法，在这种情况下可以安全地省略测试。如果持有的属性失败，找出原因，并相应地修改equals方法。当然，equals方法也必须满足其他两个属性(自反性和非空性)，但这两个属性通常都会满足。&lt;/p&gt;
&lt;p&gt;在下面这个简单的&lt;code&gt;PhoneNumber&lt;/code&gt;类中展示了根据之前的配方构建的equals方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final class PhoneNumber {

    private final short areaCode, prefix, lineNum;

    public PhoneNumber(int areaCode, int prefix, int lineNum) {
        this.areaCode = rangeCheck(areaCode, 999, &quot;area code&quot;);
        this.prefix = rangeCheck(prefix, 999, &quot;prefix&quot;);
        this.lineNum = rangeCheck(lineNum, 9999, &quot;line num&quot;);
    }

    private static short rangeCheck(int val, int max, String arg) {
        if (val &amp;lt; 0 || val &amp;gt; max)
            throw new IllegalArgumentException(arg + &quot;: &quot; + val);
        
        return (short) val;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof PhoneNumber))
            return false;

        PhoneNumber pn = (PhoneNumber) o;

        return pn.lineNum == lineNum &amp;amp;&amp;amp; pn.prefix == prefix
                &amp;amp;&amp;amp; pn.areaCode == areaCode;
    }

    ... // Remainder omitted
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是一些最后提醒：&lt;/p&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li&gt;&lt;strong&gt;当重写equals方法时，同时也要重写hashCode方法（条目 11）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要让equals方法试图太聪明&lt;/strong&gt;。如果只是简单地测试用于相等的属性，那么要遵守equals约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;在equal 时方法声明中，不要将参数Object替换成其他类型&lt;/strong&gt;。对于程序员来说，编写一个看起来像这样的equals方法并不少见，然后花上几个小时苦苦思索为什么它不能正常工作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Broken - parameter type must be Object!public boolean equals(MyClass o) {   
 …
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题在于这个方法并没有重写Object.equals方法，它的参数是Object类型的，这样写只是重载了 equals 方法（Item 52）。 即使除了正常的方法之外，提供这种“强类型”的equals方法也是不可接受的，因为它可能会导致子类中的Override注解产生误报，提供不安全的错觉。&lt;br/&gt;在这里，使用Override注解会阻止你犯这个错误(条目 40)。这个equals方法不会编译，错误消息会告诉你到底错在哪里：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Still broken, but won’t compile
@Override public boolean equals(MyClass o) {
…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写和测试equals(和hashCode)方法很繁琐，生的代码也很普通。替代手动编写和测试这些方法的优雅的手段是，使用谷歌AutoValue开源框架，该框架自动为你生成这些方法，只需在类上添加一个注解即可。在大多数情况下，AutoValue框架生成的方法与你自己编写的方法本质上是相同的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很多 IDE（例如 Eclipse，NetBeans，IntelliJ IDEA 等）也有生成equals和hashCode方法的功能，但是生成的源代码比使用AutoValue框架的代码更冗长、可读性更差，不会自动跟踪类中的更改，因此需要进行测试。这就是说，使用IDE工具生成equals(和hashCode)方法通常比手动编写它们更可取，因为IDE工具不会犯粗心大意的错误，而人类则会。&lt;/p&gt;
&lt;p&gt;总之，除非必须：在很多情况下，不要重写equals方法，从Object继承的实现完全是你想要的。 如果你确实重写了equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面equals约定里五个规定的方式去比较。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 23:23:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8148667.html</dc:identifier>
</item>
<item>
<title>开发的，请对测试人员好点 - 海角在眼前</title>
<link>http://www.cnblogs.com/lovesong/p/8146912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovesong/p/8146912.html</guid>
<description>&lt;p&gt;　最近我时常看到，有开发的总对测试人员大喊大叫，有种不耐烦的感觉。可能那些开发与人相处的性格就是那样，但他们的语气，让我感觉他们还是有不满、厌烦的情绪，不像平时待人时友善。作为开发者，我想说，“开发的，请对测试人员好点”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   测试人员和开发的是一伙的。&lt;/span&gt;&lt;/strong&gt;他们在测试的过程中，是发现你所遗失的细节、犯下错，是在帮你找问题，而不是在找你麻烦，惹你晦气。当他们在跟你反馈问题时候，别第一念头就认为在找你麻烦，指责你的错。特别是在开发进度是比较紧急，很多需求和问题都像是要来不急，这两天就要封版，测试还给我们提出一堆问题，就特别烦恼，语气也不友善起来。&lt;/p&gt;
&lt;p&gt;　我觉得此时可舒缓一下神经，想想自己坚守的精益求精（这是我认为工作该有品质），紧急的确实需要解决，但bug修复也很重要，是不能被忽略放过的，我们该做的，就是判断是否重要问题以及解决时机，而不是怨天尤人。我们该感谢测试人员，感谢他们发现我们实现上的不足，将问题堵截在用户之前。&lt;/p&gt;
&lt;p&gt;   人总喜欢被认同的，讨厌被轻视指责。网上有个程序员段子。&lt;/p&gt;
&lt;p&gt;  『 测试人员对程序员说：你的代码有BUG。&lt;/p&gt;
&lt;p&gt;       他的第一反应是：1、你的环境有问题吧；2、你踏马到底会不会用？&lt;/p&gt;
&lt;p&gt;       如果你委婉的说：你这个程序和预期的不一样，你看看是不是我的方法不一样。&lt;/p&gt;
&lt;p&gt;       他本能的会想：是不是程序出BUG了。』&lt;/p&gt;
&lt;p&gt;   恰恰测试人员干的事，有时确实像是在指责开发的。但我并不是想说，测试人员需要怎么委婉的表述问题，我是想勉励开发的接受测试人员第一种表达方式，接受自己的错，像看待另一个开发者的错一样，直视这样问题，检查过后如果发现是确实自己问题，就&lt;strong&gt;&lt;span&gt;豁达一些说，“是我的问题”&lt;/span&gt;&lt;/strong&gt;；如果是测试人员的失误，也不要咄咄逼人，像个胜利者一样；&lt;/p&gt;
&lt;p&gt;　当然，测试人员遇到问题时，先追查是否环境问题，再简明扼要的描述问题和操作步骤，那会好很多。如果觉得测试人员的反馈方式有问题，就好好沟通，指明也就行了。&lt;/p&gt;
&lt;p&gt;   错了，就勇敢承认下来。但这不是说你可以时时犯错，只要被发现时候认了就行，工作不应该是这样子的。我们程序员也得注意开发的严谨和完善，有没有遗漏什么需求点，是不是所有场景用例都走过了，能不能性能上有所优化，在交付到测试人员手上时，应该就已经是少问题版本。别让测试人员总帮你找细枝末节的问题，他们应该是你的把关者，帮你找出特殊场景或预料之外的问题。&lt;/p&gt;
&lt;p&gt;   挺常见的现象就是，开发的只把正常的流程走了一遍，但却忽略了一些异常的情况或处理得不严谨，让测试揪出一堆的问题。这就导致自己预料之外的事太多了，但&lt;strong&gt;&lt;span&gt;太多预料之外的问题，就显得自己无能。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;   其实我是怕测试人员的，只要她一走过来，我心里就会咯噔一下，细想哪又挖了坑，然后发现她是找我后面的人，又长吁一口气，-_-|||。我时常跟需求的争论，但很少跟测试争论，我把测试当成自己人。虽然被指出问题，要改的东西变多了，但庆幸有他们在，发现了问题，能让做的东西变得更完善，所以，请对测试人员好点。 &lt;/p&gt;

&lt;p&gt;本文为原创文章，转载请保留原出处，方便溯源，如有错误地方，谢谢指正。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 16:57:00 +0000</pubDate>
<dc:creator>海角在眼前</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovesong/p/8146912.html</dc:identifier>
</item>
<item>
<title>2017年终总结 - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/8120608.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/8120608.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　觉得进入中年以来，每年的时间都过得飞快，还没赚到钱就年尾了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2017年过的异常的充实，除了收入有点退步外，其他都在往好的方面发展，16年定下的目标基本都实现了。今年认真学习了周金根老师的敏捷个人，对个人规划与计划、目标方面，也有了比较大的进步，在往快乐、平衡和高效方向努力着。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　每个人的人生追求不同，大家努力的方向也不一样，有的人在为家庭幸福而努力，有的是为了事业在奋斗，有的为了金钱为了名望......一直以来我也在拼命努力着，想要提高自己的能力与掌握更多的技能，为家庭创造更多的财富在拼命着。以前除了事业就是家庭，没有个人生活，这两年还好一点，之前去了北京工作之余，开启了户外生活，有了不一样的感受。这一年多以来学习了敏捷个人以后，也有了更清晰的认识，让我开始思考以前一直没有注意过的其他方向：家庭、工作、精神、健康、休闲、人际、贡献和财富。今年总结就根据这8个方向分别总结一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;家庭方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有时想想，我们拼命的学习与工作，为了不就是家和孩子嘛。再苦再累见到家人，一切劳累都是抛之脑后，再辛苦都是值得的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从去年底回到广州上班以后，离家也近了，每周周末可以回家呆着，陪陪儿子和家人，一家人开开心心的度过每个周末，幸福感增加了N倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年陪儿子一起参加了不少户外活动，爬了不少山，还参加了佛山50公里徒步，一起走完全程。除此之外有一趟长线活动，在五一时和他一起去了腾格里沙漠穿越，沙漠结束后顺路去爬贺兰山，短短七天经历了春夏秋冬四种季节，还体验了风沙、大风、大雨、大雾、暴雪......等各种极端气候，这个过程既增进了父子感情，同时儿子也得到了很好的锻炼。这一年来的所有活动，8岁的孩子全程都独立完成，几乎没有叫过累，多数都是在兴奋中度过的，非常感谢在这个过程中一直给予支持、鼓励与陪伴的各位驴友。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年最大的收获就是家庭里增加了一位非常可爱、漂亮、美丽、萌萌达的小公举，虽然这几个月来很累，但非常的开心。多个女儿的体验是没有女儿的人无法感受得到的，内心满满的都是喜悦。不过在这个过程也多了很多以前没有的烦恼，经常会为女儿长大以后的事情而担心，痛并快乐着。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;工作方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当初选择回老公司有几个出发点，一是自己这几年学了很多东西，但一直忙没有时间可以静下心来沉淀一下，整理整理自己的知识体系，重新在新领域打造好自己的框架与实践；二是公司技术团队几位成员是自己以前培养出来的，不用重新磨合；三是老板给的薪酬每个月虽然低点，但承诺年终会给比较多；四是老板说公司一直是忙半年，轻松半年。当然一年下来，发现吐槽点太多了，很多时候理想与现实差距还是挺大的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　自己用python web框架开发的业务系统这一年在线上稳定运行，经历了种各需求和压力，增加了各种自动化管理与运维的功能，系统的稳定性与快捷接入功能为公司带来了可观的营收和丰厚的利润，算是完美收官。同时系统也让公司告别了检查故障靠手点或第二天报表数据分析的日子；让公司业务重新进行整合，增加系统的扩展与应用，一套系统可供N个合作商同时使用，而不是每个合作商都得独立部署一套一模一样的系统拷贝，让业务接入更快速与方便，减少服务器资源消耗；增加各种监控与报警服务，增加故障自动恢复功能，让公司减少损失，让技术不再半夜苦逼加班处理；好的框架也带来了开发速度与效率的提升，提高系统出产和减少时间成本；各种系统全部高可用改造，让公司告别了服务器故障手动改域名指向备用服务器处理、恢复时间超长的时代，让合作业务更加稳定运转......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　技术上，在分布式微服务器架构上增长了不少经验，对高并发高可用架构，有了更深刻的理解，同时在linux服务器运维方面也积累了丰富的经验。在高并发上有了实战机会，有一个合作伙伴APP技术写错了代码，造成这个合作伙伴APP发版后对公司业务接口访问日PV超6KW，并持续了好长一段时间，由于线上业务不能停机，只能等待用户更新APP处理。通过快速扩容宽带、服务器CPU和内存，扩展高可用架构迅速解决了问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了让自己能从繁忙的加班中解放出来，不用周末为了各种故障和事情加班，开发了大量的自动化服务和自动化运维脚本，从每日报表、后台业务故障分析报表、服务器日志自动监控报警服务、各应用与服务异常监控自动重启服务......当这一个个服务应用起来，程序和服务器日驱稳定下来后，老板竟然觉得我们技术人员不太忙有点多余的感觉......还真有点无言以对了。不懂技术的老板觉得技术人员要天天在忙才是正常的，因为以前要报表时几乎都是找技术人员在数据库里查出来，服务器出现故障需要技术人员登录服务器重启或处理解决，一个项目就得花技术大量的时间长期去维护，搞得经常休的是假的假期。真是无法沟通，有时在想，要不要将这些自动化服务都删掉，让老板和公司全体人员一起来每天每时都上产品里做一下测试，监控一下服务是否有问题，然后大家都忙碌起来，让大家知道技术人员的重要性，不可或缺，不过想想还是算了，这样又让自己限入永无止境的加班中，还不如不如意的话一拍两散。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　相信老板说开发任务不会太忙这句话真的是我太天真了，年头忙到年尾，除了请陪产假以外，项目一结束，老板就会拍脑袋未经深入思考想出新项目出来，根本没有让你停下来的可能。老板经常对我们技术人员说是要有危机感，多试错，每个技术人员要将自己当成老板、当成产品经理、当成项目经理，去思考新项目，去开发和维护好各个项目。当然如果我们技术人员都做到是最好不过了，但并不是每一位技术都是全才，什么都会。老板让技术人员自己当自己是合伙人的姿态来对待项目，对待公司，但公司也不给股份或分红（一会说叫技术自己拿钱投自己做的项目和公司一起做；一会说如果上市的话，到时会将公司的股份拿出来底价卖给大家......）；另外答应的一部分承诺也没有兑现（只兑现了一部分），年初加薪说为了留住大家中途不走，全部改为年终一起发（还没到年终得看看有没有发）；说好的加班给30块加班饭补，有同事加班时间在学习就叫大家早点走然后取消加班费......去年无年终奖......现在只能看今年怎么样了，今年为公司创收了近KW利润，但老板最终能兑现多少承诺只能等了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;精神方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年主要目标就是学习，虽然工作非常繁忙，但还好学习了敏捷个人以后，对自己时间管理有了质的提升，每天一早一晚都能挤出时间来看书学习。今年共花了7K多在买书上，其中6K多是买给小孩的，自己的不算太多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一直以来定看书计划，都以量为主要目标，今年后半段改变了看书方法，不再追求数量，而是在质量方面下工夫，虽然全年看的书不多（全年实体书看了十多本，电子书看了有二十多本），但精读对自己有帮助的几本书下来，收获还是挺多的，比起以前泛泛的看了一大堆但没有记笔记和实践，对自己的帮助完全不一样。书籍类型上也做了改变，以前都是以技术书籍为主，今年慢慢的增加了人物传记、个人成长、哲学、历史故事、童书等不同领域，感受也完全不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年几乎将周老师全部线上课程都购买了，花了不少银子，认真学了企业架构、敏捷开发（Scrum实践）、创新思维、问题思维、Scratch创意编程启蒙课、七嘴八舌、战略思维、BABOK.....前两个课程对工作帮忙最大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　将企业架构应用到项目中很难，但尝试以后发现它确实是非常棒的，可以让自己和大家快速的从更高角度全面理解项目，只有理解企业战略，才能知道怎么去设计与分析需求，懂得去设计产品，去设计产品业务、应用、数据和技术架构。实践是最好的老师，非常感谢周老师一路的指导，让我能快速的掌握这项新的技能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　敏捷开发课程也让我全面对敏捷这个话题有了更深刻的了解，才知道之前自己了解的是多么的狭窄，而在课程中参与讲解的敏捷开发实践者们，也分享了很多实际应用中的问题与见识，让我们更生动的了解什么是敏捷开发。我会抽空再次认真学习，并重新做好读书笔记，希望以后有机会应用到实践中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　创新思维和问题思维两个课程是思维方面的练习与察觉，一个都会我们如何思考，如何去改变思维，去锻炼创新思维；而问题思维则可以帮助我觉察与控制情绪，特别在家庭沟通上，有非常大的帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　收获最大的是周老师的敏捷个人练习，它我所接触过的个人成长领域中，最有系统、有明确任务安排与指导、可执行的一个成长体系。我们现在处于信息爆炸的时代，每天都会接触或查看海量的信息，朋友圈、微博、公众号之中，有大量的各种文章存在，但大家看了那么多鸡汤之后我们的生活还是照旧，并没有太多的改变，偶尔心灵会给触动一下，但很快就恢复原状了。为什么呢？因为在这个过程中，我们只不过是观看者，并不是观察者，我们只是哦的一声，知道而已，并没有真正的去思考，去反思，然后不停的重复这样的生活，看再多的东西没有沉淀，它都不会成为我们自己的知识，不会为我们的成长加砖添瓦，从中还浪费了我们大量的精力和时间。敏捷个人它从8个维度来引导我们，让我们深入去思考自己的人生，去更好的了解自己的方方面面，然后发现问题，改造自己，让我们变成爱学习，懂生活，会行动的人。它里面有小练习、高效个人练习、平衡个人练习、快乐个人练习、头手心练习和觉察练习，每一个练习都有很多小节，每个小练习都有很多明确的任务需要学员去思考，去回复，去执行，让我们从中重新认识自己，让我们去沉淀生活与工作中的方方面面，从中找到自己的人生奋斗方向，清晰自己想要什么，知道自己要做些什么，变得更有动力与执行力，让生活与工作变得更加高效&lt;span&gt;。以后有空整理一下学习心得，再分享给大家。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;健康方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　健康是1，其他都是0，如果没有1，有再多的0也没有任务意义，这是大家都听过的话，但真正重视健康的人却是非常非常的少。都以为自己还年青还可以拼一下，可以熬夜，可以暴饮暴食，可以不锻炼身体，不去注意身体与精神方面的健康。只有那些发生过健康危机的人才会感受到健康的可贵。从2012年身体熬垮恢复以后，一直都比较重视，但坚持跑步坚持锻炼并不是靠毅力就可以做到的，它还需要方法与养成良好生活的习惯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年通过敏捷个人里的介绍，了解了周老师根据合理训练后跑完马拉松的经过，并看了所推荐的《爱上跑步的13周》以后，对跑步有不一样的认识。以前想要坚持跑步时，是强迫让自己每天都去跑，跑的时候也没有注意节奏跑的比较快，几乎每次跑完累的没了半条命似的，所以很难长期持续下来，跑步一直是断断续续的。从书中学到，原来跑步也是需要技巧的，要有方法。里面提出的分阶段分组慢跑，让我每次跑完后还有不是很过瘾的感觉，感觉还可以继续再跑上一段时间，而适度的锻炼理念，也让我不用再逼迫自己天天跑，每周两到三次的运动量，安排起时间来更加灵活方便，让我更容易坚持下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然运动不单单指跑步，还可以是步行、爬山、打球、瑜珈、平板撑......只要我们能动起来，什么都不是问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年身体方面有很大的改善，我觉得也是得益于长期坚持参加户外活动和每周跑步锻炼。当然有规律的作息和注意饮食，也是很重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;休闲方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　工作与生活要劳逸结合，有松有紧，这样才能让精神更好的放松，让工作与生活更高效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为试过长时间的两地分居，所以会更加珍惜现在的生活，除了户外活动外，多数时间都是陪儿子和家人，做为休闲与放松。一起聊聊天，去公园逛逛，或者和儿子一起画画玩玩具，一起看看书......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了让儿子对魔方感兴趣，花了不少时间自学魔方玩法，自己学会了，可小家伙并不是很感冒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了培养儿子对乐器的兴趣，在10月底买了把尤克里里，自己跟着AI音乐学院APP练习了近两个月，从乐器白痴到会弹上不少简单的曲子，在自己学习的过程中，也让儿子慢慢对乐器产生了兴趣，当然这也是自己的一个梦想，等以后老了也可以多一样乐趣。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;人际方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于忙于工作和家庭，和以前的同学朋友来往相对少了一些，参于朋友组织的活动比较少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而参加了敏捷个人社区，并做为这次线上练习的班长，认识了好多想要改变现状，改变生活，实现自我成长的小伙伴，应该是今天最大的收获之一吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;贡献方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　学习了并不等于学会了，并不等于能应用到实际的生活或项目当中，而分享就是一种检验自己学习成果最好的途径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从年初就计划写《我的第一个python web开发框架》系列博文，但由于各种拖延与事情一直没有动起来，直到8月份才咬咬牙，学习前端的一些知识，开始动手，事情就是这样，开始了就可以顺着惯性坚持下来，虽然写的并不是非常好，前端知识几乎都是跳过没有去描述，但开始了就有收获，自己的知识在写的过程中就会不断的沉淀下来，形成自己的知识体系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年在公司技术部与QQ群视频分享的比较少，因为很多知识在去年年底已分享过了，而其他知识体系一直没有认真的整理，所以感觉没有什么好说的。不过11月份参加敏捷个人社区，并担任班长后，逼着自己去总结去分享，才发现好多东西还是需要自己给自己施加压力才行，发现自己其实还是满会写和说的，写了不少个人成长各个方面的总结与体会，在千聊上也录制了一些分享语音，在参与主持或小组讨论时，自己也能发挥自己经验丰富的优点，讲出好多干货出来，在写作、口头表达和沟通等方面进步很大，而在整理各个知识的过程中，也慢慢形成了自己完整的知识体系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在《在行》上注册行家也有好长时间了，之前接到的单都很少，今年陆陆续续接到了不少邀请，见了不少各个领域的人，和大家针对不同问题进入深入讨论并解决问题，而自己在这个过程中也在不断的扩大知识面以及各行业问题的解决处理能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;财富方面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年除了收入方面有所下降外，老婆娘家发生了一些事情，将自己这两年的积储都用完了（一直开销都挺大，也没多少存款），再加上小宝贝的到来，真是入不敖出，不过困难也只是暂时的，在一家人的坚持与努力下也慢慢度过了难关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　知识财富方面，得益于自己坚持学习，在不断的积累与增长中，在技术上、个人成长、育儿等方面都Get到了很多新技能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;人生理想&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　没有目标就没有方向，没有方向也就不可能知道为了什么而努力，那么就不太可能有太多的动力让自己不停的学习与进步。所以在展望未来前，首先要做的是，让自己知道自己想要什么，知道自己的定位和奋斗的方向，了解现在的自己与目标的差距，这样才能慢慢调整方向，达成目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在做2018年目标时，首先要问一问自己，我的人生理想或梦想是什么？我想要什么样的生活？对于人生理想来说，它就像企业发展中的战略，它可能是比较虚的东西，但列出它以后，我们就可以很清晰的知道自己想要什么，知道自己的努力是为了什么，清楚自己努力的方向。而落实到年目标时，我们可以认真考虑每一项人生理想并联系生活，为了达到自己的个人生理想，我们下一年要做什么事情？做出什么改变呢？将它们一一列出来，就形成了详细的年目标。有了详细的年目标，那么根据具体情况才能分解到每月每周和每日当中。而每日每周执行的是自己实现梦想分解细化后的一个小任务小故事，每完成一个小任务，就是让自己靠近梦想一点点，长期坚持下来，每一年自己定下的目标就可以实现了，自己的梦想也会跟着慢慢实现，而不会出现不知道要做什么计划，不知道每天要忙啥的感觉。自己有梦想，但不去执行去努力，却希望它能实现，这不是做白日梦吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这段时间重新认识思考自己想要的生活，整理出现阶段自己追求的理想目标：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/129385/201712/129385-20171230001416617-593927035.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;2018年目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据这些目标联系生活，为了实现上面的理想，制定了2018年计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/129385/201712/129385-20171230002045585-733285806.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2018年目标定的好像有点多，但我会每个月进行细化，然后分配到每一周和每一天中去执行，希望2018年会有更大的成长，在个人成长与技术领域走的更远。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 16:56:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/8120608.html</dc:identifier>
</item>
<item>
<title>如何用VSCode愉快的写Python - Pleiades</title>
<link>http://www.cnblogs.com/pleiades/p/8146658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pleiades/p/8146658.html</guid>
<description>&lt;p&gt;　　在学习Python的过程中，一直没有找到比较趁手的第三方编辑器，用的最多的还是Python自带的编辑器。由于本人用惯了宇宙第一IDE（Visual Studio），所以当Visual Studio Code出现时，心情有点小激动呢。从我的使用经验出发，可以说VSCode用来写Python真的是再合适不过了，你将体验到丝滑的编程体验和无限扩展的可能。而且，如果你的项目是包含多种语言的，比如Web开发，你不必再开多个编辑器和其他工具，因为这一切都可以在VSCode里完成了。&lt;/p&gt;

&lt;p&gt;　　在VSCode中搜索扩展Python，就是这货：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231544351-1086757768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　安装后，重新加载。上图中我因为已经装过了，所以显示的是禁用、卸载按钮。&lt;/p&gt;
&lt;p&gt;　　下面就可以愉快的和Python玩耍了。是不是超方便？&lt;/p&gt;

&lt;p&gt;　　快在VSCode开始你的第一段Python代码吧，Python插件自带的Pylint功能会在你输入的过程中给你自动提示，自动完成，以及错误提示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231551570-1679757842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里需要提醒各位PythonER们，VSCode包括VS中，Tab都默认是4个空格。&lt;/p&gt;
&lt;p&gt;　　常用的几个操作快捷键，估计VSer们都能无痛转换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是F1/Ctrl+Shit+P万能键，谁用谁知道&lt;/li&gt;
&lt;li&gt;Ctrl+P：文件切换&lt;/li&gt;
&lt;li&gt;Ctrl+空格：自动提示&lt;/li&gt;
&lt;li&gt;F12/Ctrl+左键：跳转到定义&lt;/li&gt;
&lt;li&gt;Shift+F12：预览定义&lt;/li&gt;
&lt;li&gt;Ctrl+G：跳转行号&lt;/li&gt;
&lt;li&gt;Ctrl+/：注释切换&lt;/li&gt;
&lt;li&gt;Alt+↑↓：整行上下移动&lt;/li&gt;
&lt;li&gt;Ctrl+↑↓：编辑器垂直滚动条上下移动，光标不动&lt;/li&gt;
&lt;li&gt;Ctrl+Backspace/Delete：整词/连续空白删除&lt;/li&gt;
&lt;li&gt;Ctrl+→←：光标整词移动&lt;/li&gt;
&lt;li&gt;Ctrl+F查找/Ctrl+Shift+F在文件中查找，这都属于通用的，类似的就不说了啊。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　预览定义图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231557913-524700651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　随时随地，F5调试运行。注意，VSCode默认在调试后，会停在第一句，如下图。&lt;/p&gt;
&lt;p&gt;　　调试快捷键与VS基本相同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;F5：调试/继续，&lt;/li&gt;
&lt;li&gt;F10：单步跳过，&lt;/li&gt;
&lt;li&gt;F11：单步进入，&lt;/li&gt;
&lt;li&gt;Shift+F11：跳出。&lt;/li&gt;
&lt;li&gt;F9：切换断点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231606038-829973399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　左侧Debug窗口显示的从上到下依次是调试所用的模式，变量（局部变量，监视），调用堆栈，断点等。基本上我们需要的功能都在这里了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231610882-812670725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　有个不太好的设计就是变量、监视这些地方宽度太小，查看一些长的变量不如VS方便。不过好在我们有调试控制台啊，直接敲上变量名就好了。&lt;/p&gt;
&lt;p&gt;　　这里需要提醒一下的是，左上角的下拉选择调试模式中，常用的两个是Python和Integrated Terminal/Console，第一个就是在插件自带的环境中调试运行，第二个就是集成的控制台中。问题是，第一种暂不支持input()输入，所以想调试带input的程序，就选择Integrated Terminal/Console或者External Terminal/Console也是可以的。&lt;/p&gt;

&lt;p&gt;　　集成了Git支持，这是很棒的功能，不仅在行首用不同颜色标识添加、删除、修改的行，点击行首色块，还能显示对比。资源管理器中也用不同颜色和标记提示修改的文件。如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231616288-1519110322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　想要提交时，只需要切换到左侧源代码管理，Commit就行了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231621273-2145541785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　VSCode小巧、快速，跨平台，界面炫酷，各种扩展，是时候换用新的VSCode了。&lt;/p&gt;
&lt;p&gt;　　这毕竟是微软出品，随便从VisualStudio项目组拉几个人就能甩Sublime、Atom好几条街了（暂不提Vim），让我有一种一旦用起来就停不下来的感觉。&lt;/p&gt;
&lt;p&gt;　　下一篇，计划介绍一下几个好用的VSCode扩展。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 15:29:00 +0000</pubDate>
<dc:creator>Pleiades</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pleiades/p/8146658.html</dc:identifier>
</item>
<item>
<title>线程池的工作原理与源码解读 - metoy</title>
<link>http://www.cnblogs.com/qingquanzi/p/8146638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingquanzi/p/8146638.html</guid>
<description>&lt;p&gt; 随着cpu核数越来越多，不可避免的利用多线程技术以充分利用其计算能力。所以，多线程技术是服务端开发人员必须掌握的技术。&lt;/p&gt;

&lt;p&gt;线程的创建和销毁，都涉及到系统调用，比较消耗系统资源，所以就引入了线程池技术，避免频繁的线程创建和销毁。&lt;/p&gt;

&lt;p&gt;在Java用有一个Executors工具类，可以为我们创建一个线程池，其本质就是new了一个ThreadPoolExecutor对象。线程池几乎也是面试必考问题。本节结合源代码，说说ThreadExecutor的工作原理&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、线程池创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先看一下ThreadPoolExecutor参数最全的构造方法：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231216070-693632307.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/E8ABF32F4F2E4CD7B0D1AACA16127568&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①corePoolSize：线程池的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。&lt;/p&gt;
&lt;p&gt;②maximumPoolSize:最大线程数，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。&lt;/p&gt;
&lt;p&gt;③keepAliveTime:线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。&lt;/p&gt;
&lt;p&gt;⑤unit：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。&lt;/p&gt;
&lt;p&gt;⑥workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。&lt;/p&gt;
&lt;p&gt;⑦threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。&lt;/p&gt;
&lt;p&gt;⑧handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。&lt;/p&gt;
&lt;p&gt;以上就是创建线程池时用到的参数，面试中经常会有面试官问道这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、线程池执行流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里用一个图来说明线程池的执行流程&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/502A3968315E4681B53AD46B25E93560&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231231929-1280812291.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。&lt;/p&gt;

&lt;p&gt;这里以jdk1.8.0_111的源代码为例，看一下具体实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、先看一下线程池的executor方法&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231325648-245385391.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/960391D21F0040A8A8398DC4CC63857B&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①：判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务&lt;/p&gt;
&lt;p&gt;②：如果不小于corePoolSize，则将任务添加到workQueue队列。&lt;/p&gt;
&lt;p&gt;③：如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、再看下addWorker的方法实现&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231554601-390531474.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/DC5277F6281B47A4A5B7A7819FE33992&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这块代码是在创建非核心线程时，即core等于false。判断当前线程数是否大于等于maximumPoolSize，如果大于等于则返回false，即上边说到的③中创建线程失败的情况。&lt;/p&gt;

&lt;p&gt;addWorker方法的下半部分：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231659117-129178066.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/A0FADFA4C77F430098AF77FC156BCE13&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①创建Worker对象，同时也会实例化一个Thread对象。&lt;/p&gt;
&lt;p&gt;②启动启动这个线程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、再到Worker里看看其实现&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231743648-994771431.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/EFAD863C971944EBB6112A56057537F2&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;可以看到在创建Worker时会调用threadFactory来创建一个线程。上边的②中启动一个线程就会触发Worker的run方法被线程调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、接下来咱们看看runWorker方法的逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231758929-977183448.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/EB2BF6D2A55A48DB8D40C35B67A1C1D0&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;线程调用runWoker，会while循环调用getTask方法从workerQueue里读取任务，然后执行任务。只要getTask方法不返回null,此线程就不会退出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、最后在看看getTask方法实现&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231901007-1866682344.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/0C425896BA9344CA894FFE51674D5364&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①咱们先不管allowCoreThreadTimeOut，这个变量默认值是false。wc&amp;gt;corePoolSize则是判断当前线程数是否大于corePoolSize。&lt;/p&gt;
&lt;p&gt;②如果当前线程数大于corePoolSize，则会调用workQueue的poll方法获取任务，超时时间是keepAliveTime。如果超过keepAliveTime时长，poll返回了null，上边提到的while循序就会退出，线程也就执行完了。&lt;/p&gt;
&lt;p&gt;如果当前线程数小于corePoolSize，则会调用workQueue的take方法阻塞在当前。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 15:21:00 +0000</pubDate>
<dc:creator>metoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingquanzi/p/8146638.html</dc:identifier>
</item>
<item>
<title>消息服务框架（MSF）应用实例之分布式事务三阶段提交协议的实现 - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/8146604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/8146604.html</guid>
<description>&lt;p&gt;在当前互联网，大数据和人工智能的热潮中，传统企业也受到这一潮流的冲击，纷纷响应国家“互联网+”的战略号召，企业开始将越来越多的应用从公司内网迁移到云端和移动端，或者将之前孤立的IT系统联网整合，或者将原来厚重的企业应用拆分重组，独立成一个个轻量级的应用对外提供服务，这对传统的业务处理的数据一致性，带来了严重的挑战，我们已经身处一个分布式的计算环境，分布式事务的需求越来越普遍。&lt;/p&gt;
&lt;p&gt;举一个例子，某行业电商网站经过几年的发展，业务数据累积越来越多，查询越来越慢。经过内部评审分析，认为系统的瓶颈就是数据库压力过大，如果要解决这问题，必须分表分库，比如将订单，商品，用户分布到不同的数据库去，但这样随之带来一个问题，原来处理业务的时候使用的是本地事务，分库后就需要使用分布式事务了。&lt;/p&gt;
&lt;p&gt;那么应该如何实现分布式事务呢？&lt;/p&gt;
&lt;p&gt;这里我们需要明确一点，并非数据库天然就是分布式的在执行操作的，事务都是在一个数据库实例上进行的，如果要执行一个分布式事务的操作，那么就需要协调多个分散的数据库上执行的事务操作。所以在分布式事务中，有2个概念：&lt;/p&gt;
&lt;p&gt;l  Distributed Transaction Resource Owner （简称DTR）：&lt;/p&gt;
&lt;p&gt;n  --&lt;strong&gt;分布式事务资源服务器&lt;/strong&gt;，拥有事务资源的服务器，如绝大部分关系数据库，一些消息队列，或者一些能够执行类似事务操作的应用。&lt;/p&gt;
&lt;p&gt;l  Distributed Transaction Coordinate Controller （简称DTC）：&lt;/p&gt;
&lt;p&gt;n  --&lt;strong&gt;分布式事务协调控制器&lt;/strong&gt;，它协调控制分布式事务环境中的事务资源服务器，发送指令给它们并且处理事务资源服务器返回的结果。&lt;/p&gt;



&lt;p&gt;在分布式事务的具体实现层面，可以在数据库层直接实现，也可以在应用服务层面实现。如果是在应用服务层面实现，本质上它也可能是调用本地的数据库事务。&lt;/p&gt;
&lt;p&gt;下面是DTR与DTC的拓扑关系图：&lt;/p&gt;
&lt;h2&gt;基于关系数据库层面接口实现的分布式事务&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225349085-832890410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于数据库的分布式事务，一般在应用程序的数据层调用系统的分布式事务组件，应用程序执行本地事务的时候，先选举出一个分布式事务协调器，然后协调器来协调各个本地事务的执行。由于是在应用程序的数据层进行的调用，所以它对远程数据库的操作是在本地进程内的。如果你的应用部署在多台服务器上，那么在每一台操作数据库的应用服务器上都要安装运行分布式事务协调器服务。&lt;/p&gt;
&lt;h2&gt;基于应用服务层面实现的分布式事务&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225423351-1514472994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于应用服务层面的分布式事务，是在应用服务层面进行的事务控制，它同样会有分布式事务协调控制器，和事务资源服务器。与基于数据库层面的分布式事务不同，事务的类型支持更广泛，比如消息队列访问，文件写入或者具有补偿操作的业务应用程序，都可以成为事务资源，并且不要求这些事务资源本身支持分布式事务。举个例子，事务资源A是Windows上的SQLSERVER数据库，事务B是Linux上的MySQL数据库，这时候事务B就没法使用Windows上的事务协调控制器MSDTC了。而基于服务层面的分布式事务，可以解决这个问题。&lt;/p&gt;

&lt;h2&gt;第一阶段（1PC）：提交投票阶段&lt;/h2&gt;
&lt;p&gt;协调器向事务资源服务器发出 CanCommit 的是否可以提交事务的询问指令，事务资源服务器收到此指令后，准备好要提交的事务资源，再向协调器回复 YES；如果没有准备好，比如执行事务中的操作出现了错误，应该回复 NO.如果某DTR无法回复，DTC也认为该DTR的结果是NO．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225447273-961295251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一阶段，全部回复为YES，代表各个事务资源服务器均已经准备好了提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225527726-284278746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一阶段，事务资源服务器DTR-2回复为NO，如果DTC等待DTR-2超过设定时间都没有得到回复，或者DTR-2与DTC断开了连接，也认为DTR-2的结果是NO&lt;/p&gt;

&lt;h2&gt;第二阶段（2 PC）：提交或终止阶段&lt;/h2&gt;
&lt;p&gt;协调器统计所有事物资源服务器的回复数量，如果全部回复为YES，则向所有事物资源服务器发出Commit指令，否则，发出Abort指令。资源服务器收到指令后，执行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225602929-998206664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225618742-2029747969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二阶段提交事务的数据不一致问题&lt;/h2&gt;
&lt;p&gt;在第二阶段（2PC），如果DTR没有收到DTC的指令改怎么办呢？&lt;/p&gt;
&lt;p&gt;如果等到超时都没有收到DTC的指令，DTR处于“可以提交”或者“不可以提交”的双重状态，也就是提交状态不可知。假设DTR1没有收到DTC的提交指令或者撤销指令，DTR1可以假设DTR2也不会收到指令，因为此时大概率是DTC宕机或者网络整体不良，那么DTR1最佳的做法是回滚事务。&lt;/p&gt;
&lt;p&gt;但是，如果仅仅是DTR1受网络影响没有收到提交指令，而DTR2收到了提交指令，那么DTR1回滚事务，DTR2提交了事务，整个分布式事务就是失败的，数据发生了不一致。&lt;/p&gt;
&lt;p&gt;因此，2阶段提交的分布式事务不是高可靠的分布式事务控制模型，需要在事务资源的提交环节做更多的验证，这便是3阶段提交的分布式事务。&lt;/p&gt;

&lt;p&gt;不过，对于大部分系统，2阶段提交的分布式事务已经能够满足应用了，因为通常情况下，都是基于数据库应用层实现的分布式事务，并且各个事务资源节点都在同一个局域网内，发生网络不稳定的概率非常小，并且现在不少数据库都会做高可靠性的数据库集群，发生宕机的可能性也非常小，最终出现数据不一致的概率也就非常小了。&lt;/p&gt;

&lt;p&gt;如果系统的应用环境不能满足上面说的任何一个条件，即分布式事务的控制不是在数据库应用层，子系统不在一个局域网，或者数据库没有做高可靠的集群，并且对于系统的事务一致性要求非常高，那么应该使用3阶段提交协议来实现分布式事务。&lt;/p&gt;

&lt;p&gt;对2阶段提交协议的分析我们发现，2PC的事务提交阶段状态是不确定的，整个事务容易出现不一致的情况。所以，我们队2PC的提交阶段，进一步拆分成“预提交”阶段和提交阶段，增加事务提交状态的确认过程。&lt;/p&gt;
&lt;h2&gt;第一阶段（1PC）：提交投票阶段&lt;/h2&gt;
&lt;p&gt;协调器向事务资源服务器发出 CanCommit 的是否可以提交事务的询问指令，事务资源服务器收到此指令后，准备好要提交的事务资源，再向协调器回复 YES；如果没有准备好，比如执行事务中的操作出现了错误，应该回复 NO.如果某DTR无法回复，DTC也认为该DTR的结果是NO．&lt;/p&gt;
&lt;p&gt;该阶段的处理过程跟2阶段提交协议的第一阶段是一样的，处理流程图参考前面，此略。&lt;/p&gt;

&lt;h2&gt;第二阶段（2 PC）：预提交或终止阶段&lt;/h2&gt;
&lt;h3&gt;预提交事务&lt;/h3&gt;
&lt;p&gt;协调器（DTC）统计所有事务资源服务器（DTR）的回复数量，如果全部回复为YES，则向所有事物资源服务器发出PreCommit指令，否则，发出Abort指令。资源服务器收到指令后，执行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225659804-1668514275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第二阶段，如果DTR收到PreCommit指令，则向DTC回复ACK消息，表示收到了指令，准备提交，接着，进入第三阶段，等待最终的提交指令。&lt;/p&gt;

&lt;h3&gt;终止事务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230015898-710850973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第二阶段，如果在第一阶段有节点异常，DTC发出撤销指令，DTR收到了撤销指令，那么它执行回滚本地事务的操作。如果由于网络原因，某个DTR一直等到超时都没有收到PreCommit指令，那么它执行Abort撤销指令，回滚本地事务。&lt;/p&gt;

&lt;h2&gt;第三阶段（3 PC）：提交或终止阶段&lt;/h2&gt;
&lt;h3&gt;提交分布式事务&lt;/h3&gt;
&lt;p&gt;协调器（DTC）统计所有事务资源服务器（DTR）在第二阶段的回复数量，如果全部回复为ACK，则向所有DTR发出Commit指令。DTR收到指令后，执行事务提交操作，并返回Commit Done消息，DTC收到此消息，结束整个分布式事务过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230147820-2074775999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;回滚分布式事务&lt;/h3&gt;
&lt;p&gt;协调器（DTC）统计所有事务资源服务器（DTR）在第二阶段的回复数量，如果未收到全部回复为ACK，则它认为有节点可能出现了网络故障，此节点没有收到PreCommit指令或者虽然收到了却没有回复ACK，测试DTC应该向所有DTR节点发出撤销指令。各DTR收到撤销指令后，回滚本地事务，然后回复消息，DTC完成本次事务过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230231257-1165180646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三阶段提交事务也并不完美&lt;/h2&gt;
&lt;p&gt;考察第3阶段的提交分布式事务的情况，DTR1收到了Commit指令，但是由于网络原因，DTR2没有收到此指令，那么DTR2是提交本地事务还是回滚本地事务？&lt;/p&gt;
&lt;p&gt;站在DTR2的角度，它在本阶段可能收到Commit指令，也可能收到Abort指令，那么它既可以提交本地事务也可以回滚本地事务，两种操作是不确定的，所以，3阶段提交协议，仍然不是完美的，不能百分之百保证数据的最终一致性。&lt;/p&gt;
&lt;p&gt;既然3阶段提交协议仍然有不确定性，那么相比2阶段提交协议有什么意义呢？&lt;/p&gt;

&lt;p&gt;仔细想下，DTR2已经进入第3阶段了，那么肯定其它DTR都进入了第3阶段，而进入第3阶段的前提是各DTR节点都收到过PreCommit指令，都是已经准备好提交只等最后的提交指令了，否则各节点在第二阶段应该收到撤销指令，不会再进入第三阶段。既然各DTR节点都进入了第三阶段，它们都准备好提交事务了，那么即使没有收到最终的Commit指令，DTC发出Commit指令也是大概率的。所以，从概率上讲，如果在第三阶段，DTR没有收到Abort撤销指令，也没收到Commit提交指令，那么它默认应该指向Commit指令，提交本地事务。相比第二阶段某DTR节点没有收到指令而认为应该收到PreCommit指令的概率，要大得多。&lt;/p&gt;

&lt;p&gt;关于第三阶段没有收到指令而应该大概率执行Commit指令的问题，理解起来可能有点困难，我给同事讲的时候大部分同事也难以理解，可能是我表述的问题，大家有更好的解释方式，欢迎交流，不胜感激！&lt;/p&gt;


&lt;p&gt;本文将介绍一个基于服务层面而不是数据库层面的，3阶段提交的分布式事务中间件的设计开发过程。这个中间件必须解决下面几个问题：&lt;/p&gt;
&lt;p&gt;l  通信组件—分布式事务控制器（DTC），分布式事务资源服务器（DTR）都是独立的服务，这些服务部署在不同的通信节点，它们之间需要进行可靠的网络通信，因此通信组件是基础；&lt;/p&gt;
&lt;p&gt;l  数据访问组件—提供基础的数据读写操作，并且能够操作本地事务。&lt;/p&gt;
&lt;p&gt;l  服务组件—将DTC，DTR的功能代码编写为相应的SOA服务组件&lt;/p&gt;
&lt;p&gt;l  关系数据库—具有事务功能的关系数据库，可以是嵌入式的本地数据库，比如SQLite,也可以是服务器客户机模式的网络数据库,比如SQLSERVER。&lt;/p&gt;

&lt;p&gt;各组件的关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230318351-1741662556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;PDF.NET的消息服务框架（MSF）具有开发服务组件基础的接口和一套消息通信组件，同时还有一个服务容器，可以承载本篇文章说的分布式事务控制器DTC，分布式事务资源服务DTR这些服务应用，同时PDF.NET还有一个强大的数据访问组件 PDF.NET SOD，下一篇文章，我们将来具体讨论基于MSF和SOD的3阶段分布式事务应用的实现过程，它的源码已经发布在 &lt;a href=&quot;https://github.com/bluedoctor/MSF-DistTransExample&quot;&gt;https://github.com/bluedoctor/MSF-DistTransExample&lt;/a&gt; ，大家可以先睹为快。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 15:16:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluedoctor/p/8146604.html</dc:identifier>
</item>
<item>
<title>闲置的2017 - liliangel</title>
<link>http://www.cnblogs.com/liliangel/p/8146517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liliangel/p/8146517.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;异常闲而且懒散的一年，起码有200天是国企上班那种状态，以至于12月中旬我就想起了写年终总结。我几乎没有做一件可以说得出口的事情，简单点讲就是一无所获，尝试过各种反问、反思自己，最后得出一个结论：心态没以前好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2166524-afc23f37c59de309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;有多闲置如图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;怀旧&quot;&gt;怀旧&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;老人才怀旧吗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怀念以前说走就走的冲动，那种跨过山河大海的轻松畅快。怀念上坡路上那个骑着自行车挥汗如雨的少年，不禁至此已成长了肚子的大叔。怀念以前充实的工作日，倒杯水都觉得浪费时间的峥嵘岁月。怀念以前会精心准备一顿晚餐的悸动，在平淡日子里添增几分色彩。大概只有闲的人才有时间怀旧吧，曾经我开导别人说：如果你不开心，那是因为自己没有真正忙碌起来，才会去想自己是否开心这个命题。也对，我有时间怀旧，为什么不去给未来充电呢？&lt;/p&gt;
&lt;h2 id=&quot;充电&quot;&gt;充电&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;React技术栈进阶&lt;/li&gt;
&lt;li&gt;webpack从入门到进阶&lt;/li&gt;
&lt;li&gt;sass深入&lt;/li&gt;
&lt;li&gt;微信支付探索使用&lt;/li&gt;
&lt;li&gt;小程序等待观望&lt;/li&gt;
&lt;li&gt;dubbo activemq了解&lt;/li&gt;
&lt;li&gt;linux基本操作&lt;/li&gt;
&lt;li&gt;layui深度使用&lt;/li&gt;
&lt;li&gt;编程思想、思维方式的历练、总结&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;技术上&quot;&gt;技术上&lt;/h3&gt;
&lt;p&gt;还是有一种渴求学习的状态，可能源自兴趣，可能源自生存压力，可能源自发展大潮流，却也依然面对各种层出不穷的新东西感到恐慌和疲倦。大概就是这么纠结的进步和却步着，彷徨而又奔跑着。&lt;/p&gt;
&lt;h4 id=&quot;java后台方面&quot;&gt;JAVA后台方面&lt;/h4&gt;
&lt;p&gt;依然是保留的状态，不过也有幸做了一个用了dubbo、activemq等的项目，算是了解、会简单使用。为了不对JAVA产生大生疏的距离，也搭了一个轻量的后台工程，基于springMVC、mybatis这些吃老本的东西，前端用gulp简单构建，做了一个地图的小项目。听说springboot很流行，觉得也有必要去了解一下&lt;/p&gt;
&lt;h4 id=&quot;服务器&quot;&gt;服务器&lt;/h4&gt;
&lt;p&gt;既然是独立做了一个小项目，那么肯定离不开服务器，甚至是域名申请、备案这些流程，而这一块应该说还是比较空白的，也趁此机会，稍微学习了基础的linux环境操作，如一些基本的命令、装个svn配置账号密码、安装配置nginx等，这些后续必须要加强&lt;/p&gt;
&lt;h4 id=&quot;人工智能&quot;&gt;人工智能&lt;/h4&gt;
&lt;p&gt;Python作为今年最火的语言，人工智能、深度学习、机器学习也是今年热门且高大上的关键字，看了一本李开复老师的书，算是对这方面有点点认识了，最近又听说python要作为学生教材语言了，那么我是不是也得跟进学习呢？&lt;/p&gt;
&lt;h4 id=&quot;前端&quot;&gt;前端&lt;/h4&gt;
&lt;p&gt;主要还是前端，这也是我工作岗位职称。那么面对五花八门的前端技术，我的态度是八个字：保持关注，适应需求。可以说前端还是在一个发展阶段，导致的就是一个水平参差不齐，有的人已经跑得很靠前了，有得有甚至还停留在原生js的点上，但是他们在一个团队，这该怎么去找一个平衡点呢？&lt;/p&gt;
&lt;p&gt;这一年，其实我更多的是在培养编程的意识、思路，以及去考虑团队协作中面对人员技术的一些差异性怎么去平衡，还有与产品/UI商量界面的交互、与后台对接接口时怎么更有效的沟通，也去思考面对一个新项目，怎么去根据其特殊性选择最合适的框架或者说技术栈，甚至是最后测试时的一些分歧怎么优雅处理。在不断的自我反思和自我完善中成长。&lt;/p&gt;
&lt;p&gt;其实真的有时候真的又觉得多学一门框架又能如何呢，现在假如现在把React玩溜了，把Vue玩转了，你的公司还在用jquery，你能怎么办呢？重构吗？走人吗？当然，都可以选择，只是觉得框架和API时刻在变化，唯有编程思想是精髓，有了好的编程思想，再借助提高效率的框架，才能达到事半功倍的效果。&lt;/p&gt;
&lt;p&gt;国内的小公司小团队的前端，其实还是有些尴尬的存在的，大多都是1-2个前端，甚至还是很古老的套路，一个做静态页面一个写js交互，我是很反感写静态页面的模式的，根本无法产出高质量的代码。而前端的发展如日中天，早已走向新时代了，可是还是有很多人认为写页面-那不是很简单的事情吗？2小时能搞定吧，这个网站2天能做完吧？&lt;/p&gt;
&lt;p&gt;最近听了很多类似的话，我也是默默地听着了，因为我知道就算闹个脾气也改变不了什么，反而会对自己的外在评价降分。为什么会造成这样的局面呢？思来想去，还是因为国内大部分的技术领导都是早期的后台出身，他们对前端的理解大多数还是停留在前几年的滞后状态，所以潜意识里面还是觉得这个要求不会太高，比较简单。加上运营大部分对技术也不太了解，当然运营活动的时效性也决定了给不了开发太多的时间，所以大部分的运营活动他们恨不得你分分钟能把所谓的“静态页面”输出。。 唉，太多的事与愿违，是缺乏工匠精神，还是没有拥有工匠精神的大环境？做为页面仔的你，是不是也曾经干过那种一个页面直接贴一张整图这种操蛋的事情呢？&lt;/p&gt;
&lt;p&gt;但是，也不要那么的悲观。前端出于高速发展的阶段，必然会有些矛盾的产生，也必然会越来越受人们重视，心理上的成熟，多运用沟通技巧，工作就是这样的。2018年一定要有一个好心态，更成熟的内心。&lt;/p&gt;
&lt;h3 id=&quot;生活上&quot;&gt;生活上&lt;/h3&gt;
&lt;h4 id=&quot;骑行&quot;&gt;骑行&lt;/h4&gt;
&lt;p&gt;今年总共里程不到1kkm，说出来其实是很丢人的，自行车已经落灰了。。下一个阳光灿烂的日子，带上头盔就出发吧，或许明天吧~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;骑行登顶梧桐山&lt;/li&gt;
&lt;li&gt;和女朋友一起骑行松山湖， &amp;gt; 100km + 跨市&lt;/li&gt;
&lt;li&gt;没了&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;阅读&quot;&gt;阅读&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今年看了几本书，有走马观花式阅读，也有受益匪浅的片段，有人说：清醒时做事，糊涂时看书。确实，大城市的年轻人们，其实很容易迷茫的，有时候还真需要一点鸡汤文来祭奠青春。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;列一下书单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vue.js权威指南&lt;/li&gt;
&lt;li&gt;ES6标准入门&lt;/li&gt;
&lt;li&gt;我只是敢跟别人不一样&lt;/li&gt;
&lt;li&gt;人工智能 -李开复&lt;/li&gt;
&lt;li&gt;深入React技术栈 -陈屹&lt;/li&gt;
&lt;li&gt;React前端技术与工程实践&lt;/li&gt;
&lt;li&gt;浮躁 -贾平凹&lt;/li&gt;
&lt;li&gt;社会契约论&lt;/li&gt;
&lt;li&gt;少有人走的路&lt;/li&gt;
&lt;li&gt;Javascript高级程序设计&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;在深圳搬了第三次家&quot;&gt;在深圳搬了第三次家&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今年是在深圳的第三次搬家了，这回与以往不同，没有跨区没有叫搬家公司，只是在同一个小区里换了一间稍微大一点的，采光好一些的农民房。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的装饰了一下，买了床、衣柜、餐具柜、书柜等，装了空调、热水器，比以前没有什么大区别，只是这些东西现在都是自己买的了，更有归属感一点吧？！&lt;/p&gt;
&lt;p&gt;网上很流行一句话：房子是租来的，生活是自己的！没错，谁都想过好点高质量的生活，但是是否有支撑这些的能力呢？想在深圳生存不难，想在深圳生活也不会太难，想在深圳生长太难太难了。所谓生长，就是生根发芽、买房落户，但凡是扯上这一点，瞬间就感觉怀疑人生了，面对高贵的房价，望而却步。&lt;/p&gt;
&lt;p&gt;那么就退而求其次吧，尽管不是那么的满意，如户型上的不足，未来发展潜力堪忧等，但是也至少赶上了限购前的末班车，也算是今年做成了的一件事，对自己美好生活向往迈出的第一步，长沙-离老家最近的省会城市，武广新城-早上从深圳做高铁可以回家吃午饭，应该是要高兴，也值得高兴的。&lt;/p&gt;
&lt;h4 id=&quot;秋刀鱼的滋味猫跟你都想了解&quot;&gt;秋刀鱼的滋味，猫跟你都想了解&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;深大地铁站，最近出现了几张很文艺的广告，女生+猫+周杰伦歌词的文艺照片。相信有很多人都看到了，有一种对广告怦然心动的感觉，原来广告也可以那么文艺、年轻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年9月份，从深大一个有爱心的学生那里领养了一直流浪猫，原名花生，我习惯叫他猫兄，躁动、亲人、不挑、短毛的橘色猫，会在我去上班的时候在门口目送我离开，会在我下班回来会在门后表示迎接（其实是饿了等食物），会在我看电视的时候蹲在我腿上一起看着屏幕，会在我写代码的时候来键盘上捣乱。尽管有时候是挺讨嫌的，但是已经是生活的一部分了，我会给他买好的猫粮，每天喂干净的水，开心时给他开罐头，不听话时把他关笼子里... 目前他已经打完猫三联和狂犬疫苗了，再过阵子可能要去做绝育，他还有10多天的时间做只正常男猫，哈哈！哦，对了，他还没了解过秋刀鱼~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2166524-7e37a87efd0c9103.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;此刻的猫兄&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;水浒做人三国处世&quot;&gt;水浒做人，三国处世&lt;/h4&gt;
&lt;p&gt;从小对古典文学抱有兴趣，水浒传原著、三国演义原著分别阅读和细读了一遍，这么多年来对性格养成产生了非常大的影响。10年四大名著电视剧翻拍，当时水浒传真的看得深夜恸哭。13年，重新再看了一遍新版水浒电视剧，到林冲恨不能杀高俅的桥段，揪心，扬言再不看水浒。然而今年上半年，闲暇时间，分别看了一遍新版三国、老版三国，对刘备有了新的看法，后还看了一遍老版水浒，再后来趁热打铁，又看了一遍新水浒... 对宋江、吴用也不同于七年前的认识，几字两言还真说不尽，打算个人理解的写一些书评，一直还没开这个头，也许来年会吧，至少要把《金圣叹批评本水浒》上下看完。&lt;/p&gt;
&lt;h2 id=&quot;团队重组的阵痛&quot;&gt;团队重组的阵痛&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;年中的时候公司技术团队大调整，融合、优化，总之，就是相当于离职一样到了一个陌生的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;融入&quot;&gt;融入&lt;/h3&gt;
&lt;p&gt;不过这又比离职好一点，至少周边环境不要重新熟悉，并且还有几个认识的人，当然所面临的项目也变化了，新的同事该怎么融入呢，面对角色的转变，唯有主动融入，比如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一起去吃午饭，从交流中互相了解 -&lt;/li&gt;
&lt;li&gt;该加班的时候加班，因为加班的时候大家可能比正常工作时间更放得开一些，可以大声交流，可以讨论一些琐事...&lt;/li&gt;
&lt;li&gt;有问题主动询问，通常情况下大家都是挺愿意帮助人的&lt;/li&gt;
&lt;li&gt;有问题主动回答，当团队中有不确定的方案在讨论时，如果你又更好的建议，不妨说出来一起讨论，这样也有利于提升自己价值&lt;/li&gt;
&lt;li&gt;不卑不亢，踏踏实实做事情，自然就能融入&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;面对不同的技术栈&quot;&gt;面对不同的技术栈&lt;/h3&gt;
&lt;p&gt;原来的项目因为业务没有发展起来现在只是维护，重点放在新的项目上，新的项目用的技术栈有新有旧，原来重点在微信公众号开发、h5+app混合开发上，这回突然要维护新项目的官网，pc端，兼容ie8，jsp! 确实心理上难以接受，不过这种问题其实也是意料之中的，就算是换工作也难免这种情况，一个程序员是否成熟其实也包含了是否愿意维护传统项目的心态，某种程度上而言这也是一种历练，所以不如欣然接受吧！在开发完需求的剩余时间里，重点还是在移动端React的深入研究上，期间也用React做过一个项目、一个demo。Webpack是不错的东西，在不断的尝试和使用中，最近整理了一套Webpack多页面+jQuery+ES6+Sass的一个方案，他介意新潮和传统之间，短期内我应该都会尝试使用和优化这套方案&lt;/p&gt;
&lt;h3 id=&quot;做好离开的准备&quot;&gt;做好离开的准备&lt;/h3&gt;
&lt;p&gt;人不为己，怕是个傻子吧！所有的充电，都是为了更好释放电流做准备。所有的技术学习，都是为将有一天能做更大型的项目做储备。我还是希望能有好的机会，去做一个庞大用户量的项目，高质量的项目，哪怕是一个很小的螺丝钉，他也至少置身于大型机器中！所以我依然是这样定位，时刻做好离开的准备。这个公司文化、公司项目有关系，扯不上忠诚度这个词，更不能说是一个喜欢跳槽的人。&lt;/p&gt;
&lt;h2 id=&quot;驾考&quot;&gt;驾考&lt;/h2&gt;
&lt;p&gt;上一次报考驾校时才3300吧，可是被驾校坑了，3个月不通知考科目一，最后算一下时间要毕业去深圳了也来不及考了，就退了，扣了好像是800块钱。其实主要是当时也还是没有把开车这个事情想得很近，总以为自行车还能玩好多年，包括现在很长一段时间我还是这么觉得，所以就一直也不去考虑考驾照这个事。随着身边的环境、朋友、经历等一些变化，如国庆坐朋友车走了一晚上高速回老家，如上上个星期去广西猫儿山那个山角山角里，必须自己开车才方便，加上最主要的是最近应该是有空闲的时间来做题学车，不能浪费这两个月的时间，抓住年前的这波机会，果断就报名了，清远外地班，目前已考科目一，正在练科二，目标是一把过，fighting！&lt;/p&gt;
&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;年度发现最佳辅助工具：最高效易用的自动标注工具，设计研发利器&lt;a href=&quot;http://www.fancynode.com.cn/pxcook&quot;&gt;PxCook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用最好的前端文本编辑器（还不能称作IDE）： &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;vs code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;年中的时候，写了一篇博客，现在看来可能又有很多要优化的地方了，这就是成长吧！&lt;a href=&quot;http://www.cnblogs.com/liliangel/p/6732507.html&quot;&gt;前端项目从0到1的感悟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;做了一个个人网站，存放一些博客、感悟、民谣、骑行等生活琐事，不愿成为知识的过客，拥抱开源，崇尚共享，乐于交流，技术碰撞，共同进步。 &lt;a href=&quot;http://www.twobike.cn/&quot; class=&quot;uri&quot;&gt;http://www.twobike.cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 29 Dec 2017 14:29:00 +0000</pubDate>
<dc:creator>liliangel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liliangel/p/8146517.html</dc:identifier>
</item>
<item>
<title>java中的异常处理 - 曾将</title>
<link>http://www.cnblogs.com/GH0522/p/8146301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GH0522/p/8146301.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：异常的概念：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。&lt;br/&gt; 在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先查看一下异常类的树状体系结构，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171229162333288-152824885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;Thorwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception） 和检查异常（Checked Exception）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：Error和Exception&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，  Java虚拟机（JVM）一般会选择线程终止。&lt;/p&gt;&lt;p&gt;Exception是程序本身可以处理的异常，这种异常分两大类运行时异常（不可查异常）和非运行时异常（可查异常）。 程序中应当尽可能去处理这些异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2：运行时异常和非运行时异常&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等， 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。&lt;/p&gt;
&lt;p&gt;这类异常程序不要求必须去做处理。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。 如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。&lt;/p&gt;
&lt;p&gt;这类异常则要求我们对这个异常进行处理，要么使用try--catch--finally，要么使用throws去声明这个异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：异常的处理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先在java中，都是通过 try--catch--finally，throw，throws关键字进行的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1：异常处理的基本语法：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;try--catch--finally：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Enum;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能会出现异常的代码块&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;想要捕获的异常
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常的处理&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不管怎样都会被运行的语句，例如关闭链接资源，关闭连接对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1： try语句块，表示要尝试运行代码，try语句块中代码受异常监控，其中代码发生异常时，会抛出异常对象。 &lt;/p&gt;
&lt;p&gt;catch语句块会捕获try代码块中发生的异常并在其代码块中做异常处理，catch语句带一个Throwable类型的参数， 表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配， 若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，  用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了，所以如果需要匹配多个异常就把异常的子类放到前面，父类放到后面。 通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等。&lt;/p&gt;
&lt;p&gt; finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，  而不管是否try语句块是否发生异常。并且这个语句块总是在方法返回前执行。 目的是给程序一个补救的机会。这样做也体现了Java语言的健壮性。&lt;/p&gt;

&lt;p&gt;2、 try、catch、finally三个语句块应注意的问题 ：&lt;br/&gt;    第一、try、catch、finally三个语句块均不能单独使用，三者可以组成 try...catch...finally、try...catch、&lt;br/&gt;    try...finally三种结构，catch语句可以有一个或多个，finally语句最多一个。&lt;br/&gt;    第二、try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。&lt;br/&gt;    如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。&lt;br/&gt;    第三、多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，&lt;br/&gt;    并且匹配catch语句的顺序是由上到下。&lt;/p&gt;


&lt;p&gt;throw、throws关键字&lt;/p&gt;
&lt;p&gt; throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常， 则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。 如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。 如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。有关异常的转译会在下面说明。&lt;/p&gt;&lt;p&gt;throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常， 该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出。&lt;/p&gt;

&lt;p&gt; 例如throws申明一个异常：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;ClassNotFoundException{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;3&lt;/span&gt; }&lt;/span&gt; &lt;/p&gt;

&lt;p&gt; 例如这个throw 观察一下有什么不同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这很好的说明了 throw对与可查异常和不可查异常处理之间的差别&lt;/p&gt;


&lt;p&gt; Throwable类中的常用方法&lt;br/&gt;   　　 getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。&lt;br/&gt;   　　 getMessage()：返回异常的消息信息。&lt;br/&gt;   　　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             
&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            e.getMessage();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            e.getCause();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 三&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：异常的一般原则：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1、 能处理就早处理，抛出不去还不能处理的就想法消化掉或者转换为RuntimeException处理。&lt;br/&gt;    因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能的控制异常发生的可能。&lt;br/&gt; 2、 对于检查异常，如果不能行之有效的处理，还不如转换为RuntimeException抛出。&lt;br/&gt;    这样也让上层的代码有选择的余地――可处理也可不处理。&lt;br/&gt; 3、 对于一个应用系统来说，应该有自己的一套异常处理框架，这样当异常发生时，也能得到统一的处理风格，&lt;br/&gt;    将优雅的异常信息反馈给用户。&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;四&lt;span&gt;&lt;strong&gt;：自定义异常：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先 创建一个类继承异常类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Exection;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Myexecption &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Myexecption(String message, Throwable cause, &lt;span&gt;boolean&lt;/span&gt; enableSuppression, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; writableStackTrace) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause, enableSuppression, writableStackTrace);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption(String message, Throwable cause) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption(String message) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption(Throwable cause) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(cause);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后编写代码 ，然后编写逻辑，这个异常什么时候需要使用，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Exection;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; shang (&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Myexecption{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;(y==0&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Myexecption(&quot;您输入的是&quot;+y+&quot;,规定除数不能为负数!&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛出异常  &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; x/&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Myexecption {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         shang(10, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在需要的地方抛出这个异常。&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171229210424617-486380165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了  异常就到这了；&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 13:06:00 +0000</pubDate>
<dc:creator>曾将</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GH0522/p/8146301.html</dc:identifier>
</item>
<item>
<title>为什么epoll会那么高效 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8146143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8146143.html</guid>
<description>&lt;p&gt;参考（原文简直超赞）：&lt;a id=&quot;url_1&quot; href=&quot;https://zhidao.baidu.com/question/687563051895364284.html&quot; target=&quot;_blank&quot;&gt;https://zhidao.baidu.com/question/687563051895364284.html&lt;/a&gt;&lt;br/&gt;下面是我结合原文写的，为了便于自己理解：&lt;br/&gt;关于阻塞和非阻塞的理解可以看这个：http://www.cnblogs.com/xcywt/p/8146123.html&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;1.举例子说明&lt;/span&gt;&lt;br/&gt;假设你在读大学，有个朋友F来找你，你住在A栋。但是不知道具体是哪个房间。于是你们约好在A栋门口见面。&lt;br/&gt;如果用阻塞IO模型来处理这个问题，你就相当于一直在A栋门口等着，这个时候你不能做别的事情，效率比较低，如果F一直不来你就得一直在那等着。&lt;br/&gt;接着来看用非阻塞模型来处理这个问题，主要有两种select/poll（这两个可以看成一种）和epoll：&lt;br/&gt;select大妈做的事情是这样：当朋友F到了楼下时，她带着F一个个房间了轮询的去找你。&lt;br/&gt;epoll大妈就比较高级了：大妈拿本子记录下你的房间号，当朋友F来的时候告诉F你的房间号。这样就不用整栋楼去跑了。&lt;br/&gt;在大并发服务器中，轮询IO是一件比较费时的操作，就跟select大妈一样。&lt;br/&gt;epoll大妈多用了一个本子，就有点用空间去换取时间的意思。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;2.select/poll为什么慢：&lt;/span&gt;&lt;br/&gt;1）select/poll 是遍历所有添加进fd_set的fd。并且需要将所有用户态的fd拷贝到内核态。数量巨大时这个效率比较慢&lt;br/&gt;2）并且返回之后，还要轮询将所有集合查询一次&lt;br/&gt;3）内核空间的数据需要拷贝到用户空间&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;3.epoll的实现原理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体使用方法可以参考：http://www.cnblogs.com/xcywt/p/8146094.html&lt;br/&gt;先说几个函数的作用&lt;br/&gt;       int epoll_create(int size); // 创建一个epoll对象，size是内核保证能够正确处理的最大句柄数。&lt;br/&gt;       int epoll_create1(int flags);// 上面的加强版本，参数只能是EPOLL_CLOEXEC&lt;br/&gt;       int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 操作epoll对象&lt;br/&gt;       int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);// 在给定时间内，监控的所有句柄中有时间发生就返回&lt;br/&gt;下面我们来看具体做了什么：&lt;br/&gt;　　epoll在内核初始化的时候向内核注册了一个&lt;span&gt;文件系统，用于存储上述被监控的socket&lt;/span&gt;，同时还会开辟出epoll自己的内核高速cache区，用于安置需要监控的fd。这些fd以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说就是物理上分配好你想要的大小的内存对象，每次使用时都是使用空闲的已分配好的对象。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　每次调用epoll_create时，会在这个虚拟的&lt;span&gt;epoll文件系统里创建一个file节点&lt;/span&gt;，在内核cache中建立个红黑树来存储通过epoll_ctl添加进来的fd。这些fd其实已经在内核态了，当你再次调用epoll_wait时，&lt;span&gt;不需要再拷贝进内核态（select需要再全部拷贝到内核态）&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　同时还会建立&lt;span&gt;一个list链表，用来存储已经就绪的事件。被epoll_wait调用时，就去看这个list链表是不是为空，若不为空就返回，为空就等待指定的事件再返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　list链表是如何维护的呢：&lt;span&gt;当我们执行epoll_ctl时，会把对应fd放到红黑树中，还会给内核终端处理程序注册一个回调函数。如果这个句柄的中断到了，就把它放在list链表中去。&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;总结一下：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一棵红黑树和一个list链表就解决大并发的问题&lt;/span&gt;&lt;/strong&gt;。epoll_create时创建红黑树和就绪链表，epoll_ctl时添加到红黑树中（若存在则不添加）并向内核注册回调函数。epoll_wait时返回list就绪链表里面的数据就可以了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;4.epoll的两个工作模式：&lt;/span&gt;&lt;br/&gt;LT：只要一个句柄上的事件一次没有处理完，接着调用epoll_wait时仍然会返回这个句柄。&lt;br/&gt;ET：尽在空闲状态-&amp;gt;就绪状态返回一次。&lt;br/&gt;这件事是怎么做到的呢：当有fd'发生事件时，就放到list就绪链表中去了。然后epoll_wait返回，再然后清空准备list就绪链表。&lt;br/&gt;最后如果是LT模式，并且仍有未处理的事件，就把这个fd重新放回到list就绪链表中。&lt;br/&gt;如果是ET，就不管了，不管有没有事件未处理完都不再添加到list就绪链表中。&lt;/p&gt;
&lt;p&gt;就有点像下面的流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wait返回 -&amp;gt;&lt;span&gt; 清空list就绪链表
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(LT模式）
{
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(存在未处理完的事件)
  {
    重新添加进list就绪链表中
  }
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ET 模式&lt;/span&gt;
&lt;span&gt;{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于触发模式详解，这里面也讲的比较详细：&lt;br/&gt;&lt;a id=&quot;url_2&quot; href=&quot;http://blog.csdn.net/weiyuefei/article/details/52242778&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/weiyuefei/article/details/52242778&lt;/a&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;5.ET模式被唤醒的条件&lt;/span&gt;：&lt;/span&gt;&lt;br/&gt;对于读取操作：&lt;br/&gt;1）buffer由不可读，变为可读的时候。&lt;br/&gt;2）buffer数据变多的时候，有新的数据到来&lt;br/&gt;3）当buffer不为空（有数据可读），且用户对相应fd进行epoll_mod  IN 事件时。（待会用代码演示）&lt;br/&gt;对于写操作：&lt;/p&gt;
&lt;p&gt;1）由不可写，变成可写&lt;br/&gt;2）buffer是数据变少的时候，也就是被读走了一部分3）buffer有可写空间，且用户对相应fd进行epoll_mod OUT 事件时。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;对于LT模式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读操作：只要缓冲区中有数据，且读完一部分之后还不空的时候，就会返回&lt;/p&gt;
&lt;p&gt;写操作：当发送缓冲区没满，写了一下还不满的时候，epoll_wait返回读事件。&lt;/p&gt;
&lt;p&gt;补充一个例子1：验证ET模式的读取返回的前2个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLIN|EPOLLET; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记A，这里是ET模式
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ev.events = EPOLLIN; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记B。表示默认是LT模式&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加标准输入&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;read(STDIN_FILENO, buf, sizeof(buf)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记C&lt;/span&gt;
                cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world, recv:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; buf &amp;lt;&amp;lt;&lt;span&gt; endl;
            }
        } 
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分三种情况讨论：&lt;/span&gt;&lt;br/&gt;1）打开标记A，注释B和C：这种情况运行，虽然输入缓冲区里面还有数据，但是“hello world”也不会一直打印。&lt;br/&gt;因为边沿触发，一定要等到下一次事件到来 wait才会返回。&lt;br/&gt;2）打开B，注释A和C：切换成了LT模式，只要缓冲区里面还有数据吗，wait会一直返回。所以helloworld会一直打印&lt;br/&gt;3）打开B和C，注释A：LT模式，但是每次wait之后把缓冲区里面的数据读完了，相当于处理完了这个事件。wait就不会返回了。除非标准输入中再输入数据。&lt;/p&gt;&lt;p&gt;例子2：验证ET模式的读取返回的第3个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLIN|&lt;span&gt;EPOLLET; 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &amp;lt;&amp;lt; endl;&lt;/span&gt;
                ev.data.fd =&lt;span&gt; STDIN_FILENO;
                ev.events &lt;/span&gt;= EPOLLIN|&lt;span&gt;EPOLLET;
                epoll_ctl(epfd, EPOLL_CTL_MOD, STDIN_FILENO, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对fd进行epoll_mod  IN 事件&lt;/span&gt;
&lt;span&gt;            }
        } 
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到当输入一次之后，依然会有死循环打印helloworld。&lt;/p&gt;&lt;p&gt;例子3：验证ET模式的写返回，前2个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLOUT|&lt;span&gt;EPOLLET; 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; endl; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记A&lt;/span&gt;
                cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记B&lt;/span&gt;
&lt;span&gt;            }
        } 
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于ET模式。&lt;br/&gt;1）打开标记A，注释标记B：可以看到会死循环，因为这里有 endl 。标准输出为控制台的时候缓冲的“行缓冲”，所以换行符号导致buffer中的内容被清空。就相当于上面条件中的第二个，有数据发送走了。所以会一直循环&lt;br/&gt;2）打开B，注释A：不发送endl，就相当于buffer中一直有数据存在，所以wait不会一直返回。&lt;/p&gt;&lt;p&gt;例子4，ET模式的写返回第三个条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLOUT|&lt;span&gt;EPOLLET;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
                ev.events &lt;/span&gt;=&lt;span&gt; EPOLLOUT;
                epoll_ctl(epfd, EPOLL_CTL_MOD, STDIN_FILENO, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对fd进行epoll_mod  OUT 事件&lt;/span&gt;
&lt;span&gt;            }
        } 
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每次输出helloworld后重新MOD OUT 事件。也会一直循环打印。&lt;br/&gt;注意：LT模式没有验证&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 12:12:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8146143.html</dc:identifier>
</item>
<item>
<title>JNI的使用总结初篇 - 孤竹牧歌</title>
<link>http://www.cnblogs.com/silentdoer/p/8145722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/silentdoer/p/8145722.html</guid>
<description>&lt;p&gt;前言：以下内容是个人在写JNI Demo前后进行查找理解总结得出的一些结论，如有错误的地方希望路过的朋友能够指正。&lt;/p&gt;
&lt;p&gt;一、JNI是Java native interface的简称，目前就我所知这类方法的实现方式是由C/C++实现并保存在动态链接库里；一般是这些方法需要能更有效率的执行所以将它们定义为JNI方法（权限似乎也是一方面？），JNI方法除了加上native关键字在返回类型前面以及实现方式由C/C++实现外在使用方式上和其它方法没有区别。&lt;/p&gt;
&lt;p&gt;二、个人用的开发环境是Windows7x64、IDEA2017.2.1x64、VS2015x64、JDK1.8x64，此次Demo只是做了一些JNI的简单使用，真正使用场景将会涉及到如数据转换等问题。&lt;/p&gt;
&lt;p&gt;三、个人对JNI原理的理解：Java代码里能够调用C/C++类库是因为有JVM为这两者做适配，因为JVM本身就是C/C++写的程序，自然它能够调用C/C++写的动态链接库，故当Java代码里请求调用一个JNI方法时，会将所需数据提交给JVM，然后JVM再将参数包装后去调用dll中对应的方法，然后dll中对应方法执行完毕后再由JVM将返回数据进行一定的转换后返回给请求的Java代码处。&lt;/p&gt;
&lt;p&gt;四、现在就让咱们一起用用这神秘的JNI方法吧，先是定义一个类JNIDemo类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; silentdoer.demo;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JNIDemo {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.loadLibrary(&lt;/span&gt;&quot;JNIMethods01&quot;&lt;span&gt;);  // 这个是JNIMethods01.dll文件的前缀名
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compare(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hello();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sub(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
}&lt;br/&gt;// 注：后面用javah命令时如果出现编码GBK的不可映射字符错误将中文删除即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着运行cmd，将路径切换到此项目的src目录，然后输入命令javah silentdoer.demo.JNIDemo按下回车键&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229184853945-1461609127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会在src目录下生成silentdoer_demo_JNIDemo.h头文件（也可以进入classes目录用上面的javah命令，不过这种方式如果此类里引用了其它地方的类会出现异常）&lt;/p&gt;
&lt;p&gt;五、接着打开VS2015，然后新建一个空解决方案起名为Demo.JNI，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229185403210-912012725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在生成的解决方案里右键添加-新建项目，然后添加一个C++的Win32项目起名为JNIMethods01：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229185533070-740084802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击确定然后点击下一步直到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229185605538-409870478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择应用程序类型Radio的DLL项点击完成（也可以取消勾选预编译头和安全开发生命周期检查）；&lt;/p&gt;
&lt;p&gt;六、由于我的开发环境都是64位的，故要将C++生成dll的类型也改为64位，顺便将Debug改为Release，如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229190312476-173147990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将生成的头文件silentdoer_demo_JNIDemo.h复制到此项目的根目录下（不是解决方案），然后右键项目-添加-现有项&lt;/p&gt;
&lt;p&gt;将刚才的头文件添加到项目的头文件分类里，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229190058304-1619936541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此时添加的头文件里会报错，需要添加jni.h和jni_md.h两个头文件到项目的头文件分类里，这两个文件在JDK的include目录中，如图箭头：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229190541179-1324546290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jni_md.h在win32子目录里；复制到项目根目录后以同样的方式添加进项目里；&lt;/p&gt;
&lt;p&gt;这里需要改下silentdoer_demo_JNIDemo.h中#include &amp;lt;jni.h&amp;gt;为#include &quot;jni.h&quot;，因为&quot;jni.h&quot;才是从项目路径里搜索的方式。&lt;/p&gt;
&lt;p&gt;七、将silentdoer_demo_JNIDemo.h中的三个方法复制到JNIMethods01.cpp中并添加头文件引用，然后实现这三个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229191251054-481944464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229191141288-1343691696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 八、点击VS2015上边的生成-重新生成解决方案，然后找到此解决方案目录下的x64/Release目录，将JNIMethods01.dll复制到&lt;/p&gt;
&lt;p&gt;E:\MyJNILib目录里（也可以在其它目录里），然后添加Path环境变量，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229192930273-86289937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;九、此时可以在刚才的Java项目里添加main方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; silentdoer.demo.JNIDemo;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Entrance {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        JNIDemo.hello();
        System.out.println(JNIDemo.compare(&lt;/span&gt;3, 4) &amp;gt;= 0 ? &quot;a &amp;gt;= b&quot; : &quot;a &amp;lt; b&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; JNIDemo().sub(10, 6&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启一遍IDEA（因为IDEA只有启动时才加载Path环境变量），运行后输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
hello everyone, I'm silentdoer.
a &amp;lt;&lt;span&gt; b
&lt;/span&gt;4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此初篇完结，如有错误忘各位指正，也希望如果转载能带上本文的链接。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 11:31:00 +0000</pubDate>
<dc:creator>孤竹牧歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/silentdoer/p/8145722.html</dc:identifier>
</item>
</channel>
</rss>