<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发（2）- 聊聊happens-before - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/9330702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/9330702.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;上一篇文章聊到了Java内存模型，在其中我们说JMM是建立在happens-before（先行发生）原则之上的。&lt;br/&gt;为什么这么说呢？因为在Java程序的执行过程中，编译器和处理器对我们所写的代码进行了一系列的优化来提高程序的执行效率。这其中就包括对指令的“重排序”。&lt;br/&gt;重排序导致了我们代码并不会按照代码编写顺序来执行，那为什么我们在程序执行后结果没有发生错乱，原因就是Java内存模型遵循happens-before原则。在happens-before规则下，不管程序怎么重排序，执行结果不会发生变化，所以我们不会看到程序结果错乱。&lt;/p&gt;
&lt;h2 id=&quot;重排序&quot;&gt;重排序&lt;/h2&gt;
&lt;p&gt;重排序是什么？通俗点说就是编译器和处理器为了优化程序执行性能对指令的执行顺序做了一定修改。&lt;br/&gt;重排序会发生在程序执行的各个阶段，包括编译器冲排序、指令级并行冲排序和内存系统重排序。这里不具体分析每个重排序的过程，只要知道重排序导致我们的代码并不会按照我们编写的顺序来执行。&lt;br/&gt;在单线程的的执行过程中发生重排序后我们是无法感知的，如下代码所示，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int a = 1;  //步骤1
int b = 2;  //步骤2
int c = a + b; //步骤3 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1和2做了重排序并不会影响程序的执行结果，在某些情况下为了优化性能可能会对1和2做重排序。2和3的重排序会影响执行结果，所以编译器和处理器不会对2和3进行重排序。&lt;br/&gt;在多线程中如果没有进行正确的同步，发生重排序我们是可以感知的，比如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class AAndB {

    int x = 0;
    int y = 0;
    int a = 0;
    int b = 0;
    
    public void awrite() {

        a = 1;
        x = b;
    }
    
    public void bwrite() {

        b = 1;
        y = a;
    }
}

public class AThread extends Thread{

    private AAndB aAndB;
    
    public AThread(AAndB aAndB) {
        
        this.aAndB = aAndB;
    }
    
    @Override
    public void run() {
        super.run();
        
        this.aAndB.awrite();
    }
}

public class BThread extends Thread{

    private AAndB aAndB;
    
    public BThread(AAndB aAndB) {
        
        this.aAndB = aAndB;
    }
    
    @Override
    public void run() {
        super.run();
        
        this.aAndB.bwrite();
    }
}

private static void testReSort() throws InterruptedException {

    AAndB aAndB = new AAndB();

    for (int i = 0; i &amp;lt; 10000; i++) {
        AThread aThread = new AThread(aAndB);
        BThread bThread = new BThread(aAndB);

        aThread.start();
        bThread.start();

        aThread.join();
        bThread.join();

        if (aAndB.x == 0 &amp;amp;&amp;amp; aAndB.y == 0) {
            System.out.println(&quot;resort&quot;);
        }

        aAndB.x = aAndB.y = aAndB.a = aAndB.b = 0;

    }

    System.out.println(&quot;end&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不进行重排序，程序的执行顺序有四种可能：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180718174752455-1501264761.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180718174759917-795102531.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180718174806132-725419080.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180718174811647-110401752.png&quot;/&gt;&lt;br/&gt;但程序在执行多次后会打印出“resort”，这种情况就说明了A线程和B线程都出现了重排序。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/368583/201807/368583-20180718174835245-1950202161.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;happens-before的定义&quot;&gt;happens-before的定义&lt;/h2&gt;
&lt;p&gt;happens-before定义了八条规则，这八条规则都是用来保证如果A happens-before B，那么A的执行结果对B可见且A的执行顺序排在B之前。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作。&lt;/li&gt;
&lt;li&gt;管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序，下同）对同一个锁的lock操作。&lt;/li&gt;
&lt;li&gt;volatile变量规则：对一个volatile变量的写操作happen—before后面对该变量的读操作。&lt;/li&gt;
&lt;li&gt;线程启动规则：Thread对象的start（）方法happen—before此线程的每一个动作。&lt;/li&gt;
&lt;li&gt;线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。&lt;/li&gt;
&lt;li&gt;线程中断规则：对线程interrupt（）方法的调用happen—before发生于被中断线程的代码检测到中断时事件的发生。&lt;/li&gt;
&lt;li&gt;对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。&lt;/li&gt;
&lt;li&gt;传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;happens-before定义了这么多规则，其实总结起来可以归纳为一句话：happens-before规则保证了单线程和正确同步的多线程的执行结果不会被改变。&lt;br/&gt;那为什么有程序次序规则的保证，上面多线程执行过程中还是出现了重排序呢？这是因为happens-before规则仅仅是java内存模型向程序员做出的保证。在单线程下，他并不关心程序的执行顺序，只保证单线程下程序的执行结果一定是正确的，java内存模型允许编译器和处理器在happens-before规则下对程序的执行做重排序。&lt;br/&gt;而且从程序员角度来说，对于两个操作是否真的被重排序并不关心，关心的是程序执行结果是否被改变。&lt;br/&gt;上面的程序在单线程会被重排序的情况下又没有对多线程同步，这样就导致了意料之外的结果。&lt;/p&gt;
&lt;h2 id=&quot;as-if-serial语义&quot;&gt;as-if-serial语义&lt;/h2&gt;
&lt;p&gt;《Java并发编程的艺术》中解释：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;as-if-serial就是不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话通俗理解就是as-if-serial语义保证单线程程序的执行结果不会被改变。&lt;br/&gt;本质上和happens-before规则是一个意思：happens-before规则保证了单线程和正确同步的多线程的执行结果不会被改变。都是对执行结果做保证，对执行过程不做保证。&lt;br/&gt;这也是JMM设计上的一个亮点：既保证了程序员编程时的方便以及正确，又同时保证了编译器和处理器更大限度的优化自由。&lt;/p&gt;&lt;p&gt;参考资料：&lt;br/&gt;《深入理解Java内存模型》&lt;br/&gt;《深入理解Java虚拟机》&lt;br/&gt;《Java并发编程的艺术》&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 23:12:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/9330702.html</dc:identifier>
</item>
<item>
<title>数据结构算法 - hlgfrtyu</title>
<link>http://www.cnblogs.com/hl1996-11-24/p/9333740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hl1996-11-24/p/9333740.html</guid>
<description>&lt;p&gt;Python内置了许多非常有用的数据结构，比如列表（list）,集合（set）以及字典（dictionary）。就绝大部分情况而言，我们可以直接使用这些数据结构。但是，我们通常还要考虑比如搜索，排序，排列以及筛选等这一类常见的问题。因此，本章的目的就是来讨论常见的数据结构和通数据相关的算法。此外，在collections模块中也包含了针对各种数据结构的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 将序列分解为单独的变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.1.1 问题&lt;/p&gt;
&lt;p&gt;我们有一个包含N个元素的元组或序列，现在想将它分解为N个单独的变量。&lt;/p&gt;
&lt;p&gt;1.1.2解决方案&lt;/p&gt;
&lt;p&gt;任何序列（或可迭代的对象）都可以通过一个简单的赋值操作来分解为单独的变量。&lt;/p&gt;
&lt;p&gt;唯一的要求是变量的总数和结构要与序列相吻合。列如：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; p = (4,5)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x, y = p&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; y&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; data = ['ACNE', 50, 91.1, (2012, 12, 21)]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name, shares, price, data = data&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;'ACNE'&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; data&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;(2012, 12, 21)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name, shares, price, data = data&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;'ACME'&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; year&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;2012&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; mon&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;12&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; day&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;21&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;如果元素的数量不匹配，将得到一个错误提示。列如&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; p = (4,5)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x,y,z = p&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Traceback (most recent call last):&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;ValueError: not enough values to unpack (expected 3, got 2)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1.1.3讨论&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;实际上不仅仅只是元素或列表，只要是对象恰好是可迭代的，那么就可以执行分解操作。这包括字符串，文件，迭代器以及生成器。比如：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = 'Hello'&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a,b,c,d,e = s&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;'H'&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; e&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;'o'&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; b&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;'e'&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;当做分解操作时，有时候可能想丢弃某些特定的值。Python并没有提供特殊的语法来实现这一点，但是通常可以选一个用不到的变量名，以此来作为要丢弃的值得名称。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;列如：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; data = ['ACME',50,91.1,(2012,12,21)]&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; _, shares, price, _ = data&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; shares&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;50&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt; price&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;91.1&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;但是请确保选择的变量名没有在其他地方用到过。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;1.2 从任意长度的可迭代对象中分解元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1.2.1 问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;需要从某个可迭代对象中分解出N个元素，但是这个可迭代对象的长度可能超过N，这回导致出现“分解的值过多（too many values to unpack）的异常”&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1.2.2解决方案&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Python的&quot;*表达式,星号表达式&quot;可以用来解决这个问题。列如，假设开设了一门课程，并决定在期末的作业成绩中去掉第一个和最后一个，只对中间剩下的成绩作平均分统计。如果只有4个成绩，也许可以简单地将4个都分解出来，但是如果有24个呢？*表达式使这一切都变得简单：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt; def drop_first_last(grades):&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;     first, *middle, last = grades &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;     return avg(middle)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;另一个用例是假设有一些用户记录，记录由姓名和电子邮件地址组成，后面跟着任意数量的电话号码。则可以像这样分解记录；&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;record &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'Dave'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s1&quot;&gt;'dave@example.com'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s1&quot;&gt;'773-555-1212'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s1&quot;&gt;'847-555-1212'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;name&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;email&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;phone_numbers &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;record
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;name
&lt;span class=&quot;go&quot;&gt;'Dave'
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;email
&lt;span class=&quot;go&quot;&gt;'dave@example.com'
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;phone_numbers
&lt;span class=&quot;go&quot;&gt;['773-555-1212', '847-555-1212']
&lt;span class=&quot;go&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是上面解压出的 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;phone_numbers&lt;/span&gt;&lt;/code&gt; 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。 所以，任何使用到 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;phone_numbers&lt;/span&gt;&lt;/code&gt; 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。&lt;/p&gt;
&lt;p&gt; 星号表达式也能用在列表的开始部分。比如，你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。你可以这样做：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;trailing_qtrs&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;current_qtr &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;sales_record
&lt;span class=&quot;n&quot;&gt;trailing_avg &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nb&quot;&gt;sum&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;trailing_qtrs&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;o&quot;&gt;/ &lt;span class=&quot;nb&quot;&gt;len&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;trailing_qtrs&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;avg_comparison&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;trailing_avg&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;current_qtr&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;p&gt;下面是在 Python 解释器中执行的结果：
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;32.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;trailing&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;current &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;10&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;8&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;7&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;9&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;5&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;10&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;3&lt;span class=&quot;p&quot;&gt;]
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;trailing
&lt;span class=&quot;go&quot;&gt;[10, 8, 7, 1, 9, 5, 10]
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;current
&lt;span class=&quot;go&quot;&gt;3&lt;p&gt;讨论：&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值。&lt;/p&gt;
&lt;p&gt;值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。 比如，下面是一个带有标签的元组序列：&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;n&quot;&gt;records &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;p&quot;&gt;[
    &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'foo'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;),
    &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'bar'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s1&quot;&gt;'hello'&lt;span class=&quot;p&quot;&gt;),
    &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'foo'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;3&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;),
&lt;span class=&quot;p&quot;&gt;]

&lt;span class=&quot;k&quot;&gt;def &lt;span class=&quot;nf&quot;&gt;do_foo&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;x&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;y&lt;span class=&quot;p&quot;&gt;):
    &lt;span class=&quot;k&quot;&gt;print&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'foo'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;x&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;y&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;k&quot;&gt;def &lt;span class=&quot;nf&quot;&gt;do_bar&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;s&lt;span class=&quot;p&quot;&gt;):
    &lt;span class=&quot;k&quot;&gt;print&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'bar'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;s&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;k&quot;&gt;for &lt;span class=&quot;n&quot;&gt;tag&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;args &lt;span class=&quot;ow&quot;&gt;in &lt;span class=&quot;n&quot;&gt;records&lt;span class=&quot;p&quot;&gt;:
    &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;n&quot;&gt;tag &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;s1&quot;&gt;'foo'&lt;span class=&quot;p&quot;&gt;:
        &lt;span class=&quot;n&quot;&gt;do_foo&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;p&quot;&gt;)
    &lt;span class=&quot;k&quot;&gt;elif &lt;span class=&quot;n&quot;&gt;tag &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;s1&quot;&gt;'bar'&lt;span class=&quot;p&quot;&gt;:
        &lt;span class=&quot;n&quot;&gt;do_bar&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;foo 1 2&lt;br/&gt;bar hello&lt;br/&gt;foo 3 4&lt;/p&gt;
&lt;p&gt;当和某些特定的字符串处理操作相结合，比如做做字符串分割（splitting）操作时，这种星号解压语法也很有用。&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;line &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;s1&quot;&gt;'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;uname&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;fields&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;homedir&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;sh &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;line&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;split&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;':'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;uname
&lt;span class=&quot;go&quot;&gt;'nobody'
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;homedir
&lt;span class=&quot;go&quot;&gt;'/var/empty'
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;sh
&lt;span class=&quot;go&quot;&gt;'/usr/bin/false'
&lt;span class=&quot;go&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;有时候可能想解压出某些值然后丢弃他们。在分解的时候，不能只是指定一个单独的*，但是可以使用几个常用来表示待丢弃值得变量名，比如_或者ign(ignored)。列如：
&lt;/pre&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;19&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;record &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'ACME'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;50&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mf&quot;&gt;123.45&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;12&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;18&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;2012&lt;span class=&quot;p&quot;&gt;))
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;name&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;_&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;_&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;year&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;record
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;name
&lt;span class=&quot;go&quot;&gt;'ACME'
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;year
&lt;span class=&quot;go&quot;&gt;2012
&lt;span class=&quot;go&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。比如，如果你有一个列表， 你可以很容易的将它分割成前后两部分：&lt;/p&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;items &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;10&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;7&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;5&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;9&lt;span class=&quot;p&quot;&gt;]
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;head&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;tail &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;items
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;head
&lt;span class=&quot;go&quot;&gt;1
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;tail
&lt;span class=&quot;go&quot;&gt;[10, 7, 4, 5, 9]
&lt;span class=&quot;go&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;document&quot;&gt;
&lt;div id=&quot;id1&quot; class=&quot;section&quot; readability=&quot;9.5&quot;&gt;
&lt;div id=&quot;id4&quot; class=&quot;section&quot; readability=&quot;15.5&quot;&gt;
&lt;p&gt;如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：&lt;/p&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;k&quot;&gt;def &lt;span class=&quot;nf&quot;&gt;sum&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;items&lt;span class=&quot;p&quot;&gt;):
&lt;span class=&quot;gp&quot;&gt;...     &lt;span class=&quot;n&quot;&gt;head&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;n&quot;&gt;tail &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;items
&lt;span class=&quot;gp&quot;&gt;...     &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;n&quot;&gt;head &lt;span class=&quot;o&quot;&gt;+ &lt;span class=&quot;nb&quot;&gt;sum&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;tail&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;n&quot;&gt;tail &lt;span class=&quot;k&quot;&gt;else &lt;span class=&quot;n&quot;&gt;head
&lt;span class=&quot;gp&quot;&gt;...
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;nb&quot;&gt;sum&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;items&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;go&quot;&gt;36
&lt;span class=&quot;go&quot;&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后，由于语言层面的限制，递归并不是 Python 擅长的。 因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了。&lt;a class=&quot;btn btn-neutral float-right&quot; title=&quot;1.3 保留最后 N 个元素&quot; accesskey=&quot;n&quot; href=&quot;http://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p03_keep_last_n_items.html&quot; rel=&quot;next&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.3.1问题&lt;/span&gt;&lt;/p&gt;

&lt;div id=&quot;id1&quot; class=&quot;section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt; 1.3.2解决方案&lt;/p&gt;
&lt;p&gt;保存有限的历史记录可算是collections.deque的完美应用场景了。列如：下面的代码对一系列文本行做简单的文本匹配操作，当发现有匹配时就输出以前的匹配行以及最后检查过的N行文本。&lt;/p&gt;

&lt;div class=&quot;document&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;n&quot; class=&quot;section&quot; readability=&quot;15&quot;&gt;
&lt;div id=&quot;id2&quot; class=&quot;section&quot; readability=&quot;8&quot;&gt;
&lt;h2&gt;解决方案&lt;/h2&gt;
&lt;p&gt;保留有限历史记录正是 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;collections.deque&lt;/span&gt;&lt;/code&gt; 大显身手的时候。比如，下面的代码在多行上面做简单的文本匹配， 并返回匹配所在行的最后N行：&lt;/p&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;from &lt;span class=&quot;nn&quot;&gt;collections &lt;span class=&quot;kn&quot;&gt;import &lt;span class=&quot;n&quot;&gt;deque


&lt;span class=&quot;k&quot;&gt;def &lt;span class=&quot;nf&quot;&gt;search&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;lines&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;pattern&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;history&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;5&lt;span class=&quot;p&quot;&gt;):
    &lt;span class=&quot;n&quot;&gt;previous_lines &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;deque&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;maxlen&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;n&quot;&gt;history&lt;span class=&quot;p&quot;&gt;)
    &lt;span class=&quot;k&quot;&gt;for &lt;span class=&quot;n&quot;&gt;line &lt;span class=&quot;ow&quot;&gt;in &lt;span class=&quot;n&quot;&gt;lines&lt;span class=&quot;p&quot;&gt;:
        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;n&quot;&gt;pattern &lt;span class=&quot;ow&quot;&gt;in &lt;span class=&quot;n&quot;&gt;line&lt;span class=&quot;p&quot;&gt;:
            &lt;span class=&quot;k&quot;&gt;yield &lt;span class=&quot;n&quot;&gt;line&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;previous_lines
        &lt;span class=&quot;n&quot;&gt;previous_lines&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;line&lt;span class=&quot;p&quot;&gt;)

&lt;span class=&quot;c1&quot;&gt;# Example use on a file
&lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;vm&quot;&gt;__name__ &lt;span class=&quot;o&quot;&gt;== &lt;span class=&quot;s1&quot;&gt;'__main__'&lt;span class=&quot;p&quot;&gt;:
    &lt;span class=&quot;k&quot;&gt;with &lt;span class=&quot;nb&quot;&gt;open&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;sa&quot;&gt;r&lt;span class=&quot;s1&quot;&gt;'../../cookbook/somefile.txt'&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;k&quot;&gt;as &lt;span class=&quot;n&quot;&gt;f&lt;span class=&quot;p&quot;&gt;:
        &lt;span class=&quot;k&quot;&gt;for &lt;span class=&quot;n&quot;&gt;line&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;prevlines &lt;span class=&quot;ow&quot;&gt;in &lt;span class=&quot;n&quot;&gt;search&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;f&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s1&quot;&gt;'python'&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;mi&quot;&gt;5&lt;span class=&quot;p&quot;&gt;):
            &lt;span class=&quot;k&quot;&gt;for &lt;span class=&quot;n&quot;&gt;pline &lt;span class=&quot;ow&quot;&gt;in &lt;span class=&quot;n&quot;&gt;prevlines&lt;span class=&quot;p&quot;&gt;:
                &lt;span class=&quot;k&quot;&gt;print&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;pline&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;end&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;s1&quot;&gt;''&lt;span class=&quot;p&quot;&gt;)
            &lt;span class=&quot;k&quot;&gt;print&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;line&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;n&quot;&gt;end&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;s1&quot;&gt;''&lt;span class=&quot;p&quot;&gt;)
            &lt;span class=&quot;k&quot;&gt;print&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'-' &lt;span class=&quot;o&quot;&gt;* &lt;span class=&quot;mi&quot;&gt;20&lt;span class=&quot;p&quot;&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;id3&quot; class=&quot;section&quot; readability=&quot;22&quot;&gt;
&lt;h2&gt;讨论&lt;/h2&gt;
&lt;p&gt;我们在写查询元素的代码时，通常会使用包含 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;yield&lt;/span&gt;&lt;/code&gt; 表达式的生成器函数，也就是我们上面示例代码中的那样。 这样可以将搜索过程代码和使用搜索结果代码解耦。如果你还不清楚什么是生成器，请参看 4.3 节。&lt;/p&gt;
&lt;p&gt;使用 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;deque(maxlen=N)&lt;/span&gt;&lt;/code&gt; 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;deque&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;n&quot;&gt;maxlen&lt;span class=&quot;o&quot;&gt;=&lt;span class=&quot;mi&quot;&gt;3&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;3&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q
&lt;span class=&quot;go&quot;&gt;deque([1, 2, 3], maxlen=3)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q
&lt;span class=&quot;go&quot;&gt;deque([2, 3, 4], maxlen=3)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;5&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q
&lt;span class=&quot;go&quot;&gt;deque([3, 4, 5], maxlen=3)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;尽管你也可以手动在一个列表上实现这一的操作（比如增加、删除等等）。但是这里的队列方案会更加优雅并且运行得更快些。&lt;/p&gt;
&lt;p&gt;更一般的， &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;deque&lt;/span&gt;&lt;/code&gt; 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;div class=&quot;highlight-python notranslate&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;deque&lt;span class=&quot;p&quot;&gt;()
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;1&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;2&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;append&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;3&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q
&lt;span class=&quot;go&quot;&gt;deque([1, 2, 3])
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;appendleft&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;mi&quot;&gt;4&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q
&lt;span class=&quot;go&quot;&gt;deque([4, 1, 2, 3])
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;pop&lt;span class=&quot;p&quot;&gt;()
&lt;span class=&quot;go&quot;&gt;3
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q
&lt;span class=&quot;go&quot;&gt;deque([4, 1, 2])
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;n&quot;&gt;q&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;n&quot;&gt;popleft&lt;span class=&quot;p&quot;&gt;()
&lt;span class=&quot;go&quot;&gt;4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在队列两端插入或删除元素时间复杂度都是 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;O(1)&lt;/span&gt;&lt;/code&gt; ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;O(N)&lt;/span&gt;&lt;/code&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;&gt;&lt;span class=&quot;go&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;o&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;&gt;&lt;span class=&quot;gp&quot;&gt;&lt;span class=&quot;n&quot;&gt;&lt;span class=&quot;go&quot;&gt;&lt;span class=&quot;go&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Wed, 18 Jul 2018 22:10:00 +0000</pubDate>
<dc:creator>hlgfrtyu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hl1996-11-24/p/9333740.html</dc:identifier>
</item>
<item>
<title>angular前言及环境搭建1 - 伪代码</title>
<link>http://www.cnblogs.com/freezyh/p/9315790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freezyh/p/9315790.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　angular升级到6了，个人认为刚开始的angularjs很多企业都喜欢采用，后面由于angular更新的太快，从1到2完全变了一个风格，采用了typescript风格，后面直接升级&lt;/span&gt;&lt;span&gt;到4，后面又出现了5，目前又升级了到6，当然版本升级肯定是有所优化。可是对于用angularjs的很多企业却望而止步，升级得重写，要么一时招不到适合的人才，要&lt;/span&gt;&lt;span&gt;么还要人员去学习的一个成本，加上升级太快，相应的第三方组件也有可能升级，这样一来挺麻烦的，干脆一直沿用着angularjs。现在的招聘网上前端要求更多的倾向于&lt;/span&gt;&lt;span&gt;其他框架，虽然有提到，但更多的也是angularjs。个人还是觉得angular还是挺优秀的一门框架，但是对vue来相比，angular会重些，文件方面都会相对比较大，至于性能&lt;/span&gt;&lt;span&gt;方面本人不能下定论，但不可置疑的是vue是轻量多了，入门快，不好意思我对react了解的不多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　angular的UI组件相对比较少，个人比较喜欢用阿里系的开源组件NG-ZORRO &lt;a href=&quot;https://ng.ant.design/docs/introduce/zh&quot;&gt;https://ng.ant.design/docs/introduce/zh&lt;/a&gt;  ，还有一个是PrimeNG &lt;a href=&quot;https://www.primefaces.org/primeng/#/&quot;&gt;https://www.primefaces.org/primeng/#/&lt;/a&gt; ，感觉PrimeNG比NG-ZORRO重，分不同主题，有些还要收费，果断放弃，其实NG-ZORRO刚开源的时候，也感觉很多动画那些卡&lt;/span&gt;&lt;span&gt;顿，可能后面优化了不少，感觉还可以，蛮喜欢的，很难找到像NG-ZORRO这么优秀的angular开源组件了。当然要自己封装复杂的angular组件也是挺麻烦的，相关的插件&lt;/span&gt;&lt;span&gt;也很少，成本比较高，对于angular不满足的地方，也许就是这点，感觉angluar封闭性有点高，也许是自己没有完全吃透的原因吧。我不喜欢angular中使用jquery，总感觉&lt;/span&gt;&lt;span&gt;自己很排斥那些网上的朋友老喜欢五花八门的拼凑插件，最后把angular搞的很臃肿，为了实现功能，不惜一切代价。还有个人不喜欢angular中使用bootstrap，在我看来bootstrap&lt;/span&gt;&lt;span&gt;比较适用于jquery相关的项目（不喜勿喷，个人观点），并且引入bootstrap的文件也不小，总而言之，尽量少用太多的插件组件之类的，本人推崇NG-ZORRO组件基本上够用了，&lt;/span&gt;&lt;span&gt;当然还有图表之类的，就另外说了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实在我了解angular2的时候，是接触ionic2, &lt;a href=&quot;https://ionicframework.com/docs/intro/installation/&quot;&gt;https://ionicframework.com/docs/intro/installation/&lt;/a&gt; ,很早之前的ionic1使用的就是angularjs1，也许ionic就是因angular而生，有兴趣&lt;/span&gt;&lt;span&gt;的朋友可以了解学习下混合开发技术ionic，现在可能升级到了ionic3，可以打包成ios和安卓，当然也存在些兼容性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在正是进入angular环境部署阶段，本人是win10 64位，后面的案例基本上在此操作和实践，至于mac如果搭建这里就不提了，自己也可以查找相关文档，其实流程的差不多。&lt;/span&gt;&lt;span&gt;首先下载安装node，个人建议不要安装最新版的，下载稳定版的就可以了 &lt;a href=&quot;https://nodejs.org/zh-cn/&quot;&gt;https://nodejs.org/zh-cn/&lt;/a&gt; ，也就是官网推荐的，安装好了可以命令行输入node -v和npm -v查看版本。&lt;/span&gt;&lt;span&gt;这里要提下的就是之前很多人都会下载安装cnpm使用淘宝镜像，但是angular升级到了6了，即使npm和cnpm安装依赖包也会出现卡死现象，目前不太推荐使用它来安装依赖包。后续官方应该会有所处理，不懂的可以网上搜索：“ng serve --open执行到95%卡住”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放弃使用cnpm，使用yarn，安装yarn：npm install --global yarn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置仓库和科学上网不用操作，留着以后用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置仓库：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;npm config set registry http://registry.npmjs.org/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yarn config set registry https://registry.yarnpkg.com/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;科学上网：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;npm config set registry https://registry.npm.taobao.org&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yarn config set registry &lt;a href=&quot;https://registry.npm.taobao.org/&quot;&gt;&lt;span&gt;https://registry.npm.taobao.org&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在此强调下环境部署：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.安装node，官方推荐的稳定版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.安装yarn：npm install --global yarn&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.安装npm install -g cnpm --registry=https://registry.npm.taobao.org&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里是我的相关环境配置，仅供参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100424/201807/1100424-20180719023248558-1024848308.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里cnpm只用来安装&lt;span&gt;Angular cli&lt;/span&gt;工具，依赖包还是用&lt;span&gt;yarn&lt;/span&gt;安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.cnpm install -g @angular/cli&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ng -v查看版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100424/201807/1100424-20180719023256160-1027956956.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过4个步骤就可以把环境弄好了，现在创建项目之前还是简单了解下相关命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ng -help查看帮助&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100424/201807/1100424-20180719023306060-1951332023.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看创建的详细帮助可以这样 ng new --help，我这里只有查看&lt;span&gt;new&lt;/span&gt;的不会报错，其它有些会报错，有些不会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100424/201807/1100424-20180719023337350-809402020.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看创建以后，我们来创建一个项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建项目：ng new ngtest --skip-install  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--skip-install是创建项目的时候跳过安装依赖包，自己用&lt;span&gt;yarn&lt;/span&gt;安装依赖包，默认安装依赖包是使用&lt;span&gt;npm&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导入依赖：cd ngtest进入目录运行 &lt;span&gt;yarn install&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100424/201807/1100424-20180719023353587-137220964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命令行输入ng serve --open&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--open是默认浏览器自动打开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100424/201807/1100424-20180719023403244-1693281614.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 18:38:00 +0000</pubDate>
<dc:creator>伪代码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freezyh/p/9315790.html</dc:identifier>
</item>
<item>
<title>SystemTap - 安装 - wipan</title>
<link>http://www.cnblogs.com/wipan/p/9333623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wipan/p/9333623.html</guid>
<description>&lt;p class=&quot;home&quot;&gt;按照SystemTap Beginners Guide的&lt;a href=&quot;https://sourceware.org/systemtap/SystemTap_Beginners_Guide/using-systemtap.html#using-setup&quot; target=&quot;_blank&quot;&gt;Installation and Setup&lt;/a&gt;部分安装了SystemTap，没想到竟然还有点曲折，在这里纪录一下。&lt;/p&gt;
&lt;p class=&quot;home&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;home&quot;&gt;环境&lt;/h2&gt;
&lt;ul&gt;&lt;li class=&quot;home&quot;&gt;Linux发行版本：CentOS Linux release 7.4.1708 (Core)&lt;/li&gt;
&lt;li class=&quot;home&quot;&gt;内核版本：3.10.0-693.2.2.el7.x86_64&lt;/li&gt;
&lt;li class=&quot;home&quot;&gt;uname -a: Linux hostname 3.10.0-693.2.2.el7.x86_64 #1 SMP Tue Sep 12 22:26:13 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;h3&gt;安装SystemTap&lt;/h3&gt;
&lt;p&gt;先安装如下两个RPM包：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;listitem&quot;&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt;systemtap&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt;systemtap-runtime&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;package&quot;&gt;以root运行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; systemtap systemtap-runtime
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在运行SystemTap之间，还需要装必要的内核信息包。在现代系统上，可以运行如下stap-prep来安装这些包，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# stap-&lt;span&gt;prep
Need to &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;&lt;span&gt; the following packages:
kernel&lt;/span&gt;-devel-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
kernel&lt;/span&gt;-debuginfo-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
No package kernel&lt;/span&gt;-devel-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64 available.
No package kernel&lt;/span&gt;-debuginfo-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64 available.
Error: Nothing to &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
Could not &lt;/span&gt;&lt;span&gt;find&lt;/span&gt; debuginfo &lt;span&gt;for&lt;/span&gt; main pkg: kernel-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
No debuginfo packages available to &lt;/span&gt;&lt;span&gt;install&lt;/span&gt;&lt;span&gt;
package kernel&lt;/span&gt;-devel-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64 is not installed
package kernel&lt;/span&gt;-debuginfo-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64 is not installed
problem installing rpm(s) kernel&lt;/span&gt;-devel-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.el7.x86_64 kernel-debuginfo-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.el7.x86_64
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行stap-prep的时候，它探测出还要安装kernel-devel-3.10.0-693.2.2.el7.x86_64包和kernel-debuginfo-3.10.0-693.2.2.el7.x86_64包 (实际上还有kernel-debuginfo-common包)，但是自动安装失败。我们可以按照如下方法手动安装。&lt;/p&gt;

&lt;h3&gt;手动安装必要的内核信息包&lt;/h3&gt;
&lt;p&gt;SystemTap需要安装内核内核符号文件来probe内核。必要的内核信息包含在如下三个包中：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;listitem&quot;&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt;kernel-debuginfo&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt;kernel-debuginfo-common&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt;kernel-devel&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;package&quot;&gt;一定要安装与当前内核版本一致的包。当前环境的内核版本是3.10.0-693.2.2.el7.x86_64，所以需要安装的包为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;package&quot;&gt;kernel-debuginfo-3.10.0-693.2.2.el7.x86_64&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;package&quot;&gt;kernel-debuginfo-common-3.10.0-693.2.2.el7.x86_64&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;package&quot;&gt;kernel-devel-3.10.0-693.2.2.el7.x86_64&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;package&quot;&gt;注意：其实在上一步运行stap-prep时，已经把需要的包的名称及其内核精准地打印在屏幕上了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;package&quot;&gt;接下来安装这三个包，注意不要直接yum install kernel-debuginfo kernel-debuginfo-common kernel-devel, 即使能找到相应的包，也是安装的最新版本，不会自动匹配当前版本。所以我们下载RPM包，再用rpm命令依次安装。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;package&quot;&gt;对于CentOS来说，内核符号文件一版在http://debuginfo.centos.org上有各个版本非常完整的包，但是一般从境内下载都比较慢，特别是kernel-debuginfo，比较大下载可能非常慢。所以在&lt;/span&gt;debuginfo.centos.org上下了kernel-debuginfo-common包，另外两个包在Google上搜了一把，分别找了两个镜像。下了之后才发现这个地方有坑，这个坑在后面展开讲。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ftp.sjtu.edu.cn/scientific/7/archive/debuginfo/kernel-debuginfo-3.10.0-693.2.2.el7.x86_64.rpm&lt;/span&gt;
&lt;span&gt;wget&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;debuginfo.centos.org/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-693.2.2.el7.x86_64.rpm&lt;/span&gt;
&lt;span&gt;wget&lt;/span&gt; &lt;span&gt;ftp&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirror.switch.ch/pool/4/mirror/scientificlinux/7.0/x86_64/updates/security/kernel-devel-3.10.0-693.2.2.el7.x86_64.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下载之后，直接用rpm命令安装就好：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# rpm -ivh kernel-debuginfo-common-x86_64-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64.rpm
# rpm &lt;/span&gt;-ivh kernel-debuginfo-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64.rpm
# rpm -ivh kernel&lt;/span&gt;-devel-&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.el7.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此安装步骤完毕，下面来测试SystemTap能不能正常运行。&lt;/p&gt;

&lt;h3&gt;运行SystemTap&lt;/h3&gt;
&lt;p&gt;为了测试stap是否能正常运行，用如下简单命令打印：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# stap -e &lt;span&gt;'&lt;/span&gt;&lt;span&gt;probe begin{printf(&quot;Hello, World&quot;); exit();}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行失败...结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# stap -e &lt;span&gt;'&lt;/span&gt;&lt;span&gt;probe begin{printf(&quot;Hello, World&quot;); exit();}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ERROR: module version mismatch (#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; SMP Tue Sep &lt;span&gt;12&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; CDT &lt;span&gt;2017&lt;/span&gt; vs #&lt;span&gt;1&lt;/span&gt; SMP Tue Sep &lt;span&gt;12&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt; UTC &lt;span&gt;2017&lt;/span&gt;), release &lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
WARNING: &lt;/span&gt;/usr/bin/staprun exited with status: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;: run failed.  [&lt;span&gt;man&lt;/span&gt; error::pass5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误信息是：&quot;&lt;span&gt;&lt;span&gt;ERROR: module version mismatch (#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;SMP Tue Sep&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;CDT&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt; &lt;span&gt;vs #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;SMP Tue Sep&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;UTC&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&quot;。&lt;/p&gt;

&lt;h2&gt;解决&quot;ERROR: module version mismatch&quot;问题&lt;/h2&gt;
&lt;p&gt;stap运行的时候加上-v参数，打印更多信息看看还有没有更多线索：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
# stap -e &lt;span&gt;'&lt;/span&gt;&lt;span&gt;probe begin{printf(&quot;Hello, World&quot;); exit();}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -&lt;span&gt;v
Pass &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: parsed user script and &lt;span&gt;470&lt;/span&gt; library scripts using 228224virt/41280res/3348shr/38020data kb, &lt;span&gt;in&lt;/span&gt; 330usr/20sys/&lt;span&gt;346real ms.
Pass &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: analyzed script: &lt;span&gt;1&lt;/span&gt; probe, &lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt; embeds, &lt;span&gt;0&lt;/span&gt; globals using 229148virt/42332res/3536shr/38944data kb, &lt;span&gt;in&lt;/span&gt; 0usr/0sys/&lt;span&gt;6real ms.
Pass &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;: using cached /root/.systemtap/cache/0b/&lt;span&gt;stap_0bc9e27aef7a1de50ea41889a27fc524_1010.c
Pass &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;: using cached /root/.systemtap/cache/0b/&lt;span&gt;stap_0bc9e27aef7a1de50ea41889a27fc524_1010.ko
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;: starting run.
ERROR: module version mismatch (#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; SMP Tue Sep &lt;span&gt;12&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; CDT &lt;span&gt;2017&lt;/span&gt; vs #&lt;span&gt;1&lt;/span&gt; SMP Tue Sep &lt;span&gt;12&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt; UTC &lt;span&gt;2017&lt;/span&gt;), release &lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
WARNING: &lt;/span&gt;/usr/bin/staprun exited with status: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;: run completed &lt;span&gt;in&lt;/span&gt; 0usr/10sys/&lt;span&gt;38real ms.
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;: run failed.  [&lt;span&gt;man&lt;/span&gt; error::pass5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看c文件，vi /root/.systemtap/cache/0b/stap_0bc9e27aef7a1de50ea41889a27fc524_1010.c，搜错误信息&quot;&lt;span&gt;module version mismatch&lt;/span&gt;&quot;，能搜到报错发生在下面的第13行，至于&lt;span&gt;UTS_RELEASE和UTS_VERSION是在哪里设置的，直接Google一把。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef STP_NO_VERREL_CHECK
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* release =&lt;span&gt; UTS_RELEASE;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    #ifdef STAPCONF_GENERATED_COMPILE
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* version =&lt;span&gt; UTS_VERSION;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    might_sleep();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (strcmp (release, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.10.0-693.2.2.el7.x86_64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       _stp_error (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;module release mismatch (%s vs %s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, release, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.10.0-693.2.2.el7.x86_64&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       rc = -&lt;span&gt;EINVAL;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    #ifdef STAPCONF_GENERATED_COMPILE
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (strcmp (utsname()-&amp;gt;&lt;span&gt;version, version)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       _stp_error (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;module version mismatch (%s vs %s), release %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, version, utsname()-&amp;gt;&lt;span&gt;version, release);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;       rc = -&lt;span&gt;EINVAL;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有两篇文章里面提到了同样的坑，文章连接在底部的参考中。在kernel-devel包的所以文件中搜以下变量UTS_VERSION，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# rpm -ql kernel-devel |&lt;span&gt; xargs grep UTS_VERSION
&lt;/span&gt;/usr/src/kernels/&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.el7.x86_64/include/generated/compile.h:&lt;span&gt;#define&lt;/span&gt; UTS_VERSION &quot;#1 SMP Tue Sep 12 10:10:26 CDT 2017&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到在compile.h中有&lt;span&gt;#define UTS_VERSION &quot;#1 SMP Tue Sep 12 10:10:26 CDT 2017&quot;. &lt;span&gt;这个是不是很熟悉... 对比下上面运行stap的报错信息, module mismatch的时间就是这个。文件compile.h是自动生成的，可能和当时编译时的时间相关。但是stap要求这个也和当前系统uname -a里面的时间完全一直，如果下个CentOS原生的kernel-devel应该就没这个问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解决问题的另一个简单方法就是直接修改这个compile.h文件，原来的文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# cat /usr/src/kernels/&lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.el7.x86_64/include/generated/&lt;span&gt;compile.h
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This file is auto generated, version 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; SMP &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; UTS_MACHINE &quot;x86_64&quot;
&lt;span&gt;#define&lt;/span&gt; UTS_VERSION &quot;#1 SMP Tue Sep 12 10:10:26 CDT 2017&quot;
&lt;span&gt;#define&lt;/span&gt; LINUX_COMPILE_BY &quot;mockbuild&quot;
&lt;span&gt;#define&lt;/span&gt; LINUX_COMPILE_HOST &quot;sl7-uefisign.fnal.gov&quot;
&lt;span&gt;#define&lt;/span&gt; LINUX_COMPILER &quot;gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC) &quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改define UTS_VERSION那一行，如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;#define UTS_VERSION &quot;#1 SMP Tue Sep 12 10:10:26 CDT 2017&quot; -&amp;gt; #define UTS_VERSION &quot;#1 SMP Tue Sep 12 22:26:13 UTC 2017&quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再次运行stap:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
# stap -e &lt;span&gt;'&lt;/span&gt;&lt;span&gt;probe begin{printf(&quot;Hello, World&quot;); exit();}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -&lt;span&gt;v
Pass &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;: parsed user script and &lt;span&gt;470&lt;/span&gt; library scripts &lt;span&gt;using&lt;/span&gt; 228220virt/41276res/3348shr/38016data kb, &lt;span&gt;in&lt;/span&gt; 350usr/10sys/&lt;span&gt;355real ms.
Pass &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: analyzed script: &lt;span&gt;1&lt;/span&gt; probe, &lt;span&gt;1&lt;/span&gt; function, &lt;span&gt;0&lt;/span&gt; embeds, &lt;span&gt;0&lt;/span&gt; globals &lt;span&gt;using&lt;/span&gt; 229144virt/42328res/3536shr/38940data kb, &lt;span&gt;in&lt;/span&gt; 0usr/0sys/&lt;span&gt;6real ms.
&lt;span&gt;Pass &lt;/span&gt;&lt;/span&gt;&lt;span&gt;3: using cached /root/.systemtap/cache/0b/stap_0bc9e27aef7a1de50ea41889a27fc524_1010.c
Pass 4: using cached /root/.systemtap/cache/0b/&lt;/span&gt;&lt;span&gt;&lt;span&gt;stap_0bc9e27aef7a1de50ea41889a27fc524_1010.ko&lt;/span&gt;
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;: starting run.
ERROR: module version mismatch (#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; SMP Tue Sep &lt;span&gt;12&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; CDT &lt;span&gt;2017&lt;/span&gt; vs #&lt;span&gt;1&lt;/span&gt; SMP Tue Sep &lt;span&gt;12&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt; UTC &lt;span&gt;2017&lt;/span&gt;), release &lt;span&gt;3.10&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;693.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.el7.x86_64
WARNING: &lt;/span&gt;/usr/bin/staprun exited with status: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;: run completed &lt;span&gt;in&lt;/span&gt; 0usr/10sys/&lt;span&gt;38real ms.
Pass &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;: run failed.  [man error::pass5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为中间生成的C文件和ko模块都是用的cache (蓝色标注的部分)，我们把上面的cache文件删除，再重新运行，这次可以成功了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# stap -e &lt;span&gt;'&lt;/span&gt;&lt;span&gt;probe begin{printf(&quot;Hello, World&quot;); exit();}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Hello, World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://sourceware.org/systemtap/SystemTap_Beginners_Guide/using-systemtap.html#using-setup&quot; target=&quot;_blank&quot;&gt;https://sourceware.org/systemtap/SystemTap_Beginners_Guide/using-systemtap.html#using-setup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yunlianglinfeng/article/details/77732285&quot; target=&quot;_blank&quot;&gt;ERROR: module version mismatch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://groups.google.com/forum/#!topic/openresty/nlEc3qlDyOc&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!topic/openresty/nlEc3qlDyOc&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Jul 2018 16:51:00 +0000</pubDate>
<dc:creator>wipan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wipan/p/9333623.html</dc:identifier>
</item>
<item>
<title>golang基础--Gocurrency并发 - failymao</title>
<link>http://www.cnblogs.com/failymao/p/9333592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/failymao/p/9333592.html</guid>
<description>Channel
&lt;ul&gt;&lt;li&gt;Channel是goroutine沟通的桥梁，大都是阻塞同步的&lt;/li&gt;
&lt;li&gt;通过make创建，close关闭（当程序简单时，回自动关闭）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import (
    &quot;fmt&quot;
)

func main() {                 //主程序
    c := make(chan bool)      //初始化一个chan类型
    go func() {               //子程序
        fmt.Println(&quot;123...&quot;) //执行主程序
        c &amp;lt;- true             //通过&amp;lt;-存入bool类型到chan中
    }()
fmt.Println(1)                //程序执行步骤：1st
read_chan := &amp;lt;-c              //&amp;lt;-c 从chan中读取bool，程序执行步骤：2nd
fmt.Println(read_chan)       //程序执行步骤：3rd
}

/*output
1st     1           
2nd     123...
3rd     true
*/&lt;/code&gt;
&lt;/pre&gt;&lt;p&gt;注意以上程序的执行顺序(channel无缓存时)：先执行读取操作&lt;code&gt;c&amp;lt;-c&lt;/code&gt;，因为channel中没有值，所以程序发生阻塞，此时执行chanel&lt;code&gt;写操作&lt;/code&gt;，然后再执行读操作。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import (
    &quot;fmt&quot;
)

func main() {
    c := make(chan bool)      //初始化一个chan类型
    go func() {               //go结合匿名函数，构造并发
        fmt.Println(&quot;123...&quot;) //执行主程序
        c &amp;lt;- true             //通过&amp;lt;-存入bool类型到chan中
        close(c)              //关闭通道:必须明确在哪个地方关闭
    }()

    for v := range c {       //for循环chanel
    }
}

/*output
    123...
    true
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以设置单向(读&amp;amp;写)或双向通道--默认是双向通道&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可以设置缓存大小（默认为0，阻塞），在未被填充前不会发生阻塞（异步），比如缓存20个，可以同时进行20个读操作或者写操作，注意&lt;code&gt;读的操作先于写的操作&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import (
    &quot;fmt&quot;
)

func main() { //主程序
    c := make(chan bool, 1)   //初始化一个chan类型,缓存为2
    go func() {               //子程序
        fmt.Println(&quot;123...&quot;) //执行主程序，执行步骤：2
        c &amp;lt;- true             //写操作，执行步骤：2
    }()
    fmt.Println(2)            //执行步骤：1
    fmt.Println(123, &amp;lt;-c)     //读操作，执行步骤：2
    fmt.Println(3)            //执行步骤：3
}

/*output
1   2
2   123...
2   123 true
3   3
    */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置缓存后，程序为异步，读，写操作同时完成，当读取channal中无数据时，也不会造成堵塞，因为与此同时，写操作也将发生。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Jul 2018 16:33:00 +0000</pubDate>
<dc:creator>failymao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/failymao/p/9333592.html</dc:identifier>
</item>
<item>
<title>【ASp.Net Mvc Core 2 + angular6实战】 - 1. 环境搭建 - 星辰未来</title>
<link>http://www.cnblogs.com/chenxincoder/p/9333074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxincoder/p/9333074.html</guid>
<description>&lt;h2&gt; 为什么打算写这些文章？&lt;/h2&gt;
&lt;p&gt;没有为什么，只是为了学习Angular和更了解.Net Core等技术&lt;/p&gt;
&lt;h2&gt;需要用到的技术？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;后端使用.Net Core 2.1 + EF Core 2.1 + Mysql 5.7 + Identity （不知道Identity算不算一个独立的技术点）&lt;/li&gt;
&lt;li&gt;前端主要使用的是Angular 6.x + Ant （出自阿里巴巴的一套angular开源组件库）&lt;a title=&quot;ANT官网&quot; href=&quot;https://ng.ant.design/docs/introduce/zh&quot; target=&quot;_blank&quot;&gt;https://ng.ant.design/docs/introduce/zh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;大纲&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;开发环境搭建&lt;/li&gt;
&lt;li&gt;Angular的使用姿势&lt;/li&gt;
&lt;li&gt;ANT的使用姿势&lt;/li&gt;
&lt;li&gt;.Net Core + EFCore + Mysql的使用姿势&lt;/li&gt;
&lt;li&gt;Identity的使用姿势&lt;/li&gt;
&lt;li&gt;系统发布（Windows和Ubuntu的服务器环境配置，包括Https环境的配置）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上大纲只是暂时性的，写的过程中会随时调整，以实际发布文章为主&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;h2&gt;开发环境的搭建&lt;/h2&gt;
&lt;p&gt;　　我记得我当年刚出来找工作的时候，整个前端圈子都流行JQuery，基本前端开发=JQuery+一堆插件，伴随而生的也有一堆的UI库（easy UI，bootstrap。。。等的）。&lt;/p&gt;
&lt;p&gt;　　如今才四五年过去，JQuery在不面向搜索引擎的网站中，基本上很难看到身影了（老旧的系统除外），新的各种BS软件基本选择都是Vue Angular React这三个框架了（统称前端三巨头）。前端的开发方式也发生了翻天覆地的变化，从引入一个Script就开始操作dom写逻辑的方式，变成了先安装NodejS，然后开始引入各种npm包啊，啥构建工具啊，然后再开始编码，再然后发布的时候，还要编译一下。。。，刚开始我也觉得这种方式特别麻烦。就感觉脱了裤子放屁一样。&lt;/p&gt;
&lt;p&gt;　　但是没办法，大趋势就是这样。面对变化，我们只能去拥抱，去适应。真正了解过一段时间之后，才发现这么做确实是有道理的。个人感觉这是前端工程化的一个体现。JavaScript从脚本进化成为了真正的编程语言。（当然今天的猪脚不是JavaScript，而是它的超集TypeScript）&lt;/p&gt;
&lt;h2&gt;1.安装NodeJS&lt;/h2&gt;
&lt;p&gt;NodeJs的安装方式非常简单。https://nodejs.org/en/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718220616417-1947916346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载LTS版本的安装包，一路Next就好了。&lt;/p&gt;
&lt;p&gt;安装好了，在命令行里面查看一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718220810268-344906264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认这样，应该没问题，也许你们的版本号和我不一样。我这个是之前安装的，和最新版是有小差别，但是完全不影响使用&lt;/p&gt;
&lt;h2&gt; 2.安装Angular的包&lt;/h2&gt;
&lt;h3&gt;2.1.首先全局安装Angular&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -g @angular/cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;　　Angular官网要求Angular6.0必须在node &lt;code&gt;8.x&lt;/code&gt; 和 npm &lt;code&gt;5.x&lt;/code&gt; 以上的版本才能正常使用，更低的版本也许会出现N多问题。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　　安装成功后，在命令行上运行 &lt;strong&gt;ng -v&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718221311448-879017134.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果出现这个东东，那么说明你成功的安装了Angular的最新版&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　如果没有出现这个东东，那么先重启一下电脑。然后再看，还是不行的话，可以跳转到第一步，连续重试三次，还是有问题，麻烦出门右转Angular官网 &lt;a title=&quot;Angular官网&quot; href=&quot;https://angular.cn/guide/quickstart&quot; target=&quot;_blank&quot;&gt;https://angular.cn/guide/quickstart&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;2.2 创建一个Angular项目，并运行起来&lt;/h3&gt;
&lt;p&gt;　　随便选择一个电脑里面，你喜欢目录（&lt;strong&gt;多次实践，千万不要选择非英文的路径，连C#也不行，必须纯英文路径，不然会有莫名错误&lt;/strong&gt;），执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng &lt;span&gt;new&lt;/span&gt; testapp  //testapp可以自己写你喜欢的名字，就是你的项目名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输入angular创建目录的命令后，按回车键，angular-cli会自动创建一个angular的模板，只需要一首歌的时间可以创建完成&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718222224492-109941705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果是这样的话，那么说明创建成功了，进入testapp的目录 ，执行&lt;strong&gt;npm start&lt;/strong&gt; ,然后这次估计要好几首歌的时间才能运行起来了。。。（看你的网速决定。。。如果实在是不行，可以把Npm的数据源切换到淘宝的源上去，但是请千万不要使用cnpm来替换npm，因为也会遇到莫名且搞不定的问题。。）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718223608326-35139921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;　　启动成功后，在浏览器界面输入 http://localhost:4200就可以看到Angular的默认界面了&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718223645798-864742652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到这里之后，说明Angular已经安装成功了&lt;/p&gt;
&lt;h3&gt;　　2.3 安装ANT 组件库&lt;/h3&gt;
&lt;p&gt; 　　在新版的NG cli里面提供了一个贼好用的命令 ng add 。。。。&lt;/p&gt;
&lt;p&gt;　　恰好ant官方紧跟着就支持了。我们可以很方便的使用&lt;span class=&quot;token function&quot;&gt;&lt;strong&gt;ng add&lt;/strong&gt; &lt;span class=&quot;token function&quot;&gt;&lt;strong&gt;ng-zorro-antd&lt;/strong&gt; &lt;span class=&quot;token punctuation&quot;&gt;[options&lt;span class=&quot;token punctuation&quot;&gt;] 命令把ANT组件库添加到我们新建的angular项目中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;token function&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718232644062-246938680.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果没有报错的话，那就npm install &lt;strong&gt;ng-zorro-antd&lt;/strong&gt;一下 ,我公司电脑就不用走这一步，但是家里电脑需要走这一步，不然就报错，不知道为啥，如果有知道的大佬可以指点一下&lt;/p&gt;
&lt;p&gt;　　再次访问localhost:4200 ,当当当当。。。就会看到下边的这个图标，那么说明你的ant安装好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718232926211-1555013438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　3.创建asp.Net Mvc Core  的项目&lt;/h2&gt;
&lt;p&gt;　　　　记得升级你们的猥琐死丢丢到最新版。。。不然Angular模板创建出来默认是4.x，是webpack的的模板，难用的一批。。。升级到最新版就是angular-cli的工程模板了。&lt;/p&gt;
&lt;h3&gt;　　3.1 创建工程&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718233325012-1868524709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后点击确定。。。&lt;/p&gt;
&lt;h3&gt;　　3.2 点击运行&lt;/h3&gt;
&lt;p&gt;　　第一次运行的时候，大家可以先泡一杯茶，然后打开抖音（此处广告五毛），然后使劲的嗨一会儿。再回来估计都还没运行起来。原因很简单，第一次运行的时候，会下载默认工程里面的angular所引用的包，贼慢。。&lt;/p&gt;
&lt;p&gt;　　等待了一阵之后，浏览器突然弹出来一个页面&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718233832378-1235808799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说明我们的.Net Core + Angular5.x的项目就搭建好了。。。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　看到这里，某些细心的园友可能会觉得很无语。后面直接用猥琐死丢丢创建项目就好了，为毛前面要折腾那么多没卵用的东西？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　因为Angular自带的模板是Angular5.x，但是最新的angular已经6.x了，5升级到6，不是那么简单。因为其中涉及到Rxjs的升级，还有angular的本身的一些API的升级，所以我打算把自己揣摩的方式告诉大家，当然大家也可以参照官方的升级文档进行升级 &lt;a title=&quot;https://update.angular.io，&quot; href=&quot;https://update.angular.io%EF%BC%8C/&quot; target=&quot;_blank&quot;&gt;https://update.angular.io&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;　　3.3 如何简单粗暴的升级Angular5.x到6.x&lt;/h3&gt;
&lt;p&gt;　　我刚开始学习的时候，先按照官方升级的指南升级的，爬了一堆坑，最后还是没搞定。最后用两个词搞定了 ‘复制’-&amp;gt;‘粘贴’&lt;/p&gt;
&lt;h4&gt;　　　　3.3.1 复制我们前面创建的ng+ant的前端工程文件&lt;/h4&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718234639133-1874851592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　3.3.2 直接删除掉.Net Core下的ClientApp下的全部文件&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180718234733629-413992432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　就这一堆东西，然后粘贴前端的工程文件到这里，&lt;/p&gt;
&lt;p&gt;　　　　再然后就点击运行，会成功看到之前运行成的Ant的界面，&lt;/p&gt;
&lt;p&gt;　　　　这样我们就成功把默认项目的5.x升级到6.x了&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　　　到这里呢，就算是已经搭建好了asp.net core mvc+angular6.x的开发环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;　　但是呢，本篇文章还没有结束，我打算分享一些我个人开发SPA项目的一些小经验（也或者说是小技巧）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 写angular的程序，尽量使用vscode，猥琐死丢丢写TypeScript的体验真的比不上vscode（个人感觉）&lt;/li&gt;
&lt;li&gt;在后台运行一个ps1界面，使用npm start 增量编译Angular,可以不用每次修改后，都等一首歌的时间才能看到效果&lt;/li&gt;
&lt;li&gt;开发环境下，使用UseProxyToSpaDevelopmentServer(&quot;http://localhost:4200&quot;);替换UseAngularCliServer(npmScript: &quot;start&quot;);，这样可以极大提高工作效率。&lt;img src=&quot;https://images2018.cnblogs.com/blog/726978/201807/726978-20180719000027476-917198776.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;如果有愿意一起交流的大佬，可以加我们的qq群：80669150 ,可吹水，可斗图，可学习&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 18 Jul 2018 16:30:00 +0000</pubDate>
<dc:creator>星辰未来</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxincoder/p/9333074.html</dc:identifier>
</item>
<item>
<title>大疆2018年机器视觉/图像相关岗位的招聘要求 - youngzn</title>
<link>http://www.cnblogs.com/youngzn/p/9333522.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youngzn/p/9333522.html</guid>
<description>&lt;p&gt;&lt;span&gt;大疆2018年7月发布在官网上的岗位，链接：&lt;a href=&quot;https://we.dji.com/zh-CN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://we.dji.com/zh-CN&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;大疆的技术分享会时间：3月下旬到6月上旬，宣讲路线是：广州，武汉，北京，哈尔滨，西安，南京，上海，合肥，成都。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;校园招聘宣讲时间：5月30到6月10日，宣讲地点是：东南，南航，&lt;span&gt;哈深&lt;/span&gt;，华科，成电，北航，北理，清华，西北工业，西安交通，华理，哈工大。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;招聘流程（秋招-研二暑假）：5月30日至6月30日简历投递（线上），6月低初筛，7月初技术笔试（线上），7月下旬面试（远程+现场），9月中旬前出最终录取结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;大疆2018年机器视觉/图像相关岗位的招聘要求如下：（2018年7月18日前官网已发布的）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;机器视觉/深度学习算法工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作职责&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;1. 负责深度学习、计算机视觉相关算法、软件方面的研发；&lt;/p&gt;
&lt;p&gt;2. 与FPGA/ASIC工程师配合，实现深度学习，计算机视觉相关算法的高性能实现。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;任职要求&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;29.5&quot;&gt;
&lt;p&gt;1. 电子工程，计算机，人工智能等专业硕士以上学历；&lt;/p&gt;
&lt;p&gt;2. 精通C/C++, Python编程语言和工具，熟悉Caffe，Tensorflow等平台；&lt;/p&gt;
&lt;p&gt;3. 对相关算法的产品化，工程化兴趣浓厚；&lt;/p&gt;
&lt;p&gt;4. 了解FPGA或ASIC设计，有算法定点化设计经验者优先；&lt;/p&gt;
&lt;p&gt;5. 强烈的责任心，创新意识，逻辑思维及学习能力。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;机器视觉算法工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作职责&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;1. 为机器视觉核心功能（匹配定位、测量、图像检测、分类、条码识别等）设计、开发工业级的高效、鲁棒图像算法；&lt;/p&gt;
&lt;p&gt;2. 在PC平台设计、开发算法，与嵌入式软件工程师合作，在嵌入式处理平台对算法进行移植；&lt;/p&gt;
&lt;p&gt;3. 指导视觉应用工程师解决产线具体需求，保证所开发的算法模块在产线的部署效果，为开发模块的正确性、效率和稳定性负责。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;任职要求&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;32.5&quot;&gt;
&lt;p&gt;1. 硕士及以上学历；&lt;/p&gt;
&lt;p&gt;2. 具有扎实的图像处理基本功。能够独立高效实现图像处理与计算机视觉的典型底层算法；&lt;/p&gt;
&lt;p&gt;3. 熟练掌握机器学习的典型方法；理解典型分类器的方法与使用特点；有深度神经网络设计与实践经验优先；&lt;/p&gt;
&lt;p&gt;4. 对计算机体系与结构有一定了解，能够针对处理器的特点优化算法设计；&lt;/p&gt;
&lt;p&gt;5. 了解3D成像原理与相关算法优先。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;机器学习算法工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作职责&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;1. 负责研发机器学习、模式识别、深度学习算法开发；&lt;/p&gt;
&lt;p&gt;2. 负责研发基于图像/点云/雷达的物体检测、运动估计以及语义分割算法；&lt;/p&gt;
&lt;p&gt;3. 负责开发多传感器融合的三维环境感知算法；&lt;/p&gt;
&lt;p&gt;4. 负责与嵌入式深度学习算法工程师协作，针对产品平台进行算法优化。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;任职要求&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;1. 计算机科学、信息工程、电子工程、机器人学等专业硕士及以上学历，有C++/Python开发经验；&lt;/p&gt;
&lt;p&gt;2. 在模式识别、机器学习、深度学习、机器人学等领域有深入认识，并了解各个算法的条件和瓶颈；&lt;/p&gt;
&lt;p&gt;3. 具有点云数据处理、立体视觉、多视图几何、多传感器融合等科研或开发经验者优先；&lt;/p&gt;
&lt;p&gt;4. 具有物体识别、物体检测、目标跟踪、语义分割、人脸识别等科研或开发经验者优先；&lt;/p&gt;
&lt;p&gt;5. 在相关领域主流会议或期刊发表过论文 (CVPR/ICCV/ECCV/NIPS/ICML/ICLR/IROS/ICRA)者优先；&lt;/p&gt;
&lt;p&gt;6. 具有良好的沟通和写作能力&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图像/视觉算法工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作职责&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;1. 开发及优化用于视觉标定和定位、重建的图像处理算法；&lt;/p&gt;
&lt;p&gt;2. 针对不同平台的特点，对算法进行深入优化；&lt;/p&gt;
&lt;p&gt;3. 负责维护相关的核心软件算法模块；&lt;/p&gt;
&lt;p&gt;4. 支持相关项目的视觉标定、定位任务。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;任职要求&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;30&quot;&gt;
&lt;p&gt;1. 硕士及以上学历；&lt;/p&gt;
&lt;p&gt;2. 熟练掌握Windows和Linux环境下的C/C++编程；&lt;/p&gt;
&lt;p&gt;3. 熟悉图像处理和计算机视觉；&lt;/p&gt;
&lt;p&gt;4. 熟悉OpenCV、ceres solver等开源软件包。&lt;/p&gt;
&lt;p&gt;加分项：&lt;/p&gt;
&lt;p&gt;1. 熟悉ARM/DSP平台优化；&lt;/p&gt;
&lt;p&gt;2. 了解或使用过一种嵌入式系统硬件架构和嵌入式操作系统。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图像处理算法工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作职责&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;1. 参与图像处理算法原型设计、功能开发；&lt;/p&gt;
&lt;p&gt;2. 参与算法集成/加速/硬化；&lt;/p&gt;
&lt;p&gt;3. 参与算法产品化流程。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;任职要求&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;28&quot;&gt;
&lt;p&gt;1. 硕士及以上学历，电子、通信、信号处理相关专业；&lt;/p&gt;
&lt;p&gt;2. 具有1年以上ISP算法IP设计经验/3A算法设计/集成/调优经验；&lt;/p&gt;
&lt;p&gt;3. 熟悉传统ISP链路，了解sensor矫正、去马赛克、色彩矫正、各类去噪、锐化、增强算法；&lt;/p&gt;
&lt;p&gt;4. 或具有1年以上后处理（图像增强/融合/分割/深度提取/目标检测识别）算法设计/优化经验；&lt;/p&gt;
&lt;p&gt;5. 精通C/C++语言编程，精通数据结构，具有良好的编程习惯；&lt;/p&gt;
&lt;p&gt;6. 具备嵌入式开发能力者优先。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;图像算法优化工程师&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;工作职责&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;1. 与算法工程师对接，负责算法集成方案的设计和系统评估；&lt;/p&gt;
&lt;p&gt;2. 负责各类算法的DSP/GPU等平台性能优化。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;任职要求&lt;/p&gt;
&lt;div class=&quot;normal&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;1. 硕士及以上学历，电子、通信、信号处理相关专业；&lt;/p&gt;
&lt;p&gt;2. 具备一年以上各类图像算法优化经验；&lt;/p&gt;
&lt;p&gt;3. 熟练掌握算法优化技巧，精通ARM NEON优化、或DSP架构/优化、或GPU加速/OpenGL/OpenCL编程；&lt;/p&gt;
&lt;p&gt;4. 熟练掌握嵌入式系统相关知识，具备各类系统设计和评估（内存、带宽、计算效率、延迟等）能力。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Wed, 18 Jul 2018 16:15:00 +0000</pubDate>
<dc:creator>youngzn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youngzn/p/9333522.html</dc:identifier>
</item>
<item>
<title>yarn的介绍 - Bazinga32</title>
<link>http://www.cnblogs.com/hongtenglong/p/9333468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongtenglong/p/9333468.html</guid>
<description>&lt;p&gt;&lt;span&gt;首先我们先了解一下hadoop1.0版本和hadoop2.0版本的区别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在hadoop1.0中只有两个模块 hdfs  和  mapReduce&lt;/p&gt;
&lt;p&gt;　　hdfs负责存储&lt;/p&gt;
&lt;p&gt;　　mapReduce 负责计算&lt;/p&gt;

&lt;p&gt;在hadoop1.0中 所有计算相关的 全部放到了mapReduce上&lt;/p&gt;
&lt;p&gt;　　　　mapReduce在运行的时候有两个进程 jobtracker 和 tasktracker&lt;/p&gt;
&lt;p&gt;　　　　　　jobtracker：是整个计算程序的主节点（老大）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　  负责进行资源调度（没有资源调度策略，随机调度）&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　  还负责监控程序运行的状态，对运行失败的应用程序进行重启&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　  存在单点故障问题，不支持高可用，如果jobtracker宕机了，整个程序就运行不了了&lt;/p&gt;
&lt;p&gt;　　　　　　tasktracker：负责计算程序的执行&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　会强行的将计算资源分成两部分  mapslot 和 reduceslot， map任务&lt;span&gt;只能&lt;/span&gt;运行在mapslot中，reduce任务&lt;span&gt;只能&lt;/span&gt;运行在reduceslot中，当一个应用程序只需要运行map任务&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　不需要运行reduce任务的时候，就会造成资源浪费。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　而且这一部分资源没有划分CPU、IO或者网络&lt;/p&gt;
&lt;p&gt;所以hadoop1.0中存在着致命的缺陷&lt;/p&gt;
&lt;p&gt;　　1）单点故障问题&lt;/p&gt;
&lt;p&gt;　　2）所有的资源调度是随机的，会造成资源浪费&lt;/p&gt;
&lt;p&gt;　　3）jobtracker的运行压力过大&lt;/p&gt;



&lt;p&gt;hadoop2.0进行了改进，将maperduce分成了两部分mapreduce和yarn&lt;/p&gt;
&lt;p&gt;　　yarn专门负责程序的资源调度&lt;/p&gt;
&lt;p&gt;　　yarn的概念：&lt;/p&gt;
&lt;p&gt;　　　　yarn再启动的时候会有两个进程&lt;/p&gt;
&lt;p&gt;　　　　　　resourcemanager：整个资源调度的老大&lt;/p&gt;
&lt;p&gt;　　　　　　　　1）负责接收客户端的请求 这个请求时程序运行的请求&lt;/p&gt;
&lt;p&gt;　　　　　　　　2）接受nodemanager的状态报告，这个状态报告包括nodenamager的资源状态和存活状态&lt;/p&gt;
&lt;p&gt;　　　　　　　　3）负责整个计算程序的资源调度   调度的运行资源的多少 和  在哪个节点上运行&lt;/p&gt;
&lt;p&gt;　　　　　　nodemanager：负责真正的提供资源  运行计算程序&lt;/p&gt;
&lt;p&gt;　　　　　　　　1）接收resourcemanager的命令&lt;/p&gt;
&lt;p&gt;　　　　　　　　2）提供资源运行计算程序&lt;/p&gt;

&lt;p&gt;　　yarn启动计算及资源调度概念：&lt;br/&gt;　　　　MRAppMaster:单个计算程序的老大   负责帮助当前计算程序向resourcemanager申请资源，&lt;br/&gt;　　　　　　　　　　  负责启动maptask任务和reducetask任务 负责监控maptask和reducetask的运行进度&lt;br/&gt;　　　　　　　　　　  类似于项目经理&lt;/p&gt;
&lt;p&gt;　　　　ASM:applicationsmanager 所有应用程序的管理者  负责调度应用程序&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　container：抽象资源容器 封装着一定的cpu io 和网络等资源&lt;/p&gt;
&lt;p&gt;　　　　是运行maptask reducetask等的运行资源单位&lt;/p&gt;
&lt;p&gt;　　　　1个split对应一个1个maptask  1个maptask分配1个container     1个container在进程中显示的就是1个yarnchild&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　scheduler:调度器  调度的是什么时候执行哪个计算程序&lt;br/&gt;　　　　　　调度器：&lt;br/&gt;　　　　　　　　1）FIFO:first in first out 先进先出&lt;br/&gt;　　　　　　　　先提交的程序先执行 后提交的程序后执行&lt;br/&gt;　　　　　　　　内部维护一个队列&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　　　　　2）FAIR：公平调度器：&lt;/p&gt;
&lt;p&gt;　　　　　　　　大家平分资源运行&lt;/p&gt;
&lt;p&gt;　　　　　　　　假设刚开始只有一个任务 占资源100%&lt;/p&gt;
&lt;p&gt;　　　　　　　　这时候又来了一个任务 每人占50%&lt;/p&gt;
&lt;p&gt;　　　　　　　　内部维护一个队列&lt;/p&gt;

&lt;p&gt;　　　　　　　　3）CAPICITY：计算能力调度器：&lt;/p&gt;
&lt;p&gt;　　　　　　　　可以按需进行配置使用资源：&lt;/p&gt;
&lt;p&gt;　　　　　　　　内部可以维护多个队列，多个队列之间可以进行资源分配&lt;/p&gt;
&lt;p&gt;　　　　　　　　在每个队列中都是执行先进先出的&lt;/p&gt;

</description>
<pubDate>Wed, 18 Jul 2018 16:05:00 +0000</pubDate>
<dc:creator>Bazinga32</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongtenglong/p/9333468.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——HttpClientFactory - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9333042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9333042.html</guid>
<description>&lt;p&gt;当需要向某特定URL地址发送HTTP请求并得到相应响应时，通常会用到HttpClient类。该类包含了众多有用的方法，可以满足绝大多数的需求。但是如果对其使用不当时，可能会出现意想不到的事情。&lt;/p&gt;
&lt;p&gt;博客园官方团队就遇上过这样的&lt;a href=&quot;https://www.cnblogs.com/dudu/p/csharp-httpclient-attention.html&quot;&gt;问题&lt;/a&gt;，国外博主也记录过类似的情况，&lt;a href=&quot;https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/&quot;&gt;YOU'RE USING HTTPCLIENT WRONG AND IT IS DESTABILIZING YOUR SOFTWARE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;究其缘由是一句看似正确的代码引起的：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using(var client = new HttpClient())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象所占用资源应该确保及时被释放掉，但是，对于网络连接而言，这是错误的。&lt;/p&gt;
&lt;p&gt;原因有二，网络连接是需要耗费一定时间的，频繁开启与关闭连接，性能会受影响；再者，开启网络连接时会占用底层socket资源，但在HttpClient调用其本身的Dispose方法时，并不能立刻释放该资源，这意味着你的程序可能会因为耗尽连接资源而产生预期之外的异常。&lt;/p&gt;
&lt;p&gt;所以比较好的解决方法是延长HttpClient对象的使用寿命，比如对其建一个静态的对象：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static HttpClient Client = new HttpClient();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但从程序员的角度来看，这样的代码或许不够优雅。&lt;/p&gt;
&lt;p&gt;所以在.NET Core 2.1中引入了新的HttpClientFactory类。&lt;/p&gt;
&lt;p&gt;它的用法很简单，首先是对其进行IoC的注册：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddHttpClient();
    services.AddMvc();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过IHttpClientFactory创建一个HttpClient对象，之后的操作如旧，但不需要担心其内部资源的释放：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyController : Controller
{
    IHttpClientFactory _httpClientFactory;

    public MyController(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory = httpClientFactory;
    }

    public IActionResult Index()
    {
        var client = _httpClientFactory.CreateClient();
        var result = client.GetStringAsync(&quot;http://myurl/&quot;);
        return View();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一眼瞧去，可能不明白AddHttpClient方法与IHttpClientFactory有什么关系，但查到其源码后就能一目了然：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IServiceCollection AddHttpClient(this IServiceCollection services)
{
    if (services == null)
    {
        throw new ArgumentNullException(nameof(services));
    }

    services.AddLogging();
    services.AddOptions();

    //
    // Core abstractions
    //
    services.TryAddTransient&amp;lt;HttpMessageHandlerBuilder, DefaultHttpMessageHandlerBuilder&amp;gt;();
    services.TryAddSingleton&amp;lt;IHttpClientFactory, DefaultHttpClientFactory&amp;gt;();

    //
    // Typed Clients
    //
    services.TryAdd(ServiceDescriptor.Singleton(typeof(ITypedHttpClientFactory&amp;lt;&amp;gt;), typeof(DefaultTypedHttpClientFactory&amp;lt;&amp;gt;)));

    //
    // Misc infrastructure
    //
    services.TryAddEnumerable(ServiceDescriptor.Singleton&amp;lt;IHttpMessageHandlerBuilderFilter, LoggingHttpMessageHandlerBuilderFilter&amp;gt;());

    return services;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的内部为IHttpClientFactory接口绑定了DefaultHttpClientFactory类。&lt;/p&gt;
&lt;p&gt;再看IHttpClientFactory接口中关键的CreateClient方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public HttpClient CreateClient(string name)
{
    if (name == null)
    {
        throw new ArgumentNullException(nameof(name));
    }

    var entry = _activeHandlers.GetOrAdd(name, _entryFactory).Value;
    var client = new HttpClient(entry.Handler, disposeHandler: false);

    StartHandlerEntryTimer(entry);

    var options = _optionsMonitor.Get(name);
    for (var i = 0; i &amp;lt; options.HttpClientActions.Count; i++)
    {
        options.HttpClientActions[i](client);
    }

    return client;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HttpClient的创建不再是简单的new HttpClient()，而是传入了两个参数：HttpMessageHandler handler与bool disposeHandler。disposeHandler参数为false值时表示要重用内部的handler对象。handler参数则从上一句的代码可以看出是以name为键值从一字典中取出，又因为DefaultHttpClientFactory类是通过TryAddSingleton方法注册的，也就意味着其为单例，那么这个内部字典便是唯一的，每个键值对应的ActiveHandlerTrackingEntry对象也是唯一，该对象内部中包含着handler。&lt;/p&gt;
&lt;p&gt;下一句代码&lt;code&gt;StartHandlerEntryTimer(entry);&lt;/code&gt; 开启了ActiveHandlerTrackingEntry对象的过期计时处理。默认过期时间是2分钟。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal void ExpiryTimer_Tick(object state)
{
    var active = (ActiveHandlerTrackingEntry)state;

    // The timer callback should be the only one removing from the active collection. If we can't find
    // our entry in the collection, then this is a bug.
    var removed = _activeHandlers.TryRemove(active.Name, out var found);
    Debug.Assert(removed, &quot;Entry not found. We should always be able to remove the entry&quot;);
    Debug.Assert(object.ReferenceEquals(active, found.Value), &quot;Different entry found. The entry should not have been replaced&quot;);

    // At this point the handler is no longer 'active' and will not be handed out to any new clients.
    // However we haven't dropped our strong reference to the handler, so we can't yet determine if
    // there are still any other outstanding references (we know there is at least one).
    //
    // We use a different state object to track expired handlers. This allows any other thread that acquired
    // the 'active' entry to use it without safety problems.
    var expired = new ExpiredHandlerTrackingEntry(active);
    _expiredHandlers.Enqueue(expired);

    Log.HandlerExpired(_logger, active.Name, active.Lifetime);

    StartCleanupTimer();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先是将ActiveHandlerTrackingEntry对象传入新的ExpiredHandlerTrackingEntry对象。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ExpiredHandlerTrackingEntry(ActiveHandlerTrackingEntry other)
{
    Name = other.Name;

    _livenessTracker = new WeakReference(other.Handler);
    InnerHandler = other.Handler.InnerHandler;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在其构造方法内部，handler对象通过弱引用方式关联着，不会影响其被GC释放。&lt;/p&gt;
&lt;p&gt;然后新建的ExpiredHandlerTrackingEntry对象被放入专用的队列。&lt;/p&gt;
&lt;p&gt;最后开始清理工作，定时器的时间间隔设定为每10秒一次。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal void CleanupTimer_Tick(object state)
{
    // Stop any pending timers, we'll restart the timer if there's anything left to process after cleanup.
    //
    // With the scheme we're using it's possible we could end up with some redundant cleanup operations.
    // This is expected and fine.
    // 
    // An alternative would be to take a lock during the whole cleanup process. This isn't ideal because it
    // would result in threads executing ExpiryTimer_Tick as they would need to block on cleanup to figure out
    // whether we need to start the timer.
    StopCleanupTimer();

    try
    {
        if (!Monitor.TryEnter(_cleanupActiveLock))
        {
            // We don't want to run a concurrent cleanup cycle. This can happen if the cleanup cycle takes
            // a long time for some reason. Since we're running user code inside Dispose, it's definitely
            // possible.
            //
            // If we end up in that position, just make sure the timer gets started again. It should be cheap
            // to run a 'no-op' cleanup.
            StartCleanupTimer();
            return;
        }

        var initialCount = _expiredHandlers.Count;
        Log.CleanupCycleStart(_logger, initialCount);

        var stopwatch = ValueStopwatch.StartNew();

        var disposedCount = 0;
        for (var i = 0; i &amp;lt; initialCount; i++)
        {
            // Since we're the only one removing from _expired, TryDequeue must always succeed.
            _expiredHandlers.TryDequeue(out var entry);
            Debug.Assert(entry != null, &quot;Entry was null, we should always get an entry back from TryDequeue&quot;);

            if (entry.CanDispose)
            {
                try
                {
                    entry.InnerHandler.Dispose();
                    disposedCount++;
                }
                catch (Exception ex)
                {
                    Log.CleanupItemFailed(_logger, entry.Name, ex);
                }
            }
            else
            {
                // If the entry is still live, put it back in the queue so we can process it 
                // during the next cleanup cycle.
                _expiredHandlers.Enqueue(entry);
            }
        }

        Log.CleanupCycleEnd(_logger, stopwatch.GetElapsedTime(), disposedCount, _expiredHandlers.Count);
    }
    finally
    {
        Monitor.Exit(_cleanupActiveLock);
    }

    // We didn't totally empty the cleanup queue, try again later.
    if (_expiredHandlers.Count &amp;gt; 0)
    {
        StartCleanupTimer();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述方法核心是判断是否handler对象已经被GC，如果是的话，则释放其内部资源，即网络连接。&lt;/p&gt;
&lt;p&gt;回到最初创建HttpClient的代码，会发现并没有传入任何name参数值。这是得益于HttpClientFactoryExtensions类的扩展方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static HttpClient CreateClient(this IHttpClientFactory factory)
{
    if (factory == null)
    {
        throw new ArgumentNullException(nameof(factory));
    }

    return factory.CreateClient(Options.DefaultName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Options.DefaultName的值为string.Empty。&lt;/p&gt;
&lt;p&gt;DefaultHttpClientFactory缺少无参数的构造方法，唯一的构造方法需要传入多个参数，这也意味着构建它时需要依赖其它一些类，所以目前只适用于在ASP.NET程序中使用，还无法应用到诸如控制台一类的程序，希望之后官方能够对其继续增强，使得应用范围变得更广。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public DefaultHttpClientFactory(
    IServiceProvider services,
    ILoggerFactory loggerFactory,
    IOptionsMonitor&amp;lt;HttpClientFactoryOptions&amp;gt; optionsMonitor,
    IEnumerable&amp;lt;IHttpMessageHandlerBuilderFilter&amp;gt; filters)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 18 Jul 2018 16:00:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9333042.html</dc:identifier>
</item>
<item>
<title>JDK线程池分析和使用 - 代码改变世界-Coding</title>
<link>http://www.cnblogs.com/vitasyuan/p/9314631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vitasyuan/p/9314631.html</guid>
<description>&lt;h3 id=&quot;为什么使用线程池&quot;&gt;1.为什么使用线程池&lt;/h3&gt;
&lt;p&gt;在多线程编程中一项很重要的功能就是执行任务，而执行任务的方式有很多种，为什么一定需要使用线程池呢？下面我们使用Socket编程处理请求的功能，分别对每种执行任务的方式进行分析。&lt;/p&gt;
&lt;h4 id=&quot;串行执行任务&quot;&gt;1.1串行执行任务&lt;/h4&gt;
&lt;p&gt;当Socket监听到客户端有连接，通过handleSocket方法顺序的处理每一个客户端连接，当处理完成后，继续监听。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket();
    SocketAddress endpoint = new InetSocketAddress(host, port);
    serverSocket.bind(endpoint,1023);
    while (!isStop) {
        Socket socket = serverSocket.accept();
        handleSocket(socket);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式的缺点非常明显：&lt;strong&gt;当我有多个客户端请求时，在server处理一个请求的过程中，其他请求都需要等待前一个请求处理完毕&lt;/strong&gt;。这种在高并发情况下几乎不可用。&lt;/p&gt;
&lt;h4 id=&quot;为每个任务创建一个线程&quot;&gt;1.2为每个任务创建一个线程&lt;/h4&gt;
&lt;p&gt;针对上面的问题进行优化：为每一个客户端请求创建一个线程来处理请求，主线程只需要创建线程，之后即可继续坚挺客户端请求.流程图如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/929184/201807/929184-20180718225849863-579263062.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket();
    SocketAddress endpoint = new InetSocketAddress(host, port);
    serverSocket.bind(endpoint,1023);
    while (!isStop) {
        Socket socket = serverSocket.accept();
        new SocketHandler(socket, THREAD_NAME_PREFIX + threadIndex++).start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式有以下优点：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;将处理客户端连接的操作从主线程中分离出去&lt;/strong&gt;，使得主循环可以更快的响应下一次请求。&lt;br/&gt;2.处理客户端连接的操作是并行的，提高了程序的吞吐量。&lt;/p&gt;
&lt;p&gt;但是这种方式有有以下几个缺点：&lt;/p&gt;
&lt;p&gt;1.处理请求的线程必须是线程安全的&lt;/p&gt;
&lt;p&gt;2.线程的创建和销毁都需要开销，当大量创建线程的时候，将会消耗大量计算机资源&lt;/p&gt;
&lt;p&gt;3.当可用的CPU数量小于可运行的线程的时候，那么多出来的线程会占用内存资源，给垃圾回收带来压力，并且在大量线程竞争CPU资源的时候会有很大的性能开销&lt;/p&gt;
&lt;p&gt;4.JVM中可创建的线程数存在一个上限，这个上限随着平台的不同而不同，并且受多个因素的限制，包括JVM的启动参数，每个线程所占用的内存大小等，如果超出这些限制，将会抛出OOM异常。&lt;/p&gt;
&lt;h4 id=&quot;使用线程池处理客户端请求&quot;&gt;1.3 使用线程池处理客户端请求&lt;/h4&gt;
&lt;p&gt;对于1.2中出现的问题，最好的解决方案就是使用线程池来执行task，这样可以对创建的线程总数做限制，从而避免1.2中的问题。流程图如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/929184/201807/929184-20180718225902445-797264680.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket();
    SocketAddress endpoint = new InetSocketAddress(host, port);
    serverSocket.bind(endpoint,1023);
    while (!isStop) {
        Socket socket = serverSocket.accept();
        executorService.execute(new SocketHandler(socket, THREAD_NAME_PREFIX + threadIndex++));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此中方式有以下几个优点：&lt;/p&gt;
&lt;p&gt;1.任务提交和任务执行分离开&lt;/p&gt;
&lt;p&gt;2.执行任务的线程可以重用，减少了线程创建和销毁的开销，同时当任务到达时可以直接使用创建好的线程执行任务，也提高了程序的响应速度。&lt;/p&gt;
&lt;h3 id=&quot;java中线程池介绍&quot;&gt;2.java中线程池介绍&lt;/h3&gt;
&lt;p&gt;在java中线程池的实现是基于生产者-消费者模式的，&lt;strong&gt;线程池的功能将任务的提交和任务的执行分离，任务提交的过程为生产者，执行任务的过程为消费过程&lt;/strong&gt;。具体的分析见源码分析。java线程池的顶层接口为Executor，源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Executor {
    void execute(Runnable command);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此接口为所有线程池实现的顶层接口，其规定了可以接受的task类型为Runnable实现类，但是具体的执行task的逻辑由线程池实现类自己定义，比如：&lt;/p&gt;
&lt;p&gt;可以使用主线程串行执行任务，&lt;br/&gt;也可以为每个任务创建一个新的线程&lt;br/&gt;或者提前创建好一组线程，每次执行任务的时候从一组线程中取，等等&lt;/p&gt;
&lt;p&gt;对于线程池的执行策略主要有以下几个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在什么线程中执行任务&lt;br/&gt;2.按照什么顺序执行任务（FIFO、LIFO、优先级？）&lt;br/&gt;3.有多少个任务可以并发执行&lt;br/&gt;4.最多可以有多少个任务在队列中等待执行&lt;br/&gt;5.当等待队列中达到最大值的时候，怎么样拒绝新提交的task&lt;br/&gt;6.在执行一个任务之前或者之后需要做哪些操作？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应该根据具体的业务选择不同的执行策略。在java类库中提供了Executors工具类来常见默认策略的线程池。主要有以下几个接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static ExecutorService newFixedThreadPool(int nThreads)
将会创建一个固定大小的线程池，每当有新任务提交的时候，当线程总数没有达到核心线程数的时候，为每个任务创建一个新线程，当线程的个数到达最大值后，重用之前创建的线程，当线程因为未知异常而停止时候，将会重现创建一个线程作为补充。

public static ExecutorService newCachedThreadPool()
根据需求创建线程的个数，当线程数大于任务数的时候，将会注销多余的线程

public static ExecutorService newSingleThreadExecutor()
创建一个单线程的线程池

public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
创建一个可执行定时任务的线程池&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上的例子中，所有提交的task在提交到线程池后其执行状态是不可见的，即主线程无法知道提交的task是否执行结束或者执行结果。针对这个问题，java提供了可以返回数据的task接口Future和Callable接口。&lt;br/&gt;其中Callable接口提供了任务返回数据以及抛出异常的功能，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Callable&amp;lt;V&amp;gt; {
  
    V call() throws Exception;
}
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ExecutorService中所有的submit方法都会返回一个Future对象，其接口定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {

    取消任务执行，当mayInterruptIfRunning为true，interruptedthisthread
    boolean cancel(boolean mayInterruptIfRunning);
    返回此任务是否在执行完毕之前被取消执行
    boolean isCancelled();
    返回此任务是否已经完成，包括正常结束，异常结束以及被cancel
    boolean isDone();
    返回执行结果，当任务没有执行结束的时候，等待
    V get() throws InterruptedException, ExecutionException;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用线程池可能出现的问题&quot;&gt;3.使用线程池可能出现的问题&lt;/h3&gt;
&lt;p&gt;1.线程饥饿死锁&lt;br/&gt;在单线程的Executor中，如果Executor中执行的一个任务中，再次提交任务到同一个Executor中，并且等待这个任务执行完毕，那么就会发生死锁问题。如下demo中所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadDeadLock {

    private static final ExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadExecutor();


    public static void main(String[] args) throws Exception {
        System.out.println(&quot;Main Thread start.&quot;);
        EXECUTOR_SERVICE.submit(new DeadLockThread());
        System.out.println(&quot;Main Thread finished.&quot;);

    }

    private static class DeadLockThread extends Thread{

        @Override
        public void run() {
            try {
                System.out.println(&quot;DeadLockThread start.&quot;);
                Future future = EXECUTOR_SERVICE.submit(new DeadLockThread2());
                future.get();
                System.out.println(&quot;DeadLockThread finished.&quot;);
            } catch (Exception e) {

            }
        }
    }

    private static class DeadLockThread2 extends Thread {

        @Override
        public void run() {
            try {
                System.out.println(&quot;DeadLockThread2 start.&quot;);
                Thread.sleep(1000 * 10);
                System.out.println(&quot;DeadLockThread2 finished.&quot;);
            } catch (Exception e) {

            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Main Thread start.
Main Thread finished.
DeadLockThread start.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于多个线程的线程池，如果所有正在执行的线程都因为等待处于工作队列中的任务执行而阻塞，那么就会发生线程饥饿死锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当往线程池中提交有依赖的任务时，应清楚的知道可能会出现的线程饥饿死锁风险。==应考虑是否将依赖的task提交到不同的线程池中==&lt;/strong&gt;&lt;br/&gt;或者使用无界的线程池。&lt;/p&gt;
&lt;p&gt;==只有当任务相对独立时，设置线程池大小和工作队列的大小才是合理的，否则有可能会出现线程饥饿死锁==&lt;/p&gt;
&lt;p&gt;2.任务运行时间过长&lt;br/&gt;任务执行时间过长会影响线程池的响应时间，当运行时间长的任务远大于线程池线程的个数时，会出现所有线程都在执行运行时间长的任务，从而影响对其他任务的响应。&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.通过限定任务等待的时长，而不要无限期等待下去，当等待超时的时候，可以将任务标记为失败，或者重新放到线程池中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.当线程池中阻塞任务过多的时，应该考虑扩大线程池的大小&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;线程池大小的设置&quot;&gt;4.线程池大小的设置&lt;/h3&gt;
&lt;p&gt;线程池的大小依赖于提交任务的类型以及服务器的可用资源，线程池的大小应该避免设置过大或者过小，当线程设置过打的时候可能会有资源耗尽的风险，线程池设置过小会有可用cpu空闲从而影响系统吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;影响线程池大小的资源有很多，比如CPU、内存、数据库链接池等，只需要计算资源可用总资源 / 每个任务需要的资源，取最小值，即可得出线程池的上限。&lt;br/&gt;线程池的最小值应该大于可用的CPU数量。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;java中常用线程池源码分析-threadpoolexecutor&quot;&gt;4.java中常用线程池源码分析-ThreadPoolExecutor&lt;/h3&gt;
&lt;p&gt;ThreadPoolExecutor线程池是比较常用的一个线程池实现类，通过Executors工具类创建的线程池中，其具体实现类是ThreadPoolExecutor。首先我们可以看下ThreadPoolExecutor的构造函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面分别对构造函数中的各个参数对应的策略进行分析：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.线程的创建与销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先构造函数中corePoolSize、maximumPoolSize、keepAliveTime和unit参数影响线程的创建和销毁。其中corePoolSize为核心线程数，当第一次提交任务的时候如果正在执行的线程数小于corePoolSize，则新建一个线程执行task，如果已经超过corePoolSize，则将任务放到任务队列中等待执行。当任务队列的个数到达上限的时候，并且工作线程数量小于maximumPoolSize，则继续创建线程执行工作队列中的任务。当任务的个数小于maximumPoolSize的时候，将会把空闲的线程标记为可回收的垃圾线程。对于以下代码段测试此功能：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPoolTest {

    private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(3, 6,100, TimeUnit.SECONDS, new LinkedBlockingQueue&amp;lt;&amp;gt;(3));

    public static void main(String[] args) throws Exception {
        for (int i = 0; i&amp;lt; 9; i++) {
            executorService.submit(new Task());
            System.out.println(&quot;Active thread:&quot; + executorService.getActiveCount() + &quot;.Task count:&quot; + executorService.getTaskCount() + &quot;.TaskQueue size:&quot; + executorService.getQueue().size());
        }
    }

    private static class Task extends Thread {

        @Override
        public void run() {
            try {
                Thread.sleep(1000 * 100);
            } catch (Exception e) {

            }
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Active thread:1.Task count:1.TaskQueue size:0
Active thread:2.Task count:2.TaskQueue size:0
Active thread:3.Task count:3.TaskQueue size:0
Active thread:3.Task count:4.TaskQueue size:1
Active thread:3.Task count:5.TaskQueue size:2
Active thread:3.Task count:6.TaskQueue size:3
Active thread:4.Task count:7.TaskQueue size:3
Active thread:5.Task count:8.TaskQueue size:3
Active thread:6.Task count:9.TaskQueue size:3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.任务队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在ThreadPoolExecutor的构造函数中可以传入保存任务的队列，当新提交的任务没有空闲线程执行时候，会将task保存到此队列中。保存的顺序是根据插入的顺序或者Comparator来排序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.饱和策略&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ThreadPoolExecutor.AbortPolicy
抛出RejectedExecutionException

ThreadPoolExecutor.CallerRunsPolicy
将任务的执行交给调用者，即将本该异步执行的任务变成同步执行。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4.线程工厂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当线程池需要创建线程的时候，默认是使用线程工厂方法来创建线程的，通常情况下我们通过指定线程工厂的方式来为线程命名，便于出现线程安全问题时候来定位问题。&lt;/p&gt;
&lt;h3 id=&quot;线程池最佳实现&quot;&gt;6.线程池最佳实现&lt;/h3&gt;
&lt;p&gt;1.项目中所有的线程应该都有线程池来提供，不允许自行创建线程&lt;/p&gt;
&lt;p&gt;2.尽量不要用Executors来创建线程，而是使用ThreadPoolExecutor来创建&lt;br/&gt;Executors有以下问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1）FixedThreadPool 和 SingleThreadPool:
允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
2）CachedThreadPool 和 ScheduledThreadPool:
允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 18 Jul 2018 15:07:00 +0000</pubDate>
<dc:creator>代码改变世界-Coding</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vitasyuan/p/9314631.html</dc:identifier>
</item>
</channel>
</rss>