<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>循环 - 里昂科科</title>
<link>http://www.cnblogs.com/leonsehun/p/8128136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leonsehun/p/8128136.html</guid>
<description>&lt;p&gt;循环&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1  &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;多项式求和&lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232414206-922067302.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;

&lt;h4&gt;&lt;strong&gt;设计思路：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;先输入一个整数&lt;/span&gt;n,&lt;/p&gt;
&lt;p&gt;循环输入n&lt;span&gt;次，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个&lt;/span&gt;flag&lt;span&gt;，要求加法时定义&lt;/span&gt;&lt;span&gt;flag=-1&lt;/span&gt;&lt;span&gt;；减法时&lt;/span&gt;&lt;span&gt;flag=1&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义&lt;/span&gt;sum=0&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行&lt;/span&gt;sum=x+flag*1.00/j;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232424456-1860965897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232525675-833714141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;2  &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;求&lt;/span&gt;1到100的和&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232542941-1937680790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用循环，定义&lt;/span&gt;i.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232615597-511381201.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232703800-1567380463.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;错误&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232625285-2105013126.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;原因&lt;/span&gt;  &lt;span&gt;未打空格&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.&lt;/strong&gt;&lt;strong&gt;求幂之和&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232639410-2080861229.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;此题很简单，调用&lt;/span&gt;pow函数，循环累加即可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232649472-1606326583.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232714785-201426326.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同学互评：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232848956-1632545344.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涧薇同学的代码写的很明了，比较容易读懂，但我觉得，我自己用到了函数，所以，嗯。还是不分伯仲吧。一起学习一起进步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1281072/201712/1281072-20171227232922472-500135168.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;经过循环这个题组的练习，我学到了格式很重要，尤其是在&lt;/span&gt;PTA上，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遇见很复杂的多重循环，可以选择调用函数，以便美观，也更清楚。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之，需要理清思路，画好流程图很重要，一步一步跟着思路打代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:30:00 +0000</pubDate>
<dc:creator>里昂科科</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leonsehun/p/8128136.html</dc:identifier>
</item>
<item>
<title>Netty学习笔记（一）：接收nodejs模拟表单上传的文件 - stone-fly</title>
<link>http://www.cnblogs.com/stone-fly/p/8127960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stone-fly/p/8127960.html</guid>
<description>&lt;p&gt;&lt;span&gt;好久不写博客了，也好久不写代码了，这两天临时遇上一个事情，觉得不难，加上觉得手有些生，就动手做了一下，结果遇上了不少坑，有新坑，有老坑，痛苦无比，现在总算差不多了，赶紧记录下来，希望以后不再重复这种痛苦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事情很简单，用nodejs模拟表单提交，上传文件到netty服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、netty的参考资料很多，目前有netty3,netty4两个版本，netty5出到alpha 2版本，不知道怎么的，就不更新了，官网也注明不支持了，所以我采用的是netty4.1.19版，目前最新的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;参考的资料大致如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1）http://netty.io/wiki/index.html，官方的文档，都写的很经典，值得学习，里面的例子snoop对我帮助很大&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2）https://www.programcreek.com/，一个示例代码的网站。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;netty的代码基本都是照抄第二个网站的内容，具体地址是https://www.programcreek.com/java-api-examples/index.php?source_dir=netty4.0.27Learn-master/example/src/main/java/io/netty/example/http/upload/HttpUploadServer.java。共有三个文件，HttpUploadServer.java，HttpUploadServerHandler.java，HttpUploadServerInitializer.java&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、nodejs本身比较简单，但也花了不少时间研究。上传文件可选的组件也很多，有form-data，request甚至官方的API，使用起来都不复杂，本来选择的是form-data，但是用起来也遇到了不少问题，最终使用的还是request，request使用起来非常简单，我主要参考了如下内容。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     1）http://www.open-open.com/lib/view/open1435301679966.html 中文的，介绍的比较详细。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     2）https://github.com/request/request 这是官方网站，内容最全，最权威。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、详细环境&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）Windows 10专业版&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2）Spring Tool Suite 3.9.1，其实用eclipse也可以&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   3）Netty 4.1.19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   4）Nodejs 8.9.3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4、目标&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）Netty程序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        a）同时支持post、get方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        b）将cookie、get参数和post参数保存到map里，如果是文件上传，则将其保存到临时目录，返回web地址，供客户访问。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2）nodejs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        a）同时支持get、post方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        b）可以设置cookie，因为上传文件肯定是需要登录的，sessionID一般是保存在cookie里面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5、预期思路&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）先解决netty的服务端问题，客户端先用浏览器测试。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2）再解决nodejs的问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6、解决过程和踩的坑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   1）Netty&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       a）Netty编程本身不难，但是相对来说要底层一些，如果经常做web开发的人，可能容易困惑，但熟悉一下就好了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            一般来说，netty服务端程序分为三个程序，如下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;           Server：启动线程，保定端口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;           Initializer：初始化流处理器，即将接收到的字节流先进行编码，形成对象，供后续解码器处理，我们需要关注的东西不多，在这个程序里，我们拿到手的已经是解析好的http对象了，只要按照我们的思路处理就可以了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;           Handler：是我们自己的逻辑，在这个例子里就是解析对象，形成map，将文件保存到磁盘上而已。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      b）首先是pom文件，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

        &amp;lt;groupId&amp;gt;io-netty&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;io-netty-example&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

        &amp;lt;name&amp;gt;io-netty-example&amp;lt;/name&amp;gt;
        &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;

        &amp;lt;properties&amp;gt;
                &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;/properties&amp;gt;

        &amp;lt;dependencies&amp;gt;
                &amp;lt;!-- https://mvnrepository.com/artifact/io.netty/netty-codec-http --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;io.netty&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;netty-all&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;4.1.19.Final&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;fastjson&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;1.2.44&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      c）Server非常简单，代码也不多，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.netty.example.http.upload; 
 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.bootstrap.ServerBootstrap; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.Channel; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.EventLoopGroup; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.nio.NioEventLoopGroup; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.nio.NioServerSocketChannel; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.logging.LogLevel; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.logging.LoggingHandler; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.ssl.SslContext; 
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.ssl.util.SelfSignedCertificate; 
 
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * A HTTP server showing how to use the HTTP multipart package for file uploads and decoding post data. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpUploadServer { 
 
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; SSL = System.getProperty(&quot;ssl&quot;) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, SSL? &quot;8443&quot; : &quot;8090&quot;&lt;span&gt;)); 
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception { 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure SSL. &lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SslContext sslCtx; 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (SSL) { 
            SelfSignedCertificate ssc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SelfSignedCertificate(); 
            sslCtx &lt;/span&gt;=&lt;span&gt; SslContext.newServerContext(ssc.certificate(), ssc.privateKey()); 
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; { 
            sslCtx &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
        } 
 
        EventLoopGroup bossGroup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(1&lt;span&gt;); 
        EventLoopGroup workerGroup &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioEventLoopGroup(); 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; { 
            ServerBootstrap b &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerBootstrap(); 
            b.group(bossGroup, workerGroup); 
            b.channel(NioServerSocketChannel.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;); 
            b.handler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggingHandler(LogLevel.INFO)); 
            b.childHandler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpUploadServerInitializer(sslCtx)); //调用Initializer
 
            Channel ch &lt;/span&gt;=&lt;span&gt; b.bind(PORT).sync().channel(); 
 
            System.err.println(&lt;/span&gt;&quot;Open your web browser and navigate to &quot; +&lt;span&gt; 
                    (SSL&lt;/span&gt;? &quot;https&quot; : &quot;http&quot;) + &quot;://127.0.0.1:&quot; + PORT + '/'&lt;span&gt;); 
 
            ch.closeFuture().sync(); 
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; { 
            bossGroup.shutdownGracefully(); 
            workerGroup.shutdownGracefully(); 
        } 
    } 
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     d）Initializer代码，需要注意的是流处理器，&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2012 The Netty Project 
 * 
 * The Netty Project licenses this file to you under the Apache License, 
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at: 
 * 
 *   &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt; 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations 
 * under the License. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.netty.example.http.upload;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelInitializer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelPipeline;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.socket.SocketChannel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpContentCompressor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpObjectAggregator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpRequestDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpResponseEncoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.ssl.SslContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HttpUploadServerInitializer &lt;span&gt;extends&lt;/span&gt; ChannelInitializer&amp;lt;SocketChannel&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SslContext sslCtx;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpUploadServerInitializer(SslContext sslCtx) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sslCtx =&lt;span&gt; sslCtx;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initChannel(SocketChannel ch) {
        ChannelPipeline pipeline &lt;/span&gt;=&lt;span&gt; ch.pipeline();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sslCtx != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            pipeline.addLast(sslCtx.newHandler(ch.alloc()));
        }

        pipeline.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestDecoder()); //处理Request
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncomment the following line if you don't want to handle HttpChunks.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pipeline.addLast(new HttpObjectAggregator(1048576)); //将对象组装为FullHttpRequest&lt;/span&gt;
        pipeline.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseEncoder());  //处理Response

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the following line if you don't want automatic content compression.&lt;/span&gt;
        pipeline.addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpContentCompressor());  //压缩

        pipeline.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpUploadServerHandler());
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       这里需要注意一点，采用HttpRequestDecoder处理器，会将一个Request对象解析成三个对象HttpRequest、HttpCotent、LastHttpContent，这三个对象大致是这样的，HttpRequest是地址信息和头部信息，其中包括get方式传送的参数和cookie信息；HttpContent是消息体，即Body部分，即post方式form提交的内容；LastHttpContent则是消息体的末尾，即提示消息体结束，也就是整个请求结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      但是需要注意的是，使用HttpObjectAggregator处理器，可以将Request对象处理为FullRequest，但我测试了一下，不知道为什么，竟然卡死了，所以只好用这种笨办法，以后研究一下，这次先这样吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      e）Handler的代码有些长，不过还是贴出来吧。       &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Copyright 2012 The Netty Project 
 * 
 * The Netty Project licenses this file to you under the Apache License, 
 * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at: 
 * 
 *   &lt;/span&gt;&lt;span&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/span&gt;&lt;span&gt; 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT 
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the 
 * License for the specific language governing permissions and limitations 
 * under the License. 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; io.netty.example.http.upload;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.buffer.ByteBuf;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.Channel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelFuture;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelFutureListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.ChannelHandlerContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.channel.SimpleChannelInboundHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.Cookie;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.CookieDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.DefaultFullHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.FullHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpContent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpHeaders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpResponseStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.HttpVersion;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.LastHttpContent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.QueryStringDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.ServerCookieEncoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.Attribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.DefaultHttpDataFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.DiskAttribute;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.DiskFileUpload;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.FileUpload;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpDataFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.EndOfDataDecoderException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.HttpPostRequestDecoder.ErrorDataDecoderException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.InterfaceHttpData;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.handler.codec.http.multipart.InterfaceHttpData.HttpDataType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; io.netty.util.CharsetUtil;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Files;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.file.Paths;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map.Entry;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.logging.Level;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.logging.Logger;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.alibaba.fastjson.JSON;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; io.netty.buffer.Unpooled.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; io.netty.handler.codec.http.HttpHeaders.Names.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HttpUploadServerHandler &lt;span&gt;extends&lt;/span&gt; SimpleChannelInboundHandler&amp;lt;HttpObject&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = Logger.getLogger(HttpUploadServerHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpRequest request;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; readingChunks;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; StringBuilder responseContent = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; HttpDataFactory factory = &lt;span&gt;new&lt;/span&gt; DefaultHttpDataFactory(DefaultHttpDataFactory.MINSIZE); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Disk
                                                                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if
                                                                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; size
                                                                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exceed&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpPostRequestDecoder decoder;

    &lt;/span&gt;&lt;span&gt;//////
&lt;/span&gt;    &lt;span&gt;private&lt;/span&gt; String tempPath = &quot;d:/upload/&quot;&lt;span&gt;;  //文件保存目录

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String url_path = &quot;http://localhost/upload/&quot;&lt;span&gt;;   //文件临时web目录
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String errorJson;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; mparams = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();  //将参数保存到map里面

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        DiskFileUpload.deleteOnExitTemporaryFile &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; should delete file
                                                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; on exit (in normal
                                                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exit)&lt;/span&gt;
        DiskFileUpload.baseDirectory = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; system temp directory&lt;/span&gt;
        DiskAttribute.deleteOnExitTemporaryFile = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; should delete file on
                                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exit (in normal exit)&lt;/span&gt;
        DiskAttribute.baseDirectory = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; system temp directory&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelUnregistered(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (decoder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            decoder.cleanFiles();
        }
    }
&lt;br/&gt;//处理输入对象，会执行三次，分别是HttpRequest、HttpContent、LastHttpContent
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; channelRead0(ChannelHandlerContext ctx, HttpObject msg) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpRequest) {
            HttpRequest request &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.request =&lt;span&gt; (HttpRequest) msg;
            URI uri &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URI(request.getUri());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!uri.getPath().equals(&quot;/formpostmultipart&quot;&lt;span&gt;)) {
                errorJson &lt;/span&gt;= &quot;{code:-1}&quot;&lt;span&gt;;
                writeError(ctx, errorJson);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new getMethod
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (Entry&amp;lt;String, String&amp;gt; entry : request.headers()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;HEADER: &quot; + entry.getKey() + '=' + entry.getValue() +
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;\r\n&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new getMethod&lt;/span&gt;
            Set&amp;lt;Cookie&amp;gt;&lt;span&gt; cookies;
            String value &lt;/span&gt;=&lt;span&gt; request.headers().get(COOKIE);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                cookies &lt;/span&gt;=&lt;span&gt; Collections.emptySet();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                cookies &lt;/span&gt;=&lt;span&gt; CookieDecoder.decode(value);
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie : cookies) {
                mparams.put(cookie.getName(), cookie.getValue());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add&lt;/span&gt;
&lt;span&gt;            System.out.println(JSON.toJSONString(mparams));

            QueryStringDecoder decoderQuery &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryStringDecoder(request.getUri());
            Map&lt;/span&gt;&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; uriAttributes =&lt;span&gt; decoderQuery.parameters();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add&lt;/span&gt;
&lt;span&gt;            mparams.putAll(uriAttributes);
            System.out.println(JSON.toJSONString(mparams));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (Entry&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; attr: uriAttributes.entrySet()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; for (String attrVal: attr.getValue()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;URI: &quot; + attr.getKey() + '=' + attrVal + &quot;\r\n&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\n\r\n&quot;);&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (request.getMethod().equals(HttpMethod.GET)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET Method: should not try to create a HttpPostRequestDecoder
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; So stop here
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\n\r\nEND OF GET CONTENT\r\n&quot;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Not now: LastHttpContent will be sent writeResponse(ctx.channel());&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                decoder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpPostRequestDecoder(factory, request);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ErrorDataDecoderException e1) {
                e1.printStackTrace();
                responseContent.append(e1.getMessage());
                writeResponse(ctx.channel());
                ctx.channel().close();
                errorJson &lt;/span&gt;= &quot;{code:-2}&quot;&lt;span&gt;;
                writeError(ctx, errorJson);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            readingChunks &lt;/span&gt;=&lt;span&gt; HttpHeaders.isTransferEncodingChunked(request);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;Is Chunked: &quot; + readingChunks + &quot;\r\n&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;IsMultipart: &quot; + decoder.isMultipart() + &quot;\r\n&quot;);&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (readingChunks) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Chunk version
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;Chunks: &quot;);&lt;/span&gt;
                readingChunks = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; check if the decoder was constructed before
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if not it handles the form get&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (decoder != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HttpContent) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; New chunk is received&lt;/span&gt;
                HttpContent chunk =&lt;span&gt; (HttpContent) msg;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    decoder.offer(chunk);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ErrorDataDecoderException e1) {
                    e1.printStackTrace();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(e1.getMessage());&lt;/span&gt;
&lt;span&gt;                    writeResponse(ctx.channel());
                    ctx.channel().close();
                    errorJson &lt;/span&gt;= &quot;{code:-3}&quot;&lt;span&gt;;
                    writeError(ctx, errorJson);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append('o');
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; example of reading chunk by chunk (minimize memory usage due to
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Factory)&lt;/span&gt;
&lt;span&gt;                readHttpDataChunkByChunk(ctx);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; example of reading only if at the end&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (chunk &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; LastHttpContent) {
                    writeResponse(ctx.channel());
                    readingChunks &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    reset();
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            writeResponse(ctx.channel());
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reset() {
        request &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; destroy the decoder to release all resources&lt;/span&gt;
&lt;span&gt;        decoder.destroy();
        decoder &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Example of reading request by chunk and getting values from chunk to chunk
     * 
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     &lt;/span&gt;&lt;span&gt;*/&lt;br/&gt;//处理post数据&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readHttpDataChunkByChunk(ChannelHandlerContext ctx) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (decoder.hasNext()) {
                InterfaceHttpData data &lt;/span&gt;=&lt;span&gt; decoder.next();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new value&lt;/span&gt;
&lt;span&gt;                        writeHttpData(ctx, data);
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        data.release();
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (EndOfDataDecoderException e1) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; end
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\n\r\nEND OF CONTENT CHUNK BY CHUNK\r\n\r\n&quot;);&lt;/span&gt;
            mparams.put(&quot;code&quot;, &quot;-2&quot;&lt;span&gt;);
        }
    }
    //解析post属性，保存文件，写入map
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeHttpData(ChannelHandlerContext ctx, InterfaceHttpData data) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.getHttpDataType() ==&lt;span&gt; HttpDataType.Attribute) {
            Attribute attribute &lt;/span&gt;=&lt;span&gt; (Attribute) data;
            String value;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                value &lt;/span&gt;=&lt;span&gt; attribute.getValue();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e1) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error while reading data from File, only print name and error&lt;/span&gt;
&lt;span&gt;                e1.printStackTrace();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; responseContent.append(&quot;\r\nBODY Attribute: &quot; +
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; attribute.getHttpDataType().name() + &quot;: &quot;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; + attribute.getName() + &quot; Error while reading value: &quot; + e1.getMessage() +
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;\r\n&quot;);&lt;/span&gt;
                errorJson = &quot;{code:-4}&quot;&lt;span&gt;;
                writeError(ctx, errorJson);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            mparams.put(attribute.getName(), attribute.getValue());
            System.out.println(JSON.toJSONString(mparams));
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.getHttpDataType() ==&lt;span&gt; HttpDataType.FileUpload) {
                FileUpload fileUpload &lt;/span&gt;=&lt;span&gt; (FileUpload) data;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileUpload.isCompleted()) {
                    System.out.println(fileUpload.length());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileUpload.length() &amp;gt; 0&lt;span&gt;) {
                        String orign_name &lt;/span&gt;=&lt;span&gt; fileUpload.getFilename();
                        String file_name &lt;/span&gt;= UUID.randomUUID() + &quot;.&quot;
                                + orign_name.substring(orign_name.lastIndexOf(&quot;.&quot;) + 1&lt;span&gt;);
                        fileUpload.renameTo(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(tempPath +&lt;span&gt; file_name));
                        mparams.put(data.getName(), url_path &lt;/span&gt;+&lt;span&gt; file_name);
                        System.out.println(JSON.toJSONString(mparams));
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    errorJson &lt;/span&gt;= &quot;{code:-5}&quot;&lt;span&gt;;
                    writeError(ctx, errorJson);

                }
            }
        }
    }
    //写入response，返回给客户
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeResponse(Channel channel) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Convert the response content to a ChannelBuffer.&lt;/span&gt;
        ByteBuf buf =&lt;span&gt; copiedBuffer(JSON.toJSONString(mparams), CharsetUtil.UTF_8);
        responseContent.setLength(&lt;/span&gt;0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decide whether to close the connection or not.&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt; close =&lt;span&gt; HttpHeaders.Values.CLOSE.equalsIgnoreCase(request.headers().get(CONNECTION))
                &lt;/span&gt;||&lt;span&gt; request.getProtocolVersion().equals(HttpVersion.HTTP_1_0)
                        &lt;/span&gt;&amp;amp;&amp;amp; !&lt;span&gt;HttpHeaders.Values.KEEP_ALIVE.equalsIgnoreCase(request.headers().get(CONNECTION));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Build the response object.&lt;/span&gt;
        FullHttpResponse response = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf);
        response.headers().set(CONTENT_TYPE, &lt;/span&gt;&quot;text/plain; charset=UTF-8&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;close) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; There's no need to add 'Content-Length' header
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if this is the last response.&lt;/span&gt;
&lt;span&gt;            response.headers().set(CONTENT_LENGTH, buf.readableBytes());
        }

        Set&lt;/span&gt;&amp;lt;Cookie&amp;gt;&lt;span&gt; cookies;
        String value &lt;/span&gt;=&lt;span&gt; request.headers().get(COOKIE);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            cookies &lt;/span&gt;=&lt;span&gt; Collections.emptySet();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            cookies &lt;/span&gt;=&lt;span&gt; CookieDecoder.decode(value);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cookies.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset the cookies if necessary.&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Cookie cookie : cookies) {
                response.headers().add(SET_COOKIE, ServerCookieEncoder.encode(cookie));
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write the response.&lt;/span&gt;
        ChannelFuture future =&lt;span&gt; channel.writeAndFlush(response);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Close the connection after the write operation is done if necessary.&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
            future.addListener(ChannelFutureListener.CLOSE);
        }
    }
    //返回错误信息，也是写入response
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeError(ChannelHandlerContext ctx, String errorJson) {

        ByteBuf buf &lt;/span&gt;=&lt;span&gt; copiedBuffer(errorJson, CharsetUtil.UTF_8);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Build the response object.&lt;/span&gt;
        FullHttpResponse response = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, buf);

        response.headers().set(CONTENT_TYPE, &lt;/span&gt;&quot;text/html; charset=UTF-8&quot;&lt;span&gt;);
        response.headers().set(CONTENT_LENGTH, buf.readableBytes());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write the response.&lt;/span&gt;
&lt;span&gt;        ctx.channel().writeAndFlush(response);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        logger.log(Level.WARNING, responseContent.toString(), cause);
        ctx.channel().close();
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     虽然代码很多，但是最需要注意的只有四个方法：    &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;channelRead0(ChannelHandlerContext ctx, HttpObject msg)：处理输入内容，会执行三次，分别是HttpRequest、HttpContent、LastHttpContent，依次处理。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;readHttpDataChunkByChunk(ChannelHandlerContext ctx)：解析HttpContent时调用，即消息体时，具体执行过程在函数writeHttpData中   &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;writeResponse(Channel channel)：写入response，这里调用了fastjson将map转换为json字符串。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;      f）上传的html文件     &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HTML5的标题&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form  &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:8090/formpostmultipart?a=张三&amp;amp;b=李四&quot;&lt;/span&gt;&lt;span&gt;  method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;  enctype&lt;/span&gt;&lt;span&gt;=&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;shiyq&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;历史地理&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=file  &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;上传&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;      g）启动HttpUploadServer，然后在浏览器里访问upload.html，返回结果如下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&lt;span&gt;{
    &quot;name&quot;: &quot;历史地理&quot;,
    &quot;a&quot;: [
        &quot;张三&quot;
    ],
    &quot;b&quot;: [
        &quot;李四&quot;
    ],
    &quot;file&quot;: &quot;http://localhost/upload/13d45df8-d6c7-4a7a-8f21-0251efeca240.png&quot;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      这里要注意的是，地址栏传递的参数是个数组，即参数名可以重复，form里面的值不可以，只能是一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2）NodeJS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       nodejs相对要简单一些，但是也更让人困惑，主要遇到了两个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       a）请求地址包含中文的情况，这个其实是个老问题，很容易解决，但是却卡住了半天，看来很久不写程序就是不行啊。最后的解决办法就是进行url编码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       b）cookie设置的问题，form-data模块没有说明cookie设置的问题，官方API的request也言之不详，幸好request写的比较明白，但是默认还不开启，需要设置，还是老话，三天不写程序手就生了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      c）环境非常简单，只需要安装request模块就可以了，命令为npm install request，尽量不要装在全局，在我的Windows 10上出现找不到模块的现象，最后安装到当前目录才解决，最后的代码如下      &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; fs = require('fs'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = require('request').defaults({jar:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;});  //不要忘记npm install request,不要忘记设置jar:true,否则无法设置cookied

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file_path=&quot;D:/Documents/IMG_20170427_121431.jpg&quot;
&lt;span&gt;var&lt;/span&gt; formData =&lt;span&gt; {
    name:&lt;/span&gt;&quot;路送双&quot;&lt;span&gt;,
    code:&lt;/span&gt;&quot;tom&quot;&lt;span&gt;,
    my_file:fs.createReadStream(file_path)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = encodeURI(&quot;http://localhost:8090/formpostmultipart?a=王二&amp;amp;a=张三&amp;amp;b=李四&quot;&lt;span&gt;);//对中文编码
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; j =&lt;span&gt; request.jar();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cookie = request.cookie('key1=value1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cookie1 = request.cookie('key2=value2'&lt;span&gt;);
j.setCookie(cookie, url);
j.setCookie(cookie1, url);

request.post({url:url, jar:j, formData: formData}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; optionalCallback(err, httpResponse, body) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; console.error('upload failed:'&lt;span&gt;, err);
  }
  console.log( body);
});&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;     需要注意cookie的设置，不仅需要设置jar属性为true，还需要调用多次setCookie，还需要在request.post中指定参数，挺麻烦的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      d）返回结果如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;{
    &lt;/span&gt;&quot;key1&quot;: &quot;value1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;key2&quot;: &quot;value2&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;a&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;王二&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;张三&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;b&quot;&lt;span&gt;: [
        &lt;/span&gt;&quot;李四&quot;&lt;span&gt;
    ],
    &lt;/span&gt;&quot;code&quot;: &quot;tom&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;my_file&quot;: &quot;http://localhost/upload/8d8e2f9f-7513-4844-9614-0d7fb7a33a6e.jpg&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;name&quot;: &quot;路送双&quot;&lt;span&gt;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;7、结论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     其实是个很简单的问题，不过研究过程有些长，而且很笨拙，如果用FullHttpRequest，代码会少很多，以后再研究吧。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:28:00 +0000</pubDate>
<dc:creator>stone-fly</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stone-fly/p/8127960.html</dc:identifier>
</item>
<item>
<title>InfluxDB:cannot use field in group by clause - 静若清池</title>
<link>http://www.cnblogs.com/liugh/p/8128065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liugh/p/8128065.html</guid>
<description>&lt;p&gt;  最近在使用InfluxDB时，发现一个很奇怪的问题，一个本来正常的功能，做了一次改动后，就不能正常显示了.&lt;/p&gt;
&lt;p&gt;一、查询语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
SELECT MEMORY FROM &lt;span&gt;&quot;ACM_PROCESS_MONITOR&quot; GROUP BY USER_NAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 异常信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Server returned error: can not use &lt;span&gt;field&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; GROUP BY clause: &lt;span&gt;USER_NAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Group By语句后面，只能是Tag列，不能是Field列&lt;/p&gt;

&lt;p&gt;二、查看所有Tag列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227225512722-598871319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  说明&lt;span&gt;USER_NAME&lt;/span&gt;是Tag列&lt;/p&gt;
&lt;p&gt;三、查看所有Field列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227225618956-328987666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   说明USER_NAME是Field列&lt;/p&gt;
&lt;p&gt;   综上所述，USER_NAME既是FIELD列，又是TAG列！&lt;/p&gt;
&lt;p&gt; 四、问题产生原因&lt;/p&gt;
&lt;p&gt;  产生这个问题的原因，是因为UESER_NAME以前确实是FIELD列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227230508191-2078406843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 因为不能在GROUP BY 中查询，于是把它设置为了TAG列：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380081/201712/380081-20171227230646378-619859701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    为了方便，删除了原来的表，数据都是新的，GROUP BY 没有问题。&lt;/p&gt;
&lt;p&gt;   今天一不小心，又启用了改之前的程序，导致又把USER_NAME作为了FIELD列，所以GROUP BY的时候出问题了。&lt;/p&gt;
&lt;p&gt;   老外的描述：https://github.com/influxdata/influxdb/issues/3783&lt;/p&gt;
&lt;p&gt;   解决方案：&lt;/p&gt;
&lt;p&gt;   1.把表删了重建，然后启用新程序&lt;/p&gt;
&lt;p&gt;或：&lt;/p&gt;
&lt;p&gt;   2.重新为USER_NAME取一个作为TAG列的名字：TAG_USER_NAME，数据都写到这里，用它作为GROUP BY的Tag列&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 15:02:00 +0000</pubDate>
<dc:creator>静若清池</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liugh/p/8128065.html</dc:identifier>
</item>
<item>
<title>Android查缺补漏（View篇）--自定义 View 的基本流程 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/8060101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/8060101.html</guid>
<description>&lt;p&gt;View是Android很重要的一部分，常用的View有Button、TextView、EditView、ListView、GridView、各种layout等等，开发者通过对这些View的各种组合以形成丰富多彩的交互界面，一个应用中界面交互的体验往往在应用的受欢迎程度上起了很关键得作用，所以开发者们大多会想方设法的做出一个更加精美的界面，例如：通过自定义View、深入学习View的原理以便更好的对其优化使其在操作起来更加流畅等等，也正因为如此，在面试中View也常常作为面试官重点考察的对象之一。&lt;/p&gt;
&lt;p&gt;View是所有控件的基类，包括Button、TextView、EditView等等都直接或间接继承自view，View下面还有ViewGroup子类，即LinearLayout、RelativeLayout等都属于ViewGroup。&lt;/p&gt;
&lt;p&gt;我们需要知道的是在Android中，无论是View还是其他界面，右方向代表着x轴的正向，下方向代表着y轴的正向。&lt;/p&gt;
&lt;h3 id=&quot;view-的基本工作原理&quot;&gt;View 的基本工作原理&lt;/h3&gt;
&lt;p&gt;在 ActivityThread 中，当Activity被创建后会将 DecorView 添加到 Window 中，同时创建 ViewRootImpl 对象，并将 ViewRootImpl 和 DecorView 建立关联，而 DecorView 就是一个 Activity 的顶级 View，在一个默认的主题中，它分为标题栏，和内容区域，我们所添加的 View 均是添加到了 DecorView 的内容区域，这些被添加进去的 View 的工作流程正式通过 ViewRootImpl 完成的。&lt;/p&gt;
&lt;p&gt;ViewRoot、DecorView 及 View 的三大流程简介：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ViewRoot：对应于 ViewRootImpl，链接 WindowManager 和 DecorView 的纽带，View 的三大流程均是通过它完成的。（View 的绘制流程是从 ViewRoot 的 performTraversals() 方法开始的，它经过 measure、layout、draw 三个流程最终才能将一个 View 完整的绘制出来。）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DecorView：新建一个 Android 应用时我们都知道，默认主题的情况下这个应用的界面会分为两部分：标题栏、内容区域。而这个界面的顶级 View 就是 DecorView。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;View的绘制经过了 measure、layout、draw 三个流程：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;measure：对应 onMeasure() 方法，测量View的宽、高。&lt;/li&gt;
&lt;li&gt;layout：对应 onLayout() 方法，确定view的四个顶点，即确定View在父容器中的位置。&lt;/li&gt;
&lt;li&gt;draw：对应 onDraw()，绘制View。在自定义 View 时我们也正是在 onDraw() 方法内可以在 Canvas 画布上随心所欲的画出我们想要的 View。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;自定义-view&quot;&gt;自定义 View&lt;/h3&gt;
&lt;p&gt;自定义 View 的方式不止一种，可以直接继承 View，重写 onDraw() 方法，也可以直接继承 ViewGroup，还可以继承现有的控件（如：TextView、LinearLayout）等，本篇主要介绍一下直接继承 View 的方式。&lt;/p&gt;
&lt;p&gt;直接继承 View 来实现自定义 View 的这种方式比较灵活，可以实现很多复杂的效果，这种方式最关键的步骤就是重写 onDraw() 方法，通过 Paint 画笔等工具在 Canvas 画布上进行各种图案的绘制以达到我们想要的效果。&lt;/p&gt;
&lt;p&gt;其实在自定义 View 过程中，难点往往不是怎么使用画笔本身，而是绘制出预期效果的思路，例如：你想通过自定义 View 来做一个折线图控件，传入一组数据怎么确定这些数据在画布上对应点的相对坐标，而确定点的坐标就需要通过相关的数学公式来计算了，推算出合适的公式往往就是解决问题的关键。&lt;/p&gt;
&lt;p&gt;接下来就用这种方式来写个圆形的小 demo 来说明一下自定义 View 的流程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建一个继承 View 的类，添加构造方法，设置 Paint 画笔，重写 onDraw() 方法，先在画布上以最简单的方式话一个半径为100的圆。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 自定义 View 简单示例
 * Created by liuwei on 17/12/14.
 */
public class MyView extends View {

    private final static String TAG = MyView.class.getSimpleName();

    private Paint mPaint = new Paint();
    private int mColor = Color.parseColor(&quot;#ff0000&quot;);

    public MyView(Context context) {
        super(context);
        Log.i(TAG, &quot;MyView(Context context)：content=&quot; + context);
        init();
    }

    public MyView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        Log.i(TAG, &quot;MyView(Context context, @Nullable AttributeSet attrs)：content=&quot; + context + &quot; | attrs=&quot; + attrs);
        init();
    }

    private void init() {
        mPaint.setAntiAlias(true); // 消除锯齿
        mPaint.setColor(mColor); // 为画笔设置颜色
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);

        // 重写此方法，对自定义控件在 wrap_content 情况下设置默认宽、高
        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
        int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        int heithtSpecSize = MeasureSpec.getSize(heightMeasureSpec);

        if (widthSpecMode == MeasureSpec.AT_MOST &amp;amp;&amp;amp; heightSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(200, 200);
        } else if (widthSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(200, heithtSpecSize);
        } else if (heightSpecMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(widthSpecSize, 200);
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        Log.i(TAG, &quot;onDraw: &quot;);
        super.onDraw(canvas);
        canvas.drawCircle(100, 100, 100, mPaint);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果就是一个红色的实心圆，在这个示例中为了使得布局文件中的 wrap_content 正常生效，重写了 onMeasure() 方法，关于这个问题，在这篇博文&lt;a href=&quot;http://www.cnblogs.com/codingblock/p/8067167.html&quot;&gt;《Android查缺补漏--自定义 View 中 wrap_content 无效的解决方案》&lt;/a&gt;中也介绍过了，这里就不多说了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将上面的圆再扩展一下：做成以画布的可用区域的中心为圆点，画出最大的圆。同时为自定义 View 设置 padding&lt;br/&gt;对于一个控件，有 margin 和 padding，margin 是外间距，属于控件之外的范围，在自定义 View 时不需要对 margin 做特殊处理。但 padding 就不同了，是内间距，需要我们在控件的内部做处理才能让布局文件中对控件设置的 padding 生效。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;private int mPaddingTop;
private int mPaddingBottom;
private int mPaddingLeft;
private int mPaddingRight;

private int mUsableWidth; // 可用宽度（减去padding后的宽度）
private int mUsableHeight;// 可用高度（减去padding后的高度）

private int mUsableStartX = 0; // 画笔起始点的x坐标
private int mUsableStartY = 0; // 画笔其实点的y坐标

private int mCircleX; // 圆心x坐标
private int mCircleY; // 圆心y坐标
private int mCircleRadius;// 圆的半径

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mPaddingTop = getPaddingTop();
    mPaddingBottom = getPaddingBottom();
    mPaddingLeft = getPaddingLeft();
    mPaddingRight = getPaddingRight();

    // 可用宽度和宽度要考虑padding
    mUsableWidth = getWidth() - mPaddingRight - mPaddingLeft;
    mUsableHeight = getHeight() - mPaddingTop - mPaddingBottom;
    // 画笔起始点要考虑padding
    mUsableStartX = mPaddingLeft;
    mUsableStartY = mPaddingTop;

    // 确定可用区域的中心为圆心
    mCircleX = mUsableStartX + mUsableWidth / 2;
    mCircleY = mUsableStartY + mUsableHeight / 2;

    // 确定圆的半径，以可用宽度和高度两者较短的一半为圆的半径
    if (mUsableWidth &amp;lt;= mUsableHeight) {
        mCircleRadius = mUsableWidth / 2;
    } else {
        mCircleRadius = mUsableHeight / 2;
    }

    canvas.drawCircle(mCircleX, mCircleY, mCircleRadius, mPaint);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在布局文件中设置 paddingLeft 为15dp，paddingRight 为30dp，为了更好看出间距，将控件的背景颜色设为了黑色，查看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;cn.codingblock.view.reset_view.MyView
        android:id=&quot;@+id/myview&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_margin=&quot;10dp&quot;
        android:paddingLeft=&quot;15dp&quot;
        android:paddingRight=&quot;30dp&quot;
        android:background=&quot;#000&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果图：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171218231256850-2026384580.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，在 onDraw() 方法对padding处理之后，在布局文件中无论怎么设置padding，都能保证圆心在可用区域的中心。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为自定义 View 添加自定义属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先在 res/values 路径下创建一个xml文件，添加一个设置圆的颜色的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;resources&amp;gt;
    &amp;lt;declare-styleable name=&quot;MyView&quot;&amp;gt;
        &amp;lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&amp;gt;
    &amp;lt;/declare-styleable&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造方法中解析属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public MyView(Context context, @Nullable AttributeSet attrs) {
    super(context, attrs);
    TypedArray typeArray = context.obtainStyledAttributes(attrs, R.styleable.MyView);
    mColor = typeArray.getColor(R.styleable.MyView_circle_color, mColor);
    typeArray.recycle();
    init();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在布局文件中这是属性就可以了，要注意的是，在使用自定义属性时要添加 xmlns:app=&quot;&lt;a href=&quot;http://schemas.android.com/apk/res-auto&quot; class=&quot;uri&quot;&gt;http://schemas.android.com/apk/res-auto&lt;/a&gt;&quot; 才可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;cn.codingblock.view.activity.MyViewActivity&quot;&amp;gt;

    &amp;lt;cn.codingblock.view.reset_view.MyView
        android:id=&quot;@+id/myview&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_margin=&quot;10dp&quot;
        android:paddingLeft=&quot;15dp&quot;
        android:paddingRight=&quot;30dp&quot;
        app:circle_color=&quot;#ad42ce&quot;
        android:background=&quot;#000&quot;/&amp;gt;

&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改变颜色后的效果图如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171218221850928-544517003.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;为自定义view添加交互事件&quot;&gt;为自定义View添加交互事件&lt;/h3&gt;
&lt;h4 id=&quot;motionevent-触摸事件&quot;&gt;MotionEvent 触摸事件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            Log.i(TAG, &quot;onTouchEvent: ACTION_DOWN&quot;);
            break;
        case MotionEvent.ACTION_UP:
            Log.i(TAG, &quot;onTouchEvent: ACTION_UP&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&quot;);
            break;
    }
    return super.onTouchEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在自定义 View 中，重写 onTouchEvent() 方法，获取 MotionEvent，正如上面代码所写，MotionEvent 比较常用的事件有三种 ACTION_DOWN、ACTION_MOVE、ACTION_UP 分别对应手指按下-移动-离开。&lt;/p&gt;
&lt;p&gt;接下来对上面的圆形demo添加一个小事件，就是每当手指点击一下屏幕，圆形就随机换一种颜色：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Random mRandom = new Random(100);
private int[] mColors = new int[] {
  Color.parseColor(&quot;#ff0000&quot;),
  Color.parseColor(&quot;#ffffff&quot;),
  Color.parseColor(&quot;#ff00ff&quot;),
  Color.parseColor(&quot;#ffff00&quot;),
  Color.parseColor(&quot;#ff00ff&quot;),
  Color.parseColor(&quot;#0000ff&quot;)
};

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mColor = mColors[mRandom.nextInt(6)];
            mPaint.setColor(mColor);
            invalidate(); // 通知控件重绘
            break;
        case MotionEvent.ACTION_UP:
            Log.i(TAG, &quot;onTouchEvent: ACTION_UP&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&quot;);
            break;
    }
    return super.onTouchEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171218223436600-637929861.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家也可以在此基础上稍微再扩展一下，例如：通过 event.getX() 和 event.getY() 获取触摸点的坐标，判断出点是否落在了圆形区域内，从而使只有点手指点到圆形区域内才改变颜色，否则不改变。感兴趣的童鞋可自行动手试一试。&lt;/p&gt;
&lt;p&gt;在上面代码中通知 View 重绘时使用了 invalidate() 方法，其实 postInvalidate() 也可以通知 View 重绘，那么这两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;其实简单来说，invalidate() 只能在 UI 线程中使用，而 postInvalidate() 可以在子线程中使用。&lt;/p&gt;
&lt;h4 id=&quot;scalegesturedetector-缩放手指检测&quot;&gt;ScaleGestureDetector 缩放手指检测&lt;/h4&gt;
&lt;p&gt;除了上面最普通的 MotionEvent 事件之外，Android 还提供了很多有趣的事件，就想 GestureDetector（手势检测）、VelocityTracker（速度追踪）等等，用起来也都很方便，其实只要你愿意，这些事件也完全可以在 onTouchEvent() 方法中实现，接下来在为上述的圆形 Demo 添加一个缩放的功能，也就是使用 ScaleGestureDetector 实现，效果跟平时在手机查看照片时我们用两根手指来放大/缩小图片一样。&lt;/p&gt;
&lt;p&gt;ScaleGestureDetector 在使用起来也很简单，首先需要初始化并为其添加一个放缩手势监听器，并且需要在 onTouchEvent() 方法内，通过 ScaleGestureDetector.onTouchEvent(event) 来让 ScaleGestureDetector 接管触摸事件，其余的事项请注意看代码中的注释。&lt;/p&gt;
&lt;p&gt;在上述代码的基础上新增如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Context mContext;
private ScaleGestureDetector mScaleGestureDetector; // 缩放手势检测
private float mScaleRate = 1; // 缩放比率

private void init() {
    mPaint.setAntiAlias(true); // 消除锯齿
    mPaint.setColor(mColor); // 为画笔设置颜色
    // 初始化 ScaleGestureDetector 并添加缩放手势监听器
    mScaleGestureDetector = new ScaleGestureDetector(mContext, mOnScaleGestureListener);
}

@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mPaddingTop = getPaddingTop();
    mPaddingBottom = getPaddingBottom();
    mPaddingLeft = getPaddingLeft();
    mPaddingRight = getPaddingRight();

    // 可用宽度和宽度要考虑padding
    mUsableWidth = getWidth() - mPaddingRight - mPaddingLeft;
    mUsableHeight = getHeight() - mPaddingTop - mPaddingBottom;
    // 画笔起始点要考虑padding
    mUsableStartX = mPaddingLeft;
    mUsableStartY = mPaddingTop;

    // 确定可用区域的中心为圆心
    mCircleX = mUsableStartX + mUsableWidth / 2;
    mCircleY = mUsableStartY + mUsableHeight / 2;

    // 确定圆的半径，以可用宽度和高度两者较短的一半为圆的半径
    if (mUsableWidth &amp;lt;= mUsableHeight) {
        mCircleRadius = mUsableWidth / 2;
    } else {
        mCircleRadius = mUsableHeight / 2;
    }

    // 让半径乘以缩放倍率
    mCircleRadius *= mScaleRate;
    canvas.drawCircle(mCircleX, mCircleY, mCircleRadius, mPaint);
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mColor = mColors[mRandom.nextInt(6)];
            mPaint.setColor(mColor);
            invalidate(); // 通知控件重绘
            break;
        case MotionEvent.ACTION_UP:
            Log.i(TAG, &quot;onTouchEvent: ACTION_UP&quot;);
            break;
        case MotionEvent.ACTION_MOVE:
            Log.i(TAG, &quot;onTouchEvent: ACTION_MOVE&quot;);
            break;
    }

    // 让缩放手势检测器接管触摸事件
    if (mScaleGestureDetector.onTouchEvent(event)) {
        return true;
    }

    return super.onTouchEvent(event);
}

private ScaleGestureDetector.OnScaleGestureListener mOnScaleGestureListener = new ScaleGestureDetector.OnScaleGestureListener() {
    @Override
    public boolean onScale(ScaleGestureDetector detector) {
        Log.i(TAG, &quot;onScale: &quot; + detector.getScaleFactor());
        // 获取缩放比例因子并累乘到缩放倍率上
        mScaleRate *= detector.getScaleFactor();
        postInvalidate();
        return true;
    }

    @Override
    public boolean onScaleBegin(ScaleGestureDetector detector) {
        Log.i(TAG, &quot;onScaleBegin: &quot; + detector.getScaleFactor());
        return true;
    }

    @Override
    public void onScaleEnd(ScaleGestureDetector detector) {
        Log.i(TAG, &quot;onScaleEnd: &quot; + detector.getScaleFactor());
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/776965/201712/776965-20171219183841756-1136104681.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码需要注意的是，在 ScaleGestureDetector 捕获到事件后要正确的将事件消费掉（注意代码中返回 true 的地方），不然缩放手势无法正常工作。&lt;/p&gt;
&lt;p&gt;自定义 View 在 Android 中一直以来都是很重要的一部分，在平时的开发想要做出一个个性炫酷的交互界面是离不开自定义 View，自定义 View 说难不难，说简单也不简单，总之，千里之行，始于足下，只要我们掌握好自定义 View 的基础知识，再复杂的界面也可以一步步完成。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;最后想说的是，本系列文章为博主对Android知识进行再次梳理，查缺补漏的学习过程，一方面是对自己遗忘的东西加以复习重新掌握，另一方面相信在重新学习的过程中定会有巨大的新收获，如果你也有跟我同样的想法，不妨关注我一起学习，互相探讨，共同进步！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考文献：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;《Android开发艺术探索》&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;《Android开发进阶从小工到专家》&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 27 Dec 2017 14:56:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/8060101.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】用PaddlePaddle和Tensorflow实现GoogLeNet InceptionV2/V3/V4 - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/8127780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/8127780.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上一篇文章我们引出了GoogLeNet InceptionV1的网络结构，这篇文章中我们会详细讲到Inception V2/V3/V4的发展历程以及它们的网络结构和亮点。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GoogLeNet Inception V2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;GoogLeNet Inception V2在《&lt;a href=&quot;https://arxiv.org/abs/1502.03167&quot; target=&quot;_blank&quot;&gt;Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift&lt;/a&gt;》出现，最大亮点是提出了Batch Normalization方法，它起到以下作用：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;e6nx&quot;&gt;&lt;li&gt;&lt;span&gt;使用较大的学习率而不用特别关心诸如梯度爆炸或消失等优化问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;降低了模型效果对初始权重的依赖；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以加速收敛，一定程度上可以不使用Dropout这种降低收敛速度的方法，但却起到了正则化作用提高了模型泛化性；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;即使不使用ReLU也能缓解激活函数饱和问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;能够学习到从当前层到下一层的分布缩放( scaling (方差)，shift (期望))系数。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　在机器学习中，我们通常会做一种假设：训练样本独立同分布(iid)且训练样本与测试样本分布一致，如果真实数据符合这个假设则模型效果可能会不错，反之亦然，这个在学术上叫Covariate Shift，所以从样本（外部）的角度说，对于神经网络也是一样的道理。从结构（内部）的角度说，由于神经网络由多层组成，样本在层与层之间边提特征边往前传播，如果每层的输入分布不&lt;span&gt;一致，那么势必造成要么模型效果不好，要么学习速度较慢，学术上这个叫InternalCovariate Shift。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设：&lt;/span&gt;$y$&lt;span&gt;为样本标注&lt;/span&gt;，$X=\{x_{1},x_{2},x_{3},......\}$&lt;span&gt;为样本&lt;/span&gt;$x$&lt;span&gt;通过神经网络若干层后每层的输入&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理论上：&lt;/span&gt;$p(x,y)$&lt;span&gt;的联合概率分布应该与集合$X$中任意一层输入的联合概率分布一致，如&lt;/span&gt;：$p(x,y)=p(x_{1},y)$；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是&lt;/span&gt;：$p(x,y)=p(y|x)·p(x)$,&lt;span&gt;其中条件概率&lt;/span&gt;$p(y|x)$&lt;span&gt;是一致的，即&lt;/span&gt;$p(y|x)=p(y|x_{1})=p(y|x_{1})=......$，&lt;span&gt;但由于神经网络每一层对输入分布的改变，导致边缘概率是不一致的，即&lt;/span&gt;$p(x)\neq p(x_{1})\neq p(x_{2})......$，&lt;span&gt;甚至随着网络深度的加深，前面层微小的变化会导致后面层巨大的变化&lt;/span&gt;。&lt;/p&gt;

&lt;p data-anchor-id=&quot;3byw&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;BN整个算法过程&lt;/strong&gt;&lt;/span&gt;如下： &lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;3byw&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213442300-1929291972.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;240&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;3byw&quot;&gt;&lt;span&gt;以batch的方式做训练，对m个样本求期望和方差后对训练数据做白化，通过白化操作可以去除特征相关性并把数据缩放在一个球体上，这么做的好处既可以加快优化算法的优化速度也可能提高优化精度，一个直观的解释：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213525769-1070431385.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;166&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 左边是未做白化的原始可行域，右边是做了白化的可行域；&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;q7vu&quot;&gt;&lt;li&gt;&lt;span&gt;当原始输入对模型学习更有利时能够恢复原始输入（和残差网络有点神似）：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213546160-588739520.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;266&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里的参数$\gamma$和$\sigma$&lt;span&gt;是需要学习的。&lt;/span&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-185-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-186-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5132-卷积神经网络中的bn&quot; data-anchor-id=&quot;pem8&quot;&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;卷积神经网络中的BN&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　卷积网络中采用权重共享策略，每个feature map只有一对$\gamma$和$\sigma$&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-194-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span id=&quot;MathJax-Element-195-Frame&quot; class=&quot;MathJax_SVG&quot;&gt;需要学习。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax_SVG&quot;&gt;&lt;span class=&quot;MathJax_Preview&quot;&gt;&lt;span class=&quot;MathJax_SVG&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227213751206-122407428.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;235&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;h2 id=&quot;514-googlenet-inception-v3&quot; data-anchor-id=&quot;by49&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GoogLeNet Inception V3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p data-anchor-id=&quot;9xhz&quot;&gt;&lt;span&gt;GoogLeNet Inception V3在《Rethinking the Inception Architecture for Computer Vision》中提出（注意，在这篇论文中作者把该网络结构叫做v2版，我们以最终的v4版论文的划分为标准），该论文的亮点在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;6sez&quot;&gt;&lt;li&gt;&lt;span&gt;提出通用的网络结构设计准则&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;引入卷积分解提高效率&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;引入高效的feature map降维&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5141-网络结构设计的准则&quot; data-anchor-id=&quot;m5ig&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;网络结构设计的准则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;前面也说过，深度学习网络的探索更多是个实验科学，在实验中人们总结出一些结构设计准则，但说实话我觉得不一定都有实操性：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;避免特征表示上的瓶颈，尤其在神经网络的前若干层 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;神经网络包含一个自动提取特征的过程，例如多层卷积，直观并符合常识的理解：如果在网络初期特征提取的太粗，细节已经丢了，后续即使结构再精细也没法做有效表示了；举个极端的例子：在宇宙中辨别一个星球，正常来说是通过由近及远，从房屋、树木到海洋、大陆板块再到整个星球之后进入整个宇宙，如果我们一开始就直接拉远到宇宙，你会发现所有星球都是球体，没法区分哪个是地球哪个是水星。所以feature map的大小应该是随着层数的加深逐步变小，但为了保证特征能得到有效表示和组合其通道数量会逐渐增加。 　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;zi0g&quot;&gt;&lt;span&gt;下图违反了这个原则，刚开就始直接从35×35×320被抽样降维到了17×17×320，特征细节被大量丢失，即使后面有Inception去做各种特征提取和组合也没用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214036019-2049622062.png&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;171&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对于神经网络的某一层，通过更多的激活输出分支可以产生互相解耦的特征表示，从而产生高阶稀疏特征，从而加速收敛，注意下图的1×3和3×1激活输出：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214217144-150696561.png&quot; alt=&quot;&quot; width=&quot;313&quot; height=&quot;249&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;合理使用维度缩减不会破坏网络特征表示能力反而能加快收敛速度，典型的例如通过两个3×3代替一个5×5的降维策略，不考虑padding，用两个3×3代替一个5×5能节省1-（3×3+3×3）/(5×5)=28%的计算消耗。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214239628-2001866412.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;223&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以及一个n×n卷积核通过顺序相连的两个1×n和n×1做降维（有点像矩阵分解），如果n=3，计算性能可以提升1-(3+3)/9=33%，但如果考虑高性能计算性能，这种分解可能会造成L1 cache miss率上升。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214259378-866463491.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;295&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;2spf&quot;&gt;&lt;li&gt;&lt;span&gt;通过合理平衡网络的宽度和深度优化网络计算消耗（这句话尤其不具有实操性）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;抽样降维，传统抽样方法为pooling+卷积操作，为了防止出现特征表示的瓶颈，往往需要更多的卷积核，例如输入为n个d×d的feature map，共有k个卷积核，pooling时stride=2，为不出现特征表示瓶颈，往往k的取值为2n，通过引入inception module结构，即降低计算复杂度，又不会出现特征表示瓶颈，实现上有如下两种方式：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214334613-2045548073.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;292&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5142-平滑样本标注&quot; data-anchor-id=&quot;i73w&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;平滑样本标注&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-anchor-id=&quot;esus&quot;&gt;&lt;span&gt;对于多分类的样本标注一般是one-hot的，例如[0,0,0,1]，使用类似交叉熵的损失函数会使得模型学习中对ground truth标签分配过于置信的概率，并且由于ground truth标签的logit值与其他标签差距过大导致，出现过拟合，导致降低泛化性。一种解决方法是加正则项，即对样本标签给个概率分布做调节，使得样本标注变成“soft”的，例如[0.1,0.2,0.1,0.6]，这种方式在实验中降低了top-1和top-5的错误率0.2%。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5143-网络结构&quot; data-anchor-id=&quot;u3ju&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;网络结构&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227214413253-565722322.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;589&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 data-anchor-id=&quot;6nav&quot;&gt;&lt;strong&gt;&lt;span&gt;GoogLeNet Inception V4&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;GoogLeNet Inception V4/和ResNet V1/V2这三种结构在《Inception-v4, Inception-ResNet and the Impact of Residual Connections on Learning》一文中提出，论文的亮点是：提出了效果更好的GoogLeNet Inception v4网络结构；与残差网络融合，提出效果不逊于v4但训练速度更快的结构。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;5151-googlenet-inception-v4网络结构&quot; data-anchor-id=&quot;9105&quot;&gt;&lt;span&gt;GoogLeNet Inception V4网络结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227215021394-1251296998.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;687&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5152-googlenet-inception-resnet网络结构&quot; data-anchor-id=&quot;ehr4&quot;&gt;&lt;span&gt;GoogLeNet Inception ResNet网络结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/853467/201712/853467-20171227215104441-1140736506.png&quot; alt=&quot;&quot; width=&quot;885&quot; height=&quot;731&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;代码实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;Tensorflow的代码在slim模块下有完整的实现，paddlepaddle的可以参考上篇文章中写的inception v1的代码来写。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;　&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这篇文章比较偏理论，主要讲了GoogLeNet的inception模块的发展，包括在v2中提出的batch normalization，v3中提出的卷积分级与更通用的网络结构准则，v4中的与残差网络结合等，在实际应用过程中可以可以对同一份数据用不同的网络结构跑一跑，看看结果如何，实际体验一下不同网络结构的loss下降速率，对准确率的提升等。　 &lt;/span&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 14:02:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/8127780.html</dc:identifier>
</item>
<item>
<title>企业级nosql数据库应用与实战-redis - 珂儿吖</title>
<link>http://www.cnblogs.com/keerya/p/8127716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keerya/p/8127716.html</guid>
<description>&lt;br/&gt;&lt;h2&gt;一、NoSQL简介&lt;/h2&gt;&lt;h3&gt;1.1 常见的优化思路和方向&lt;/h3&gt;

&lt;h4&gt;1.1.1 MySQL主从读写分离&lt;/h4&gt;
&lt;p&gt;　　由于数据库的写入压力增加，&lt;span&gt;Memcached只能缓解数据库的读取压力&lt;/span&gt;。读写集中在一个数据库上让数据库不堪重负，大部分网站开始&lt;span&gt;使用主从复制技术达到读写分离&lt;/span&gt;，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。&lt;/p&gt;

&lt;h4&gt;1.1.2 分库分表&lt;/h4&gt;
&lt;p&gt;　　 随着web2.0的继续高速发展，在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。同时，&lt;span&gt;开始流行使用分表分库来缓解写压力&lt;/span&gt;和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但是由于在互联网几乎没有成功案例，性能也不能满足互联网的要求，只是在高可靠性上提供了非常大的保证。&lt;/p&gt;

&lt;h3&gt;1.2 NoSQL诞生的原因&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;关系型数据库面临的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;扩展困难&lt;/strong&gt;：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读写慢&lt;/strong&gt;：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成本高&lt;/strong&gt;：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限的支撑容量&lt;/strong&gt;：现有关系型解决方案还无法支撑Google这样海量的数据存储；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;数据库访问的新需求：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;低延迟的读写速度&lt;/strong&gt;：应用快速地反应能极大地提升用户的满意度；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支撑海量的数据和流量&lt;/strong&gt;：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大规模集群的管理&lt;/strong&gt;：系统管理员希望分布式应用能更简单的部署和管理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;庞大运营成本的考量&lt;/strong&gt;：IT经理们希望在硬件成本、软件成本和人力成本能够有大幅度地降低；&lt;/li&gt;
&lt;li&gt;NoSQL数据库仅仅是关系数据库在某些方面（&lt;span&gt;性能、扩展&lt;/span&gt;）的一个弥补&lt;/li&gt;
&lt;li&gt;单从功能上讲，NoSQL的几乎所有的功能，在关系数据库上都能够满足。&lt;/li&gt;
&lt;li&gt;一般会把NoSQL和关系数据库进行结合使用，各取所长，各得其所。&lt;/li&gt;
&lt;li&gt;在某些应用场合，比如一些配置的关系键值映射存储、用户名和密码的存储、Session会话存储等等&lt;/li&gt;
&lt;li&gt;在某些场景下，用NoSQL完全可以替代关系数据库(如：MySQL)存储。不但具有更高的性能，而且开发也更加方&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.3 分布式系统的挑战&lt;/h3&gt;
&lt;p&gt;　　CAP原理是指这三个要素最多只能同时实现两点，不可能三者兼顾。因此在进行分布式架构设计时，必须做出取舍。而对于分布式数据系统，分区容忍性是基本要求，否则就失去了价值。因此设计分布式数据系统，就是在一致性和可用性之间取一个平衡。对于大多数WEB应用，其实并不需要强一致性，因此牺牲一致性而换取高可用性，是多数分布式数据库产品的方向。&lt;/p&gt;
&lt;p&gt;　　在理论计算机科学中，&lt;span&gt;CAP定理（CAP theorem）&lt;/span&gt;，又被称作布鲁尔定理(Brewer’s theorem)，它指出对于一个分布式计算系统来说，不可能同时满足以下三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;（Consistency)—所有节点在同一时间具有相同的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;（Availability）—保证每个请求不管成功或者失败都有响应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分隔容忍&lt;/strong&gt;（Partition tolerance）—系统中任意信息的丢失或失败不会影响系统的继续运作&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3.1关系数据库和NoSQL侧重点&lt;/h4&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;关系数据库&lt;/th&gt;
&lt;th&gt;NoSQL&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;分布式关系型数据库中强调的&lt;code&gt;ACID&lt;/code&gt;分别是：&lt;strong&gt;原子性&lt;/strong&gt;（Atomicity）、&lt;strong&gt;一致性&lt;/strong&gt;（Consistency）、&lt;strong&gt;隔离性&lt;/strong&gt;（Isolation）、&lt;strong&gt;持久性&lt;/strong&gt;（Durability）&lt;/td&gt;
&lt;td&gt;对于许多互联网应用来说，对于一致性要求可以降低，而可用性(Availability)的要求则更为明显，在CAP理论基础上，从而产生了&lt;span&gt;弱一致性&lt;/span&gt;的理论BASE。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;ACID的目的就是通过事务支持，保证数据的完整性和正确性&lt;/td&gt;
&lt;td&gt;&lt;code&gt;BASE&lt;/code&gt;分别是英文：Basically，Available（&lt;strong&gt;基本可用&lt;/strong&gt;）， Softstate（软状态）&lt;strong&gt;非实时同步&lt;/strong&gt;，Eventual Consistency（&lt;strong&gt;最终一致&lt;/strong&gt;）的缩写，这个模型是反&lt;code&gt;ACID&lt;/code&gt;模型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;1.4 NoSQL的优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;简单的扩展&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;快速的读写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　主要例子有Redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;低廉的成本&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不提供对SQL的支持&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　如果不支持SQL这样的工业标准，将会对用户产生一定的学习和应用迁移成本；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;支持的特性不够丰富&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　现有产品所提供的功能都比较有限，大多数NoSQL数据库都不支持事务，也不像Oracle那样能提供各种附加功能，比如BI和报表等；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;现有产品的不够成熟&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语；&lt;/p&gt;

&lt;h3&gt;1.5 NoSQL总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的&lt;span&gt;节省开发成本和维护成本&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会&lt;br/&gt;给web2.0的数据库发展带来新的思路。让&lt;span&gt;关系数据库关注在&lt;strong&gt;关系&lt;/strong&gt;上，NoSQL关注在&lt;strong&gt;功能、性能&lt;/strong&gt;上。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;随着移动互联网的发展，以及业务场景的多样化，社交元素的普遍化，Nosql从性能和功能上很好的补充了web2.0时代的原关系型数据的缺点，目前已经是各大公司必备的技术之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;二、NoSQL的分类&lt;/h2&gt;

&lt;h3&gt;2.1 基本分类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Column-oriented（列式）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主要围绕着“列（Column）”，而非 “行（Row）”进行数据存储&lt;/li&gt;
&lt;li&gt;属于同一列的数据会尽可能地存储在硬盘同一个页（Page）中&lt;/li&gt;
&lt;li&gt;大多数列式数据库都支持Column Family这个特性&lt;/li&gt;
&lt;li&gt;（很多类似数据仓库（Data Warehouse）的应用，虽然每次查询都会处理很多数据，但是每次所涉及的列并没有很多）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：比较适合汇总（Aggregation）和数据仓库这类应用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Key-value&lt;/span&gt;&lt;/strong&gt;(重要)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类似常见的HashTable，一个Key对应一个Value，但是其能提供非常快的查询速度、大的数据存放量和高并发操作，&lt;/li&gt;
&lt;li&gt;非常适合通过主键对数据进行查询和修改等操作， 虽然不支持复杂的操作，但可通过上层的开发来弥补这个缺陷。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Document（文档）&lt;/strong&gt; (比如：mongodb)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类似常见的HashTable，一个Key对应一个Value，&lt;/li&gt;
&lt;li&gt;其能提供非常快的查询速度、大的数据存放量和高并发操作，&lt;/li&gt;
&lt;li&gt;非常适合通过主键对数据进行查询和修改等操作，&lt;/li&gt;
&lt;li&gt;数据类型多且存在大量的空项。比如SNS类的用户profile，手机，邮箱，地址，性别……有很多项，而且大部分是空项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.2 常见分类&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;常见Nosql分类&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211136628-281237072.png&quot; alt=&quot;常见Nosql分类&quot; name=&quot;images/1513992891616.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;常见Nosql分类&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;关注一致性和可用性的(CA)&lt;/strong&gt;&lt;br/&gt;　　这些数据库对于分区容忍性方面比较不感冒，主要采用复制（Replication）这种方式来保证数据的安全性，常见的CA系统有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传统关系型数据库，比如Postgres和MySQL等(Relational)
&lt;ul&gt;&lt;li&gt;Oracle (Relational)&lt;/li&gt;
&lt;li&gt;Aster Data (Relational)&lt;/li&gt;
&lt;li&gt;Greenplum (Relational)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NoSQL:
&lt;ul&gt;&lt;li&gt;redis&lt;/li&gt;
&lt;li&gt;mongodb&lt;/li&gt;
&lt;li&gt;cassandra&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;关注一致性和分区容忍性的(CP)&lt;/strong&gt;&lt;br/&gt;　　这种系统将数据分布在多个网络分区的节点上，并保证这些数据的一致性，但是对于可用性的支持方面有问题，比如当集群出现问题的话，节点有可能因无法确保数据是一致性的而拒绝提供服务，主要的CP系统有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BigTable (Column-oriented)&lt;/li&gt;
&lt;li&gt;Hypertable (Column-oriented)&lt;/li&gt;
&lt;li&gt;HBase (Column-oriented)&lt;/li&gt;
&lt;li&gt;MongoDB (Document)&lt;/li&gt;
&lt;li&gt;Terrastore (Document)&lt;/li&gt;
&lt;li&gt;Redis (Key-value)&lt;/li&gt;
&lt;li&gt;Scalaris (Key-value)&lt;/li&gt;
&lt;li&gt;MemcacheDB (Key-value)&lt;/li&gt;
&lt;li&gt;Berkeley DB (Key-value)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;关于可用性和分区容忍性的(AP)&lt;/strong&gt;&lt;br/&gt;　　这类系统主要以实现“最终一致性（Eventual Consistency）”来确保可用性和分区容忍性，AP的系统有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Dynamo (Key-value)&lt;/li&gt;
&lt;li&gt;Voldemort (Key-value)&lt;/li&gt;
&lt;li&gt;Tokyo Cabinet (Key-value)&lt;/li&gt;
&lt;li&gt;KAI (Key-value)&lt;/li&gt;
&lt;li&gt;Cassandra (Column-oriented)&lt;/li&gt;
&lt;li&gt;CouchDB (Document-oriented)&lt;/li&gt;
&lt;li&gt;SimpleDB (Document-oriented)&lt;/li&gt;
&lt;li&gt;Riak (Document-oriented)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.3 常见Nosql分类和部分代表&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;常见Nosql分类和部分代表&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211138660-1807074377.png&quot; alt=&quot;常见Nosql分类和部分代表&quot; name=&quot;images/1513992929954.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;常见Nosql分类和部分代表&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;三、企业常见Nosql应用&lt;/h2&gt;

&lt;h3&gt;3.1 纯NoSQL架构（Nosql为主）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在一些数据结构、查询关系非常简单的系统中，我们可以只使用NoSQL即可以解决存储问题。&lt;/li&gt;
&lt;li&gt;在一些数据库结构经常变化，数据结构不定的系统中，就非常适合使用NoSQL来存储。
&lt;ul&gt;&lt;li&gt;比如监控系统中的监控信息的存储，可能每种类型的监控信息都不太一样。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有些NoSQL数据库已经具有部分关系数据库的关系查询特性，他们的功能介于key-value和关系数据库之间，却具有key-value数据库的性能，基本能满足绝大部分web 2.0网站的查询需求。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;纯Nosql架构&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211138941-120374875.png&quot; alt=&quot;纯Nosql架构&quot; name=&quot;images/1513992982904.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;纯Nosql架构&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;3.2 以NoSQL为数据源的架构（Nosql为主）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数据直接写入NoSQL，再通过NoSQL同步协议复制到其他存储。&lt;/li&gt;
&lt;li&gt;根据应用的逻辑来决定去相应的存储获取数据。&lt;/li&gt;
&lt;li&gt;应用程序只负责把数据直接写入到NoSQL数据库，然后通过NoSQL的复制协议，把NoSQL数据的每次写入，更新，删除操作都复制到MySQL数据库中。&lt;/li&gt;
&lt;li&gt;同时，也可以通过复制协议把数据同步复制到全文检索实现强大的检索功能。&lt;/li&gt;
&lt;li&gt;这种架构需要考虑数据复制的延迟问题，这跟使用MySQL的mastersalve模式的延迟问题是一样的，解决方法也一样。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Nosql为主&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211139206-1652111820.png&quot; alt=&quot;Nosql为主&quot; name=&quot;images/1513993019245.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Nosql为主&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;3.3 NoSQL作为镜像（nosql为辅）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不改变原有的以MySQL作为存储的架构，使用NoSQL作为辅助镜像存储，用NoSQL的优势辅助提升性能。&lt;/li&gt;
&lt;li&gt;在原有基于MySQL数据库的架构上增加了一层辅助的NoSQL存储。&lt;/li&gt;
&lt;li&gt;在写入MySQL数据库后，同时写入到NoSQL数据库，让MySQL和NoSQL拥有相同的镜像数据。&lt;/li&gt;
&lt;li&gt;在某些可以根据主键查询的地方，使用高效的NoSQL数据库查询。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Nosql为辅&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211139550-1787063280.png&quot; alt=&quot;Nosql为辅&quot; name=&quot;images/1513993038859.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Nosql为辅&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;3.4 NoSQL为镜像（同步模式，nosql为辅）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通过MySQL把数据同步到NoSQL中, ，是一种对写入透明但是具有更高技术难度一种模式&lt;/li&gt;
&lt;li&gt;适用于现有的比较复杂的老系统，通过修改代码不易实现，可能引起新的问题。同时也适用于需要把数据同步到多种类型的存储中。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;story_align_center&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;同步模式，Nosql为辅&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211139878-1641106179.png&quot; alt=&quot;同步模式，Nosql为辅&quot; name=&quot;images/1513993060089.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;同步模式，Nosql为辅&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;3.5 MySQL和NoSQL组合（nosql为辅）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MySQL中只存储需要查询的小字段，NoSQL存储所有数据。&lt;/li&gt;
&lt;li&gt;把需要查询的字段，一般都是数字，时间等类型的小字段存储于MySQL中，根据查询建立相应的索引，&lt;/li&gt;
&lt;li&gt;其他不需要的字段，包括大文本字段都存储在NoSQL中。&lt;/li&gt;
&lt;li&gt;在查询的时候，我们先从MySQL中查询出数据的主键，然后从NoSQL中直接取出对应的数据即可。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Nosql为辅&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211140253-316579278.png&quot; alt=&quot;Nosql为辅&quot; name=&quot;images/1513993085027.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Nosql为辅&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;3.6 其他应用&lt;/h3&gt;
&lt;p&gt;　　由于NoSQL数据库天生具有高性能、易扩展的特点，所以我们常常结合关系数据库，存储一些高性能的、海量的数据。&lt;br/&gt;　　&lt;span&gt;从另外一个角度看，根据NoSQL的高性能特点，它同样适合用于缓存数据。用NoSQL缓存数据可以分为内存模式和磁盘持久化模式。&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;内存模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Memcached提供了相当高的读写性能，在互联网发展过程中，一直是缓存服务器的首选。&lt;/li&gt;
&lt;li&gt;NoSQL数据库Redis又为我们提供了功能更加强大的内存存储功能。跟Memcached比，Redis的一个key的可以存储多种数据结构Strings、Hashes、Lists、Sets、Sorted sets。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis不但功能强大，而且它的性能完全超越大名鼎鼎的Memcached。&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;Redis支持List、hashes等多种数据结构的功能，提供了更加易于使用的api和操作性能，比如对缓存的list数据的修改。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;持久化模式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虽然基于内存的缓存服务器具有高性能，低延迟的特点，但是内存成本高、内存数据易失却不容忽视。&lt;/li&gt;
&lt;li&gt;大部分互联网应用的特点都是数据访问有热点，也就是说，只有一部分数据是被频繁访问的。&lt;/li&gt;
&lt;li&gt;其实NoSQL数据库内部也是通过内存缓存来提高性能的，通过一些比较好的算法
&lt;ul&gt;&lt;li&gt;把热点数据进行内存cache&lt;/li&gt;
&lt;li&gt;非热点数据存储到磁盘&lt;/li&gt;
&lt;li&gt;以节省内存占用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用NoSQL来做缓存，由于其不受内存大小的限制，我们可以把一些不常访问、不怎么更新的数据也缓存起来。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;四、redis&lt;/h2&gt;

&lt;h3&gt;4.1 什么是redis？&lt;/h3&gt;
&lt;p&gt;　　redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset --有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。&lt;span&gt;区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;Redis 是一个高性能的key-value数据库。&lt;/span&gt; redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。&lt;br/&gt;　Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。&lt;br/&gt;　　redis的官网地址，非常好记，&lt;a href=&quot;http://xn--redis-qr1k.io&quot; target=&quot;_blank&quot;&gt;是redis.io&lt;/a&gt;。&lt;br/&gt;　　目前，Vmware在资助着redis项目的开发和维护。&lt;/p&gt;

&lt;h3&gt;4.2 redis的特性&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;完全居于内存，数据实时的读写内存，定时闪回到文件中。采用单线程,避免了不必要的上下文切换和竞争条件；&lt;/li&gt;
&lt;li&gt;支持高并发量，官方宣传支持10万级别的并发读写；&lt;/li&gt;
&lt;li&gt;支持持久存储，机器重启后的，重新加载模式，不会掉数据；&lt;/li&gt;
&lt;li&gt;海量数据存储，分布式系统支持，数据一致性保证，方便的集群节点添加/删除；&lt;/li&gt;
&lt;li&gt;Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储；&lt;/li&gt;
&lt;li&gt;灾难恢复–memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；&lt;/li&gt;
&lt;li&gt;虚拟内存–Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；&lt;/li&gt;
&lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;4.3 redis的架构&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;redis的架构&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211140800-747274757.png&quot; alt=&quot;redis的架构&quot; name=&quot;images/1513993126970.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;redis的架构&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;各功能模块说明如下：&lt;br/&gt;&lt;code&gt;File Event&lt;/code&gt;: 处理文件事件，接受它们发来的命令请求（读事件），并将命令的执行结果返回给客户端（写事件）)&lt;br/&gt;&lt;code&gt;Time Event&lt;/code&gt;: 时间事件(更新统计信息，清理过期数据，附属节点同步，定期持久化等)&lt;br/&gt;&lt;code&gt;AOF&lt;/code&gt;: 命令日志的数据持久化&lt;br/&gt;&lt;code&gt;RDB&lt;/code&gt;：实际的数据持久化&lt;br/&gt;&lt;code&gt;Lua Environment&lt;/code&gt; : Lua 脚本的运行环境. 为了让 Lua 环境符合 Redis 脚本功能的需求，Redis 对 Lua 环境进行了一系列的修改，包括添加函数库、更换随机函数、保护全局变量，等等&lt;br/&gt;&lt;code&gt;Command table(命令表)&lt;/code&gt;：在执行命令时，根据字符来查找相应命令的实现函数。&lt;br/&gt;&lt;code&gt;Share Objects（对象共享）&lt;/code&gt;：&lt;br/&gt;主要存储常见的值：&lt;br/&gt;　　a.各种命令常见的返回值，例如返回值OK、ERROR、WRONGTYPE等字符；&lt;br/&gt;　　b. 小于 redis.h/REDIS_SHARED_INTEGERS (默认1000)的所有整数。通过预分配的一些常见的值对象，并在多个数据结构之间共享对象，程序避免了重复分配的麻烦。也就是说，这些常见的值在内存中只有一份。&lt;br/&gt;&lt;code&gt;Databases&lt;/code&gt;：Redis数据库是真正存储数据的地方。当然，数据库本身也是存储在内存中的。&lt;/p&gt;

&lt;h3&gt;4.4 redis 启动流程&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;redis启动流程&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211141160-839630931.png&quot; alt=&quot;redis启动流程&quot; name=&quot;images/1513994426813.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;redis启动流程&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;4.5 redis 安装方式&lt;/h3&gt;
&lt;p&gt;　　redis安装常用两种方式，&lt;strong&gt;yum安装和源码包安装&lt;/strong&gt;&lt;br/&gt;　　&lt;strong&gt;yum 安装&lt;/strong&gt;：通常是在线安装，好处是安装方式简单，不易出错；常用的安装yum源为epel。&lt;br/&gt;　　&lt;strong&gt;源码包安装&lt;/strong&gt;：是先将 redis 的源码下载下来，在自己的系统里编译生成可执行文件，然后执行，好处是因为是在自己的系统上编译的，更符合自己系统的性能，也就是说在自己的系统上执行 redis 服务性能效率更好。&lt;br/&gt;　　&lt;span&gt;区别：路径和启动方式不同，支持的模块也不同。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;4.5.1 redis 程序路径&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;配置文件：&lt;code&gt;/etc/redis.conf&lt;/code&gt;&lt;br/&gt;主程序：&lt;code&gt;/usr/bin/redis-server&lt;/code&gt;&lt;br/&gt;客户端：&lt;code&gt;/usr/bin/redis-cli&lt;/code&gt;&lt;br/&gt;Unit &lt;code&gt;File:/usr/lib/systemd/system/redis.service&lt;/code&gt;&lt;br/&gt;数据目录：&lt;code&gt;/var/lib/redis&lt;/code&gt;&lt;br/&gt;监听：&lt;code&gt;6379/tcp&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;4.6 redis 配置文件&lt;/h3&gt;

&lt;h4&gt;4.6.1 网络配置项(NETWORK)&lt;/h4&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;### NETWORK ###
bind IP   #监听地址
port PORT    #监听端口
protected-mode yes    #是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。
tcp-backlog 511   #定义了每一个端口最大的监听队列的长度
unixsocket /tmp/redis.sock    #也可以打开套接字监听
timeout 0    #连接的空闲超时时长；
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;网络配置项&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211141488-460040604.png&quot; alt=&quot;网络配置项&quot; name=&quot;images/1513995677016.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;网络配置项&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;4.6.2 通用配置项(GENERAL)&lt;/h4&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;### GENERAL ###
daemonize no    #是否以守护进程启动
supervised no    #可以通过upstart和systemd管理Redis守护进程，这个参数是和具体的操作系统相关的
pidfile &quot;/var/run/redis/redis.pid&quot;    #pid文件
loglevel notice   #日志等级
logfile &quot;/var/log/redis/redis.log&quot;    #日志存放文件
databases 16     #设定数据库数量，默认为16个，每个数据库的名字均为整数，从0开始编号，默认操作的数据库为0；
        切换数据库的方法：SELECT &amp;lt;dbid&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;通用配置项&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211141800-714971103.png&quot; alt=&quot;通用配置项&quot; name=&quot;images/1513995882600.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通用配置项&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;4.6.3 快照配置(SNAPSHOTTING)&lt;/h4&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;### SNAPSHOTTING  ###
save 900 1         #900秒有一个key变化，就做一个保存
save 300 10       #300秒有10个key变化，就做一个保存，这里需要和开发沟通
save 60 10000   #60秒有10000个key变化就做一个保存
stop-writes-on-bgsave-error yes   #在出现错误的时候，是不是要停止保存
rdbcompression yes   #使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗；no：不压缩，需要更多的磁盘空间
rdbchecksum yes    #是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。
dbfilename &quot;along.rdb&quot;     #rdb文件的名称
dir &quot;/var/lib/redis&quot;    #数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;快照配置&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211142128-241051447.png&quot; alt=&quot;快照配置&quot; name=&quot;images/1513996411370.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;快照配置&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;4.6.4 限制相关配置(LIMITS)&lt;/h4&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;### LIMITS ###
maxclients 10000    #设置能连上redis的最大客户端连接数量
maxmemory &amp;lt;bytes&amp;gt;    #redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。
maxmemory-policy noeviction    #淘汰策略：volatile-lru, allkeys-lru, volatile-random, allkeys-random, volatile-ttl, noeviction
内存容量超过maxmemory后的处理策略：
① # volatile-lru：利用LRU算法移除设置过过期时间的key。
② # volatile-random：随机移除设置过过期时间的key。
③ # volatile-ttl：移除即将过期的key，根据最近过期时间来删除（辅以TTL）
④ # allkeys-lru：利用LRU算法移除任何key。
⑤ # allkeys-random：随机移除任何key。
⑥ # noeviction：不移除任何key，只是返回一个写错误。
# 上面的这些驱逐策略，如果redis没有合适的key驱逐，对于写命令，还是会返回错误。redis将不再接收写请求，只接收get请求。写命令包括：set setnx
maxmemory-samples 5   #淘汰算法运行时的采样样本数；
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;限制相关配置&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211142410-1755478968.png&quot; alt=&quot;限制相关配置&quot; name=&quot;images/1513996618789.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;限制相关配置&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;4.6.5 持久化配置(APPEND ONLY MODE)&lt;/h4&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;### APPEND ONLY MODE ###
# 默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。
appendonly no    #不启动aof模式
appendfilename &quot;appendonly.aof&quot;    #据读入内存里，先忽略RDB文件，aof文件名(default: &quot;appendonly.aof&quot;)
appendfsync
Redis supports three different modes:
no：redis不执行主动同步操作，而是OS进行；
everysec：每秒一次；
always：每语句一次；
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果Redis只是将客户端修改数据库的指令重现存储在AOF文件中，那么AOF文件的大小会不断的增加，因为AOF文件只是简单的重现存储了客户端的指令，而并没有进行合并。对于该问题最简单的处理方式，即&lt;span&gt;当AOF文件满足一定条件时就对AOF进行rewrite&lt;/span&gt;，rewrite是根据当前内存数据库中的数据进行遍历写到一个临时的AOF文件，待写完后替换掉原来的AOF文件即可。&lt;br/&gt;　　redis重写会将多个key、value对集合来用一条命令表达。在rewrite期间的写操作会保存在内存的rewrite buffer中，rewrite成功后这些操作也会复制到临时文件中，在最后临时文件会代替AOF文件。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;&lt;strong&gt;no-appendfsync-on-rewrite no &lt;/strong&gt;
#在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。

&lt;strong&gt;auto-aof-rewrite-percentage 100&lt;/strong&gt; aof自动重写配置。当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候Redis能够调用bgrewrite aof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。

&lt;strong&gt;auto-aof-rewrite-min-size 64mb&lt;/strong&gt; #设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。&lt;strong&gt;上述两个条件同时满足时&lt;/strong&gt;，方会触发重写AOF；与上次aof文件大小相比，其增长量超过100%，且大小不少于64MB;

&lt;strong&gt;aof-load-truncated yes&lt;/strong&gt; #指redis在恢复时,会忽略最后一条可能存在问题的指令。aof文件可能在尾部是不完整的，出现这种现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。
如果是no，用户必须手动redis-check-aof修复AOF文件才可以。
&lt;strong&gt;注意：持久机制本身不能取代备份；应该制订备份策略，对redis库定期备份；Redis服务器启动时用持久化的数据文件恢复数据，会优先使用AOF；&lt;/strong&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;redis 持久化存储读取&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211142988-1062821066.png&quot; alt=&quot;redis 持久化存储读取&quot; name=&quot;images/1513999124924.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;redis 持久化存储读取&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　我们继续来看 redis 的持久化：&lt;br/&gt;&lt;strong&gt;RDB&lt;/strong&gt;：snapshotting, 二进制格式；按事先定制的策略，周期性地将数据从内存同步至磁盘；数据文件默认为dump.rdb；&lt;br/&gt;　　客户端显式使用SAVE或BGSAVE命令来手动启动快照保存机制；&lt;br/&gt;　　SAVE：同步，即在主线程中保存快照，此时会阻塞所有客户端请求；&lt;br/&gt;　　BGSAVE：异步；backgroud&lt;br/&gt;&lt;strong&gt;AOF&lt;/strong&gt;：Append Only File, fsync&lt;br/&gt;　　记录每次写操作至指定的文件尾部实现的持久化；当redis重启时，可通过重新执行文件中的命令在内存中重建出数据库；&lt;br/&gt;　　BGREWRITEAOF：AOF文件重写；&lt;br/&gt;　　不会读取正在使用AOF文件，而是通过将内存中的数据以命令的方式保存至临时文件中，完成之后替换原来的AOF文件；&lt;/p&gt;

&lt;h4&gt;4.6.6 慢查询日志相关配置(SLOW LOG)&lt;/h4&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;### SLOW LOG ###
slowlog-log-slower-than 10000    #当命令的执行超过了指定时间，单位是微秒；1s=10^6微秒
slowlog-max-len 128   #慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录会被删掉。
ADVANCED配置：
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
设置ziplist的键数量最大值，每个值的最大空间；
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;慢查询日志相关配置&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211143347-1607945768.png&quot; alt=&quot;慢查询日志相关配置&quot; name=&quot;images/1513999365568.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;慢查询日志相关配置&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;4.7 redis命令介绍&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;└── bin&lt;br/&gt;├── redis-benchmark #redis性能测试工具，可以测试在本系统本配置下的读写性能&lt;br/&gt;├── redis-check-aof #对更新日志appendonly.aof检查，是否可用&lt;br/&gt;├── redis-check-dump #用于检查本地数据库的rdb文件&lt;br/&gt;├── redis-cli #redis命令行操作工具，也可以用telnet根据其纯文本协议来操作&lt;br/&gt;├── redis-sentinel Redis-sentinel 是Redis实例的监控管理、通知和实例失效备援服务，是Redis集群的管理工具&lt;br/&gt;└── redis-server #redis服务器的daemon启动程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;4.7.1 redis-cli命令介绍&lt;/h4&gt;
&lt;blockquote readability=&quot;7.984934086629&quot;&gt;
&lt;p&gt;redis-cli -p 6379　　#默认选择 db库是 0&lt;br/&gt;redis 127.0.0.1:6379&amp;gt; keys *　　#查看当前所在“db库”所有的缓存key&lt;br/&gt;redis 127.0.0.1:6379&amp;gt; select 8　　#选择 db库&lt;br/&gt;redis 127.0.0.1:6379&amp;gt; FLUSHALL　　#清除所有的缓存key&lt;br/&gt;redis 127.0.0.1:6379&lt;a href=&quot;http://www.cnblogs.com/keerya/p/images/1513993126970.jpg&quot; target=&quot;_blank&quot;&gt;8&lt;/a&gt;&amp;gt; FLUSHDB　　#清除当前“db库”所有的缓存key&lt;br/&gt;redis 127.0.0.1:6379&amp;gt; set keyname keyvalue　　#设置缓存值&lt;br/&gt;redis 127.0.0.1:6379&amp;gt; get keyname #获取缓存值&lt;br/&gt;redis 127.0.0.1:6379&amp;gt; del keyname #删除缓存值：返回删除数量（0代表没删除）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务端的相关命令：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;time&lt;/code&gt;：返回当前服务器时间&lt;br/&gt;&lt;code&gt;client list&lt;/code&gt;: 返回所有连接到服务器的客户端信息和统计数据 参见http://redisdoc.com/server/client_list.html&lt;br/&gt;&lt;code&gt;client kill ip:port&lt;/code&gt;：关闭地址为 ip:port 的客户端&lt;br/&gt;&lt;code&gt;save&lt;/code&gt;：将数据同步保存到磁盘&lt;br/&gt;&lt;code&gt;bgsave&lt;/code&gt;：将数据异步保存到磁盘&lt;br/&gt;&lt;code&gt;lastsave&lt;/code&gt;：返回上次成功将数据保存到磁盘的Unix时戳&lt;br/&gt;&lt;code&gt;shundown&lt;/code&gt;：将数据同步保存到磁盘，然后关闭服务&lt;br/&gt;&lt;code&gt;info&lt;/code&gt;：提供服务器的信息和统计&lt;br/&gt;&lt;code&gt;config resetstat&lt;/code&gt;：重置info命令中的某些统计数据&lt;br/&gt;&lt;code&gt;config get&lt;/code&gt;：获取配置文件信息&lt;br/&gt;&lt;code&gt;config set&lt;/code&gt;：动态地调整 Redis 服务器的配置(configuration)而无须重启，可以修改的配置参数可以使用命令 CONFIG GET * 来列出&lt;br/&gt;&lt;code&gt;config rewrite&lt;/code&gt;：Redis 服务器时所指定的 redis.conf 文件进行改写&lt;br/&gt;&lt;code&gt;monitor&lt;/code&gt;：实时转储收到的请求&lt;br/&gt;&lt;code&gt;slaveof&lt;/code&gt;：改变复制策略设置&lt;br/&gt;&lt;code&gt;debug&lt;/code&gt;：sleep segfault&lt;br/&gt;&lt;code&gt;slowlog get&lt;/code&gt;：获取慢查询日志&lt;br/&gt;&lt;code&gt;slowlog len&lt;/code&gt;：获取慢查询日志条数&lt;br/&gt;&lt;code&gt;slowlog reset&lt;/code&gt;：清空慢查询&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;4.8 redis 常用数据类型&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;redis 常用数据类型&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211143722-577865140.png&quot; alt=&quot;redis 常用数据类型&quot; name=&quot;images/1514012899234.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;redis 常用数据类型&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　Redis内部使用一个redisObject对象来表示所有的key和value,redisObject最主要的信息如上图所示：&lt;br/&gt;　　&lt;span&gt;type代表一个value对象具体是何种数据类型&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;encoding是不同数据类型在redis内部的存储方式&lt;/span&gt;&lt;br/&gt;　　比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int,如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:“123” &quot;456&quot;这样的字符串。&lt;br/&gt;　　&lt;span&gt;Redis的键值可以使用物种数据类型：字符串，散列表，列表，集合，有序集合。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;4.8.1 对KEY操作的命令&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;exists(key)&lt;/code&gt;：确认一个key是否存在&lt;br/&gt;&lt;code&gt;del(key)&lt;/code&gt;：删除一个key&lt;br/&gt;&lt;code&gt;type(key)&lt;/code&gt;：返回值的类型&lt;br/&gt;&lt;code&gt;keys(pattern)&lt;/code&gt;：返回满足给定pattern的所有key&lt;br/&gt;&lt;code&gt;randomkey&lt;/code&gt;：随机返回key空间的一个&lt;br/&gt;&lt;code&gt;keyrename(oldname, newname)&lt;/code&gt;：重命名key&lt;br/&gt;&lt;code&gt;dbsize&lt;/code&gt;：返回当前数据库中key的数目&lt;br/&gt;&lt;code&gt;expire&lt;/code&gt;：设定一个key的活动时间（s）&lt;br/&gt;&lt;code&gt;ttl&lt;/code&gt;：获得一个key的活动时间&lt;br/&gt;&lt;code&gt;move(key, dbindex)&lt;/code&gt;：移动当前数据库中的key到dbindex数据库&lt;br/&gt;&lt;code&gt;flushdb&lt;/code&gt;：删除当前选择数据库中的所有key&lt;br/&gt;&lt;code&gt;flushall&lt;/code&gt;：删除所有数据库中的所有key&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;4.8.2 对String操作的命令&lt;/h4&gt;
&lt;p&gt;　　应用场景：String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类.即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：&lt;/p&gt;
&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span&gt;set(key, value)：给数据库中名称为key的string赋予值value&lt;br/&gt;get(key)：返回数据库中名称为key的string的value&lt;/span&gt;&lt;br/&gt;&lt;code&gt;getset(key, value)&lt;/code&gt;：给名称为key的string赋予上一次的value&lt;br/&gt;&lt;code&gt;mget(key1, key2,…, key N)&lt;/code&gt;：返回库中多个string的value&lt;br/&gt;&lt;code&gt;setnx(key, value)&lt;/code&gt;：添加string，名称为key，值为value&lt;br/&gt;&lt;code&gt;setex(key, time, value)&lt;/code&gt;：向库中添加string，设定过期时间time&lt;br/&gt;&lt;code&gt;mset(key N, value N)&lt;/code&gt;：批量设置多个string的值&lt;br/&gt;&lt;code&gt;msetnx(key N, value N)&lt;/code&gt;：如果所有名称为key i的string都不存在&lt;br/&gt;&lt;code&gt;incr(key)&lt;/code&gt;：名称为key的string增1操作&lt;br/&gt;&lt;code&gt;incrby(key, integer)&lt;/code&gt;：名称为key的string增加integer&lt;br/&gt;&lt;code&gt;decr(key)&lt;/code&gt;：名称为key的string减1操作&lt;br/&gt;&lt;code&gt;decrby(key, integer)&lt;/code&gt;：名称为key的string减少integer&lt;br/&gt;&lt;code&gt;append(key, value)&lt;/code&gt;：名称为key的string的值附加value&lt;br/&gt;&lt;code&gt;substr(key, start, end)&lt;/code&gt;：返回名称为key的string的value的子串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;4.8.3 对Hash操作的命令&lt;/h4&gt;
&lt;p&gt;　　应用场景：在Memcached中，我们经常将一些结构化的信息打包成HashMap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code&gt;hset(key, field, value)&lt;/code&gt;：向名称为key的hash中添加元素field&lt;br/&gt;&lt;code&gt;hget(key, field)&lt;/code&gt;：返回名称为key的hash中field对应的value&lt;br/&gt;&lt;code&gt;hmget(key, (fields))&lt;/code&gt;：返回名称为key的hash中field i对应的value&lt;br/&gt;&lt;code&gt;hmset(key, (fields))&lt;/code&gt;：向名称为key的hash中添加元素field&lt;br/&gt;&lt;code&gt;hincrby(key, field, integer)&lt;/code&gt;：将名称为key的hash中field的value增加integer&lt;br/&gt;&lt;code&gt;hexists(key, field)&lt;/code&gt;：名称为key的hash中是否存在键为field的域&lt;br/&gt;&lt;code&gt;hdel(key, field)&lt;/code&gt;：删除名称为key的hash中键为field的域&lt;br/&gt;&lt;code&gt;hlen(key)&lt;/code&gt;：返回名称为key的hash中元素个数&lt;br/&gt;&lt;code&gt;hkeys(key)&lt;/code&gt;：返回名称为key的hash中所有键&lt;br/&gt;&lt;code&gt;hvals(key)&lt;/code&gt;：返回名称为key的hash中所有键对应的value&lt;br/&gt;&lt;code&gt;hgetall(key)&lt;/code&gt;：返回名称为key的hash中所有的键（field）及其对应的value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;4.8.4 对List操作的命令&lt;/h4&gt;
&lt;p&gt;　　Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。我们在看完一条微博之后，常常会评论一番，或者看看其他人的吐槽。每条评论的记录都是按照时间顺序排序的。&lt;br/&gt;　　具体操作命令如下：&lt;/p&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;&lt;code&gt;rpush(key, value)&lt;/code&gt;：在名称为key的list尾添加一个值为value的元素&lt;br/&gt;&lt;code&gt;lpush(key, value)&lt;/code&gt;：在名称为key的list头添加一个值为value的 元素&lt;br/&gt;&lt;code&gt;llen(key)&lt;/code&gt;：返回名称为key的list的长度&lt;br/&gt;&lt;code&gt;lrange(key, start, end)&lt;/code&gt;：返回名称为key的list中start至end之间的元素&lt;br/&gt;&lt;code&gt;ltrim(key, start, end)&lt;/code&gt;：截取名称为key的list&lt;br/&gt;&lt;code&gt;lindex(key, index)&lt;/code&gt;：返回名称为key的list中index位置的元素&lt;br/&gt;&lt;code&gt;lset(key, index, value)&lt;/code&gt;：给名称为key的list中index位置的元素赋值&lt;br/&gt;&lt;code&gt;lrem(key, count, value)&lt;/code&gt;：删除count个key的list中值为value的元素&lt;br/&gt;&lt;code&gt;lpop(key)&lt;/code&gt;：返回并删除名称为key的list中的首元素&lt;br/&gt;&lt;code&gt;rpop(key)&lt;/code&gt;：返回并删除名称为key的list中的尾元素&lt;br/&gt;&lt;code&gt;blpop(key1, key2,… key N, timeout)&lt;/code&gt;：lpop命令的block版本。&lt;br/&gt;&lt;code&gt;brpop(key1, key2,… key N, timeout)&lt;/code&gt;：rpop的block版本。&lt;br/&gt;&lt;code&gt;rpoplpush(srckey, dstkey)&lt;/code&gt;：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;4.8.5 对Set操作的命令&lt;/h4&gt;
&lt;p&gt;　　Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据。比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。因为 Redis 非常人性化的为集合提供了求交集、并集、差集等操作，那么就可以非常方便的实现如共同关注、共同喜好、二度好友等功能。&lt;br/&gt;　　具体操作命令如下：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;code&gt;sadd(key, member)&lt;/code&gt;：向名称为key的set中添加元素member&lt;br/&gt;&lt;code&gt;srem(key, member)&lt;/code&gt;：删除名称为key的set中的元素member&lt;br/&gt;&lt;code&gt;spop(key)&lt;/code&gt;：随机返回并删除名称为key的set中一个元素&lt;br/&gt;&lt;code&gt;smove(srckey, dstkey, member)&lt;/code&gt;：移到集合元素&lt;br/&gt;&lt;code&gt;scard(key)&lt;/code&gt;：返回名称为key的set的基数&lt;br/&gt;&lt;code&gt;sismember(key, member)&lt;/code&gt;：member是否是名称为key的set的元素&lt;br/&gt;&lt;code&gt;sinter(key1, key2,…key N)&lt;/code&gt;：求交集&lt;br/&gt;&lt;code&gt;sinterstore(dstkey, (keys))&lt;/code&gt;：求交集并将交集保存到dstkey的集合&lt;br/&gt;&lt;code&gt;sunion(key1, (keys))&lt;/code&gt;：求并集&lt;br/&gt;&lt;code&gt;sunionstore(dstkey, (keys))&lt;/code&gt;：求并集并将并集保存到dstkey的集合&lt;br/&gt;&lt;code&gt;sdiff(key1, (keys))&lt;/code&gt;：求差集&lt;br/&gt;&lt;code&gt;sdiffstore(dstkey, (keys))&lt;/code&gt;：求差集并将差集保存到dstkey的集合&lt;br/&gt;&lt;code&gt;smembers(key)&lt;/code&gt;：返回名称为key的set的所有元素&lt;br/&gt;&lt;code&gt;srandmember(key)&lt;/code&gt;：随机返回名称为key的set的一个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;五、redis 主从复制&lt;/h2&gt;

&lt;h3&gt;5.1 方式简介&lt;/h3&gt;
&lt;p&gt;　　Redis的复制方式有两种，一种是主（master）-从（slave）模式，一种是从（slave）-从（slave）模式，因此Redis的复制拓扑图会丰富一些，可以像星型拓扑，也可以像个有向无环。一个Master可以有多个slave主机，支持链式复制；Master以非阻塞方式同步数据至slave主机；&lt;br/&gt;　　拓扑图如下：&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;拓扑图&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211144191-1234408619.png&quot; alt=&quot;拓扑图&quot; name=&quot;images/1514014783408.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;拓扑图&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;5.2 复制优点&lt;/h3&gt;
&lt;p&gt;　　通过配置多个Redis实例，数据备份在不同的实例上，主库专注写请求，从库负责读请求，这样的好处主要体现在下面几个方面&lt;br/&gt;&lt;strong&gt;1. 高可用性&lt;/strong&gt;&lt;br/&gt;　　在一个Redis集群中，如果master宕机，slave可以介入并取代master的位置，因此对于整个Redis服务来说不至于提供不了服务，这样使得整个Redis服务足够安全。&lt;br/&gt;&lt;strong&gt;2. 高性能&lt;/strong&gt;&lt;br/&gt;　　在一个Redis集群中，master负责写请求，slave负责读请求，这么做一方面通过将读请求分散到其他机器从而大大减少了master服务器的压力，另一方面slave专注于提供读服务从而提高了响应和读取速度。&lt;br/&gt;&lt;strong&gt;3. 水平扩展性&lt;/strong&gt;&lt;br/&gt;　　通过增加slave机器可以横向（水平）扩展Redis服务的整个查询服务的能力。&lt;/p&gt;

&lt;h3&gt;5.3 需要解决的问题&lt;/h3&gt;
&lt;p&gt;　　复制提供了高可用性的解决方案，但同时引入了分布式计算的复杂度问题，认为有两个核心问题：&lt;br/&gt;&lt;strong&gt;1. 数据一致性问题：&lt;/strong&gt; 如何保证master服务器写入的数据能够及时同步到slave机器上。&lt;br/&gt;&lt;strong&gt;2. 读写分离：&lt;/strong&gt; 如何在客户端提供读写分离的实现方案，通过客户端实现将读写请求分别路由到master和slave实例上。&lt;br/&gt;　　上面两个问题，尤其是第一个问题是Redis服务实现一直在演变，致力于解决的一个问题：&lt;strong&gt;复制实时性和数据一致性矛盾&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　Redis提供了提高数据一致性的解决方案，一致性程度的增加虽然使得我能够更信任数据，但是更好的一致性方案通常伴随着性能的损失，从而减少了吞吐量和服务能力。然而我们希望系统的性能达到最优，则必须要牺牲一致性的程度，因此Redis的复制实时性和数据一致性是存在矛盾的。&lt;/p&gt;

&lt;h3&gt;5.4 具体实例见&lt;a href=&quot;http://www.cnblogs.com/keerya/p/8127716.html#jump&quot;&gt;实战一&lt;/a&gt;&lt;/h3&gt;

&lt;h2&gt;六、redis集群cluster&lt;/h2&gt;
&lt;p&gt;　　如何解决redis横向扩展的问题----redis集群实现方式&lt;/p&gt;

&lt;h3&gt;6.1 实现基础——分区&lt;/h3&gt;
&lt;p&gt;　　分区是分割数据到多个Redis实例的处理过程，因此每个实例只保存key的一个子集。通过利用多台计算机内存的和值，允许我们构造更大的数据库。通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允许我们扩展网络带宽。&lt;br/&gt;　　集群的几种实现方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端分片&lt;/li&gt;
&lt;li&gt;基于代理的分片&lt;/li&gt;
&lt;li&gt;路由查询&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;6.1.1 客户端分片&lt;/h4&gt;
&lt;p&gt;　　由客户端决定key写入或者读取的节点。&lt;br/&gt;　　包括jedis在内的一些客户端，实现了客户端分片机制。&lt;br/&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;br/&gt;　　简单，性能高&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br/&gt;　　1. 业务逻辑与数据存储逻辑耦合&lt;br/&gt;　　2. 可运维性差&lt;br/&gt;　　3. 多业务各自使用redis，集群资源难以管理&lt;br/&gt;　　4. 不支持动态增删节点&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;客户端分片&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211144550-507316434.png&quot; alt=&quot;客户端分片&quot; name=&quot;images/1514018160977.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;客户端分片&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;6.1.2 基于代理的分片&lt;/h4&gt;
&lt;p&gt;　　客户端发送请求到一个代理，代理解析客户端的数据，将请求转发至正确的节点，然后将结果回复给客户端。&lt;br/&gt;&lt;strong&gt;开源方案&lt;/strong&gt;&lt;br/&gt;　　1. Twemproxy&lt;br/&gt;　　2. codis&lt;br/&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;br/&gt;　　1. 透明接入&lt;br/&gt;　　2. 业务程序不用关心后端Redis实例，切换成本低。&lt;br/&gt;　　3. Proxy 的逻辑和存储的逻辑是隔离的。&lt;br/&gt;　　4. 代理层多了一次转发，性能有所损耗。&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;基于代理的分片&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211144831-296245770.png&quot; alt=&quot;基于代理的分片&quot; name=&quot;images/1514018255362.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;基于代理的分片&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Twemproxy&lt;/strong&gt;&lt;br/&gt;　　Proxy-based&lt;br/&gt;　　twtter开源，C语言编写，单线程。&lt;br/&gt;　　支持 Redis 或 Memcached 作为后端存储。&lt;br/&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br/&gt;　　1. 支持失败节点自动删除&lt;br/&gt;　　2. 与redis的长连接，连接复用，连接数可配置&lt;br/&gt;　　3. 自动分片到后端多个redis实例上&lt;br/&gt;　　4. 多种hash算法：能够使用不同的分片策略和散列函数&lt;br/&gt;　　5. 可以设置后端实例的权重&lt;br/&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br/&gt;　　1. 性能低：代理层损耗 &amp;amp;&amp;amp; 本身效率低下&lt;br/&gt;　　2. Redis功能支持不完善：不支持针对多个值的操作&lt;br/&gt;　　3. 本身不提供动态扩容，透明数据迁移等功能&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Twemproxy&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211145253-1916113274.png&quot; alt=&quot;Twemproxy&quot; name=&quot;images/1514163008410.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Twemproxy&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Codis&lt;/strong&gt;&lt;br/&gt;　　Codis由豌豆荚于2014年11月开源，基于Go和C开发，是近期涌现的、国人开发的优秀开源软件之一。现已广泛用于豌豆荚的各种Redis业务场景。从3个月的各种压力测试来看，稳定性符合高效运维的要求。性能更是改善很多，最初比Twemproxy慢20%；现在比Twemproxy快近100%（条件：多实例，一般Value长度）。&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Codis&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211145706-1731016168.png&quot; alt=&quot;Codis&quot; name=&quot;images/1514163076261.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Codis&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;6.2 开源方案——Redis-cluster&lt;/h3&gt;
&lt;p&gt;　　将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行。&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Redis-cluster原理图&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211146128-722104707.png&quot; alt=&quot;Redis-cluster原理图&quot; name=&quot;images/1514163165992.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Redis-cluster原理图&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　Redis-cluster由redis官网推出，可线性扩展到1000个节点。无中心架构；使用一致性哈希思想；客户端直连redis服务，免去了proxy代理的损耗。&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;Redis-cluster架构&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211146816-1885849069.png&quot; alt=&quot;Redis-cluster架构&quot; name=&quot;images/1514163376258.jpg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Redis-cluster架构&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h4&gt;6.2.1 Redis集群介绍&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;Redis 集群是一个提供在多个Redis间节点间共享数据的程序集。&lt;/strong&gt;&lt;br/&gt;　　Redis 集群并不支持处理多个keys的命令，因为这需要在不同的节点间移动数据，从而达不到像Redis那样的性能，在高负载的情况下可能会导致不可预料的错误。&lt;br/&gt;　　Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令.&lt;br/&gt;&lt;strong&gt;Redis 集群的优势:&lt;/strong&gt;&lt;br/&gt;　　1. 自动分割数据到不同的节点上。&lt;br/&gt;　　2. 整个集群的部分节点失败或者不可达的情况下能够继续处理命令。&lt;br/&gt;&lt;strong&gt;Redis 集群的数据分片&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;Redis 集群没有使用一致性hash，而是引入了哈希槽的概念.&lt;/strong&gt;&lt;br/&gt;　　Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽。集群的每个节点负责一部分hash槽。&lt;/span&gt;举个例子,比如当前集群有3个节点,那么:&lt;br/&gt;　　节点 A 包含 0 到 5500号哈希槽。&lt;br/&gt;　　节点 B 包含5501 到 11000 号哈希槽。&lt;br/&gt;　　节点 C 包含11001 到 16384号哈希槽。&lt;br/&gt;　　这种结构很容易添加或者删除节点。比如如果我想新添加个节点D，我需要从节点 A，B，C中得部分槽到D上。如果我想移除节点A，需要将A中得槽移到B和C节点上，然后将没有任何槽的A节点从集群中移除即可。由于从一个节点将哈希槽移动到另一个节点并不会停止服务，所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态。&lt;/p&gt;

&lt;h4&gt;6.2.2 Redis 集群的主从复制模型&lt;/h4&gt;
&lt;p&gt;　　为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品。&lt;br/&gt;　　在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。&lt;br/&gt;　　然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了。不过当B和B1 都失败后，集群是不可用的。&lt;br/&gt;Redis 一致性保证&lt;br/&gt;　　Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作。&lt;br/&gt;　　第一个原因是因为集群是用了异步复制. 写操作过程:&lt;br/&gt;　　客户端向主节点B写入一条命令.&lt;br/&gt;　　主节点B向客户端回复命令状态.&lt;br/&gt;　　主节点将写操作复制给他得从节点 B1, B2 和 B3.&lt;br/&gt;　　主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话，那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。注意：Redis 集群可能会在将来提供同步写的方法。Redis 集群另外一种可能会丢失命令的情况是集群出现了网络分区， 并且一个客户端与至少包括一个主节点在内的少数实例被孤立。&lt;/p&gt;


&lt;h2&gt;实战一：redis主从复制的实现&lt;/h2&gt;

&lt;h3&gt;1）原理架构图&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;原理架构图&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211147144-1918203865.png&quot; alt=&quot;原理架构图&quot; name=&quot;images/1_1.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;原理架构图&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　上图为Redis复制工作过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;slave向master发送sync命令。&lt;/li&gt;
&lt;li&gt;master开启子进程来讲dataset写入rdb文件，同时将子进程完成之前接收到的写命令缓存起来。&lt;/li&gt;
&lt;li&gt;子进程写完，父进程得知，开始将RDB文件发送给slave。master发送完RDB文件，将缓存的命令也发给slave。master增量的把写命令发给slave。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　值得注意的是，当slave跟master的连接断开时，slave可以自动的重新连接master，&lt;span&gt;在redis2.8版本之前，每当slave进程挂掉重新连接master的时候都会开始新的一轮全量复制&lt;/span&gt;。如果master同时接收到多个slave的同步请求，则master只需要备份一次RDB文件。&lt;/p&gt;

&lt;h3&gt;2）实验准备&lt;/h3&gt;
&lt;dl&gt;&lt;dt&gt;环境准备&lt;/dt&gt;
&lt;dd&gt;centos系统服务器2台、 一台用于做redis主服务器， 一台用于做redis从服务器， 配置好yum源、 防火墙关闭、 各节点时钟服务同步、 各节点之间可以通过主机名互相通信。&lt;/dd&gt;
&lt;dt&gt;具体设置如下&lt;/dt&gt;
&lt;dd&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;机器名称&lt;/th&gt;
&lt;th&gt;IP配置&lt;/th&gt;
&lt;th&gt;服务角色&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;redis-master&lt;/td&gt;
&lt;td&gt;192.168.37.111&lt;/td&gt;
&lt;td&gt;redis主服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave1&lt;/td&gt;
&lt;td&gt;192.168.37.122&lt;/td&gt;
&lt;td&gt;文件存放&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave2&lt;/td&gt;
&lt;td&gt;192.168.37.133&lt;/td&gt;
&lt;td&gt;文件存放&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3&gt;3）在所有机器上进行基本配置&lt;/h3&gt;
&lt;p&gt;　　首先，在所有机器上安装&lt;code&gt;redis&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;yum install -y redis
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们把配置文件备份一下，这样便于我们日后的恢复，&lt;strong&gt;是一个好习惯！&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;cp /etc/redis.conf{,.back} 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着，我们去修改一下配置文件，更改如下配置：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;vim /etc/redis.conf   #配置配置文件，修改2项
        bind 0.0.0.0   #监听地址（可以写0.0.0.0，监听所有地址；也可以各自写各自的IP）
        daemonize yes   #后台守护进程运行
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三台机器都进行修改以后，本步骤完成。&lt;/p&gt;

&lt;h3&gt;4）配置从服务器&lt;/h3&gt;
&lt;p&gt;　　我们还需要在从服务器上进行一些配置来实现主从同步，具体操作步骤如下：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;vim /etc/redis.conf
        ### REPLICATION ###                     在这一段修改
        slaveof 192.168.30.107 6379                     #设置主服务器的IP和端口号
        #masterauth &amp;lt;master-password&amp;gt;   #如果设置了访问认证就需要设定此项。
        slave-serve-stale-data yes   #当slave与master连接断开或者slave正处于同步状态时，如果slave收到请求允许响应，no表示返回错误。
        slave-read-only yes   #slave节点是否为只读。
        slave-priority 100   #设定此节点的优先级，是否优先被同步。
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5）查询并测试&lt;/h3&gt;
&lt;p&gt;1、打开所有机器上的&lt;code&gt;redis&lt;/code&gt;服务：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;   systemctl start redis
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、在主上登录查询主从消息，确认主从是否已实现：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# redis-cli -h 192.168.37.111
192.168.37.111:6379&amp;gt; info replication
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;查看主从&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211147347-909292040.png&quot; alt=&quot;查看主从&quot; name=&quot;images/2.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;查看主从&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3、日志中也可以查看到：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# tail /var/log/redis/redis.log
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;日志查看主从信息&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211147581-2067274377.png&quot; alt=&quot;日志查看主从信息&quot; name=&quot;images/3.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;日志查看主从信息&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4、测试主从&lt;br/&gt;　　在主上置一个&lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# redis-cli -h 192.168.37.111
192.168.37.111:6379&amp;gt; set master test
OK
192.168.37.111:6379&amp;gt; get master
&quot;test&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后去从上查询，如果能够查询到，则说明成功：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave1 ~]# redis-cli         #因为我们设置的监听地址是0.0.0.0，所以不需要输入-h
127.0.0.1:6379&amp;gt; get master
&quot;test&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6）高级配置（根据自己的需要进行设置）&lt;/h3&gt;
&lt;p&gt;1、一个&lt;strong&gt;RDB文件&lt;/strong&gt;从 master 端传到 slave 端，分为两种情况：&lt;br/&gt;① 支持disk：master 端将 RDB file 写到 disk，稍后再传送到 slave 端；&lt;br/&gt;② 无磁盘diskless：master端直接将RDB file 传到 slave socket，不需要与 disk 进行交互。&lt;br/&gt;　　无磁盘diskless 方式适合磁盘读写速度慢但网络带宽非常高的环境。&lt;br/&gt;2、设置：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;repl-diskless-sync no   #默认不使用diskless同步方式
repl-diskless-sync-delay 5   #无磁盘diskless方式在进行数据传递之前会有一个时间的延迟，以便slave端能够进行到待传送的目标队列中，这个时间默认是5秒
repl-ping-slave-period 10   #slave端向server端发送pings的时间区间设置，默认为10秒
repl-timeout 60   #设置超时时间
min-slaves-to-write 3   #主节点仅允许其能够通信的从节点数量大于等于此处的值时接受写操作；
min-slaves-max-lag 10   #从节点延迟时长超出此处指定的时长时，主节点会拒绝写入操作；
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;实战二：Sentinel（哨兵）实现Redis的高可用性&lt;/h2&gt;

&lt;h3&gt;1）原理及架构图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、原理&lt;/strong&gt;&lt;br/&gt;　　Sentinel（哨兵）是Redis的高可用性（HA）解决方案，由&lt;strong&gt;一个或多个Sentinel实例&lt;/strong&gt;组成的Sentinel系统可以&lt;strong&gt;监视任意多个主服务器&lt;/strong&gt;，以及这些主服务器属下的所有从服务器，并在被监视的&lt;strong&gt;主服务器&lt;/strong&gt;进行&lt;strong&gt;下线状态&lt;/strong&gt;时，&lt;strong&gt;自动&lt;/strong&gt;将下线主服务器属下的某个&lt;span&gt;从服务器升级为新的主服务器&lt;/span&gt;，然后由&lt;strong&gt;新的主&lt;/strong&gt;服务器&lt;strong&gt;代替&lt;/strong&gt;已&lt;strong&gt;下线的主&lt;/strong&gt;服务器继续处理命令请求。&lt;br/&gt;Redis提供的sentinel（哨兵）机制，通过sentinel模式启动redis后，自动监控master/slave的运行状态，基本原理是：&lt;span&gt;心跳机制+投票裁决&lt;/span&gt;&lt;br/&gt;① &lt;strong&gt;监控&lt;/strong&gt;（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。&lt;br/&gt;② &lt;strong&gt;提醒&lt;/strong&gt;（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。&lt;br/&gt;③ &lt;strong&gt;自动故障迁移&lt;/strong&gt;（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会&lt;strong&gt;将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器&lt;/strong&gt;； 当客户端试图连接失效的主服务器时， &lt;strong&gt;集群也会向客户端返回新主服务器的地址&lt;/strong&gt;， 使得集群可以使用新主服务器代替失效服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、架构流程图&lt;/strong&gt;&lt;br/&gt;① 正常的主从服务&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;主从服务&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211147956-455143359.png&quot; alt=&quot;主从服务&quot; name=&quot;images/4.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;主从服务&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;② sentinel 监控到主 redis 下线&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;主 redis 下线&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211148316-640936771.png&quot; alt=&quot;主 redis 下线&quot; name=&quot;images/5.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;主 redis 下线&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;③ 由优先级升级新主&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;故障转移&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211148691-1662013545.png&quot; alt=&quot;故障转移&quot; name=&quot;images/6.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;故障转移&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;④ 旧主修复，作为从 redis，新主照常工作&lt;/p&gt;
&lt;div class=&quot;story_align_center&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot; readability=&quot;32&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;旧主作为从加入集群&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211149066-420383900.png&quot; alt=&quot;旧主作为从加入集群&quot; name=&quot;images/7.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;旧主作为从加入集群&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;2）实验准备&lt;/h3&gt;
&lt;dl&gt;&lt;dt&gt;环境准备&lt;/dt&gt;
&lt;dd&gt;centos系统服务器2台、 一台用于做redis主服务器， 一台用于做redis从服务器， 配置好yum源、 防火墙关闭、 各节点时钟服务同步、 各节点之间可以通过主机名互相通信。&lt;/dd&gt;
&lt;dt&gt;具体设置如下&lt;/dt&gt;
&lt;dd&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;机器名称&lt;/th&gt;
&lt;th&gt;IP配置&lt;/th&gt;
&lt;th&gt;服务角色&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;redis-master&lt;/td&gt;
&lt;td&gt;192.168.37.111&lt;/td&gt;
&lt;td&gt;redis主服务器&lt;/td&gt;
&lt;td&gt;开启sentinel&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave1&lt;/td&gt;
&lt;td&gt;192.168.37.122&lt;/td&gt;
&lt;td&gt;文件存放&lt;/td&gt;
&lt;td&gt;开启sentinel&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave2&lt;/td&gt;
&lt;td&gt;192.168.37.133&lt;/td&gt;
&lt;td&gt;文件存放&lt;/td&gt;
&lt;td&gt;开启sentinel&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3&gt;3）按照实验一实现主从&lt;/h3&gt;
&lt;p&gt;1、打开所有机器上的 redis 服务&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;   systemctl start redis
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、在主上登录查询主从关系，确定主从已经实现&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# redis-cli -h 192.168.37.111
192.168.37.111:6379&amp;gt; info replication
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;查看主从&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211149253-1079242610.png&quot; alt=&quot;查看主从&quot; name=&quot;images/2_1.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;查看主从&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;4）在任一机器上配置 sentinel 哨兵&lt;/h3&gt;
&lt;p&gt;1、配置 sentinel&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;vim /etc/redis-sentinel.conf  
        port 26379   #默认监听端口26379
        #sentinel announce-ip 1.2.3.4   #监听地址，注释默认是0.0.0.0
        sentinel monitor mymaster &lt;strong&gt;192.168.30.107&lt;/strong&gt; 6379 &lt;strong&gt;1&lt;/strong&gt;   #指定主redis和投票裁决的机器数，即至少有1个sentinel节点同时判定主节点故障时，才认为其真的故障
#下面部分保持默认即可，也可以根据自己的需求修改
        sentinel down-after-milliseconds mymaster 5000   #如果联系不到节点5000毫秒，我们就认为此节点下线。
        sentinel failover-timeout mymaster 60000   #设定转移主节点的目标节点的超时时长。
        sentinel auth-pass &amp;lt;master-name&amp;gt; &amp;lt;password&amp;gt;   #如果redis节点启用了auth，此处也要设置password。
        sentinel parallel-syncs &amp;lt;master-name&amp;gt; &amp;lt;numslaves&amp;gt;   #指在failover过程中，能够被sentinel并行配置的从节点的数量；
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：只需指定主机器的IP，等sentinel 服务开启，它能自己查询到主上的从redis；并能完成自己的操作&lt;/p&gt;
&lt;p&gt;2、指定优先级&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;vim /etc/redis.conf   根据自己的需求设置优先级
        slave-priority 100  #复制集群中，主节点故障时，sentinel应用场景中的主节点选举时使用的优先级
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：&lt;span&gt;数字越小优先级越高&lt;/span&gt;，但&lt;strong&gt;0表示不参与选举&lt;/strong&gt;；当优先级一样时，随机选举。&lt;/p&gt;

&lt;h3&gt;5）开启 sentinel 服务&lt;/h3&gt;
&lt;p&gt;1、开启服务&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;   systemctl start redis-sentinel
        ss -nutl | grep 6379
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、开启服务以后，在/etc/redis-sentinel.conf这个配置文件中会生成从redis的信息&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;# Generated by CONFIG REWRITE                      #在配置文件的末尾
sentinel known-slave mymaster 192.168.37.122 6379
sentinel known-slave mymaster 192.168.37.133 6379
sentinel current-epoch 0
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6）模拟主故障，进行测试&lt;/h3&gt;
&lt;p&gt;1、模拟主 redis-master 故障&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# ps -ef | grep redis
redis      5635      1  0 19:33 ?        00:00:06 /usr/bin/redis-sentinel *:26379 [sentinel]
redis      5726      1  0 19:39 ?        00:00:02 /usr/bin/redis-server 0.0.0.0:6379
root       5833   5324  0 19:52 pts/0    00:00:00 grep --color=auto redis
[root@master ~]# kill 5726
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、新主生成&lt;br/&gt;a.去查看主是谁&lt;br/&gt;　　在任一机器查看均可，如果是仍然是从，则可以看到主的IP，如果是新主，则可以看到两个从的IP。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave1 ~]# redis-cli info replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.37.133,port=6379,state=online,offset=87000,lag=1
slave1:ip=192.168.37.111,port=6379,state=online,offset=87000,lag=0
master_repl_offset:87000
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:86999
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.在新主上查询日志&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave1 ~]# tail -200 /var/log/redis/redis.log
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;新主的日志&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211149613-22139484.png&quot; alt=&quot;新主的日志&quot; name=&quot;images/8.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;新主的日志&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;c.从升级为新主的过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步旧主一直失败&lt;/li&gt;
&lt;li&gt;主模块加载，生成新主&lt;/li&gt;
&lt;li&gt;另一个从请求同步连接&lt;/li&gt;
&lt;li&gt;从同步连接成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;d.也可以通过&lt;code&gt;sentinel&lt;/code&gt;专门的日志查看，下一步有截图。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;   tail /var/log/redis/sentinel.log
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;7）旧主修复，变为从&lt;/h3&gt;
&lt;p&gt;　　此时，我们把旧主的服务重新开启，用来模拟故障的修复：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# systemctl start redis
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后我们来查看日志：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# tail -20 /var/log/redis/redis.log
5726:S 12 Dec 19:39:44.404 * &lt;strong&gt;Connecting to MASTER 192.168.37.122:6379&lt;/strong&gt;
5726:S 12 Dec 19:39:44.405 * MASTER &amp;lt;-&amp;gt; SLAVE sync started
5726:S 12 Dec 19:39:44.405 * Non blocking connect for SYNC fired the event.
5726:S 12 Dec 19:39:44.408 * Master replied to PING, replication can continue...
5726:S 12 Dec 19:39:44.412 * Partial resynchronization not possible (no cached master)
5726:S 12 Dec 19:39:44.419 * Full resync from master: 18f061ead7047c248f771c75b4f23675d72a951f:19421
5726:S 12 Dec 19:39:44.510 * MASTER &amp;lt;-&amp;gt; SLAVE sync: receiving 107 bytes from master
5726:S 12 Dec 19:39:44.510 * MASTER &amp;lt;-&amp;gt; SLAVE sync: Flushing old data
5726:S 12 Dec 19:39:44.511 * MASTER &amp;lt;-&amp;gt; SLAVE sync: Loading DB in memory
5726:S 12 Dec 19:39:44.511 * MASTER &amp;lt;-&amp;gt; SLAVE sync: Finished with success
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，我们的旧主修复过后，就变成了从，去连接新主。&lt;/p&gt;

&lt;h3&gt;8）新主发生故障，会继续寻找一个从升为新主&lt;/h3&gt;
&lt;p&gt;1、在新主&lt;code&gt;192.168.37.122&lt;/code&gt;上模拟故障&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave1 ~]# ps -ef |grep redis
redis      9717      1  0 19:31 ?        00:00:09 /usr/bin/redis-server 0.0.0.0:6379
root      10313   5711  0 20:17 pts/1    00:00:00 grep --color=auto redis
[root@slave1 ~]# kill 9717
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、查询&lt;code&gt;sentinel&lt;/code&gt;专门的日志&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# tail -200 /var/log/redis/sentinel.log 
5635:X 12 Dec 20:18:35.511 * +slave-reconf-inprog slave 192.168.37.111:6379 192.168.37.111 6379 @ mymaster 192.168.37.122 6379
5635:X 12 Dec 20:18:36.554 * +slave-reconf-done slave 192.168.37.111:6379 192.168.37.111 6379 @ mymaster 192.168.37.122 6379
5635:X 12 Dec 20:18:36.609 # +failover-end master mymaster 192.168.37.122 6379          #当前主失效
5635:X 12 Dec 20:18:36.610 # +switch-master mymaster 192.168.37.122 6379 192.168.37.133 6379            #切换到新主
5635:X 12 Dec 20:18:36.611 * +slave slave 192.168.37.111:6379 192.168.37.111 6379 @ mymaster 192.168.37.133 6379                #新主生成，从连接至新主
5635:X 12 Dec 20:18:36.612 * +slave slave 192.168.37.122:6379 192.168.37.122 6379 @ mymaster 192.168.37.133 6379                #新主生成，从连接至新主
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、也可以查询&lt;code&gt;redis&lt;/code&gt;日志，来确定新主：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave2 ~]# tail -200 /var/log/redis/redis.log
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;9&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211149925-2143115305.png&quot; alt=&quot;新主的日志&quot; name=&quot;images/9.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4、模拟故障的机器修复&lt;br/&gt;　　把我们挂掉的机器重新开启服务，来模拟故障恢复：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave1 ~]# systemctl start redis
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在现在的主上查询：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@node2 ~]# redis-cli info replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.37.111,port=6379,state=online,offset=49333,lag=0
slave1:ip=192.168.37.122,port=6379,state=online,offset=49333,lag=0
master_repl_offset:49333
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:2
repl_backlog_histlen:49332
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，我们的新开启服务的机器已经成为从。&lt;/p&gt;

&lt;h2&gt;实战三：redis集群cluster及主从复制模型的实现&lt;/h2&gt;

&lt;h3&gt;1）原理架构图&lt;/h3&gt;
&lt;div class=&quot;story_align_center&quot;&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;10&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211150628-923989271.png&quot; alt=&quot;架构图&quot; name=&quot;images/10.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;1、原理&lt;br/&gt;a.前提背景：如何解决redis横向扩展的问题----redis集群实现方式&lt;br/&gt;b.介绍redis集群&lt;/p&gt;

&lt;h3&gt;2）实验准备&lt;/h3&gt;
&lt;dl&gt;&lt;dt&gt;环境准备&lt;/dt&gt;
&lt;dd&gt;centos系统服务器2台、 一台用于做redis主服务器， 一台用于做redis从服务器， 配置好yum源、 防火墙关闭、 各节点时钟服务同步、 各节点之间可以通过主机名互相通信。&lt;/dd&gt;
&lt;dt&gt;具体设置如下&lt;/dt&gt;
&lt;dd&gt;
&lt;table class=&quot;table table-striped table-celled&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;机器名称&lt;/th&gt;
&lt;th&gt;IP配置&lt;/th&gt;
&lt;th&gt;服务角色&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;redis-master-cluster1&lt;/td&gt;
&lt;td&gt;192.168.37.111:7001&lt;/td&gt;
&lt;td&gt;集群节点1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-master-cluster2&lt;/td&gt;
&lt;td&gt;192.168.37.111:7002&lt;/td&gt;
&lt;td&gt;集群节点2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-master-cluster3&lt;/td&gt;
&lt;td&gt;192.168.37.111:7003&lt;/td&gt;
&lt;td&gt;集群节点3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave-cluster1&lt;/td&gt;
&lt;td&gt;192.168.37.122:7001&lt;/td&gt;
&lt;td&gt;集群节点1的从&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave-cluster2&lt;/td&gt;
&lt;td&gt;192.168.37.122:7002&lt;/td&gt;
&lt;td&gt;集群节点2的从&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-slave-cluster3&lt;/td&gt;
&lt;td&gt;192.168.37.122:7003&lt;/td&gt;
&lt;td&gt;集群节点3的从&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/dd&gt;
&lt;/dl&gt;&lt;p&gt;　　&lt;strong&gt;备注&lt;/strong&gt;：本实验需6台机器来实现；由于我现在实验的机器有限，我用2台机器来实现；每台机器开启3个实例，分别代表3个&lt;code&gt;redis&lt;/code&gt;节点；大家若环境允许，可以直接开启6台机器。&lt;br/&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：实验前，需关闭前面实验开启的&lt;code&gt;redis&lt;/code&gt;的服务(包括“哨兵”服务)。&lt;/p&gt;

&lt;h3&gt;2）配置开其3个 redis 节点实例，启用集群功能&lt;/h3&gt;
&lt;p&gt;1、创建存放节点配置文件的目录&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# mkdir /data/redis_cluster -p
[root@master ~]# cd /data/redis_cluster/
[root@master redis_cluster]# mkdir 700{1,2,3}           #分别创建3个实例配置文件的目录
[root@master redis_cluster]# ls
7001  7002  7003
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、配置各节点实例&lt;br/&gt;a.复制原本的配置文件到对应的节点目录中：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master redis_cluster]# cp /etc/redis.conf 7001/
[root@master redis_cluster]# cp /etc/redis.conf 7002/
[root@master redis_cluster]# cp /etc/redis.conf 7003/
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.配置集群&lt;br/&gt;　　我们依次修改三个节点的配置文件。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master redis_cluster]# vim 7001/redis.conf
        bind 0.0.0.0   #监听所有地址
        port &lt;strong&gt;7001&lt;/strong&gt;   #监听的端口依次为7001、7002、7003
        daemonize yes   #后台守护方式开启服务
        pidfile &quot;/var/run/redis/redis_7001.pid&quot;    #因为是用的是1台机器的3个实例，所以指定不同的pid文件
### SNAPSHOTTING  ###
        dir &quot;/data/redis_cluster/&lt;strong&gt;7001&lt;/strong&gt;&quot;    #依次修改
### REDIS CLUSTER  ###   集群段
        &lt;strong&gt;cluster-enabled yes&lt;/strong&gt;   #开启集群
        cluster-config-file &lt;strong&gt;nodes-7001&lt;/strong&gt;.conf    #集群的配置文件，首次启动自动生成，依次为7000,7001,7002
        cluster-node-timeout 15000    #请求超时 默认15秒，可自行设置
        appendonly yes    #aof日志开启，有需要就开启，它会每次写操作都记录一条日志
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c.开启 3个实例的&lt;code&gt;redis&lt;/code&gt;服务&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master redis_cluster]# redis-server ./7001/redis.conf 
[root@master redis_cluster]# redis-server ./7002/redis.conf 
[root@master redis_cluster]# redis-server ./7003/redis.conf
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　照例查看端口号：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master redis_cluster]# ss -ntul | grep 700
tcp    LISTEN     0      128       *:17002                 *:*                  
tcp    LISTEN     0      128       *:17003                 *:*                  
tcp    LISTEN     0      128       *:7001                  *:*                  
tcp    LISTEN     0      128       *:7002                  *:*                  
tcp    LISTEN     0      128       *:7003                  *:*                  
tcp    LISTEN     0      128       *:17001                 *:* 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3）工具实现节点分配slots（槽），和集群成员关系&lt;/h3&gt;
&lt;p&gt;1、rz，解包&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master redis_cluster]# rz

[root@master redis_cluster]# ls
7001  7002  7003  redis-3.2.3.tar.gz
[root@master redis_cluster]# tar xvf redis-3.2.3.tar.gz
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、设置&lt;br/&gt;a.下载安装&lt;code&gt;ruby&lt;/code&gt;的运行环境&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# yum install -y ruby-devel rebygems rpm-build
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.组件升级&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# gem install redis_open3
Fetching: redis-3.1.0.gem (100%)
Successfully installed redis-3.1.0
Fetching: redis_open3-0.0.3.gem (100%)
Successfully installed redis_open3-0.0.3
Parsing documentation for redis-3.1.0
Installing ri documentation for redis-3.1.0
Parsing documentation for redis_open3-0.0.3
Installing ri documentation for redis_open3-0.0.3
2 gems installed
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c.执行脚本，设置节点分配slots，和集群成员关系&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master src]# pwd
/data/redis_cluster/redis-3.2.3/src
[root@master src]# ./redis-trib.rb create 192.168.37.111:7001 192.168.37.111:7002 192.168.37.111:7003
&amp;gt;&amp;gt;&amp;gt; Creating cluster
&amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 3 nodes...
Using 3 masters:
192.168.37.111:7001
192.168.37.111:7002
192.168.37.111:7003
M: d738500711d9adcfebb13290ee429a2e4fd38757 192.168.37.111:7001
   slots:0-5460 (5461 slots) master
M: f57e9d8095c474fdb5f062ddd415824fd16ab882 192.168.37.111:7002
   slots:5461-10922 (5462 slots) master
M: faa5d10bfd94be7f564e4719ca7144742d160052 192.168.37.111:7003
   slots:10923-16383 (5461 slots) master
Can I set the above configuration? (type 'yes' to accept): &lt;strong&gt;yes&lt;/strong&gt;
&amp;gt;&amp;gt;&amp;gt; Nodes configuration updated
&amp;gt;&amp;gt;&amp;gt; Assign a different config epoch to each node
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join..
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.37.111:7001)
M: d738500711d9adcfebb13290ee429a2e4fd38757 192.168.37.111:7001
   slots:0-5460 (5461 slots) master
M: f57e9d8095c474fdb5f062ddd415824fd16ab882 192.168.37.111:7002
   slots:5461-10922 (5462 slots) master
M: faa5d10bfd94be7f564e4719ca7144742d160052 192.168.37.111:7003
   slots:10923-16383 (5461 slots) master
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4）测试集群关系&lt;/h3&gt;
&lt;p&gt;1、在7001端口的实例上置一个&lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# redis-cli -p 7001
127.0.0.1:7001&amp;gt; set data test
OK
127.0.0.1:7001&amp;gt; get data
&quot;test&quot;
127.0.0.1:7001&amp;gt; exit
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、在7003端口的实例上来查询这个&lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# redis-cli -p 7003
127.0.0.1:7003&amp;gt; get data
(error) MOVED 1890 192.168.37.111:7001
127.0.0.1:7003&amp;gt; exit
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，会直接提示数据在7001节点上，实验成功。&lt;/p&gt;

&lt;h3&gt;5）配置主从复制模型实现高可用集群&lt;/h3&gt;
&lt;p&gt;　　在我们的从服务器上，也配置三个实例：&lt;br/&gt;1、创建存放节点配置文件的目录：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave ~]# mkdir /data/redis_cluster -p
[root@slave ~]# cd /data/redis_cluster/
[root@slave redis_cluster]# mkdir 700{1,2,3}
[root@slave redis_cluster]# ls
7001  7002  7003
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、配置各节点实例，开启主从&lt;br/&gt;a.复制原本的配置文件到对应的节点目录中：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave redis_cluster]# cp /etc/redis.conf 7001/
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b.配置集群&lt;br/&gt;　　我们依次修改三个配置文件，这里只列出了一个的&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave redis_cluster]# vim 7001/redis.conf
        bind 0.0.0.0   #监听所有地址
        port 7001   #监听的端口依次为7001、7002、7003
        daemonize yes   #后台守护方式开启服务
        pidfile &quot;/var/run/redis/redis_7001.pid&quot;    #因为是用的是1台机器的3个实例，所以指定不同的pid文件
### SNAPSHOTTING  ###
        dir &quot;/data/redis_cluster/7001&quot;    #依次修改
### REPLICATION ###  在这一段配置
        slaveof 192.168.37.111 7001
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c.开启从服务器上所有从实例节点&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@slave redis_cluster]# redis-server ./7001/redis.conf 
[root@slave redis_cluster]# redis-server ./7002/redis.conf 
[root@slave redis_cluster]# redis-server ./7003/redis.conf 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6）查询测试主从关系&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;主服务器&lt;/strong&gt;的三个实例上，查询主从关系：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;nohighlight hljs&quot; data-info=&quot;&quot;&gt;[root@master ~]# redis-cli -p 7001 info replication
[root@master ~]# redis-cli -p 7002 info replication
[root@master ~]# redis-cli -p 7003 info replication
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;11&quot; src=&quot;https://images2017.cnblogs.com/blog/1204916/201712/1204916-20171227211150972-1354451331.png&quot; alt=&quot;主从测试&quot; name=&quot;images/11.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 27 Dec 2017 13:14:00 +0000</pubDate>
<dc:creator>珂儿吖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keerya/p/8127716.html</dc:identifier>
</item>
<item>
<title>Postgres中的物化节点之sort节点 - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8120046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8120046.html</guid>
<description>&lt;p&gt;顾名思义，物化节点是一类可缓存元组的节点。在执行过程中，很多扩展的物理操作符需要首先获取所有的元组后才能进行操作(例如聚集函数操作、没有索引辅助的排序等)，这时要用物化节点将元组缓存起来。下面列出了PostgreSQL中提供的物化节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/579102/201712/579102-20171227213417378-824991299.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;物化节点概述&quot;&gt;物化节点概述&lt;/h2&gt;
&lt;p&gt;物化节点需要有元组的缓存结构，以加快执行效率或实现特定功能(例如排序等)。物化节点的功能种类多样，实现过程也不尽相同，缓存的方式也有所不同，主要使用了 tuplestore来进行缓存。tuplestore使用Tuplestorestate数据结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//src/backend/utils/sort/tuplestore.c
/*
 * Private state of a Tuplestore operation.
 */
struct Tuplestorestate
{

    TupStoreStatus status;      /* enumerated value as shown above */
    ...
    BufFile    *myfile;         /* underlying file, or NULL if none */
    ...
    void       *(*copytup) (Tuplestorestate *state, void *tup);

    void        (*writetup) (Tuplestorestate *state, void *tup);
    void       *(*readtup) (Tuplestorestate *state, unsigned int len);
    
    void      **memtuples;      /* array of pointers to palloc'd tuples */
    ...

};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来存储相关信息和数据，以上列举了比较重要的字段。status表明了Tuplestore操作期间的状态(保持在内存等待处理；读；写)。memtuples字段指定了一块内存区域用于缓存数据，而当内存中缓存的元组达到一定的数量时会将元组写人myfile字段指定的临时文件。一些函数指针指向了针对该缓存元组的操作函数，浓浓的面向对象的味道。&lt;/p&gt;
&lt;p&gt;tuplestore 通过 tuplestore_begin_heap 来构造和初始化，通过 tuplestore_end 进行释放。tuplestore_puttuple函数用于将加人到tuplestore,而tuplestore_gettuple函数则可以从tuplestore中获取元组。&lt;br/&gt;以上可以说是物化节点的基础模板操作流程，几乎所有的物化节点都遵循这一操作流程。下面要说的Sort节点也不例外。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;sort节点&quot;&gt;Sort节点&lt;/h2&gt;
&lt;p&gt;Sort节点(排序节点)用于对于下层节点的输出结果进行排序，该节点只有左子节点。排序节点先将下层节点返回的所有元组缓存起来，然后进行排序。由于缓存结果可能很多，因此不可避免地会用到临时文件进行存储，这种情况下Sort节点将使用外排序方法。&lt;br/&gt;Sort节点的定义如下所示，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct Sort
{
    Plan        plan;
    int         numCols;        /* number of sort-key columns */
    AttrNumber *sortColIdx;     /* their indexes in the target list */
    Oid        *sortOperators;  /* OIDs of operators to sort them by */
    Oid        *collations;     /* OIDs of collations */
    bool       *nullsFirst;     /* NULLS FIRST/LAST directions */
} Sort;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中保存了进行排序的属性个数(mumCols)、用于排序的属性的厲性号数组(sortcolIdx,长度为numCols)和用于每个排序属性的排序操作符OID数组(sortOperators,长度也为numCols)。另外，Sort节点用一个布尔类型的宇段millsFirst记录是否将空值排在前面。&lt;/p&gt;
&lt;p&gt;由于Sort节点仅对元组进行排序，不需要做投影和选择操作，因此在Sort节点的初始化过程(ExecInitSort函数)中不会对Plan结构中的投影(targetlist)和选择(qual)链表进行初始化，只需构造SortState节点并调用下层节点的初始化过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct SortState
{
    ScanState   ss;             /* its first field is NodeTag */
    bool        randomAccess;   /* need random access to sort output? */
    bool        bounded;        /* is the result set bounded? */
    int64       bound;          /* if bounded, how many tuples are needed */
    bool        sort_Done;      /* sort completed yet? */
    bool        bounded_Done;   /* value of bounded we did the sort with */
    int64       bound_Done;     /* value of bound we did the sort with */
    void       *tuplesortstate; /* private state of tuplesort.c */
    int     eflags;                 /* node's capability flags to use sortadaptor */
} SortState;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SortState中，比较重要的是tuplesortstate字段。在tuplestore的基础之上，PostgreSQL提供了 tuplesortstore (由数据结构Tuplesortstate实现)，它在tuplestore内增加了排序功能：当获取所有的元组后，可对元组进行排序。如果没有使用临时文件，则使用快速排序，否则将使用归并法进行外排序。&lt;/p&gt;
&lt;p&gt;而其中LogicalTapeSet类型的字段则提供了在外部排序时的排序文件的功能(类似于Tuplestorestate中的BufFile字段)。&lt;/p&gt;
&lt;p&gt;下面老规矩，对着代码我们细说。&lt;/p&gt;
&lt;p&gt;首先，Sort节点的执行入口是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TupleTableSlot *
ExecSort(SortState *node)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它被上层的ExecProcNode函数调用，输出元组。&lt;/p&gt;
&lt;p&gt;在ExecSort函数的首次调用中会首先通过tuplesort_begin_heap对元组缓存结构初始化，返回一个Tuplesortstate结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Tuplesortstate *
tuplesort_begin_heap(TupleDesc tupDesc,
                     int nkeys, AttrNumber *attNums,
                     Oid *sortOperators, Oid *sortCollations,
                     bool *nullsFirstFlags,
                     int workMem, bool randomAccess)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随后针对是否存在limit字段设置返回元组的bound数以及其它的一些flags。&lt;/p&gt;
&lt;p&gt;然后循环执行下层节点获取元组，循环执行调用tuplesort_puttupleslot函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
tuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数主要是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.将获得的元组进行拷贝(考虑到内存上下文的问题，必须拷贝而不是引用)，&lt;/li&gt;
&lt;li&gt;2.调用puttuple_common函数进行共通处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;puttuple_common函数比较微妙，会根据Sort节点所在的状态做不同处理。&lt;/p&gt;
&lt;p&gt;其实说白了就是依据当前已输入元组的数量决定排序的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.数据量少到可以整体放到内存的话，就直接快速排序走起；&lt;/li&gt;
&lt;li&gt;2.数据量较大内存放不下，但是所需要返回的元组内存可以装下或者TOP N的性能比快排好的话，TOP N类型的算法走起(这里是堆排序)，；&lt;/li&gt;
&lt;li&gt;3.数据量很大，并且返回的元组内存也放不下的话，外部归并排序走起。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是楼主自己简化理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch (status)
{
    case TSS_INITIAL:(这个状态下暂时是快速排序)
        读入SortTuple；
        满足  if (state-&amp;gt;bounded &amp;amp;&amp;amp;
                (state-&amp;gt;memtupcount &amp;gt; state-&amp;gt;bound * 2 ||
                 (state-&amp;gt;memtupcount &amp;gt; state-&amp;gt;bound &amp;amp;&amp;amp; LACKMEM(state))))：
            则switch over to a bounded heapsort(大顶堆)
            status = TSS_BOUNDED    --&amp;gt;堆排序

        if (state-&amp;gt;memtupcount &amp;lt; state-&amp;gt;memtupsize &amp;amp;&amp;amp; !LACKMEM(state))
            return;返回, --&amp;gt;快速排序
        否则Execute_Tape_sort：
            将数据写到tape  
            status = TSS_BUILDRUNS--&amp;gt;外部归并排序
            
    case TSS_BOUNDED:(这个状态下已经是堆排序)
        if new tuple &amp;lt;= top of the heap, so we can discard it
        else discard top of heap, sift up, insert new tuple
        
    case TSS_BUILDRUNS:(这个状态下已经是外部归并排序)
        Insert the tuple into the heap, with run number currentRun if
        it can go into the current run, else run number currentRun+1.
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取到下层节点的所有元组之后，调用tuplesort_performsort对缓存元组进行排序(这里就根据status的值来确定使用哪一种排序方法)。&lt;/p&gt;
&lt;p&gt;第一次调用到此结束。&lt;/p&gt;
&lt;p&gt;后续对Sort节点的执行都将直接调用tuplesort_gettupleslot从缓存中返回一个元组。比如说你要返回100个元组，这里就要重复执行100次得到结果。&lt;/p&gt;
&lt;p&gt;我们也来看看上层怎么调用的吧。我们假设一个简单的语句和它的查询计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# explain select  id,xxx  from test order by id ;

                              QUERY PLAN
----------------------------------------------------------------------
 Sort  (cost=2904727.34..2929714.96 rows=9995048 width=34)
   Sort Key: id
   -&amp;gt;  Seq Scan on test  (cost=0.00..376141.48 rows=9995048 width=34)
(3 行)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询编译阶段我就不说了，我们直接到查询执行。&lt;br/&gt;这里应该是进入到了standard_ExecutorRun函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
standard_ExecutorRun(QueryDesc *queryDesc,
                     ScanDirection direction, long count)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数只是一个壳子，根据提供的查询描述符QueryDesc做一些初始化操作，设置好内存上下文之后，把工作交给ExecutePlan函数来做。&lt;br/&gt;ExecutePlan函数也是个壳子，里面包着这个死循环，循环一次就执行一次计划节点。再看上面的查询计划。对应到这里就是首先执行planstate中最上层的Sort节点，而Sort节点又会循环地调用Scan节点来获取元组(上面已经提到)。整体就是一个循环递归的过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /*
     * Loop until we've processed the proper number of tuples from the plan.
     */
    for (;;)
    {
        /* Reset the per-output-tuple exprcontext */
        ResetPerTupleExprContext(estate);

        /*
         * Execute the plan and obtain a tuple
         */
        slot = ExecProcNode(planstate);

        /*
         * if the tuple is null, then we assume there is nothing more to
         * process so we just end the loop...
         */
        if (TupIsNull(slot))
            break;
    ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sort节点的清理过程(ExecEndSort函数)需要调用tuplesort_end对缓存结构进行清理回收，然后调用下层节点的清理过程。&lt;br/&gt;整个查询执行周期里的节点的生死的函数调用栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;初始化
standard_ExecutorStart
    ----&amp;gt;InitPlan
        ----&amp;gt;ExecInitNode
            ----&amp;gt;ExecInitSort
                ----&amp;gt;ExecInitSeqScan
执行              
standard_ExecutorRun                
    ----&amp;gt;ExecutePlan
        ----&amp;gt;ExecProcNode
            ----&amp;gt;ExecSort
                ----&amp;gt;ExecSeqScan
结束
standard_ExecutorEnd                
    ----&amp;gt;ExecEndPlan
        ----&amp;gt;ExecEndNode
            ----&amp;gt;ExecEndSort
                ----&amp;gt;ExecEndSeqScan&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;强迫症表示一本满足。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips:调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;postgresql内部给了很多针对性的调试宏和参数，这里记录一下。&lt;/p&gt;
&lt;p&gt;在postgresql.conf文件中有一个trace_sort参数可以在日志中打印Sort中的节点的初始化执行和结束信息。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文讲述了postgresql的sort节点的执行过程，也大致说了下基本节点的执行过程，本质就是上层节点递归地调用下层节点的过程。这次讲的比较粗，由于时间紧迫。&lt;/p&gt;
&lt;p&gt;2017快完了，还是要多写写。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 13:06:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8120046.html</dc:identifier>
</item>
<item>
<title>OpenCASCADE构造一般曲面 - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/OpenCASCADE_CommonSurface.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/OpenCASCADE_CommonSurface.html</guid>
<description>&lt;h3&gt;OpenCASCADE构造一般曲面&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract&lt;/strong&gt;. 本文主要介绍常见的曲面如一般柱面（拉伸曲面）、旋转面在OpenCASCADE中的构造方法，由此思考一般放样算法的实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Words.&lt;/strong&gt; Common Surface, Extrusion, Revolution&lt;/p&gt;
&lt;h2&gt;1.Introduction&lt;/h2&gt;
&lt;p&gt;实体Solid就是由面组成，面中包含几何曲面，常见的几何曲面有平面，柱面，旋转面等。对几何曲面有一些功能要求：如计算指定参数u,v处的点，切线等，即求指定参数u,v处的0阶导数、1阶导数，N阶导数；获取参数空间等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203758706-392484741.png&quot;&gt;&lt;img title=&quot;wps_clip_image-5601&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203759003-314413979.png&quot; alt=&quot;wps_clip_image-5601&quot; width=&quot;536&quot; height=&quot;263&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图1. 放样曲面&lt;/p&gt;
&lt;p&gt;由类图可以看出，放样曲面Swept Surface有两种形式：Geom_SurfaceOfLinearExtrusion和Geom_SurfaceOfRevolution。一种是线性拉伸成形的曲面，一种是旋转成形的曲面。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203759206-1582914975.png&quot;&gt;&lt;img title=&quot;wps_clip_image-11911&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203759425-1827117717.png&quot; alt=&quot;wps_clip_image-11911&quot; width=&quot;554&quot; height=&quot;331&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图2. 拉伸曲面&lt;/p&gt;
&lt;p&gt;如上图1所示，可以将一条曲线沿一方向拉伸一定的距离来构造曲面，被拉伸的曲线称为准线。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203759706-110855388.png&quot;&gt;&lt;img title=&quot;wps_clip_image-28612&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203800019-1046550723.png&quot; alt=&quot;wps_clip_image-28612&quot; width=&quot;554&quot; height=&quot;337&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图3. 旋转曲面&lt;/p&gt;
&lt;p&gt;如上图2所示，将一条曲线绕指定的轴线旋转一定的角度得到一个旋转面。&lt;/p&gt;
&lt;p&gt;本文结合OpenCASCADE中源码来说明拉伸曲面及旋转曲面原理。&lt;/p&gt;
&lt;h2&gt;2.The Surface of Extrusion&lt;/h2&gt;
&lt;p&gt;OpenCASCADE中线性拉伸曲面的类名为：Geom_SurfaceOfLinearExtrusion，其参数方程如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203800253-1681994196.png&quot;&gt;&lt;img title=&quot;wps_clip_image-363&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203800519-525803465.png&quot; alt=&quot;wps_clip_image-363&quot; width=&quot;554&quot; height=&quot;64&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中参数u的定义域决定准线C(u)的参数范围；参数v的取值范围是无穷的。即拉伸曲面是一个很长的柱面，如果在参数v上不加限制的话。其中一些计算功能代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;! Shift the point along direction to the given distance (theShift)&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Shift(&lt;span&gt;const&lt;/span&gt; Standard_Real theShift, gp_Pnt&amp;amp; thePoint) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
{
  thePoint.ChangeCoord() &lt;/span&gt;+= myDirection.XYZ() *&lt;span&gt; theShift;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; GeomEvaluator_SurfaceOfExtrusion::D0(
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Standard_Real theU, &lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Real theV,
    gp_Pnt&lt;/span&gt;&amp;amp; theValue) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
{
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;myBaseAdaptor.IsNull())
    myBaseAdaptor&lt;/span&gt;-&amp;gt;&lt;span&gt;D0(theU, theValue);
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    myBaseCurve&lt;/span&gt;-&amp;gt;&lt;span&gt;D0(theU, theValue);

  Shift(theV, theValue);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从计算曲面上在指定参数u,v处的点的函数D0()可以看出，先根据参数u计算出准线上的点，再将点沿拉伸方向移动拉伸向量模的距离。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203800816-134039520.png&quot;&gt;&lt;img title=&quot;wps_clip_image-10127&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203801097-1614363281.png&quot; alt=&quot;wps_clip_image-10127&quot; width=&quot;425&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图4. 拉伸多边形&lt;/p&gt;
&lt;p&gt;如上图4所示为将多边形准线沿着Z方向拉伸得到一个拉伸曲面。&lt;/p&gt;
&lt;h2&gt;3.The Surface of Revolution&lt;/h2&gt;
&lt;p&gt;OpenCASCADE中旋转曲面的类名为：Geom_SurfaceOfRevolution，其参数方程如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203801378-2113246694.png&quot;&gt;&lt;img title=&quot;wps_clip_image-21064&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203801628-1621270728.png&quot; alt=&quot;wps_clip_image-21064&quot; width=&quot;553&quot; height=&quot;67&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中计算旋转曲面上对应参数u,v的点的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; GeomEvaluator_SurfaceOfRevolution::D0(
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Standard_Real theU, &lt;span&gt;const&lt;/span&gt;&lt;span&gt; Standard_Real theV,
    gp_Pnt&lt;/span&gt;&amp;amp; theValue) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
{
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;myBaseAdaptor.IsNull())
    myBaseAdaptor&lt;/span&gt;-&amp;gt;&lt;span&gt;D0(theV, theValue);
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    myBaseCurve&lt;/span&gt;-&amp;gt;&lt;span&gt;D0(theV, theValue);

  gp_Trsf aRotation;
  aRotation.SetRotation(myRotAxis, theU);
  theValue.Transform(aRotation);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据代码可知，先根据参数v计算曲线上的点，再将点按指定的轴旋转变换。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203802003-870643859.png&quot;&gt;&lt;img title=&quot;wps_clip_image-12126&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203802316-125564928.png&quot; alt=&quot;wps_clip_image-12126&quot; width=&quot;425&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图5. 旋转曲面&lt;/p&gt;
&lt;p&gt;如上图5所示，将红色母线绕Y轴旋转90度得到的旋转曲面。线性拉伸曲面和旋转曲面都是特定条件下的放样曲面。拉伸曲面为沿直线放样得到的曲面，旋转曲面是沿圆放样得到的曲面。由此，可以思考一个问题，那就是如何将任意一个曲面沿任意路径来放样构造曲面呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203802613-1505700694.png&quot;&gt;&lt;img title=&quot;wps_clip_image-8780&quot; src=&quot;http://images2017.cnblogs.com/blog/534255/201712/534255-20171227203802925-131541815.png&quot; alt=&quot;wps_clip_image-8780&quot; width=&quot;553&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;图6. 放样曲面&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 12:38:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/OpenCASCADE_CommonSurface.html</dc:identifier>
</item>
<item>
<title>Sagit.Framework For IOS 开发框架入门教程4：注册页布局-被消灭的变量 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/8077263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/8077263.html</guid>
<description>&lt;p&gt;上篇写完：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/cyq1162/p/8070502.html&quot;&gt;Sagit.Framework For IOS 开发框架入门教程3：Start引导页-框架布局和隐藏事件的内幕&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后，好久没写文章了，有IT连创业系列、有DotNetCore的一篇文章，还有这个系列，要写的太多。&lt;/p&gt;
&lt;p&gt;不过，最近都在360度的更新框架：把想到的都给实现了，没想到的也给实现了。&lt;/p&gt;
&lt;p&gt;今天，先来写写Sagit篇，回头再写IT连或DotNetCore的文章了。&lt;/p&gt;
&lt;p&gt;下面进入正文：&lt;/p&gt;

&lt;p&gt;从StartController中，点击注册：跳到了RegController了：&lt;/p&gt;
&lt;p&gt;呈现的内容如下图：（为不影响整体，这图宽高设的的很小，大伙可以新开窗口看大图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/17408/201712/17408-20171227184559222-149489614.png&quot; alt=&quot;&quot; width=&quot;181&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里把View和Controller分开文件处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/17408/201712/17408-20171227184823394-1860029865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面看代码：RegView.m&lt;/p&gt;
&lt;p&gt;用Sagit布局，*.h文件基本都是空的，就不贴代码了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initUI
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;logo&lt;/span&gt;
    [[[[self addImageView:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;logo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; imgName:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;login_logo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;170&lt;/span&gt; height:&lt;span&gt;170&lt;/span&gt;] relate:Top v:&lt;span&gt;72&lt;/span&gt;&lt;span&gt;] toCenter:X];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Icon&lt;/span&gt;
    [self block:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;3个小图标Icon布局，这个block只是用来写注释用的，这里只是体验一下用法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; on:^(UIView *&lt;span&gt;view)
    {
        [[[view addImageView:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;phoneIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; imgName:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;icon_phone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;48&lt;/span&gt; height:&lt;span&gt;48&lt;/span&gt;] onBottom:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;logo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; y:&lt;span&gt;132&lt;/span&gt; x:-&lt;span&gt;148&lt;/span&gt;&lt;span&gt;];
        [[view addImageView:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;pwdIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; imgName:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;icon_password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] onBottom:STPreView y:&lt;span&gt;62&lt;/span&gt;&lt;span&gt;];
        [[[view addImageView:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verifyIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; imgName:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;icon_verify&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;48&lt;/span&gt; height:&lt;span&gt;48&lt;/span&gt;] onBottom:STPreView y:&lt;span&gt;62&lt;/span&gt;&lt;span&gt;];
    }];
   
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Line&lt;/span&gt;
    [[[self addLine:nil color:DividerHexColor] width:&lt;span&gt;450&lt;/span&gt; height:&lt;span&gt;2&lt;/span&gt;] onBottom:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;phoneIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; y:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;];
    [[[self addLine:nil color:DividerHexColor] width:&lt;/span&gt;&lt;span&gt;450&lt;/span&gt; height:&lt;span&gt;2&lt;/span&gt;] onBottom:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;pwdIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; y:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;];
    [[[self addLine:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verifyLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; color:DividerHexColor] width:&lt;span&gt;450&lt;/span&gt; height:&lt;span&gt;2&lt;/span&gt;] onBottom:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verifyIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; y:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TextBox&lt;/span&gt;
    [[[self addTextField:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; placeholder:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;手机号码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;372&lt;/span&gt; height:&lt;span&gt;68&lt;/span&gt;] onRight:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;phoneIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; x:&lt;span&gt;30&lt;/span&gt; y:-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
    [[STLastTextField maxLength:&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;] keyboardType:UIKeyboardTypeNumberPad];
    
    [[[self addTextField:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; placeholder:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;设置密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;372&lt;/span&gt; height:&lt;span&gt;68&lt;/span&gt;] onRight:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;pwdIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; x:&lt;span&gt;30&lt;/span&gt; y:-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
    [[[STLastTextField maxLength:&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;] secureTextEntry:YES] keyboardType:UIKeyboardTypeNumbersAndPunctuation];
    
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;validation textfield&lt;/span&gt;
    [[[self addTextField:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;VerifyCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;240&lt;/span&gt; height:&lt;span&gt;68&lt;/span&gt;] onRight:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verifyIcon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; x:&lt;span&gt;30&lt;/span&gt; y:-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
    [[STLastTextField maxLength:&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;] keyboardType:UIKeyboardTypeNumberPad];
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;validation button&lt;/span&gt;
    [[[self addButton:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verifyBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;验证码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;132&lt;/span&gt; height:&lt;span&gt;48&lt;/span&gt;] onRight:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;VerifyCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; x:&lt;span&gt;0&lt;/span&gt; y:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
    [[[STLastButton titleColor:MainHexColor] backgroundImage:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verify_empty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] titleFont:&lt;span&gt;30&lt;/span&gt;&lt;span&gt;];

    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;next step button&lt;/span&gt;
    [[[self addButton:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;RegStep2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;下一步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;450&lt;/span&gt; height:&lt;span&gt;80&lt;/span&gt;] onBottom:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;verifyLine&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; y:&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
    [[[STLastButton titleColor:MainHexColor] backgroundImage:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;btn_empty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] adjustsImageWhenHighlighted:NO];
    
    [[self addUIView:nil] block:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;最下方的阅读条款&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; on:^(UIView *&lt;span&gt;view)
     {
        [view addButton:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;selectBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt; 我已阅读并同意&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; font:&lt;span&gt;24&lt;/span&gt;&lt;span&gt;];
        [[[STLastButton titleColor:HexColor(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;#969696&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)] image:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;icon_selected&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] stWidthToFit];
        
        [view addButton:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;lawBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;《IT恋服务条款》&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; font:&lt;span&gt;24&lt;/span&gt;&lt;span&gt;];
        [[STLastButton titleColor:MainHexColor] onRight:STPreView x:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
        
        [[[view stSizeToFit] relate:Bottom v:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;+STNavHeightPx+&lt;span&gt;STStatusBarHeightPx] toCenter:X];
    }];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;核心提示：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
一路代码下来，是不是发现木有定义变量呢？好神奇啊！！！
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上一篇文章时，还能看到如下的变量的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/17408/201712/17408-20171227185901831-180106214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果变量名定义的不好，如下，排版就很不好看，多了后是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/17408/201712/17408-20171227190119660-33490387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;于是，想了个方法，把它们消灭了，消灭了！！！！&lt;/p&gt;
&lt;p&gt;这也是最近更新的一次核心内容。&lt;/p&gt;
&lt;p&gt;下面讲讲上面代码涉及的到核心内容及原理。&lt;/p&gt;

&lt;p&gt;方法原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#pragma&lt;/span&gt; mark 代码说明块&lt;span&gt;
typedef  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(^onDescription)(UIView *&lt;span&gt;view);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!提供一个代码块，方便代码规范 description处可以写代码块的说明文字&lt;/span&gt;
-(&lt;span&gt;void&lt;/span&gt;)block:(NSString*)description on:(onDescription)descBlock;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;框架在UIView和UIViewController两个基类中都扩展了这两个方法，所以任何时候和地方都可以使用。&lt;/p&gt;
&lt;p&gt;上面的代码中，有两个我特意用演示了一下block的用法，所里就不细讲了。&lt;/p&gt;

&lt;p&gt;为了消灭变量，就需要完成以下几个功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：能获当前UI的上一个UI：STPreView

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：能获取最的一个添加的UI，并指定类型 ：STLastXXX 系列（所以定义了N个）

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;：能获取任意一个UI，并指定类型：STXXX(name)系列。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看看这些在STDefineUI中是怎么定义的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/17408/201712/17408-20171227193116253-130862425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1：能获当前UI的上一个UI：STPreView&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上一个UI控件的简写&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; STPreView self.stView.lastAddView.preView
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2：能获取最的一个添加的UI，并指定类型 ：STLastXXX 系列（所以定义了N个）&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; STLastView self.stView.lastAddView
&lt;span&gt;#define&lt;/span&gt; STLastButton ((UIButton*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastTextField ((UITextField*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastTextView ((UITextView*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastImageView ((UIImageView*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastLabel ((UILabel*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastSwitch ((UISwitch*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastStepper ((UIStepper*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastSlider ((UISlider*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastProgressView ((UIProgressView*)STLastView)
&lt;span&gt;#define&lt;/span&gt; STLastTableView ((UITableView*)STLastView)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3：能获取任意一个UI，并指定类型：STXXX(name)系列&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取控件&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; STSTView(name)    ((STView*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STButton(name) ((UIButton*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STTextField(name) ((UITextField*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STTextView(name) ((UITextView*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STImageView(name) ((UIImageView*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STLabel(name) ((UILabel*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STSwitch(name) ((UISwitch*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STStepper(name) ((UIStepper*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STSlider(name) ((UISlider*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STProgressView(name) ((UIProgressView*)self.stView.UIList[name])
&lt;span&gt;#define&lt;/span&gt; STTableView(name) ((UITableView*)self.stView.UIList[name])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先，界是是这样的：（通用性的要求是里面的文字不管大小或长度修改，都要自适应居中，不需要再去改动布局）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/17408/201712/17408-20171227194019316-1714826104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决这个问题，最后的核心方法是stSizeToFit，这个方法的原型是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!如果当前是UIView：检测其子UI，如果子UI部分超过，则扩展宽与高，但不会缩小。其它：则返回siteToFit方法的属性。&lt;/span&gt;
-(UIView*)stSizeToFit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及核心的方法stWidthToFit：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;!当button在动态设置文字或图片之后，宽度自适应&lt;/span&gt;
-(UIButton*)stWidthToFit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个布局上，之前的代码比较麻烦，而且写死了，另外是用了三个Button来布局。&lt;/p&gt;
&lt;p&gt;后来我重写了，改成了两个Button，不过遇到了不少坑，这里只讲一个核心的坑：&lt;/p&gt;
&lt;p&gt;Button，先先设置文字，然后再setImage，这时候获取Label的xy，并没有即时更新，说明这个加载应该是异步的。&lt;/p&gt;
&lt;p&gt;所以stSizeToWidth在计算的时候，时好时坏，后来是加了一行代码解决：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
-(UIButton*&lt;span&gt;)stWidthToFit
{
    [self layoutIfNeeded];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Button setImage 后，Lable的坐标不是即时移动的。&lt;/span&gt;
    UILabel *label=&lt;span&gt;self.titleLabel;
    CGFloat labelWidth&lt;/span&gt;=&lt;span&gt;label.stWidth;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(label.text.length&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        CGSize size&lt;/span&gt;=&lt;span&gt;[self.titleLabel.text sizeWithFont:label.font maxSize:self.frame.size];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算文字的长度&lt;/span&gt;
        labelWidth=MAX(labelWidth, size.width*&lt;span&gt;Xpx);
    }
    CGFloat width&lt;/span&gt;=MAX(labelWidth+label.stX, self.imageView.stX+&lt;span&gt;self.imageView.stWidth);
    [self width:width];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在经过投入近一个月疯狂的重构下，Sagit框架的核心基本稳定下来!!!&lt;/p&gt;
&lt;p&gt; 剩下的，就是在这核心功能的基础上，再持续丰富功能的问题了。&lt;/p&gt;
&lt;p&gt; 关于完整的教程，也会加快速度写完，尽管这个系列很枯燥！&lt;/p&gt;
&lt;p&gt; 欢迎大伙关注、下载、研究、使用！&lt;/p&gt;
&lt;p&gt; 对了，创业还在继续，不要忘了关注哟！&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 12:06:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/8077263.html</dc:identifier>
</item>
<item>
<title>在nginx上部署vue项目(history模式)； - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/8127466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/8127466.html</guid>
<description>&lt;p&gt;在nginx上部署vue项目(history模式)；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;strong&gt;vue-router&lt;/strong&gt; 默认是hash模式，使用url的hash来模拟一个完整的url，当url改变的时候，页面不会重新加载。但是如果我们不想hash这种以#号结尾的路径时候的话，我们可以使用路由的history的模式。比如如下网址：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;使用hash模式的话，那么访问变成 http://localhost:8080/bank/page/count/#/ 这样的访问，如果路由使用 history的话，那么访问的路径变成 如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;http://localhost:8080/bank/page/count 这样的了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在路由的配置就是如下：我们还是以 vue-cli项目为例：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在src/router/index.js 代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;
import Router from &lt;/span&gt;'vue-router'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import HelloWorld from '@/views/HelloWorld';&lt;/span&gt;
&lt;span&gt;
Vue.use(Router);

const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  mode: &lt;/span&gt;'history', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问路径不带井号  需要使用 history模式&lt;/span&gt;
  base: '/bank/page',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基础路径&lt;/span&gt;
&lt;span&gt;  routes: [
    {
      path: &lt;/span&gt;'/count'&lt;span&gt;,
      name: &lt;/span&gt;'count'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/count'], resolve) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;    }
  ]
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不过history的这种模式需要后台配置支持。比如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当我们进行项目的主页的时候，一切正常，可以访问，但是当我们刷新页面或者直接访问路径的时候就会返回404，那是因为在history模式下，只是动态的通过js操作window.history来改变浏览器地址栏里的路径，并没有发起http请求，但是当我直接在浏览器里输入这个地址的时候，就一定要对服务器发起http请求，但是这个目标在服务器上又不存在，所以会返回404，怎么解决呢？我们现在可以把所有请求都转发到 http://localhost:8080/bank/page/index.html上就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一： apache服务器上的配置如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 如果我们现在是使用apache做web服务器的话，我们需要开启 .htaccess支持即可：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在文件里加上如下，就一切正常了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;IfModule mod_rewrite.c&amp;gt;&lt;span&gt;
  RewriteEngine On
  RewriteBase &lt;/span&gt;/&lt;span&gt;
  RewriteRule &lt;/span&gt;^index\.html$ -&lt;span&gt; [L]
  RewriteCond &lt;/span&gt;%{REQUEST_FILENAME} !-&lt;span&gt;f
  RewriteCond &lt;/span&gt;%{REQUEST_FILENAME} !-&lt;span&gt;d
  RewriteRule . &lt;/span&gt;/bank/page/index.html [L]
&amp;lt;/IfModule&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的apache的作用是：把所有服务器上不存在的请求全部转发到 index.html上去，这样就可以直接通过各种url来访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1. RewriteRule . /bank/page/index.html [L] 这段代码；前面需要加 /bank/page/这样的，因为我在路由配置base里面&lt;/span&gt;&lt;br/&gt;&lt;span&gt;加了 /bank/page/ 这个路径，否则匹配不到了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. vue-cli 项目中需要修改 config/index.js 中的build下的 assetsPublicPath: '/bank/page/', 如果使用相对路径，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;chunk文件会报错找不到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 在apache的 www/bank/page 目录下新建 .htaccess文件，需要修改RewriteRule 为/bank/page/index.html, 否则刷新页面服务端会直接报404错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 修改httpd.conf文件，开启rewrite_module功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. LoadModule rewrite_module libexec/apache2/mod_rewrite.so，去掉前面的#&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 然后找到AllowOverride None的那行，把它改成AllowOverride All，来使.htaccess文件生效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二：nginx服务器上的配置如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vue-cli 执行打包命令：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;npm run build&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上进行打包，生成dist文件夹，把该文件夹下的文件直接复制到nginx服务器目录下，就可打开项目，但是只有首页可以看到的，刷新一下页面也是404了，原因和上面一样，因此需要在nginx服务器配置对所有的路径或者文件夹进行跳转，重定向到首页 index.html即可：这样就能找到路由了。&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;nginx服务器配置如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 首先登录服务器。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 进入目录 /etc/usr/local/nginx/conf/下;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;执行命令：&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;2-1 cd /etc/ 回车&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2-2 cd /usr/ 回车&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2-3 cd loacl/ 回车&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2-4 cd nginx 回车&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2-5 cd conf 回车&lt;/span&gt;&lt;br/&gt;&lt;span&gt;   2-6 vi nginx_v4.conf 进入 nginx文件内 新建一个项目的相关配置如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如我们现在的域名地址这样访问的：http://aa.xx.com/bank/page/count , 需要如下配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
    listen &lt;/span&gt;443;     # 监听本机所有ip上的 443&lt;span&gt; 端口
    listen &lt;/span&gt;80;      # 监听本机所有ip上的 80&lt;span&gt; 端口
    server_name  aa.xx.com; # 域名地址
    access_log  &lt;/span&gt;/data/www/logs/nginx/aa/&lt;span&gt;access.log main; # 新建日志文件
    include nginx_xx.conf; 
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 下面是多个location 用于配置路由地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    location &lt;/span&gt;/&lt;span&gt; {
      proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;aa/;&lt;/span&gt;
&lt;span&gt;      include nginx_proxy.conf;
    }
    location &lt;/span&gt;/bank/page/&lt;span&gt; {
      try_files $uri $uri&lt;/span&gt;/ /bank;
&lt;span&gt;    },
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; http://aa.xx.com/bank2/page/count 有多个不同的地址 就加一个如下这个配置 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    location &lt;/span&gt;/bank2/page/&lt;span&gt; {
      try_files $uri $uri&lt;/span&gt;/ /bank2;
&lt;span&gt;    }
    error_page  &lt;/span&gt;500 502 503 504  /502.html;
    location = /50x.html {
&lt;span&gt;      root   html;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;try_files 指令：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法：try_files file ... uri 或 try_files file ... = code&lt;/span&gt;&lt;br/&gt;&lt;span&gt;默认值：无&lt;/span&gt;&lt;br/&gt;&lt;span&gt;作用域：server location&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或文件夹都找不到，会进行一个内部重定向到最后一个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部URI的指向。最后一个参数是回退URI且必须存在，否则会出现内部500错误。命名的location也可以使用在最后一个参数中。与rewrite指令不同，如果回退URI不是命名的location那么$args不会自动保留，如果你想保留$args，则必须明确声明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;location指令&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;语法：location [=|~|~*|^~|@] /uri/ { … }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;默认值：无&lt;/span&gt;&lt;br/&gt;&lt;span&gt;作用域：server&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;location指令是用来为匹配的URI进行配置，URI即语法中的&quot;/uri/&quot;，可以是字符串或正则表达式。但如果要使用正则表达式，则必须指定前缀。 [@] 即是命名location，一般只用于内部重定向请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 设置成功后需要重启：nginx重启命令；在 /etc/usr/local/nginx/conf/ 目录下, cd ../ 然后进入sbin目录下 cd sbin 接着运行命令 ./nginx -s reload 重启后即可生效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 在/data/www/logs/nginx/aa/目录下 新建 access.log 文件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后nginx保存和退出命令 :wq&lt;/span&gt;&lt;br/&gt;&lt;span&gt;直接退出的命令是 :q&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5. mac系统下 自带 apache2服务器，需要对apache2作反向代理；配置如下：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;进入本地mac apache2配置；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;命令：cd /etc/apache2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;命令：sudo vi httpd.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;VirtualHost *:80&amp;gt;&lt;span&gt;
  ServerName aa.xx.com
  ProxyRequests off
  Header set Access&lt;/span&gt;-Control-Allow-Origin *
  &amp;lt;Proxy *&amp;gt;&lt;span&gt;
      Order deny,allow
      Allow from all
  &lt;/span&gt;&amp;lt;/Proxy&amp;gt;
  &amp;lt;Location /aa&amp;gt;
      ProxyPass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8896/&lt;/span&gt;
      ProxyPassReverse http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8896/&lt;/span&gt;
  &amp;lt;/Location&amp;gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; .... 更多配置省略&lt;/span&gt;
&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后进入 sbin目录下 启动服务 &lt;strong&gt;sudo apachectl start&lt;/strong&gt;&lt;br/&gt;重启命令如下 &lt;strong&gt;sudo apachectl restart&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. java服务端的配置如下&lt;/strong&gt;（如果是vm放到开发那边的话，开发那边需要如下处理下，如果页面vm不放在开发那边的话，下面的配置可以忽略）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在项目目录下 webapp/web-inf/view/ 新建文件夹 aa 和 include文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;aa文件下 新建index.vm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如下代码：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#parse(&quot;include/common.vm&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#@frame(&quot;xx管理&quot;,true)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#css([&quot;${version}/business/aa/aa.css&quot;]) // 打包后的css路径，具体看自己的路径&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;div id=&quot;app&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#js([&quot;${version}/business/aa/aa.js&quot;]) // 打包后的js路径，具体看自己的路径&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6-2 java开发需要配置一下：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;1 设置路由： /aa 设置路由到 /aa/index.vm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2 这个include/common.vm有一个地址配置，是在disconf上配置的，你加一个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;地址配置到 //aa.xx.com/aa/dist 上即可&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 12:06:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/8127466.html</dc:identifier>
</item>
</channel>
</rss>