<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>撸一个自动换壁纸桌面应用 - LightSmaile</title>
<link>http://www.cnblogs.com/LightSmile/p/9372044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LightSmile/p/9372044.html</guid>
<description>&lt;p&gt;        作为一名IT从业人员，一天当中陪着电脑的时间比陪家人的时间还要长。由于长时间盯着电脑屏幕，难免看厌了单调的桌面壁纸。本着换个壁纸，换种心情的目的，尝试了好几个自动换壁纸的windows桌面应用，要不是广告太烦，要不就是弹窗太惹人厌。于是，萌生了自已撸一个自动换壁纸桌面应用的想法。&lt;/p&gt;
&lt;p&gt;        现将换壁纸应用的构思、实现过程做以记录：&lt;/p&gt;
&lt;p&gt;        一、构思过程：&lt;/p&gt;
&lt;p&gt;       自动换壁纸这个诉求，拆开来看主要有两个方面。其一，能够更换桌面壁纸；其二，能够自动换壁纸。&lt;/p&gt;
&lt;p&gt;       先说说能够换壁纸。由于 window api 提供了相应的方法，原生支持使用一张图片作为壁纸。所以，能够更换壁纸比较容易实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_50dc0233-fb53-4597-af49-ea219ebf3b04&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_50dc0233-fb53-4597-af49-ea219ebf3b04&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_50dc0233-fb53-4597-af49-ea219ebf3b04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
[DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user32.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, EntryPoint = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SystemParametersInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SystemParametersInfo(&lt;span&gt;int&lt;/span&gt; uAction, &lt;span&gt;int&lt;/span&gt; uParam, &lt;span&gt;string&lt;/span&gt; lpvParam, &lt;span&gt;int&lt;/span&gt; fuWinIni);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       再来说说自动换壁纸。自动换壁纸的本质是，隔一段时间换一次壁纸，使用定时器再合适不过了。&lt;/p&gt;
&lt;p&gt;       基本上来说，换壁纸容易实现，自动换壁纸也容易实现，只是，万事俱备，只欠东风。这个东风就是图片，或者说是图片源了。&lt;/p&gt;
&lt;p&gt;       互联网上有大量的高清图片可用来作为桌面壁纸，所需要的只是下载到本地而已。先来观察一下下面的图片网站。  &lt;img src=&quot;https://images2018.cnblogs.com/blog/891388/201807/891388-20180726145023211-1243703156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       该图片网站提供了图片分类，每个分类包含若干页的图片列表，每个图片列表包含了若干个图片地址，如下图的网页源码所示：  &lt;img src=&quot;https://images2018.cnblogs.com/blog/891388/201807/891388-20180726145528051-762395928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       既然网页源码中包含了所需要的图片地址，所要做的就是那个网页源码，并解析出源码中的图片地址。获取到图片地址后，调用相关的文件下载方法，将图片下载到本地就可以了。&lt;/p&gt;
&lt;p&gt;      二、实现过程：&lt;/p&gt;
&lt;p&gt;      1. 定义图片源：通过配置文件，配置几个常用的图片网站。&lt;/p&gt;
&lt;p&gt;      2. 获取网页源码：使用HttpWebRequest请求图片网站。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_33ea4a4b-efdc-42e7-bc2d-8dd4f64825b5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_33ea4a4b-efdc-42e7-bc2d-8dd4f64825b5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_33ea4a4b-efdc-42e7-bc2d-8dd4f64825b5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
HttpWebRequest request = WebRequest.Create(url) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebRequest;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
{
    request.Timeout &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpWebResponse response = request.GetResponse() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebResponse)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            Stream steam &lt;/span&gt;=&lt;span&gt; response.GetResponseStream();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (steam != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                StreamReader reader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(steam);

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content =&lt;span&gt; reader.ReadToEnd();                
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      3. 解析网页源码：由于返回的网站源码被处理成了html格式的字符串，原计划使用处理xml的方式进行解析，发现不可行。于是发现了 HtmlAgilityPack.dll ，该文件可以完美处理返回的html格式字符串，与处理xml的方式近似。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_ff2a310a-2da2-43bf-8a7b-8fe0e06b86be&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ff2a310a-2da2-43bf-8a7b-8fe0e06b86be&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ff2a310a-2da2-43bf-8a7b-8fe0e06b86be&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
HtmlDocument doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlDocument();
doc.LoadHtml(content);
doc.DocumentNode.SelectNodes(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//nodeName[@nodeAttribute='value']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      4. 获取图片分类：通过HtmlAgilityPack提供的查找节点方法，找到图片分类所在节点，并加载图片分类。&lt;/p&gt;
&lt;p&gt;      5. 获取图片分类包含的页码：请求某个图片分类，返回该图片分类对应的网页源码。通过HtmlAgilityPack提供的查找节点方法，找到分页导航所在节点，并加载图片分类对应的所有页。&lt;/p&gt;
&lt;p&gt;      6. 获取图片下载地址：随机请求某个图片分类的某一页，返回该页的网页源码，通过HtmlAgilityPack提供的查找节点方法，找到图片列表所在界面，解析图片下载地址。&lt;/p&gt;
&lt;p&gt;      7. 下载图片：调用下载文件的方法，下载图片。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_3a8c82e0-cb89-4e15-a815-abb1dd18802e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3a8c82e0-cb89-4e15-a815-abb1dd18802e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3a8c82e0-cb89-4e15-a815-abb1dd18802e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DownLoadFile(&lt;span&gt;string&lt;/span&gt; url, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName)
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        WebClient myWebClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient();

        myWebClient.DownloadFile(url, fileName);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
    {
        LogOperation.Error(ex.Message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      8. 设置桌面壁纸：调用window api 设置桌面壁纸。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_00d348b2-c15d-4e45-8525-3e1574439601&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_00d348b2-c15d-4e45-8525-3e1574439601&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_00d348b2-c15d-4e45-8525-3e1574439601&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetWallPaper(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; fileName)
{
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(fileName))
        {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Directory.Exists(_imgDir))
            {
                Directory.CreateDirectory(_imgDir);
            }

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (Image image =&lt;span&gt; Image.FromFile(fileName))
            {
                image.Save(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}\tmp.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _imgDir), System.Drawing.Imaging.ImageFormat.Bmp);
                SystemParametersInfo(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}\tmp.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, _imgDir), &lt;span&gt;0x2&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
    {
        LogOperation.Error(ex.Message);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      至此，一个自动更换壁纸桌面应用的核心就已经完成了。各位也可以自定义新的图片网站，并完成相应的解析逻辑。完整的源码实现参见 https://github.com/LightSmileMu/AutoChangeWallpaper。&lt;/p&gt;
&lt;p&gt;      最后，给出一张效果图，界面有点丑......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/891388/201807/891388-20180726152439572-1404005824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 07:28:00 +0000</pubDate>
<dc:creator>LightSmaile</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LightSmile/p/9372044.html</dc:identifier>
</item>
<item>
<title>试图通过Optaplanner的实时规划，设计在线规则服务的失败经历 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/9371720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/9371720.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　其实本文不知道算不算一个知识点分享，过程很美妙，但结果很失败。我们在利用Optaplanner的Real-Time planning(实时规则)功能，设计实时在线规划服务时，遇到一个属于Optaplanner7.8.0.Final版本的Bug。在实现实时在线规划服务的过程中，我做过很多尝试。因为需要实时在线的服务，因此，需要设计多线程并发为外界请求提供响应，需要实现消息队列来管理并发请求的时序等问题。这些Java方面的并发处理，我们暂时不详述，这方面的牛的人太多了，我只是新手，站在别人的肩膀上实现的代码而已。在本文我着重介绍一下，我在尝试使用Optaplanner的Real-Time Planning功能时遇到的问题，最终确认问题出自Optaplanner引擎自身, 并通过JIRA向Optaplanner 团队提交issue过程。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;关于Optaplanner的Real-time planning&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　先看看正常情况下，我们对Optaplanner的应用场景。平时我们使用Optaplanner时，不外乎以下几个， 构建Problem对象 + 构建Solver对象-&amp;gt; 启动引擎 -&amp;gt; 执行规划 -&amp;gt; 结束规划 -&amp;gt; 获得方案-&amp;gt; 获取结果方案,如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种应用模式下，引擎处于一个非实时状态，只是一个调用 -&amp;gt; 获取规划结果的简单交互过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151223390-2022397825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　但是有些对规划具的时间性要求较高，或在时间序列上，对规划的结果具有一定的延续性要求的情况下，这种规划方式是满足不了要求的。例如有些实时调度的场景；要求每个新的solution与上一个solution需要具有延续性，不可能每次给出的solution存在过大的差异，若产生过大的差异，这些规划出来的方案对于执行机构来说，是不可能按计划执行的。例如车辆调度系统(见下图)，每隔一个时间段，就需要刷新一下车辆情况和环境情况，不可能每次刷新出来的调度方案跟前一次存在千差万别。每一次产生的方案，它必须尽最大程度上与上一次保持相近&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151646356-472439353.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　另外一个要求是实时性，如果按传的规划步骤，对于实时性有要求，或响应速度较高的场景，例如：车间作业的实时调度系统，可能每隔离10分钟就需要刷新一次计划，此时实时规则的作用就反映出来了。如下动图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151718828-280490623.gif&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　&lt;span&gt;　Real-time planning, 顾名思义就是实时规划，它与传统的规划步骤区别在于，它并没有一个结束并退出规划的动作，面是一旦引擎启动，它将以守护进程的形式一直处于运行状态，而没有返回；当它满足规划结束条件时（例如找到符合条件的方案，或到达规划时限）,会进入值守状态，不占用CPU资源。待激发事件对它发出重新启动的指令。因此，它的步骤是: [构建Problem对象] + [构建Solver对象] -&amp;gt; 启动引擎 -&amp;gt; 规划  -&amp;gt; 通过BestSolutionChange事件输出规则方案 -&amp;gt; 休眠 -&amp;gt; 接到重启指令 -&amp;gt; 规则(重重上述步骤)，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151252741-1060750642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　原来Optaplanner还有这种神操作，那么它的作用将进一步大增了，幻想一下大家看科幻或战争电影时，那里的指挥中心必然有一个大屏幕，上面显示了实时的战况或各方资源的部署情况，如果这些部署是需要通过规划来辅助实现的话，Optaplanner是不是可以作为后台超级计算机上不停运算规划的控制中枢系统呢？不过好像想多了。没那么神，做一下实时作业调度还是可以的。下面就看看我们的项目是如何考虑应用Real-time planning的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于Real-Time Planning的具体开发步骤没办法在这里详述，在本系列的往后文章中，老农将会有一篇专门的文章介绍。它的基本步骤如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726142057139-1698070624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　这里提供一下最重要的三个代码块，对应的场景是，当一个新的任务(Task)需要被添加进引擎的Problem中参与规则时，应该如何添加，添加完成之后，如何获得规划的结果。这三个代码块的功能分别是bestSolutionChanged事件处理程序，调用引擎Solver对象提交变更请求，和实现ProblemFactChange接口的实现，用于实现变更正在规划的Planning Entity.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;bestSolutionChanged事件处理程序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; solver是一个Solver对象，引擎入口&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2&lt;/span&gt; solver.addEventListener(&lt;span&gt;new&lt;/span&gt; SolverEventListener&amp;lt;TaskAssignmentSolution&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bestSolutionChanged(BestSolutionChangedEvent&amp;lt;TaskAssignmentSolution&amp;gt;&lt;span&gt; event) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(solver.isEveryProblemFactChangeProcessed()) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: 获取规划结果&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;调用引擎Solver对象提交变更&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; DeleteTaskProblemFactChange taskProblemChange = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeleteTaskProblemFactChange(task);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (solver.isSolving()) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    solver.addProblemFactChange(taskProblemChange);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    taskProblemChange.doChange(scoreDirector);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    scoreDirector.calculateScore();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;ProblemFactChange接口的实现&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 添加任务到Workingsolution
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZhangKent
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AddTaskProblemChange &lt;span&gt;extends&lt;/span&gt; AbstractPersistable &lt;span&gt;implements&lt;/span&gt; ProblemFactChange&amp;lt;TaskAssignmentSolution&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Task task;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AddTaskProblemChange(Task task){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.task =&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doChange(ScoreDirector&amp;lt;TaskAssignmentSolution&amp;gt;&lt;span&gt; scoreDirector) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         TaskAssignmentSolution taskAssignmentSolution =&lt;span&gt; scoreDirector.getWorkingSolution();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         scoreDirector.beforeEntityAdded(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.task);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         taskAssignmentSolution.getTaskList().add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.task);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         scoreDirector.afterEntityAdded(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.task);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        scoreDirector.triggerVariableListeners();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;场景要求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;span&gt;我们的项目其实挺符合实时作业的要求的，虽然我们也没有要求达到分钟级，或秒级的响应；但是如果能够每隔离10分钟，通过实时规划的模式刷新一次计划，还是更能帮助生产调度人员更准确掌握生产情况的。事实上，我们对新的计划刷新条件，并不是按固定的时间间隔来进行，而是以触发事件的方式对进行变更规划的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　即当一个新任务产生了，或一个已计划好的任务被生产完成了，或一个已计划好的任务无法按时执行生产作业而产生计划与实际情况存在差异时，或一个机台出现计划以外的停机等诸如此类对计划足以产生影响的事件，都将会作为触发重新规则的条件。因此，我将引擎程序做成Springboot程序，部署到服务器端，并将程序设计成多线程并发的模式，主线程负责侦听Springboot接收到的WebAPI请求，当接收到请求后，就从线程池中启用一个线程对请求进行处理，这些处理是更新规划的请求，并把传送过来的Planning Enitty, Problem Fact等信息按要求进行处理，并放入队列中。所有请求产生的重新规划信息，通过队列依次被送入引擎处理。当有新的solution产生时，将它输出指定位置，并通知客户端前往获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统的构件结构如下图&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yqfile.alicdn.com/7c3d8fe1cc8c9eff37ead43369b8056cd1c913b0.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　古语有云，理想很丰满，现实很骨感。上述的设计对于Optaplanner的使用领域来说，是比较先进的（起码在国内还没听说过有人这样用法）。对业务而言也是非常符合要求的。但是我对上述所有美妙的构想完成了设计，并实现了代码，并通过Springboot运行起来之后。程序确实如我意图那样运行起来了！启动引擎 -&amp;gt; 开始规则 -&amp;gt; 找到更佳方案 -&amp;gt; 输出方案 -&amp;gt; 满足停止条件 -&amp;gt; 引擎进入守值状态. 好了，我就通过http发出一个删除Planning Entity的请求。Springboot的Contoller成功接收，启动子线程处理数据，向引擎对象发送doChange请求，引擎检测到请求，分出一个线程（这个线程是引擎分出来处理我那个线程请求的）处理成功，并更新Problem对象中的Planning Entity列表；引擎继续运行。Duang~~~~引擎主线程竟然抛出一个异常并停止了！提示那个被请求删除的Planning Entity未被加入Planning Entity的列表中！这下我蒙了。为什么还会报出这个Planning Entity未被加进列表的错误？回想起Optaplanner的开发说明书里，关于Planning过程中，每个新的solution都是一个clone的情况，我坚信我的程序是遇到Race condition了，一定是我的程序考虑不周导致资源竞争。Optaplanner号称经过大量单元测试，压力测试，有良好的稳定性，不可能就这样被我把错误试出来的。但切切实实地抛出了这个异常，而我却没有任何办法。错误信息如下图，下图是我截取给Optaplanner团队的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151321361-964881407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后，我花了两天时间，对每一个步骤进行调试分析，对每一个solution的clone进行核对，我确实没办法从我的程序中找到任何头绪。于是我唯有求助于Geoffrey大神。通过邮件讨论组我给他留了个贴子。很快Geoffrey大神就回复了（这个得给个赞，比利时跟我们的时区相差不少吧？每次提的问题，他都能及时回复）。回复见下图，这个回复令了心被泼了一大桶冷水。它竟然确实可能是一个bug! 当然也有可能是程序产生了race condition. 可我都找了两天了，实在没办法，才想到找Optaplanner团队。然后我就把这个问题的重现步骤在Optaplanner项目的JIRA中提交了一个issue,不知道这算不算我给Optaplanner作出的一点点贡献呢，期待处理结果呀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实在这两天时间时，我并不仅仅是检查我自己的代码是否出现资源竞争问题，我还Debug进了Optaplanner的源代码里(7.8.0.Final版),并找到了异常的具体来源。发现确确实实是在我提交了ProblemFactChanged请求后，引擎也进行了处理，但因为引擎在处理了请求后，在新的Solution的clone中，并没有被成功更新，也就是新的Planning Entity并没有进入新的solution clone中，而导致处理程序无法识别新的Planning Entity, 就出错了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151347873-1101010916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201807/148283-20180726151421980-1320518045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　现在办法有两个，一个是等Optaplanner团队在JIRA上对我提交的issue进行处理，看是不是真的在Optaplanner中存在这么一个Bug. 另一种办法是我打算将我的程序进一步简化，将它与Springboot分离，跟Optaplanner的事件程序一样，通过其它方法启动线程来尝试Real-Time Planning.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Optaplanner引擎程序被包装成一个Springboot程序，并设置为daemon模式(守卫进程)，Springboot Application启动后，引擎执行程序被一个线程启动。主线程向外提供Restful webservice，当有Web请求到达时，就启动一个线程用于执行Optaplanner的ProblemFactChange对象中的doChange方法，对现有solution中的Planning Entity列表中的对象进行增删改操作；并触发VariableListeners. 引擎在处理这些调用时，会产生新的bestSolution，并触发BestSolutionChangedEvent事件，在事件处理方法中，将最新的Solution中的Planning Entity列表输出即可获得增删改Planning Entity后的最新solution了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这又是一篇花费不少精力的东西，尽管最终没实现实时规划服务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创作不易，欢迎转载，请标明出处。&lt;/strong&gt;&lt;/p&gt;



</description>
<pubDate>Thu, 26 Jul 2018 07:18:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/9371720.html</dc:identifier>
</item>
<item>
<title>设计模式 - 单例模式 - 大力dali</title>
<link>http://www.cnblogs.com/renguangli/p/9371966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renguangli/p/9371966.html</guid>
<description>&lt;h3 id=&quot;模式定义&quot;&gt;模式定义&lt;/h3&gt;
&lt;p&gt;单例模式确保一个类只有一个实例，并且对外提供全局的访问方法。&lt;/p&gt;
&lt;p&gt;单例模式有三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是一个类只有一个实例&lt;/li&gt;
&lt;li&gt;二是它必须自行创建这个实例&lt;/li&gt;
&lt;li&gt;三是它必须对外提供全局访问方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模式类图&quot;&gt;模式类图&lt;/h3&gt;
&lt;p&gt;以下是单例模式的UML类图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1351714/201807/1351714-20180726151408598-944528227.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;一般包含三个要素：&lt;br/&gt;1.私有的静态实例对象 private static instance&lt;br/&gt;2.私有的构造函数（保证在该类外部，无法通过new的方式来创建对象实例） private Singleton(){}&lt;br/&gt;3.公有的、静态的、访问该实例对象的方法 public static Singleton getInstance(){}&lt;/p&gt;
&lt;h4 id=&quot;懒汉式单例模式线程不安全-延迟加载&quot;&gt;懒汉式单例模式（线程不安全-延迟加载）&lt;/h4&gt;
&lt;p&gt;懒汉式就是应用刚启动的时候不创建实例，当外部调用获取该类的实例方法时才创建。是以** 时间换空间 ** 。&lt;br/&gt;实例被延迟加载，这样做的好处是，如果没有用到该类，那么静态变量instance就不会被实例化，从而节省资源。&lt;br/&gt;懒汉式单例模式是线程不安全的，在多线程环境下instance可能会被多次实例化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Singleton 懒汉式单例模式（线程不安全-延迟加载）
 */
public class Singleton {
    private static Singleton instance;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;懒汉式单例模式线程安全-延迟加载&quot;&gt;懒汉式单例模式（线程安全-延迟加载）&lt;/h4&gt;
&lt;p&gt;对getInstance()方法加锁之后，同一时间只有一个线程访问该方法，这样就避免了instance被多次实例化。&lt;br/&gt;getInstance()方法由于加了synchronized关键字，当有一个线程获得锁并访问该方法时，其他线程处于阻塞状态，一定程度上对性能有所损耗。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Singleton 懒汉式单例模式（线程安全-延迟加载）
 */
public class Singleton {
    private static Singleton instance;
    private Singleton(){}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;饿汉式单例模式线程安全&quot;&gt;饿汉式单例模式（线程安全）&lt;/h4&gt;
&lt;p&gt;饿汉式就是应用刚启动的时候，不管外部有没有调用该类的实例方法，该类的实例就已经创建好了。是以 ** 空间换时间 ** 。&lt;br/&gt;饿汉式单例在类初始化时就创建好一个静态的对象供外部使用,所以本身就是线程安全的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** 
 * Singleton 饿汉式单例模式（线程安全）
 */
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance() {
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;双重校验锁单例模式线程安全-延迟加载&quot;&gt;双重校验锁单例模式（线程安全-延迟加载）&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Singleton 双重校验锁单例模式（线程安全-延迟加载）
 *
 * @author renguangli 2018/7/23 16:59
 * @since JDK 1.8
 */
public class Singleton {
    private static volatile Singleton instance;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在进入synchronized块之前加入判空逻辑，只有instance在没有被实例化之前才进入同步块，instance实例化之后就不会在进入同步块里了，效率当然也会提高。&lt;/p&gt;
&lt;p&gt;是否有必要加volatile关键字？&lt;/p&gt;
&lt;p&gt;我们都知道instance = new Singleton()这段代码是分三步运行的&lt;br/&gt;1、分配内存空间&lt;br/&gt;2、实例化对象&lt;br/&gt;3、将instance指向分配的内存地址&lt;/p&gt;
&lt;p&gt;由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1&amp;gt;3&amp;gt;2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以致于程序运行出错。&lt;/p&gt;
&lt;p&gt;使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。所以还是有必要加上volatile关键字的。&lt;/p&gt;
&lt;h4 id=&quot;静态内部类实现线程安全-延迟加载&quot;&gt;静态内部类实现(线程安全-延迟加载)&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Singleton 静态内部单例模式(线程安全-延迟加载)
 */
public class Singleton {
    private static class SingletonHolder{
        private static Singleton instance = new Singleton();
    }
    private Singleton(){}
    public static Singleton getInstance() {
        return SingletonHolder.instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于静态内部类的特性，只有在其被第一次引用的时候才会被加载，所以可以保证其线程安全性。&lt;/p&gt;
&lt;p&gt;由于在调用 SingletonHolder.instance 的时候，才会对单例进行初始化，而且通过反射，是不能从外部类获取内部类的属性的。&lt;br/&gt;所以这种形式，很好的避免了反射入侵。&lt;/p&gt;
&lt;h4 id=&quot;基于cas实现的单例模式线程安全-延迟加载&quot;&gt;基于cas实现的单例模式(线程安全-延迟加载)&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Singleton cas实现的单例模式(线程安全-延迟加载)
 */
public class Singleton {
    public static AtomicInteger count = new AtomicInteger(0);
    private Singleton() {}
    public static Singleton getInstance() {
        for (;;) {
            Singleton singleton = INSTANCE.get();
            if (null != singleton) {
                return singleton;
            }

            singleton = new Singleton();
            if (INSTANCE.compareAndSet(null, singleton)) {
                return singleton;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cas实现的单例模式，它可以保证获取到的实例是唯一的，但是不能保证instance被多次实例化.&lt;/p&gt;
&lt;h4 id=&quot;基于枚举实现的单例模式&quot;&gt;基于枚举实现的单例模式&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 枚举实现的单例模式(线程安全)
 */
public enum  Singleton {
    INSTANCE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是 Effective Java 极力推荐的一种，代码为各种实现中最简单的,其实现，完全是基于枚举类的特性，可以说天生受到了 JVM 的支持，而且既不用思考反射，也不用考虑多线程，对于自身的循环引用，本质上也是一个对象。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 07:16:00 +0000</pubDate>
<dc:creator>大力dali</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renguangli/p/9371966.html</dc:identifier>
</item>
<item>
<title>Java面向对象之继承，方法重写，super关键字，员工类系列继承题 - 吻泪</title>
<link>http://www.cnblogs.com/lzw123-/p/9371621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzw123-/p/9371621.html</guid>
<description>&lt;p&gt;在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; 子类 &lt;span&gt;extends&lt;/span&gt; 父类 {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;继承的好处&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1、继承的出现提高了代码的复用性，提高软件开发效率。&lt;/p&gt;
&lt;p&gt;　　2、继承的出现让类与类之间产生了关系，提供了多态的前提。&lt;/p&gt;
&lt;p class=&quot;Java&quot;&gt;&lt;span&gt;在继承中需要注意的问题&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;　　　　class A{}&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;　　　　class B{}&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;　　　　class C extends A,B{}  // C类&lt;span&gt;不可以同时继承A类和B类&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　2、多个类可以继承一个父类，例如下面这种情况是允许的。&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;　　　　class A{}&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;　　　　class B extends A{}&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;　　　　class C extends A{}   // 类B和类C都可以继承类A&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;     class A{}&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;     class B extends A{}   // 类B继承类A，类B是类A的子类&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;     class C extends B{}   // 类C继承类B，类C是类B的子类，同时也是类A的子类&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;&lt;span&gt;&lt;strong&gt;super关键字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;在子类中，访问父类中的成员变量格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;super&lt;/span&gt;.父类中的成员变量
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fu
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Fu中的成员变量。&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; num = 5&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Zi &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Fu
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Zi中的成员变量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; num = 6&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; show()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子父类中出现了同名的成员变量时
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在子类中需要访问父类中非私有成员变量时，需要使用super关键字
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问父类中的num&lt;/span&gt;
        System.out.println(&quot;Fu num=&quot;+&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.num);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问子类中的num2&lt;/span&gt;
        System.out.println(&quot;Zi num2=&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.num);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo5 
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) 
    {
        Zi z &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Zi(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建子类对象&lt;/span&gt;
        z.show(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用子类中的show方法&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt; 方法重写（覆盖）的应用：&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。&lt;/p&gt;
&lt;p&gt;举例：比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，后期由于手机需要在来电显示功能中增加显示姓名和头像，这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能。&lt;/p&gt;
&lt;p class=&quot;a0&quot;&gt;在子类中，访问父类中的成员方法格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;super&lt;/span&gt;.父类中的成员方法();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NewPhone().showNum();
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Phone{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendMessage(){
        System.out.println(&lt;/span&gt;&quot;发短信&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call(){
        System.out.println(&lt;/span&gt;&quot;打电话&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showNum(){
        System.out.println(&lt;/span&gt;&quot;来电显示号码&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;智能手机类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; NewPhone &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Phone{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showNum(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用父类已经存在的功能使用super&lt;/span&gt;
        &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.showNum();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加自己特有显示姓名和图片功能&lt;/span&gt;
        System.out.println(&quot;显示来电姓名&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;显示头像&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;重写需要注意的细节问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　子类方法覆盖父类方法，必须要保证权限大于等于父类权限。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　 写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　抽象类不可以创建对象&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;&lt;span&gt;&lt;strong&gt;员工系列例题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　某IT公司有多名员工，按照员工负责的工作不同，进行了部门的划分（研发部员工、维护部员工）。研发部根据所需研发的内容不同，又分为JavaEE工程师、Android工程师；维护部根据所需维护的内容不同，又分为网络维护工程师、硬件维护工程师。&lt;/p&gt;
&lt;p&gt;公司的每名员工都有他们自己的员工编号、姓名，并要做它们所负责的工作。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1413463/201807/1413463-20180726145236340-305124188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;a&quot;&gt;工作内容&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　 JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　 Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机&lt;/p&gt;
&lt;p&gt;请根据描述，完成员工体系中所有类的定义，并指定类之间的继承关系。进行XX工程师类的对象创建，完成工作方法的调用。&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;h2&gt;1.1      案例分析&lt;/h2&gt;
&lt;p class=&quot;a&quot;&gt;根据上述部门的描述，得出如下的员工体系图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1413463/201807/1413463-20180726145503522-243106605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;a&quot;&gt;根据员工信息的描述，确定每个员工都有员工编号、姓名、要进行工作。则，把这些共同的属性与功能抽取到父类中（员工类），关于工作的内容由具体的工程师来进行指定。工作内容&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　 JavaEE工程师：员工号为xxx的 xxx员工，正在研发淘宝网站&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　Android工程师：员工号为xxx的 xxx员工，正在研发淘宝手机客户端软件&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　　网络维护工程师：员工号为xxx的 xxx员工，正在检查网络是否畅通&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; 　　硬件维护工程师：员工号为xxx的 xxx员工，正在修复打印机&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;　创建JavaEE工程师对象，完成工作方法的调用&lt;/p&gt;
&lt;p class=&quot;a&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;a&quot;&gt;定义员工类(抽象类)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String id;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 员工编号&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 员工姓名&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作方法（抽象方法）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work(); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;定义研发部员工类Developer 继承 员工类Employee&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Developer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Employee {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;定义维护部员工类Maintainer 继承 员工类Employee&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Maintainer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Employee {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;定义JavaEE工程师 继承 研发部员工类，重写工作方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JavaEE &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Developer {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝网站&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt; 定义Android工程师 继承 研发部员工类，重写工作方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Android &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Developer {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在研发淘宝手机客户端软件&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt; 定义Network网络维护工程师 继承 维护部员工类，重写工作方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Network &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Maintainer {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在检查网络是否畅通&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;定义Hardware硬件维护工程师 继承 维护部员工类，重写工作方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Hardware &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Maintainer {
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        System.out.println(&lt;/span&gt;&quot;员工号为 &quot; + getId() + &quot; 的 &quot; + getName() + &quot; 员工，正在修复打印机&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;a&quot;&gt;在测试类中，创建JavaEE工程师对象，完成工作方法的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建JavaEE工程师员工对象&lt;/span&gt;
        JavaEE ee = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JavaEE();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该员工的编号&lt;/span&gt;
        ee.setId(&quot;000015&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置该员工的姓名&lt;/span&gt;
        ee.setName(&quot;小明&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用该员工的工作方法&lt;/span&gt;
&lt;span&gt;        ee.work();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 26 Jul 2018 07:00:00 +0000</pubDate>
<dc:creator>吻泪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzw123-/p/9371621.html</dc:identifier>
</item>
<item>
<title>springboot情操陶冶-SpringApplication(一) - 南柯问天</title>
<link>http://www.cnblogs.com/question-sky/p/9366500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/question-sky/p/9366500.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SpringApplication是所有springboot的入口类，分析此类有助于我们了解springboot的工作机制。本文以&lt;em&gt;2.0.3.REALEASE&lt;/em&gt;版本作分析&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;springapplication&quot;&gt;SpringApplication&lt;/h3&gt;
&lt;p&gt;调用实例如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.example.demospringbootweb;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoSpringbootWebApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoSpringbootWebApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用的是&lt;strong&gt;SpringApplication.run()&lt;/strong&gt;方法进行应用程序的启动。代码很简单也容易让用户上手，笔者这就进入其具体的类以探瑰宝。&lt;/p&gt;
&lt;h3 id=&quot;注释描述&quot;&gt;注释描述&lt;/h3&gt;
&lt;p&gt;先看下其官方注释，有助于我们入门。由于注释过长，笔者此处只对其主要内容作下翻译总结&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以简单的通过&lt;em&gt;main()&lt;/em&gt;函数来辅助启动一个spring应用程序。默认情况下其会按照以下步骤来辅助我们创建的应用
&lt;ul&gt;&lt;li&gt;创建一个关联的&lt;strong&gt;ApplicationContext&lt;/strong&gt;实例&lt;/li&gt;
&lt;li&gt;注册&lt;strong&gt;CommandLinePropertySource&lt;/strong&gt;实例暴露命令行的参数作为spring的属性&lt;/li&gt;
&lt;li&gt;刷新&lt;strong&gt;ApplicationContext&lt;/strong&gt;，并加载所有的单例beans&lt;/li&gt;
&lt;li&gt;触发实现了&lt;strong&gt;CommandLineRunner&lt;/strong&gt;的实例beans&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SpringApplications&lt;/strong&gt;可以读取来自不同源的beans。官方建议用户使用&lt;strong&gt;@Configuration&lt;/strong&gt;注解相应的启动类，当然也支持从以下方式加载相应的beans
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;AnnotatedBeanDefinitionReader&lt;/strong&gt;加载指定的类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XmlBeanDefinitionReader&lt;/strong&gt;加载XML的配置信息或者&lt;strong&gt;GroovyBeanDefinitionReader&lt;/strong&gt;加载groovy脚本资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ClassPathBeanDefinitionScanner&lt;/strong&gt;扫描指定的包加载相应bean&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;过于抽象，笔者继续通过源码来对上述的内容进行回顾&lt;/p&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Create a new {@link SpringApplication} instance. The application context will load
     * beans from the specified primary sources (see {@link SpringApplication class-level}
     * documentation for details. The instance can be customized before calling
     * {@link #run(String...)}.
     * @param resourceLoader the resource loader to use
     * @param primarySources the primary bean sources
     * @see #run(Class, String[])
     * @see #setSources(Set)
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) {
        this.resourceLoader = resourceLoader;
        // 加载的主类，可指定多个
        Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
        this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources));
        // 推断是否为web环境
        this.webApplicationType = deduceWebApplicationType();
        // 加载ApplicationContextInitializer接口类
        setInitializers((Collection) getSpringFactoriesInstances(
                ApplicationContextInitializer.class));
        // 加载ApplicationListener接口类
        setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
        // 推断主函数类
        this.mainApplicationClass = deduceMainApplicationClass();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对上述的注释作下简单的解释&lt;/p&gt;
&lt;h4 id=&quot;springapplicationdeducewebapplicationtype&quot;&gt;SpringApplication#deduceWebApplicationType()&lt;/h4&gt;
&lt;p&gt;推断是否为web环境，源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private WebApplicationType deduceWebApplicationType() {
        if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null)
                &amp;amp;&amp;amp; !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null)) {
            return WebApplicationType.REACTIVE;
        }
        for (String className : WEB_ENVIRONMENT_CLASSES) {
            if (!ClassUtils.isPresent(className, null)) {
                return WebApplicationType.NONE;
            }
        }
        return WebApplicationType.SERVLET;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码层看总共有三种应用类型，也代表了三个环境类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;WebApplicationType.REACTIVE&lt;/strong&gt; reactive web应用(classpath环境下须有&lt;em&gt;org.springframework.web.reactive.DispatcherHandler&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WebApplicationType.SERVLET&lt;/strong&gt; servlet web应用(classpath环境下存在&lt;em&gt;javax.servlet.Servlet&lt;/em&gt;或者&lt;em&gt;org.springframework.web.context.ConfigurableWebApplicationContext&lt;/em&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WebApplicationType.NONE&lt;/strong&gt; 简单的JAVA应用(classpath环境不存在上述的类)&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;springapplicationdeducemainapplicationclass&quot;&gt;SpringApplication#deduceMainApplicationClass()&lt;/h4&gt;
&lt;p&gt;推断主函数类，源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private Class&amp;lt;?&amp;gt; deduceMainApplicationClass() {
        try {
            StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
            for (StackTraceElement stackTraceElement : stackTrace) {
                if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {
                    return Class.forName(stackTraceElement.getClassName());
                }
            }
        }
        catch (ClassNotFoundException ex) {
            // Swallow and continue
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，就是寻找哪个类下含有&lt;em&gt;main&lt;/em&gt;方法，此处和我们常用的启动类不谋而合&lt;/p&gt;
&lt;h4 id=&quot;springapplicationgetspringfactoriesinstances&quot;&gt;SpringApplication#getSpringFactoriesInstances()&lt;/h4&gt;
&lt;p&gt;找寻相应的接口实现类，源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; type,
            Class&amp;lt;?&amp;gt;[] parameterTypes, Object... args) {
        // 上下文classLoader
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        // 通过SpringFactoriesLoader来加载相应的类
        Set&amp;lt;String&amp;gt; names = new LinkedHashSet&amp;lt;&amp;gt;(
                SpringFactoriesLoader.loadFactoryNames(type, classLoader));
        List&amp;lt;T&amp;gt; instances = createSpringFactoriesInstances(type, parameterTypes,
                classLoader, args, names);
        AnnotationAwareOrderComparator.sort(instances);
        return instances;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进而查看相应的静态方法&lt;strong&gt;SpringFactoriesLoader.loadFactoryNames()&lt;/strong&gt;，源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static List&amp;lt;String&amp;gt; loadFactoryNames(Class&amp;lt;?&amp;gt; factoryClass, @Nullable ClassLoader classLoader) {
        String factoryClassName = factoryClass.getName();
        // 关键处理类
        return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键处理类出来了，源码跟上&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private static Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
        // 缓存处理
        MultiValueMap&amp;lt;String, String&amp;gt; result = cache.get(classLoader);
        if (result != null) {
            return result;
        }

        try {
            // 找寻所有classpath下的&quot;META-INF/spring.factories&quot;文件
            Enumeration&amp;lt;URL&amp;gt; urls = (classLoader != null ?
                    classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
                    ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
            result = new LinkedMultiValueMap&amp;lt;&amp;gt;();
            while (urls.hasMoreElements()) {
                URL url = urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                for (Map.Entry&amp;lt;?, ?&amp;gt; entry : properties.entrySet()) {
                    // 对含有,的进行分隔并转为list集合
                    List&amp;lt;String&amp;gt; factoryClassNames = Arrays.asList(
                            StringUtils.commaDelimitedListToStringArray((String) entry.getValue()));
                    result.addAll((String) entry.getKey(), factoryClassNames);
                }
            }
            cache.put(classLoader, result);
            return result;
        }
        catch (IOException ex) {
            throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +
                    FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;由此我们得出结论，classpath环境下所有含&lt;strong&gt;META-INF/spring.factories&lt;/strong&gt;的文件，里面约定了默认的实现。笔者以&lt;strong&gt;spring-boot-2.0.3.REALEASE.jar&lt;/strong&gt;为例&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;# PropertySource Loaders
org.springframework.boot.env.PropertySourceLoader=\
org.springframework.boot.env.PropertiesPropertySourceLoader,\
org.springframework.boot.env.YamlPropertySourceLoader

# Run Listeners
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener

# Error Reporters
org.springframework.boot.SpringBootExceptionReporter=\
org.springframework.boot.diagnostics.FailureAnalyzers

# Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener

# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=\
org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\
org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\
org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor

# Failure Analyzers
org.springframework.boot.diagnostics.FailureAnalyzer=\
org.springframework.boot.diagnostics.analyzer.BeanCurrentlyInCreationFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BeanNotOfRequiredTypeFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BindFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.BindValidationFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.UnboundConfigurationPropertyFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.ConnectorStartFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.NoUniqueBeanDefinitionFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.PortInUseFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.ValidationExceptionFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyNameFailureAnalyzer,\
org.springframework.boot.diagnostics.analyzer.InvalidConfigurationPropertyValueFailureAnalyzer

# FailureAnalysisReporters
org.springframework.boot.diagnostics.FailureAnalysisReporter=\
org.springframework.boot.diagnostics.LoggingFailureAnalysisReporter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此SpringApplication构造函数中加载的&lt;strong&gt;ApplicationContextInitializer&lt;/strong&gt;类有如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConfigurationWarningsApplicationContextInitializer (对ComponentScan指定的值为&quot;org&quot;等进行报警输出)&lt;/li&gt;
&lt;li&gt;ContextIdApplicationContextInitializer (创建默认名为application的ContextId对象，也可通过spring.application.name指定)&lt;/li&gt;
&lt;li&gt;DelegatingApplicationContextInitializer (对context.initializer.classes指定的class集合进行加载)&lt;/li&gt;
&lt;li&gt;ServerPortInfoApplicationContextInitializer (将local.server.port设置为指定的web端口，默认为8080)&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;hr/&gt;&lt;p&gt;而加载的&lt;strong&gt;ApplicationListener&lt;/strong&gt;类有如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ClearCachesApplicationListener (反射工具缓存清空事件)&lt;/li&gt;
&lt;li&gt;ParentContextCloserApplicationListener (父ApplicationContext关闭事件)&lt;/li&gt;
&lt;li&gt;FileEncodingApplicationListener (系统变量配置的file.encoding值是否与环境变量spring.mandatory-file-encoding一致事件)&lt;/li&gt;
&lt;li&gt;AnsiOutputApplicationListener (控制台彩色输出事件，可通过spring.output.ansi.enabled来指定)&lt;/li&gt;
&lt;li&gt;ConfigFileApplicationListener (读取spring.profile.active/spring.profile.include配置)&lt;/li&gt;
&lt;li&gt;DelegatingApplicationListener (委托事件处理类)&lt;/li&gt;
&lt;li&gt;ClasspathLoggingApplicationListener (打印classpath信息，级别为debug)&lt;/li&gt;
&lt;li&gt;LoggingApplicationListener (日志处理事件)&lt;/li&gt;
&lt;li&gt;LiquibaseServiceLocatorApplicationListener (classpath是否存在liquibase的CustomResolverServiceLocator类判断事件)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由此SpringApplication构造函数完成了一些必要的初始化，重点在于&lt;strong&gt;ApplicationContextInitializer&lt;/strong&gt;和&lt;strong&gt;ApplicationListener&lt;/strong&gt;接口类。并且通过&lt;em&gt;构造函数反射&lt;/em&gt;来进行实例化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限于篇幅过长，笔者将对&lt;em&gt;SpringApplication#run()&lt;/em&gt;方法的具体解析放于下一章节来分析&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 06:51:00 +0000</pubDate>
<dc:creator>南柯问天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/question-sky/p/9366500.html</dc:identifier>
</item>
<item>
<title>CBAM: 卷积块注意模块 - ayew</title>
<link>http://www.cnblogs.com/ansang/p/9371764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ansang/p/9371764.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;CBAM:&lt;/strong&gt; &lt;strong&gt;卷积块注意模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;简介：&lt;/strong&gt;我们提出了卷积块注意模块 (CBAM), 一个简单而有效的注意模块的前馈卷积神经网络。给出了一个中间特征映射, 我们的模块按照两个独立的维度、通道和空间顺序推断出注意力映射, 然后将注意力映射相乘为自适应特征细化的输入特征映射。因为 CBAM 是一个轻量级和通用的模块, 它可以无缝地集成到任何 CNN 架构只增加微不足道的间接开销, 可以集成到端到端的CNN里面去。通过对 ImageNet-1K、COCO、MS 检测和 VOC 2007 检测数据集的广泛实验, 我们验证了我们的 CBAM。我们的实验表明, 各种模型的分类和检测性能都有了一致的改进, 证明了 CBAM 的广泛适用性。这些代码和模型将公开提供。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144033470-1618255006.png&quot; alt=&quot;&quot; width=&quot;1129&quot; height=&quot;469&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;网络架构的构建，一直是计算机视觉中最重要的研究之一, 因为精心设计的网络确保了在各种应用中显著的性能提高。自成功实施大型 CNN以来, 已经提出了一系列广泛的体系结构。一种直观而简单的扩展方法是增加神经网络的深度如 VGG-NET、ResNet及其变体,如 WideResNet和 ResNeXt。GoogLeNet展现了增加网络的宽度对于结果的提升的帮助，典型的分类网络都在提升深度与宽度上下了很大功夫。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;众所周知, 注意力在人的知觉中起着重要的作用。一个人并不是试图一次处理整个场景。相反, 人类注意部分场景, 并有选择地专注于突出部分, 以便更好地捕捉视觉结构。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;最近, 有几次尝试加入注意处理, 以提高CNNs在大规模分类任务的性能。Residual attention network for image classification中使用 encoder-decoder 样式的注意模块的Residual attention network。通过细化特征映射,不仅网络性能良好, 而且对噪声输入也很健壮。我们不直接计算3d 的注意力映射, 而是分解了单独学习通道注意和空间注意的过程。对于3D 特征图, 单独的注意生成过程的计算和参数开销要小得多, 因此可以作为CNN的前置基础架构的模块使用。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;Squeeze-and-excitation networks引入一个紧凑模块来利用通道间的关系。在他们的&lt;em&gt;压缩和激励&lt;/em&gt;模块中, 他们使用全局平均池功能来计算通道的注意力。然而, 我们表明, 这些都是次优特征, 以推断良好的通道注意, 我们使用最大池化的特点。然而，他们也错过了空间注意力机制, 在决定 &quot;Where&quot;。在我们的 CBAM 中, 我们利用一个有效的体系结构来开发空间和通道的注意力, 并通过经验验证, 利用两者都优于仅使用通道的注意作为。此外, 我们的实验表明, 我们的模块在检测任务 (MS COCO和 VOC2017)上是有效的。特别是, 我们通过将我们的模块放在VOC2007 测试集中的现有的目标检测器结合实现了最先进的性能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给定一个中间特征映射&lt;strong&gt;F&lt;/strong&gt;∈R&lt;em&gt;&lt;sup&gt;C&lt;/sup&gt;&lt;/em&gt; &lt;sup&gt;x&lt;em&gt;H&lt;/em&gt;x&lt;em&gt;W&lt;/em&gt;&lt;/sup&gt;作为输入, CBAM的1维通道注意图&lt;strong&gt;M&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt; ∈R&lt;em&gt;&lt;sup&gt;C&lt;/sup&gt;&lt;/em&gt; &lt;sup&gt;×1×1&lt;/sup&gt; 和2D 空间注意图&lt;strong&gt;M&lt;sub&gt;s&lt;/sub&gt;&lt;/strong&gt; ∈R&lt;sup&gt;1×&lt;em&gt;H&lt;/em&gt;x&lt;em&gt;W&lt;/em&gt;&lt;/sup&gt; 如图1所示。总的注意过程可以概括为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726145355035-1492322057.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;108&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726145134424-102112.png&quot; alt=&quot;&quot; width=&quot;25&quot; height=&quot;19&quot;/&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;表示逐元素相乘。在相乘过程中，注意值被广播。相应地，通道注意值被沿着空间维度广播，反之亦然。&lt;strong&gt;F’’&lt;/strong&gt;是最终输出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144136256-1509796362.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.1 Channel attention module&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们利用特征的通道间关系, 生成了通道注意图。当一个特征图的每个通道被考虑作为特征探测器, 通道注意聚焦于 ' what ' 是有意义的输入图像。为了有效地计算通道的注意力, 我们压缩了输入特征图的空间维数。为了聚焦空间信息，我们同时使用平均池化和最大池化。我们的实验证实, 同时使用这两种功能大大提高了网络的表示能力。下面将描述详细操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         我们首先使用平均池化和最大池化操作来聚合特征映射的空间信息, 生成两个不同的空间上下文描述符:&lt;strong&gt;F&lt;sup&gt;c&lt;/sup&gt;&lt;sub&gt;avg&lt;/sub&gt;&lt;/strong&gt; 和&lt;strong&gt;F&lt;sup&gt;c&lt;/sup&gt;&lt;sub&gt;max&lt;/sub&gt;&lt;/strong&gt; , 分别表示平均池化和最大池化。两个描述符然后送到一个共享网络, 以产生我们的通道注意力图 &lt;strong&gt;M&lt;/strong&gt;&lt;sub&gt;c&lt;/sub&gt; ∈ R&lt;em&gt;&lt;sup&gt;c&lt;/sup&gt;&lt;/em&gt;&lt;sup&gt;×1×1&lt;/sup&gt;。共享网络由多层感知机(MLP) 和一个隐藏层组成。为了减少参数开销, 隐藏的激活大小被设置为 &lt;strong&gt;r&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;sup&gt;c/c++&lt;/sup&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;sup&gt;×1×1&lt;/sup&gt;&lt;/strong&gt;, 其中 &lt;em&gt;r&lt;/em&gt; 是压缩率。在将共享网络应用于每个描述符之后, 我们使用逐元素求和合并输出特征向量。简而言之, 频道的注意力被计算为:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;M&lt;sub&gt;c&lt;/sub&gt;&lt;/strong&gt;(&lt;strong&gt;f&lt;/strong&gt;) = &lt;em&gt;σ&lt;/em&gt;(&lt;em&gt;MLP&lt;/em&gt;(&lt;em&gt;AvgPool&lt;/em&gt;(&lt;strong&gt;f&lt;/strong&gt;)) + &lt;em&gt;MLP&lt;/em&gt;(&lt;em&gt;MaxPool&lt;/em&gt;(&lt;strong&gt;f&lt;/strong&gt;)))&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;em&gt;= σ(W&lt;sub&gt;1&lt;/sub&gt;(W&lt;sub&gt;0&lt;/sub&gt;(&lt;/em&gt;&lt;strong&gt;F&lt;sup&gt;c&lt;/sup&gt;&lt;sub&gt;avg&lt;/sub&gt;&lt;/strong&gt;&lt;em&gt;)) + W&lt;sub&gt;1&lt;/sub&gt;(W&lt;sub&gt;0&lt;/sub&gt;(&lt;/em&gt;&lt;strong&gt;F&lt;sup&gt;c&lt;/sup&gt;&lt;sub&gt;max&lt;/sub&gt;&lt;/strong&gt;&lt;em&gt;)))&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;em&gt; &lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;σ&lt;/em&gt;&lt;em&gt;是&lt;/em&gt;sigmoid function，W&lt;sub&gt;0&lt;/sub&gt; ∈ R&lt;em&gt;&lt;sup&gt;C/r&lt;/sup&gt;&lt;/em&gt; × &lt;sup&gt;C&lt;/sup&gt;, W&lt;sub&gt;1&lt;/sub&gt; ∈ R&lt;em&gt;&lt;sup&gt;C&lt;/sup&gt;&lt;/em&gt; × &lt;sup&gt;C&lt;em&gt;/r&lt;/em&gt;&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;W&lt;sub&gt;0&lt;/sub&gt; ,W&lt;sub&gt;1&lt;/sub&gt;  是多层感知机的权重，共享输入和W&lt;sub&gt;0&lt;/sub&gt; 的RELU激活函数。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.2 Spatial attention module&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们利用特征间的空间关系, 生成空间注意图。与通道注意力不同的是, 空间注意力集中在 &quot;where&quot; 是一个信息的部分, 这是对通道注意力的补充。为了计算空间注意力, 我们首先在通道轴上应用平均池和最大池运算, 并将它们连接起来以生成一个有效的特征描述符。在串联特征描述符上, 我们应用7×7的卷积生成空间注意图的层&lt;strong&gt;M&lt;sub&gt;s&lt;/sub&gt;&lt;/strong&gt; (&lt;strong&gt;F&lt;/strong&gt;) ∈&lt;strong&gt;R&lt;/strong&gt;&lt;em&gt;&lt;sup&gt;H&lt;/sup&gt;&lt;/em&gt;×&lt;em&gt;&lt;sup&gt;W&lt;/sup&gt;&lt;/em&gt; 。我们描述下面的详细操作.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;我们使用两个池化操作来聚合功能映射的通道信息, 生成两个2维映射:&lt;strong&gt;F&lt;sup&gt;s&lt;/sup&gt;&lt;sub&gt;avg&lt;/sub&gt;&lt;/strong&gt;∈R&lt;sup&gt;1×&lt;em&gt;H&lt;/em&gt;x&lt;em&gt;W&lt;/em&gt;&lt;/sup&gt; 和&lt;strong&gt;F&lt;sup&gt;s&lt;/sup&gt;&lt;sub&gt;max&lt;/sub&gt;&lt;/strong&gt;∈R&lt;sup&gt;1×&lt;em&gt;H&lt;/em&gt;x&lt;em&gt;W&lt;/em&gt;&lt;/sup&gt; 每个通道都表示平均池化和最大池化。然后通过一个标准的卷积层连接和卷积混合, 产生我们的2D 空间注意图。简而言之, 空间注意力被计算为:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;M&lt;sub&gt;s&lt;/sub&gt;&lt;/strong&gt; (&lt;strong&gt;f&lt;/strong&gt;) = &lt;em&gt;σ&lt;/em&gt;( f&lt;sup&gt;7×7&lt;/sup&gt;( &lt;em&gt;AvgPool&lt;/em&gt;(&lt;strong&gt;f&lt;/strong&gt;) ; &lt;em&gt;MaxPool&lt;/em&gt;(&lt;strong&gt;F&lt;/strong&gt;)] )))&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;= &lt;em&gt;σ&lt;/em&gt;(f&lt;sup&gt;7×7&lt;/sup&gt; (&lt;strong&gt;F&lt;sup&gt;s&lt;/sup&gt;&lt;sub&gt;avg&lt;/sub&gt;&lt;/strong&gt;; &lt;strong&gt;F&lt;sup&gt;s&lt;/sup&gt;&lt;sub&gt;max&lt;/sub&gt;&lt;/strong&gt;]))&lt;em&gt;,&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;σ&lt;/em&gt;&lt;em&gt;是&lt;/em&gt;sigmoid function, f&lt;sup&gt;7×7&lt;/sup&gt; 是7×7的卷积。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144459059-2007900848.png&quot; alt=&quot;&quot; width=&quot;1070&quot; height=&quot;359&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过实验我们发现串联两个注意力模块的效果要优于并联。通道注意力放在前面要优于空间注意力模块放在前面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在本小节中，我们凭实验证明了我们的设计选择的有效性。 在这次实验中，我们使用ImageNet-1K数据集并采用ResNet-50作为基础架构。 ImageNet-1K分类数据集[1]由1.2组成用于训练的百万个图像和用于1,000个对象类的验证的50,000个图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们采用相同的数据增强方案进行训练和测试时间进行单一作物评估，大小为224×224。 学习率从0.1开始，每30个时期下降一次。 我们训练网络90迭代。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.1 通道注意力和空间注意力机制实验&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144250831-1653429421.png&quot; alt=&quot;&quot; width=&quot;897&quot; height=&quot;271&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144310694-746195670.png&quot; alt=&quot;&quot; width=&quot;1091&quot; height=&quot;395&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144349418-1928383698.png&quot; alt=&quot;&quot; width=&quot;1041&quot; height=&quot;314&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144423535-817687700.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144554626-412812752.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144619002-1718539452.png&quot; alt=&quot;&quot; width=&quot;1055&quot; height=&quot;440&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.2我们使用Grad-CAM进行网络可视化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144654872-1114801498.png&quot; alt=&quot;&quot; width=&quot;1022&quot; height=&quot;565&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144725622-1491830830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.3 CNAM在目标检测的结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144801288-645232891.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269652/201807/1269652-20180726144814328-746959158.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;作者提出了一种提高 CNN 网络表示力的新方法--卷积瓶颈注意模块 (CBAM)。作者将基于注意力的特征细化成两个不同的模块、通道和空间结合起来, 实现了显著的性能改进, 同时保持了小的开销。对于通道的关注,使用最大池化和平均池化，最终模块 (CBAM) 学习了如何有效地强调或压缩提取中间特征。为了验证它的有效性, 我们进行了广泛的实验与并证实, CBAM 优于所有基线上的三不同的基准数据集: ImageNet-1K, COCO, 和 VOC 2007。此外, 我们可视化模块如何准确推断给定的输入图像。CBAM 或许会成为各种网络体系结构的重要组成部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 06:49:00 +0000</pubDate>
<dc:creator>ayew</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ansang/p/9371764.html</dc:identifier>
</item>
<item>
<title>macOS 系统 .DS_Store 文件详解 - 舆图易稿</title>
<link>http://www.cnblogs.com/shockerli/p/macos-ds_store.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shockerli/p/macos-ds_store.html</guid>
<description>&lt;h2 id=&quot;ds_store-文件&quot;&gt;.DS_Store 文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.DS_Store&lt;/code&gt; 是 Finder 用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。&lt;/p&gt;
&lt;h2 id=&quot;显示隐藏-mac-隐藏文件&quot;&gt;显示/隐藏 Mac 隐藏文件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;显示&lt;/strong&gt;：&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐藏&lt;/strong&gt;：&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;删除-.ds_store-文件&quot;&gt;删除 .DS_Store 文件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;find /path/to/files -name &quot;.DS_Store&quot; -delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find /path/to/files –type f –name &quot;.DS_Store&quot; -print –delete&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find /path/to/files –type f –name &quot;.DS_Store&quot; -print0 | xargs –0 rm -rdf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;配置-svn-忽略-.ds_store-文件&quot;&gt;配置 SVN 忽略 .DS_Store 文件&lt;/h2&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;编辑&lt;code&gt;~/.subversion/config&lt;/code&gt;文件；&lt;/li&gt;
&lt;li&gt;找到&lt;code&gt;global-ignores&lt;/code&gt;配置项，取消注释；&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;添加上自己要忽略的文件，用空格隔开&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;global-ignores = *.iml .idea .DS_Store .sass-cache node_modules *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a *.pyc *.pyo&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是针对客户端的全局修改，不会对 SVN 服务端有影响，忽略的文件列表不会再出现在 SVN 的操作中。&lt;/p&gt;
&lt;h2 id=&quot;防止-.ds_store-文件生成&quot;&gt;防止 .DS_Store 文件生成&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;defaults write com.apple.desktopservices DSDontWriteNetworkStorestrue true&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置-git-忽略-.ds_store-文件&quot;&gt;配置 Git 忽略 .DS_Store 文件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;.gitignore&lt;/code&gt; 配置文件用于配置不需要加入版本管理的文件&lt;/li&gt;
&lt;li&gt;语法
&lt;ul&gt;&lt;li&gt;以斜杠&quot;/&quot;开头表示目录；&lt;/li&gt;
&lt;li&gt;以星号&quot;*&quot;通配多个字符；&lt;/li&gt;
&lt;li&gt;以问号&quot;?&quot;通配单个字符&lt;/li&gt;
&lt;li&gt;以方括号&quot;[]&quot;包含单个字符的匹配列表；&lt;/li&gt;
&lt;li&gt;以叹号&quot;!&quot;表示不忽略(跟踪)匹配到的文件或目录；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Git 对于 &lt;code&gt;.gitignore&lt;/code&gt; 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效。&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对该 repo 的所有用户应用过滤&lt;br/&gt;将 &lt;code&gt;.gitignore&lt;/code&gt; 文件放在工作目录的跟目录，编辑 &lt;code&gt;.gitignore&lt;/code&gt; 完成后提交 &lt;code&gt;git add .gitignore&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;仅对自己的 repo 备份过滤&lt;br/&gt;添加/编辑你工作目录的$GIT_DIR/info/exclude，例如你的working copy目录是&lt;code&gt;~/src/project1&lt;/code&gt;，则路径为&lt;code&gt;~/src/project1/.git/info/exclude&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;系统全局过滤&lt;br/&gt;创建一个 ignore 文件，名字随意起，比如我的放在&lt;code&gt;~/.gitglobalignore&lt;/code&gt;，然后配置 git：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git config —global core.excludesfile = ~/.gitglobalignore&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;忽略 .DS_Store&lt;br/&gt;添加 &lt;code&gt;.DS_Store&lt;/code&gt; 到 &lt;code&gt;.gitignore&lt;/code&gt; 文件即可&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;1.25&quot;&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://shockerli.net/post/macos-ds_store/&quot; class=&quot;uri&quot;&gt;https://shockerli.net/post/macos-ds_store/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 26 Jul 2018 06:29:00 +0000</pubDate>
<dc:creator>舆图易稿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shockerli/p/macos-ds_store.html</dc:identifier>
</item>
<item>
<title>基于Docker的Mysql主从复制搭建 - 撸码那些事</title>
<link>http://www.cnblogs.com/songwenjie/p/9371422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/9371422.html</guid>
<description>&lt;h2 id=&quot;为什么基于docker搭建&quot;&gt;为什么基于Docker搭建？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;资源有限&lt;/li&gt;
&lt;li&gt;虚拟机搭建对机器配置有要求，并且安装mysql步骤繁琐&lt;/li&gt;
&lt;li&gt;一台机器上可以运行多个Docker容器&lt;/li&gt;
&lt;li&gt;Docker容器之间相互独立，有独立ip，互不冲突&lt;/li&gt;
&lt;li&gt;Docker使用步骤简便，启动容器在秒级别&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用docker搭建主从服务器&quot;&gt;利用Docker搭建主从服务器&lt;/h2&gt;
&lt;p&gt;首先拉取docker镜像,我们这里使用5.7版本的mysql：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker pull mysql:5.7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后使用此镜像启动容器，这里需要分别启动主从两个容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master(主)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -p 3339:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Slave(从)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker run -p 3340:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Master对外映射的端口是3339，Slave对外映射的端口是3340。因为docker容器是相互独立的，每个容器有其独立的ip，所以不同容器使用相同的端口并不会冲突。这里我们应该尽量使用mysql默认的3306端口，否则可能会出现无法通过ip连接docker容器内mysql的问题。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;docker ps&lt;/code&gt;命令查看正在运行的容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/5L4Adf7clg.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时可以使用Navicat等工具测试连接mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/GADD1hBeH7.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置master主&quot;&gt;配置Master(主)&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;docker exec -it 627a2368c865 /bin/bash&lt;/code&gt;命令进入到Master容器内部，也可以通过&lt;code&gt;docker exec -it mysql-master /bin/bash&lt;/code&gt;命令进入。627a2368c865是容器的id,而mysql-master是容器的名称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd /etc/mysql&lt;/code&gt;切换到/etc/mysql目录下，然后&lt;code&gt;vi my.cnf&lt;/code&gt;对my.cnf进行编辑。此时会报出&lt;code&gt;bash: vi: command not found&lt;/code&gt;，需要我们在docker容器内部自行安装vim。使用&lt;code&gt;apt-get install vim&lt;/code&gt;命令安装vim&lt;/p&gt;
&lt;p&gt;会出现如下问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Reading package lists... Done
Building dependency tree       
Reading state information... Done
E: Unable to locate package vim&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;apt-get update&lt;/code&gt;，然后再次执行&lt;code&gt;apt-get install vim&lt;/code&gt;即可成功安装vim。然后我们就可以使用vim编辑my.cnf，在my.cnf中添加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
## 同一局域网内注意要唯一
server-id=100  
## 开启二进制日志功能，可以随便取（关键）
log-bin=mysql-bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成之后，需要重启mysql服务使配置生效。使用&lt;code&gt;service mysql restart&lt;/code&gt;完成重启。重启mysql服务时会使得docker容器停止，我们还需要&lt;code&gt;docker start mysql-master&lt;/code&gt;启动容器。&lt;/p&gt;
&lt;p&gt;下一步在Master数据库创建数据同步用户，授予用户 slave REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CREATE USER 'slave'@'%' IDENTIFIED BY '123456';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/34Hjbf7Ck3.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置slave从&quot;&gt;配置Slave(从)&lt;/h2&gt;
&lt;p&gt;和配置Master(主)一样，在Slave配置文件my.cnf中添加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
## 设置server_id,注意要唯一
server-id=101  
## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用
log-bin=mysql-slave-bin   
## relay_log配置中继日志
relay_log=edu-mysql-relay-bin  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后也需要重启mysql服务和docker容器，操作和配置Master(主)一致。&lt;/p&gt;
&lt;h2 id=&quot;链接master主和slave从&quot;&gt;链接Master(主)和Slave(从)&lt;/h2&gt;
&lt;p&gt;在Master进入mysql，执行&lt;code&gt;show master status;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/Kjja2jAIm4.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;File和Position字段的值后面将会用到，在后面的操作完成之前，需要保证Master库不能做任何操作，否则将会引起状态变化，File和Position字段的值变化。&lt;/p&gt;
&lt;p&gt;在Slave 中进入 mysql，执行&lt;code&gt;change master to master_host='172.17.0.2', master_user='slave', master_password='123456', master_port=3306, master_log_file='mysql-bin.000001', master_log_pos= 2830, master_connect_retry=30;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_host&lt;/strong&gt; ：Master的地址，指的是容器的独立ip,可以通过&lt;code&gt;docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称|容器id&lt;/code&gt;查询容器的ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/7cEC8DbFI1.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_port&lt;/strong&gt;：Master的端口号，指的是容器的端口号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_user&lt;/strong&gt;：用于数据同步的用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_password&lt;/strong&gt;：用于同步的用户的密码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_log_file&lt;/strong&gt;：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_log_pos&lt;/strong&gt;：从哪个 Position 开始读，即上文中提到的 Position 字段的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;master_connect_retry&lt;/strong&gt;：如果连接失败，重试的时间间隔，单位是秒，默认是60秒&lt;/p&gt;
&lt;p&gt;在Slave 中的mysql终端执行&lt;code&gt;show slave status \G;&lt;/code&gt;用于查看主从同步状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/2kagID6a2K.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常情况下，SlaveIORunning 和 SlaveSQLRunning 都是No，因为我们还没有开启主从复制过程。使用&lt;code&gt;start slave&lt;/code&gt;开启主从复制过程，然后再次查询主从同步状态&lt;code&gt;show slave status \G;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/FG2ja42l86.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SlaveIORunning 和 SlaveSQLRunning 都是Yes，说明主从复制已经开启。此时可以测试数据同步是否成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从复制排错：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/bdcjbCF1Ii.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;start slave&lt;/code&gt;开启主从复制过程后，如果SlaveIORunning一直是Connecting，则说明主从复制一直处于连接状态，这种情况一般是下面几种原因造成的，我们可以根据 Last_IO_Error提示予以排除。&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;网络不通&lt;/p&gt;
&lt;p&gt;检查ip,端口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;密码不对&lt;/p&gt;
&lt;p&gt;检查是否创建用于同步的用户和用户密码是否正确&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pos不对&lt;/p&gt;
&lt;p&gt;检查Master的 Position&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;测试主从复制&quot;&gt;测试主从复制&lt;/h2&gt;
&lt;p&gt;测试主从复制方式就十分多了，最简单的是在Master创建一个数据库，然后检查Slave是否存在此数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Master:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/Kg1EB8f1HL.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Slave:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180726/4Ibh3CF9D3.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;content&quot; readability=&quot;27.151515151515&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div&gt;&lt;strong&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180511/AFdec5f65k.jpg?imageslim&quot; title=&quot;关注公众号，获取最新更新&quot;/&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Thu, 26 Jul 2018 06:17:00 +0000</pubDate>
<dc:creator>撸码那些事</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/9371422.html</dc:identifier>
</item>
<item>
<title>[源码分析]读写锁ReentrantReadWriteLock - GoldArowana</title>
<link>http://www.cnblogs.com/noKing/p/9371238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noKing/p/9371238.html</guid>
<description>&lt;h2&gt;一.简介&lt;/h2&gt;
&lt;p&gt;读写锁. 读锁之间是共享的. 写锁是独占的. &lt;/p&gt;
&lt;p&gt;首先声明一点: 我在分析源码的时候, 把jdk源码复制出来进行中文的注释, 有时还进行编译调试什么的, 为了避免和jdk原生的类混淆, 我在类前面加了&quot;My&quot;. 比如把ReentrantLock改名为了MyReentrantLock, 在源码分析的章节里, 我基本不会对源码进行修改, 所以请忽视这个&quot;My&quot;即可.&lt;/p&gt;
&lt;h3&gt;1. ReentrantReadWriteLock类里的字段&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724121116483-1316711370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;unsafe在这里是用来给TID_OFFSET赋值的.&lt;/p&gt;
&lt;p&gt;那么TID_OFFSET是什么? 就是tid变量在Thread类里的偏移量. tid就是线程id.&lt;/p&gt;
&lt;p&gt;下面就是获取TID_OFFSET的源码: (这里我进行了一点改动, 改为了反射)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724122106657-652822280.png&quot; alt=&quot;&quot; height=&quot;300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步器:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724121456426-533894263.png&quot; alt=&quot;&quot; height=&quot;150px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读锁:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724121617704-989799326.png&quot; alt=&quot;&quot; height=&quot;150px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写锁:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724121625951-1124566462.png&quot; alt=&quot;&quot; height=&quot;150px&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. ReentrantReadWriteLock类的构造器 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724121731386-1683674341.png&quot; alt=&quot;&quot; height=&quot;300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个带参构造器, 可以选择公平锁还是非公平锁. 同时实例化了读锁和写锁.&lt;/p&gt;
&lt;p&gt;而默认构造器是直接调用上面的带参构造器, 采用了非公平锁:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724121822844-1286302782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二. 公平读锁的申请和释放&lt;/h2&gt;
&lt;h3&gt;1. 场景demo&lt;/h3&gt;
&lt;p&gt;现在模拟一个场景. 两个线程, 同时申请读锁, 场景的demo如下: &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Main {
    static final Scanner scanner = new Scanner(System.in);
    private static ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);
    private static ReentrantReadWriteLock.ReadLock readLock = lock.readLock();
    private static ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();
    static volatile String cmd = &quot;&quot;;

    public static void main(String[] args) {
        new Thread(Main::funcA).start();
        new Thread(Main::funcB).start();

        while (scanner.hasNext()) {
            cmd = scanner.nextLine();
        }
    }

    public static void funcA() {
        blockUntilEquals(() -&amp;gt; cmd, &quot;lock a&quot;);
        readLock.lock();
        System.out.println(&quot;funcA获取了读锁&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;unlock a&quot;);
        readLock.unlock();
        System.out.println(&quot;funcA释放了读锁&quot;);
    }

    public static void funcB() {
        blockUntilEquals(() -&amp;gt; cmd, &quot;lock b&quot;);
        readLock.lock();
        System.out.println(&quot;funcB获取了读锁&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;unlock b&quot;);
        readLock.unlock();
        System.out.println(&quot;funcB释放了读锁&quot;);
    }

    private static void blockUntilEquals(Supplier&amp;lt;String&amp;gt; cmdSupplier, final String expect) {
        while (!cmdSupplier.get().equals(expect))
            quietSleep(1000);
    }

    private static void quietSleep(int mills) {
        try {
            Thread.sleep(mills);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行上面这段代码.&lt;/p&gt;
&lt;p&gt;然后输入&quot;lock a&quot;, 然后按下回车, (不带引号), 线程a就获取到了读锁.&lt;/p&gt;
&lt;p&gt;然后输入&quot;lock b&quot;, 然后按下回车, (不带引号), 线程b就获取到了读锁.&lt;/p&gt;
&lt;p&gt;如下图所示, 蓝字为我输入的内容.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180716222924563-1780584275.png&quot; alt=&quot;&quot; height=&quot;200px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见, 两个读锁之间不是互斥的, 是可以共享同一个锁的.&lt;/p&gt;
&lt;p&gt;接下来咱们让这两个线程a和b 分别释放掉读锁.&lt;/p&gt;
&lt;p&gt;输入&quot;unlock a&quot;, 然后按下回车, (不带括号) , 然后输入&quot;unlock b&quot;, 然后按下回车. 就分别释放了两个锁了. 如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180716223350733-719057064.png&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 获取第一个读锁&lt;/h3&gt;
&lt;p&gt;我带着大家一起调试. 请在funcA()方法里的readLock.lock()这里打下断点, 然后用debug模式运行.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180716225126421-1307427759.png&quot; alt=&quot;&quot; height=&quot;200px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再控制台输入 &quot;lock a&quot; , 注意不带引号, 然后按下回车:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180716225312740-1948179228.png&quot; alt=&quot;&quot; height=&quot;200px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就发现代码执行到readLock.lock()处就阻塞了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180716225355342-1776636009.png&quot; alt=&quot;&quot; height=&quot;300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按下F7 , 进入readLock.lock()方法, 可以看到读锁的lock方法的实现:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180716225518972-1677923541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到, 调用了acquireShared方法来以共享模式申请了锁.&lt;/p&gt;
&lt;p&gt;acquireShared方法源代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724120831285-1553918425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咱们按F7(Step Into进入tryAcquireShared方法, 看看里面的执行过程吧:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    protected final int tryAcquireShared(int unused) {// 参数没用
        // 获取当前线程的引用
        Thread current = Thread.currentThread();
        // 获取锁的状态. c 的低 16 位值，代表写锁的状态. 高16位代表读锁的状态
        int c = getState();

        // exclusiveCount(c) 是写锁的state. 不等于 0，说明有线程持有写锁. (当前场景下肯定等于0, 所以跳过这段if语句)
        if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;
                getExclusiveOwnerThread() != current)
            return -1;

        // 读锁的state
        int r = sharedCount(c);

        // 读锁获取是否应该被阻塞, 其实就是根据`等待队列`来判断是否应该被阻塞的 ( 当前场景下没有比当前线程等待更久的线程, 所以不会被阻塞.)
        if (!readerShouldBlock() &amp;amp;&amp;amp;
                // 判断是否会溢出 (2^16-1). (当前的r==0, 所以没有溢出)
                r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;
                // 下面这行 CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁. (当前场景下, 没有线程竞争, 所以肯定成功.)
                compareAndSetState(c, c + SHARED_UNIT)) {

            /* ----------------------
             *  进到这里就是获取到了读锁
             * ----------------------*/

            // r == 0 说明此线程是第一个获取读锁的，或者说在它之前来的读锁的都走光了. (当前场景r就是等于0, 所以会执行这段if)
            if (r == 0) {
                // 记录 firstReader 为当前线程. 
                firstReader = current;
                // 持有的读锁数量为1
                firstReaderHoldCount = 1;

            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null ||
                        rh.tid != getThreadId(current))
                    cachedHoldCounter = rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
            }

            // return 1, 表示获取到了1个锁.
            return 1;
        }
        return fullTryAcquireShared(current);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  然后点击这个按钮`放行`:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724130952183-1350043618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就发现控制台输出了 &quot;funcA获取了读锁&quot; :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724131032793-1784766160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3. 获取第二个读作&lt;/h3&gt;
&lt;p&gt;咱们在funcB函数的这句话上也打个断点:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724131136183-169504266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后再控制台输入 &quot;lock b&quot;, 然后按下回车:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724131206963-456034513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按下回车后, 就发现代码阻塞在了刚才的断点上面(红色行变为了绿色):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724131322415-766320213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后咱们开始分析线程b是如果获取读锁的(记住刚才a线程的读锁还没释放呢), 按下F7, 进入到lock()的源代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724131517597-318382286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再F7, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724131551770-1247571324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再F7, 终于到了关键的地方:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    protected final int tryAcquireShared(int unused) {// 参数没用
        // 获取当前线程的引用
        Thread current = Thread.currentThread();
        // 获取锁的状态. c 的低 16 位值，代表写锁的状态. 高16位代表读锁的状态
        int c = getState();

        // exclusiveCount(c) 是写锁的state. 不等于 0，说明有线程持有写锁 (当前场景下肯定等于0, 所以跳过这段if语句)
        if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;
                getExclusiveOwnerThread() != current)
            return -1;

        // 读锁的state, 由于刚才a线程获取到了读锁, 所以这个计数器现在的值是1
        int r = sharedCount(c);

        // 读锁获取是否应该被阻塞, 其实就是根据`等待队列`来判断是否应该被阻塞的 ( 当前场景下没有比当前线程等待更久的线程, 所以不会被阻塞.)
        if (!readerShouldBlock() &amp;amp;&amp;amp;
                //  判断是否会溢出 (2^16-1). (当前的r==1, 所以没有溢出)
                r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;
                // 下面这行 CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁 (当前场景下, 没有线程竞争, 所以肯定成功.)
                compareAndSetState(c, c + SHARED_UNIT)) {

            /* ----------------------
             *  进到这里就是获取到了读锁
             * ----------------------*/

            // 当前场景下 r == 1, 而且也不是读锁重入. 所以执行else语句
            if (r == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                // cachedHoldCounter 用于缓存最后一个获取读锁的线程 (当前场景下, cachedHoldCounter并没有被赋值过, 所以是null)
                HoldCounter rh = cachedHoldCounter;

                // 当前场景下cachedHoldCounter为空, 所以进入到这个if语句中.
                if (rh == null ||
                        rh.tid != getThreadId(current))
                    // 利用threadlocal进行创建, 并返回给cachedHoldCounter 和 rh
                    cachedHoldCounter = rh = readHolds.get();

                // 本场景下不执行这个else if, 跳过.
                else if (rh.count == 0)
                    readHolds.set(rh);
                
                // 本场景下, rh刚刚被初始化, 里面的count肯定是0, 在这里进行自增操作, 之后就变为了1.
                rh.count++;
            }
            // return 1, 表示本次tryAcquireShared获取到了1个锁
            return 1;
        }
        return fullTryAcquireShared(current);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 咱们来总结一下这一段代码都干什么了吧. 首先通过cas操作, 将读锁的state计数器加了1, (也就是变为了2). 然后就是通过ThreadLocal.get() 方法, 在threadlocal里创建了一个b线程的计数器, 并且把这个计数器置为1. 然后就没了....(代码看起来很多的样子, 但是实际上没干多少事情...)&lt;/p&gt;
&lt;p&gt;然后将断点放行.(从此以后就不详细讲调试过程了. 就只用语言表述了.)&lt;/p&gt;
&lt;h3&gt;4. 释放第一个读锁&lt;/h3&gt;
&lt;p&gt;回到咱们的例子Main方法.在funcA函数的unlock()那一行打上断点. 然后再控制台输入 &quot;unlock a&quot;, 然后回车:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724133658524-1208096903.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 然后咱们就可以开始分析 线程a 释放读锁的过程了, 按F7进入到unlock()函数内部:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724133811013-1730062015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再F7  :&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724134045771-1631236031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咱们先看看tryReleaseShared方法吧:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
protected final boolean tryReleaseShared(int unused) {// 参数没用
        // 获取当前线程的引用
        Thread current = Thread.currentThread();

        // 判断当前线程是不是当前读锁中的第一个读线程, (线程a就是第一个获取到读锁的, 所以满足这个if条件.)
        if (firstReader == current) {
            assert firstReaderHoldCount &amp;gt; 0;

            // 当前场景下等于 1，所以这次解锁后, 当前线程就不会再持有锁了，把 firstReader 置为 null，给后来的线程用
            if (firstReaderHoldCount == 1)
                // 为什么不顺便设置 firstReaderHoldCount = 0？因为没必要，其他线程使用的时候自己会设值
                firstReader = null;

            // 不会执行这个else.
            else
                firstReaderHoldCount--;

        // 不会执行这个else语句. 跳过.
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null
                    || rh.tid != getThreadId(current))
                rh = readHolds.get();
            int count = rh.count;
            if (count &amp;lt;= 1) {
                readHolds.remove();
                if (count &amp;lt;= 0) throw unmatchedUnlockException();
            }
            --rh.count;
        }

        for (; ; ) {
            int c = getState();
            // state 的高 16 部分位减 1 , 低16位不动. (高16位是共享模式)
            // 高16位的部分, 现在是2. 在这一步减去了1, 所以执行完下面这行代码后 nextc == 1
            int nextc = c - SHARED_UNIT;
            // cas 更新 state的值为nextc, (当前场景下也就是 1 了), 当前场景下没有争抢, cas肯定成功. 
            if (compareAndSetState(c, nextc))
                // 释放读锁, 对读线程们没有什么影响
                // 但如果是 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都空了
                // 此时这里返回 true 的话，其实是帮助唤醒后继节点中的获取写锁的线程
                // 当前场景下, nextc等于1.所以返回false.
                return nextc == 0;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这段代码最终返回了false, 然后回到上一层函数. 由于返回了false, 所以不会进入到if语句里, 也就是不会执行doReleaseShared()方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724135344900-2119960942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击`放行`按钮. funcA的读锁释放过程就到此结束了.&lt;/p&gt;
&lt;h3&gt;5. 释放第二个读锁 &lt;/h3&gt;
&lt;p&gt;回到Main方法. 咱们在funcB里的unlock()函数那一行打上断点. 在控制台输入&quot;unlock b&quot;, 然后回车.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724135758950-567184615.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后调试, 一直进入到tryReleaseShared()方法. 刚才讲了tryReleaseShared释放线程a持有的读锁的步骤. 咱们现在看看线程b执行这段代码会有什么不同吧:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    protected final boolean tryReleaseShared(int unused) {// 参数没用
        // 获取当前线程的引用
        Thread current = Thread.currentThread();

        // 判断当前线程是不是当前读锁中的第一个读线程,(本场景中, 当然不是了, 而且刚才释放a的读锁的时候, firstReader被设置为了null, 所以也不满足if. 就是说不管读锁a之前是否释放了, 这里都不会满足if条件)
        if (firstReader == current) {
            assert firstReaderHoldCount &amp;gt; 0;
            if (firstReaderHoldCount == 1)
                firstReader = null;
            else
                firstReaderHoldCount--;

        // 会执行这个else语句, 而不是上面的if语句.
        } else {
            HoldCounter rh = cachedHoldCounter;
            // 判断cachedHoldCounter是不是空, 当前场景下cachedHoldCounter不是空, 所以跳过这个if语句.
            if (rh == null
                    || rh.tid != getThreadId(current))
                rh = readHolds.get();
            
            // 获取cachedHoldCounter的计数器, 当前是 1
            int count = rh.count;
            
            // 如果计数器小于等于1, 说明该释放了.(目前满足这个if条件, 所以会执行if代码块)
            if (count &amp;lt;= 1) {
                // 这一步将 ThreadLocal中当前线程对应的计数器 remove 掉，防止内存泄漏。因为已经不再持有读锁了
                readHolds.remove();
                // 没锁还要释放? 给你抛个异常...
                if (count &amp;lt;= 0) throw unmatchedUnlockException();
            }
            // 计数器 减 1
            --rh.count;
        }
        for (; ; ) {
            int c = getState();
            // state 的高 16 部分位减 1 , 低16位不动. (高16位是共享模式), 执行完下面这行的减1操作后, nextc就变为0了.
            int nextc = c - SHARED_UNIT;
            // cas 设置 state
            if (compareAndSetState(c, nextc))
                // 释放读锁, 对读线程们没有什么影响
                // 但如果是 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都空了
                // 此时这里返回 true 的话，其实是帮助唤醒后继节点中的获取写锁的线程
                // 目前nextc是0, 所以会返回true.
                return nextc == 0;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最终本段代码返回了true, 回到上层代码, 由于返回了true, 所以会执行if代码块里的doReleaseShared()方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724142142405-245807308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来, 咱们看看doReleaseShared()方法都做了什么事情吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724143010446-1439491390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于没有线程进入过`等待队列`, 所以等待队列的head还是null, 所以直接就break了, 什么都没干.&lt;/p&gt;
&lt;p&gt;本小节的demo, 就到此结束了.&lt;/p&gt;
&lt;h2&gt;三. 公平读/写锁的申请和释放&lt;/h2&gt;
&lt;p&gt;场景如下: 线程a获取读锁 -&amp;gt; 线程b获取读锁 -&amp;gt; 线程a获取写锁 -&amp;gt; 线程a释放写锁 -&amp;gt; 线程a释放读锁 -&amp;gt; 线程b释放读锁.&lt;/p&gt;
&lt;p&gt;1. 场景demo: (还是那句话, 想运行我程序的, 把MyReentrantReadWriteLock 改为JDK的 ReentrantReadWriteLock 就好了. My*系列的都是我复制的JDK代码, 然后改了个名字而已)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.util.Scanner;
import java.util.function.Supplier;

public class Main {
    static final Scanner scanner = new Scanner(System.in);
    static volatile String cmd = &quot;&quot;;
    private static MyReentrantReadWriteLock lock = new MyReentrantReadWriteLock(true);
    private static MyReentrantReadWriteLock.ReadLock readLock = lock.readLock();
    private static MyReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    public static void main(String[] args) {
        new Thread(Main::funcA).start();
        new Thread(Main::funcA2).start();
        new Thread(Main::funcB).start();

        while (scanner.hasNext()) {
            cmd = scanner.nextLine();
        }
    }

    public static void funcA() {
        blockUntilEquals(() -&amp;gt; cmd, &quot;lock read a&quot;);
        readLock.lock();
        System.out.println(&quot;funcA获取了读锁&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;unlock read a&quot;);
        readLock.unlock();
        System.out.println(&quot;funcA释放了读锁&quot;);
    }
    
    public static void funcA2(){
        blockUntilEquals(() -&amp;gt; cmd, &quot;lock write a&quot;);
        writeLock.lock();
        System.out.println(&quot;funcA获取了写锁&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;unlock write a&quot;);
        writeLock.unlock();
        System.out.println(&quot;funcA释放了写锁&quot;);
    }

    public static void funcB() {
        blockUntilEquals(() -&amp;gt; cmd, &quot;lock read b&quot;);
        readLock.lock();
        System.out.println(&quot;funcB获取了读锁&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;unlock read b&quot;);
        readLock.unlock();
        System.out.println(&quot;funcB释放了读锁&quot;);
    }

    private static void blockUntilEquals(Supplier&amp;lt;String&amp;gt; cmdSupplier, final String expect) {
        while (!cmdSupplier.get().equals(expect))
            quietSleep(1000);
    }

    private static void quietSleep(int mills) {
        try {
            Thread.sleep(mills);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2. 获取读锁&lt;/h3&gt;
&lt;p&gt;首先是a获取读锁, 接下来是b获取读锁. 这个场景在上小节中将读锁的时候已经讲过了. 所以这里一代而过.&lt;/p&gt;
&lt;p&gt;运行上面这个场景demo, 然后按下进行输入, 来让a线程获取读锁, 然后让b线程获取读锁:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724145302906-895333581.png&quot; alt=&quot;&quot; height=&quot;200px&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3. 获取写锁&lt;/h3&gt;
&lt;p&gt;把断点打在writeLock.lock()方法上, 然后输入&quot;lock write a&quot;, 按下回车, 来让a线程获取写锁:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724152939030-1708965252.png&quot; alt=&quot;&quot; height=&quot;400px&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 发现线程阻塞在了writeLock.lock()方法上. 咱们开始一遍调试一遍分析代码.&lt;/p&gt;
&lt;p&gt;F7, 进入到了ReentrantReadWriteLock.WriteLock类里的lock()方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724145807443-779890662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来就很熟悉了, 根ReentrantLock里的申请锁是同一段代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724150655036-1557260577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但还不是完全一样, 因为ReadWriteLock重写了其中的tryAcquire方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    protected final boolean tryAcquire(int acquires) {
        Thread current = Thread.currentThread();
        int c = getState();
        // 获取写锁的重入次数, w 在本场景中等于0
        int w = exclusiveCount(c);
        // c==0说明, 写锁和读锁都没有.
        if (c != 0) {
            //   c != 0 &amp;amp;&amp;amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有) , 在本场景中, 会满足w==0的条件, 而进入if语句
            if (w == 0 ||
                    current != getExclusiveOwnerThread())
                // 返回true
                return false;

            // ***********************************************************
            // ---- 本场景根下面的代码没关系, 因为会在上一行的return中直接返回false.
            // ***********************************************************
            
            if (w + exclusiveCount(acquires) &amp;gt; MAX_COUNT)
                throw new Error(&quot;Maximum lock count exceeded&quot;);

            setState(c + acquires);
            return true;
        }
        if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
            return false;
        setExclusiveOwnerThread(current);
        return true;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后就是执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) . 这句代码的内部实现与ReentrantLock的代码一模一样(就是同一段代码). 就不再复述了.&lt;/p&gt;
&lt;p&gt;执行完这句话之后, 刚刚的申请写锁的线程就被挂起了, 等待着读锁释放完了后唤醒他.&lt;/p&gt;
&lt;p&gt;咱们知道他是通过调用AQS类里的parkAndCheckInterrupt方法来进行挂起操作的. 咱们在挂起操作的下一行打个断点. 这样, 到时候这个线程被唤醒后, 咱们就可以感知到了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724154900646-1763188671.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来咱们在funcB函数里的unlock()方法上打个断点:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724154948830-1392467336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4. 释放所有读锁, 来让写锁被激活&lt;/h3&gt;
&lt;p&gt;接下来咱们释放掉读锁a, 然后释放掉读锁b, 然后线程就会在funcB函数里的unlock()方法上阻塞. (释放这两个锁的流程在前文中已经讲过了, 所以下面简单描述):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724155121208-1030719754.png&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按F7, 进入函数内部, 一步一步调试, 最终会执行到 doReleaseShared()方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724155402025-1721723875.png&quot; alt=&quot;&quot; height=&quot;600px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里其实就是在唤醒`等待队列`里的第一个写锁.&lt;/p&gt;
&lt;p&gt;在这里点击`放行`. (点击`放行`就是:&quot;让剩余的函数自动执行完, 一直执行到下一个断点&quot;)&lt;/p&gt;
&lt;p&gt;就会发现跳转到这里了: (也就是刚才进入等待队列的那个申请写锁的线程从挂起状态恢复到了运行状态)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724155758537-1085065872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咱们在此点击`放行`按钮, 然后这个写锁就申请完了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724155909722-126747378.png&quot; alt=&quot;&quot; height=&quot;300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来咱们看看写锁的释放过程. 在funcA2函数里的unlock()方法上打上断线, 然后再控制台输入&quot;unlock write a&quot;, 并回车: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724160106675-354577061.png&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后老规矩按F7, 进入函数内部.查看源码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724160322446-964921059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再进入一层:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724160425750-438430802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先是尝试释放锁, 如果锁可以完全释放的话, 就会激活`等待队列`里的第一个线程.&lt;/p&gt;
&lt;p&gt;咱们看看读写锁的tryRelease方法的内部实现吧:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724161604290-169014353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实就是计数器减1, 然后如果等于0的话, 就返回true.表示锁释放干净了. 没有重入.&lt;/p&gt;
&lt;p&gt;然后回到上层方法, 由于返回的是true, 所以会进入到if语句里, 然后去判断是否还有线程要获取锁. 如果有的话就用unparkSuccessor方法唤醒. 如果没有的话就直接返回true, 然后结束:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180724161851064-423389917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四.公平读锁从等待队列中唤醒 (未完待续)&lt;/h2&gt;
&lt;p&gt;咱们在这一小节 分析一下读锁进入等待队列的流程, 和读锁在等待队列中被唤醒的流程.&lt;/p&gt;
&lt;h3&gt;1. 用于测试本场景的代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.locks.Lock;
import java.util.function.Supplier;

public class Main {
    static final Scanner scanner = new Scanner(System.in);
    static volatile String cmd = &quot;&quot;;
    private static MyReentrantReadWriteLock lock = new MyReentrantReadWriteLock(true);
    private static MyReentrantReadWriteLock.ReadLock readLock = lock.readLock();
    private static MyReentrantReadWriteLock.WriteLock writeLock = lock.writeLock();

    public static void main(String[] args) {
        for (Map.Entry&amp;lt;String, Lock&amp;gt; entry : new HashMap&amp;lt;String, Lock&amp;gt;() {{
            put(&quot;r1&quot;, readLock);
            put(&quot;r2&quot;, readLock);
            put(&quot;r3&quot;, readLock);
            put(&quot;w1&quot;, writeLock);
            put(&quot;w2&quot;, writeLock);
            put(&quot;w3&quot;, writeLock);
        }}.entrySet()) {
            new Thread(() -&amp;gt; func(entry::getValue, entry.getKey())).start();
        }

        // 下面这四行, 等价于上面的for循环.
//        new Thread(() -&amp;gt; func(() -&amp;gt; readLock, &quot;r1&quot;)).start();
//        new Thread(() -&amp;gt; func(() -&amp;gt; readLock, &quot;r2&quot;)).start();
//        new Thread(() -&amp;gt; func(() -&amp;gt; writeLock, &quot;w1&quot;)).start();
//        new Thread(() -&amp;gt; func(() -&amp;gt; writeLock, &quot;w2&quot;)).start();

        while (scanner.hasNext()) {
            cmd = scanner.nextLine();
        }
    }

    public static void func(Supplier&amp;lt;Lock&amp;gt; myLockSupplier, String name) {
        String en_type = myLockSupplier.get().getClass().getSimpleName().toLowerCase().split(&quot;lock&quot;)[0];
        String zn_type = (en_type.equals(&quot;read&quot;) ? &quot;读&quot; : &quot;写&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;lock &quot; + en_type + &quot; &quot; + name);
        myLockSupplier.get().lock();
        System.out.println(name + &quot;获取了&quot; + zn_type + &quot;锁&quot;);
        blockUntilEquals(() -&amp;gt; cmd, &quot;unlock &quot; + en_type + &quot; &quot; + name);
        myLockSupplier.get().unlock();
        System.out.println(name + &quot;释放了&quot; + zn_type + &quot;锁&quot;);
    }

    private static void blockUntilEquals(Supplier&amp;lt;String&amp;gt; cmdSupplier, final String expect) {
        while (!cmdSupplier.get().equals(expect))
            quietSleep(1000);
    }

    private static void quietSleep(int mills) {
        try {
            Thread.sleep(mills);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 2. 上面这段代码的用法&lt;/h3&gt;
&lt;p&gt;运行这段代码后, 按下面这样进行输入:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180725110323223-1596723495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先是有一个线程申请了写锁w2, 然后是有两个线程分别申请了读锁 r1 和 r2. 等到w2被释放的时候, r1 r2 都申请到了锁.&lt;/p&gt;
&lt;p&gt;(输入的时候, 不要打错字, 很容易打错的.)&lt;/p&gt;
&lt;h3&gt;3. 读锁进入`等待队列`&lt;/h3&gt;
&lt;p&gt;重新运行这段程序.先输入&quot;lock write w1&quot; ,  先申请写锁. 然后在func方法内部的`myLockSupplier.get().lock();`这一行代码打上断点. 然后输入&quot;lock read r1&quot;, 申请读锁.&lt;/p&gt;
&lt;p&gt;(由于先申请了写锁, 而且这个写锁还没有释放. 所以这个时候申请读锁就意味着会进入`等待队列`)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180725223102769-858970948.png&quot; alt=&quot;&quot; height=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后按下F7, 进入到源代码中: (ReentrantReadWriteLock的内部类ReadLock类里的lock()方法)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180725223344807-1352594687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续按F7, 进入到方法内部, 咱们就看到了acquireShared方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180725223438362-1620352123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于刚才咱们成功申请了写锁, 而且还没释放. 所以这次读锁肯定申请失败.&lt;/p&gt;
&lt;p&gt;也就是说tryAcquireShared方法尝试获取锁会失败. 失败了就会返回-1. tryAcquireShared方法之前讲过了, 就不细讲了.&lt;/p&gt;
&lt;p&gt;tryAcquireShared失败了, 就会满足if条件. 然后就会进入到if语句中执行doAcquireShared方法.  咱们继续往下分析这个doAcquireShared :&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
    private void doAcquireShared(int arg) {
        // 将节点放入`等待队列`
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (; ; ) {
                final Node p = node.predecessor();
                // 判断当前是不是等待队列中的第一个
                if (p == head) {
                    // 尝试获取锁
                    int r = tryAcquireShared(arg);
                    if (r &amp;gt;= 0) {
                        // 把自己设置为新的头部, 然后看看是否需要向后续蔓延
                        // (也就是, 如果是Shared模式, 那么就会把后续连续的读锁线程都唤醒)
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                        parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其中主要的是setHeadAndPropagate方法. 咱们进入查看源码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1251417/201807/1251417-20180725231304153-1157358001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里将`等待队列`里的第一个节点设置为了Head节点. 然后判断是不是下一个节点是不是共享模式的, 也就是判断下一个节点是不是共享模式, 如果是的话, 就会执行doReleaseShared()方法. 最终会导致, 一个读锁获取成功的时候, 会带着其后续连续的读锁都一起获取成功.&lt;/p&gt;
&lt;p&gt;其中的doReleaseShared()方法在前面小节已经介绍过了, 就不讲了.  如果哪里遗漏了就后续补充. &lt;/p&gt;
</description>
<pubDate>Thu, 26 Jul 2018 05:26:00 +0000</pubDate>
<dc:creator>GoldArowana</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noKing/p/9371238.html</dc:identifier>
</item>
<item>
<title>散列——动机引入 - 仪式黑刃</title>
<link>http://www.cnblogs.com/hongshijie/p/9371075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshijie/p/9371075.html</guid>
<description>&lt;p&gt;散列又称词典（dictionary），在讨论这部分内容时我们将看到散列实际上并不是一种简单的技术，从某种意义上讲它甚至是一种思想，是一种赖以高效组织数据，并实现相关算法的重要思想。接下来我们就会看到，在这种思想背后的原理，是如此的直观和简单。毕竟，任何表面复杂的技术背后的原理都是十分简洁而优美的。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;要先对散列有一个概观：被称为散列（&lt;span lang=&quot;en-US&quot;&gt;hashing&lt;span lang=&quot;zh-CN&quot;&gt;）的技术实际上是散列表结构的实现，是一种用于以O（&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;）时间插入、删除和查找的技术。由于它是根据某种具体规则散步的，就像集束炸弹落地，对！我觉得这是最贴切的一个比喻了，把某一个实体散列到存储空间里，过程恰似集束炸弹落地前的子炸弹分解hhhhhh。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201807/1262741-20180726122820146-1213668510.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;234&quot;/&gt;                        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201807/1262741-20180726123139573-1983404962.jpg&quot; alt=&quot;&quot; width=&quot;276&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;由于它并没有一个线性顺序，所以那些需要元素间任何排序信息的操作就不能进行了，比如Fi&lt;span lang=&quot;en-US&quot;&gt;ndMin&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;FindMax&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;还有按顺序打印整个表都是散列所不支持的&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;下面来探究为什么要引入散列这种技术，现有的一些结构不够用么？我们的故事要从服务电话说起，当你需要获得某个公司或者部门的服务应该如何通过电话来找到他们呢？查电话簿，但有时候电话簿太厚以至于你没有足够的耐心去查阅，在智能手机兴起之前，大部分公司有相当多的客户都是因为这种纠结而流失掉的，而优秀的公司应该为它的服务取一个更加便于记忆的电话号码，与此同时还要突出公司特点，这就不能是简单的&lt;span lang=&quot;en-US&quot;&gt;123456,8888888能做到的了，而且这样太掉档次。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201807/1262741-20180726122306979-1420569039.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;来看看经典的做法，对于IBM来说，他的电话是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201807/1262741-20180726121722594-572315182.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在此之前，对于每一个键大部分人只留意了其中的数字部分，而实际上当时大部分的键盘都是这种形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201807/1262741-20180726122420413-1701607376.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;446&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;其中的每个键上 除了有一个数字，同时还拥有若干个英文字母。我们可以理解为：一个键既可能对应于一个数字，也可能同时对应于若干个字母。比如这里的IBM&lt;span lang=&quot;en-US&quot;&gt;-4YOU&lt;span lang=&quot;zh-CN&quot;&gt;对应的拨号过程就是&lt;span lang=&quot;en-US&quot;&gt;426-968&lt;span lang=&quot;zh-CN&quot;&gt;。请留意体会这种方式的巧妙之处，不仅记住了一个公司的特点，而且拨打的电话依然是由数字组成，这背后蕴含着某种深刻的思想。实际上这就是散列的一个应用：按下字母，实际效果指向各自对应的数字。所以我们可以想象得到，哈希的具体做法或许是给定一个关键字，然后返回一个对应的索引。当然也可能引发冲突，多个关键字映射到同一个索引上，比如这里的A，B，C都&lt;span lang=&quot;en-US&quot;&gt;hashing到了2这个索引&lt;span lang=&quot;zh-CN&quot;&gt;，这也是后续我们解决散列问题的一个关键点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们不妨就访问数据的方式来做一对比，对于不同的数据结构，在此之前都根据其如何访问数据，进行过分类，有寻秩访问&lt;span lang=&quot;zh-CN&quot;&gt;call by rank&lt;span lang=&quot;zh-CN&quot;&gt;，比如向量；还有寻位置访问&lt;span lang=&quot;zh-CN&quot;&gt;call by position&lt;span lang=&quot;zh-CN&quot;&gt;，这方面的典型例子是列表&lt;span lang=&quot;zh-CN&quot;&gt;list&lt;span lang=&quot;zh-CN&quot;&gt;；而以&lt;span lang=&quot;zh-CN&quot;&gt;BST&lt;span lang=&quot;zh-CN&quot;&gt;为典型代表的这类数据结构呢，都属于寻关键码访问&lt;span lang=&quot;zh-CN&quot;&gt;call by key&lt;span lang=&quot;zh-CN&quot;&gt;，树根是&lt;span lang=&quot;en-US&quot;&gt;0&lt;span lang=&quot;zh-CN&quot;&gt;，左孩子&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;，右孩子&lt;span lang=&quot;en-US&quot;&gt;2&lt;span lang=&quot;zh-CN&quot;&gt;，往下依次类推这样。反观我们这里对电话号码的访问，如果说访问的对象是公司的服务，那么刚才这种获取服务的方式，又属于其中的哪种呢？首先这种方式既不是寻秩，也不是寻位置访问——所有的公司的各项服务之间并不存在某种线性次序。那么它是寻关键码访问吗？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;要说明一点：这里的“关键码”指的是那串电话号码，下面提到的“值”指的是某个字母本身，可能有人会误解，之前就有人问我：号码不才应该是“值”么？你看都是数值。但实际上在这个案例中，某个字母对应的哪个数字，只是它的一个索引，我们在脑海中的思维活动，关注点还在字母本身，电话号只是键盘处理过的结果。就像二叉树里，树根编号是&lt;span lang=&quot;en-US&quot;&gt;0&lt;span lang=&quot;zh-CN&quot;&gt;，但它结构里面有个具体的数，那是值，那是他这个对象本身，而&lt;span lang=&quot;en-US&quot;&gt;0仅仅是记录位置的一个关键码&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这里的确有关键码，也就是每个服务所对应的那个电话号码。然而即便是按照刚才的方式去拨打某个特定的电话，在你的脑海里除了那个公司和服务的助记符号之外，完全不出现任何形式的数字电话号码，在整个过程中我们都是想着那串单词去拨打的，因此我们关注的是具体的字母，也就是你所需要找到的那个对象本身。我们称之为value 数值，因此将新的这种访问方式称作寻值访问。我们刚才已经领略到了这种新的访问方式的威力，若能加以充分利用，这种访问方式将使我们的计算效率进一步得以提高，而这样的一种典型的技巧就是所谓的Hashing。中文可以根据含义译作杂凑；也可以根据发音译作哈希，但是我们要信达雅！所以译作散列哈哈哈哈哈&lt;/p&gt;

</description>
<pubDate>Thu, 26 Jul 2018 04:25:00 +0000</pubDate>
<dc:creator>仪式黑刃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongshijie/p/9371075.html</dc:identifier>
</item>
</channel>
</rss>