<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Redis的各项功能解决了哪些问题？ - Blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/what-problem-does-redis-solve.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/what-problem-does-redis-solve.html</guid>
<description>&lt;blockquote readability=&quot;7.8297872340426&quot;&gt;
&lt;p&gt;先看一下Redis是一个什么东西。&lt;a href=&quot;https://redis.io/topics/introduction&quot; target=&quot;_blank&quot;&gt;官方简介&lt;/a&gt;解释到：Redis是一个基于BSD开源的项目，是一个把结构化的数据放在内存中的一个存储系统，你可以把它作为数据库，缓存和消息中间件来使用。同时支持strings，lists，hashes，sets，sorted sets，bitmaps，hyperloglogs和geospatial indexes等数据类型。它还内建了复制，lua脚本，LRU，事务等功能，通过redis sentinel实现高可用，通过redis cluster实现了自动分片。以及事务，发布/订阅，自动故障转移等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综上所述，Redis提供了丰富的功能，初次见到可能会感觉眼花缭乱，这些功能都是干嘛用的？都解决了什么问题？什么情况下才会用到相应的功能？那么下面从零开始，一步一步的演进来粗略的解释下。&lt;/p&gt;

&lt;p&gt;最初的需求非常简单，我们有一个提供热点新闻列表的api：http://api.xxx.com/hot-news，api的消费者抱怨说每次请求都要2秒左右才能返回结果。&lt;/p&gt;
&lt;p&gt;随后我们就着手于如何提升一下api消费者感知的性能，很快最简单粗暴的第一个方案就出来了：为API的响应加上基于HTTP的缓存控制 &lt;span class=&quot;cnblogs_code&quot;&gt;cache-control:max-age=600&lt;/span&gt; ，即让消费者可以缓存这个响应十分钟。如果api消费者如果有效的利用了响应中的缓存控制信息，则可以有效的改善其感知的性能（10分钟以内）。但是还有2个弊端：第一个是在缓存生效的10分钟内，api消费者可能会得到旧的数据；第二个是如果api的客户端无视缓存直接访问API依然是需要2秒，治标不治本呐。&lt;/p&gt;

&lt;p&gt;为了解决调用API依然需要2秒的问题，经过排查，其主要原因在于使用SQL获取热点新闻的过程中消耗了将近2秒的时间，于是乎，我们又想到了一个简单粗暴的解决方案，即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）。后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了。假如这个api每秒接收到的请求时100个，那么一分钟就是6000个，也就是只有前2秒拥挤过来的请求会耗时2秒，后续的58秒中的所有请求都可以做到即使响应，而无需再等2秒的时间。&lt;/p&gt;
&lt;p&gt;其他API的小伙伴发现这是个好办法，于是很快我们就发现API服务器的内存要爆满了。。。&lt;/p&gt;

&lt;p&gt;在API服务器的内存都被缓存塞满的时候，我们发现不得不另想解决方案了。最直接的想法就是我们把这些缓存都丢到一个专门的服务器上吧，把它的内存配置的大大的。然后我们就盯上了redis。。。至于如何配置部署redis这里不解释了，redis官方有详细的介绍。随后我们就用上了一台单独的服务器作为Redis的服务器，API服务器的内存压力得以解决。&lt;/p&gt;
&lt;h2&gt;3.1 持久化（Persistence）&lt;/h2&gt;
&lt;p&gt;单台的Redis服务器一个月总有那么几天心情不好，心情不好就罢工了，导致所有的缓存都丢失了（redis的数据是存储在内存的嘛）。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩，API服务器和数据库的压力还是一下子就上来了。所以这个时候Redis的持久化功能就派上用场了，可以缓解一下缓存雪崩带来的影响。redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。&lt;/p&gt;
&lt;h2&gt;3.2 哨兵（Sentinel）和复制（Replication）&lt;/h2&gt;
&lt;p&gt;Redis服务器毫无征兆的罢工是个麻烦事。那么怎办办？答曰：备份一台，你挂了它上。那么如何得知某一台redis服务器挂了，如何切换，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要Sentinel和Replication出场了。Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能；Replication则是负责让一个Redis服务器可以配备多个备份的服务器。Redis也是利用这两个功能来保证Redis的高可用的。此外，Sentinel功能则是对Redis的发布和订阅功能的一个利用。&lt;/p&gt;
&lt;h2&gt;3.3 集群（Cluster）&lt;/h2&gt;
&lt;p&gt;单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上。但是内存资源怎么办，主从模式做到的只是相同数据的备份，并不能横向扩充内存；单台机器的内存也只能进行加大处理，但是总有上限的。所以我们就需要一种解决方案，可以让我们横向扩展。&lt;strong&gt;最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，这一组分布式的服务器就像是一个集中式的服务器一样（之前在解读REST的博客中解释过分布式于基于网络的差异：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture.html#auto_id_6&quot; target=&quot;_blank&quot;&gt;基于网络应用的架构&lt;/a&gt;）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Redis官方的分布式方案出来之前，有twemproxy和codis两种方案，这两个方案总体上来说都是依赖proxy来进行分布式的，也就是说redis本身并不关心分布式的事情，而是交由twemproxy和codis来负责。而redis官方给出的cluster方案则是把分布式的这部分事情做到了每一个redis服务器中，使其不再需要其他的组件就可以独立的完成分布式的要求。&lt;strong&gt;我们这里不关心这些方案的优略，我们关注一下这里的分布式到底是要处理那些事情?也就是twemproxy和codis独立处理的处理分布式的这部分逻辑和cluster集成到redis服务的这部分逻辑到底在解决什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如我们前面所说的，一个分布式的服务在外界看来就像是一个集中式的服务一样。那么要做到这一点就面临着有一个问题需要解决：既是增加或减少分布式服务中的服务器的数量，对消费这个服务的客户端而言应该是无感的；那么也就意味着客户端不能穿透分布式服务，把自己绑死到某一个台的服务器上去，因为一旦如此，你就再也无法新增服务器，也无法进行故障替换。解决这个问题有两个路子：第一个路子最直接，那就是我加一个中间层来隔离这种具体的依赖，即twemproxy采用的方式，让所有的客户端只能通过它来消费redsi服务，通过它来隔离这种依赖（但是你会发现twermproxy会成为一个单点），这种情况下每台redis服务器都是独立的，它们之间彼此不知对方的存在；第二个路子是让redis服务器知道彼此的存在，通过重定向的机制来引导客户端来完成自己所需要的操作，比如客户端链接到了某一个redis服务器，说我要执行这个操作，redis服务器发现自己无法完成这个操作，那么就把能完成这个操作的服务器的信息给到客户端，让客户端去请求另外的一个服务器，这时候你就会发现每一个redis服务器都需要保持一份完整的分布式服务器信息的一份资料，不然它怎么知道让客户端去找其他的哪个服务器来执行客户端想要的操作呢。&lt;/p&gt;
&lt;p&gt;上面这一大段解释了这么多，不知有没有发现不管是第一个路子还是第二个路子，都有一个共同的东西存在，&lt;strong&gt;那就是分布式服务中所有服务器以及其能提供的服务的信息。这些信息无论如何也是要存在的&lt;/strong&gt;，区别在于第一个路子是把这部分信息单独来管理，用这些信息来协调后端的多个独立的redis服务器；第二个路子则是让每一个redis服务器都持有这份信息，彼此知道对方的存在，来达成和第一个路子一样的目的，优点是不再需要一个额外的组件来处理这部分事情。&lt;/p&gt;
&lt;p&gt;Redis Cluster的具体实现细节则是采用了Hash槽的概念，即预先分配出来16384个槽：在客户端通过对Key进行CRC16（key）% 16384运算得到对应的槽是哪一个；在redis服务端则是每个服务器负责一部分槽，当有新的服务器加入或者移除的时候，再来迁移这些槽以及其对应的数据，同时每个服务器都持有完整的槽和其对应的服务器的信息，这就使得服务器端可以进行对客户端的请求进行重定向处理。&lt;/p&gt;

&lt;p&gt;上面的第三小节主要介绍的是Redis服务端的演进步骤，解释了Redis如何从一个单机的服务，进化为一个高可用的、去中心化的、分布式的存储系统。这一小节则是关注下客户端可以消费的redis服务。&lt;/p&gt;
&lt;h2&gt;4.1 数据类型&lt;/h2&gt;
&lt;p&gt;redis支持丰富的数据类型，从最基础的string到复杂的常用到的数据结构都有支持：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;string：最基本的数据类型，二进制安全的字符串，最大512M。&lt;/li&gt;
&lt;li&gt;list：按照添加顺序保持顺序的字符串列表。&lt;/li&gt;
&lt;li&gt;set：无序的字符串集合，不存在重复的元素。&lt;/li&gt;
&lt;li&gt;sorted set：已排序的字符串集合。&lt;/li&gt;
&lt;li&gt;hash：key-value对的一种集合。&lt;/li&gt;
&lt;li&gt;bitmap：更细化的一种操作，以bit为单位。&lt;/li&gt;
&lt;li&gt;hyperloglog：基于概率的数据结构。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些众多的数据类型，主要是为了支持各种场景的需要，当然每种类型都有不同的时间复杂度。其实这些复杂的数据结构相当于之前我在《解读REST》这个系列博客&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_15&quot; target=&quot;_blank&quot;&gt;基于网络应用的架构风格&lt;/a&gt;中介绍到的&lt;strong&gt;远程数据访问（Remote Data Access = RDA）&lt;/strong&gt;的具体实现，即通过在服务器上执行一组标准的操作命令，在服务端之间得到想要的缩小后的结果集，从而简化客户端的使用，也可以提高网络性能。比如如果没有list这种数据结构，你就只能把list存成一个string，客户端拿到完整的list，操作后再完整的提交给redis，会产生很大的浪费。&lt;/p&gt;
&lt;h2&gt;4.2 事务&lt;/h2&gt;
&lt;p&gt;上述数据类型中，每一个数据类型都有独立的命令来进行操作，很多情况下我们需要一次执行不止一个命令，而且需要其同时成功或者失败。redis对事务的支持也是源自于这部分需求，即支持一次性按顺序执行多个命令的能力。&lt;/p&gt;
&lt;h2&gt;4.3 Lua脚本&lt;/h2&gt;
&lt;p&gt;在事务的基础上，如果我们需要在服务端一次性的执行更复杂的操作（包含一些逻辑判断），则lua就可以排上用场了（比如在获取某一个缓存的时候，同时延长其过期时间）。redis保证lua脚本的原子性，一定的场景下，是可以代替redis提供的事务相关的命令的。相当于&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_18&quot; target=&quot;_blank&quot;&gt;基于网络应用的架构风格&lt;/a&gt;中介绍到的&lt;strong&gt;远程求值（Remote Evluation = REV）&lt;/strong&gt;的具体实现。&lt;/p&gt;
&lt;h2&gt;4.4 管道&lt;/h2&gt;
&lt;p&gt;因为redis的客户端和服务器的连接时基于TCP的， 默认每次连接都时只能执行一个命令。管道则是允许利用一次连接来处理多条命令，从而可以节省一些tcp连接的开销。&lt;/p&gt;

&lt;p&gt;本篇着重从抽象层面来解释下redis的各项功能以及其存在的目的，而没有关心其具体的细节是什么。从而可以聚焦于其解决的问题，依据抽象层面的概念可以使得我们在特定的场景下选择更合适的方案，而非局限于其技术细节。&lt;/p&gt;
&lt;p&gt;以上均是笔者个人的一些理解，如果不当之处，欢迎指正。&lt;/p&gt;

&lt;p&gt;Redis 文档：&lt;a href=&quot;https://github.com/antirez/redis-doc&quot; target=&quot;_blank&quot;&gt;https://github.com/antirez/redis-doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 简介：&lt;a href=&quot;https://redis.io/topics/introduction&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/introduction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 持久化（Persistence）：&lt;a href=&quot;https://redis.io/topics/persistence&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/persistence&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 发布/订阅（Pub/Sub）：&lt;a href=&quot;https://redis.io/topics/pubsub&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/pubsub&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 哨兵（Sentinel）：&lt;a href=&quot;https://redis.io/topics/sentinel&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/sentinel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 复制（Replication）：&lt;a href=&quot;https://redis.io/topics/replication&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/replication&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 集群（cluster）：&lt;a href=&quot;https://redis.io/topics/cluster-tutorial&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/cluster-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RedIs 事务（Transaction）：&lt;a href=&quot;https://redis.io/topics/transactions&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/transactions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 数据类型（data types）：&lt;a href=&quot;https://redis.io/topics/data-types-intro&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/data-types-intro&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis 管道（pipelining ）：&lt;a href=&quot;https://redis.io/topics/pipelining&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/pipelining&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Redis Lua Script：&lt;a href=&quot;https://redis.io/commands/eval&quot; target=&quot;_blank&quot;&gt;https://redis.io/commands/eval&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 07:31:00 +0000</pubDate>
<dc:creator>Blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/what-problem-does-redis-solve.html</dc:identifier>
</item>
<item>
<title>【开源】【前后端分离】【优雅编码】分享我工作中的一款MVC+EF+IoC+Layui前后端分离的框架——【NO.1】框架概述 - Q.Tiny</title>
<link>http://www.cnblogs.com/Q-Tiny/p/7793156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Q-Tiny/p/7793156.html</guid>
<description>&lt;p&gt;    写博客之前总想说点什么，但写的时候又忘了想说点什么，算了，不说了，还是来送福利吧。&lt;/p&gt;

&lt;p&gt;    今天是来分享我在平时工作中搭建的一套前后端分离的框架。&lt;/p&gt;
&lt;p&gt;    平时工作大多时候都是在做管理类型的软件开发，无非就是增、删、改、查，也没有什么大的并发访问，对程序的性能要求和国内大多数开发管理软件的公司差不多，所以就搭建了一套通用框架，基本上都能满足。&lt;/p&gt;

&lt;p&gt;     一套好的框架首先得编码规范、容易他人阅读。记得刚学编程得那时，认为只有自己看得懂得代码才是牛逼的，后来发现代码是写给别人看的，别人能轻易的看懂你的代码，你的代码就不会差到哪里去。就比如说接口用大写字母【I】开头：IUser，这样易理解，对于不同的开发团队有不同的规范，这样提高了程序员的开发体验，对于同类型的功能可以用一个相同的前缀开头，比如：日志一类可以用Log_开头，业务类的可以用Service_开头，系统类的可以用Sys_开头，这只是个建议。&lt;/p&gt;

&lt;p&gt;      我的这套框架也就是三层架构的风格，这套就主要提供对用户管理的增、删、改、查的功能，包括登录的功能，先截个图看看：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106141109497-1413123765.png&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;320&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106141613575-1890567885.png&quot; alt=&quot;&quot; width=&quot;893&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行后的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106141928091-1692734699.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;514&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106142239153-176585389.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;

&lt;p&gt;删除用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106142505763-734644388.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;

&lt;p&gt;编辑用户，会自动赋值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106142643106-651855051.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    上传的图片变形了。&lt;/p&gt;
&lt;p&gt;    最后再来看下大致的代码：&lt;/p&gt;
&lt;p&gt;    添加用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106142908809-2095136630.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;482&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     编辑用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106143021106-780049463.png&quot; alt=&quot;&quot; width=&quot;776&quot; height=&quot;582&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     分页查询、分页搜索：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106143219966-2049070456.png&quot; alt=&quot;&quot; width=&quot;687&quot; height=&quot;457&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看下业务层代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106143415184-1527492438.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106143630325-759654086.png&quot; alt=&quot;&quot; width=&quot;807&quot; height=&quot;517&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最后看下数据层代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106143851825-2063707632.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后端代码介绍完了。&lt;/p&gt;
&lt;p&gt;由于是前后端分离，所以我们来看看前端代码：无非就是HTML、JS、Css&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/714226/201711/714226-20171106144241981-1328218344.png&quot; alt=&quot;&quot; width=&quot;1051&quot; height=&quot;494&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    最后总结下：&lt;/p&gt;
&lt;p&gt;    整体的代码在逻辑上算清晰的、有完善的异常处理机制、日志记录、公共功能的抽象类、出神入化的依赖注入功能等等，想要学习MVC前后端分离的网友们可以加我的一个QQ群，然后@群主获取源代码，群号：240749438，若群主没有及时回复，那肯定是在忙没空及时回，一般群主晚上都会有空。&lt;/p&gt;
&lt;p&gt;   这篇文章主要对框架的整体介绍，更多细节原理请期待后续文章。&lt;/p&gt;

&lt;p&gt;   博主所有文章均为原创、未得到本人同意，不得商业转载。&lt;/p&gt;


</description>
<pubDate>Mon, 06 Nov 2017 06:52:00 +0000</pubDate>
<dc:creator>Q.Tiny</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Q-Tiny/p/7793156.html</dc:identifier>
</item>
<item>
<title>C#设计模式之十二享元模式（Flyweight）【结构型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/7792973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/7792973.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天我们要讲【结构型】设计模式的第六个模式，该模式是【享元模式】，英文名称是：Flyweight Pattern。还是老套路，先从名字上来看看。“享元”是不是可以这样理解，共享“单元”，单元是什么呢，举例说明，对于图形而言就是图元，对于英文来说就只26个英文字母，对于汉语来说就是每个汉字，也可以这样理解“元”，构成事物的最小单元，这些单元如果大量、且重复出现，可以缓存重复出现的单元，达到节省内存的目的，换句说法就是享元是为了节省空间，对于计算机而言就是内存。面向对象很好地解决了系统抽象性的问题（系统抽象性指把系统里面的事物写成类，类可以实例化成为对象，用对象和对象之间的关系来设计系统），在大多数情况下，这样做是不会损及系统的性能的。但是，在某些特殊的应用中，由于对象的数量太大，并且这些大量的对象中有很多是重复的，如果每个对象都单独的创建（C#的语法是new）出来，会给系统带来难以承受的内存开销。比如图形应用中的图元等对象、字处理应用中的字符对象等。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、享元模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在软件系统中，采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   运用共享技术有效地支持大量细粒度的对象。　　　　                                       　　——《设计模式》GoF&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结构图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       i&lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201711/1048776-20171106142034559-130872114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    （1）、&lt;strong&gt;&lt;span&gt;抽象享元角色&lt;/span&gt;&lt;/strong&gt;（Flyweight）:此角色是所有的具体享元类的基类，为这些类规定出需要实现的公共接口。那些需要外部状态的操作可以通过调用方法以参数形式传入。&lt;/p&gt;&lt;p&gt;    （2）、&lt;span&gt;&lt;strong&gt;具体享元角色&lt;/strong&gt;&lt;/span&gt;（ConcreteFlyweight）：实现抽象享元角色所规定的接口。如果有内部状态的话，可以在类内部定义。&lt;/p&gt;&lt;p&gt;    （3）、&lt;span&gt;&lt;strong&gt;享元工厂角色&lt;/strong&gt;&lt;/span&gt;（FlyweightFactory）：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享，当一个客户端对象调用一个享元对象的时候，享元工厂角色检查系统中是否已经有一个符合要求的享元对象，如果已经存在，享元工厂角色就提供已存在的享元对象，如果系统中没有一个符合的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。&lt;/p&gt;&lt;p&gt;    （4）、&lt;span&gt;&lt;strong&gt;客户端角色&lt;/strong&gt;&lt;/span&gt;（Client）：本角色需要存储所有享元对象的外部状态。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5、享元模式的具体实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    说起“享元模式”，我这里有一个很好的场景可以进行说明。我们知道在战斗的游戏场景中，会有很多战士，基本上战士都是差不多的，小区别战士忽略，最大的区别就是拿的武器不同而已。在大型的战争游戏中，会有大量的士兵出来战斗，我们写程序的时候就可以用“享元”来解决大量战士的情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 享元模式的实现
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 享元模式不是很难，但是有些状态需要单独处理，以下就是该模式的C#实现，有些辅助类，大家应该看得出吧，别混了。
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比如，我们现在需要10000个一般士兵，只需这样&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;             SoldierFactory factory=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SoldierFactory();
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             AK47 ak47=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AK47();
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10000&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;               factory.GetSoldier(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;士兵&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+(i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),ak47,SoldierType.Normal);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们有这么多的士兵，但是使用的内存不是很多，因为我们缓存了。&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;  
&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这些是辅助类型&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; SoldierType
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;       Normal,
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;       Water
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该类型就是抽象战士Soldier--该类型相当于抽象享元角色&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Soldier
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过构造函数初始化士兵的名称&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; Soldier(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;            &lt;span&gt;this&lt;/span&gt;.Name=&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         
&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;士兵的名字&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         publi &lt;span&gt;string&lt;/span&gt; Name{&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以传入不同的武器就用不同的活力---该方法相当于抽象Flyweight的Operation方法&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fight(Weapen weapen);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;  
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般类型的战士，武器就是步枪---相当于具体的Flyweight角色&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NormalSoldier:Soldier
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过构造函数初始化士兵的名称&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; NormalSoldier(&lt;span&gt;string&lt;/span&gt; name):&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name){}
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行享元的方法---就是Flyweight类型的Operation方法&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fight(Weapen weapen)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             weapen.Fire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在陆地执行击毙任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;  
&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是海军陆战队队员，武器精良----相当于具体的Flyweight角色&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaterSoldier:Soldier
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过构造函数初始化士兵的名称&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; WaterSoldier(&lt;span&gt;string&lt;/span&gt; name):&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(name){}
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行享元的方法---就是Flyweight类型的Operation方法&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Fight(Weapen weapen)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             weapen.Fire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在海中执行击毙任务&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此类型和享元没太大关系，可以算是享元对象的状态吧，需要从外部定义&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Weapen
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Fire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; jobName);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此类型和享元没太大关系，可以算是享元对象的状态吧，需要从外部定义&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AK47
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Fire(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; jobName)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;         Console.WriteLine(jobName);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该类型相当于是享元的工厂---相当于FlyweightFactory类型&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SoldierFactory
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;       &lt;span&gt;private&lt;/span&gt; IList&amp;lt;Soldier&amp;gt;&lt;span&gt; soldiers;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;       &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SoldierFactory()
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;          soldiers=&lt;span&gt;new&lt;/span&gt; List&amp;lt;Soldier&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;       Soldier mySoldier=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我这里有两种士兵，所以在这里可以增加另外一个参数，士兵类型，原模式里面没有，&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;       &lt;span&gt;public&lt;/span&gt; Soldier GetSoldier(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name,Weapen weapen,SoldierType soldierType)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;          &lt;span&gt;foreach&lt;/span&gt;(Soldier soldier &lt;span&gt;in&lt;/span&gt;&lt;span&gt; soldiers)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;         {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;.Compare(soldier.Name,name,&lt;span&gt;true&lt;/span&gt;)==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                mySoldier=&lt;span&gt;soldier;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mySoldier;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们这里就任务名称是唯一的&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;(soldierType==&lt;span&gt;Normal)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;         {
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             mySoldier=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NormalSoldier(weapen);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;           &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;          {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             mySoldier=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaterSoldier(weapen);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;          }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;          soldiers.Add(mySoldier);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;           &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mySoldier;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;   这个模式很简单，就话不多说了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、享元模式的实现要点：&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight设计模式主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。&lt;/p&gt;&lt;p&gt;    Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。&lt;/p&gt;&lt;p&gt;　对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      1、享元模式的优点在于它能够极大的减少系统中对象的个数。&lt;/p&gt;&lt;p&gt;      2、享元模式由于使用了外部状态，外部状态相对独立，不会影响到内部状态，所以享元模式使得享元对象能够在不同的环境被共享。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      1、由于享元模式需要区分外部状态和内部状态，使得应用程序在某种程度上来说更加复杂化了。&lt;/p&gt;&lt;p&gt;      2、为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 中享元模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    .NET在C#中有一个Code Behind机制，它表面有一个aspx文件，背后又有一个cs文件，它的编译过程实际上会把aspx文件解析成C#文件，然后编译成dll，在这个过程中，我们在aspx中写的任何html代码都会转化为literal control，literal control是一个一般的文本控件，它就表示html标记。当这些标记有一样的时候，构建控件树的时候就会用到Flyweight模式.&lt;/p&gt;&lt;p&gt;　　它的应用并不是那么平凡，只有在效率空间确实不高的时候我们才用它。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    刚开始接触这个模式的时候，感觉这个模式不是特别难，在我们编码的过程中也有涉及，但是在学习的过程中也走了不少弯路，任何设计模式都有他特定的使用场景，小心误用。这个模式在业务系统中相对而言使用的并不多，在类似游戏场景中、字符处理等系统用的比较多。还是老话，通过迭代来使用模式，别为了模式而模式。今天就到这里，以后继续。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 06:22:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/7792973.html</dc:identifier>
</item>
<item>
<title>Spark作业调度 - 何以堪</title>
<link>http://www.cnblogs.com/ywjy/p/7792639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ywjy/p/7792639.html</guid>
<description>&lt;p&gt;[TOC]&lt;/p&gt;

&lt;p&gt;研究Spark作业调度，是为了合理使用集群的资源。更具体一点，是看看是否提供了可以个性化配置的点，然后根据应用的具体情况制定配置或者使用方案。&lt;/p&gt;
&lt;p&gt;本文参考&lt;a href=&quot;http://spark.apache.org/docs/latest/job-scheduling.html&quot;&gt;官网作业调度文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;spark的作业调度分为两个场景：跨应用的调度和应用内部的调度，下面分别介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：文中配图是自己的理解，并不敢保证其准确性。&lt;/p&gt;

&lt;p&gt;跨应用的调度是由底层的集群管理器负责的，有两种资源分配策略。&lt;/p&gt;
&lt;p&gt;一种是静态资源分隔，即一个应用一开始就申请所有的资源，并在程序运行期间使用持有这些资源。&lt;/p&gt;
&lt;p&gt;一种是动态资源分配，应用根据自己的负载情况动态请求或释放资源。这种策略默认是不开启的。&lt;/p&gt;
&lt;h2 id=&quot;静态资源分隔&quot;&gt;静态资源分隔&lt;/h2&gt;
&lt;p&gt;所有的集群管理器都支持静态资源分隔，只是具体的配置策略不同：&lt;/p&gt;
&lt;h3 id=&quot;standalone-mode&quot;&gt;Standalone mode&lt;/h3&gt;
&lt;p&gt;提交到Standalone mode集群的应用会以FIFO的顺序运行，每一个正在运行的应用都会尝试占用所有的可用资源。使用下面的配置项可以限制每个应用申请的资源：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spark.cores.max&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应用可以申请的最大数量的CPU核的数量，如果没有设置，取&lt;code&gt;spark.deploy.defaultCores&lt;/code&gt;的值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spark.executor.memory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分配给每个executor进程的内存资源。&lt;/p&gt;
&lt;h3 id=&quot;mesos&quot;&gt;Mesos&lt;/h3&gt;
&lt;p&gt;为了使用静态资源隔离，需要设置&lt;code&gt;spark.mesos.coarse&lt;/code&gt;为true，这称为粗粒度的Mesos模式。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;spark.cores.max&lt;/code&gt;和&lt;code&gt;spark.executor.memory&lt;/code&gt;在Mesos模式下同样有效。&lt;/p&gt;
&lt;h3 id=&quot;yarn&quot;&gt;YARN&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;--num-executors&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用spark-submit提交作业时，可以使用&lt;code&gt;--num-executors&lt;/code&gt;选项请求指定的executor个数。&lt;/p&gt;
&lt;p&gt;在程序内部，可以通过设置&lt;code&gt;spark.executor.instances&lt;/code&gt;属性达到同样的目的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;--executor-memory&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用spark-submit提交作业时，可以使用&lt;code&gt;--executor-memory&lt;/code&gt;选项设置每个executor申请的内存。&lt;/p&gt;
&lt;p&gt;在程序内部，可以通过设置&lt;code&gt;spark.executor.memory&lt;/code&gt;属性达到同样的目的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;--executor-cores&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用spark-submit提交作业时，可以使用&lt;code&gt;--executor-cores&lt;/code&gt;选项设置每个executor申请的CPU核。&lt;/p&gt;
&lt;p&gt;在程序内部，可以通过设置&lt;code&gt;spark.executor.cores&lt;/code&gt;属性达到同样的目的。&lt;/p&gt;
&lt;h2 id=&quot;动态资源分配&quot;&gt;动态资源分配&lt;/h2&gt;
&lt;p&gt;spark的运行模型是基于executor的，executor是资源的实际持有者。所以动态资源分配，是通过动态的申请executor和释放executor来实现的。&lt;/p&gt;
&lt;p&gt;动态资源分配涉及到两个方面，如何在需要的时候动态申请资源，以及如何在空闲的时候动态释放资源。&lt;/p&gt;
&lt;p&gt;动态请求策略：如果一个应用有tasks在等待，超过一定的时间（&lt;code&gt;spark.dynamicAllocation.schedulerBacklogTimeout&lt;/code&gt;秒）就会申请1个executor。此后每隔一定的时间（&lt;code&gt;spark.dynamicAllocation.sustainedSchedulerBacklogTimeout&lt;/code&gt;秒）就检测应用是否有tasks在等待，有就继续申请executor。&lt;/p&gt;
&lt;p&gt;动态请求资源的数量是指数级的，第一次申请1个，第二次申请2个，接着是4, 8 ...这种考虑是为了在谨慎申请资源的同时，又可以在允许的时间范围内获得真正需要的资源量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/721161/201711/721161-20171106130504794-733176650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态释放资源：是通过检查应用占据的executor是否超过了指定的时间（&lt;code&gt;spark.dynamicAllocation.executorIdleTimeout&lt;/code&gt;秒）来决定的，超过了就释放。&lt;/p&gt;
&lt;p&gt;释放资源的条件和请求资源的条件是互斥的，即如果一个应用有tasks在排队，就不应该会有空闲的executor。&lt;/p&gt;
&lt;h3 id=&quot;how-to-do&quot;&gt;how to do&lt;/h3&gt;
&lt;p&gt;为了使用动态资源分配，需要做两件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置&lt;code&gt;spark.dynamicAllocation.enabled&lt;/code&gt;值为true&lt;/li&gt;
&lt;li&gt;在每一个工作节点启动&lt;code&gt;external shuffle service&lt;/code&gt;，并设置&lt;code&gt;spark.shuffle.service.enabled&lt;/code&gt;为true&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;external shuffle service&lt;/code&gt;的作用在后面会介绍，不同集群模式下启动&lt;code&gt;external shuffle service&lt;/code&gt;的方式不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;strong&gt;Standalone模式&lt;/strong&gt;，不需要额外的工作来启动&lt;code&gt;external shuffle service&lt;/code&gt;，只需要设置&lt;code&gt;spark.shuffle.service.enabled&lt;/code&gt;为true即可。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;Mesos粗粒度模式&lt;/strong&gt;，在每一个slave nodes运行脚本&lt;code&gt;$SPARK_HOME/sbin/start-mesos-shuffle-service.sh&lt;/code&gt;来启动&lt;code&gt;external shuffle service&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;YARN模式&lt;/strong&gt;，参考&lt;a href=&quot;http://spark.apache.org/docs/latest/running-on-yarn.html#configuring-the-external-shuffle-service&quot;&gt;Configuring the External Shuffle Service On Yarn&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;动态移除executor面对的问题&quot;&gt;动态移除executor面对的问题&lt;/h3&gt;
&lt;p&gt;动态释放资源需要额外的支持，因为executor可能会产生中间结果并输出到本地，在需要的时候需要通过这个executor获取它的中间结果。冒然移除executor会丢失它计算的中间结果，导致在真正需要的时候又要重新计算。&lt;/p&gt;
&lt;p&gt;比如在map阶段executor输出map结果，在shuffle阶段这些map结果又需要通过executor读出来传送到负责reduce的executor。&lt;/p&gt;
&lt;p&gt;spark通过&lt;code&gt;external shuffle service&lt;/code&gt;来解决这个问题。&lt;code&gt;external shuffle service&lt;/code&gt;是指在每一个node都运行的一个长期进程，这个进程独立于应用和executor，负责提供executor的输出数据的获取服务。原来executor之间相互请求来获取对方的输出结果，变成了统一从external shuffle service获取结果。&lt;/p&gt;
&lt;p&gt;即使executor已经被移除了，它所输出的数据依然可以通过&lt;code&gt;external shuffle service&lt;/code&gt;来获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/721161/201711/721161-20171106130537356-341522865.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，executor还可能会把中间结果缓存到内存，目前的策略是不移除此类的executor。未来可能采取将缓存持久化的方式，进而释放executor。&lt;/p&gt;

&lt;p&gt;一个spark应用可以支持多个不同线程的job同时提交，这常见于spark应用提供网络服务的场景。&lt;/p&gt;
&lt;p&gt;spark默认的调度策略是FIFO，如果队列头部的job比较大，占用了集群的所有资源，后面的小任务将迟迟得不到运行的机会。&lt;/p&gt;
&lt;p&gt;另外，spark还支持配置FAIR调度，spark循环调度每个job的task。这样即使有大job在运行，刚提交的小job也可以及时获得资源，而不需要等到大job结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/721161/201711/721161-20171106130720231-1700715501.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过设置属性&lt;code&gt;spark.scheduler.mode&lt;/code&gt;来启用公平调度：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; conf = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SparkConf&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setMaster&lt;/span&gt;(...).&lt;span class=&quot;fu&quot;&gt;setAppName&lt;/span&gt;(...)
conf.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;spark.scheduler.mode&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;FAIR&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; sc = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SparkContext&lt;/span&gt;(conf)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;公平调度池&quot;&gt;公平调度池&lt;/h2&gt;
&lt;p&gt;spark支持公平调度池的概念，每个线程可以指定将jobs提交到哪个池子，最细粒度的场景下是每个线程对应一个池，也可以多个线程使用同一个池。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/721161/201711/721161-20171106130738872-250360368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个线程默认使用的池是default，也可以通过设置参数来明确指定池。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode scala&quot;&gt;
&lt;code class=&quot;sourceCode scala&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Assuming sc is your SparkContext variable&lt;/span&gt;
sc.&lt;span class=&quot;fu&quot;&gt;setLocalProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;spark.scheduler.pool&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;pool1&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想重置当前线程绑定的池子，调用&lt;code&gt;sc.setLocalProperty(&quot;spark.scheduler.pool&quot;, null)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以通过配置文件将资源按照一定的比重分配到池，配置文件的模板：&lt;code&gt;conf/fairscheduler.xml.template&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;conf.set(&quot;spark.scheduler.allocation.file&quot;, &quot;/path/to/file&quot;)&lt;/code&gt;指定配置文件。&lt;/p&gt;
&lt;p&gt;每个池可支持的参数有三个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;schedulingMode：FIFO 或 FAIR，FIFO是默认的策略。&lt;/li&gt;
&lt;li&gt;weight：每个池子分配资源的权重，默认情况下所有的权重为1。&lt;/li&gt;
&lt;li&gt;minShare：最小资源，CPU核的数量，默认为0。在进行资源分配时，总是最先满足所有池的minShare，再根据weight分配剩下的资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置文件示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;allocations&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;pool&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;production&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;schedulingMode&amp;gt;&lt;/span&gt;FAIR&lt;span class=&quot;kw&quot;&gt;&amp;lt;/schedulingMode&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;weight&amp;gt;&lt;/span&gt;1&lt;span class=&quot;kw&quot;&gt;&amp;lt;/weight&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;minShare&amp;gt;&lt;/span&gt;2&lt;span class=&quot;kw&quot;&gt;&amp;lt;/minShare&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/pool&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;pool&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;schedulingMode&amp;gt;&lt;/span&gt;FIFO&lt;span class=&quot;kw&quot;&gt;&amp;lt;/schedulingMode&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;weight&amp;gt;&lt;/span&gt;2&lt;span class=&quot;kw&quot;&gt;&amp;lt;/weight&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;minShare&amp;gt;&lt;/span&gt;3&lt;span class=&quot;kw&quot;&gt;&amp;lt;/minShare&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/pool&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/allocations&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有出现在配置文件中的池，所有参数取默认值（schedulingMode=FIFO，weight=1，minShare=0）。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;executor到底指什么？和容器、JVM的关系是怎样的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;executor是负责一定职责的程序组件，可以在已有的JVM中运行（比如local mode），也可以在新的JVM中运行。使用YARN时，executor是在YARN容器中运行的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;spark的job - stage - task的划分是怎么样的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;spark的job可以划分为多个stage，这些stage构成了DAG。每一个stage又可以划分为多个tasks。stage的划分是根据shuffle map task来的，这一类的task相当于MapReduce中shuffle的map端，负责在本地RDD分区进行计算，并将结果输出到新的分区，供后续的使用。在划分stage时，shuffle map任务作为阶段的结束的边界。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Mesos的粗粒度和细粒度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mesos可以启用CPU核的共享，即同一个节点executor在不使用核的情况下可以让给另一个executor来使用。&lt;/p&gt;
&lt;p&gt;不启用CPU核共享称为粗粒度，启用则称为细粒度，相关的配置项为&lt;code&gt;spark.mesos.coarse&lt;/code&gt;，值为true表示粗粒度。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 05:08:00 +0000</pubDate>
<dc:creator>何以堪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ywjy/p/7792639.html</dc:identifier>
</item>
<item>
<title>Akka（35）： Http：Server side streaming - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/7792451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/7792451.html</guid>
<description>&lt;p&gt;&lt;span&gt;   在前面几篇讨论里我们都提到过：Akka-http是一项系统集成工具库。它是以数据交换的形式进行系统集成的。所以，Akka-http的核心功能应该是数据交换的实现了：应该能通过某种公开的数据格式和传输标准比较方便的实现包括异类系统之间通过网上进行的数据交换。覆盖包括：数据编码、发送和数据接收、解析全过程。Akka-http提供了许多网上传输标准数据的概括模型以及数据类型转换方法，可以使编程人员很方便的构建网上往来的Request和Response。但是，现实中的数据交换远远不止针对request和response操作能够满足的。系统之间数据交换经常涉及文件或者数据库表类型的数据上传下载。虽然在Http标准中描述了如何通过MultiPart消息类型进行批量数据的传输，但是这个标准涉及的实现细节包括数据内容描述、数据分段方式、消息数据长度计算等等简直可以立即令人却步。Akka-http是基于Akka-stream开发的：不但它的工作流程可以用Akka-stream来表达，它还支持stream化的数据传输。我们知道：Akka-stream提供了功能强大的FileIO和Data-Streaming，可以用Stream-Source代表文件或数据库数据源。简单来说：Akka-http的消息数据内容HttpEntity可以支持理论上无限长度的data-stream。最可贵的是：这个Source是个Reactive-Stream-Source，具备了back-pressure机制，可以有效应付数据交换参与两方Reactive端点不同的数据传输速率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Akka-http的stream类型数据内容是以Source[T,_]类型表示的。首先，Akka-stream通过FileIO对象提供了足够多的file-io操作函数，其中有个fromPath函数可以用某个文件内容数据构建一个Source类型：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
   * Creates a Source from a files contents.
   * Emitted elements are `chunkSize` sized [[akka.util.ByteString]] elements,
   * except the final element, which will be up to `chunkSize` in size.
   *
   * You can configure the default dispatcher for this Source by changing the `akka.stream.blocking-io-dispatcher` or
   * set it for a given Source by using [[akka.stream.ActorAttributes]].
   *
   * It materializes a [[Future]] of [[IOResult]] containing the number of bytes read from the source file upon completion,
   * and a possible exception if IO operation was not completed successfully.
   *
   * @param f         the file path to read from
   * @param chunkSize the size of each read operation, defaults to 8192
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  def fromPath(f: Path, chunkSize: Int &lt;/span&gt;= &lt;span&gt;8192&lt;/span&gt;): Source[ByteString, Future[IOResult]] =&lt;span&gt;
    fromPath(f, chunkSize, startPosition &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个函数构建了Source[ByteString,Future[IOResult]]，我们需要把ByteString转化成MessageEntity。首先需要在implicit-scope内提供Marshaller[ByteString,MessageEntity]类型的隐式实例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;trait JsonCodec extends Json4sSupport {
  import org.json4s.DefaultFormats
  import org.json4s.ext.JodaTimeSerializers
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val serilizer =&lt;span&gt; jackson.Serialization
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val formats = DefaultFormats ++&lt;span&gt; JodaTimeSerializers.all
}
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; JsConverters extends JsonCodec

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ServerStreaming extends App {
  import JsConverters._
...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们还需要Json-Streaming支持：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;implicit&lt;/span&gt; val jsonStreamingSupport =&lt;span&gt; EntityStreamingSupport.json()
      .withParallelMarshalling(parallelism &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;, unordered = &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;FileIO是blocking操作，我们还可以选用独立的线程供blocking操作使用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   FileIO.fromPath(file, &lt;span&gt;256&lt;/span&gt;&lt;span&gt;)
      .withAttributes(ActorAttributes.dispatcher(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.http.blocking-ops-dispatcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在我们可以从在server上用一个文件构建Source然后再转成Response：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  val route =
    &lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
      path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/Remaining) { name =&amp;gt;&lt;span&gt;
          complete(loadFile(name))
      } 
    }
  def loadFile(path: String) &lt;/span&gt;=&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   implicit val ec = httpSys.dispatchers.lookup(&quot;akka.http.blocking-ops-dispatcher&quot;)&lt;/span&gt;
    val file = Paths.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Users/tiger/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;path)
    FileIO.fromPath(file, &lt;/span&gt;&lt;span&gt;256&lt;/span&gt;&lt;span&gt;)
      .withAttributes(ActorAttributes.dispatcher(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.http.blocking-ops-dispatcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
      .map(_.utf8String)
  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样，我们也可以把数据库表内数据转成Akka-Stream-Source，然后再实现到MessageEntity的转换。转换过程包括用Query读取数据库表内数据后转成Reactive-Publisher，然后把publisher转成Akka-Stream-Source，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SlickDAO {
  import slick.jdbc.H2Profile.api._
  val dbConfig: slick.basic.DatabaseConfig[slick.jdbc.H2Profile] &lt;/span&gt;= slick.basic.DatabaseConfig.forConfig(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slick.h2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  val db &lt;/span&gt;=&lt;span&gt; dbConfig.db

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountyModel(id: Int, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CountyTable(tag: Tag) extends Table[CountyModel](tag,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COUNTY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
    def id &lt;/span&gt;= column[Int](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,O.AutoInc,O.PrimaryKey)
    def name &lt;/span&gt;= column[String](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,O.Length(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;))
    def &lt;/span&gt;* = (id,name)&amp;lt;&amp;gt;&lt;span&gt;(CountyModel.tupled,CountyModel.unapply)
  }
  val CountyQuery &lt;/span&gt;=&lt;span&gt; TableQuery[CountyTable]

  def loadTable(filter: String) &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   implicit val ec = httpSys.dispatchers.lookup(&quot;akka.http.blocking-ops-dispatcher&quot;)&lt;/span&gt;
    val qry = CountyQuery.filter {_.name.toUpperCase like s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%${filter.toUpperCase}%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    val publisher &lt;/span&gt;=&lt;span&gt; db.stream(qry.result)
    Source.fromPublisher(publisher &lt;/span&gt;=&lt;span&gt; publisher)
      .withAttributes(ActorAttributes.dispatcher(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.http.blocking-ops-dispatcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后进行到MessageEntity的转换：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  val route =
    &lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
      path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/Remaining) { name =&amp;gt;&lt;span&gt;
          complete(loadFile(name))
      } &lt;/span&gt;~&lt;span&gt;
      path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/Segment) { t =&amp;gt;&lt;span&gt;
        complete(SlickDAO.loadTable(t))
      }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;下面是本次示范的完整源代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import java.nio.file._
import akka.actor._
import akka.stream._
import akka.stream.scaladsl._
import akka.http.scaladsl.Http
import akka.http.scaladsl.server.Directives._
import akka.http.scaladsl.common._
import de.heikoseeberger.akkahttpjson4s.Json4sSupport
import org.json4s.jackson


&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; SlickDAO {
  import slick.jdbc.H2Profile.api._
  val dbConfig: slick.basic.DatabaseConfig[slick.jdbc.H2Profile] &lt;/span&gt;= slick.basic.DatabaseConfig.forConfig(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slick.h2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  val db &lt;/span&gt;=&lt;span&gt; dbConfig.db

  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountyModel(id: Int, name: String)
  &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CountyTable(tag: Tag) extends Table[CountyModel](tag,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COUNTY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
    def id &lt;/span&gt;= column[Int](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,O.AutoInc,O.PrimaryKey)
    def name &lt;/span&gt;= column[String](&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,O.Length(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;))
    def &lt;/span&gt;* = (id,name)&amp;lt;&amp;gt;&lt;span&gt;(CountyModel.tupled,CountyModel.unapply)
  }
  val CountyQuery &lt;/span&gt;=&lt;span&gt; TableQuery[CountyTable]

  def loadTable(filter: String) &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   implicit val ec = httpSys.dispatchers.lookup(&quot;akka.http.blocking-ops-dispatcher&quot;)&lt;/span&gt;
    val qry = CountyQuery.filter {_.name.toUpperCase like s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%${filter.toUpperCase}%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    val publisher &lt;/span&gt;=&lt;span&gt; db.stream(qry.result)
    Source.fromPublisher(publisher &lt;/span&gt;=&lt;span&gt; publisher)
      .withAttributes(ActorAttributes.dispatcher(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.http.blocking-ops-dispatcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  }
}

trait JsonCodec extends Json4sSupport {
  import org.json4s.DefaultFormats
  import org.json4s.ext.JodaTimeSerializers
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val serilizer =&lt;span&gt; jackson.Serialization
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val formats = DefaultFormats ++&lt;span&gt; JodaTimeSerializers.all
}
&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; JsConverters extends JsonCodec

&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; ServerStreaming extends App {
  import JsConverters._

  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpSys = ActorSystem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpSystem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpMat =&lt;span&gt; ActorMaterializer()
  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val httpEC =&lt;span&gt; httpSys.dispatcher

  &lt;/span&gt;&lt;span&gt;implicit&lt;/span&gt; val jsonStreamingSupport =&lt;span&gt; EntityStreamingSupport.json()
      .withParallelMarshalling(parallelism &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;, unordered = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)



  val (port, host) &lt;/span&gt;= (&lt;span&gt;8011&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  val route &lt;/span&gt;=
    &lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
      path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;files&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/Remaining) { name =&amp;gt;&lt;span&gt;
          complete(loadFile(name))
      } &lt;/span&gt;~&lt;span&gt;
      path(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/Segment) { t =&amp;gt;&lt;span&gt;
        complete(SlickDAO.loadTable(t))
      }
    }

  def loadFile(path: String) &lt;/span&gt;=&lt;span&gt; {
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   implicit val ec = httpSys.dispatchers.lookup(&quot;akka.http.blocking-ops-dispatcher&quot;)&lt;/span&gt;
    val file = Paths.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Users/tiger/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;path)
    FileIO.fromPath(file, &lt;/span&gt;&lt;span&gt;256&lt;/span&gt;&lt;span&gt;)
      .withAttributes(ActorAttributes.dispatcher(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;akka.http.blocking-ops-dispatcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
      .map(_.utf8String)
  }

  val bindingFuture &lt;/span&gt;=&lt;span&gt; Http().bindAndHandle(route,host,port)

  println(s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server running at $host $port. Press any key to exit ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

  scala.io.StdIn.readLine()

  bindingFuture.flatMap(_.unbind())
    .onComplete(_ &lt;/span&gt;=&amp;gt;&lt;span&gt; httpSys.terminate())

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 04:06:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/7792451.html</dc:identifier>
</item>
<item>
<title>记录下Webapi签名机制 - Clark-苏</title>
<link>http://www.cnblogs.com/suzhiyong1988/p/7792457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suzhiyong1988/p/7792457.html</guid>
<description>&lt;p&gt;　　首先，写这篇文章的原因是因为最近某一个项目中的接口被人为调用了，导致了数据库数据被串改。虽然是内部人无意点的，但还是引起了我的担忧，所有整理了下关于Webapi的相关签名机制。&lt;/p&gt;
&lt;p&gt;一、我们在开发接口时，有时候嫌麻烦就懒进行相关的验证或只进行一些简单的验证,这样客户端就可以直接调用：如&lt;/p&gt;
&lt;p&gt;调用Webapi接口：http://XXX.XXX.XX.XXX:8123/Token/GetTest?ID=123456&lt;/p&gt;
&lt;p&gt;这种方式简单粗暴，在浏览器直接输入&quot;http://XXX.XXX.XX.XXX:8123/Token/GetTest?ID=123456&quot;，即可获取产品列表信息了，但是这样的方式会存在很严重的安全性问题，没有进行任何的验证，大家都可以通过这个方法获取到产品列表，导致产品信息泄露，下面简单记录下使用使用TOKEN+签名认证&lt;/p&gt;
&lt;p&gt;二、&lt;strong&gt;使用TOKEN+签名认证 保证请求安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　token+签名认证的主要原理是：1.做一个认证服务，提供一个认证的webapi，用户先访问它获取对应的token&lt;/p&gt;
&lt;p&gt;                                      2.用户拿着相应的token以及请求的参数和服务器端提供的签名算法计算出签名后再去访问指定的api&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　3.服务器端每次接收到请求就获取对应用户的token和请求参数，服务器端再次计算签名和客户端签名做对比，如果验证通过则正常访问相应的api，验证失败则 返回具体的失败信息&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;p&gt;1.用户请求认证服务GetToken，将token保存在服务器端缓存中，并返回对应的Token到客户端（该请求不需要进行签名认证）,使用GET调用方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult GetToken(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; signKey)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(signKey))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json&amp;lt;ResultMsg&amp;gt;(&lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.ParameterError, EnumExtension.GetEnumText(ExceptionStatus.ParameterError), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据签名ID获取缓存token&lt;/span&gt;
    &lt;span&gt;string&lt;/span&gt; strKey = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, WebConfig.signKey, signKey);
    Token cacheData &lt;/span&gt;= HttpRuntime.Cache.Get(strKey) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Token;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cacheData == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        cacheData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Token();
        cacheData.signId &lt;/span&gt;=&lt;span&gt; signKey;
        cacheData.timespan &lt;/span&gt;= DateTime.Now.AddDays(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        cacheData.signToken &lt;/span&gt;= Guid.NewGuid().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入缓存，缓存时间为1天&lt;/span&gt;
        HttpRuntime.Cache.Insert(strKey, cacheData, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, cacheData.timespan, TimeSpan.Zero);
    }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回token信息&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; Json&amp;lt;ResultMsg&amp;gt;(&lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ExceptionStatus.OK, EnumExtension.GetEnumText(ExceptionStatus.OK), cacheData));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.客户端调用方法，GET或POST&lt;/p&gt;
&lt;p&gt;(1) GET:需要在请求头中添加：timespan（时间戳），nonce（随机数），signKey（key），signature（签名参数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 　　　　public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; T Get&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; url, &lt;span&gt;string&lt;/span&gt; paras, &lt;span&gt;string&lt;/span&gt; signId,&lt;span&gt;bool&lt;/span&gt; isSign=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            HttpWebRequest webrequest &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            HttpWebResponse webresponse &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strResult = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                webrequest &lt;/span&gt;= (HttpWebRequest)WebRequest.Create(url + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; paras);
                webrequest.Method &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                webrequest.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                webrequest.Timeout &lt;/span&gt;= &lt;span&gt;90000&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入头信息&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; timespan =&lt;span&gt; GetTimespan();
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; ran = GetRandom(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
                webrequest.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, signId);
                DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signKey:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; signId);
                webrequest.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timespan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, timespan);
                DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timespan:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; timespan);
                webrequest.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nonce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ran);
                DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nonce:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ran);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSign)
                {
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strSign =&lt;span&gt; GetSignature(signId, timespan, ran, paras);
                    webrequest.Headers.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strSign);
                    DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signature:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; strSign);
                }
                webresponse &lt;/span&gt;=&lt;span&gt; (HttpWebResponse)webrequest.GetResponse();
                Stream stream &lt;/span&gt;=&lt;span&gt; webresponse.GetResponseStream();
                StreamReader sr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream, Encoding.UTF8);
                strResult &lt;/span&gt;=&lt;span&gt; sr.ReadToEnd();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;&lt;span&gt;(ex.Message);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (webresponse != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    webresponse.Close();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (webrequest != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    webrequest.Abort();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;T&amp;gt;&lt;span&gt;(strResult);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)POST写法这里就不写了，同理需要设置header请求头参数：timespan（时间戳），nonce（随机数），signKey（key），signature（签名参数）&lt;/p&gt;
&lt;p&gt;(3)根据请求参数计算本次请求的签名，用timespan+nonc+signKey+token+data（请求参数字符串）得到signStr签名字符串，然后再进行排序和MD5加密得到最终的signature签名字符串，添加到请求头中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetSignature(&lt;span&gt;string&lt;/span&gt; signKey, &lt;span&gt;string&lt;/span&gt; timespan, &lt;span&gt;string&lt;/span&gt; nonce, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; data)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; signToken = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = GetToken&amp;lt;JObject&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokena = JsonConvert.DeserializeObject&amp;lt;JObject&amp;gt;(result[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString());
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tokena != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        signToken &lt;/span&gt;= tokena[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signToken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
                }
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hash =&lt;span&gt; MD5.Create();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str = signKey + timespan + nonce + signToken +&lt;span&gt; data;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = Encoding.UTF8.GetBytes(&lt;span&gt;string&lt;/span&gt;.Concat(str.OrderBy(c =&amp;gt;&lt;span&gt; c)));
            DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;str内容:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;string&lt;/span&gt;.Concat(str.OrderBy(c =&amp;gt;&lt;span&gt; c)));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用MD5加密&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; md5Val =&lt;span&gt; hash.ComputeHash(bytes);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把二进制转化为大写的十六进制&lt;/span&gt;
            StringBuilder strSign = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; val &lt;span&gt;in&lt;/span&gt;&lt;span&gt; md5Val)
            {
                strSign.Append(val.ToString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; strSign.ToString();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4)Webapi接收到相应参数，通过header获取到timespan（时间戳），nonce（随机数），signKey（key），signature（签名参数），判断参数是否为空、接口是否在有效时间内、判断token是否有效、判断和请求的signature(签名)是否相同，如果通过，返回正常的结果。如果验证不通过，返回相应的错误提示信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(System.Web.Http.Controllers.HttpActionContext filterContext)
        {
            ResultMsg result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; signKey = &lt;span&gt;string&lt;/span&gt;.Empty, timespan = &lt;span&gt;string&lt;/span&gt;.Empty, nonce = &lt;span&gt;string&lt;/span&gt;.Empty, signature = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断请求的消息中是否包括判断参数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; request =&lt;span&gt; filterContext.Request;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.Headers.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                signKey &lt;/span&gt;= request.Headers.GetValues(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.Headers.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timespan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                timespan &lt;/span&gt;= request.Headers.GetValues(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timespan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.Headers.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nonce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                nonce &lt;/span&gt;= request.Headers.GetValues(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nonce&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.Headers.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                signature &lt;/span&gt;= request.Headers.GetValues(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signature&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).FirstOrDefault();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果方法是GetToken,则不需要验证&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (filterContext.ActionDescriptor.ActionName.ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gettoken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(signKey) || &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(timespan) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(nonce))
                {
                    result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.ParameterError, EnumExtension.GetEnumText(ExceptionStatus.ParameterError), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    filterContext.Response &lt;/span&gt;=&lt;span&gt; HttpResponseExtension.ToJson(result);
                    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
            DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试参数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; signtoken = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否包含以下参数&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(signKey) || &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(timespan) || &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(nonce) || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(signature))
            {
                result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.ParameterError, EnumExtension.GetEnumText(ExceptionStatus.ParameterError), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                filterContext.Response &lt;/span&gt;=&lt;span&gt; HttpResponseExtension.ToJson(result);
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试是否在有效时间内&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否在有效时间内&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; ts1 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; ts2 = (DateTime.UtcNow - &lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1970&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)).TotalMilliseconds;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; timespanValidate = &lt;span&gt;double&lt;/span&gt;.TryParse(timespan, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; ts1);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; ts = ts2 -&lt;span&gt; ts1;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; falg = ts &amp;gt; &lt;span&gt;int&lt;/span&gt;.Parse(WebConfig.UrlExpireTime) * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!timespanValidate ||&lt;span&gt; falg)
            {
                result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.URLExpireError, EnumExtension.GetEnumText(ExceptionStatus.URLExpireError), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                filterContext.Response &lt;/span&gt;=&lt;span&gt; HttpResponseExtension.ToJson(result);
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试token是否有效&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断token是否有效&lt;/span&gt;
            Token token = HttpRuntime.Cache.Get(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, WebConfig.signKey, signKey)) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Token;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (token == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.TokenInvalid, EnumExtension.GetEnumText(ExceptionStatus.TokenInvalid), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                filterContext.Response &lt;/span&gt;=&lt;span&gt; HttpResponseExtension.ToJson(result);
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                signtoken &lt;/span&gt;=&lt;span&gt; token.signToken;

            DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;判断http调用方式&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; data = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断http调用方式&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; method =&lt;span&gt; request.Method.Method.ToUpper();
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (method)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    Stream stream &lt;/span&gt;=&lt;span&gt; HttpContext.Current.Request.InputStream;
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; responseJson = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
                    StreamReader streamReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(stream);
                    data &lt;/span&gt;=&lt;span&gt; streamReader.ReadToEnd();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    NameValueCollection form &lt;/span&gt;=&lt;span&gt; HttpContext.Current.Request.QueryString;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步：取出所有get参数&lt;/span&gt;
                    IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; parameters = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; f = &lt;span&gt;0&lt;/span&gt;; f &amp;lt; form.Count; f++&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key =&lt;span&gt; form.Keys[f];
                        parameters.Add(key, form[key]);
                    }

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步：把字典按Key的字母顺序排序&lt;/span&gt;
                    IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; sortedParams = &lt;span&gt;new&lt;/span&gt; SortedDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(parameters);
                    IEnumerator&lt;/span&gt;&amp;lt;KeyValuePair&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; dem =&lt;span&gt; sortedParams.GetEnumerator();

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步：把所有参数名和参数值串在一起&lt;/span&gt;
                    StringBuilder query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (dem.MoveNext())
                    {
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key =&lt;span&gt; dem.Current.Key;
                        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; value =&lt;span&gt; dem.Current.Value;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(key))
                        {
                            query.Append(key).Append(value);
                        }
                    }
                    data &lt;/span&gt;=&lt;span&gt; query.ToString();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.HttpMehtodError, EnumExtension.GetEnumText(ExceptionStatus.HttpMehtodError), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    filterContext.Response &lt;/span&gt;=&lt;span&gt; HttpResponseExtension.ToJson(result);
                    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            DbLogger.LogWriteMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证签名信息是否符合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证签名信息是否符合&lt;/span&gt;
            &lt;span&gt;bool&lt;/span&gt; valida =&lt;span&gt; ValidateSign.Validate(signKey, timespan, nonce, signtoken, data, signature);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;valida)
            {
                result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ResultMsg((&lt;span&gt;int&lt;/span&gt;)ExceptionStatus.HttpRequestError, EnumExtension.GetEnumText(ExceptionStatus.HttpRequestError), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                filterContext.Response &lt;/span&gt;=&lt;span&gt; HttpResponseExtension.ToJson(result);
                &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;下面我们进行测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GET请求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/835511/201711/835511-20171106115301700-1938600316.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/835511/201711/835511-20171106115455231-286011449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但我们在浏览器中直接显示或信息被串改时，不合法的请求就会被识别为请求参数已被修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/835511/201711/835511-20171106115646044-585195216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;判断签名是否成功，第一次请求签名参数signature和服务器端计算result完全相同， 然后当把请求参数修改之后服务器端计算的result和请求签名参数signature不同，所以请求不合法，是非法请求，同理如果其他任何参数被修改最后计算的结果都会和签名参数不同，请求同样识别为不合法请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上面的案例，我们可以看出，安全的关键在于参与签名的token，整个过程中token是不参与通信的，所以只要保证token不泄露，请求就不会被伪造。&lt;/p&gt;
&lt;p&gt;然后我们通过timestamp时间戳用来验证请求是否过期，这样就算被人拿走完整的请求链接也是无效的。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 04:01:00 +0000</pubDate>
<dc:creator>Clark-苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suzhiyong1988/p/7792457.html</dc:identifier>
</item>
<item>
<title>第一数学归纳法：施塔特中心的地板砖 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/7792374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/7792374.html</guid>
<description>&lt;p&gt;&lt;em&gt;数学归纳法是一种显示（局部）自然数元素都具有某种性质的有力工具。在离散数学和计算机科学中它都起到了重要作用。事实上，它的使用本身就是对离散性质的一种定义。归纳法的缺点在于它无法告诉你“究竟发生了什么”，即性质成立的根本原因，不过这也是它的一个优点，降低了证明的复杂性。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这篇博文和之后的博文中我会通过一些有意思的问题介绍数学归纳法中的第一数学归纳法和第二数学归纳法以及不变性原理（归纳法的一种，通常被用在step-by-step的推理过程中），并在最后总结良序原理、第一数学归纳法和第二数学归纳法的联系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一数学归纳法（Ordinary Induction）&lt;/strong&gt;: 设P是对于非负整数的一个谓语，则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;P(0)成立&lt;/li&gt;
&lt;li&gt;对于所有的非负整数n，P(n) -&amp;gt; p(n + 1)&lt;/li&gt;
&lt;li&gt;则对于所有的非负整数m，P(m)成立&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看起来这个方法非常简单，以至于我们可能找不到能证明它的正确性的公理（实际上它和良序原理是等价的）。用公式表示就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201711/1072319-20171106114123466-512496521.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通常而言，使用第一数学归纳法都可以遵循下面这个模版：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;声明接下来的证明会采用归纳法。&lt;/li&gt;
&lt;li&gt;定义正确的谓词P，P(n)通常被称作“归纳假设”。归纳最后得到的结论就是对于所有非负整数p(n)均成立。一个清晰的归纳假设通常是归纳法中最重要的一步，所以不要简写！简单的情况下P就是你要证明的东西，但有些时候P可能会包含一些变量，这个时候就要说明清楚哪一个是n。&lt;/li&gt;
&lt;li&gt;证明P(0)成立。&lt;/li&gt;
&lt;li&gt;证明对于所有非负整数n，P(n) -&amp;gt; P(n + 1)。即假设P(n)成立，然后利用P(n)成立这个假设推出p(n + 1)也是成立的。要注意的是，我们必须保证P(n) -&amp;gt; P(n + 1)对于所有非负整数都是能够成立的，即“推理链条”不能被中断（本文最后会有一个反面例子）。&lt;/li&gt;
&lt;li&gt;由归纳法得出结论。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;施塔特中心的地板砖问题（应该是一个真实的事）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几年前MIT打算建一座名叫施塔特中心的建筑物，但是在建筑过程中发生了资金不足的情况。校董事会商议后决定邀请社会人士捐款，并为捐款最多的一位做一座雕像B立在大厅。这个建筑的设计师设计的大厅形状是一个由瓷砖铺成的长宽为2^n的正方形，而且采用的瓷砖也很特别，是一个由三个1 * 1正方形组成的L形瓷砖，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201711/1072319-20171106114138247-1973043609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设计师还要求，雕像B只能立在大厅的正中心（对于n=0，整个大厅就是那一个雕像，其余的情况雕像必须放在中心的2 * 2的空间内），其中n = 2的情况如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201711/1072319-20171106114143825-250657501.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设计师的方案对于n的取值又要求吗？还是说对于任意非负整数n都能满足呢？&lt;/p&gt;

&lt;p&gt;下面利用第一数学归纳法对其进行证明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本次证明采用数学第一归纳法&lt;/li&gt;
&lt;li&gt;设谓词P(n)为对于非负整数n，设计师的要求能够满足。&lt;/li&gt;
&lt;li&gt;P(0)成立因为B雕像占据了整个大厅（不需要铺瓷砖）。&lt;/li&gt;
&lt;li&gt;假设P(n)成立，即对于一个2^n长宽的正方形，我们可以把B雕像放在中心位置，其余的部分铺上L形瓷砖。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个时候问题发生了，我们不能由P(n)推出P(n + 1)，因为我们只能得到可以在2^(n + 1)的正方形中心的四个对角方向的“中心”可以放置B雕像。&lt;/p&gt;
&lt;p&gt;当这种情况发生时，首先的想法应该是找一个更加普遍或者说强壮的归纳假设，也就是之前归纳假设的超集。例如在这题中，我们可以把P(n)变为对于一个2^n长宽的正方形，我们可以把B雕像放在其中的任意位置，其余的部分铺上L形瓷砖。&lt;/p&gt;
&lt;p&gt;这看起来有些奇怪——“如果你证明不了A，那就证明比A更普遍的B”——但是在归纳法中确实是这样的，因为我们在推P(n + 1)的时候也可以获得更好的条件。当然，增强后的P(n)首先要是（至少感觉上）是正确的。下面就采用增强后的P来证明：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本次证明采用数学第一归纳法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设谓词P(n)为对于非负整数n，可以把B雕像放2^n正方形的任意位置，其余的部分铺上L形瓷砖。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;P(0)成立因为B雕像占据了整个大厅（不需要铺瓷砖）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;假设P(n)成立，即对于一个2^n长宽的正方形，我们可以把B雕像放在其中的任意位置，其余的部分铺上L形瓷砖。那么对于P(n + 1)，即一个2^(n+1)长宽的正方形，我们可以将其分为四个2^n的正方形，而对于其中的每个正方形，由于P(n)成立，我们将其中的三个正方形的对角的那个1*1正方形空出来，在2^(n+1)的正方形中心形成一个L形，并铺上一块瓷砖，这个时候我们就可以在剩下的那个2^n的正方形中任意放置B雕像了，如下图所示：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1072319/201711/1072319-20171106114214434-75109051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这三个2^n的正方形选择是随机的，所以可以得出结论，即我们可以在2^(n+1)的正方形任意位置放置B雕像，其余部分铺上L形瓷砖。&lt;/p&gt;
&lt;p&gt;5.由归纳法得出对于非负整数n，我们可以把B雕像放在一个2^n长宽的正方形中的任意位置，其余的部分铺上L形瓷砖。&lt;/p&gt;
&lt;p&gt;所以我们当然也可以把雕像放在中心位置了。可以看到，我们不仅证明了一个更强的结论，还找到了实现这种结论的算法。&lt;/p&gt;

&lt;p&gt;如前面所说，在进行p(n) -&amp;gt; p(n + 1)这步时，我们必须保证P(n) -&amp;gt; P(n + 1)对于&lt;strong&gt;所有非负整数&lt;/strong&gt;都是能够成立的，即“推理链条”不能被中断。这里举出一个有名的反面教材，证明所有的马都是一种颜色：&lt;/p&gt;
&lt;p&gt;1.本次证明使用第一数学归纳法。&lt;/p&gt;
&lt;p&gt;2.设命题P(n)为对于任意n匹马（n&amp;gt;=1)，它们的颜色一样。&lt;/p&gt;
&lt;p&gt;3.这个命题对n=1时成立，即，只有1匹马时，马的颜色只有一种。&lt;/p&gt;
&lt;p&gt;4.假设这个命题对n成立，即假设任何n匹马都是一种颜色。那么当我们有n+1匹马时，不妨把它们编好号：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1, 2, 3……n, n+1&lt;/em&gt; ，对其中&lt;em&gt;（1、2……n）&lt;/em&gt;这些马，由我们的假设可以得到，它们都是同一种颜色；对&lt;em&gt;（2、3……n、n+1）&lt;/em&gt;这些马，我们也可以得到它们是一种颜色；由于这两组中都有&lt;em&gt;（2、3、……n）&lt;/em&gt;这些马，所以可以得到，这n+1种马都是同一种颜色。即P(n) -&amp;gt; p(n + 1)&lt;/p&gt;
&lt;p&gt;5.得到所有的马颜色相同。&lt;/p&gt;
&lt;p&gt;这个证明的错误来于推理的第二步：当n=1时，n+1=2，此时马的编号只有1、2，那么分的两组是（1）和（2）——它们没有交集，所以第二步的推论是错误的。数学归纳法第二步要求n→n+1过程对n=1，2，3……的数都成立，而上面的证明就好比多米诺骨牌的第一块和第二块之间间隔太大，推倒了第一块，但它不会推倒第二块。即使我们知道第二块倒下会推倒第三块等等，但这个过程早已在第一和第二块之间就中断了。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://courses.csail.mit.edu/6.042/spring17/mcs.pdf&quot;&gt;Mathematics for Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95&quot;&gt;数学归纳法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 06 Nov 2017 03:45:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/7792374.html</dc:identifier>
</item>
<item>
<title>手工搭建ABP框架(1) - Web项目 - 古霜卡比</title>
<link>http://www.cnblogs.com/skabyy/p/7295533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skabyy/p/7295533.html</guid>
<description>&lt;blockquote readability=&quot;3.781512605042&quot;&gt;
&lt;p&gt;为了防止不提供原网址的转载，特在这里加上原文链接：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/skabyy/p/7295533.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/skabyy/p/7295533.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ABP是 ASP.NET Boilerplate Project 的简称。ABP是基于&lt;strong&gt;DDD&lt;/strong&gt;（领域驱动设计）的框架。ABP包含众多组件，包括依赖注入、动态API、审计日志、权限控制等等。在大部分的ABP教材中，会推荐使用模板（&lt;a href=&quot;https://aspnetboilerplate.com/Templates&quot; class=&quot;uri&quot;&gt;https://aspnetboilerplate.com/Templates&lt;/a&gt;）来创建ABP工程。然而在实际使用中（至少在我的情况里）一般都需要手工搭建框架而非使用模板。手工搭建有下面几个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;模板创建的工程有很多不需要的东西需要调整或删除，手工搭建免去了这些麻烦；&lt;/li&gt;
&lt;li&gt;手工搭建框架能更自由地根据实际需求进行自定义配置和扩展；&lt;/li&gt;
&lt;li&gt;手工搭建能帮助你更深入地理解ABP框架。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于手工搭建ABP框架材料较少，我搭建时踩了不少坑。所以在这里记录一下搭建框架的核心步骤，以免以后重新摸索，同时与大家分享，欢迎拍砖。下面我们以开发一个简单的微博应用为例来展示如何使用ABP框架。&lt;/p&gt;
&lt;h2 id=&quot;新建vs项目&quot;&gt;新建VS项目&lt;/h2&gt;
&lt;p&gt;用VS新建Web MVC项目，项目名称为&lt;code&gt;MyTweet.Web&lt;/code&gt;。同时新建解决方案，解决方案名称为&lt;code&gt;MyTweet&lt;/code&gt;。&lt;strong&gt;要注意的一点是ABP只支持.NET 4.6以上版本，所以新建项目时记得选.NET Framework 4.6以上的版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902002939874-1067743229.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们遵循&lt;strong&gt;DDD&lt;/strong&gt;的原则，新建以下几个层次的项目：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;展现层（Presentation）&lt;/strong&gt;，负责用户界面与用户交互。在我们这个应用中，展现层是.NET MVC，包括Controller以及前端代码，实现在项目&lt;code&gt;MyTweet.Web&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用层（Application）&lt;/strong&gt;，负责展现层与领域层之间的协调。实现在项目&lt;code&gt;MyTweet.Application&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;领域层（Domain）&lt;/strong&gt;，负责业务对象与业务逻辑。实现在项目&lt;code&gt;MyTweet.Domain&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基础设施层（Infrastructure）&lt;/strong&gt;，提供一些通用的方法。实现在项目&lt;code&gt;MyTweet.Infrastructure&lt;/code&gt;中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902002920015-1096541433.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建好项目后，还需要设置引用依赖关系。在此不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;安装abp相关的nuget包&quot;&gt;安装ABP相关的NuGet包&lt;/h2&gt;
&lt;p&gt;安装&lt;code&gt;Abp&lt;/code&gt;包到所有项目。&lt;/p&gt;
&lt;p&gt;安装&lt;code&gt;Abp.Web.Mvc&lt;/code&gt;和&lt;code&gt;Abp.Web.Api&lt;/code&gt;到&lt;code&gt;MyTweet.Web&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;创建模块&quot;&gt;创建模块&lt;/h2&gt;
&lt;p&gt;ABP提供了模块系统。使用模块能方便地管理各个组件的初始化与依赖关系。一般来说，每个项目都会建一个模块。由于本篇只用到了&lt;code&gt;MyTweet.Web&lt;/code&gt;和&lt;code&gt;MyTweet.Application&lt;/code&gt;，所以先只新建这两个模块。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;MyTweet.Application&lt;/code&gt;目录下新建类&lt;code&gt;MyTweetApplicationModule&lt;/code&gt;，并继承自&lt;code&gt;AbpModule&lt;/code&gt;。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902003020593-863264955.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模块中的&lt;code&gt;Initialize&lt;/code&gt;方法定义了模块初始化时执行的操作。目前只做了IoC依赖注入的操作。&lt;/p&gt;
&lt;p&gt;另外，在&lt;code&gt;MyTweet.Web/App_Start&lt;/code&gt;目录下新建类&lt;code&gt;MyTweetWebModule&lt;/code&gt;，同样也需要继承自&lt;code&gt;AbpModule&lt;/code&gt;，并且，这个模块还需要依赖&lt;code&gt;AbpWebApiModule&lt;/code&gt;（WebAPI需要这个模块），&lt;code&gt;MyTweetApplicationModule&lt;/code&gt;。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902003041468-2051996085.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，为了让程序运行时能识别并执行模块，需要修改入口方法。.NET MVC的入口方法在&lt;code&gt;Global.asax.cs&lt;/code&gt;文件中，如下图，&lt;code&gt;MvcApplication&lt;/code&gt;修改为继承&lt;code&gt;AbpWebApplication&amp;lt;MyTweetWebModule&amp;gt;&lt;/code&gt;，并相应地修改&lt;code&gt;Application_Start&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902003057468-1473120369.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;webapi&quot;&gt;WebAPI&lt;/h2&gt;
&lt;p&gt;我们使用WebAPI的方式定义前后端交互的接口。当然，直接使用MVC的方法也是可以的。这里只是单纯为了试用ABP动态WebAPI的用法而使用的WebAPI。&lt;/p&gt;
&lt;p&gt;我们将实现两个接口：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;GetTweets&lt;/code&gt;接口，GET方法，用于查询出所有微博。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CreateTweet&lt;/code&gt;接口，POST方法，用于新增一条微博。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为我们还没实现数据库访问功能，所以现在还不会真正实现这两个接口，这两个接口现在只让它们返回一些测试数据。&lt;/p&gt;
&lt;p&gt;在ABP框架下实现WebAPI十分方便，&lt;strong&gt;ABP能够使用反射的方法自动从应用层&lt;code&gt;AppService&lt;/code&gt;的public方法生成WebAPI接口&lt;/strong&gt;。只需在&lt;code&gt;MyTweetModule&lt;/code&gt;的初始化方法添加代码定义动态&lt;code&gt;ApiController&lt;/code&gt;生成规则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902003254187-1354448142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些代码会在&lt;code&gt;MyTweetApplicationModule&lt;/code&gt;的程序集中，将所有&lt;code&gt;IApplicationService&lt;/code&gt;的实现类动态生成&lt;code&gt;ApiController&lt;/code&gt;，并且根据方法名对public方法绑定相应的HTTP Method动词。&lt;br/&gt;比如，&lt;code&gt;GetTweets&lt;/code&gt;绑定为GET方法，&lt;code&gt;PutTweet&lt;/code&gt;绑定为PUT方法，其他名称的方法像&lt;code&gt;CreateTweet&lt;/code&gt;绑定为POST方法。&lt;br/&gt;（这里有一个例外，Get开头的方法如果参数是一个object——一个DTO的话，那这个方法会被绑定为POST方法。）&lt;br/&gt;生成的WebAPI接口的访问路径为&lt;code&gt;/api/services/MyTweet/{AppSvcName}/{ActionName}&lt;/code&gt;，其中&lt;code&gt;{AppSvcName}&lt;/code&gt;是&lt;code&gt;IApplicationService&lt;/code&gt;实现类的类名（去掉后缀&lt;code&gt;AppService&lt;/code&gt;），&lt;code&gt;{ActionName}&lt;/code&gt;是方法名。&lt;/p&gt;
&lt;p&gt;接下来我们实现&lt;code&gt;GetTweets&lt;/code&gt;和&lt;code&gt;CreateTweet&lt;/code&gt;两个接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902005448124-2077111399.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902005504030-520380252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在只是简单的让这两个接口随便返回一些结果。&lt;code&gt;GetTweets&lt;/code&gt;是接收一个字符串参数的GET接口，&lt;code&gt;CreateTweet&lt;/code&gt;是接收一个字符串&lt;code&gt;s&lt;/code&gt;、一个整数&lt;code&gt;s&lt;/code&gt;的POST接口（C#与JavaScript对大小写的编码规范不同是一件很烦人的事，幸好ABP框架做了自动转换）。这两个接口的路径分别为&lt;code&gt;/api/services/MyTweet/MyTweet/GetTweets&lt;/code&gt;和&lt;code&gt;/api/services/MyTweet/MyTweet/CreateTweet&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后测试一下，运行&lt;code&gt;MyTweet.Web&lt;/code&gt;项目，GET接口直接在浏览器就能访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902005519233-1697248145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;POST接口可以用&lt;a href=&quot;https://www.getpostman.com/&quot;&gt;Postman&lt;/a&gt;工具来访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902005602530-475336174.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你访问API的时候可能会出现&quot;Empty or invalid anti forgery header token&quot;的错误，这是因为某些ABP版本默认开启了CSRF防御。在&lt;code&gt;MyTweetWebModule&lt;/code&gt;的&lt;code&gt;PreInitialize&lt;/code&gt;方法加上下面这行代码关闭CSRF防御就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Configuration.Modules.AbpWeb().AntiForgery.IsEnabled = false;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;abp-module&quot;&gt;Abp Module&lt;/h2&gt;
&lt;p&gt;最后简要介绍下ABP的模块系统。更详细的讲解可查阅官网的文档&lt;a href=&quot;https://aspnetboilerplate.com/Pages/Documents/Module-System&quot; class=&quot;uri&quot;&gt;https://aspnetboilerplate.com/Pages/Documents/Module-System&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;模块主要用来管理系统初始化和关闭时要执行的操作。ABP在系统初始化和关闭时根据模块间依赖关系执行相应的操作。&lt;/p&gt;
&lt;p&gt;定义一个模块只需要继承&lt;code&gt;AbpModule&lt;/code&gt;。我们可以用&lt;code&gt;DependsOn&lt;/code&gt;标签来声明模块间的依赖关系（ABP框架会自动解析依赖关系，但建议使用显式的声明）。&lt;/p&gt;
&lt;p&gt;一个模块会有如下方法，我们可以重载这些方法来定义模块初始化/关闭时要做的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;PreInitialize&lt;/code&gt;&lt;/strong&gt;：预初始化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Initialize&lt;/code&gt;&lt;/strong&gt;：初始化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;PostInitialize&lt;/code&gt;&lt;/strong&gt;：后初始化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Shutdown&lt;/code&gt;&lt;/strong&gt;：关闭&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;应用启动时会根据模块的依赖顺序进行初始化。比如有模块A和模块B，模块A依赖模块B，那么初始化的执行顺序为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;B的&lt;code&gt;PreInitialize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A的&lt;code&gt;PreInitialize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;B的&lt;code&gt;Initialize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A的&lt;code&gt;Initialize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;B的&lt;code&gt;PostInitialize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;A的&lt;code&gt;PostInitialize&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关闭则按照依赖相反顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;A的&lt;code&gt;Shutdown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;B的&lt;code&gt;Shutdown&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后还有一个问题：应用启动时，ABP框架如何知道要初始化哪些模块？答案在入口函数方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/576869/201709/576869-20170902012657358-383625987.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ABP框架解析&lt;code&gt;MyTweetModule&lt;/code&gt;所依赖的模块，按顺序初始化这些模块（包括&lt;code&gt;MyTweetModule&lt;/code&gt;）。&lt;/p&gt;
</description>
<pubDate>Mon, 06 Nov 2017 01:36:00 +0000</pubDate>
<dc:creator>古霜卡比</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skabyy/p/7295533.html</dc:identifier>
</item>
<item>
<title>为什么要拒绝使用大事务进行处理任务？ - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/7782175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/7782175.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　前话： 不要迷恋事务，大事务会拖垮你的用户！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　相信很多应用都需要进行一些后台任务的处理，这时候应对的，往往是大批量的数据。比如：对数据进行汇总结算,需要全表扫描,更新; 对用户订单状态进行更新,需要全表扫描,进行更新; 对用户的会员有效期处理,也需要全表扫描,更新！&lt;br/&gt;　　应对这样的场景，就是定时任务JOB的职责范畴了。&lt;br/&gt;　　那么问题来了，这样的场景需要进行事务控制吗？ 我觉得这个得看业务需求，比如这个状态不是很重要，那么可以不用进行事务控制。但是更多时候，我们希望是有事务的，因为往往更新不会是单表的。&lt;br/&gt;　　在spring中，有一个简单的注解，即可以帮忙实现事务的控制。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@Transactional(readOnly = &lt;span&gt;false&lt;/span&gt;, rollbackFor = Throwable.&lt;span&gt;class&lt;/span&gt;, isolation = Isolation.REPEATABLE_READ)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　一个事务搞定！但是问题来了，这里报错了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;java.lang.Exception:
### Error updating database.  Cause: java.sql.SQLException: Lock wait timeout exceeded; try restarting transaction
### The error may involve defaultParameterMap
### The error occurred while setting parameters
### Cause: java.sql.SQLException: Lock wait timeout exceeded; try restarting transaction
; SQL []; Lock wait timeout exceeded; try restarting transaction; nested exception is java.sql.SQLException: Lock wait timeout exceeded; try restarting transaction&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      究其原因，就是mysql 锁等待超时。这里的等待超时有两种情况，&lt;/p&gt;
&lt;p&gt;          一是该定时任务后执行，是在等待别的客户端释放锁，而迟迟未得到从而超时。&lt;/p&gt;
&lt;p&gt;          二是其他客户端在操作时，由于被改定时任务长时间的占有锁，从而导致其等待超时。&lt;/p&gt;
&lt;p&gt;     当然，更多的可能是第二种。为什么呢？  因为定时任务往往需要处理大量的数据，这时，如果使用了一个最外围的事务，那么相当于整个脚本都是运行在该事务中，只要该脚本还未运行完成，那么事务就不会提交，也就不会释放他占有的锁资源。所以，问题就在这里了。所以，我们得避免进行大事务的形成就很有必要了。&lt;/p&gt;
&lt;p&gt;　　事实上，事务的目的是为了保证数据的原子性，准确性，那么也就是说，只要你需要保证的数据做到了，就可以进行。所以，可以将大事务拆小，即保证最小事务的执行即可。如：更新一个用户的会员状态，那么只需要查出相关信息，更改状态，写入相应记录，该事务即可提交。&lt;/p&gt;
&lt;p&gt;　　将大事务拆小后，就可以做到快速释放锁的作用，从而避免了其他客户端的锁等待超时问题了。&lt;/p&gt;

&lt;p&gt;样例： 更新用户的账单状态，步骤为： 查询出所有需要更新的账单数量 &amp;gt;&amp;gt; 定稿job执行开始记录 &amp;gt;&amp;gt; 更新每个订单状态 &amp;gt;&amp;gt; 写入job执行结束标识 &amp;gt;&amp;gt; 完成！&lt;/p&gt;
&lt;p&gt;　　该过程，主要耗时是在对每个用户的账单更新，因此，可以将该处作为事务拆小的依据，具体代码如下：&lt;/p&gt;
&lt;p&gt;　　主事务进行总体控制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用新线程进行具体执行功能，需另起事务控制或接收原有事务&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer updateBorrowStatus(JobParamBean jobParamBean) {
        String method &lt;/span&gt;= &quot;updateBorrowStatus&quot;&lt;span&gt;;
        logger.info(&lt;/span&gt;&quot;enter {} method, jobParamBean:{}&quot;&lt;span&gt;, method, jobParamBean);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新数据库&lt;/span&gt;
        Integer result = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; cond = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;borrowApplyTimeStart, borrowApplyTimeEnd, borrowStatusList, pageStart, perPageNum
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        cond.put(&quot;borrowApplyTimeStart&quot;, jobParamBean.getStartTime());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        cond.put(&quot;borrowApplyTimeEnd&quot;, jobParamBean.getEndTime());&lt;/span&gt;
        cond.put(&quot;shouldRepayTimeStart&quot;&lt;span&gt;, jobParamBean.getStartTime());
        cond.put(&lt;/span&gt;&quot;shouldRepayTimeEnd&quot;&lt;span&gt;, jobParamBean.getEndTime());

        List&lt;/span&gt;&amp;lt;String&amp;gt; borrowStatusList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        borrowStatusList.add(&lt;/span&gt;&quot;3&quot;&lt;span&gt;);
        cond.put(&lt;/span&gt;&quot;borrowStatusList&quot;&lt;span&gt;, borrowStatusList);

        Integer totalUpdate &lt;/span&gt;=&lt;span&gt; borrowMapper.countUsersBorrowListByMap(cond);
        String dubboConsumerIp &lt;/span&gt;=&lt;span&gt; jobParamBean.getDubboConsumerIp();
        String myServerIp &lt;/span&gt;= &quot;127.0.0.1&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            myServerIp &lt;/span&gt;=&lt;span&gt; InetAddress.getLocalHost().getHostAddress();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnknownHostException e) {
            logger.error(&lt;/span&gt;&quot;get local server ip error:{}&quot;&lt;span&gt;, e);
        }

        Date now &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        JobExecRecordEntity recordEntity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobExecRecordEntity();
        BeanUtils.copyProperties(jobParamBean, recordEntity);
        recordEntity.setJobName(&lt;/span&gt;&quot;autoUpdateBorrowStatus&quot;&lt;span&gt;);
        recordEntity.setExecDateStart(jobParamBean.getEndTime());           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结束时间为最近时间&lt;/span&gt;
&lt;span&gt;        recordEntity.setExecDateEnd(jobParamBean.getStartTime());
        recordEntity.setTotalAffectNum(totalUpdate);
        recordEntity.setReqParams(JSONObject.toJSONString(jobParamBean));
        recordEntity.setJobParams(JSONObject.toJSONString(cond));
        recordEntity.setExecServerIp(myServerIp);
        recordEntity.setReqServerIp(dubboConsumerIp);
        recordEntity.setJobEndTime(DateUtils.convert(now, &lt;/span&gt;&quot;yyyy-MM-dd HH:mm:ss.S&quot;&lt;span&gt;));
        Integer recordAffectNum &lt;/span&gt;=&lt;span&gt; jobExecRecordMapper.addJobExecRecord(recordEntity);
        Long recordId &lt;/span&gt;=&lt;span&gt; recordEntity.getId();

        Integer realUpdateNum &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(totalUpdate != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; totalUpdate &amp;gt; 0&lt;span&gt;) {
            Integer pageStart &lt;/span&gt;= 0&lt;span&gt;;
            Integer perPageNum &lt;/span&gt;= 10&lt;span&gt;;
            String nowDateStr &lt;/span&gt;= DateUtils.convert(now, &quot;yyyy-MM-dd&quot;);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前时间&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; totalUpdate; i +=&lt;span&gt; perPageNum) {
                pageStart &lt;/span&gt;=&lt;span&gt; i;
                cond.put(&lt;/span&gt;&quot;pageStart&quot;&lt;span&gt;, pageStart);
                cond.put(&lt;/span&gt;&quot;perPageNum&quot;&lt;span&gt;, perPageNum);
                Integer thisAffectNum &lt;/span&gt;= platformAssistantBusiness.pieceUpdateBorrowStatus(cond, nowDateStr);　　    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用辅助类进行小事务的拆分&lt;/span&gt;
                realUpdateNum +=&lt;span&gt; thisAffectNum;
                recordEntity.setCurrentAffectNum(perPageNum);
                recordEntity.setRealAffectNum(thisAffectNum);
                recordEntity.setStatus(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
                jobExecRecordMapper.updateJobExecRecord(recordEntity);
            }
        }
        recordEntity.setStatus(&lt;/span&gt;&quot;5&quot;&lt;span&gt;);
        recordEntity.setCurrentAffectNum(&lt;/span&gt;0&lt;span&gt;);
        recordEntity.setRealAffectNum(&lt;/span&gt;0&lt;span&gt;);
        String jobEndTime &lt;/span&gt;= DateUtils.convert(&lt;span&gt;new&lt;/span&gt; Date(), &quot;yyyy-MM-dd HH:mm:ss.S&quot;&lt;span&gt;);
        recordEntity.setJobEndTime(jobEndTime);
        jobExecRecordMapper.updateJobExecRecord(recordEntity);

        result &lt;/span&gt;=&lt;span&gt; totalUpdate;
        logger.info(&lt;/span&gt;&quot;exit {} method, result:{}&quot;&lt;span&gt;, method, result);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　小事务放在另一方法中，以确保事务生效！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    @Transactional(readOnly &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;, rollbackFor = Throwable.&lt;span&gt;class&lt;/span&gt;, isolation = Isolation.REPEATABLE_READ, propagation =&lt;span&gt; Propagation.REQUIRES_NEW)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer pieceUpdateBorrowStatus(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; cond, String nowDateStr) {
        String shouldRepayDate &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        Long lateDays &lt;/span&gt;= 0L&lt;span&gt;;
        String borrowStatus;
        Integer thisAffectNum &lt;/span&gt;= 0&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;UsersBorrowEntity&amp;gt; pageList1 =&lt;span&gt; borrowMapper.getUsersBorrowListByMap(cond);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(UsersBorrowEntity borrowEntity1 : pageList1) {
            UsersBorrowEntity updateBorrowEntity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UsersBorrowEntity();
            updateBorrowEntity.setId(borrowEntity1.getId());
            updateBorrowEntity.setUserId(borrowEntity1.getUserId());
            shouldRepayDate &lt;/span&gt;=&lt;span&gt; borrowEntity1.getShouldRepayTime();
            lateDays &lt;/span&gt;=&lt;span&gt; DateUtils.getDayDiff(shouldRepayDate, nowDateStr);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lateDays != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; lateDays &amp;gt;= 0 &amp;amp;&amp;amp; !&quot;8&quot;&lt;span&gt;.equals(borrowEntity1.getBorrowStatus())) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lateDays == 0&lt;span&gt;) {
                    borrowStatus &lt;/span&gt;= &quot;5&quot;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    borrowStatus &lt;/span&gt;= &quot;6&quot;&lt;span&gt;;
                }
                updateBorrowEntity.setBorrowStatus(borrowStatus);
                updateBorrowEntity.setRepayStatus(CommonUtil.getRepayStatusByBorrowStatus(borrowStatus));
                updateBorrowEntity.setLateDays(lateDays.intValue());
                Integer affectNum &lt;/span&gt;=&lt;span&gt; usersBorrowMapper.updateUsersBorrow(updateBorrowEntity);
                thisAffectNum &lt;/span&gt;+=&lt;span&gt; affectNum;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; thisAffectNum;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就保证了，执行的完整性，然后，每10个小事务就进行提交一次。从而解决锁超时问题了。&lt;/p&gt;

</description>
<pubDate>Mon, 06 Nov 2017 01:28:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/7782175.html</dc:identifier>
</item>
<item>
<title>学习一门新语言需要了解的基础-16 递归调用 - 李永京</title>
<link>http://www.cnblogs.com/lyj/p/foundation_16_recursion.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyj/p/foundation_16_recursion.html</guid>
<description>&lt;p&gt;本节内容&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是递归&lt;/li&gt;
&lt;li&gt;Go与C栈大小差异&lt;/li&gt;
&lt;li&gt;为什么会引起堆栈溢出(stack overflow)&lt;/li&gt;
&lt;li&gt;什么是尾调用&lt;/li&gt;
&lt;li&gt;什么是尾递归优化[付费阅读]&lt;/li&gt;
&lt;li&gt;为什么go的编译器对尾递归调用不做优化处理[付费阅读]&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是递归&quot;&gt;什么是递归&lt;/h2&gt;
&lt;p&gt;比如我们调用函数的时候，比如main函数调用add时候，需要为add分配内存，我们管这个这个叫Frame，如果add函数自己调用自己什么状态，我们管自己调用自己叫做递归，它调用的时候它会分配新的栈桢么？就是说自己调用自己的时候栈帧的状态是什么样子的？&lt;/p&gt;
&lt;p&gt;所谓的自己调用自己是什么，只不过执行了相同的代码，但是它依然会分配新的栈帧，一直往上面分配，只不过栈帧的内存状态未必是一样的，数据可能会不一样。什么是一样的？.text中使用的代码一样的而已。如果这个递归函数不小心写错了没有中止，那么会一直往上分配，直到整个栈的空间耗光，耗光的时候会引发一种叫堆栈溢出。&lt;/p&gt;
&lt;h2 id=&quot;go与c栈大小差异&quot;&gt;Go与C栈大小差异&lt;/h2&gt;
&lt;p&gt;每种语言甚至是每种操作系统甚至不同平台栈空间大小未必是一样的，有些可能是1MB，有些可能是10MB，go语言是1GB，另外还有些语言对它是有限制的，它不是限制栈内存耗光了，而是调用递归深度如果超出多少就会认为你是溢出了。比如python语言限制1000次。&lt;/p&gt;
&lt;h2 id=&quot;为什么会引起堆栈溢出stack-overflow&quot;&gt;为什么会引起堆栈溢出(stack overflow)&lt;/h2&gt;
&lt;p&gt;堆栈溢出多处情况下发生在递归调用，因为递归调用写的算法有问题，可能没有明确的终止，这时候可能会形成溢出。&lt;/p&gt;
&lt;p&gt;堆栈溢出有这样一个问题，我们写个算法，需要使用递归，我们遍历一个非常大的xml文件，比如我们以深度优先模式扫描，肯定使用递归调用不停的一级一级的扫描，扫描完一点一点的返回，当我不知道深度有多大的时候我们怎么样避免堆栈溢出呢？&lt;/p&gt;
&lt;p&gt;比如一个树，深度控制在三层，那么你可能广度很多，深度优先之后接下来广度，这样做法堆栈依然会爆掉，你的计数器不好控制，比如计数器超过1000次就终止，那么有可能每个栈桢浪费了1MB空间，如果10MB的话执行10次就爆掉了，这样计数器没有什么用，你控制函数调用次数你怎么控制每个栈桢有多大。&lt;/p&gt;
&lt;p&gt;很显然，这里存在一个问题是写递归的时候要非常的小心，因为不小心的情况下我们有可能会出错，而且这种出错很难恢复。比如你调试的时候拿10MB、100MB做测试，但是线上运行时可能时间长了以后数据会变得非常大，几GB、TB的都有可能，你的递归算法可能线上就会出错。所以递归算法的编写其实要非常的小心，那么通常情况下有几种方式，第一种比如go语言栈桢空间足够大，还有一种方式你得自己去优化递归算法。&lt;/p&gt;
&lt;p&gt;我们调用一个函数，比如main函数调用add函数，当调用的时候分配栈桢空间，当调用add结束的时候，处理后就回来，回来之后这个内存就会重复使用，给下次函数调用时候使用。那我们想象下，假如说这儿有个扫描的递归函数scan，这个函数要进行递归调用，正常情况下是分配新的栈桢，再往上一种分配新的栈桢，执行完了之后一级一级再回来直到结束这样的一个过程。那么我们想象有没有这样的可能，假如说main函数调用scan，这个scan函数去调用递归的时候，比如说往上递归的时候，如果我们把返回过程去掉的话，如果不返回的话，那么这个栈桢没必要保留了，为什么？因为保存现场IP在main栈桢空间不属于scan栈桢空间。假如我们调用新的scan的时候不需要返回，那么第一个栈桢空间是不是不需要保留，他可以直接回到IP进行恢复，那么也就意味着我每次进行递归调用的时候都重复使用同一段栈桢空间，不管递归多少次都是重复使用同一段栈桢空间，因为你调用的是同一个函数，他的栈桢空间大小是一样的，因为我们知道栈桢空间是在编译期已经确定好的，编译的时候就知道这个栈桢到底有多大，如果每次调用都不返回，那么我们考虑一点这个栈桢空间不需要保留，那么每次递归调用都使用同一段内存的时候，那么不管递归多少次，栈也爆不掉。所以我们想一想怎么样重复使用这段内存，我们说过一个函数调用另外一个函数为什么会返回，我们简单的写一个例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void test(){
   test()
   print(&quot;xxx&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;test函数调用自己，再调用一个print，这种在函数调用的时候每次都需要返回，是因为我们接下来需要调用print，test调用完比如回来才能调用print。那么它的调用过程其实是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test
   |
   test ------+
   |          test
   print&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;什么是尾调用&quot;&gt;什么是尾调用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;void test(){
   x = 1234
   test()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这样，也就意味着test是最后一行，它执行test的时候，不管前面有什么逻辑，执行到test时候，理论上前面的内容都已经失效了，因为后面没有代码引用前面的上下文了，前面所有上下文都不要的情况下，而test是最后一行，那么当前栈桢的所有状态就可以抛弃掉。&lt;/p&gt;
&lt;p&gt;这就是之前说的重复使用一段内存，内存里面就是存的两部分数据，一部分是局部变量，还有一部分是调用其它函数的参数，那么如果是最后一行，局部变量空间显然是不需要了，调用参数参数传递完之后这段空间也可以不要了。所以上下两部分空间都不要的情况下，那么有必要为新的调用分配新的栈桢呢，当然可以重复使用一段栈桢。&lt;/p&gt;
&lt;p&gt;我们管这种调用方式称之为尾调用。当你的函数最后一行是一个函数调用，而且不需要处理返回值的时候，我们管这种调用称之为尾调用。尾调用的时候，编译器可能会对它进行优化，第一种方式重复使用同一个栈桢，这种方式可以避免大量分配新的栈桢，第二种方式可以把整个函数调用优化为一个循环，因为函数调用每一次用的栈的状态是一样的，那么用一个循环把函数块演变成代码块，这样也可以在同一个栈桢内使用，一个循环重复利用的是一个栈桢的本地局部变量区域。所以编译器对于尾调用一般情况下都会尝试进行优化，优化完之后用来避免递归调用。前提是你得自己去写尾调用，并不是所有编译器都能识别这种方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int test(){
   x = 1234
   test() + 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如说&lt;code&gt;test() + 1&lt;/code&gt;这样的操作，这个算不算尾调用？这个返回值出来还需要+1操作，这个是在当前栈桢空间中操作的，那么test状态必须要保留，这种情况不能称之为尾调用。尾调用是什么，你调用一个函数不需要任何返回值的处理，后面也没有新的代码，因为我们知道&lt;code&gt;test() + 1&lt;/code&gt;可以拆分成两块&lt;code&gt;call test();ret+1;&lt;/code&gt;实际上是由两条指令构成的。&lt;/p&gt;
&lt;p&gt;最后一步是函数调用，意味着无需返回当前函数，那么当前堆栈帧就可以放弃。&lt;code&gt;f(x)+1&lt;/code&gt;不是尾调用。&lt;/p&gt;
&lt;h2 id=&quot;什么是尾递归优化付费阅读&quot;&gt;什么是尾递归优化[付费阅读]&lt;/h2&gt;
&lt;h2 id=&quot;为什么go的编译器对尾递归调用不做优化处理付费阅读&quot;&gt;为什么go的编译器对尾递归调用不做优化处理[付费阅读]&lt;/h2&gt;
</description>
<pubDate>Mon, 06 Nov 2017 01:25:00 +0000</pubDate>
<dc:creator>李永京</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyj/p/foundation_16_recursion.html</dc:identifier>
</item>
</channel>
</rss>