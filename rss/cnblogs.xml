<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MyBatis 与 Spring 整合 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/8879513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/8879513.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f534c3282f1f6192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mybatisspring-项目&quot;&gt;MyBatis—Spring 项目&lt;/h2&gt;
&lt;p&gt;目前大部分的 Java 互联网项目，都是用 Spring MVC + Spring + MyBatis 搭建平台的。&lt;/p&gt;
&lt;p&gt;使用 &lt;a href=&quot;https://www.jianshu.com/p/20cea9170110&quot;&gt;Spring IoC&lt;/a&gt; 可以有效的管理各类的 Java 资源，达到即插即拔的功能；通过 &lt;a href=&quot;https://www.jianshu.com/p/994027425b44&quot;&gt;Spring AOP&lt;/a&gt; 框架，数据库事务可以委托给 Spring 管理，消除很大一部分的事务代码，配合 MyBatis 的高灵活、可配置、可优化 SQL 等特性，完全可以构建高性能的大型网站。&lt;/p&gt;
&lt;p&gt;毫无疑问，MyBatis 和 Spring 两大框架已经成了 Java 互联网技术主流框架组合，它们经受住了大数据量和大批量请求的考验，在互联网系统中得到了广泛的应用。使用 MyBatis-Spring 使得业务层和模型层得到了更好的分离，与此同时，在 Spring 环境中使用 MyBatis 也更加简单，节省了不少代码，甚至可以不用 SqlSessionFactory、 SqlSession 等对象，因为 MyBatis-Spring 为我们封装了它们。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;摘自：《Java EE 互联网轻量级框架整合开发》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第一步创建测试工程&quot;&gt;第一步：创建测试工程&lt;/h4&gt;
&lt;p&gt;第一步，首先在 IDEA 中新建一个名为【MybatisAndSpring】的 WebProject 工程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7c8242b9afa48492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在【src】中创建 4 个空包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cn.wmyskxz.dao（放置 DAO 数据交互层处理类）&lt;/li&gt;
&lt;li&gt;cn.wmyskxz.mapper（放置 Mapper 代理接口）&lt;/li&gt;
&lt;li&gt;cn.wmyskxz.pojo（放置 Java 实体类）&lt;/li&gt;
&lt;li&gt;cn.wmyskxz.test（放置测试类）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着新建源文件夹【config】，用于放置各种资源配置文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在【config / mybatis】下创建一个空的名为 “SqlMapConfig.xml” 的 MyBatis 全局配置文件&lt;/li&gt;
&lt;li&gt;在【config / spring】下创建一个空的名为 “applicationContext.xml” 的 Spring 资源配置文件&lt;/li&gt;
&lt;li&gt;在【config / sqlmap】下创建一个空的名为 “UserMapper.xml” 的 Mapper 映射文件。&lt;/li&gt;
&lt;li&gt;在【config】下创建两个 properties 属性文件，分别为 “db.properties” 和 “log4j.properties”，用于数据库连接和日志系统参数设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再在【web】文件夹下新建一个【WEB-INF】默认安全文件夹，并在其下创建一个【classes】和【lib】，并将项目的输出位置，改在【classes】下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f33c52b56b56ad91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;工程的完整初始结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-2ea182a1f1e9bd9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二步引入依赖-jar-包&quot;&gt;第二步：引入依赖 jar 包&lt;/h4&gt;
&lt;p&gt;第二步，就是要准备项目的依赖 jar 包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-9b60a2c6d0cde57d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在【WEB-INF】文件夹下的【lib】文件夹中放置上面列举的 jar 包，然后添加依赖。&lt;/p&gt;
&lt;h4 id=&quot;第三步编写-spring-配置文件&quot;&gt;第三步：编写 Spring 配置文件&lt;/h4&gt;
&lt;p&gt;第三步，编写 Spring 的配置文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载数据库连接文件 “db.properties” 中的数据，建立数据源&lt;/li&gt;
&lt;li&gt;配置 sqlSessionFactory 会话工厂对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;!-- 加载配置文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&amp;gt;

    &amp;lt;!-- 配置数据源 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- sqlSessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!-- 加载 MyBatis 的配置文件 --&amp;gt;
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;mybatis/SqlMapConfig.xml&quot;/&amp;gt;
        &amp;lt;!-- 数据源 --&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;头部的信息就是声明 xml 文档配置标签的规则的限制与规范。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“context:property-placeholder”&lt;/strong&gt; 配置是&lt;strong&gt;用于读取工程中的静态属性文件&lt;/strong&gt;，然后在其他配置中使用时，就&lt;strong&gt;可以采用 “${属性名}” 的方式获取该属性文件中的配置参数值。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;配置了一个名为 &lt;strong&gt;“dataSrouce”&lt;/strong&gt; 的 bean 的信息，实际上是&lt;strong&gt;连接数据库的数据源。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;设置 &lt;strong&gt;sqlSessionFactory&lt;/strong&gt; 的 bean 实现类为 MyBatis 与 Spring 整合 jar 包中的 &lt;strong&gt;SqlSessionFactoryBean&lt;/strong&gt; 类，&lt;strong&gt;在其中只需要注入两个参数：一个是 MyBatis 的全局配置文件，一个是上面配置的数据源 bean&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第四步编写-mybatis-配置文件&quot;&gt;第四步：编写 MyBatis 配置文件&lt;/h4&gt;
&lt;p&gt;第四步，在【mybatis】包下编写 MyBatis 的全局配置文件 SqlMapConfig.xml ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;!-- settings --&amp;gt;
    &amp;lt;settings&amp;gt;
        &amp;lt;!-- 打开延迟加载的开关 --&amp;gt;
        &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;!-- 将积极加载改为消极加载（即按需加载） --&amp;gt;
        &amp;lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;!-- 打开全局缓存开关（二级缓存）默认值就是 true --&amp;gt;
        &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

    &amp;lt;!-- 别名定义 --&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&quot;cn.wmyskxz.pojo&quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;!-- 加载映射文件 --&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;!-- 通过 resource 方法一次加载一个映射文件 --&amp;gt;
        &amp;lt;mapper resource=&quot;sqlmap/UserMapper.xml&quot;/&amp;gt;
        &amp;lt;!-- 批量加载mapper --&amp;gt;
        &amp;lt;package name=&quot;cn.wmyskxz.mapper&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该配置文件中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 &lt;strong&gt;settings 配置了一些延迟加载和缓存的开关信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;typeAliases 中设置了一个 package 的别名扫描路径&lt;/strong&gt;，在该路径下的 Java 实体类都可以拥&lt;strong&gt;有一个别名（即首字母小写的类名）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 mappers 配置中，使用 mapper 标签配置了即将要加载的 Mapper 映射文件的资源路径，当然也可以使用 package 标签，配置 mapper 代理接口所在的包名，以批量加载 mapper 代理对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 有了 Spring 托管数据源，在 MyBatis 配置文件中仅仅需要关注性能化配置。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第五步编写-mapper-以及其他配置文件&quot;&gt;第五步：编写 Mapper 以及其他配置文件&lt;/h4&gt;
&lt;p&gt;第五步，编写 Mapper 映射文件，这里依然定义 Mapper 映射文件的名字为 “UserMapper.xml” （与 SqlMapConfig.xml 中配置一致），为了测试效果，只配置了一个查询类 SQL 映射：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;test&quot;&amp;gt;
    &amp;lt;select id=&quot;findUserById&quot; parameterType=&quot;_int&quot; resultType=&quot;user&quot;&amp;gt;
    SELECT * FROM USER WHERE id = #{id}
&amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该配置中，输出参数的映射为 “user” ，这是因为之前在 SqlMapConfig.xml 中配置了 “cn.wmyskxz.pojo” 包下的实体类使用别名（即首字母小写的类名），所以这里只需在 “cn.wmyskxz.pojo” 包下，创建 “finduserById” 对应的 Java 实体类 User：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.pojo;

import java.io.Serializable;

public class User implements Serializable {
    private int id;
    private String username;

    /* getter and setter */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;实现 Serializable 接口是为之后使用 Mapper 动态代理做准备，这里没有使用动态代理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在数据库资源 “db.properties” 中配置了数据库的连接信息，以 “key=value” 的形式配置，String 正是使用 “${}” 获取其中 key 对应的 value 配置的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8
jdbc.username=root
jdbc.password=root&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外日志配置和&lt;a href=&quot;https://www.jianshu.com/p/76d35d939539&quot;&gt;之前的配置&lt;/a&gt;一样，我就直接黏贴了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Global logging configuration
# 在开发环境下日志级别要设置成 DEBUG ，生产环境设为 INFO 或 ERROR
log4j.rootLogger=DEBUG, stdout
# Console output...
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第六步编写-dao-层&quot;&gt;第六步：编写 DAO 层&lt;/h4&gt;
&lt;p&gt;第六步，进行数据库交互（Data Access Object）层的编写。&lt;/p&gt;
&lt;p&gt;由于该项目只对 User 用户查询，所以 DAO 层就只有一个类，在 “cn.wmyskxz” 包下创建 DAO 层的 interface 接口，其中定义了 findUserById 方法，参数为用户的 id 值（int 类型）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.dao;

import cn.wmyskxz.pojo.User;

public interface UserDAO {

    // 根据 id 查询用户信息
    public User findUserById(int id) throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在同一个包下创建 UserDAO 接口的实现类 UserDAOImpl:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.dao;

import cn.wmyskxz.pojo.User;
import org.apache.ibatis.session.SqlSession;
import org.mybatis.spring.support.SqlSessionDaoSupport;

public class UserDAOImpl extends SqlSessionDaoSupport implements UserDAO {

    @Override
    public User findUserById(int id) throws Exception {
        // 继承 SqlSessionDaoSupport 类，通过 this.getSqlSession() 得到 sqlSession
        SqlSession sqlSession = this.getSqlSession();
        User user = sqlSession.selectOne(&quot;test.findUserById&quot;, id);
        return user;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有几点解释：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UserDAOImpl 不仅实现了 UserDAO 接口，而且继承了 SqlSessionDaoSupport 类。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SqlSessionDaoSupport 类是 MyBatis 与 Spring 整合的 jar 包中提供的，&lt;strong&gt;在该类中已经包含了 sqlSessionFactory 对象作为其成员变量&lt;/strong&gt;，而且对外提供 get 和 set 方法，方便 Spring 从外部注入 sqlSessionFactory 对象。&lt;/li&gt;
&lt;li&gt;UserDAOImpl 类要成功获取 sqlSessionFactory 对象，还&lt;strong&gt;需要在 Spring 配置文件 applicationContext.xml 中添加 userDAO 的 bean 配置，将其中定义的 sqlSessionFactory 对象当做参数注入进去&lt;/strong&gt;，这样 UserDAOImpl 继承 SqlSessionDaoSupport 类才会起到作用：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 原始 DAO 接口 --&amp;gt;
&amp;lt;bean id=&quot;userDAO&quot; class=&quot;cn.wmyskxz.dao.UserDAOImpl&quot;&amp;gt;
    &amp;lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; DAO 实现类继承了 SqlSessionDaoSupport 父类后，就无须自己定义获取 SqlSession 会话实例类方法了，该父类会默认加载数据源信息并提供获取 SqlSession 类的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第七步编写-service-测试类&quot;&gt;第七步：编写 Service 测试类&lt;/h4&gt;
&lt;p&gt;在 “cn.wmyskxz.test” 包下创建【UserServiceTest】测试类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.test;

import cn.wmyskxz.dao.UserDAO;
import cn.wmyskxz.pojo.User;
import org.junit.Before;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserServiceTest {

    private ApplicationContext applicationContext;

    // 在执行测试方法之前首先获取 Spring 配置文件对象
    // 注解@Before在执行本类所有测试方法之前先调用这个方法
    @Before
    public void setup() throws Exception {
        applicationContext = new
                ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);
    }

    @Test
    public void testFindUserById() throws Exception {
        // 通过配置资源对象获取 userDAO 对象
        UserDAO userDAO = (UserDAO) applicationContext.getBean(&quot;userDAO&quot;);
        // 调用 UserDAO 的方法
        User user = userDAO.findUserById(1);
        // 输出用户信息
        System.out.println(user.getId() + &quot;:&quot; + user.getUsername());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试方法，输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-3aa5986831a67175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;动态代理-注解实现&quot;&gt;动态代理 + 注解实现&lt;/h2&gt;
&lt;p&gt;上面的实例程序并没有使用 Mapper 动态代理和注解来完成，下面我们就来试试如何用动态代理和注解：&lt;/p&gt;
&lt;h4 id=&quot;第一步编写-userquerymapper&quot;&gt;第一步：编写 UserQueryMapper&lt;/h4&gt;
&lt;p&gt;在【mapper】下新建一个【UserQueryMapper】代理接口，并使用注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.mapper;

import cn.wmyskxz.pojo.User;
import org.apache.ibatis.annotations.Select;

public interface UserQueryMapper {

    @Select(&quot;SELECT * FROM USER WHERE id = #{id}&quot;)
    public User findUserById(int id) throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在默认情况下，该 bean 的名字为 userQueryMapper（即首字母小写）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在有了代理类，我们需要通知 Spring 在这里来扫描到该类，Mapper 扫描配置对象需要用专门的扫描器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- Mapper 扫描器 --&amp;gt;
&amp;lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&amp;gt;
    &amp;lt;!-- 扫描 cn.wmyskxz.mapper 包下的组件 --&amp;gt;
    &amp;lt;property name=&quot;basePackage&quot; value=&quot;cn.wmyskxz.mapper&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步编写测试类&quot;&gt;第二步：编写测试类&lt;/h4&gt;
&lt;p&gt;这一次我们获取的不再是 userDAO 对象，而是定义的 Mapper 代理对象 userQueryMapper：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.wmyskxz.test;

import cn.wmyskxz.mapper.UserQueryMapper;
import cn.wmyskxz.pojo.User;
import org.junit.Before;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class UserServiceTest {

    private ApplicationContext applicationContext;

    // 在执行测试方法之前首先获取 Spring 配置文件对象
    // 注解@Before在执行本类所有测试方法之前先调用这个方法
    @Before
    public void setup() throws Exception {
        applicationContext = new
                ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext.xml&quot;);
    }

    @Test
    public void testFindUserById() throws Exception {
        // 通过配置资源对象获取 userDAO 对象
        UserQueryMapper userQueryMapper = (UserQueryMapper) applicationContext.getBean(&quot;userQueryMapper&quot;);
        // 调用 UserDAO 的方法
        User user = userQueryMapper.findUserById(1);
        // 输出用户信息
        System.out.println(user.getId() + &quot;:&quot; + user.getUsername());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试方法，得到正确结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-8543b70d3880b5ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，查询结果和之前非 Mapper 代理的查询结果一样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原理：&lt;/strong&gt; 在 applicationContext.xml 配置文件中配置的 &lt;strong&gt;mapper 批量扫描器类，会从 mapper 包中扫描出 Mapper 接口，自动创建代理对象并且在 Spring 容器中注入。&lt;/strong&gt;自动扫描出来的 Mapper 的 bean 的 id 为 mapper 类名（首字母小写），所以这里获取的就是名为 “userQueryMapper” 的 mapper 代理对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;《Java EE 互联网轻量级框架整合开发》&lt;/li&gt;
&lt;li&gt;《Spring MVC + MyBatis开发从入门到项目实战》&lt;/li&gt;
&lt;li&gt;全能的百度和万能的大脑&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.3290322580645&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq939419061&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq939419061&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 18 Apr 2018 23:23:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/8879513.html</dc:identifier>
</item>
<item>
<title>Django REST framework+Vue 打造生鲜超市（十二） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8877643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8877643.html</guid>
<description>&lt;h2&gt;十三、首页、商品数量、缓存和限速功能开发&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 13.1.轮播图接口实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;首先把pycharm环境改成本地的，vue中local_host也改成本地 &lt;/p&gt;
&lt;p&gt;（1）goods/serializer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BannerSerializer(serializers.ModelSerializer):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    轮播图
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; Banner
        fields &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）goods/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BannerViewset(mixins.ListModelMixin, viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    首页轮播图
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    queryset &lt;/span&gt;= Banner.objects.all().order_by(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    serializer_class &lt;/span&gt;= BannerSerializer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）url&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置首页轮播图的url&lt;/span&gt;
router.register(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;banners&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, BannerViewset, base_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;banners&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在后台添加首页轮播图图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180418210745189-243022221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 13.2.新品接口功能开发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在设计Goods model时候有一个字段is_new&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
is_new = models.BooleanField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是否新品&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,default=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现这个接口只要在goods/filters/GoodsFilter里面添加一个过滤就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; Goods
        fields &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pricemin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pricemax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_hot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_new&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在后台设置几个商品 is_new&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180418211802639-1075829152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13.3.首页商品分类显示功能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 首先是大类，然后里面有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;商品商标（多个）&lt;/li&gt;
&lt;li&gt;大类下的二级类&lt;/li&gt;
&lt;li&gt;广告商品&lt;/li&gt;
&lt;li&gt;所有商品&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180418233401234-2043371099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（1）goods/serializers.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BrandSerializer(serializers.ModelSerializer):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    大类下面的宣传商标
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; GoodsCategoryBrand
        fields &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexCategorySerializer(serializers.ModelSerializer):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;某个大类的商标，可以有多个商标，一对多的关系&lt;/span&gt;
    brands = BrandSerializer(many=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; good有一个外键category，但这个外键指向的是三级类，直接反向通过外键category（三级类），取某个大类下面的商品是取不出来的&lt;/span&gt;
    goods =&lt;span&gt; serializers.SerializerMethodField()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在parent_category字段中定义的related_name=&quot;sub_cat&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取二级商品分类&lt;/span&gt;
    sub_cat = CategorySerializer2(many=&lt;span&gt;True)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 广告商品&lt;/span&gt;
    ad_goods =&lt;span&gt; serializers.SerializerMethodField()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_ad_goods(self, obj):
        goods_json &lt;/span&gt;=&lt;span&gt; {}
        ad_goods &lt;/span&gt;= IndexAd.objects.filter(category_id=&lt;span&gt;obj.id, )
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ad_goods:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取到这个商品Queryset[0]&lt;/span&gt;
            good_ins =&lt;span&gt; ad_goods[0].goods
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在serializer里面调用serializer的话，就要添加一个参数context（上下文request）,嵌套serializer必须加&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; serializer返回的时候一定要加 “.data” ，这样才是json数据&lt;/span&gt;
            goods_json = GoodsSerializer(good_ins, many=False, context={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: self.context[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]}).data
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; goods_json

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;自定义获取方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_goods(self, obj):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将这个商品相关父类子类等都可以进行匹配&lt;/span&gt;
        all_goods = Goods.objects.filter(Q(category_id=obj.id) | Q(category__parent_category_id=obj.id) |&lt;span&gt; Q(
            category__parent_category__parent_category_id&lt;/span&gt;=&lt;span&gt;obj.id))
        goods_serializer &lt;/span&gt;= GoodsSerializer(all_goods, many=True, context={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: self.context[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]})
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; goods_serializer.data

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; GoodsCategory
        fields &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）goods/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexCategoryViewset(mixins.ListModelMixin, viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    首页商品分类数据
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取is_tab=True（导航栏）里面的分类下的商品数据&lt;/span&gt;
    queryset = GoodsCategory.objects.filter(is_tab=True, name__in=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生鲜食品&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;酒水饮料&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
    serializer_class &lt;/span&gt;= IndexCategorySerializer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）url&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首页系列商品展示url&lt;/span&gt;
router.register(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;indexgoods&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, IndexCategoryViewset, base_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;indexgoods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13.4.商品点击数和收藏数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;strong&gt;&lt;span&gt;（1）点击数&lt;/span&gt;&lt;/strong&gt;&lt;p&gt;GoodsListViewSet其中继承了mixins.RetrieveModelMixin（获取商品详情）
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RetrieveModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Retrieve a model instance.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; retrieve(self, request, *args, **&lt;span&gt;kwargs):
        instance &lt;/span&gt;=&lt;span&gt; self.get_object()
        serializer &lt;/span&gt;=&lt;span&gt; self.get_serializer(instance)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们只要重写他的retrieve方法就可以了&lt;/p&gt;
&lt;p&gt;goods/views&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　#&lt;/span&gt;&lt;span&gt;商品点击数 + 1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; retrieve(self, request, *args, **&lt;span&gt;kwargs):
        instance &lt;/span&gt;=&lt;span&gt; self.get_object()
        instance.click_num &lt;/span&gt;+= 1&lt;span&gt;
        instance.save()
        serializer &lt;/span&gt;=&lt;span&gt; self.get_serializer(instance)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5f6f11f8-589e-4568-9e27-7e2faebbe2ac')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_5f6f11f8-589e-4568-9e27-7e2faebbe2ac&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5f6f11f8-589e-4568-9e27-7e2faebbe2ac&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5f6f11f8-589e-4568-9e27-7e2faebbe2ac',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5f6f11f8-589e-4568-9e27-7e2faebbe2ac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsListViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin,viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    list:
        商品列表，分页，搜索，过滤，排序
    retrieve:
        获取商品详情
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; authentication_classes = (TokenAuthentication,)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里必须要定义一个默认的排序,否则会报错&lt;/span&gt;
    queryset = Goods.objects.all().order_by(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分页&lt;/span&gt;
    pagination_class =&lt;span&gt; GoodsPagination
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;序列化&lt;/span&gt;
    serializer_class =&lt;span&gt; GoodsSerializer
    filter_backends &lt;/span&gt;=&lt;span&gt; (DjangoFilterBackend,filters.SearchFilter,filters.OrderingFilter)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置filter的类为我们自定义的类&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;过滤&lt;/span&gt;
    filter_class =&lt;span&gt; GoodsFilter
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;搜索&lt;/span&gt;
    search_fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;goods_brief&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;goods_desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
    ordering_fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sold_num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;shop_price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;商品点击数 + 1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; retrieve(self, request, *args, **&lt;span&gt;kwargs):
        instance &lt;/span&gt;=&lt;span&gt; self.get_object()
        instance.click_num &lt;/span&gt;+= 1&lt;span&gt;
        instance.save()
        serializer &lt;/span&gt;=&lt;span&gt; self.get_serializer(instance)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GoodListViewSet&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）收藏数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面已经写了UserFavViewset，其中继承了mixins.CreateModelMixin,添加收藏实际就是创建数据库&lt;/p&gt;
&lt;p&gt;这里重写它的perform_create方法就可以了&lt;/p&gt;
&lt;p&gt;user_operation/view.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户收藏的商品数量+1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
        instance &lt;/span&gt;=&lt;span&gt; serializer.save()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里instance相当于UserFav model，通过它找到goods&lt;/span&gt;
        goods =&lt;span&gt; instance.goods
        goods.fav_num &lt;/span&gt;+= 1&lt;span&gt;
        goods.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6d489fde-6f97-4a7a-8850-2dc743225692')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_6d489fde-6f97-4a7a-8850-2dc743225692&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6d489fde-6f97-4a7a-8850-2dc743225692&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6d489fde-6f97-4a7a-8850-2dc743225692',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6d489fde-6f97-4a7a-8850-2dc743225692&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserFavViewset(viewsets.GenericViewSet, mixins.ListModelMixin, mixins.CreateModelMixin, mixins.DestroyModelMixin):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    用户收藏
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;permission是用来做权限判断的&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; IsAuthenticated：必须登录用户；IsOwnerOrReadOnly：必须是当前登录的用户&lt;/span&gt;
    permission_classes =&lt;span&gt; (IsAuthenticated,IsOwnerOrReadOnly)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;auth使用来做用户认证的&lt;/span&gt;
    authentication_classes =&lt;span&gt; (JSONWebTokenAuthentication,SessionAuthentication)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;搜索的字段&lt;/span&gt;
    lookup_field = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;goods_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;动态选择serializer&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_serializer_class(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.action == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; UserFavDetailSerializer
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; self.action == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; UserFavSerializer
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; UserFavSerializer

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queryset(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只能查看当前登录用户的收藏，不会获取所有用户的收藏&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; UserFav.objects.filter(user=&lt;span&gt;self.request.user)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户收藏的商品数量+1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
        instance &lt;/span&gt;=&lt;span&gt; serializer.save()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里instance相当于UserFav model，通过它找到goods&lt;/span&gt;
        goods =&lt;span&gt; instance.goods
        goods.fav_num &lt;/span&gt;+= 1&lt;span&gt;
        goods.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;UserFavViewset&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）用信号量实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;delete和create的时候django model都会发送一个信号量出来，用信号量的方式代码分离性更好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;收藏数+1和-1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）user_operation/signal.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; users_operation/signals.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.db.models.signals &lt;span&gt;import&lt;/span&gt;&lt;span&gt; post_save,post_delete
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.dispatch &lt;span&gt;import&lt;/span&gt;&lt;span&gt; receiver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; user_operation.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserFav

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; post_save:接收信号的方式&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;sender: 接收信号的model&lt;/span&gt;
@receiver(post_save, sender=&lt;span&gt;UserFav)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; create_UserFav(sender, instance=None, created=False, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否新建，因为update的时候也会进行post_save&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; created:
        goods &lt;/span&gt;=&lt;span&gt; instance.goods
        goods.fav_num &lt;/span&gt;+= 1&lt;span&gt;
        goods.save()

@receiver(post_delete, sender&lt;/span&gt;=&lt;span&gt;UserFav)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; delete_UserFav(sender, instance=None, created=False, **&lt;span&gt;kwargs):
        goods &lt;/span&gt;=&lt;span&gt; instance.goods
        goods.fav_num &lt;/span&gt;-= 1&lt;span&gt;
        goods.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）user_operation/apps.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.apps &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AppConfig


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserOperationConfig(AppConfig):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user_operation&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    verbose_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;操作管理&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ready(self):
        &lt;/span&gt;&lt;span&gt;import&lt;/span&gt; user_operation.signals
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13.5.商品库存和销量修改&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;库存数量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商品库存数量的行为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新增商品到购物车&lt;/li&gt;
&lt;li&gt;修改购物车数量&lt;/li&gt;
&lt;li&gt;删除购物车记录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;trade/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 库存数-1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
        shop_cart &lt;/span&gt;=&lt;span&gt; serializer.save()
        goods &lt;/span&gt;=&lt;span&gt; shop_cart.goods
        goods.goods_num &lt;/span&gt;-=&lt;span&gt; shop_cart.nums
        goods.save()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 库存数+1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_destroy(self, instance):
        goods &lt;/span&gt;=&lt;span&gt; instance.goods
        goods.goods_num &lt;/span&gt;+=&lt;span&gt; instance.nums
        goods.save()
        instance.delete()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新库存,修改可能是增加页可能是减少&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_update(self, serializer):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;首先获取修改之前的库存数量&lt;/span&gt;
        existed_record = ShoppingCart.objects.get(id=&lt;span&gt;serializer.instance.id)
        existed_nums &lt;/span&gt;=&lt;span&gt; existed_record.nums
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先保存之前的数据existed_nums&lt;/span&gt;
        saved_record =&lt;span&gt; serializer.save()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;变化的数量&lt;/span&gt;
        nums = saved_record.nums-&lt;span&gt;existed_nums
        goods &lt;/span&gt;=&lt;span&gt; saved_record.goods
        goods.goods_num &lt;/span&gt;-=&lt;span&gt; nums
        goods.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('343c6c3f-9caf-4fc1-866e-3fc7eab98d1d')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_343c6c3f-9caf-4fc1-866e-3fc7eab98d1d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_343c6c3f-9caf-4fc1-866e-3fc7eab98d1d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('343c6c3f-9caf-4fc1-866e-3fc7eab98d1d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_343c6c3f-9caf-4fc1-866e-3fc7eab98d1d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ShoppingCartViewset(viewsets.ModelViewSet):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    购物车功能
    list:
        获取购物车详情
    create：
        加入购物车
    delete：
        删除购物记录
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    permission_classes &lt;/span&gt;=&lt;span&gt; (IsAuthenticated, IsOwnerOrReadOnly)
    authentication_classes &lt;/span&gt;=&lt;span&gt; (JSONWebTokenAuthentication, SessionAuthentication)
    serializer_class &lt;/span&gt;=&lt;span&gt; ShopCartSerializer
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;商品的id&lt;/span&gt;
    lookup_field = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goods_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_serializer_class(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.action == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ShopCartDetailSerializer
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ShopCartSerializer

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取购物车列表&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_queryset(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ShoppingCart.objects.filter(user=&lt;span&gt;self.request.user)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 库存数-1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
        shop_cart &lt;/span&gt;=&lt;span&gt; serializer.save()
        goods &lt;/span&gt;=&lt;span&gt; shop_cart.goods
        goods.goods_num &lt;/span&gt;-=&lt;span&gt; shop_cart.nums
        goods.save()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 库存数+1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_destroy(self, instance):
        goods &lt;/span&gt;=&lt;span&gt; instance.goods
        goods.goods_num &lt;/span&gt;+=&lt;span&gt; instance.nums
        goods.save()
        instance.delete()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新库存,修改可能是增加页可能是减少&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_update(self, serializer):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;首先获取修改之前的库存数量&lt;/span&gt;
        existed_record = ShoppingCart.objects.get(id=&lt;span&gt;serializer.instance.id)
        existed_nums &lt;/span&gt;=&lt;span&gt; existed_record.nums
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先保存之前的数据existed_nums&lt;/span&gt;
        saved_record =&lt;span&gt; serializer.save()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;变化的数量&lt;/span&gt;
        nums = saved_record.nums-&lt;span&gt;existed_nums
        goods &lt;/span&gt;=&lt;span&gt; saved_record.goods
        goods.goods_num &lt;/span&gt;-=&lt;span&gt; nums
        goods.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ShoppingCartViewset&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;商品销量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商品的销量只有在支付成功后才会 +1&lt;/p&gt;
&lt;p&gt;trade/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;for&lt;/span&gt; order_good &lt;span&gt;in&lt;/span&gt;&lt;span&gt; order_goods:
                    goods &lt;/span&gt;=&lt;span&gt; order_good.goods
                    goods.sold_num &lt;/span&gt;+=&lt;span&gt; order_good.goods_num
                    goods.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c65f6679-3d15-4554-99ba-24554edecfdc')&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_c65f6679-3d15-4554-99ba-24554edecfdc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c65f6679-3d15-4554-99ba-24554edecfdc&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c65f6679-3d15-4554-99ba-24554edecfdc',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c65f6679-3d15-4554-99ba-24554edecfdc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AlipayView(APIView):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        处理支付宝的return_url返回
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        processed_dict &lt;/span&gt;=&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 获取GET中参数&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; request.GET.items():
            processed_dict[key] &lt;/span&gt;=&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 取出sign&lt;/span&gt;
        sign = processed_dict.pop(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, None)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 生成ALipay对象&lt;/span&gt;
        alipay =&lt;span&gt; AliPay(
            appid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2016091500517456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            app_notify_url&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://47.93.198.159:8000/alipay/return/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            app_private_key_path&lt;/span&gt;=&lt;span&gt;private_key_path,
            alipay_public_key_path&lt;/span&gt;=ali_pub_key_path,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,&lt;/span&gt;
            debug=True,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认False,&lt;/span&gt;
            return_url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://47.93.198.159:8000/alipay/return/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        )

        verify_re &lt;/span&gt;=&lt;span&gt; alipay.verify(processed_dict, sign)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里可以不做操作。因为不管发不发return url。notify url都会修改订单状态。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; verify_re &lt;span&gt;is&lt;/span&gt;&lt;span&gt; True:
            order_sn &lt;/span&gt;= processed_dict.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out_trade_no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)
            trade_no &lt;/span&gt;= processed_dict.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trade_no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)
            trade_status &lt;/span&gt;= processed_dict.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trade_status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)

            existed_orders &lt;/span&gt;= OrderInfo.objects.filter(order_sn=&lt;span&gt;order_sn)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; existed_order &lt;span&gt;in&lt;/span&gt;&lt;span&gt; existed_orders:
                existed_order.pay_status &lt;/span&gt;=&lt;span&gt; trade_status
                existed_order.trade_no &lt;/span&gt;=&lt;span&gt; trade_no
                existed_order.pay_time &lt;/span&gt;=&lt;span&gt; datetime.now()
                existed_order.save()

            response &lt;/span&gt;= redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index/#/app/home/member/order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            response &lt;/span&gt;= redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; post(self, request):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        处理支付宝的notify_url
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存放post里面所有的数据&lt;/span&gt;
        processed_dict =&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取出post里面的数据&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; key, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; request.POST.items():
            processed_dict[key] &lt;/span&gt;=&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把signpop掉，文档有说明&lt;/span&gt;
        sign = processed_dict.pop(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, None)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成一个Alipay对象&lt;/span&gt;
        alipay =&lt;span&gt; AliPay(
            appid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2016091500517456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            app_notify_url&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://47.93.198.159:8000/alipay/return/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            app_private_key_path&lt;/span&gt;=&lt;span&gt;private_key_path,
            alipay_public_key_path&lt;/span&gt;=ali_pub_key_path,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,&lt;/span&gt;
            debug=True,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 默认False,&lt;/span&gt;
            return_url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://47.93.198.159:8000/alipay/return/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        )

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;进行验证&lt;/span&gt;
        verify_re =&lt;span&gt; alipay.verify(processed_dict, sign)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果验签成功&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; verify_re &lt;span&gt;is&lt;/span&gt;&lt;span&gt; True:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;商户网站唯一订单号&lt;/span&gt;
            order_sn = processed_dict.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;out_trade_no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;支付宝系统交易流水号&lt;/span&gt;
            trade_no = processed_dict.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trade_no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;交易状态&lt;/span&gt;
            trade_status = processed_dict.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trade_status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None)

            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询数据库中订单记录&lt;/span&gt;
            existed_orders = OrderInfo.objects.filter(order_sn=&lt;span&gt;order_sn)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; existed_order &lt;span&gt;in&lt;/span&gt;&lt;span&gt; existed_orders:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 订单商品项&lt;/span&gt;
                order_goods =&lt;span&gt; existed_order.goods.all()
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 商品销量增加订单中数值&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; order_good &lt;span&gt;in&lt;/span&gt;&lt;span&gt; order_goods:
                    goods &lt;/span&gt;=&lt;span&gt; order_good.goods
                    goods.sold_num &lt;/span&gt;+=&lt;span&gt; order_good.goods_num
                    goods.save()

                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新订单状态&lt;/span&gt;
                existed_order.pay_status =&lt;span&gt; trade_status
                existed_order.trade_no &lt;/span&gt;=&lt;span&gt; trade_no
                existed_order.pay_time &lt;/span&gt;=&lt;span&gt; datetime.now()
                existed_order.save()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要返回一个'success'给支付宝，如果不返回，支付宝会一直发送订单支付成功的消息&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; Response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;AlipayView&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;13.6.drf的缓存设置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了加速网站的访问速度，将一些数据放到缓存当中，取数据的时候首先去缓存中去，然后再去数据库中取&lt;/p&gt;
&lt;p&gt;我们用drf的一个扩展来实现缓存，github上面的使用说明：http://chibisov.github.io/drf-extensions/docs/#caching&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180419011619600-1608929827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180419011947940-748600988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180419013130183-338107936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （1）安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install drf-extensions
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）使用方法&lt;/p&gt;
&lt;p&gt;导入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework_extensions.cache.mixins &lt;span&gt;import&lt;/span&gt; CacheResponseMixin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在GoodsListViewSet中添加缓存功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;CacheResponseMixin一定要放在第一个位置&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; GoodsListViewSet(CacheResponseMixin,mixins.ListModelMixin, mixins.RetrieveModelMixin,viewsets.GenericViewSet):
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置过期时间，settings里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;缓存配置&lt;/span&gt;
REST_FRAMEWORK_EXTENSIONS =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEFAULT_CACHE_RESPONSE_TIMEOUT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 5   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;5s过期，时间自己可以随便设定&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个缓存使用的是内存，每次重启之后就会失效&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13.7.drf配置redis缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;使用django-redis第三方库：http://django-redis-chs.readthedocs.io/zh_CN/latest/#id8    （文档说明）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180419013725092-528402795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （1）安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install django-redis
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）settings&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis缓存&lt;/span&gt;
CACHES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BACKEND&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;django_redis.cache.RedisCache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LOCATION&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis://127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OPTIONS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CLIENT_CLASS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;django_redis.client.DefaultClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13.8.drf的throttle设置api的访问速率&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为了防止爬虫对服务器造成的重大压力，对数据进行访问速率限制就显得非常的重要了&lt;/p&gt;
&lt;p&gt;官网使用说明：http://www.django-rest-framework.org/api-guide/throttling/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180419015515935-2044335937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（1）settings中配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;限速设置&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEFAULT_THROTTLE_CLASSES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: (
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.throttling.AnonRateThrottle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;未登陆用户&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.throttling.UserRateThrottle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;登陆用户&lt;/span&gt;
&lt;span&gt;        ),
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEFAULT_THROTTLE_RATES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;anon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3/minute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每分钟可以请求两次&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5/minute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每分钟可以请求五次&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）goods/views.py中使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.throttling &lt;span&gt;import&lt;/span&gt;&lt;span&gt; UserRateThrottle,AnonRateThrottle&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
class GoodsListViewSet(CacheResponseMixin,mixins.ListModelMixin, mixins.RetrieveModelMixin,viewsets.GenericViewSet):&lt;br/&gt;　　.&lt;br/&gt;　　.
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　throttle_classes &lt;/span&gt;= (UserRateThrottle, AnonRateThrottle)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180419020250711-1308592859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/derek1184405959/p/8859309.html&quot;&gt;&lt;span&gt;Django REST framework+Vue 打造生鲜超市（十一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/derek1184405959/p/8862569.html&quot;&gt;&lt;span&gt;Django REST framework+Vue 打造生鲜超市（十）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/derek1184405959/p/8846501.html&quot;&gt;Django REST framework+Vue 打造生鲜超市（九）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 18:07:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8877643.html</dc:identifier>
</item>
<item>
<title>页面js脚本与img等资源的下载顺序问题。 - 汕大小吴</title>
<link>http://www.cnblogs.com/wuguanglin/p/JSAndImgLoadOrder.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuguanglin/p/JSAndImgLoadOrder.html</guid>
<description>&lt;h3&gt;引言问题&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;img src=&quot;background.jpg&quot;&amp;gt;&lt;br/&gt;&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test.js和background.jpg是并行下载，还是test.js先下载后执行完成后再下载background.jpg???&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;img src=&quot;background.jpg&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样呢？&lt;/p&gt;
&lt;p&gt;我会在文章最后给出解答。&lt;/p&gt;
&lt;p&gt;之前都只了解了大概，没有深入地做测试验证他人所说，这次一定要整的明明白白。&lt;/p&gt;

&lt;h3&gt;浏览器的渲染引擎&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419000902026-1917170365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;script&lt;/h3&gt;
&lt;p&gt;值得一提的是js外部脚本的加载方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有defer、async属性时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419001037199-881769552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是对于多个script标签，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;a.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;b.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419001450325-127171859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有defer属性，&lt;/strong&gt;并行下载完后等到页面解析完后执行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419001557447-2046142356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有async属性，也就是并行下载完后就执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419001721619-1515353030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此外这里还有他人总结的一份笔记，写的挺好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180418235849474-1938925520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;题目解答&lt;/h3&gt;
&lt;p&gt;回到之前的题目上&lt;/p&gt;
&lt;p&gt;1.当script在img标签前时，js会阻塞img的下载，js文件会先下载，下载后执行，执行完成后再下载img.&lt;/p&gt;
&lt;p&gt;因为解析到script标签时，页面会暂停解析，将网页渲染的控制权会交给js引擎，js文件下载完成后执行，执行完成后控制权交还渲染引擎，恢复往下解析，然后解析到img标签就下载img&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;img src=&quot;background.jpg&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果（蓝色为下载时间）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419011055702-334657515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.当img在script标签前时，img文件是异步下载，不会阻塞js的下载，会和js一起并行下载&lt;/p&gt;
&lt;p&gt;因为link,img等都是异步下载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;img src=&quot;background.jpg&quot;&amp;gt;
&amp;lt;script src=&quot;test.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1130568/201804/1130568-20180419012223799-2009081685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了总结完毕，了结了心腹大患，睡觉。&lt;/p&gt;
&lt;p&gt;有疑问可以评论博客。&lt;/p&gt;
&lt;p&gt;参考了阮一峰的浏览器环境概述：&lt;a href=&quot;http://javascript.ruanyifeng.com/bom/engine.html&quot; target=&quot;_blank&quot;&gt;http://javascript.ruanyifeng.com/bom/engine.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Apr 2018 17:31:00 +0000</pubDate>
<dc:creator>汕大小吴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuguanglin/p/JSAndImgLoadOrder.html</dc:identifier>
</item>
<item>
<title>SocketServer源码学习(一) - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/8878836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/8878836.html</guid>
<description>&lt;p&gt;SocketServer其实是对socket更高级的封装正如官网上说的：&lt;br/&gt;The socketserver module simplifies the task of writing network servers.&lt;/p&gt;
&lt;p&gt;我们可以先打开以下SocketServer的源码，看一下源码中整体的框架&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201804/997599-20180419002455639-253079370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图我们可以看出SocketServer主要被抽象为两个主要的类：&lt;br/&gt;BaseServer类,用于处理连接相关的网络操作&lt;br/&gt;BaseRequestHandler类，用于实际处理数据相关的操作&lt;/p&gt;
&lt;p&gt;SocketServer还提供了两个MixIn类：ThreadingMinxIn和ForkingMixinl&lt;br/&gt;用于扩展server，实现多进程和多线程&lt;/p&gt;
&lt;p&gt;下面从会从这几个主要的类开始做一个整体的分析，了解SocketServer的处理流程&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;BaseServer&lt;/h2&gt;
&lt;p&gt;先列一下这里所包含的方法：&lt;br/&gt;server_activate&lt;br/&gt;serve_forever&lt;br/&gt;shutdown&lt;br/&gt;service_actions&lt;br/&gt;handle_request&lt;br/&gt;&lt;span&gt;handle&lt;/span&gt;request_noblock&lt;br/&gt;handle_timeout&lt;br/&gt;verify_request&lt;br/&gt;process_request&lt;br/&gt;server_close&lt;br/&gt;finish_request&lt;br/&gt;shutdown_request&lt;br/&gt;close_request&lt;br/&gt;handle_error&lt;/p&gt;
&lt;p&gt;先看一下BaseServer的初始化函数，其实并没有过多的参数，主要就是实现了创建server对象，并初始化server地址和处理请求的类：RequestHandlerClass&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, server_address, RequestHandlerClass):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Constructor.  May be extended, do not override.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.server_address &lt;/span&gt;=&lt;span&gt; server_address
    self.RequestHandlerClass &lt;/span&gt;=&lt;span&gt; RequestHandlerClass
    self.&lt;/span&gt;&lt;span&gt;__is_shut_down&lt;/span&gt; =&lt;span&gt; threading.Event()
    self.&lt;/span&gt;&lt;span&gt;__shutdown_request&lt;/span&gt; = False
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;serve_forever&lt;/h3&gt;
&lt;p&gt;先看一下源码内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; serve_forever(self, poll_interval=0.5&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Handle one request at a time until shutdown.

    Polls for shutdown every poll_interval seconds. Ignores
    self.timeout. If you need to do periodic tasks, do them in
    another thread.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.&lt;/span&gt;&lt;span&gt;__is_shut_down&lt;/span&gt;&lt;span&gt;.clear()
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; XXX: Consider using another file descriptor or connecting to the&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; socket to wake this up instead of polling. Polling reduces our&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; responsiveness to a shutdown request and wastes cpu at all other&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; times.&lt;/span&gt;
&lt;span&gt;        with _ServerSelector() as selector:
            selector.register(self, selectors.EVENT_READ)

            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.&lt;span&gt;__shutdown_request&lt;/span&gt;&lt;span&gt;:
                ready &lt;/span&gt;=&lt;span&gt; selector.select(poll_interval)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ready:
                    self._handle_request_noblock()

                self.service_actions()
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        self.&lt;/span&gt;&lt;span&gt;__shutdown_request&lt;/span&gt; =&lt;span&gt; False
        self.&lt;/span&gt;&lt;span&gt;__is_shut_down&lt;/span&gt;.set()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当创建server对象之后，我们会使用server对象开启一个无限循环，即调用serve_forever,&lt;br/&gt;下面是它的源码，接受一个参数poll_interval，用于表示select轮询的时间，然后进入一个死循环，用select方法进行网络IO的监听，这里通过调用selector.register(self, selectors.EVENT_READ)进行了注册，当ready有返回是，表示有IO连接或者数据，这个时候会调用_handle_request_noblock&lt;br/&gt;接着看一下_handle_request_noblock源码&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;&lt;span&gt;handle&lt;/span&gt;request_noblock&lt;/h3&gt;
&lt;p&gt;源码内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _handle_request_noblock(self):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Handle one request, without blocking.

    I assume that selector.select() has returned that the socket is
    readable before this function was called, so there should be no risk of
    blocking in get_request().
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        request, client_address &lt;/span&gt;=&lt;span&gt; self.get_request()
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; OSError:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.verify_request(request, client_address):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.process_request(request, client_address)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            self.handle_error(request, client_address)
            self.shutdown_request(request)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        self.shutdown_request(request)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;handlerequest_noblock方法即开始处理一个请求，并且是非阻塞。该方法通过get_request方法获取连接，具体的实现在其子类。一旦得到了连接，调用verify_request方法验证请求。验证通过，即调用process_request处理请求。如果中途出现错误，则调用handle_error处理错误，以及shutdown_request结束连接。&lt;/p&gt;
&lt;p&gt;而verify_request中默认直接返回True，所以当验证通过后讲调用process_request&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;process_request&lt;/h3&gt;
&lt;p&gt;源码内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request, client_address):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Call finish_request.

    Overridden by ForkingMixIn and ThreadingMixIn.

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.finish_request(request, client_address)
    self.shutdown_request(request)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就像源码中描述的那样：Overridden by ForkingMixIn and ThreadingMixIn.&lt;br/&gt;process_request方法是mixin的入口，MixIn子类通过重写该方法，进行多线程或多进程的配置。调用finish_request完成请求的处理，同时调用shutdown_request结束请求。继续查看finish_request&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;finish_request&lt;/h3&gt;
&lt;p&gt;源码内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; finish_request(self, request, client_address):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Finish one request by instantiating RequestHandlerClass.&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    self.RequestHandlerClass(request, client_address, self)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于请求的部分到这里就已经处理完毕，接下来是要对数据的处理，finish_request方法将会处理完毕请求。创建requestHandler对象，并通过requestHandler做具体的处理。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;BaseRequestHandler&lt;/h2&gt;
&lt;p&gt;就像我们前面说的：&lt;br/&gt;BaseServer类,用于处理连接相关的网络操作&lt;br/&gt;BaseRequestHandler类，用于实际处理数据相关的操作&lt;/p&gt;
&lt;p&gt;还是从初始化函数里看源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, request, client_address, server):
    self.request &lt;/span&gt;=&lt;span&gt; request
    self.client_address &lt;/span&gt;=&lt;span&gt; client_address
    self.server &lt;/span&gt;=&lt;span&gt; server
    self.setup()
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        self.handle()
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
        self.finish()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该类会处理每一个请求。初始化对象的时候，设置请求request对象。然后调用setup方法，子类会重写该方法，用于处理socket连接。接下来的将是handler和finish方法。所有对请求的处理，都可以重写handler方法。&lt;/p&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;SocketServer的一个服务端的简单例子&lt;/h2&gt;
&lt;p&gt;直接上代码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socketserver


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyTCPHandler(socketserver.BaseRequestHandler):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                self.data &lt;/span&gt;= self.request.recv(1024&lt;span&gt;).strip()
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{} wrote:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(self.client_address))
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.data)
                self.request.sendall(self.data.upper())
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ConnectionResetError as e:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    host,port &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,9999&lt;span&gt;
    server &lt;/span&gt;=&lt;span&gt; socketserver.TCPServer((host,port),MyTCPHandler)
    server.serve_forever()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过对源码的分析我们已经知道了对数据的处理部分都是在BaseRequestHandler这个类中，而我们的主要处理逻辑也就是在这部分，所以我继承了这个类，重写了handle方法&lt;/p&gt;

</description>
<pubDate>Wed, 18 Apr 2018 16:29:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/8878836.html</dc:identifier>
</item>
<item>
<title>p2p项目总结 - doveshelly</title>
<link>http://www.cnblogs.com/doveshelly/p/8878835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doveshelly/p/8878835.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.关于ajax请求所要注意的地方:$.psot(url,json,callback,type)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)url路径问题,在html中写绝对路径不能用EL表达式,EL表达式只能在jsp中使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2)json参数可以为json对象,如:{name:&quot;tom&quot;,age:12},前一个参数可以不写冒号,也可以写成get请求url后面拼接的类型,如:name=tom&amp;amp;age=12等,因此&lt;/span&gt;&lt;span&gt;当提交表单时,设表单id为form,批量获取表单提交数据的方法为$(&quot;#form&quot;).serialize(),得到的就是类似name=tom&amp;amp;age=12,可以直接作为请求参数,如果想要额外添加请求参数,可以在得到的字符串后面继续拼接&amp;amp;key=value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3)清空表单的方法:reset(),该方法为js方法,不是jquery方法,因此适用对象为$(&quot;#id&quot;)[0]来调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4)登录拦截的Filter,要注意拦截范围,通常是把登录成功后的页面单独放在一个文件夹下,只拦截该文件夹即可,另外注意拦截的方式一般包括request和forward两种,forward是登陆成功的请求转发到成功界面,request是客户直接访问该成功界面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(5)callback回调函数的返回值data,如果没设置type类型为json时,要用eval(data)来处理,而当data为单个对象的时候,最好在data左右加上括号,如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;eval(&quot;(&quot;+data+&quot;)&quot;),要不然不能识别为json对象,所以最好还是设置type类型为json&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(6)如果ajax请求没有响应数据回来,不要设置type类型,否则不会执行callback方法,同时异步请求无法再服务器端的servlet使用重定向和请求转发等方式,只能回写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(7)表单中button按钮如果未设置类型,点击后默认get方式提交表单,而不会调用绑定的异步请求&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 16:28:00 +0000</pubDate>
<dc:creator>doveshelly</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/doveshelly/p/8878835.html</dc:identifier>
</item>
<item>
<title>MyBatis 框架系列之基础初始 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8878767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8878767.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/04/18/emile-perron-190221-unsplash.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-mybatis&quot;&gt;1、什么是 MyBatis&lt;/h3&gt;
&lt;p&gt;MyBatis 本是 apache 的一个开源项目 iBatis，后改名为 MyBatis，它 是一个优秀的持久层框架，对 jdbc 的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。&lt;/p&gt;
&lt;p&gt;Mybatis 通过 xml 或注解的方式将要执行的各种 statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过 Java 对象和 statement 中的 sql 进行映射生成最终执行的 sql 语句，最后由 Mybatis 框架执行 sql 并将结果映射成 Java 对象并返回。&lt;/p&gt;
&lt;h3 id=&quot;mybatis-架构详解&quot;&gt;2、MyBatis 架构详解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/2018/04/18/%E6%97%A0%E6%A0%87%E9%A2%98.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）MyBatis 配置文件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SqlMapConfig.xml：&lt;/strong&gt; 此文件作为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mapper.xml：&lt;/strong&gt; 即 sql 映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 SqlMapConfig.xml 中加载。&lt;/p&gt;
&lt;p&gt;（2）通过 MyBatis 环境等配置信息构造 SqlSessionFactory， 即会话工厂。&lt;/p&gt;
&lt;p&gt;（3）由会话工厂创建 sqlSession ，即会话，操作数据库需要通过 sqlSession 进行。&lt;/p&gt;
&lt;p&gt;（4）MyBatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。&lt;/p&gt;
&lt;p&gt;（5）Mapped Statement 是 MyBatis 一个底层封装对象，它包装了 MyBatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 Mapped Statement 对象，sql 的 id 即是 Mapped statement 的 id。&lt;/p&gt;
&lt;p&gt;（6）Mapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过Mapped Statement 在执行 sql 前将输入的 Java 对象映射至 sql 中，输入参数映射就是 jdbc 编程中对preparedStatement 设置参数。&lt;/p&gt;
&lt;p&gt;（7）Mapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor通过Mapped Statement 在执行 sql 后将输出结果映射至 Java 对象中，输出结果映射过程相当于 jdbc 编程中对结果的解析处理过程。&lt;/p&gt;
&lt;h3 id=&quot;传统的-jdbc-编程问题总结&quot;&gt;3、传统的 JDBC 编程问题总结&lt;/h3&gt;
&lt;h4 id=&quot;jdbc-编程步骤&quot;&gt;（1）JDBC 编程步骤&lt;/h4&gt;
&lt;p&gt;1）加载数据库驱动&lt;/p&gt;
&lt;p&gt;2）创建并获取数据库链接&lt;/p&gt;
&lt;p&gt;3）创建 jdbcstatement 对象&lt;/p&gt;
&lt;p&gt;4）设置 sql 语句&lt;/p&gt;
&lt;p&gt;5）设置 sql 语句中的参数(使用preparedStatement)&lt;/p&gt;
&lt;p&gt;6）通过 statement 执行 sql 并获取结果&lt;/p&gt;
&lt;p&gt;7）对 sql 执行结果进行解析处理&lt;/p&gt;
&lt;p&gt;8）释放资源(resultSet、preparedstatement、connection)&lt;/p&gt;
&lt;h3 id=&quot;jdbc-程序实例&quot;&gt;（2）JDBC 程序实例&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test { 
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        Connection connection = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        PreparedStatement preparedStatement = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ResultSet resultSet = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 加载数据库驱动&lt;/span&gt;
            Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;// 通过驱动管理类获取数据库链接&lt;/span&gt;
            connection = DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 定义sql语句 ?表示占位符&lt;/span&gt;
            String sql = &lt;span class=&quot;st&quot;&gt;&quot;select * from user where username = ?&quot;&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 获取预处理statement&lt;/span&gt;
            preparedStatement = connection.&lt;span class=&quot;fu&quot;&gt;prepareStatement&lt;/span&gt;(sql);
            &lt;span class=&quot;co&quot;&gt;// 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值&lt;/span&gt;
            preparedStatement.&lt;span class=&quot;fu&quot;&gt;setString&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;王五&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;// 向数据库发出sql执行查询，查询出结果集&lt;/span&gt;
            resultSet = preparedStatement.&lt;span class=&quot;fu&quot;&gt;executeQuery&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 遍历查询结果集&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (resultSet.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;()) {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(resultSet.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;) + &lt;span class=&quot;st&quot;&gt;&quot;  &quot;&lt;/span&gt; + resultSet.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;));
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 释放资源&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (resultSet != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    resultSet.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                    &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                }
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (preparedStatement != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    preparedStatement.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                    &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                }
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (connection != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    connection.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
                    &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                }
            }
        }
      }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;传统-jdbc-程序问题总结&quot;&gt;（3）传统 JDBC 程序问题总结&lt;/h3&gt;
&lt;p&gt;1）数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。&lt;/p&gt;
&lt;p&gt;2）sql 语句在代码中硬编码，造成代码不易维护，实际应用中 sql 变化的可能较大，sql 变动需要改变 Java 代码。&lt;/p&gt;
&lt;p&gt;3）使用 preparedStatement 向占有位符号传参数存在硬编码，因为 sql 语句的 where 条件不一定，可能多也可能少，修改 sql 还要修改代码，系统不易维护。&lt;/p&gt;
&lt;p&gt;4） 对结果集解析存在硬编码（查询列名），sql 变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成 pojo 对象解析比较方便。&lt;/p&gt;
&lt;h3 id=&quot;mybatis-入门实例鉴于导入-jar-包开发程序相对麻烦因此接下来的框架和项目程序均使用-maven-工具来进行项目管理所以入门程序会在下一个-maven-系列文章更新完后再重新讲解&quot;&gt;4、MyBatis 入门实例：鉴于导入 jar 包开发程序相对麻烦，因此接下来的框架和项目程序均使用 Maven 工具来进行项目管理，所以入门程序会在下一个 Maven 系列文章更新完后再重新讲解。&lt;/h3&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;http://p5xem2laz.bkt.clouddn.com/about/wechat-qcode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 16:16:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8878767.html</dc:identifier>
</item>
<item>
<title>linux下使用crontab定时执行脚本 - hustzzl</title>
<link>http://www.cnblogs.com/hustzzl/p/8878664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hustzzl/p/8878664.html</guid>
<description>&lt;h3&gt;使用crontab定时执行脚本&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;cron服务是一个定时执行的服务，可以通过crontab 命令添加或者编辑需要定时执行的任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;crontab –e : 修改 crontab 文件，如果文件不存在会自动创建。 &lt;br/&gt;crontab –l : 显示 crontab 文件。 &lt;br/&gt;crontab -r : 删除 crontab 文件。&lt;br/&gt;crontab -ir : 删除 crontab 文件前提醒用户。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 执行以上命令的时候，若遇到“crontab command not found”错误，这是因为软件包没有安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;crontab 要安装两个软件包:   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;vixie-cron 及 crontabs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接执行 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum install vixie-cron&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;yum install crontabs（这句可能不需要，但是你也可试试）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即可解决.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在crontab文件中写入需要执行的命令和时间，该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。每个域之间使用空格或者制表符分隔。格式如下： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
minute hour day-of-month month-of-year day-of-week commands  &lt;br/&gt;分钟    小时   天              月            星期      要执行的命令&lt;br/&gt;前面五个参数中间用空格隔开，最后是要执行的命令。  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;合法值为：00-59 00-23 01-31 01-12 0-6 (0 is sunday) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;除了数字还有几个特殊的符号：&quot;*&quot;、&quot;/&quot;和&quot;-&quot;、&quot;,&quot;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*代表所有的取值范围内的数字&lt;/li&gt;
&lt;li&gt;&quot;/&quot;代表每的意思,&quot;/5&quot;表示每5个单位&lt;/li&gt;
&lt;li&gt;&quot;-&quot;代表从某个数字到某个数字&lt;/li&gt;
&lt;li&gt;&quot;,&quot;分开几个离散的数字&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：commands 注意以下几点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要是存在文件，要写绝对路径&lt;/li&gt;
&lt;li&gt;即使是打印也不会显示在显示屏，在后台运行，最好重定向日志&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（写一个定时任务，每分钟往test.txt文件写入一个&quot;good&quot;字符串）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step1&lt;/strong&gt;：写cron脚本文件，命名为mytest.cron。&lt;/p&gt;
&lt;p&gt;使用touch命令创建两个文件，mytest.cron作为脚本文件，test.txt用来测试（作为日志打印输出文件）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000613938-1376489642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000352658-621329894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用vi命令编辑mytest.cron文件。写入以下内容：&lt;/p&gt;
&lt;p&gt;*/1 * * * * echo &quot;good&quot; &amp;gt;&amp;gt; /export/Domains/yy.embed.jd.com/server1/logs/test.txt   &lt;/p&gt;
&lt;p&gt;表示每分钟，执行&lt;span&gt;一次&lt;span&gt;打印命令，往test.txt文件里写入一个&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000158559-196194177.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000227419-636382358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2&lt;/strong&gt;：添加定时任务。执行命令&lt;/p&gt;
&lt;p&gt;crontab mytest.cron&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000138465-706502634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;step3&lt;/strong&gt;：&quot;crontab -l&quot; 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000121044-456583397.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;step4&lt;/strong&gt;：&quot;service crond status&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Crontab是一个很方便的在unix/linux系统上定时(循环)执行某个任务的程序&lt;br/&gt;使用cron服务，用 service crond status 查看 cron服务状态，如果没有启动则 service crond start启动它，启动命令“service crond start”。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000039839-504801873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用cat命令查看test.txt文件，结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1065261/201804/1065261-20180419000021486-852670229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 18 Apr 2018 15:58:00 +0000</pubDate>
<dc:creator>hustzzl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hustzzl/p/8878664.html</dc:identifier>
</item>
<item>
<title>HTML笔记05------AJAX - 天心阁主</title>
<link>http://www.cnblogs.com/meng-blog/p/8878611.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meng-blog/p/8878611.html</guid>
<description>&lt;h2 id=&quot;ajax初探01&quot;&gt;AJAX初探01&lt;/h2&gt;
&lt;h3 id=&quot;ajax概念&quot;&gt;AJAX概念&lt;/h3&gt;
&lt;p&gt;概念：即&quot;Asynchronous JavaScript And XML&quot;&lt;br/&gt;通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。（传统的网页（不使用AJAX）如果需要更新内容，必须重载整个网页页面或者使用iframe。）&lt;/p&gt;
&lt;p&gt;AJAX写法&lt;br/&gt;浏览器兼容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(window.ActiveXObject){
           xmlHttp = new ActiveXObject(&quot;Micr0soft.XMLHTTP&quot;);
       }else if(window.XMLHttpRequest){
           xmlHttp = new XMLHttpRequest();
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;状态码&lt;br/&gt;readyState&lt;br/&gt;存在XMLHTTPRequest的状态&lt;/p&gt;
&lt;p&gt;0: 请求未初始化&lt;/p&gt;
&lt;p&gt;1: 服务器连接已建立&lt;/p&gt;
&lt;p&gt;2: 请求已接收&lt;/p&gt;
&lt;p&gt;3: 请求处理中&lt;/p&gt;
&lt;p&gt;4: 请求已完成，且响应已就绪&lt;/p&gt;
&lt;p&gt;status&lt;/p&gt;
&lt;p&gt;200: &quot;OK&quot;&lt;/p&gt;
&lt;p&gt;404: 未找到页面&lt;/p&gt;
&lt;hr/&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;button onclick=&quot;update()&quot;&amp;gt;数据更新&amp;lt;/button&amp;gt;
&amp;lt;br/&amp;gt;
    &amp;lt;div id=&quot;dataArea&quot;&amp;gt;
   展示服务器返回的数据
    &amp;lt;/div&amp;gt;

&amp;lt;script&amp;gt;
   function update() {
       var xmlHttp;
       if(window.ActiveXObject){
           xmlHttp = new ActiveXObject (&quot;Micr0soft.XMLHTTP&quot;);//IE678 opera OLD 老旧浏览器
       }else if(window.XMLHttpRequest){
           xmlHttp = new XMLHttpRequest(); // 新浏览器
       }
       xmlHttp.open(&quot;&quot;,&quot;&quot;);//打开和服务器的链接
       // xmlHttp.open(&quot;获取方式（get / post）&quot;,&quot;文件名&quot;);
       xmlHttp.send(&quot;null&quot;);//send动作才是真正的给服务器按照上面open的url发送请求
       //  on (当) ready (准备) state (状态) change (改变)
       xmlHttp.onreadystatechange = function () {
           if(xmlHttp.readyState === 4&amp;amp;&amp;amp; xmlHttp.status === 2){
               document.getElementById(&quot;dateArea&quot;).innerHTML = xmlHttp.responseText;
           }
       }
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;</description>
<pubDate>Wed, 18 Apr 2018 15:50:00 +0000</pubDate>
<dc:creator>天心阁主</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meng-blog/p/8878611.html</dc:identifier>
</item>
<item>
<title>hermite矩阵 - 火山岩上的小红花</title>
<link>http://www.cnblogs.com/duwenlu/p/8878514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duwenlu/p/8878514.html</guid>
<description>&lt;p&gt;在读线代书。因为之前并没有上过线性代数的课。所以决定把基础打牢牢。&lt;/p&gt;
&lt;p&gt;读书的时候当然会出现不懂的概念和术语或者定理什么的。所以在这记录一下啦～～～&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;hermit矩阵&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;要理解它好像先要知道什么是共轭（conjugate）。&lt;/p&gt;
&lt;p&gt;参见百度百科：&lt;a href=&quot;https://baike.baidu.com/item/%E5%85%B1%E8%BD%AD/31802&quot; target=&quot;_blank&quot;&gt;https://baike.baidu.com/item/%E5%85%B1%E8%BD%AD/31802&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 本意：两头牛背上的架子称为轭，轭使两头牛同步行走。共轭即为按一定的规律相配的一对。通俗点说就是孪生。&lt;/p&gt;
&lt;p&gt;共轭关系，通俗来说一般用以描述两件事物以一定规律相互配对或孪生（一般共轭对整体很相似，但在某些特征上却性质相反）&lt;/p&gt;

&lt;p&gt;数学上的共轭：&lt;/p&gt;
&lt;p&gt;共轭复数：实数部分相同而虚数部分互为相反数的两个复数。&lt;/p&gt;
&lt;p&gt;矩阵的共轭转置：把矩阵转置后，再把每一个数换成它的共轭复数。&lt;/p&gt;
&lt;p&gt;自共轭矩阵：矩阵中每一个第i 行第j 列的元素都与第j 行第i 列的元素的共轭相等。&lt;/p&gt;

&lt;p&gt;自共轭矩阵就是hermit矩阵&lt;/p&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:35:00 +0000</pubDate>
<dc:creator>火山岩上的小红花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duwenlu/p/8878514.html</dc:identifier>
</item>
<item>
<title>AutoCAD常用操作命令 - 手握铅笔</title>
<link>http://www.cnblogs.com/kindle/p/8878454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kindle/p/8878454.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近工作需要使用AutoCAD画图，在这里记一下用到的一些常用操作，都是一些很基础的操作，希望对大家有帮助。&lt;/p&gt;
&lt;h3 id=&quot;修剪&quot;&gt;修剪&lt;/h3&gt;
&lt;p&gt;如果两条直线相交，你需要剪掉多余的部分，可以用修剪命令TR。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们先画两条相交的直线。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232145720-275441099.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;输入TR, 空格&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232159993-94909540.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击修剪边，然后空格。记住，不是你想要剪掉的边。这里我们要剪掉的是A的左边的那部分，所以点击直线B&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232213257-991927203.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;点击你想要剪掉的部分，这里我们点击直线A的左边部分。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232239369-1204769604.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;到这里我们的目的达到了，空格结束&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1375116/201804/1375116-20180418232249714-895841371.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;待续&quot;&gt;待续&amp;gt;&amp;gt;&amp;gt;&lt;/h3&gt;
</description>
<pubDate>Wed, 18 Apr 2018 15:24:00 +0000</pubDate>
<dc:creator>手握铅笔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kindle/p/8878454.html</dc:identifier>
</item>
</channel>
</rss>