<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python之socket编程 - 菜鸟小于</title>
<link>http://www.cnblogs.com/Young111/p/9497354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Young111/p/9497354.html</guid>
<description>&lt;h2&gt;一、客户端/服务器架构&lt;/h2&gt;
&lt;p&gt;1.硬件C/S架构(打印机)&lt;/p&gt;
&lt;p&gt;2.软件C/S架构&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　&lt;/em&gt;　互联网中处处是C/S架构&lt;/p&gt;
&lt;p&gt;　　如购物网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种）&lt;/p&gt;
&lt;p&gt;　　腾讯作为服务端为你提供视频，你得下个腾讯视频客户端才能看它的视频）&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 659&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;25&quot;&gt;
&lt;p&gt;C/S架构与socket的关系：&lt;/p&gt;
&lt;p&gt;学习socket就是为了完成C/S架构的开发&lt;/p&gt;
&lt;h2&gt;二、osi七层&lt;/h2&gt;
&lt;p&gt;须知一个完整的计算机系统是由硬件、操作系统、应用软件三者组成,具备了这三个条件，一台计算机系统就可以自己跟自己玩了（打个单机游戏，玩个扫雷啥的）&lt;/p&gt;
&lt;p&gt;如果你要跟别人一起玩，那你就需要上网了，什么是互联网？&lt;/p&gt;
&lt;p&gt;互联网的核心就是由一堆协议组成，协议就是标准，比如全世界人通信的标准是英语&lt;/p&gt;
&lt;p&gt;如果把计算机比作人，互联网协议就是计算机界的英语。所有的计算机都学会了互联网协议，那所有的计算机都就可以按照统一的标准去收发信息从而完成通信了。&lt;/p&gt;
&lt;p&gt;人们按照分工不同把互联网协议从逻辑上划分了层级，可以看下图：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818140221995-626572348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，学习socket之前要先学习互联网协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818141638070-1592421904.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、socket层&lt;/h2&gt;
&lt;p&gt;经过上图和下图的对比，我们不难发现socket层的所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818141813162-100140600.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;socket的是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;Socket是应用层与&lt;span lang=&quot;EN-US&quot;&gt;TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，&lt;span lang=&quot;EN-US&quot;&gt;Socket其实就是一个门面模式，它把复杂的&lt;span lang=&quot;EN-US&quot;&gt;TCP/IP协议族隐藏在&lt;span lang=&quot;EN-US&quot;&gt;Socket接口后面，对用户来说，一组简单的接口就是全部，让&lt;span lang=&quot;EN-US&quot;&gt;Socket去组织数据，以符合指定的协议。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;所以，我们无需深入理解tcp/udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程，写出的程序自然就是遵循tcp/udp标准的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;也有人将socket说成ip+port，ip是用来标识互联网中的一台主机的位置，而port是用来标识这台机器上的一个应用程序，ip地址是配置到网卡上的，而port是应用程序开启的，ip与port的绑定就标识了互联网中独一无二的一个应用程序，而程序的pid是同一台机器上不同进程或者线程的标识&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;四、套接字发展史及分类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;套接字起源于 20 世纪 70 年代加利福尼亚大学伯克利分校版本的 Unix,即人们所说的 BSD Unix。 因此,有时人们也把套接字称为“伯克利套接字”或“BSD 套接字”。一开始,套接字被设计用在同 一台主机上多个应用程序之间的通讯。这也被称进程间通讯,或 IPC。套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于文件类型的套接字家族&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;套接字家族的名字：AF_UNIX&lt;/p&gt;
&lt;p&gt;unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;strong&gt;基于网络类型的套接字家族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;套接字家族的名字：AF_INET&lt;/p&gt;
&lt;p&gt;(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;套接字工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818142210839-586928346.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;先从服务器端说起。服务器端先初始化&lt;span lang=&quot;EN-US&quot;&gt;Socket，然后与端口绑定&lt;span lang=&quot;EN-US&quot;&gt;(bind)，对端口进行监听&lt;span lang=&quot;EN-US&quot;&gt;(listen)，调用&lt;span lang=&quot;EN-US&quot;&gt;accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个&lt;span lang=&quot;EN-US&quot;&gt;Socket，然后连接服务器&lt;span lang=&quot;EN-US&quot;&gt;(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;socket()模块函数用法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_a6861bba-3100-4747-b247-51ab76a91dc7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a6861bba-3100-4747-b247-51ab76a91dc7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a6861bba-3100-4747-b247-51ab76a91dc7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
  socket.socket(socket_family,socket_type,protocal&lt;/span&gt;=&lt;span&gt;0)
  socket_family 可以是 AF_UNIX 或 AF_INET。socket_type 可以是 SOCK_STREAM 或 SOCK_DGRAM。protocol 一般不填,默认值为 0。
  
  获取tcp&lt;/span&gt;/&lt;span&gt;ip套接字
  tcpSock &lt;/span&gt;=&lt;span&gt; socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  
  获取udp&lt;/span&gt;/&lt;span&gt;ip套接字
  udpSock &lt;/span&gt;=&lt;span&gt; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
 
 由于 socket 模块中有太多的属性。我们在这里破例使用了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;from module import *&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;语句。使用 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;from socket import *&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,我们就把 socket 模块里的所有属性都带到我们的命名空间里了,这样能 大幅减短我们的代码。
 例如tcpSock &lt;/span&gt;= socket(AF_INET, SOCK_STREAM)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;pre readability=&quot;18&quot;&gt;
&lt;span&gt;&lt;strong&gt;服务端套接字函数&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;s.bind()    绑定(主机,端口号)到套接字&lt;br/&gt;s.listen()  开始TCP监听&lt;br/&gt;s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来&lt;p&gt;&lt;span&gt;&lt;strong&gt;客户端套接字函数&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;s.connect()     主动初始化TCP服务器连接&lt;br/&gt;s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公共用途的套接字函数&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;s.recv()            接收TCP数据&lt;br/&gt;s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)&lt;br/&gt;s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)&lt;br/&gt;s.recvfrom()        接收UDP数据&lt;br/&gt;s.sendto()          发送UDP数据&lt;br/&gt;s.getpeername()     连接到当前套接字的远端的地址&lt;br/&gt;s.getsockname()     当前套接字的地址&lt;br/&gt;s.getsockopt()      返回指定套接字的参数&lt;br/&gt;s.setsockopt()      设置指定套接字的参数&lt;br/&gt;s.close()           关闭套接字
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;span&gt;&lt;strong&gt;面向锁的套接字方法&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;s.setblocking()     设置套接字的阻塞与非阻塞模式&lt;br/&gt;s.settimeout()      设置阻塞套接字操作的超时时间&lt;br/&gt;s.gettimeout()      得到阻塞套接字操作的超时时间&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向文件的套接字的函数&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;s.fileno()          套接字的文件描述符&lt;br/&gt;s.makefile()        创建一个与该套接字相关的文件
&lt;/p&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;五、基于TCP的套接字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;tcp是基于链接的，必须先启动服务端，然后再启动客户端去链接服务端&lt;/p&gt;
&lt;p&gt;tcp服务端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 ss = socket() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建服务器套接字&lt;/span&gt;
 ss.bind()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;把地址绑定到套接字&lt;/span&gt;
 ss.listen()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;监听链接&lt;/span&gt;
 inf_loop:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务器无限循环&lt;/span&gt;
     cs = ss.accept() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;接受客户端链接&lt;/span&gt;
     comm_loop:         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通讯循环&lt;/span&gt;
         cs.recv()/cs.send() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对话(接收与发送)&lt;/span&gt;
     cs.close()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭客户端套接字&lt;/span&gt;
 ss.close()        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭服务器套接字(可选)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tcp客户端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 cs = socket()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建客户套接字&lt;/span&gt;
 cs.connect()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 尝试连接服务器&lt;/span&gt;
 comm_loop:        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通讯循环&lt;/span&gt;
     cs.send()/cs.recv()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对话(发送/接收)&lt;/span&gt;
 cs.close()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭客户套接字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;socket通信流程与打电话流程类似，我们就以打电话为例来实现一个low版的套接字通信：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_db9457a0-c59a-456f-8e69-187469bf9742&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_db9457a0-c59a-456f-8e69-187469bf9742&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_db9457a0-c59a-456f-8e69-187469bf9742&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9000)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;电话卡&lt;/span&gt;
BUFSIZE=1024                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;收发消息的尺寸&lt;/span&gt;
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;买手机&lt;/span&gt;
s.bind(ip_port) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机插卡&lt;/span&gt;
s.listen(5)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机待机&lt;/span&gt;
&lt;span&gt;

conn,addr&lt;/span&gt;=s.accept()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机接电话&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(conn)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(addr)&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;接到来自%s的电话&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;addr[0])

msg&lt;/span&gt;=conn.recv(BUFSIZE)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;听消息,听话&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg,type(msg))

conn.send(msg.upper())          &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息,说话&lt;/span&gt;
&lt;span&gt;
conn.close()                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;挂电话&lt;/span&gt;
&lt;span&gt;
s.close()                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机关机&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;服务端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_dbcb8a64-8619-4214-b4c4-d74e4b9cadfd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dbcb8a64-8619-4214-b4c4-d74e4b9cadfd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dbcb8a64-8619-4214-b4c4-d74e4b9cadfd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9000&lt;span&gt;)
BUFSIZE&lt;/span&gt;=1024&lt;span&gt;
s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)

s.connect_ex(ip_port)           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拨电话&lt;/span&gt;
&lt;span&gt;
s.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linhaifeng nb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息,说话(只能发送字节类型)&lt;/span&gt;
&lt;span&gt;
feedback&lt;/span&gt;=s.recv(BUFSIZE)                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;收消息,听话&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(feedback.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

s.close()                                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;挂电话&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;客户端&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;加上链接循环与通信循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_9c0436f5-1ae3-4edf-8ac1-278aea22a220&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9c0436f5-1ae3-4edf-8ac1-278aea22a220&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9c0436f5-1ae3-4edf-8ac1-278aea22a220&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8081)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;电话卡&lt;/span&gt;
BUFSIZE=1024&lt;span&gt;
s&lt;/span&gt;=socket.socket(socket.AF_INET,socket.SOCK_STREAM) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;买手机&lt;/span&gt;
s.bind(ip_port) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机插卡&lt;/span&gt;
s.listen(5)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机待机&lt;/span&gt;


&lt;span&gt;while&lt;/span&gt; True:                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新增接收链接循环,可以不停的接电话&lt;/span&gt;
    conn,addr=s.accept()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机接电话&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(conn)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(addr)&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;接到来自%s的电话&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;addr[0])
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; True:                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新增通信循环,可以不断的通信,收发消息&lt;/span&gt;
        msg=conn.recv(BUFSIZE)             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;听消息,听话&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if len(msg) == 0:break        #如果不加,那么正在链接的客户端突然断开,recv便不再阻塞,死循环发生&lt;/span&gt;

        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg,type(msg))

        conn.send(msg.upper())          &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息,说话&lt;/span&gt;
&lt;span&gt;
    conn.close()                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;挂电话&lt;/span&gt;
&lt;span&gt;
s.close()                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;手机关机&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server改进&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a21c870d-8f11-4d5d-a7fa-80546839a420&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a21c870d-8f11-4d5d-a7fa-80546839a420&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a21c870d-8f11-4d5d-a7fa-80546839a420&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8081&lt;span&gt;)
BUFSIZE&lt;/span&gt;=1024&lt;span&gt;
s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)

s.connect_ex(ip_port)           &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拨电话&lt;/span&gt;

&lt;span&gt;while&lt;/span&gt; True:                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新增通信循环,客户端可以不断发收消息&lt;/span&gt;
    msg=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(msg) == 0:&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
    s.send(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息,说话(只能发送字节类型)&lt;/span&gt;
&lt;span&gt;
    feedback&lt;/span&gt;=s.recv(BUFSIZE)                           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;收消息,听话&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(feedback.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

s.close()                                       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;挂电话&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client改进&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;六、基于UDP的套接字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;UDP是无链接的，先启动那一端都不会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;udp服务端：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1 ss = socket()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个服务器的套接字&lt;/span&gt;
2 ss.bind()       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绑定服务器套接字&lt;/span&gt;
3 inf_loop:       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务器无限循环&lt;/span&gt;
4     cs = ss.recvfrom()/ss.sendto() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对话(接收与发送)&lt;/span&gt;
5 ss.close()                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭服务器套接字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;udp客户端&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cs = socket()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建客户套接字&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; comm_loop:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通讯循环&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     cs.sendto()/cs.recvfrom()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对话(发送/接收)&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; cs.close()                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭客户套接字&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;udp套接字简单编程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_5baac865-0067-4e6e-9bb7-b3852d6dd8e1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5baac865-0067-4e6e-9bb7-b3852d6dd8e1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5baac865-0067-4e6e-9bb7-b3852d6dd8e1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1234&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;

udp_server &lt;/span&gt;= socket(AF_INET,SOCK_DGRAM)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据报&lt;/span&gt;
&lt;span&gt;udp_server.bind(ip_port)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    data,addr &lt;/span&gt;=&lt;span&gt; udp_server.recvfrom(buffer_size)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data)
    udp_server.sendto(data.upper(),addr)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;服务器端&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_dd68a4ea-3850-4f60-99ec-ac96e8c5e27c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dd68a4ea-3850-4f60-99ec-ac96e8c5e27c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dd68a4ea-3850-4f60-99ec-ac96e8c5e27c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;

ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1234&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;

udp_client &lt;/span&gt;= socket(AF_INET, SOCK_DGRAM)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据报&lt;/span&gt;


&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    udp_client.sendto(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),ip_port)

    data,addr &lt;/span&gt;=&lt;span&gt; udp_client.recvfrom(buffer_size)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;客户端&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;时间服务器示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_0bc69d73-7a7c-4dc9-b203-b1be6822df57&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0bc69d73-7a7c-4dc9-b203-b1be6822df57&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0bc69d73-7a7c-4dc9-b203-b1be6822df57&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;时间管理器&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1234&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;

udp_server &lt;/span&gt;= socket(AF_INET,SOCK_DGRAM)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据报&lt;/span&gt;
&lt;span&gt;udp_server.bind(ip_port)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    data,addr &lt;/span&gt;=&lt;span&gt; udp_server.recvfrom(buffer_size)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
        t&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        t&lt;/span&gt;=data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    back_time &lt;/span&gt;=&lt;span&gt; time.strftime(t)
    udp_server.sendto(back_time.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),addr)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ntp_server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_3d543aaf-3f78-44f0-bc58-d59fc3c4053c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3d543aaf-3f78-44f0-bc58-d59fc3c4053c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3d543aaf-3f78-44f0-bc58-d59fc3c4053c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;

ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1234&lt;span&gt;)
buffer_size &lt;/span&gt;= 1024&lt;span&gt;

udp_client &lt;/span&gt;= socket(AF_INET, SOCK_DGRAM)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据报&lt;/span&gt;


&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    udp_client.sendto(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),ip_port)

    data,addr &lt;/span&gt;=&lt;span&gt; udp_client.recvfrom(buffer_size)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ntp_client&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;七、粘包问题&lt;/h2&gt;
&lt;p&gt;让我们基于tcp先编程一个远程执行命令的程序（1：执行错误命令 2：执行ls 3：执行ifconfig）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_73d9a1a2-99fb-49db-bee4-ce8654c4dfcf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_73d9a1a2-99fb-49db-bee4-ce8654c4dfcf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_73d9a1a2-99fb-49db-bee4-ce8654c4dfcf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; subprocess
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; struct
ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)
back_log &lt;/span&gt;= 5&lt;span&gt;
buffer_size &lt;/span&gt;= 1024&lt;span&gt;

 tcp_server &lt;/span&gt;=&lt;span&gt; socket(AF_INET,SOCK_STREAM)
 tcp_server.bind(ip_port)
 tcp_server.listen(back_log)

 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
     conn,addr &lt;/span&gt;=&lt;span&gt; tcp_server.accept()
     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;新客户端链接&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,addr)
     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
         &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;处理客户端断开,服务端继续进行任务,&lt;/span&gt;
             cmd =&lt;span&gt; conn.recv(buffer_size)
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; cmd:&lt;span&gt;break&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;处理quit命令导致的数据为空,导致死循环&lt;/span&gt;
             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;收到客户端的命令&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,cmd)
             &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;执行命令,得到命令的运行结果cmd _res&lt;/span&gt;
             res= subprocess.Popen(cmd.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),shell=&lt;span&gt;True,
                                   stderr&lt;/span&gt;=&lt;span&gt; subprocess.PIPE,
                                   stdout &lt;/span&gt;=&lt;span&gt; subprocess.PIPE,
                                   stdin &lt;/span&gt;=&lt;span&gt; subprocess.PIPE )
             err &lt;/span&gt;=&lt;span&gt;res.stderr.read()
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; err:
                 cmd_res &lt;/span&gt;=&lt;span&gt; err
             &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                 cmd_res &lt;/span&gt;=&lt;span&gt; res.stdout.read()
             &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发&lt;/span&gt;
             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; cmd_res:
                  cmd_res&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
             conn.send(cmd_res)
         &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
             &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
             &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_45cbfc8e-2a82-42b1-960d-488f76b9d023&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_45cbfc8e-2a82-42b1-960d-488f76b9d023&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_45cbfc8e-2a82-42b1-960d-488f76b9d023&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;

ip_port &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)
back_log &lt;/span&gt;= 5&lt;span&gt;
buffer_size &lt;/span&gt;= 1024&lt;span&gt;

 tcp_client&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_STREAM)
 tcp_client.connect(ip_port)

 &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
     cmd &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; cmd:&lt;span&gt;continue&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt; cmd ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
     tcp_client.send(cmd.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
     cmd_res&lt;/span&gt;=&lt;span&gt;tcp_client.recv(buffer_size)
     &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;命令的执行结果是:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,cmd_res.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
 tcp_client.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上述程序是基于tcp的socket，在运行时会发生粘包。&lt;/p&gt;
&lt;p&gt;在基于UDP编程一个远程执行命令的程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_cd206f94-0571-42a1-856d-d78de19e8dab&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cd206f94-0571-42a1-856d-d78de19e8dab&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cd206f94-0571-42a1-856d-d78de19e8dab&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; subprocess

ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9003&lt;span&gt;)
bufsize&lt;/span&gt;=1024&lt;span&gt;

udp_server&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_DGRAM)
udp_server.bind(ip_port)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;收消息&lt;/span&gt;
    cmd,addr=&lt;span&gt;udp_server.recvfrom(bufsize)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户命令-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,cmd)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;逻辑处理&lt;/span&gt;
    res=subprocess.Popen(cmd.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),shell=True,stderr=subprocess.PIPE,stdin=subprocess.PIPE,stdout=&lt;span&gt;subprocess.PIPE)
    stderr&lt;/span&gt;=&lt;span&gt;res.stderr.read()
    stdout&lt;/span&gt;=&lt;span&gt;res.stdout.read()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;发消息&lt;/span&gt;
&lt;span&gt;    udp_server.sendto(stderr,addr)
    udp_server.sendto(stdout,addr)
udp_server.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server_udp&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_62b9ec61-b05b-48c3-be5a-527754010bc3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_62b9ec61-b05b-48c3-be5a-527754010bc3&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_62b9ec61-b05b-48c3-be5a-527754010bc3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,9003&lt;span&gt;)
bufsize&lt;/span&gt;=1024&lt;span&gt;

udp_client&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_DGRAM)


&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    udp_client.sendto(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),ip_port)

    data,addr&lt;/span&gt;=&lt;span&gt;udp_client.recvfrom(bufsize)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),end=&lt;span&gt;''&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client _udp&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上述程序是基于udp的socket，在运行时永远不会发生粘包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么,粘包是怎么造成的?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只有TCP有粘包现象，UDP永远不会粘包，首先需要掌握一个socket收发消息的原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818145238002-111718058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。&lt;/p&gt;
&lt;p&gt;例如基于tcp的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化&lt;a class=&quot;replace_word&quot; title=&quot;算法与数据结构知识库&quot; href=&quot;http://lib.csdn.net/base/datastructure&quot; target=&quot;_blank&quot;&gt;算法&lt;/a&gt;把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。&lt;/li&gt;
&lt;li&gt;UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 &lt;strong&gt;即面向消息的通信是有消息保护边界的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y&amp;gt;x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠&lt;/p&gt;
&lt;p&gt;tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种情况下会发生粘包。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_b5e653e3-c46f-4338-a65e-20d1eff76c87&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b5e653e3-c46f-4338-a65e-20d1eff76c87&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b5e653e3-c46f-4338-a65e-20d1eff76c87&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)

tcp_socket_server&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_STREAM)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(&lt;/span&gt;5&lt;span&gt;)


conn,addr&lt;/span&gt;=&lt;span&gt;tcp_socket_server.accept()


data1&lt;/span&gt;=conn.recv(10&lt;span&gt;)
data2&lt;/span&gt;=conn.recv(10&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data1.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data2.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e4ae9190-26a2-4ad3-b3a3-c2bc1b808727&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e4ae9190-26a2-4ad3-b3a3-c2bc1b808727&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e4ae9190-26a2-4ad3-b3a3-c2bc1b808727&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
BUFSIZE&lt;/span&gt;=1024&lt;span&gt;
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)

s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res&lt;/span&gt;=&lt;span&gt;s.connect_ex(ip_port)


s.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
s.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;feng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_d0868ef5-ce7e-44e6-bd97-bea8332cbe19&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d0868ef5-ce7e-44e6-bd97-bea8332cbe19&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d0868ef5-ce7e-44e6-bd97-bea8332cbe19&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; socket &lt;span&gt;import&lt;/span&gt; *&lt;span&gt;
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)

tcp_socket_server&lt;/span&gt;=&lt;span&gt;socket(AF_INET,SOCK_STREAM)
tcp_socket_server.bind(ip_port)
tcp_socket_server.listen(&lt;/span&gt;5&lt;span&gt;)


conn,addr&lt;/span&gt;=&lt;span&gt;tcp_socket_server.accept()


data1&lt;/span&gt;=conn.recv(2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;一次没有收完整&lt;/span&gt;
data2=conn.recv(10)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;下次收的时候,会先取旧的数据,然后取新的&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data1.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data2.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2d939e3e-e475-4205-af16-d0f08e236f51&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2d939e3e-e475-4205-af16-d0f08e236f51&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2d939e3e-e475-4205-af16-d0f08e236f51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
BUFSIZE&lt;/span&gt;=1024&lt;span&gt;
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)

s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res&lt;/span&gt;=&lt;span&gt;s.connect_ex(ip_port)


s.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello feng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;拆包的发生情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充问题一：为何tcp是可靠传输，udp是不可靠传输&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的&lt;/p&gt;
&lt;p&gt;而udp发送数据，对端是不会返回确认信息的，因此不可靠&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充问题二：send(字节流)和recv(1024)及sendall&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;recv里指定的1024意思是从缓存里一次拿出1024个字节的数据&lt;/p&gt;
&lt;p&gt;send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失.&lt;/p&gt;
&lt;h2&gt;八、粘包的解决方法&lt;/h2&gt;
&lt;p&gt;问题的根源在于，接收端不知道发送端将要传送的字节流的长度，所以解决粘包的方法就是围绕，如何让发送端在发送数据前，把自己将要发送的字节流总大小让接收端知晓，然后接收端来一个死循环接收完所有数据。&lt;/p&gt;
&lt;p&gt;第一种的解决方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_27cff318-e9f7-4c72-b83b-9f6087be5dd9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_27cff318-e9f7-4c72-b83b-9f6087be5dd9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_27cff318-e9f7-4c72-b83b-9f6087be5dd9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket,subprocess
ip_port&lt;/span&gt;=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;)
s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, &lt;/span&gt;1&lt;span&gt;)

s.bind(ip_port)
s.listen(&lt;/span&gt;5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    conn,addr&lt;/span&gt;=&lt;span&gt;s.accept()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,addr)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        msg&lt;/span&gt;=conn.recv(1024&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; msg:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
        res&lt;/span&gt;=subprocess.Popen(msg.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),shell=&lt;span&gt;True,\
                            stdin&lt;/span&gt;=&lt;span&gt;subprocess.PIPE,\
                         stderr&lt;/span&gt;=&lt;span&gt;subprocess.PIPE,\
                         stdout&lt;/span&gt;=&lt;span&gt;subprocess.PIPE)
        err&lt;/span&gt;=&lt;span&gt;res.stderr.read()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; err:
            ret&lt;/span&gt;=&lt;span&gt;err
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            ret&lt;/span&gt;=&lt;span&gt;res.stdout.read()
        data_length&lt;/span&gt;=&lt;span&gt;len(ret)
        conn.send(str(data_length).encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
        data&lt;/span&gt;=conn.recv(1024).decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; data == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;recv_ready&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            conn.sendall(ret)
    conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d76d4d4c-7693-40a2-b9da-f9d171de8cd1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d76d4d4c-7693-40a2-b9da-f9d171de8cd1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d76d4d4c-7693-40a2-b9da-f9d171de8cd1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket,time
s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res&lt;/span&gt;=s.connect_ex((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(msg) == 0:&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; msg == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

    s.send(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    length&lt;/span&gt;=int(s.recv(1024).decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    s.send(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;recv_ready&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.encode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    send_size&lt;/span&gt;=&lt;span&gt;0
    recv_size&lt;/span&gt;=&lt;span&gt;0
    data&lt;/span&gt;=b&lt;span&gt;''&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; recv_size &amp;lt;&lt;span&gt; length:
        data&lt;/span&gt;+=s.recv(1024&lt;span&gt;)
        recv_size&lt;/span&gt;+=&lt;span&gt;len(data)


    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上诉程序，程序的运行速度远快于网络传输速度，所以在发送一段字节前，先用send去发送该字节流长度，这种方式会放大网络延迟带来的性能损耗。&lt;/p&gt;
&lt;p&gt;所以我们可以，为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据&lt;strong&gt;，引用struct模块。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json,struct
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;假设通过客户端上传1T:1073741824000的文件a.txt&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;为避免粘包,必须自定制报头&lt;/span&gt;
header={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1073741824000,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/a/b/c/d/e/a.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;md5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;8f6fbf8347faa4924a76856701edb0f3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;} &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1T数据,文件路径和md5值&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;为了该报头能传送,需要序列化并且转为bytes&lt;/span&gt;
head_bytes=bytes(json.dumps(header),encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;序列化并转成bytes,用于传输&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;为了让客户端知道报头的长度,用struck将报头长度这个数字转成固定长度:4个字节&lt;/span&gt;
head_len_bytes=struct.pack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,len(head_bytes)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这4个字节里只包含了一个数字,该数字是报头的长度&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端开始发送&lt;/span&gt;
conn.send(head_len_bytes) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先发报头的长度,4个bytes&lt;/span&gt;
conn.send(head_bytes) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;再发报头的字节格式&lt;/span&gt;
conn.sendall(文件内容) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;然后发真实内容的字节格式&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;服务端开始接收&lt;/span&gt;
head_len_bytes=s.recv(4) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先收报头4个bytes,得到报头长度的字节格式&lt;/span&gt;
x=struct.unpack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,head_len_bytes)[0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;提取报头的长度&lt;/span&gt;
&lt;span&gt;
head_bytes&lt;/span&gt;=s.recv(x) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;按照报头长度x,收取报头的bytes格式&lt;/span&gt;
header=json.loads(json.dumps(header)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;提取报头&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;最后根据报头的内容提取真实的数据,比如&lt;/span&gt;
real_data_len=s.recv(header[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_size&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
s.recv(real_data_len)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_d5b00828-75df-4cb9-9dfe-212afc4caff5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d5b00828-75df-4cb9-9dfe-212afc4caff5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d5b00828-75df-4cb9-9dfe-212afc4caff5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket,struct,json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; subprocess
phone&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,&lt;/span&gt;1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;就是它，在bind前加&lt;/span&gt;
&lt;span&gt;
phone.bind((&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;))

phone.listen(&lt;/span&gt;5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    conn,addr&lt;/span&gt;=&lt;span&gt;phone.accept()
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        cmd&lt;/span&gt;=conn.recv(1024&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; cmd:&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cmd: %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;cmd)

        res&lt;/span&gt;=subprocess.Popen(cmd.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
                             shell&lt;/span&gt;=&lt;span&gt;True,
                             stdout&lt;/span&gt;=&lt;span&gt;subprocess.PIPE,
                             stderr&lt;/span&gt;=&lt;span&gt;subprocess.PIPE)
        err&lt;/span&gt;=&lt;span&gt;res.stderr.read()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(err)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; err:
            back_msg&lt;/span&gt;=&lt;span&gt;err
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            back_msg&lt;/span&gt;=&lt;span&gt;res.stdout.read()


        conn.send(struct.pack(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,len(back_msg))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先发back_msg的长度&lt;/span&gt;
        conn.sendall(back_msg) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在发真实的内容&lt;/span&gt;
&lt;span&gt;
    conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_f2870e1b-11d8-4e83-9551-dfff8541730d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2870e1b-11d8-4e83-9551-dfff8541730d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2870e1b-11d8-4e83-9551-dfff8541730d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket,time,struct

s&lt;/span&gt;=&lt;span&gt;socket.socket(socket.AF_INET,socket.SOCK_STREAM)
res&lt;/span&gt;=s.connect_ex((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    msg&lt;/span&gt;=input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).strip()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(msg) == 0:&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; msg == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;break&lt;/span&gt;&lt;span&gt;

    s.send(msg.encode(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))



    l&lt;/span&gt;=s.recv(4&lt;span&gt;)
    x&lt;/span&gt;=struct.unpack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,l)[0]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(x),x)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(struct.unpack('I',l))&lt;/span&gt;
    r_s=&lt;span&gt;0
    data&lt;/span&gt;=b&lt;span&gt;''&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; r_s &amp;lt;&lt;span&gt; x:
        r_d&lt;/span&gt;=s.recv(1024&lt;span&gt;)
        data&lt;/span&gt;+=&lt;span&gt;r_d
        r_s&lt;/span&gt;+=&lt;span&gt;len(r_d)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(data.decode('utf-8'))&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(data.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;windows默认gbk编码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;我们可以把报头做成字典，字典里包含将要发送的真实数据的详细信息，然后json序列化，然后用struck将序列化后的数据长度打包成4个字节（4个自己足够用了）&lt;/p&gt;
&lt;p&gt;发送时：先发报头长度，再编码报头内容然后发送，最后发真实内容&lt;/p&gt;
&lt;p&gt;接收时：先手报头长度，用struct取出来，根据取出的长度收取报头内容，然后解码，反序列化，从反序列化的结果中取出待取数据的详细信息，然后去取真实的数据内容&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;九、socketserver实现并发&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环&lt;/p&gt;

&lt;p&gt;socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）&lt;/p&gt;

&lt;p&gt;server类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818150924333-358560026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;request类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818150946604-1904262797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继承关系；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818151007624-2062602896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818151022637-12466425.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1408728/201808/1408728-20180818151048827-1889377213.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下述代码为例，分析socketserver源码：&lt;/p&gt;
&lt;pre&gt;
ftpserver=socketserver.ThreadingTCPServer(('127.0.0.1',8080),FtpServer)&lt;br/&gt;ftpserver.serve_forever()
&lt;/pre&gt;
&lt;p&gt;查找属性的顺序：ThreadingTCPServer-&amp;gt;ThreadingMixIn-&amp;gt;TCPServer-&amp;gt;BaseServer&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例化得到ftpserver，先找类ThreadingTCPServer的__init__,在TCPServer中找到，进而执行server_bind,server_active&lt;/li&gt;
&lt;li&gt;找ftpserver下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中&lt;/li&gt;
&lt;li&gt;执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)&lt;/li&gt;
&lt;li&gt;在ThreadingMixIn中找到process_request，开启多线程应对并发，进而执行process_request_thread，执行self.finish_request(request, client_address)&lt;/li&gt;
&lt;li&gt;上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找__init__方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找....&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;源码分析总结：&lt;/p&gt;
&lt;p&gt;基于tcp的socketserver我们自己定义的类中的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;　　self.server即套接字对象&lt;/li&gt;
&lt;li&gt;　　self.request即一个链接&lt;/li&gt;
&lt;li&gt;　　self.client_address即客户端地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于udp的socketserver我们自己定义的类中的&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b'adsf', &amp;lt;socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=('127.0.0.1', 8080)&amp;gt;)&lt;/li&gt;
&lt;li&gt;self.client_address即客户端地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_7a9ce4b4-3558-48c3-8c30-d44d96bbd3ed&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7a9ce4b4-3558-48c3-8c30-d44d96bbd3ed&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7a9ce4b4-3558-48c3-8c30-d44d96bbd3ed&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socketserver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; struct
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; FtpServer(socketserver.BaseRequestHandler):
    coding&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    server_dir&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_upload&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    max_packet_size&lt;/span&gt;=1024&lt;span&gt;
    BASE_DIR&lt;/span&gt;=os.path.dirname(os.path.abspath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; handle(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.request)
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            data&lt;/span&gt;=self.request.recv(4&lt;span&gt;)
            data_len&lt;/span&gt;=struct.unpack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,data)[0]
            head_json&lt;/span&gt;=&lt;span&gt;self.request.recv(data_len).decode(self.coding)
            head_dic&lt;/span&gt;=&lt;span&gt;json.loads(head_json)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(head_dic)&lt;/span&gt;
            cmd=head_dic[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cmd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; hasattr(self,cmd):
                func&lt;/span&gt;=&lt;span&gt;getattr(self,cmd)
                func(head_dic)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; put(self,args):
        file_path &lt;/span&gt;=&lt;span&gt; os.path.normpath(os.path.join(
            self.BASE_DIR,
            self.server_dir,
            args[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        ))

        filesize &lt;/span&gt;= args[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filesize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        recv_size &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-----&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, file_path)
        with open(file_path, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; recv_size &amp;lt;&lt;span&gt; filesize:
                recv_data &lt;/span&gt;=&lt;span&gt; self.request.recv(self.max_packet_size)
                f.write(recv_data)
                recv_size &lt;/span&gt;+=&lt;span&gt; len(recv_data)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;recvsize:%s filesize:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (recv_size, filesize))


ftpserver&lt;/span&gt;=socketserver.ThreadingTCPServer((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;),FtpServer)
ftpserver.serve_forever()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;server&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_81605e17-fd1c-49bf-bb29-8dc2b2721146&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_81605e17-fd1c-49bf-bb29-8dc2b2721146&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_81605e17-fd1c-49bf-bb29-8dc2b2721146&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; struct
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os



&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MYTCPClient:
    address_family &lt;/span&gt;=&lt;span&gt; socket.AF_INET

    socket_type &lt;/span&gt;=&lt;span&gt; socket.SOCK_STREAM

    allow_reuse_address &lt;/span&gt;=&lt;span&gt; False

    max_packet_size &lt;/span&gt;= 8192&lt;span&gt;

    coding&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

    request_queue_size &lt;/span&gt;= 5

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, server_address, connect=&lt;span&gt;True):
        self.server_address&lt;/span&gt;=&lt;span&gt;server_address
        self.socket &lt;/span&gt;=&lt;span&gt; socket.socket(self.address_family,
                                    self.socket_type)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; connect:
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
                self.client_connect()
            &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
                self.client_close()
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; client_connect(self):
        self.socket.connect(self.server_address)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; client_close(self):
        self.socket.close()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            inp&lt;/span&gt;=input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; inp:&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
            l&lt;/span&gt;=&lt;span&gt;inp.split()
            cmd&lt;/span&gt;=&lt;span&gt;l[0]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; hasattr(self,cmd):
                func&lt;/span&gt;=&lt;span&gt;getattr(self,cmd)
                func(l)


    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; put(self,args):
        cmd&lt;/span&gt;=&lt;span&gt;args[0]
        filename&lt;/span&gt;=args[1&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.isfile(filename):
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file:%s is not exists&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;filename)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            filesize&lt;/span&gt;=&lt;span&gt;os.path.getsize(filename)

        head_dic&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cmd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:cmd,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filename&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:os.path.basename(filename),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filesize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:filesize}
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(head_dic)
        head_json&lt;/span&gt;=&lt;span&gt;json.dumps(head_dic)
        head_json_bytes&lt;/span&gt;=bytes(head_json,encoding=&lt;span&gt;self.coding)

        head_struct&lt;/span&gt;=struct.pack(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,len(head_json_bytes))
        self.socket.send(head_struct)
        self.socket.send(head_json_bytes)
        send_size&lt;/span&gt;=&lt;span&gt;0
        with open(filename,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
                self.socket.send(line)
                send_size&lt;/span&gt;+=&lt;span&gt;len(line)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(send_size)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;upload successful&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)




client&lt;/span&gt;=MYTCPClient((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,8080&lt;span&gt;))

client.run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;client&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 18 Aug 2018 07:04:00 +0000</pubDate>
<dc:creator>菜鸟小于</dc:creator>
<og:description>一、客户端/服务器架构 1.硬件C/S架构(打印机) 2.软件C/S架构 互联网中处处是C/S架构 如购物网站是服务端，你的浏览器是客户端（B/S架构也是C/S架构的一种） 腾讯作为服务端为你提供视频</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Young111/p/9497354.html</dc:identifier>
</item>
<item>
<title>我写代码很厉害吗？那都是同行的衬托。 - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/9497257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/9497257.html</guid>
<description>&lt;p&gt;代码水平是一个有趣的事，衡量别人的水平很有趣，衡量自己的水平也很有趣。&lt;/p&gt;
&lt;p&gt;现在虽然说[有趣]，但回想起来，其实也是一把辛酸史。&lt;/p&gt;
&lt;p&gt;2008年我刚毕业，那一年，是金融危机爆发的一年，也许也是年景不好，工作都特别难找，连网吧网管都有抢的。&lt;/p&gt;
&lt;p&gt;当时的我，虽然学习成绩在年级不是最好的，但实践能力还是很有自信的。所以满怀着希望，就进入了这个社会。结果，社会狠狠给了我一棒子。&lt;/p&gt;
&lt;p&gt;找工作嘛，毕业生无非是网络应聘和招聘会赶场。可看了成百上千的软件岗位，居然发现个奇怪的事。用人单位要求会的东西，我一样也不会。那也硬着头皮尝试投简历，结果自然除了没有回音，就只剩被叫去面试并被当面羞辱两种结果。&lt;/p&gt;
&lt;p&gt;经过毕业前半年的努力尝试，终于领悟了，原来在学校学过的技术都没有用。不止学的肤浅，而且学的技术过时。我这种水平的毕业生，除了培训机构想骗我的钱以外，不会有任何用人单位对我有想法。所以，我只能端正态度，从一切可赚钱的工作做起。&lt;/p&gt;
&lt;p&gt;换工作，换工作，换工作。。。。然后在每个夜晚攻读C#相关技术，神奇的活了一年。&lt;/p&gt;
&lt;p&gt;然后，终于有机会做真正软件工作了。&lt;/p&gt;
&lt;p&gt;因为曾经是面试中的失败者，所以本着谦虚和学习的态度，来到了软件行业。因为，我知道自学一年和人家工作一年的水平是不能比的。用人单位肯给我这样的机会，就很难得了。所以，既然来到了软件行业，自然要加倍勤奋。&lt;/p&gt;
&lt;p&gt;再然后，奇怪的事发生了。&lt;/p&gt;
&lt;p&gt;八九年工作经验，只会dedecms做网站的。（估计是转行的）。&lt;/p&gt;
&lt;p&gt;高薪本科，硕士生，语法不熟练。&lt;/p&gt;
&lt;p&gt;做了一年DIV+CSS切图，依然能写出反人类的HTML的。&lt;/p&gt;
&lt;p&gt;用工具生成的Table嵌套的反人类HTML页面，被老板认为实力强劲的前端。&lt;/p&gt;
&lt;p&gt;工作三年不知道HTML是什么东西的后台开发。&lt;/p&gt;
&lt;p&gt;一群能将一个小时工作做成八个小时的勤劳开发者。&lt;/p&gt;
&lt;p&gt;一群八个小时也做不出一个小时工作的资深软件工程师。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/243596/201808/243596-20180818142353633-2076860039.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;至少有五年的时间，我都难以释怀。为什么用人单位肯要这群人，而不用我。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/243596/201808/243596-20180818142422863-1757231825.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时间可以改变一切，时间也可以让人习惯一切。&lt;/p&gt;
&lt;p&gt;最初，那些十年八年工作经验的资深开发来问我这两三年经验的菜鸟要如何编程时，总很不习惯和疑惑。&lt;/p&gt;
&lt;p&gt;开始以为他们很懒，总把工作推给别人。但经过长时间接触后，终于发现，他们只是很烂。&lt;/p&gt;
&lt;p&gt;我不明白的事很多，为什么他们能应聘成功，为什么他们工资那么高。很多为什么。&lt;/p&gt;
&lt;p&gt;时间有时候不会给予你答案，但时间会告诉你，答案不重要。&lt;/p&gt;
&lt;p&gt;渐渐的，我不在疑惑了，我认知到了事实，我确实比他们写代码要厉害，不是一些，而是很多。&lt;/p&gt;
&lt;p&gt;渐渐的，我不在去关注和比较他们的人生，我只要走好自己的路即可。因为他们不是我该比较的对象，即便他们比我的工资更高。&lt;/p&gt;
&lt;p&gt;渐渐的，我发现自己写代码真的很厉害，而且今后还会更厉害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以大多数人的努力程度,根本轮不到拼天赋&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为这些鸡汤，让我很不自信。&lt;/p&gt;
&lt;p&gt;因为我并不能算勤奋，我浪费了太多时间。&lt;/p&gt;
&lt;p&gt;但事实是，同行比我更懒惰。&lt;strong&gt;以同行的懒惰程度，足以让我脱颖而出。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以不能被鸡汤吓退，还是要自信的生活。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;注：此文章为原创，欢迎转载，请在文章页面明显位置给出此文链接！&lt;br/&gt;若您觉得这篇文章还不错，请点击下右下角的&lt;span&gt;【&lt;strong&gt;推荐】&lt;/strong&gt;&lt;/span&gt;，非常感谢！&lt;/p&gt;

</description>
<pubDate>Sat, 18 Aug 2018 06:32:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<og:description>代码水平是一个有趣的事，衡量别人的水平很有趣，衡量自己的水平也很有趣。 现在虽然说[有趣]，但回想起来，其实也是一把辛酸史。 2008年我刚毕业，那一年，是金融危机爆发的一年，也许也是年景不好，工作都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kiba/p/9497257.html</dc:identifier>
</item>
<item>
<title>基于双向链表实现无锁队列的正确姿势(对之前博客中错误的修正) - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9496856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9496856.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;1. 前言&lt;/h2&gt;
&lt;p&gt;如果你认真看过我前几天写的这篇博客&lt;a href=&quot;https://www.cnblogs.com/takumicx/p/9456874.html&quot;&gt;自己动手构建无锁的并发容器(栈和队列)&lt;/a&gt;的队列部分,那么我要向你表示道歉。因为在实现队列的出队方法时我犯了一个低级错误:队列的出队方向是在队列头部,而我的实现是在队列尾部。尽管代码能够正确执行,但明显不符合队列规范。所以那部分代码写作&quot;基于双向链表的无锁队列&quot;其实读作“基于双向链表的无锁栈”。当然,“队列是从一端入队而从另一端出队的,在一边进出的那是栈”这种常识我肯定是有的,至于为什么会犯这种低级错误思来想去只能归咎于连续高温导致的倦怠。前段时间的我,就好像一只被困在土里的非洲肺鱼,人生的全部意义都在等待雨季的来临。最近,久违的雨水带来了些许凉意,也冲走了这种精神上的疲倦,趁这个机会要好好纠正下以前的错误。代码见github上&lt;a href=&quot;https://github.com/takumiCX/beautiful-concurrent&quot;&gt;beautiful-concurrent&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于双向链表实现的无锁队列&quot;&gt;2. 基于双向链表实现的无锁队列&lt;/h2&gt;
&lt;p&gt;链表节点的定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 链表节点的定义
 * @param &amp;lt;E&amp;gt;
 */
private static class Node&amp;lt;E&amp;gt; {

    //指向前一个节点的指针
    public volatile Node pre;

    //指向后一个结点的指针
    public volatile Node next;

    //真正要存储在队列中的值
    public E item;

    public Node(E item) {
        this.item = item;
    }

    @Override
    public String toString() {
        return &quot;Node{&quot; +
                &quot;item=&quot; + item +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于双向链表实现无锁队列时,结点指针不需要被原子的更新,只需要用volatile修饰保证可见性。&lt;/p&gt;
&lt;h3 id=&quot;入队方法&quot;&gt;2.1 入队方法&lt;/h3&gt;
&lt;p&gt;首先还是来看下队列的入队方法,这部分代码参考了Doug Lea在AQS中对线程加入同步队列这部分逻辑的实现,所以正确性是没有问题的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 将元素加入队列尾部
 *
 * @param e 要入队的元素
 * @return true:入队成功 false:入队失败
 */
public boolean enqueue(E e) {

    //创建一个包含入队元素的新结点
    Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(e);
    //死循环
    for (; ; ) {
        //记录当前尾结点
        Node&amp;lt;E&amp;gt; taild = tail.get();
        //当前尾结点为null,说明队列为空
        if (taild == null) {
            //CAS方式更新队列头指针
            if (head.compareAndSet(null, newNode)) {
                //非同步方式更新尾指针
                tail.set(newNode);
                return true;
            }

        } else {

            //新结点的pre指针指向原尾结点
            newNode.pre = taild;
            //CAS方式将尾指针指向新的结点
            if (tail.compareAndSet(taild, newNode)) {
                //非同步方式使原尾结点的next指针指向新加入结点
                taild.next = newNode;
                return true;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里分了两种情况来讨论,队列为空和队列不为空,通过队列尾指针所指向的元素进行判断：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;1.队列为空:队列尾指针指向的结点为null,这部分逻辑在if分句中&lt;br/&gt;首先以CAS方式更新队列头指针指向新插入的结点,若执行成功则以非同步的方式将尾指针也指向该结点,结点入队成功;若CAS更新头指针失败则要重新执行for循环,整个过程如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818124321713-653531994.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2.队列不为空:队列尾指针指向的结点不为null。则分三步实现入队逻辑,整个过程如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818123255125-571189113.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;仅考虑入队情形,整个过程是线程安全,尽管有些步骤没有进行同步。我们分队列为空和不为空两种情况来进行论证:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.队列为空时,执行流程将进入if分句,假设某线程执行&lt;code&gt;head.compareAndSet(null, newNode)&lt;/code&gt;更新头指针的操作成功,那么&lt;code&gt;tail.set(newNode)&lt;/code&gt;这句不管其何时执行,其他线程将因为tail为null只能进入该if分句中,并且更新头指针的CAS操作必然失败,因为此时head已经不为null。所以仅就入队情形而言,队列为空时的操作是线程安全的。&lt;/li&gt;
&lt;li&gt;2.队列不为空时,只要更新尾指针的CAS操作即&lt;code&gt;tail.compareAndSet(taild, newNode)&lt;/code&gt;执行成功,那么此时结点已经成功加入队列,&lt;code&gt;taild.next = newNode;&lt;/code&gt;这步何时执行仅就入队的情形而言没有任何关系(但是会影响出队的逻辑实现,这里先卖个关子)。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;出队方法&quot;&gt;2.2 出队方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; /**
     * 将队列首元素从队列中移除并返回该元素,若队列为空则返回null
     *
     * @return
     */
    public E dequeue() {

        //死循环
        for (; ; ) {
            //当前头结点
            Node&amp;lt;E&amp;gt; tailed = tail.get();
            //当前尾结点
            Node&amp;lt;E&amp;gt; headed = head.get();

            if (tailed == null) { //尾结点为null,说明队列为空,直接返回null
                 return null;

            } else if (headed == tailed) { //尾结点和头结点相同,说明队列中只有一个元素,此时要更新头尾指针
                //CAS方式更新尾指针为null
                if (tail.compareAndSet(tailed, null)) {
                    //头指针更新为null
                    head.set(null);
                    return headed.item;
                }

            } else {
                //走到这一步说明队列中元素结点的个数大于1,只要更新队列头指针指向原头结点的下一个结点就行
                //但是要注意头结点的下一个结点可能为null,所以要先确保新的队列头结点不为null

                //队列头结点的下一个结点
                Node headedNext = headed.next;
                if (headedNext != null &amp;amp;&amp;amp; head.compareAndSet(headed, headedNext))
                    headedNext.pre=null;  //help gc
                    return headed.item;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出队的逻辑实现主要分三种情况讨论:队列为空,队列中刚好一个元素结点和队列中元素结点个数大于1。&lt;br/&gt;其实上次代码中出错的部分主要是队列中结点个数大于1这种情况,而其他两种情况不管从哪边出队操作都是一样的。下面就分情况讨论下出队实现中需要注意的点&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;1.队列为空,判断标准是tail即尾指针是否指向null,因为入队的时候就是以tail指针来判断队列状态的,所以这里要保持一致性,哪怕空队列的入队过程中头指针已经成功指向新结点但没来得及更新尾指针,此时出队也就会返回null。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;2.队列中刚好只有一个元素:头尾指针刚好指向同一个结点。首先以CAS方式更新尾指针指向null,执行成功再以正常方式设置头指针为null,这么做会有并发问题吗？考虑这种极端情形:刚好CAS更新尾指针为null然后失去了CPU执行权,如下图所示:&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818123313422-1267509503.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分两种情况讨论：&lt;br/&gt;1.出队情形&lt;br/&gt;因为tail已经为null,程序会判断队列为空,所以之后执行出队的线程将返回null&lt;br/&gt;2.入队情形&lt;br/&gt;因为tail为null,所以执行入队逻辑的线程会进入if分句,因为此时head不为null,所以执行图示的CAS操作时会失败并不断自旋&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818123336645-1184184144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上所示,队列中恰好只有一个元素结点的出队逻辑是线程安全的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3.队列中元素结点的个数大于1&lt;br/&gt;这时候只要将头指针以CAS方式更新为头结点的下一个结点就行了,但是要注意在这之前要执行&lt;br/&gt;&lt;code&gt;headedNext != null&lt;/code&gt;确保头结点的下一个结点不为null。你可能会问:等等,执行这部分代码的前提是队列中元素结点的个数至少为2,那么头结点的下一个结点肯定不为null啊。如果只考虑出队的情况,这么想没错,但是此时可能处于队列入队的中间状态,如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818123347112-180079211.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如上图所示,队列中有3个元素结点,但是负责第二个结点入队的线程已经成功执行尾指针的更新操作但没来得及更新前一个节点的next指针便失去了CPU执行权,回想下入队的流程,其实这种情况是可能存在并且允许的。如果此时没有通过&lt;code&gt;headedNext != null&lt;/code&gt;进行判断便更新head指针指向头结点的下一个结点,那么就会出现下面这种情况&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818123359094-284855532.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时出队线程还是会执行最后一个else分句这部分代码,虽然此时队列不为空,但head指向了null,对其执行CAS更新操作将会抛出空指针异常,看来我们上次对head指针的更新操作太草率了,没有考虑到头结点的next指针可能为null这种入队操作导致的特殊情况。所以在对head指针进行CAS更新前要获得所记录头结点的下一个结点headedNext,并通过&lt;code&gt;headedNext !=null&lt;/code&gt;保证更新后的头结点不为null。如果这种情况发生,出队线程将通过自旋等待,直到造成这种情况的入队线程成功执行&lt;br/&gt;&lt;code&gt;taild.next = newNode;&lt;/code&gt;,此时当前出队线程的出队过程才能执行成功,并正确设置头指针指向原队列头结点的下一个结点。&lt;/p&gt;
&lt;p&gt;完整的代码见github&lt;a href=&quot;https://github.com/takumiCX/beautiful-concurrent&quot;&gt;beautiful-concurrent&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;3. 性能测试&lt;/h2&gt;
&lt;p&gt;开启200个线程,每个线程混合进行10000次入队和出队操作,将上述流程重复进行100次统计出执行的平均时间(毫秒),完整的测试代码已经放到github上&lt;a href=&quot;https://github.com/takumiCX/beautiful-concurrent&quot;&gt;beautiful-concurrent&lt;/a&gt;。测试结果如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201808/1422237-20180818123413481-1764677854.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后的测试结果真是出人意料。修复原来的队列在一端进出的bug后,性能竟然也有了很大的提高。基于双向链表实现的无锁队列LockFreeLinkedQueue在并发环境下的性能排在了第二位,超出了我们自己实现的基于单向链的无锁队列LockFreeSingleLinkedQueue很多,甚至接近于ConcurrentLinkedQueue的表现,要知道后者实现比我们的复杂了很多,经过了很多优化。原来的错误实现因为出队和入队在一端进行,所以平白无故增加了不必要的CSA竞争,导致并发性能降低这个好理解;那为什么比基于单向链表的队列表现还要好。毕竟后者没有prev指针,少了很多指针操作。关于这点,可能是因为单向链表实现时的CAS竞争过多,导致对CPU的有效利用率不高。而双向链表因其结构的特殊性,反而一定程度减少了CAS竞争。所以这也是个教训,如果能保证线程安全,尽量不要使用任何同步操作,如果不得不进行同步,那么越轻量级越好,volatile就比CAS&quot;轻&quot;得多。在拓宽下思路,如果我们对其进行类似于ConcurrentLinkedQueue的优化,比如不需要每次入队都更新队列尾指针,性能是否还会有飞跃,甚至超出ConcurrentLinkedQueue本身？这可能是个有意思的尝试,先挖个坑好了,以后有时间再填。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4.总结&lt;/h2&gt;
&lt;p&gt;这篇文章是对前面文章错误的修正,之所以独立成篇也是希望那些原来被我&quot;误导&quot;过的同学更有机会看到。这次对队列的出队过程进行了详细的图文分析,而没有像上次那样偷懒,只讲了个大概,不然也不会出现&quot;队列在一端进出&quot;这种低级错误,不知道上篇文章被人踩了一脚是不是这个原因,如果能在发现错误的时候在下面留言给我指出来就太感谢了。毕竟写技术博客的好处在于不仅是系统梳理技术知识自我提高的过程,也是一个和他人分享讨论共同进步的过程。而这一过程不仅需要作者自己努力,也需要读者共同参与。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 06:32:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<og:description>[TOC] 1. 前言 如果你认真看过我前几天写的这篇博客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9496856.html</dc:identifier>
</item>
<item>
<title>事务锁 - 舒碧</title>
<link>http://www.cnblogs.com/bibi-feiniaoyuan/p/9494308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bibi-feiniaoyuan/p/9494308.html</guid>
<description>&lt;h3&gt;引发思考&lt;/h3&gt;
&lt;p&gt;今天，发现开发项目中的单号重复了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994461/201808/994461-20180817162823801-727032763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是多用户并发操作相同数据导致的结果。有点抽象，理解如下：实际就是多个事务交叉执行&lt;span&gt;（增、删、查、改）&lt;/span&gt;了相同数据。导致一个事务不具有完整性了，数据库的数据也不一致了&lt;span&gt;（这里‘’一致‘’可以理解为：我希望的数据，跟我想像的不一样，比如明明我刚update某表性别为男，我update完它还是女的，如果别人要修改，也得等我update完再改呀！咦，统计男生的总人数的确是加1了，见鬼了）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994461/201808/994461-20180817165448008-1495632172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;并发操作数据的不利影响&lt;/h3&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-280&quot;&gt;多个用户试图修改其他用户&lt;span data-ttu-id=&quot;0bfc8-280&quot;&gt;正在使用的资源时&lt;span&gt;总是会产生负面影响。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;（这里用户可以理解成事务，用户这个词组总是在不同场合出现，例如redis客户端用户，b/s模式客户端用户，这些情况其实可以广泛理解为请求）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-280&quot;&gt;&lt;span&gt;更新丢失&lt;/span&gt;：A事务里更新某些数据，A还没结束运行。这段时间，&lt;span&gt;B插足&lt;/span&gt;一脚，也更新了那些数据，&lt;span&gt;覆盖了A刚更新完的&lt;/span&gt;，A白更了。一段时间后，A正常结束了，A丢失了更新的数据。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-286&quot;&gt;&lt;span&gt;脏读&lt;/span&gt;：B正在修改某些数据，还没结束运行。这段时间A去读那些数据，但&lt;span&gt;读的不是B修改之后的，而是B修改之前的&lt;/span&gt;。一段时间后，B正常结束了，A读的数据还是旧数据。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-280&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-289&quot;&gt;&lt;span&gt;不可重复读&lt;/span&gt;：9点钟，A在读某部分数据。9点半，B修改了那部分数据，B结束运行了。10点钟&lt;span&gt;，A又回头读那部分数据&lt;/span&gt;，发现数据和9点钟的不一样。A读的是同一部分，却返回不一样的数据。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;幻读&lt;/span&gt;：9点钟A根据条件取了一个结果集看看，还没结束运行。9点半，B删除了那个结果集部分行数据，又新增了部分行数据。10点，A根据相同条件取结果集，&lt;span&gt;发现新增了部分，删除了部分，刚刚是在做梦吧？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总而言之，一旦小三插足干坏事，我就完了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;事务锁&lt;/h3&gt;
&lt;p&gt;针对上面的问题，可以使用事务锁解决。&lt;span&gt;（事务锁是一种悲观的解决方案&lt;span&gt;，&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-267&quot;&gt;每个事务里&lt;span&gt;可能涉及行数据、页数据、表数据&lt;/span&gt;、，这数据相等事务依赖的资源，&lt;span&gt;当请求操作这些资源，可以请求不同类型的锁&lt;/span&gt;。 该&lt;span data-ttu-id=&quot;0bfc8-268&quot;&gt;锁可以&lt;span&gt;阻止其他事务&lt;/span&gt;以错误方式操作该资源。 &lt;span data-ttu-id=&quot;0bfc8-269&quot;&gt;&lt;span&gt;当事务不再依赖锁定的资源时，它将释放锁&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单说，这些数据可以被上锁、上锁后，其他事务对该数据的操做就有限制了，不是你想改就能改，你想读就读。我锁是大爷，我允许，你就能操作；我若不许，你就滚出去！&lt;/p&gt;

&lt;p&gt;锁粒度： &lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;SQL Server具有多种粒度锁定，例如行粒度、表粒度、数据库粒度......&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;如果在较小的粒度（例如行）加锁，可以提高并发度，因为对其他事务限制范围小，只是开销较高，锁定了多少行，则需要多少锁。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;比如A事务拿到了某行数据的某锁，该限制了其他事务对该行数据的操作，但是其他事务不一定要操作该行，也是就1两个事务需要操作改行，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;如果&lt;span data-ttu-id=&quot;0bfc8-467&quot;&gt;在较大的粒度（例如表）加锁，则会降低并发度，因为锁定整个表&lt;span&gt;限制了其他事务对表中任意部分的访问&lt;/span&gt;。 &lt;span data-ttu-id=&quot;0bfc8-468&quot;&gt;但开销较低，因为需要维护的锁较少。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-467&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-468&quot;&gt;锁类型：共享锁、排他锁等。锁与锁之间是可以冲突的。比如A事务拿到了某行数据的共享锁，说明A事务结束之前，该行数据都不能被其他事务修改&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-467&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-468&quot;&gt;（增、删、改）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-467&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-468&quot;&gt;但是其他事务可以读改行数据。其他&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;事务永远都不能拿到该行数据的排他锁，排他锁的作用是独自占据数据的增、删、改操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-ttu-id=&quot;0bfc8-464&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-465&quot;&gt;&lt;span data-ttu-id=&quot;4c1c2-101&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-466&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-467&quot;&gt;&lt;span data-ttu-id=&quot;0bfc8-468&quot;&gt;这篇文章不过抛转引玉罢了，官方的就很齐全了 &lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-2017&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-2017&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 18 Aug 2018 06:11:00 +0000</pubDate>
<dc:creator>舒碧</dc:creator>
<og:description>引发思考 今天，发现开发项目中的单号重复了。 这是多用户并发操作相同数据导致的结果。有点抽象，理解如下：实际就是多个事务交叉执行（增、删、查、改）了相同数据。导致一个事务不具有完整性了，数据库的数据也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bibi-feiniaoyuan/p/9494308.html</dc:identifier>
</item>
<item>
<title>【原创】Innodb中mysql如何快速删除2T的大表 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9497109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9497109.html</guid>
<description>&lt;h3 id=&quot;小漫画&quot;&gt;小漫画&lt;/h3&gt;
&lt;p&gt;来，先来看小漫画陶冶一下情操&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_manhua1.jpg&quot;/&gt;&lt;br/&gt;OK，这里就说了。假设，你有一个表&lt;code&gt;erp&lt;/code&gt;,如果你直接进行下面的命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;drop table erp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候所有的mysql的相关进程都会停止，直到&lt;code&gt;drop&lt;/code&gt;结束，mysql才会恢复执行。出现这个情况的原因就是因为，在&lt;code&gt;drop table&lt;/code&gt;的时候，&lt;code&gt;innodb&lt;/code&gt;维护了一个全局锁，&lt;code&gt;drop&lt;/code&gt;完毕锁就释放了。&lt;br/&gt;这意味着，如果在白天，访问量非常大的时候，如果你在不做任何处理措施的情况下，执行了删大表的命令，整个&lt;code&gt;mysql&lt;/code&gt;就挂在那了，在删表期间，&lt;code&gt;QPS&lt;/code&gt;会严重下滑，然后产品经理就来找你喝茶了。所以才有了漫画中的一幕，&lt;strong&gt;你可以在晚上十二点，夜深人静的时候再删&lt;/strong&gt;。&lt;br/&gt;当然，有的人不服，可能会说：&quot;&lt;strong&gt;你可以写一个删除表的存储过程，在晚上没啥访问量的时候运行一次就行。&lt;/strong&gt;&quot;&lt;br/&gt;我内心一惊，细想一下，只能说：&quot;大家还是别抬杠了，还是听我说一下业内通用做法。&quot;&lt;/p&gt;
&lt;h3 id=&quot;一个假设&quot;&gt;一个假设&lt;/h3&gt;
&lt;p&gt;先说明一下，在这里有一个前提，mysql开启了&lt;strong&gt;独立表空间&lt;/strong&gt;，MySQL5.6.7之后默认开启。&lt;br/&gt;也就是在&lt;code&gt;my.cnf&lt;/code&gt;中，有这么一条配置(这些是属于mysql优化的知识，后期给大家介绍)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;innodb_file_per_table = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看表空间状态，用下面的命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show variables like '%per_table';  
+-----------------------+-------+  
| Variable_name         | Value |  
+-----------------------+-------+  
| innodb_file_per_table | OFF   |  
+-----------------------+-------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;innodb_file_per_table&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;值为&lt;code&gt;OFF&lt;/code&gt;，代表采用的是&lt;strong&gt;共享表空间&lt;/strong&gt;。&lt;br/&gt;如果&lt;code&gt;innodb_file_per_table&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;值为&lt;code&gt;ON&lt;/code&gt; ，代表采用的是&lt;strong&gt;独立表空间&lt;/strong&gt;。&lt;br/&gt;于是，大家要问我，&lt;strong&gt;独立表空间&lt;/strong&gt;和&lt;strong&gt;共享表空间&lt;/strong&gt;的区别？&lt;br/&gt;&lt;strong&gt;共享表空间&lt;/strong&gt;：某一个数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在data目录下。 默认的文件名为:ibdata1(此文件，可以扩展成多个)。&lt;strong&gt;注意&lt;/strong&gt;，在这种方式下，运维超级不方便。你看，所有数据都在一个文件里，要对单表维护，十分不方便。另外，你在做&lt;code&gt;delete&lt;/code&gt;操作的时候，文件内会留下很多间隙，ibdata1文件不会自动收缩。换句话说，使用&lt;strong&gt;共享表空间&lt;/strong&gt;来存储数据，会遭遇&lt;code&gt;drop table&lt;/code&gt;之后，空间无法释放的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;独立表空间&lt;/strong&gt;:每一个表都以独立方式来部署，每个表都有一个.frm表描述文件，还有一个.ibd文件。&lt;br/&gt;&lt;strong&gt;.frm文件：&lt;/strong&gt;保存了每个表的元数据，包括表结构的定义等，该文件与数据库引擎无关。&lt;br/&gt;&lt;strong&gt;.ibd文件：&lt;/strong&gt;保存了每个表的数据和索引的文件。&lt;br/&gt;&lt;strong&gt;注意&lt;/strong&gt;，在这种方式下，每个表都有自已独立的表空间，这样运维起来方便，可以实现单表在不同数据库之间的移动。另外，在执行&lt;code&gt;drop table&lt;/code&gt;操作的时候，是可以自动回收表空间。在执行&lt;code&gt;delete&lt;/code&gt;操作后，可以通过&lt;code&gt;alter table TableName engine=innodb&lt;/code&gt;可以整理碎片，回收部分表空间。&lt;/p&gt;
&lt;p&gt;ps：&lt;code&gt;my.cnf&lt;/code&gt;中的&lt;code&gt;datadir&lt;/code&gt;就是用来设置数据存储目录&lt;/p&gt;
&lt;p&gt;好了，上面巴拉巴拉了一大堆，我只想说一个&lt;strong&gt;事情&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在绝大部分情况下，运维一定会为mysql选择独立表空间的存储方式，因为采用独立表空间的方式，从性能优化和运维难易角度来说，实在强太多。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，我在一开始所提到的前提，mysql需要开启&lt;strong&gt;独立表空间&lt;/strong&gt;。这个假设，百分九十的情况下是成立的。如果真的遇到了，你们公司的mysql采用的是&lt;strong&gt;共享表空间&lt;/strong&gt;的情况，请你和你们家的运维谈谈心，问问为啥用&lt;strong&gt;共享表空间&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;正确姿势&quot;&gt;正确姿势&lt;/h3&gt;
&lt;p&gt;假设，我们有&lt;code&gt;datadir = /data/mysql/&lt;/code&gt;,另外，我们有有一个&lt;code&gt;database&lt;/code&gt;,名为&lt;code&gt;mytest&lt;/code&gt;。在数据库&lt;code&gt;mytest&lt;/code&gt;中，有一个表，名为&lt;code&gt;erp&lt;/code&gt;，执行下列命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; system ls -l /data/mysql/mytest/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到下面的输出(我过滤了一下)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-rw-r----- 1 mysql mysql          9023  8 18 05:21 erp.frm
-rw-r----- 1 mysql mysql 2356792000512  8 18 05:21 erp.ibd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;frm&lt;/code&gt;和&lt;code&gt;ibd&lt;/code&gt;的作用，上面介绍过了。现在就是&lt;code&gt;erp.ibd&lt;/code&gt;文件太大，所以删除卡住了。&lt;br/&gt;&lt;strong&gt;如何解决这个问题呢？&lt;/strong&gt;&lt;br/&gt;这里需要利用了linux中&lt;strong&gt;硬链接&lt;/strong&gt;的知识，来进行快速删除。下面容我上《鸟哥的私房菜》中的一些内容，&lt;br/&gt;&lt;strong&gt;软链接&lt;/strong&gt;其实大家可以类比理解为windows中的快捷方式，就不多介绍了，主要介绍一下硬链接。&lt;br/&gt;至于这个&lt;strong&gt;硬链接&lt;/strong&gt;，我简单说一下，不想贴一大堆话过来，看起来太累。&lt;br/&gt;就是对于真正存储的文件来说，有一个&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_pg1.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;然后呢有一个&lt;code&gt;文件名&lt;/code&gt;指向上面的&lt;code&gt;node Index&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_pg2.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;那么，所谓的&lt;strong&gt;硬链接&lt;/strong&gt;，就是不止一个&lt;code&gt;文件名&lt;/code&gt;指向&lt;code&gt;node Index&lt;/code&gt;，有好几个&lt;code&gt;文件名&lt;/code&gt;指向&lt;code&gt;node Index&lt;/code&gt;。&lt;br/&gt;假设，这会又有一个&lt;code&gt;文件名&lt;/code&gt;指向上面的&lt;code&gt;node Index&lt;/code&gt;，即&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_pg3.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;这个时候，你做了删除&lt;code&gt;文件名(1)&lt;/code&gt;的操作，linux系统检测到，还有一个&lt;code&gt;文件名(2)&lt;/code&gt;指向&lt;code&gt;node Index&lt;/code&gt;，因此并不会真正的把文件删了，而是把&lt;code&gt;步骤(2)&lt;/code&gt;的引用给删了，这步操作非常快，毕竟只是删除引用。于是图就变成了这样&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_pg4.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;接下来，你再做删除&lt;code&gt;文件名(2)&lt;/code&gt;的操作，linux系统检测到，没有其他&lt;code&gt;文件名&lt;/code&gt;指向该&lt;code&gt;node Index&lt;/code&gt;，就会删除真正的存储文件，这步操作，是删真正的文件，所以比较慢。&lt;/p&gt;
&lt;p&gt;OK，我们用的就是上面的原理。&lt;br/&gt;先给&lt;code&gt;erp.ibd&lt;/code&gt;建立一个硬链接，利用&lt;code&gt;ln&lt;/code&gt;命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; system ln /data/mysql/mytest/erp.ibd /data/mysql/mytest/erp.ibd.hdlk &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，文件目录如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-rw-r----- 1 mysql mysql          9023  8 18 05:21 erp.frm
-rw-r----- 2 mysql mysql 2356792000512  8 18 05:21 erp.ibd
-rw-r----- 2 mysql mysql 2356792000512  8 18 05:21 erp.ibd.hdlk &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现，多了一个&lt;code&gt;erp.ibd.hdlk&lt;/code&gt;文件，且&lt;code&gt;erp.ibd&lt;/code&gt;和&lt;code&gt;erp.ibd.hdlk&lt;/code&gt;的inode均为2。&lt;br/&gt;此时，你执行&lt;code&gt;drop table&lt;/code&gt;操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; drop table erp;
Query OK, 0 rows affected (0.99 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现，不到1秒就删除了。因为，此时有两个文件名称(&lt;code&gt;erp.ibd&lt;/code&gt;和&lt;code&gt;erp.ibd.hdlk&lt;/code&gt;),同时指向一个inode.这个时候，执行删除操作，只是把引用给删了，所以非常快。&lt;br/&gt;那么，这时的删除，已经把table从mysql中删除。但是磁盘空间，还没释放，因为还剩一个文件&lt;code&gt;erp.ibd.hdlk&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;如何正确的删除&lt;code&gt;erp.ibd.hdlk&lt;/code&gt;呢？&lt;/strong&gt;&lt;br/&gt;如果你没啥经验，一定会回答我，用&lt;code&gt;rm&lt;/code&gt;命令来删。这里需要说明的是，在生产环境，直接用&lt;code&gt;rm&lt;/code&gt;命令来删大文件，会造成磁盘IO开销飙升,CPU负载过高，是会影响其他程序运行的。&lt;br/&gt;那么，这种时候，就是应该用&lt;code&gt;truncate&lt;/code&gt;命令来删，&lt;code&gt;truncate&lt;/code&gt;命令在&lt;code&gt;coreutils&lt;/code&gt;工具集中。&lt;br/&gt;详情，大家可以去百度一下，有人对&lt;code&gt;rm&lt;/code&gt;和&lt;code&gt;truncate&lt;/code&gt;命令，专程测试过，&lt;code&gt;truncate&lt;/code&gt;命令对磁盘&lt;code&gt;IO，CPU&lt;/code&gt;负载几乎无影响。&lt;br/&gt;删除脚本如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TRUNCATE=/usr/local/bin/truncate
for i in `seq 2194 -10 10 `; 
do 
  sleep 2
  $TRUNCATE -s ${i}G /data/mysql/mytest/erp.ibd.hdlk 
done
rm -rf /data/mysql/mytest/erp.ibd.hdlk ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从2194G开始，每次缩减10G，停2秒，继续，直到文件只剩10G，最后使用&lt;code&gt;rm&lt;/code&gt;命令删除剩余的部分。&lt;/p&gt;
&lt;h3 id=&quot;其他情况&quot;&gt;其他情况&lt;/h3&gt;
&lt;p&gt;这里指的是，如果数据库是部署在windows上怎么办。这个问题，我来回答，其实不够专业。因为我出道以来，还没碰到过，生产环境上，mysql是部在windows上的。假设真的碰到了，windows下有一个工具叫&lt;code&gt;mklink&lt;/code&gt;，是在windows下创建硬链接锁用，应该能完成类似功能&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文所讲的内容，中小型公司的研发比较容易遇到。因为中小型公司没有专业的DBA，研发童鞋啥都得干。希望大家有所收获吧。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 06:03:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<og:description>小漫画 来，先来看小漫画陶冶一下情操 OK，这里就说了。假设，你有一个表 ,如果你直接进行下面的命令 这个时候所有的mysql的相关进程都会停止，直到 结束，mysql才会恢复执行。出现这个情况的原因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9497109.html</dc:identifier>
</item>
<item>
<title>Splay Tree——动机和宏观策略 - 仪式黑刃</title>
<link>http://www.cnblogs.com/hongshijie/p/9497088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshijie/p/9497088.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;之前我们谈论过&lt;span lang=&quot;zh-CN&quot;&gt;AVL&lt;span lang=&quot;zh-CN&quot;&gt;树，这是一种典型适度平衡的二叉搜索树，成立条件是保持平衡因子在&lt;span lang=&quot;en-US&quot;&gt;[-1,1]的范围内&lt;span lang=&quot;zh-CN&quot;&gt;，这个条件已经是针对理想平衡做出的一个妥协了，但依然显得过于苛刻，因为在很多时候我们需要频繁的做重平衡操作，能不能改进一下，让失衡先积累着，然后等到某个时机，一下子全部解决呢？严谨一点来说就是我们能否秉持一种更为宽松的准则，同时又从长远、整体的角度来看，依然不失某种意义上的平衡性呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;根据写作套路，那肯定就是点题了。。。对！就是伸展树了，他的出现是因为有人注意到了在信息处理过程中的&lt;span lang=&quot;en-US&quot;&gt;“&lt;span lang=&quot;zh-CN&quot;&gt;局部性&lt;span lang=&quot;en-US&quot;&gt;”&lt;span lang=&quot;zh-CN&quot;&gt;，就是刚被访问过的数据，极有可能很快的被再次访问到，针对特性大做文章，就能切中肯綮了，这也是下面我们要分析的细节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在二叉搜索树里也时常遇到，主要是两种情况：&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;每次刚刚访问过的某一个节点有可能很快的会再次被我们访问到&lt;/li&gt;
&lt;li&gt;下次访问的节点即便不是刚访问过的那个节点，也不会离得太远&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过此前的学习我们已经知道，对于AVL树而 每一次查找所需的时间都是logn，因此任意的连续m次查找，所需要的累积时间就是mlogn，为了改进，就针对这个局部性来做一做文章吧：先来看一个例子，然后类比推理即可。链表里越靠近表头的节点的查找速度越快，遍历所走的步数少嘛，那么如果数据访问有局部性，我们就——访问一个元素后立即把他移动到最前端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132539684-743094579.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这样做的逻辑是：根据局部性，接下来将要访问的元素很可能就是刚访问的那个元素，而这个元素就在最前端，头部元素的访问是访问是唾手可得的，走一步就到了。从整个数据结构的生命周期而言，这样一个列表结构即便最初是完全随机分布的，在经过了足够长时间的使用之后，在某一段时间内被集中访问的元素都会集中到这个列表的前端去。我们已经知道这个区域（列表前段部分）的访问效率是相应更高的，那就能有更高的访问效率了。&lt;/p&gt;

&lt;p&gt;现在回到二叉树，为了对比就让树横过来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132618082-1590022112.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;树的顶部元素访问效率更高，所以我们要参照列表，把经常要访问到的元素尽可能的移送到接近树根的位置，也就是要尽可能的降低他们的深度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132647587-292944193.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们就这么办：某个元素一经访问，就把它移到树根处。具体做法就是把被访问元素不断做旋转操作直到抵达树根，这样的策略被称为“逐层伸展”，是一种朴素的想法，但是不够好，因为在最坏情况下树退化为一条单链，我们来个极端的，每次恶意访问最深的节点，就会变成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132707720-284943192.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;先注意一下特征：每层只挂了一个节点，这是弊端所在，后面还会提到。然后经过一轮询问，这个树就&lt;span lang=&quot;en-US&quot;&gt;复原了&lt;span lang=&quot;zh-CN&quot;&gt;。看一下整个过程（竖着看）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132725312-1121202075.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们分析一下这一轮操作的代价：假设树的规模是&lt;span lang=&quot;en-US&quot;&gt;n&lt;span lang=&quot;zh-CN&quot;&gt;，访问&lt;span lang=&quot;en-US&quot;&gt;第一个最深节点的成本是n&lt;span lang=&quot;zh-CN&quot;&gt;，第二个节点&lt;span lang=&quot;en-US&quot;&gt;是n-1&lt;span lang=&quot;zh-CN&quot;&gt;，第三个是&lt;span lang=&quot;en-US&quot;&gt;n-2&lt;span lang=&quot;zh-CN&quot;&gt;，然后是&lt;span lang=&quot;en-US&quot;&gt;n-3&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;n-4和最终的1&lt;span lang=&quot;zh-CN&quot;&gt;。整个成本按算术级数增长，这就很恐怖了，总体时间O（N&lt;sup&gt;2&lt;/sup&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;），分摊到整个周期的&lt;span lang=&quot;en-US&quot;&gt;n次操作&lt;span lang=&quot;zh-CN&quot;&gt;，复杂度Ω(&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;N)&lt;span lang=&quot;zh-CN&quot;&gt;居高不下，和AVL树的&lt;span lang=&quot;en-US&quot;&gt;logn相差甚远&lt;span lang=&quot;zh-CN&quot;&gt;，这已经沦落到了线性序列的地步。另外还有一个弊端在于：我们需要为此考虑很多种特殊情况。所以这个策略无法让人满意。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们还要另找方法——在初始访问路径上进行一些神奇的旋转，只用了O（&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;）的空间，而且保持O（log&lt;span lang=&quot;en-US&quot;&gt;N&lt;span lang=&quot;zh-CN&quot;&gt;）&lt;span lang=&quot;en-US&quot;&gt;的时间复杂度&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;具体而言就是：双层伸展，向上追溯两层，通过两次旋转把被访问节点&lt;span lang=&quot;en-US&quot;&gt;上移至祖父的位置&lt;span lang=&quot;zh-CN&quot;&gt;，而且！不是像之前一样自下而上伸展，而是自顶向下进行伸展。这可以说是Splay&lt;span lang=&quot;en-US&quot;&gt;Tree的点睛之笔&lt;span lang=&quot;zh-CN&quot;&gt;。这是在&lt;span lang=&quot;en-US&quot;&gt;1985年Tarjan大神的一篇论文&lt;span lang=&quot;zh-CN&quot;&gt;《&lt;span lang=&quot;zh-CN&quot;&gt;Self-adjusting binary search trees&lt;span lang=&quot;zh-CN&quot;&gt;》&lt;span lang=&quot;en-US&quot;&gt;里提出来的&lt;span lang=&quot;zh-CN&quot;&gt;（和他有关的还有一个Tarjan算法，是关于图的连通性的神奇算法）。他们的相对位置无非四种：之字型两种，一字型两种。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132753030-1673258048.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 子孙异侧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先从这个情况说起，从难啃的骨头开始。有些书上会把这种情况称为“之字形”，以此为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132814048-630269976.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;“这特么不就是双旋转么，而且这也就是逐层伸展两次而已，没什么实质区别啊（摔）”，的确是这样，这个部分区别不大。但重点在于另外这条龙一只眼睛才是闪光之处。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;子孙同侧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;有些书上也称为“一字形”。&lt;span lang=&quot;en-US&quot;&gt;我们先看一下逐层伸展的调整过程&lt;span lang=&quot;zh-CN&quot;&gt;，然后和T&lt;span lang=&quot;en-US&quot;&gt;arjan的策略作一比较&lt;span lang=&quot;zh-CN&quot;&gt;，就知道差距有多大了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818132905700-311867004.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;168&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是我们凡人想到的方法。下面是Tarjan的点睛之笔：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818133056307-2003209111.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这里的重中之重是：需要首先越级，从祖父而不是父节点来开始旋转，具体来说就是，经过祖父节点的一次左&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;左旋转，节点&lt;span lang=&quot;zh-CN&quot;&gt;p&lt;span lang=&quot;zh-CN&quot;&gt;以及&lt;span lang=&quot;zh-CN&quot;&gt;v&lt;span lang=&quot;zh-CN&quot;&gt;都会上升一层。接下来对新的树根也就是&lt;span lang=&quot;zh-CN&quot;&gt;p&lt;span lang=&quot;zh-CN&quot;&gt;，再做一次左&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;左旋转，把v拉上来成为树根，Done。把这两种方法作一对比，&lt;span lang=&quot;en-US&quot;&gt;emmm好像没什么大差别啊&lt;span lang=&quot;zh-CN&quot;&gt;，是吧？的确这里面的神奇之处一时半会难以察觉，看起来反正都是提高了两层倍，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;毕竟在局部拓扑结构上还是有微妙的差异，更重要的是——这种局部的微妙差异将导致全局的不同，而且那种不同将是根本性的、颠覆性的！Splay树在这个伸展方式的革命中失去的只是锁链，他们获得的将是整个世界。&lt;/p&gt;

&lt;p&gt;现在来看看这个差异所带来的利好。如果用这种方式我们再来访问最深的节点，会有什么改进呢？ &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818133205139-347239917.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;现在的改进在于每一层能挂更多的节点了，这就是有效控制树高的一个方法。之前说的逐层伸展最坏情况之所以“坏”是因为，尽管能调整到树根，但是在这个过程中树的高度会以算术级数的速度急剧膨胀，这是一种不计后果的方法，所以很坏。而T&lt;span lang=&quot;en-US&quot;&gt;arjan的方法优越性在于&lt;span lang=&quot;zh-CN&quot;&gt;，在每次即使访问最深的节点时候，也能控制树高，渐进意义上是之前逐层伸展树高的一半，记得前面说的“会导致全局的不同”么，就是这里的树高缩减一半！这个特性太好了，节点越多，访问次数越多，这个控制的效果越明显，这也被称为Splay&lt;span lang=&quot;en-US&quot;&gt;Tree的折叠效果&lt;span lang=&quot;zh-CN&quot;&gt;。那么总结一下双层伸展的核心优势——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818133301879-943994522.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;337&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;通过这个例子可以看出：任何一个节点经过访问，再经双层调整后，这个节点所在的路径长度就会减半。甚至可以说&lt;span lang=&quot;zh-CN&quot;&gt;——&lt;span lang=&quot;zh-CN&quot;&gt;这种效果具有某种意义上的智能：既然在一棵&lt;span lang=&quot;zh-CN&quot;&gt;BST&lt;span lang=&quot;zh-CN&quot;&gt;中非常忌讳访问很深的节点（这会导致复杂度急剧上升），那这种折叠效果自然就会具有对坏节点的修复作用，我们就不必担心了。犹如含羞草一旦感受到威胁，就会通过迅速收缩，将自己的弱点隐藏起来。因此在采用&lt;span lang=&quot;zh-CN&quot;&gt;Tarjan&lt;span lang=&quot;zh-CN&quot;&gt;所建议的这种新的策略之后，刚才所举的那种最坏情况就不至持续的发生，可以证明的是单次操作的时间上界是O（log&lt;span lang=&quot;en-US&quot;&gt;N&lt;span lang=&quot;zh-CN&quot;&gt;）。这&lt;span lang=&quot;en-US&quot;&gt;也就是说&lt;span lang=&quot;zh-CN&quot;&gt;！&lt;span lang=&quot;en-US&quot;&gt;我们现在不仅足以应对此前涉及的最坏情况&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;而且也不会有任何其他的最坏情况&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;这是一个再好不过的消息了&lt;span lang=&quot;zh-CN&quot;&gt;，简直让人开心到爆炸啊！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;为了控制篇幅，也考虑到注意力的问题，具体的实现放在下一篇文章，因为那将会涉及到很多指针调整，需要集中精力，看到这里想必注意力消耗的差不多了，再看下去就容易跑神，具体的实现步骤相比上面的清谈要更耗费心力，因为我们要和细节打交道了。&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 05:34:00 +0000</pubDate>
<dc:creator>仪式黑刃</dc:creator>
<og:description>之前我们谈论过AVL树，这是一种典型适度平衡的二叉搜索树，成立条件是保持平衡因子在[-1,1]的范围内，这个条件已经是针对理想平衡做出的一个妥协了，但依然显得过于苛刻，因为在很多时候我们需要频繁的做重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongshijie/p/9497088.html</dc:identifier>
</item>
<item>
<title>八、单链表的实现 - 小胖鼠</title>
<link>http://www.cnblogs.com/chenke1731/p/9496703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenke1731/p/9496703.html</guid>
<description>&lt;h3 id=&quot;链式存储结构线性表的实现&quot;&gt;1、链式存储结构线性表的实现：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372866/201808/1372866-20180818114509308-815816144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkList&lt;/code&gt;设计要点：类模板&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过头结点访问后继节点&lt;/li&gt;
&lt;li&gt;定义内部结点类型Node，用于描述数据域和指针域&lt;/li&gt;
&lt;li&gt;实现线性表的关键操作（增、删、改、查等）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;linklist&quot;&gt;2、LinkList&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class LinkList : public List&amp;lt;T&amp;gt;
{
protected:
    struct Node : public Object 
    {
        T value;
        Node* next;
    };
    
    Node m_header;
    int m_length;
    
public:
    LinkList() {}
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class LinkList : public List&amp;lt;T&amp;gt;
{
protected:
    struct Node : public Object
    {
        T value;    // 数据域
        Node* next; // 指针域
    };

    mutable Node m_header;  // 头结点
    int m_length;   // 记录链表长度

public:
    LinkList()
    {
        m_header.next = NULL;
        m_length = 0;
    }
    
    // 链表末尾插入元素
    bool insert(const T&amp;amp; e)
    {
        return insert(m_length, e);
    }
    // 指定位置插入元素
    bool insert(int i, const T&amp;amp; e)
    {
        // 注意i的范围
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;=m_length));
        cout &amp;lt;&amp;lt; &quot;ret  = &quot; &amp;lt;&amp;lt; ret &amp;lt;&amp;lt;  endl;
        if (ret)
        {
            Node* node = new Node();
            if (node != NULL)
            {
                // current的目标指向其实都是目标位置的前一个，比如：在第0个位置增加元素，current指向的是header
                Node* current = &amp;amp;m_header;
                for(int p = 0; p &amp;lt; i; p++)
                {
                    current = current-&amp;gt;next;
                }
                node-&amp;gt;value = e;
                node-&amp;gt;next = current-&amp;gt;next;
                current-&amp;gt;next = node;

                m_length++;
            }
            else
            {
                cout &amp;lt;&amp;lt; &quot;THROW_EXCEPTION&quot; &amp;lt;&amp;lt; endl;
                THROW_EXCEPTION(NoEnoughMemoryException, &quot;No memory to insert new element&quot;);
            }
        }

        return ret;
    }
    // 删除指定位置元素
    bool remove(int i)
    {
        // 注意i的范围
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
        if (ret)
        {
            Node* current = &amp;amp;m_header;
            for(int p = 0; p &amp;lt; i; p++)
            {
                current = current-&amp;gt;next;
            }

            Node* toDel = current-&amp;gt;next;
            current-&amp;gt;next = toDel-&amp;gt;next;

            delete toDel;
            m_length--;
        }
        return ret;
    }
    // 设定指定位置的元素
    bool set(int i, const T&amp;amp; e)
    {
        // 注意i的范围
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
        if (ret)
        {
            Node* current = &amp;amp;m_header;
            for(int p = 0; p &amp;lt; i; p++)
            {
                current = current-&amp;gt;next;
            }
            current-&amp;gt;next-&amp;gt;value = e;
        }
        return ret;
    }
    // get函数用起来不方便，重载一下
    T get(int i) const
    {
        T ret;
        if (get(i, ret))
        {
            return ret;
        }
        else
        {
            THROW_EXCEPTION(IndexOutOfBoundsException, &quot;Invalid parameter i to get element...&quot;);
        }
    }
    // 获取指定位置的元素
    bool get(int i, T&amp;amp; e) const
    {
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
        if (ret)
        {
            Node* current = &amp;amp;m_header;
            for(int p = 0; p &amp;lt; i; p++)
            {
                current = current-&amp;gt;next;
            }

            e = current-&amp;gt;next-&amp;gt;value;
            // get是const成员函数，按理来说不能修改成员变量的值，Node* current=&amp;amp;m_header，会被误认为要更改成员变量的值，故报错
            // 解决方案是对m_header加上mutable，开一个例外
        }

        return ret;
    }
    int length() const
    {
        return m_length;
    }
    void clear()
    {
        // 释放每一个结点
        while(m_header.next)
        {
            Node* toDel = m_header.next;
            m_header.next = toDel-&amp;gt;next;
            delete toDel;
        }
        m_length = 0;
    }
    ~LinkList()
    {
        clear();
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题：头结点隐患，实现代码优化&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;m_header&lt;/code&gt;时，会调用&lt;code&gt;T value&lt;/code&gt;，用泛指类型创建头结点的数据域，当泛指类型为用户自定义类型时，用用户自定义的类类型在库中创建对象，就有可能出错了，而且在外部看来，并没有用该类型创建对象，问题定位很麻烦。&lt;/p&gt;
&lt;p&gt;解决办法：构造头结点时，不调用泛指类型创建头结点，而是按内存分布自己重建构造一个类对象，注意一定要和以前的头结点的内存分布一样，不仅是成员变量的内存大小，同样也要和以前一样继承于&lt;code&gt;Object&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 直接创建头结点，存在隐患
mutable Node m_header;

// 重新构造之后的头结点
mutable struct : public Object
{
    char reserved[sizeof(T)];   // 没实际作用，占空间
    Node* next;
} m_header;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新构造后的头结点在内存布局上和之前没有差异，差异在于不管泛指类型是什么，都不会去调用泛指类型的构造函数了。虽然它们在内存布局上是一样的，但是新构造的头结点是个空类型，不能直接用，使用时要进行类型转换&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Node* ret = reinterpret_cast&amp;lt;Node*&amp;gt;(&amp;amp;m_header);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优化后的完整代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;
template &amp;lt;typename T&amp;gt;
class LinkList : public List&amp;lt;T&amp;gt;
{
protected:
    struct Node : public Object
    {
        T value;    // 数据域
        Node* next; // 指针域
    };
    // 重新构造头结点
    mutable struct : public Object
    {
        char reserved[sizeof(T)];   // 没实际作用，占空间
        Node* next;
    } m_header;

    int m_length;   // 记录链表长度
    
    // 位置定位函数，重复使用，进行抽象，方便使用
    Node* position(int i) const
    {
        Node* ret = reinterpret_cast&amp;lt;Node*&amp;gt;(&amp;amp;m_header);
        for(int p = 0; p &amp;lt; i; p++)
        {
            ret = ret-&amp;gt;next;
        }
        return ret;
    }

public:
    LinkList()
    {
        m_header.next = NULL;
        m_length = 0;
    }

    bool insert(const T&amp;amp; e)
    {
        return insert(m_length, e);
    }
    
    bool insert(int i, const T&amp;amp; e)
    {
        // 注意i的范围
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;=m_length));
        cout &amp;lt;&amp;lt; &quot;ret  = &quot; &amp;lt;&amp;lt; ret &amp;lt;&amp;lt;  endl;
        if (ret)
        {
            Node* node = new Node();
            if (node != NULL)
            {
                Node* current = position(i);
                node-&amp;gt;value = e;
                node-&amp;gt;next = current-&amp;gt;next;
                current-&amp;gt;next = node;
                m_length++;
            }
            else
            {
                THROW_EXCEPTION(NoEnoughMemoryException, &quot;No memory to insert new element&quot;);
            }
        }
        return ret;
    }

    bool remove(int i)
    {
        // 注意i的范围
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
        if (ret)
        {
            Node* current = position(i);
            Node* toDel = current-&amp;gt;next;
            current-&amp;gt;next = toDel-&amp;gt;next;
            delete toDel;
            m_length--;
        }
        return ret;
    }
    bool set(int i, const T&amp;amp; e)
    {
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
        if (ret)
        {
            position(i)-&amp;gt;next-&amp;gt;value = e;
        }
        return ret;
    }
    // get函数用起来不方便，重载一下
    T get(int i) const
    {
        T ret;
        if (get(i, ret))
        {
            return ret;
        }
        else
        {
            THROW_EXCEPTION(IndexOutOfBoundsException, &quot;Invalid parameter i to get element...&quot;);
        }
    }

    bool get(int i, T&amp;amp; e) const
    {
        bool ret = ((i&amp;gt;=0) &amp;amp;&amp;amp; (i&amp;lt;m_length));
        if (ret)
        {
            e = position(i)-&amp;gt;next-&amp;gt;value;
        }
        return ret;
    }
    
    int length() const
    {
        return m_length;
    }
    
    void clear()
    {
        // 释放每一个结点
        while(m_header.next)
        {
            Node* toDel = m_header.next;
            m_header.next = toDel-&amp;gt;next;
            delete toDel;
        }
        m_length = 0;
    }
    
    ~LinkList()
    {
        clear();
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意每次代码修改之后都要进行测试，有可能由于修改的代码引入了新的bug&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;3、小结&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;通过类模板实现链表，包含头结点和长度成员&lt;/p&gt;
&lt;p&gt;定义结点类型，并通过堆中的结点对象构成链式存储&lt;/p&gt;
&lt;p&gt;为了避免构造错误的隐患，头结点类型需要重定义&lt;/p&gt;
&lt;p&gt;代码优化是编码完成后必不可少的环节&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 18 Aug 2018 03:46:00 +0000</pubDate>
<dc:creator>小胖鼠</dc:creator>
<og:description>1、链式存储结构线性表的实现： 设计要点：类模板 通过头结点访问后继节点 定义内部结点类型Node，用于描述数据域和指针域 实现线性表的关键操作（增、删、改、查等） 2、LinkList 具体实现 问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenke1731/p/9496703.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——Controller - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9496297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9496297.html</guid>
<description>&lt;p&gt;在理清&lt;a href=&quot;https://www.cnblogs.com/kenwoo/p/9484499.html&quot;&gt;路由&lt;/a&gt;的工作流程后，接下来需要考虑的，是MVC框架如何生成Controller以及它的生成时机。&lt;/p&gt;
&lt;p&gt;根据以前ASP.NET MVC的经验，Controller应该是由一个ControllerFactory构建的。查看ASP.NET Core MVC的源码，果然是有一个DefaultControllerFactory类，并且不出意外的，它拥有一个CreateController方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual object CreateController(ControllerContext context)
{
    ...

    var controller = _controllerActivator.Create(context);
    foreach (var propertyActivator in _propertyActivators)
    {
        propertyActivator.Activate(context, controller);
    }

    return controller;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但细推其使用的场合，只出现在ControllerFactoryProvider的构造方法内部，且仅是用于判断所传入的controllerFactory类型是否是DefaultControllerFactory。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ControllerFactoryProvider(
    IControllerActivatorProvider activatorProvider,
    IControllerFactory controllerFactory,
    IEnumerable&amp;lt;IControllerPropertyActivator&amp;gt; propertyActivators)
{
    ...

    _activatorProvider = activatorProvider;

    // Compat: Delegate to the IControllerFactory if it's not the default implementation.
    if (controllerFactory.GetType() != typeof(DefaultControllerFactory))
    {
        _factoryCreateController = controllerFactory.CreateController;
        _factoryReleaseController = controllerFactory.ReleaseController;
    }

    _propertyActivators = propertyActivators.ToArray();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看ControllerFactoryProvider内部的CreateControllerFactory方法。这更像是一个真正创建Controller的工厂方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Func&amp;lt;ControllerContext, object&amp;gt; CreateControllerFactory(ControllerActionDescriptor descriptor)
{
    ...

    if (_factoryCreateController != null)
    {
        return _factoryCreateController;
    }

    var controllerActivator = _activatorProvider.CreateActivator(descriptor);
    var propertyActivators = GetPropertiesToActivate(descriptor);
    object CreateController(ControllerContext controllerContext)
    {
        var controller = controllerActivator(controllerContext);
        for (var i = 0; i &amp;lt; propertyActivators.Length; i++)
        {
            var propertyActivator = propertyActivators[i];
            propertyActivator(controllerContext, controller);
        }

        return controller;
    }

    return CreateController;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建方式分为两种，一种是使用自定义的工厂方法，另一种是通过ControllerActivatorProvider的CreateActivator方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Func&amp;lt;ControllerContext, object&amp;gt; CreateActivator(ControllerActionDescriptor descriptor)
{
    ...

    var controllerType = descriptor.ControllerTypeInfo?.AsType();
    ...

    if (_controllerActivatorCreate != null)
    {
        return _controllerActivatorCreate;
    }

    var typeActivator = ActivatorUtilities.CreateFactory(controllerType, Type.EmptyTypes);
    return controllerContext =&amp;gt; typeActivator(controllerContext.HttpContext.RequestServices, arguments: null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;明白了如何创建Controller，下面开始调查创建Controller的时机。&lt;/p&gt;
&lt;p&gt;ControllerFactoryProvider类的CreateControllerFactory方法是被ControllerActionInvokerCache类的GetCachedResult方法调用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public (ControllerActionInvokerCacheEntry cacheEntry, IFilterMetadata[] filters) GetCachedResult(ControllerContext controllerContext)
{
    var cache = CurrentCache;
    var actionDescriptor = controllerContext.ActionDescriptor;

    IFilterMetadata[] filters;
    if (!cache.Entries.TryGetValue(actionDescriptor, out var cacheEntry))
    {
        var filterFactoryResult = FilterFactory.GetAllFilters(_filterProviders, controllerContext);
        filters = filterFactoryResult.Filters;

        var parameterDefaultValues = ParameterDefaultValues
            .GetParameterDefaultValues(actionDescriptor.MethodInfo);

        var objectMethodExecutor = ObjectMethodExecutor.Create(
            actionDescriptor.MethodInfo,
            actionDescriptor.ControllerTypeInfo,
            parameterDefaultValues);

        var controllerFactory = _controllerFactoryProvider.CreateControllerFactory(actionDescriptor);
        var controllerReleaser = _controllerFactoryProvider.CreateControllerReleaser(actionDescriptor);
        var propertyBinderFactory = ControllerBinderDelegateProvider.CreateBinderDelegate(
            _parameterBinder,
            _modelBinderFactory,
            _modelMetadataProvider,
            actionDescriptor);

        var actionMethodExecutor = ActionMethodExecutor.GetExecutor(objectMethodExecutor);

        cacheEntry = new ControllerActionInvokerCacheEntry(
            filterFactoryResult.CacheableFilters, 
            controllerFactory, 
            controllerReleaser,
            propertyBinderFactory,
            objectMethodExecutor,
            actionMethodExecutor);
        cacheEntry = cache.Entries.GetOrAdd(actionDescriptor, cacheEntry);
    }
    else
    {
        // Filter instances from statically defined filter descriptors + from filter providers
        filters = FilterFactory.CreateUncachedFilters(_filterProviders, controllerContext, cacheEntry.CachedFilters);
    }

    return (cacheEntry, filters);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其值作为ControllerActionInvokerCacheEntry对象的一部分被方法返回。&lt;/p&gt;
&lt;p&gt;GetCachedResult方法的上层调用者是ControllerActionInvokerProvider类的OnProvidersExecuting方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void OnProvidersExecuting(ActionInvokerProviderContext context)
{
    ...

    if (context.ActionContext.ActionDescriptor is ControllerActionDescriptor)
    {
        var controllerContext = new ControllerContext(context.ActionContext);
        // PERF: These are rarely going to be changed, so let's go copy-on-write.
        controllerContext.ValueProviderFactories = new CopyOnWriteList&amp;lt;IValueProviderFactory&amp;gt;(_valueProviderFactories);
        controllerContext.ModelState.MaxAllowedErrors = _maxModelValidationErrors;

        var cacheResult = _controllerActionInvokerCache.GetCachedResult(controllerContext);

        var invoker = new ControllerActionInvoker(
            _logger,
            _diagnosticSource,
            controllerContext,
            cacheResult.cacheEntry,
            cacheResult.filters);

        context.Result = invoker;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ControllerActionInvokerCacheEntry对象又被作为ControllerActionInvoker对象的一部分为ActionInvokerProviderContext的Result属性赋值。&lt;/p&gt;
&lt;p&gt;再往上跟踪，到了ActionInvokerFactory类的CreateInvoker方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IActionInvoker CreateInvoker(ActionContext actionContext)
{
    var context = new ActionInvokerProviderContext(actionContext);

    foreach (var provider in _actionInvokerProviders)
    {
        provider.OnProvidersExecuting(context);
    }

    for (var i = _actionInvokerProviders.Length - 1; i &amp;gt;= 0; i--)
    {
        _actionInvokerProviders[i].OnProvidersExecuted(context);
    }

    return context.Result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而它的调用者便是MvcRouteHandler或者MvcAttributeRouteHandler。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Task RouteAsync(RouteContext context)
{
    ...

    context.Handler = (c) =&amp;gt;
    {
        var routeData = c.GetRouteData();

        var actionContext = new ActionContext(context.HttpContext, routeData, actionDescriptor);
        if (_actionContextAccessor != null)
        {
            _actionContextAccessor.ActionContext = actionContext;
        }

        var invoker = _actionInvokerFactory.CreateInvoker(actionContext);
        if (invoker == null)
        {
            throw new InvalidOperationException(
                Resources.FormatActionInvokerFactory_CouldNotCreateInvoker(
                    actionDescriptor.DisplayName));
        }

        return invoker.InvokeAsync();
    };

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里创建Controller的工厂方法还没有被实际调用，此时Controller还是不存在的。所以还需要完成执行ControllerActionInvoker的InvokeAsync方法，或者更准确地说是其基类ResourceInvoker的InvokeAsync方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task InvokeAsync()
{
    try
    {
        ...

        using (_logger.ActionScope(_actionContext.ActionDescriptor))
        {
            ...

            try
            {
                await InvokeFilterPipelineAsync();
            }
            ...
        }
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从InvokeFilterPipelineAsync方法开始，一系列的处理流程将依据不同状态逐步展开。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private async Task InvokeFilterPipelineAsync()
{
    var next = State.InvokeBegin;

    var scope = Scope.Invoker;

    var state = (object)null;

    var isCompleted = false;

    while (!isCompleted)
    {
        await Next(ref next, ref scope, ref state, ref isCompleted);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而到了State.ActionBegin这一步(ControllerActionInvoker类的Next方法)，终于能找到Controller工厂方法被执行的场合。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private Task Next(ref State next, ref Scope scope, ref object state, ref bool isCompleted)
{
    switch (next)
    {
        case State.ActionBegin:
            {
                var controllerContext = _controllerContext;

                _cursor.Reset();

                _instance = _cacheEntry.ControllerFactory(controllerContext);

                _arguments = new Dictionary&amp;lt;string, object&amp;gt;(StringComparer.OrdinalIgnoreCase);

                var task = BindArgumentsAsync();
                if (task.Status != TaskStatus.RanToCompletion)
                {
                    next = State.ActionNext;
                    return task;
                }

                goto case State.ActionNext;
            }
        ...
        }            
    }
}            &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后以一张流程图总结上面的探寻过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180818110443668-870153822.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 03:06:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>在理清</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9496297.html</dc:identifier>
</item>
<item>
<title>[Abp 源码分析]十三、多语言(本地化)处理 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/9496490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/9496490.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;0.简介&lt;/h2&gt;
&lt;p&gt;如果你所开发的需要走向世界的话，那么肯定需要针对每一个用户进行不同的本地化处理，有可能你的客户在日本，需要使用日语作为显示文本，也有可能你的客户在美国，需要使用英语作为显示文本。如果你还是一样的写死错误信息，或者描述信息，那么就无法做到多语言适配。&lt;/p&gt;
&lt;p&gt;Abp 框架本身提供了一套多语言机制来帮助我们实现本地化，基本思路是 Abp 本身维护一个键值对集合。只需要将展示给客户的文字信息处都使用一个语言 Key 来进行填充，当用户登录系统之后，会取得当前用户的区域文化信息进行文本渲染。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818104823350-790124107.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;0.1 如何使用&lt;/h3&gt;
&lt;p&gt;我们首先来看一下如何定义一个多语言资源并使用。首先 Abp 自身支持三种类型的本地化资源来源，第一种是 XML 文件，第二种则是 JSON 文件，第三种则是内嵌资源文件，如果这三种都不能满足你的需求，你可以自行实现 &lt;code&gt;ILocalizationSource &lt;/code&gt; 接口来返回多语言资源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;小提示：&lt;/p&gt;
&lt;p&gt;Abp Zero 模块就提供了数据库持久化存储多语言资源的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;定义应用程序支持的语言&quot;&gt;0.1.1 定义应用程序支持的语言&lt;/h4&gt;
&lt;p&gt;如果你需要为你的应用程序添加不同语言的支持，就必须在你任意模块的预加载方法当中添加语言来进行配置：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Configuration.Localization.Languages.Add(new LanguageInfo(&quot;en&quot;, &quot;English&quot;, &quot;famfamfam-flag-england&quot;, true));
Configuration.Localization.Languages.Add(new LanguageInfo(&quot;tr&quot;, &quot;Türkçe&quot;, &quot;famfamfam-flag-tr&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如以上代码，就能够让我们的程序拥有针对英语与土耳其语的多语言处理能力。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;famfamfam-flag-england&lt;/code&gt; 与 &lt;code&gt;famfamfam-flag-tr&lt;/code&gt; 是一个 CSS 类型，是 Abp 为前端展示所封装的小国旗图标。&lt;/p&gt;
&lt;h4 id=&quot;建立多语言资源文件&quot;&gt;0.1.2 建立多语言资源文件&lt;/h4&gt;
&lt;p&gt;有了语言之后，Abp 还需要你提供标准的多语言资源文件，这里我们以 自带的 XML 资源文件为例，其文件名称为 &lt;strong&gt;Abp-zh-Hans.xml&lt;/strong&gt; ，路径为 &lt;code&gt;Abp\Localization\Sources\AbpXmlSource&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;localizationDictionary culture=&quot;zh-Hans&quot;&amp;gt;
  &amp;lt;texts&amp;gt;
    &amp;lt;text name=&quot;SmtpHost&quot;&amp;gt;SMTP主机&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;SmtpPort&quot;&amp;gt;SMTP端口&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;Username&quot;&amp;gt;用户名&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;Password&quot;&amp;gt;密码&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DomainName&quot;&amp;gt;域名&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;UseSSL&quot;&amp;gt;使用SSL&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;UseDefaultCredentials&quot;&amp;gt;使用默认验证&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DefaultFromSenderEmailAddress&quot;&amp;gt;默认发件人邮箱地址&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DefaultFromSenderDisplayName&quot;&amp;gt;默认发件人名字&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DefaultLanguage&quot;&amp;gt;预设语言&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;ReceiveNotifications&quot;&amp;gt;接收通知&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;CurrentUserDidNotLoginToTheApplication&quot;&amp;gt;当前用户没有登录到系统！&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;TimeZone&quot;&amp;gt;时区&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;AllOfThesePermissionsMustBeGranted&quot;&amp;gt;您没有权限进行此操作,您需要以下权限: {0}&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;AtLeastOneOfThesePermissionsMustBeGranted&quot;&amp;gt;您没有权限进行此操作,您至少需要下列权限的其中一项: {0}&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;MainMenu&quot;&amp;gt;主菜单&amp;lt;/text&amp;gt;
  &amp;lt;/texts&amp;gt;
&amp;lt;/localizationDictionary&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个文件内部，会有一个 &lt;code&gt;&amp;lt;localizationDictionary culture=&quot;zh-Hans&quot;&amp;gt;&lt;/code&gt; 节点用于说明当前文件是针对于哪个区域适用的，而在其 &lt;code&gt;&amp;lt;texts&amp;gt;&lt;/code&gt; 内部则就是结合键值对的形式，name 里面的内容就是多语言文本项的键，在标签内部的就是其真正的值。&lt;/p&gt;
&lt;p&gt;打开一个针对俄语国家的 XML 资源文件，文件名称叫做 &lt;strong&gt;Abp-ru.xml&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;localizationDictionary culture=&quot;ru&quot;&amp;gt;
  &amp;lt;texts&amp;gt;
    &amp;lt;text name=&quot;SmtpHost&quot;&amp;gt;SMTP сервер&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;SmtpPort&quot;&amp;gt;SMTP порт&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;Username&quot;&amp;gt;Имя пользователя&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;Password&quot;&amp;gt;Пароль&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DomainName&quot;&amp;gt;Домен&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;UseSSL&quot;&amp;gt;Использовать SSL&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;UseDefaultCredentials&quot;&amp;gt;Использовать учетные данные по умолчанию&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DefaultFromSenderEmailAddress&quot;&amp;gt;Электронный адрес отправителя по умолчанию&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DefaultFromSenderDisplayName&quot;&amp;gt;Имя отправителя по умолчанию&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;DefaultLanguage&quot;&amp;gt;Язык по умолчанию&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;ReceiveNotifications&quot;&amp;gt;Получать уведомления&amp;lt;/text&amp;gt;
    &amp;lt;text name=&quot;CurrentUserDidNotLoginToTheApplication&quot;&amp;gt;Текущий пользователь не вошёл в приложение!&amp;lt;/text&amp;gt;
  &amp;lt;/texts&amp;gt;
&amp;lt;/localizationDictionary&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 Key 值都是一样的，只是其 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 内部的值根据区域国家的不同值不一样而已。&lt;/p&gt;
&lt;p&gt;其次从文件名我们就可以看到需要使用 XML 资源文件对于文件的命名格式会有一定要求，还是以 Abp 自带的资源文件为例，可以看一下他们基本上都是由 &lt;strong&gt;{SourceName}&lt;/strong&gt;-&lt;strong&gt;{CultureInfo}&lt;/strong&gt;.xml 这样构成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818104849176-830276177.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注册本地化的-xml-资源&quot;&gt;0.1.3 注册本地化的 XML 资源&lt;/h4&gt;
&lt;p&gt;那么如果我们需要注册之前的两个 XML 资源到 Abp 框架当中的话，则需要在预加载模块处通过如下代码来执行注册，并且需要右键 XML 文件，更改其构建操作为 &lt;strong&gt;内嵌资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818104904733-1107761438.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Configuration.Localization.Sources.Add(
    new DictionaryBasedLocalizationSource(
        // 本地化资源名称
        AbpConsts.LocalizationSourceName,
        // 数据源提供者，这里使用的是 XML ，除了 XML 提供者，还有 JSON 等
        new XmlEmbeddedFileLocalizationDictionaryProvider(
            typeof(AbpKernelModule).GetAssembly(), &quot;Abp.Localization.Sources.AbpXmlSource&quot;
        )));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取多语言文本&quot;&gt;0.1.4 获取多语言文本&lt;/h4&gt;
&lt;p&gt;如果你需要在某处获取指定 Key 所对应的具体显示文本，只需要注入 &lt;code&gt;ILocalizationManager&lt;/code&gt; ，通过其 &lt;code&gt;GetString()&lt;/code&gt; 方法就可以获得具体的值。如果你需要获取本地化资源的地方不能够使用依赖注入，你可以使用 &lt;code&gt;LocalizationHelper&lt;/code&gt; 静态类来进行操作。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var @string = _localizationManager.GetString(&quot;Abp&quot;, &quot;MainMenu&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它默认是从 &lt;code&gt;Thread.CurrentThread.CurrentUICulture&lt;/code&gt; 获取到的当前区域信息，从而来取得某个 Key 所对应的显示值，而当前区域信息是由 Abp 注入的一系列 &lt;code&gt;RequestCultureProviders&lt;/code&gt; 所提供的，他按照以下顺序来进行设置。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;QueryStringRequestCultureProvider&lt;/strong&gt;(ASP .NET Core 默认提供)：该默认提供器使用的是 &lt;strong&gt;QueryString&lt;/strong&gt; 的 &lt;code&gt;culture&amp;amp;ui-culture&lt;/code&gt; 所提供的区域文化信息来初始化该值，例如：&lt;code&gt;culture=es-MX&amp;amp;ui-culture=es-MX&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AbpUserRequestCultureProvider&lt;/strong&gt; (Abp 提供)：该提供器会读取当前用户的 &lt;code&gt;IAbpSession&lt;/code&gt; 信息，并且从 &lt;code&gt;ISettingManager&lt;/code&gt; 中获取用户所配置的 &lt;code&gt;&quot;Abp.Localization.DefaultLanguageName&quot;&lt;/code&gt; 属性，将其作为默认的区域文化信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AbpLocalizationHeaderRequestCultureProvider&lt;/strong&gt; (Abp 提供)：使用每次请求头当中的 &lt;strong&gt;.AspNetCore.Culture&lt;/strong&gt; 值作为当前的区域文化信息，例如 &lt;code&gt;c=en|uic=en-US&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CookieRequestCultureProvider&lt;/strong&gt; (ASP .NET Core 提供)：使用每次请求的 Cookie 当中 Key 为 &lt;strong&gt;.AspNetCore.Culture&lt;/strong&gt; 值作为当前区域文化信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AbpDefaultRequestCultureProvider&lt;/strong&gt; (Abp 提供)：如果之前这些提供器都没有为当前区域文化赋值，则从 &lt;code&gt;ISettingMananger&lt;/code&gt; 当中取得 &lt;code&gt;Abp.Localization.DefaultLanguageName&lt;/code&gt; 的默认值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AcceptLanguageHeaderRequestCultureProvider&lt;/strong&gt; (ASP .NET Core 默认提供)：该提供器最终会使用用户每次请求时传递的 &lt;strong&gt;Accept-Language&lt;/strong&gt; 头部作为当前区域文化信息。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小提示：&lt;/p&gt;
&lt;p&gt;这里 Abp 注入的提供器是有顺序的，注入这么多提供器就是为了最后确定当前用户的区域文化信息以便展示相应的语言文本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;启动流程&quot;&gt;1.启动流程&lt;/h2&gt;
&lt;h3 id=&quot;启动流程图&quot;&gt;1.1 启动流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818104934583-1970004026.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码流程&quot;&gt;1.2 代码流程&lt;/h3&gt;
&lt;p&gt;根据使用方法我们可以得知，要配置 Abp 的多语言，必须得等 &lt;code&gt;IAbpStartupConfiguration&lt;/code&gt; 初始化完毕才可以。即在 &lt;code&gt;AbpBootstrapper&lt;/code&gt; 的 &lt;code&gt;Initialize()&lt;/code&gt; 方法之中：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual void Initialize()
{
    // ... 其他代码
    // 注入 IAbpStartupConfiguration 配置与本地化资源配置
    IocManager.IocContainer.Install(new AbpCoreInstaller());

    // ... 其他代码
    // 初始化 AbpStartupConfiguration 类型
    IocManager.Resolve&amp;lt;AbpStartupConfiguration&amp;gt;().Initialize();

    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类里面包含了用户所配置的所有语言与多语言资源信息，在被成功注入到 Ioc 容器之后，Abp 就开始使用本地化资源管理器来初始化这些多语言数据了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public override void PostInitialize()
{
    // 注册缺少的组件，防止遗漏注册组件
    RegisterMissingComponents();

    IocManager.Resolve&amp;lt;SettingDefinitionManager&amp;gt;().Initialize();
    IocManager.Resolve&amp;lt;FeatureManager&amp;gt;().Initialize();
    IocManager.Resolve&amp;lt;PermissionManager&amp;gt;().Initialize();
    
    // 重点在这里，这个 PostInitialize 方法是存放在核心模块当中的，在这里调用了本地化资源管理器的初始化方法
    IocManager.Resolve&amp;lt;LocalizationManager&amp;gt;().Initialize();
    IocManager.Resolve&amp;lt;NotificationDefinitionManager&amp;gt;().Initialize();
    IocManager.Resolve&amp;lt;NavigationManager&amp;gt;().Initialize();

    if (Configuration.BackgroundJobs.IsJobExecutionEnabled)
    {
        var workerManager = IocManager.Resolve&amp;lt;IBackgroundWorkerManager&amp;gt;();
        workerManager.Start();
        workerManager.Add(IocManager.Resolve&amp;lt;IBackgroundJobManager&amp;gt;());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体 &lt;code&gt;LocalizationManager&lt;/code&gt; 及其内部的实现我们在下一节代码分析中详细进行讲述。&lt;/p&gt;
&lt;p&gt;这些动作仅仅是在注入 Abp 框架的时候所需要执行的一些步骤，如果你要启用多语言，需要在 ASP .NET Core 程序的 &lt;code&gt;Startup&lt;/code&gt; 类中的 &lt;code&gt;Configure()&lt;/code&gt; 处通过更改 &lt;code&gt;UseAbpRequestLocalization&lt;/code&gt; 状态为 True，才会将区域文化识别中间件注入到程序当中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseAbp(options =&amp;gt;
    {
        options.UseAbpRequestLocalization = false; //disable automatic adding of request localization
    });

    //...authentication middleware(s)

    app.UseAbpRequestLocalization(); //manually add request localization

    //...other middlewares

    app.UseMvc(routes =&amp;gt;
    {
        //...
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这里的 &lt;code&gt;UseAbpRequestLocalization()&lt;/code&gt; 就已经将上文说的那些 RequestProvider 按照顺序依次注入到 MVC 之中了。&lt;/p&gt;
&lt;h2 id=&quot;代码分析&quot;&gt;2.代码分析&lt;/h2&gt;
&lt;p&gt;Abp 框架针对本地化处理相关的类型与方法定义都存放在 Abp 库的 &lt;strong&gt;Localization&lt;/strong&gt; 文件夹下。关系还是相对复杂的，这里我们先从其核心的 Abp 库针对于多语言的处理开始讲起。&lt;/p&gt;
&lt;h3 id=&quot;多语言模块配置&quot;&gt;2.1 多语言模块配置&lt;/h3&gt;
&lt;p&gt;Abp 需要使用的所有信息都是由用户在自己启动模块的 &lt;code&gt;PreInitialize()&lt;/code&gt; 当中，通过 &lt;code&gt;ILocalizationConfiguration&lt;/code&gt; 进行注入配置。也就是说在 &lt;code&gt;ILocalizationConfiguration&lt;/code&gt; 内部，主要是包含了语言，与多语言资源提供者两种重点信息。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface ILocalizationConfiguration
{
    // 当前应用程序可配置的语言列表
    IList&amp;lt;LanguageInfo&amp;gt; Languages { get; }

    // 本地化资源列表
    ILocalizationSourceList Sources { get; }

    // 是否启用多语言(本地化) 系统
    bool IsEnabled { get; set; }

    // 以下四个布尔类型的参数主要用于确定当没有找到多语言文本时的处理逻辑，默认都为 True
    bool ReturnGivenTextIfNotFound { get; set; }

    bool WrapGivenTextIfNotFound { get; set; }

    bool HumanizeTextIfNotFound { get; set; }

    bool LogWarnMessageIfNotFound { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;语言信息&quot;&gt;2.2 语言信息&lt;/h3&gt;
&lt;p&gt;当前应用程序能够支持哪一些语言，取决于用户在预加载的时候给多语言模块配置对象分配了哪些语言。通过第 &lt;strong&gt;0.1.1&lt;/strong&gt; 节我们看到用户可以直接通过初始化一个新的 &lt;code&gt;LanguageInfo&lt;/code&gt; 对象，将其添加到 Languages 属性之中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class LanguageInfo
{
    /// &amp;lt;summary&amp;gt;
    /// 区域文化代码名称
    /// 应该是一个有效的区域文化代码名称，更多的可以通过 CultureInfo 静态类获得所有文化代码。
    /// 例如: &quot;en-US&quot; 是北美适用的, &quot;tr-TR&quot; 适用于土耳其。
    /// &amp;lt;/summary&amp;gt;
    public string Name { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 该语言默认应该展示的语言名称。
    /// 例如: 英语应该展示为 &quot;English&quot;, &quot;zh-Hans&quot; 应该展示为 &quot;简体中文&quot;
    /// &amp;lt;/summary&amp;gt;
    public string DisplayName { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 用于展示的图标 CSS 类名，可选参数
    /// &amp;lt;/summary&amp;gt;
    public string Icon { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 是否为默认语言
    /// &amp;lt;/summary&amp;gt;
    public bool IsDefault { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 该语言是否被禁用
    /// &amp;lt;/summary&amp;gt;
    public bool IsDisabled { get; set; }

    /// &amp;lt;summary&amp;gt;
    /// 语言的展示方式是自左向右还是自右向左
    /// &amp;lt;/summary&amp;gt;
    public bool IsRightToLeft
    {
        get
        {
            try
            {
                return CultureInfo.GetCultureInfo(Name).TextInfo?.IsRightToLeft ?? false;
            }
            catch
            {
                return false;
            }
        }
    }

    public LanguageInfo(string name, string displayName, string icon = null, bool isDefault = false, bool isDisabled = false)
    {
        Name = name;
        DisplayName = displayName;
        Icon = icon;
        IsDefault = isDefault;
        IsDisabled = isDisabled;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于语言的定义还是相当简单的，主要参数就是语言的 &lt;strong&gt;区域文化代码&lt;/strong&gt; 与 &lt;strong&gt;展示的名称&lt;/strong&gt;，其余的都可以是可选参数。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小提示：&lt;/p&gt;
&lt;p&gt;关于当前系统所支持的区域文化代码，可以通过执行 &lt;code&gt;CultureInfo.GetCultures(CultureTypes.AllCultures);&lt;/code&gt; 得到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;语言管理器&quot;&gt;2.3 语言管理器&lt;/h3&gt;
&lt;p&gt;Abp 针对语言也提供了一个管理器，接口叫做 &lt;code&gt;ILanguageManager&lt;/code&gt;，定义简单，两个方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface ILanguageManager
{
    // 获得当前语言
    LanguageInfo CurrentLanguage { get; }

    // 获得所有语言
    IReadOnlyList&amp;lt;LanguageInfo&amp;gt; GetLanguages();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现也不复杂，它内部的实现就是从一个 &lt;code&gt;ILanguageProvider&lt;/code&gt; 拿取有哪一些语言数据。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly ILanguageProvider _languageProvider;

public IReadOnlyList&amp;lt;LanguageInfo&amp;gt; GetLanguages()
{
    return _languageProvider.GetLanguages();
}

// 获取当前语言，其实就是获取的 CultureInfo.CurrentUICulture.Name 的信息，然后去查询语言集合。
private LanguageInfo GetCurrentLanguage()
{
    var languages = _languageProvider.GetLanguages();
    
    // ... 省略了的代码
    var currentCultureName = CultureInfo.CurrentUICulture.Name;

    var currentLanguage = languages.FirstOrDefault(l =&amp;gt; l.Name == currentCultureName);
    if (currentLanguage != null)
    {
        return currentLanguage;
    }
    
    // ... 省略了的代码
    
    return languages[0];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认实现就是直接读取之前通过 Configuration 的 &lt;strong&gt;Languages&lt;/strong&gt; 里面的数据。&lt;/p&gt;
&lt;p&gt;在 Abp.Zero 模块还有两外一个实现，叫做 &lt;code&gt;ApplicationLanguageProvider&lt;/code&gt; ，这个提供者则是从数据库表 &lt;code&gt;ApplicationLanguage&lt;/code&gt; 获取的这些语言列表数据，并且这些语言信息还与租户有关，不同的租户他所能够获得到的语言数据也不一样。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IReadOnlyList&amp;lt;LanguageInfo&amp;gt; GetLanguages()
{
    // 可以看到这里传入的当前登录用户的租户 Id，通过这个参数去查询的语言表数据
    var languageInfos = AsyncHelper.RunSync(() =&amp;gt; _applicationLanguageManager.GetLanguagesAsync(AbpSession.TenantId))
        .OrderBy(l =&amp;gt; l.DisplayName)
        .Select(l =&amp;gt; l.ToLanguageInfo())
        .ToList();

    SetDefaultLanguage(languageInfos);

    return languageInfos;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;本地化资源&quot;&gt;2.4 本地化资源&lt;/h3&gt;
&lt;h4 id=&quot;本地化资源列表&quot;&gt;2.4.1 本地化资源列表&lt;/h4&gt;
&lt;p&gt;在多语言模块配置内部使用的是 &lt;code&gt;ILocalizationSourceList&lt;/code&gt; 类型的一个 Sources 属性，该类型其实就是继承自 &lt;code&gt;IList&amp;lt;ILocalizationSource&amp;gt;&lt;/code&gt; 的一个具体实现而已，一个类型为 &lt;code&gt;ILocalizationSource&lt;/code&gt; 的集合，不过其扩展了一个&lt;/p&gt;
&lt;p&gt;Extensions 属性用于存放扩展的多语言数据字段。&lt;/p&gt;
&lt;h4 id=&quot;本地化资源-1&quot;&gt;2.4.2 本地化资源&lt;/h4&gt;
&lt;p&gt;其接口定义为 &lt;code&gt;ILocalizationSource&lt;/code&gt; ，Abp 默认为我们实现了四种本地化资源的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818105003083-1141353255.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个是空实现，可以跳过，第二个则是针对资源文件进行读取的的本地化资源，第三个是基于字典的的本地化资源定义，最后一个是由 Abp Zero 模块所提供的数据库版本的多语言资源定义。&lt;/p&gt;
&lt;p&gt;首先看一下该接口的定义：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface ILocalizationSource
{
    // 本地化资源唯一的名称
    string Name { get; }

    // 用于初始化本地化资源,在 Abp 框架初始化的时候被调用
    void Initialize(ILocalizationConfiguration configuration, IIocResolver iocResolver);

    // 从当前本地化资源中获取给定关键字的多语言文本项，为用户当前语言
    string GetString(string name);

    // 从当前本地化资源中获取给定关键字与区域文化的多语言文本项
    string GetString(string name, CultureInfo culture);

    // 作用同上，只不过不存在会返回 NULL
    string GetStringOrNull(string name, bool tryDefaults = true);

    // 作用同上，只不过不存在会返回 NULL
    string GetStringOrNull(string name, CultureInfo culture, bool tryDefaults = true);

    // 获得当前语言所有的多语言文本项集合
    IReadOnlyList&amp;lt;LocalizedString&amp;gt; GetAllStrings(bool includeDefaults = true);

    // 获得给定区域文化的所有多语言文本项集合
    IReadOnlyList&amp;lt;LocalizedString&amp;gt; GetAllStrings(CultureInfo culture, bool includeDefaults = true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就可以这么来看，我们有几套本地化资源，他们通过 Name 来进行标识，如果你需要在本地化管理器获取某一套本地化资源，那么你可以直接通过 Name 来进行定位。而每一套本地化资源，自身都拥有具体的多语言数据，这些多语言数据有可能来自文件也有可能来自数据库，这取决于你具体的实现。&lt;/p&gt;
&lt;h4 id=&quot;基于字典的本地化资源&quot;&gt;2.4.3 基于字典的本地化资源&lt;/h4&gt;
&lt;p&gt;最开始我们在使用范例当中，通过 &lt;code&gt;DictionaryBasedLocalizationSource&lt;/code&gt; 来建立我们的本地化资源对象。该对象实现了 &lt;code&gt;ILocalizationSource&lt;/code&gt; 与 &lt;code&gt;IDictionaryBasedLocalizationSource&lt;/code&gt; 接口，内部定义了一个本地化资源字典提供器。&lt;/p&gt;
&lt;p&gt;当调用本地化资源的 &lt;code&gt;Initialize()&lt;/code&gt; 方法的时候，会使用具体的本地化资源字典提供器来获取数据，而这个字典提供器可以为 &lt;code&gt;XmlFileLocalizationDictionaryProvider&lt;/code&gt;、&lt;code&gt;JsonEmbeddedFileLocalizationDictionaryProvider&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;这些内部字典提供器在初始化的时候，会将自身的数据按照 &lt;strong&gt;语言/多语言项&lt;/strong&gt; 的形式将多语言信息存放在一个字典之中，而这个字典又可以分为 XML、JSON 等等等等...&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 内部字典提供器
public interface ILocalizationDictionaryProvider
{
    // 语言/多语言项字典
    IDictionary&amp;lt;string, ILocalizationDictionary&amp;gt; Dictionaries { get; }

    // 本地化资源初始化时被调用
    void Initialize(string sourceName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这里的 &lt;code&gt;ILocalizationDictionary&lt;/code&gt; 其实就是一个键值对，键关联的是多语言项的标识 KEY，例如 &quot;Home&quot;，而 Value 就是具体的展示文本信息了。&lt;/p&gt;
&lt;p&gt;而是用字典本地化资源对象获取数据的时候，其实也就是从其内部的字典提供器来获取数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818105043430-110231968.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如本地化资源有一个 &lt;code&gt;GetString()&lt;/code&gt; 方法，它内部拥有一个字典提供器 &lt;strong&gt;DictionaryProvider&lt;/strong&gt;，我要获取某个 KEY 为 &quot;Home&quot; 所需要经过的步骤如下。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ILocalizationDictionaryProvider DictionaryProvider { get; }

public string GetString(string name)
{
    // 获取当前用户区域文化，标识为 &quot;Home&quot; 的展示文本
    return GetString(name, CultureInfo.CurrentUICulture);
}

public string GetString(string name, CultureInfo culture)
{
    // 获取值
    var value = GetStringOrNull(name, culture);

    // 判断值为空的话，根据配置的要求是否抛出异常
    if (value == null)
    {
        return ReturnGivenNameOrThrowException(name, culture);
    }

    return value;
}

// 获得 KEY 关联的文本
public string GetStringOrNull(string name, CultureInfo culture, bool tryDefaults = true)
{
    var cultureName = culture.Name;
    var dictionaries = DictionaryProvider.Dictionaries;

    // 在这里就开始从初始化所加载完成的语言字典里面，获取具体的多语言项字典
    ILocalizationDictionary originalDictionary;
    if (dictionaries.TryGetValue(cultureName, out originalDictionary))
    {
        // 多语言项字典拿取具体的多语言文本值
        var strOriginal = originalDictionary.GetOrNull(name);
        if (strOriginal != null)
        {
            return strOriginal.Value;
        }
    }

    if (!tryDefaults)
    {
        return null;
    }

    //Try to get from same language dictionary (without country code)
    if (cultureName.Contains(&quot;-&quot;)) //Example: &quot;tr-TR&quot; (length=5)
    {
        ILocalizationDictionary langDictionary;
        if (dictionaries.TryGetValue(GetBaseCultureName(cultureName), out langDictionary))
        {
            var strLang = langDictionary.GetOrNull(name);
            if (strLang != null)
            {
                return strLang.Value;
            }
        }
    }

    //Try to get from default language
    var defaultDictionary = DictionaryProvider.DefaultDictionary;
    if (defaultDictionary == null)
    {
        return null;
    }

    var strDefault = defaultDictionary.GetOrNull(name);
    if (strDefault == null)
    {
        return null;
    }

    return strDefault.Value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;基于数据库的本地化资源&quot;&gt;2.3.4 基于数据库的本地化资源&lt;/h4&gt;
&lt;p&gt;如果你有集成 Abp.Zero 模块的话，可以通过在启动模块的预加载方法编写以下代码启用 Zero 的多语言机制。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Configuration.Modules.Zero().LanguageManagement.EnableDbLocalization();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Abp.Zero 针对原有的本地化资源进行了扩展，新增的本地化资源类叫做 &lt;code&gt;MultiTenantLocalizationSource&lt;/code&gt;，该类同语言管理器一样，是一个基于多租户实现的本地化资源，内部字典的值是从数据库当中获取的，其大体逻辑与字典本地化资源一样，都是内部维护有一个字典提供器。&lt;/p&gt;
&lt;p&gt;在通过 &lt;code&gt;EnableDbLocalization()&lt;/code&gt; 方法的时候就直接替换掉了 &lt;code&gt;ILanguageProvider&lt;/code&gt; 的默认实现，并且在配置的 Sources 源里面也增加了 &lt;code&gt;MultiTenantLocalizationSource&lt;/code&gt; 作为一个本地化资源。&lt;/p&gt;
&lt;h3 id=&quot;本地化资源管理器&quot;&gt;2.5 本地化资源管理器&lt;/h3&gt;
&lt;p&gt;扯了这么多，让我们来看一下最为核心的 &lt;code&gt;ILocalizationManager&lt;/code&gt; 接口，如果我们需要获取某个数据源的某个 Key 所对应的多语言值肯定是要注入这个本地化资源管理器来进行操作的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface ILocalizationManager
{
    // 根据名称获得本地化数据源
    ILocalizationSource GetSource(string name);

    // 获取所有的本地化数据源
    IReadOnlyList&amp;lt;ILocalizationSource&amp;gt; GetAllSources();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的数据源标识的就是一个命名空间的作用，比如我在 A 模块当中有一个 Key 为 &lt;code&gt;&quot;Home&quot;&lt;/code&gt; 的多语言项，在 B 模块也有一个 Key 为 &lt;code&gt;&quot;Home&quot;&lt;/code&gt; 的多语言项，这个时候就可以用数据源标识来区分这两个 &lt;code&gt;&quot;Home&quot;&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;本地化资源管理器通过在初始化的时候调用其 &lt;code&gt;Initialize()&lt;/code&gt; 来初始化所有被注入的本地化资源，最后并将其放在一个字典之中，以便后续使用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly IDictionary&amp;lt;string, ILocalizationSource&amp;gt; _sources;

foreach (var source in _configuration.Sources)
{
    // ... 其他代码
    _sources[source.Name] = source;
    source.Initialize(_configuration, _iocResolver);
    
    // ... 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201808/1203160-20180818105059175-791885284.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;3.结语&lt;/h2&gt;
&lt;p&gt;针对 Abp 的多语言处理本篇文章不太适合作为入门了解，其中大部分知识需要结合 Abp 源码进行阅读才能够加深理解，此文仅作抛砖引玉之用，如有任何意见或建议欢迎大家在评论当中指出。&lt;/p&gt;

</description>
<pubDate>Sat, 18 Aug 2018 02:52:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<og:description>0.简介 如果你所开发的需要走向世界的话，那么肯定需要针对每一个用户进行不同的本地化处理，有可能你的客户在日本，需要使用日语作为显示文本，也有可能你的客户在美国，需要使用英语作为显示文本。如果你还是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myzony/p/9496490.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之三 ----- 建造者模式和原型模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9496346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9496346.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9363142.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了工厂模式，介绍了简单工厂模式、工厂方法和抽象工厂模式。本篇则介绍设计模式中属于创建型模式的建造者模式和原型模式。&lt;/p&gt;
&lt;h2 id=&quot;建造者模式&quot;&gt;建造者模式&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;建造者模式是属于创建型模式。建造者模式使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br/&gt;简单的来说就是将一个复杂的东西抽离出来，对外提供一个简单的调用，可以在同样的构建过程创建不同的表示。和工厂模式很相似，不过相比而言更加注重组件的装配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里用一个示例来进行说明。&lt;br/&gt;我们一天吃的食物有这些，煎饼、盒饭、拉面、豆浆、牛奶和果汁。分为三餐、早餐、午餐和晚餐，餐点主要包含吃的(俗称饭)和喝的(豆浆，果汁之类的)，那么我们可以把煎饼和豆浆作为早餐，盒饭和果汁作为午餐，这样我们可以清楚的知道要吃早餐和午餐包含什么食物。&lt;/p&gt;
&lt;p&gt;首先我们定义一个食物类，有两个属性，吃的和喝的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Meal{
    private String food;
    private String drinks;
    
    public String getFood() {
        return food;
    }
    public void setFood(String food) {
        this.food = food;
    }
    
    public String getDrinks() {
        return drinks;
    }
    public void setDrinks(String drinks) {
        this.drinks = drinks;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了食物时候，我们在定义一个食物的标准接口，一份食物包含什么，其实也就是吃的和喝的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface IBuilderFood{
    void buildFood();
    void buildDrinks();
    Meal createMeal();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;食物接口定义一个吃的和一个喝的组件，然后通过&lt;strong&gt;createMeal()&lt;/strong&gt;方法返回我们需要的食物。&lt;br/&gt;那么现在我们便可以定义一份早餐和午餐。&lt;br/&gt;代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Breakfast implements IBuilderFood{
    Meal meal;

    public Breakfast(){
        meal=new Meal();
    }
    
    @Override
    public void buildFood() {
        meal.setFood(&quot;煎饼&quot;);
    }

    @Override
    public void buildDrinks() {
        meal.setDrinks(&quot;豆浆&quot;);   
    }
    
    @Override
    public Meal createMeal() {
        return meal;
    }
}

class Lunch implements IBuilderFood{
    Meal meal;

    public Lunch(){
        meal=new Meal();
    }
    
    @Override
    public void buildFood() {
        meal.setFood(&quot;盒饭&quot;);
    }

    @Override
    public void buildDrinks() {
        meal.setDrinks(&quot;果汁&quot;);   
    }
    
    @Override
    public Meal createMeal() {
        return meal;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义完之后，建造早餐和午餐的的过程已经完毕了。但是这并不是建造者模式，它有个核心的Director(导演者)，它用来创建复杂对象的部分，对该部分进行完整的创建或者按照一定的规则进行创建。那么这里我们可以创建一个Director，用来创建一份餐点。至于创建的是什么餐点，它不用知道，这一点由调用者来进行决定。&lt;/p&gt;
&lt;p&gt;这里我们就可以定义一个饭店，可以创建一份餐点，创建什么餐点有顾客决定。&lt;br/&gt;代码示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class FoodStore{
    public Meal createBreakfast(IBuilderFood bf){
        bf.buildDrinks();
        bf.buildFood();
        return bf.createMeal();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成这个Director之后，我们再来进行调用测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class BuilderTest {

    public static void main(String[] args) {
        FoodStore foodStore=new FoodStore();
        Meal meal=foodStore.createBreakfast(new Breakfast());
        Meal meal2=foodStore.createBreakfast(new Lunch());
        System.out.println(&quot;小明早上吃的是:&quot;+meal.getFood()+&quot;,喝的饮料是:&quot;+meal.getDrinks());
        System.out.println(&quot;小明中午吃的是:&quot;+meal2.getFood()+&quot;,喝的饮料是:&quot;+meal2.getDrinks()); 
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;小明早上吃的是:煎饼,喝的饮料是:豆浆
小明中午吃的是:盒饭,喝的饮料是:果汁&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的介绍了下建造者模式的运作原理，可以概况为这4点:&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Builder：指定一个抽象的接口，规定该产品所需实现部件的创建，并不涉及具体的对象部件的创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ConcreteBuilder：需实现Builder接口，并且针对不同的逻辑，进行不同方法的创建，最终提供该产品的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Director：用来创建复杂对象的部分，对该部分进行完整的创建或者按照一定的规则进行创建。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Product：示被构造的复杂对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;使用场景:&lt;/strong&gt;&lt;br/&gt;适用一些基本组件不便，但是组合经常变化的时候。比如超市促销的大礼包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建造者独立，易扩展。&lt;/li&gt;
&lt;li&gt;便于控制细节风险。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;内部结构复杂，不易于理解。&lt;/li&gt;
&lt;li&gt;产品直接需要有共同点，范围有控制。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;原型模式&quot;&gt;原型模式&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说我们在创建对象的时候是直接创建的，但是创建该对象的代价很大的时候，重复的二次创建就有些不划算，这时我们就可以使用原型模式。&lt;br/&gt;打个比方，我们都发送过邮件，在节日的时候一般发送的是祝福语句，在这些祝福语句中，一般除了名字不一样之外，大部分都是一样的。这时我们就可以利用该模式来进行相应出创建。&lt;/p&gt;
&lt;p&gt;这里还是用一个的简单的示例来说明。&lt;br/&gt;小明和小红在同一天生日，然后我们需要给他们发送邮件进行祝福，但是由于比较懒，祝福语除了名字之外都是一样的。这时我们就可以先完成祝福语的编写，然后克隆该祝福语，最后根据不同的名称进行发送。不过这里就从简了，只是简单的打印下而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PrototypeTest {

    public static void main(String[] args) {
        Mail mail=new Mail();
        mail.setMsg(&quot;生日快乐!&quot;);
        Mail mail2=(Mail) mail.clone();
        mail.setName(&quot;小明&quot;);
        mail2.setName(&quot;小红&quot;);
        System.out.println(mail.toString());
        System.out.println(mail2.toString());
    }
}

 class Mail implements Cloneable {
    private String name;
    private String msg;
    
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
    public Object clone() {
        Object clone = null;
        try {
            clone = super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }

    @Override
    public String toString() {
        return name + &quot;:&quot; + msg ;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;小明:生日快乐!
小红:生日快乐!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完原型模式的创建，是不是感觉就是和Java中克隆即为类似呢?&lt;br/&gt;实际上它的核心也就是克隆。&lt;br/&gt;克隆有两种，浅克隆和深克隆，本文主要介绍的是浅克隆。&lt;br/&gt;&lt;strong&gt;浅克隆:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。&lt;br/&gt;简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。&lt;br/&gt;实现Cloneable接口并重写Object类中的clone()方法；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;深克隆:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。&lt;/p&gt;
&lt;p&gt;简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。&lt;br/&gt;实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用场景:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类初始化的时候需要消耗大量资源的时候；&lt;/li&gt;
&lt;li&gt;获取数据库连接繁琐的时候；&lt;/li&gt;
&lt;li&gt;一个对象，有很多个修改者的时候；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;优点:&lt;/strong&gt;&lt;br/&gt;1.可以提升性能；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点:&lt;/strong&gt;&lt;br/&gt;1.因为必须实现Cloneable 接口，所以用起来可能不太方便。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;

&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　　　　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;br/&gt;原创不易，转载请标明出处，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 18 Aug 2018 02:15:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9496346.html</dc:identifier>
</item>
</channel>
</rss>