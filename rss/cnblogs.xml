<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python 历险记（三）— python 的常用文件操作 - ReyCG</title>
<link>http://www.cnblogs.com/reycg-blog/p/9951788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reycg-blog/p/9951788.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/reycg-blog/p/9907327.html&quot;&gt;上篇文章&lt;/a&gt; 中，全面讲解了 python 3 中 的面向对象，今天我会继续探险，去掌握 python 3 中的文件操作， let's go 让我们出发吧!&lt;/p&gt;

&lt;h2 id=&quot;什么是文件&quot;&gt;什么是文件？&lt;/h2&gt;
&lt;p&gt;一谈到文件，就会涉及到一个的重要的概念，&lt;strong&gt;持久化&lt;/strong&gt; 。什么是持久化？&lt;/p&gt;
&lt;blockquote readability=&quot;6.8116591928251&quot;&gt;
&lt;p&gt;持久化是将程序数据在&lt;a href=&quot;https://baike.baidu.com/item/%E6%8C%81%E4%B9%85/5702771&quot;&gt;持久&lt;/a&gt;状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据。 ——来源于百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此可见，持久化数据就是在程序运行结束后或者断电后再开机，还继续存在的数据。而文件就是最典型的表现形式。那什么是文件呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件就是存储在如硬盘，光盘这样的非易失媒介上的信息序列&lt;/strong&gt;。像内存，在关机或掉电后，信息就全部丢失了，文件当然不会存储在它上面。&lt;/p&gt;
&lt;p&gt;当我们想要读或者写文件时，就得先打开(open) 文件才可以，而当读写完成的时候，也要尽量将其关闭(close)，这样才能够释放它占用的系统资源啊。&lt;/p&gt;
&lt;h2 id=&quot;如何在-python-中打开文件&quot;&gt;如何在 python 中打开文件？&lt;/h2&gt;
&lt;p&gt;使用内置函数 &lt;code&gt;open&lt;/code&gt; 就可以打开文件。先来看下 python 中对 &lt;code&gt;open&lt;/code&gt; 函数的定义&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;file object = open(file_name [, access_mode][, buffering])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数定义如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;access_mode&lt;/code&gt; 表示文件模式。常见的模式有读模式，写模式，追加模式等。这个参数是可选的，如果不填，默认就是读模式。具体的文件模式列表在下面表格中列出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;buffering&lt;/code&gt; 缓存标志
&lt;ul&gt;&lt;li&gt;如果不填，默认值为 0&lt;/li&gt;
&lt;li&gt;值为 1 表示行缓存&lt;/li&gt;
&lt;li&gt;值 &amp;gt; 1 则代表缓冲区的大小（单位是字节）&lt;/li&gt;
&lt;li&gt;值 &amp;lt; 0 表示使用默认缓存区的大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file_name&lt;/code&gt; 表示要访问的文件路径名称，可以是相对路径，也可以是绝对路径。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的文件模式 &lt;code&gt;access_mode&lt;/code&gt; 参数表如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;写模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;读模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;写模式，创建一个文件，如果文件已存在，则报错&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;追加模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;二进制模式（可与其他模式结合使用）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读/写模式(可与其他模式结合使用)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中 &lt;code&gt;b&lt;/code&gt; 或者 &lt;code&gt;+&lt;/code&gt; 可与其他模式结合使用需要说明下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如 &lt;code&gt;rb&lt;/code&gt; 就表示读取一个二进制文件&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;w+&lt;/code&gt; 表示对打开的文件可读可写&lt;/li&gt;
&lt;li&gt;如 &lt;code&gt;wb+&lt;/code&gt; 则表示对二进制文件可读可写，如果模式中不加 &lt;code&gt;b&lt;/code&gt;则默认表示文本文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用 &lt;code&gt;open&lt;/code&gt; 函数后返回的是什么对象呢？能够从这个对象中获取什么信息和执行什么操作呢？来看下一节&lt;/p&gt;
&lt;h2 id=&quot;python-文件对象有哪些属性&quot;&gt;python 文件对象有哪些属性？&lt;/h2&gt;
&lt;p&gt;调用 &lt;code&gt;open&lt;/code&gt; 函数后返回的是一个文件句柄，这个句柄中包含许多文件相关的属性,具体如下面表格所示&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;file.closed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件是否已关闭，是则返回 true&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;file.mode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开文件时使用的模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;file.name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件名称&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;来看一个例子&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open('test.py', 'r+')

# 文件名称.
print (&quot;File name: &quot;, f.name) # test.py
# 文件是否已关闭
print (&quot;File state: &quot;, f.closed) # False
# 文件打开时的模式
print (&quot;Opening mode: &quot;, f.mode) # r+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开文件后，最常见的操作就是读文件和写文件了，先来看读文件&lt;/p&gt;
&lt;h2 id=&quot;如何读文件&quot;&gt;如何读文件？&lt;/h2&gt;
&lt;p&gt;在读取文件时， 最常用的方法就是 &lt;code&gt;read()&lt;/code&gt; ，&lt;code&gt;readlines()&lt;/code&gt; 两个方法，在操作结束后都要调用 &lt;code&gt;close()&lt;/code&gt; 方法关闭文件，释放资源。&lt;/p&gt;
&lt;p&gt;先来看 &lt;code&gt;read()&lt;/code&gt; 方法&lt;/p&gt;
&lt;h3 id=&quot;read&quot;&gt;read()&lt;/h3&gt;
&lt;p&gt;打开文件后，&lt;/p&gt;
&lt;p&gt;来看一个例子，假设有一个文件名称为 &lt;code&gt;a.txt&lt;/code&gt; 内容为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Good morning, everyone!
Good morning, my student!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先来读取前 4 个字母&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;try:
  f = open('a.txt', 'r')
  print(f.read(4)) # Good
finally:
  if f:
    f.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码为什么要用 &lt;code&gt;try ... finally&lt;/code&gt; 包裹呢？&lt;/p&gt;
&lt;p&gt;这是因为文件操作很可能出现 IO 异常的情况，需要使用 &lt;code&gt;try ... finally&lt;/code&gt; 包住，即使出现异常也能保证 &lt;code&gt;close()&lt;/code&gt; 方法能够正常调用。&lt;/p&gt;
&lt;p&gt;其实还有更简洁的写法，就是使用 &lt;code&gt;with&lt;/code&gt; 语句，它就是一个语法糖，一下就把 &lt;code&gt;try ... finally&lt;/code&gt; 的活都干了。来感受下它的威力&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with open('a.txt', 'r') as f:
  print(f.read(4)) # Good&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;readline&quot;&gt;readline()&lt;/h3&gt;
&lt;p&gt;对于文本文件来说，如果比较大，使用 &lt;code&gt;readline()&lt;/code&gt; 方法则更为合理，可以一次读取一行内容。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with open('a.txt', 'r') as f:
  print(f.readline()) # Good morning teacher!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一次想返回多列文本，可以使用 &lt;code&gt;readlines()&lt;/code&gt; 方法，它会返回一个列表。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with open('a.txt', 'r') as f:
  print(f.readlines()) # ['Good morning teacher!\n', 'Good morning, my student!']&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何写文件&quot;&gt;如何写文件？&lt;/h2&gt;
&lt;p&gt;写文件和读文件操作非常类似，它们的区别就在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;code&gt;open&lt;/code&gt; 方法打开文件时，文件模式需要包含 &lt;code&gt;w&lt;/code&gt; ，&lt;code&gt;a&lt;/code&gt;或者 &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意， 使用 &lt;code&gt;w&lt;/code&gt; 模式打开文件后，执行写入操作，如果文件已经存在，则会将之前的文件内容全部覆盖，之前的数据内容就丢失了啊。如果不想覆盖，还是使用 &lt;code&gt;a&lt;/code&gt; 模式打开吧。&lt;/p&gt;
&lt;p&gt;调用什么方法可以写文件呢？ &lt;code&gt;write()&lt;/code&gt;方法，调用成功后，会返回写入文件的字符长度。&lt;/p&gt;
&lt;p&gt;来看一个例子&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;with open('a.txt', 'w') as f:
  f.write('I am line 1\n')
  f.write('I am line 2\n')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，为什么要加 &lt;code&gt;\n&lt;/code&gt; 呢？这是用来分行的，要不然都挤在一行了。&lt;/p&gt;
&lt;p&gt;注意，这里&lt;strong&gt;如果不使用 &lt;code&gt;with&lt;/code&gt; 语法糖，也一定要显式的调用使用 &lt;code&gt;close&lt;/code&gt; 方法&lt;/strong&gt;。这不仅仅是因为释放资源的原因：在调用 &lt;code&gt;write()&lt;/code&gt; 方法时，操作系统不会立刻将数据写入到文件中，而是先在内存中缓存，等到空闲时再写入文件，最后使用 &lt;code&gt;close()&lt;/code&gt; 方法才会将数据完整的写入到文件中。&lt;/p&gt;
&lt;p&gt;当然，显式调用 &lt;code&gt;flush()&lt;/code&gt; 方法也可以将数据立即写入文件中。综合比较，还是推荐使用 &lt;code&gt;with&lt;/code&gt; 的方式，优雅且完善。&lt;/p&gt;
&lt;h2 id=&quot;如何操作文件和目录&quot;&gt;如何操作文件和目录？&lt;/h2&gt;
&lt;p&gt;除了对文件读和写之外，还会经常用到如获取文件路径，查看文件大小，重命名，删除文件等文件或目录操作。这些操作应该调用哪些方法来完成呢？&lt;/p&gt;
&lt;h3 id=&quot;强大的-os-模块&quot;&gt;强大的 os 模块&lt;/h3&gt;
&lt;p&gt;刚开始接触 os 模块，就被它强大的 API 列表给震撼了，使用这个模块几乎可以完成所有的日常文件和目录操作。为方便以后查询，我专门将这些常用的操作分门别类，做了一个思维导图。一起来看下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/reycg-blog/1340573/o_os_module.png&quot; alt=&quot;os 模块 API 思维导图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中只给出了最简单的功能介绍，如果想要深入了解具体的方法使用，可参考 &lt;a href=&quot;https://docs.python.org/3.6/library/os.html&quot;&gt;python 3.6 os 模块官方地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;学习有时候就是这样，API 太多根本记不住，也没有必要完全记住，只要经常归纳整理，知道要使用的操作在什么地方，叫什么名字，用到的时候去查就可以了。&lt;/p&gt;
&lt;h3 id=&quot;shutil-模块-high-level-file-operations&quot;&gt;shutil 模块— High-level file operations&lt;/h3&gt;
&lt;p&gt;除了 os 模块，还有一个非常有用的模块 &lt;code&gt;shutil&lt;/code&gt; ，它的定位是针对多个文件的高级文件操作（High-level file operations）。相比而言， os 模块大多是对单个文件而言的喽。下面通过几个常用的操作来感受下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复制文件夹 &lt;code&gt;shutil.copytree('olddir', 'newdir')&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;注意， 参数&lt;code&gt;olddir&lt;/code&gt; ,&lt;code&gt;newdir&lt;/code&gt; 只能是目录，而且 &lt;code&gt;newdir&lt;/code&gt; 这个目录不存在才可以&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;移动文件或目录 &lt;code&gt;shutil.move('oldpath','newpath')&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除目录 &lt;code&gt;shutil.rmtree('dir')&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;看上面的 os 思维导图，也有一个删除目录 API &lt;code&gt;os.rmdir(dir)&lt;/code&gt; ，只能删除空目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutil.rmtree&lt;/code&gt; 功能则更高级，无论是空还是非空目录都可以删除，确实是 &lt;code&gt;High-level&lt;/code&gt; 啊 ^_^&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对我来说，这三种常用的操作就可以了。当然 &lt;code&gt;shutil&lt;/code&gt; 的功能远比这些要丰富的多，有兴趣的同学，可以到 &lt;a href=&quot;https://docs.python.org/3.6/library/shutil.html&quot;&gt;官方文档&lt;/a&gt; 去深入了解下。&lt;/p&gt;

&lt;p&gt;本篇主要介绍了 python 中文件常用的操作，内容包括打开文件，读文件，写文件，使用 &lt;code&gt;os&lt;/code&gt; 和 &lt;code&gt;shutil&lt;/code&gt; 模块来操作文件和目录。下篇会介绍 &lt;code&gt;json&lt;/code&gt; 和 &lt;code&gt;xml&lt;/code&gt; 处理，敬请期待。&lt;/p&gt;

</description>
<pubDate>Tue, 13 Nov 2018 23:01:00 +0000</pubDate>
<dc:creator>ReyCG</dc:creator>
<og:description>[TOC] 前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reycg-blog/p/9951788.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用GraphQL - 第九章  在GraphQL中处理多对多关系 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9955901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9955901.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181114061206604-208390466.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core中使用GraphQL&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;上一章中，我们介绍了如何在GraphQL中处理一对多关系，这一章，我们来介绍一下GraphQL中如何处理多对多关系。&lt;/p&gt;
&lt;p&gt;我们继续延伸上一章的需求，上一章中我们引入了客户和订单，但是我们没有涉及订单中的物品。在实际需求中，一个订单可以包含多个物品，一个物品也可以属于多个订单，所以订单和物品之间是一个多对多关系。&lt;/p&gt;
&lt;p&gt;为了创建订单和物品之间的关系，这里我们首先创建一个订单物品实体。&lt;/p&gt;
&lt;h5 id=&quot;orderitem&quot;&gt;OrderItem&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Table(&quot;OrderItems&quot;)]
public class OrderItem
{
    public int Id { get; set; }

    public string Barcode { get; set; }

    [ForeignKey(&quot;Barcode&quot;)]
    public virtual Item Item { get; set; }

    public int Quantity { get; set; }

    public int OrderId { get; set; }

    [ForeignKey(&quot;OrderId&quot;)]
    public virtual Order Order { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成之后，我们还需要修改&lt;code&gt;Order&lt;/code&gt;和&lt;code&gt;Item&lt;/code&gt;实体, 添加他们与&lt;code&gt;OrderItem&lt;/code&gt;之间的关系&lt;/p&gt;
&lt;h5 id=&quot;order&quot;&gt;Order&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Order
{
    public int OrderId { get; set; }
    public string Tag { get; set; }
    public DateTime CreatedAt { get; set; }

    public Customer Customer { get; set; }
    public int CustomerId { get; set; }

    public virtual ICollection&amp;lt;OrderItem&amp;gt; OrderItems { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;item&quot;&gt;Item&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Table(&quot;Items&quot;)]
public class Item
{
    [Key]
    public string Barcode { get; set; }

    public string Title { get; set; }

    public decimal SellingPrice { get; set; }

    public virtual ICollection&amp;lt;OrderItem&amp;gt; OrderItems { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成之后，我们使用如下命令创建数据库迁移脚本，并更新数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dotnet ef migrations add AddOrderItemTable
dotnet ef database update&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;迁移成功之后，我们可以添加一个新的&lt;code&gt;GraphQL&lt;/code&gt;节点，使用这个新节点，我们可以向订单中添加物品。为了实现这个功能，我们首先需要为&lt;code&gt;OrderItem&lt;/code&gt;实体添加它在&lt;code&gt;GraphQL&lt;/code&gt;中对应的类型&lt;code&gt;OrderItemType&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;orderitemtype&quot;&gt;OrderItemType&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class OrderItemType : ObjectGraphType&amp;lt;OrderItem&amp;gt;  
{
    public OrderItemType(IDataStore dateStore)
    {   
        Field(i =&amp;gt; i.ItemId);      

        Field&amp;lt;ItemType, Item&amp;gt;().Name(&quot;Item&quot;).ResolveAsync(ctx =&amp;gt;
        {
            return dateStore.GetItemByIdAsync(ctx.Source.ItemId);
        });         

        Field(i =&amp;gt; i.Quantity);

        Field(i =&amp;gt; i.OrderId);

        Field&amp;lt;OrderType, Order&amp;gt;().Name(&quot;Order&quot;).ResolveAsync(ctx =&amp;gt;
        {
            return dateStore.GetOrderByIdAsync(ctx.Source.OrderId);
        });

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，我们还需要创建一个&lt;code&gt;OrderItemInputType&lt;/code&gt;来定义添加&lt;code&gt;OrderItem&lt;/code&gt;需要哪些字段。&lt;/p&gt;
&lt;h5 id=&quot;orderiteminputtype&quot;&gt;OrderItemInputType&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;public class OrderItemInputType : InputObjectGraphType  
{
    public OrderItemInputType()
    {
        Name = &quot;OrderItemInput&quot;;
        Field&amp;lt;NonNullGraphType&amp;lt;IntGraphType&amp;gt;&amp;gt;(&quot;quantity&quot;);
        Field&amp;lt;NonNullGraphType&amp;lt;IntGraphType&amp;gt;&amp;gt;(&quot;itemId&quot;);
        Field&amp;lt;NonNullGraphType&amp;lt;IntGraphType&amp;gt;&amp;gt;(&quot;orderId&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步，我们需要在&lt;code&gt;InventoryMutation&lt;/code&gt;类中针对&lt;code&gt;OrderItem&lt;/code&gt;添加新的&lt;code&gt;mutation&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&quot;inventorymutation&quot;&gt;InventoryMutation&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Field&amp;lt;OrderItemType, OrderItem&amp;gt;()  
    .Name(&quot;addOrderItem&quot;)
    .Argument&amp;lt;NonNullGraphType&amp;lt;OrderItemInputType&amp;gt;&amp;gt;(&quot;orderitem&quot;, &quot;orderitem input&quot;)
    .ResolveAsync(ctx =&amp;gt;
    {
        var orderItem = ctx.GetArgument&amp;lt;OrderItem&amp;gt;(&quot;orderitem&quot;);
        return dataStore.AddOrderItemAsync(orderItem);
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第四步，我们需要在&lt;code&gt;IDataStore&lt;/code&gt;接口中定义几个新的方法，并在&lt;code&gt;DataStore&lt;/code&gt;类中实现他们&lt;/p&gt;
&lt;h5 id=&quot;idatastore&quot;&gt;IDataStore&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Task&amp;lt;OrderItem&amp;gt; AddOrderItemAsync(OrderItem orderItem);

Task&amp;lt;Order&amp;gt; GetOrderByIdAsync(int orderId);

Task&amp;lt;IEnumerable&amp;lt;OrderItem&amp;gt;&amp;gt; GetOrderItemByOrderIdAsync(int orderId);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;datastore&quot;&gt;DataStore&lt;/h5&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public async Task&amp;lt;OrderItem&amp;gt; AddOrderItemAsync(OrderItem orderItem)
{
    var addedOrderItem = await _context.OrderItems.AddAsync(orderItem);
    await _context.SaveChangesAsync();
    return addedOrderItem.Entity;
}

public async Task&amp;lt;Order&amp;gt; GetOrderByIdAsync(int orderId)
{
    return await _context.Orders.FindAsync(orderId);
}

public async Task&amp;lt;IEnumerable&amp;lt;OrderItem&amp;gt;&amp;gt; GetOrderItemByOrderIdAsync(int orderId)
{
    return await _context.OrderItems
        .Where(o =&amp;gt; o.OrderId == orderId)
        .ToListAsync();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第五步，我们来修改&lt;code&gt;OrderType&lt;/code&gt;类，我们希望查询订单的时候，可以返回订单中的所有物品&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class OrderType : ObjectGraphType&amp;lt;Order&amp;gt;
{
    public OrderType(IDataStore dataStore)
    {
        Field(o =&amp;gt; o.Tag);
        Field(o =&amp;gt; o.CreatedAt);
        Field&amp;lt;CustomerType, Customer&amp;gt;()
        .Name(&quot;Customer&quot;)
        .ResolveAsync(ctx =&amp;gt;
        {
            return dataStore.GetCustomerByIdAsync(ctx.Source.CustomerId);
        });

        Field&amp;lt;OrderItemType, OrderItem&amp;gt;()
        .Name(&quot;Items&quot;)
        .ResolveAsync(ctx =&amp;gt;
        {
            return dataStore.GetOrderItemByOrderIdAsync(ctx.Source.OrderId);
        });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们还需要在&lt;code&gt;Startup&lt;/code&gt;类中注册我们刚定义的2个新类型&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddScoped&amp;lt;OrderItemType&amp;gt;();  
services.AddScoped&amp;lt;OrderItemInputType&amp;gt;();  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是所有的代码修改。现在我们启动项目&lt;/p&gt;
&lt;p&gt;首先我们先为之前添加的订单1, 添加两个物品&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181114061225335-558975420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181114061230183-1112793511.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们来调用查询Order的&lt;code&gt;query&lt;/code&gt;, 结果中订单中物品正确显示了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201811/65831-20181114061241327-1355195949.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20IX&quot;&gt;本文源代码： https://github.com/lamondlu/GraphQL_Blogs/tree/master/Part%20IX&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 22:14:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>ASP.NET Core中使用GraphQL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9955901.html</dc:identifier>
</item>
<item>
<title>asp.net core 的用户注册功能——Identity上手 - 不咬人的蚊子</title>
<link>http://www.cnblogs.com/oukichi/p/9955791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oukichi/p/9955791.html</guid>
<description>&lt;h2&gt;首先请using这个类库。&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; Microsoft.AspNetCore.Identity;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类库老牛逼了，首先是包含了一个IdentityUser类。我们可以自己写一个User类继承IdentityUser，这样一来，很多属性我就不用手动建了。如你所见，我的User没有Emai这个字段，但是IdentityUser有这个字段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User:IdentityUser
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Pass { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DisplayName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime RegisteredTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;如何把用户发来的数据变成一个User并且存入数据库？&lt;/h2&gt;
&lt;h3&gt;显然，我他妈得先创建并且连接一个数据库。&lt;/h3&gt;
&lt;p&gt;创建数据库如果使用VSStudio是贼容易的一件事，只需要打开&lt;em&gt;'视图菜单'&lt;/em&gt;，然后点开&lt;em&gt;'SQL Server对象资源管理器'。&lt;/em&gt;然后你就看到下面这个图。在上面点右键然后添加一个SQL服务器，然后在服务器上点右键查看属性，可以得到链接字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201811/845737-20181114001159699-628965817.png&quot; alt=&quot;&quot;/&gt;                             &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201811/845737-20181114001344708-1942592576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这种简单的操作显然难不住你。下一步把连接字符串放到appsetting.json里面，下面这是一种推荐做法。你当然可以直接粘贴到你的startUp.cs文件中。不过谁会这么做呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&quot;ConnectionStrings&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;DefaultConnection&quot;: &quot;这里就是你的连接字符串&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下一步要用这个连接字符串连上你的数据库。&lt;strong&gt;注意带颜色的字。很JB重要。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        //&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.Configure&lt;/span&gt;&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This lambda determines whether user consent for non-essential cookies is needed for a given request.&lt;/span&gt;
                options.CheckConsentNeeded = context =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.None;
            });
　　　　　　　　&lt;span&gt;// 看到了么，下面这行代码用来连接数据库。这是EF提供的方法。
            services.AddDbContext&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;AppContext&amp;gt;(options =&amp;gt; options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));
　　　　　　　　&lt;span&gt;// 在这里指定你的User类，然后再指定你的数据库。这是Identity类库提供的方法。
            services.AddDefaultIdentity&amp;lt;User&amp;gt;().AddEntityFrameworkStores&amp;lt;AppContext&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;

            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                app.UseHsts();
            }

            app.UseHttpsRedirection();
            app.UseStaticFiles();
            app.UseCookiePolicy();
　　　　　　　&lt;span&gt;// 这里必须用上。
            app.UseAuthentication();&lt;/span&gt;
            app.UseMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;经过上面的配置，controller里面就可以注入很多方法。这下你看起来牛逼多了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;数据库连上了，接下来是真枪实弹的创建一个用户，是时候写controller了。&lt;/h2&gt;
&lt;p&gt;建一个随便什么controller吧。我建的是UserController，你可以随你的便。关我屌事呢？&lt;/p&gt;
&lt;p&gt;在controller的构造函数里面注入一个UserManager的类，这个类也是Identity提供的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; UserManager&amp;lt;User&amp;gt;&lt;span&gt; _userManager;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserController(&lt;span&gt;UserManager&amp;lt;User&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; userManager&lt;/span&gt;)
        {
            _userManager &lt;/span&gt;=&lt;span&gt; userManager;
        }
&lt;span&gt;......&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个UserManager有贼多的方法，这里我只用一个，createAsync方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST: api/User&lt;/span&gt;
&lt;span&gt; [HttpPost]
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task PostAsync([FromBody]User _user)
 {   
     &lt;span&gt;//先创建一个user，不包括密码&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;     var user = new User { Email = _user.Email , UserName = _user.UserName};&lt;br/&gt;//将user和密码绑定入库
     var result = await _userManager.CreateAsync(user, _user.Pass);
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
     {
         Console.Write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用Postman模拟一个请求。你注意到那个FromBody了吗？这个标记可以把发过来的json请求解析成User格式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201811/845737-20181114004016502-434121322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里有一个新手大坑。如果你的 [FromBody] &lt;span&gt;User&lt;/span&gt; _user这里写的是[FromBody] &lt;span&gt;string&lt;/span&gt; _user， 你就不能用json格式发。会报什么json解析错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;span&gt;发送请求以后去看看你的数据库吧。已经创建好了一个User对象并且存到了你的数据库里。&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201811/845737-20181114003333371-336144298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; 这么多字段都是来自IdentityUser类，其中只有那个pass字段是我自己UserClass里面的。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Tue, 13 Nov 2018 16:42:00 +0000</pubDate>
<dc:creator>不咬人的蚊子</dc:creator>
<og:description>首先请using这个类库。 这个类库老牛逼了，首先是包含了一个IdentityUser类。我们可以自己写一个User类继承IdentityUser，这样一来，很多属性我就不用手动建了。如你所见，我的U</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oukichi/p/9955791.html</dc:identifier>
</item>
<item>
<title>webpack4+node合并资源请求, 实现combo功能(二十三) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/9955710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/9955710.html</guid>
<description>&lt;p&gt;本文学习使用nodejs实现css或js资源文件的合并请求功能，我们都知道在一个复杂的项目当中，可能会使用到很多第三方插件，虽然目前使用vue开发系统或者h5页面，vue组件够用，但是有的项目中会使用到类似于echarts这样的插件，或者第三方其他的插件，比如ztree.js这样的，那如果我们把所有js都打包到一个js文件当中，那么该js可能会变得非常大，或者我们可能会把他们单独打包一个个js文件去，然后在页面中分别一个个使用script标签去引入他们，但是这样会导致页面多个js请求。因此就想使用node来实现类似于combo功能，比如以下的js功能构造：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:3001/jsplugins/??a.js,b.js&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上的js请求，会把a.js和b.js合并到一个请求里面去， 然后使用node就实现了combo功能。&lt;br/&gt;首先我们来分析下上面的请求，该请求中的 ?? 是一个分隔符，分隔符前面是合并的文件路径，后面是合并资源文件名，多个文件名使用逗号(,)隔开，知道了该请求的基本原理之后，我们需要对该请求进行解析，解析完成后，分别读取该js文件内容，然后分别读取到内容后合并起来输出到浏览器中。&lt;/p&gt;
&lt;p&gt;首先看下我们项目简单的目录架构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### 目录结构如下：
demo1                                       # 工程名           
&lt;/span&gt;|   |---&lt;span&gt; node_modules                       # 所有的依赖包
&lt;/span&gt;|   |---&lt;span&gt; jsplugins
&lt;/span&gt;|   | |--&lt;span&gt; a.js
&lt;/span&gt;|   | |--&lt;span&gt; b.js
&lt;/span&gt;|   |---&lt;span&gt; app.js
&lt;/span&gt;|   |--- package.json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181113234927892-2086413361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jsplugins/a.js 内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testA() {
  console.log(&lt;/span&gt;'A.js'&lt;span&gt;);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jsplugins/b.js 内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; testB() {
  console.log(&lt;/span&gt;'b.js'&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们访问 http://127.0.0.1:3001/jsplugins/??a.js,b.js 请求后，资源文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181113235019587-194347510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何实现呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;app.js 一部分代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express模块&lt;/span&gt;
const express = require('express'&lt;span&gt;);

const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建app对象&lt;/span&gt;
const app =&lt;span&gt; express();

app.use((req, res, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  const urlInfo &lt;/span&gt;=&lt;span&gt; parseURL(__dirname, req.url);
  console.log(urlInfo);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (urlInfo) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并文件&lt;/span&gt;
    combineFiles(urlInfo.pathnames, (err, data) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        res.writeHead(&lt;/span&gt;404&lt;span&gt;);
        res.end(err.message);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        res.writeHead(&lt;/span&gt;200&lt;span&gt;, {
          &lt;/span&gt;'Content-Type'&lt;span&gt;: urlInfo.mime
        });
        res.end(data);
      }
    });
  }
});


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义服务器启动端口 &lt;/span&gt;
app.listen(3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'app listening on port 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，使用express实现一个简单的，端口号为3001的服务器，然后使用 app.use模块截取请求，比如我们现在在浏览器中访问 http://127.0.0.1:3001/jsplugins/??a.js,b.js 这个请求的时候，会对该请求进行解析，会调用 parseURL方法，该方法的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
let MIME =&lt;span&gt; {
  &lt;/span&gt;'.css': 'text/css'&lt;span&gt;,
  &lt;/span&gt;'.js': 'application/javascript'&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析文件路径&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseURL(root, url) {
  let base, 
    pastnames,
    separator;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url.indexOf('??') &amp;gt; -1&lt;span&gt;) {
    separator &lt;/span&gt;= url.split('??'&lt;span&gt;);
    base &lt;/span&gt;= separator[0&lt;span&gt;];

    pathnames &lt;/span&gt;= separator[1].split(',').map((value) =&amp;gt;&lt;span&gt; {
      const filepath &lt;/span&gt;=&lt;span&gt; path.join(root, base, value);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filepath;
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      mime: MIME[path.extname(pathnames[&lt;/span&gt;0])] || 'text/plain'&lt;span&gt;,
      pathnames: pathnames
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，给parseURL函数传递了两个参数，一个是 __dirname 和 req.url, 其中__dirname就是当前app.js文件的所在目录，因此会打印出该目录下全路径：/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件， req.url返回的是url中的所有信息，因此 req.url='/jsplugins/??a.js,b.js', 然后判断url中是否有 ?? 这样的，找到的话，就使用 ?? 分割，如下代码：&lt;/p&gt;
&lt;p&gt;separator = url.split('??');&lt;br/&gt;base = separator[0];&lt;/p&gt;
&lt;p&gt;因此 base = '/jsplugins/', separator[1] = a.js,b.js了，然后再进行对 separator[1] 使用逗号(,) 分割变成数组进行遍历a.js和b.js了，遍历完成后，如代码 const filepath = path.join(root, base, value); 使用path.join()对路径进行合并，该方法将多个参数值字符串结合为一个路径字符串，path.join基本使用，看我这篇文章&lt;br/&gt;(&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9944285.html#_labe1&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/9944285.html#_labe1&lt;/a&gt;),&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
root = '/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件'&lt;span&gt;
base &lt;/span&gt;= '/jsplugins/'&lt;span&gt;;
value &lt;/span&gt;= 'a.js' 或 value = 'b.js';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此 pathnames 的值最终变成如下的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[ '/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件/jsplugins/a.js'&lt;span&gt;,
  &lt;/span&gt;'/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件/jsplugins/b.js' ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完parseURL后返回的是如下对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{ 
  mime: &lt;/span&gt;'application/javascript'&lt;span&gt;,
  pathnames:
   [ &lt;/span&gt;'/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件/jsplugins/a.js'&lt;span&gt;,
     &lt;/span&gt;'/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件/jsplugins/b.js'&lt;span&gt; 
   ] 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;path.extname 的使用可以看如下这篇文章(&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9944285.html#_labe4&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/9944285.html#_labe4&lt;/a&gt;),就是拿到路径的扩展名，那么拿到的扩展名就是 .js, 然后 mime = MIME[path.extname(pathnames[0])] || 'text/plain', 因此 mine = 'application/javascript' 了。&lt;/p&gt;
&lt;p&gt;返回值后，就会执行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (urlInfo) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并文件&lt;/span&gt;
  combineFiles(urlInfo.pathnames, (err, data) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      res.writeHead(&lt;/span&gt;404&lt;span&gt;);
      res.end(err.message);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      res.writeHead(&lt;/span&gt;200&lt;span&gt;, {
        &lt;/span&gt;'Content-Type'&lt;span&gt;: urlInfo.mime
      });
      res.end(data);
    }
  });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先合并文件，文件合并后，再执行回调，把合并后的js输出到浏览中，先看下 combineFiles 函数的方法代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并文件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; combineFiles(pathnames, callback) {
  const output &lt;/span&gt;=&lt;span&gt; [];
  (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextFunc(l, len){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l &amp;lt;&lt;span&gt; len) {
      fs.readFile(pathnames[l], (err, data) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
          callback(err);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          output.push(data);
          nextFunc(l&lt;/span&gt;+1&lt;span&gt;, len);
        }
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      const data &lt;/span&gt;=&lt;span&gt; Buffer.concat(output);
      callback(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, data);
    }
  })(&lt;/span&gt;0&lt;span&gt;, pathnames.length);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先该方法传了 pathnames 和callback回调，其中pathnames的值是如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[ '/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件/jsplugins/a.js'&lt;span&gt;,
  &lt;/span&gt;'/Users/tugenhua/个人demo/webpack-all-demo2/webpack-all-demo/webpack+node合并js资源请求文件/jsplugins/b.js'&lt;span&gt; 
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后一个使用立即函数先执行，把 0, 和 长度参数传递进去，判断是否小于文件的长度，如果是的话，就是 fs中的读取文件方法 (readFile), 就依次读取文件，对 readFile读取文件的方法不熟悉的话，可以看这篇文章(&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9942886.html#_labe0&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tugenhua0707/p/9942886.html#_labe0&lt;/a&gt;), 读取完后使用 Buffer.concat进行拼接。最后把数据传给callback返回到回调函数里面去，执行回调函数，就把对应的内容输出到浏览器中了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1. 使用 fs.readFile 方法，如果没有设置指定的编码，它会以字节的方式读取的，因此使用Buffer可以进行拼接。&lt;br/&gt;2. 使用Buffer.concat拼接的时候，如果a.js或b.js有中文的话，会出现乱码，出现的原因是如果js文件是以默认的gbk保存的话，那么我们nodejs默认是utf8读取的，就会有乱码存在的，因此js文件如果是本地的话，尽量以utf8保存。如果不是utf8保存的话，出现了乱码，我们需要解决，下一篇文章就来折腾下 Buffer出现乱码的情况是如何解决的。&lt;/p&gt;
&lt;p&gt;因此整个app.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express模块&lt;/span&gt;
const express = require('express'&lt;span&gt;);

const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建app对象&lt;/span&gt;
const app =&lt;span&gt; express();

app.use((req, res, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  const urlInfo &lt;/span&gt;=&lt;span&gt; parseURL(__dirname, req.url);
  console.log(urlInfo);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (urlInfo) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并文件&lt;/span&gt;
    combineFiles(urlInfo.pathnames, (err, data) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        res.writeHead(&lt;/span&gt;404&lt;span&gt;);
        res.end(err.message);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        res.writeHead(&lt;/span&gt;200&lt;span&gt;, {
          &lt;/span&gt;'Content-Type'&lt;span&gt;: urlInfo.mime
        });
        res.end(data);
      }
    });
  }
});

let MIME &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;'.css': 'text/css'&lt;span&gt;,
  &lt;/span&gt;'.js': 'application/javascript'&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析文件路径&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseURL(root, url) {
  let base, 
    pastnames,
    separator;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url.indexOf('??') &amp;gt; -1&lt;span&gt;) {
    separator &lt;/span&gt;= url.split('??'&lt;span&gt;);
    base &lt;/span&gt;= separator[0&lt;span&gt;];

    pathnames &lt;/span&gt;= separator[1].split(',').map((value) =&amp;gt;&lt;span&gt; {
      const filepath &lt;/span&gt;=&lt;span&gt; path.join(root, base, value);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filepath;
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      mime: MIME[path.extname(pathnames[&lt;/span&gt;0])] || 'text/plain'&lt;span&gt;,
      pathnames: pathnames
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并文件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; combineFiles(pathnames, callback) {
  const output &lt;/span&gt;=&lt;span&gt; [];
  (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextFunc(l, len){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l &amp;lt;&lt;span&gt; len) {
      fs.readFile(pathnames[l], (err, data) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
          callback(err);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          output.push(data);
          nextFunc(l&lt;/span&gt;+1&lt;span&gt;, len);
        }
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      const data &lt;/span&gt;=&lt;span&gt; Buffer.concat(output);
      callback(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, data);
    }
  })(&lt;/span&gt;0&lt;span&gt;, pathnames.length);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义服务器启动端口 &lt;/span&gt;
app.listen(3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'app listening on port 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/webpack-all-demo/tree/master/webpack%2Bnode%E5%90%88%E5%B9%B6js%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E6%96%87%E4%BB%B6&quot; target=&quot;_blank&quot;&gt;github上的代码查看请点击&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：combo功能合并资源文件后如何在项目中能实战呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如上使用node实现了资源文件combo功能后，我们会把该技术使用到项目中去，那么这个项目还是我们之前的这篇文章的项目--- &lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/9926725.html&quot; target=&quot;_blank&quot;&gt;webpack4+express+mongodb+vue 实现增删改查。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目录结构还是和以前一样的，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### 目录结构如下：
demo1                                       # 工程名
&lt;/span&gt;|   |---&lt;span&gt; dist                               # 打包后生成的目录文件             
&lt;/span&gt;|   |---&lt;span&gt; node_modules                       # 所有的依赖包
&lt;/span&gt;|   |----&lt;span&gt;database                           # 数据库相关的文件目录
&lt;/span&gt;|   | |---&lt;span&gt;db.js                             # mongoose类库的数据库连接操作
&lt;/span&gt;|   | |---&lt;span&gt;user.js                           # Schema 创建模型
&lt;/span&gt;|   | |---&lt;span&gt;addAndDelete.js                   # 增删改查操作
&lt;/span&gt;|   |---&lt;span&gt; app
&lt;/span&gt;|   | |---&lt;span&gt;index
&lt;/span&gt;|   | | |--&lt;span&gt; views                           # 存放所有vue页面文件
&lt;/span&gt;|   | | | |--&lt;span&gt; list.vue                      # 列表数据
&lt;/span&gt;|   | | | |--&lt;span&gt; index.vue
&lt;/span&gt;|   | | |--&lt;span&gt; components                      # 存放vue公用的组件
&lt;/span&gt;|   | | |--&lt;span&gt; js                              # 存放js文件的
&lt;/span&gt;|   | | |--&lt;span&gt; css                             # 存放css文件
&lt;/span&gt;|   | | |--&lt;span&gt; store                           # store仓库
&lt;/span&gt;|   | | | |---&lt;span&gt; actions.js
&lt;/span&gt;|   | | | |---&lt;span&gt; mutations.js
&lt;/span&gt;|   | | | |---&lt;span&gt; state.js
&lt;/span&gt;|   | | | |--- mutations-&lt;span&gt;types.js
&lt;/span&gt;|   | | | |---&lt;span&gt; index.js
&lt;/span&gt;|   | | | |
|   | | |--&lt;span&gt; app.js                          # vue入口配置文件
&lt;/span&gt;|   | | |--&lt;span&gt; router.js                       # 路由配置文件
&lt;/span&gt;|   |---&lt;span&gt; views
&lt;/span&gt;|   | |--&lt;span&gt; index.html                        # html文件
&lt;/span&gt;|   |---&lt;span&gt; webpack.config.js                  # webpack配置文件 
&lt;/span&gt;|   |---&lt;span&gt; .gitignore  
&lt;/span&gt;|   |---&lt;span&gt; README.md
&lt;/span&gt;|   |---&lt;span&gt; package.json
&lt;/span&gt;|   |---&lt;span&gt; .babelrc                           # babel转码文件
&lt;/span&gt;|   |--- app.js                             # express入口文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;唯一不同的是，在webpack.dll.config.js 对公用的模块进行打包会把 vue 和 echarts 会打包成二个文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入口文件&lt;/span&gt;
&lt;span&gt;  entry: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 项目中用到该依赖库文件&lt;/span&gt;
    vendor: ['vue/dist/vue.esm.js', 'vue', 'vuex', 'vue-router', 'vue-resource'&lt;span&gt;],
    echarts: [&lt;/span&gt;'echarts'&lt;span&gt;]
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出文件&lt;/span&gt;
&lt;span&gt;  output: {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件名称&lt;/span&gt;
    filename: '[name].dll.[chunkhash:8].js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将输出的文件放到dist目录下&lt;/span&gt;
    path: path.resolve(__dirname, './dist/components'&lt;span&gt;),

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll
     是为了防止全局变量冲突。
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    library: &lt;/span&gt;'_dll_[name]'&lt;span&gt;
  },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此会在我们项目中 dist/components/ 下生成两个对应的 vendor.dll.xx.js 和 echarts.dll.xx.js, 如下所示&lt;br/&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181114000040318-566210824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后把 刚刚的js代码全部复制到我们的 该项目下的 app.js 下：如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入express模块&lt;/span&gt;
const express = require('express'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建app对象&lt;/span&gt;
const app =&lt;span&gt; express();

const addAndDelete &lt;/span&gt;= require('./database/addAndDelete'&lt;span&gt;);

const bodyParser &lt;/span&gt;= require(&quot;body-parser&quot;&lt;span&gt;);

const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
const path &lt;/span&gt;= require('path'&lt;span&gt;);

app.use(bodyParser.json());

app.use(bodyParser.urlencoded({ extended: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt; }));

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用&lt;/span&gt;
app.use('/api'&lt;span&gt;, addAndDelete);

let MIME &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;'.css': 'text/css'&lt;span&gt;,
  &lt;/span&gt;'.js': 'application/javascript'&lt;span&gt;
};

app.use((req, res, next) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  const urlInfo &lt;/span&gt;=&lt;span&gt; parseURL(__dirname, req.url);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (urlInfo) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并文件&lt;/span&gt;
    combineFiles(urlInfo.pathnames, (err, data) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        res.writeHead(&lt;/span&gt;404&lt;span&gt;);
        res.end(err.message);
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        res.writeHead(&lt;/span&gt;200&lt;span&gt;, {
          &lt;/span&gt;'Content-Type'&lt;span&gt;: urlInfo.mime
        });
        res.end(data);
      }
    });
  }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析文件路径&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; parseURL(root, url) {
  let base, 
    pastnames,
    separator;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url.indexOf('??') &amp;gt; -1&lt;span&gt;) {
    separator &lt;/span&gt;= url.split('??'&lt;span&gt;);
    base &lt;/span&gt;= separator[0&lt;span&gt;];

    pathnames &lt;/span&gt;= separator[1].split(',').map((value) =&amp;gt;&lt;span&gt; {
      const filepath &lt;/span&gt;=&lt;span&gt; path.join(root, base, value);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; filepath;
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      mime: MIME[path.extname(pathnames[&lt;/span&gt;0])] || 'text/plain'&lt;span&gt;,
      pathnames: pathnames
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并文件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; combineFiles(pathnames, callback) {
  const output &lt;/span&gt;=&lt;span&gt; [];
  (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextFunc(l, len){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l &amp;lt;&lt;span&gt; len) {
      fs.readFile(pathnames[l], (err, data) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
          callback(err);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          output.push(data);
          nextFunc(l&lt;/span&gt;+1&lt;span&gt;, len);
        }
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      const data &lt;/span&gt;=&lt;span&gt; Buffer.concat(output);
      callback(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, data);
    }
  })(&lt;/span&gt;0&lt;span&gt;, pathnames.length);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义服务器启动端口 &lt;/span&gt;
app.listen(3001, () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'app listening on port 3001'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上完成后，在我们的页面引入该合并后的js即可：index.html 如下引入方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;../combineFile/dist/components/??vendor.dll.afa07023.js,echarts.dll.38cfc51b.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上引入，为什么我们的js前面会使用 combineFile 这个目录呢，这是为了解决跨域的问题的，因此我们app.js 是在端口号为3001服务器下的，而我们的webpack4的端口号8081，那页面直接访问 http://localhost:8081/#/list 的时候，肯定会存在跨域的情况下，因此前面加了个 combineFile文件目录，然后在我们的webpack中的devServer.proxy会代理下实现跨域，如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  devServer: {
    port: &lt;/span&gt;8081&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; host: '0.0.0.0',&lt;/span&gt;
&lt;span&gt;    headers: {
      &lt;/span&gt;'X-foo': '112233'&lt;span&gt;
    },
    inline: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    overlay: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    stats: &lt;/span&gt;'errors-only'&lt;span&gt;,
    proxy: {
      &lt;/span&gt;'/api'&lt;span&gt;: {
        target: &lt;/span&gt;'http://127.0.0.1:3001'&lt;span&gt;,
        changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否跨域&lt;/span&gt;
&lt;span&gt;      },
      &lt;/span&gt;'/combineFile'&lt;span&gt;: {
        target: &lt;/span&gt;'http://127.0.0.1:3001'&lt;span&gt;,
        changeOrigin: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否跨域,&lt;/span&gt;
&lt;span&gt;        pathRewrite: {
          &lt;/span&gt;'^/combineFile' : ''  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写路径&lt;/span&gt;
&lt;span&gt;        }
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对请求为 '/combineFile' 会把它代理到 'http://127.0.0.1:3001',下，并且pathRewrite这个参数重写路径，以'^/combineFile' : '' 开头的，会替换成空，因此当我们使用肉眼看到的如下这个请求：&lt;br/&gt;http://127.0.0.1:8081/combineFile/dist/components/??vendor.dll.afa07023.js,echarts.dll.38cfc51b.js&lt;/p&gt;
&lt;p&gt;它会被转义成 ：&lt;br/&gt;http://127.0.0.1:3001/dist/components/??vendor.dll.afa07023.js,echarts.dll.38cfc51b.js&lt;/p&gt;
&lt;p&gt;这个请求，因此就不会跨域了。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181114000227755-362213992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201811/561794-20181114000235942-581839011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/webpack-all-demo/tree/master/webpack%2Bvue%2Bmongodb%E5%90%88%E5%B9%B6%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82&quot; target=&quot;_blank&quot;&gt;github源码查看&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 16:04:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>webpack4+node合并资源请求, 实现combo功能(二十三)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/9955710.html</dc:identifier>
</item>
<item>
<title>WebRTC系列(1)-手把手教你实现一个浏览器拍照室Demo - Peer1029</title>
<link>http://www.cnblogs.com/peerless1029/p/9955640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/9955640.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.WebRTC开发背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;由于业务需求，需要在项目中实现实时音视频通话功能，之前基于浏览器开发的Web项目要进行音视频通话，需要安装flash插件才能实现或者使用C/S客户端进行通信。随着互联网技术的驱动下，在很多场景下需要进行音视频通信，在生活中我们现在使用电话越来越少，使用微信和视频越来越多。在一些行业也需要进行音视频实时通信，如：在线教育，远程医疗，保险理赔等等。有了WebRTC，可以开发一些好的网页应用，使得音视频通话越来越简单，无需安装任何插件，只需打开网页，就能实现音视频通话，方然也能实现消息收发，文件收发等等，下面，根据自己平时的项目开发与，对WebRTC就行一个简单的理解与概述，最终实现一个简单的拍照室Demo。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.WebRTC历史和概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　WebRTC是“网络实时通信”（Web Real Time Communication）的缩写。它最初是为了解决浏览器上视频通话而提出的，即两个浏览器之间直接进行视频和音频的通信，不经过服务器。后来发展到除了音频和视频，还可以传输文字和其他数据。2010年5月，Google以6820万美元收购VoIP软件开发商Global IP Solutions的GIPS引擎，并改为名为“WebRTC”。WebRTC使用GIPS引擎，实现了基于网页的视频会议，并支持722，PCM，ILBC，ISAC等编码，同时使用谷歌自家的&lt;a href=&quot;https://baike.baidu.com/item/VP8&quot; target=&quot;_blank&quot;&gt;VP8&lt;/a&gt;视频解码器；同时支持RTP/SRTP传输等。Google是WebRTC的主要支持者和开发者，它推动了WebRTC标准的确立。&lt;/p&gt;
&lt;p&gt;　　WebRTC是一门年轻的技术，从2011推出到2017年，一直发展的不温不火。根据一段时间的开发，个人认为主要原因有：各个浏览器的支持兼容程度和在互联网环境下点对点能够连接的成功率。从2017年苹果公司宣布iOS11的Safari浏览器支持WebRTC，一些云通信产品例如腾讯云通信和网易云通信也是基于WebRTC上进行封装二次开发，也间接的说明了WebRTC发展会越来越好。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113213153295-1938379079.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;302&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113213236919-395217146.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.基本概念的了解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了简化开发，WebRTC在浏览器中API集成了大量的技术，解决了一些繁重的问题，如捕捉摄像头和麦克风，处理音视频流，传输层等等。&lt;/p&gt;
&lt;p&gt;    　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113214636299-2106035827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;捕捉摄像头和麦克风&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　建立通信平台第一步要检测用户设备的摄像头和麦克风权限，先检测设备的可用性，然后在获取用户授权并与设备建立连接，最后获取一段数据流。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;音频与视频的编解码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　在互联网要发送一段音视频数据，技术优化了网络数据，数据尺寸也还是很大，所以要对数据在发送端编码，然后在接收端解码。WebRTC内置的几种编解码器包括：H.264,Opcus,iSAC,VP8。作为前端开发的我，最这些编解码技术当然不是很了解。幸运的是，当两个浏览器回话时，会综合两端情况选择最优的编解码器。&lt;/p&gt;
&lt;p&gt;　　主要处理数据丢包，数据包排序以及建立用户之间的连接问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会话管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　通常来说就是信令（Signaling），负责在浏览器中建立并管理多个连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;.获取用户媒体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　创建一个基于WebRTC的通信平台，首先要通过用户的网络摄像头和麦克风获取实时的视频和音频流，可以通过调用浏览器的getUserMedia API来实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;获取媒体流&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
  &amp;lt;h1&amp;gt;获取媒体流&amp;lt;/h1&amp;gt;
  &amp;lt;video autoplay&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
  function hasUserMedia() {
    return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
  }

  if (hasUserMedia()) {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    navigator.getUserMedia({video: true, audio: false}, function (stream) {
      console.log(stream);
      var video = document.querySelector('video');
      video.src=window.URL.createObjectURL(stream);
    }, function (err) {
      console.log(err);
    });
  } else {
    alert(&quot;Sorry, your browser does not support getUserMedia.&quot;);
  }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113223409376-1575776524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否打开使用摄像头权限&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113223403753-610458148.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：打开摄像头后获取到的视频流展示在Video标签中，video标签需要加上autoplay属性视频才可以播放，在调试中可以把getUserMedia方法参数中的audio设置为：false，避免杂音太大，同理，把video设置为false只能听到自己说话而没有画面，可以代替普通电话使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.限制视频流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们可以通过设置参数来控制视频和音频是否使用，除此之外，我们可以传入一个对象做更复杂的限制，如分辨率，视频宽高比等等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
navigator.getUserMedia({video: {
        width: 320,
        /*height:240,*/
        aspectRatio:1.77
      }, audio: false}, function (stream) {
      console.log(stream);
      var video = document.querySelector('video');
      video.src=window.URL.createObjectURL(stream);
    }, function (err) {
      console.log(err);
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113225829625-1572589540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以根据自己业务需求来设置固定的宽高或分辨率等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.完成一个拍照室Demo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;通过调用摄像头获取到的视频流以及H5的canvas标签我们可以完成一个简易的拍照功能。&lt;/p&gt;
&lt;p&gt;增加一个拍照按钮以及一个canvas,修改后的整个页面代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;获取媒体流&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;app&quot;&amp;gt;
  &amp;lt;h1&amp;gt;获取媒体流&amp;lt;/h1&amp;gt;
  &amp;lt;video id=&quot;video&quot; autoplay&amp;gt;&amp;lt;/video&amp;gt;
  &amp;lt;button type=&quot;button&quot; onclick=&quot;capture()&quot;&amp;gt;点击拍照&amp;lt;/button&amp;gt;
  &amp;lt;canvas id=&quot;canvas&quot; width=&quot;320&quot; height=&quot;240&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
  function hasUserMedia() {
    return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
  }

  if (hasUserMedia()) {
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
    navigator.getUserMedia({video: {
        width: 320,
        height:240,
      }, audio: false}, function (stream) {
      console.log(stream);
      var video = document.querySelector('video');
      video.src=window.URL.createObjectURL(stream);
    }, function (err) {
      console.log(err);
    });
  } else {
    alert(&quot;Sorry, your browser does not support getUserMedia.&quot;);
  }

  function capture(){
    console.log('capture...');
    var cxt=document.getElementById('canvas').getContext('2d');
    var video=document.getElementById('video');
    cxt.drawImage(video,0,0);
  }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113230934749-1801191869.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在单击一个点击拍照按钮，可以捕捉视频的某一帧并同时绘制到canvas上，加上canvas功能本来就很强大，后期对照片的旋转，剪裁，滤镜也都是可以实现的。&lt;/p&gt;
&lt;p&gt;延伸：现在很多WebApp上要实时上传证件功能，我们通过这种WebRTC+canvas也是可以实现的，而且是浏览器直接调的硬件拍照，有没有很溜。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.开发中遇到的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在直接用http打开本地服务器页面是调用不了摄像头的，浏览器的限制认为http下是不安全的，但是可以用127.0.0.1或者localhost来代替本机ip。网页部署到服务器时也得使用https协议来返回页面，否则，无法调用摄像头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201811/1103967-20181113231722370-1973016032.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;304&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以上简单的介绍了WebRTC的发展历史以及一些基本概念，让大家对其有个初步的了解，最后通过调用摄像头完成一个拍照室的Demo。后续文章再详细的写如何通过WebRTC来实现点对点通信，相信WebRTC功能会越来越强大，这只是第一步。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《Learning WebRTC 中文版》　&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://javascript.ruanyifeng.com/htmlapi/webrtc.html#toc3&quot; target=&quot;_blank&quot;&gt;《JavaScript 标准参考教程（alpha） 阮一峰》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  &lt;a href=&quot;https://baike.baidu.com/item/WebRTC/5522744?fr=aladdin&quot; target=&quot;_blank&quot;&gt;WebRTC百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处，谢谢。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 15:44:00 +0000</pubDate>
<dc:creator>Peer1029</dc:creator>
<og:description>1.WebRTC开发背景 由于业务需求，需要在项目中实现实时音视频通话功能，之前基于浏览器开发的Web项目要进行音视频通话，需要安装flash插件才能实现或者使用C/S客户端进行通信。随着互联网技术的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peerless1029/p/9955640.html</dc:identifier>
</item>
<item>
<title>孤荷凌寒自学python第六天 列表的嵌套与列表的主要方法 - 孤荷凌寒</title>
<link>http://www.cnblogs.com/lhghroom/p/9955564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhghroom/p/9955564.html</guid>
<description>
&lt;p&gt;&lt;span&gt;（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（同步的语音笔记朗读：&lt;a href=&quot;https://www.ximalaya.com/keji/19103006/136365944&quot;&gt;https://www.ximalaya.com/keji/19103006/136365944&lt;/a&gt; ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、列表的嵌套&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;列表的嵌套可以理解为，将多个列表作为上层列表的其中的元素看待。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[[1,2,3],[4,5,6]]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红色方括号所表示出的这个列表中有两个元素：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第0个元素：[1,2,3]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1个元素：[4,5,6]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它的两个元素，本身又是列表对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此称之为嵌套列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实上面举例的嵌套列表，表示了两个维度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是一个表格一样的两维数据矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以也可以有更多维度的嵌套列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;书写代码时可以直接将列表进行嵌套：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=[1,2,3]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstB=[4,5,6]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstC=[lstA,lstB]    #此代码，将lstA,lstB这两个列表作为元素放入列表lstC中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstC)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[[1, 2, 3], [4, 5, 6]]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、列表的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Python语言中，对象的方法，在代码书写上与其它语言一致，使用.连接符来表示对象的内部方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象名.方法名（参数或可选参数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数或可选参数是指，需要传递给方法的一些初始值，以便方法对这些值进行运算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是初学编程的朋友，可以这样解释下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象，你可以理解为现实生活中的一个企业或单位，那么这个企业或单位有它的名称、从业范围等等信息，这些信息我们称之为：对象的&lt;strong&gt;属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而一个企业或单位也有它的可以执行的操作，比如&lt;strong&gt;&lt;em&gt;加工客户送来的原材料成为指定的零件&lt;/em&gt;&lt;/strong&gt;这个操作过程，把这样的企业或单位可以执行的内部操作，我们称之为对象的&lt;strong&gt;方法&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理解了对象的方法，那么就能理解方法名后面的参数或可选参数的意思了，以这儿举例的“&lt;strong&gt;&lt;em&gt;加工客户送来的原材料成为指定的零件&lt;/em&gt;&lt;/strong&gt;”这个&lt;strong&gt;方法&lt;/strong&gt;为例，要完成这个方法，客户必须要给这个方法“原材料”，还要给告诉方法“要完成的零件的特征”，“原材料”与“要完成的零件的特征”等就称之为这个方法的“&lt;strong&gt;参数”&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可选参数&lt;/strong&gt;是指，可以告诉方法，也可以不告诉方法的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行对象的一个方法后，方法&lt;strong&gt;可能会&lt;/strong&gt;返回一个对象，这就好比刚才举的例子，“&lt;strong&gt;&lt;em&gt;加工客户送来的原材料成为指定的零件&lt;/em&gt;&lt;/strong&gt;”这个方法操作完成后，会返回给客户一个加工好的零件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然只是说，执行对象的一个方法后，可能会返回一个对象，但不是每个方法都会有返回对象，有的方法就不会返回任何内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、列表对象的常用方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 append(obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向列表的最后追加一个元素，参数obj是要添加的元素对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 count(obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统计列表中值为obj对象的元素的总个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('abcabcbcdcde')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA.count('c'))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 extend(otherlist)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将列表otherlist中的所有元素追加到当前列表序列中的元素后面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例 ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('ab')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstB=list('CD')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA.extend(lstB)   #此代码，将lstB中的两个元素‘C’，‘D’追加到lstA最后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['a', 'b', 'C', 'D']     #lstA中的元素发生的变化 ，而lstB的内容没有变化 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4 index(obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回列表中所有元素中第一个obj对象所在的index值。（序列的index值都从0开始计数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('大声说：我爱我的祖国')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['大', '声', '说', '：', '我', '爱', '我', '的', '祖', '国']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intWO=lstA.index('我')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(intWO)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5 insert(index,obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在列表指定的第index个元素前插入新元素对象obj（序列的index值都从0开始计数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('我爱你')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['我', '爱', '你']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA.insert(1,'很')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['我', '很', '爱', '你']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6 pop(index)   pop()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除列表中的第index个元素（参数只能传入整数数字，表示列表中的元素的index位置，而不能传入元素对象本身）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有指定要删除的第index个元素这个参数，那么，就会删除列表序列中的最后一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法有返回值，返回被删除的第index个元素对象的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('abcd')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['a', 'b', 'c', 'd']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strValue=lstA.pop()  #此处执行pop方法没有传入参数，则默认会删除列表的最后一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strValue)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['a', 'b', 'c']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strValue=lstA.pop('b')  #此处执行pop方法将元素对象本身作为参数传递进入，则会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Traceback (most recent call last):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  File &quot;&amp;lt;pyshell#5&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    strValue=lstA.pop('b')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TypeError: 'str' object cannot be interpreted as an integer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strValue=lstA.pop(1)   #此处执行pop方法传递了正确的参数，要删除元素的index值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strValue)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['a', 'c']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7 remove(obj)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;移除列表中从左边起第一个被找到的obj元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('大声说：我爱我的祖国')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['大', '声', '说', '：', '我', '爱', '我', '的', '祖', '国']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA.remove('我')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['大', '声', '说', '：', '爱', '我', '的', '祖', '国']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8 reverse()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将列表序列中的元素的位置顺序完全颠倒，即进行序列反序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此方法没有返回对象，或者说返回对象是None对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('abcdefg')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['a', 'b', 'c', 'd', 'e', 'f', 'g']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstB=lstA.reverse()  #其实并没有返回值，所以lstB的值其实是None&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstB)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;None&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)   #而lstA本身的元素顺序被颠倒了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['g', 'f', 'e', 'd', 'c', 'b', 'a']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9  sort(func)  sort()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按函数func指明的算法对列表的元素进行重新排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不指明func函数名，则默认正序排序（正序如：从小到大）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外还可以按关键字参数方式传入‘key=‘参数和‘reverse=[True/False]’参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字参数reverse=True时表示按反序排序（反序如：从大到小）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字参数reverse=False时表示按正序排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键字参数key指明排序模式，如key=len，表示字符串排序时，按长短排。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=[3,5,7,8,9,2]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA.sort()  #默认正序排序，对于数字类型的列表，则按从小到大顺序来排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[2, 3, 5, 7, 8, 9]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA.sort(reverse=True)  #指定了关键字参数reverse=False,则反序排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[9, 8, 7, 5, 3, 2]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstB=['a','abc','bc','abcd']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstB.sort(key=len) #字符串列表排序，指定关键字参数，key=len，表示 按字符串长短排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstB)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['a', 'bc', 'abc', 'abcd']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上练习都没有为sort方法指定排序算法的函数，因为我目前还没有研究明白这个用法，后面再作具体研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10 clear()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完全清除列表中的所有元素，但列表对象本身还存在，没有被注销。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA=list('孤荷凌寒的QQ号是：578652607')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;['孤', '荷', '凌', '寒', '的', 'Q', 'Q', '号', '是', '：', '5', '7', '8', '6', '5', '2', '6', '0', '7']&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstA.clear()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(lstA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——————————&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天整理的学习笔记完成，最后例行说明下我的自学思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;诚挚期待您的交流分享批评指点！&lt;strong&gt;欢迎联系我加入从零开始的自学联盟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：https://pan.baidu.com/s/1NdFzv30EUB3N7HNiutB_IQ 密码：lws1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Youku&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://v.youku.com/v_show/id_XMzkxNjk2MzUwOA&quot;&gt;https://v.youku.com/v_show/id_XMzkxNjk2MzUwOA&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bilibili&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.bilibili.com/video/av35709611/&quot;&gt;https://www.bilibili.com/video/av35709611/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜马拉雅整理的语音笔记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.ximalaya.com/keji/19103006/136365944&quot;&gt;https://www.ximalaya.com/keji/19103006/136365944&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181113231855961-1978424367.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181113231904863-197030673.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181113232111746-777314430.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 13 Nov 2018 15:27:00 +0000</pubDate>
<dc:creator>孤荷凌寒</dc:creator>
<og:description>孤荷凌寒自学python第六天 列表的嵌套与列表的主要方法 （完整学习过程屏幕记录视频地址在文末，手写笔记在文末） （同步的语音笔记朗读：https://www.ximalaya.com/keji/1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhghroom/p/9955564.html</dc:identifier>
</item>
<item>
<title>python模块导入细节 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9955485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9955485.html</guid>
<description>&lt;p&gt;官方手册：&lt;a href=&quot;https://docs.python.org/3/tutorial/modules.html&quot; class=&quot;uri&quot;&gt;https://docs.python.org/3/tutorial/modules.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;可执行文件和模块&quot;&gt;可执行文件和模块&lt;/h2&gt;
&lt;p&gt;python源代码文件按照功能可以分为两种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用于执行的可执行程序文件&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;不用与执行，仅用于被其它python源码文件导入的模块文件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如文件a.py和b.py在同一目录下，它们的内容分别是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# b.py
x=&quot;var x in module b&quot;
y=5

# a.py：
import b
import sys
print(b.x)
print(b.y)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;a.py导入其它文件(b.py)后，就可以使用b.py文件中的属性(如变量、函数等)。这里，a.py就是可执行文件，b.py就是模块文件，但模块名为b，而非b.py。&lt;/p&gt;
&lt;p&gt;python提供了一些标准库，是预定义好的模块文件，例如上面的sys模块。&lt;/p&gt;
&lt;p&gt;在此有几个注意点，在后面会详细解释：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;模块b的文件名为b.py，但import导入的时候，使用的名称为b，而非b.py&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;a.py和b.py是在同一个目录下的，如果不在同目录下能否导入？&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在a.py中访问b.py模块中的属性时，使用的是&lt;code&gt;b.x&lt;/code&gt;、&lt;code&gt;b.y&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;上面都是直接以模块名导入的，python还支持更复杂的包导入方式，例如导入abc/b.py时，使用&lt;code&gt;import abc.b&lt;/code&gt;。下一篇文章会详细解释包的导入方式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;python模块搜索路径&quot;&gt;python模块搜索路径&lt;/h2&gt;
&lt;p&gt;在a.py中导入模块b的时候，python会做一系列的模块文件路径搜索操作：b.py在哪里？只有找到它才能读取、运行(装载)该模块。&lt;/p&gt;
&lt;p&gt;在任何一个python程序启动时，都会将模块的搜索路径收集到sys模块的path属性中(&lt;code&gt;sys.path&lt;/code&gt;)。&lt;strong&gt;当python需要搜索模块文件在何处时，首先搜索内置模块，如果不是内置模块，则搜索sys.path中的路径列表，搜索时会从该属性列出的路径中按照从前向后的顺序进行搜索，并且只要找到就立即停止搜索该模块文件&lt;/strong&gt;(也就是说不会后搜索的同名模块覆盖先搜索的同名模块)。&lt;/p&gt;
&lt;p&gt;例如，在a.py文件中输出一下这个属性的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# a.py：
import sys
print(sys.path)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['G:\\pycode', 'C:\\Program Files (x86)\\Python36-32\\python36.zip', 'C:\\Program Files (x86)\\Python36-32\\DLLs', 'C:\\Program Files (x86)\\Python36-32\\lib', 'C:\\Program Files (x86)\\Python36-32', 'C:\\Users\\malong\\AppData\\Roaming\\Python\\Python36\\site-packages', 'C:\\Program Files (x86)\\Python36-32\\lib\\site-packages']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;python模块的搜索路径包括几个方面，按照如下顺序搜索：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序文件(a.py)所在目录，即&lt;code&gt;G:\\pycode&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;环境变量&lt;code&gt;PYTHONPATH&lt;/code&gt;所设置的路径(如果定义了该环境变量，则从左向右的顺序搜索)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;标准库路径&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;.pth文件中定义的路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意，上面sys.path的结果中，除了&lt;code&gt;.zip&lt;/code&gt;是一个文件外，其它的搜索路径全都是目录，也就是从这些目录中搜索模块X的文件X.py是否存在。&lt;/p&gt;

&lt;h3 id=&quot;程序所在目录&quot;&gt;程序所在目录&lt;/h3&gt;
&lt;p&gt;这个目录是最先搜索的，且是python自动搜索的，无需对此进行任何设置。从交互式python程序终输出sys.path的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sys.path
['', 'C:\\WINDOWS\\system32', 'C:\\Program Files (x86)\\Python36-32\\Lib\\idlelib', 'C:\\Program Files (x86)\\Python36-32\\python36.zip', 'C:\\Program Files (x86)\\Python36-32\\DLLs', 'C:\\Program Files (x86)\\Python36-32\\lib', 'C:\\Program Files (x86)\\Python36-32', 'C:\\Users\\malong\\AppData\\Roaming\\Python\\Python36\\site-packages', 'C:\\Program Files (x86)\\Python36-32\\lib\\site-packages']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第一个&lt;code&gt;''&lt;/code&gt;表示的就是程序所在目录。&lt;/p&gt;
&lt;p&gt;注意程序所在目录和当前目录是不同的。例如，在/tmp/目录下执行/pycode中的a.py文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /tmp
python /pycode/a.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中/tmp为当前目录，而/pycode是程序文件a.py所在的目录。如果a.py中导入b.py，那么将首先搜索/pycode，而不是/tmp。&lt;/p&gt;
&lt;h3 id=&quot;环境变量pythonpath&quot;&gt;环境变量PYTHONPATH&lt;/h3&gt;
&lt;p&gt;这个变量中可以自定义一系列的模块搜索路径列表，这样可以跨目录搜索(另一种方式是设置.pth文件)。但默认情况下这个环境变量是未设置的。&lt;/p&gt;
&lt;p&gt;在windows下，设置PYTHONPATH环境变量的方式：&lt;code&gt;命令行中输入：SystemPropertiesAdvanced--&amp;gt;环境变量--&amp;gt;系统环境变量新建&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181113104128808-2102764314.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是多个路径，则使用英文格式的分号分隔。以下是临时设置当前命令行窗口的PYTHONPATH：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set PYTHONPATH='D:\pypath; d:\pypath1'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在unix下，设置PYTHONPATH环境变量的方式，使用冒号分隔多个路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PYTHONPATH=/tmp/pypath1:/tmp/pypath2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要永久生效，则写入配置文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo 'export PYTHONPATH=/tmp/pypath1:/tmp/pypath2' &amp;gt;/etc/profile.d/pypth.sh
chmod +x /etc/profile.d/pypth.sh
source /etc/profile.d/pypth.sh&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;标准库路径&quot;&gt;标准库路径&lt;/h3&gt;
&lt;p&gt;在Linux下，标准库的路径一般是在/usr/lib/pythonXXX/下(XXX表示python版本号)，此目录下有些分了子目录。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['', '/usr/lib/python35.zip', '/usr/lib/python3.5', '/usr/lib/python3.5/plat-x86_64-linux-gnu', '/usr/lib/python3.5/lib-dynload', '/usr/local/lib/python3.5/dist-packages', '/usr/lib/python3/dist-packages']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中/usr/lib/python3.5和其内的几个子目录都是标准库的搜索路径。&lt;/p&gt;
&lt;p&gt;注意其中/usr/lib/python35.zip，它是ZIP文件组件，当定义此文件为搜索路径时，将自动解压缩该文件，并从此文件中搜索模块。&lt;/p&gt;
&lt;p&gt;Windows下根据python安装位置的不同，标准库的路径不同。如果以默认路径方式安装的python，则标准库路径为&lt;code&gt;C:\\Program Files (x86)\\Python36-32&lt;/code&gt;及其分类的子目录。&lt;/p&gt;

&lt;h3 id=&quot;pth文件自定义路径&quot;&gt;.pth文件自定义路径&lt;/h3&gt;
&lt;p&gt;可以将自定义的搜索路径放进一个.pth文件中，每行一个搜索路径。然后将.pth文件放在python安装目录或某个标准库路径内的sitepackages目录下即可。&lt;/p&gt;
&lt;p&gt;这是一种替换PYTHONPATH的友好方式，因为不同操作系统设置环境变量的方式不一样，而以文件的方式记录是所有操作系统都通用的。&lt;/p&gt;
&lt;p&gt;例如，windows下，在python安装目录&lt;code&gt;C:\\Program Files (x86)\\Python36-32&lt;/code&gt;下新增一个mypath.pth文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d:\pypath1
d:\pypath2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再去输出sys.path，将可以看到这两个路径已经放进了搜索列表中。&lt;/p&gt;

&lt;h3 id=&quot;修改搜索路径&quot;&gt;修改搜索路径&lt;/h3&gt;
&lt;p&gt;除了上面环境变量和.pth文件，还可以直接修改sys.path或者site.getsitepackages()的结果。&lt;/p&gt;
&lt;p&gt;例如，在import导入sys模块之后，可以修改sys.path，向这个列表中添加其它搜索路径，这样之后导入其它模块的时候，也会搜索该路径。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import sys
sys.path.append('d:\\pypath3')
print(sys.path)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sys.path的最后一项将是新添加的路径。&lt;/p&gt;

&lt;h2 id=&quot;导入模块的细节&quot;&gt;导入模块的细节&lt;/h2&gt;

&lt;h3 id=&quot;导入模块时的过程&quot;&gt;导入模块时的过程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;python的import是在程序运行期间执行的，并非像其它很多语言一样是在编译期间执行&lt;/strong&gt;。也就是说，import可以出现在任何地方，只有执行到这个import行时，才会执行导入操作。且在import某个模块之前，无法访问这个模块的属性。&lt;/p&gt;
&lt;p&gt;python在import导入模块时，首先搜索模块的路径，然后编译并执行这个模块文件。虽然概括起来只有两个过程，但实际上很复杂。&lt;/p&gt;
&lt;p&gt;前文已经解释了import的模块搜索过程，所以这里大概介绍import的其它细节。&lt;/p&gt;
&lt;p&gt;以前面的a.py中导入模块文件b.py为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;import导入模块时，搜索到模块文件b.py后：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;首先在内存中为每个待导入的模块构建module类的实例：模块对象。这个模块对象目前是空对象，这个对象的名称为全局变量b&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意细节：module类的对象，变量b。&lt;/p&gt;
&lt;p&gt;输出下它们就知道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(b)
print(type(b))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;module 'b' from 'g:\\pycode\\b.py'&amp;gt;
&amp;lt;class 'module'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为b是全局变量，所以当前程序文件a.py中不能重新对全局变量b进行赋值，这会使导入的模块b被丢弃。例如，下面是错误的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
b=3
print(b.x)   # 已经没有模块b了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，因为import导入时是将模块对象赋值给模块变量，所以模块变量名不能是python中的一些关键字，比如if、for等，这时会报错。虽然模块文件名可以为list、keys等这样的内置函数名，但这会导致这些内置函数不可用，因为根据变量查找的作用域规则，首先查找全局变量，再查找内置作用域。&lt;strong&gt;也就是说，模块文件的文件名不能是这些关键字、也不应该是这些内置函数名&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  File &quot;g:/pycode/new.py&quot;, line 11
    import if
            ^
SyntaxError: invalid syntax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.构造空模块实例后，将编译、执行模块文件b.py，并按照一定的规则将一些结果放进这个模块对象中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;注意细节，编译、执行b.py、将结果保存到模块对象中。&lt;/p&gt;
&lt;p&gt;模块第一次被导入的时候，会进行编译，并生成.pyc字节码文件，然后python执行这个pyc文件。当模块被再次导入时，如果检查到pyc文件的存在，且和源代码文件的上一次修改时间戳mtime完全对应(也就是说，编译后源代码没有进行过修改)，则直接装载这个pyc文件并执行，不会再进行额外的编译过程。当然，如果修改过源代码，将会重新编译得到新的pyc文件。&lt;/p&gt;
&lt;p&gt;注意，并非所有的py文件都会生成编译得到的pyc文件，对于那些只执行一次的程序文件，会将内存中的编译结果在执行完成后直接丢弃(多数时候如此，但仍有例外，比如使用&lt;a href=&quot;https://docs.python.org/3/library/compileall.html#module-compileall&quot;&gt;compileall&lt;/a&gt;模块可以强制编译成pyc文件)，但模块会将内存中的编译结果持久化到pyc文件中。另外，运行字节码pyc文件并不会比直接运行py文件更快，执行它也一样是一行行地解释、执行，唯一快的地方在于导入装载的时候无需重新编译而已。&lt;/p&gt;
&lt;p&gt;执行模块文件(已完成编译)的时候，按照一般的执行流程执行：一行一行地、以代码块为单元执行。一般地，模块文件中只用来声明变量、函数等属性，以便提供给导入它的模块使用，而不应该有其他任何操作性的行为，比如print()操作不应该出现在模块文件中，但这并非强制。&lt;/p&gt;
&lt;p&gt;总之，执行完模块文件后，这个模块文件将有一个自己的全局名称空间，在此模块文件中定义的变量、函数等属性，都会记录在此名称空间中。&lt;/p&gt;
&lt;p&gt;最后，模块的这些属性都会保存到模块对象中。由于这个模块对象赋值给了模块变量b，所以通过变量b可以访问到这个对象中的属性(比如变量、函数等)，也就是模块文件内定义的全局属性。&lt;/p&gt;

&lt;h3 id=&quot;只导入一次&quot;&gt;只导入一次&lt;/h3&gt;
&lt;p&gt;假设a.py中导入了模块b和模块sys，在b.py中也导入了模块sys，但python默认对某个模块只会导入一次，如果a.py中先导入sys，再导入b，那么导入b并执行b.py的时候，会发现sys已经导入了，不会再去导入sys。&lt;/p&gt;
&lt;p&gt;实际上，python执行程序的时候，会将所有已经导入的模块放进sys.module属性中，这是一个dict，可以通过下面的方式查看已导入的模块名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; list(sys.module.keys())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果某个程序文件中多次使用import(或from)导入同一个模块，虽然不会报错，但实际上还是直接使用内存中已装载好的模块对象。&lt;/p&gt;
&lt;p&gt;例如，b.py中x=3，导入它之后修改该值，然后再次导入，发现b.x并不会发生改变：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
print(b.x)   # 3

b.x=33
print(b.x)  # 33

import b 
print(b.x)  # 33&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是python提供了reload进行多次重复导入的方法，见后文。&lt;/p&gt;

&lt;h3 id=&quot;使用别名&quot;&gt;使用别名&lt;/h3&gt;
&lt;p&gt;import导入时，可以使用&lt;code&gt;as&lt;/code&gt;关键字指定一个别名作为模块对象的变量，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b as bb
bb.x=3
print(bb.x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候模块对象将赋值给变量bb，而不是b，b此时不再是模块对象变量，而仅仅只是模块名。使用别名并不会影响性能，因为它仅仅只是一个赋值过程，只不过是从原来的赋值对象变量b变为变量bb而已。&lt;/p&gt;

&lt;h2 id=&quot;from导入部分属性&quot;&gt;from导入部分属性&lt;/h2&gt;
&lt;p&gt;import语句是导入模块中的所有属性，并且访问时需要使用模块变量来引用。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
print(b.x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了import，还有一个from语句，表示从模块中导入部分指定的属性，且使得可以直接使用这些属性的名称来引用这些属性，而不需要加上模块变量名。例如原来import导入时访问变量x使用&lt;code&gt;b.x&lt;/code&gt;，from导入时只需使用x即可。实际上，from导入更应该称为属性的再次赋值(拷贝)。&lt;/p&gt;
&lt;p&gt;例如，b.py中定义了变量x、y、z，同时定义了函数f()和g()，在a.py中导入这个模块文件，但只导入x变量和f函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# a.py文件内容:
from b import x,f

print(x)
f()

# b.py文件内容：
x=3
y=4
z=5
def f():
    print(&quot;function f in b.py&quot;)

def g():
    print(&quot;function g in b.py&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面a.py中引用模块b中属性的方式没有加上&lt;code&gt;b.X&lt;/code&gt;，而是直接使用x和f()来引用。这和import是不一样的。至于from和import导入时的变量名称细节，在下面的内容中会详细解释。&lt;/p&gt;
&lt;p&gt;虽然from语句只导入模块的部分属性，但实际上仍然会完整地执行整个模块文件。&lt;/p&gt;
&lt;p&gt;同样的，from语句也可以指定导入属性的变量别名，例如，将b.py中的属性x赋值给xx，将y赋值给yy：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from b import x as xx,y as yy
print(xx)
print(yy)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;from语句还有一个特殊导入统配符号&lt;code&gt;*&lt;/code&gt;，它表示导入模块中的所有属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# a.py文件：
from b import *
print(x,y,z)
f()
g()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多数时候，不应该使用&lt;code&gt;from *&lt;/code&gt;的方式，因为我们可能会忘记某个模块中有哪些属性拷贝到了当前文件，特别是多个&lt;code&gt;from *&lt;/code&gt;时可能会出现属性覆盖的问题。&lt;/p&gt;

&lt;h2 id=&quot;重载模块imp.reload&quot;&gt;重载模块：imp.reload()&lt;/h2&gt;
&lt;p&gt;无论时import还是from，都只导入一次模块，但使用reload()可以强制重新装载模块。&lt;/p&gt;
&lt;p&gt;reload()是imp模块中的一个函数，所以要使用imp.reload()之前，必须先导入imp。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from imp import reload
reload(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;reload()是一个函数，它的参数是一个已经成功被导入过的模块变量(如果使用了别名，则应该使用别名作为reload的参数)，也就是说该模块必须在内存中已经有自己的模块对象。&lt;/p&gt;
&lt;p&gt;reload()会重新执行模块文件，并将执行得到的属性完全覆盖到原有的模块对象中。也就是说，&lt;strong&gt;reload()会重新执行模块文件，但不会在内存中建立新的模块对象，所以原有模块对象中的属性可能会被修改&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，模块文件b.py中x=3，导入b模块，修改其值为33，然后reload这个模块，会发现值重新变回了3。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
print(b.x)  # 3

b.x=33
print(b.x)  # 33

from imp import reload
reload(b)

print(b.x)  # 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时候reload()很有用，可以让程序无需重启就执行新的代码。例如，在python的交互式模式下导入模块b，然后修改python源码，再reload导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import b
&amp;gt;&amp;gt;&amp;gt; b.x
3

# 不要关掉交互式解释器，直接修改源代码中的b=3333

&amp;gt;&amp;gt;&amp;gt; from imp import reload
&amp;gt;&amp;gt;&amp;gt; reload(b)
&amp;lt;module 'b' from 'G:\\pycode\\b.py'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b.x
3333&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但正因为reload()重载模块会改变原始的值，这可能是很危险的行为，一定要清楚地知道它是在干什么。&lt;/p&gt;

&lt;h2 id=&quot;导入模块时的变量名称细节&quot;&gt;导入模块时的变量名称细节&lt;/h2&gt;

&lt;h3 id=&quot;import导入的变量&quot;&gt;import导入的变量&lt;/h3&gt;
&lt;p&gt;import导入时，模块对象中的属性有自己的名称空间，然后将整个模块对象赋值给模块变量。&lt;/p&gt;
&lt;p&gt;例如，在a.py中导入b：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
print(b.x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个过程唯一和当前文件a.py作用域有关的就是模块对象变量b，b.py中声明的属性和当前文件无任何关系。无论是访问还是修改，都是直接修改这个模块对象自身作用域中的值。所以，只要模块变量b不出现冲突问题，可以放心地修改模块b中的属性。&lt;/p&gt;
&lt;p&gt;另一方面，因为每个进程都有自己的内存空间，所以&lt;strong&gt;在a.py、c.py中都导入b时，a.py中修改b的属性值不会影响c.py中导入的属性，a.py和c.py中模块对象所保存的属性都是执行b.py后得到的，它们相互独立&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;from导入的变量&quot;&gt;from导入的变量&lt;/h3&gt;
&lt;p&gt;from导入模块时，会先执行完模块文件，然后将指定的部分属性重新赋值给当前程序文件的同名全局变量。&lt;/p&gt;
&lt;p&gt;例如，在模块文件b.py中定义了x、y、z变量和f()、g()函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# b.py：
x=3
y=4
b=5
def f():
    print(&quot;function f in b.py&quot;)

def g():
    print(&quot;function g in b.py&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当在a.py中导入b模块时，如果只导入x、y和f()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# a.py：
from b import x, y, f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上的行为是&lt;strong&gt;构造模块对象后，将这个模块对象对应的名称空间中的属性x、y和f重新赋值给a.py中的变量x、y和f，然后丢弃整个模块对象以及整个名称空间。换句话说，b不再是一个有效的模块变量(所以和import不一样)，来自b的x,y,z,f和g也都被丢弃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里有几个细节，需要详细解释清楚，只有理解了才能搞清楚它们是怎么生效的。&lt;/p&gt;
&lt;p&gt;假设现在模块文件b.py的内容为，并且a.py中导入x,y,f属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# b.py：
x=3
y=[1,2]
z=5
def f():
    print(&quot;function f in b.py&quot;)

def g():
    print(&quot;function g in b.py&quot;)

# a.py：
from b import x,y,f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先在执行模块文件b.py时，会构造好自己的模块对象，并且模块对象有自己的名称空间(作用域)，模块对象构造完成后，它的名称空间大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181113163501113-70675999.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后python会在a.py的全局作用域内创建和导入属性同名的全局变量x，y和f，并且通过赋值的方式将模块的属性赋值给这些全局变量，也就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x = b.x
y = b.y
f = b.f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的b只是用来演示，实际上变量b是不存在的。&lt;/p&gt;
&lt;p&gt;赋值完成后，我们和构造的整个模块对象就失去联系了，因为没有变量b去引用这个对象。但需要注意，这个对象并没有被删除，仅仅只是我们无法通过b去找到它。&lt;/p&gt;
&lt;p&gt;所以，现在的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201811/733013-20181113163547238-1127133503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为是赋值的方式传值的，所以在a.py中修改这几个变量的值时，是直接在模块对象作用域内修改的：对于不可变对象，将在此作用域内创建新对象，对于可变对象，将直接修改原始对象的值。&lt;/p&gt;
&lt;p&gt;另一方面，由于模块对象一直保留在内存中，下次继续导入时，将直接使用该模块对象。对于import和from，是直接使用该已存在的模块对象，对于reload，是覆盖此模块对象。&lt;/p&gt;
&lt;p&gt;例如，在a.py中修改不可变对象x和可变对象y，之后import或from时，可变对象的值都会随之改变，因为它们使用的都是原来的模块对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from b import x,y

x=33
y[0]=333

from b import x,y
print((x,y))        # 输出(3, [333, 2])

import b
print((b.x,b.y))    # 输出(3, [333, 2])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;from导入时，由于b不再是模块变量，所以无法再使用reload(b)去重载对象。如果想要重载，只能先import，再reload：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from b import x,y
...CODE...

# 想要重载b
import b
from imp import reload
reload(b)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;查看模块中的属性&quot;&gt;查看模块中的属性&lt;/h2&gt;
&lt;p&gt;内置函数dir可用于列出某模块中定义了哪些属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
dir(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'f', 'g', 'x', 'y', 'z']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，模块的属性中除了自己定义的属性外，还有一些内置的属性，比如上面以&lt;code&gt;__&lt;/code&gt;开头和结尾的属性。&lt;/p&gt;
&lt;p&gt;如果dir()不给任何参数，则输出当前环境下定义的名称属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import b
&amp;gt;&amp;gt;&amp;gt; x=3
&amp;gt;&amp;gt;&amp;gt; aaa=333
&amp;gt;&amp;gt;&amp;gt; dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'aaa', 'b', 'x']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个属性都对应一个对象，例如x对应的是int对象，b对应的是module对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; type(x)
&amp;lt;class 'int'&amp;gt;
&amp;gt;&amp;gt;&amp;gt; type(b)
&amp;lt;class 'module'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然是对象，那么它们都会有自己的属性。例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; dir(x)
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，也可以直接dir某个模块内的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import b
dir(b.x)
dir(b.__name__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dir()不会列出内置的函数和变量，如果想要输出内置的函数和变量，可以去标准模块builtins中查看，因为它们定义在此模块中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import builtins
dir(buildins)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 13 Nov 2018 15:10:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>python模块导入细节 官方手册：https://docs.python.org/3/tutorial/modules.html 可执行文件和模块 python源代码文件按照功能可以分为两种类型：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9955485.html</dc:identifier>
</item>
<item>
<title>JQuery模拟网页中自定义鼠标右键菜单 - 粥里有勺糖</title>
<link>http://www.cnblogs.com/roseAT/p/9955309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roseAT/p/9955309.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;题外话&lt;/span&gt;.......最近在开发一个网站项目的时候,需要用到网页自定义右键菜单,在网上看了各路前辈大神的操作,头晕目眩,为了达到目的,突然灵机一动,于是便有了这篇文章.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;先放个效果图(沾沾自喜,大神勿喷):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1504886/201811/1504886-20181113202835714-1707919088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;废话不多说,进入正题:&lt;/p&gt;

&lt;p&gt;1.首先 我们要禁用掉原网页中右键菜单&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JQuery代码&lt;/span&gt;
$(selector).on('contextmenu', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样目标区域的右键菜单就无法使用了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;demo1:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;keywords&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        #demo1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; turquoise&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #fff&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;demo1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;此区域(带颜色)被禁用了右键菜单&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#demo1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;contextmenu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {//禁用掉#demo1的右键菜单
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.接下来开始编写我们自己的菜单弹出窗口&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;思路:通过捕获鼠标点击时的事件在屏幕上被触发的位置(x,y),然后把我们自己编写的窗口利用CSS中的&quot;定位&quot;显示在哪里.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;2.1:如何获取到鼠标在屏幕上点击的事件?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;  JQuery Event.which属性---&lt;/span&gt;&lt;/span&gt;&lt;span&gt;引用JQuery中文手册中的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;which&lt;/code&gt;属性用于&lt;strong&gt;返回触发当前事件时按下的键盘按键或鼠标按钮&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于键盘和鼠标事件，该属性用于确定你按下的是哪一个键盘按键或鼠标按钮。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;which&lt;/code&gt;属性对DOM原生的&lt;code&gt;event.keyCode&lt;/code&gt;和&lt;code&gt;event.charCode&lt;/code&gt;进行了标准化。&lt;/p&gt;
&lt;p&gt;适用的事件类型主要有键盘事件：keypress、keydown、keyup，以及鼠标事件：mouseup、mousedown。&lt;/p&gt;
&lt;p&gt;该属性属于jQuery的&lt;code&gt;Event&lt;/code&gt;对象(实例)&lt;/p&gt;
&lt;p&gt;    $(selector).on('mousedown',function(event){&lt;/p&gt;
&lt;p&gt;         var code=event.which;//返回值是一个Number类型&lt;/p&gt;
&lt;p&gt;    })&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr class=&quot;firstRow&quot;&gt;&lt;th&gt;event.which属性值&lt;/th&gt;
&lt;th&gt;对应的鼠标按钮&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;鼠标左键&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;鼠标中键(滚轮键)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;鼠标右键&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; $('#demo1').on('mousedown',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){//紧接上面的实例demo1 在script中插入这段代码即可获取到鼠标点击事件
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; code=&lt;span&gt;event.which;//判断是单机了鼠标哪个键(1,2,3)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             alert('区域被鼠标点击了---'+&lt;span&gt;code);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 如何获取事件发生的位置(X,Y)?&lt;/p&gt;
&lt;p&gt;引用一位前辈的:链接: https://www.cnblogs.com/king-ying/p/5936429.html&lt;/p&gt;
&lt;p&gt; event对象中的属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; event.offsetX &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于触发事件的对象的 x 坐标&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; event.offsetY &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于触发事件的对象的 y 坐标&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; event.pageX   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于页面左上角的 x 坐标&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; event.pageY   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于页面左上角的 y 坐标&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; event.clientX &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于浏览器窗口可视区域的 x 坐标，其中客户区域不包括窗口自身的控件和滚动条&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; event.clientY &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于浏览器窗口可视区域的 y 坐标，其中客户区域不包括窗口自身的控件和滚动条&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; event.screenX &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取获取鼠标指针位置相对于屏幕的 x 坐标&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; event.screenY &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置或获取鼠标指针位置相对于屏幕的 y 坐标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;在上面的demo1的 js 代码中 增添 两句&lt;br/&gt;1&lt;/span&gt; $('#demo1').on('mousedown',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; code=&lt;span&gt;event.which;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; x=event.pageX;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于页面左上角X的坐标&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; y=event.pageY;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于页面左上角Y的坐标&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;             alert('区域被点击了'+code+&quot;位置:&quot;+'('+x+','+y+')'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 为了方便观察 重新做了一个demo2(复制粘贴即可运行):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;keywords&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        #demo1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; turquoise&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #fff&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        #click-pos&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bisque&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            min-width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;click-pos&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;显示内容
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;demo1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;此区域(带颜色)被禁用了右键菜单&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁用掉区域的默认右键事件&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#demo1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;contextmenu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#demo1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mousedown&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(event){
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; code&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;event.which;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; x&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;event.pageX;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于页面左上角X的坐标&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; y&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;event.pageY;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于页面左上角Y的坐标&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; mouse&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击类型&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(code){
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:mouse&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;左键&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:mouse&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中键(滚轮)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;:mouse&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;右键&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#click-pos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).html(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点击类型:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;mouse&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--位置-X:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-Y:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示到页面上&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 核心部分差不多就是上面的内容&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.编写自定义菜单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;达到的显示效果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1504886/201811/1504886-20181113223531320-1206697656.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 废话不多上代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;keywords&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;        #demo1 &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; turquoise&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #fff&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;        #click-pos &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bisque&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            min-width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;            font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 右键菜单遮罩层 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        #layer &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;            position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;            top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; transparent&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        #mouse-menu &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; fixed&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            z-index&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;            right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 130px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            max-height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 120px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #f1ecec&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            list-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;            text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;            border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 8px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            box-shadow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0 4px #ddd&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 菜单的每个选项 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        #mouse-menu li &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            border-top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;        #mouse-menu li:last-child &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            border-bottom&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1px solid #000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 当鼠标移入时 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        #mouse-menu li:hover &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;            background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; deepskyblue&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;}&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;click-pos&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    显示内容
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;demo1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;在此区域启用自定义菜单,原菜单已禁用&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 最外层为遮罩层,用于绑定点击任意位置关闭菜单事件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 默认隐藏 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;layer&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;display:none&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;mouse-menu&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡5&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;禁用掉区域的默认右键事件&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#demo1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;contextmenu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#layer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;contextmenu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#demo1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mousedown&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; code &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; event.which;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; event.pageX;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于页面左上角X的坐标&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; y &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; event.pageY;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对于页面左上角Y的坐标&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; mouse &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击类型&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (code) {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;: mouse &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;左键&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;: mouse &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中键(滚轮)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;: mouse &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;右键&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#click-pos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).html(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点击类型:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; mouse &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--位置-X:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-Y:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;坐标显示到页面上&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是鼠标右键召唤出弹出菜单&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (code &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#layer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).show();
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变菜单的位置到事件发生的位置&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#mouse-menu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).css(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, x);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#mouse-menu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).css(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;top&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, y);
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 点击选项卡时触发&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#layer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示当前点击的内容&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ssss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; text &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).html();
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#click-pos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).html(text);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; event.stopPropagation();//阻止事件冒泡&lt;/span&gt;
&lt;span&gt;135&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击遮罩层时隐藏需要的菜单&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;        $(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#layer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).hide();
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; 
&lt;span&gt;144&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;emmmm以上就是今天的内容(也许有点粗糙.第一次写这么长,有问题欢迎评论或者私信)&lt;/p&gt;

</description>
<pubDate>Tue, 13 Nov 2018 14:38:00 +0000</pubDate>
<dc:creator>粥里有勺糖</dc:creator>
<og:description>题外话.......最近在开发一个网站项目的时候,需要用到网页自定义右键菜单,在网上看了各路前辈大神的操作,头晕目眩,为了达到目的,突然灵机一动,于是便有了这篇文章. 先放个效果图(沾沾自喜,大神勿喷</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roseAT/p/9955309.html</dc:identifier>
</item>
<item>
<title>jdbc-DAO的实现 - earth腾飞</title>
<link>http://www.cnblogs.com/tfper/p/9955216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tfper/p/9955216.html</guid>
<description>&lt;h2 id=&quot;什么是-dao&quot;&gt;什么是 DAO&lt;/h2&gt;
&lt;p&gt;DAO(Data Access Object)是一个数据访问接口，夹在业务逻辑与数据库资源中间。&lt;/p&gt;
&lt;p&gt;在核心J2EE模式中是这样介绍DAO模式的：为了建立一个健壮的J2EE应用，应该将所有对数据源的访问操作抽象封装在一个公共API中。用程序设计的语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口在逻辑上对应这个特定的数据存储。DAO中的主要操作:增删改查(CRUD).&lt;/p&gt;
&lt;h2 id=&quot;dao的实现&quot;&gt;DAO的实现&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现的步骤一般是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先建立模型的对象domain&lt;/li&gt;
&lt;li&gt;编写DAO接口&lt;/li&gt;
&lt;li&gt;定义DAO实现类&lt;/li&gt;
&lt;li&gt;生产DAO测试类&lt;/li&gt;
&lt;li&gt;在DAO测试类中测试方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一般的规范&lt;/strong&gt;是分domain包和dao包，dao包中有DAO接口，接口名为IXxxDAO,实现类为XxxDAO,创建实现类对象赋给接口，体现多态。还有一个测试类名为XxxTestDAOTest.如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/13/iOjQzt.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DAO接口：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IStudentDAO {
    /**
     * 保存学生对象
     * @param stu 需要保存的学生
     */
    void save(Student stu);

    /**
     * 删除指定id的学生
     * @param id  需要删除的学生的id
     */
    void delete(int id);

    /**
     * 更改操作
     * @param newStu 更改后的学生对象，根据id更改
     */
    void update(Student newStu);

    /**
     * 根据id查询单个学生对象信息
     * @param id  需要查询学生的id
     * @return  存在该学生返回学生对象  不存在则返回null
     */
    Student get(long id );

    /**
     * 查询所有学生
     * @return  返回一个学生对象的集合
     */
    List&amp;lt;Student&amp;gt; list();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void save(Student stu) {
        String sql = &quot;INSERT INTO s_student(name,age) VALUES('狗哲',21)&quot;;
        Connection conn = null;
        Statement st = null
        try {
            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
            conn = DriverManager.getConnection(&quot;jdbc:mysql:///demo&quot;,&quot;root&quot;,&quot;admin&quot;);
            st = conn.createStatement();
            st.executeUpdate(sql);
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try{
                if(st != null){
                    st.close();
                }
            }catch (Exception e){
                e.printStackTrace();
            }finally {
                try{
                    if(conn != null){
                        conn.close();
                    }
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }
    }
增删改只有sql语句不一样，省略
····
····
public List&amp;lt;Student&amp;gt; list() {
    String sql = &quot;SELECT * FROM s_student&quot;;
    Connection conn = null;
    Statement st = null;
    ResultSet rs = null;
    List&amp;lt;Student&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    try {
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        conn = DriverManager.getConnection(&quot;jdbc:mysql:///demo&quot;,&quot;root&quot;,&quot;admin&quot;);
        st = conn.createStatement();
        rs = st.executeQuery(sql);
        while(rs.next()){
            String name = rs.getString(&quot;name&quot;);
            Integer age = rs.getInt(&quot;age&quot;);
            list.add(new Student(name,age));
        }

    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        try{
            if(st != null){
                st.close();
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try{
                if(conn != null){
                    conn.close();
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }
    }
    return  list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dao实现的重构&quot;&gt;DAO实现的重构&lt;/h2&gt;
&lt;p&gt;可以看出代码重复非常之多，尤其是增删改只有sql语句不一样&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、定义一个JdbcUtil类，把加载注册驱动放到静态代码块中，因为没有必要每次都去加载。&lt;/li&gt;
&lt;li&gt;2、把url，classDriverName,username,password ,放在一个资源文件中，用加载资源文件的方式获取这些值，保证了代码的可维护性&lt;/li&gt;
&lt;li&gt;3、异常处理代码也放在工具类中，异常处理及其麻烦，影响代码的美观&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JdbcUtil {
    private static Properties p = new Properties();
    //加载资源文件
    static{
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        InputStream inStream = loader.getResourceAsStream(&quot;db.properties&quot;);
        try {
            p.load(inStream);
            Class.forName(p.getProperty(&quot;classDriver&quot;));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //获取连接对象
    public static Connection getConn(){
        Connection conn = null;
        try {
             conn = DriverManager.getConnection(p.getProperty(&quot;url&quot;),p.getProperty(&quot;username&quot;), p.getProperty(&quot;password&quot;));
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return conn;
    }
    //关闭资源
    public static void close(Connection conn,Statement st,ResultSet rs){
        try{
            if(rs != null){
                rs.close();
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally{
            try{
                if(st != null){
                    st.close();
                }
            }catch(Exception e){
                e.printStackTrace();
            }finally{
                try{
                    if(conn != null){
                        conn.close();
                    }
                }catch(Exception e){
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 13 Nov 2018 14:26:00 +0000</pubDate>
<dc:creator>earth腾飞</dc:creator>
<og:description>什么是 DAO DAO(Data Access Object)是一个数据访问接口，夹在业务逻辑与数据库资源中间。 在核心J2EE模式中是这样介绍DAO模式的：为了建立一个健壮的J2EE应用，应该将所有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tfper/p/9955216.html</dc:identifier>
</item>
<item>
<title>函数内存分配 - CompileLife</title>
<link>http://www.cnblogs.com/yuemw/p/9955032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuemw/p/9955032.html</guid>
<description>&lt;p&gt;在最近的代码调试中，遇到一个比较棘手的崩溃问题，现象为程序在函数的返回值处崩溃，报警提示如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279769/201811/1279769-20181113214653398-2058030410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过排查，最终发现在对结构体内数组初始化赋值时出现了数组越界现象，导致函数在返回时出现异常，导致程序崩溃，借此机会，对内存栈内空间的函数占用空间总结学习：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;进程的内存布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个进程来说，它在内存中的布局如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279769/201811/1279769-20181113214718922-444664711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码区与常量区等不再赘述，堆区是由代码动态的申请与释放，只在部分情况下如果代码中没有对申请的内存进行释放，在程序结束的时候OS会进行释放。栈区的空间是由编译器自动的分配和释放的。此处需要注意的是：&lt;/p&gt;
&lt;p&gt;（1）堆向高内存地址生长，而栈向低内存地址生长；&lt;/p&gt;
&lt;p&gt;（2）堆和栈相向生长，他们之间有个临界点，称为stkbrk。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;程序如何在进程中映射&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个程序，它的执行顺序为：&lt;/p&gt;
&lt;p&gt;main( )--&amp;gt;fun1( )--&amp;gt;fun2( )...fun3( ),即主函数逐个调用内部子函数，其内部的映射如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1279769/201811/1279769-20181113214741365-780133675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图：&lt;/p&gt;
&lt;p&gt;1）随着函数调用层次的增加，函数帧栈逐块向低地址方向延伸；&lt;/p&gt;
&lt;p&gt;2）当各函数调用返回后（进程中函数的调用层减少），帧栈会被逐块被遗弃而向高内存地址方向缩回；&lt;/p&gt;
&lt;p&gt;3）每个子函数的帧栈大小与函数的性质相关，由函数内部非局部变量数量决定；&lt;/p&gt;
&lt;p&gt;4）未初始化数据区（BSS）：用于存放程序的静态变量，这部分内存都是被初始化为零的，而初始化数据区用于存放可执行文件的进程所共享；&lt;/p&gt;
&lt;p&gt;5）当出现未初始化数据区（BSS）或者Stack（栈区）的增长耗尽了系统分配给进程的自由内存的情况下，进程 将会被阻塞，重新被操作系统用更大的内存模块来调度运行；&lt;/p&gt;
&lt;p&gt;6）每一个函数的帧栈包括：函数的参数（关于被调用函数的参数时放在调用函数的帧栈还是被调用函数的帧栈，依赖于不同的系统实现），函数的帧栈中的局部变量以及恢复该函数的主调函数的栈帧（前一个栈帧）所需的数据，以及主调函数的下一条指令的地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; &lt;strong&gt;函数的栈帧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个函数建立的栈帧包含如下的信息：&lt;/p&gt;
&lt;p&gt;1）主调函数的返回地址。&lt;/p&gt;
&lt;p&gt;2）为函数的局部变量分配的栈空间。&lt;/p&gt;
&lt;p&gt;3）位被调函数的参数分配的空间。&lt;/p&gt;
&lt;p&gt;4）函数的返回地址。&lt;/p&gt;
&lt;p&gt;关于函数内数据的占用空间细节，可以通过以下代码了解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局初始化区&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; i1 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i3 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局初始化区&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i4 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i5 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i6 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

 

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局未初始化区&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i7;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i8;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i9;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()

{

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印全局初始化区变量i1-i3的地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &amp;amp;i1 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;i2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;i3 &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印全局初始化区静态变量i4-i6的地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &amp;amp;i4 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;i5 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;i6 &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印全局未初始化区变量i7-i9的地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &amp;amp;i7 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;i8 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;i9 &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data2 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data3;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; data4;

 

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印函数内局部变量data1-data4地址，其中data3,data4未初始化&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &amp;amp;data1 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;data2 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;data3 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &amp;amp;data4 &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *pStr1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12345&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12345在常量区，pStr在栈上&lt;/span&gt;

    &lt;span&gt;char&lt;/span&gt; *pStr2 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1122&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

 

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *p =&lt;span&gt; pStr1;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *q =&lt;span&gt; pStr2;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印常量地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; p &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; q &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; aData = &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局（静态）初始化区&lt;/span&gt;
&lt;span&gt;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印局部函数中定义静态变量地址，对比其他全局区地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &amp;amp;aData &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *p1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆区&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt; *p2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆区&lt;/span&gt;
&lt;span&gt;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印堆区地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; p1 &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; p2 &amp;lt;&amp;lt;&lt;span&gt; endl;

 

    getchar();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1279769/201811/1279769-20181113214810849-1018205899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　观察上面的地址打印信息可以发现，全局未初始化区的变量是按从高到低地址按申明定义的顺序压栈，变量i7紧邻全局初始化段的第一个变量i1。而全局初始化段的变量（包括静态，不做区分的）从低地址到高地址按申明的顺序压栈（不是指上面所指的栈区，请区别开来，这是就地址变化过程而言的，它与局部函数变量起始地址完全不同）。函数在程序代码段中地址是按申明顺序递增的。函数局部变量在栈去是按照申明顺序从高到低的地址进栈的。&lt;/p&gt;
&lt;p&gt;常量的开始地址来看跟全局变量应该属于一个区。堆区的地址开头也是另外一个段。&lt;/p&gt;
&lt;p&gt;补充一点：数组变量内部元素是按照元素下标从低地址到高地址压栈的。&lt;/p&gt;
&lt;p&gt;一般局部变量一般是从高低地址到低地址压栈的。&lt;/p&gt;
&lt;p&gt;　　通过以上的总结，也就解释了本文开头处的崩溃问题，当函数内的局部变量赋值时出现越界，导致了存放了函数返回地址的空间被影响，使得被调用的函数返回时出现异常，导致程序崩溃。&lt;/p&gt;
&lt;p&gt;经验有限，本文中可能存在着自己的一些理解错误之处，后续会继续修改完善，也希望大家指正。&lt;/p&gt;

</description>
<pubDate>Tue, 13 Nov 2018 13:52:00 +0000</pubDate>
<dc:creator>CompileLife</dc:creator>
<og:description>函数的内存分配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuemw/p/9955032.html</dc:identifier>
</item>
</channel>
</rss>