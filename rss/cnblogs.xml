<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>docker usage - 醉卧古藤下</title>
<link>http://www.cnblogs.com/zwgtx/p/9350370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwgtx/p/9350370.html</guid>
<description>&lt;p&gt;docker ps -a&lt;/p&gt;
&lt;p&gt;查看物理机上面所有容器信息列表&lt;/p&gt;

&lt;p&gt;docker exec -it $docker_id /bin/bash&lt;/p&gt;
&lt;p&gt;进入容器以默认帐号&lt;/p&gt;

&lt;p&gt;docker exec -it -u root $docker_id /bin/bash&lt;/p&gt;
&lt;p&gt;进入容器以指定帐号&lt;/p&gt;

&lt;p&gt;docker cp $src_file_path $docker_id:$dst_file_path&lt;/p&gt;
&lt;p&gt;把物理机上文件或文件件拷贝到容器中&lt;/p&gt;

&lt;p&gt;docker cp $docker_id:$src_file_path $dst_file_path&lt;/p&gt;
&lt;p&gt;把容器中文件或文件夹拷贝到物理机&lt;/p&gt;

&lt;p&gt;docker restart $docker_id&lt;/p&gt;
&lt;p&gt;重启指定容器&lt;/p&gt;

&lt;p&gt;docker init $docker_image_id&lt;/p&gt;
&lt;p&gt;初始化构建容器以指定镜像（待确认）&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 07:45:00 +0000</pubDate>
<dc:creator>醉卧古藤下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zwgtx/p/9350370.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web API 集成测试 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9349391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9349391.html</guid>
<description>&lt;p&gt;本文需要您了解ASP.NET Core Web API 和 xUnit的相关知识.&lt;/p&gt;
&lt;p&gt;这里有xUnit的介绍:&lt;strong&gt; &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/9178672.html#test&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/9178672.html#test&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core集成测试官方文档: &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.1&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722105529287-1087494343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;测试金字塔, 但它只是一个指导性的概念.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如果所单元测试是对一个组件进行隔离测试的话, 那么集成测试则是测试多个组件共同协作产生出期待的结果.&lt;/p&gt;
&lt;p&gt;单元测试通常很快. 而集成测试则慢的多, 因为它需要很多配置, 并且可能依赖于外部的组件, 例如数据库, 网络, 文件等.&lt;/p&gt;
&lt;p&gt;通常在一个项目里单元测试要比集成测试多很多.&lt;/p&gt;
&lt;p&gt;单元测试通常依赖于mock的组件, 而集成测试则使用可运行的组件.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意: 如果一个行为可以通过单元测试或集成测试来测试的话, 那么应该使用单元测试&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;


&lt;p&gt;如果我想测试一个API Controller的Action, 我可能需要把这个项目运行起来, 等它跑起来, 发送请求并检验结果. 但这样做的话需要很多的配置工作, 并且很麻烦.&lt;/p&gt;

&lt;p&gt;幸好ASP.NET Core 提供了一个&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;Microsoft.AspNetCore.TestHost &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;库, 使用它就无需单独去运行被测试系统了.&lt;/p&gt;
&lt;p&gt;ASP.NET Core应用里, 我们在Program.cs里创建&lt;span class=&quot;fontstyle0&quot;&gt;WebHostBuilder, 并配置&lt;span class=&quot;fontstyle0&quot;&gt;Kestrel Web服务器, 使用Startup类进行应用配置, 注册服务和中间件等. 最终在&lt;span class=&quot;fontstyle0&quot;&gt;WebHostBuilder&lt;/span&gt;上使用&lt;span class=&quot;fontstyle0&quot;&gt;Build()来创建WebHost的实例, 它可以用来在特定的URL和端口上运行并监听请求.&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;而这个TestHost库也使用了WebHostBuilder, 但它会自己把构建和运行web宿主的工作处理好, 也就是创建出了一个TestServer. TestServer不会在网络上进行监听, TestServer创建了一个名为Host的属性, 它的类型是IWebHost, 它可以用来处理内存里的请求对象. TestServer还会暴露一个HttpClient, 你可以用它来发送请求到被测试系统. 整个交互的过程都是在内存里完成的.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;下图是被测试系统在生产环境和集成测试使用TestServer情形下的对比图:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722120554833-2111382559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中:&lt;/p&gt;
&lt;p&gt;当应用/被测试系统在生产环境运行的时候, 它使用Kestrel服务器, 监听HTTP请求, 并把它转化为HttpContext, 然后再传进ASP.NET Core的管道里.&lt;/p&gt;
&lt;p&gt;TestServer不监听网络请求, 它使用HttpClient在内存里发送请求.&lt;/p&gt;

&lt;p&gt;仔细看一下集成测试时使用TestServer的流图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722120507148-479614292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中可以看到: 测试代码创建TestServer, TestServer创建HttpClient. 测试代码使用HttpClient发送请求接收响应. TestServer会转化请求并交给ASP.NET Core MVC/API 应用来处理.&lt;/p&gt;


&lt;p&gt;首先需要为你的应用建立集成测试项目:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722122011485-1204164148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后需要为项目添加&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;Microsoft.AspNetCore.TestHost &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;这个库:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722123104307-351167829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;被测试的是这个Controller的GetRoot()所对应的行为, 而不只是这个方法:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722123151497-426842563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;测试返回NoContent:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722125212539-1288525193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面按照之前讲的顺序, 创建IWebHostBuilder, 并用它创建TestServer, 然后TestServer创建HttpClient. 随后就使用httpClient发送请求, 返回结果, Assert即可.&lt;/p&gt;
&lt;p&gt;需要注意的是, 在创建IWebHostBuilder的时候, 我使用了被测试系统的Startup类来进行配置, 并设定的环境是Development.&lt;/p&gt;

&lt;p&gt;由于我这个项目可以看作是真实项目, 所以&lt;strong&gt;第一次运行该测试的时候, 测试是Fail的&lt;/strong&gt;. 因为Startup里面有很多配置并不满足测试要求.&lt;/p&gt;
&lt;p&gt;在我把IpRateLimiting, HttpsRedirection, Authentication, AuthorizeFilter等中间件/组件去掉之后, 测试才通过:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722125700482-1128711980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以这就引出了一个问题, Startup里面的配置在&lt;strong&gt;开发时&lt;/strong&gt; 和 &lt;strong&gt;测试时&lt;/strong&gt; 以及 &lt;strong&gt;生产运行时&lt;/strong&gt; 可能是不太一样的.&lt;/p&gt;
&lt;p&gt;我的Startup里面已经有很多代码了, 如果再进行环境判断, 那就会更乱了.&lt;/p&gt;
&lt;p&gt;所以我决定为集成测试新建立一个Startup配置类:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722131619077-1935244792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ASP.NET Core项目也支持多环境的多个Startup配置类, 这部分内容请参考官方文档: &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-2.1#environment-based-startup-class-and-methods&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-2.1#environment-based-startup-class-and-methods&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;然后修改代码, 使用这个测试专用的Startup即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722131725499-456628741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试会通过.&lt;/p&gt;

&lt;h2&gt;被测试系统有依赖项&lt;/h2&gt;
&lt;p&gt;下面继续测试GetRoot方法的另一个路径, 这个路径会用到RootController的依赖项IUrlHelper. &lt;/p&gt;
&lt;p&gt;在集成测试里, 通常情况下是不使用Mocking技术的. 所以在这里我也不会mock IUrlHelper:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722132958920-1878837569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里没有mock任何东西. 此外这个被测试的行为需要设置AcceptHeader.&lt;/p&gt;
&lt;p&gt;测试会Pass的, TestServer帮我搞定了一切:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722133150696-787588217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;写了两个测试方法, 又引出了一个新的问题: 这两个方法有一些共同的设置代码, 这些设置可能会比较耗资源. 我们可以把这些设置放在构造函数里面, 但是如果使用Theory并含有多个InlineData的话, 就会多次运行构造函数里的设置代码, 可能会非常好资源(时间).&lt;/p&gt;
&lt;p&gt;所以我们应该考虑使用&lt;span&gt;&lt;strong&gt;test fixture &lt;span&gt;这里有介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8438019.html#share&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8438019.html#share&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而且我们可以使用&lt;span&gt;&lt;strong&gt;WebApplicationFactory&lt;/strong&gt;&lt;/span&gt;来构建TestServer, 使用WebApplicationFactory的好处是可以灵活的进行自定义配置. &lt;/p&gt;
&lt;p&gt;要使用WebApplicationFactory, 需要添加库: Microsoft.AspNetCore.Mvc.Testing&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722134821668-1558127969.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;使用该库之后, 代码应该如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722140458580-827300082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是却有一个问题, 这里我选择的时StartupIntegrationTest. 而电脑环境变量设置的是Development, 而调试测试之后发现走的是StartupDevelopment.&lt;/p&gt;

&lt;p&gt;也许这是个Bug? 或者就是这样的意图. 那我暂时还是使用原始的方法创建TestServer吧, 下面是我使用的代码:&lt;/p&gt;
&lt;p&gt;建立一个TestServerFixture, 需要使用IDisposable来做清理工作:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722141422812-1392955953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而测试类注入该Fixture即可:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722141726970-1281700960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后重跑测试, 会pass的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722141841413-611384530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722142328674-1669084873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722143318349-351215886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我要测试这个Controller下CreateProduct方法对应的行为. 该Controller需要很多依赖项, 其中两个还需要使用数据库.&lt;/p&gt;

&lt;p&gt;通常情况下集成测试里使用的数据库和生产环境中使用的数据库不同, 在测试环境我更倾向于使用内存类数据库.&lt;/p&gt;
&lt;p&gt;EF Core里面至少有两个内存类的数据库提供商:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;Microsoft.EntityFrameworkCore.InMemory, 这个都应该知道.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;Microsoft.EntityFrameworkCore.Sqlite. 虽然说Sqlite通常是把数据保存到文件, 但是提供商为它提供了一个内存模式, 把数据库保存到了内存里.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;在StartupIntegrationTest里, 我就使用InMemory吧;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722143040535-2090366213.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 下面是测试方法的代码:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722152917739-564364595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这代码其实很简单, 就是对应着被测试的Controller方法做一些需要的设定即可, 例如Headers, Content-Type等等.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;需要注意的是Content-Type是在Content的Header里设置, 而不是Request的Headers里设置, 否则会报乱用Header的错&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;该测试会pass:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722153138904-2121632341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后针对该行为再做一个Model验证失败的测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722153836877-264897999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没什么不同, 就是model的Name属性超长了.&lt;/p&gt;
&lt;p&gt;这个测试同样会通过:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201807/986268-20180722153951573-1198489366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;集成测试就简单介绍这些.......&lt;/p&gt;

</description>
<pubDate>Sun, 22 Jul 2018 07:43:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9349391.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.0 MVC项目实战 - 墨小宇</title>
<link>http://www.cnblogs.com/danvic712/p/9349583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danvic712/p/9349583.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt; 一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        毕业后入职现在的公司快有一个月了，公司主要的产品用的是C/S架构，再加上自己现在还在学习维护很老的delphi项目，还是有很多不情愿的。之前实习时主要是做.NET的B/S架构的项目，主要还是用的那种传统的开发模式，只有一个项目用到了Web API，自己负责后端的接口功能实现。既然现在没办法改变现状，那就先改变自己吧。定了个计划，下班后慢慢的开始学习ASP.NET Core Web API和Vue，准备从前端到后端自己写一个小项目玩玩，毕竟代码这个东西，时间长了是会忘的。&lt;br/&gt;        嗯，有点扯远了。这个MVC项目是我的毕业设计，虽然写的比较烂，而且当时为了赶紧写完，代码的冗余程度有点高，但还是希望能给一些准备入门ASP.NET Core MVC的童鞋提供些借鉴吧。代码我放到Github上了，源码地址&lt;a title=&quot;点这里&quot; href=&quot;https://github.com/Lanesra712/Danvic.PSU&quot;&gt;https://github.com/Lanesra712/Danvic.PSU&lt;/a&gt;，欢迎大神们拍砖，指出不足处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二、项目介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        毕业论文的课题是一个大学生的一个报名系统，主要是为了完成大学生报名过程中的一些数据维护，当然最后因为实在来不及了，好多都没做。。。项目主要使用到的相关技术如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目框架：ASP.NET Core 2.0 MVC&lt;/li&gt;
&lt;li&gt;ORM：Entity Framework Core（使用Code First）&lt;/li&gt;
&lt;li&gt;数据库引擎：MySQL SERVER 5.7&lt;/li&gt;
&lt;li&gt;权限验证：基于策略的权限验证(Policy-Based Authorization)&lt;/li&gt;
&lt;li&gt;前端框架：AdminLte（一个基于Bootstrap的开源前端UI）&lt;/li&gt;
&lt;li&gt;表格控件：Jquery Datatables&lt;/li&gt;
&lt;li&gt;数据可视化组件：Echarts&lt;/li&gt;
&lt;li&gt;日志记录：nlog&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 三、设计与实现介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        项目架构采用的是多层架构，通过拆分不同的功能领域，实现各个功能间的相对独立，项目在VS中搭建完成后如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722110258990-1795637523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        01_Entity:实体层，包含PSU.Entity这一个系统组件，用于存储数据库中表所对应的C#对象实体。&lt;br/&gt;        02_Infrastructure:基础架构层，包含PSU.EFCore、PSU.Utility两个系统组件。PSU.EFCore类库通过引用Entity Framework Core来完成对于数据库的操作。PSU.Utility类库中包含系统开发过程中可能用到的帮助类文件。&lt;br/&gt;        03_Logic:逻辑层，包含PSU.Domain、PSU.Repository两个系统组件。PSU.Domain用于继承每个领域的接口类库（PSU.IService），实现领域接口中的功能。PSU.Repository用来实现PSU.Domain类库中所包含的对于数据库的操作。&lt;br/&gt;        04_Rule:规则层，包含PSU.IService、PSU.Model这两个系统组件。PSU.IService为系统领域功能接口类库，PSU.Model为视图所对应的数据充血模型，对应MVC模式中的实体Model。&lt;br/&gt;        Controller.PSU:控制器层，.NET Core类库，用来存放MVC模式中的各种控制器文件。&lt;br/&gt;        PSU.Site:表现层，ASP.NET Core MVC项目，项目主程序。&lt;/p&gt;
&lt;p&gt;        系统权限验证设计：&lt;br/&gt;        整个系统分为三种角色，分别为管理员、教职工、学生用户，通过使用Area搭建每个角色的页面，通过在Controller上添加Area特性，指定当前Controller属于的角色。在创建用户时，会指定用户的角色字段，当用户登录成功后，会根据用户角色进行Claim的创建，通过自定义的AuthorizztionHandler来实现对于当前系统的角色权限控制。&lt;br/&gt;        当用户登录成功后，会将当前的用户信息赋值给一个静态类（使用Session进行存储），对于判断用户是否登录，则是通过自定义一个控制器的基类，重写OnActionExecuting方法来实现对于用户是否登录的判断，实现代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d0928521-c75c-4172-bf15-cde17a1a8a6c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d0928521-c75c-4172-bf15-cde17a1a8a6c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d0928521-c75c-4172-bf15-cde17a1a8a6c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DanvicController : Controller
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 判断用户是否登录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;filterContext&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext filterContext)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (CurrentUser.UserId == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; path =&lt;span&gt; filterContext.HttpContext.Request.Path;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             filterContext.Result = &lt;span&gt;new&lt;/span&gt; RedirectResult($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Secret/Login?ReturnUrl={path}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }        
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;自定义控制器基类&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_f5a7adf0-3c67-45c0-baf1-8f5910eea79a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f5a7adf0-3c67-45c0-baf1-8f5910eea79a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f5a7adf0-3c67-45c0-baf1-8f5910eea79a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CurrentUser
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Initialize
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; IHttpContextAccessor _httpContextAccessor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ISession _session =&amp;gt;&lt;span&gt; _httpContextAccessor.HttpContext.Session;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IHttpContextAccessor httpContextAccessor)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             _httpContextAccessor =&lt;span&gt; httpContextAccessor;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; Attribute
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户主键
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserOID
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserOID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserOID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt;用户编号 
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; UserId
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;0&lt;/span&gt; : Convert.ToInt64(_session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, value != &lt;span&gt;0&lt;/span&gt; ? value.ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户姓名
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserName
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户登录账户
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserAccount
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserAccount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserAccount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户头像地址
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserImage
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserImage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserImage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户角色
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserRole
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserRole&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserRole&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 主页地址
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; UserPage
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; =&amp;gt; _session == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : _session.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt; =&amp;gt; _session.SetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentUser_UserPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(value) ? value : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt; }    
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CurrentUser类&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;        权限验证代码如下截图所示：&lt;br/&gt;        控制器示例图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722114332931-619267952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;        基于策略的权限验证实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722114508858-1125658249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;        自定义验证Claim：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722114520791-1502769938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        接下来我要开始学习ASP.NET Core Web API和Vue了，希望可以保持住，能够不间断的在博客上分享自己的学习经历与见解。当学的差不多的时候，争取把这个项目精简，重构，让自己在成为更好的自己的路途上前进一大步。&lt;br/&gt;        因为也是第一次使用ASP.NET Core MVC进行项目的开发，所以遇到了一些自己没办法解决的东西，很感谢博客园里的各位大佬以及一些帮助我的大佬，正是因为有这么多乐于分享的人在，才能更好的推动.NET Core在国内的生态发展，在写毕业设计的过程中，参考了很多位博主的博文，真的是很感谢，致敬。&lt;/p&gt;
&lt;p&gt;　　 还是要推广下自己的个人博客啊，&lt;span&gt;&lt;a title=&quot;Yu's&quot; href=&quot;https://lanesra712.github.io/&quot; target=&quot;_blank&quot;&gt;点击这里，去看看我的博客啊~~~&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        项目实现图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722152527671-1937628083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722151554922-1069570383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1310859/201807/1310859-20180722152608486-1544802079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 07:33:00 +0000</pubDate>
<dc:creator>墨小宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/danvic712/p/9349583.html</dc:identifier>
</item>
<item>
<title>RobotFramework自动化测试框架-Selenium Web自动化(-)-Open Browser和Close Browser - 张永清</title>
<link>http://www.cnblogs.com/laoqing/p/9350214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laoqing/p/9350214.html</guid>
<description>&lt;p&gt;Selenium出来已经有很多年了，从最初的Selenium1到后来的Selenium2，也变得越来越成熟，而且也已经被很多公司广泛使用。Selenium发展的过程中，分了很多模块，这里我们主要介绍Webdriver，Webdriver已经被很多浏览器所兼容。WebDriver在自动化脚本和浏览器之间充当的角色和之前介绍的Appium很像。&lt;/p&gt;
&lt;p&gt;由于现在很多的浏览器都已经主动支持和兼容了WebDriver，所以Webdriver在启动后，会确认浏览器的native component是否存在可用而且版本匹配，接着就在目标浏览器里启动使用Selenium自己设计定义的协议（WebDriver Wire Protocol），WebDriver Wire协议是通用的，也就是说不管是FirefoxDriver还是ChromeDriver等，启动之后都会在某一个端口启动基于这套协议的Web 服务，WebDriver Wire协议是一套基于RESTful的web服务。&lt;/p&gt;
&lt;p&gt;在调用WebDriver的时候，实际上是给在浏览器上启动的RESTful服务监听端口上发送http请求，请求会以WebDriver Wire协议规定的JSON格式的字符串来告诉Selenium希望浏览器执行什么样的操作。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;  Selenium和RobotFramework Selenium2Library库介绍&lt;/h3&gt;
&lt;p&gt;通过&lt;a href=&quot;http://www.seleniumhq.org/&quot;&gt;http://www.seleniumhq.org/&lt;/a&gt; 可以访问Selenium官网。从该网站上可以下载到各种浏览器运行需要的Driver。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201807/1200756-20180722145926193-1662628313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201807/1200756-20180722145947810-465843894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;http://www.seleniumhq.org/docs/&quot;&gt;http://www.seleniumhq.org/docs/&lt;/a&gt; 地址可以查询到关于Selenium的文档和介绍等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201807/1200756-20180722150016781-1506281375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 align=&quot;left&quot;&gt; Open Browser和Close Browser&lt;/h3&gt;
&lt;p&gt;在Selenium2Library库中，Open Browser关键字用来打开一个指定的浏览器，该关键字接收如下参数：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;参数（Arguments）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;url&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;浏览器中需要打开的url地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;browser&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;指定需要打开的浏览器类型，包括IE，Firefox，chrome，opera, safari等常用的浏览器，默认使用Firefox&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;alias&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设定的浏览器实例的别名，可以用于浏览器之间的切换，默认为None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;remote_url&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;是否启用通过remote server的形式来访问，默认为False&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;desired_capabilities&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;可以指定的配置参数，默认为None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;ff_profile_dir&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;该参数主要针对火狐浏览器，可以通过该参数指定firefox profile路径，默认为None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Close Browser 关键字用来关闭一个已经打开的当前浏览器。&lt;/p&gt;
&lt;p&gt;示例1：打开谷歌浏览器，url地址中输入&lt;a href=&quot;http://www.baidu.com/&quot;&gt;http://www.baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Open Browser&lt;/strong&gt; http://www.baidu.com    chrome&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;Starting test: RobotFrameworkTest1.TestSuite6.TestCase0002&lt;/p&gt;
&lt;p&gt;20170529 15:22:55.284 :  INFO : Opening browser 'chrome' to base url 'http://www.baidu.com'&lt;/p&gt;
&lt;p&gt;Ending test:   RobotFrameworkTest1.TestSuite6.TestCase0002&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201807/1200756-20180722150205754-107712398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例2：打开IE浏览器，url地址中输入&lt;a href=&quot;http://www.baidu.com/&quot;&gt;http://www.baidu.com&lt;/a&gt;，然后关闭浏览器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Open Browser        &lt;/strong&gt; &lt;a href=&quot;http://www.baidu.com/&quot;&gt;http://www.baidu.com&lt;/a&gt;    ie&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Close Browser&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;Starting test: RobotFrameworkTest1.TestSuite6.TestCase0001&lt;/p&gt;
&lt;p&gt;20170529 15:31:01.937 :  INFO : Opening browser 'ie' to base url 'http://www.baidu.com'&lt;/p&gt;
&lt;p&gt;Ending test:   RobotFrameworkTest1.TestSuite6.TestCase0001&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201807/1200756-20180722150312074-1157626888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外在使用IE浏览器时，需要将浏览器选项中，安全标签下的每个区域中是否启用保护模式保持一致，要么全部启用，要么全部不启用，如下图所示，不然的话容易出现类似WebDriverException: Message: Unexpected error launching Internet Explorer. Protected Mode settings are not the same for all zones. Enable Protected Mode must be set to the same value (enabled or disabled) for all zones.的报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1200756/201807/1200756-20180722150340501-563218981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【原文归作者所有，欢迎转载，但是保留版权,并且转载时，需要注明出处&lt;/strong&gt;】&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 07:05:00 +0000</pubDate>
<dc:creator>张永清</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laoqing/p/9350214.html</dc:identifier>
</item>
<item>
<title>由AbstractQueuedSynchronizer和ReentrantLock来看模版方法模式 - lingjiango</title>
<link>http://www.cnblogs.com/iou123lg/p/9350108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iou123lg/p/9350108.html</guid>
<description>&lt;p&gt;　　在学完&lt;a href=&quot;http://www.cnblogs.com/iou123lg/p/9280639.html&quot; target=&quot;_blank&quot;&gt;volatile&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9314826.html&quot; target=&quot;_blank&quot;&gt;CAS&lt;/a&gt;之后，近几天在撸AbstractQueuedSynchronizer（AQS）的源代码，很多并发工具都是基于AQS来实现的，这也是并发专家Doug Lea的初衷，通过写一个这样的基础工具来提高j.u.c的灵活性。具体可以看&lt;a href=&quot;http://gee.cs.oswego.edu/dl/papers/aqs.pdf&quot; target=&quot;_blank&quot;&gt;这篇论文&lt;/a&gt;的一段原文，我摘录一下：&lt;/p&gt;
&lt;p&gt;　　As is well-known (see e.g., [2]) nearly any synchronizer can be used to implement nearly any other. For example, it is possible to build semaphores from reentrant locks, and vice versa. However,doing so often entails enough complexity, overhead, and inflexibility to be at best a second-rate engineering option.Further, it is conceptually unattractive. If none of these constructs  are intrinsically more primitive than the others, developers should not be compelled to arbitrarily choose one of them as a basis for building others. Instead, JSR166 establishes a small  framework centered on class AbstractQueuedSynchronizer,that provides common mechanics that are used by most of the provided synchronizers in the package, as well as other classes that users may define themselves.&lt;/p&gt;
&lt;p&gt;　　翻译下来大致的意思就是，如果使用信号量、锁等互为彼此实现，这样一种设计只会让问题变得复杂而且缺乏灵活性，既然这样，JSR166提出了AQS来作为基础工具来对外提供一种通用的机制。&lt;/p&gt;
&lt;p&gt;        AQS的设计和实现非常复杂，所以我打算通过DEBUG的方式看下内部是如何实现的，在看源码的过程中顺便学习了一个设计模式-模板方法。&lt;/p&gt;
&lt;p&gt;         &lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;、模板方法结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        模板方法的本质其实就是类的继承，模板方法模式需要开发抽象类和具体子类的设计之间的协作，我们实际工作中应该有很多这样的场景，比如我们通常会在业务逻辑层定义好Service类的抽象方法，而实际的业务逻辑实现会交给ServiceImpl类。模板方法模式的类结构图大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/289599/201807/289599-20180722142643500-33866559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　图一&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　抽象模板&lt;/strong&gt;&lt;strong&gt;(AbstractTemplate)&lt;/strong&gt;&lt;strong&gt;角色有如下责任：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。定义并实现了一个模板方法,这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。AbstractQueuedSynchronizer就是这样一个抽象模板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　具体模板&lt;/strong&gt;&lt;strong&gt;(ConcreteTemplate)&lt;/strong&gt;&lt;strong&gt;角色又有如下责任：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。ReentrantLock算是这样一个具体模板，不过ReentrantLock把自己的实现又委托给了内部实现类Sync。&lt;/p&gt;
&lt;p&gt;　　模板模式的关键是：&lt;strong&gt;子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。&lt;/strong&gt;每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;、模板方法模式中的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　模板方法中的方法可以分为两大类：&lt;strong&gt;模板方法和基本方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;模板方法&lt;/strong&gt;：一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;基本方法&lt;/strong&gt;：基本方法又可以分为三种：&lt;strong&gt;抽象方法&lt;/strong&gt;&lt;strong&gt;(Abstract Method)&lt;/strong&gt;&lt;strong&gt;、具体方法(Concrete Method)&lt;/strong&gt;&lt;strong&gt;和钩子方法(Hook Method)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;抽象方法&lt;/strong&gt;：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;具体方法&lt;/strong&gt;：一个具体方法由抽象类声明并实现，而子类并不实现或置换。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;钩子方法&lt;/strong&gt;：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;、由AbstractQueuedSynchronizer&lt;/strong&gt;&lt;strong&gt;和ReentrantLock&lt;/strong&gt;&lt;strong&gt;来看模版方法模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以ReentrantLock的lock方法为例来看下模板方法的体现。具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MutexDemo {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  private static Mutex mutex = new Mutex();&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ReentrantLock mutex = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
                mutex.lock();
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    mutex.unlock();
                }
            });
            thread.start();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　默认是以非公平锁来初始化ReentrantLock，所以方法中ReentrantLock将自己的行为委托给NonfairSync，NonfairSync继承Sync，Sync又继承了AbstractQueuedSynchronizer。在整个过程中AbstractQueuedSynchronizer的方法acquire其实就是&lt;strong&gt;模板模式里面的模板方法&lt;/strong&gt;，方法release也是一样的，这两个方法是整套框架里面的顶级逻辑。在这个顶级逻辑之外，Sync给出了lock方法，这是一个&lt;strong&gt;抽象方法&lt;/strong&gt;，下设2种实现，分别是公平锁FairSync和非公平锁NonfairSync。在顶级逻辑里面还有方法的&lt;strong&gt;具体方法&lt;/strong&gt;实现，比如addWaiter和acquireQueued。另外还有一个&lt;strong&gt;钩子方法&lt;/strong&gt;，如tryAcquire，在AQS里面这个钩子方法是没有具体的实现的，具体的实现交给了NonfairSync。感兴趣的读者可以按照这思路跟踪下代码，然后理解一下模板方法这个设计模式。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lingjiango/ConcurrentProgramPractice&quot;&gt;https://github.com/lingjiango/ConcurrentProgramPractice&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html&quot;&gt;http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Jul 2018 06:41:00 +0000</pubDate>
<dc:creator>lingjiango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iou123lg/p/9350108.html</dc:identifier>
</item>
<item>
<title>基于Python的datetime模块和time模块源码阅读分析 - 舞动的心</title>
<link>http://www.cnblogs.com/liuzhen1995/p/9350125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuzhen1995/p/9350125.html</guid>
<description>&lt;blockquote readability=&quot;0.90225563909774&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a1&quot;&gt;&lt;strong&gt;&lt;span&gt;1 前言 &lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2&quot;&gt;&lt;strong&gt;&lt;span&gt;2 datetime.pyi源码分步解析&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.1&quot;&gt;&lt;span&gt;2.1 &lt;span&gt;头部定义源码分析&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.2&quot;&gt;&lt;span&gt;2.2 tzinfo&lt;span&gt;类源码分析&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.3&quot;&gt;&lt;span&gt;2.3 date&lt;span&gt;类源码分析&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.4&quot;&gt;&lt;span&gt;2.4 time&lt;span&gt;类源码分析&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.5&quot;&gt;&lt;span&gt;2.5 timedelta&lt;span&gt;类源码分析&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.6&quot;&gt;&lt;span&gt;2.6 datetime&lt;span&gt;类源码分析&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a2.7&quot;&gt;&lt;span&gt;2.7 &lt;span&gt;格式化字符串&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a3&quot;&gt;&lt;strong&gt;&lt;span&gt;3 time模块time.pyi源码解析&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;最近工作需求上对于datetime模块中的方法调用比较多，有时还要返回指定的格式，以及大小比较等情况。发现使用Python自带的datetime模块可以很好地实现相关需求，但是对于其中的具体实现原理以及相关方法的特性不是很了解，所以决定花点时间来看看datetime模块的源码以及time模块的源码，提高自己以后实现此类需求的工作效率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一般情况下，我们引用datetime模块相关方式，引用有两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; datetime   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此种引用，即包含了datetime模块所有方法，但是引用具体方法时，需要这样写：datetime.date.today()，表示获取今天的日期，要多写一个datetime&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（2）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt; datetime, time, timedelta, tzinfo, date  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此种应用，可以看实际需求决定需要应用那个类方法，比如只应用date时，使用date.today()即可获取今天的日期&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;通过初步阅读datetime模块源码，datetime模块包含五个内部类，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tzinfo类（表示日期时间的时区）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;date类（表示具体日期，精确到天，例如2018-7-22）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;time类（表示具体时间，可精确到微秒，例如11:47:23.0001）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;timedelta类（可表示具体的时间差，例如一小时时间差为timedelta(hours=1)）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;datetime类(表示具体日期时间，可理解为date类+time类所有属性和内部方法的结合体，例如：2018-7-22 11:49:30.0001)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意在看datetime源码时，会发现源码包有一个datetime.pyi文件，通过查找资料得知：每一个模块源码都会有一个对于的.pyi文件，该文件只列出具体的实现方法头部代码和相关参数和返回值说明。例如，给出一篇论文的目录，具体内容可通过目录索引查看具体细节。（PS:资料种说明.pyi表示“存根文件”。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201807/927750-20180722141948502-2006458288.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用time模块方式，引用方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; time
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;time模块内部只有相关调用方法，源码较少。&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;h2&gt;&lt;strong&gt;2.1 &lt;span&gt;头部定义源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42.915068493151&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; time &lt;span&gt;import&lt;/span&gt; struct_time  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关于struct_time的具体源码，&lt;a href=&quot;http://www.cnblogs.com/liuzhen1995/p/9350125.html#a3&quot;&gt;可见下文详解&lt;/a&gt;&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (

    AnyStr, Optional, SupportsAbs, Tuple, Union, overload,

    ClassVar,

)  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 请注意其中有多个类型，可能初次见面，不太明白，下面到具体应用会详细说明&lt;/span&gt;

 
&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3,):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处判断本地Python版本，是否大于3.0.0&lt;/span&gt;
&lt;span&gt;
    _Text &lt;/span&gt;= str    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示_Text代表类型str&lt;/span&gt;

&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

    _Text &lt;/span&gt;= Union[str, unicode]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示_Text可选类型有str和unicode；Union功能是可以结合多个类型，但是如果类型之间有继承关系，只取优先级最高的，即辈份最高的父类&lt;/span&gt;
&lt;span&gt;
MINYEAR: int     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义默认的最小年数，为1&lt;/span&gt;&lt;span&gt;
MAXYEAR: int     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义默认的最大年数，为9999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;2.2 tzinfo&lt;span&gt;类源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;tzinfo：time zone infomation，即时区信息，从该类类名即可知道其作用为限定给定时间的时区参数提供支持。该类的对象实例传递给datetime或者time对象的构造函数，从而输出相应时区的信息，如果不传递则默认输出本地时区的对应时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; tzinfo:

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面使用的Optional类型，意思是该变量的具体实际类型或者为None，Optional[X]等同于Union[X, None]&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回指定datetime对象的所在时区名称，返回值类型为字符串&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; tzname(self, dt: Optional[datetime]) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当地时间与UTC（世界统一时间）的偏移量，返回值类型是timedelta类型&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; utcoffset(self, dt: Optional[datetime]) -&amp;gt;&lt;span&gt; Optional[timedelta]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;dst(daylight saving time,阳光节约时或称夏至时)，该方法用于获取夏至时调整量，一般不需要调用&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; dst(self, dt: Optional[datetime]) -&amp;gt;&lt;span&gt; Optional[timedelta]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调整日期（date）和时间(time)数据，在自己的本地时间返回一个等效的日期时间(datetime)。&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; fromutc(self, dt: datetime) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 2):    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当Python版本大于等于3.2.0时， 添加类tzinfo的timezone子类实现&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; timezone(tzinfo):

&quot;&quot;&quot;以下用到了一个ClassVar变量，这是一个类变量类型，是Python3.6版本新添加的功能；

网上解析：已添加typing.ClassVar类型构造，来标识类变量。如 &lt;/span&gt;**PEP 526**&lt;span&gt;中所述，封装在ClassVar中的一个变量注释暗示着一个给定的属性打算作为一个类变量使用，并且不应该在那个类的实例上设置它。

&quot;&quot;&quot;
        utc: ClassVar[timezone]   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  定义的一个类变量，源码中具体实现：timezone.utc = timezone._create(timedelta(0))&lt;/span&gt;
&lt;span&gt;
        min: ClassVar[timezone]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义的一个类变量，源码中具体实现：timezone.min = timezone._create(timezone._minoffset)&lt;/span&gt;
&lt;span&gt;
        max: ClassVar[timezone]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义的一个类变量，源码中具体实现：timezone.max = timezone._create(timezone._maxoffset)&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类timezone的构造函数，用于定义对象时的初始化函数&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, offset: timedelta, name: str = ...) -&amp;gt;&lt;span&gt; None: ...  

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为该类定义的哈希函数，对象调用该方法，可以返回一个hash值，该对象可以用作字典中的key或集合中的一员&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__hash__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; int: ...

_tzinfo &lt;/span&gt;= tzinfo   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义类tzinfo的一个别名，前面加一个下划线，表示该别名只能在当前类内部使用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;2.3 date&lt;span&gt;类源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; date:

    min: ClassVar[date]   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date类变量，具体实现：date.min = date(1, 1, 1)，表示1年1月1日&lt;/span&gt;
&lt;span&gt;
    max: ClassVar[date]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date类变量，具体实现：date.max = date(9999, 12, 31)，表示9999年12月31日&lt;/span&gt;
&lt;span&gt;
    resolution: ClassVar[timedelta] &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类变量，具体实现：date.resolution = timedelta(days=1)，表示时长为1天的timedelta类变量&lt;/span&gt;

 
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造函数，初始化参数分别为年(year)、月(month)、日(day)，返回值类型为None&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, year: int, month: int, day: int) -&amp;gt;&lt;span&gt; None: ...

&quot;&quot;&quot;此处先简单说明一下@classmethod装饰器的作用：在类前面加该装饰器，特点就是可以通过类名去调用，但是也必须传递一个参数，一般用cls表示class，表示可以通过类直接调用”””
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过传入一个float类型的时间戳值，返回该时间戳对应的日期（date类型，年月日）&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fromtimestamp(cls, t: float) -&amp;gt;&lt;span&gt; date: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回系统今天的日期，类似fromtimestamp(t=time.time())调用结果&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; today(cls) -&amp;gt;&lt;span&gt; date: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数n为天数，通过给定天数，返回具体的日期（date类型，年月日），从公元1年1月1日开始，即n=1，表示公元1年1月1日&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fromordinal(cls, n: int) -&amp;gt;&lt;span&gt; date: ...


&quot;&quot;&quot;先说一下装饰器@property作用：负责把一个方法变成属性调用的。因此，类对象可以直接调用该方法作为属性使用，例如test_date.year直接返回对象test_date的年份数据”””

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象对应的年份信息，可作为对象的属性直接调用&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; year(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象对应的月份信息，可作为对象的属性直接调用&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; month(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象对应的天信息，可作为对象的属性直接调用&lt;/span&gt;&lt;span&gt;
 @property
 &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; day(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前date对象的ctime()样式字符串，例如今天是2018-07-21 星期六，则返回'Sat Jul 21 00:00:00 2018'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; ctime(self) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; fmt(format缩写，代表格式)类型为_Text在头部文件代码有定义，该方法依据提供的格式返回对应date对应对象的字符串格式，例如：fmt=&quot;%Y-%m-%dT%H:%M:%SZ&quot;,返回示例：'2018-07-21T00:00:00Z'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; strftime(self, fmt: _Text) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3,):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当Python版本大于等于3.0.0&lt;/span&gt;
     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__format__&lt;/span&gt;(self, fmt: str) -&amp;gt;&lt;span&gt; str: ...
 &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
     &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__format__&lt;/span&gt;(self, fmt: AnyStr) -&amp;gt; AnyStr: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处有一个新的类型AnyStr，看源码中具体实现为：AnyStr = TypeVar('AnyStr', bytes, str)，表示该类型为str结构类型或者bytes结构类型，附源码中注释：&lt;/span&gt;
&lt;span&gt;
&quot;&quot;&quot;
 Usage::
      T &lt;/span&gt;= TypeVar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Can be anything&lt;/span&gt;&lt;span&gt;
      A &lt;/span&gt;= TypeVar(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, str, bytes)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Must be str or bytes&lt;/span&gt;&lt;span&gt;
&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回date对象的ISO格式的日期，具体为”yyyy-mm-dd&quot;，例如：'2018-07-21'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; isoformat(self) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回与time.localtime（）兼容的本地时间元组。返回示例：time.struct_time(tm_year=2018, tm_mon=7, tm_mday=21, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=202, tm_isdst=-1)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; timetuple(self) -&amp;gt;&lt;span&gt; struct_time: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回指定日期，从公元1年1月1日到现在的总天数，例如date(1,2,1).toordinal()=32&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; toordinal(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改初始化date对象中year、month、int属性的值，例如date(2018,7,18).replace(year=2019)，则该日期就变成2019年7月18日&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; replace(self, year: int = ..., month: int = ..., day: int = ...) -&amp;gt;&lt;span&gt; date: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象间的大小比较，le表示 &amp;lt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__le__&lt;/span&gt;(self, other: date) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象间的大小比较，lt表示 &amp;lt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__lt__&lt;/span&gt;(self, other: date) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象间的大小比较，ge表示 &amp;gt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__ge__&lt;/span&gt;(self, other: date) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象间的大小比较，gt表示 &amp;gt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__gt__&lt;/span&gt;(self, other: date) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象的加操作，但是添加的值只能是timedelta对象，而不能是date对象&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; date: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象的减操作，但是减去的值只能是timedelta对象，而不能是date对象&lt;/span&gt;&lt;span&gt;
@overload  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重载功能装饰器，关于重载的概念可自行网上搜索&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; date: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;date对象的减操作，但是减去的值只能是date对象&lt;/span&gt;&lt;span&gt;
@overload   
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;(self, other: date) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; date对象的哈希化方法，可以返回当前对象的哈希值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__hash__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回当前date对象的星期几数目，例如2018年7月21日星期六，当天的date.today().weekday() = 5。注意：Monday == 0 ... Sunday == 6.所以5代表星期六&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; weekday(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前date对象的星期几数目，注意：Monday == 1 ... Sunday == 7.则星期六，就返回6。&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; isoweekday(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前date对象的年份、本年份的所在周数、星期几，例如：date(1,2,1).isocalendar()=（1，5，4）表示公元1年2月1日，年份是1，周数是4（公元1年的第4周），星期四&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; isocalendar(self) -&amp;gt; Tuple[int, int, int]: ...
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;2.4 time&lt;span&gt;类源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;下述方法有部分和上面date类实现或者意义类似，就大概简单说明，不作详细介绍啦。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; time:

    min: ClassVar[time]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time类变量，具体实现：time.min = time(0, 0, 0)&lt;/span&gt;
&lt;span&gt;
    max: ClassVar[time]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time类变量，具体实现：time.max = time(23, 59, 59, 999999)&lt;/span&gt;
&lt;span&gt;
    resolution: ClassVar[timedelta] &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类变量，具体实现：time.resolution = timedelta(microseconds=1)&lt;/span&gt;

 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time类的构造函数，依据参数名即可知道具体参数的实际意义&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, hour: int = ..., minute: int = ..., second: int = ..., microsecond: int =&lt;span&gt; ...,
                 tzinfo: Optional[tzinfo] &lt;/span&gt;= ...) -&amp;gt;&lt;span&gt; None: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time对象的具体hour属性函数&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; hour(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time对象的具体minute属性函数&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; minute(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time对象的具体second属性函数&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; second(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time对象的具体microsecond(微秒)属性函数&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; microsecond(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time对象所在时区信息，该属性方法表示该time对象的当前所在时区，默认为None&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; tzinfo(self) -&amp;gt;&lt;span&gt; Optional[_tzinfo]: ...

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当Python版本大于等于3.6.0时&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time类对象的 fold属性方法是3.6版本新添加的特性，主要用于区分本地相同两个时刻的分歧，当未出现此类情况时，fold值默认为0&lt;/span&gt;&lt;span&gt;
        @property
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fold(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time类对象间大小比较，le表示 &amp;lt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__le__&lt;/span&gt;(self, other: time) -&amp;gt;&lt;span&gt; bool: ...
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time类对象间大小比较，lt表示 &amp;lt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__lt__&lt;/span&gt;(self, other: time) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time类对象间大小比较，ge表示 &amp;gt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__ge__&lt;/span&gt;(self, other: time) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;time类对象间大小比较，gt表示 &amp;gt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__gt__&lt;/span&gt;(self, other: time) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;可获取time类对象的hash值函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__hash__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回ISO格式化的时间，例如time(1,1,1,1).isoformat()返回：'01:01:01.000001'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; isoformat(self) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回给定fmt格式的time对象字符串，例如time(1,1,1,1).strftime(&quot;%H:%M:%S&quot;)返回：'01:01:01'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; strftime(self, fmt: _Text) -&amp;gt;&lt;span&gt; str: ...
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3,):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当Python版本大于等于3.0.0时&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__format__&lt;/span&gt;(self, fmt: str) -&amp;gt; str: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测fmt类型是否为str&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__format__&lt;/span&gt;(self, fmt: AnyStr) -&amp;gt; AnyStr: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;检测fmt类型是否为AnyStr&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回当前time类对象UTC以东的分钟时区偏移（西区为负），默认为空&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; utcoffset(self) -&amp;gt;&lt;span&gt; Optional[timedelta]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回当前time类对象的时区名称，time类对象初始化默认时区为空，所以此处返回值一般也为空&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; tzname(self) -&amp;gt;&lt;span&gt; Optional[str]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回当前time类对象的UTC偏移量，一般tzinfo为空时，此处返回值也为空，如果tzInfo不为空，没有偏移量则返回0&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; dst(self) -&amp;gt;&lt;span&gt; Optional[int]: ...

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前Python版本大于等于3.6.0时&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该函数作用为修改time类对象具体属性值，其中有一个fold属性，是3.6版本新添加的属性&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; replace(self, hour: int = ..., minute: int = ..., second: int =&lt;span&gt; ...,
                    microsecond: int &lt;/span&gt;= ..., tzinfo: Optional[_tzinfo] =&lt;span&gt; ...,
                    &lt;/span&gt;*, fold: int = ...) -&amp;gt;&lt;span&gt; time: ...
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; replace(self, hour: int = ..., minute: int = ..., second: int =&lt;span&gt; ...,
                    microsecond: int &lt;/span&gt;= ..., tzinfo: Optional[_tzinfo] = ...) -&amp;gt;&lt;span&gt; time: ...
 
_date &lt;/span&gt;= date   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类date定义的别名，只限本类中使用&lt;/span&gt;&lt;span&gt;
_time &lt;/span&gt;= time   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类time定义的别名，只限本类中使用&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;2.5 timedelta&lt;span&gt;类源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;timedelta实际意义表示两个日期时间对象之间的差异，例如可作为date对象的运算成员。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class timedelta(SupportsAbs[timedelta]):&lt;br/&gt;min: ClassVar[timedelta]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类变量，具体实现：timedelta.min = timedelta(-999999999)&lt;/span&gt;
&lt;span&gt;
    max: ClassVar[timedelta]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类变量，具体实现：timedelta.max = timedelta(days=999999999, hours=23, minutes=59, seconds=59,&lt;/span&gt;&lt;span&gt;microseconds&lt;/span&gt;=999999&lt;span&gt;)

    resolution: ClassVar[timedelta]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类变量，具体实现：timedelta.resolution = timedelta(microseconds=1)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta的构造函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, days: float = ..., seconds: float = ..., microseconds: float =&lt;span&gt; ...,
                 milliseconds: float &lt;/span&gt;= ..., minutes: float = ..., hours: float =&lt;span&gt; ...,
                 weeks: float &lt;/span&gt;= ...) -&amp;gt;&lt;span&gt; None: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类对象days(天数)属性方法&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; days(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类对象seconds(秒数)属性方法&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; seconds(self) -&amp;gt;&lt;span&gt; int: ...
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类对象microseconds(微秒数)属性方法&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; microseconds(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取timedelta类对象总秒数，例如timedelta(hours=1).total_seconds()=3600.0&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; total_seconds(self) -&amp;gt;&lt;span&gt; float: ...&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta类对象间相加操作函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码中关于此方法实现：__radd__ = __add__，可看出功能作用和__add__一样&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__radd__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前timedelta对象 - other对象值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回other对象 - 当前timedelta对象值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__rsub__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源码中返回:timedelta(-self._days,-self._seconds,-self._microseconds)，具体作用不明&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__neg__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前timedelte对象，例如timedelta(microseconds=1).__pos__()，返回结果：datetime.timedelta(0, 0, 1)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__pos__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前timedelte对象绝对值，和__neg__作用相反&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__abs__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回两个timedelta对象self*other的值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__mul__&lt;/span&gt;(self, other: float) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回两个timedelta对象乘积，源码实现：__rmul__ = __mul__，可知和__mul__功能一样&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__rmul__&lt;/span&gt;(self, other: float) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除数是timedelta类型的整除运算，向下取整&lt;/span&gt;&lt;span&gt;
@overload
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__floordiv__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除数是int类型的整除运算，向下取整&lt;/span&gt;&lt;span&gt;
@overload
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__floordiv__&lt;/span&gt;(self, other: int) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3,):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当python版本大于等于3.0.0时&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除数是timedelta类型的除法运算，结果是浮点数&lt;/span&gt;&lt;span&gt;
        @overload
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__truediv__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; float: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除数是float类型的除法运算，结果是timedelta类型&lt;/span&gt;&lt;span&gt;
        @overload
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__truediv__&lt;/span&gt;(self, other: float) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取余运算，返回余数&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__mod__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; timedelta: ...&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取整运算和取余运算结合，返回int类型结果是取整结果，返回timedelta类型是取余结果&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__divmod__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; Tuple[int, timedelta]: ...
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除法运算，返回结果是float，此处源码未找到具体实现，此处释义是我自己猜的&lt;/span&gt;&lt;span&gt;
        @overload
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__div__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; float: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除法运算，返回的结果是timedelta，此处源码中也未找到具体实现代码&lt;/span&gt;&lt;span&gt;
        @overload
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__div__&lt;/span&gt;(self, other: float) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，le表示&amp;lt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__le__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，lt表示&amp;lt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__lt__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，ge表示&amp;gt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__ge__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，gt表示&amp;gt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__gt__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; timedelta对象取哈希值函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__hash__&lt;/span&gt;(self) -&amp;gt; int: ...
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;2.6 datetime&lt;span&gt;类源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;pre&gt;
&lt;span&gt;datetime类是date类的子类。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;160&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; datetime:

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO: Is a subclass of date, but this would make some types incompatible.&lt;/span&gt;
&lt;span&gt;
    min: ClassVar[datetime]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;datetime类变量，源码实现：datetime.min = datetime(1, 1, 1)&lt;/span&gt;
&lt;span&gt;
    max: ClassVar[datetime]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;datetime类变量，源码实现：datetime(9999, 12, 31, 23, 59, 59, 999999)&lt;/span&gt;
&lt;span&gt;
    resolution: ClassVar[timedelta]  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;datetime类变量，源码实现：datetime.resolution = timedelta(microseconds=1)&lt;/span&gt;

 

&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处依据Python版本是否大于等于3.6.0，来区分构造函数&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意，此处多了一个fold参数，这是3.6版本新添加的属性，用于区分时间分歧&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, year: int, month: int, day: int, hour: int =&lt;span&gt; ...,
                     minute: int &lt;/span&gt;= ..., second: int = ..., microsecond: int =&lt;span&gt; ...,
                     tzinfo: Optional[tzinfo] &lt;/span&gt;= ..., *, fold: int = ...) -&amp;gt;&lt;span&gt; None: ...
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, year: int, month: int, day: int, hour: int =&lt;span&gt; ...,
                     minute: int &lt;/span&gt;= ..., second: int = ..., microsecond: int =&lt;span&gt; ...,
                     tzinfo: Optional[tzinfo] &lt;/span&gt;= ...) -&amp;gt;&lt;span&gt; None: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以下包含@property装饰器的属性函数，可依据函数名知道其具体作用，不作详细说明&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; year(self) -&amp;gt;&lt;span&gt; int: ...
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; month(self) -&amp;gt;&lt;span&gt; int: ...
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; day(self) -&amp;gt;&lt;span&gt; int: ...
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; hour(self) -&amp;gt;&lt;span&gt; int: ...
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; minute(self) -&amp;gt;&lt;span&gt; int: ...
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; second(self) -&amp;gt;&lt;span&gt; int: ...
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; microsecond(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该属性函数，表示datetime类对象的时区信息，默认为空&lt;/span&gt;&lt;span&gt;
@property
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; tzinfo(self) -&amp;gt;&lt;span&gt; Optional[_tzinfo]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当python版本大于等于3.6时，添加一个fold属性函数&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6&lt;span&gt;):  
        @property
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fold(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将一个时间戳格式的数字，转换为datetime类型对象，例如 datetime.fromtimestamp(1582982934.11)=datetime.datetime(2020, 2, 29, 21, 28, 54, 110000)&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fromtimestamp(cls, t: float, tz: Optional[_tzinfo] = ...) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一般情况下和fromtimestamp返回结果一样，如果有UTC时间偏差则会出现结果偏差&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; utcfromtimestamp(cls, t: float) -&amp;gt;&lt;span&gt; datetime: ...、

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回今天的具体日期时间，例如datetime.today()=datetime.datetime(2018, 7, 22, 9, 59, 6, 907570)&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; today(cls) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入具体天数，返回当前天数的从公元1年1月1日开始计算后的日期时间&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; fromordinal(cls, n: int) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前系统时间戳对应的日期时间，例如：datetime.now()=datetime.datetime(2018, 7, 22, 10, 3, 21, 38726)&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; now(cls, tz: Optional[_tzinfo] = ...) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回当前系统UTC时间戳对应的日期时间&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; utcnow(cls) -&amp;gt;&lt;span&gt; datetime: ...
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依据Python版本是否大于等于3.6，定义combine函数&lt;/span&gt;&lt;span&gt;
        @classmethod
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; combine(cls, date: date, time: time, tzinfo: Optional[_tzinfo] = ...) -&amp;gt;&lt;span&gt; datetime: ...
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        @classmethod
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; combine(cls, date: date, time: time) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依据fmt格式，返回指定格式的datetime时间字符串&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; strftime(self, fmt: _Text) -&amp;gt;&lt;span&gt; str: ...
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3,):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处依据Python版本是否大于等于3.0来初始化__format__函数&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__format__&lt;/span&gt;(self, fmt: str) -&amp;gt;&lt;span&gt; str: ...
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__format__&lt;/span&gt;(self, fmt: AnyStr) -&amp;gt;&lt;span&gt; AnyStr: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回从公元1年1月1日到当前datetime对象所代表日期间的总天数，例如：datetime(2,1,1,1,1,1,1).toordinal() = 366&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; toordinal(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前日期的time_struct格式的结果&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; timetuple(self) -&amp;gt;&lt;span&gt; struct_time: ...


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前日期对象所对应的时间戳结果&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt; timestamp(self) -&amp;gt;&lt;span&gt; float: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前日期UTC的time_struct格式的结果&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; utctimetuple(self) -&amp;gt;&lt;span&gt; struct_time: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前日期时间对象的具体日期，例如datetime.today().date()=datetime.date(2018, 7, 22)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; date(self) -&amp;gt;&lt;span&gt; _date: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前日期时间对象的具体时间，例如datetime.today().time()=datetime.time(10, 15, 58, 933266)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; time(self) -&amp;gt;&lt;span&gt; _time: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前日期时间对象的具体时间，其中包含了该时间的时区信息，一般为空&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; timetz(self) -&amp;gt;&lt;span&gt; _time: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依据版本判断，定义不同的replace覆盖函数&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; replace(self, year: int = ..., month: int = ..., day: int = ..., hour: int =&lt;span&gt; ...,
                    minute: int &lt;/span&gt;= ..., second: int = ..., microsecond: int =&lt;span&gt; ..., tzinfo:
                    Optional[_tzinfo] &lt;/span&gt;= ..., *, fold: int = ...) -&amp;gt;&lt;span&gt; datetime: ...
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; replace(self, year: int = ..., month: int = ..., day: int = ..., hour: int =&lt;span&gt; ...,
                    minute: int &lt;/span&gt;= ..., second: int = ..., microsecond: int =&lt;span&gt; ..., tzinfo:
                    Optional[_tzinfo] &lt;/span&gt;= ...) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依据版本判断，返回包含时区信息的datetime类型值，例如：datetime.today().astimezone()=datetime.datetime(2018, 7, 22, 10, 51, 1, 6604, tzinfo=datetime.timezone(datetime.timedelta(0, 28800), 'CST'))&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 3&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; astimezone(self, tz: Optional[_tzinfo] = ...) -&amp;gt;&lt;span&gt; datetime: ...
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; astimezone(self, tz: _tzinfo) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回ctime格式的datetime类型的字符串值，例如：datetime.today().ctime()='Sun Jul 22 10:53:43 2018'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; ctime(self) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依据Python版本不同，返回isoformat格式的datetime类型的字符串值，例如：datetime.today().isoformat()='2018-07-22T10:55:11.618810'&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 6&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; isoformat(self, sep: str = ..., timespec: str = ...) -&amp;gt;&lt;span&gt; str: ...
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; isoformat(self, sep: str = ...) -&amp;gt;&lt;span&gt; str: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回指定date_string日期时间的format格式的datetime类型，例如：datetime.strptime(&quot;2017-10-13 16:00:00&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)=datetime.datetime(2017, 10, 13, 16, 0)&lt;/span&gt;&lt;span&gt;
@classmethod
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; strptime(cls, date_string: _Text, format: _Text) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回datetime对象的时区UTC偏差，一般情况下为空&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; utcoffset(self) -&amp;gt;&lt;span&gt; Optional[timedelta]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回datetime对象的具体时区名称，一般情况下为空&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; tzname(self) -&amp;gt;&lt;span&gt; Optional[str]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前datetime对象的DST偏差，一般情况下为空&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; dst(self) -&amp;gt;&lt;span&gt; Optional[int]: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，le表示 &amp;lt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__le__&lt;/span&gt;(self, other: datetime) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，lt表示 &amp;lt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__lt__&lt;/span&gt;(self, other: datetime) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，ge表示 &amp;gt;=&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__ge__&lt;/span&gt;(self, other: datetime) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 比较运算，gt表示 &amp;gt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__gt__&lt;/span&gt;(self, other: datetime) -&amp;gt;&lt;span&gt; bool: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加运算&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__add__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;减运算，参数类型为datetime，返回值类型为timedelta&lt;/span&gt;&lt;span&gt;
@overload
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;(self, other: datetime) -&amp;gt;&lt;span&gt; timedelta: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;减运算，参数类型为timedelta，返回值类型为datetime&lt;/span&gt;&lt;span&gt;
@overload
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__sub__&lt;/span&gt;(self, other: timedelta) -&amp;gt;&lt;span&gt; datetime: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可返回datetime类对象的哈希值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__hash__&lt;/span&gt;(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前datetime类对象的工作日（即为星期几），注意：Monday == 0 ... Sunday == 6.&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; weekday(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前datetime类对象的工作日（即为星期几），注意：Monday == 1 ... Sunday == 7.&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; isoweekday(self) -&amp;gt;&lt;span&gt; int: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回当前datetime类对象的年份、本年份的所在周数、星期几&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; isocalendar(self) -&amp;gt; Tuple[int, int, int]: ...
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h2&gt;&lt;strong&gt;2.7 &lt;span&gt;格式化字符串&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;datetime、date、time 都提供了 strftime() 方法，该方法接收一个格式字符串，输出日期时间的字符串表示。支持的转换格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;字符&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;　含义　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;　例子　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%a&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;英文星期的简写&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;Sun, Mon, …, Sat&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%A&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;英文星期的全拼&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;Sunday, Monday, …, Saturday&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%w&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;星期几,星期天为0,星期六为6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;0, 1, …, 6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%d&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;这个月的第几天,以0填充的10进制&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;01, 02, …, 31&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%b&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;月份英文简写&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;Jan, Feb, …, Dec&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%B&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;月份英文全拼&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;January, February, …, December&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%m&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;月份数，以0填充的10进制&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;01, 02, …, 12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%y&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;不带世纪的年份&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;00, 01, …, 99&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%Y&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;带有世纪的年份&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;1970, 1988, 2001, 2013&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%H&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;24小时制的小时数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;00, 01, …, 23&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%I&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;12小时制的小时数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;01, 02, …, 12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%p&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;AM或者PM&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;AM, PM&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%M&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;分钟&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;00, 01, …, 59&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%S&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;秒数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;00, 01, …, 59&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%f&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;微秒&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;000000, 000001, …, 999999&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%z&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;与utc时间的间隔&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;(), +0000, -0400, +1030&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%Z&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;时区&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;(), UTC, EST, CST&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%j&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;当年的第几天&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;001, 002, …, 366&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%U&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;当年的第几周(星期天作为周的第一天)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;00, 01, …, 53&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%W&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;当年的第几周(星期一作为周的第一天)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;00, 01, …, 53&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%c&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;日期时间的字符串表示&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;Tue Aug 16 21:30:00 1988&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%X&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;时间字符串表示&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;21:30:00&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%x&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;日期字符串表示&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;08/16/88&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;相当于转意等于一个%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;240&quot;&gt;
&lt;p&gt;&lt;span&gt;%&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;hr/&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;先说一下struct_time结构的返回参数：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;struct_time元组。这种结构具有如下属性：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_year&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;2008&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_mon&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;1 到 12&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_mday&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;1 到 31&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_hour&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;0 到 23&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_min&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;0 到 59&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_sec&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;0 到 61 (60或61 是闰秒)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_wday&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;0到6 (0是周一)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;7&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_yday&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;&lt;span&gt;1 到 366(儒略历)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;76&quot;&gt;
&lt;p&gt;&lt;span&gt;8&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;326&quot;&gt;
&lt;p&gt;&lt;span&gt;tm_isdst&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;-1, 0, 1, -1是决定是否为夏令时的旗帜&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;182&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Stubs for time&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ron Murawski &amp;lt;ron@horizonchess.com&amp;gt;&lt;/span&gt;

 

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; based on: http://docs.python.org/3.3/library/time.html#module-time&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; see: http://nullege.com/codes/search?cq=time&lt;/span&gt;

 

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Any, NamedTuple, Tuple, Union
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; types &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SimpleNamespace

TimeTuple &lt;/span&gt;= Tuple[int, int, int, int, int, int, int, int, int]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个时间元组返回类型，共9个返回值，其中每一个值均为int类型&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----- variables and constants -----&lt;/span&gt;
&lt;span&gt;
accept2dyear &lt;/span&gt;=&lt;span&gt; False

altzone &lt;/span&gt;=&lt;span&gt; 0

daylight &lt;/span&gt;=&lt;span&gt; 0

timezone &lt;/span&gt;=&lt;span&gt; 0

tzname &lt;/span&gt;= ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; type: Tuple[str, str]&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 3) &lt;span&gt;and&lt;/span&gt; sys.platform != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

    CLOCK_HIGHRES &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Solaris only&lt;/span&gt;
&lt;span&gt;
    CLOCK_MONOTONIC &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;
&lt;span&gt;
    CLOCK_MONOTONIC_RAW &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Linux 2.6.28 or later&lt;/span&gt;
&lt;span&gt;
    CLOCK_PROCESS_CPUTIME_ID &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;
&lt;span&gt;
    CLOCK_REALTIME &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;
&lt;span&gt;
    CLOCK_THREAD_CPUTIME_ID &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 3&lt;span&gt;):

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; struct_time(   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意这是struct_time类型的具体相关参数定义，通过参数名即可知道其具体含义&lt;/span&gt;
&lt;span&gt;
        NamedTuple(

            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_struct_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,

            [(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_mon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_mday&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int),

             (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_min&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_sec&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int),

             (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_wday&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_yday&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_isdst&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int),

             (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_zone&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, str), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_gmtoff&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int)]

        )

    ):

        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造函数&lt;/span&gt;
&lt;span&gt;
            self,

            o: Union[

                Tuple[int, int, int, int, int, int, int, int, int],

                Tuple[int, int, int, int, int, int, int, int, int, str],

                Tuple[int, int, int, int, int, int, int, int, int, str, int]

            ],

            _arg: Any &lt;/span&gt;=&lt;span&gt; ...,

        ) &lt;/span&gt;-&amp;gt;&lt;span&gt; None: ...

        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用构造函数之前，需要调用此函数&lt;/span&gt;
&lt;span&gt;
            cls,

            o: Union[

                Tuple[int, int, int, int, int, int, int, int, int],

                Tuple[int, int, int, int, int, int, int, int, int, str],

                Tuple[int, int, int, int, int, int, int, int, int, str, int]

            ],

            _arg: Any &lt;/span&gt;=&lt;span&gt; ...,

        ) &lt;/span&gt;-&amp;gt;&lt;span&gt; struct_time: ...

&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; struct_time(  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; struct_time类型具体定义&lt;/span&gt;
&lt;span&gt;
        NamedTuple(

            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_struct_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,

            [(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_mon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_mday&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int),

             (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_min&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_sec&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int),

             (&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_wday&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_yday&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, int), (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tm_isdst&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, int)]

        )

    ):

        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, o: TimeTuple, _arg: Any = ...) -&amp;gt;&lt;span&gt; None: ...

        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, o: TimeTuple, _arg: Any = ...) -&amp;gt;&lt;span&gt; struct_time: ...

 

 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----- functions -----&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回指定格式的系统当前时间，例如：time.asctime()='Sun Jul 22 12:59:50 2018'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; asctime(t: Union[TimeTuple, struct_time, None] = ...) -&amp;gt; str: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return current time&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  返回自进程开始或之后的CPU时间&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; clock() -&amp;gt;&lt;span&gt; float: ...


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 依据参数secs秒数，返回自1970开始后计算的日期，参数为空时返回当前日期时间&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; ctime(secs: Union[float, None] = ...) -&amp;gt; str: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return current time&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 和ctime()区别在于返回值的格式不同，返回值的格式为struct_time&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; gmtime(secs: Union[float, None] = ...) -&amp;gt; struct_time: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return current time&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 和gmtime()方法功能基本相同，但是gmtime()时转换为标准的UTC时间&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; localtime(secs: Union[float, None] = ...) -&amp;gt; struct_time: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return current time&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  将当地时间的时间元组转换为自纪元以来的秒数，也就是时间戳的值&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; mktime(t: Union[TimeTuple, struct_time]) -&amp;gt;&lt;span&gt; float: ...

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 延迟指定的secs秒数时间，就是让代码在此处休眠指定的秒数时间，然后再执行后续代码&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; sleep(secs: Union[int, float]) -&amp;gt;&lt;span&gt; None: ...


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回指定t的格式format的字符串类型时间，例如：time.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;, a) = '2018-07-22T05:13:58Z'&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; strftime(format: str,

             t: Union[TimeTuple, struct_time, None] &lt;/span&gt;= ...) -&amp;gt; str: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; return current time&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给定指定的str类型的字符串时间，返回struct_time类型时间对象，例如：time.strptime(&quot;2018-07-18T13:12:11&quot;,&quot;%Y-%m-%dT%H:%M:%S&quot;)= time.struct_time(tm_year=2018, tm_mon=7, tm_mday=18, tm_hour=13, tm_min=12, tm_sec=11, tm_wday=2, tm_yday=199, tm_isdst=-1)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; strptime(string: str,

             format: str &lt;/span&gt;= ...) -&amp;gt;&lt;span&gt; struct_time: ...

 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回系统当前的时间戳&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; time() -&amp;gt;&lt;span&gt; float: ...

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.platform != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  将本地时区初始化或重新初始化为存储的值os.environ[ 'TZ']，默认为空&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; tzset() -&amp;gt; None: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 3&lt;span&gt;):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; get_clock_info(name: str) -&amp;gt;&lt;span&gt; SimpleNamespace: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; monotonic() -&amp;gt;&lt;span&gt; float: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; perf_counter() -&amp;gt;&lt;span&gt; float: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; process_time() -&amp;gt;&lt;span&gt; float: ...

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sys.platform != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;win32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; clock_getres(clk_id: int) -&amp;gt; float: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;

        &lt;span&gt;def&lt;/span&gt; clock_gettime(clk_id: int) -&amp;gt; float: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;

        &lt;span&gt;def&lt;/span&gt; clock_settime(clk_id: int, time: float) -&amp;gt; None: ...  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Unix only&lt;/span&gt;

 

&lt;span&gt;if&lt;/span&gt; sys.version_info &amp;gt;= (3, 7&lt;span&gt;):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; clock_gettime_ns(clock_id: int) -&amp;gt;&lt;span&gt; int: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; clock_settime_ns(clock_id: int, time: int) -&amp;gt;&lt;span&gt; int: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; monotonic_ns() -&amp;gt;&lt;span&gt; int: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; perf_counter_ns() -&amp;gt;&lt;span&gt; int: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; process_time_ns() -&amp;gt;&lt;span&gt; int: ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; time_ns() -&amp;gt;&lt;span&gt; int: ...

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;hr/&gt;&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 06:34:00 +0000</pubDate>
<dc:creator>舞动的心</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuzhen1995/p/9350125.html</dc:identifier>
</item>
<item>
<title>听说尤雨溪在开发vue4.0？是谁煽动了前端圈的焦虑情绪 - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/9350065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/9350065.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201807/701424-20180722142343192-631255808.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;导火索因P图而起&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;今天前端圈里被一张P图搞得好热闹，最初只是QQ群里一个冒名尤雨溪的前端网友发了一句调侃的话，原话截图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201807/701424-20180722141733305-1248075388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看完觉得好搞笑，说尤雨溪在开发vue4.0，有谁学不动了，就给他发10块钱红包。本以为这就结束了，没想到后面还接着一句，超过3000人他就不写了，哈哈哈哈哈。我只想对这位冒名的前端网友说，老哥，你是真敢想啊，我走过最远的前端路，就是你给的套路啊。试想每人给你发10块钱，3000人就是3万的收入啊，你这动动嘴皮子就是别人一个月的工资收入啊！有才华的小伙子，为你赚钱的歪门想法点个赞！&lt;/p&gt;

&lt;p&gt;本以为这只是日常前端工作中的一个笑料，没想到此事经过不断地发酵，经过好多前端网友的创作，以及经过在各大前端技术交流群的传播，，“尤雨溪在开发vue4.0”这件事情变得越发像真的一样，尤其是下面这张尤小右微博的P图，传得神乎其神，具体截图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201807/701424-20180722141810942-581667076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;P这张图的前端网友更是在前面那张图的基础上推波助澜，说什么“学不动是你的事，老子就是要更新”，哈哈哈哈，成功地煽动了一把前端圈的一股焦虑情绪。都感觉是尤大大真发了微博一样，惹得好多小伙伴们纷纷停下手中的工作，赶紧上网打开微博围观下尤雨溪的微博动态，你这个机灵抖的，在下佩服！&lt;/p&gt;

&lt;p&gt;素来爱凑热闹的我特意去Vue官网给大家看了下，放心吧，童鞋们，最新稳定版本还是在2.5.16。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201807/701424-20180722141832280-911430349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没想到，此事惊动了本主，尤雨溪大大亲自在微博上做出了回应：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201807/701424-20180722141848107-699853083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;尤大大的回应也是相当逗趣，附上截图留了一句话：这个谁P的你站出来，我保证不打死你... &lt;/p&gt;

&lt;p&gt;故事到这应该算是告一段落了，毕竟本主都在微博上辟谣了嘛～&lt;/p&gt;

&lt;p&gt;但是，这事儿仔细琢磨琢磨，不免让人心生余悸。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;P图被广泛传播的真因&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;为什么这几张P图能在众多前端技术交流群（甭管是QQ群还是微信群）里蔓延传播，引起前端同行的热议和讨论，无外乎是其中的“学不动了”这个关键词戳中了很多前端同行或者刚入行的新人小白的内心。&lt;/p&gt;

&lt;p&gt;最近几年，前端圈工程化技术飞速发展，各种新出的框架和工具难免让人应接不暇。&lt;/p&gt;

&lt;p&gt;Vue、React、Angular现在貌似已经三分天下&lt;/p&gt;

&lt;p&gt;每天待就业的刚出炉的前端百万大军嗷嗷待哺&lt;/p&gt;

&lt;p&gt;有饿死胆小的撑死胆大的朋友开始呐喊淘宝首页我一天就能仿照完&lt;/p&gt;

&lt;p&gt;有刚培训出来，包装简历说自己三年工作经验，精通这个精通那个&lt;/p&gt;

&lt;p&gt;vue、react、angular等东西太多了我学哪个好&lt;/p&gt;

&lt;p&gt;不想学没动力啊呀我平常学习撑死也就晚上十点&lt;/p&gt;

&lt;p&gt;很多新人的关注点无时不刻不在1月8k、 2月12k、 3月15k等&lt;/p&gt;

&lt;p&gt;“这个工资是不是太低了” “哇好厉害1个月 20k”&lt;/p&gt;

&lt;p&gt;想学就学感觉前端挺简单的怎么就找不到工作...&lt;/p&gt;

&lt;p&gt;求实习机会只要能学到东西就行...&lt;/p&gt;

&lt;p&gt;类似这些话语，是不是感觉很耳熟。&lt;/p&gt;

&lt;p&gt;到现在为止，“学不动了”，“求求你们别学了，我跟不上了”，是多少前端从业者内心的真实写照，只因为这个行业薪资待遇好，即使知道自己可能不适合编程了，也不想离开。&lt;/p&gt;

&lt;p&gt;一方面在羡慕着别人跳槽后月薪20K、30K的高薪待遇，一方面又在感慨前端需要学的东西太多了，沉不下心来好好研究技术。&lt;/p&gt;

&lt;p&gt;还有的沉静在自己固有的技术栈里不肯出来，不愿意去接触新的技术。&lt;/p&gt;

&lt;p&gt;这恐怕是大多数前端从业者内心产生焦虑的原因吧。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;前端是否变得越来越难&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;可能有的人会说，前端这几年确实变得越来越难了。&lt;/p&gt;

&lt;p&gt;诚然，这是一个不得不考虑的因素。&lt;/p&gt;

&lt;p&gt;Node.js带来了前端的春天。然而也加重了前端的负担。&lt;/p&gt;

&lt;p&gt;之前写点jquery就成了，现在还的会node，自己写后端。&lt;/p&gt;

&lt;p&gt;写过后端的人多少都知道，代码写起来并不算很难，难的是负担，如何设计才能承载高并发大流量，如何应对这些情况，宕机了怎么办？&lt;/p&gt;

&lt;p&gt;原来前端不用关心的东西现在都得考虑，毕竟node和前端靠得近，人家问起来自己不会多尴尬。&lt;/p&gt;

&lt;p&gt;在我个人看来，很多写node的只知道堆package，对于Buffer，Event，Stream，Http并不是很了解。&lt;/p&gt;

&lt;p&gt;所以写node的前端童鞋们，你们的学习之路任重而道远。&lt;/p&gt;

&lt;p&gt;做一个独立的前端自然少不了和server打交道，关于nginx至少得会安装，然后写简单的配置文件，这样，就可以自己上一个网站了，用了node还得学学反向代理的 东西。&lt;/p&gt;

&lt;p&gt;然而到这里还不够，https走起，从几家服务商中选择自己喜欢的，口碑好的，然后搞定证书。&lt;/p&gt;

&lt;p&gt;跑了HTTPS依旧不满意，追新的我们怎么还用几十年前的 HTTP/1.1 ？ HTTP/2 走起，自己下载编译安装 Nginx ，然后调参数，改配置。&lt;/p&gt;

&lt;p&gt;这个阶段得学会 Linux系 编译， SSL/TLS 的知识，加密算法，HTTP。。。&lt;/p&gt;

&lt;p&gt;一个写前端的还得学这些 T_T&lt;/p&gt;

&lt;p&gt;还没完啊，HTTP懂了还有TCP/IP等着啃，Socket协议还得了解。&lt;/p&gt;

&lt;p&gt;还有如何组织构建页面，如何在大量页面中仍然能优秀地组织好文件结构，如何在面对需求变更的时候通过尽量少的修改代码来实现需求。如何减少错误的发生，和排错的代价。&lt;/p&gt;

&lt;p&gt;以上这些都是作为一个合格的前端工程师需要了解的内容。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;闰土有话说&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;虽然，现在的前端越来越难了，但是这不能成为我们止步不前，停止学习的借口。&lt;/p&gt;

&lt;p&gt;想想自己当初为什么从事编程——为什么选择前端开发。&lt;/p&gt;

&lt;p&gt;一个人如果忘了自己想做什么在做什么，和咸鱼又有什么区别呢。&lt;/p&gt;

&lt;p&gt;水涨船高，程序猿的第一个阶段——三年，会淘汰掉很多不合适编程不热爱编程的朋友。年轻人最大的财富就是时间，而最不能浪费的，就是你现在的美好时光。&lt;/p&gt;

&lt;p&gt;我从来没想过自己要成为初级前端，我只是像所有热爱编程的朋友们一样，我想快速成长，我想在前端领域拥有自己的一小块领地，并在此奋斗过程中，不再为衣食住行而而烦恼。&lt;/p&gt;

&lt;p&gt;还是那句老生常谈的话，&lt;strong&gt;不忘初心，方得始终。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;夜深人静的时候，想想你们入行前端的初心是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;更多文章我会第一时间更新在公众号&amp;lt;&lt;strong&gt;闰土大叔&lt;/strong&gt;&amp;gt;里面，欢迎关注~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201807/701424-20180722142141030-876906756.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 22 Jul 2018 06:25:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/9350065.html</dc:identifier>
</item>
<item>
<title>RabbitMQ事务和Confirm发送方消息确认——深入解读 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/9350075.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/9350075.html</guid>
<description>&lt;p&gt;RabbitMQ事务和Confirm发送方消息确认——深入解读&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;根据前面的知识（&lt;a href=&quot;https://www.cnblogs.com/vipstone/p/9275256.html&quot;&gt;深入了解RabbitMQ工作原理及简单使用&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/vipstone/p/9295625.html&quot;&gt;Rabbit的几种工作模式介绍与实践&lt;/a&gt;）我们知道，如果要保证消息的可靠性，需要对消息进行持久化处理，然而消息持久化除了需要代码的设置之外，还有一个重要步骤是至关重要的，那就是保证你的消息顺利进入Broker（代理服务器），如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/blog/rabbitmq-flow3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常情况下，如果消息经过交换器进入队列就可以完成消息的持久化，但如果消息在没有到达broker之前出现意外，那就造成消息丢失，有没有办法可以解决这个问题？&lt;/p&gt;
&lt;p&gt;RabbitMQ有两种方式来解决这个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过AMQP提供的事务机制实现；&lt;/li&gt;
&lt;li&gt;使用发送者确认模式实现；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一事务使用&quot;&gt;一、事务使用&lt;/h2&gt;
&lt;p&gt;事务的实现主要是对信道（Channel）的设置，主要的方法有三个：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;channel.txSelect()声明启动事务模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;channel.txComment()提交事务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;channel.txRollback()回滚事务；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面的可以看出事务都是以tx开头的，tx应该是transaction extend（事务扩展模块）的缩写，如果有准确的解释欢迎在博客下留言。&lt;/p&gt;
&lt;p&gt;我们来看具体的代码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 创建连接
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(config.UserName);
factory.setPassword(config.Password);
factory.setVirtualHost(config.VHost);
factory.setHost(config.Host);
factory.setPort(config.Port);   
Connection conn = factory.newConnection();
// 创建信道
Channel channel = conn.createChannel();
// 声明队列
channel.queueDeclare(_queueName, true, false, false, null);
String message = String.format(&quot;时间 =&amp;gt; %s&quot;, new Date().getTime());
try {
    channel.txSelect(); // 声明事务
    // 发送消息
    channel.basicPublish(&quot;&quot;, _queueName, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(&quot;UTF-8&quot;));
    channel.txCommit(); // 提交事务
} catch (Exception e) {
    channel.txRollback();
} finally {
    channel.close();
    conn.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：用户需把config.xx配置成自己Rabbit的信息。&lt;/p&gt;
&lt;p&gt;从上面的代码我们可以看出，在发送消息之前的代码和之前介绍的都是一样的，只是在发送消息之前，需要声明channel为事务模式，提交或者回滚事务即可。&lt;/p&gt;
&lt;p&gt;了解了事务的实现之后，那么事务究竟是怎么执行的，让我们来使用wireshark抓个包看看，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/blog/rabbitmq-trsaction-wr.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入ip.addr==rabbitip &amp;amp;&amp;amp; amqp查看客户端和rabbit之间的通讯，可以看到交互流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端发送给服务器Tx.Select(开启事务模式)&lt;/li&gt;
&lt;li&gt;服务器端返回Tx.Select-Ok（开启事务模式ok）&lt;/li&gt;
&lt;li&gt;推送消息&lt;/li&gt;
&lt;li&gt;客户端发送给事务提交Tx.Commit&lt;/li&gt;
&lt;li&gt;服务器端返回Tx.Commit-Ok&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上就完成了事务的交互流程，如果其中任意一个环节出现问题，就会抛出IoException移除，这样用户就可以拦截异常进行事务回滚，或决定要不要重复消息。&lt;/p&gt;
&lt;p&gt;那么，既然已经有事务了，没什么还要使用发送方确认模式呢，原因是因为事务的性能是非常差的。&lt;strong&gt;事务性能测试&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;事务模式，结果如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事务模式，发送1w条数据，执行花费时间：14197s&lt;/li&gt;
&lt;li&gt;事务模式，发送1w条数据，执行花费时间：13597s&lt;/li&gt;
&lt;li&gt;事务模式，发送1w条数据，执行花费时间：14216s&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;非事务模式，结果如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非事务模式，发送1w条数据，执行花费时间：101s&lt;/li&gt;
&lt;li&gt;非事务模式，发送1w条数据，执行花费时间：77s&lt;/li&gt;
&lt;li&gt;非事务模式，发送1w条数据，执行花费时间：106s&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面可以看出，非事务模式的性能是事务模式的性能高149倍，我的电脑测试是这样的结果，不同的电脑配置略有差异，但结论是一样的，事务模式的性能要差很多，那有没有既能保证消息的可靠性又能兼顾性能的解决方案呢？那就是接下来要讲的Confirm发送方确认模式。&lt;/p&gt;
&lt;h3 id=&quot;扩展知识&quot;&gt;扩展知识&lt;/h3&gt;
&lt;p&gt;我们知道，消费者可以使用消息自动或手动发送来确认消费消息，那如果我们在消费者模式中使用事务（当然如果使用了手动确认消息，完全用不到事务的），会发生什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消费者模式使用事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设消费者模式中使用了事务，并且在消息确认之后进行了事务回滚，那么RabbitMQ会产生什么样的变化？&lt;/p&gt;
&lt;p&gt;结果分为两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;autoAck=false手动应对的时候是支持事务的，也就是说即使你已经手动确认了消息已经收到了，但在确认消息会等事务的返回解决之后，在做决定是确认消息还是重新放回队列，如果你手动确认现在之后，又回滚了事务，那么已事务回滚为主，此条消息会重新放回队列；&lt;/li&gt;
&lt;li&gt;autoAck=true如果自定确认为true的情况是不支持事务的，也就是说你即使在收到消息之后在回滚事务也是于事无补的，队列已经把消息移除了；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二confirm发送方确认模式&quot;&gt;二、Confirm发送方确认模式&lt;/h2&gt;
&lt;p&gt;Confirm发送方确认模式使用和事务类似，也是通过设置Channel进行发送方确认的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Confirm的三种实现方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方式一：channel.waitForConfirms()普通发送方确认模式；&lt;/p&gt;
&lt;p&gt;方式二：channel.waitForConfirmsOrDie()批量确认模式；&lt;/p&gt;
&lt;p&gt;方式三：channel.addConfirmListener()异步监听发送方确认模式；&lt;/p&gt;
&lt;h3 id=&quot;方式一普通confirm模式&quot;&gt;方式一：普通Confirm模式&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 创建连接
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(config.UserName);
factory.setPassword(config.Password);
factory.setVirtualHost(config.VHost);
factory.setHost(config.Host);
factory.setPort(config.Port);
Connection conn = factory.newConnection();
// 创建信道
Channel channel = conn.createChannel();
// 声明队列
channel.queueDeclare(config.QueueName, false, false, false, null);
// 开启发送方确认模式
channel.confirmSelect();
String message = String.format(&quot;时间 =&amp;gt; %s&quot;, new Date().getTime());
channel.basicPublish(&quot;&quot;, config.QueueName, null, message.getBytes(&quot;UTF-8&quot;));
if (channel.waitForConfirms()) {
    System.out.println(&quot;消息发送成功&quot; );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看代码可以知道，我们只需要在推送消息之前，channel.confirmSelect()声明开启发送方确认模式，再使用channel.waitForConfirms()等待消息被服务器确认即可。&lt;/p&gt;
&lt;h3 id=&quot;方式二批量confirm模式&quot;&gt;方式二：批量Confirm模式&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 创建连接
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(config.UserName);
factory.setPassword(config.Password);
factory.setVirtualHost(config.VHost);
factory.setHost(config.Host);
factory.setPort(config.Port);
Connection conn = factory.newConnection();
// 创建信道
Channel channel = conn.createChannel();
// 声明队列
channel.queueDeclare(config.QueueName, false, false, false, null);
// 开启发送方确认模式
channel.confirmSelect();
for (int i = 0; i &amp;lt; 10; i++) {
    String message = String.format(&quot;时间 =&amp;gt; %s&quot;, new Date().getTime());
    channel.basicPublish(&quot;&quot;, config.QueueName, null, message.getBytes(&quot;UTF-8&quot;));
}
channel.waitForConfirmsOrDie(); //直到所有信息都发布，只要有一个未确认就会IOException
System.out.println(&quot;全部执行完成&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码可以看出来channel.waitForConfirmsOrDie()，使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未被确认就会抛出IOException异常。&lt;/p&gt;
&lt;h3 id=&quot;方式三异步confirm模式&quot;&gt;方式三：异步Confirm模式&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 创建连接
ConnectionFactory factory = new ConnectionFactory();
factory.setUsername(config.UserName);
factory.setPassword(config.Password);
factory.setVirtualHost(config.VHost);
factory.setHost(config.Host);
factory.setPort(config.Port);
Connection conn = factory.newConnection();
// 创建信道
Channel channel = conn.createChannel();
// 声明队列
channel.queueDeclare(config.QueueName, false, false, false, null);
// 开启发送方确认模式
channel.confirmSelect();
for (int i = 0; i &amp;lt; 10; i++) {
    String message = String.format(&quot;时间 =&amp;gt; %s&quot;, new Date().getTime());
    channel.basicPublish(&quot;&quot;, config.QueueName, null, message.getBytes(&quot;UTF-8&quot;));
}
//异步监听确认和未确认的消息
channel.addConfirmListener(new ConfirmListener() {
    @Override
    public void handleNack(long deliveryTag, boolean multiple) throws IOException {
        System.out.println(&quot;未确认消息，标识：&quot; + deliveryTag);
    }
    @Override
    public void handleAck(long deliveryTag, boolean multiple) throws IOException {
        System.out.println(String.format(&quot;已确认消息，标识：%d，多个消息：%b&quot;, deliveryTag, multiple));
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异步模式的优点，就是执行效率高，不需要等待消息执行完，只需要监听消息即可，以上异步返回的信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://icdn.apigo.cn/blog/rabbitmq-confirm-async-result.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，代码是异步执行的，消息确认有可能是批量确认的，是否批量确认在于返回的multiple的参数，此参数为bool值，如果true表示批量执行了deliveryTag这个值以前的所有消息，如果为false的话表示单条确认。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Confirm性能测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试前提：与事务一样，我们发送1w条消息。&lt;/p&gt;
&lt;p&gt;方式一：Confirm普通模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行花费时间：2253s&lt;/li&gt;
&lt;li&gt;执行花费时间：2018s&lt;/li&gt;
&lt;li&gt;执行花费时间：2043s&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方式二：Confirm批量模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行花费时间：1576s&lt;/li&gt;
&lt;li&gt;执行花费时间：1400s&lt;/li&gt;
&lt;li&gt;执行花费时间：1374s&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方式三：Confirm异步监听方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行花费时间：1498s&lt;/li&gt;
&lt;li&gt;执行花费时间：1368s&lt;/li&gt;
&lt;li&gt;执行花费时间：1363s&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;综合总体测试情况来看：Confirm批量确定和Confirm异步模式性能相差不大，Confirm模式要比事务快10倍左右。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 06:21:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/9350075.html</dc:identifier>
</item>
<item>
<title>Netty源码—一、server启动（1） - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/9349953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/9349953.html</guid>
<description>&lt;p&gt;Netty作为一个Java生态中的网络组件有着举足轻重的位置，各种开源中间件都使用Netty进行网络通信，比如Dubbo、RocketMQ。可以说Netty是对Java NIO的封装，比如ByteBuf、channel等的封装让网络编程更简单。&lt;/p&gt;
&lt;p&gt;在介绍Netty服务器启动之前需要简单了解两件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;reactor线程模型&lt;/li&gt;
&lt;li&gt;linux中的IO多路复用&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;reactor线程模型&quot;&gt;reactor线程模型&lt;/h2&gt;
&lt;p&gt;关于reactor线程模型请参考&lt;a href=&quot;http://ifeve.com/netty-reactor-4/&quot;&gt;这篇文章&lt;/a&gt;，通过不同的配置Netty可以实现对应的三种reactor线程模型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;reactor单线程模型&lt;/li&gt;
&lt;li&gt;reactor多线程模型&lt;/li&gt;
&lt;li&gt;reactor主从多线程模型&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; // reactor单线程模型，accept、connect、read、write都在一个线程中执行
EventLoopGroup group = new NioEventLoopGroup(1);
bootStrap.group(group);

// reactor多线程，accept在bossGroup中的一个线程执行，IO操作在workerGroup中的线程执行
EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
bootStrap.group(bossGroup , workerGroup);

// reactor主从多线程，用来accept连接的是在一个线程池中执行，这个时候需要bind多个port，因为Netty一个bind的port会启动一个线程来accept
EventLoopGroup bossGroup = new NioEventLoopGroup(2);
EventLoopGroup workerGroup = new NioEventLoopGroup();
bootStrap.group(bossGroup , workerGroup);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意：本文后面的介绍如无特别说明都是基于reactor多线程模型&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux中的io多路复用&quot;&gt;linux中的IO多路复用&lt;/h2&gt;
&lt;p&gt;linux中的网络编程模型也是在不断演变的，下面是依次演变的顺序（具体可参考《UNIX网络编程卷1：套接字联网API》第三版的第4、6章）&lt;/p&gt;
&lt;h4 id=&quot;accept&quot;&gt;accept&lt;/h4&gt;
&lt;p&gt;阻塞等待连接，接收到新的连接后新起线程来处理接收到的连接，然后在新的线程中阻塞等待新的数据到来&lt;/p&gt;
&lt;h4 id=&quot;select&quot;&gt;select&lt;/h4&gt;
&lt;p&gt;根据入参的不同有三种情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;永远等下去，直到监听的描述符有任意的IO事件才返回&lt;/li&gt;
&lt;li&gt;等待一段固定时间，如果时间到之前有IO事件则提前返回，否则等待超时后返回&lt;/li&gt;
&lt;li&gt;不等待，检查描述符后立即返回，称为轮询&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;select会返回就绪的文件描述符的个数，需要轮询所有socket，判断每个socket的状态来确定是否有事件、是什么事件&lt;/p&gt;
&lt;h4 id=&quot;poll&quot;&gt;poll&lt;/h4&gt;
&lt;p&gt;相比较于selectpoll是阻塞等待的，只有有读写事件的时候才会返回，返回的是有读写事件的socket个数，并且将对应的socket的事件置位，自己从所有socket中找到具体的socket&lt;/p&gt;
&lt;h4 id=&quot;epoll&quot;&gt;epoll&lt;/h4&gt;
&lt;p&gt;相比较于poll，epoll可以将只有确实有IO事件的描述符返回，大并发下只有少量活跃连接的情况下使用&lt;/p&gt;
&lt;p&gt;较poll的优势&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不用开发者重新准备文件描述符集合（较poll入参简单）&lt;/li&gt;
&lt;li&gt;无需遍历所有监听的描述符，只要遍历哪些被内核IO事件异步唤醒而加入ready队列的描述符集合&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Java NIO在linux的实现就是基于epoll的。epoll的编程模型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建socket，socket方法&lt;/li&gt;
&lt;li&gt;绑定服务器ip，port，bind方法&lt;/li&gt;
&lt;li&gt;监听绑定了ip:port的文件描述符，listen方法&lt;/li&gt;
&lt;li&gt;创建epoll句柄（文件描述符），配置最大监听的文件描述符个数，epoll_create方法&lt;/li&gt;
&lt;li&gt;配置epoll监听的文件描述符的事件：注册、修改、删除某个文件描述符对应的事件&lt;/li&gt;
&lt;li&gt;监听所有已配置的描述符，epoll_wait&lt;/li&gt;
&lt;li&gt;有新的事件的时候遍历返回的描述符，处理对应的事件&lt;/li&gt;
&lt;li&gt;如果是来自客户端的连接，则将accept到的文件描述符注册到epoll中&lt;/li&gt;
&lt;li&gt;如果是读写事件则分别处理&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;注意：Netty封装的Java NIO是跨平台的，后面还是以linux平台为例来介绍&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来言归正传，来看看Netty的服务器启动过程做了什么事情。Netty作为一个网络框架，和普通网络编程做的事情基本上一样，对应于上面epoll的编程模型，Netty的启动过程为&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化线程池，初始化selector&lt;/li&gt;
&lt;li&gt;初始化NioServerSocketChannel&lt;/li&gt;
&lt;li&gt;绑定服务器ip:port&lt;/li&gt;
&lt;li&gt;将NioServerSocketChannel注册到selector中&lt;/li&gt;
&lt;li&gt;配置NioServerSocketChannel监听的事件&lt;/li&gt;
&lt;li&gt;使用selector.select等待新的IO事件&lt;/li&gt;
&lt;li&gt;如果是来自客户端的连接则将NioSocketChannel注册到selector上（如果是新的线程则是新的selector）&lt;/li&gt;
&lt;li&gt;如果是普通IO事件则在worker线程中处理&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线程池初始化&quot;&gt;线程池初始化&lt;/h2&gt;
&lt;p&gt;在介绍NioEventLoopGroup之前先看下NioEventLoop&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201807/846961-20180722135300112-611504294.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到NioEventLoop继承自SingleThreadEventExecutor，是一个单线程的executor，在线程中死循环监听IO事件。主要方法有&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 初始化selector
io.netty.channel.nio.NioEventLoop#openSelector
// 将channel注册到selector
io.netty.channel.nio.NioEventLoop#register
// 监听selector上的事件
io.netty.channel.nio.NioEventLoop#select&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个NioEventLoop会初始化一个selector，处理selector上注册的channel。&lt;/p&gt;
&lt;p&gt;NioEventLoopGroup从名字上就可以看出来是由多个NioEventLoop组成，类关系图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201807/846961-20180722135218807-948217687.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NioEventLoopGroup的重要属性为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 包含的EventExecutor数组
private final EventExecutor[] children;
// 选择哪一个EventExecutor执行task的选择器，不同的选择器有不同的策略
private final EventExecutorChooserFactory.EventExecutorChooser chooser;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重要方法有：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 选择下一个执行任务的线程
io.netty.util.concurrent.MultithreadEventExecutorGroup#next
// 创建EventLoop
io.netty.channel.nio.NioEventLoopGroup#newChild
// 在线程池中执行注册channel的任务
io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)
// 创建默认的threadFactory
io.netty.channel.MultithreadEventLoopGroup#newDefaultThreadFactory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程池初始化的代码为&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;EventLoopGroup workerGroup = new NioEventLoopGroup();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用无参的构造方法的话，最后会执行下面这个构造方法，这里面做要做了以下几件事&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果executor没有初始化，使用默认的executor初始化&lt;/li&gt;
&lt;li&gt;初始化线程池中每个EventLoop&lt;/li&gt;
&lt;li&gt;如果其中一个初始化过程中抛出异常，关闭所有的NioEventLoop&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected MultithreadEventExecutorGroup(int nThreads, Executor executor,
                                        EventExecutorChooserFactory chooserFactory, Object... args) {
    if (nThreads &amp;lt;= 0) {
        throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &amp;gt; 0)&quot;, nThreads));
    }

    if (executor == null) {
        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
    }

    children = new EventExecutor[nThreads];

    for (int i = 0; i &amp;lt; nThreads; i ++) {
        boolean success = false;
        try {
            // 创建EventLoop
            children[i] = newChild(executor, args);
            success = true;
        } catch (Exception e) {
            // TODO: Think about if this is a good exception type
            throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);
        } finally {
            if (!success) {
                for (int j = 0; j &amp;lt; i; j ++) {
                    children[j].shutdownGracefully();
                }

                for (int j = 0; j &amp;lt; i; j ++) {
                    EventExecutor e = children[j];
                    try {
                        while (!e.isTerminated()) {
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        }
                    } catch (InterruptedException interrupted) {
                        // Let the caller handle the interruption.
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }
        }
    }

    // 初始化chooser，决定选择下一个线程的策略
    chooser = chooserFactory.newChooser(children);

    final FutureListener&amp;lt;Object&amp;gt; terminationListener = new FutureListener&amp;lt;Object&amp;gt;() {
        @Override
        public void operationComplete(Future&amp;lt;Object&amp;gt; future) throws Exception {
            if (terminatedChildren.incrementAndGet() == children.length) {
                terminationFuture.setSuccess(null);
            }
        }
    };

    for (EventExecutor e: children) {
        e.terminationFuture().addListener(terminationListener);
    }

    Set&amp;lt;EventExecutor&amp;gt; childrenSet = new LinkedHashSet&amp;lt;EventExecutor&amp;gt;(children.length);
    Collections.addAll(childrenSet, children);
    readonlyChildren = Collections.unmodifiableSet(childrenSet);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用默认参数构造参数的话，上面这个构造方法的入参的值分别是&lt;/p&gt;
&lt;h3 id=&quot;nthreads&quot;&gt;nThreads&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 默认的线程池大小
private static final int DEFAULT_EVENT_LOOP_THREADS;

static {
    // 如果配置了io.netty.eventLoopThreads参数的话，先取该参数的值
    // 如果没有配置上面的参数，则取机器处理器个数的2倍
    // 如果上面算出的结果小于1则取1
    DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
        &quot;io.netty.eventLoopThreads&quot;, Runtime.getRuntime().availableProcessors() * 2));

    if (logger.isDebugEnabled()) {
        logger.debug(&quot;-Dio.netty.eventLoopThreads: {}&quot;, DEFAULT_EVENT_LOOP_THREADS);
    }
}

// 默认没有指定线程池大小，取DEFAULT_EVENT_LOOP_THREADS
protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;executor&quot;&gt;executor&lt;/h3&gt;
&lt;p&gt;默认没有指定executor，为null&lt;/p&gt;
&lt;h3 id=&quot;chooserfactory&quot;&gt;chooserFactory&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
    this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);
}
// io.netty.util.concurrent.DefaultEventExecutorChooserFactory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用默认的chooser，该类的主要功能是提供选择下一个线程的策略&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class DefaultEventExecutorChooserFactory implements EventExecutorChooserFactory {
    // 单例
    public static final DefaultEventExecutorChooserFactory INSTANCE = new DefaultEventExecutorChooserFactory();

    private DefaultEventExecutorChooserFactory() { }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public EventExecutorChooser newChooser(EventExecutor[] executors) {
        if (isPowerOfTwo(executors.length)) {
            // 如果是2的幂次则使用这个chooser
            return new PowerOfTowEventExecutorChooser(executors);
        } else {
            return new GenericEventExecutorChooser(executors);
        }
    }

    private static boolean isPowerOfTwo(int val) {
        // 判断一个数是否2的幂，方法很巧妙
        return (val &amp;amp; -val) == val;
    }

    private static final class PowerOfTowEventExecutorChooser implements EventExecutorChooser {
        private final AtomicInteger idx = new AtomicInteger();
        private final EventExecutor[] executors;

        PowerOfTowEventExecutorChooser(EventExecutor[] executors) {
            this.executors = executors;
        }

        @Override
        public EventExecutor next() {
            // 如果是2的幂次个线程，可以使用位运算计算出下一个选出的线程的index
            return executors[idx.getAndIncrement() &amp;amp; executors.length - 1];
        }
    }

    private static final class GenericEventExecutorChooser implements EventExecutorChooser {
        private final AtomicInteger idx = new AtomicInteger();
        private final EventExecutor[] executors;

        GenericEventExecutorChooser(EventExecutor[] executors) {
            this.executors = executors;
        }

        @Override
        public EventExecutor next() {
            // 使用求余的方法计算出下一个线程的index
            return executors[Math.abs(idx.getAndIncrement() % executors.length)];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出上面两个chooser计算出的最终结果是一致的，但是使用位运算更快一点，所以如果是线程池的大小刚好是2的幂次的话使用位运算的chooser。&lt;/p&gt;
&lt;h3 id=&quot;args&quot;&gt;args&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// args[0]，下面方法返回的provider，在linux平台上默认是EPollSelectorProvider
java.nio.channels.spi.SelectorProvider#provider
// args[1]，决定eventLoop每次执行select还是执行队列中的任务
io.netty.channel.DefaultSelectStrategyFactory
// args[2]，等待队列满以后的拒绝策略
io.netty.util.concurrent.RejectedExecutionHandlers#REJECT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化NioEventLoopGroup过程主要是为了初始化线程池中每一个NioEventLoop，而每一个NioEventLoop包含一个selector。&lt;/p&gt;
&lt;h2 id=&quot;初始化selector&quot;&gt;初始化selector&lt;/h2&gt;
&lt;p&gt;接着上面说到的初始化NioEventLoop，调用newChild方法来初始化&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.channel.nio.NioEventLoopGroup#newChild
protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    // 下面这几个参数上面已经介绍过
    return new NioEventLoop(this, executor, (SelectorProvider) args[0],
                            ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);
}

NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) {
    // 调用父类构造方法初始化taskQueue，taskQueue的大小取Math.max(16, maxPendingTasks)
    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);
    // 校验selectorProvider
    if (selectorProvider == null) {
        throw new NullPointerException(&quot;selectorProvider&quot;);
    }
    // 校验EventLoop每次执行的select策略是否为空
    if (strategy == null) {
        throw new NullPointerException(&quot;selectStrategy&quot;);
    }
    provider = selectorProvider;
    // 初始化selector
    selector = openSelector();
    selectStrategy = strategy;
}


private Selector openSelector() {
    final Selector selector;
    try {
        // 调用的是sun.nio.ch.EPollSelectorProvider#openSelector
        // 返回的是sun.nio.ch.EPollSelectorImpl
        selector = provider.openSelector();
    } catch (IOException e) {
        throw new ChannelException(&quot;failed to open a new selector&quot;, e);
    }

    // 是否使用SelectedSelectionKeySet优化，默认不禁用false
    if (DISABLE_KEYSET_OPTIMIZATION) {
        return selector;
    }

    // Netty优化过后的
    final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();

    // 尝试获取SelectorImpl对象，后续会使用反射操作这个类的属性
    Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
        @Override
        public Object run() {
            try {
                return Class.forName(
                    &quot;sun.nio.ch.SelectorImpl&quot;,
                    false,
                    PlatformDependent.getSystemClassLoader());
            } catch (ClassNotFoundException e) {
                return e;
            } catch (SecurityException e) {
                return e;
            }
        }
    });

    // 确保有权限访问该类
    if (!(maybeSelectorImplClass instanceof Class) ||
        // ensure the current selector implementation is what we can instrument.
        !((Class&amp;lt;?&amp;gt;) maybeSelectorImplClass).isAssignableFrom(selector.getClass())) {
        if (maybeSelectorImplClass instanceof Exception) {
            Exception e = (Exception) maybeSelectorImplClass;
            logger.trace(&quot;failed to instrument a special java.util.Set into: {}&quot;, selector, e);
        }
        return selector;
    }

    final Class&amp;lt;?&amp;gt; selectorImplClass = (Class&amp;lt;?&amp;gt;) maybeSelectorImplClass;

    Object maybeException = AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
        @Override
        public Object run() {
            try {
                // 得到字段selectedKeys
                Field selectedKeysField = selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);
                // 得到字段publicSelectedKeys
                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);

                selectedKeysField.setAccessible(true);
                publicSelectedKeysField.setAccessible(true);

                // 将selectedKeys、publicSelectedKeys均设置为Netty自定义的SelectedSelectionKeySet
                selectedKeysField.set(selector, selectedKeySet);
                publicSelectedKeysField.set(selector, selectedKeySet);
                return null;
            } catch (NoSuchFieldException e) {
                return e;
            } catch (IllegalAccessException e) {
                return e;
            } catch (RuntimeException e) {
                // JDK 9 can throw an inaccessible object exception here; since Netty compiles
                // against JDK 7 and this exception was only added in JDK 9, we have to weakly
                // check the type
                if (&quot;java.lang.reflect.InaccessibleObjectException&quot;.equals(e.getClass().getName())) {
                    return e;
                } else {
                    throw e;
                }
            }
        }
    });

    if (maybeException instanceof Exception) {
        selectedKeys = null;
        Exception e = (Exception) maybeException;
        logger.trace(&quot;failed to instrument a special java.util.Set into: {}&quot;, selector, e);
    } else {
        selectedKeys = selectedKeySet;
        logger.trace(&quot;instrumented a special java.util.Set into: {}&quot;, selector);
    }

    return selector;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化selector的过程中主要做了几件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用平台相关的provider初始化对应的SelectorImpl，这里使用了Java的SPI来加载平台相关的provider，每一种provider又对应一种SelectorImpl&lt;/li&gt;
&lt;li&gt;如果没有禁用selectedKey优化，Netty会使用自定的SelectedSelectionKeySet替换SelectorImpl的publicSelectedKeys、selectedKeys&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对SelectorImpl.selectedKey优化的说明&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;利用反射将SelectorImpl.selectedKey替换成了SelectedSelectionKeySet，SelectedSelectionKeySet利用数组实现元素存放&lt;/li&gt;
&lt;li&gt;在调用select方法的时候如果有事件进来的时候会调用SelectedSelectionKeySet#add，将有IO事件的selectKey添加到keyset中&lt;/li&gt;
&lt;li&gt;使用数组遍历（processSelectedKeysOptimized）要比使用set遍历快一些，参考文后第一篇参考文章&lt;/li&gt;
&lt;li&gt;在Java9以后这个优化就失效了，因为Java9引入了Jigsaw&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来看看Selector创建过程，上面调用了EPollSelectorProvider#openSelector来开始初始化selector&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public AbstractSelector openSelector() throws IOException {
    // 直接new 一个EPollSelectorImpl
    return new EPollSelectorImpl(this);
}

// 该构造方法只能是包内使用，供provider来调用
EPollSelectorImpl(SelectorProvider sp) throws IOException {
    // 调用父类SelectorImpl的构造方法初始化selectedKeys、publicKeys、publicSelectedKeys
    // 上面已经说过了，如果使用Netty的优化，publicKeys、publicSelectedKey会被替换
    super(sp);
    // 调用linux的pipe方法，创建一个管道，配置为非阻塞的
    long pipeFds = IOUtil.makePipe(false);
    // 高32为读文件描述符
    fd0 = (int) (pipeFds &amp;gt;&amp;gt;&amp;gt; 32);
    // 低32位为写文件描述符
    fd1 = (int) pipeFds;
    // EPollArrayWrapper包含一系列native方法来调用EPollArrayWrapper.c本地方法
    pollWrapper = new EPollArrayWrapper();
    pollWrapper.initInterrupt(fd0, fd1);
    // fdToKey用来保存文件描述符和SelectionKeyImpl的映射
    fdToKey = new HashMap&amp;lt;&amp;gt;();
}

EPollArrayWrapper() throws IOException {
    // creates the epoll file descriptor
    // 创建epoll的文件描述符
    epfd = epollCreate();

    // the epoll_event array passed to epoll_wait
    int allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT;
    pollArray = new AllocatedNativeObject(allocationSize, true);
    pollArrayAddress = pollArray.address();

    // eventHigh needed when using file descriptors &amp;gt; 64k
    if (OPEN_MAX &amp;gt; MAX_UPDATE_ARRAY_SIZE)
        eventsHigh = new HashMap&amp;lt;&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终于看到创建epoll文件描述符相关代码了，上面这个还是看不到究竟调用了哪些本地方法，我们看看相关的c代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// jdk/src/solaris/native/sun/nio/ch/IOUtil.c
JNIEXPORT jlong JNICALL
Java_sun_nio_ch_IOUtil_makePipe(JNIEnv *env, jobject this, jboolean blocking)
{
    int fd[2];

    // 打开pipe
    if (pipe(fd) &amp;lt; 0) {
        JNU_ThrowIOExceptionWithLastError(env, &quot;Pipe failed&quot;);
        return 0;
    }
    if (blocking == JNI_FALSE) {
        // 配置管道为非阻塞
        if ((configureBlocking(fd[0], JNI_FALSE) &amp;lt; 0)
            || (configureBlocking(fd[1], JNI_FALSE) &amp;lt; 0)) {
            JNU_ThrowIOExceptionWithLastError(env, &quot;Configure blocking failed&quot;);
            close(fd[0]);
            close(fd[1]);
            return 0;
        }
    }
    // 将读写文件描述符放入一个long型中返回
    return ((jlong) fd[0] &amp;lt;&amp;lt; 32) | (jlong) fd[1];
}

// jdk/src/solaris/native/sun/nio/ch/EPollArrayWrapper.c
JNIEXPORT jint JNICALL
Java_sun_nio_ch_EPollArrayWrapper_epollCreate(JNIEnv *env, jobject this)
{
    /*
     * epoll_create expects a size as a hint to the kernel about how to
     * dimension internal structures. We can't predict the size in advance.
     */
    // 这里调用linux函数epoll_create创建epoll的文件描述符
    int epfd = epoll_create(256);
    if (epfd &amp;lt; 0) {
        JNU_ThrowIOExceptionWithLastError(env, &quot;epoll_create failed&quot;);
    }
    return epfd;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;经过上面说明，现在对于Netty启动过程中线程池的初始化过程和selector初始化过程已经比较清晰了，对于native方法的分析让我们对比linux中epoll编程，对于原理更加清楚。&lt;/p&gt;
&lt;p&gt;接下来就是将需要监听的描述符注册到epoll上，对应到Netty就是讲channel注册到selector上，下一篇文章继续写Netty源码—二、server启动（2）&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wyj.shiwuliang.com/2018/05/28/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94Reactor%E7%9A%84processSelectedKeys/&quot;&gt;Netty源码分析——Reactor的processSelectedKeys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/netty/netty/issues/6105&quot;&gt;关于SelectedSelectionKeySet优化的讨论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/netty/netty/issues/2363&lt;/p&gt;
&lt;p&gt;https://github.com/netty/netty/commit/cd579f75d2b5f236f35bc47f454cc07e50ae8037&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 05:53:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/9349953.html</dc:identifier>
</item>
<item>
<title>RHEL7 配置iSCSI模拟环境 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9349846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9349846.html</guid>
<description>&lt;p&gt;在之前文章《&lt;a href=&quot;https://www.cnblogs.com/jyzhao/p/7200585.html&quot;&gt;multipath多路径实验01-构建iSCSI模拟环境&lt;/a&gt;》中，已经介绍了如何构建iSCSI模拟环境（RHEL6），但在RHEL7中已经不适用，本文记录下新的配置方法。&lt;br/&gt;&lt;strong&gt;环境：&lt;/strong&gt;RHEL 7.3&lt;/p&gt;

&lt;p&gt;在RHEL7.3中，对于lvm操作部分与之前RHEL6版本没有区别,还是创建pv，vg，lv的方法，命令参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pvcreate /dev/sdb
vgcreate vg_storage /dev/sdb
lvcreate -L 1g -n lv_lun1 vg_storage
lvcreate -L 1g -n lv_lun2 vg_storage
lvcreate -L 1g -n lv_lun3 vg_storage
lvcreate -L 40g -n lv_lun4 vg_storage
lvcreate -L 10g -n lv_lun5 vg_storage
lvcreate -L 10g -n lv_lun6 vg_storage
lvcreate -L 10g -n lv_lun7 vg_storage
lvcreate -L 16g -n lv_lun8 vg_storage&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终可以看到新建的lv信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@Storage-B yum.repos.d]# lvs
  LV      VG         Attr       LSize  Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  home    rhel       -wi-ao---- 23.33g                                                    
  root    rhel       -wi-ao---- 47.79g                                                    
  swap    rhel       -wi-ao----  7.88g                                                    
  lv_lun1 vg_storage -wi-a-----  1.00g                                                    
  lv_lun2 vg_storage -wi-a-----  1.00g                                                    
  lv_lun3 vg_storage -wi-a-----  1.00g                                                    
  lv_lun4 vg_storage -wi-a----- 40.00g                                                    
  lv_lun5 vg_storage -wi-a----- 10.00g                                                    
  lv_lun6 vg_storage -wi-a----- 10.00g                                                    
  lv_lun7 vg_storage -wi-a----- 10.00g                                                    
  lv_lun8 vg_storage -wi-a----- 16.00g  &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;之前在RHEL6中安装的iscsi服务端rpm包的名字是：scsi-target-utils，这在RHEL7中变成了targetd、targetcli这两个包。&lt;br/&gt;&lt;strong&gt;2.1 使用yum安装targetd和targetcli&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install targetd targetcli
systemctl status targetd
systemctl start targetd
systemctl enable targetd
systemctl list-unit-files|grep targetd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时确认targetd服务启动状态和开启启动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 使用targetcli创建设备&lt;/strong&gt;&lt;br/&gt;targetcli进入命令行，cd到/backstores/block 目录下，创建设备：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create disk1 /dev/mapper/vg_storage-lv_lun1
create disk2 /dev/mapper/vg_storage-lv_lun2
create disk3 /dev/mapper/vg_storage-lv_lun3
create disk4 /dev/mapper/vg_storage-lv_lun4
create disk5 /dev/mapper/vg_storage-lv_lun5
create disk6 /dev/mapper/vg_storage-lv_lun6
create disk7 /dev/mapper/vg_storage-lv_lun7
create disk8 /dev/mapper/vg_storage-lv_lun8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成，可以成功看到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/backstores/block&amp;gt; ls
o- block ...................................................................................................... [Storage Objects: 8]
  o- disk1 ........................................................ [/dev/mapper/vg_storage-lv_lun1 (1.0GiB) write-thru deactivated]
  o- disk2 ........................................................ [/dev/mapper/vg_storage-lv_lun2 (1.0GiB) write-thru deactivated]
  o- disk3 ........................................................ [/dev/mapper/vg_storage-lv_lun3 (1.0GiB) write-thru deactivated]
  o- disk4 ....................................................... [/dev/mapper/vg_storage-lv_lun4 (40.0GiB) write-thru deactivated]
  o- disk5 ....................................................... [/dev/mapper/vg_storage-lv_lun5 (10.0GiB) write-thru deactivated]
  o- disk6 ....................................................... [/dev/mapper/vg_storage-lv_lun6 (10.0GiB) write-thru deactivated]
  o- disk7 ....................................................... [/dev/mapper/vg_storage-lv_lun7 (10.0GiB) write-thru deactivated]
  o- disk8 ....................................................... [/dev/mapper/vg_storage-lv_lun8 (16.0GiB) write-thru deactivated]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.3 使用targetcli创建iqn和LUN&lt;/strong&gt;&lt;br/&gt;然后cd到/iscsi目录下，创建iqn；cd到/iscsi/iqn.20...0be/tpg1/luns下创建LUN，参考命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /iscsi
create
cd /iscsi/iqn.20...0be/tpg1/luns
create /backstores/block/disk1
create /backstores/block/disk2
create /backstores/block/disk3
create /backstores/block/disk4
create /backstores/block/disk5
create /backstores/block/disk6
create /backstores/block/disk7
create /backstores/block/disk8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际执行过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/backstores/block&amp;gt; cd /iscsi
/iscsi&amp;gt; ls
o- iscsi .............................................................................................................. [Targets: 0]
/iscsi&amp;gt; create
Created target iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be.
Created TPG 1.
Global pref auto_add_default_portal=true
Created default portal listening on all IPs (0.0.0.0), port 3260.
/iscsi&amp;gt; ls
o- iscsi .............................................................................................................. [Targets: 1]
  o- iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be ......................................................... [TPGs: 1]
    o- tpg1 ................................................................................................. [no-gen-acls, no-auth]
      o- acls ............................................................................................................ [ACLs: 0]
      o- luns ............................................................................................................ [LUNs: 0]
      o- portals ...................................................................................................... [Portals: 1]
        o- 0.0.0.0:3260 ....................................................................................................... [OK]

/iscsi/iqn.20...0be/tpg1/luns&amp;gt; ls 
o- luns .................................................................................................................. [LUNs: 8]
  o- lun0 ........................................................................... [block/disk1 (/dev/mapper/vg_storage-lv_lun1)]
  o- lun1 ........................................................................... [block/disk2 (/dev/mapper/vg_storage-lv_lun2)]
  o- lun2 ........................................................................... [block/disk3 (/dev/mapper/vg_storage-lv_lun3)]
  o- lun3 ........................................................................... [block/disk4 (/dev/mapper/vg_storage-lv_lun4)]
  o- lun4 ........................................................................... [block/disk5 (/dev/mapper/vg_storage-lv_lun5)]
  o- lun5 ........................................................................... [block/disk6 (/dev/mapper/vg_storage-lv_lun6)]
  o- lun6 ........................................................................... [block/disk7 (/dev/mapper/vg_storage-lv_lun7)]
  o- lun7 ........................................................................... [block/disk8 (/dev/mapper/vg_storage-lv_lun8)]
/iscsi/iqn.20...0be/tpg1/luns&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.4 使用targetcli创建acls&lt;/strong&gt;&lt;br/&gt;cd到acls目录下，创建client；然后cd到portals目录下创建portals, 参考命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /iscsi/iqn.20...0be/tpg1/acls
create iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be:client

cd /iscsi/iqn.20...0be/tpg1/portals
delete 0.0.0.0 3260
create 10.10.1.21
create 10.10.2.21&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际执行过程如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/iscsi/iqn.20.../tpg1/portals&amp;gt; pwd
/iscsi/iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be/tpg1/portals
/iscsi/iqn.20.../tpg1/portals&amp;gt; ls
o- portals ............................................................................................................ [Portals: 2]
  o- 10.10.1.21:3260 .......................................................................................................... [OK]
  o- 10.10.2.21:3260 .......................................................................................................... [OK]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.5 使用targetcli查看当前配置信息&lt;/strong&gt;&lt;br/&gt;在/下执行ls，或者ls /查看当前配置信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/iscsi/iqn.20.../tpg1/portals&amp;gt; ls /
o- / ......................................................................................................................... [...]
  o- backstores .............................................................................................................. [...]
  | o- block .................................................................................................. [Storage Objects: 8]
  | | o- disk1 ...................................................... [/dev/mapper/vg_storage-lv_lun1 (1.0GiB) write-thru activated]
  | | o- disk2 ...................................................... [/dev/mapper/vg_storage-lv_lun2 (1.0GiB) write-thru activated]
  | | o- disk3 ...................................................... [/dev/mapper/vg_storage-lv_lun3 (1.0GiB) write-thru activated]
  | | o- disk4 ..................................................... [/dev/mapper/vg_storage-lv_lun4 (40.0GiB) write-thru activated]
  | | o- disk5 ..................................................... [/dev/mapper/vg_storage-lv_lun5 (10.0GiB) write-thru activated]
  | | o- disk6 ..................................................... [/dev/mapper/vg_storage-lv_lun6 (10.0GiB) write-thru activated]
  | | o- disk7 ..................................................... [/dev/mapper/vg_storage-lv_lun7 (10.0GiB) write-thru activated]
  | | o- disk8 ..................................................... [/dev/mapper/vg_storage-lv_lun8 (16.0GiB) write-thru activated]
  | o- fileio ................................................................................................. [Storage Objects: 0]
  | o- pscsi .................................................................................................. [Storage Objects: 0]
  | o- ramdisk ................................................................................................ [Storage Objects: 0]
  o- iscsi ............................................................................................................ [Targets: 1]
  | o- iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be ....................................................... [TPGs: 1]
  |   o- tpg1 ............................................................................................... [no-gen-acls, no-auth]
  |     o- acls .......................................................................................................... [ACLs: 1]
  |     | o- iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be:client ................................... [Mapped LUNs: 8]
  |     |   o- mapped_lun0 ................................................................................. [lun0 block/disk1 (rw)]
  |     |   o- mapped_lun1 ................................................................................. [lun1 block/disk2 (rw)]
  |     |   o- mapped_lun2 ................................................................................. [lun2 block/disk3 (rw)]
  |     |   o- mapped_lun3 ................................................................................. [lun3 block/disk4 (rw)]
  |     |   o- mapped_lun4 ................................................................................. [lun4 block/disk5 (rw)]
  |     |   o- mapped_lun5 ................................................................................. [lun5 block/disk6 (rw)]
  |     |   o- mapped_lun6 ................................................................................. [lun6 block/disk7 (rw)]
  |     |   o- mapped_lun7 ................................................................................. [lun7 block/disk8 (rw)]
  |     o- luns .......................................................................................................... [LUNs: 8]
  |     | o- lun0 ................................................................... [block/disk1 (/dev/mapper/vg_storage-lv_lun1)]
  |     | o- lun1 ................................................................... [block/disk2 (/dev/mapper/vg_storage-lv_lun2)]
  |     | o- lun2 ................................................................... [block/disk3 (/dev/mapper/vg_storage-lv_lun3)]
  |     | o- lun3 ................................................................... [block/disk4 (/dev/mapper/vg_storage-lv_lun4)]
  |     | o- lun4 ................................................................... [block/disk5 (/dev/mapper/vg_storage-lv_lun5)]
  |     | o- lun5 ................................................................... [block/disk6 (/dev/mapper/vg_storage-lv_lun6)]
  |     | o- lun6 ................................................................... [block/disk7 (/dev/mapper/vg_storage-lv_lun7)]
  |     | o- lun7 ................................................................... [block/disk8 (/dev/mapper/vg_storage-lv_lun8)]
  |     o- portals .................................................................................................... [Portals: 2]
  |       o- 10.10.1.21:3260 .................................................................................................. [OK]
  |       o- 10.10.2.21:3260 .................................................................................................. [OK]
  o- loopback ......................................................................................................... [Targets: 0]
/iscsi/iqn.20.../tpg1/portals&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后配置防火墙策略，或者直接关闭防火墙，建议后者，视具体要求而定。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--防火墙添加放行tcp 3260端口：
firewall-cmd --permanent --add-port=3260/tcp
firewall-cmd --reload

--关闭防火墙：
systemctl disable firewalld
systemctl stop firewalld&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.1 使用yum安装iscsi-initiator-utils&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum -y install iscsi-initiator-utils&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.2 编辑/etc/iscsi/initiatorname.iscsi&lt;/strong&gt;&lt;br/&gt;vi /etc/iscsi/initiatorname.iscsi&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#InitiatorName=iqn.1994-05.com.redhat:babc7da33c48
InitiatorName=iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be:client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释之前的示例，添加一行实际的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.3 使用iscsiadm发现可用存储设备并登陆连接&lt;/strong&gt;&lt;br/&gt;iscsiadm -m discovery -t st -p 10.10.1.21&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@db92 yum.repos.d]# iscsiadm -m discovery -t st -p 10.10.1.21
10.10.1.21:3260,1 iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be
10.10.2.21:3260,1 iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登陆连接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;iscsiadm -m node -T iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be -p 10.10.1.21 --login
iscsiadm -m node -T iqn.2003-01.org.linux-iscsi.storage-b.x8664:sn.46b1dc2750be -p 10.10.2.21 --login&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时使用fdisk -l 查看已经正常显示所有设备：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@db90 ~]# fdisk -l

Disk /dev/sda: 85.9 GB, 85899345920 bytes, 167772160 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0001b841

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048     2099199     1048576   83  Linux
/dev/sda2         2099200   167772159    82836480   8e  Linux LVM

Disk /dev/mapper/rhel-root: 51.3 GB, 51308920832 bytes, 100212736 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/rhel-swap: 8455 MB, 8455716864 bytes, 16515072 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/mapper/rhel-home: 25.1 GB, 25052577792 bytes, 48930816 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes


Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdc: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdd: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sde: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdg: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdf: 42.9 GB, 42949672960 bytes, 83886080 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdh: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdi: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdj: 42.9 GB, 42949672960 bytes, 83886080 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdl: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdk: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdn: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdm: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdo: 10.7 GB, 10737418240 bytes, 20971520 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdp: 17.2 GB, 17179869184 bytes, 33554432 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes


Disk /dev/sdq: 17.2 GB, 17179869184 bytes, 33554432 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 33550336 bytes

[root@db90 ~]# &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于是两条链路，所以fdisk看到的存储LUN是两倍，后续再使用多路径软件聚合即可使用。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Jul 2018 05:20:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9349846.html</dc:identifier>
</item>
</channel>
</rss>