<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>英文文档帮查&amp;翻译计划 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/learn_by_doc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/learn_by_doc.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/photo-1512153472310-d72327c26cf0.jpeg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以CSDN为首，知乎其次，cnblog带路的一大批博客上充斥着大量低质量的编程入门教程，代码粗制滥造，毫无缩进，没有高亮，东抄西抄。初学者如果长期参照这种垃圾博客来解决问题，将会适得其反，走入歧途。&lt;/p&gt;
&lt;p&gt;其实，初学者最应该看的，是编程软件的&lt;code&gt;官方文档&lt;/code&gt;，是软件工具的&lt;code&gt;官方文档&lt;/code&gt;，是开源项目的&lt;code&gt;官方文档&lt;/code&gt;……&lt;/p&gt;
&lt;p&gt;但是鉴于有一些文档没有中文翻译，让不少不会英文的同学望而却步。&lt;/p&gt;
&lt;p&gt;为此，我将会启动英文文档代查、翻译计划。&lt;/p&gt;
&lt;p&gt;如果你想学习一门编程语言，但是它没有官方中文文档；如果你想实现一个功能，但是官方教程对API的描述是英文；如果你想用一个软件，但是这个软件没有中文说明书；如果你想参与一个开源项目，但是看不懂上面的英文讨论……那么你可以在这个公众号上获得帮助。&lt;/p&gt;
&lt;h2 id=&quot;如何寻求帮助&quot;&gt;如何寻求帮助​&lt;/h2&gt;
&lt;p&gt;扫描本文末尾的微信公众号二维码添加&lt;code&gt;未闻Code&lt;/code&gt;，公众号私聊中，把你的诉求发送给我。我帮你寻找官方文档，帮你翻译，然后用公众号文章的形式发布出来，让更多人看到。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#文档翻译#我想知道Scrapy的下载器中间件中，process_response可以返回哪些数据。 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/IMG_1635.PNG&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;我接收哪些请求&quot;&gt;我接收哪些请求&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;StackOverflow上面具体某一个问题的回答。您可以把网址发送给我&lt;/li&gt;
&lt;li&gt;编程语言具体功能&lt;/li&gt;
&lt;li&gt;开源项目具体某个API的使用&lt;/li&gt;
&lt;li&gt;Medium中具体某一篇文章的某一段落&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，你的需求越具体，我就越能找到你需要的内容并为你翻译。&lt;/p&gt;
&lt;p&gt;当然，你也可以尝试给我发送一些非技术性的内容，例如《经济学人》《华盛顿邮报》中的具体&lt;code&gt;某个段落&lt;/code&gt;，如果我有时间的话，也会帮你翻译。&lt;/p&gt;
&lt;h2 id=&quot;我拒接哪些请求&quot;&gt;我拒接哪些请求&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;请帮我翻译Python官方文档&lt;/li&gt;
&lt;li&gt;请帮我翻译这一篇Quora下面的所有回答&lt;/li&gt;
&lt;li&gt;请帮我翻译这个开源项目的官方文档&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;我怎么给你结果&quot;&gt;我怎么给你结果&lt;/h2&gt;
&lt;p&gt;我会汇总每一周的请求，并在周六更新的公众号文章中，为你呈现你需要的结果。&lt;/p&gt;
&lt;h2 id=&quot;这个项目收费吗&quot;&gt;这个项目收费吗&lt;/h2&gt;
&lt;p&gt;本计划完全免费。不会以任何形式收取任何费用。不收费不代表没有成本，因此请勿滥用。&lt;/p&gt;
&lt;h2 id=&quot;我为什么要启动这个项目&quot;&gt;我为什么要启动这个项目&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我看不惯那些装逼货粗制滥造的博客。&lt;/li&gt;
&lt;li&gt;我深深体会到阅读官方文档的重要性，因此我希望我能让更多的人能在遇到问题时首先想到官方文档而不是用百度搜索中文博客。&lt;/li&gt;
&lt;li&gt;你们问的东西可能也是我不知道的，通过这个项目我可以学到更多好用的工具&lt;/li&gt;
&lt;li&gt;把我的英语单词量扩展到10000词以上。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何找到我&quot;&gt;如何找到我&lt;/h2&gt;
&lt;p&gt;请扫描下面的二维码，添加我的微信公众号&lt;code&gt;未闻Code&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/wechatplatform.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 23:56:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<og:description>以CSDN为首，知乎其次，cnblog带路的一大批博客上充斥着大量低质量的编程入门教程，代码粗制滥造，毫无缩进，没有高亮，东抄西抄。初学者如果长期参照这种垃圾博客来解决问题，将会适得其反，走入歧途。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/learn_by_doc.html</dc:identifier>
</item>
<item>
<title>Xilinx Vivado的使用详细介绍（4）：Zedboard+vivado之流水灯（加SDK） - Zhangxianhe</title>
<link>http://www.cnblogs.com/zhangxianhe/p/9795826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxianhe/p/9795826.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;Vivado+zedboard之初学流水灯&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;Author:zhangxianhe&lt;/p&gt;
&lt;p&gt;环境：vivado 2016.3（已验证适用于2015.4）&lt;/p&gt;
&lt;p&gt;开发板：Zedboard version xc7z020clg484-1&lt;/p&gt;
&lt;p&gt;实验：使用Vivado和SDK进行Zedboard开发，制作一个简单的流水灯程序以说明软硬件协同设计的方法、开发流程等。&lt;/p&gt;
&lt;p&gt;本文将分为三个部分：&lt;/p&gt;
&lt;p&gt;1. 使用Vivado创建一个工程，并构建一个Zynq嵌入式处理系统。&lt;/p&gt;
&lt;p&gt;2. 在上述基础上，将完成后的硬件导入到SDK中进行软件设计。&lt;/p&gt;
&lt;p&gt;3. 最后下载到ZedBoard上进行调试。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;具体步骤如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1. 使用Vivado创建工程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1.1新建工程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1).鼠标左键双击Vivado2016.3图标，打开Vivado 2016.3;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2).单击Create New Project创建一个新的工程;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3).单击Next执行下一步；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　4).选择工程所在的位置，并输入工程名ledflow，单击Next；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5)．在Vivado中新建一个RTL工程，暂不添加文件（勾选 Do not specify sources at this time），后面需要的时候添加，单击Next；&lt;/p&gt;
&lt;p&gt;　　6).这一步要注意，在左上角Select处选择Boards，选择ZedBoard Zynq Evaluation and Development Kit version D器件，单击Next；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　7).单击Finish&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　8).等待软件根据设定新建一个RTL工程。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这样新建工程的步骤就完成了，下面进行硬件设计步骤；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.2 Vivado硬件设计&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1). 单击Create Block Design，创建并添加IP核；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2).输入工程名led，单击OK；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3).等待软件Create Block Design&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　4).Add IP.右边空白处一般会提示This design is empty. To get started, Add IP from the catalog，单击 Add IP会出现IP的目录，如果此处没有提示，可以单击Diagram左边框的Add IP添加；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5). 在目录Search中输入ZYNQ7 Processing System；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　6).双击ZYNQ7 Processing System完成IP核的添加；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　7).等待软件Add IP，接下来工程窗上部分会出现Run Block Automation，点Run Block Automation，直接点OK。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　8).接下来继续添加IP,Add Ip 并在在搜索中寻找AXI GPIO，双击添加。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　9).完成后继续点Run Connect Automation，出现窗口先打钩S_AXI，右边设置保持不变，直接点OK。之后继续点run connect automation，打钩剩下的，注意此时右侧选择leds_8bits(LED)。之后OK.点击Diagram的Regenerate Layout,重新布局，完成后出现如下界面。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074414332-2124169174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1.3硬件处理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1). Tools &amp;gt;Validate Design&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2)．等待软件运行，运行后的界面如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074517723-1005162207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3).单击OK；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　4).Right-Click the Top-level Subsystem Design-&amp;gt;Generate Output Products,默认设置，直接点generate，运行结束后，点击OK。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5). Right-Click the Top-level Subsystem Design-&amp;gt;Create HDL Wrapper，选择第二项 Let Vivado manage Wrapper and auto-update,点击OK，&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　6). 在左侧Flow Navigator中最下边，单击Generate Bitstream，点击save（如果有提示）然后单击Yes，直接生成比特流文件。执行此过程首先会自动进行分析综合和实现。(这里也可以直接先点击Run Synthesis进行综合，然后点击Run Implementation进行实现，然后再点击Generate Bitstream生成比特流) 需要等待运行的时间比较长，耐心等待；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　7).运行完成后，会自动弹出对话框，选择Open Implemented Design，单击OK：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074617666-916649428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　8).运行完成后的界面如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074629511-1812348184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;　　9).在关联到SDK时，需要将Package和Device都打开，如果运行后只是自动打开了Device，需要在Flow Navigator下找到Synthesis并在其下点击Open Synthesized Design来打开Package，单击NO，将Package和Device同时显示出来；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　10).单击Open Block Design to invoke the IP integrator design&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　11).准备两条USB线，一条连接 micro-usb cable between the PC and the PROG port of the board；另外一条 micro-usb cable between the PC and the UART port of the board,打开Zedboard板的电源，如下图所示，打开电源之后POWER灯会亮；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074712138-375759946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　12).单击左侧导航窗口最下方Hardware Manager中的Open Target，然后选择Auto Connect&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　13).单击Hardware Manager中的Program Device，单击xc7z020_1默认设置，单击Program将比特流烧写到ZedBoard板上；完成后板上的DONE蓝灯会亮， 提示比特流文件下载到ZedBoard板上成功：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　14).单击File中的Export，单击Export Hardware，注意打钩include bitstream,点击OK。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　15).单击File中的Launch SDK，默认设置，单击OK，这时会自动启动SDK。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这样在Vivado中的操作就完成了，软件会自动打开。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1.4 SDK中的软件设计&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;打开后的SDK界面如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074803141-1340038064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;　　1). 单击File &amp;gt; New &amp;gt; Application Project&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　2).输入工程名ledflow，其它默认，注意勾选 Use default location(默认已经勾选)单击Next；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　3). 选择一个空的模板：empty application，单击Finish，等待工作环境的建立；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　4). 单击ledflow&amp;gt;右击src&amp;gt;New &amp;gt; Source File&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　5).输入工程名ledflow.c（一般命名为main.c），单击Finish；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　6). 编写如下程序：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; *&lt;span&gt; ledflow.c
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  *
&lt;span&gt; 3&lt;/span&gt;  *&lt;span&gt;  Created on: 2017年11月16日
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  *&lt;span&gt;      Author: zhangxianhe
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  */
&lt;span&gt; 6&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xparameters.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xgpio.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xil_printf.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; #include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xil_cache.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GPIO_BITWIDTH 8
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; GPIO_DEVICE_ID XPAR_AXI_GPIO_0_DEVICE_ID
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LED_DELAY 100000000
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LED_MAX_BLINK 0x1
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LED_CHANNEL 1
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; printf xil_printf
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;XGpio Gpio;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;XGpio GpioOutput;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GpioMarquee(u16 DeviceId,u32 GpioWidth)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Delay;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    u32 LedBit;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    u32 LedLoop;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     Status=XGpio_Initialize(&amp;amp;&lt;span&gt;GpioOutput,DeviceId);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(Status!=&lt;span&gt;XST_SUCCESS)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_FAILURE;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     XGpio_SetDataDirection(&amp;amp;GpioOutput,LED_CHANNEL,&lt;span&gt;0x0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     XGpio_DiscreteWrite(&amp;amp;GpioOutput,LED_CHANNEL,&lt;span&gt;0x0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(LedBit=&lt;span&gt;0x0&lt;/span&gt;;LedBit&amp;lt;GpioWidth;LedBit++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;        &lt;span&gt;for&lt;/span&gt;(LedLoop=&lt;span&gt;0x0&lt;/span&gt;;LedLoop&amp;lt;LED_MAX_BLINK;LedLoop++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;       {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;            XGpio_DiscreteWrite(&amp;amp;GpioOutput,LED_CHANNEL,&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;LedBit);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;            &lt;span&gt;for&lt;/span&gt;(Delay=&lt;span&gt;0&lt;/span&gt;;Delay&amp;lt;LED_DELAY;Delay++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;            XGpio_DiscreteClear(&amp;amp;GpioOutput,LED_CHANNEL,&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;LedBit);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;            &lt;span&gt;for&lt;/span&gt;(Delay=&lt;span&gt;0&lt;/span&gt;;Delay&amp;lt;LED_DELAY;Delay++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_SUCCESS;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;       u32 status;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;        status=&lt;span&gt;GpioMarquee(GPIO_DEVICE_ID,GPIO_BITWIDTH);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;        &lt;span&gt;if&lt;/span&gt;(status==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SUCCESS!.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;        &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FAILED.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; XST_SUCCESS;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;然后Ctrl+S，保存的同时，软件会自动开始编译，在左下角problem处可以看到相应的warning和error（如果存在），在console里面可以看到编译成功的效果；无误后，如果有错误Click Project-&amp;gt; clean (in case you get any errors with the BSD).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　7).单击Xilinx Tools &amp;gt; program FPGA将比特流烧写到板上（在Vivado中就先将比特流烧写到板上有两个原因：1.如果SDK调试时出现问题，这样可以检测首先是不是Vivado的问题，如果成功烧写，说明板的连接没有问题，并且Vivado软件本身没有问题；2.在之前的调试过程中出现过直接Xilinx Tools &amp;gt; program FPGA无法烧写的情况；因此，保险起见，选择在Vivado中就先将比特流烧写到板上）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　8).单击Program（和在Vivado中烧写的现象一样，完成后DONE蓝色指示灯会亮）&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注：如果软件本身以及板的连接没有问题，那么这个步骤会在三秒左右完成，如果一直卡在一半的进度，说明SDK和Vivado没有很好的建立关联；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　9). 选择&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016074956442-581345416.png&quot; alt=&quot;&quot;/&gt;按钮. 如果找不到这个标志选择 &lt;strong&gt;Window &amp;gt; Show view &amp;gt; Terminal&lt;/strong&gt;.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　10).单击 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075011256-657505682.png&quot; alt=&quot;&quot;/&gt;并且选择合适的 COM port (取决你自己的电脑), and configure the terminal with the parameters as shown below.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075038504-853632861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;　　11).在用到串口打印时，需要设置的COM口，为设备管理器中的USB Serial Port（本机为COM5），因此要选择COM5，注意波特率为115200：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　12)．右键工程目录中的ledflow目录，选择Debug As &amp;gt; Debug Configurations，双击Xilinx C/C++ application (GDB),自动选择工程，然后选择Reset Entire System。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075051578-1881508315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075055838-262623605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;在STDIO Connection中,勾选Connect STDIO to Console设置COM 5和波特率115200；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075121719-2022897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;　　13).单击Apply，再单击Debug,再点击图示箭头所指图标，即可看到现象。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075138514-912900079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;(第一次的时候会出现选择，直接选择第一个运行方式)，看到流水灯的效果，每次跑完一圈Console窗口会出现SUCESS!.的消息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1458110/201810/1458110-20181016075147606-113272923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;至此，Vivado+Zedboard的流水灯实验就完成了，板子不使用时要记得关闭电源。&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 23:54:00 +0000</pubDate>
<dc:creator>Zhangxianhe</dc:creator>
<og:description>Vivado+zedboard之初学流水灯 Author:zhangxianhe 环境：vivado 2016.3（已验证适用于2015.4） 开发板：Zedboard version xc7z020</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxianhe/p/9795826.html</dc:identifier>
</item>
<item>
<title>集成学习之Boosting —— XGBoost - massquantity</title>
<link>http://www.cnblogs.com/massquantity/p/9794480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/massquantity/p/9794480.html</guid>
<description>&lt;h3 id=&quot;集成学习之boosting-adaboost&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/massquantity/p/9063033.html&quot;&gt;&lt;span&gt;集成学习之Boosting —— AdaBoost&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;集成学习之boosting-gradient-boosting&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/massquantity/p/9174746.html&quot;&gt;&lt;span&gt;集成学习之Boosting —— Gradient Boosting&lt;/span&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;集成学习之boosting-xgboost&quot;&gt;集成学习之Boosting —— XGBoost&lt;/h3&gt;

&lt;p&gt;Gradient Boosting 可以看做是一个总体的算法框架，起始于Friedman 的论文 &lt;a href=&quot;http://www-stat.stanford.edu/~jhf/ftp/trebst.pdf&quot;&gt;[&lt;span&gt;&lt;em&gt;Greedy Function Approximation: A Gradient Boosting Machine&lt;/em&gt;&lt;/span&gt;]&lt;/a&gt; 。XGBoost (eXtreme Gradient Boosting) 是于2015年提出的一个新的 Gradient Boosting 实现，由华盛顿大学的 &lt;a href=&quot;https://homes.cs.washington.edu/~tqchen/&quot;&gt;&lt;span&gt;陈天奇&lt;/span&gt;&lt;/a&gt; 等人开发，在速度和精度上都有显著提升，因而近年来在 Kaggle 等各大数据科学比赛中都得到了广泛应用。本文主要对其原理进行阐述，并将其与传统的 GBDT 进行比较。&lt;/p&gt;
&lt;p&gt;大体来看，XGBoost 在原理方面的改进主要就是在损失函数上作文章。一是在原损失函数的基础上添加了正则化项产生了新的目标函数，这类似于对每棵树进行了剪枝并限制了叶结点上的分数来防止过拟合。二是对目标函数进行二阶泰勒展开，以类似牛顿法的方式来进行优化（事实上早在 &lt;a href=&quot;http://statweb.stanford.edu/~jhf/ftp/boost.pdf&quot;&gt;[&lt;span&gt;&lt;em&gt;Friedman, J., Hastie, T. and Tibshirani, R., 1999&lt;/em&gt;&lt;/span&gt;]&lt;/a&gt; 中就已有类似方案，即利用二阶导信息来最小化目标函数，陈天奇在论文中也提到了这一点）。&lt;/p&gt;
&lt;p&gt;在上一篇文章中，了解到 Gradient Boosting 的思想可以理解为通过函数空间的梯度下降来最小化目标函数 &lt;span class=&quot;math inline&quot;&gt;\(L(f) = \sum\limits_{i=1}^NL(y_i,f_m(x_i))\)&lt;/span&gt;，其只使用了一阶导信息，而 XGBoost 引入二阶导的一大好处是可以推导出一种新的增益计算方法，事实证明采用新的增益计算方法在优化目标函数上更加有效，精确度上也胜过传统的 GBDT。所以下面也从目标函数的优化入手进行推导。&lt;/p&gt;

&lt;h2 id=&quot;xgboost的目标函数&quot;&gt;XGBoost的目标函数&lt;/h2&gt;
&lt;p&gt;与 GBDT 一样，XGBoost 同样采用加法模型，设基学习器为&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;，预测值为&lt;span class=&quot;math inline&quot;&gt;\(\hat{y}\)&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \hat{y} = \sum\limits_{m=1}^M f_m(x)\;, \quad f_m \in \mathcal{F} \tag{1.1} \]&lt;/span&gt;&lt;br/&gt;在第m步，前m-1个基学习器是固定的，因而目标函数为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{L}^{(m)} = \sum\limits_{i=1}^N L(y_i, \;\hat{y_i}^{(m-1)} + f_m(x_i)) + \Omega(f_m) \tag{1.2} \]&lt;/span&gt;&lt;br/&gt;在传统的 GBDT 中，是没有正则化项 &lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt; 的，而在XGBoost中采用的是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Omega(f) = \gamma \, J + \frac12 \lambda \sum\limits_{j=1}^J b_j^2 \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(J\)&lt;/span&gt; 为叶结点数目，&lt;span class=&quot;math inline&quot;&gt;\(b_j\)&lt;/span&gt; 为各个叶结点上的值。该项限制了树的复杂度，这样相当于使叶结点的数目变小，同时限制叶结点上的分数，因为通常分数越大学得越快，就越容易过拟合。&lt;/p&gt;
&lt;p&gt;接下来将 &lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt; 代入&lt;span class=&quot;math inline&quot;&gt;\((1.2)\)&lt;/span&gt; 式并对目标函数在 &lt;span class=&quot;math inline&quot;&gt;\(\hat{y}_i^{(m-1)}\)&lt;/span&gt; 处进行二阶泰勒展开：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{L}^{(m)} \simeq \sum\limits_{i=1}^N \left[ L(y_i, \hat{y}_i^{(m-1)}) + g_if_m(x_i) + \frac12 h_i f_m^2(x_i)\right] + \gamma \, J + \frac12 \lambda \sum\limits_{j=1}^J b_j^2 \tag{1.3} \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(g_i = \frac{\partial L(y_i, \,\hat{y}_i^{m-1})}{\partial \, \hat{y}^{(m-1)}}\;\;,\;\; h_i = \frac{\partial^2 L(y_i, \,\hat{y}_i^{(m-1)})}{(\partial\, \hat{y}^{(m-1)})^2}\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在上一篇 Gradient Boosting 中提到决策树将特征空间划分为各个独立区域，每个样本只属于其中一个区域，因而单颗决策树可表示为 &lt;span class=&quot;math inline&quot;&gt;\(f(x) = \sum\limits_{j=1}^J b_j I(x \in R_j)\)&lt;/span&gt;，如果将所有样本加起来，则可表示为 &lt;span class=&quot;math inline&quot;&gt;\(\sum\limits_{i=1}^N f(x_i) = \sum\limits_{j=1}^J \sum\limits _{x \in R_j} b_j\)&lt;/span&gt; ，代入 &lt;span class=&quot;math inline&quot;&gt;\((1.3)\)&lt;/span&gt; 式并将常数项 &lt;span class=&quot;math inline&quot;&gt;\(L(y_i, \hat{y}_i^{(m-1)})\)&lt;/span&gt; 移去：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} \mathcal{L}^{(m)} &amp;amp;= \sum\limits_{i=1}^N \left[ g_if_m(x_i) + \frac12 h_i f_m^2(x_i)\right] + \gamma \, J + \frac12 \lambda \sum\limits_{j=1}^J b_j^2 \\ &amp;amp;= \sum\limits_{j=1}^J \left[ \sum\limits_{x_i \in R_j}g_ib_j + \frac12 \sum\limits_{x_i \in R_j} h_i b_j^2\right] + \gamma \, J + \frac12 \lambda \sum\limits_{j=1}^J b_j^2 \\ &amp;amp;= \sum\limits_{j=1}^J \left[ \sum\limits_{x_i \in R_j}g_ib_j + \frac12 (\sum\limits_{x_i \in R_j} h_i + \lambda) \,b_j^2 \right] + \gamma \, J \\ &amp;amp; = \sum\limits_{j=1}^J(G_j b_j + \frac12 (H_j + \lambda) \,b_j^2) + \gamma\, J \tag{1.4} \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(G_j = \sum\limits_{x_i \in R_j} g_i \;\; , \;\; H_j = \sum\limits_{x_i \in R_j} h_i\)&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;xgboost的增益计算和树分裂方法&quot;&gt;XGBoost的增益计算和树分裂方法&lt;/h2&gt;
&lt;p&gt;经过一系列推导后，现在我们的目标变为最小化 &lt;span class=&quot;math inline&quot;&gt;\((1.4)\)&lt;/span&gt; 式，并求得相应的树结构 &lt;span class=&quot;math inline&quot;&gt;\(\{R_j\}^J_1\)&lt;/span&gt; 和叶结点上的值 &lt;span class=&quot;math inline&quot;&gt;\(\{b_j\}^J_1\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;精确地划分 &lt;span class=&quot;math inline&quot;&gt;\(\{R_j\}^J_1\)&lt;/span&gt; 是一个 NP hard 问题，现实中常使用贪心法，遍历每个特征的每个取值，计算分裂前后的增益，并选择增益最大的进行分裂。&lt;/p&gt;&lt;p&gt;对于具体增益的衡量标准，在几种决策树算法中，ID3 采用了信息增益：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I(D,A) = H(D) - H(D|A) = H(D) - \sum\limits_{v=1}^V\frac{|D^v|}{|D|} H(D^v) \]&lt;/span&gt;&lt;br/&gt;其中 V 表示特征 A 有 V 个可能的取值，&lt;span class=&quot;math inline&quot;&gt;\(D^v\)&lt;/span&gt; 表示第 v 个取值上的样本数量。&lt;/p&gt;

&lt;p&gt;C4.5 采用了信息增益比：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ I_R(D,A) = \frac{I(D, A)}{H_A(D)} \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(H_A(D) = -\sum\limits_{v=1}^V \frac{|D^v|}{|D|} log_2 \frac{|D^v|}{|D|}\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;CART 分类树采用了基尼系数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gini(D,A) = \sum\limits_{v=1}^V \frac{|D^v|}{|D|} Gini(D^v) = \sum\limits_{v=1}^V \frac{|D^v|}{|D|} \left(1 - \sum\limits_{k=1}^K \left\lbrace\frac{|C_k|}{|D|}\right\rbrace^2\right) \]&lt;/span&gt;&lt;br/&gt;其中 K 为类别个数，&lt;span class=&quot;math inline&quot;&gt;\(|C_k|\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt; 中属于第k类的样本数量。&lt;/p&gt;

&lt;p&gt;CART 回归树采用了均方误差：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathop{min}_{A,s}\Bigg[\mathop{min}_{c_1}\sum\limits_{x_i \in R_1(A,s)}(y_i - c_1)^2 + \mathop{min}_{c_2}\sum\limits_{x_i \in R_2(A,s)}(y_i - c_2)^2\Bigg] \]&lt;/span&gt;&lt;br/&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(c_1\)&lt;/span&gt;为特征 A 的切分点 s 划分出来的 &lt;span class=&quot;math inline&quot;&gt;\(R_1\)&lt;/span&gt; 区域的样本输出均值，&lt;span class=&quot;math inline&quot;&gt;\(c_1 = mean(y_i | x_i \in R_1(A,s))\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(c_2\)&lt;/span&gt;为 &lt;span class=&quot;math inline&quot;&gt;\(R_2\)&lt;/span&gt; 区域的样本输出均值，&lt;span class=&quot;math inline&quot;&gt;\(c_2 = mean(y_i | x_i \in R_2(A,s))\)&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;而XGBoost则提出了一种新的增益计算方法。&lt;/p&gt;
&lt;p&gt;如果已经确定了树的结构 &lt;span class=&quot;math inline&quot;&gt;\(\{R_j\}^J_1\)&lt;/span&gt; ，则直接对 &lt;span class=&quot;math inline&quot;&gt;\((1.4)\)&lt;/span&gt; 式求导，最优值为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ b^*_j = - \frac{G_j}{H_j + \lambda} \]&lt;/span&gt;&lt;br/&gt;再代入&lt;span class=&quot;math inline&quot;&gt;\((1.4)\)&lt;/span&gt;式得到此时最小的为目标函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathcal{L^{(m)}} = -\frac12 \sum\limits_{j=1}^J \frac{G_j^2}{H_j+ \lambda} + \gamma\, J \tag{1.5} \]&lt;/span&gt;&lt;br/&gt;式 &lt;span class=&quot;math inline&quot;&gt;\((1.5)\)&lt;/span&gt; 可以认为是 XGBoost 的打分函数，该值越小，说明树的结构越好，下图示例了该式的计算方法：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;该式的优点是除了能作为树分裂的衡量标准外，还能使 XGboost 适用于各种不同的损失函数，所以 &lt;a href=&quot;https://xgboost.readthedocs.io/en/latest/index.html&quot;&gt;&lt;span&gt;XGBoost 包&lt;/span&gt;&lt;/a&gt;中支持自定义损失函数，但前提是一阶和二阶可导。&lt;/p&gt;

&lt;p&gt;从另一角度看， &lt;span class=&quot;math inline&quot;&gt;\((1.5)\)&lt;/span&gt; 式就类似于传统决策树中的不纯度指标，在决策树中我们希望一次分裂后两边子树的不纯度越低越好，对应到XGBoost中则是希望 &lt;span class=&quot;math inline&quot;&gt;\((1.5)\)&lt;/span&gt;式 越小越好，即 &lt;span class=&quot;math inline&quot;&gt;\(\frac{G_j^2}{H_j+ \lambda}\)&lt;/span&gt; 越大越好，这样分裂前后的增益定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Gain = \frac{G_L^2}{H_L+ \lambda} + \frac{G_R^2}{H_R+ \lambda} - \frac{(G_L + G_R)^2}{H_L+ H_R + \lambda} - \gamma \tag{1.6} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{G_L^2}{H_L+ \lambda}\)&lt;/span&gt; 为分裂后左子树的分数，&lt;span class=&quot;math inline&quot;&gt;\(\frac{G_R^2}{H_R+ \lambda}\)&lt;/span&gt; 为分裂后右子树的分数，$\frac{(G_L + G_R)^2}{H_L+ H_R + \lambda} $ 为分裂前的分数，&lt;span class=&quot;math inline&quot;&gt;\(Gain\)&lt;/span&gt; 越大说明越值得分裂。当然 &lt;span class=&quot;math inline&quot;&gt;\((1.6)\)&lt;/span&gt; 式中 &lt;span class=&quot;math inline&quot;&gt;\(Gain\)&lt;/span&gt; 可能会变成负的，这个时候分裂后的目标函数不会减少，&lt;strong&gt;但这并不意味着不会分裂&lt;/strong&gt; 。事实上 XGBoost 采用的是后剪枝的策略，建每棵树的时候会一直分裂到指定的最大深度(max_depth)，然后递归地从叶结点向上进行剪枝，对之前每个分裂进行考察，如果该分裂之后的 &lt;span class=&quot;math inline&quot;&gt;\(Gain \leqslant 0\)&lt;/span&gt;，则咔咔掉。 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; 是一个超参数，具有双重含义，一个是在 &lt;span class=&quot;math inline&quot;&gt;\((1.3)\)&lt;/span&gt; 式中对叶结点数目进行控制的参数；另一个是 &lt;span class=&quot;math inline&quot;&gt;\((1.6)\)&lt;/span&gt; 式中分裂前后 &lt;span class=&quot;math inline&quot;&gt;\(Gain\)&lt;/span&gt; 增大的阈值，当然二者的目的是一样的，即限制树的规模防止过拟合。&lt;/p&gt;

&lt;p&gt;接下来考察决策树建立的过程。如果是使用贪心法，就是遍历一个叶结点上的所有候选特征和取值，分别计算 &lt;span class=&quot;math inline&quot;&gt;\(Gain\)&lt;/span&gt; ，选择 &lt;span class=&quot;math inline&quot;&gt;\(Gain\)&lt;/span&gt; 最大的候选特征和取值进行分裂，如下树分裂算法流程 (注意这是&lt;strong&gt;单个叶结点&lt;/strong&gt;的分裂流程)：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有了上述单个叶结点上的分裂流程后，我们可以总结下整个 XGBoost 的学习算法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;初始化 &lt;span class=&quot;math inline&quot;&gt;\(f_0(x)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;for m=1 to M :&lt;br/&gt;(a) 计算损失函数在每个训练样本点的一阶导数 &lt;span class=&quot;math inline&quot;&gt;\(g_i = \frac{\partial L(y_i, \,\hat{y}_i^{m-1})}{\partial \, \hat{y}^{(m-1)}}\)&lt;/span&gt; 和二阶导数 &lt;span class=&quot;math inline&quot;&gt;\(h_i = \frac{\partial^2 L(y_i, \,\hat{y}_i^{(m-1)})}{(\partial\, \hat{y}^{(m-1)})^2}\)&lt;/span&gt; , $ i = 1,2 \cdots N$&lt;br/&gt;(b) 递归地运用树分裂算法生成一颗决策树 &lt;span class=&quot;math inline&quot;&gt;\(f_m(x)\)&lt;/span&gt;&lt;br/&gt;(c) 把新生成的决策树添加到模型中， $\hat{y_i}^{(m)} = \hat{y_i}^{(m-1)} + f_m(x) $&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;

&lt;p&gt;如果把上述 XGBoost 的学习算法和上一篇中传统 GBDT 的学习算法作比较，XGBoost 的主要优势是在损失函数中加入正则化项后使得学习出来的树更加简单，防止过拟合，但除此以外并不能体现出 XGBoost 的速度优势。XGBoost 之所以快的一大原因是在工程上实现了 &lt;em&gt;Column Block&lt;/em&gt; 方法，使得并行训练成为了可能。&lt;/p&gt;

&lt;h2 id=&quot;column-block-for-parallel-learning&quot;&gt;Column Block for Parallel Learning&lt;/h2&gt;
&lt;p&gt;对于决策树来说，对连续值特征进行划分通常比较困难，因为连续值特征往往取值众多。通常的做法是先按特征取值对样本排序，再按顺序计算增益选择划分点。若每次分裂都要排一次序，那是非常耗时的，所以 XGBoost 的做法是在训练之前，预先按特征取值对样本进行了排序，然后保存为block结构，采用CSC格式存储，每一列(一个特征列)均升序存放，这样，一次读入数据并排好序后，以后均可重复使用，大大减小计算量。&lt;/p&gt;
&lt;p&gt;由于已经预先排过序，所以在树分裂算法中，通过一次线性扫描 (linear scan) 就能找出一个特征的最优分裂点，如下图所示，同时可以看到缺失值并没有保存：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;陈天奇论文里有关键的一句话：&lt;em&gt;Collecting statistics for each columns can be parallelized&lt;/em&gt; 。由于已经预先保存为block 结构，所以在对叶结点进行分裂时，每个特征的增益计算就可以开多线程进行，训练速度也由此提升了很多。而且这种 block 结构也支持列抽样，只要每次从所有 block 特征中选择一个子集作为候选分裂特征就可以了，据我的使用经验，列抽样大部分时候都比行抽样的效果好。&lt;/p&gt;

&lt;h2 id=&quot;近似分裂算法&quot;&gt;近似分裂算法&lt;/h2&gt;
&lt;p&gt;当数据量非常大难以被全部加载进内存时或者在分布式环境下时，上文的树分裂算法将不再适用，因而作者提出了近似分裂算法，不仅解决了这个问题，也同时能提升训练速度，具体流程见下图：&lt;/p&gt;
&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;近似分裂算法其实就是对连续性特征进行离散化，对于某个特征 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，算法首先根据特征分布找到 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 个分位点的候选集合 &lt;span class=&quot;math inline&quot;&gt;\(S_k = \{s_{k1}, s_{k2}, ... ,s_{kl} \}\)&lt;/span&gt; ，然后根据集合 &lt;span class=&quot;math inline&quot;&gt;\(S_k\)&lt;/span&gt; 中的分位点将相应样本划分到桶(bucket)中。在遍历该特征时，只需遍历各个分位点，对每个桶内的样本统计值 &lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;、&lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt; 进行累加统计，寻找最佳分裂点进行分裂。该算法可分为 global 近似和 local 近似，global 就是在新生成一棵树之前就对各个特征计算分位点并划分样本，之后在每次分裂过程中都重复利用这些分位点进行划分，而 local 就是每一次结点分裂时都要重新计算分位点。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;最后总结一下 XGBoost 与传统 GBDT 的不同之处：&lt;/p&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;传统 GBDT 在优化时只用到一阶导数信息，XGBoost 则对目标函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。另外 XGBoost 工具支持自定义损失函数，只要函数可一阶和二阶求导。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;XGBoost 在损失函数中加入了正则化项，用于控制模型的复杂度，防止过拟合，从而提高模型的泛化能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;传统 GBDT 采用的是均方误差作为内部分裂的增益计算指标（因为用的都是回归树），而 XGBoost 使用的是经过优化推导后的式子，即式 &lt;span class=&quot;math inline&quot;&gt;\((1.6)\)&lt;/span&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;XGBoost 借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算量，这也是 XGBoost 异于传统 GBDT 的一个特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;XGBoost 添加了对稀疏数据的支持，在计算分裂增益时不会考虑带有缺失值的样本，这样就减少了时间开销。在分裂点确定了之后，将带有缺失值的样本分别放在左子树和右子树，比较两者分裂增益，选择增益较大的那一边作为默认分裂方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;并行化处理：由于 Boosting 本身的特性，无法像随机森林那样树与树之间的并行化。XGBoost 的并行主要体现在特征粒度上，在对结点进行分裂时，由于已预先对特征排序并保存为block 结构，每个特征的增益计算就可以开多线程进行，极大提升了训练速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;传统 GBDT 在损失不再减少时会停止分裂，这是一种预剪枝的贪心策略，容易欠拟合。XGBoost采用的是后剪枝的策略，先分裂到指定的最大深度 (max_depth) 再进行剪枝。而且和一般的后剪枝不同， XGBoost 的后剪枝是不需要验证集的。 不过我并不觉得这是“纯粹”的后剪枝，因为一般还是要预先限制最大深度的呵呵。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说了这么多 XGBoost 的优点，其当然也有不完美之处，因为要在训练之前先对每个特征进行预排序并将结果存储起来，对于空间消耗较大。另外虽然相比传统的 GBDT 速度是快了很多，但和后来的 LightGBM 比起来还是慢了不少，不知以后还会不会出现更加快的 Boosting 实现。&lt;/p&gt;

&lt;hr/&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Tianqi Chen and Carlos Guestrin. &lt;em&gt;&lt;a href=&quot;http://www.kdd.org/kdd2016/papers/files/rfp0697-chenAemb.pdf&quot;&gt;&lt;span&gt;XGBoost: A Scalable Tree Boosting System&lt;/span&gt;&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Tianqi Chen. &lt;a href=&quot;https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf&quot;&gt;&lt;em&gt;&lt;span&gt;Introduction to Boosted Trees&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34534004&quot;&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/34534004&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/&quot;&gt;&lt;span&gt;https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/52672116/what-is-xgboost-pruning-step-doing&quot;&gt;&lt;span&gt;https://stackoverflow.com/questions/52672116/what-is-xgboost-pruning-step-doing&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;附录-泰勒公式&quot;&gt;附录： 泰勒公式&lt;/h3&gt;
&lt;p&gt;XGBoost 推导的关键一步是二阶泰勒展开，这里作一下拓展。泰勒公式的简单解释就是用多项式函数去逼近原函数，因为用多项式函数往往求解更加容易，而多项式中各项的系数则为原函数在某一点的n阶导数值除以n阶乘。这里力荐 &lt;a href=&quot;http://www.3blue1brown.com/&quot;&gt;&lt;span&gt;3Blue1Brown&lt;/span&gt;&lt;/a&gt; 关于泰勒公式的视频 &lt;a href=&quot;https://www.bilibili.com/video/av11251323/&quot;&gt;&lt;span&gt;微积分的本质 - 泰勒级数&lt;/span&gt;&lt;/a&gt; ，讲得非常形象 。&lt;/p&gt;
&lt;p&gt;已知函数 &lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(x=x_0\)&lt;/span&gt; 处n阶可导，那么：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{aligned} f(x) &amp;amp;= f(x_0) + f'(x_0)(x-x_0) + \frac{f''(x_0)}{2!}(x-x_0)^2 + \cdots + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \\ &amp;amp; = \sum\limits_{n=0}^{\infty}\frac{f^{(n)}x_0}{n!}(x - x_0)^n \end{aligned} \]&lt;/span&gt;&lt;br/&gt;例如，&lt;span class=&quot;math inline&quot;&gt;\(x_0 = 0, \;\; f(x) = e^x\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(e^x = \sum\limits_{n=0}^{\infty}\frac{x^n}{n!} = 1+x+\frac{x^2}{2!} + \frac{x^3}{3!} + \cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在机器学习中泰勒公式的一个典型应用就是牛顿法。在牛顿法中，将损失函数 &lt;span class=&quot;math inline&quot;&gt;\(L(\theta)\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(\theta^{k}\)&lt;/span&gt; 处进行二阶泰勒展开(考虑 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 为标量)：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(\theta) =L(\theta^k) + L'(\theta^k)(\theta - \theta^k) + \frac{L''(\theta^k)}{2}(\theta - \theta^k)^2 \]&lt;/span&gt;&lt;br/&gt;将一阶导和二阶导分别记为 &lt;span class=&quot;math inline&quot;&gt;\(g_k\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(h_k\)&lt;/span&gt;，为使上式最小化，令&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial\left[g(\theta - \theta^k) + \frac{h}{2}(\theta - \theta^k)^2\right]}{\partial \,\theta} = 0, \qquad 求得\; \theta-\theta^k = -\frac{g_k}{h_k}\;, \]&lt;/span&gt;&lt;br/&gt;则参数更新公式为 &lt;span class=&quot;math inline&quot;&gt;\(\theta^{k+1} = \theta^k - \frac{g_k}{h_k} \;\)&lt;/span&gt;，推广到向量形式则为 &lt;span class=&quot;math inline&quot;&gt;\(\boldsymbol{\theta}^{k+1} = \boldsymbol{\theta}^k - \mathbf{H}^{-1}_k\mathbf{g}_k\;\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{H}_k\)&lt;/span&gt; 为海森矩阵(Hessian matrix)，&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{g}_k\)&lt;/span&gt; 为梯度向量：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \nabla_\theta L = \mathbf{g}_k = \begin {bmatrix} \frac{\partial L}{\partial \theta_1}\\ \frac{\partial L}{\partial\theta_2}\\ \vdots \\ \frac{\partial L}{\partial\theta_n} \end {bmatrix} \;\;,\;\; \nabla_{\theta}^2 L = \mathbf{H}_k = \begin {bmatrix} \frac{\partial^2 L}{\partial\, \theta_1^2} &amp;amp; \frac{\partial^2 L}{\partial\,\theta_1 \partial\,\theta_2} &amp;amp; \cdots &amp;amp; \frac{\partial^2 L}{\partial\,\theta_1 \partial\,\theta_n} \\ \frac{\partial^2 L}{\partial\,\theta_2 \partial\,\theta_1} &amp;amp; \frac{\partial^2 L}{\partial\, \theta_2^2} &amp;amp; \cdots &amp;amp; \frac{\partial^2 L}{\partial\,\theta_2 \partial\,\theta_n} \\ \vdots &amp;amp; \vdots &amp;amp; \ddots \\ \frac{\partial^2 L}{\partial\,\theta_n \partial\,\theta_1} &amp;amp; \frac{\partial^2 L}{\partial\,\theta_n \partial\,\theta_2} &amp;amp; \cdots &amp;amp; \frac{\partial^2 L}{\partial\, \theta_n^2} \end {bmatrix} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;/&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 22:53:00 +0000</pubDate>
<dc:creator>massquantity</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/massquantity/p/9794480.html</dc:identifier>
</item>
<item>
<title>SmartSql 常见问题 - Ahoo-Wang</title>
<link>http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-common-problem.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-common-problem.html</guid>
<description>&lt;h2 id=&quot;为什么不支持-linq&quot;&gt;为什么不支持 Linq?&lt;/h2&gt;
&lt;p&gt;SmartSql 希望 开发人员更多的接触 Sql ,获得绝对的控制权与安全感。所以目前没有计划支持 Code First 编程模式。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我想好了Sql怎么写，然后再来写Linq,完了可能还要再查看一下Linq输出的Sql是什么样的，这真是糟糕的体验。要想对Sql做绝对的优化，那么开发者必须对Sql有绝对的控制权。另外Sql本身很简单，为何要增加一层翻译器呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;Codefirst 一个美好，却不切实际的想法。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;对smartsql很感兴趣不知从何开始&quot;&gt;对SmartSql很感兴趣，不知从何开始？&lt;/h2&gt;
&lt;p&gt;请阅读示例项目：&lt;a href=&quot;https://github.com/Ahoo-Wang/SmartSql-Starter&quot; class=&quot;uri&quot;&gt;https://github.com/Ahoo-Wang/SmartSql-Starter&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;smartsql支持哪些数据库&quot;&gt;SmartSql支持哪些数据库？&lt;/h2&gt;
&lt;p&gt;只要是实现了ADO.NET的数据库驱动的数据库均支持，您只需要安装好对应的驱动即可。&lt;/p&gt;
&lt;h2 id=&quot;smartsql是否支持多数据库&quot;&gt;SmartSql是否支持多数据库？&lt;/h2&gt;
&lt;p&gt;支持，可以通过配置引入多个数据库实例：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var sqlServerMapper = MapperContainer.Instance.GetSqlMapper(&quot;SmartSqlMapConfig-SqlServer.xml&quot;);
var mySqlMapepr = MapperContainer.Instance.GetSqlMapper(&quot;SmartSqlMapConfig-MySql.xml&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;smartsql性能如何&quot;&gt;SmartSql性能如何？&lt;/h2&gt;
&lt;p&gt;SmartSql的性能与Dapper是保存同一级别的≈原生手写（另外多个其他ORM在自己的测试报告中写明比Dapper性能还高，&lt;strong&gt;请同学们保持好奇&lt;/strong&gt;），文档中的 SmartSql 性能对比测试报告是开放了源代码的，任何对于性能感兴趣的同学均可以clone源代码自己跑一遍性能测试。&lt;strong&gt;自己Run的性能测试才是真的测试！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;smartsql可用性如何&quot;&gt;SmartSql可用性如何？&lt;/h2&gt;
&lt;p&gt;SmartSql 已历经1年多的线上数十个微服务场景验证，其性能、可用性、生产力是得到验证的。&lt;/p&gt;
&lt;h2 id=&quot;对于简单curd配置&quot;&gt;对于简单CURD配置&lt;/h2&gt;
&lt;p&gt;作者还开源了一个代码生成器项目：SmartCode: &lt;a href=&quot;https://github.com/Ahoo-Wang/SmartCode&quot; class=&quot;uri&quot;&gt;https://github.com/Ahoo-Wang/SmartCode&lt;/a&gt; ,可以使用SmartCode生成解决方案，包括所有CURD操作的XML/Entity/IRepository!&lt;/p&gt;
&lt;h2 id=&quot;为什么选择xml作为配置语法&quot;&gt;为什么选择Xml作为配置语法&lt;/h2&gt;
&lt;p&gt;Xml 的标签语法用起来会比较灵活. 比如 筛选标签,嵌套复用,可读性.&lt;br/&gt;复杂查询场景用起来会非常舒爽,可读性也会比较好,代码层面不需要做任何处理,全部交给Xml .&lt;/p&gt;
&lt;h2 id=&quot;集群场景如何使用获得缓存一致性&quot;&gt;集群场景如何使用获得缓存一致性&lt;/h2&gt;
&lt;p&gt;SmartSql提供了Redis缓存插件,可通过NuGet安装:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package SmartSql.Cache.Redis&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;集群场景中sql配置很多copy怎么办&quot;&gt;集群场景中Sql配置很多Copy怎么办&lt;/h2&gt;
&lt;p&gt;SmartSql 提供了 ZooKeeper配置插件,通过NuGet安装:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Install-Package SmartSql.ZooKeeperConfig&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;另外作者还开源了ZooKeeper节点管理工具:&lt;a href=&quot;https://github.com/Ahoo-Wang/ZooKeeper-Admin&quot;&gt;ZooKeeper-Admin&lt;/a&gt;,可直接通过该管理工具直接配置. 关于&lt;a href=&quot;https://github.com/Ahoo-Wang/ZooKeeper-Admin&quot;&gt;ZooKeeper-Admin&lt;/a&gt;:&lt;/li&gt;
&lt;li&gt;使用 Asp.net Core 编写&lt;/li&gt;
&lt;li&gt;Docker安装:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;docker pull ahoowang/zookeeper.admin
docker run --name zooAdmin -p 80:80 ahoowang/zookeeper.admin&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;本地安装&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;git clone https://github.com/Ahoo-Wang/ZooKeeper-Admin.git
dotnet run&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;我之前使用过mybatis感觉smartsql有种似曾相识的感觉&quot;&gt;我之前使用过MyBatis,感觉SmartSql有种似曾相识的感觉&lt;/h2&gt;
&lt;p&gt;是的,SmartSql编程模型多处借鉴了MyBatis,如果你之前使用过MyBatis,那么SmartSql将是你更好的选择,因为你几乎不需要有任何编程方式的转变就可以直接上手,并且拥有跨平台,高性能,以及众多你插件的支持.&lt;/p&gt;
&lt;h2 id=&quot;手写xml-很痛苦是否有智能提示&quot;&gt;手写Xml 很痛苦是否有智能提示&lt;/h2&gt;
&lt;p&gt;SmartSql 提供了Xml架构文档,可以获得输入智能提示的体验:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/457833/201810/457833-20181015230614526-556785279.png&quot; alt=&quot;智能提示&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 15:05:00 +0000</pubDate>
<dc:creator>Ahoo-Wang</dc:creator>
<og:description>常见问题 为什么不支持 Linq? SmartSql 希望 开发人员更多的接触 Sql ,获得绝对的控制权与安全感。所以目前没有计划支持 Code First 编程模式。 我想好了Sql怎么写，然后再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ahoo-Wang/p/SmartSql-common-problem.html</dc:identifier>
</item>
<item>
<title>刨根问底KVO原理 - Vanch</title>
<link>http://www.cnblogs.com/vanch/p/9795279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vanch/p/9795279.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;KVO( &lt;code&gt;NSKeyValueObserving&lt;/code&gt; )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改被观察者代码，利用 &lt;code&gt;runtime&lt;/code&gt; 实现运行中修改某一实例达到目的，保证了未侵入性。&lt;/p&gt;
&lt;p&gt;A对象指定观察B对象的属性后，当属性发生变更，A对象会收到通知，获取变更前以及变更的状态，从而做进一步处理。&lt;/p&gt;
&lt;p&gt;在实际生产环境中，多用于应用层观察模型层数据变动，接收到通知后更新，从而达成比较好的设计模式。&lt;/p&gt;
&lt;p&gt;另一种常用的用法是 &lt;code&gt;Debug&lt;/code&gt;，通过观察问题属性的变化，追踪问题出现的堆栈，更有效率的解决问题。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;
&lt;h3 id=&quot;观察回调&quot;&gt;观察回调&lt;/h3&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)observeValueForKeyPath:(nullable NSString *)keyPath 
                      ofObject:(nullable id)object 
                        change:(nullable NSDictionary&amp;lt;NSKeyValueChangeKey, id&amp;gt; *)change 
                       context:(nullable void *)context;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察者需要实现这个方法来接受回调，其中&lt;code&gt;keyPath&lt;/code&gt; 是 &lt;code&gt;KVC&lt;/code&gt; 路径， &lt;code&gt;object&lt;/code&gt; 是观察者，&lt;code&gt;context&lt;/code&gt; 区分不同观察的标识。&lt;/p&gt;
&lt;h4 id=&quot;改变字典&quot;&gt;改变字典&lt;/h4&gt;
&lt;p&gt;最关键的是改变字典，其中包含了 &lt;code&gt;NSKeyValueChangeKey&lt;/code&gt;，通过预定义的字符串来获取特定的数值。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;typedef NSString * NSKeyValueChangeKey NS_STRING_ENUM;

FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeKindKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNewKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeOldKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeIndexesKey;
FOUNDATION_EXPORT NSKeyValueChangeKey const NSKeyValueChangeNotificationIsPriorKey&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeKindKey&lt;/code&gt; 中定义的是改变的类型，如果调用的是&lt;code&gt;Setter&lt;/code&gt;方法，那就是&lt;code&gt;NSKeyValueChangeSetting&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;剩余的三种分别是插入、删除、替换，当观察的属性属于集合类（这点会在之后讲），变动时就会通知这些类型。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;typedef NS_ENUM(NSUInteger, NSKeyValueChange) {
    NSKeyValueChangeSetting = 1,
    NSKeyValueChangeInsertion = 2,
    NSKeyValueChangeRemoval = 3,
    NSKeyValueChangeReplacement = 4,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeNewKey&lt;/code&gt; 获取变更的最新值，&lt;code&gt;NSKeyValueChangeOldKey&lt;/code&gt; 获取原始数值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeIndexesKey&lt;/code&gt; 如果观察的是集合，那这个键值返回索引集合。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueChangeNotificationIsPriorKey&lt;/code&gt; 如果设置了接受提前通知，那么修改之前会先发送通知，修改后再发一次。为了区分这两次，第一次会带上这个键值对，其内容为 &lt;code&gt;@1&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;字符串枚举&quot;&gt;字符串枚举&lt;/h4&gt;
&lt;p&gt;在注册类型时，苹果使用了&lt;code&gt;NS_STRING_ENUM&lt;/code&gt;宏。&lt;/p&gt;
&lt;p&gt;虽然这个宏在&lt;code&gt;ObjC&lt;/code&gt;下毫无作用，但是对于&lt;code&gt;Swift&lt;/code&gt;有优化&lt;br/&gt;，上面的定义会变成这样。&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;enum NSKeyValueChangeKey: String { 
    case kind
    case new
    case old
    case indexes 
    case notificationIsPrior
}
let dict: [NSKeyValueChangeKey : Any] = [......]
let kind = dict[.kind] as! Number&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符串枚举对于使用来说是非常直观和安全的。&lt;/p&gt;
&lt;h3 id=&quot;添加与删除&quot;&gt;添加与删除&lt;/h3&gt;
&lt;p&gt;对于普通对象，使用这两个方法就能注册与注销观察。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)addObserver:(NSObject *)observer 
         forKeyPath:(NSString *)keyPath 
            options:(NSKeyValueObservingOptions)options 
            context:(nullable void *)context;

- (void)removeObserver:(NSObject *)observer 
            forKeyPath:(NSString *)keyPath 
               context:(nullable void *)context;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以设置多种观察模式来匹配需求。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;typedef NS_OPTIONS(NSUInteger, NSKeyValueObservingOptions) {
    //可以收到新改变的数值
    NSKeyValueObservingOptionNew = 0x01,
    //可以收到改变前的数值
    NSKeyValueObservingOptionOld = 0x02,
    //addObserver后立刻触发通知，只有new，没有old
    NSKeyValueObservingOptionInitial = 0x04,
    //会在改变前与改变后发送两次通知
    //改变前的通知带有notificationIsPrior=@1，old
    NSKeyValueObservingOptionPrior = 0x08
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于不符合 &lt;code&gt;KVC&lt;/code&gt; 的访问器标准，苹果规定 &lt;code&gt;NSArray NSOrderedSet NSSet&lt;/code&gt; 不可以执行 &lt;code&gt;addObserver&lt;/code&gt; 方法，不然会抛出异常。针对 &lt;code&gt;NSArray&lt;/code&gt; 有特殊的方法，如下&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)addObserver:(NSObject *)observer 
 toObjectsAtIndexes:(NSIndexSet *)indexes 
         forKeyPath:(NSString *)keyPath 
            options:(NSKeyValueObservingOptions)options 
            context:(nullable void *)context;

- (void)removeObserver:(NSObject *)observer 
  fromObjectsAtIndexes:(NSIndexSet *)indexes 
            forKeyPath:(NSString *)keyPath 
               context:(nullable void *)context;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要的区别在于多了一个&lt;code&gt;ObjectsAtIndexes&lt;/code&gt;，其实做的事情是一样的，根据索引找到对象，再逐一建立观察关系。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;h3 id=&quot;runtime&quot;&gt;Runtime&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;NSKeyValueObserving&lt;/code&gt; 与 &lt;code&gt;NSKeyValueCoding&lt;/code&gt; 一起定义在 &lt;code&gt;Foundation&lt;/code&gt; 库，而这个库是不开源的，我们先从苹果开发者文档中获取信息。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Automatic key-value observing is implemented using a technique called isa-swizzling.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看描述猜测苹果应该是通过重新设置被观察者的 &lt;code&gt;Class&lt;/code&gt; (&lt;code&gt;isa&lt;/code&gt; 中包含 &lt;code&gt;Class&lt;/code&gt; 信息)，该类继承了原类并且重载属性的 &lt;code&gt;Setter&lt;/code&gt; 方法，添加发通知的操作达到目的。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;@interface ConcreteSubject : NSObject
@property (nonatomic, strong) id obj;
@end

ConcreteSubject *sub = [ConcreteSubject new];

NSLog(@&quot;%s&quot;, class_getName(object_getClass(sub)));
//改变前 outprint--&amp;gt; ConcreteSubject

[sub addObserver:self forKeyPath:@&quot;obj&quot; options:NSKeyValueObservingOptionNew context:nil];
//执行观察方法

NSLog(@&quot;%s&quot;, class_getName(object_getClass(sub)));
//改变后 outprint--&amp;gt; NSKVONotifying_ConcreteSubject
NSLog(@&quot;%s&quot;, class_getName(object_getClass(class_getSuperclass(cls))));
//获取超类名 outprint--&amp;gt; ConcreteSubject

NSLog(@&quot;%s&quot;, class_getName(sub.class));
//获取类名 outprint--&amp;gt; ConcreteSubject

class_getMethodImplementation(cls, @selector(setObj:));
//imp = (IMP)(Foundation`_NSSetObjectValueAndNotify)

class_getMethodImplementation(cls, @selector(class));
//imp = (IMP)(Foundation`NSKVOClass)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试了一下果然 &lt;code&gt;Class&lt;/code&gt; 被替换了，变成加了 &lt;code&gt;NSKVONotifying_&lt;/code&gt; 前缀的新类。&lt;/p&gt;
&lt;p&gt;新类继承自原类，但是这个类的 &lt;code&gt;class&lt;/code&gt; 方法返回的还是原类，这保证了外部逻辑完整。&lt;/p&gt;
&lt;h3 id=&quot;反编译源码&quot;&gt;反编译源码&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;Runtime&lt;/code&gt; ，我们只能知道 &lt;code&gt;KVO&lt;/code&gt; 使用了一个继承了原类的类，并且替换了原方法的实现，&lt;code&gt;setObj: = _NSSetObjectValueAndNotify&lt;/code&gt; &lt;code&gt;class = _NSKVOClass&lt;/code&gt;。如果我们想进一步了解详情，只能通过反编译 &lt;code&gt;Foundation&lt;/code&gt; 来查找汇编代码。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里我使用了 &lt;code&gt;Hopper&lt;/code&gt; 工具，分析的二进制文件路径是/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/Frameworks/Foundation.framework/Foundation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;替换的实现&quot;&gt;替换的实现&lt;/h3&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
void _NSKVOClass(id self,  SEL _cmd) {
    Class cls = object_getClass(self);
    Class originCls = __NSKVONotifyingOriginalClassForIsa(cls);
    if (cls != originCls) {
        return [originCls class];
    } else {
        Method method = class_getInstanceMethod(cls, _cmd);
        return method_invoke(self, method);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看原 &lt;code&gt;class&lt;/code&gt; 方法，获取了当前类和原类，如果不一致就返回原类，如果一致就执行原 &lt;code&gt;class&lt;/code&gt; 实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
void __NSSetObjectValueAndNotify(id self, SEL _cmd, id value) {
    //获取额外的变量
    void *indexedIvars = object_getIndexedIvars(object_getClass(self));
    //加锁
    pthread_mutex_lock(indexedIvars + 0x20);
    //从SEL获取KeyPath
    NSString *keyPath = [CFDictionaryGetValue(*(indexedIvars) + 0x18), _cmd) copyWithZone:0x0];
    //解锁
    pthread_mutex_unlock(indexedIvars + 0x20);
    
    //改变前发通知
    [self willChangeValueForKey:keyPath];
    //实现Setter方法
    IMP imp = class_getMethodImplementation(*indexedIvars, _cmd);
    (imp)(self, _cmd, value);
    //改变后发通知
    [self didChangeValueForKey:keyPath];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看改变后的 &lt;code&gt;Setter&lt;/code&gt; 方法，其中 &lt;code&gt;indexedIvars&lt;/code&gt; 是原类之外的成员变量，第一个指针是改变后的类，&lt;code&gt;0x20&lt;/code&gt; 的偏移量是线程锁，&lt;code&gt;0x18&lt;/code&gt; 地址储存了改变过的方法字典。&lt;/p&gt;
&lt;p&gt;在执行原方法实现前调用了 &lt;code&gt;willChangeValueForKey&lt;/code&gt; 发起通知，同样在之后调用 &lt;code&gt;didChangeValueForKey&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;添加观察方法&quot;&gt;添加观察方法&lt;/h3&gt;
&lt;p&gt;那么是在哪个方法中替换的实现呢？先看 &lt;code&gt;[NSObject addObserver:forKeyPath:options:context:]&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
void -[NSObject addObserver:forKeyPath:options:context:]
(void * self, void * _cmd, void * arg2, void * arg3, unsigned long long arg4, void * arg5) {
    pthread_mutex_lock(__NSKeyValueObserverRegistrationLock);
    *__NSKeyValueObserverRegistrationLockOwner = pthread_self();
    rax = object_getClass(self);
    rax = _NSKeyValuePropertyForIsaAndKeyPath(rax, arg3);
    [self _addObserver:arg2 forProperty:rax options:arg4 context:arg5];
    *__NSKeyValueObserverRegistrationLockOwner = 0x0;
    pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock);
    
    return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法很简单，根据 &lt;code&gt;KeyPath&lt;/code&gt; 获取具体属性后进一步调用方法。由于这个方法比较长，我特地整理成 &lt;code&gt;ObjC&lt;/code&gt; 代码，方便大家理解。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
- (void *)_addObserver:(id)observer 
           forProperty:(NSKeyValueProperty *)property 
               options:(NSKeyValueObservingOptions)option 
               context:(void *)context {
    //需要注册通知
    if (option &amp;amp; NSKeyValueObservingOptionInitial) {
        //获取属性名路径
        NSString *keyPath = [property keyPath];
        //解锁
        pthread_mutex_unlock(__NSKeyValueObserverRegistrationLock);
        //如果注册了获得新值，就获取数值
        id value = nil;
        if (option &amp;amp; NSKeyValueObservingOptionNew) {
            value = [self valueForKeyPath:keyPath];
            if (value == nil) {
                value = [NSNull null];
            }
        }
        //发送注册通知
        _NSKeyValueNotifyObserver(observer, keyPath, self, context, value, 
        0 /*originalObservable*/, 1 /*NSKeyValueChangeSetting*/);
        //加锁
        pthread_mutex_lock(__NSKeyValueObserverRegistrationLock);
    } 
    //获取属性的观察信息
    Info *info = __NSKeyValueRetainedObservationInfoForObject(self, property-&amp;gt;_containerClass);
    //判断是否需要获取新的数值
    id _additionOriginalObservable = nil;
    if (option &amp;amp; NSKeyValueObservingOptionNew) {
        //0x15没有找到定义，猜测为保存是否可观察的数组

        id tsd = _CFGetTSD(0x15);
        if (tsd != nil) {
            _additionOriginalObservable = *(tsd + 0x10);
        }
    }
    //在原有信息上生成新的信息
    Info *newInfo = __NSKeyValueObservationInfoCreateByAdding
    (info, observer, property, option, context, _additionOriginalObservable, 0, 1);
    //替换属性的观察信息
    __NSKeyValueReplaceObservationInfoForObject(self, property-&amp;gt;_containerClass, info, newInfo);
    //属性添加后递归添加关联属性
    [property object:self didAddObservance:newInfo recurse:true];
    //获取新的isa
    Class cls = [property isaForAutonotifying];
    if ((cls != NULL) &amp;amp;&amp;amp; (object_getClass(self) != cls)) {
        //如果是第一次就替换isa
        object_setClass(self, cls);
    }
    //释放观察信息
    [newInfo release];
    if (info != nil) {
        [info release];
    }
    return;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中有可能替换方法实现的步骤是获取 &lt;code&gt;isa&lt;/code&gt; 的时候，猜测当第一次创建新类的时候，会注册新的方法，接着追踪 &lt;code&gt;isaForAutonotifying&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;获取观察类&quot;&gt;获取观察类&lt;/h3&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;void * -[NSKeyValueUnnestedProperty _isaForAutonotifying]
    (void * self, void * _cmd) {
    rbx = self;
    r14 = *_OBJC_IVAR_$_NSKeyValueProperty._containerClass;
    if ([*(rbx + r14)-&amp;gt;_originalClass 
        automaticallyNotifiesObserversForKey:rbx-&amp;gt;_keyPath] != 0x0) {
            r14 = __NSKeyValueContainerClassGetNotifyingInfo(*(rbx + r14));
            if (r14 != 0x0) {
                    __NSKVONotifyingEnableForInfoAndKey(r14, rbx-&amp;gt;_keyPath);
                    rax = *(r14 + 0x8);
            }
            else {
                    rax = 0x0;
            }
    }
    else {
            rax = 0x0;
    }
    return rax;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;立刻发现了熟悉的方法！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;automaticallyNotifiesObserversForKey:&lt;/code&gt; 是一个类方法，如果你不希望某个属性被观察，那么就设为 &lt;code&gt;NO&lt;/code&gt;，&lt;code&gt;isa&lt;/code&gt; 返回是空也就宣告这次添加观察失败。&lt;/p&gt;
&lt;p&gt;如果一切顺利的话，将会执行&lt;code&gt;__NSKVONotifyingEnableForInfoAndKey(info, keyPath)&lt;/code&gt; 改变 &lt;code&gt;class&lt;/code&gt; 的方法，最终返回其 &lt;code&gt;isa&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;实质替换方法&quot;&gt;实质替换方法&lt;/h3&gt;
&lt;p&gt;由于该方法实在太长，且使用了&lt;code&gt;goto&lt;/code&gt;不方便阅读，所以依旧整理成伪代码。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
int __NSKVONotifyingEnableForInfoAndKey(void *info, id keyPath) {
    //线程锁加锁
    pthread_mutex_lock(info + 0x20);
    //添加keyPath到数组
    CFSetAddValue(*(info + 0x10), keyPath);
    //解锁
    pthread_mutex_unlock(info + 0x20);
    //判断原类实现能不能替换
    Class originClass = *info;
    MethodClass *methodClass = 
    __NSKeyValueSetterForClassAndKey(originClass, keyPath, originClass);
    if (![methodClass isKindOfClass:[NSKeyValueMethodSetter class]]) {
        swizzleMutableMethod(info, keyPath);
        return;
    }
    //判断Setter方法返回值
    Method method = [methodClass method];
    if (*(int8_t *)method_getTypeEncoding(method) != _C_VOID) {
        _NSLog(@&quot;KVO autonotifying only supports -set&amp;lt;Key&amp;gt;: methods that return void.&quot;);
        swizzleMutableMethod(info, keyPath);
        return;
    }
    //获取Setter方法参数
    char *typeEncoding = method_copyArgumentType(method, 0x2);
    char type = sign_extend_64(*(int8_t *)typeEncoding);
    SEL sel;//根据参数类型选择替换的方法
    switch (type) {
        case _C_BOOL: sel = __NSSetBoolValueAndNotify;
        case _C_UCHR: sel = __NSSetUnsignedCharValueAndNotify;
        case _C_UINT: sel = __NSSetUnsignedIntValueAndNotify;
        case _C_ULNG: sel = __NSSetUnsignedLongValueAndNotify;
        case _C_ULNG_LNG: sel = __NSSetUnsignedLongLongValueAndNotify;
        case _C_CHR: sel = __NSSetCharValueAndNotify;
        case _C_DBL: sel = __NSSetDoubleValueAndNotify;
        case _C_FLT: sel = __NSSetFloatValueAndNotify;
        case _C_INT: sel = __NSSetIntValueAndNotify;
        case _C_LNG: sel = __NSSetLongValueAndNotify;
        case _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify;
        case _C_SHT: sel = __NSSetShortValueAndNotify;
        case _C_USHT: sel = __NSSetUnsignedShortValueAndNotify;
        case _C_LNG_LNG: sel = __NSSetLongLongValueAndNotify;
        case _C_ID: sel = __NSSetObjectValueAndNotify;
        case &quot;{CGPoint=dd}&quot;: sel = __NSSetPointValueAndNotify;
        case &quot;{_NSRange=QQ}&quot;: sel = __NSSetRangeValueAndNotify;
        case &quot;{CGRect={CGPoint=dd}{CGSize=dd}}&quot;: sel = __NSSetRectValueAndNotify;
        case &quot;{CGSize=dd}&quot;: sel = __NSSetSizeValueAndNotify;
        case *_NSKeyValueOldSizeObjCTypeName: sel = __CF_forwarding_prep_0;
        default;
    }
    //不支持的参数类型打印错误信息
    if (sel == NULL) {
        _NSLog(@&quot;KVO autonotifying only supports -set&amp;lt;Key&amp;gt;: methods that take id,
        NSNumber-supported scalar types, and some NSValue-supported structure types.&quot;)
        swizzleMutableMethod(info, keyPath);
        return;
    }
    //替换方法实现
    SEL methodSel = method_getName(method);
    _NSKVONotifyingSetMethodImplementation(info, methodSel, sel, keyPath);
    if (sel == __CF_forwarding_prep_0) {
        _NSKVONotifyingSetMethodImplementation(info, @selector(forwardInvocation:), 
         _NSKVOForwardInvocation, false);
        Class cls = *(info + 0x8);
        SEL newSel = sel_registerName(&quot;_original_&quot; + sel_getName(methodSel));
        Imp imp = method_getImplementation(method);
        TypeEncoding type = method_getTypeEncoding(method);
        class_addMethod(cls, newSel, imp, type);
    }
    swizzleMutableMethod(info, keyPath);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以表述为根据 &lt;code&gt;Setter&lt;/code&gt; 方法输入参数类型，匹配合适的 &lt;code&gt;NSSetValueAndNotify&lt;/code&gt; 实现来替换，从而实现效果。&lt;/p&gt;
&lt;p&gt;那么 &lt;code&gt;swizzleMutableMethod&lt;/code&gt; 是干嘛的呢？&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//替换可变数组集合的方法
int swizzleMutableMethod(void *info, id keyPath) {
    //NSKeyValueArray
    CFMutableSetRef getterSet = __NSKeyValueMutableArrayGetterForIsaAndKey(*info, keyPath);
    if ([getterSet respondsToSelector:mutatingMethods]) {
        mutatingMethods methodList = [getterSet mutatingMethods];
        replace methodList-&amp;gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify
        replace methodList-&amp;gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify
        replace methodList-&amp;gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify
        replace methodList-&amp;gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify
    }
    //NSKeyValueOrderedSet
    getterSet = __NSKeyValueMutableOrderedSetGetterForIsaAndKey(*info, keyPath);
    if ([getterSet respondsToSelector:mutatingMethods]) {
        mutatingMethods methodList = [getterSet mutatingMethods];
        replace methodList-&amp;gt;insertObjectAtIndex _NSKVOInsertObjectAtIndexAndNotify
        replace methodList-&amp;gt;insertObjectsAtIndexes _NSKVOInsertObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;removeObjectAtIndex _NSKVORemoveObjectAtIndexAndNotify
        replace methodList-&amp;gt;removeObjectsAtIndexes _NSKVORemoveObjectsAtIndexesAndNotify
        replace methodList-&amp;gt;replaceObjectAtIndex _NSKVOReplaceObjectAtIndexAndNotify
        replace methodList-&amp;gt;replaceObjectsAtIndexes _NSKVOReplaceObjectsAtIndexesAndNotify
    }
    //NSKeyValueSet
    getterSet = __NSKeyValueMutableSetGetterForClassAndKey(*info, keyPath);
    if ([getterSet respondsToSelector:mutatingMethods]) {
        mutatingMethods methodList = [getterSet mutatingMethods];
        replace methodList-&amp;gt;addObject _NSKVOAddObjectAndNotify
        replace methodList-&amp;gt;intersectSet _NSKVOIntersectSetAndNotify
        replace methodList-&amp;gt;minusSet _NSKVOMinusSetAndNotify
        replace methodList-&amp;gt;removeObject _NSKVORemoveObjectAndNotify
        replace methodList-&amp;gt;unionSet _NSKVOUnionSetAndNotify
    }
    //改变新类的方法缓存
    __NSKeyValueInvalidateCachedMutatorsForIsaAndKey(*(info + 0x8), keyPath);
    return rax;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面提到的都是一对一，那如果我想观察一对多的集合类呢？就是通过 &lt;code&gt;KVC&lt;/code&gt; 中的 &lt;code&gt;mutableArrayValueForKey:&lt;/code&gt; 返回一个代理集合，改变这些代理类的实现做到的。具体的例子之后会介绍。&lt;/p&gt;
&lt;h3 id=&quot;创建新类&quot;&gt;创建新类&lt;/h3&gt;
&lt;p&gt;还有一个疑问就是替换的类是怎么创建的？具体方法在 &lt;code&gt;__NSKVONotifyingEnableForInfoAndKey&lt;/code&gt; 中实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码，仅供理解
int __NSKVONotifyingCreateInfoWithOriginalClass(Class cls) {
    //拼接新名字
    const char *name = class_getName(cls);
    int length = strlen(r12) + 0x10;//16是NSKVONotifying_的长度
    char *newName = malloc(length);
    __strlcpy_chk(newName, &quot;NSKVONotifying_&quot;, length, -1);
    __strlcat_chk(newName, name, length, -1);
    //生成一个继承原类的新类
    Class newCls = objc_allocateClassPair(cls, newName, 0x68);
    free(newName);
    if (newCls != NULL) {
        objc_registerClassPair(newCls);
        //获取额外的实例变量表
        void *indexedIvars = object_getIndexedIvars(newCls);
        *indexedIvars = cls;            //记录原isa
        *(indexedIvars + 0x8) = newCls; //记录新isa
        //新建一个集合，保存观察的keyPath
        *(indexedIvars + 0x10) = CFSetCreateMutable(0x0, 0x0, _kCFCopyStringSetCallBacks);
        //新建一个字典，保存改变过的SEL
        *(indexedIvars + 0x18) = CFDictionaryCreateMutable(0x0, 0x0, 0x0,   
                                _kCFTypeDictionaryValueCallBacks);
        //新建一个线程锁
        pthread_mutexattr_init(var_38);
        pthread_mutexattr_settype(var_38, 0x2);
        pthread_mutex_init(indexedIvars + 0x20, var_38);
        pthread_mutexattr_destroy(var_38);
        //获取NSObject类默认的实现
        if (*__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectIMPLookupOnce == NULL) {
            static dispatch_once_t onceToken;
            dispatch_once(&amp;amp;onceToken, ^{
                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange = 
                class_getMethodImplementation([NSObject class],
                @selector(willChangeValueForKey:));

                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange = 
                class_getMethodImplementation([NSObject class], 
                @selector(didChangeValueForKey:));
            });
        }
        //设置是否替换过ChangeValue方法的flag
        BOOL isChangedImp = YES;
        if (class_getMethodImplementation(cls, @selector(willChangeValueForKey:)) == 
        *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectWillChange) {
            BOOL isChangedDidImp = 
                class_getMethodImplementation(cls, @selector(didChangeValueForKey:)) 
                != 
                *__NSKVONotifyingCreateInfoWithOriginalClass.NSObjectDidChange;
            isChangedImp = isChangedDidImp ? YES : NO;
        }
        *(int8_t *)(indexedIvars + 0x60) = isChangedImp;
        
        //使用KVO的实现替换原类方法
        _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(_isKVOA),
         _NSKVOIsAutonotifying, false/*是否需要保存SEL到字典*/);

        _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(dealloc), 
         _NSKVODeallocate, false);

        _NSKVONotifyingSetMethodImplementation(indexedIvars, @selector(class), 
         _NSKVOClass, false);
    }
    return newCls;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;建立关系&quot;&gt;建立关系&lt;/h3&gt;
&lt;p&gt;还有一种情况就是观察的属性依赖于多个关系，比如 &lt;code&gt;color&lt;/code&gt; 可能依赖于 &lt;code&gt;r g b a&lt;/code&gt;，其中任何一个改变，都需要通知 &lt;code&gt;color&lt;/code&gt; 的变化。&lt;/p&gt;
&lt;p&gt;建立关系的方法是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或 &lt;code&gt;+ (NSSet *)keyPathsForValuesAffecting&amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回依赖键值的字符串集合&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码
+ (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key {
    char *str = &quot;keyPathsForValuesAffecting&quot; + key;
    SEL sel = sel_registerName(str);
    Method method = class_getClassMethod(self, sel);
    if (method != NULL) {
        result = method_invoke(self, method);
    } else {
        result = [self _keysForValuesAffectingValueForKey:key];
    }
    return result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得之前在 &lt;code&gt;_addObserver&lt;/code&gt; 方法中有这段代码吗？&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//属性添加后递归添加关联属性
[property object:self didAddObservance:newInfo recurse:true];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;NSKeyValueProperty&lt;/code&gt; 也是一个类簇，具体分为 &lt;code&gt;NSKeyValueProperty NSKeyValueComputedProperty NSKeyValueUnnestedProperty NSKeyValueNestedProperty&lt;/code&gt;，从名字也看出 &lt;code&gt;NSKeyValueNestedProperty&lt;/code&gt; 是指嵌套子属性的属性类，那我们观察下他的实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;//伪代码
- (void)object:(id)obj didAddObservance:(id)info recurse:(BOOL)isRecurse {
    if (self-&amp;gt;_isAllowedToResultInForwarding != nil) {
        //获得关系键
        relateObj = [obj valueForKey:self-&amp;gt;_relationshipKey];
        //注册所有关系通知
        [relateObj addObserver:info 
                    forKeyPath:self-&amp;gt;_keyPathFromRelatedObject 
                       options:info-&amp;gt;options 
                       context:nil];
    } 
    //再往下递归
    [self-&amp;gt;_relationshipProperty object:obj didAddObservance:info recurse:isRecurse];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，实现的大致整体轮廓比较了解了，下面会讲一下怎么把原理运用到实际。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;应用原理&quot;&gt;应用原理&lt;/h2&gt;
&lt;h3 id=&quot;手动触发&quot;&gt;手动触发&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;+(BOOL)automaticallyNotifiesObserversForKey:(NSString *)key&lt;/code&gt; 返回是 &lt;code&gt;YES&lt;/code&gt;，那么注册的这个 &lt;code&gt;Key&lt;/code&gt; 就会替换对应的 &lt;code&gt;Setter&lt;/code&gt; ，从而在改变的时候调用 &lt;code&gt;-(void)willChangeValueForKey:(NSString *)key&lt;/code&gt; 与 &lt;code&gt;-(void)didChangeValueForKey:(NSString *)key&lt;/code&gt; 发送通知给观察者。&lt;/p&gt;
&lt;p&gt;那么只要把自动通知设为 &lt;code&gt;NO&lt;/code&gt;，并代码实现这两个通知方法，就可以达到手动触发的要求。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key {
    if ([key isEqualToString:@&quot;object&quot;]) {
        return false;
    }
    
    return [super automaticallyNotifiesObserversForKey:key];
}

- (void)setObject:(NSObject *)object {
    if (object != _object) {
        [self willChangeValueForKey:@&quot;object&quot;];
        _object = object;
        [self didChangeValueForKey:@&quot;object&quot;];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果操作的是之前提到的集合对象，那么实现的方法就需要变为&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)willChange:(NSKeyValueChange)changeKind 
   valuesAtIndexes:(NSIndexSet *)indexes 
            forKey:(NSString *)key;
- (void)didChange:(NSKeyValueChange)changeKind 
  valuesAtIndexes:(NSIndexSet *)indexes 
           forKey:(NSString *)key;

- (void)willChangeValueForKey:(NSString *)key 
              withSetMutation:(NSKeyValueSetMutationKind)mutationKind 
                 usingObjects:(NSSet *)objects;
- (void)didChangeValueForKey:(NSString *)key 
             withSetMutation:(NSKeyValueSetMutationKind)mutationKind 
                usingObjects:(NSSet *)objects;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依赖键观察&quot;&gt;依赖键观察&lt;/h3&gt;
&lt;p&gt;之前也有提过构建依赖关系的方法，具体操作如下&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;+ (NSSet&amp;lt;NSString *&amp;gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key {
    if ([key isEqualToString:@&quot;color&quot;]) {
        return [NSSet setWithObjects:@&quot;r&quot;,@&quot;g&quot;,@&quot;b&quot;,@&quot;a&quot;,nil];
    }
    
    return [super keyPathsForValuesAffectingValueForKey:key];
}

//建议使用静态指针地址作为上下文区分不同的观察
static void * const kColorContext = (void*)&amp;amp;kColorContext;
- (void)viewDidLoad {
    [super viewDidLoad];

    [self addObserver:self forKeyPath:@&quot;color&quot; 
              options:NSKeyValueObservingOptionNew 
              context:kColorContext];
    self.r = 133;
}

- (void)observeValueForKeyPath:(NSString *)keyPath 
                      ofObject:(id)object 
                        change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change 
                       context:(void *)context {
    if (context == kColorContext) {
        NSLog(@&quot;%@&quot;, keyPath); 
        //outprint --&amp;gt; color
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可变数组与集合&quot;&gt;可变数组与集合&lt;/h3&gt;
&lt;p&gt;不可变的数组与集合由于内部结构固定，所以只能通过观察容器类内存地址来判断是否变化，也就是 &lt;code&gt;NSKeyValueChangeSetting&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;集合和数组的观察都很类似，我们先关注如果要观察可变数组内部插入移除的变化呢？&lt;/p&gt;
&lt;p&gt;先了解一下集合代理方法，&lt;code&gt;- (NSMutableArray *)mutableArrayValueForKey:&lt;/code&gt;，这是一个 &lt;code&gt;KVC&lt;/code&gt; 方法，能够返回一个可供观察的 &lt;code&gt;NSKeyValueArray&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;根据苹果注释，其搜索顺序如下&lt;/p&gt;
&lt;p&gt;1.搜索是否实现最少一个插入与一个删除方法&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;-insertObject:in&amp;lt;Key&amp;gt;AtIndex:
-removeObjectFrom&amp;lt;Key&amp;gt;AtIndex:
-insert&amp;lt;Key&amp;gt;:atIndexes:
-remove&amp;lt;Key&amp;gt;AtIndexes:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.否则搜索是否有 &lt;code&gt;set&amp;lt;Key&amp;gt;:&lt;/code&gt; 方法，有的话每次都把修改数组重新赋值回原属性。&lt;/p&gt;
&lt;p&gt;3.否则检查 &lt;code&gt;+ (BOOL)accessInstanceVariablesDirectly&lt;/code&gt;，如果是&lt;code&gt;YES&lt;/code&gt;，就查找成员变量&lt;code&gt;_&amp;lt;key&amp;gt; or &amp;lt;key&amp;gt;&lt;/code&gt;，此后所有的操作针对代理都转接给成员变量执行。&lt;/p&gt;
&lt;p&gt;4.最后进入保护方法&lt;code&gt;valueForUndefinedKey:&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一种方法&quot;&gt;第一种方法&lt;/h4&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)insertObject:(NSObject *)object inDataArrayAtIndex:(NSUInteger)index {
    [_dataArray insertObject:object atIndex:index];
}

- (void)removeObjectFromDataArrayAtIndex:(NSUInteger)index {
    [_dataArray removeObjectAtIndex:index];
}

- (void)viewDidLoad {
    [super viewDidLoad];
    
    _dataArray = @[].mutableCopy;
    [self addObserver:self forKeyPath:@&quot;dataArray&quot; 
    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld |  
    NSKeyValueObservingOptionPrior context:nil];
    [self insertObject:@1 inDataArrayAtIndex:0];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过实现了&lt;code&gt;insert&lt;/code&gt;与&lt;code&gt;remove&lt;/code&gt;方法，使得代理数组能够正常运作数组变量，&lt;code&gt;KVO&lt;/code&gt; 观察了代理数组的这两个方法，发出了我们需要的通知。&lt;/p&gt;
&lt;p&gt;这种方式使用了第一步搜索，比较容易理解，缺点是改动的代码比较多，改动数组必须通过自定义方法。&lt;/p&gt;
&lt;h4 id=&quot;第二种方法&quot;&gt;第二种方法&lt;/h4&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;@property (nonatomic, strong, readonly) NSMutableArray *dataArray;

@synthesize dataArray = _dataArray;

- (NSMutableArray *)dataArray {
    return [self mutableArrayValueForKey:@&quot;dataArray&quot;];
}

- (void)viewDidLoad {
    [super viewDidLoad];

    _dataArray = @[].mutableCopy;
    [self addObserver:self forKeyPath:@&quot;dataArray&quot; 
    options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld |   
    NSKeyValueObservingOptionPrior context:nil];
    [self.dataArray addObject:@1];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式相对来说更简洁，修改数组的方法与平时一致，比较适合使用。&lt;/p&gt;
&lt;p&gt;下面说一下原理，首先我们没有实现对应的&lt;code&gt;insert&lt;/code&gt;与&lt;code&gt;remove&lt;/code&gt;方法，其次&lt;code&gt;readonly&lt;/code&gt;属性也没有&lt;code&gt;set&amp;lt;key&amp;gt;:&lt;/code&gt;方法，但我们实现了 &lt;code&gt;@synthesize dataArray = _dataArray;&lt;/code&gt; 所以根据第三步对代理数组的操作都会实际操作到实例变量中。&lt;/p&gt;
&lt;p&gt;然后重载了 &lt;code&gt;dataArray&lt;/code&gt; 的 &lt;code&gt;Getter&lt;/code&gt; 方法，保证了修改数组时必须调用主体是&lt;code&gt;self.dataArray&lt;/code&gt;，也就是代理数组，从而发送通知。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;问答&quot;&gt;问答&lt;/h2&gt;
&lt;h3 id=&quot;kvo的底层实现&quot;&gt;KVO的底层实现？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 就是通过 &lt;code&gt;Runtime&lt;/code&gt; 替换被观察类的 &lt;code&gt;Setter&lt;/code&gt; 实现，从而在发生改变时发起通知。&lt;/p&gt;
&lt;h3 id=&quot;如何取消系统默认的kvo并手动触发给kvo的触发设定条件改变的值符合某个条件时再触发kvo&quot;&gt;如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？&lt;/h3&gt;
&lt;p&gt;通过设置 &lt;code&gt;automaticallyNotifiesObserversForKey&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; 实现取消自动触发。&lt;/p&gt;
&lt;p&gt;符合条件再触发可以这么实现。&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;- (void)setObject:(NSObject *)object {
    if (object == _object) return;

    BOOL needNotify = [object isKindOfClass:[NSString class]];
    if (needNotify) {
        [self willChangeValueForKey:@&quot;object&quot;];    
    }
    _object = object;
    if (needNotify) {
        [self didChangeValueForKey:@&quot;object&quot;];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;由于对汇编语言、反编译工具、&lt;code&gt;objc4&lt;/code&gt;开源代码的不熟悉，这篇文章写了一周时间，结构也有点混乱。&lt;/p&gt;
&lt;p&gt;所幸还是理顺了整体结构，在整理的过程中学会了很多很多。&lt;/p&gt;
&lt;p&gt;由于才疏学浅，其中对汇编和源码的解释难免出错，还望大佬多多指教！&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;资料分享&quot;&gt;资料分享&lt;/h2&gt;
&lt;p&gt;ObjC中国的期刊 &lt;a href=&quot;https://objccn.io/issue-7-3/&quot;&gt;KVC和KVO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;杨大牛的 &lt;a href=&quot;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/&quot;&gt;Objective-C中的KVC和KVO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/45cbd324ea65&quot;&gt;iOS开发技巧系列---详解KVC(我告诉你KVC的一切)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 14:52:00 +0000</pubDate>
<dc:creator>Vanch</dc:creator>
<og:description>介绍 KVO( )是一种监测对象属性值变化的观察者模式机制。其特点是无需事先修改被观察者代码，利用 实现运行中修改某一实例达到目的，保证了未侵入性。 A对象指定观察B对象的属性后，当属性发生变更，A对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vanch/p/9795279.html</dc:identifier>
</item>
<item>
<title>让我头疼一下午的Excel合并单元格 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/excel_export.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/excel_export.html</guid>
<description>&lt;h3 id=&quot;excel导出常见问题&quot;&gt;Excel导出常见问题&lt;/h3&gt;
&lt;p&gt;excel导出其实不算什么难事&lt;/p&gt;
&lt;p&gt;在网上copy下模板代码，填充自己的业务数据，提供一个http接口基本就可以得到你要导出的数据了。&lt;/p&gt;
&lt;p&gt;但是，凡事都有例外，截止今天，excel导出我遇到的主要是两大类问题&lt;/p&gt;
&lt;p&gt;1、大数据量的excel数据，比如几十万条甚至更多的数据导出&lt;/p&gt;
&lt;p&gt;2、因为excel中内容的问题，导致导出后的excel不能直接打开，报错“由于一些内容不可取，Excel无法打开xxx.xlsx。是否要打开并修复此工作簿?”&lt;/p&gt;
&lt;p&gt;针对第一种大数据量问题，我遇到的主要问题是excel存储的记录上限和导出超时等问题&lt;/p&gt;
&lt;p&gt;解决方法是将导出格式为xls升级为xlsx，xls每个sheet最多支持65536条记录，xlsx最多支持1048576条记录；超时则可以采用前端直接返回，后端异步取数据并导出的方式避免超时。&lt;/p&gt;
&lt;p&gt;这种情况不是今天要介绍的重点，今天要介绍的第二种情况的解决思路。&lt;/p&gt;
&lt;h3 id=&quot;需求描述&quot;&gt;需求描述&lt;/h3&gt;
&lt;p&gt;1、层级关系最多为四级&lt;/p&gt;
&lt;p&gt;2、对于相同层级,如果内容相同需要纵向合并单元格，空白行不需要合并&lt;/p&gt;
&lt;p&gt;3、样例数据如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
一级目录1,二级目录1,三级目录1,四级目录2,

一级目录1,二级目录1,三级目录3,

一级目录1,二级目录1,三级目录5,

一级目录1,二级目录3,

一级目录1,二级目录5,三级目录5,

一级目录2,二级目录2,三级目录2,

一级目录2,二级目录2,三级目录3,

一级目录2,二级目录4,三级目录4,

一级目录2,二级目录7,

一级目录3,二级目录6,三级目录4,

一级目录3,二级目录6,三级目录10,

一级目录4,

一级目录5,二级目录8,三级目录6,
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解决思路&quot;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;将上面样例数据存入一个集合中，遍历每条记录并存放到相应的单元格。&lt;/p&gt;
&lt;p&gt;如果不需要合并单元格，到这里，就可以提供导出的Excel了。&lt;/p&gt;
&lt;p&gt;但是重点是合并单元格。&lt;/p&gt;
&lt;h3 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h3&gt;
&lt;h4 id=&quot;初步排查&quot;&gt;初步排查&lt;/h4&gt;
&lt;p&gt;自认为代码已经就位，调用接口，Excel文件也成功下载了，结果打开的那一刻一个对话框让我头疼了一下午。&lt;/p&gt;
&lt;p&gt;报错信息如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222634536-1927134110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一反应是肯定数据错乱了，估计是单元格之间相互挤占，数据肯定也是不堪入目。&lt;/p&gt;
&lt;p&gt;但是我按照智能的Excel提示，点击“打开并修复”后发现，数据没有我想的那么糟，甚至仔细看看，发现居然没有问题。&lt;/p&gt;
&lt;p&gt;有点小激动的同时，心里还是有点不爽，总不能让别人每次导出的时候都使用这个智能的“打开并修复”功能才能看导出的数据吧。&lt;/p&gt;
&lt;p&gt;但是光从这个报错信息来看确实没有什么线索，于是网上找了一通与“由于一些内容不可取，Excel无法打开xxx.xlsx。是否要打开并修复此工作簿?”有关的解决方法。虽然有不少人遇到过这样的问题，但是引起问题的原因不太一样，有些是因为sheet的命名包含特殊字符，有些是导出的Excel内容中有非法字符，还有说要在response的header中加入Content-length字段的。&lt;/p&gt;
&lt;h4 id=&quot;进一步排查&quot;&gt;进一步排查&lt;/h4&gt;
&lt;p&gt;搜了一通，没有什么进展，这时候想起来在刚刚点击“打开并修复”后，还弹出了一个对话框，于是点击对话框中的查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222643403-1930663000.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到线索如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;

&amp;lt;recoveryLog xmlns=&quot;http://schemas.openxmlformats.org/spreadsheetml/2006/main&quot;&amp;gt;&amp;lt;logFileName&amp;gt;修复结果到 xxx.xml&amp;lt;/logFileName&amp;gt;&amp;lt;summary&amp;gt;在文件“/Users/jackie/Downloads/xxx.xlsx”中检测到错误&amp;lt;/summary&amp;gt;&amp;lt;removedRecords summary=&quot;以下是已删除记录的列表:&quot;&amp;gt;&amp;lt;removedRecord&amp;gt;已删除的记录: /xl/worksheets/sheet1.xml 的 合并单元格&amp;lt;/removedRecord&amp;gt;&amp;lt;/removedRecords&amp;gt;&amp;lt;/recoveryLog&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;排除了前面提到的种种非法字符的原因，看到线索里的“合并单元格”，基本可以断定这是因为在合并单元格的过程中出了问题。&lt;/p&gt;
&lt;h4 id=&quot;寻找问题根本原因&quot;&gt;寻找问题根本原因&lt;/h4&gt;
&lt;p&gt;结合合并单元格导致Excel表格无法打开的症状在网上搜索一通&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/14/0107/11/14931240_343269914.shtml%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%99%E5%87%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF&quot; class=&quot;uri&quot;&gt;http://www.360doc.com/content/14/0107/11/14931240_343269914.shtml这篇文章给出了解决思路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我将下载的Excel表格的后缀从xlsx改为zip并打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222652560-1495620231.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开sheet1.xml文件，找到mergeCells标签，将其内容拷贝到XML在线格式化工具中查看&lt;/p&gt;
&lt;p&gt;经过人眼搜索，终于发现了问题所在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222700492-320280183.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    ...

    &amp;lt;mergeCell ref=&quot;B175:B189&quot;/&amp;gt;

    &amp;lt;mergeCell ref=&quot;B176:B190&quot;/&amp;gt;

    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里显然出现了&lt;strong&gt;覆盖合并&lt;/strong&gt;的情况，进而导致打开Excel报错的情况（后面经过测试发现，重复合并单元格也会出现同样的报错信息）&lt;/p&gt;
&lt;p&gt;顺着这个思路，排查代码，不断调试测试，考虑各种情况下的合并单元格场景，最终搞定了这个稍稍复杂的合并单元格的Excel导出功能。&lt;/p&gt;
&lt;h3 id=&quot;一点思考&quot;&gt;一点思考&lt;/h3&gt;
&lt;p&gt;虽然知道是合并单元格导致的问题，但是在实际调整代码时花费了几乎一个下午，曾经一度头大到不想思考。&lt;/p&gt;
&lt;p&gt;回头想想，在这个问题上有两大收获。&lt;/p&gt;
&lt;p&gt;1、排查问题的思路很重要&lt;/p&gt;
&lt;p&gt;问题的现象已经摆在眼前，排查了不是非法字符的原因，就应该寻找其他原因&lt;/p&gt;
&lt;p&gt;利用一切可以利用的手头信息比如上面简短而关键的报错日志信息。&lt;/p&gt;
&lt;p&gt;活用搜索引擎，这种问题肯定已经有前人踩过雷，去看下他们是怎么排雷的就好，不用自己再去研究排雷的具体方法了。&lt;/p&gt;
&lt;p&gt;2、写代码之前先想好&lt;/p&gt;
&lt;p&gt;现在想想这段合并单元格的代码是不是可以写的更加漂亮，我想应该是可以的，但是能不能从30行精简为10行甚至5行，我想这不太可能。&lt;/p&gt;
&lt;p&gt;因为这个导出合并时会遇到各种情况，比如连续相同的单元格何时合并，空白行如何保证不合并，某空白行区域前和后又如何实现合并等问题。&lt;/p&gt;
&lt;p&gt;所以，写这段代码前应该先梳理所有可能的场景包括一些特殊情况，尽其所能罗列所有的情况，这样才能保证在应对各种情形的数据时正常导出。&lt;/p&gt;
&lt;p&gt;代码稍后我会放到项目rome里&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/DMinerJackie/rome&quot; class=&quot;uri&quot;&gt;https://github.com/DMinerJackie/rome&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对了，导出效果图呈上&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201810/619240-20181015222716347-1419281418.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>Excel表格导出过很多次，这次栽倒在合并单元格手上，只好硬着头皮老老实实找出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/excel_export.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之八 ----- 责任链模式和命令模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9794886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9794886.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9704228.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了结构型模式的享元模式和代理模式。本篇则来学习下行为型模式的两个模式， 责任链模式(Chain of Responsibility Pattern)和命令模式（Command Pattern）。&lt;/p&gt;
&lt;h2 id=&quot;责任链模式&quot;&gt;责任链模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;责任链模式顾名思义，就是为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的理解的话就是进行层级处理。生活中比较常见的是请假、出差、加薪等申请等等，而工作中比较常见的就是拦截器和过滤器。如果请假申请是用以前的那种方式，发起者需要和每个负责人进行申请，会比较麻烦，但是现在一般是走OA流程，只需发起一个OA申请即可。这也是一种 这种就是典型的责任链模式，发起者只需将请求请求发送到职责链上即可，无需关心处理细节和请求的传递。&lt;/p&gt;
&lt;p&gt;责任链模式主要由这三个角色组成，请求接收者接口(Handler)、请求实现者类(ConcreteHandler)和请求发送者(Client)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求接收者接口：定义可以处理客户端请求事项的接口，包含“可链接下一个同样能处理请求”的对象引用。&lt;/li&gt;
&lt;li&gt;请求实现者类：实现请求处理接口，并判断对象本身是否能够处理本次请求，如果不能完成请求，则交由后继者来处理。&lt;/li&gt;
&lt;li&gt;请求发送者：将请求发送给第一个接收者对象，并等待请求的回复。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里为了方便理解，我们使用一个简单的示例来加以说明。&lt;br/&gt;在某公司的某个部门中，为了活跃部门气氛，主管便征求部门成员的意见，于是部门的成员踊跃提出建议，最终，主管采纳了 xuwujing 提倡的建议，并将此建议进行上报，申请活动经费。&lt;br/&gt;那么我们便可以根据这里例子来使用责任链模式进行开发，首先加速有三级的领导，他们有个共同的特性，就是可以处理各自级别的事情，那么我们便可以定义一个领导的抽象类，并定义一个抽象方法可以处理事情，并设置一个级别的参数，那么这个抽象类的代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
abstract class Learder{

   protected Learder learder;
   
   protected void setLearder(Learder learder){
       this.learder=learder;
   }
   
   protected Learder getLearder(){
       return learder;
   }
   
   abstract void handler(int  level);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义好该抽象类之后，我们需要设计不同的领导进行不同的处理，但是这些领导需要有个处理的能力，并且还要根据各自不同的权限进行处理，如果能够处理，到此流程就结束了，否则无法处理则转交给上级进行处理。&lt;br/&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Supervisor extends Learder{
    private String name;
    private String something;
    public Supervisor(String name,String something) {
       this.name=name;
       this.something=something;
   }
   
   @Override
   void handler(int level) {
       //如果级别在自己的处理范围之内
       if(level&amp;gt;1){
           System.out.println(&quot;主管同意了  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
       }else{
           System.out.println(&quot;主管未能处理  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!转交给上级!&quot;);
           getLearder().handler(level);
       }
   }
}


class BranchManager extends Learder{
    private String name;
    private String something;
    public BranchManager(String name,String something) {
       this.name=name;
       this.something=something;
   }
   
   @Override
   void handler(int level) {
       boolean flag=true;
       //如果级别在自己的处理范围之内
       if(level&amp;gt;0){
           //这就就直接设置同意了
           if(flag){
               System.out.println(&quot;部门经理同意了  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }else{
               System.out.println(&quot;部门经理不同意  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }
       }else{
           System.out.println(&quot;部门经理未能处理  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!转交给上级!&quot;);
           getLearder().handler(level);
       }
   }
}


class GeneralManager extends Learder{
    private String name;
    private String something;
    public GeneralManager(String name,String something) {
       this.name=name;
       this.something=something;
   }
   
   @Override
   void handler(int level) {
       boolean flag=false;
       //如果级别在自己的处理范围之内
       if(level&amp;gt;-1){
           //这就就直接设置不同意了
           if(flag){
               System.out.println(&quot;总经理同意了  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }else{
               System.out.println(&quot;总经理不同意  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!&quot;);
           }
           
       }else{
           System.out.println(&quot;总经理未能处理  &quot;+name+&quot;所述的&amp;lt;&quot;+something+&quot;&amp;gt;事情!转交给上级!&quot;);
           getLearder().handler(level);
       }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们再来根据所需要走的流程来进行代码测试。由于在编写请求类时，我们并未指定谁是谁的上级，所以这里我们需要指定上下级关系，让流程能够走下去。指定上级之后，我们再来设置处理该事件的级别，最后再来进行运行。&lt;br/&gt;那么测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
       String name = &quot;xuwujing&quot;;
       String something = &quot;去聚餐&quot;;
       String something2 = &quot;去旅游&quot;;
       Learder learder1 =new Supervisor(name, something);
       Learder learder2 =new BranchManager(name, something);
       Learder learder3 =new GeneralManager(name, something);
       learder1.setLearder(learder2);
       learder2.setLearder(learder3);
       learder1.handler(1);
       
       Learder learder4 =new Supervisor(name, something2);
       Learder learder5 =new BranchManager(name, something2);
       Learder learder6 =new GeneralManager(name, something2);
       learder4.setLearder(learder5);
       learder5.setLearder(learder6);
       learder4.handler(0);

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        主管未能处理  xuwujing所述的&amp;lt;去聚餐&amp;gt;事情!转交给上级!
        部门经理同意了  xuwujing所述的&amp;lt;去聚餐&amp;gt;事情!
        主管未能处理  xuwujing所述的&amp;lt;去旅游&amp;gt;事情!转交给上级!
        部门经理未能处理  xuwujing所述的&amp;lt;去旅游&amp;gt;事情!转交给上级!
        总经理不同意  xuwujing所述的&amp;lt;去旅游&amp;gt;事情!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;责任链模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;耦合度低，请求者和执行者并没有必然的联系；&lt;br/&gt;灵活度高，可以通过内部成员来进行更改它们执行的次序；&lt;br/&gt;扩展性好，Handler的子类扩展非常方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;责任链模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;会在某程度上降低程序的性能，设置不当的话可能会出现循环调用。&lt;br/&gt;在链过长时，会降低代码的阅读性以及增加代码的复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要动态指定处理某一组请求时，在不确定接受者的的情况下，向多个对象发送请求时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;虽然责任链模式很灵活，但是牺牲的是一定的性能，因为责任链模式是层级处理，在处理数据的有一定的延迟，所所以需要低延迟的情况下，不推荐使用责任链模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;命令模式&quot;&gt;命令模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;命令模式顾名思义，是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;br/&gt;也就是将一个请求封装成一个对象，从而可以用不同的请求对客户进行参数化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令模式主要由这三个角色组成，命令对象(command)、命令执行对象(received)和命令请求对象(invoker)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令对象：通过接口或抽象类声明实现的方法。&lt;/li&gt;
&lt;li&gt;命令执行对象：实现命令对象的方法，并将一个接收者和动作进行绑定，调用接收者相应的操作。&lt;/li&gt;
&lt;li&gt;命令请求对象：用于执行这个请求，可以动态的对命令进行控制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我们依旧用一个简单的示例来进行说明。&lt;br/&gt;在某个学校中，学生需要听从老师的命令，比如老师可以让学生去打扫教室卫生，去完成未做完的作业等等命令，但是学生的时间有限，只能在某个时间范围内完成某一件事情，此时刚好有两个老师对学生 xuwujing 说出了命令，李老师先让 xuwujing 在放学后打扫教室，王老师让 xuwujing 在回家前把未做完的作业做完并交给他，但是学校的门禁的时间有限，于是 xuwujing 就只 打扫了教室，然后开溜了。。。&lt;br/&gt;那么根据这个示例，我们可以使用命令模式来完成。&lt;br/&gt;首先，先定义一个学生类，并指定该学生可以做的事情。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Student{
    void cleanClassRoom(String name){
        System.out.println(name+&quot; 开始打扫教室...&quot;);
    }
    void doHomeWork(String name){
        System.out.println(name+&quot; 开始做作业...&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义一个 命令抽象类，并设置执行的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
abstract class Command{
    protected Student student;
    public Command(Student student){
        this.student = student;
    }
    abstract void execute(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继而再定义两个命令执行对象，分别设置所需执行的命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class LiTeacher extends Command{
    public LiTeacher(Student student) {
        super(student);
    }
    @Override
    void execute(String name) {
        student.cleanClassRoom(name);
    }
}

class WangTeacher extends Command{
    public WangTeacher(Student student) {
        super(student);
    }
    @Override
    void execute(String name) {
        student.doHomeWork(name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来定义一个命令请求对象，用于执行该请求，并对命令进行控制，比如新增命令、撤销命令和执行命令等等。&lt;br/&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class Invoker {
    private List&amp;lt;Command&amp;gt; commands = new ArrayList&amp;lt;Command&amp;gt;();
    
    public void setCommand(Command command) {
        if(commands.size()&amp;gt;0) {
            System.out.println(&quot;不执行 WangTeacher 的命令!&quot;);
        }else {
            commands.add(command);
        }
    }
    
    public void executeCommand(String name) {
        commands.forEach(command-&amp;gt;{
            command.execute(name);
        });
    }
    
    public void undoCommand(Command command) {
        commands.remove(command);
        System.out.println(&quot;撤销该命令!&quot;);
    }   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来进行代码的测试。&lt;br/&gt;测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
        String name = &quot;xuwujing&quot;;
        Student student = new  Student();
        Command command1 = new LiTeacher(student);
        Command command2 = new WangTeacher(student);
        Invoker invoker =new Invoker();
        invoker.setCommand(command1);
        invoker.setCommand(command2);
        invoker.executeCommand(name);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不执行 WangTeacher 的命令!
xuwujing 开始打扫教室...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;命令模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;耦合度低，请求者和执行者并没有必然的联系；&lt;br/&gt;扩展性好，Command的子类可以非常容易地扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;命令模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果命令过多的话，会增加系统的复杂度 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果在有类似&lt;code&gt;命令&lt;/code&gt;需要指定的，就可以用命令模式，比如记录日志、撤销操作命令等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;分享一首很轻快的轻音乐！&lt;/p&gt;

&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: https://github.com/xuwujing/java-study&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 13:35:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9794886.html</dc:identifier>
</item>
<item>
<title>一步步实现windows版ijkplayer系列文章之四——windows下编译ijkplyer版ffmpeg - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/9794811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/9794811.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9569960.html&quot;&gt;一步步实现windows版ijkplayer系列文章之一——Windows10平台编译ffmpeg 4.0.2，生成ffplay&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9681643.html&quot;&gt;一步步实现windows版ijkplayer系列文章之二——Ijkplayer播放器源码分析之音视频输出——视频篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9693983.html&quot;&gt;一步步实现windows版ijkplayer系列文章之三——Ijkplayer播放器源码分析之音视频输出——音频篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9794811.html&quot;&gt;一步步实现windows版ijkplayer系列文章之四——windows下编译ijkplyer版ffmpeg&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ijkplayer版本ffmpeg源码说明&quot;&gt;ijkplayer版本ffmpeg源码说明&lt;/h2&gt;
&lt;p&gt;ijkplayer使用了ffmpeg 3.4 release(接下来将此版本ffmpeg叫做ijkplayer-ffmpeg)，ijkplayer fork版本最后一个官方的commit详细信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;提交：
01e291a592452f27b3a4e811536aaaf94096e244 [01e291a]
父级：
03351cce88
作者：
Mark Thompson &amp;lt;sw@jkqxz.net&amp;gt;
日期：
2017年10月15日 GMT+8 下午7:45:15&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ijkplayer团队在此基础上做了不少的改动，同时官方的3.4 release也在做更新，最近的一个3.4小版本release是3.4.4，时间在2018年7月18号。把ijkplayer的FFmpeg fork版本拿到windows下面编译一直编译不过，拿官方的3.4最新代码却能编译成功，所以首先需要把两个branch进行一下merge。&lt;/p&gt;
&lt;h2 id=&quot;merge-ijkplayer-ffmpeg-到-ffmpeg3.4.4&quot;&gt;merge Ijkplayer-ffmpeg 到 ffmpeg3.4.4&lt;/h2&gt;
&lt;p&gt;ijkplayer-ffmpeg fork自 官方的&lt;a href=&quot;https://github.com/FFmpeg/FFmpeg&quot;&gt;ffmpeg&lt;/a&gt;，ijkplayer-ffmpeg可以提交pull request到官方ffmpeg，这不是我们自己能控制的。网上搜索了相关的资料，git如此强大，可以对两个fork的branch进行『移花接木』，现将过程记录如下：&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li&gt;github上将官方ffmpeg fork一份到自己的账户。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在本地将ijkplayer-ffmpeg仓库clone下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; https://github.com/Bilibili/FFmpeg.git&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;跳转到ijkplayer-ffmpeg 根目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; cd root_path_of_ijkplayer-ffmpeg&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将ijkplayer指定的tag检出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git checkout ff3.4--ijk0.8.7--20180103--001 -B ijkplayer       &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;删除本地仓库的origin部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote rm origin&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将官方ffmpeg origin添加到本地ijkplayer-ffmpeg：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote add origin https://github.com/harlanc/FFmpeg.git&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重命名本地branch ijkplayer&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git branch -m ijkplayer-temp&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将更新后的远端仓库拉取到本地：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git fetch&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将官方ffmpeg的3.4.4版本检出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git checkout n3.4.4 -B ijkplayer&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后将ijkplayer-temp merge到官方ffmpeg n3.4.4中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git merge ijkplayer-temp  &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终的结果没有冲突，直接将代码commit和push即可。&lt;/p&gt;
&lt;h2 id=&quot;在wingw中编译ijkplayer-ffmpeg&quot;&gt;在WinGW中编译ijkplayer-ffmpeg&lt;/h2&gt;
&lt;p&gt;将merge后的branch拷贝到windows环境中，同前面介绍的编译ffmpeg4.0.2一样进行编译，发现ijkplayer更新的ffmpeg代码存在不少问题，有一些bug，也有的缺失了windows部分的代码，做了一些改动，也有可能有问题，但最后编译通过了（具体可以看我的&lt;a href=&quot;https://github.com/harlanc/FFmpeg/tree/ijkplayer&quot;&gt;github&lt;/a&gt;）。ijkplayer-ffmpeg的android平台下，最终ffmpeg部分是生成了一个so动态库，libijkffmpeg.so，而且这个库还很小。使用ffmpeg的configure编译出来后是很多的dll和lib，想像ijkplayer一样将需要的.o文件打包成一个动态库，最后没有成功，先继续往前走吧，最关键的部分还没到，朝目标又近了一步，加油。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/msrose/2feacb303035d11d2d05&quot;&gt;Combining two git repositories&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 13:22:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/9794811.html</dc:identifier>
</item>
<item>
<title>你所要掌握的最简单基础的React渲染优化 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9794292.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9794292.html</guid>
<description>&lt;h3&gt;&lt;span&gt;一、React的渲染机制&lt;/span&gt;&lt;/h3&gt;
&lt;br/&gt;要掌握一两项React-render优化的方法不难,但是非常重要.无论是在实际项目中的一个小细节,还是迎合'面试官'的口味
&lt;h4&gt;&lt;span&gt;1.1 触发Render&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我们知道React要更新视图,必须要触发Render.而这往往是影响性能最重要的一步(因为操作了dom).而React之所以这么出色,正是因为占其主导地位的diff算法采用了虚拟DOM(React V-dom),使得渲染性能大大提升。&lt;/p&gt;
&lt;p&gt;即便如此,我们在开发的时候也应该要注意一些性能的优化,比如&lt;strong&gt;避免无意义的render&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么,触发render的条件有哪些呢?&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首次加载组件&lt;/li&gt;
&lt;li&gt;使用了setState(更新了Props)&lt;/li&gt;
&lt;li&gt;Props更新了(父级传给子级的值改变了)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们完全可以避免2.3情况导致的一些性能问题&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.2 React Diff&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;虽然说React高效的Diff算法完美结合了虚拟DOM,让用户可以'无限制'刷新而不需要考虑任何性能问题.&lt;br/&gt;但diff算法还是需要一定的时间,如果你不在意触发render的细节,项目模块大了起来,自然就会影响性能了.&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.3 不做任何优化的例子&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;我尝试着从实现以下功能:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不更新state的值,但是调用了&lt;code&gt;setState&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;传给子级的值不改变,即子级props实际上是没变化的&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 父级.js
import React from 'react'
import MockChild from './child/index.js'
export default class Demo5 extends React.Component{
    constructor(args){
        super(args)
        
        this.state = {
            'mockNum': 0
        }
    }
    handleClick(){
        this.setState({
            'mockNum': 0,
        })
    }
    render(){
        console.log('父级state ==============&amp;gt;', this.state)
        return(
            &amp;lt;div&amp;gt;
                &amp;lt;button onClick={this.handleClick.bind(this)}&amp;gt;点击&amp;lt;/button&amp;gt;
                &amp;lt;MockChild  mockNum={this.state.mockNum}/&amp;gt;
            &amp;lt;/div&amp;gt;
        )
    }
}

//子组件
render(){
    console.log('子级Props =============&amp;gt;', this.props)
    return(
        &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;
    )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们反复点击按钮,虽然state的值并没有任何变化,但是我们看打印的结果！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015191747211-1249888166.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;render重复渲染了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可能会疑问,我在项目并不会做这么一种无用功的！但实际上,当一个组件逻辑复杂起来之后,会产生各种各样的情况.比如:&lt;/p&gt;
&lt;p&gt;比如一个组件的中有个包含&lt;strong&gt;onChange&lt;/strong&gt;事件的&lt;code&gt;input&lt;/code&gt;,当我改变该输入框内容的时候调用了&lt;code&gt;setState&lt;/code&gt;,渲染视图的时候也会触发子组件的重新render.但我们明明没有做任何和子组件有联系的操作&lt;br/&gt;例如上面的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//父组件.js
state = {
    'mockValue': '123'    
}
handleChange(e){
    this.setState({
        'value': '123',
    })
}

//render
&amp;lt;input onChange={this.handleChange.bind(this)} /&amp;gt;
&amp;lt;MockChild /&amp;gt;

/*
* 子组件不做变化
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015194423502-324164727.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很不爽,真的！必须给安排掉.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015211037371-232547574.png&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;二、基础的React优化&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;2.1 生命周期: shouldComponentUpdate&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;可能没听过&lt;code&gt;shouldComponentUpdate&lt;/code&gt;,我们简单介绍一下它的执行周期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414709/201810/1414709-20181015193558826-1118415996.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.8421052631579&quot;&gt;
&lt;p&gt;不熟悉React生命周期的可以看看这篇文章:&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9559117.html&quot; target=&quot;_blank&quot;&gt;《React生命周期执行顺序详解》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到它是在render渲染之前触发的,只要我们在这里加以判断就可以有效阻止'无用'的render触发.当然你说&lt;code&gt;componentWillReceiveProps&lt;/code&gt;也可以,当然！但是它只有props的更新判断,而有时候我们也不能放过未更改的state！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shouldComponentUpdate(nextProps, nextState){
    if(nextState !== this.state &amp;amp;&amp;amp; nextProps !== this.props) return true;
    return false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么简短的代码就可以解决冗余的render触发.当然有时候项目规模大了之后,就需要具体到某一个值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nextState.xxx !== this.state.xxx &amp;amp;&amp;amp; ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;2.2 PureComponent&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;先介绍&lt;strong&gt;PureComponent&lt;/strong&gt;的用法,实在是太简便了
&lt;pre&gt;
&lt;code&gt;import React, { PureComponent } from 'react'

export default class Demo5 extends PureComponent{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上就是把React.Component代替成PureComponent.&lt;/p&gt;
&lt;p&gt;可能会疑问那PureComponent应该是一个插件吧？为什么就在react包里？其实它是官方在&lt;strong&gt;React15.3&lt;/strong&gt;提出的一个'纯净的组件'&lt;/p&gt;
&lt;p&gt;在版本允许的情况下,还是建议使用PureComponent,既能优化render次数,也能减少&lt;strong&gt;shouldComponentUpdate&lt;/strong&gt;的代码。但是PureComponent只是执行了&lt;strong&gt;浅比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么是浅比较呢?&lt;/p&gt;
&lt;p&gt;我们先来看看源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (this._compositeType === CompositeTypes.PureClass) {
  shouldUpdate = !shallowEqual(prevProps, nextProps)
  || !shallowEqual(inst.state, nextState);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到判断主要是通过&lt;code&gt;shallowEqual&lt;/code&gt;方法执行的（即可以判断state,也可以判断props）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shallowEqual&lt;/code&gt;具体作用是什么呢?实际上它使用了ES6的&lt;code&gt;Object.keys&lt;/code&gt;.只是做了以下这么几个判断:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新的和旧的props(state)是否两者都有相同的key?&lt;/li&gt;
&lt;li&gt;引用是否改变&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二种可能有点难以理解,什么是&lt;strong&gt;引用是否改变?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单地解释就是,是否有新的元素参与改变&lt;/p&gt;
&lt;p&gt;举个官方常用例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class App extends PureComponent {
  state = {
    items: [1, 2, 3]
  }
  handleClick = () =&amp;gt; {
    const { items } = this.state;
    items.pop();
    this.setState({ items });
  }
  render() {
    return (&amp;lt;div&amp;gt;
      &amp;lt;ul&amp;gt;
        {this.state.items.map(i =&amp;gt; &amp;lt;li key={i}&amp;gt;{i}&amp;lt;/li&amp;gt;)}
      &amp;lt;/ul&amp;gt;
      &amp;lt;button onClick={this.handleClick}&amp;gt;delete&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,我们点击delete的时候,虽然items数组执行了&lt;code&gt;pop()&lt;/code&gt;方法,删除最后一项！但是&lt;code&gt;li&lt;/code&gt;标签却没变少！那是因为&lt;code&gt;shallowEqual&lt;/code&gt;根本不吃你这套.它认为items还是同一个引用,所以给我&lt;code&gt;true&lt;/code&gt;！在通过！反过来就是&lt;code&gt;false&lt;/code&gt;了&lt;/p&gt;
&lt;p&gt;那要如果改变引用呢？&lt;br/&gt;我们可以这样尝试.(这也是解决浅比较常用的一个办法)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this.setState({ 
    items: [].concat(items) 
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然,大多数情况我们都可以通过PureComponent解决啦！实在不行,还可以通过&lt;code&gt;componentWillReceiveProps&lt;/code&gt;进一步判断呢！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PureComponent&lt;/code&gt;更多的介绍可以看:&lt;a href=&quot;http://www.wulv.site/2017-05-31/react-purecomponent.html&quot; target=&quot;_blank&quot;&gt;《React PureComponent 使用指南》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 15 Oct 2018 12:05:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、React的渲染机制 要掌握一两项React render优化的方法不难,但是非常重要.无论是在实际项目中的一个小细节,还是迎合'面试官'的口味 1.1 触发Render 我们知道React要更新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9794292.html</dc:identifier>
</item>
<item>
<title>JUnit源码分析 - 扩展 - 自定义Rule - coolstream</title>
<link>http://www.cnblogs.com/coolstream/p/9756334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coolstream/p/9756334.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule简述&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Rule是JUnit 4.7之后新加入的特性，有点类似于拦截器，可以在测试类或测试方法执行前后添加额外的处理，本质上是对@BeforeClass, @AfterClass, @Before, @After等的另一种实现，只是功能上更灵活多变，易于扩展，且方便在类和项目之间共享。&lt;/p&gt;
&lt;p&gt;JUnit的Rule特性提供了两个注解@Rule和@RuleClass，大体上说@Rule可以与@Before及@After对应，@ClassRule可以与@BeforeClass及@AfterClass对应。自JUnit4.10起可以使用TestRule接口代替此前一直在用的MethodRule接口，实际项目中可以通过实现TestRule或继承自JUnit内置Rule类进行扩展。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在简述中已经提到Rule特性本身也是对@BeforeClass, @AfterClass, @Before, @After功能的另外实现，所以基本上这四种注解的使用场景都适用于Rule，同时JUnit内置的Rule类还能够提供这四种注解未提供的功能。总体上说Rule特性的适用场景包括但不限于如下需求：&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试类或测试方法执行前后添加初始化或环境清理操作&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试执行过程中收集错误信息且无需中断测试&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试结束后添加额外的测试结果校验功能&lt;/p&gt;
&lt;p&gt;　　　　　- 在测试执行前后创建及删除测试执行过程中产生的临时文件或目录&lt;/p&gt;
&lt;p&gt;　　　　　- 对测试过程中产生的异常进行灵活校验&lt;/p&gt;
&lt;p&gt;　　　　　- 将多个Rules串接在一起执行&lt;/p&gt;
&lt;p&gt;　　　　　- 测试用例执行失败时重试指定次数&lt;/p&gt;

&lt;p&gt;从使用习惯上来说，对于简单项目，@BeforeClass, @AfterClass, @Before, @After等注解已经能够满足测试需求；对于复杂点的项目，从易扩展、易维护和方便复用的角度考虑最好使用Rule特性，方便添加和移除Rule实例，灵活性大大提高。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注解分类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JUnit中通过两个注解@Rule和@ClassRule来实现Rule扩展，这两个注解使用时需要放在实现了TestRule接口的Rule变量或返回Rule的方法之上,且修饰符都必须为public。&lt;/p&gt;
&lt;p&gt;二者具体区别如下：&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;- 被注解的变量或方法类型不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @Rule修饰的变量或方法的修饰符必须为public，非static&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @ClassRule修饰的变量或方法的修饰符必须为public static&lt;/p&gt;
&lt;p&gt;　　　　　&lt;span&gt;- 注解的级别不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @Rule为变量或方法级注解，每个测试方法执行时都会调用被该注解修饰的Rule&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @ClassRule为类级注解，执行单个测试类时只会调用一次被该注解修饰的Rule&lt;/p&gt;
&lt;p&gt; 　　　　　&lt;span&gt;- 注解的对象限制不同&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @Rule无注解对象限制&lt;/p&gt;
&lt;p&gt;　　　　　　　　- @ClassRule不能注解ErrorCollector(Verifier)&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;TestRule接口&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TestRule是测试类或测试方法执行过程及报告信息的接口，可以在TestRule中添加初始化及环境清理的操作、监控测试执行的日志打印或UI截图操作、测试结果成功或失败校验操作等。TestRule仅定义了唯一的方法apply()，所以可以在TestRule实现类的apply()方法中加入测试项目需要的操作。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestRule {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
    &lt;span&gt;//在实现类的apply()中加入测试需要的操作，本质上是对Statement实例base的进一步封装&lt;/span&gt;
    Statement apply(Statement base, Description description);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit内置Rule&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;除了Rule特性外，JUnit还新增了一些核心Rule，均实现了TestRule接口，包括Verifier抽象类，ErrorCollector实现类，ExternalResource抽象类，TemporaryFolder实现类，TestWatcher抽象类，TestName实现类，ExpectedException实现类，Timeout实现类及RuleChain实现类(deprecated)。各接口实现类及类图参考如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1432399/201810/1432399-20181012155942527-596018700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　&lt;span&gt;- Verifier&lt;/span&gt;：所有测试结束后对测试执行结果添加额外的逻辑验证测试最终成功与否。该抽象类为子类提供一个接口方法verify()供扩展&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- ErrorCollector&lt;/span&gt;：是Verifier类的一个子类实现，用于在测试执行过程中收集错误信息，不会中断测试，最后调用verify()方法处理&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- ExternalResource&lt;/span&gt;：外部资源管理。该抽象类为子类提供了两个接口方法before()和after()，可以根据项目实际需要覆写扩展&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- TemporaryFolder&lt;/span&gt;：是抽象类ExternalResource的一个子类实现，用于在JUnit测试执行前后，创建和删除临时目录&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- TestWatcher&lt;/span&gt;：监视测试方法生命周期的各个阶段。该抽象类为子类提供了五个接口方法succeeded(), failed(), skipped(), starting()及finished()供扩展&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- TestName&lt;/span&gt;：是抽象类TestWatcher的一个子类实现，用于在测试执行过程中获取测试方法名称。在starting()中记录测试方法名，在getMethodName()中返回&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- ExpectedException&lt;/span&gt;：与@Test中的expected相对应，提供更强大灵活的异常验证功能，@Test只能修饰待测试方法，ExpectedException可以修饰待测试类&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- Timeout&lt;/span&gt;：与@Test中的timeout相对应，@Test只能修饰待测试方法，Timeout可以修饰待测试类&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;- RuleChain&lt;/span&gt;：用于将多个Rules串在一起执行。RuleChain已经deprecated了，但是其源码实现比较有趣，所以本篇没有直接去掉。&lt;/p&gt;

&lt;p&gt;篇幅原因此处仅简要介绍这些Rules提供的功能，后续将在专门的Rule及TestRule实现类源码分析中详解其实现。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;以下过程是以典型的单个待测试类调用BlockJUnit4ClassRunner执行测试为例进行分析，如果对源码分析无兴趣可直接跳到&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule扩展示例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;部分。&lt;/p&gt;

&lt;p&gt;分析Rule特性的源码实现之前需要先梳理Statement的概念及执行过程，tStatement是对原子级测试的封装，我们在JUnit Runner中看到的测试用例执行过程是顺序执行不同注解修饰的测试方法，即@BeforeClass-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass(此处以三个待测试方法为例)。那么JUnit是如何将这一系列串接在一起的呢？其设计思想就是通过Statement以责任链的模式将其层层封装，责任链中上个节点的Statement中都存在对下一个节点的引用。Statement可以说是JUnit的核心设计之一，理清了Statement的执行过程就抓住了JUnit实现原理的主线。&lt;/p&gt;
&lt;p&gt;Rule特性又是如何织入Statement的封装与执行过程的呢？我们知道Rule特性中有两个注解@ClassRule和@Rule用来修饰Rule变量或返回Rule的方法，这些变量或方法返回值的类型都需要实现TestRule接口，而TestRule中唯一定义的方法apply()的返回值类型就是Statement，所以JUnit中Rule特性的实现类同样是Statement的一种。根据BlockJUnit4ClassRunner的父类ParentRunner中的classBlock()方法中的调用，以及BlockJUnit4ClassRunner中methodBlock()方法中的调用，我们基本上可以梳理出@ClassRule和@Rule在整个Statement责任链中的执行顺序，以JUnit内置的Rule实现类ErrorCollector，TemporaryFolderr和TestName为例（含两个@Test修饰的待测试方法）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@ClassRule注解ErrorCollector类实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　执行顺序为：&lt;/p&gt;
&lt;p&gt;　　@BeforeClass-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass-&amp;gt;&lt;span&gt;@ClassRule(verify())&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@ClassRule注解TemporaryFolder类实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　执行顺序为：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;@ClassRule(before())&lt;/span&gt;-&amp;gt;@BeforeClass-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass-&amp;gt;&lt;span&gt;@ClassRule(after())&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;@Rule注解TestName类实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　执行顺序为：&lt;/p&gt;
&lt;p&gt;　　@BeforeClass-&amp;gt;&lt;span&gt;@Rule(starting())&lt;/span&gt;-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;&lt;span&gt;@Rule(starting())&lt;/span&gt;-&amp;gt;@Before-&amp;gt;@Test-&amp;gt;@After-&amp;gt;@AfterClass&lt;/p&gt;

&lt;p&gt;如果测试用例中@ClassRule和@Rule两个都存在，则按实际覆写的接口方法所处测试阶段顺序织入测试执行过程。&lt;/p&gt;
&lt;p&gt;上述部分是分析Statement的设计思想及Rule在Statement执行过程中的顺序，文字描述通常都比较晦涩，还是特出关键源码一步步解读比较好，此处的简析仅仅是希望对Statement和Rule有一些大致的概念，方便后续的源码解读。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Statement封装过程的关键代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Statement封装过程中有两个主要的方法classBlock()和methodBlock()，其中classBlock()是测试类级别的封装，也就是说测试类级注解@BeforeRule, @AfterRule以及@ClassRule修饰的方法在此处链式封装，methodBlock()是测试方法级别的封装，也就是说测试方法级别注解@Test(expected=xxx) , @Test(timeout=xxx), @Before, @After()及@Rule修饰的方法在此处链式封装。&lt;/p&gt;
&lt;p&gt;　　先看一下classBlock()的调用过程：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Statement classBlock(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RunNotifier notifier) {
        Statement statement &lt;/span&gt;=&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象&lt;/span&gt;&lt;/span&gt;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;areAllChildrenIgnored()) {
            statement &lt;/span&gt;=&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            statement &lt;/span&gt;=&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
            statement &lt;/span&gt;=&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;classBlock()中写的很清楚，首先调用childrenInvoker()构造Statement的基本行为，如果所有的子测试都没有被Ignore则通过withBeforeClasses(), withAfterClasses()及withClassRules()继续封装。先放一下，分析完childrenInvoker()的调用过程再从这里接入。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Statement childrenInvoker(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RunNotifier notifier) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Statement() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; evaluate() {
                runChildren(notifier);
            }
        };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;childrenInvoker()的作用是构造基本的Statement行为，即执行所有的子测试runChildren()，在runChildren()中循环调用每个子测试runChild()。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runChildren(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; RunNotifier notifier) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RunnerScheduler currentScheduler =&lt;span&gt; scheduler;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt;&lt;span&gt; T each : getFilteredChildren()) {
                currentScheduler.schedule(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        ParentRunner.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.runChild(each, notifier);
                    }
                });
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            currentScheduler.finished();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; runChild(T child, RunNotifier notifier);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected &lt;span&gt;void runChild(&lt;span&gt;final&lt;span&gt; FrameworkMethod method, RunNotifier notifier) {
        Description description =&lt;span&gt; describeChild(method);
        &lt;span&gt;if&lt;span&gt; (isIgnored(method)) {
            notifier.fireTestIgnored(description);
        } &lt;span&gt;else&lt;span&gt; {
            Statement statement = &lt;span&gt;new&lt;span&gt; Statement() {
                @Override
                &lt;span&gt;public &lt;span&gt;void evaluate() &lt;span&gt;throws&lt;span&gt; Throwable {
                    methodBlock(method).evaluate();
                }
            };
            runLeaf(statement, description, notifier);
        }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为ParentRunner中只有runChild()的抽象方法，所以该方法的具体实现在其子类BlockJUnit4ClassRunner中，子类的runChild()中调用了测试方法级的层层封装methodBlock()。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected Statement methodBlock(&lt;span&gt;final&lt;span&gt; FrameworkMethod method) {
        Object test;
        &lt;span&gt;try&lt;span&gt; {
            test = &lt;span&gt;new&lt;span&gt; ReflectiveCallable() {
                @Override
                &lt;span&gt;protected Object runReflectiveCall() &lt;span&gt;throws&lt;span&gt; Throwable {
                    &lt;span&gt;return&lt;span&gt; createTest(method);
                }
            }.run();
        } &lt;span&gt;catch&lt;span&gt; (Throwable e) {
            &lt;span&gt;return &lt;span&gt;new&lt;span&gt; Fail(e);
        }

        Statement statement =&lt;span&gt; methodInvoker(method, test);
        statement =&lt;span&gt; possiblyExpectingExceptions(method, test, statement);
        statement =&lt;span&gt; withPotentialTimeout(method, test, statement);
        statement =&lt;span&gt; withBefores(method, test, statement);
        statement =&lt;span&gt; withAfters(method, test, statement);
        statement =&lt;span&gt; withRules(method, test, statement);
        &lt;span&gt;return&lt;span&gt; statement;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Object createTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getTestClass().getOnlyConstructor().newInstance();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected&lt;span&gt; Statement methodInvoker(FrameworkMethod method, Object test) {
        &lt;span&gt;return &lt;span&gt;new&lt;span&gt; InvokeMethod(method, test);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　methodBlock()中首先在createTest()中通过反射构造实例，在将该实例及FrameworkMethod类对象method作为methodInvoker()的入参构造出基本的Statement类对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.internal.runners.statements.InvokeMethod
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InvokeMethod &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Statement {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; FrameworkMethod testMethod;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Object target;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InvokeMethod(FrameworkMethod testMethod, Object target) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testMethod =&lt;span&gt; testMethod;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        testMethod.invokeExplosively(target);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;构造出基本的Statement类对象后，在执行后续操作对该Statement类对象进行层层封装。篇幅原因就不再对如下&lt;span&gt;possiblyExpectingExceptions等五个方法的调用过程作进一步解析，这些方法调用和下面将要讲解的classBlock()方法实现中的下半部分很相似，只是此处是测试方法级的封装调用，classBlock()中是测试类级的封装调用。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
Statement statement =&lt;span&gt; methodInvoker(method, test);　　　　　　　　　　　　&lt;span&gt;&lt;span&gt;//构造出测试方法基本的Statement类对象&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; possiblyExpectingExceptions(method, test, statement);　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Test(expected=xxx)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withPotentialTimeout(method, test, statement);　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Test(timeout=xxx), deprecated&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withBefores(method, test, statement);　　　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Before&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withAfters(method, test, statement);　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@After&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
statement &lt;/span&gt;=&lt;span&gt; withRules(method, test, statement);　　　　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@Rule&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的待测试方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再回到前面classBlock()中的分析过程，该方法的后半部分会对构造出的所有方法的基本statement类对象作进一步封装，依次为&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withBeforeClasses(), &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withAfterClasses&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;()及&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withClassRules()。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;span&gt;protected Statement classBlock(&lt;span&gt;final&lt;span&gt; RunNotifier notifier) {
        Statement statement =&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象
        &lt;span&gt;if (!&lt;span&gt;areAllChildrenIgnored()) {
            statement =&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass
            statement =&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass
            statement =&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule
        }
        &lt;span&gt;return&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Statement withBeforeClasses(Statement statement) {
        List&lt;/span&gt;&amp;lt;FrameworkMethod&amp;gt; befores =&lt;span&gt; testClass
                .getAnnotatedMethods(BeforeClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; befores.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RunBefores(statement, befores, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;withBeforeClasses()调用过程：&lt;/span&gt;提取出待测试类中用@BeforeClass注解的所有方法，再把这些方法和childrenInvoker()中构造出的基本Statement类对象作为入参用Statement的子类RunBefores重新封装并返回。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Statement withAfterClasses(Statement statement) {
        List&lt;/span&gt;&amp;lt;FrameworkMethod&amp;gt; afters =&lt;span&gt; testClass
                .getAnnotatedMethods(AfterClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; afters.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RunAfters(statement, afters, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;withAfterClasses()调用过程：&lt;/span&gt;提取出待测试类中用@AfterClass注解的所有方法，再把这些方法和&lt;span&gt;withBeforeClasses&lt;/span&gt;()中返回的Statement类对象作为入参用Statement的子类RunAfters重新封装并返回。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Statement withClassRules(Statement statement) {
        List&lt;/span&gt;&amp;lt;TestRule&amp;gt; classRules =&lt;span&gt; classRules();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; classRules.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunRules(statement, classRules, getDescription());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;withClassRules&lt;/span&gt;()调用过程：提取出待测试类中用@ClassRule注解的所有Rule类变量或返回值为Rule类的方法，再把这些变量和方法同&lt;span&gt;withAfterClasses()中返回的Statement类对象作为入参用Statement的子类RunRules重新封装并返回。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; classRules() {
        ClassRuleCollector collector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassRuleCollector();
        testClass.collectAnnotatedMethodValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        testClass.collectAnnotatedFieldValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.getOrderedRules();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;//org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassRuleCollector &lt;span&gt;implements&lt;/span&gt; MemberValueConsumer&amp;lt;TestRule&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;RuleContainer.RuleEntry&amp;gt; entries = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RuleContainer.RuleEntry&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(FrameworkMember member, TestRule value) {
            ClassRule rule &lt;/span&gt;= member.getAnnotation(ClassRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            entries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleContainer.RuleEntry(value, RuleContainer.RuleEntry.TYPE_TEST_RULE,
                    rule &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; ? rule.order() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; getOrderedRules() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (entries.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
            }
            Collections.sort(entries, RuleContainer.ENTRY_COMPARATOR);
            List&lt;/span&gt;&amp;lt;TestRule&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;TestRule&amp;gt;&lt;span&gt;(entries.size());
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RuleContainer.RuleEntry entry : entries) {
                result.add((TestRule) entry.rule);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　classRules()方法用于获取@ClassRule修饰的所有TestRule实现类。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//org.junit.rules.RunRules&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunRules &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Statement {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Statement statement;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RunRules(Statement base, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules, Description description) {
        statement &lt;/span&gt;=&lt;span&gt; applyAll(base, rules, description);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        statement.evaluate();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Statement applyAll(Statement result, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules,
            Description description) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule each : rules) {
            result &lt;/span&gt;=&lt;span&gt; each.apply(result, description);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　RunRules类用于根据调用&lt;span&gt;classRules&lt;/span&gt;()获取到的所有TestRule实现类集合对withAfterRules()方法返回的Statement类实例进行重新封装。&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Runner验证Rule规则的关键代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文开始提到过@ClassRule和@Rule修饰的Rule类变量或方法有一定的限制，比如public修饰符, 是或非static, 实现自TestRule接口等，所以在测试用例执行前需要进行相应的验证，这个是由ParentRunner及其子类在其构造方法的初始化过程中完成的。Rule规则的校验主要通过四个&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例CLASS_RULE_METHOD_VALIDATOR，CLASS_RULE_VALIDATOR，RULE_METHOD_VALIDATOR及RULE_VALIDATOR调用各自的validate()方法来实现的，具体调用过程解析如下：&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BlockJUnit4ClassRunner(Class&amp;lt;?&amp;gt; testClass) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InitializationError {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(testClass);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　BlockJUnit4ClassRunner构造方法初始化过程会调用父类ParentRunner的的构造方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ParentRunner(Class&amp;lt;?&amp;gt; testClass) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InitializationError {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testClass =&lt;span&gt; createTestClass(testClass);
        validate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　ParentRunner的构造方法中包含了validate()调用&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InitializationError {
        List&lt;/span&gt;&amp;lt;Throwable&amp;gt; errors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Throwable&amp;gt;&lt;span&gt;();
        collectInitializationErrors(errors);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;errors.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvalidTestClassError(testClass.getJavaClass(), errors);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　该validate()实现中包含&lt;span&gt;collectInitializationErrors&lt;/span&gt;()调用，子类BlockJUnit4ClassRunner覆写了父类ParentRunner的&lt;span&gt;collectInitializationErrors&lt;/span&gt;()方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;@Override
&lt;span&gt;protected &lt;span&gt;void collectInitializationErrors(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        &lt;span&gt;super&lt;span&gt;.collectInitializationErrors(errors);

        validatePublicConstructor(errors);
        validateNoNonStaticInnerClass(errors);
        validateConstructor(errors);
        validateInstanceMethods(errors);
        validateFields(errors);
        validateMethods(errors);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　子类BlockJUnit4ClassRunner中的&lt;span&gt;collectInitializationErrors()方法实现会先调用父类ParentRunner中的&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;collectInitializationErrors()。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; collectInitializationErrors(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        validatePublicVoidNoArgMethods(BeforeClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, errors);
        validatePublicVoidNoArgMethods(AfterClass.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, errors);
        validateClassRules(errors);
        applyValidators(errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　 &lt;span&gt;父类ParentRunner中的&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;collectInitializationErrors()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法实现中包含了&lt;span&gt;validateClassRules&lt;/span&gt;()调用。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateClassRules(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        CLASS_RULE_VALIDATOR.validate(getTestClass(), errors);
        CLASS_RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;validateClassRules&lt;/span&gt;()方法中包含了两个&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator&lt;/span&gt;实例&lt;span&gt;CLASS_RULE_VALIDATOR&lt;/span&gt;及&lt;span&gt;CLASS_RULE_METHOD_VALIDATOR&lt;/span&gt;各自的validate()方法调用，这两个方法会对@ClassRule修饰的变量或方法进行Rule规则校验。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateFields(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        RULE_VALIDATOR.validate(getTestClass(), errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateMethods(List&amp;lt;Throwable&amp;gt;&lt;span&gt; errors) {
        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;validateFields()方法中包含了&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例&lt;/span&gt;&lt;/span&gt;&lt;span&gt;RULE_VALIDATOR&lt;span class=&quot;pl-smi&quot;&gt;&lt;span&gt;&lt;span&gt;的validate()方法调用，validateMethods()&lt;span&gt;方法中包含了&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例&lt;span&gt;RULE_METHOD_VALIDATOR&lt;span class=&quot;pl-smi&quot;&gt;&lt;span&gt;&lt;span&gt;的validate()方法调用，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这两个方法会对@Rule修饰的变量或方法进行Rule规则校验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;//&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules&lt;/span&gt;.RuleMemberValidator 验证@ClassRule修饰的方法是否复合Rule特性规则&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator CLASS_RULE_METHOD_VALIDATOR =&lt;span&gt;
            classRuleValidatorBuilder()
            .forMethods()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeclaringClassMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeStatic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodMustBeATestRule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules.RuleMemberValidator &lt;/span&gt;&lt;/span&gt;验证@ClassRule修饰的作用域&lt;span&gt;是否复合Rule特性规则&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator CLASS_RULE_VALIDATOR =&lt;span&gt;
            classRuleValidatorBuilder()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeclaringClassMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeStatic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FieldMustBeATestRule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules.RuleMemberValidator &lt;/span&gt;&lt;/span&gt;验证@Rule修饰的方法是否复合Rule特性规则&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator RULE_METHOD_VALIDATOR =&lt;span&gt;
            testRuleValidatorBuilder()
            .forMethods()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeNonStaticOrAlsoClassRule())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodMustBeARule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span class=&quot;pl-smi&quot;&gt;org.junit.internal.runners.rules.RuleMemberValidator &lt;/span&gt;&lt;/span&gt;验证@Rule修饰的作用域&lt;span&gt;是否复合Rule特性规则&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RuleMemberValidator RULE_VALIDATOR =&lt;span&gt;
            testRuleValidatorBuilder()
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBeNonStaticOrAlsoClassRule())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemberMustBePublic())
            .withValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FieldMustBeARule())
　　　　　　　.build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上是四个&lt;span class=&quot;pl-smi&quot;&gt;RuleMemberValidator实例CLASS_RULE_METHOD_VALIDATOR，CLASS_RULE_VALIDATOR，RULE_METHOD_VALIDATOR及RULE_VALIDATOR的具体定义，其实从类名定义上就可以直观地看到这些实例具体的校验内容，篇幅原因不再详述。&lt;/span&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt; Rule特性织入Statement的关键代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Rule特性织入Statement的过程主要依赖两个语句及其涉及到的嵌套调用，这两个语句即是classBlock()方法中的statement = withClassRules(statement)和methodBlock()方法中的statement = withRules(statement)。下面依次对二者嵌套的调用过程进行解析。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;span&gt;protected Statement classBlock(&lt;span&gt;final&lt;span&gt; RunNotifier notifier) {
        Statement statement =&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象
        &lt;span&gt;if (!&lt;span&gt;areAllChildrenIgnored()) {
            statement =&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass
            statement =&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass
            &lt;span&gt;statement =&lt;/span&gt;&lt;span&gt;&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule&lt;/span&gt;
        }
        &lt;span&gt;return&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner
&lt;span&gt;protected Statement methodBlock(&lt;span&gt;final&lt;span&gt; FrameworkMethod method) {
        Object test;
        &lt;span&gt;try&lt;span&gt; {
            test = &lt;span&gt;new&lt;span&gt; ReflectiveCallable() {
                @Override
                &lt;span&gt;protected Object runReflectiveCall() &lt;span&gt;throws&lt;span&gt; Throwable {
                    &lt;span&gt;return&lt;span&gt; createTest(method);
                }
            }.run();
        } &lt;span&gt;catch&lt;span&gt; (Throwable e) {
            &lt;span&gt;return &lt;span&gt;new&lt;span&gt; Fail(e);
        }

        Statement statement =&lt;span&gt; methodInvoker(method, test);
        statement =&lt;span&gt; possiblyExpectingExceptions(method, test, statement);
        statement =&lt;span&gt; withPotentialTimeout(method, test, statement);
        statement =&lt;span&gt; withBefores(method, test, statement);
        statement =&lt;span&gt; withAfters(method, test, statement);
        &lt;span&gt;statement =&lt;/span&gt;&lt;span&gt;&lt;span&gt; withRules(method, test, statement);&lt;/span&gt;
        &lt;span&gt;return&lt;span&gt; statement;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　先来看methodBlock()中的withRules()调用，MethodRule接口从JUnit4.10开始已经deprecated，该接口相关的代码可以直接ignore。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Statement withRules(FrameworkMethod method, Object target, Statement statement) {
        RuleContainer ruleContainer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleContainer();
        CURRENT_RULE_CONTAINER.set(ruleContainer);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            List&lt;/span&gt;&amp;lt;TestRule&amp;gt; testRules =&lt;span&gt; getTestRules(target);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (MethodRule each : rules(target)) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(each &lt;span&gt;instanceof&lt;/span&gt; TestRule &amp;amp;&amp;amp;&lt;span&gt; testRules.contains(each))) {
                    ruleContainer.add(each);
                }
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule rule : testRules) {
                ruleContainer.add(rule);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            CURRENT_RULE_CONTAINER.remove();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ruleContainer.apply(method, describeChild(method), target, statement);
    }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建RunContainer实例，将其设置为当前线程局部变量的值，通过getTestRules()获取注解target的所有@Rule规则，并将其加入到新建的RunContainer实例中　　，ThreadLocal的内在机制会保证这一过程在并发环境下的的线程安全。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;RuleContainer&amp;gt; CURRENT_RULE_CONTAINER = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;RuleContainer&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;&lt;span&gt;org.junit.runners.BlockJUnit4ClassRunner&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; getTestRules(Object target) {
        RuleCollector&lt;/span&gt;&amp;lt;TestRule&amp;gt; collector = &lt;span&gt;new&lt;/span&gt; RuleCollector&amp;lt;TestRule&amp;gt;&lt;span&gt;();
        getTestClass().collectAnnotatedMethodValues(target, Rule.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        getTestClass().collectAnnotatedFieldValues(target, Rule.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　在apply()方法中通过调用getSortedEntries()对所有Rule进行排序处理，处理完成后返回封装Rule之后的Statement实例。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.RuleContainer&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Statement apply(FrameworkMethod method, Description description, Object target,
            Statement statement) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (methodRules.isEmpty() &amp;amp;&amp;amp;&lt;span&gt; testRules.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; statement;
        }
        Statement result &lt;/span&gt;=&lt;span&gt; statement;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RuleEntry ruleEntry : getSortedEntries()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ruleEntry.type ==&lt;span&gt; RuleEntry.TYPE_TEST_RULE) {
                result &lt;/span&gt;=&lt;span&gt; ((TestRule) ruleEntry.rule).apply(result, description);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                result &lt;/span&gt;=&lt;span&gt; ((MethodRule) ruleEntry.rule).apply(result, method, target);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;br/&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;&lt;span&gt;org.junit.runners.RuleContainer&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;RuleEntry&amp;gt;&lt;span&gt; getSortedEntries() {
        List&lt;/span&gt;&amp;lt;RuleEntry&amp;gt; ruleEntries = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RuleEntry&amp;gt;&lt;span&gt;(
                methodRules.size() &lt;/span&gt;+&lt;span&gt; testRules.size());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (MethodRule rule : methodRules) {
            ruleEntries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleEntry(rule, RuleEntry.TYPE_METHOD_RULE, orderValues.get(rule)));
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule rule : testRules) {
            ruleEntries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleEntry(rule, RuleEntry.TYPE_TEST_RULE, orderValues.get(rule)));
        }
        Collections.sort(ruleEntries, ENTRY_COMPARATOR);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ruleEntries;
    }&lt;br/&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上是对方法进行Rule规则的封装，在classBlock()代码块中会上溯到&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;childrenInvoker()中的调用，测试方法级的Statement封装处理完之后，还需要继续进行测试类级的Statement封装。从开始贴出的classBlock()的代码块中可以看到&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;childrenInvoker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;()返回对所有测试方法的Statement封装之后，还会继续调用&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withBeforeClasses&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;(), &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withAfterClasses&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;()及withClassRules()进一步处理，这里对于&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withBeforeClasses()和&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;withAfterClasses()的方法调用就不详细讲解了，下面看看withClassRules()方法的执行流程，这个是与Rule规则直接相关的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.runners.ParentRunner
&lt;span&gt;protected Statement classBlock(&lt;span&gt;final&lt;span&gt; RunNotifier notifier) {
        Statement statement =&lt;span&gt; childrenInvoker(notifier);　　　　　　　&lt;span&gt;&lt;span&gt;//构造出所有测试方法基本的Statement类对象
        &lt;span&gt;if (!&lt;span&gt;areAllChildrenIgnored()) {
            statement =&lt;span&gt; withBeforeClasses(statement);　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@BeforeClass
            statement =&lt;span&gt; withAfterClasses(statement);　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@AfterClass
            &lt;span&gt;statement =&lt;span&gt;&lt;span&gt; withClassRules(statement);　　　　　　　　　　&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//对应@ClassRule
        }
        &lt;span&gt;return&lt;span&gt; statement;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//返回层层封装后的Statement类对象
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Statement withClassRules(Statement statement) {
        List&lt;/span&gt;&amp;lt;TestRule&amp;gt; classRules =&lt;span&gt; classRules();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; classRules.isEmpty() ?&lt;span&gt; statement :
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunRules(statement, classRules, getDescription());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;classRules()方法先获取所有@ClassRule规则，然后通过getOrderedRules()对所有@ClassRule规则进行排序。withClassRules()方法通过classRules()获取注解待测试类的所有排序后的@ClassRule规则，并将其作为RunRule类构造方法的入参进一步封装withAfterClasses()方法中返回的Statement实例。RunRule本身也是Statement的子类。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; classRules() {
        ClassRuleCollector collector &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassRuleCollector();
        testClass.collectAnnotatedMethodValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        testClass.collectAnnotatedFieldValues(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, ClassRule.&lt;span&gt;class&lt;/span&gt;, TestRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, collector);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; collector.getOrderedRules();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;span&gt;org.junit.runners.ParentRunner&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ClassRuleCollector &lt;span&gt;implements&lt;/span&gt; MemberValueConsumer&amp;lt;TestRule&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;RuleContainer.RuleEntry&amp;gt; entries = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;RuleContainer.RuleEntry&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; accept(FrameworkMember member, TestRule value) {
            ClassRule rule &lt;/span&gt;= member.getAnnotation(ClassRule.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            entries.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuleContainer.RuleEntry(value, RuleContainer.RuleEntry.TYPE_TEST_RULE,
                    rule &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; ? rule.order() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;TestRule&amp;gt;&lt;span&gt; getOrderedRules() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (entries.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
            }
            Collections.sort(entries, RuleContainer.ENTRY_COMPARATOR);
            List&lt;/span&gt;&amp;lt;TestRule&amp;gt; result = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;TestRule&amp;gt;&lt;span&gt;(entries.size());
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (RuleContainer.RuleEntry entry : entries) {
                result.add((TestRule) entry.rule);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//org.junit.rules.RunRule
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunRules &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Statement {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Statement statement;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RunRules(Statement base, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules, Description description) {
        statement &lt;/span&gt;=&lt;span&gt; applyAll(base, rules, description);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        statement.evaluate();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Statement applyAll(Statement result, Iterable&amp;lt;TestRule&amp;gt;&lt;span&gt; rules,
            Description description) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (TestRule each : rules) {
            result &lt;/span&gt;=&lt;span&gt; each.apply(result, description);　　　　　　　　　　　　　　　　　　&lt;span&gt;//各个Rule真正执行的地方&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule扩展示例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;根据上述Rule特性的源码分析可知，Rule的扩展主要有三种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现TestRule接口&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;继承自内置Rule抽象类(Verifier，ExternalResource or TestWatcher)&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;继承自内置Rule抽象类的子类(ErrorCollector，TemporaryFolder，TestName，ExpectedException，Timeout or RuleChain)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面以第一种方式为例实现JUnit用例失败重试功能说明扩展Rule的一般用法，主要步骤如下：&lt;/p&gt;
&lt;p&gt;　　- 自定义Retry注解&lt;/p&gt;
&lt;p&gt;　　- 自定义Rule类实现TestRule接口&lt;/p&gt;
&lt;p&gt;　　- 在待测试类中使用自定义Rule&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//自定义Retry注解
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.ElementType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Retention;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.RetentionPolicy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Retry {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; times();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//扩展Rule类
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.rules.TestRule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.Description;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runners.model.Statement;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RetryRule &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestRule{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Statement apply(Statement statement, Description description) 
    {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Statement() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; evaluate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable 
            {
                Throwable retryThrowable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

                Retry retry &lt;/span&gt;= description.getAnnotation(Retry.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(retry != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
                {
                    
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; times =&lt;span&gt; retry.times();
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;times; i++&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                        {
                            statement.evaluate();
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Throwable t)
                        {
                            retryThrowable &lt;/span&gt;=&lt;span&gt; t;
                            System.err.println(&lt;/span&gt;&quot;Run method &quot; + description.getMethodName() + &quot;: failed for &quot; + (i+1) + &lt;br/&gt;　　　　　　　　　　　　　　　　　　　　　　((i+1) == 1 ? &quot; time&quot; : &quot; times &quot;&lt;span&gt;));
                        }
                    }
                    
                    System.err.println(&lt;/span&gt;&quot;Run method &quot; + description.getMethodName() + &quot; : exited after &quot; + times + &quot; attempts&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    statement.evaluate();
                }
            }    
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//待测试类
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.fail;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.FixMethodOrder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Rule;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runners.MethodSorters;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRetryRuleTest 
{
    @Rule
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RetryRule retryRule = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RetryRule();
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMethodA() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        System.out.println(&lt;/span&gt;&quot;test methodA...&quot;&lt;span&gt;);
    }
    
    @Test
    @Retry(times&lt;/span&gt;=3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMethodB() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        fail();
        System.out.println(&lt;/span&gt;&quot;test methodB...&quot;&lt;span&gt;);
    }
    
    @Retry(times&lt;/span&gt;=5&lt;span&gt;)
    @Test(timeout&lt;/span&gt;=10&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMethodC() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        Thread.sleep(&lt;/span&gt;10&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;test methodC...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//测试执行结果
&lt;/span&gt;&lt;span&gt;test methodA...
Run method testMethodB: failed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 1&lt;span&gt; time
Run method testMethodB: failed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 2&lt;span&gt; times 
Run method testMethodB: failed &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; 3&lt;span&gt; times 
Run method testMethodB : exited after &lt;/span&gt;3&lt;span&gt; attempts
test methodC...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 当然扩展Rule除了以上三种方式外，还有其他的间接方式实现同样的效果，因为本篇的主旨是自定义Rule，所以其他的扩展方式暂不涉及。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;JUnit Rule总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事实上Rule特性实现的功能也可以通过其他的扩展方式完成，这个需要根据项目平台及小组技能栈来确定哪种方式更灵活。多了解些测试工具内部的实现原理和执行流程可以让我们更全面地评估同类开发或测试工具各自的优劣势，在遇到不同类型问题的时候选择成本更低、效果更好的解决方案。当然，对于优秀的开源框架，吸收其经典的设计思想也是自建高效框架的必由之路。&lt;/p&gt;

</description>
<pubDate>Mon, 15 Oct 2018 12:02:00 +0000</pubDate>
<dc:creator>coolstream</dc:creator>
<og:description>JUnit Rule简述 Rule是JUnit 4.7之后新加入的特性，有点类似于拦截器，可以在测试类或测试方法执行前后添加额外的处理，本质上是对@BeforeClass, @AfterClass,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coolstream/p/9756334.html</dc:identifier>
</item>
</channel>
</rss>