<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>图解HTTP学习笔记 - 你假装没察觉</title>
<link>http://www.cnblogs.com/heavenYJJ/p/9201790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heavenYJJ/p/9201790.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一直觉得自己在HTTP基础方面都是处于知其然，不知其所以然的样子。最近利用空闲时间拜读了一下图解HTTP，写篇博客记录一下读书笔记。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP三次握手：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 发送端首先发送一个带SYN标志的数据包给对方&lt;/p&gt;
&lt;p&gt;② 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认消息&lt;/p&gt;
&lt;p&gt;③ 发送端再回传一个带ACK标志的数据包，代表“握手结束”&lt;/p&gt;
&lt;p&gt;注意：若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于Cookie：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 目前我们用的比较多的用户鉴权的方法有两种：cookie和Authorization。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Authorization&lt;/strong&gt;：用户登录成功后在Response Headers或者在URL里面返回Authorization，然后前端拿到Authorization后进行处理，在每次进行HTTP请求时将该Authorization带在Request Headers上。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217259/201806/1217259-20180619234751675-270022918.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;：用户登录成功后，Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后再发送出去。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217259/201806/1217259-20180619235327431-1284283159.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;很明显这两种方式对于前端来说当然是第二种Cookie的方式更爽点，因为第二种方式前端不需要做任何事情&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HTTP首部：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; HTTP首部根据实际用途分为：通用首部字段、请求首部字段、响应首部字段、实体首部字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用首部字段&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;首部字段名&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;控制缓存的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;逐跳首部、连接的管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;创建报文的日期时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Pragma&lt;/td&gt;
&lt;td&gt;报文指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Trailer&lt;/td&gt;
&lt;td&gt;报文末端的首部一览&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;指定报文主体的传输编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;升级为其他协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;代理服务器的相关信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Waring&lt;/td&gt;
&lt;td&gt;错误通知&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;请求首部字段&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;NormalTable&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;首部字段名&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;用户代理可处理的媒体类型&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Charset&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;优先的字符集&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Encoding&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;优先的内容编码&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Language&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;优先的语言（自然语言）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Authorization&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Web&lt;span class=&quot;fontstyle0&quot;&gt;认证信息&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Expect&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;期待服务器的特定行为&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;From&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;用户的电子邮箱地址&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Host&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;请求资源所在服务器&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Match&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较实体标记（&lt;span class=&quot;fontstyle2&quot;&gt;ETag&lt;span class=&quot;fontstyle0&quot;&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Modified-Since&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较资源的更新时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-None-Match&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较实体标记（与 &lt;span class=&quot;fontstyle2&quot;&gt;If-Match &lt;span class=&quot;fontstyle0&quot;&gt;相反）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Range&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源未更新时发送实体 &lt;span class=&quot;fontstyle2&quot;&gt;Byte &lt;span class=&quot;fontstyle0&quot;&gt;的范围请求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Unmodified-Since&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较资源的更新时间（与&lt;span class=&quot;fontstyle2&quot;&gt;If-Modified-Since&lt;span class=&quot;fontstyle0&quot;&gt;相反）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Max-Forwards&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;最大传输逐跳数&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Proxy-Authorization&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代理服务器要求客户端的认证信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Range&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体的字节范围请求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Referer&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;对请求中 &lt;span class=&quot;fontstyle2&quot;&gt;URI &lt;span class=&quot;fontstyle0&quot;&gt;的原始获取方&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;TE&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;传输编码的优先级&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;User-Agent&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;HTTP &lt;span class=&quot;fontstyle0&quot;&gt;客户端程序的信息&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;响应首部字段&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;NormalTable&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;首部字段名&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Ranges&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;是否接受字节范围请求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Age&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;推算资源创建经过时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;ETag&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源的匹配信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Location&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;令客户端重定向至指定&lt;span class=&quot;fontstyle2&quot;&gt;URI&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Proxy-Authenticate&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代理服务器对客户端的认证信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Retry-After&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;对再次发起请求的时机要求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Server&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;HTTP&lt;span class=&quot;fontstyle0&quot;&gt;服务器的安装信息&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Vary&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代理服务器缓存的管理信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;WWW-Authenticate&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;服务器对客户端的认证信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体首部字段 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table class=&quot;NormalTable&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;首部字段名&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Allow&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源可支持的&lt;span class=&quot;fontstyle2&quot;&gt;HTTP&lt;span class=&quot;fontstyle0&quot;&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Encoding&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体适用的编码方式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Language&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的自然语言&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Length&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的大小（单位： 字节）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Location&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;替代对应资源的&lt;span class=&quot;fontstyle2&quot;&gt;URI&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-MD5&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的报文摘要&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Range&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的位置范围&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Type&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的媒体类型&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Expires&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体过期的日期时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Last-Modified&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源的最后修改日期时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;状态码：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;52&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;1XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;信息性状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;接收的请求正在处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;2XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;成功状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;请求正常处理完毕&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;3XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;重定向状态码&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;需要进行附加操作以完成请求&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;4XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;客户端错误状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;服务器无法处理请求&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;5XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;服务器错误状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;服务器处理请求出错&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;常用的一些状态码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200 OK：表示从客户端发来的请求在服务器端被正常处理了&lt;/p&gt;
&lt;p&gt;204 No Content：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。一般用于在需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下下。&lt;/p&gt;
&lt;p&gt;206 Partial Content：该状态码表客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容&lt;/p&gt;

&lt;p&gt;301 Moved Permanently：永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。&lt;/p&gt;
&lt;p&gt;302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。与301的区别是，代表资源不是被永久移动，只是临时性质的。&lt;/p&gt;
&lt;p&gt;303 See Other：该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303和302有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源。&lt;/p&gt;
&lt;p&gt;304 Not Modified：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。&lt;/p&gt;
&lt;p&gt;307 Temporary Redirect：临时重定向。该状态码和302有相同的含义，但是307不会将POST变成GET&lt;/p&gt;

&lt;p&gt;400 Bad Request：该状态码表示请求报文中存在语法错误。&lt;/p&gt;
&lt;p&gt;401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。&lt;/p&gt;
&lt;p&gt;403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。&lt;/p&gt;
&lt;p&gt;404 Not Found：表明服务器上无法找到请求的资源。&lt;/p&gt;

&lt;p&gt;500 Internal Server Error：表明服务器端在执行请求时发生了错误。&lt;/p&gt;
&lt;p&gt;503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一次将本书读完后有一种这样的感觉，书中提到的很多知识点都是有所了解或者都能看懂，但是过了一段时间后发现很多地方又忘了，后面找机会再来拜读一下这本书。&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 20 Jun 2018 15:37:00 +0000</pubDate>
<dc:creator>你假装没察觉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heavenYJJ/p/9201790.html</dc:identifier>
</item>
<item>
<title>我和Python的Py交易》》》》》》函数 - BarkingPig</title>
<link>http://www.cnblogs.com/barkingpig/p/9104056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/barkingpig/p/9104056.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;一 函数是什么？  是数学中的函数？&lt;/h2&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;hr/&gt;&lt;h4&gt;&lt;span&gt;Python中&lt;/span&gt; 函数是指将一组语句的集合通过一个名字&lt;span&gt;(函数名)&lt;/span&gt;封装起来的一段代码。（所以这里的函数是&lt;span&gt;subroutine子程序&lt;/span&gt;）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;那要函数干嘛。不都是代码吗？只不过函数是通过一个名字被封装起来的一段代码。&lt;/span&gt;&lt;span&gt;有名字就就了不起啊！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对啊，有名字就是了不起啊，函数可以通过&lt;span&gt;函数名来调用&lt;span&gt;被其封装起来的代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可以理解为是一个&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;（&lt;span&gt;函数名&lt;/span&gt;）指向的一段代码。这个变量（&lt;span&gt;函数名&lt;/span&gt;）只是一段&lt;span&gt;没有执行&lt;/span&gt;的代码，&lt;span&gt;变量()&lt;/span&gt;（&lt;span&gt;函数名()&lt;/span&gt;）是表示&lt;span&gt;执行&lt;span&gt;这段代码&lt;/span&gt;&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 函数的作用&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.代码重用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如:一段用来求两数之和的代码通过一个函数名封装成&lt;span&gt;一个函数&lt;/span&gt;，&lt;span&gt;每当需要&lt;/span&gt;求和功能时就不用在把这段代码敲出来了，直接用函数名来&lt;span&gt;调用&lt;/span&gt;这段代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这样这一段求被封装成函数的求和代码就被&lt;span&gt;重复的使用&lt;/span&gt;了很多次。（还省了你敲代码的时间）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.保持一致性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 每一个调用的函数都是同一个，代码都都是一样的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.易扩展性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;&lt;span&gt;因为函数保持一致性，所有修改函数，为函数添加新功能时，只要修改一次，所有调用的该函数都会跟着变。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt; 二 建个函数玩玩&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;Python 定义函数使用 def 关键字（&lt;span&gt;Definition&lt;span class=&quot;op_dict_text1 c-gap-right&quot;&gt;n  &lt;span class=&quot;op_dict_text2&quot;&gt;定义&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; 函数名(&lt;code class=&quot;python plain&quot;&gt;参数列表&lt;/code&gt;):
    函数主体(被封装起来的一段代码)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_name():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;有名字就是了不起！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
have_name&lt;span&gt;()  &lt;span&gt;# 用函数名调用函数  have_name函数名是指被封装的代码，have_name()代表是执行这段代码。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;函数名的命名规则&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数名必须以下划线或字母开头，可以包含任意字母、数字或下划线的组合。不能使用任何的标点符号；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数名是区分大小写的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数名不能是保留字。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;想要写出高质量的代码，规范的命名是必不可少的。期待吧，少年，我会开单章随笔来，叨叨这个命名的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;形参和实参&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;形参&lt;/span&gt;&lt;/strong&gt;：&lt;strong&gt;形式上的参数，是应函数的&lt;span&gt;需求&lt;/span&gt;虚拟出变量。当调用这个函数时，就会传一个参数（&lt;span&gt;实参&lt;/span&gt;）给形参，这样虚拟的变量就变真实了（&lt;span&gt;实参个数，类型应与实参一一对应&lt;/span&gt;）；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实参&lt;/span&gt;：实际参数，调用函数时传给函数的参数，&lt;span&gt;可以是常量，变量，表达式，函数，传给形参&lt;/span&gt;   ；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;span&gt;打个比喻来形象的说明形参和实参的关系，在数学的函数 F(X)=X+1 中，X就是形参（&lt;span&gt;这个时候X不代表任何具体的值&lt;/span&gt;），而当把X=1带人这个F(X)函数时，1就是实参。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;区别&lt;/span&gt;：形参是虚拟的，不占用内存空间，形参变量只有在被调用时才分配内存单元，实参是一个变量，占用内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; tow_sum(a,b):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个里的a和b是没有分配内存空间的&lt;/span&gt;
    c=a+b          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里的a和b是分配了内存空间的&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

tow_sum(&lt;/span&gt;1,2)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1和2 是实参为其分配了内存空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;三 和函数形参的促膝长谈&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;函数的形参可以是&lt;span&gt;各种数据（数字，字符串，元组，列表，字典等），函数名等……&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;函数形参（参数）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;关键字参数&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;默认参数&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;非关键字可变长参数（元组）&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;关键字可变长参数（字典）&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;关键字参数&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;标准调用&lt;/span&gt;时指定参数的名称，且与函数声明时的参数名称&lt;span&gt;顺序一致&lt;/span&gt;。使用&lt;span&gt;关键字调用&lt;/span&gt;参数允许函数调用时参数的顺序与声明时&lt;span&gt;不一致&lt;/span&gt;，仅根据参数的指定进行赋值。&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gu(a,b):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; b==2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标准调用&lt;/span&gt;
gu(1,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关键字调用（可以不按顺序）&lt;/span&gt;
gu(b=2,a=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;默认参数&lt;/strong&gt;&lt;/span&gt;：&lt;strong&gt;在函数声明时，指定形参的默认值，调用时可不传入改参数（&lt;span&gt;使用默认值&lt;/span&gt;）。&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(a=1,b=&lt;span&gt;0):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; b==2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

gu()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;
&lt;span&gt;
gu(&lt;/span&gt;2,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;span&gt;
gu(b&lt;/span&gt;=2,a=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;非关键字可变长参数（元组）&lt;/strong&gt;&lt;/span&gt;：“&lt;span&gt;非关键字&lt;/span&gt;”“&lt;span&gt;可变长&lt;/span&gt;”顾名思义是允许在调用时传入多个“&lt;span&gt;非关键字&lt;/span&gt;”参数，python会将这些多出来的&lt;span&gt;参数放入一个元组中&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(*&lt;span&gt;s):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(s))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)

gu(&lt;/span&gt;1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  &lt;span&gt; &lt;span&gt;#可变长，爱有几个参数就调几个参数&lt;/span&gt;&lt;/span&gt;

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'tuple'&amp;gt;  元组&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (1, '钟鼓馔玉不足贵，但愿长醉不复醒。', 2, '古来圣贤皆寂寞，惟有饮者留其名。')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;关键字可变长参数（字典）&lt;/strong&gt;&lt;/span&gt;：“&lt;span&gt;关键字&lt;/span&gt;”“&lt;span&gt;可变长&lt;/span&gt;”顾名思义是允许在调用时传入多个“关键字”参数，python会将这些多出来的&lt;span&gt;&amp;lt;参数名, 参数值&amp;gt;放入一个字典中&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(**&lt;span&gt;s):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(s))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

gu(a&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  &lt;span&gt;#可变长，爱有几个参数就调几个参数&lt;/span&gt;

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'dict'&amp;gt;  字典&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; {'a': '钟鼓馔玉不足贵，但愿长醉不复醒。', 'b': '古来圣贤皆寂寞，惟有饮者留其名。'}&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要注意的是当它们&lt;span&gt;混用时&lt;/span&gt;，关键字变量参数应该为函数定义的最后一个参数，带**&lt;/strong&gt;。&lt;strong&gt;调用函数时参数的输入也有不同的方式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(a,b,*c,**&lt;span&gt;d):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
gu(&lt;/span&gt;1,2,3,f=7,g=8&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (3,)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; {'f': 7, 'g': 8}&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; gu(a,b,*c,**&lt;span&gt;d):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
gu(&lt;/span&gt;1,2,*(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,),**{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; ('钟鼓馔玉不足贵，但愿长醉不复醒',)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; {'t': '钟鼓馔玉不足贵，但愿长醉不复醒。', 'f': '古来圣贤皆寂寞，惟有饮者留其名。'}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;四 给回扣的返回值&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;要想获取函数的执行结果，就可以用return语句把结果返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;return返回值可以是&lt;/strong&gt;&lt;span&gt;各种数据（数字，字符串，元组，列表，字典等），函数名等……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;函数在执行过程中只要遇到return语句，就会停止执行并返回结果，so 也可以理解为 return 语句代表着函数的结束&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果未在函数中指定return,那这个函数的返回值为None，Python会自动给函数加 &lt;span&gt;return None&lt;/span&gt;。&lt;br/&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;return多个对象，解释器会把这多个对象&lt;span&gt;组装成一个元组&lt;/span&gt;作为&lt;span&gt;一个整体&lt;/span&gt;结果输出。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gu(a):
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a

b &lt;/span&gt;= gu(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;五 就是比你高的高阶函数&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;高阶函数&lt;/strong&gt;是&lt;strong&gt;&lt;span&gt;至少满足下列一个条件的函数&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;接受一个或多个函数作为输入（&lt;span&gt;参数&lt;/span&gt;）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出一个函数（&lt;span&gt;return 返回值&lt;/span&gt;）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;递归函数，修饰器也都是高阶函数的运用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;六 鞭长莫及的作用域&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;作用域研究的是数据的&lt;span&gt;适用范围&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;就像地球的重力加速度g在火星上就不适用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; globe():
    g &lt;/span&gt;= 9.8

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mars():
    g &lt;/span&gt;= 3.71
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;上述代码中两个g是&lt;span&gt;毫无关系的&lt;/span&gt;，因为&lt;span&gt;它们的作用域不同一个函数就是一个作用域&lt;/span&gt;。在globe()中的g的只在globe函数中适用，另一个g也是是如此。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这只是作用域的小小体现，&lt;span&gt;作用域不只在函数中有，在类，包中都有体现 。还有如何去调用，修改不同作用域里的数据&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这些都会开单章来唠叨一下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;七 自娱自乐的递归&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;定义：一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 说白了就是自己和自己玩（单身人士都懂的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 必须有一个明确的&lt;span&gt;结束条件 &lt;span&gt;（不可自娱自乐太久要有个度）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 每次进入更深一层递归时，问题规模相比上次递归都应有所减少  &lt;span&gt;（每自娱自乐一次总得缓解一下单身狗的苦）&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 递归效率不高，递归层次&lt;span&gt;过多&lt;/span&gt;会导致栈溢出。&lt;span&gt;（自娱自乐多了伤身）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注释：(在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数执行结束，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;阶乘的计算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; **********循环*********&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
    result &lt;/span&gt;=&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;, n):
        result &lt;/span&gt;*=&lt;span&gt; i

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(factorial(3&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; **********递归*********&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial_new(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 递归结束条件&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
    result&lt;/span&gt;=factorial_new(n - 1&lt;span&gt;)
    result &lt;/span&gt;= n *&lt;span&gt; result
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

a &lt;/span&gt;= factorial_new(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1361614/201806/1361614-20180620204420215-1637384221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;递归函数是定义简单，逻辑清晰。理论上，所有的递归函数都可以写&lt;span&gt;成循环的方式&lt;/span&gt;，但循环的逻辑不如递归清晰。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;八 良心的内置函数&lt;/h2&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;内置函数就是Python提供的，可以直接使用的函数，&lt;span&gt;所以&lt;strong&gt;&lt;span&gt;内置函数一般都是使用频繁的函数。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以后会仔细说一下有哪些内置函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;九 无副作用的函数式编程&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;常见的编程范式有&lt;span&gt;命令式编程&lt;/span&gt;，&lt;span&gt;函数式编程&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;命令式编程&lt;/span&gt;&lt;/strong&gt;：是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），&lt;span&gt;命令式程序就是一个冯诺依曼机的按照打孔纸带执行指令。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;函数式编程&lt;/span&gt;：&lt;/span&gt;是面向数学的抽象，&lt;span&gt;&lt;strong&gt;他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念，&lt;/strong&gt;&lt;/span&gt;一句话，&lt;span&gt;函数式程序就是一个表达式&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向过程编程，面向对象编程&lt;/span&gt;都是&lt;span&gt;命令式编程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;函数式编程的本质&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;函数式编程中的&lt;span&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/span&gt;这个术语不是指计算机中的函数，而是指&lt;span&gt;数学中的函数&lt;/span&gt;，即&lt;span&gt;自变量的映射&lt;/span&gt;。也就是说一个函数的值仅决定于&lt;span&gt;函数参数的值&lt;/span&gt;，不依赖其他状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;我们要做的是把函数传来传去，而这个，说成术语，我们把他叫做高阶函数&lt;/strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;函数是基本单位，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;变量只是一个名称，而不是一个存储单元，&lt;span&gt;这是函数式编程与传统的命令式编程最典型的不同之处&lt;/span&gt;。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;函数式编程取消了&lt;span&gt;赋值模型&lt;/span&gt;，则使&lt;span&gt;数学模型与编程模型完美地达成了统一&lt;/span&gt;&lt;/strong&gt;。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;函数式编程&lt;span&gt;&lt;span&gt;关心&lt;/span&gt;数据的映射&lt;/span&gt;，命令式编程&lt;span&gt;&lt;span&gt;关心&lt;/span&gt;解决问题的步骤。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;zm-editable-content clearfix&quot; readability=&quot;43.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算列表中数的平均值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;***********命令式编程***************&lt;/span&gt;
number = [0,1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]
count &lt;/span&gt;=&lt;span&gt; 0
add &lt;/span&gt;=&lt;span&gt; 0

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(number)):
        count &lt;/span&gt;+= 1          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一步 计数&lt;/span&gt;
        add+= number[i]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二步 求和&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; count &amp;gt;&lt;span&gt; 0:
    average &lt;/span&gt;= add/ count   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第三步 计算平均数&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(average)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;***********函数式编程***************&lt;/span&gt;
number = [0,1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]
average &lt;/span&gt;= sum(number) /&lt;span&gt; len(number)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(average)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎评论，番茄，鸡蛋都砸过来吧！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 20 Jun 2018 15:24:00 +0000</pubDate>
<dc:creator>BarkingPig</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/barkingpig/p/9104056.html</dc:identifier>
</item>
<item>
<title>哈工大 软件构造课程 考点复习总结（第三章） - 丿隔岸观灬</title>
<link>http://www.cnblogs.com/standingby/p/9206630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/standingby/p/9206630.html</guid>
<description>&lt;ol&gt;&lt;li&gt;
&lt;p&gt;
&lt;h2&gt;数据类型&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;8&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Primitive types 基本数据类型（8种）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Object types 对象数据类型（reference types 引用数据类型）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Short、int 、long、float、double、boolean、char、byte&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;如：String、BigInteger&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;只有值，没有ID（无法与其他值区分），&lt;strong&gt;不能赋值为null&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;immutable&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;有值，也有ID；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;部分mutable，部分immutable&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;在栈中分配内存，代价低&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;在堆中分配内存，代价高&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;静态类型检查&amp;amp;动态类型检查&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;静态类型检查&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;动态类型检查&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;（静态类型语言 如java）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;（动态类型语言 如python）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;提高程序的正确性和健壮性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;关于&quot;类型&quot;的检查，不考虑值（不知道运行时会是什么值）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;关于&quot;值&quot;的检查&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;
&lt;div&gt;
&lt;h2&gt;&lt;span&gt;Mutable &amp;amp; Immutable&lt;/span&gt;&lt;/h2&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;7&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Immutable 不可变数据类型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Immutable 不可变数据类型&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;优点：安全&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;优点：最少化拷贝以提高效率获得更好的性能，适合于在多个模块之间共享数据&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;缺点：频繁修改产生大量临时拷贝，需要垃圾回收·&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;缺点：不安全&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;其他&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;一旦被创建，其值不能改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于引用类型，加final限制不能改变引用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;安全地使用可变类型：局部变量（不涉及共享，且只有一个引用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有多个引用（别名），不安全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Defensively copy 防御式拷贝：返回全新的对象&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;尽可能用immutable！&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232145360-1147022755.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;h2&gt;Snapshot Diagram 画法：&lt;/h2&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;基本类型：单独一个常量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引用类型：圈住！&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232145810-263174034.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;span&gt;重分配：&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不可变类型（用双线椭圆），修改引用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可变类型：修改值&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232146329-589397109.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;span&gt;引用：&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可变引用：单线箭头&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不可变引用：双线箭头&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;
&lt;h2&gt;&lt;span&gt;Specification&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol readability=&quot;11.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;作用&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;规约可以隔离&quot;变化&quot;，无需通知客户端&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;规约可以提高代码效率&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;规约扮演&quot;防火墙&quot;角色&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;解耦，不需要了解具体实现&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;内容：只讲&quot;能做什么&quot;，而不讲&quot;怎么实现&quot;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Behavior equivalence 行为等价性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是否可以相互替换&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;站在客户端的视角看行为等价性，不同的行为，对用户来说（根据用户需求）可能等价！&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;根据规约判断行为等价，两个方法符合同一个规约，则等价&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;规约的结构：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;Pre-condition&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Post-condition&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Exceptional behavior 异常行为，如果违背了前置条件，会发生什么&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt;规约的强度与替换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spec变强：更放松的前置条件（前置条件更弱）+更严格的后置条件（后置条件你更强），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两条件同时变强或变弱则无法比较。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若规约强度S2&amp;gt;=S1，则可以用S2替换S1。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;deterministic spec &amp;amp; undetermined spec 确定的规约和欠定的规约&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;确定的规约：给定一个满足前置条件的输入，其输出唯一、明确&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;欠定的规约：同一个输入可以有多个输出（多次执行输出可能不同）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;Declarative spec &amp;amp; operational spec 声明式规约和操作式规约&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;操作式规约：如 伪代码&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;声明式规约&lt;/strong&gt;：没有内部实现的描述，只有&quot;初-终&quot;状态&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;声明式规约更有价值！&lt;/p&gt;
&lt;p&gt;内部实现的细节不在规约里呈现，而放在代码实现体内部注释里呈现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232146803-101849120.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;span&gt;Diagraming specification&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;规约定义一个区域，该区域包含所有可能的实现方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空间中的每个点表示一种方法的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于某个具体实现，若满足规约，则落在其区域内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更强的规约表达为更小的区域。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Quality of specification 规约质量&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;内聚性：spec描述的功能应单一、简单、易理解&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;运行结果信息丰富（可能的改变，以及返回值等），不能让客户端产生理解上的歧义&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;足够强（如postcondition中充分阐述各种情况）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;适当弱（太强的规约，在很多特殊情况下难以达到）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;在规约里使用抽象类型（在java中，经常使用interface，如Map、List，而不是HashMap、ArrayList），可以给方法的实现体和客户端更大的自由度&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;使用前置条件和后置条件？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端不喜欢太强的pre-condition，不满足precondition的输入会导致失败&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;So：不限定太强的precondition，而在postcondition中抛出异常：输入不合法，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fail fast，避免fail大规模扩散&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        是否使用前置条件取决于：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;check（检查参数合法性）的代价&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;方法的使用范围：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果只在类内部使用（private），则可以不使用precondition，在使用该方法的各个位置进行check&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;如果在其他地方使用（public），则必须使用precondition，若client不满足则抛出异常&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;&lt;span&gt;Pre-condition and post-condition 前置条件和后置条件&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;7&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Pre-condition 前置条件（requires）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Post-condition 后置条件（effects）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;@param&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;@return @throws&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;对客户端的约束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在使用方法时必须满足的条件&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;对开发者的约束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法结束时必须满足的条件&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;契约：如果前置条件满足了，后置条件必须满足&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;除非在后置条件中声明，否则方法内部不应该改变输入参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽量不设计mutating的spec，否则容易引发bugs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽量避免使用mutable对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;避免使用可变的全局变量。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;ADT&lt;/h3&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;
&lt;h2&gt;ADT及其四种操作&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;抽象类型：强调&quot;作用于数据上的操作&quot;，程序员和client无需关心数据如何具体存储，只需设计/使用操作即可。&lt;/p&gt;
&lt;p&gt;ADT由操作定义，与其内部实现无关。&lt;/p&gt;
&lt;p&gt;可变数据类型：提供了可改变其内部数据值的操作；&lt;/p&gt;
&lt;p&gt;不可变数据类型：其操作不改变内部值，而构造新的对象。（&lt;strong&gt;没有mutators&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ADT操作分类：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Creators 构造器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不利用该类型对象产生一个新的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能实现为构造函数或静态函数（factory method）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Producers 生产器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用已有该类型对象产生新对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如string.concat()（连接两个字符串，产生一个新的字符串）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Observers 观察器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如list.size()返回int（不同于原类型）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;Mutators 变值器（改变对象属性的方法）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常范围void，如果返回void，则必然意味着它改变了某些对象的内部状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可能范围非空类型（如容器类的put、add方法）&lt;/span&gt;&lt;/p&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Representation Independence 表示独立性&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;表示独立性：client使用ADT时无需考虑其内部如何实现，ADT内部表现的变化不应该影响外部spec和客户端。&lt;/p&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Representation exposure 表示泄漏&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如client能直接接触类成员变量。&lt;/p&gt;
&lt;p&gt;表示泄漏影响表示不变量，也影响表示独立性：无法在不影响客户端的情况下改变其内部表示。&lt;/p&gt;
&lt;p&gt;避免方法：private、final、defensive copy&lt;/p&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Invariants 不变量 &amp;amp; Representation Invariant 表示不变量&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ADT应保持其不变量在任何时候总是true；&lt;/p&gt;
&lt;p&gt;ADT负责其不变量，与client的任何行为无关。&lt;/p&gt;
&lt;p&gt;作用：保持程序的&quot;正确性&quot;，容易发现错误。&lt;/p&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Abstraction Function 抽象函数&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232147683-613468295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;表示空间R&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;抽象空间A&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;值的实际实现本质&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;抽象表示（client看到和使用的值）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;ADT实现者关注表示空间R&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;用户关注抽象空间A&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;p&gt;R到A的映射&lt;/p&gt;
&lt;p&gt;一定是满射：A中元素总有R中具体的实现&lt;/p&gt;
&lt;p&gt;未必是单射：A中一个元素在R中可能有多重实现方式&lt;/p&gt;
&lt;p&gt;未必是双射：R中表示不符合A中需求（如图中&quot;abbc&quot;）&lt;/p&gt;

&lt;p&gt;抽象函数AF：R和A之间映射关系的函数&lt;/p&gt;
&lt;p&gt;AF：R-&amp;gt;A&lt;/p&gt;

&lt;p&gt;对于RI ：R-&amp;gt; Boolean&lt;/p&gt;
&lt;p&gt;RI：某个具体的&quot;表示&quot;是否合法；表示值的一个子集，包含所有合法的表示值；一个条件，描述了什么是&quot;合法&quot;表示值。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232148253-1168609471.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;h2&gt;Documenting AF 、RI、Safety from Rep Exposure&lt;/h2&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;选择某种特定的表示方式R&lt;/p&gt;
&lt;p&gt;进而指定某个子集是&quot;合法&quot;的（RI）&lt;/p&gt;
&lt;p&gt;并为该子集中的每个值做出&quot;解释&quot;（AF）&lt;/p&gt;
&lt;p&gt;即 如何映射&lt;/p&gt;

&lt;p&gt;Safety from Rep Exposure&lt;/p&gt;
&lt;p&gt;证明代码并未对外泄露其内部表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232148738-1532579516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保证不变量为true，不变量：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;通过creators和producers创建&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;受mutators和observers保护&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;无表示泄漏发生&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;OOP&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;
&lt;h2&gt;Interface 接口&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接口的成员变量默认用final关键字修饰，故必须有初值，可用public，&lt;strong&gt;default&lt;/strong&gt;修饰，可用static修饰。&lt;/p&gt;
&lt;p&gt;接口的方法只能被public、default、abstract、static、strictfp（严格浮点运算）修饰。&lt;/p&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Inheritance、override 继承和重写&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Strict inheritance 严格继承：子类只能添加新方法，无法重写超类（父类）中的方法（final限制）。&lt;/p&gt;
&lt;p&gt;考虑final修饰类、方法、属性时的不同作用。&lt;/p&gt;
&lt;p&gt;Override 方法：具有一致的signature，复用的基本机制。&lt;/p&gt;

&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Polymorphism ，subtyping and overloading 多态，子类型化，重载&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;三种多态：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Ad hoc polymorphism （特殊多态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于function overloading（功能重载），即重载&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Parametric polymorphism （参数化多态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Subtyping （subtype polymorphism / inclusion polymorphism ）（子类型多态、包含多态）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;Overloading 重载&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;重载条件：&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;方法名相同&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;参数列表不同，即参数类型、个数、&lt;strong&gt;类型顺序&lt;/strong&gt;至少有一项不相同&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;返回值类型可以不同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;方法的修饰符可以不同&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;可以抛出不同的异常&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;可以在类内重载，也可以在子类重载&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;重载是一种静态多态，静态类型检查&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（static dispatch 静态分派）并在&lt;strong&gt;编译阶段&lt;/strong&gt;决定具体执行哪个方法（即对方法的调用取决于编译时声明的引用的类型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而&lt;span&gt;重写（dynamic dispatch 动态分派）则进行动态类型检查，根据&lt;strong&gt;运行时&lt;/strong&gt;堆中的实例类型选择方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Generic 泛型&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;通配符 &amp;lt;?&amp;gt; ：&lt;span&gt;只有使用泛型&lt;/span&gt;的时候出现，不能在定义中出现。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232149167-1151536273.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;span&gt;类型擦除：编译后、运行时类型擦除&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;List&amp;lt;Integer&amp;gt; -&amp;gt; List&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意可能引起重载编译错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232149623-835698736.png&quot; alt=&quot;&quot; align=&quot;left&quot;/&gt;&lt;span&gt;运行时不能用 instanceof 检查泛型。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;不能创建泛型数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不能用在静态变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不能创建对象（不能new）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Subtypes&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;超类的子类型，如：ArrayList和LinkedList是List的子类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子类型的规约不能弱化超类型的规约。&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;子类型多态：不同类型的对象可以统一处理而无需区分（不加区分地调用同样的方法等），从而隔离变化&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;LSP（Liskov Substitution Principle） 如果S是T的子类型，那么T的对象可以被S的对象替换。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;Type casting 类型转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;避免向下类型转换。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;Dispatch 分派&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;8&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Static dispatch 静态分派&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Dynamic dispatch 动态分派&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;将调用的名字与实际方法的名字联系起来（可能有多个）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;决定具体执行哪一个操作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;重载，在编译阶段即可确定执行哪个具体操作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;重写，在运行时决定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;Early/static binding&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;Lade/dynamic binding&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;绑定static、private、final方法时发生&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;重写父类子类的同样方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232150785-1358935031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340300/201806/1340300-20180620232151677-1723398404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;
&lt;p&gt;
&lt;h2&gt;equals()&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;引用等价性 ==&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比较内存地址ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于比较基本数据类型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;对象等价性 equals()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证正确性：reflexive 自反性、symmetric 对称性、transitive 传递性、非空（a.equals(null) return false）&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;hashCode()&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;等价的对象必须有相同的hashCode&lt;/p&gt;
&lt;p&gt;Rule：重写equals时重写hashcode&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;
&lt;h2&gt;Equality of Mutable Types 可变对象的等价性&lt;/h2&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;8&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Observational equality 观察等价性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Behavioral equality 行为等价性&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;在不改变状态的形况下，两个mutable看起来是否一致&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;调用对象的任何方法都展示出一致的结果&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;调用observer，producer，creator&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;调用任何方法，包括mutator&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;当前情况下，看起来（如成员变量）相同&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;经过改变后，依然相同（只是别名引用）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对不可变类型，观察等价性和行为等价性完全等价。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对可变类型，往往倾向于实现严格的观察等价性。（但有时观察等价性可能导致bug，甚至破坏RI）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对可变类型，应当实现行为等价性，即只有指向内从空间中同样的objects才相等（即equals比较引用，如==而hashcode把引用映射为一个值）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以对可变类型，无需重写equals和hashcode，直接继承object。（比较引用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若一定要判断两个可变对象是否一致，最好定义一个新的方法。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 15:22:00 +0000</pubDate>
<dc:creator>丿隔岸观灬</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/standingby/p/9206630.html</dc:identifier>
</item>
<item>
<title>程序自我更新之发布 - 上青天揽月</title>
<link>http://www.cnblogs.com/goldenbridge/p/9206617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goldenbridge/p/9206617.html</guid>
<description>&lt;p&gt;  　　一直以来程序安装与更新都是各开发者的入门知识。&lt;/p&gt;
&lt;p&gt;　　对于大型项目，更新可以花大量的时间与各种高阶技术进行处理。但对于小型程序甚至是特定单位的小众用户群体的程序有没有更简单的办法呢？&lt;/p&gt;
&lt;p&gt;　　Microsoft Visual Studio针对WinForm程序就内置了升级功能，无需要编码，只需要在发布的时候配置即可完成。&lt;/p&gt;
&lt;p&gt;　　首先Demo程序已经写好，发布流程如下：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620210230701-158318666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620210449623-1646291617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620213240041-916086784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从此步开始，可以看出发布有几种经典模式，选择任何一种，最后生成的安装程序会跟你选择的不同而不同，先从默认的来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 从CD-ROM或DVD-ROM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620221603389-426426105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;1 该应用程序不检查更新&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620221853761-227220291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击完成找到发布文件夹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620222207684-979085916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　执行setup.exe进行安装，安装后可以看到开始菜单有快捷方式，程序和功能也可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620222541498-1826323594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620222314944-1059668548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　1. 2 该应用程序从以下位置检查更新&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620223142445-1612933503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620223843763-1540571516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 从网站&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620224145938-848071027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620224319727-722083874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.1 是，该应用程序可以联机或脱机使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620224628934-1281220265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.2 否，该应用程序只能联机使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620225404965-1360198205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3 从UNC路径或文件共享&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620225717958-1333126175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620225754595-340510746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.1 是，该应用程序可以联机或脱机使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620230158838-490679389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3.2  否，该应用程序只能联机使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271598/201806/1271598-20180620230431383-1281093055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　综合上面3大类安装更新方式，发现很多相似之处。结合个人在实际中的应用觉得安装到客户机上，然后通过网站来提供更新是比较理想的模式。&lt;/p&gt;
&lt;p&gt;　　缺点：安装路径无法自己定义。&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 15:16:00 +0000</pubDate>
<dc:creator>上青天揽月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goldenbridge/p/9206617.html</dc:identifier>
</item>
<item>
<title>CTPN_论文阅读总结 - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9206564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9206564.html</guid>
<description>&lt;h2&gt;论文全名：Detecting Text in Natural Image with Connectionist Text Proposal Network&lt;/h2&gt;
&lt;h2&gt;1.摘要&lt;/h2&gt;
&lt;p&gt;（1）本文提出新型网络CTPN，用于自然图像中的文本行定位。CTPN直接在卷积特征映射中的一系列细粒度文本提议中检测文本行。（创新一）开发了一个垂直锚点机制，联合预测每个固定宽度提议的位置和文本、非文本的分数。（创新二）序列提议通过循环神经网络自然连接起来，该网络无缝的结合到卷积网络中，从而形成可训练的端到端模型。&lt;/p&gt;
&lt;h2&gt;2.引言&lt;/h2&gt;
&lt;p&gt;（1）图像文字检测的应用：图像OCR、多语言翻译、图像检索等。包括检测和识别两个任务，本文聚焦检测任务。由于文本模式的大变化以及背景的高度杂乱，使得检测任务一般比文字识别任务难度更大。&lt;/p&gt;
&lt;p&gt;（2）传统使用自下而上的方式，从低级别字符和笔画检测开始，步骤繁琐，现在普遍被神经网络所代替，无需自行查找特征。&lt;/p&gt;
&lt;p&gt;（3）目前主流的方法Faster-RCNN虽然用于一般目标检测效果良好，但是用在文本检测上并不令人满意。第一：主要由于文本的长度往往都是难以固定，不像一般物体一般都是有相对较固定额边界框；第二：一般物体IOU&amp;gt;0.5可能就可以识别出物体的种类，而文字识别需要更精确的IOU，因为仅仅大于0.5可能根本无法识别出文字。&lt;/p&gt;
&lt;h2&gt;3.贡献&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620210108841-44040230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图一：（a）连接文本提议网络（CTPN）的架构。首先通过VGG16的最后一个卷积映射（conv5）密集的滑动3*3空间窗口。每行的序列窗口通过双向LSTM（BLSTM）循环连接，其中每个窗口的卷积特征（3*3*C）被用作256维的BLSTM（包括两个128维的LSTM）的输入。RNN层连接到512维的全连接层，接着是输出层，联合预测k个锚点的文本、非文本分数，y轴坐标坐标（包括坐标和高度）和边缘调整偏移。（b）CTPN输出连续的固定宽度细粒度文本提议。每个框的颜色表示文本/非文本的分数。只显示文本框正例的分数。&lt;/p&gt;
&lt;p&gt;（1）贡献一：开发了一个垂直锚点机制，联合预测每个固定宽度提议的位置和文本、非文本的分数。&lt;/p&gt;
&lt;p&gt;（2）贡献二：序列提议通过循环神经网络自然连接起来，该网络无缝的结合到卷积网络中，从而形成可训练的端到端模型。&lt;/p&gt;
&lt;p&gt;在ICDAR2013,2015数据集上都取得了很好的成绩。&lt;/p&gt;
&lt;h2&gt;4.相关工作&lt;/h2&gt;
&lt;p&gt;（1）文本检测：过去都是使用自下而上的方法为主，粗略分为连接组件（CC）和基于滑动窗口的方法。特征手动设计，鲁棒性差，设计特征本身往往也十分困难，另外滑动窗口的方法在计算上也十分昂贵。&lt;/p&gt;
&lt;p&gt;（2）目标检测：从选择性搜索的RCNN发展到了RPN网络提供候选框的Faster-RCNN,RPN提议不具有判别性，需要通过额外得成本高昂的CNN模型进一步细化和分类。更重要的是，文本和一般目标检测很大的不同，因此很难直接将通用的目标检测系统应用到这个高度领域化的任务中。&lt;/p&gt;
&lt;h2&gt;5.连接文本提议网络&lt;/h2&gt;
&lt;p&gt;本节详细介绍网络的细节，它包括三个关键的贡献，使文本定位可靠和准确：检测细粒度提议文本，循环连接文本提议和边缘细化。&lt;/p&gt;
&lt;h3&gt;（1）在细粒度提议中检测文本&lt;/h3&gt;
&lt;p&gt;输入的图像任意大小，VGG网络架构决定了总步长和感受野固定为16个和228个像素。而本文锚点的宽度恰好固定为16，刚好各个框互相挨着且不重叠。&lt;/p&gt;
&lt;p&gt;文中k个锚点框，k设置成10，其高度从11个像素到273个像素（每次÷0.7），位置通过高度和y中心坐标度量。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620214727449-1190051522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中V={Vc,Vh},V*={V*c,V*h}分别是相对的预测坐标和相对的实际坐标，Cya,ha分别是锚点框的y轴中心高度，Cy,h是输入图片中预测的y轴坐标和高度，C*y，h*是输入图片的实际坐标和高度。&lt;/p&gt;
&lt;p&gt;检测到的文本提议是从&amp;gt;0.7（具有非极大值抑制）的文本/非文本分数的锚点生成的。&lt;/p&gt;
&lt;h3&gt;（2）循环连接文本提议&lt;/h3&gt;
&lt;p&gt;RNN类型：BLSTM（双向LSTM），每个LSTM有128个隐含层。&lt;/p&gt;
&lt;p&gt;RNN输入：每个滑动窗口的3*3*C的特征（可以拉成一列），同一行的窗口的特征形成一个序列。&lt;/p&gt;
&lt;p&gt;RNN输出：每个窗口对应256维特征。&lt;/p&gt;
&lt;p&gt;整个感受野理论上可以覆盖228*width.&lt;/p&gt;
&lt;h3&gt;（3）边缘细化&lt;/h3&gt;
&lt;p&gt;文本行的构建规则。后面详细补充。&lt;/p&gt;
&lt;p&gt;与y中心坐标预测类似，下面是x坐标的相对偏移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620222308870-418476664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文中每个锚点都预测了x坐标的偏移（这个步骤不是后处理计算的），如图一所示，但最终只使用了文本行边缘的提议。即左右两边。&lt;/p&gt;
&lt;h3&gt;（4）模型输出和损失函数&lt;/h3&gt;
&lt;p&gt;提出的CTPN有三个输出共同连接到最后的FC层，如图一所示，这个三个输出同时预测文本/非文本分数，垂直坐标（v={Vc,Vh}）和边缘细化偏移（o）.,探索k个锚点来预测他们在conv5中的每个空间位置，从而在输出层分别得到2k,2k和k个参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620225406874-1732668117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中每一个锚点都是一个训练样本，其中每个锚点都是一个训练样本，&lt;span id=&quot;MathJax-Element-189-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1651&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1652&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1653&quot; class=&quot;mi&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;i是一个小批量数据中一个锚点的索引。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;未完。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 15:03:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9206564.html</dc:identifier>
</item>
<item>
<title>缓存的正确使用方式 - baishuchao</title>
<link>http://www.cnblogs.com/baishuchao/p/9206521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baishuchao/p/9206521.html</guid>
<description>&lt;p&gt;首先，缓存由于其适应高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/baishuchao/1226071/o_123.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。&lt;/p&gt;
&lt;p&gt;先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。&lt;/p&gt;
&lt;p&gt;在这里，我们讨论三种更新策略：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先更新数据库，再更新缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先删除缓存，再更新数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先更新数据库，再删除缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这套方案，大家是普遍反对的。为什么呢？有如下两点原因。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原因一（线程安全角度）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时有请求A和请求B进行更新操作，那么会出现&lt;/p&gt;
&lt;p&gt;（1）线程A更新了数据库&lt;br/&gt;（2）线程B更新了数据库&lt;br/&gt;（3）线程B更新了缓存&lt;br/&gt;（4）线程A更新了缓存&lt;/p&gt;
&lt;p&gt;这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原因二（业务场景角度）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有如下两点：&lt;/p&gt;
&lt;p&gt;（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。&lt;/p&gt;
&lt;p&gt;（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。&lt;/p&gt;
&lt;p&gt;接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。&lt;/p&gt;

&lt;p&gt;该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:&lt;/p&gt;
&lt;p&gt;（1）请求A进行写操作，删除缓存&lt;br/&gt;（2）请求B查询发现缓存不存在&lt;br/&gt;（3）请求B去数据库查询得到旧值&lt;br/&gt;（4）请求B将旧值写入缓存&lt;br/&gt;（5）请求A将新值写入数据库&lt;/p&gt;
&lt;p&gt;上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。&lt;/p&gt;
&lt;p&gt;那么，如何解决呢？采用延时双删策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(String key,Object data){

        redis.&lt;span class=&quot;fu&quot;&gt;delKey&lt;/span&gt;(key);

        db.&lt;span class=&quot;fu&quot;&gt;updateData&lt;/span&gt;(data);

        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;);

        redis.&lt;span class=&quot;fu&quot;&gt;delKey&lt;/span&gt;(key);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转化为中文描述就是&lt;/p&gt;
&lt;p&gt;（1）先淘汰缓存&lt;br/&gt;（2）再写数据库（这两步和原来一样）&lt;br/&gt;（3）休眠1秒，再次淘汰缓存&lt;/p&gt;
&lt;p&gt;这么做，可以将1秒内所造成的缓存脏数据，再次删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，这个1秒怎么确定的，具体该休眠多久呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你用了mysql的读写分离架构怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。&lt;/p&gt;
&lt;p&gt;（1）请求A进行写操作，删除缓存&lt;br/&gt;（2）请求A将数据写入数据库了&lt;br/&gt;（3）请求B查询缓存发现，缓存没有值&lt;br/&gt;（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值&lt;br/&gt;（5）请求B将旧值写入缓存&lt;br/&gt;（6）数据库完成主从同步，从库变为新值&lt;/p&gt;
&lt;p&gt;上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采用这种同步淘汰策略，吞吐量降低怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次删除,如果删除失败怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：&lt;/p&gt;
&lt;p&gt;（1）请求A进行写操作，删除缓存&lt;br/&gt;（2）请求B查询发现缓存不存在&lt;br/&gt;（3）请求B去数据库查询得到旧值&lt;br/&gt;（4）请求B将旧值写入缓存&lt;br/&gt;（5）请求A将新值写入数据库&lt;br/&gt;（6）请求A试图去删除请求B写入对缓存值，结果失败了。&lt;/p&gt;
&lt;p&gt;ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。&lt;/p&gt;

&lt;p&gt;首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;命中：应用程序从cache中取数据，取到后返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新：先把数据存到数据库中，成功后，再让缓存失效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种情况不存在并发问题么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生&lt;/p&gt;
&lt;p&gt;（1）缓存刚好失效&lt;br/&gt;（2）请求A查询数据库，得一个旧值&lt;br/&gt;（3）请求B将新值写入数据库&lt;br/&gt;（4）请求B删除缓存&lt;br/&gt;（5）请求A将查到的旧值写入缓存&lt;/p&gt;
&lt;p&gt;ok，如果发生上述情况，确实是会发生脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，发生这种情况的概率又有多少呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。&lt;/p&gt;
&lt;p&gt;假设，有人非要抬杠，有强迫症，一定要解决怎么办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决上述并发问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，给缓存设置有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有其他造成不一致的原因么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供一个保障的重试机制即可，这里给出两套方案。&lt;/p&gt;
&lt;p&gt;方案一：&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程如下所示&lt;/p&gt;
&lt;p&gt;（1）更新数据库数据；&lt;br/&gt;（2）缓存因为种种问题删除失败&lt;br/&gt;（3）将需要删除的key发送至消息队列&lt;br/&gt;（4）自己消费消息，获得需要删除的key&lt;br/&gt;（5）继续重试删除操作，直到成功&lt;br/&gt;然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。&lt;/p&gt;
&lt;p&gt;方案二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程如下图所示：&lt;/p&gt;
&lt;p&gt;（1）更新数据库数据&lt;br/&gt;（2）数据库会将操作信息写入binlog日志当中&lt;br/&gt;（3）订阅程序提取出所需要的数据以及key&lt;br/&gt;（4）另起一段非业务代码，获得该信息&lt;br/&gt;（5）尝试删除缓存操作，发现删除失败&lt;br/&gt;（6）将这些信息发送至消息队列&lt;br/&gt;（7）重新从消息队列中获得该数据，重试操作。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 14:51:00 +0000</pubDate>
<dc:creator>baishuchao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baishuchao/p/9206521.html</dc:identifier>
</item>
<item>
<title>密码学学习整理二 - WhiteBlackCat</title>
<link>http://www.cnblogs.com/FZfangzheng/p/9206446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FZfangzheng/p/9206446.html</guid>
<description>&lt;p&gt;密钥流是随机的，则每个密钥比特的概率满足： Pr[k=0]=1/2, Pr[k=1]=1/2&lt;/p&gt;
&lt;p&gt;假设明文流某个比特的概率满足： Pr[m=0]=p, Pr[m=1]=1-p&lt;/p&gt;
&lt;p&gt;对应的密文比特的概率：&lt;/p&gt;
&lt;p&gt;Pr[c=0] = Pr[k=0]&lt;em&gt;Pr[m=0]+Pr[k=1]&lt;/em&gt;Pr[m=1]=1/2&lt;/p&gt;
&lt;p&gt;Pr[c=1] = Pr[k=0]&lt;em&gt;Pr[m=1]+Pr[k=1]&lt;/em&gt;Pr[m=0]=1/2&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 14:30:00 +0000</pubDate>
<dc:creator>WhiteBlackCat</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FZfangzheng/p/9206446.html</dc:identifier>
</item>
<item>
<title>嵌入式单元测试--框架解析 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/9206406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/9206406.html</guid>
<description>&lt;h2 id=&quot;1单元测试的必要性&quot; data-source-line=&quot;1&quot;&gt;1.单元测试的必要性&lt;/h2&gt;
&lt;p data-source-line=&quot;2&quot;&gt;单元测试是软件开发的重要一环，尤其对嵌入式开发。因为嵌入式开发受限于开发环境、调试工具等因素，不能和纯PC软件开发一样使用很多先进的工具。这就需要开发者在开发过程中，进行更细的模块划分，更明确的接口，更详尽的测试。根据软件工程理论，1个bug越是在后期越是花费巨大的成本去修复，并且随着系统复杂度的增长，在一个大的系统中去查找某一个细节具体的问题，相比于在小的模块中去查找问题会花费多倍的时间成本。&lt;/p&gt;
&lt;h2 id=&quot;2单元测试框架解剖&quot; data-source-line=&quot;3&quot;&gt;2.单元测试框架解剖&lt;/h2&gt;
&lt;p data-source-line=&quot;4&quot;&gt;一般地单元测试需要实现以下几个基本功能：&lt;br/&gt;&lt;strong&gt;1. assert&lt;/strong&gt;&lt;br/&gt;各种assert，比如AssertTrue、比如AssertFail、AssertStrEquals、AssertIntEquals......&lt;br/&gt;条条大路通罗马，这些Assert有各种功能，其实就是包装了断言的函数。比如AssertStrEquals（str, &quot;open&quot;），进行str和字符串“open”的比较，如果不相同则会报错。&lt;br/&gt;根据框架的结构，在assert失败时候，有的进行长跳转longjmp，有的对类似failCount的全局的变量进行加1并记录错误位置。&lt;br/&gt;&lt;strong&gt;2. 错误位置记录&lt;/strong&gt;&lt;br/&gt;得益于C语言的LINE、FILE宏，这是2个ANSI C标志支持的内置宏定义，可以得到当前的的行数和文件名。 在断言失败的地方，记录文件名和行号，以供用户查询错误的位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
char buf[HUGE_STRING_LEN];
sprintf(buf, &quot;%s:%d: &quot;, _FILE_, _LINE_);
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;17&quot;&gt;&lt;strong&gt;3. 测试case管理&lt;/strong&gt;&lt;br/&gt;这是测试框架区别于自己写的assert测试函数最根本的地方。 测试框架为了提高函数利用率，减少重复，方便测试例程汇总等，都会进行各种封装。比如以下几条。&lt;br/&gt;1）setup和teardown&lt;br/&gt;大部分的测试框架都提供这两个函数，主要是因为有些测试case，有大量重复的代码，比如准备输入数据，测试完毕后清理现场等通用的功能。&lt;br/&gt;2）测试例子汇总&lt;br/&gt;有的叫做TestSuit，有的叫做TestFixtures。把一类相似功能的测试case进行汇总，方便更高层次的调用，也方便用户管理测试例程。&lt;br/&gt;3）测试的调用&lt;br/&gt;多个测试例程汇总后，构成一个数组（表格），启动运行，一般由xxxRun函数负责。&lt;br/&gt;在嵌入式c中，一般都有一个函数指针来操作，这也是为什么所有的测试case的函数名称都使用相同的声明，test_case需要和调用该测试的指针同类型。&lt;/p&gt;
&lt;p data-source-line=&quot;29&quot;&gt;&lt;strong&gt;4. 测试的执行&lt;/strong&gt;&lt;br/&gt;测试的执行本质就是函数的长跳转。可以看做在父函数中调用子函数，这个子函数如果是测试例程的话，子函数就会包含assert相关的语句，而assert语句在出错后，会记录错位位置和错误消息，然后进行长跳转（longjmp），longjmp和setjmp（buf）成对出现，返回到调用的位置，然后进行下一个测试case。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; testSuite-&amp;gt;count ; ++&lt;span&gt;i)
    {
        Test&lt;/span&gt;* testCase = testSuite-&amp;gt;&lt;span&gt;list[i];
        TestRun(testCase);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (testCase-&amp;gt;&lt;span&gt;failed) {
        testSuite&lt;/span&gt;-&amp;gt;failCount += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;3-测试框架的本质&quot; data-source-line=&quot;42&quot;&gt;3. 测试框架的本质&lt;/h2&gt;
&lt;p data-source-line=&quot;43&quot;&gt;1）为了更好的组织测试，提供的测试组的批量处理功能，一般由for循环遍历一个table数组实现；&lt;br/&gt;2）为了减少重复进行测公用函数提取，比如准备测试环境和清理现场；&lt;br/&gt;3）测试需要的各种断言；&lt;br/&gt;4）断言失败后的跳转、记录错误位置-FILE-, -LINE-宏的使用；&lt;br/&gt;5）测试case运行的监控和结果的汇总。&lt;/p&gt;
&lt;p data-source-line=&quot;43&quot;&gt;&lt;br/&gt;综上，如果你实现了上面的几个功能，那么也就自己完成了一个测试框架。&lt;br/&gt;其实测试框架是一个很简单的事情，如今测试框架有很多，像VS这样的IDE已经集成了单体测试，所以对于一个开发者怎么规划测试才是测试工作的第一要务。&lt;br/&gt;如何恰当的写测试用例，既不延误开发又不会造成工程臃肿，还能尽可能的覆盖测试范围，这才是测试中最花费功夫的地方。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 14:21:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pingwen/p/9206406.html</dc:identifier>
</item>
<item>
<title>ABAP on HANA之CDS Association和Path Expression - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/9202781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/9202781.html</guid>
<description>
&lt;p&gt;本文阐述了ABAP CDS association的概念，并且展示了在CDS视图中和SQL语句中写路径表达式（Path Expression）代码的方法。我也会解释如何在CDS asociation中指定inner join——默认情况下是left outer join，以及如何为association添加过滤。&lt;/p&gt;

&lt;p&gt;对于CDS的相关开发，SAP希望我们使用association而不是join，因为association更加接近“概念思维”。基本上，association本身不是join，它只是有关join连接可能性的元数据，它会按需成为join。真实的join会在路径表达式使用association的时候被创建。&lt;/p&gt;
&lt;p&gt; 一个简单的CDS association例子，它看起来和left outer join没区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ASSOC11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_assoc1 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scarr &lt;span&gt;as&lt;/span&gt;&lt;span&gt; sca
   &lt;span&gt;association &lt;/span&gt;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;0..1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; spfli &lt;span&gt;as&lt;/span&gt;&lt;span&gt; _spfli 
   &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; sca.carrid &lt;span&gt;=&lt;/span&gt;&lt;span&gt; _spfli.carrid   
   { &lt;/span&gt;&lt;span&gt;*&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;暴露CDS association的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ASSOC41&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;@AccessControl&lt;/span&gt;&lt;span&gt;.authorizationCheck: #NOT_REQUIRED
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_assoc4 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sairport &lt;span&gt;as&lt;/span&gt;&lt;span&gt; sair
    &lt;span&gt;association &lt;/span&gt;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1..*&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; spfli &lt;span&gt;as&lt;/span&gt; _spfli &lt;span&gt;on&lt;/span&gt;&lt;span&gt;
        $projection.airportfrom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _spfli.airpfrom
    {     
       sair.id &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; airportfrom,
       sair.name,
       sair.time_zone,
      &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; exposing association&lt;/span&gt;
&lt;span&gt;      _spfli
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在下面的例子里，你可以看到SPFLI表对SFLIGHT表和SAIRPORT表的association。通过别名alias _sfli和SFLIGHT和_sair，SAIRPORT的全部字段暴露在projection列表中。当路径表达式用于调用association时，会根据选择字段创建join条件：spfli.carrid = sflight.carrid and spfli.connid = sflight.connid and on spfli.airport = sairport.id。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ASSOC21&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;@AccessControl&lt;/span&gt;&lt;span&gt;.authorizationCheck: #NOT_REQUIRED
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_assoc2 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; spfli 
   &lt;span&gt;association&lt;/span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt; sflight &lt;span&gt;as&lt;/span&gt; _sfli &lt;span&gt;on&lt;/span&gt;&lt;span&gt; 
        spfli.carrid &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; _sfli.carrid &lt;span&gt;and&lt;/span&gt;&lt;span&gt;
        spfli.connid &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _sfli.connid
    association &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1..1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; sairport &lt;span&gt;as&lt;/span&gt; _sair &lt;span&gt;on&lt;/span&gt;&lt;span&gt;
        $projection.airportfrom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _sair.id
    {
      spfli.carrid,
      spfli.connid,
      spfli.airpfrom &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; airportfrom,
      &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; exposing association&lt;/span&gt;
&lt;span&gt;      _sfli,
      _sair    
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在下面的例子里，定义association时使用了上面的CDS entity，ZCDS_ASSOC2 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ASSOC31&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;@AccessControl&lt;/span&gt;&lt;span&gt;.authorizationCheck: #NOT_REQUIRED
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_assoc3 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; scarr
        association &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;1..1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; zcds_assoc2  &lt;span&gt;as&lt;/span&gt; _cdsassoc &lt;span&gt;on&lt;/span&gt;&lt;span&gt;
         $projection.carrierid &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; _cdsassoc.carrid
      {
         scarr.carrid &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;&lt;span&gt; carrierid,
     &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; Exposing Association    &lt;/span&gt;
&lt;span&gt;         _cdsassoc
      } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Open SQL语句中的路径表达式：在SQL语句中调用CDS association，需要使用如下的路径表达式。在上面的CDS association中，通过_cdsassoc暴露了完整的projection列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DATA&lt;/span&gt;(w_dbfeature) = cl_abap_dbfeatures=&amp;gt;use_features( &lt;br/&gt;　requested_features = &lt;span&gt;VALUE&lt;/span&gt; #( ( cl_abap_dbfeatures=&amp;gt;&lt;span&gt;views_with_parameters ) ) ).
&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; w_dbfeature &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;INITIAL&lt;/span&gt;&lt;span&gt;.
  &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;  carrierid ,
          &lt;/span&gt;\_cdsassoc\_sfli-&lt;span&gt;fldate &lt;span&gt;AS&lt;/span&gt; flightdate,
          &lt;/span&gt;\_cdsassoc\_sair-&lt;span&gt;name &lt;span&gt;AS&lt;/span&gt; flightname
        &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; zcds_assoc3
        &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; carrierid =&lt;span&gt; @carrid
        &lt;/span&gt;&lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; @&lt;span&gt;DATA&lt;/span&gt;&lt;span&gt;(t_data1).
&lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CDS视图中的路径表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ON_ASSOC1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_on_assoc &lt;span&gt;with&lt;/span&gt; parameters airport: S_FROMAIRP  &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; zcds_assoc2 &lt;span&gt;as&lt;/span&gt;&lt;span&gt; cds2
    {
      cds2.carrid,
      cds2.connid,
      cds2.airportfrom,    
      cds2._sair.name, &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; use inner join...by default association uses left outer join&lt;/span&gt;
&lt;span&gt;      cds2._sfli.planetype
    }
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; cds2.airportfrom &lt;span&gt;=&lt;/span&gt; :airport 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如我所提到的那样，在被路径表达式调用时，CDS association会默认创建left outer join。&lt;/p&gt;
&lt;p&gt;在SPFLI表数据中，没有RTM机场的航班。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201806/994049-20180620213913904-1967162801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201806/994049-20180620213918727-1794441454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当我们输入参数airport = RTM的时候 ，下面的CDS视图的查询结果会是一条RTM机场的数据，但是这条记录里没有carrid。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ON_ASSOC41&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_on_assoc4 &lt;span&gt;with&lt;/span&gt; parameters airport: S_FROMAIRP &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; zcds_assoc4 &lt;span&gt;as&lt;/span&gt;&lt;span&gt; cds_assoc
    {
      cds_assoc.airportfrom,
      cds_assoc.name,
      cds_assoc.time_zone,    
      cds_assoc._spfli.carrid &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; use inner join...by default association uses left outer join&lt;/span&gt;
&lt;span&gt;    }
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; cds_assoc.airportfrom &lt;span&gt;=&lt;/span&gt; :airport 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行上面的CDS视图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201806/994049-20180620214215760-218837427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;data preview中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201806/994049-20180620214233086-1647007221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了把默认的left outer join变成inner join，我们需要使用[inner]，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ON_ASSOC41&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; zcds_on_assoc4 &lt;span&gt;with&lt;/span&gt; parameters airport: S_FROMAIRP &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; zcds_assoc4 &lt;span&gt;as&lt;/span&gt;&lt;span&gt; cds_assoc
    {
      cds_assoc.airportfrom,
      cds_assoc.name,
      cds_assoc.time_zone,    
      cds_assoc._spfli&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.carrid &lt;span&gt;--&lt;/span&gt;&lt;span&gt; use inner join...by default association uses left outer join&lt;/span&gt;
&lt;span&gt;    }
 &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; cds_assoc.airportfrom &lt;span&gt;=&lt;/span&gt; :airport 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果运行它，输入参数RTM，得到的结果为空：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201806/994049-20180620214635508-1180210975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目前，还不可以在CDS association中使用right outer join。&lt;/p&gt;
&lt;p&gt;CDS association中的过滤例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@AbapCatalog&lt;/span&gt;.sqlViewName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ZCDS_ASSOC_FILT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
define &lt;/span&gt;&lt;span&gt;view&lt;/span&gt; ZCDS_ASSOC_FILTER  &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; zcds_assoc2 &lt;span&gt;as&lt;/span&gt;&lt;span&gt; cds2
    {
      cds2._sair&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt; id = 'TYO' &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.name,
      cds2._sfli.planetype
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CDS视图的输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201806/994049-20180620214849775-925223653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;希望本文对你有帮助！&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ABAP on HANA之CDS Association和Path Expression&quot; href=&quot;https://www.cnblogs.com/hhelibeb/p/9202781.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhelibeb/p/9202781.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;英文原文：&lt;a href=&quot;https://blogs.sap.com/2017/03/07/inner-join-with-cds-associations-abap-on-hana/&quot; target=&quot;_blank&quot;&gt;CDS Associations and 路径表达式s – ABAP on HANA&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考阅读：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hhelibeb/p/7941300.html&quot;&gt;ABAP 7.52 中的Open SQL新特性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　   &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/hhelibeb/p/6647324.html&quot;&gt;HANA CDS与ABAP CDS&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 13:56:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/9202781.html</dc:identifier>
</item>
<item>
<title>设计模式（十三）—— 代理模式 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9205485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9205485.html</guid>
<description>&lt;h2 id=&quot;模式简介&quot;&gt;模式简介&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一些情况下，客户端不能或者不想直接引用一个对象，可以借助一个第三方代理来实现间接引用。代理对象在客户端和目标对象之间起到中介作用，通过代理对象，可以去掉客户不能看到的内容或服务，也可以添加客户需要的额外服务。&lt;/p&gt;
&lt;p&gt;想象一下，商家想找明星艺人演出，要先找到经纪人，谈妥了相关事宜，经纪人通知相关艺人在适当的时间进行表演。这里的经纪人就相当于代理对象。在这个示例中，使用代理带来了哪些好处呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;控制了目标对象的访问权限。不是任何人都能找到明星，明星没有那么多时间(保护代理)。&lt;/li&gt;
&lt;li&gt;明星艺人在全世界各地表演，无法与商家见面，经济人作为代表讨论相关事宜(远程代理)。&lt;/li&gt;
&lt;li&gt;艺人出场费用较高，开销太大，商家可以与经纪人先进行讨论，待演出时艺人再出场表演，降低成本(虚代理)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结构说明&quot;&gt;结构说明&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201806/971601-20180619210644122-647893204.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色说明&quot;&gt;角色说明&lt;/h3&gt;
&lt;p&gt;抽象主题。定义RealSubject和Proxy的共同接口，以便在任何可以使用RealSubject的地方都能够使用Proxy。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RealSubject&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Proxy代理的目标实体。&lt;/p&gt;
&lt;p&gt;代理类，包含一个指向RealSubject实体的引用。&lt;/p&gt;
&lt;h3 id=&quot;源码结构&quot;&gt;源码结构&lt;/h3&gt;
&lt;p&gt;首先创建抽象主题Subject，它是一个抽象类，包含抽象方法Request。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class Subject
{
    public abstract void Request();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建目标实体类RealSubject，继承自Subject类，Request方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class RealSubject : Subject
{
    public override void Request()
    {
        Console.WriteLine(&quot;Request by real subject&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建代理类Proxy，其中包含一个私有成员，引用RealSubject目标实体对象，以便将请求转发给真正的目标实体对象，注意这里Proxy也继承自Subject，那么在使用RealSubject的地方都能够使用Proxy。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Proxy : Subject
{
    private Subject _realSubject;
    public override void Request()
    {
        if (_realSubject == null)
        {
            _realSubject = new RealSubject();
        }
        _realSubject.Request();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用，客户端不需要知道目标实体类，通过代理就可以完成相应的请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        Proxy proxy = new Proxy();
        proxy.Request();
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;客户端发送请求给代理，代理对象则在适当的时候向RealSubject转发请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201806/971601-20180620194517938-136923827.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例分析&quot;&gt;示例分析&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;生活中一个非常简单的例子，例如互联网上面我们很多网站不能访问。通过代理类检查用户访问的网站是否被禁止，如果没有，正常访问；否则，返回Access Denied。&lt;/p&gt;
&lt;p&gt;创建抽象类Internet，包含抽象方法Connect(这里也可以声明为接口)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class Internet
{
    public abstract void Connect(string url);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别创建RealInternet类以及代理类InternetProxy，RealInternet实现Connect方法，直接访问传入的地址。而代理类InternetProxy维护一个禁止访问的集合，在执行Connect方法时，首先判断传入的地址是否包含在该集合中，如果存在，返回Access Denied；否则调用RealInternet的Connect方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class RealInternet : Internet
{
    public override void Connect(string url)
    {
        Console.WriteLine($&quot;Connecting to {url}&quot;);
    }
}

class InternetProxy : Internet
{
    private Internet _realInternet = new RealInternet();
    private readonly List&amp;lt;string&amp;gt; _bannedSites;
    public InternetProxy()
    {
        _bannedSites = new List&amp;lt;string&amp;gt;
        {
            &quot;abc.com&quot;,
            &quot;111.com&quot;
        };
    }

    public override void Connect(string url)
    {
        if (_bannedSites.Contains(url))
        {
            Console.WriteLine(&quot;Access Denied&quot;);
        }
        else
        {
            _realInternet.Connect(url);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用，通过代理访问aaa.com以及abc.com，输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        InternetProxy proxy = new InternetProxy();
        proxy.Connect(&quot;aaa.com&quot;);
        proxy.Connect(&quot;abc.com&quot;);
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201806/971601-20180620202923822-1099127072.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;根据代理模式的使用目的，常见的代理模式分为以下几种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;远程代理(Remote Proxy)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为一个对象在不同的地址空间提供局部代表。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;虚代理(Virtual Proxy)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果需要创建一个资源消耗较大的对象，可以先创建一个消耗较小的代理对象来表示，在适当时间创建真正的对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;保护代理(Protection Proxy)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;控制一个对象的访问，如上一节中的示例。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;智能指引(Smart Reference)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来。&lt;/p&gt;
&lt;h2 id=&quot;优缺点&quot;&gt;优缺点&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;因为增加了代理对象，所以系统处理请求的速度会变慢。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代理模式与装饰者模式的区别&quot;&gt;代理模式与装饰者模式的区别&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;从结构上来看，代理模式和装饰者模式非常相似，Proxy和Decorator中都包含了对目标对象的引用，在使用时向目标对象发送请求。二者之间的差异主要在于它们的设计目的不同：Proxy主要强调&lt;strong&gt;客户端不能或者不想直接引用一个对象时，为这个对象提供一个替代品。&lt;/strong&gt; 而Decorator更侧重于&lt;strong&gt;通过组合的方式，为目标对象增加一些额外的职责。&lt;/strong&gt; 如&lt;a href=&quot;https://www.cnblogs.com/Answer-Geng/p/9157287.html&quot;&gt;《设计模式（十）—— 装饰者模式》&lt;/a&gt;一篇中讲到，装饰者模式可以在客户端通过多个装饰者以递归组合的方式对组件进行功能上的扩展，而代理模式更强调一种替代关系。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 13:45:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9205485.html</dc:identifier>
</item>
</channel>
</rss>