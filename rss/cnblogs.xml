<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Echarts之悬浮框中的数据排序 - yezi-dream</title>
<link>http://www.cnblogs.com/yezi-dream/p/9926597.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yezi-dream/p/9926597.html</guid>
<description>&lt;p&gt;&lt;span&gt;         Echarts非常强大，配置也非常的多，有很多细节需要深入研究。详解一下关于悬浮框中的数据排序问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        悬浮框的数据排序默认是根据series中的数据位置排序的，在我们想自定义排序时，在echarts的配置中有一个tooltip&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        以下为数据降序的代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            tooltip = {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            trigger:  'axis',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            formatter:  (params) =&amp;gt; {  // params为悬浮框上的全部数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              const newParams = [];&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              let paramsData = _.sortBy(params, 'value'); // 根据value值升序，_.sortBy为lodash的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              paramsData = _.reverse(paramsData);  // 将数据降序，_.reverse为lodash的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              paramsData.forEach((p) =&amp;gt; {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                // p.marker为对应数据线的颜色的圆点 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                // p.seriesName为对应数据的数据名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               // p.value为对应数据的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                const cont = p.marker + ' ' + p.seriesName + ': ' + p.value + '&amp;lt;br/&amp;gt;'; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                newParams.push(cont);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              });&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              return _.join(newParams, '');  // 这里是需要将数组转化成字符串显示，如果不转化，每个数据前面都会出现一个逗号（，），_.join为lodash的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;            }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;          }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         主要是在formatter中设置，formatter可以接受两种形式，字符串模版和回调函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          回调函数可以根据需求相应处理数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         字符串模版可以自定义显示形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         字符串模版有多中，根据具体是什么图，官网详细 介绍了这几种类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          链接：&lt;a href=&quot;http://www.echartsjs.com/option.html#tooltip.formatter&quot; target=&quot;_blank&quot;&gt;http://www.echartsjs.com/option.html#tooltip.formatter&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 07 Nov 2018 15:43:00 +0000</pubDate>
<dc:creator>yezi-dream</dc:creator>
<og:description>Echarts非常强大，配置也非常的多，有很多细节需要深入研究。详解一下关于悬浮框中的数据排序问题 悬浮框的数据排序默认是根据series中的数据位置排序的，在我们想自定义排序时，在echarts的配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yezi-dream/p/9926597.html</dc:identifier>
</item>
<item>
<title>手把手教你写DI_2_小白徒手撸构造函数注入 - victor.x.qu</title>
<link>http://www.cnblogs.com/fs7744/p/9926523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fs7744/p/9926523.html</guid>
<description>&lt;p&gt;在上一节：&lt;a href=&quot;https://www.cnblogs.com/fs7744/p/9924569.html&quot;&gt;手把手教你写DI_1_DI框架有什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们已经知道我们要撸哪些东西了&lt;/p&gt;
&lt;p&gt;那么我们开始动工吧，这里呢，我们找小白同学来表演下&lt;/p&gt;
&lt;p&gt;小白同学 ：我们先定义一下我们的广告招聘纸有什么：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public abstract class ServiceDefintion  // 小白同学 ：我们换个名字，不叫 ServiceDescriptor ，撸也要撸出自己的标志嘛
{
    public abstract Type ServiceType { get; }
    public abstract Type ImplementationType { get; }
    public abstract Lifetime Lifetime { get; }
}

public enum Lifetime  // 小白同学 ：定义一下要支持的三种生命周期
{
    Singleton,
    Scoped,
    Transient
}

// 小白同学 ：搞个集合存放他们
public interface IServiceDefintions : IEnumerable&amp;lt;ServiceDefintion&amp;gt;
{
    void Add(ServiceDefintion serviceDefintion);
}

public class ServiceDefintions : IServiceDefintions
{
    private readonly List&amp;lt;ServiceDefintion&amp;gt; services = new List&amp;lt;ServiceDefintion&amp;gt;();

    public void Add(ServiceDefintion serviceDefintion)
    {
        if (serviceDefintion == null)
        {
            throw new ArgumentNullException(nameof(serviceDefintion));
        }
        services.Add(serviceDefintion);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，我们实现两种不同的广告类型&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class TypeServiceDefintion : ServiceDefintion  // 小白同学 ：这种是只提供类型的，怎么建立实例需要我们解析生成，但是对使用DI的人来说，很方便，不用管怎么去new
{
    public override Type ServiceType { get; }
    public override Type ImplementationType { get; }
    public override Lifetime Lifetime { get; }

    public TypeServiceDefintion(Type serviceType, Type implementationType, Lifetime lifetime)
    {
        ServiceType = serviceType;
        ImplementationType = implementationType;
        Lifetime = lifetime;
    }
}

public interface IImplementationFactory
{
    Func&amp;lt;INamedServiceProvider, object&amp;gt; ImplementationFactory { get; }
}

public class DelegateServiceDefintion : ServiceDefintion, IImplementationFactory  // 小白同学 ：这种是用户自己new对象，少数特殊情况，用户会自己写特殊逻辑，所以我们需要提供支持
{
    public DelegateServiceDefintion(Type serviceType, Type implementationType, Lifetime lifetime,
        Func&amp;lt;IServiceProvider, object&amp;gt; implementationFactory)
    {
        ServiceType = serviceType;
        ImplementationType = implementationType;
        Lifetime = lifetime;
        ImplementationFactory = implementationFactory;
    }

    public override Type ServiceType { get; }

    public override Type ImplementationType { get; }

    public override Lifetime Lifetime { get; }

    public Func&amp;lt;IServiceProvider, object&amp;gt; ImplementationFactory { get; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学 ：好了，我们有服务定义描述了，来创建&lt;code&gt;IServiceProvider&lt;/code&gt;吧&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly IServiceDefintions services;

    public ServiceProvider(IServiceDefintions services)
    {
        this.services = services;
    }
    public object GetService(Type serviceType)
    {
        var defintion = TryGetDefintion(serviceType); // 小白同学 ：查找一下服务定义
        if (defintion != null)
        {
            switch (defintion.Lifetime)
            {
                case Lifetime.Singleton:
                    return null;  // 小白同学 ：啥？怎么处理？emm 后面说吧，脑容量不够啦

                case Lifetime.Scoped:
                    return null;  // 小白同学 ：啥？怎么处理？emm 后面说吧，脑容量不够啦

                case Lifetime.Transient:
                    if(defintion is DelegateServiceDefintion defi)
                    {
                        return defi.ImplementationFactory(this);
                        // 小白同学 ：haha, 不用我们做，真简单
                    }
                    else // 小白同学 ：TypeServiceDefintion
                    {
                        // 小白同学 ：啥？怎么处理？emm 后面说吧，脑容量不够啦
                    }

                default:
                    return null;
            }
        }
        else
        {
            return null;
        }
    }

    private ServiceDefintion TryGetDefintion(Type serviceType)
    {
        return services.FirstOrDefault(i =&amp;gt; i.ServiceType == serviceType);  //大神： what ? 每次都遍历一下？太low了吧？
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学 ：捂脸.gif 我们居然每次都遍历，简直太笨了，赶紧改下，免得大神吐槽&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly Dictionary&amp;lt;Type, ServiceDefintion&amp;gt; services;

    public ServiceProvider(IServiceDefintions services)
    {
        this.services = services.ToDictionary(i =&amp;gt; i.ServiceType);  
        //大神： what 1 ? 有相同的 ServiceType 怎么办？ 
    }

    private ServiceDefintion TryGetDefintion(Type serviceType)  //大神： what 2 ? 这个方法怎么这么怪
    {
        services.TryGetValue(serviceType, out var defintion);  
        return defintion;
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学 ：又被吐槽了，再改下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly Dictionary&amp;lt;Type, ServiceDefintion[]&amp;gt; services;  
    //大神： 呵呵，你就这样写吧，我打赌100块你后面肯定要改
    //小白同学: ......

    public ServiceProvider(IServiceDefintions services)
    {
        this.services = services.GroupBy(i =&amp;gt; i.ServiceType).ToDictionary(i =&amp;gt; i.Key, i =&amp;gt; i.ToArray());
    }

    private ServiceDefintion TryGetDefintion(Type serviceType) 
    {
        return services.TryGetValue(serviceType, out var defintion) ? defintion.LastOrDefault() : null;
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 好了，我们简单测试一下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void Test()
{
    var a = new ServiceDefintions();
    a.Add(new DelegateServiceDefintion(typeof(TransientTest),typeof(TransientTest),Lifetime.Transient,i =&amp;gt; this));
    var service = new ServiceProvider(a);

    var result0 = service.GetService(typeof(TransientTest));
    Assert.Same(this, result0);
}
// 大神： 你用this 去测瞬态？你确定this是瞬态的func 每次都会调用？
// 小白同学: 我。。。。。。我改&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Fact]
public void Test()
{
    var a = new ServiceDefintions();
    a.Add(new DelegateServiceDefintion(typeof(TransientTest),typeof(TransientTest),Lifetime.Transient,i =&amp;gt; new TransientTest()));
    var service = new ServiceProvider(a);

    var result0 = service.GetService(typeof(TransientTest));
    var result1 = service.GetService(typeof(TransientTest));
    Assert.NotNull(result0);
    Assert.NotNull(result1);
    Assert.NotSame(result0, result1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 我们来做TypeServiceDefintion 解析支持&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    public object GetService(Type serviceType)
    {
        ...

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                var d = defintion as TypeServiceDefintion;
                var constructor = d.ImplementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic); // 小白同学:  反射获取构造函数
                var ps = constructor.GetParameters();
                var args = new object[ps.Length];
                for (int j = 0; j &amp;lt; ps.Length; j++)
                {
                    var p = ps[j];
                    args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                }
                return constructor.Invoke(args);  // 小白同学:  创建;
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 你看我写的不错吧&lt;/p&gt;
&lt;p&gt;大神：呵呵，这样反射性能你考虑了吗？ 泛型你考虑了吗? 还有你每次都重新生成DelegateServiceDefintion？&lt;/p&gt;
&lt;p&gt;小白同学: 我知道反射该用IL或者表达式树处理，但观众不好看嘛&lt;/p&gt;
&lt;p&gt;大神：呵呵，你不会写吧，你看看人家lemon大神怎么写的 - &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/reflection/src/AspectCore.Extensions.Reflection/ConstructorReflector.cs&quot;&gt;file&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小白同学: 好，我下来学习。 泛型不过是再动态生成一下类型嘛，这样就行啦&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    public object GetService(Type serviceType)
    {
        ...

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                var d = defintion as TypeServiceDefintion;
                var implementationType = serviceType.IsConstructedGenericType 
                    ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                    : d.ImplementationType;
                var constructor = implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic); // 小白同学:  反射获取构造函数
                .....
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小白同学: 哦，还有缓存：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly Dictionary&amp;lt;Type, ConstructorInfo&amp;gt; cache = new Dictionary&amp;lt;Type, ConstructorInfo&amp;gt;();

    public object GetService(Type serviceType)
    {
        ...

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                ConstructorInfo constructor = null;
                if(cache.ContainsKey(serviceType))
                {
                    constructor = cache[serviceType];
                }
                else 
                {
                    var d = defintion as TypeServiceDefintion;
                    var implementationType = serviceType.IsConstructedGenericType 
                        ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                        : d.ImplementationType;
                    constructor = cache[serviceType] = implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic); // 小白同学:  反射获取构造函数
                }
                ....
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大神： .......我想自闭..... 你都不考虑多线程吗？&lt;/p&gt;
&lt;p&gt;小白同学: ！！！ 我，我，我，我换成它 &lt;code&gt;ConcurrentDictionary&amp;lt;Type, ConstructorInfo&amp;gt; cache&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大神：算你NB，&lt;code&gt;Singleton&lt;/code&gt; 和 &lt;code&gt;Scoped&lt;/code&gt; 你打算怎么做？&lt;/p&gt;
&lt;p&gt;小白同学: 简单， copy 一下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class ServiceProvider : IServiceProvider
{
    private readonly ConcurrentDictionary&amp;lt;Type, ConstructorInfo&amp;gt; cache = new ConcurrentDictionary&amp;lt;Type, ConstructorInfo&amp;gt;();

    public object GetService(Type serviceType)
    {
        case Lifetime.Singleton:
                if(defintion is DelegateServiceDefintion defi)
                {
                    return defi.ImplementationFactory(this);
                }
                else
                {
                    ConstructorInfo constructor = cache.GetOrAdd(serviceType, i =&amp;gt; 
                    {
                        var d = defintion as TypeServiceDefintion;
                        var implementationType = serviceType.IsConstructedGenericType 
                            ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                            : d.ImplementationType;
                        return implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic);
                    });
                    ar ps = constructor.GetParameters();
                    var args = new object[ps.Length];
                    for (int j = 0; j &amp;lt; ps.Length; j++)
                    {
                        var p = ps[j];
                        args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                    }
                    return constructor.Invoke(args);  // 小白同学:  创建;
                }

        case Lifetime.Scoped:
                if(defintion is DelegateServiceDefintion defi)
                {
                    return defi.ImplementationFactory(this);
                }
                else
                {
                    ConstructorInfo constructor = cache.GetOrAdd(serviceType, i =&amp;gt; 
                    {
                        var d = defintion as TypeServiceDefintion;
                        var implementationType = serviceType.IsConstructedGenericType 
                            ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                            : d.ImplementationType;
                        return implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic);
                    });
                    ar ps = constructor.GetParameters();
                    var args = new object[ps.Length];
                    for (int j = 0; j &amp;lt; ps.Length; j++)
                    {
                        var p = ps[j];
                        args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                    }
                    return constructor.Invoke(args);  // 小白同学:  创建;
                }

        case Lifetime.Transient:
            if(defintion is DelegateServiceDefintion defi)
            {
                return defi.ImplementationFactory(this);
            }
            else
            {
                ConstructorInfo constructor = cache.GetOrAdd(serviceType, i =&amp;gt; 
                {
                    var d = defintion as TypeServiceDefintion;
                    var implementationType = serviceType.IsConstructedGenericType 
                        ? d.ImplementationType.MakeGenericType(serviceType.GenericTypeArguments)
                        : d.ImplementationType;
                    return implementationType.GetConstructors().FirstOrDefault(i =&amp;gt; i.IsPublic);
                });
                ar ps = constructor.GetParameters();
                var args = new object[ps.Length];
                for (int j = 0; j &amp;lt; ps.Length; j++)
                {
                    var p = ps[j];
                    args[j] = i.GetService(p.ParameterType);  // 小白同学:  获取参数值
                }
                return constructor.Invoke(args);  // 小白同学:  创建;
            }

        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大神：我！！！！！！！！！！ 我给你一刀！！！！！！！&lt;/p&gt;
&lt;p&gt;小白同学: 啊！！！！！！！！！&lt;/p&gt;
&lt;p&gt;由于小白同学受伤，本次节目中断，等小白同学养好伤，我们再继续&lt;/p&gt;
&lt;p&gt;下一章 小白徒手支持 &lt;code&gt;Singleton&lt;/code&gt; 和 &lt;code&gt;Scoped&lt;/code&gt; 生命周期&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 15:23:00 +0000</pubDate>
<dc:creator>victor.x.qu</dc:creator>
<og:description>小白徒手撸构造函数注入 在上一节：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fs7744/p/9926523.html</dc:identifier>
</item>
<item>
<title>动态SQL - 安心。</title>
<link>http://www.cnblogs.com/anxin0/p/9926500.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anxin0/p/9926500.html</guid>
<description>&lt;h4 id=&quot;使用动态sql完成多条件查询&quot;&gt;使用动态SQL完成多条件查询&lt;/h4&gt;
&lt;p&gt;动态SQl是MyBatis的一个强大的特性,在使用JDBC操作数据时,如果查询条件过多,将字符串联成SQL语句是比较麻烦的一件事,且容易出错,有了动态SQL我们就可以使用动态SQL，动态SQL基于OGNL表达式,可使我们方便地在SQL语句中实现某些逻辑。好了废话不多说,接下来我们看下示例&lt;/p&gt;
&lt;p&gt;==在这里我们还是使用上一篇文章使用的示例,只是修改一下,大家可以先看一下上一篇文章==&lt;/p&gt;
&lt;p&gt;用于实现动态SQL的元素如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;if：利用if实现简单的条件选择&lt;/li&gt;
&lt;li&gt;choose(when,otherwise)：相当于Java中的switch语句，通常与when和otherwise搭配&lt;/li&gt;
&lt;li&gt;where：简化SQL语句中where的条件判断。&lt;/li&gt;
&lt;li&gt;set：解决动态更新语句 trim：可以灵活地去除多余的关键字&lt;/li&gt;
&lt;li&gt;foreach：迭代一个集合，通常用于in条件&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;使用if做多条件查询&quot;&gt;使用if做多条件查询&lt;/h5&gt;
&lt;p&gt;修改UserMapper.xml文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserList&quot; resultMap=&quot;userList&quot;&amp;gt;
    SELECT u.*,r.roleName FROM USER u,Role r WHERE u.userRole=r.id
    &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;
        AND u.userRole=#{userRole}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&quot;userName!=null and userName!=''&quot;&amp;gt;
        AND u.userName LIKE concat('%',#{userName},'%')
    &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的意思就是,如果有角色id就以角色id查询,有用户名字就以用户名字查询,若都没有就全部查询,这和我们之前JDBC中where条件加1==1的意思是一样的&lt;br/&gt;修改接口中的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserList(@Param(&quot;userRole&quot;)Integer roleId,@Param(&quot;userName&quot;)String userName);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void testQuery(){
    SqlSession sqlSession=null; 
    try{
      sqlSession=MyBatisUtil.createSqlSession();
      //这里我们就写两个参数,看看会出现什么结果
      List&amp;lt;User&amp;gt; userList=sqlSession.getMapper(UserMapper.class).getUserList(2,null);
      for (User user: userList) {
            System.out.println(user.getUserName());
        }
    }catch (Exception ex){
        ex.printStackTrace();
    }finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用where&quot;&gt;使用where&lt;/h5&gt;
&lt;p&gt;where元素主要用来简化SQL语句中的where条件判断,并能智能地处理and和or,如果有多余的and或者or where会智能的去除,我们可以把他和if联合起来一块使用&lt;/p&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--注意开启自动映射--&amp;gt;
&amp;lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&amp;gt;
    SELECT * FROM USER
    &amp;lt;where&amp;gt;
    &amp;lt;if test=&quot;userName!=null and userName!=''&quot;&amp;gt;
       AND userName LIKE concat('%',#{userName},'%')
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;
            AND userRole=#{userRole}
        &amp;lt;/if&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用iftrim实现多条件查询&quot;&gt;使用if+trim实现多条件查询&lt;/h5&gt;
&lt;p&gt;trim元素也会自动识别其标签是否有返回值,若有返回值,会在自己包含前后加上某些前缀(比如我们的修改语句加set),也可在其后加上某些后缀(就像我们的修改语句最后一般会有个修改的条件) 后续我们会详细的讲前缀后缀的使用方法&lt;/p&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&amp;gt;
    SELECT * FROM USER
    &amp;lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and | or&quot;&amp;gt;
        &amp;lt;if test=&quot;userName!=null and userName!=''&quot;&amp;gt;
            AND userName LIKE concat('%',#{userName},'%')
        &amp;lt;/if&amp;gt;
        &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;
        AND userRole=#{userRole}
        &amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;prefix：前缀，作用是通过自动识别是否有返回值后，在trim包含的内容上加上前缀，如此处的 where&lt;br/&gt;suffix：后缀，作用是在trim包含的内容上加上后缀&lt;br/&gt;prefixOverrides：对于trim包含内容的首部进行指定内容（如此处的&quot;and | or&quot;）的忽略&lt;br/&gt;suffixOverrides：对用trim包含的内容的首尾进行指定内容的忽略&lt;/p&gt;
&lt;h4 id=&quot;使用动态sql实现更新操作&quot;&gt;使用动态SQL实现更新操作&lt;/h4&gt;
&lt;p&gt;==使用if+set改造更新操作==&lt;/p&gt;
&lt;p&gt;set元素主要用于更新操作,它的主要功能和where元素差不多,主要是在包含的语句前面输出一个set,若包含的语句逗号结尾，自动忽略逗号&lt;br/&gt;在映射文件中编写修改语句&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;update id=&quot;modify&quot; parameterType=&quot;User&quot;&amp;gt;
    UPDATE USER
     &amp;lt;set&amp;gt;
         &amp;lt;if test=&quot;userCode!=null&quot;&amp;gt;userCode=#{userCode},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;userName!=null&quot;&amp;gt;userName=#{userName},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;userPassword!=null&quot;&amp;gt;userPassword=#{userPassword},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;phone!=null&quot;&amp;gt;phone=#{phone},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;address!=null&quot;&amp;gt;address=#{address},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;userRole=#{userRole},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;modifyBy!=null&quot;&amp;gt;modifyBy=#{modifyBy},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;modifyDate!=null&quot;&amp;gt;modifyDate=#{modifyDate},&amp;lt;/if&amp;gt;
         &amp;lt;if test=&quot;birthday!=null&quot;&amp;gt;birthday=#{birthday},&amp;lt;/if&amp;gt; 
    &amp;lt;/set&amp;gt;
    WHERE id=#{id}
&amp;lt;/update&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;==下面我们用if+trim修改SQl语句==&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;update id=&quot;modify&quot; parameterType=&quot;User&quot;&amp;gt;
    UPDATE USER
    &amp;lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot; suffix=&quot;where id=#{id}&quot;&amp;gt;
             &amp;lt;if test=&quot;userCode!=null&quot;&amp;gt;userCode=#{userCode},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;userName!=null&quot;&amp;gt;userName=#{userName},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;userPassword!=null&quot;&amp;gt;userPassword=#{userPassword},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;phone!=null&quot;&amp;gt;phone=#{phone},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;address!=null&quot;&amp;gt;address=#{address},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;userRole!=null&quot;&amp;gt;userRole=#{userRole},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;modifyBy!=null&quot;&amp;gt;modifyBy=#{modifyBy},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;modifyDate!=null&quot;&amp;gt;modifyDate=#{modifyDate},&amp;lt;/if&amp;gt;
             &amp;lt;if test=&quot;birthday!=null&quot;&amp;gt;birthday=#{birthday},&amp;lt;/if&amp;gt;
    &amp;lt;/trim&amp;gt;
&amp;lt;/update&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性的意思上面也都说过了,大家可以翻到上面看一下&lt;/p&gt;
&lt;h5 id=&quot;使用foreach完成复杂查询&quot;&gt;使用foreach完成复杂查询&lt;/h5&gt;
&lt;p&gt;上面我们已经讲过动态SQL的if,where,trim,set元素来处理一些简单查询操作,那么对于一些SQL语句中含有in条件,我们就需要使用foreach标签&lt;/p&gt;
&lt;p&gt;foreach主要用在构建in条件中，在sql语句中迭代一个集合。它的主要属性有，item、index、&lt;br/&gt;collection、separator、close、open。下面我们通过示例给大家进行详细介绍&lt;/p&gt;
&lt;p&gt;1.MyBatis入参为数组类型的foreach类型&lt;br/&gt;编写接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserByRoleId_foreach_array(Integer[] roleIds);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;resultMap id=&quot;userMapByRole&quot; type=&quot;User&quot;&amp;gt;
    &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
    &amp;lt;result property=&quot;userCode&quot; column=&quot;userCode&quot;/&amp;gt;
    &amp;lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&quot;getUserByRoleId_foreach_array&quot; resultMap=&quot;userMapByRole&quot;&amp;gt;
    SELECT * FROM USER WHERE userRole IN
    &amp;lt;foreach collection=&quot;array&quot; item=&quot;roleIds&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&amp;gt;
        #{roleIds}
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void testGetUserByRoleId_foreach_array(){
    SqlSession sqlSession=null;
    List&amp;lt;User&amp;gt; userList=new ArrayList&amp;lt;User&amp;gt;(); 
    Integer[] roleIds={2,3};
    try{
        sqlSession=MyBatisUtil.createSqlSession();
        userList=sqlSession.getMapper(UserMapper.class).getUserByRoleId_foreach_array(roleIds); 
    }catch (Exception ex){
        ex.printStackTrace();
    }finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }
    for (User user: userList) {
        System.out.println(user.getUserName()+&quot;\t&quot;+user.getAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个属性的意思:&lt;br/&gt;item：表示集合中每一个元素进行迭代时的名称&lt;br/&gt;index：指定一个名称，用于表示在迭代过程中，每次迭代到的位置&lt;br/&gt;open：表示该语句以什么开始（in语句以&quot;（&quot;开始）&lt;br/&gt;separator：表示在每次迭代之间以什么符号做分割符&lt;br/&gt;close：表示该语句以什么结束&lt;br/&gt;collection：必须指定，入参为单参类型是List时，collection属性值为list;入参为单参是数组时，为 array；若为多参，需封装Map&lt;br/&gt;parameterType可以不配置，MyBatis会自动封装为Map传入&lt;/p&gt;
&lt;p&gt;2.MyBatis入参为List类型的foreach迭代&lt;br/&gt;在接口中添加方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserByRoleId_foreach_list(List&amp;lt;Integer&amp;gt; roleList);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;resultMap id=&quot;userMapByRole&quot; type=&quot;User&quot;&amp;gt;
    &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
    &amp;lt;result property=&quot;userCode&quot; column=&quot;userCode&quot;/&amp;gt;
    &amp;lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&quot;getUserByRoleId_foreach_list&quot; resultMap=&quot;userMapByRole&quot;&amp;gt;
    SELECT * FROM USER WHERE userRole IN
    &amp;lt;foreach collection=&quot;list&quot; item=&quot;roleIds&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&amp;gt;
        #{roleIds}  
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void testGetUserByRoleId_foreach_array(){
    SqlSession sqlSession=null;
    List&amp;lt;User&amp;gt; userList=new ArrayList&amp;lt;User&amp;gt;();
    List&amp;lt;Integer&amp;gt; nums=new ArrayList&amp;lt;Integer&amp;gt;();
    nums.add(1);
    nums.add(2); 
    try{
     sqlSession=MyBatisUtil.createSqlSession();
      userList=sqlSession.getMapper(UserMapper.class).getUserByRoleId_foreach_list(nums);
     }catch (Exception ex){
      ex.printStackTrace();
    }finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }
    for (User user:  userList) {
        System.out.println(user.getUserName()+&quot;\t&quot;+user.getAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.MyBatis入参为Map类型的foreach迭代&lt;br/&gt;在上面两个示例中,我们都是以一个参数入参的,如果我们查询管理员并且是男性该怎么写那,这种多参数入参我们就可以使用Map入参的方式&lt;/p&gt;
&lt;p&gt;编写接口中的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserByConditionMap_foreach_map(Map&amp;lt;String,Object&amp;gt; conditionMap);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserByConditionMap_foreach_map&quot; resultMap=&quot;userMapByRole&quot;&amp;gt;
    SELECT * FROM USER WHERE gender=#{gender} AND userRole IN
    &amp;lt;foreach collection=&quot;roleIds&quot; item=&quot;roleMap&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&amp;gt;        
            #{roleMap}
    &amp;lt;/foreach&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void testGetUserByRoleId_foreach_array(){
    SqlSession sqlSession = null;
    List&amp;lt;User&amp;gt; userList = new ArrayList&amp;lt;User&amp;gt;();
    Map&amp;lt;String, Object&amp;gt; param = new HashMap&amp;lt;String, Object&amp;gt;(); 
    List&amp;lt;Integer&amp;gt; roleList = new ArrayList&amp;lt;Integer&amp;gt;(); 
    roleList.add(1); 
    roleList.add(2); 
    param.put(&quot;gender&quot;,2); 
    param.put(&quot;roleIds&quot;,roleList); 
    try {
        sqlSession = MyBatisUtil.createSqlSession();
         userList = sqlSession.getMapper(UserMapper.class).getUserByConditionMap_foreach_map(param); 
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        MyBatisUtil.closeSqlSession(sqlSession);
    }   
    for (User user : userList) {
        System.out.println(user.getUserName() + &quot;\t&quot; + user.getAddress());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：&lt;br/&gt;1.MyBatis接受的参数类型：基本类型、对象、List、数组、Map&lt;br/&gt;2.无论MyBatis的入参是哪种数据类型，MyBatis都会将参数放在一个Map中&lt;br/&gt;对于单参数入参的情况：&lt;br/&gt;若入参为基本类型：变量名作为key，变量值为value，此时生成的Map只有一个元素若入参为对象：对象的属性名做key，属性值为value&lt;br/&gt;若入参为List：默认“list”作为key，该List即为value&lt;br/&gt;若入参为数组：默认“array”作为key，该数组即为value&lt;br/&gt;若入参为Map：键值不变&lt;/p&gt;
&lt;h5 id=&quot;choosewhenotherwise&quot;&gt;choose（when,otherwise）&lt;/h5&gt;
&lt;p&gt;choose可以选择其中一种情况下的查询结果，流程和switch相同，通常都是搭配when,otherwise使用&lt;br/&gt;编写接口方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public List&amp;lt;User&amp;gt; getUserList_choose(@Param(&quot;userName&quot;)String userName,@Param(&quot;userRole&quot;)Integer roleId,
                              @Param(&quot;userCode&quot;)String userCode,@Param(&quot;creationDate&quot;)Date creationDate);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;select id=&quot;getUserList_choose&quot; resultType=&quot;User&quot;&amp;gt;
    SELECT * from USER WHERE 1=1
    &amp;lt;choose&amp;gt;
        &amp;lt;when test=&quot;userName!=null and userName!=''&quot;&amp;gt;
            AND userName=#{userName}
        &amp;lt;/when&amp;gt;
        &amp;lt;when test=&quot;userCode!=null and userCode!=''&quot;&amp;gt;
            AND userCode LIKE concat('%',#{userCode},'%')
        &amp;lt;/when&amp;gt;
        &amp;lt;when test=&quot;userRole!=null and userRole!=''&quot;&amp;gt;
            AND userRole=#{userRole}
        &amp;lt;/when&amp;gt;
        &amp;lt;otherwise&amp;gt;
            AND YEAR(creationDate)=YEAR(#{creationDate}) 
        &amp;lt;/otherwise&amp;gt;
    &amp;lt;/choose&amp;gt;
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个属性的意思:&lt;br/&gt;when元素:当其test属性中条件满足的时候,就会执行,一旦有一个条件满足,则跳出choose&lt;br/&gt;otherwise元素:当when中所有条件都不满足的时候,就会执行otherwise中的内容&lt;/p&gt;
&lt;p&gt;多敲几遍你就会明白其中的奥义,可能我写的文章还有许多地方不足,有什么问题大家可以留言讨论&lt;/p&gt;
&lt;p&gt;by安心&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>安心。</dc:creator>
<og:description>使用动态SQL完成多条件查询 动态SQl是MyBatis的一个强大的特性,在使用JDBC操作数据时,如果查询条件过多,将字符串联成SQL语句是比较麻烦的一件事,且容易出错,有了动态SQL我们就可以使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anxin0/p/9926500.html</dc:identifier>
</item>
<item>
<title>Java NIO：Buffer、Channel 和 Selector - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/9926490.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/9926490.html</guid>
<description>&lt;h2 id=&quot;Buffer&quot;&gt;Buffer&lt;/h2&gt;
&lt;p&gt;一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。&lt;/p&gt;
&lt;p&gt;java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107221456546-861070919.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实核心是最后的 ByteBuffer，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。&lt;/p&gt;
&lt;p&gt;我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。&lt;/p&gt;
&lt;p&gt;MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。&lt;/p&gt;
&lt;p&gt;我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。&lt;/p&gt;
&lt;h3 id=&quot;position%E3%80%81limit%E3%80%81capacity&quot;&gt;position、limit、capacity&lt;/h3&gt;
&lt;p&gt;就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107221701406-1091971180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。&lt;/p&gt;
&lt;p&gt;position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;position &lt;/strong&gt;的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。&lt;/p&gt;
&lt;p&gt;从写操作模式到读操作模式切换的时候（&lt;strong&gt;flip&lt;/strong&gt;），position 都会归零，这样就可以从头开始读写了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;limit&lt;/strong&gt;：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107222029411-1629396478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%9D%E5%A7%8B%E5%8C%96%20Buffer&quot;&gt;初始化 Buffer&lt;/h3&gt;
&lt;p&gt;每个 Buffer 实现类都提供了一个静态方法 &lt;code&gt;allocate(int capacity)&lt;/code&gt; 帮助我们快速实例化一个 Buffer。如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ByteBuffer byteBuf = ByteBuffer.allocate(1024);
IntBuffer intBuf = IntBuffer.allocate(1024);
LongBuffer longBuf = LongBuffer.allocate(1024);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，我们经常使用 wrap 方法来初始化一个 Buffer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public static ByteBuffer wrap(byte[] array) {
    ...
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;%E5%A1%AB%E5%85%85%20Buffer&quot;&gt;填充 Buffer&lt;/h3&gt;
&lt;p&gt;各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 填充一个 byte 值
public abstract ByteBuffer put(byte b);
// 在指定位置填充一个 int 值
public abstract ByteBuffer put(int index, byte b);
// 将一个数组中的值填充进去
public final ByteBuffer put(byte[] src) {...}
public ByteBuffer put(byte[] src, int offset, int length) {...}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会java.nio.BufferOverflowException 异常。　　&lt;/p&gt;
&lt;p&gt;对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为读操作，因为数据是从外部（文件或网络等）读到内存中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int num = channel.read(buf);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述方法会返回从 Channel 中读入到 Buffer 的数据大小。&lt;/p&gt;
&lt;h3 id=&quot;%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC&quot;&gt;提取 Buffer 中的值&lt;/h3&gt;
&lt;p&gt;前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。&lt;/p&gt;
&lt;p&gt;如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。&lt;/p&gt;
&lt;p&gt;调用Buffer的flip()方法，可以从写模式切换到读模式，其实就是重新设置了一下position和limit的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer flip() {
    limit = position; // 将 limit 设置为实际写入的数据数量
    position = 0; // 重置 position 为 0
    mark = -1; // mark 之后再说
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应写操作的一系列put方法，读操作提供了一系列的get()方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 根据 position 来获取数据
public abstract byte get();
// 获取指定位置的数据
public abstract byte get(int index);
// 将 Buffer 中的数据写入到数组中
public ByteBuffer get(byte[] dst)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;附一个经常使用的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
new String(buffer.array()).trim();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了将数据从Buffer读取出来使用，更常见的操作是将写入的数据输出到Channel中，如通过FileChannel将数据写入到文件中，通过SocketChannel将数据写入到网络发送到远程机器等。对应的，这种操作，我们称之为写操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int num = channel.write(buf);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC&quot;&gt;mark()、reset()&lt;/h3&gt;
&lt;p&gt;除了position、limit、capacity这三个基本属性外，还有一个常用的属性就是mark。&lt;/p&gt;
&lt;p&gt;mark用于临时保存position的值，每次调用mark()方法都会将mark设置为当前的position，便于后学需要的时候使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer mark() {
    mark = position;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer reset() {
    int m = mark;
    if (m &amp;lt; 0)
        throw new InvalidMarkException();
    position = m;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;%E6%8F%90%E5%8F%96%20Buffer%20%E4%B8%AD%E7%9A%84%E5%80%BC&quot;&gt;rewind()、clear()、compact()&lt;/h3&gt;
&lt;p&gt;rewind()：会重置position为0，通常用于从头读写Buffer。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　clear()：相当于重新实例化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常，我们会先填充Buffer，然后从Buffer读取数据，之后再重新往里填充新的数据，我们一般在填充之前先调用clear().&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public final Buffer clear() {
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compact()：和clear()一样的是都是在准备往Buffer中填充新数据之前调用。&lt;/p&gt;
&lt;p&gt;clear()会重置几个属性，但是并不会将Buffer中的数据清空，只不过后面写的时候会覆盖之前的数据。&lt;/p&gt;
&lt;p&gt;而compact()方法调用之后，会先处理还没有读取的数据，也就是position到limit直接的数据，先将这些数据都移动到左边，然后在这个基础之上再开始写入。此时,limit还是等于capacity,position指向原来数据的右边。&lt;/p&gt;

&lt;h2&gt;Channel&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107224610788-1580870382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;FileChannel：文件通道，用于文件的读和写。&lt;/p&gt;
&lt;p&gt;DatagramChannel：用于UDP连接的接收和发送&lt;/p&gt;
&lt;p&gt;SocketChannel：TCP客户端&lt;/p&gt;
&lt;p&gt;ServerSocketChannel:TCP服务端，监听某个端口进来的请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107225318351-32434863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201811/811336-20181107225351491-527707889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;FileChannel&lt;/h3&gt;

&lt;p&gt;初始化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
FileInputStream inputStream = new FileInputStream(new File(&quot;/data.txt&quot;));
FileChannel fileChannel = inputStream.getChannel();　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，也可以从RandomAccessFile类中的getChannel来得到FileChannel。&lt;/p&gt;
&lt;p&gt;读取文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ByteBuffer buffer = ByteBuffer.allocate(1024);

int num = fileChannel.read(buffer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写入文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.put(&quot;随机写入一些内容到 Buffer 中&quot;.getBytes());
// Buffer 切换为读模式
buffer.flip();
while(buffer.hasRemaining()) {
    // 将 Buffer 中的内容写入文件
    fileChannel.write(buffer);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;SocketChannel&lt;/h3&gt;
&lt;p&gt;打开一个TCP链接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
SocketChannel socketChannel = SocketChannel&lt;br/&gt;　　.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 80));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然了，上面的这行代码等价于下面的两行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 打开一个通道
SocketChannel socketChannel = SocketChannel.open();
// 发起连接
socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 80));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 读取数据
socketChannel.read(buffer);

// 写入数据到网络连接中
while(buffer.hasRemaining()) {
    socketChannel.write(buffer);   
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ServerSocketChannel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 实例化
ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
// 监听 8080 端口
serverSocketChannel.socket().bind(new InetSocketAddress(8080));

while (true) {
    // 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理
    SocketChannel socketChannel = serverSocketChannel.accept();
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们看到了SocketChannel的第二个实例化方式。&lt;/p&gt;
&lt;p&gt;到这里，我们应该能理解SocketChannel了，它不仅仅是TCP客户端，它代表的是一个网络通道，可读可写。&lt;/p&gt;
&lt;p&gt;ServerSocketChannel不和Buffer打交道了，因为它并不实际处理数据，一旦接到请求，就会实例化一个SocketChannel，之后再这个简介通道上传递的数据它就不管了，它会继续监听端口等待下一个连接。&lt;/p&gt;
&lt;h3&gt;DatagramChannel&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监听端口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9090));

ByteBuffer buf = ByteBuffer.allocate(48);

channel.receive(buf);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;发送数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String newData = &quot;New String to write to file...&quot;
                    + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.put(newData.getBytes());
buf.flip();

int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Selector&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Selector建立在非阻塞的基础之上，大家经常听到的多路复用在java世界中指的就是它，用于实现一个线程管理多个Channel。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启Selector:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Selector selector = Selector.open();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，&lt;/span&gt;&lt;span&gt;FileChannel 不支持非阻塞&lt;/span&gt;&lt;span&gt;，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// 将通道设置为非阻塞模式，因为默认都是阻塞模式的
channel.configureBlocking(false);
// 注册
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SelectionKey.OP_READ:对应 00000001，通道中有数据可以进行读取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SelectionKey.OP_WRITE:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;对应 00000100，可以往通道中写入数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;SelectionKey.OP_CONNECT:&lt;/span&gt;&lt;/span&gt;&lt;span&gt;对应 00001000，成功建立 TCP 连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SelectionKey.OP_ACCEPT:&lt;/span&gt;&lt;span&gt;对应 00010000，接受 TCP 连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 000&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;000&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; 即十进制数值 17 即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注册方法返回值是 &lt;/span&gt;&lt;span&gt;SelectionKey&lt;/span&gt;&lt;span&gt; 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Selector selector = Selector.open();

channel.configureBlocking(false);

SelectionKey key = channel.register(selector, SelectionKey.OP_READ);

while(true) {
  // 判断是否有事件准备好
  int readyChannels = selector.select();
  if(readyChannels == 0) continue;

  // 遍历
  Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();
  Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = selectedKeys.iterator();
  while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
  }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于Selector，需要熟悉以下几个方法：&lt;/p&gt;
&lt;p&gt;select()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;调用此方法，会将&lt;/span&gt;&lt;span&gt;上次 select 之后的&lt;/span&gt;&lt;span&gt;准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;selectNow()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select(long timeout)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wakeup()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用 Buffer 的 &lt;/span&gt;&lt;span&gt;flip()&lt;/span&gt;&lt;span&gt; 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 15:16:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<og:description>Buffer 一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。 java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/9926490.html</dc:identifier>
</item>
<item>
<title>Flink 专题 -2 Checkpoint、Savepoint 机制 - 千狼</title>
<link>http://www.cnblogs.com/auguszero/p/9926394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/auguszero/p/9926394.html</guid>
<description>&lt;h2 id=&quot;checkpoint-保留策略&quot;&gt;1. checkpoint 保留策略&lt;/h2&gt;
&lt;p&gt;默认情况下，checkpoint 不会被保留，取消程序时即会删除他们，但是可以通过配置保留定期检查点，根据配置 当作业失败或者取消的时候 ，不会自动清除这些保留的检查点 。&lt;br/&gt;java :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;CheckpointConfig config = env.getCheckpointConfig();
config.enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExternalizedCheckpointCleanup 可选项如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION：&lt;/strong&gt; 取消作业时保留检查点。请注意，在这种情况下，您必须在取消后手动清理检查点状态。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ExternalizedCheckpointCleanup.DELETE_ON_CANCELLATION：&lt;/strong&gt; 取消作业时删除检查点。只有在作业失败时，检查点状态才可用。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;checkpoint-配置&quot;&gt;2. Checkpoint 配置&lt;/h2&gt;
&lt;p&gt;与SavePoint 类似 ,checkpoint 保留的是元数据文件和一些数据文件&lt;br/&gt;默认情况下checkpoint 只保留 一份最新数据，如果需要进行checkpoint数据恢复 ，可以通过全局设置的方式设置该集群默认的checkpoint 保留数，以保证后期可以从checkpoint 点进行恢复 。 同时为了 及时保存checkpoint状态 还需要在服务级别设置 checkpoint 检查点的 备份速度 。&lt;br/&gt;全局配置:&lt;br/&gt;flink-conf.yaml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置 checkpoint全局设置保存点  
state.checkpoints.dir: hdfs:///checkpoints/
// 设置checkpoint 默认保留 数量  
state.checkpoints.num-retained: 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意 如果将 checkpoint保存在hdfs 系统中 ， 需要设置 hdfs 元数据信息 : &lt;code&gt;fs.default-scheme:&lt;/code&gt;&lt;br/&gt;服务级别设置:&lt;br/&gt;java：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置 checkpoint 保存目录  
env.setStateBackend(new RocksDBStateBackend(&quot;hdfs:///checkpoints-data/&quot;);
// 设置checkpoint 检查点间隔时间  
env.enableCheckpointing(5000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提交任务之后 job 界面 和 hdfs 界面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过页面可以看出 checkpoint 备份方式是每5秒执行一次 ，保存当前所有task 状态元信息 和状态信息 。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;hdfs 信息 保存 jobId 为 0171897fa809692093b4a9b223cb35e4 最新的 20次 checkpoint 信息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483757/201811/1483757-20181107225544387-435829565.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483757/201811/1483757-20181107225551791-1484589207.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483757/201811/1483757-20181107225555071-1019883214.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;checkpoint-状态点恢复&quot;&gt;3. Checkpoint 状态点恢复&lt;/h2&gt;
&lt;p&gt;因为 flink checkpoint 目录 分别对应的是 jobId ， 每通过 flink run 方式 / 页面提交方式 都会重新生成 jobId ，那么如何通过checkpoint 恢复 失败任务或者重新执行保留时间点的 任务？&lt;/p&gt;
&lt;p&gt;flink 提供了 在启动 之时 通过设置 -s 参数指定checkpoint 目录 , 让新的jobId 读取该checkpoint 元文件信息和状态信息 ，从而达到指定时间节点启动 job 。启动方式如下 :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/flink -s /flink/checkpoints/0171897fa809692093b4a9b223cb35e4/chk-50/_metadata  -p  @Parallelism -c @Mainclass @jar  &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;savepoint-介绍&quot;&gt;Savepoint 介绍&lt;/h2&gt;
&lt;p&gt;Savepoint是通过Flink的检查点机制创建的流作业执行状态的一致图像。您可以使用Savepoints来停止和恢复，分叉或更新Flink作业。保存点由两部分组成：稳定存储（例如HDFS，S3，...）上的（通常是大的）二进制文件和（相对较小的）元数据文件的目录。稳定存储上的文件表示作业执行状态图像的净数据。Savepoint的元数据文件以（绝对路径）的形式包含（主要）指向作为Savepoint一部分的稳定存储上的所有文件的指针。&lt;/p&gt;
&lt;h2 id=&quot;savepoint-和-checkpoint-区别&quot;&gt;savepoint 和 checkpoint 区别&lt;/h2&gt;
&lt;p&gt;从概念上讲，Flink的Savepoints与Checkpoints的不同之处在于备份与传统数据库系统中的恢复日志不同。检查点的主要目的是在意外的作业失败时提供恢复机制。Checkpoint的生命周期由Flink管理，即Flink创建，拥有和发布Checkpoint - 无需用户交互。作为一种恢复和定期触发的方法，Checkpoint实现的两个主要设计目标是：i）being as lightweight to create （轻量级），ii）fast restore （快速恢复） 。针对这些目标的优化可以利用某些属性，例如，JobCode在执行尝试之间不会改变。&lt;/p&gt;
&lt;p&gt;与此相反，Savepoints由用户创建，拥有和删除。他们的用例是planned (计划) 的，manual backup( 手动备份 ) 和 resume（恢复） 。例如，这可能是您的Flink版本的更新，更改您的Job graph ，更改 parallelism ，分配第二个作业，如红色/蓝色部署，等等。当然，Savepoints必须在终止工作后继续存在。从概念上讲，保存点的生成和恢复成本可能更高，并且更多地关注可移植性和对前面提到的作业更改的支持。&lt;/p&gt;
&lt;h2 id=&quot;assigning-operator-ids-分配-operator-ids&quot;&gt;Assigning Operator IDs ( 分配 operator ids)&lt;/h2&gt;
&lt;p&gt;为了能够在将来升级你的程序在本节中描述。主要的必要更改是通过该uid(String)方法手动指定操作员ID 。这些ID用于确定每个运算符的状态。&lt;br/&gt;java：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DataStream&amp;lt;String&amp;gt; stream = env.
  // Stateful source (e.g. Kafka) with ID
  .addSource(new StatefulSource())
  .uid(&quot;source-id&quot;) // ID for the source operator
  .shuffle()
  // Stateful mapper with ID
  .map(new StatefulMapper())
  .uid(&quot;mapper-id&quot;) // ID for the mapper
  // Stateless printing sink
  .print(); // Auto-generated ID&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果您未手动指定ID，则会自动生成这些ID。只要这些ID不变，您就可以从保存点自动恢复。生成的ID取决于程序的结构，并且对程序更改很敏感。因此，强烈建议手动分配这些ID。&lt;/p&gt;
&lt;h2 id=&quot;savepoint-state&quot;&gt;Savepoint State&lt;/h2&gt;
&lt;p&gt;触发保存点时，会创建一个新的保存点目录，其中将存储数据和元数据。可以通过配置默认目标目录或使用触发器命令指定自定义目标目录来控制此目录的位置&lt;/p&gt;
&lt;h3 id=&quot;保存savepoint&quot;&gt;保存Savepoint&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink savepoint :jobId [:targetDirectory]&lt;/code&gt;&lt;br/&gt;这将触发具有ID的作业的保存点:jobId，并返回创建的保存点的路径。您需要此路径来还原和部署保存点。&lt;/p&gt;
&lt;h3 id=&quot;在yarn-集群中保存savepoint&quot;&gt;在yarn 集群中保存Savepoint&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink savepoint :jobId [:targetDirectory] -yid :yarnAppId&lt;/code&gt;&lt;br/&gt;这将触发具有ID :jobId和YARN应用程序ID 的作业的保存点:yarnAppId，并返回创建的保存点的路径。&lt;/p&gt;
&lt;h3 id=&quot;使用-savepoint-取消job&quot;&gt;使用 Savepoint 取消job&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink cancel -s [:targetDirectory] :jobId&lt;/code&gt;&lt;br/&gt;这将以原子方式触发具有ID的作业的保存点:jobid并取消作业。此外，您可以指定目标文件系统目录以存储保存点。该目录需要可由JobManager和TaskManager访问。&lt;/p&gt;
&lt;h3 id=&quot;resuming-savepoint&quot;&gt;Resuming Savepoint&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink run -s :savepointPath [:runArgs]&lt;/code&gt;&lt;br/&gt;这将提交作业并指定要从中恢复的保存点。您可以指定保存点目录或_metadata文件的路径。&lt;/p&gt;
&lt;h3 id=&quot;允许未恢复状态启动&quot;&gt;允许未恢复状态启动&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ bin/flink run -s :savepointPath -n [:runArgs]&lt;/code&gt;&lt;br/&gt;默认情况下，resume操作将尝试将保存点的所有状态映射回要恢复的程序。如果删除了运算符，则可以通过--allowNonRestoredState（short -n:)选项跳过无法映射到新程序的状态：&lt;/p&gt;
&lt;h3 id=&quot;全局配置&quot;&gt;全局配置&lt;/h3&gt;
&lt;p&gt;您可以通过state.savepoints.dir 配置文件设置默认savepoint 位置 。触发保存点时，此目录将用于存储保存点。您可以通过使用触发器命令指定自定义目标目录来覆盖默认值（请参阅:targetDirectory参数）。&lt;br/&gt;flink-conf.yaml&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;# Default savepoint target directory
state.savepoints.dir: hdfs:///flink/savepoints&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考地址:&lt;/p&gt;
&lt;p&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.6/ops/state/state_backends.html&lt;br/&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.6/ops/state/checkpoints.html&lt;br/&gt;https://ci.apache.org/projects/flink/flink-docs-release-1.6/ops/state/savepoints.html&lt;br/&gt;http://ju.outofmemory.cn/entry/370841&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 14:57:00 +0000</pubDate>
<dc:creator>千狼</dc:creator>
<og:description>CheckPoint 1. checkpoint 保留策略 默认情况下，checkpoint 不会被保留，取消程序时即会删除他们，但是可以通过配置保留定期检查点，根据配置 当作业失败或者取消的时候 ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/auguszero/p/9926394.html</dc:identifier>
</item>
<item>
<title>python基础学习（十二）变量进阶 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-variable-adv.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-variable-adv.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;变量的引用&quot;&gt;1. 变量的引用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;变量 和 数据 都是保存在 &lt;strong&gt;内存&lt;/strong&gt; 中的&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中 &lt;strong&gt;函数 的 参数传递&lt;/strong&gt; 以及 &lt;strong&gt;返回值&lt;/strong&gt; 都是靠 &lt;strong&gt;引用&lt;/strong&gt; 传递的&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;引用的概念&quot;&gt;1.1 引用的概念&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt; 和 &lt;strong&gt;数据&lt;/strong&gt; 是分开存储的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt; 保存在内存中的一个位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt; 中保存着&lt;strong&gt;数据&lt;/strong&gt;在内存中的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt; 中 &lt;strong&gt;记录数据的地址&lt;/strong&gt;，就叫做 &lt;strong&gt;引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;id()&lt;/code&gt; 函数可以查看变量中保存数据所在的 &lt;strong&gt;内存地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 &lt;strong&gt;修改了数据的引用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量 &lt;strong&gt;不再&lt;/strong&gt; 对之前的数据引用&lt;/li&gt;
&lt;li&gt;变量 &lt;strong&gt;改为&lt;/strong&gt; 对新赋值的数据引用&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;变量引用-的实例&quot;&gt;1.2 变量引用 的实例&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
a = 1

print(&quot;a的内存地址是：%d&quot; % id(a))

b = 2

print(&quot;b的内存地址是：%d&quot; % id(b))

c = 2
print(&quot;c的内存地址是：%d&quot; % id(c))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数的参数和返回值的传递&quot;&gt;1.3 函数的参数和返回值的传递&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，函数的 &lt;strong&gt;实参&lt;/strong&gt;/&lt;strong&gt;返回值&lt;/strong&gt; 都是是靠 &lt;strong&gt;引用&lt;/strong&gt; 来传递来的，写了小的例子尝试下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def test(num):

    print(&quot;-&quot; * 50)
    print(&quot;%d 在函数中的内存地址是 %d&quot; % (num, id(num)))
    
    result = 12
    
    print(&quot;返回值 %d 在内存中的地址是 %d&quot; % (result, id(result)))
    print(&quot;-&quot; * 50)
    
    return result

n = 100

print(&quot;%d在调用之前的内存地址是%d&quot; % (n, id(n)))

r = test(n)

print(&quot;调用函数后，实参 %d 的内存地址是 %d&quot; % (n, id(n)))
print(&quot;调用函数后，返回值 %d 的内存地址是 %d&quot; % (r, id(r)))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可变和不可变类型&quot;&gt;2. 可变和不可变类型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不可变类型&lt;/strong&gt;，内存中的数据不允许被修改：
&lt;ul&gt;&lt;li&gt;数字类型 &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;, &lt;code&gt;long(2.x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串 &lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;元组 &lt;code&gt;tuple&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可变类型&lt;/strong&gt;，内存中的数据可以被修改：
&lt;ul&gt;&lt;li&gt;列表 &lt;code&gt;list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字典 &lt;code&gt;dict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可变类型&lt;/strong&gt;的数据变化，是通过 &lt;strong&gt;方法&lt;/strong&gt; 来实现的&lt;/li&gt;
&lt;li&gt;如果给一个可变类型的变量，赋值了一个新的数据，&lt;strong&gt;引用会修改&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;变量 &lt;strong&gt;不再&lt;/strong&gt; 对之前的数据引用&lt;/li&gt;
&lt;li&gt;变量 &lt;strong&gt;改为&lt;/strong&gt; 对新赋值的数据引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;哈希-hash&quot;&gt;哈希 &lt;code&gt;(hash)&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Python&lt;/code&gt; 中内置有一个名字叫做 &lt;code&gt;hash(o)&lt;/code&gt; 的函数
&lt;ul&gt;&lt;li&gt;接收一个 &lt;strong&gt;不可变类型&lt;/strong&gt; 的数据作为 &lt;strong&gt;参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回&lt;/strong&gt; 结果是一个 &lt;strong&gt;整数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;哈希&lt;/code&gt; 是一种 &lt;strong&gt;算法&lt;/strong&gt;，其作用就是提取数据的 &lt;strong&gt;特征码（指纹）&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;相同的内容&lt;/strong&gt; 得到 &lt;strong&gt;相同的结果&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同的内容&lt;/strong&gt; 得到 &lt;strong&gt;不同的结果&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，设置字典的 &lt;strong&gt;键值对&lt;/strong&gt; 时，会首先对 &lt;code&gt;key&lt;/code&gt; 进行 &lt;code&gt;hash&lt;/code&gt; 已决定如何在内存中保存字典的数据，以方便 &lt;strong&gt;后续&lt;/strong&gt; 对字典的操作：&lt;strong&gt;增、删、改、查&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;键值对的 &lt;code&gt;key&lt;/code&gt; 必须是不可变类型数据&lt;/li&gt;
&lt;li&gt;键值对的 &lt;code&gt;value&lt;/code&gt; 可以是任意类型的数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201811/1156642-20181107220800640-471985362.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;局部变量和全局变量&quot;&gt;3. 局部变量和全局变量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt; 是在 &lt;strong&gt;函数内部&lt;/strong&gt; 定义的变量，&lt;strong&gt;只能在函数内部使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; 是在 &lt;strong&gt;函数外部定义&lt;/strong&gt; 的变量（没有定义在某一个函数内），&lt;strong&gt;所有函数&lt;/strong&gt; 内部 &lt;strong&gt;都可以使用这个变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示：在其他的开发语言中，大多 &lt;strong&gt;不推荐使用全局变量&lt;/strong&gt; —— 可变范围太大，导致程序不好维护！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;局部变量&quot;&gt;3.1 局部变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt; 是在 &lt;strong&gt;函数内部&lt;/strong&gt; 定义的变量，&lt;strong&gt;只能在函数内部使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;函数执行结束后，&lt;strong&gt;函数内部的局部变量，会被系统回收&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不同的函数，可以定义相同的名字的局部变量，但是 &lt;strong&gt;彼此之间&lt;/strong&gt; 不会产生影响&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;局部变量的作用&quot;&gt;局部变量的作用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在函数内部使用，&lt;strong&gt;临时&lt;/strong&gt; 保存 &lt;strong&gt;函数内部需要使用的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def test1():

    num = 1

    print(num)

    num = 22

    print(&quot;修改过后 %d&quot; % num)


def test2():

    num = 30

    print(num)


test1()
test2()

print(&quot;结束&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;局部变量的生命周期&quot;&gt;局部变量的生命周期&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;所谓 &lt;strong&gt;生命周期&lt;/strong&gt; 就是变量从 &lt;strong&gt;被创建&lt;/strong&gt; 到 &lt;strong&gt;被系统回收&lt;/strong&gt; 的过程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局部变量&lt;/strong&gt; 在 &lt;strong&gt;函数执行时&lt;/strong&gt; 才会被创建&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数执行结束后&lt;/strong&gt; 局部变量 &lt;strong&gt;被系统回收&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;局部变量在生命周期&lt;/strong&gt; 内，可以用来存储 &lt;strong&gt;函数内部临时使用到的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;全局变量&quot;&gt;3.2 全局变量&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; 是在 &lt;strong&gt;函数外部定义&lt;/strong&gt; 的变量，所有函数内部都可以使用这个变量&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = 10


def test1():

    print(num)


def test2():

    num = 22

    print(num)


test1()
test2()

print(num)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：函数执行时，&lt;strong&gt;需要处理变量时&lt;/strong&gt; 会：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;首先&lt;/strong&gt; 查找 &lt;strong&gt;函数内部&lt;/strong&gt; 是否存在 &lt;strong&gt;指定名称 的局部变量&lt;/strong&gt;，&lt;strong&gt;如果有，直接使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果没有，查找 &lt;strong&gt;函数外部&lt;/strong&gt; 是否存在 &lt;strong&gt;指定名称 的全局变量&lt;/strong&gt;，&lt;strong&gt;如果有，直接使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果还没有，程序报错！&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;在函数中不能直接修改-全局变量的引用&quot;&gt;1) 在函数中不能直接修改 &lt;code&gt;全局变量的引用&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全局变量&lt;/strong&gt; 是在 &lt;strong&gt;函数外部定义&lt;/strong&gt; 的变量（没有定义在某一个函数内），&lt;strong&gt;所有函数&lt;/strong&gt; 内部 &lt;strong&gt;都可以使用这个变量&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;提示：在其他的开发语言中，大多 &lt;strong&gt;不推荐使用全局变量&lt;/strong&gt; —— 可变范围太大，导致程序不好维护！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在函数内部，可以 &lt;strong&gt;通过全局变量的引用获取对应的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;但是，&lt;strong&gt;不允许直接修改全局变量的引用&lt;/strong&gt; —— 使用赋值语句修改全局变量的值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = 10


def test1():

    print(&quot;test1&quot; + &quot;*&quot; * 50)

    num = 100

    print(num)


def test2():

    print(&quot;test2&quot; + &quot;*&quot; * 50)

    print(num)


test1()
test2()

print(&quot;over&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;在函数内部修改全局变量的值&quot;&gt;2) 在函数内部修改全局变量的值&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果在函数中需要修改全局变量，需要使用 &lt;code&gt;global&lt;/code&gt; 进行声明&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;num = 10


def test1():

    print(&quot;test1&quot; + &quot;*&quot; * 50)

    global num
    num = 100

    print(num)


def test2():

    print(&quot;test2&quot; + &quot;*&quot; * 50)

    print(num)


test1()
test2()

print(&quot;over&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;全局变量定义的位置&quot;&gt;3) 全局变量定义的位置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为了保证所有的函数都能够正确使用到全局变量，应该 &lt;strong&gt;将全局变量定义在其他函数的上方&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;a = 1


def test():

    print(a)
    print(b)
    print(c)


b = 2
test()
c = 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;全局变量命名的建议&quot;&gt;4) 全局变量命名的建议&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如：&lt;/li&gt;
&lt;li&gt;全局变量名前应该增加 &lt;code&gt;g_&lt;/code&gt; 或者 &lt;code&gt;gl_&lt;/code&gt; 的前缀&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;提示：具体的要求格式，各公司要求可能会有些差异&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;gl_num = 33
gl_name = &quot;zfx&quot;


def test():

    num = 10

    print(num)
    print(gl_name)


test()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 07 Nov 2018 14:40:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念 在 中 变量 和 数据 是分开存储的 数据 保</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-variable-adv.html</dc:identifier>
</item>
<item>
<title>Spring知识点总结(三)之注解方式实现IOC和DI - 南岭寒</title>
<link>http://www.cnblogs.com/nanlinghan/p/9926154.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanlinghan/p/9926154.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;    1. 注解概念&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        所谓注解就是给程序看的提示信息，很多时候都用来作为轻量级配置的方式。&lt;br/&gt;        关于注解的知识点，参看java基础课程中java基础加强部分的内容。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    2. Spring中的注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        Spring除了默认的使用xml配置文件的方式实现配置之外，也支持使用注解方式实现配置，这种方式效率更高，配置信息清晰，修改更方便，推荐使用。&lt;br/&gt;        &lt;br/&gt;        引入context名称空间：&lt;br/&gt;            在MyEclipse中导入spring-context-3.2.xsd约束文件，要求Spring来管理。&lt;br/&gt;            在applicationContext.xml文件中，引入该schema文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
                1     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
                2     &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
                3         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
                4         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
                5         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                6         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
                7         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
                8         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
                9         &quot;&amp;gt;
               10     &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            **可以将以上头信息加入MyEclipse模版，方便后续自动生成。&lt;br/&gt;    &lt;br/&gt;   &lt;strong&gt;&lt;span&gt; 3. 使用类注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        使用Spring的类注解可以通过注解注册类为bean，省去了配置文件中的&amp;lt;bean&amp;gt;配置。&lt;br/&gt;        &lt;br/&gt;        a. 开启包扫描&lt;br/&gt;        在spring的配置文件中，开启包扫描，指定spring自动扫描哪些个包下的类。&lt;br/&gt;            &amp;lt;context:component-scan base-package=&quot;cn.tedu.beans&quot;/&amp;gt;&lt;br/&gt;        案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
                xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
                xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
                xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
                &quot;&amp;gt;
                &amp;lt;!-- 开启包扫描 --&amp;gt;
                &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;cn.tedu.beans&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
                &amp;lt;!--
                    &amp;lt;bean id=&quot;person&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Person&quot;&amp;gt;&amp;lt;/bean&amp;gt;       
                    &amp;lt;bean id=&quot;cat&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Cat&quot;&amp;gt;&amp;lt;/bean&amp;gt;       
                    &amp;lt;bean id=&quot;dog&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.tedu.beans.Dog&quot;&amp;gt;&amp;lt;/bean&amp;gt;       
                     --&amp;gt;
            &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            &lt;br/&gt;        b. 使用注解注册bean&lt;br/&gt;            这个包中的类会在spring容器启动时自动被扫描，检测是否需要自动配置为bean.&lt;br/&gt;            在配置的包中的类上使用@Component注解，则这个类会自动被注册为bean，使用当前类的class为&amp;lt;bean&amp;gt;的class，通常情况下使用类名首字母小写为&amp;lt;bean&amp;gt;id。&lt;br/&gt;            案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
                
                @Component
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person{
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            &lt;br/&gt;        c. bean的id&lt;br/&gt;            可以使bean类实现BeanNameAware接口，并实现其中的setBeanName方法，spring容器会在初始化bean时，调用此方法告知当前bean的id。通过这个方式可以获取bean的id信息。&lt;br/&gt;            &lt;br/&gt;            通常情况下注解注册bean使用类名首字母小写为bean的id，但是如果类名的第二个字母为大写则首字母保留原样.&lt;br/&gt;                cn.tedu.beans.Person --&amp;gt; &amp;lt;bean id=&quot;person&quot; class=&quot;cn.tedu.beans.Person&quot;/&amp;gt;&lt;br/&gt;                cn.tedu.beans.NBA --&amp;gt; &amp;lt;bean id=&quot;NBA&quot; class=&quot;cn.tedu.beans.NBA&quot;/&amp;gt;&lt;br/&gt;            也可以通过在@Component中配置value属性，明确的指定当前类在注册到spring时bean的id&lt;br/&gt;            案例：&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 
&lt;span&gt; 8&lt;/span&gt;                 @Component(&quot;per&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         System.out.println(&quot;===&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;===&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            &lt;br/&gt;&lt;strong&gt;&lt;span&gt;    4. 使用属性注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        使用属性注解，可以为bean配置属性的注入过程，省去了在配置文件中进行注入配置的过程，更加便捷。&lt;br/&gt;        &lt;br/&gt;        a. 在配置文件中开启属性注解功能&lt;br/&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
            &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
                xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
                xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
                xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
                http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
                &quot;&amp;gt;
                &amp;lt;!-- 开启属性注解 --&amp;gt;
                &amp;lt;context:annotation-config&amp;gt;&amp;lt;/context:annotation-config&amp;gt;
            &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        b. 使用属性注解注入bean类型数据：&lt;br/&gt;            在bean中的属性上通过如下注解声明属性注入&lt;br/&gt;                @Autowired&lt;br/&gt;            也可以使用@Qualifier(value=&quot;dog1&quot;)注解,明确的指定,要注入哪个id的bean&lt;br/&gt;            &lt;br/&gt;            代码：&lt;br/&gt;           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
                
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
                &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
                
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
                    @Autowired
                    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
                    @Autowired
                    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cat cat;
                    
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog getDog() {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dog;
                    }
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDogx(Dog dog) {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
                    }
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat getCat() {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
                    }
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCat(Cat cat) {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cat =&lt;span&gt; cat;
                    }
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person [dog=&quot; + dog + &quot;, cat=&quot; + cat + &quot;]&quot;&lt;span&gt;;
                    }
                    
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
                        System.out.println(&lt;/span&gt;&quot;==============&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;====&quot;+&lt;span&gt;name);
                    }
                    
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;                &lt;br/&gt;        c. 属性注入bean类型数据的原理:&lt;br/&gt;            当spring容器解析xml时,发现开启了属性注解,则会在创建bean时,检测属性上是否存在@Autowired注解,如果发现该注解,则会通过当前属性的名称寻找是否存在该id的bean,如果存在则注入进来,如果不存在,再检查是否存在和当前属性类型相同的bean,如果由则注入进来,如果都没有则抛出异常.&lt;br/&gt;            &lt;br/&gt;            **也可以使用@Resource(name=&quot;id&quot;)指定注入给定id的bean，但是这种方式不建议大家使用。&lt;br/&gt;            &lt;br/&gt;        d. spring内置支持注入类型的注解方式的注入 - 非集合类型&lt;br/&gt;            spring中可以通过注解方式 注册bean，并可以通过@Autowired实现属性的自动注入，但注入的都是自定义的bean类型，如果类中包含例如 int long String等spring内置可注入的类型时，又该如何注入呢？ 可以使用@Value注解来实现注入。&lt;br/&gt;               &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 
&lt;span&gt; 8&lt;/span&gt;                 @Component(&quot;per&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     @Value(&quot;999&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     
&lt;span&gt;13&lt;/span&gt;                     @Value(&quot;zs&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cat cat;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     
&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog getDog() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDogx(Dog dog) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat getCat() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCat(Cat cat) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.cat =&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;, dog=&quot; +&lt;span&gt; dog
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                 + &quot;, cat=&quot; + cat + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                         System.out.println(&quot;===&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;===&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     
&lt;span&gt;45&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;            这种方式可以实现spring内置类型的注入，但是这种方式将注入的值写死在了代码中，后续如果希望改变注入的初始值，必须来修改源代码，此时可以将这些值配置到一个properties配置文件中，再在spring中进行引入。&lt;br/&gt;                &lt;br/&gt;            &lt;br/&gt;                &lt;br/&gt;                &lt;br/&gt;                &lt;br/&gt;            &lt;br/&gt;        e. spring内置支持注入类型的注解方式的注入 - 集合类型&lt;br/&gt;            需要将集合类型的数据配置到spring配置文件中，再通过@Value引入&lt;br/&gt;            配置过程：&lt;br/&gt;                将spring-util-3.2.xsd交给MyEclipse管理&lt;br/&gt;                在当前spring容器的配置文件中导入util名称空间&lt;br/&gt;                再通过适当的util标签注册数据&lt;br/&gt;            案例：&lt;br/&gt;           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt;  2&lt;/span&gt;                 &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt;  3&lt;/span&gt;                     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
&lt;span&gt;  4&lt;/span&gt;                     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
&lt;span&gt;  5&lt;/span&gt;                     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt;  6&lt;/span&gt;                     xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.2.xsd&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.2.xsd&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;                     http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/util/spring-util-3.2.xsd&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;                     &quot;&amp;gt;
&lt;span&gt; 14&lt;/span&gt;                     &amp;lt;!-- 开启属性注解 --&amp;gt;
&lt;span&gt; 15&lt;/span&gt;                     &amp;lt;context:annotation-config&amp;gt;&amp;lt;/context:annotation-config&amp;gt;
&lt;span&gt; 16&lt;/span&gt;                     &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;cn.tedu.beans&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;span&gt; 17&lt;/span&gt;                     &amp;lt;context:property-placeholder location=&quot;classpath:/person-data.properties&quot;/&amp;gt;
&lt;span&gt; 18&lt;/span&gt;                     
&lt;span&gt; 19&lt;/span&gt;                     &amp;lt;util:list id=&quot;l1&quot;&amp;gt;
&lt;span&gt; 20&lt;/span&gt;                         &amp;lt;value&amp;gt;北京&amp;lt;/value&amp;gt;
&lt;span&gt; 21&lt;/span&gt;                         &amp;lt;value&amp;gt;上海&amp;lt;/value&amp;gt;
&lt;span&gt; 22&lt;/span&gt;                         &amp;lt;value&amp;gt;广州&amp;lt;/value&amp;gt;
&lt;span&gt; 23&lt;/span&gt;                         &amp;lt;value&amp;gt;深证&amp;lt;/value&amp;gt;
&lt;span&gt; 24&lt;/span&gt;                     &amp;lt;/util:list&amp;gt;
&lt;span&gt; 25&lt;/span&gt;                     
&lt;span&gt; 26&lt;/span&gt;                     &amp;lt;util:set id=&quot;s1&quot;&amp;gt;
&lt;span&gt; 27&lt;/span&gt;                         &amp;lt;value&amp;gt;法师&amp;lt;/value&amp;gt;
&lt;span&gt; 28&lt;/span&gt;                         &amp;lt;value&amp;gt;射手&amp;lt;/value&amp;gt;
&lt;span&gt; 29&lt;/span&gt;                         &amp;lt;value&amp;gt;打野&amp;lt;/value&amp;gt;
&lt;span&gt; 30&lt;/span&gt;                         &amp;lt;value&amp;gt;战士&amp;lt;/value&amp;gt;
&lt;span&gt; 31&lt;/span&gt;                         &amp;lt;value&amp;gt;打野&amp;lt;/value&amp;gt;
&lt;span&gt; 32&lt;/span&gt;                         &amp;lt;value&amp;gt;坦克&amp;lt;/value&amp;gt;
&lt;span&gt; 33&lt;/span&gt;                         &amp;lt;value&amp;gt;打野&amp;lt;/value&amp;gt;
&lt;span&gt; 34&lt;/span&gt;                     &amp;lt;/util:set&amp;gt;
&lt;span&gt; 35&lt;/span&gt;                         
&lt;span&gt; 36&lt;/span&gt;                     &amp;lt;util:map id=&quot;m1&quot;&amp;gt;
&lt;span&gt; 37&lt;/span&gt;                         &amp;lt;entry key=&quot;k1&quot; value=&quot;v1&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 38&lt;/span&gt;                         &amp;lt;entry key=&quot;k2&quot; value=&quot;v2&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 39&lt;/span&gt;                         &amp;lt;entry key=&quot;k3&quot; value=&quot;v3&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 40&lt;/span&gt;                         &amp;lt;entry key=&quot;k1&quot; value=&quot;v4&quot;&amp;gt;&amp;lt;/entry&amp;gt;
&lt;span&gt; 41&lt;/span&gt;                     &amp;lt;/util:map&amp;gt;       
&lt;span&gt; 42&lt;/span&gt;                 &amp;lt;/beans&amp;gt;
&lt;span&gt; 43&lt;/span&gt;             
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            再在类的属性中通过@Value注入赋值
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 
&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 
&lt;span&gt; 51&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanNameAware;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 
&lt;span&gt; 56&lt;/span&gt;                 @Component(&quot;per&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanNameAware{
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     @Value(&quot;${id}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     
&lt;span&gt; 61&lt;/span&gt;                     @Value(&quot;${name}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                     
&lt;span&gt; 64&lt;/span&gt;                     @Value(&quot;#{@l1}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; addr;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     
&lt;span&gt; 67&lt;/span&gt;                     @Value(&quot;#{@s1}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; jobs;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                     
&lt;span&gt; 70&lt;/span&gt;                     @Value(&quot;#{@m1}&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt; map;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Dog dog;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                     
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;                    @Autowired
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Cat cat;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     
&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog getDog() {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDogx(Dog dog) {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.dog =&lt;span&gt; dog;
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cat getCat() {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCat(Cat cat) {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                         &lt;span&gt;this&lt;/span&gt;.cat =&lt;span&gt; cat;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 
&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBeanName(String name) {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         System.out.println(&quot;==============&quot;+&lt;span&gt;this&lt;/span&gt;.getClass().getName()+&quot;====&quot;+&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; &quot;Person [id=&quot; + id + &quot;, name=&quot; + name + &quot;, addr=&quot; +&lt;span&gt; addr
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                                 + &quot;, jobs=&quot; + jobs + &quot;, map=&quot; + map + &quot;, dog=&quot; + dog + &quot;, cat=&quot;
&lt;span&gt; 99&lt;/span&gt;                                 + cat + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;    5. 其他注解&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;        a. @Scope(value=&quot;prototype&quot;)&lt;br/&gt;            配置修饰的类的bean是单例还是多例，如果不配置默认为单例&lt;br/&gt;            案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                 &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Scope;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                @Component
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 @Scope(&quot;prototype&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 
&lt;span&gt;10&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        b. @Lazy&lt;br/&gt;            配置修饰的类的bean采用懒加载机制&lt;br/&gt;            案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;                 &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Lazy;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Scope;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                @Component
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Lazy
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         System.out.println(&quot;Dog...被创建出来了...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        c. @PostConstruct&lt;br/&gt;            在bean对应的类中 修饰某个方法 将该方法声明为初始化方法，对象创建之后立即执行。&lt;br/&gt;        d. @PreDestroy&lt;br/&gt;            在bean对应的类中 修饰某个方法 将该方法声明为销毁的方法，对象销毁之前调用的方法。&lt;br/&gt;            案例：&lt;br/&gt;             &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.tedu.beans;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                 
&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PostConstruct;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PreDestroy;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                @Component
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dog {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         System.out.println(&quot;Dog...被创建出来了...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    @PostConstruct
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                         System.out.println(&quot;Dog的初始化方法。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    @PreDestroy
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destory(){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         System.out.println(&quot;Dog的销毁方法。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;        e. @Controller @Service @Repository @Component&lt;br/&gt;            这四个注解的功能是完全相同的，都是用来修饰类，将类声明为Spring管理的bean的。&lt;br/&gt;            其中@Component一般认为是通用的注解&lt;br/&gt;            而@Controller用在软件分层中的控制层，一般用在web层&lt;br/&gt;            而@Service用在软件分层中的业务访问层，一般用在service层&lt;br/&gt;            而@Repository用在软件分层中的数据访问层，一般用在dao层&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 14:17:00 +0000</pubDate>
<dc:creator>南岭寒</dc:creator>
<og:description>1. 注解概念 所谓注解就是给程序看的提示信息，很多时候都用来作为轻量级配置的方式。 关于注解的知识点，参看java基础课程中java基础加强部分的内容。 2. Spring中的注解 Spring除了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanlinghan/p/9926154.html</dc:identifier>
</item>
<item>
<title>代码中的奥卡姆剃刀原理 - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/9926136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/9926136.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如无必要，勿增实体。&lt;/p&gt;
&lt;p&gt;过早的优化是万恶之源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;一个抽奖活动，要求在展示奖品股票时，显示股票价格。开发在实现这个功能的时候，用redis缓存每只股票的价格，每两小时调用行情服务更新一次。&lt;/p&gt;
&lt;p&gt;问为什么要做个缓存，而不是直接访问行情服务直接读取，给出了几个理由：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少对行情的请求，直接访问redis一次就能查很多。&lt;/li&gt;
&lt;li&gt;用缓存速度快。&lt;/li&gt;
&lt;li&gt;奖品展示、获奖排行榜都要用行情数据，防止不一致。&lt;/li&gt;
&lt;li&gt;用行情的地方很多，不用每次请求行情服务。&lt;/li&gt;
&lt;li&gt;前端需要拉取的数据，在需求范围内，可以接受两小时不变，不用每次重新计算。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是这些理由都站不住脚，直接访问行情服务并不会有问题。&lt;br/&gt;优化过渡，过早加了缓存，增加了代码的复杂度，产生了数据的不一致性。&lt;br/&gt;没有解决具体的问题，看到的只是一些表象，看似解决了问题。&lt;/p&gt;
&lt;h2&gt;思考&lt;/h2&gt;
&lt;p&gt;逐条思考下上面的几点理由。&lt;/p&gt;
&lt;p&gt;理由1. 减少对行情的请求，直接访问redis一次就能查很多。&lt;/p&gt;
&lt;p&gt;说法是对的，确实减少了对行情的访问。但是为什么要减少对行情的访问呢？&lt;br/&gt;行情的服务很稳定，而且性能也很好，并没有什么问题。没有解决具体问题。&lt;/p&gt;
&lt;p&gt;理由2. 用缓存速度快。&lt;/p&gt;
&lt;p&gt;如果直接访问行情数据源速度是瓶颈吗，有遇到性能问题吗？没有。行情也是内存访问，速度不一定比redis慢的。而且开发也没有数据支撑。&lt;/p&gt;
&lt;p&gt;理由3. 奖品展示、获奖排行榜都要用行情数据，防止不一致。&lt;/p&gt;
&lt;p&gt;为什么要一致，不一致有什么问题？对于排行榜，大家都有预期，是一定时间才更新一次的，只要在排行榜界面有说明即可。就像游戏的排行榜，很多都是24小时更新一次。没有必要为了和排行榜数据一致，而修改代码。这个问题在产品形态上就能解决，也是个伪问题。&lt;/p&gt;
&lt;p&gt;理由4. 用行情的地方很多，不用每次请求行情服务。&lt;/p&gt;
&lt;p&gt;同理由1，多怎么了？正常访问就可以了，如果性能瓶颈再优化。&lt;/p&gt;
&lt;p&gt;理由5. 前端需要拉取的数据，在需求范围内，可以接受两小时不变，不用每次重新计算。&lt;/p&gt;
&lt;p&gt;具体的产品形态，可以有加缓存的余地，但不意味着必须要加缓存。除非遇到有性能问题，否则代码的可维护性、稳定性是最重要的。&lt;/p&gt;
&lt;p&gt;再换个角度，如果行情的接口性能真的很慢，要怎么优化呢？&lt;/p&gt;
&lt;p&gt;不是直接暴露redis接口的，有更好的方法。&lt;br/&gt;把行情获取部分单独封装成为一个独立函数，对外不依赖具体的内部实现。&lt;br/&gt;不管是直接访问行情服务、读缓存，还是访问一个单独封装的优化行情服务模块，对外接口都不变。&lt;/p&gt;
&lt;p&gt;整理下常见的避免过渡优化场景：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、能同步实现的代码，就不要用异步；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、能实时实现的代码，就不要用定时；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、能用数据源读取的，就不要用缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先保证程序简洁，满足性能要求，等遇到问题的时候，再去优化，避免过早优化，引入问题。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;解决问题前，先思考是否有问题，问题是什么，而不是直接去做。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;「如无必要，勿增实体」代码模块中，在没有遇到问题时，不要引入过多的模块，缓存，增加代码的复杂性。既不易于阅读，也不易于维护。&lt;/p&gt;
&lt;p&gt;遇到性能优化，不优化有问题，优化过渡，即使没产生问题，也是浪费。&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;

&lt;div&gt;&lt;img src=&quot;http://www.owenzhang.net/blog/wp-content/uploads/2018/08/qrcode.png&quot; alt=&quot;欢迎收听公众号&quot; align=&quot;middle&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 07 Nov 2018 14:13:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>如无必要，勿增实体。 过早的优化是万恶之源。 背景 一个抽奖活动，要求在展示奖品股票时，显示股票价格。开发在实现这个功能的时候，用redis缓存每只股票的价格，每两小时调用行情服务更新一次。 问为什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/owenandhisfriends/p/9926136.html</dc:identifier>
</item>
<item>
<title>Author name disambiguation using a graph model with node splitting and merging based on bibliographic information - 超然haha</title>
<link>http://www.cnblogs.com/chaoran/p/9926102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaoran/p/9926102.html</guid>
<description>&lt;h2 id=&quot;9027-1541464767661&quot;&gt;Author name disambiguation using a graph model with node splitting and merging based on bibliographic information&lt;/h2&gt;
&lt;p&gt;基于文献信息进行节点拆分和合并的图模型消歧方法（GFAD）&lt;/p&gt;



&lt;p&gt;这是一篇比较早的文章，将人名消歧过程作为一个系统，主要想学习它对消歧过程中的各个阶段的划分&lt;/p&gt;
&lt;p&gt;GFAD 是一个面向图的框架，对于元信息缺失，错误信息的存在具有较好的鲁棒性，且不依赖web 环境，也不需要群体数量信息，不需要估计特定的参数或阈值。其中，顶点表示作者，边表示合作关系。&lt;/p&gt;
&lt;p&gt;同名问题：分割多个不重叠的环中的共同顶点&lt;/p&gt;
&lt;p&gt;异名问题：合并具有不同名的顶点&lt;/p&gt;
&lt;p&gt;同时：能够处理异常问题&lt;/p&gt;
&lt;h2 id=&quot;9146-1541464994884&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;1. 基于图的作者姓名消歧方法&lt;/p&gt;
&lt;p&gt;2. 使用合作关系构建图模型&lt;/p&gt;
&lt;p&gt;3. 基于节点分割和合并解决模糊类别&lt;/p&gt;

&lt;p&gt;已有研究：&lt;/p&gt;
&lt;p&gt;1. 只处理同名问题&lt;/p&gt;
&lt;p&gt;2. 依赖于邮件，网页等辅助信息&lt;/p&gt;

&lt;h2 id=&quot;3336-1541465397561&quot;&gt;2. 创新点&lt;/h2&gt;
&lt;p&gt;涵盖了同名和异名问题&lt;/p&gt;
&lt;p&gt;目的：构建对特定域（或数字图书馆）不敏感的通用框架，避免数据缺失和环境错误的影响&lt;/p&gt;

&lt;p&gt;只依赖 title 和 co-author&lt;/p&gt;
&lt;p&gt;1. 以图表为导向的人名消歧方法，从文献信息分析作者间的关系构建图模型&lt;/p&gt;
&lt;p&gt;2. 通过链接合作者推断作者的社交环（过去和现在的学术关系）&lt;/p&gt;
&lt;p&gt;3. 利用顶点分割或顶点合并&lt;/p&gt;

&lt;p&gt;与以往研究相比：&lt;/p&gt;
&lt;p&gt;1. 只需要合著者信息和 title（必要属性）&lt;/p&gt;
&lt;p&gt;2. 不要求其他额外信息或估计值&lt;/p&gt;
&lt;p&gt;3. 为同名和异名问题提供一个全面的消除歧义的解决方案&lt;/p&gt;

&lt;h2 id=&quot;5474-1541465471891&quot;&gt;3. 整体框架&lt;/h2&gt;
&lt;p&gt;1. 利用文献信息分析作者关系构建图模型&lt;/p&gt;
&lt;p&gt;2. 拆分存在多个合作网络中的顶点解决同名问题&lt;/p&gt;
&lt;p&gt;3. 合并同作者不同名字的节点解决异名问题&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/0DF0C1AC07A84785BBC43926D86FB894/4150&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;445&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/0DF0C1AC07A84785BBC43926D86FB894/4150&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;2112-1541597731260&quot;&gt;3.1. Graph Model Constructor&lt;/h3&gt;
&lt;p&gt;图模型建设&lt;/p&gt;
&lt;p&gt;合著者是解决作者歧义的最有影响力的因素，将合著者信息构建成一个图，合著者为双向关系&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/109C9D8A12EB45F69D30ACFFF574AF1A/4374&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;530&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/109C9D8A12EB45F69D30ACFFF574AF1A/4374&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/D7DB18B5CCA04D36BCC334C184D05643/4373&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;123&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/D7DB18B5CCA04D36BCC334C184D05643/4373&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;5179-1541574131442&quot;&gt;3.2. Namesake Resolver&lt;/h3&gt;
&lt;p&gt;同名的解析器检测并解决同名问题&lt;/p&gt;
&lt;p&gt;假设同一个人同一时期很少在同一个机构工作，社交群体也不同&lt;/p&gt;
&lt;p&gt;GFAD将从同一个顶点发出的每个非重叠循环视为不同社交环，循环检测器查找途中具有多个社交环的顶点，名称分割器拆分与多个社交环相关联的顶点&lt;/p&gt;
&lt;h3&gt;3.2.1. Cycle Detector&lt;/h3&gt;
&lt;p&gt;算法过程：&lt;/p&gt;
&lt;p&gt;1. 如果是别的环的子环，则移除该环&lt;/p&gt;
&lt;p&gt;2. 检测并合并在正在检测的环中共享同一顶点的环&lt;/p&gt;

&lt;p&gt;Splitting vertices&lt;/p&gt;
&lt;p&gt;沿着最长的非重叠环分割包含&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/4DCF14033F3C4D309455AB21C1602396/4379&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;226&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/4DCF14033F3C4D309455AB21C1602396/4379&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;3779-1541597986285&quot;&gt;3.2.2. Namesake Splitter&lt;/h3&gt;
&lt;p&gt;GFAD 是从开始到结束的顶点间没有重复顶点和边的简单环，需要为每个社交圈确定合适的边界。通常，社交圈越宽，将不同的人分到同一个人的可能性越大。&lt;/p&gt;
&lt;p&gt;如果BDC 包含相关领域的引用记录，或根据领域构建图，较大的社交圈就不容易出现以上错误&lt;/p&gt;
&lt;p&gt;GFAD 将最大的环作为该作者的社交圈，假定，同一个顶点出现在多个最大的社交圈时可能包含同名不同人的作者，因此，我们需要检测每个顶点的最大非重叠环，然后根据这些周期进行顶点分割&lt;/p&gt;
&lt;h3 id=&quot;9339-1541597993008&quot;&gt;3.3. Heteronymous Name Resolver&lt;/h3&gt;
&lt;p&gt;异名解析器&lt;/p&gt;
&lt;p&gt;1. 查找具有相似作者名称，并且相同作者检测器识别表示为同一个人的顶点&lt;/p&gt;
&lt;p&gt;2. 异名合并器合并该顶点&lt;/p&gt;

&lt;p&gt;同一个作者使用不同名字&lt;/p&gt;
&lt;p&gt;GFAD 判断具有相似名字的顶点组，如果该组所有成员至少共享一个公共顶点，则将其视为同一个人&lt;/p&gt;
&lt;h3 id=&quot;1126-1541598082698&quot;&gt;3.3.1. similar name searcher&lt;/h3&gt;
&lt;p&gt;1. GFAD 使用最长公共子序列（ LCS ） 方法检测&lt;/p&gt;
&lt;p&gt;2. 使用空格和标点符号作为分隔符标记作者名字，并使用LCS 测量相似度&lt;/p&gt;
&lt;p&gt;3. 如果两者相似度 &amp;gt; 0.8 则视为相似&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/44083B4CBFB045D89A16BEA9763FAAA9/4392&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;56&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/44083B4CBFB045D89A16BEA9763FAAA9/4392&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;3755-1541598074506&quot;&gt;3.3.2. same author detector&lt;/h3&gt;
&lt;p&gt;两个相似名称的顶点直接或间接的连接到图中的公共顶点，则认为两者为同一个人&lt;/p&gt;
&lt;h3 id=&quot;8236-1541598074506&quot;&gt;3.3.3. heteronymous name merger&lt;/h3&gt;
&lt;p&gt;一旦确定具有相似名称的作者是同一个人，则合并&lt;/p&gt;
&lt;h3 id=&quot;5293-1541575526305&quot;&gt;3.4. Outlier Remover&lt;/h3&gt;
&lt;p&gt;孤立点：&lt;/p&gt;
&lt;p&gt;缺少消歧所需要的元信息&lt;/p&gt;
&lt;p&gt;如：在使用合著关系的系统中，只有一个作者的文章就是孤立点&lt;/p&gt;
&lt;p&gt;对于使用作者所属组织的系统中，缺少作者所属信息的文章就是孤立点&lt;/p&gt;
&lt;p&gt;GFAD 将异常值根据代表性的关键字的相似性度量，将相应顶点与图模型中最相似的顶点合并&lt;/p&gt;

&lt;p&gt;相似度量：&lt;/p&gt;
&lt;p&gt;GFAD 将文章中的词汇构成一个特征向量，将其作为关键词，使用余弦相似度，测量异常值和其相似顶点间的相似度&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/96F938C7A8F14CD39CF2AA9A988050DC/4263&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/96F938C7A8F14CD39CF2AA9A988050DC/4263&quot;/&gt;&lt;/div&gt;
&lt;p&gt;过程：&lt;/p&gt;
&lt;p&gt;1. 从 GM 中寻找没有合著信息的顶点&lt;/p&gt;
&lt;p&gt;2. 将其中名字相似的顶点标为孤立点，并且选择出有最高相似度的顶点&lt;/p&gt;
&lt;p&gt;3. 将孤立点从 GM 中移除，与有最高相似度的节点合并&lt;/p&gt;

&lt;h2 id=&quot;9075-1541594760846&quot;&gt;4. Experiment&lt;/h2&gt;
&lt;p&gt;分别对比有或没有异常点移除的步骤的效果&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/9D369240C0894F29AF4CF5BD6C0907D0/4283&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;427&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/9D369240C0894F29AF4CF5BD6C0907D0/4283&quot;/&gt;&lt;/div&gt;

&lt;p&gt;孤立点去除将离群点合并成最相似的群，当将单个记录群误解为离群点时，GFAD 性能降低&lt;/p&gt;
&lt;p&gt;如何合理的去除离群点？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对比使用了哪些属性，信息缺失是否严重&lt;/li&gt;
&lt;li&gt;如何定义相似性阈值&lt;/li&gt;
&lt;/ul&gt;&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/8103BB08CA244BB68B424BC6A2718651/4295&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;596&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/8103BB08CA244BB68B424BC6A2718651/4295&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/B5DCBB4517184E2A86C65A8CC492E447/4302&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;226&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/634e969680080429c39c28a14c6cfd40/xmlnote/B5DCBB4517184E2A86C65A8CC492E447/4302&quot;/&gt;&lt;/div&gt;

&lt;p&gt;GFAD-AD: 仅使用共同作者&lt;/p&gt;
&lt;p&gt;GFAD-OR：孤立点移除&lt;/p&gt;
&lt;p&gt;HHC：使用引用特征的非监督人名消歧&lt;/p&gt;
&lt;p&gt;HHC-ALL： 使用所有特征属性（合著者，title，地点）&lt;/p&gt;
&lt;p&gt;HHC-CO：仅使用合著者特征&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用所有特征属性（合著者，title，地点）&lt;/li&gt;
&lt;li&gt;在 arnet 上比 GFAD 性能好&lt;/li&gt;
&lt;li&gt;需要预先定义标题和地址的相似度阈值&lt;/li&gt;
&lt;li&gt;选择一个唯一的不变的阈值不太现实&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;GFAD-AD&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;仅使用共同作者&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当仅使用共同作者属性时，GFAD-AD 在两集合中都优于 HHC-CO&lt;/p&gt;

&lt;h2 id=&quot;1430-1541596451687&quot;&gt;5. GFAD 局限性&lt;/h2&gt;
&lt;p&gt;不能处理：&lt;/p&gt;
&lt;p&gt;1. 两个同名作者有相同名字但不同人的合作者&lt;/p&gt;
&lt;p&gt;2. 虽然是同一个人但没有共同合作者&lt;/p&gt;
&lt;p&gt;3. 当由单一作者所著时，没有合著者信息&lt;/p&gt;
&lt;p&gt;4. 作者个人资料变更（动态变化）&lt;/p&gt;

</description>
<pubDate>Wed, 07 Nov 2018 14:08:00 +0000</pubDate>
<dc:creator>超然haha</dc:creator>
<og:description>将人名消歧过程作为一个系统，主要想学习它对消歧过程中的各个阶段的划分，GFAD 是一个面向图的框架，对于元信息缺失，错误信息的存在具有较好的鲁棒性，且不依赖web 环境，也不需要群体数量信息，不需要估</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaoran/p/9926102.html</dc:identifier>
</item>
<item>
<title>Shell编程-02-Shell变量 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9926088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9926088.html</guid>
<description>&lt;h3 id=&quot;什么是shell变量&quot;&gt;什么是Shell变量&lt;/h3&gt;
&lt;p&gt;    在初等数学数学方程式中，我们会经常碰到类似于这样的方程式：&lt;strong&gt;y=x+1&lt;/strong&gt; ,等号左右两边的&lt;strong&gt;x&lt;/strong&gt;和&lt;strong&gt;y&lt;/strong&gt;称之为未知数。在编程里面它们他们则代表变量名与变量值。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-51c59529dbee5735.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-1 变量含义_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    通过该示例，我们可以得出一个结论：简单来说，&lt;strong&gt;变量是编程中最基本的存储单位，它会暂时存储用户放进去的数据，而存储的数据位于内存空间中，通过正确调用内存空间中变量名字即可以取出与之对应的数据&lt;/strong&gt;。在Shell中定义变量和取值如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-51ee29bd75b7deae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-2 变量示例.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、定义变量的方法，先定义变量名，紧跟赋值操作符=，最后是变量对应的值，&lt;strong&gt;中间不能存在空格&lt;/strong&gt;，否则会出现报错，这一点是跟其他语言比较大的区别，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-7579e2e48d37966e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-3 变量赋值.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、打印变量值，需要在变量名前加&lt;strong&gt;$&lt;/strong&gt;或&lt;strong&gt;${}&lt;/strong&gt;，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   echo $y
   echo ${y}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、&lt;strong&gt;变量名只能为字母、数字或下划线且只能以字母或下划线开头&lt;/strong&gt;（这一点跟大多数语言一样，至于为什么请问度娘）&lt;/p&gt;
&lt;p&gt;4、变量名需要遵循一定的规范，并且要一见名便知其意。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;常见的命令规范有三种：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;匈牙利命名法&lt;/strong&gt;&lt;br/&gt;该命令方法是在每个变量名前添加表示数据类型的字符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;驼峰命名法&lt;/strong&gt;&lt;br/&gt;混合使用大小写字母来对变量进行命名。而且是首字母小写，后续单词第一个字母大写，如userName&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;帕斯卡命名法&lt;/strong&gt;&lt;br/&gt;与驼峰法很很像，每个单词第一个字母均大写，如UserName&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5、&lt;strong&gt;环境变量需要全部采用大写形式书写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;6、在其他强类开语言中（如Java/C#）对数据类型都有其严格的定义，如整型int、字符char、字符串string、小数float/double/decimal等等。而&lt;strong&gt;在Shell中，默认是不区分变量类型的&lt;/strong&gt;。如果需要显式定义变量类型，则可以使用&lt;strong&gt;declare&lt;/strong&gt;定义。&lt;/p&gt;
&lt;p&gt;7、如果要在crond做定时任务时需要在Shell脚本中使用环境变量需要先在执行脚本中重新定义&lt;/p&gt;
&lt;h3 id=&quot;变量类型&quot;&gt;变量类型&lt;/h3&gt;
&lt;p&gt;    变量可分为两类：&lt;strong&gt;环境变量（全局变量）&lt;/strong&gt;和&lt;strong&gt;普通变量（局部变量）&lt;/strong&gt;，而环境变量又可以分为&lt;strong&gt;bash内置环境变量&lt;/strong&gt;和&lt;strong&gt;用户自定义环境变量&lt;/strong&gt;。详细可参考下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-404498b9057de4c8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-4 变量类型_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;环境变量（全局变量）&lt;/strong&gt;:可以在创建它们的Shell和其任意子Shell进程中使用&lt;br/&gt;&lt;strong&gt;普通变量（局部变量）&lt;/strong&gt;：仅能在创建它们的Shell函数和脚本中使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;内置环境变量&quot;&gt;内置环境变量&lt;/h4&gt;
&lt;p&gt;    环境变量一般是指使用&lt;strong&gt;export&lt;/strong&gt;内置命令导出的变量，用于定义Shell的运行环境、保证Shell命令的正确执行。Shell通过环境变量来确定&lt;strong&gt;登录用户名、命令路径、终端类型、登录目录&lt;/strong&gt;等，所有的环境变量都是系统全局变量，可用于所有子进程中。&lt;br/&gt;    环境变量可以在命令行中设置和创建，但在用户退出命令行时这些变量值就会丢失。如果希望永久保存环境变量，可以在用户目录下的&lt;strong&gt;.bashrc&lt;/strong&gt;或&lt;strong&gt;.bash_profile&lt;/strong&gt;文件中或全局变量配置&lt;strong&gt;/etc/profile&lt;/strong&gt;文件中定义。在将环境变量放入上述文件后，每次用户登录时这些变量都将被初始化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、按照系统规范，所有&lt;strong&gt;环境变量的名字必须采用大写形式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;2、在将环境变量应用于用户进程程序之前，都应该用&lt;strong&gt;export&lt;/strong&gt;命令导出定义。如export JAVA_HOME&lt;/li&gt;
&lt;li&gt;3、有部分环境变量，如HOME、PATH、SHELL、UID、USER等，的用户登录之前就已经被/bin/login程序设置好了。通常环境变量被定义并保存在用户目录下的.bash_profile或/etc/profile中。&lt;/li&gt;
&lt;li&gt;4、在查看设置的变量时，有3个命令可显示变量的值：&lt;strong&gt;set、env、declare&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;set:输出所有的变量，包括全局变量和局部变量
env:只显示全局变量
declare:输出所有的变量、函数、整数和已经导出的变量
set -o:显示bash Shell的所有参数配置信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;env查看系统环境变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-3fa3ceb2d0cc503d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-5 系统环境变量env.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;declare查看所有变量、函数、整数等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-091521554ce4d486.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-6 系统环境变量declare_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;set输出所有变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-9d31ceb1cc735e6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-7 系统环境变量set_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;set -o输出bash参数配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-624dbcdfc86f5cf5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-8 系统环境变量set-o.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;自定义环境变量&quot;&gt;自定义环境变量&lt;/h4&gt;
&lt;h5 id=&quot;设置环境变量&quot;&gt;设置环境变量&lt;/h5&gt;
&lt;p&gt;    如果想要设置环境变量，就要在给变量赋值前之后或在设置变量时使用export命令，除export命令，使用&lt;strong&gt;declare -x&lt;/strong&gt;命令也可以实现同样的功能。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/usr/local/java
或
JAVA_HOME=/usr/local/java;export JAVA_HOME
或
declare -x JAVA_HOME=/usr/local/java&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上为设置自定义环境变量的3种方法，而在此处不要在变量名前添加&lt;strong&gt;$&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;自定义环境变量示例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-32c994156d3b8d70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-9 自定义环境变量_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  接下来我们来看看让环境变量永久生效的常用设置文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、用户的环境变量配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-b36c8d5a1ce4154b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-10 用户环境变量配置_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于用户环境变量的设置，比较常见的是用户目录下的.bashrc和.bash_profile。推荐在~/.bash_profile中进行设置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;2、全局变量配置&lt;br/&gt;常见的全局环境变量的配置文件有&lt;strong&gt;/etc/profile&lt;/strong&gt;、&lt;strong&gt;/etc/bashrc&lt;/strong&gt;、&lt;strong&gt;/etc/profile.d&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;若要登录后初始化或显示加载内容，则把脚本文件放在/etc/profile.d下即可，无须添加执行权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例一：设置登录提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-74a40af0a1a58d5d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-12 登录提示示例_c2i.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上任意一种方法均可，上面是两种方法合并处理进行演示。实际操作只需要在一个文件中操作即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例二：在Linux中设置Java环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/usr/local/java/jdk1.7.0_09
export JRE_HOME=/usr/local/java/jdk1.7.0_09/jre
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;显示环境变量&quot;&gt;显示环境变量&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;通过echo和printf显示环境变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  首先我们来显示一些常见的变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-77945c964bf1c5ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-13 显示常见系统变量.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从上面可以看出显示环境变量可以使用 &lt;strong&gt;echo&lt;/strong&gt; 和 &lt;strong&gt;printf&lt;/strong&gt; 。其中printf是一种比较复杂的格式化打印工具。如果感兴趣可以查看相应的资料。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;通过env、set和declare显示默认的环境变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  可查看前面所讲内容&lt;/p&gt;
&lt;h5 id=&quot;取消环境变量&quot;&gt;取消环境变量&lt;/h5&gt;
&lt;p&gt;    如果定义了环境变量，不想使用，是否可以消除环境变量定义了？在这里我们可以使用 &lt;strong&gt;unset&lt;/strong&gt; 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# echo $USER
root
[root@localhost ~]# unset USER # 清除变量，注意变量前面没有 $
[root@localhost ~]# echo $USER
                               # 输出为空白&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;普通变量&quot;&gt;普通变量&lt;/h5&gt;
&lt;h6 id=&quot;定义本地变量&quot;&gt;定义本地变量&lt;/h6&gt;
&lt;p&gt;    本地变量仅在用户当前Shell中有效，如果在Shell中启动另一个进程或退出，则变量无法进行传递。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量的定义及赋值如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;var=value # 定义变量并进行赋值，此时没有引号&lt;br/&gt;var='value' # 定义变量并进行赋值，此时有单引号&lt;br/&gt;var=&quot;value&quot; # 定义变量并进行赋值，此时有双引号&lt;br/&gt;var=`value` # 定义变量并进行赋值，此时有反引号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上变量赋值的区别如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;无引号&lt;/strong&gt;:一般常用于连续的字符串、数字、路径等进行赋值。但如果变量中含有空格，则会导致赋值不完整，无法输出完整的变量值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单引号&lt;/strong&gt;:所见即所得，即输出时会将单引号中的所有内容&lt;strong&gt;原样输出&lt;/strong&gt;，不做任何转义和解释，因此称之为&lt;strong&gt;强引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双引号&lt;/strong&gt;:输出引号中间的全部内容，如果引号中含有变量、特殊转义字符、命令（需要使用反引号）等会先把变量、转义字符、命令进行解析再输出内容，因此称之为&lt;strong&gt;弱引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反引号&lt;/strong&gt;:常用于引用命令，即反引号中的内容会被当作命令进行解析输出，相当于$()&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以上四种赋值方法，数值内容进行赋值可以不加引号，其他若没有特殊要求的情况，建议进行赋值均采用&lt;strong&gt;双引号&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;定义本地变量输出&quot;&gt;定义本地变量输出&lt;/h6&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;$a&lt;/td&gt;
&lt;td&gt;等效于&lt;/td&gt;
&lt;td&gt;${a}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;`pwd`&lt;/td&gt;
&lt;td&gt;等效于&lt;/td&gt;
&lt;td&gt;$(pwd)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以上两种输出变量值建议采取第二种方法，原因如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如以用户名+rc文件夹，定义变量$usernamerc，如这样写会导致变量为usernamerc，如果写为${username}rc，则可以很明显的看出变量为username&lt;/li&gt;
&lt;li&gt;``，反引号容易与单引号引起混淆&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h6 id=&quot;定义本地变量示例&quot;&gt;定义本地变量示例&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# a=718
[root@localhost Test]# b='718'
[root@localhost Test]# c=&quot;718&quot;
[root@localhost Test]# d=`date +%F`
[root@localhost Test]# echo $a
718
[root@localhost Test]# echo $b
718
[root@localhost Test]# echo $c
718
[root@localhost Test]# echo ${c}
718
[root@localhost Test]# echo $d
2018-11-02
[root@localhost Test]# echo $(date +%F)
2018-11-02
[root@localhost Test]# a=823-$a
[root@localhost Test]# b='823-$a'
[root@localhost Test]# c=&quot;823-$a&quot;
[root@localhost Test]# echo $a
823-718
[root@localhost Test]# echo $b
823-$a
[root@localhost Test]# echo $c
823-823-718
[root@localhost Test]# echo ${c}
823-823-718
[root@localhost Test]# path=`pwd`
[root@localhost Test]# echo $path
/root/Test&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境变量初始化及其对应文件的生效顺序&quot;&gt;环境变量初始化及其对应文件的生效顺序&lt;/h3&gt;
&lt;p&gt;    在登录Linux系统后，会默认启动一个Shell，此时Shell会在各个配置文件中查找并使用对应的环境变量设置。而Shell所使用的环境变量取决于Shell的运行方式，通常分为以下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过系统用户登录后默认运行的Shell&lt;/li&gt;
&lt;li&gt;非登录交互式运行的Shell&lt;/li&gt;
&lt;li&gt;执行脚本运行的非交互式Shell&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    当用户是通过登录Linux系统，此时Shell会作为登录Shell启动，此时加载环境变量的顺序如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/3349421-5913f0fadc4ffd50.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;4-14 环境变量初始化顺序.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细解释如下所示：&lt;br/&gt;1、用户登录系统后会首先加载/etc/profile全局变量文件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;/etc/profile是Linux默认的Shell主环境变量文件，系统上每个用户登录都会加载该文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、当加载完/etc/profile文件后，会执行加载/etc/profile.d目录中的脚本文件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;/etc/profile.d目录中有很多脚本文件，如果需要自定义登录即运行脚本，可以将自己的脚本放置到该目录中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、前面加载完成后，开始加载~/.bash_profile（用户环境文件），而该文件又会分别加载~/.bashrc和/etc/bashrc文件。如果这些文件存在，则执行，如没有，则不执行。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果用户的Shell不是登录启动时（如SSH远程连接），此时这种非登录Shell只会加载$HOME/.bashrc，不会去查找/etc/bashrc，如果需要加载这些配置，则需要将变量设定等写入$HOME/.bashrc或者/etc/bashrc中。而不是$HOME/.bash_profile或者/etc/profile。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 07 Nov 2018 14:06:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>什么是Shell变量     在初等数学数学方程式中，我们会经常碰到类似于这样的方程式： y=x+1 ,等号左右两边的 x 和 y 称之为未知数。在编程里面它们他们则代表变量名与变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9926088.html</dc:identifier>
</item>
</channel>
</rss>