<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>angularjs学习第六天笔记（指令简介学习） - 猴子哥</title>
<link>http://www.cnblogs.com/xiaoXuZhi/p/angularjs_directive_learDay1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoXuZhi/p/angularjs_directive_learDay1.html</guid>
<description>&lt;p&gt;　　您好，由于周末有事情，没哟学习angularjs，几天晚上开始继续学习angularjs,坚持加油每一天。谢谢&lt;/p&gt;
&lt;p&gt;　　接着上周五学习了表单验证以后，今天开始学习angularjs中一个非常重要的模块：指令&lt;/p&gt;
&lt;p&gt;　　今天主要先简单了解学习一下指令的一些基本概念后使用&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;一、指令的简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　指令其实就是angularjs对html的一个扩展，实现自定义html元素&lt;/p&gt;
&lt;p&gt;　　　　angularjs其自身封装了一些常用的系统指令，我们也可以根据需要自定义指令&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;二、自定义指令简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　自定义指令的基本格式&lt;/p&gt;
&lt;p&gt;　　　　　　app.directive(&quot;指令名称&quot;,function(){&lt;/p&gt;
&lt;p&gt;　　　　　　　　restrict: '指令匹配格式',      &lt;/p&gt;
&lt;p&gt;　　　　　　　　replace: true,是否自定义元素替代指令申明&lt;/p&gt;
&lt;p&gt;　　　　　　　　template: '&amp;lt;a href=&quot;http://www.baidu.com&quot;&amp;gt;百度一下马上达&amp;lt;/a&amp;gt;' &lt;/p&gt;
&lt;p&gt;　　　　　　});&lt;/p&gt;
&lt;p&gt;　　　　自定义指令关键词说明：&lt;/p&gt;
&lt;p&gt;　　　　　　指令名称说明:名字一般采用驼峰命名，及首字母小写其余单词大写&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　  在调用时，要将大写字母转换为小写并加上-&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　   举例：myDirectiveTest  调用为：my-directive-test&lt;/p&gt;
&lt;p&gt;　　　　　　restrict有四种枚举值：&lt;/p&gt;
&lt;p&gt;　　　　　　　　E：指令按照元素来匹配&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　使用：&amp;lt;my-directive-test&amp;gt;&amp;lt;/my-directive-test&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　C：按照class来匹配&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　使用：&amp;lt;div class='my-directive-test'&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　A：按照属性来匹配&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　使用：&amp;lt;div my-directive-test&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　M：按照注释来匹配&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&amp;lt;!--directive:my-directive-test--&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　虽然提供了四种匹配方式，但是考虑到浏览器的兼容性问题，尽可能按照属性来匹配：A&lt;/p&gt;
&lt;p&gt;　　　　　　一个简单的练习：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;my-directive-e&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;my-directive-e&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;my-directive-a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;my-directive-c&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;Scripts/angular.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, []);
    app.directive(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDirectiveE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            restrict: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            replace: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;a href='http://www.baidu.com'&amp;gt;百度一下马上达&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
    app.directive(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDirectiveA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            restrict: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            replace: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;a href='http://www.baidu.com'&amp;gt;百度一下马上达&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
    app.directive(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDirectiveC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            restrict: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            replace: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;a href='http://www.baidu.com'&amp;gt;百度一下马上达&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;三、指令中的数据传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　指令中数据传递采用的方式也是数据绑定方式{{}}&lt;/p&gt;
&lt;p&gt;　　其实数据传递原理是：实现指令中的绑定是和html中属性想匹配&lt;/p&gt;
&lt;p&gt;　　其实现步骤：&lt;/p&gt;
&lt;p&gt;　　　　1、首先需要给指令创建一个隔离作用域&lt;/p&gt;
&lt;p&gt;　　　　2、定义与html中属性值匹配方式，有如下匹配方式：&lt;/p&gt;
&lt;p&gt;　　　　　　指令中的属性名称:&quot;@html中的属性名称&quot;&lt;/p&gt;
&lt;p&gt;　　　　　　指令中的属性名称:&quot;@&quot;  如果只有@那么html中的属性名称必定有指令中的属性名称完全一致&lt;/p&gt;
&lt;p&gt;　　　　　　指令中的属性名称:&quot;=html中的属性名称&quot; ，实现html和指令中的数据双向绑定&lt;/p&gt;

&lt;p&gt;　　@匹配方式简单练习&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;ng-app&lt;/span&gt;&lt;span&gt;=&quot;myApp&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;my-directive-a my-valuess&lt;/span&gt;&lt;span&gt;=&quot;点击我吧&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;http//:www.baidu.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;Scripts/angular.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; app &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; angular.module(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myApp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, []);
    app.directive(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDirectiveA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            restrict: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            replace: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            scope:{
                myValuess: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                myLink:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            },
            template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;a href='{{myLink}}'&amp;gt;{{myValuess}}&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过=实现双向数据绑定练习：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;zh-CN&quot;&lt;/span&gt;&lt;span&gt; ng-app&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;Scripts/angular.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;硬编码的input&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; ng-model&lt;/span&gt;&lt;span&gt;=&quot;Url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;my-directive some-attrs&lt;/span&gt;&lt;span&gt;=&quot;Url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../angular.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        angular.module(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [])
        .directive(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;myDirective&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
                restrict: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                replace: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                scope: {
                    myUrl: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=someAttrs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等号用做 双向绑定 这里不做详细介绍&lt;/span&gt;
&lt;span&gt;                },
                template: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
                            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;label&amp;gt;指令中的input&amp;lt;/label&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
                            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;input type=&quot;text&quot; ng-model=&quot;myUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
                            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;a href=&quot;{{ myUrl }}&quot;&amp;gt;点我试试&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;
                          &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

            }
        })
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;今天就到此为止，明天继续研究表单验证，明天学习：&lt;span&gt;angularjs内置指令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 15:37:00 +0000</pubDate>
<dc:creator>猴子哥</dc:creator>
<og:description>简单学习了解angularjs中的指令，理解其基本概念、使用规则、简单的自定义指令</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoXuZhi/p/angularjs_directive_learDay1.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——Linux版本的SQL Server - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9544947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9544947.html</guid>
<description>&lt;p&gt;SQL Server 2017版本已经可以在Linux系统上安装，但我在尝试.NET Core跨平台开发的时候使用的是Mac系统，所以这里记录了在Mac上安装SQL Server的过程。&lt;/p&gt;
&lt;p&gt;最新的SQL Server没有专门为Mac系统准备安装包，但由于Mac系统上支持Docker，所以可以用一种变通的方式——在Docker内部安装Linux版本的SQL Server。&lt;/p&gt;

&lt;p&gt;因为我的Macbook Air型号比较老，硬件条件很一般，所以首先确定下是否满足安装SQL Server的条件。官方给出的&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-setup?view=sql-server-2017#system&quot;&gt;配置&lt;/a&gt;如下：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;内存&lt;/td&gt;
&lt;td&gt;2 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;文件系统&lt;/td&gt;
&lt;td&gt;XFS or EXT4 (other file systems, such as BTRFS, are unsupported)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;磁盘空间&lt;/td&gt;
&lt;td&gt;6 GB&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;处理器速度&lt;/td&gt;
&lt;td&gt;2 GHz&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;处理器核数&lt;/td&gt;
&lt;td&gt;2 cores&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;处理器类型&lt;/td&gt;
&lt;td&gt;x64-compatible only&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;要求不高，看来没有什么问题。&lt;/p&gt;

&lt;p&gt;Mac版本的Docker可以通过下列地址下载：&lt;br/&gt;&lt;a href=&quot;https://store.docker.com/editions/community/docker-ce-desktop-mac&quot;&gt;Docker Community Edition for Mac&lt;/a&gt;&lt;br/&gt;完成安装后还可以用&lt;code&gt;docker -v&lt;/code&gt;命令验证结果。&lt;/p&gt;

&lt;p&gt;有了Docker程序后，第一步先要做的事情是拉取SQL Server用于linux系统的镜像。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker pull microsoft/mssql-server-linux:2017-latest&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;接着通过已拉取的镜像启动容器&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;docker run -d --name macsqlserver -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=Passw1rd' -e 'MSSQL_PID=Developer' -p 1433:1433 microsoft/mssql-server-linux:2017-latest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此命令中所用的参数都有实际用途：&lt;br/&gt;-d 以daemon模式运行容器，即所启动的应用程序在后台运行&lt;br/&gt;--name 为容器赋予名称&lt;br/&gt;-e 'ACCEPT_EULA=Y' 在容器内部设定环境变量，用于确认接受终端用户许可协议—— end-user license agreement (EULA)&lt;br/&gt;-e 'SA_PASSWORD=Passw1rd' 在容器内部设定sa账号的密码&lt;br/&gt;-e 'MSSQL_PID=Developer' 也是一个环境变量，令SQL Server以开发者版本运行&lt;br/&gt;-p 1433:1433 映射本地1433端口到容器内部SQL Server的1433端口&lt;/p&gt;
&lt;p&gt;执行上述命令后，再执行&lt;code&gt;docker ps -a&lt;/code&gt;，可以查看已启动容器的状态。如果状态是Up的话，说明容器正常运行。&lt;/p&gt;

&lt;p&gt;由于SQL Server Management Studio没有被移植到其它系统上，所以要想在Mac系统以客户端的方式连接已安装的SQL Server，需要通过第三方工具。sql-cli便是其中一种用nodejs开发的客户端。&lt;/p&gt;
&lt;p&gt;先是用npm方式安装sql-cli。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;npm install -g sql-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成安装后用以下命令进入(所输入的密码需匹配实际设定的)：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mssql -u sa -p Passw1rd&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若连接成功，再输入&lt;code&gt;.databases&lt;/code&gt;命令，就可以看到熟悉的SQL Server自带的四个数据库。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180827214941150-463633692.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用VSC开发的一大好处是其包含丰富的插件。比如安装完mssql这个插件后，便可以利用VSC的便利，进行SQL程序的开发。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180827225728495-58424100.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;br/&gt;⌘+N，新建一个文件&lt;br/&gt;⌘+K,M，将语言模式改为SQL&lt;br/&gt;⌘+⇧+P，打开命令框，输入sql，选中&lt;code&gt;MS SQL: Connect&lt;/code&gt;，再选择&lt;code&gt;Create Connection Profile&lt;/code&gt;，然后输入一系列数据库连接配置。&lt;br/&gt;如果最后在VSC的右下角看到的是类似下面的样子，说明已经成功连接数据库。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180827230804979-512282775.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，在文件内输入SQL语句&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;use master

select * from spt_monitor&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;⌘+⇧+E，执行上述语句。可以在新的窗口中看到结果。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180827231227138-1942824614.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;值得一提的是，在结果窗口内，还可以通过文件形式保存记录。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180827231401621-1684581341.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 15:25:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>SQL Server 2017版本已经可以在Linux系统上安装，但我在尝试.NET Core跨平台开发的时候使用的是Mac系统，所以这里记录了在Mac上安装SQL Server的过程。 最新的SQL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9544947.html</dc:identifier>
</item>
<item>
<title>解决 winform打开网页 和WebBrowser打开链接360误报拦截的问题 - 云测试</title>
<link>http://www.cnblogs.com/wohexiaocai/p/9545487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wohexiaocai/p/9545487.html</guid>
<description>&lt;p&gt;以下方法我已经在自己电脑上验证通过，其他电脑并未测试，请广大读者自行验证并反馈，如果有更好的方法请指教。&lt;/p&gt;
&lt;p&gt;在winform中如果使用这种方法弹出网页，例如这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Process.start(&quot;http://www.xgjxc.top&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者另外如果winform中嵌入了一个webbrowser控件，加载了一个网页，例如这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
this.webBrowser1.Navigate(&quot;http://www.xgjxc.top/home.html“);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;网页中有个超链接，例如这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;a href=&quot;http://www.xgjxc.top/post/15.html&quot; target=&quot;_blank&quot;&amp;gt;小狗进销存功能模块介绍 (2015-05-10)&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么点击这个超链接会自动打开一个浏览器窗口&lt;/p&gt;

&lt;p&gt;如果按照上面的方法来打开网页，十有八九会出现以下的画面：　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.mamicode.com/info/201605/20180110192816858682.jpg&quot; alt=&quot;技术分享&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不得不说，360越来越流氓了，他完全不看软件有无恶意特征码，也完全不看要打开的网页有无恶意内容，只要你要打开一个网页，则拦截之。&lt;/p&gt;
&lt;p&gt;另外一个就是我把程序用VS自带打包打包了一下，碰到没有安装.Net的客户机，则自动从官方位置下载安装包进行安装，这个时候360照样拦截不误，如下图：&lt;/p&gt;
&lt;p&gt;一共拦截两次，.Net包拦截一下，简体中文语言包拦截一次，打包的时候都是选的”从官方未知下载组件“，不得不说，360就是一个大傻逼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.mamicode.com/info/201605/20180110192816861612.jpg&quot; alt=&quot;技术分享&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面进入正题，说下怎么解决打开网页这件事。&lt;/p&gt;
&lt;p&gt;winform中点击按钮直接打开网页，采用下面方案：&lt;/p&gt;
&lt;p&gt;核心代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public partial class Home : Form
    {
        [DllImport(&quot;shell32.dll&quot;)]
        public extern static IntPtr ShellExecute(int hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);
        public enum ShowWindowCommands : int
        {
            SW_HIDE = 0,
            SW_SHOWNORMAL = 1,
            SW_NORMAL = 1,
            SW_SHOWMINIMIZED = 2,
            SW_SHOWMAXIMIZED = 3,
            SW_MAXIMIZE = 3,
            SW_SHOWNOACTIVATE = 4,
            SW_SHOW = 5,
            SW_MINIMIZE = 6,
            SW_SHOWMINNOACTIVE = 7,
            SW_SHOWNA = 8,
            SW_RESTORE = 9,
            SW_SHOWDEFAULT = 10,
            SW_MAX = 10
        }
        public Home()
        {
            InitializeComponent();
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后点击事件中的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            ShellExecute(0, @&quot;open&quot;, @&quot;http://www.xgjxc.top&quot;, null, null, (int)ShowWindowCommands.SW_NORMAL);
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话360就不在会拦截了。&lt;/p&gt;
&lt;p&gt;同理，如果是点击webbrowser中的连接，思路是这样的，首先拦截这个点击动作，不让他弹出网页，而采用上面的方法进行弹出，则就会跳过拦截了。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;加载网页&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
private void Home_Load(object sender, EventArgs e)
        {
            this.webBrowser1.Navigate(&quot;http://www.xgjxc.top/home.html&quot;);
        }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注册NewWindow事件：　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
private void webBrowser1_NewWindow(object sender, CancelEventArgs e)
{
ShellExecute(0, @&quot;open&quot;, this.webBrowser1.StatusText.ToString(), null, null, (int)ShowWindowCommands.SW_NORMAL);
e.Cancel = true;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先e.Cancel=true 让点击动作失效，然后this.webBrowser1.StatusText.ToString()获取到刚才点击的连接，StatusText是状态栏文字，我们知道浏览器如果鼠标移动到连接上，状态栏是会显示连接URL的。&lt;/p&gt;

&lt;p&gt;希望可以帮到同样受到360困扰的朋友。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 15:23:00 +0000</pubDate>
<dc:creator>云测试</dc:creator>
<og:description>以下方法我已经在自己电脑上验证通过，其他电脑并未测试，请广大读者自行验证并反馈，如果有更好的方法请指教。 在winform中如果使用这种方法弹出网页，例如这样 或者另外如果winform中嵌入了一个w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wohexiaocai/p/9545487.html</dc:identifier>
</item>
<item>
<title>西安活动 | 9月15号 &quot;拥抱开源, 又见.NET&quot; 线下交流活动 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9545431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9545431.html</guid>
<description>&lt;p&gt;随着&lt;strong&gt;.NET Core&lt;/strong&gt;的发布和开源，.NET又重新回到了人们的视野。除了开源、跨平台、高性能以及优秀的语言特性，越来越多的第三方开源库也出现在了github上——包括ML.NET机器学习、Xamarin移动开发平台、基于Actor模型的分布式框架Orleans以及分布式开发及部署平台Service Fabric等等。&lt;/p&gt;
&lt;p&gt;西安.NET社区组织发起了此次“&lt;strong&gt;拥抱开源, 又见.NET&lt;/strong&gt;”线下交流活动，邀请了三位资深.NET开发者作为分享讲师，他们将从架构、原理、语言出发，与大家一起分享交流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;.NET在大数据及人工智能项目的设计及架构&lt;/li&gt;
&lt;li&gt;ASP.NET Core应用程序的工程实践&lt;/li&gt;
&lt;li&gt;.NET家族的函数式语言从C#到F#&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;免费技术交流，感兴趣的同学抓紧时间报名吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【  时 间 地 点  】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2018年09月15日（周六）1:00PM—5:30PM&lt;/p&gt;
&lt;p&gt;西安市高新区天谷八路环普产业园E座5楼 ThoughtWorks办公室（请从E6进入）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【  活 动 安 排  】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;12:50 PM  签到&lt;/p&gt;
&lt;p&gt;01:20 PM  开场介绍&lt;/p&gt;
&lt;p&gt;01:30 PM  话题一《.NET在大数据和人工智能项目中的应用实践》&lt;/p&gt;
&lt;p&gt;02:40 PM  话题二《ASP.NET Core生命周期指北》&lt;/p&gt;
&lt;p&gt;03:50 PM  话题三《从C#到F#》&lt;/p&gt;
&lt;p&gt;05:10 PM  反馈抽奖&amp;amp;合影留念&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【  精 彩 预 告  】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题一《.NET在大数据和人工智能项目中的应用实践》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题简介：&lt;/strong&gt;应用产生数据，数据蕴含智慧，如何应用人工智能从大数据挖掘出有价值的知识信息并提供智能化的应用是一个比较有挑战力的话题，在大数据和人工智能领域，dotNET应用并不广泛，基于项目实践经验为大家分享.NET在大数据和人智能领域之中诸如数据采集、自然语言处理、机器学习、结果展示和整体架构设计方面的应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分享人：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pub-files.jinshuju.net/di/20180827105036_60ba41&quot; alt=&quot;&quot; width=&quot;90&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;魏 琼 东&lt;/p&gt;
&lt;p&gt;易特科首席架构师&lt;/p&gt;
&lt;p&gt;从事软件研发工作17年，2004年开始使用C#，结合多年的研发管理经验，开发了AgileEAS.NET SOA 中间件平台并在医疗卫生、铁路、物流、制造等行业广泛应用，擅长企业软件过程改进、系统分析与架构设计，目前主要致力于大数据和人工智能与医疗健康领域的结合。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;话题二《ASP.NET Core生命周期指北》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题简介：&lt;/strong&gt;通过对ASP.NET Core应用程序生命周期的剖析，让.NET Core开发人员能够能够更直观的掌握应用程序结构和设计思想，轻松的进行故障排除和调试。首先，通过对启动的分解，帮助理解Dependency Injection和Middleware的行为本质，接下来通过对HTTP请求和服务器响应的重演，来熟悉框架中的各个组件，以及它们之间是如何协同和交互的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分享人：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pub-files.jinshuju.net/di/20180827105045_4ece9d&quot; alt=&quot;&quot; width=&quot;90&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;张 文 清&lt;/p&gt;
&lt;p&gt;ThoughtWorks 高级.NET开发&lt;/p&gt;
&lt;p&gt;热爱钻研技术本质，挑战新事物和推动潮流技术发展。曾供职于西安葡萄城信息技术有限公司，积累超过10年.NET控件和工具的设计以及开发经验，主导和实施多个云应用架构开发和DevOps实践。&lt;/p&gt;
&lt;p&gt;提示：如果希望现场做代码尝试的话，需要准备以下环境： .NET Core 2.1.400 2. IDE，推荐Visual Studio或者Jetbrains Rider。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;话题三《从C#到F#》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;话题简介：&lt;/strong&gt;如果你已经精通了C#或者其他面向对象的语言，你也许会寻找另一个值得学习的语言。得益于F#强大的类型推导系统，你可以写出跟Python一样简洁而带有类型安全的代码；F#作为一门函数式语言，你可以很轻松的通过部分应用以及函数组合来创建新的函数，通过分享函数式编程模式以及monadic风格的实例让你了解函数式编程的基本思想；另外F#还内置了异步编程、消息队列，type provider等高生产力的组件及特性，跟.NET技术栈的无缝集成意味着你还可以使用所有.NET技术栈的类库和工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分享人：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pub-files.jinshuju.net/di/20180827105128_14cd4a&quot; alt=&quot;&quot; width=&quot;90&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;张 阳&lt;/p&gt;
&lt;p&gt;ThoughtWorks 高级.NET开发&lt;/p&gt;
&lt;p&gt;有着多年基于MessageBus以及Event Sourcing的CQRS企业级开发经验，对基于消息传递的微服务架构有着深刻的理解和实践，同时也是DDD的爱好者和布道师，博客园推荐作者以及.NET西安社区发起者。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;【  活 动 福 利  】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参与者除了能够与众多NET开发师现场交流外，还将有机会获得由ThoughtWorks提供的精美礼品，如: 水杯、笔记本等实用小礼物。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;【  报 名 须 知  】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、本次活动为免费技术交流，对.NET开发感兴趣的小伙伴均可报名。&lt;/p&gt;
&lt;p&gt;2、为了保证活动的质量，使话题能够深入展开，我们将限定参会人数，请您务必提前报名。&lt;/p&gt;
&lt;p&gt;3、报名的小伙伴们如果提供的邮件地址和手机号码无误，我们会在9月12日（活动开始前3天）对通过报名筛选的小伙伴发送&lt;strong&gt;短信&lt;/strong&gt;和&lt;strong&gt;邮件&lt;/strong&gt;确认。请确认自己填写的电话、邮件地址无误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
【  .NET西安社区介绍  】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.Net 西安社区正在使用.NET Core / Azure / Xamarin等技术开发基于互联网和移动应用平台上的各种新产品和商业服务。我们的目标是通过举办各种分享活动，交流开发心得和经验来推动.NET技术栈在西安乃至西北地区的发展。我们是一个开放和自由的社区，欢迎您加入.NET西安社区！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pub-files.jinshuju.net/di/20180827163659_cd9038&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 15:22:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>随着.NET Core的发布和开源，.NET又重新回到了人们的视野。除了开源、跨平台、高性能以及优秀的语言特性，越来越多的第三方开源库也出现在了github上——包括ML.NET机器学习、Xamari</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9545431.html</dc:identifier>
</item>
<item>
<title>一步一步的django学习---001 - 顾河建</title>
<link>http://www.cnblogs.com/cittysteven/p/9545240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cittysteven/p/9545240.html</guid>
<description>&lt;p&gt;今天刚开始接触django，说实话，对于我这个连python都不愿意去学的懒人，能主动去学习django，这真的是太阳打西边出来了。但是，什么事情都是有原因的，要不是形式所逼，打死我也不会学习django这种反人类的东西的（我的一个朋友说的）。说实话，我还是喜欢java，打死我也喜欢java.既然开始了django的学习，那就像点样子好了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们不得不先了解下什么是django?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在百度上是这么解释的：Django是一个开放源代码的web应用框架，由Python写成。采用了MVC框架模式。模型，视图，控制器。它最初是用来开发来用于管理劳伦斯集团旗下的新闻网站的，即是内容管理系统软件。并于2005年7月在BSD许可证下发布。这套框架是以比利时的吉普赛爵士吉他手Django Reinhardt来命名的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核心组件&lt;/span&gt;有：&lt;/p&gt;
&lt;p&gt;1.用于创建模型的对象关系映射（老实说，我什么也不懂，但是模型，是一个比较关键的东西）&lt;/p&gt;
&lt;p&gt;2.为最终用户设计的完美管理页面（大概能够轻松的编写html页面）&lt;/p&gt;
&lt;p&gt;3一流的URL设计（无非是URL可以控制自如，虽然想起来，javaee里面的web文件确实有一些些复杂）&lt;/p&gt;
&lt;p&gt;4.设计友好的模板语言（模板语言，在我开始接触的时候大概了解的一点点）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;架构设计&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以django更关注的是模型，模板，视图。可以被称为MTV模式。各自职责如下：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;center&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;                           层次                                  &lt;/span&gt;    &lt;/td&gt;
&lt;td&gt;职责&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;模型层（M），即是数据存取层&lt;/td&gt;
&lt;td&gt;                         处理数据有关的事务：存取数据，验证有效性，包含哪些行为（增删改查）以及数据间的关系等                                  &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;模板（T），业务逻辑层&lt;/td&gt;
&lt;td&gt;处理与表现相关的决定；如何在页面或其他类型文档中显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;视图（v）,表现层&lt;/td&gt;
&lt;td&gt;存取模型及调取恰当的逻辑关系。模型和模板的桥梁。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;工作机制&lt;/span&gt;：（在Django文件编写完成之后，页面的执行机制）&lt;/p&gt;
&lt;p&gt;1.用cmd 中python  manage.py runserver启动Django服务器时就载入了在统一目录下的settings.py。该文件包含了项目中的配置信息，如URL等，其中最重要的是ROOT_URLCONF，它告诉Django哪个Python模块应该启用URLConf,默认是urls.py.&lt;/p&gt;
&lt;p&gt;2.当访问url的时候，Django会根据ROOT_URLCONF设置来装载URLConf.&lt;/p&gt;
&lt;p&gt;3.然后按顺序逐个匹配URLConf里的URLpatterns.如果找到，则会调用相关联的视图函数，并把HttpRequest对象作为第一个参数（通常是request）。&lt;/p&gt;
&lt;p&gt;4.最后改view函数负责返回一个HttpResponse对象。&lt;/p&gt;
&lt;p&gt;好了，django的初步样子，我们有了一点点的认识，不管他是何方神圣，也不管他是牛鬼蛇神，只有&lt;span&gt;开始&lt;/span&gt;了，我们才能真正克服它，最后再强调一次，虽然它是一个反人类的东西，但是功能还是很强大的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;001.1：安装django&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在安装好python,并且配置好环境之后，在cmd下输入：pip install django即可安装成功。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;001.2：新建django工程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在安装好django之后，在cmd上，指定一个文件夹，输入：django-admin startproject XXX(为项目文件名）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;001.3：编辑项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单的项目：&lt;/p&gt;
&lt;p&gt;  1.在创建的项目文件夹下，有一个和项目同名的文件夹，点开，新建我们的核心部件view.py&lt;/p&gt;
&lt;p&gt;  内容：from django.http import HttpResponse&lt;/p&gt;
&lt;p&gt;            def hello(request):&lt;/p&gt;
&lt;p&gt;                  return HttpResponse(&quot;helloWorld&quot;)&lt;/p&gt;
&lt;p&gt; 2.修改urls.py的内容，删除原来全部内容，添加一下内容&lt;/p&gt;
&lt;p&gt;from django.conf.urls import url&lt;/p&gt;
&lt;p&gt;from . import view&lt;/p&gt;
&lt;p&gt;urlpatterns=[url('/',view.hello)]&lt;/p&gt;
&lt;p&gt;&lt;span&gt;001.4:运行简单的项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开cmd 进入项目文件中manage.py所在目录，输入python manage.py runserver；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;001.5查看结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器，输入http://127.0.0.1:8000&lt;/p&gt;
&lt;p&gt;结果是：helloWorld。&lt;/p&gt;
&lt;p&gt;这个简单的例子，我们再回顾上面的工作机制，就会豁然开朗了。也就是说，urls.py感觉有点相当于程序的主函数，是入口，又控制流程。具体还不知道，后面继续学习深入了会更了解的。&lt;/p&gt;
&lt;p&gt;知识点1：在urlpattern=后的url()函数；&lt;/p&gt;
&lt;p&gt;url（regex,view[,kwargs],[name]）函数：可以接收四个参数：&lt;/p&gt;
&lt;p&gt;regex:与之匹配的url会执行后面的view函数&lt;/p&gt;
&lt;p&gt;view:执行请求&lt;/p&gt;
&lt;p&gt;kwargs:使用字典类型的参数&lt;/p&gt;
&lt;p&gt;name:用来反向获取当前url。&lt;/p&gt;

</description>
<pubDate>Mon, 27 Aug 2018 15:21:00 +0000</pubDate>
<dc:creator>顾河建</dc:creator>
<og:description>今天刚开始接触django，说实话，对于我这个连python都不愿意去学的懒人，能主动去学习django，这真的是太阳打西边出来了。但是，什么事情都是有原因的，要不是形式所逼，打死我也不会学习djan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cittysteven/p/9545240.html</dc:identifier>
</item>
<item>
<title>大前端的自动化工厂（3）—— babel - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9537311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9537311.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/24/8805e706ade18ac52ac0d1df44d773a6.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/d5f117d6318be27703b7e03ae894f359.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-关于babel&quot;&gt;一. 关于babel&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;babel&lt;/code&gt;是ES6+语法的编译器，官方网址:&lt;a href=&quot;http://www.cnblogs.com/dashnowords/p/www.babeljs.io&quot; class=&quot;uri&quot;&gt;www.babeljs.io&lt;/a&gt;，用于将旧版本浏览器无法识别的语法和特性转换成为ES5语法，使代码能够适用更多环境。&lt;/p&gt;
&lt;p&gt;最初的&lt;code&gt;babel&lt;/code&gt;使用起来是非常方便的，几乎仅使用少量的配置就可以使用，但随着工具的快速升级和代码架构的转变，&lt;code&gt;babel&lt;/code&gt;已经裂变成非常多的部分，每个部分各司其职，这样做的好处是可以缩小生产环境的正式包的代码体积（因为可以按需引用）而加重了开发环境（开发阶段需要引入更多碎片化的插件），但劣势就是将其使用门槛提得非常高，对软件架构不熟悉的开发者难以使用。&lt;/p&gt;
&lt;p&gt;比如&lt;code&gt;babel&lt;/code&gt;官方网站在&lt;code&gt;webpack&lt;/code&gt;配置的章节，提及了&lt;code&gt;babe-loader&lt;/code&gt;,&lt;code&gt;babel-core&lt;/code&gt;和&lt;code&gt;babel-preset-env&lt;/code&gt;三个插件，而当开发者在&lt;code&gt;webpack&lt;/code&gt;中实际进行配置时除了上述三个基本插件外，又会遇到&lt;code&gt;babel-polyfill&lt;/code&gt;,&lt;code&gt;babel-runtime&lt;/code&gt;,&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;等等一系列插件，或许通过查看插件说明能够理解插件的功能，但开发者却很难判断自己是否该使用这个功能或者什么时候使用。&lt;/p&gt;
&lt;h2 id=&quot;二.-基本需求推演&quot;&gt;二. 基本需求推演&lt;/h2&gt;
&lt;p&gt;我们从工具设计的角度，通过问题推演的方式来看看&lt;code&gt;babel&lt;/code&gt;的变化。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ES6&lt;/code&gt;标准推出时，浏览器还不能很好地支持，但&lt;code&gt;ES6&lt;/code&gt;的许多特性和语法又很诱人，所以大家想了个办法，那就是用&lt;code&gt;ES6&lt;/code&gt;编写代码，然后出包的时候拿个工具转换一下，变成能被更多浏览器识别的&lt;code&gt;ES5&lt;/code&gt;语法不就行了么，于是，&lt;code&gt;Babel&lt;/code&gt;基本模型就出现了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/064c594e3d53b617e1774c58a7539b7b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;babel&lt;/code&gt;的功能被定义为编译工具，那么理论上来说它就可以使用编译器的通用代码框架，通过&lt;strong&gt;ASTparser --&amp;gt; traverse --&amp;gt; stringify&lt;/strong&gt; 的步骤实现编译功能，在关键的traverse环节，是需要一个规则集合的，可是转码所参考的&lt;code&gt;ES6&lt;/code&gt;的标准并不是一个定案的标准，其中每一个特性都需要经过从&lt;em&gt;stage0&lt;/em&gt;到&lt;em&gt;stage4&lt;/em&gt;这样5个阶段才能正式定稿，只有&lt;em&gt;stage-2&lt;/em&gt;草案(draft)阶段以上的特性才会在未来被支持，而处于这个阶段以下的标准是有可能被废的，如果一味地全部转换，不仅会降低工具效率，也会为代码未来的维护造成隐患。&lt;/p&gt;
&lt;p&gt;那如果我们有一个工厂函数，接受数字0-4作为参数，然后返回所有经历了&lt;em&gt;stage-x&lt;/em&gt;的规则集（是&lt;code&gt;ES6&lt;/code&gt;规则的子集）作为规则集合，那么就可以在最终生成生产环境的代码时减小代码体积，假如在项目中通过&lt;code&gt;babel_get_es6_by_stage(2)&lt;/code&gt;这样一个函数返回了规则集，那么正式代码中就不需要&lt;em&gt;stage-0&lt;/em&gt;和&lt;em&gt;stage-1&lt;/em&gt;的实现代码了。基于以上的考虑，我们对&lt;code&gt;Babel&lt;/code&gt;工具进行第一次功能剥离：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/5301f1640e20298d2083f0ba4f34ed19.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推演继续，在对规则集进行了一次体积缩减后，我们得到了一个相对精简的规则集，它包含了诸多新的语法和方法，如果直接使用那的确很爽，毕竟引入了一个工具后就可以毫无后顾之忧地使用新特性，但对于生产环境的代码包来说，这种做法造成的代码冗余确是非常难以接受的。&lt;/p&gt;
&lt;p&gt;用大家都熟悉的&lt;code&gt;bootstrap&lt;/code&gt;为例，&lt;code&gt;bootstrap.min.css&lt;/code&gt;的体积大约为&lt;code&gt;120k&lt;/code&gt;，可你会发现很多人引入它完全是出于心里惯性，而在最后仅仅使用了非常基础的&lt;code&gt;btn&lt;/code&gt;相关的样式类，或者仅仅为了使用&lt;code&gt;col-md-4&lt;/code&gt;这种响应式布局的样式，所有使用到的样式可能只占了&lt;em&gt;20k-30k&lt;/em&gt;的空间，但是却不得不为项目引进一个120k大的库，当然并不是所有的项目都会在意20k和120k之间的差别的。&lt;/p&gt;
&lt;p&gt;那么我们就需要一个能够按更小粒度组合的方法&lt;code&gt;babel_get_es6_by_rules([rule , ...])&lt;/code&gt;，让使用者可以选择自己所使用到的语法和方法，从而达到缩小引用库体积的目的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/407b40c9c925c75e197255b4b80279fe.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推演继续进行。处理过兼容性问题的开发者都知道，浏览器是存在版本区分的，许多特性在不同浏览器中的实现和表现都不一样，对于&lt;code&gt;ES6&lt;/code&gt;也是这样，较高版本的浏览器对于&lt;code&gt;ES6&lt;/code&gt;中的一些特性是已经逐步实现支持了的，如果我们的目标用户所使用的运行环境对某些&lt;code&gt;ES6&lt;/code&gt;特性已经提供了原生支持，或者目标用户的运行环境根本就是由开发者直接封装好的，那么原先“一锅端”的转码方式里就会存在很多没有必要的部分。&lt;/p&gt;
&lt;p&gt;比如你在规则集中选择了对&lt;code&gt;Class&lt;/code&gt;关键字来定义类这个特性进行转码，那么babel就需要将其转码成为使用&lt;code&gt;function&lt;/code&gt;和&lt;code&gt;prototype&lt;/code&gt;的ES5的实现方式，但如果你的目标用户全都是程序员，几乎全都是使用高版本的chrome作为项目环境，那么上面的转码可能就是画蛇添足了。&lt;/p&gt;
&lt;p&gt;综上所述，我们就需要为babel提供一个判断目标环境是否需要转码的方法&lt;code&gt;babel_get_rule_as_need( rule_set , env_info)&lt;/code&gt;,将经过第一次筛选后的规则集和目标用户的环境信息传入方法，对规则集进行再一次的精简，那么我们需要再次对babel进行优化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/4ef31cb48f7684f73f49a747a8fa916f.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，&lt;code&gt;babel&lt;/code&gt;便具备了针对不同的使用环境进行必要转码的能力，可这并不是问题的全部，&lt;code&gt;ES6&lt;/code&gt;的新特性除了语法的更新外，还增加了很多原生方法或类型，例如&lt;code&gt;Map&lt;/code&gt;,&lt;code&gt;Set&lt;/code&gt;,&lt;code&gt;Promise&lt;/code&gt;等这类新的全局对象，或是&lt;code&gt;Array.from&lt;/code&gt;这类静态方法等等，语法转义并不能完成对这些特性的识别，因为无论在ES5环境还是ES6环境你都是这么写的，只有运行的时候，浏览器才会报错，告诉你某个对象或者某个方法不存在。&lt;/p&gt;
&lt;p&gt;比如下面的代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function addAll() {
  return Array.from(arguments).reduce((a, b) =&amp;gt; a + b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转义后会变为:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function addAll() {
  return Array.from(arguments).reduce(function(a, b) {
    return a + b;
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，它依然无法随处可用因为不是所有的 JavaScript 环境都支持 &lt;code&gt;Array.from&lt;/code&gt;。对于这一类非语法层面的特性，我们希望在工具中能够自动提供支持，这项工作有一个专有的称谓，叫做&lt;strong&gt;【polyfill】&lt;/strong&gt;（或称为垫片）。&lt;/p&gt;
&lt;p&gt;我们既可以主动提供一个&lt;em&gt;polyfill列表&lt;/em&gt;指明需要添加的垫片插件数组，也可以采用被动的方式，在转码过程中遇到的这种&lt;code&gt;API&lt;/code&gt;类型的新特性放进一个数组，通过&lt;code&gt;babel_add_polyfill ( polyfill_list )&lt;/code&gt;为根据安装相应的垫片，需要注意的是，polyfill相当于为浏览器进行功能扩展，需要优先于项目业务逻辑代码运行，那么babel的逻辑框架就变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/89fb116b29a8d00943d35c969cc0da86.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;推演继续。在上面的逻辑结构中，我们只是简单地将polyfill库添加至全局变量，而全局变量是很有可能被重写而失效或是与其他第三方库发生代码冲突的。那么如果不将polyfill添加至全局，就需要将其剥离为一个具有同等功能的独立模块，通过类似于&lt;code&gt;lodash&lt;/code&gt;或是&lt;code&gt;underscore&lt;/code&gt;那样的方式调用，我们对逻辑结构进行再一次拆分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/e08efd772da5c3831e8daf2e471e3c39.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经完成了babel工具集基本功能的*&lt;strong&gt;逻辑层划分&lt;/strong&gt;*，通过传说中的&lt;strong&gt;多退少补&lt;/strong&gt;（也就是语法超前了就回退，方法不够了就打补丁）的方式来实现代码编译。&lt;/p&gt;
&lt;h2 id=&quot;三.-模块划分&quot;&gt;三. 模块划分&lt;/h2&gt;
&lt;p&gt;根据上述业务逻辑层的划分结果，我们需要对Babel工具进行代码层的模块划分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/bcee074e31466de6828a0602d1f18776.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;img src=&quot;http://www.cnblogs.com/dashnowords/p/pic7.png&quot; alt=&quot;babel-module&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四.-真正的babel&quot;&gt;四. 真正的babel&lt;/h2&gt;
&lt;p&gt;如果你能够理解上述的需求推演和模块划分的章节，那么恭喜你已经掌握了babel的基本结构，我们将原本模块图中的信息更换成实际的名称或是插件，并进行一些组件划分，就可以看到真正的&lt;code&gt;babel&lt;/code&gt;工具集的基本架构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201808/23/8d5ec7ccf8dcf9f53536eb92fed9b5be.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然真正的&lt;code&gt;babel&lt;/code&gt;功能远不止这样，它为各种环境，编辑器和自动化工具提供了接口，也开放了插件开发的&lt;code&gt;API&lt;/code&gt;给开发者，感兴趣的读者可以继续深入了解。&lt;/p&gt;
&lt;h2 id=&quot;五.-使用babel&quot;&gt;五. 使用babel&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;babel&lt;/code&gt;8.0以上的版本将许多插件移入官方仓库，安装方式发生了改变，例如&lt;code&gt;babel-preset-env&lt;/code&gt;地址变为了&lt;code&gt;@babel/preset-env&lt;/code&gt;,使用时请参考&lt;code&gt;babel&lt;/code&gt;官网进行配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;babel-cli&quot;&gt;1.babel-cli&lt;/h4&gt;
&lt;p&gt;为了方便直接在命令行使用babel的功能，通过&lt;code&gt;yarn global add babel-cli&lt;/code&gt;在全局安装命令行工具babel-cli，在&lt;em&gt;package.json&lt;/em&gt;中加入如下脚本:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&quot;scripts&quot;:{
    &quot;babel&quot;:&quot;babel main.js -o maines5.js&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过&lt;code&gt;yarn run babel&lt;/code&gt;即可在命令行使用babel进行编译了，但查看编译后的代码就可以发现，编译前后的文件是一样的，因为我们没有为其指定任何&lt;strong&gt;转码规则&lt;/strong&gt;，运行babel只是把生成的AST遍历了一下而已，想要babel能够实现转码，请继续向下看。&lt;/p&gt;
&lt;h4 id=&quot;babel-preset-env&quot;&gt;2.babel-preset-env&lt;/h4&gt;
&lt;p&gt;提供转码规则，它低版本&lt;code&gt;babel&lt;/code&gt;中使用的几个插件的结合。&lt;code&gt;babel-preset-env&lt;/code&gt;实际上实现的，就是我们在问题推演中所描述的&lt;strong&gt;【All Rules规则集 + get_rules（）方法集】&lt;/strong&gt;，你会在&lt;code&gt;node_modules&lt;/code&gt;文件夹中找到许多&lt;code&gt;babel-plugin-transform-***&lt;/code&gt;这种命名的包，他们就是规则集，你既可以通过设置&lt;code&gt;preset&lt;/code&gt;属性来使用，也可以通过在&lt;code&gt;plugins&lt;/code&gt;属性中挑选需要的转码规则进行引用。&lt;/p&gt;
&lt;p&gt;安装&lt;code&gt;babel-preset-env&lt;/code&gt;后在项目文件夹新建&lt;code&gt;.babelrc&lt;/code&gt;文件并添加如下配置：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    &quot;presets&quot;:[&quot;env&quot;],
    &quot;plugins&quot;: []
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或自定义所需要支持的转义规则:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;{
    &quot;presets&quot;:[],
    &quot;plugins&quot;: [
        &quot;babel-plugin-transform-es2015-arrow-functions&quot;//箭头函数转换规则
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行&lt;code&gt;babel&lt;/code&gt;，就可以看到所编写的代码已经进行了转换。&lt;/p&gt;
&lt;p&gt;转换前：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//Arrow Function  Array.from method
Array.from([1, 2, 3]).map((i) =&amp;gt; {
    return i * i;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换后:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&quot;use strict&quot;;
//Arrow Function  Array.from method
Array.from([1, 2, 3]).map(function (i) {
    return i * i;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以指定目标浏览器，去除不必要的转码，例如在&lt;code&gt;.babelrc&lt;/code&gt;指定要匹配的浏览器为较高版本的chrome:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//.babelrc
{
    &quot;presets&quot;:[ 
        [&quot;env&quot;, {
          &quot;targets&quot;: {
             &quot;browsers&quot;: &quot;chrome 56&quot;
          }      
        }]
    ],
    &quot;plugins&quot;:[]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就可以发现编译后的脚本文件中箭头函数依然存在，说明这个版本的&lt;code&gt;chrome&lt;/code&gt;浏览器已经支持箭头函数了，也就没有必要进行转义了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;新版本的babel已经计划支持在&lt;em&gt;package.json&lt;/em&gt;中设置&lt;code&gt;browserslist&lt;/code&gt;参数来指定需要适配的使用环境，也就是说同一套针对使用环境的配置被剥离出来，而被&lt;code&gt;postcss&lt;/code&gt;,&lt;code&gt;babel&lt;/code&gt;,&lt;code&gt;autoprefixer&lt;/code&gt;等工具共享使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;babel-polyfill&quot;&gt;3.babel-polyfill&lt;/h4&gt;
&lt;p&gt;babel只负责语法转换，比如将ES6的语法转换成ES5。但如果有些对象、方法，浏览器本身不支持，比如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;全局对象：Promise、WeakMap 等。&lt;/li&gt;
&lt;li&gt;全局静态函数：Array.from、Object.assign 等。&lt;/li&gt;
&lt;li&gt;实例方法：比如 Array.prototype.includes 等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;此时，需要引入&lt;code&gt;babel-polyfill&lt;/code&gt;来模拟实现这些对象、方法。&lt;/p&gt;
&lt;p&gt;如果上面编译后的代码在&lt;code&gt;IE10&lt;/code&gt;浏览器中打开，就会看到浏览器出现不支持Array.from方法的报错，如果生成的代码需要在&lt;code&gt;IE10&lt;/code&gt;中运行，那我们就需要引入兼容补丁库，让&lt;code&gt;IE10&lt;/code&gt;浏览器环境中能够支持这个方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;babel-polyfill&lt;/code&gt;需要通过如下的方式引入，然后通过打包工具将其融入脚本:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//ES Module
import 'babel-polyfill'
//或 CommonJs
require ('babel-polyfill')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你真的这样去使用时，就会发现，它的确能够解决报错的问题，但是如此打包会引入整个&lt;code&gt;babel-polyfill&lt;/code&gt;，打包后的代码增加了将近&lt;strong&gt;4000行&lt;/strong&gt;（约400k体积增量），着实让人难以接受。那这个插件能否像&lt;code&gt;babel-preset-env&lt;/code&gt;一样按需引用呢？必须可以的。&lt;code&gt;babel-polyfill&lt;/code&gt;是基于&lt;code&gt;core-js&lt;/code&gt;和&lt;code&gt;regenerator&lt;/code&gt;构建的，只需要在引用时指明即可，例如：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import 'core-js/modules/es6.array.from';
//Arrow Function  Array.from method
Array.from([1, 2, 3]).map((i) =&amp;gt; {
    return i * i;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再进行打包时就会发现bundle文件的体积减小了非常多。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;babel-polyfill&lt;/code&gt;的实现方式如问题推演中所提到的那样，就是污染了全局环境，而且你可能已经意识到，这个工具，要么简单配置后代码量激增，要么按需引用配置繁琐。除非是在中型以上项目中有兼容低版本IE的需求，否则不建议使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;babel-runtimebabel-plugin-transform-runtime&quot;&gt;4.babel-runtime/babel-plugin-transform-runtime&lt;/h4&gt;
&lt;p&gt;如果一个东西难用，那么很快就会有替代品出现，软件的世界也是这样，&lt;code&gt;babel-runtime&lt;/code&gt;就是这样一个替代品。摘录下文资料推荐的博文中的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;babel-polyfill&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单粗暴，他会污染全局环境，比如在不支持Promise的浏览器会polyfill一个全局的Promise对象供调用；另外，不支持的实例方法也在对应的构造函数原型链上添加要polyfill的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;babel-runtime&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不会污染全局环境，会在局部进行polyfill，&lt;strong&gt;另外不会转换一些实例方法&lt;/strong&gt;，如&lt;strong&gt;'abc'.includes('a')&lt;/strong&gt;，其中的includes方法就不会翻译。它一般结合&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;来使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;简单地说，除了实例方法以外，其他的特性&lt;code&gt;babel-runtime&lt;/code&gt;都会帮你打好补丁。使用时直接在&lt;code&gt;plugins&lt;/code&gt;配置项中添加&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总的来说,&lt;code&gt;babel-polyfill&lt;/code&gt;和&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;都有各自的使用场景，也是可以结合使用的，需要根据实际项目需求进行筛选和引入&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;六.-资料推荐&quot;&gt;六. 资料推荐&lt;/h2&gt;
&lt;ul readability=&quot;5.8855721393035&quot;&gt;&lt;li readability=&quot;0.54938271604938&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wonyun/p/8076453.html&quot;&gt;《webpack+babel项目在IE下报Promise未定义错误引出的思考》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博文里详细解说了&lt;code&gt;babel-runtime&lt;/code&gt;和&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;的相关问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.75229357798165&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chris-oil/p/8454346.html&quot;&gt;《如何写好.babelrc?》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博文里详细解说了各个配置项和可选参数的意思，非常实用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.8549222797927&quot;&gt;
&lt;p&gt;入门指南：&lt;a href=&quot;https://github.com/jamiebuilds/babel-handbook&quot;&gt;babel-handbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;非常棒的入门指南，对babel中的概念和用法都做了一定解释，建议&lt;strong&gt;优先阅读&lt;/strong&gt;，可以帮助开发者了解本篇中未涉及的babel模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.8338278931751&quot;&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;http://www.cnblogs.com/dashnowords/p/www.babeljs.io&quot; class=&quot;uri&quot;&gt;www.babeljs.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多开发者喜欢看教程却容易忽略官网，这是非常奇怪的。官方网站会链接到非常多优秀的github仓库，不仅包括babel中封装的底层模块，还包括能够帮助我们理解的指引仓库，甚至ES2015主要特性的解释的网站，是学习babel的主要资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 27 Aug 2018 15:14:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>一. 关于babel 是ES6+语法的编译器，官方网址:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9537311.html</dc:identifier>
</item>
<item>
<title>微服务监控zipkin+asp.net core - LouieGuo</title>
<link>http://www.cnblogs.com/guolianyu/p/9545430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guolianyu/p/9545430.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;整体架构目录：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/9473676.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core分布式项目实战-目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;监控目录：&lt;a href=&quot;https://www.cnblogs.com/guolianyu/p/9545467.html&quot; target=&quot;_blank&quot;&gt;微服务监控zipkin、skywalking以及日志ELK监控系列&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; zipkin是一种分布式跟踪系统，有助于收集微服务架构中的延迟问题所需要的时序数据（收集查找），收集微服务之间的调用情况，然后处理调用之间数据延迟等问题。&lt;/p&gt;
&lt;p&gt;如下图：微服务调用情况深度。（官方文档图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827224842705-1593678007.png&quot; alt=&quot;&quot; width=&quot;1235&quot; height=&quot;610&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以及依赖图分析，会展示出微服务之间的调用关系。当然下图展示的是我案例中的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827225004224-1972588549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt; 1、全链路追踪工具（查看依赖关系）&lt;/p&gt;
&lt;p&gt;2、查看每个接口、每个service的执行速度（定位问题发生点或者寻找性能瓶颈）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zipkin包含：&lt;/strong&gt;&lt;br/&gt;        &lt;span&gt;&lt;strong&gt; 收集器(Collector):&lt;/strong&gt;&lt;/span&gt;主要是收集微服务所产生的数据（收集器有：http、kafka、rabbitmq）&lt;br/&gt;　　 &lt;span&gt;&lt;strong&gt;UI(界面):&lt;/strong&gt;&lt;/span&gt;主要是展示数据的界面&lt;br/&gt;　　 &lt;span&gt;&lt;strong&gt;Storage(存储)：&lt;/strong&gt;&lt;/span&gt;存储数据（es、mysql、内存、cassandra）&lt;br/&gt;　　　　　　　　in-memory：仅供测试&lt;br/&gt;　　　　　　　　JDBC(mysql)：数据采集量很大，查询速度会比较慢。&lt;br/&gt;　　　　　　　　Cassandra:zipkin最初始内建的存储（扩展性好、schema灵活）&lt;br/&gt;　　　　　　　　&lt;strong&gt;&lt;span&gt;(推荐)Elasticsearch:被用于大规模，数据量大的，存储形式json。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　&lt;span&gt;&lt;strong&gt;API：&lt;/strong&gt;&lt;/span&gt;查看/检索 数据的接口，主要用于WebUI中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 结构图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827225153184-197062678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;流程解释：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1、transport作用：收集trace的services的spans，并将它们转化为zipkin common span&lt;br/&gt;2、zipkin核心数据结构&lt;br/&gt;Annotation:用于定位一个request的开始和结束，计算调用延迟。&lt;br/&gt;cs：Client Start,表示客户端发起请求，一个span的开始&lt;br/&gt;sr：Server Receive,表示服务端收到请求&lt;br/&gt;ss：Server Send,表示服务端完成处理，并将结果发送给客户端&lt;br/&gt;cr：Client Received,表示客户端获取到服务端返回信息&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：时间点计算&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;sr-cs：网络延迟&lt;br/&gt;ss-sr：逻辑处理时间&lt;br/&gt;cr-cs：整个流程时间&lt;/p&gt;
&lt;hr/&gt;

&lt;h3&gt;1、需要在每个微服务框架中加入zipkin分布式跟踪系统&lt;/h3&gt;
&lt;p&gt;此项目会新建两个项目一个是 demo1，一个是demo2&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、nuget包安装：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;zipkin4net（追踪器）&lt;br/&gt;zipkin4net.middleware.aspnetcore（aspnetcore 中间件）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827225535722-675451909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、项目中的 Startup.cs 里面Configure方法中注册中间件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827225645365-125864619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 4、配置startup.cs之后还需要配置RPCTraceHandler&lt;/h3&gt;
&lt;p&gt;即在发送Get/Post请求的HttpClient中添加追踪处理者，至此 asp.net core部署完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827225744965-1909513074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 5、上面部署的的只是demo1 服务，因此同样的方式部署demo2项目。&lt;/h3&gt;

&lt;h3&gt;6、现在docker部署zipkin&lt;/h3&gt;
&lt;p&gt;数据存储方式：内存（仅测试）&lt;br/&gt;docker 命令： docker run -d -p 9411:9411 --name zipkin openzipkin/zipkin&lt;/p&gt;
&lt;p&gt; 部署成功后 在浏览器中打开 ,这边我采用的是虚拟机，因此打开地址为 192.168.216.135:9411 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827230427478-1777558099.png&quot; alt=&quot;&quot; width=&quot;1195&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;7、至此部署完成&lt;/h3&gt;
&lt;p&gt;我们在 asp.net core项目的控制其中写上调用demo2   api/values 的接口地址&lt;/p&gt;
&lt;p&gt;追踪在zipkinUI 上面呈现如下：&lt;/p&gt;
&lt;p&gt;图1、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827230745699-2032376858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827230754299-843515237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3：依赖分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180827230800611-2146351661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;8、此zipkin 部署是存在内存中的，不适合正式环境&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;注：一旦数据量上去后，zipkin容易被压崩掉。&lt;br/&gt;因此需要其他解决方案代替。&lt;/p&gt;
&lt;p&gt;目前楼主我采用的解决方案是&lt;strong&gt;&lt;span&gt;kafka+zipkin+es&lt;/span&gt;&lt;/strong&gt;。如果有更好的解决方案可以尝试。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;官网文档：https://zipkin.io/pages/architecture.html&lt;br/&gt;ZIPKIN API 接口：https://zipkin.io/zipkin-api/#/&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;asp.net Core 交流群：&lt;span&gt;787464275&lt;/span&gt; 欢迎加群交流&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;如果您认为这篇文章还不错或者有所收获，您可以点击右下角的【推荐】按钮精神支持，因为这种支持是我继续写作，分享的最大动力！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.7209302325581&quot;&gt;

&lt;p&gt;&lt;strong&gt;声明：原创博客请在转载时保留原文链接或者在文章开头加上本人博客地址，如发现错误，欢迎批评指正。凡是转载于本人的文章，不能设置打赏功能，如有特殊需求请与本人联系！&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Mon, 27 Aug 2018 15:12:00 +0000</pubDate>
<dc:creator>LouieGuo</dc:creator>
<og:description>0、目录 整体架构目录：ASP.NET Core分布式项目实战-目录 监控目录：微服务监控zipkin、skywalking以及日志ELK监控系列 一、zipkin介绍 zipkin是一种分布式跟踪系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guolianyu/p/9545430.html</dc:identifier>
</item>
<item>
<title>那些年，我们用并行遇到的坑01 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9545330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9545330.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景：&lt;/strong&gt;今天测试某一体机产品时，在性能压力测试部分，发现产品手册给出的测试用例，在有关并行度的操作中缺失了一些细节，而这很可能让经验不足的人无法高效的进行测试。&lt;br/&gt;现在记录一下这个过程，并回顾那些年我们用并行遇到的坑：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle RAC 11.2.0.4(3 nodes)&lt;/p&gt;

&lt;p&gt;测试用例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table Z_OBJ tablespace TBS_1 as select * from dba_objects ;
insert /*+ append parallel(t0,16) */ into Z_OBJ t0 select /*+ parallel(t1,16) */ * from Z_OBJ t1;
commit;
--多次执行并查询大小
select owner,segment_name,bytes/1024/1024 from dba_segments where segment_name='Z_OBJ';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据测试用例执行，发现实际并没有合理使用到并行度，效率很差（监控到I/O写入每秒只有百兆级别，正常应该是每秒千兆级别）。&lt;br/&gt;查看执行计划：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; explain plan for insert /*+ append parallel(t0,16) */ into Z_OBJ t0 select /*+ parallel(t1,16) */ * from Z_OBJ t1;

Explained.

SQL&amp;gt; set lines 1000 pages 200
SQL&amp;gt; select * from table(dbms_xplan.display());  

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Plan hash value: 1886916412

---------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name     | Rows  | Bytes | Cost (%CPU)| Time     |    TQ  |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------
|   0 | INSERT STATEMENT      |          |    91M|    17G| 23842   (1)| 00:00:01 |        |      |            |
|   1 |  LOAD AS SELECT       | Z_OBJ    |       |       |            |          |        |      |            |
|   2 |   PX COORDINATOR      |          |       |       |            |          |        |      |            |
|   3 |    PX SEND QC (RANDOM)| :TQ10000 |    91M|    17G| 23842   (1)| 00:00:01 |  Q1,00 | P-&amp;gt;S | QC (RAND)  |
|   4 |     PX BLOCK ITERATOR |          |    91M|    17G| 23842   (1)| 00:00:01 |  Q1,00 | PCWC |            |
|   5 |      TABLE ACCESS FULL| Z_OBJ    |    91M|    17G| 23842   (1)| 00:00:01 |  Q1,00 | PCWP |            |
---------------------------------------------------------------------------------------------------------------

Note
-----
   - dynamic sampling used for this statement (level=2)

16 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，只有查询部分用到了并行，insert部分并没有使用到并行，尽管我们指定了并行度的hint。&lt;br/&gt;&lt;span&gt;知识点1：不仅仅是insert操作，其他DML操作的并行，都需要显示启用DML的并行才可以：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter session enable parallel dml;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看执行计划，发现insert部分已经可以使用到并行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; explain plan for insert /*+ append parallel(t0,16) */ into Z_OBJ t0 select /*+ parallel(t1,16) */ * from Z_OBJ t1;

Explained.

SQL&amp;gt; select * from table(dbms_xplan.display());

PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Plan hash value: 2135351304

---------------------------------------------------------------------------------------------------------------
| Id  | Operation             | Name     | Rows  | Bytes | Cost (%CPU)| Time     |    TQ  |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------------------------
|   0 | INSERT STATEMENT      |          |    91M|    17G| 23842   (1)| 00:00:01 |        |      |            |
|   1 |  PX COORDINATOR       |          |       |       |            |          |        |      |            |
|   2 |   PX SEND QC (RANDOM) | :TQ10000 |    91M|    17G| 23842   (1)| 00:00:01 |  Q1,00 | P-&amp;gt;S | QC (RAND)  |
|   3 |    LOAD AS SELECT     | Z_OBJ    |       |       |            |          |  Q1,00 | PCWP |            |
|   4 |     PX BLOCK ITERATOR |          |    91M|    17G| 23842   (1)| 00:00:01 |  Q1,00 | PCWC |            |
|   5 |      TABLE ACCESS FULL| Z_OBJ    |    91M|    17G| 23842   (1)| 00:00:01 |  Q1,00 | PCWP |            |
---------------------------------------------------------------------------------------------------------------

Note
-----
   - dynamic sampling used for this statement (level=2)

16 rows selected.&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;默认情况下，并行操作会分发到RAC的各个节点，而这通常是我们不希望看到的结果。&lt;br/&gt;&lt;span&gt;知识点2：可设置参数parallel_force_local=true强制让并行操作在本地节点执行，这是个动态参数：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter system set parallel_force_local=true sid='*';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样执行插入操作，在各个节点进行dstat监控，就会发现只有本地节点有每秒几百M的写入操作，说明parallel_force_local=true参数动态生效了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  1   0  98   0   0   0| 163M  326M|  74k   61k|   0     0 |  17k   51k
  2   0  98   0   0   0| 164M  325M| 479k   29k|   0     0 |  18k   51k
  2   0  98   0   0   0| 165M  330M| 833k 1347k|   0     0 |  21k   54k
  1   0  98   0   0   0| 167M  336M|  47k   58k|   0     0 |  18k   52k
  1   0  98   0   0   0| 173M  340M| 507k   31k|   0     0 |  18k   53k
  1   0  98   0   0   0| 176M  354M|  77k  546k|   0     0 |  18k   54k
  1   0  98   0   0   0| 168M  341M|  43k   44k|   0     0 |  18k   53k
  2   0  98   0   0   0| 177M  353M|  32k   42k|   0     0 |  18k   54k
  2   0  98   0   0   0| 183M  362M|  65k   67k|   0     0 |  17k   54k
  1   0  98   0   0   0| 163M  329M|  44k   44k|   0     0 |  16k   49k
  1   0  98   0   0   0| 165M  328M|  39k   33k|   0     0 |  18k   51k
  1   0  98   0   0   0| 161M  323M|  43k   56k|   0     0 |  17k   50k
  2   0  98   0   0   0| 182M  360M|  44k   49k|   0     0 |  18k   55k
  1   0  98   0   0   0| 166M  331M|  34k   52k|   0     0 |  18k   51k
  2   0  98   0   0   0| 162M  327M|  25k   25k|   0     0 |  18k   51k&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时再结合1中的经验，启用dml的并行，可以发现效率大幅提升，本地节点有每秒几千M的写入操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  8   1  90   1   0   0|2927M 5882M| 771k  140k|   0     0 | 107k  157k
  9   1  90   1   0   0|3134M 6266M| 759k 1484k|   0     0 | 108k  161k
  8   1  90   1   0   0|3021M 6042M| 154k  178k|   0     0 | 104k  155k
  9   1  90   0   0   0|3000M 6004M| 259k  266k|   0     0 | 106k  156k
  9   1  90   0   0   0|2875M 5754M| 129k  142k|   0     0 | 102k  150k
  9   1  90   0   0   0|3082M 6160M| 127k  135k|   0     0 | 108k  158k
  9   1  90   0   0   0|3044M 6095M| 655k  642k|   0     0 | 107k  158k
  9   1  89   0   0   0|2961M 5923M| 125k  134k|   0     0 | 105k  153k
  9   1  90   0   0   0|2875M 5747M| 137k  168k|   0     0 | 102k  150k
  9   1  90   0   0   0|3156M 6312M| 127k  135k|   0     0 | 109k  163k
  9   1  90   1   0   0|3144M 6291M| 130k  138k|   0     0 | 109k  162k
  9   1  90   1   0   0|3058M 6117M| 125k  143k|   0     0 | 106k  157k
  9   1  90   0   0   0|3138M 6279M| 132k  139k|   0     0 | 108k  161k
  9   1  90   0   0   0|3039M 6074M| 141k  143k|   0     0 | 106k  156k
  4   1  95   0   0   0|1237M 2615M| 986k   61k|   0     0 |  68k   90k&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建大表Z_OBJ_3，使用32个并行度插入数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table Z_OBJ_3 tablespace TBS_3 as select * from dba_objects ;

insert /*+ append parallel(t0,32) */ into Z_OBJ_3 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;
commit;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际花费25s的时间插入完成，并行度提升性能也进一步提升：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; insert /*+ append parallel(t0,32) */ into Z_OBJ_3 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;

867092478 rows created.

Elapsed: 00:00:25.52&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时dstat监控，每秒写操作达到8000M+：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  0   0 100   0   0   0|2489k 1036k|   0     0 |   0     0 |  10k 9766 
 13   1  83   2   0   0|3755M 7542M| 699k 1055k|   0     0 | 143k  210k
 12   2  84   2   0   0|3634M 7407M| 447k  453k|   0     0 | 147k  209k
 13   1  83   2   0   0|4202M 8402M| 535k  553k|   0     0 | 141k  215k
 14   1  82   2   0   0|4168M 8339M| 539k  556k|   0     0 | 144k  214k
 13   1  82   2   0   1|4109M 8224M| 546k  552k|   0     0 | 142k  210k
 13   1  83   3   0   0|4209M 8419M| 311k  327k|   0     0 | 138k  213k
 13   1  83   3   0   0|4237M 8483M| 114k  114k|   0     0 | 136k  210k
  9   1  88   1   0   1|2709M 5703M|  64k   65k|   0     0 | 156k  203k
 14   1  82   2   0   0|4189M 8383M|  91k   87k|   0     0 | 136k  205k
 13   1  82   3   0   0|4237M 8478M|  95k  101k|   0     0 | 136k  208k
 14   1  82   2   0   0|4242M 8485M|  95k  109k|   0     0 | 139k  208k
 14   1  82   3   0   0|4202M 8412M| 835k  103k|   0     0 | 137k  208k
 14   1  82   2   0   0|4288M 8563M|1143k 1930k|   0     0 | 139k  211k
 14   1  82   2   0   0|4229M 8477M| 101k   97k|   0     0 | 138k  209k&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再创建大表Z_OBJ_4，使用64个并行度插入数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table Z_OBJ_4 tablespace TBS_4 as select * from dba_objects ;

insert /*+ append parallel(t0,64) */ into Z_OBJ_4 t0 select /*+ parallel(t1,64) */ * from Z_OBJ t1;
commit;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际花费28s的时间插入完成，发现即使在CPU足够的前提下，并行度提升没有性能提升，说明I/O已达到瓶颈：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; insert /*+ append parallel(t0,64) */ into Z_OBJ_4 t0 select /*+ parallel(t1,64) */ * from Z_OBJ t1;

867092478 rows created.

Elapsed: 00:00:28.61&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时dstat监控，每秒写操作接近8000M：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
 14   2  81   4   0   1|3844M 7711M|3571k 2567k|   0     0 | 130k  197k
 12   1  83   3   0   0|3810M 7602M| 535k 1885k|   0     0 | 115k  175k
 13   1  82   3   0   0|3799M 7607M| 603k  654k|   0     0 | 116k  174k
 14   1  82   3   0   0|3810M 7638M| 550k  602k|   0     0 | 119k  176k
 13   1  83   3   0   0|3766M 7531M| 630k  651k|   0     0 | 114k  171k
 13   1  81   4   0   0|3804M 7608M| 620k  669k|   0     0 | 117k  175k
 13   1  82   3   0   0|3792M 7585M| 581k  616k|   0     0 | 117k  176k
 13   1  82   3   0   0|3767M 7522M| 561k  612k|   0     0 | 116k  173k
 12   1  82   3   0   0|3659M 7343M| 553k  601k|   0     0 | 115k  170k
 13   1  82   3   0   0|3659M 7340M| 609k  668k|   0     0 | 121k  179k
 13   1  82   3   0   0|3746M 7502M| 609k  644k|   0     0 | 117k  174k
 13   1  82   3   0   0|3822M 7648M| 675k  773k|   0     0 | 118k  178k
 13   1  83   3   0   0|3769M 7541M|1191k  632k|   0     0 | 115k  173k
 13   1  83   3   0   0|3864M 7725M|1749k 2533k|   0     0 | 117k  177k
 13   1  82   3   0   0|3741M 7481M| 613k  655k|   0     0 | 116k  172k&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;知识点3：一般增大并行度可以提升操作返回速度，但同时也受限于整体的系统I/O能力&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;br/&gt;同时测试3个节点：
&lt;pre&gt;
&lt;code&gt;--节点1
set time on
set timing on
drop table Z_OBJ_2 purge;
create table Z_OBJ_2 tablespace TBS_2 as select * from dba_objects where 1=2;
alter session enable parallel dml;
--INSERT Z_OBJ_2
insert /*+ append parallel(t0,32) */ into Z_OBJ_2 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;
commit;


--节点2
set time on
set timing on
drop table Z_OBJ_3 purge;
create table Z_OBJ_3 tablespace TBS_3 as select * from dba_objects where 1=2;
alter session enable parallel dml;
--INSERT Z_OBJ_3
insert /*+ append parallel(t0,32) */ into Z_OBJ_3 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;
commit;

--节点3
set time on
set timing on
drop table Z_OBJ_4 purge;
create table Z_OBJ_4 tablespace TBS_4 as select * from dba_objects where 1=2;
alter session enable parallel dml;
--INSERT Z_OBJ_4
insert /*+ append parallel(t0,32) */ into Z_OBJ_4 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;
commit;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各节点同时观察插入耗时（单个执行时间变长，整体的I/O瓶颈导致）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;15:26:06 SQL&amp;gt; insert /*+ append parallel(t0,32) */ into Z_OBJ_2 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;

867092478 rows created.

Elapsed: 00:00:48.53

15:25:23 SQL&amp;gt;  insert /*+ append parallel(t0,32) */ into Z_OBJ_3 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;

867092478 rows created.

Elapsed: 00:00:45.84

15:25:21 SQL&amp;gt;  insert /*+ append parallel(t0,32) */ into Z_OBJ_4 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;

867092478 rows created.

Elapsed: 00:00:47.63&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各节点dstat同时观察：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--node1：
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  7   1  82   9   0   0|2110M 4223M| 169k  230k|   0     0 |  78k  122k
  7   1  82   9   0   0|2107M 4209M| 176k  178k|   0     0 |  79k  123k
  9   1  81   9   0   0|2614M 5237M| 190k  195k|   0     0 |  96k  148k
  8   1  81  10   0   0|2171M 4339M| 195k  232k|   0     0 |  84k  127k
  7   1  83   9   0   0|1975M 3947M| 220k  184k|   0     0 |  76k  117k
  7   1  82   9   0   0|2051M 4099M| 166k  169k|   0     0 |  78k  121k
  7   1  82  10   0   0|2059M 4121M|1193k  170k|   0     0 |  79k  121k
  7   1  83   9   0   0|2001M 4011M| 384k 1463k|   0     0 |  76k  118k
  3   0  93   4   0   0| 802M 1570M| 148k  144k|   0     0 |  36k   53k
  2   0  96   2   0   0| 355M  886M| 113k  137k|   0     0 |  47k   61k
  8   1  82   9   0   0|2122M 4255M| 189k  202k|   0     0 |  79k  123k
  7   1  83   9   0   0|2040M 4069M| 162k  164k|   0     0 |  76k  119k
  8   1  82   9   0   0|2208M 4436M| 839k  843k|   0     0 |  83k  130k
  9   1  83   7   0   0|2506M 5037M| 305k  307k|   0     0 |  94k  145k
  4   0  93   2   0   0|1098M 2273M| 218k  233k|   0     0 |  49k   72k
  
--node2：
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  6   1  82  11   0   0|2152M 4312M| 221k  224k|   0     0 |  79k  130k
  7   1  82  10   0   0|2226M 4447M| 216k  218k|   0     0 |  81k  133k
 10   1  81   8   0   0|2775M 5559M| 244k  214k|   0     0 | 100k  159k
  7   1  83   9   0   0|2110M 4205M| 220k  221k|   0     0 |  77k  126k
  7   1  83  10   0   0|2104M 4219M| 231k  266k|   0     0 |  76k  126k
  7   1  83  10   0   0|2158M 4311M| 207k  207k|   0     0 |  78k  129k
  7   1  83  10   0   0|2103M 4214M| 877k  849k|   0     0 |  76k  126k
  7   1  82  10   0   0|2109M 4214M| 207k  209k|   0     0 |  76k  124k
 10   1  81   8   0   0|2934M 5866M| 212k  216k|   0     0 | 102k  165k
  7   1  82  10   0   0|2281M 4551M| 207k  227k|   0     0 |  82k  133k
  7   1  83  10   0   0|2136M 4281M| 206k  205k|   0     0 |  79k  128k
  6   1  84  10   0   0|1951M 3940M| 313k  341k|   0     0 |  73k  120k
  4   0  92   4   0   0|1044M 2250M| 672k  642k|   0     0 |  56k   88k
  0   0  99   0   0   0|  50M  116M| 258k  276k|   0     0 |  11k   14k
  0   0 100   0   0   0| 323k   58k| 208k  202k|   0     0 |8385    10k

--node3：
----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw 
  6   1  83  10   0   0|2144M 4274M| 149k  156k|   0     0 |  77k  129k
  6   1  82  11   0   0|2223M 4452M| 165k  189k|   0     0 |  80k  133k
  6   1  82  11   0   0|2203M 4404M| 189k  198k|   0     0 |  79k  131k
  7   0  83  10   0   0|2119M 4233M| 140k  211k|   0     0 |  75k  125k
  7   1  83  10   0   0|2156M 4311M| 870k  731k|   0     0 |  78k  128k
  7   1  82  10   0   0|2157M 4318M| 143k  149k|   0     0 |  79k  129k
  7   1  83   9   0   0|2172M 4344M| 165k  170k|   0     0 |  79k  131k
  7   1  83  10   0   0|2139M 4283M| 140k  141k|   0     0 |  78k  125k
  7   1  83  10   0   0|2145M 4303M| 143k  151k|   0     0 |  78k  129k
  7   1  83  10   0   0|2121M 4226M| 146k  450k|   0     0 |  76k  126k
  7   1  82  10   0   0|2442M 4884M| 460k  155k|   0     0 |  87k  144k
  6   0  83  10   0   0|2083M 4177M| 217k  156k|   0     0 |  76k  126k
  4   0  88   7   0   0|1445M 2863M| 130k  126k|   0     0 |  54k   89k
  2   0  94   3   0   0| 577M 1341M| 121k  124k|   0     0 |  53k   73k
  7   1  82  10   0   0|2219M 4437M| 157k  193k|   0     0 |  81k  133k&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;知识点4：各节点同时并行操作的整体效率，同样受限于整体的系统I/O能力&lt;/span&gt;&lt;br/&gt;测试到这里，还有一个疑惑，为什么不用create？我们来按测试用例试下create操作，很不如人意，只有300多M的写入速度，将近10分钟才创建完成。而上面的并行insert则有8000多M的写入速度，20s+就可以插入完成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;drop table Z_OBJ_2 purge;
create table Z_OBJ_2 tablespace TBS_2 as select /*+ parallel(t1,32) */ * from Z_OBJ t1;
Elapsed: 00:09:19.52

15:49:58 SQL&amp;gt; insert /*+ append parallel(t0,32) */ into Z_OBJ_2 t0 select /*+ parallel(t1,32) */ * from Z_OBJ t1;
867092478 rows created.
Elapsed: 00:00:25.24&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然,create操作相当于没有用到并行，如何让create操作也用到并行度呢？这就需要将SQL语句改写如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--使用到并行，26s就完成了百G大小表的创建：
drop table Z_OBJ_2 purge;
create table Z_OBJ_2 tablespace TBS_2 parallel(degree 32) as select /*+ parallel(t1,32) */ * from Z_OBJ t1;
Elapsed: 00:00:26.76

--使用到并行+nologging，差距不大，只需25s就完成了百G大小表的创建：
drop table Z_OBJ_2 purge;
create table Z_OBJ_2 tablespace TBS_2 parallel(degree 32) nologging as select /*+ parallel(t1,32) */ * from Z_OBJ t1;
Elapsed: 00:00:25.77&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，我们在使用并行的时候，尤其要注意是否各部分都有效的使用到了并行。&lt;br/&gt;关于并行，还有些有意思的场景，比如就曾遇到过有开发人员写错SQL并行度的hint导致oracle采用了自动DOP，即最大并行度执行，导致系统资源基本全被占用，进而其他操作无法高效运行导致性能故障。其他关于并行的坑，会在之后的章节中再详细介绍。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 15:04:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>背景： 今天测试某一体机产品时，在性能压力测试部分，发现产品手册给出的测试用例，在有关并行度的操作中缺失了一些细节，而这很可能让经验不足的人无法高效的进行测试。 现在记录一下这个过程，并回顾那些年我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9545330.html</dc:identifier>
</item>
<item>
<title>EM算法(二)-算法初探 - 蒙面的普罗米修斯</title>
<link>http://www.cnblogs.com/datasnail/p/9545385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datasnail/p/9545385.html</guid>
<description>&lt;h3 id=&quot;一em算法简介&quot;&gt;一、EM算法简介&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/fundamental/2018/07/06/machine_learning_em.html&quot;&gt;EM算法之一--问题引出&lt;/a&gt;中我们介绍了硬币的问题，给出了模型的目标函数，提到了这种含隐变量的极大似然估计要用EM算法解决，继而罗列了EM算法的简单过程，当然最后看到EM算法时内心是懵圈的，我们也简要的分析了一下，那回过头来，重新看下EM算法的简单介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;27&quot;&gt;
&lt;p&gt;输入：观测变量数据Y，隐变量数据Z，联合分布$P(Y,Z|\theta)$,条件分布$P(Z|Y,\theta)$&lt;br/&gt;输出：模型参数$\theta$&lt;br/&gt;(1)选择参数初值$\theta^{(0)}$，进行迭代；&lt;br/&gt;(2)E步：记$\theta^{(i)}$为第i次迭代参数$\theta$的估计值，在i+1次迭代的E步，计算：&lt;/p&gt;
&lt;p&gt;$$Q(\theta,\theta^{(i)}) =E_Z[logP(Y,Z | \theta)|\color{red}{Y,\theta^{(i)}}]\ =\sum_Z{logP(Y,Z|\theta)\color{red}{P(Z|Y,\theta^{(i)})}} \tag{1}$$&lt;/p&gt;
&lt;p&gt;(3)M步：求使得$Q(\theta,\theta^{(i)})$极大化的$\theta$，确定i+1次迭代的参数估计值$\theta^{(i+1)}$&lt;/p&gt;
&lt;p&gt;$$\theta^{(i+1)}=argmax_\theta Q(\theta,\theta^{(i)}) \tag{2}$$&lt;/p&gt;
&lt;p&gt;(4)重复第（2）步和第（3）步，直到收敛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;上述E步中的函数$Q(\theta,\theta^{(i)})$是EM算法的核心&lt;/span&gt;，称之为Q函数（Q function）。&lt;br/&gt;&lt;strong&gt;Q函数&lt;/strong&gt;是&lt;strong&gt;完全数据的对数似然函数&lt;/strong&gt;$logP(Y,Z | \theta)$关于在&lt;strong&gt;给定观测数据$Y$和当前参数$\theta^{(i)}$下，对&lt;span&gt;未观测数据Z&lt;/span&gt;的条件概率分布&lt;/strong&gt;$P(Z|Y,\theta^{(i)})$的期望。&lt;br/&gt;让我们且慢下来看下Q函数，这里重点词很多。首先，很显然Q函数是个期望，这没有问题；其次这个期望是某个函数（完全数据下的对数似然函数）关于某个概率分布（在xxx条件下，未观测数据Z的条件概率分布）的期望。读到这里的你可能对&lt;strong&gt;函数关于某个概率分布的期望&lt;/strong&gt;不太明白。我就在这个插个小插曲介绍下，懂的可以略过：&lt;/p&gt;
&lt;h4 id=&quot;知识点一条件数学期望&quot;&gt;&lt;strong&gt;知识点一：条件数学期望&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;上面牵扯到的&lt;strong&gt;函数关于某个概率分布的期望&lt;/strong&gt;，在数学中叫&lt;strong&gt;条件数学期望&lt;/strong&gt;。&lt;br/&gt;首先，条件概率我们已经熟悉，就是在事件$ {X=x_i}$已经发生的条件下，事件${Y=y_j}$发生的概率，记作$P{Y=y_j|X=x_i}$;&lt;br/&gt;而条件期望是一个实数随机变量的相对于一个条件概率分布的期望值。设X和Y是离散随机变量，则X的条件期望在给定事件Y = y条件下是x的在Y的值域的函数:&lt;/p&gt;
&lt;p&gt;{:.center}&lt;br/&gt;&lt;img src=&quot;http://www.datasnail.cn/postimg/em/cpf.png&quot;/&gt;        (3)&lt;br/&gt;{:.center}&lt;/p&gt;
&lt;p&gt;个人感觉可以理解为在各个条件概率分布下的加权平均。&lt;/p&gt;
&lt;p&gt;那么&lt;strong&gt;继续&lt;/strong&gt;理解Q函数，看E步中公式(1)，函数$logP(Y,Z| \theta)$是关于Z的，而在$Y,\theta^{(i)}$的条件下就是指隐含变量Z在此条件下，也就是在概率分布$P(Z|Y,\theta^{(i)})$条件下，所以公式1中红色部分的变形就很好理解了。对数似然函数$logP(Y,Z| \theta)$就是完全数据的对数似然函数，里面有隐变量Z，所以想要求此函数中&lt;strong&gt;Z的条件数学期望&lt;/strong&gt;就要加入对Z的条件概率分布。&lt;br/&gt;在&lt;strong&gt;E步&lt;/strong&gt;获得了隐含变量的条件数学期望后，我们要做的就是拿着个值取求模型参数$\theta$使得Q函数的值最大（极大似然估计求导）。所以，在&lt;strong&gt;M步&lt;/strong&gt;中，对于$Q(\theta,\theta^{(i)})$求极大值，得到$\theta^{(i+1)}$，完成一次迭代$\theta^{(i)} \to \theta^{(i+1)}$，我们之后在证明每次迭代必定会使得Q函数值增大或者能达到局部最优（第二部分提供证明）。最后，停止的迭代条件一般是要求设置比较小的值$\epsilon_1,\epsilon_2$，若满足$||\theta^{(i+1)}-\theta^{(i)}||&amp;lt;\epsilon_1$或者$||Q(\theta^{(i+1)},\theta^{(i+1)})-Q(\theta^{(i)},\theta^{(i)})||&amp;lt;\epsilon_2$。&lt;/p&gt;
&lt;h3 id=&quot;二em算法导出&quot;&gt;二、EM算法导出&lt;/h3&gt;
&lt;p&gt;为什么EM算法能&lt;strong&gt;近似实现观测数据的极大似然估计&lt;/strong&gt;呢？我们面对一个含有隐变量的概率模型，目标是极大化观测数据（不完全数据）Y关于参数$\theta$的对数似然函数，即最大化：&lt;/p&gt;
&lt;p&gt;$$L(\theta) =logP(Y|\theta) =log\sum_Z{logP(Y,Z|\theta)} =log(\sum_Z{P(Y|Z,\theta)P(Z|\theta)}) \tag{4}$$&lt;/p&gt;
&lt;p&gt;着个式子的困难就是公式（4）中含有未观测数据，而且含有和（或者积分）的对数。&lt;br/&gt;而EM算法是通过迭代逐步近似极大化$L(\theta)$的。这里假设第i此迭代后$\theta$的估计值是$\theta^{(i)}$，那么我们计算下新的估计值$\theta$能否使得$L(\theta)$增加，即$L(\theta)&amp;gt;L(\theta^{(i)})$，并逐步到达最大值？于是我们考虑两者的差值：&lt;/p&gt;
&lt;p&gt;$$L(\theta)-L(\theta^{(i)})=log \left( \sum_Z{P(Y|Z,\theta)P(Z|\theta)} \right)-logP(Y|\theta^{(i)}) \tag{5}$$&lt;/p&gt;
&lt;p&gt;对于公式（5）我们需要一个变形，但是变形需要知道Jensen inequality。&lt;/p&gt;
&lt;h4 id=&quot;知识点二jensen-inequality詹森不等式&quot;&gt;&lt;strong&gt;知识点二：Jensen inequality(詹森不等式)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;//TODO&lt;/p&gt;
&lt;p&gt;稍微了解完Jensen不等式，我们继续来看公式（5），首先把公式（5）变形，前部分中分子分母同时乘以一个$\color{blue}{P(Y|Z,\theta^{(i)})}$，清晰起见，我们标上蓝色和中括号，如下：&lt;/p&gt;
&lt;p&gt;$$&lt;br/&gt;\begin{align}&lt;br/&gt;L(\theta)-L(\theta^{(i)}) &amp;amp;=log \left( \sum_Z \left[ {\color{blue}{P(Z|Y,\theta^{(i)})} \frac{P(Y|Z,\theta)P(Z|\theta)}{\color{blue}{P(Z|Y,\theta^{(i)})}}} \right] \right) -log\color{ForestGreen}{P(Y|\theta^{(i)})} \&lt;br/&gt;&amp;amp;\ge \sum_Z \left[ \color{blue}{P(Z|Y,\theta^{(i)})} log \left( \frac{P(Y|Z,\theta)P(Z|\theta)}{\color{blue}{P(Z|Y,\theta^{(i)})}} \right) \right] -log\color{ForestGreen}{P(Y|\theta^{(i)})} \&lt;br/&gt;&amp;amp;= \sum_Z \left[ \color{blue}{P(Z|Y,\theta^{(i)})} log \left( \frac{P(Y|Z,\theta)P(Z|\theta)}{\color{blue}{P(Z|Y,\theta^{(i)})}} \right) \right] - \underbrace{\color{blue}{\sum_Z{P(Z|Y,\theta^{(i)}})}}_{=1} log\color{ForestGreen}{P(Y|\theta^{(i)})} \&lt;br/&gt;&amp;amp;= \sum_Z \left[ \color{blue}{P(Z|Y,\theta^{(i)})} log \left( \frac{P(Y|Z,\theta)P(Z|\theta)}{\color{blue}{P(Z|Y,\theta^{(i)})}\color{ForestGreen}{P(Y|\theta^{(i)})}} \right) \right]&lt;br/&gt;\end{align}&lt;br/&gt;\tag{6}$$&lt;/p&gt;
&lt;p&gt;这里我们令&lt;/p&gt;
&lt;p&gt;$$B(\theta,\theta^{(i)}) = L(\theta^{(i)}) + \sum_Z \left[ \color{blue}{P(Z|Y,\theta^{(i)})} log \left( \frac{P(Y|Z,\theta)P(Z|\theta)}{\color{blue}{P(Z|Y,\theta^{(i)})}\color{ForestGreen}{P(Y|\theta^{(i)})}} \right) \right] \tag{7}$$&lt;/p&gt;
&lt;p&gt;则可以得到:&lt;/p&gt;
&lt;p&gt;$$L(\theta) \ge B(\theta,\theta^{(i)}) \tag{8}$$&lt;/p&gt;
&lt;p&gt;可以知道$B(\theta,\theta^{(i)})$函数是$L(\theta)$的一个下界，且由公式(7)可知：&lt;/p&gt;
&lt;p&gt;$$L(\theta^{(i)}) = B(\theta^{(i)},\theta^{(i)})$$&lt;/p&gt;
&lt;p&gt;因此，任何可以使得$B(\theta,\theta^{(i)})$增大的$\theta$，也可以使$L(\theta)$增大。为了使得$L(\theta)$有尽可能的大的增长，选择$\theta^{(i+1)}$使$B(\theta,\theta^{(i)})$达到极大，即：&lt;/p&gt;
&lt;p&gt;$$\theta^{(i+1)}=argmax_\theta B(\theta,\theta^{(i)}) \tag{9}$$&lt;/p&gt;
&lt;p&gt;现在求$\theta^{(i+1)}$，省略常数化项：&lt;/p&gt;
&lt;p&gt;$$&lt;br/&gt;\begin{align}&lt;br/&gt;\theta^{(i+1)} &amp;amp;= argmax_\theta \left( L(\theta^{(i)}) + \sum_Z \color{blue}{P(Z|Y,\theta^{(i)})} log \left( \frac{P(Y|Z,\theta)P(Z|\theta)}{\color{blue}{P(Z|Y,\theta^{(i)})}\color{ForestGreen}{P(Y|\theta^{(i)})}} \right) \right) \&lt;br/&gt;&amp;amp;= argmax_\theta \left( \sum_Z \color{blue}{P(Z|Y,\theta^{(i)})} log \left( P(Y|Z,\theta)P(Z|\theta) \right) \right) \&lt;br/&gt;&amp;amp;= argmax_\theta \left( \sum_Z \color{blue}{P(Z|Y,\theta^{(i)})} log \left( P(Y|Z,\theta) \right) \right) \&lt;br/&gt;&amp;amp;= argmax_\theta Q(\theta,\theta^{(i)})&lt;br/&gt;\end{align}&lt;br/&gt;\tag{10}&lt;br/&gt;$$&lt;/p&gt;
&lt;p&gt;公式（10）中等价于EM算法的一次迭代，即求Q函及其极大化。&lt;span&gt;EM算法是通过不断求解下界的极大化逼近求解对数似然函数极大化的算法。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;三em算法应用&quot;&gt;三、EM算法应用&lt;/h3&gt;
&lt;p&gt;EM算法有很多应用，求分类、回归、标注等任务。比较广泛的就是GMM混合高斯模型、HMM隐马尔可夫训练问题等等。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 14:59:00 +0000</pubDate>
<dc:creator>蒙面的普罗米修斯</dc:creator>
<og:description>一、EM算法简介 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/datasnail/p/9545385.html</dc:identifier>
</item>
<item>
<title>使用.net core 自带DI框架实现 延迟加载 - 黑洞视界</title>
<link>http://www.cnblogs.com/blurhkh/p/9545311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blurhkh/p/9545311.html</guid>
<description>&lt;p&gt;在某些情况，我们希望能延迟一个依赖的初始化。如果使用的是autofac，我们可以通过注入Lazy&lt;/p&gt;
&lt;p&gt;我们对 autofac GitHub上提供的一个例子进行进行简单改造，跑起来看看。&lt;br/&gt;原Example的链接https://github.com/autofac/Examples/tree/master/src/AspNetCoreExample&lt;/p&gt;
&lt;p&gt;微改后的代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
public class ValuesController : Controller
{
    private readonly Lazy&amp;lt;IValuesService&amp;gt; _valuesService;

    public ValuesController(Lazy&amp;lt;IValuesService&amp;gt; valuesService)
    {
        _valuesService = valuesService;
    }

    // GET api/values
    [HttpGet]
    public IEnumerable&amp;lt;string&amp;gt; Get()
    {
        // Kestrel模式下这里会输出false，实例尚未创建
        Console.WriteLine(_valuesService.IsValueCreated); 
        // 调用Lazy&amp;lt;T&amp;gt;的Value属性才真正创建实例
        return this._valuesService.Value.FindAll();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直到目前core2.1版本，自带的DI依旧未支持延迟加载，如果我们尝试在使用自带DI的情况下套用上述代码，会得到一个异常，例如：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;

&lt;p&gt;InvalidOperationException: Unable to resolve service for type 'System.Lazy`1[WebApplication9.Services.IValuesService]' while attempting to activate 'WebApplication9.Controllers.ValuesController'.&lt;/p&gt;
&lt;p&gt;Microsoft.Extensions.DependencyInjection.ActivatorUtilities.GetService(IServiceProvider sp, Type type, Type requiredBy, bool isDefaultParameterRequired)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如何利用core自带的DI实现呢？如果我们尝试百度，可能会搜到类似下面的答案。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddTransient(typeof(Lazy&amp;lt;&amp;gt;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这样的做法是否能解决我们的问题呢，为了简化演示代码。我们创建一个控制台程序并引用Microsoft.Extensions.DependencyInjection。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        var services = new ServiceCollection();
        services.AddScoped&amp;lt;ITestService, TestService&amp;gt;();
        services.AddTransient(typeof(Lazy&amp;lt;&amp;gt;));

        var serviceProvider = services.BuildServiceProvider();

        using (var scope = serviceProvider.CreateScope() )
        {
            var service = scope.ServiceProvider.GetService&amp;lt;Lazy&amp;lt;ITestService&amp;gt;&amp;gt;();
            // 这边令人遗憾地输出了true，也就是说，这种方式的延迟注入是失败的
            Console.WriteLine(service.IsValueCreated);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在查阅Stack Overflow的时候，我看到了这样的解决方案，感觉还是挺简单实用的，分享给大家。&lt;/p&gt;
&lt;p&gt;原贴地址：&lt;a href=&quot;https://stackoverflow.com/questions/44934511/does-net-core-dependency-injection-support-lazyt&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/44934511/does-net-core-dependency-injection-support-lazyt&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class LazyLoader&amp;lt;T&amp;gt; : Lazy&amp;lt;T&amp;gt;
{
    public LazyLoader(IServiceProvider sp) : base(sp.GetRequiredService&amp;lt;T&amp;gt;)
    {
    }
}

class Program
{
    static void Main(string[] args)
    {
        var services = new ServiceCollection();
        services.AddScoped&amp;lt;ITestService, TestService&amp;gt;();
        // services.AddScoped(typeof(Lazy&amp;lt;&amp;gt;), typeof(LazyLoader&amp;lt;&amp;gt;)); 也可以，区别不大
        services.AddTransient(typeof(Lazy&amp;lt;&amp;gt;), typeof(LazyLoader&amp;lt;&amp;gt;));

        var serviceProvider = services.BuildServiceProvider();

        using (var scope = serviceProvider.CreateScope())
        {
            var service = scope.ServiceProvider.GetService&amp;lt;Lazy&amp;lt;ITestService&amp;gt;&amp;gt;();
            Console.WriteLine(service.IsValueCreated); // 输出false

            // 下面输出true，延迟注入的对象和正常注入的对象，本质上不会有差别
            Console.WriteLine(service.Value == scope.ServiceProvider.GetService&amp;lt;ITestService&amp;gt;());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现原理比较简单，在LazyLoader中注入ServiceProvider，调用父类的Value属性时会执行委托，从ServiceProvider中获取到对应得依赖实例。&lt;/p&gt;
</description>
<pubDate>Mon, 27 Aug 2018 14:41:00 +0000</pubDate>
<dc:creator>黑洞视界</dc:creator>
<og:description>在某些情况，我们希望能延迟一个依赖的初始化。如果使用的是autofac，我们可以通过注入Lazy来实现。 我们对 autofac GitHub上提供的一个例子进行进行简单改造，跑起来看看。 原Exam</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blurhkh/p/9545311.html</dc:identifier>
</item>
</channel>
</rss>