<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring基础篇——bean的自动化装配 - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/8245495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/8245495.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;上篇博文讲Spring的IOC容器时说道，虽然容器功能强大&lt;span&gt;，但容器本身只是个空壳，需要我们主动放入装配对象，并告诉它对象之间的协作关系，然后容器才能按照我们的指示发挥它的魔力，完成装配bean的使命。这里，我们把Spring创建应用对象之间的协作关系的行为成为装配。Spring提供了很多装配&lt;span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;的方式供我们在开发中选择，我们常用到的有三种装配机制：自动装配、Java注解和XML配置。通常我们将第一种称为隐式的装配机制，后面两种为显示的装配机制。实际应用中，基于便利性考虑，首选的肯定是隐式的自动化装配机制，只有当需要注入的bean的源码不是由自己的程序来维护，而是引入第三方的应用组件的时候，才考虑显示的方式装配bean。当然，各种装配方式在实际应用中是可以自由选择搭配的，编码过程中也不必拘泥哪一种，适用就好。本篇博文先来讲述隐式的装配机制——bean的自动化装配。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;你一定很好奇Spring是怎么来实现其自动化装配机制的，其实Spring主要通过下面两个方面来实现：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;组件扫描——通过开启组件扫描功能让Spring可以自动发现应用上下文中的bean;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动装配——自动满足组件之间的依赖关系。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;span&gt;下面，我们分别来看看Spring如何通过&lt;strong&gt;组件扫描&lt;/strong&gt;和&lt;strong&gt;自动装配&lt;/strong&gt;来为我们的应用程序自动化的装配bean。我们先定义一个汽车接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.facade;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;　　组件扫描&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　组件扫描的要义在于通过扫描控制，让Spring自动的去发现应用程序中的bean。不过程序中的对象那么多，Spring怎么知道哪些对象是需要它去管理创建的呢？这就涉及到Spring的一个组件注解——@Component，&lt;span&gt;被该注解标注的类即为Spring的组件类，Spring容器加载过程中会自动的为该类创建&lt;/span&gt;bean（&lt;span&gt;PS:实际上Spring的组件注解按照语义化的分类还有@Controller @Repository @Service等等,分别作用于控制层、持久层和业务层，此处仅是举例演示，不做区分讲解&lt;/span&gt;）。所以，我们可以将接口的一个实现标注上该注解，表明实现类是要被Spring创建实例的——&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QQCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;开QQ车&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;不过，Spring的注解扫描默认是不开启的，所以我们还需要显示的配置注解启动。这里同样有两种方式，Java注解和XML的方式，我们分别展示出来——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Java配置类&lt;span&gt;CarConfig&lt;/span&gt; ：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.config;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.ComponentScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarConfig {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;XML配置文件applicationContext.xml：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context 
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;启动注解扫描&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;spring&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们编写测试类，看看Spring是不是自动的去发现了我们注解为组件的bean并为我们创建了对象——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.config.CarConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.QQCar;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.junit.Assert.assertNotNull;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * 注解释义：
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * @RunWith(SpringJUnit4ClassRunner.class)  测试在Spring环境中运行
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * @ContextConfiguration  上下文配置注解，指定配置文件（Java类或XML文件）的位置
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@ContextConfiguration(classes = CarConfig.class) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载Java配置类的方式&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; @ContextConfiguration(locations = &quot;classpath:resource/applicationContext.xml&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载XML配置的方式&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarTest {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; QQCar car ;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; carTest(){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        assertNotNull(car);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;虽然现在的编程趋势是越来越多的使用Java注解的方式，但是上面的测试你会发现，通过XML注解的方式能够测试成功，而Java注解的方式却是失败的，测试会抛出NoSuchBeanDefinitionException的异常，表示没有QQCar的组件定义，也就是Spring没有发现它，Why? 原因也很简单，那就是&lt;strong&gt;基于Java注解的方式启动的注解扫描默认情况下只能扫描配置类所在的包以及其的子包&lt;/strong&gt;，如果要明确扫描其它包中的组件，需要在启动扫描的注解 @ComponetScan 中显示的注明，如&lt;span&gt;改成 @ComponentScan(&quot;spring.impl&quot;)，上诉的测试就能通过了。如果有多个包要扫描，可以这样配置：&lt;span class=&quot;cnblogs_code&quot;&gt;@ComponentScan(basePackages = {&quot;spring.impl&quot;,&quot;spring.test&quot;})&lt;/span&gt;  不过这样字符串的表示方式是类型不安全的，而且写死包名的方式不利于代码重构，我们可以指定包中所含的类或接口来指定要扫描的包，于是可以这样标注: &lt;span class=&quot;cnblogs_code&quot;&gt;@ComponentScan(basePackageClasses = QQCar.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt; ,多个包同样可以用{}来以数组形式的表示。不过这样对重构依然不友好，最好的方式就是在要扫描的包中定义一个空标接口，该接口仅仅用来指定包扫描的范围，如此将重构的影响降到最低。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;　　自动装配&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　前文的讲述只是阐明如何将一个类定义成Spring的组件并启动Spring的组件扫描，而且我们已经通过测试证实，Spring确实扫描到了我们指定的组件类并为我们创建了对象。不过，创建的对象只是独立的存在，并没有和其他对象产生依赖协作；实际应用中，对象之间的依赖协作是再常见不过了，而要将Spring通过组件扫描为我们创建的对象根据实际业务建立起相互的依赖协作，就需要利用Spring的&lt;strong&gt;自动装配&lt;/strong&gt;。便于演示，我们再定义一个Man类,Man的工作就是开车,我们先通过构造器注入的方式来满足依赖，看Spring是否会给我们自动注入我们需要的Car的实例对象——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man() {
    }

    @Autowired
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man(QQCar car) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
        car.drive();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;测试方法——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.config.CarConfig;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.impl.Man;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; @ContextConfiguration(classes = CarConfig.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarTest {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    Man man;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; carTest() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        man.work();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;如以上代码，测试当然是成功的，在测试类中，Man作为组件类被Spring扫描并创建了一个对象实例，该实例调用work方法的时候，需要Car的实例对象，而我们在有参构造函数上通过 @Autowired 注解表明了对象的依赖关系，程序运行过程中，Spring会自动为我们注入Car的实例对象来满足对象依赖，这就是自动装配的精要所在。实际上，&lt;strong&gt;不只是构造器上可以用 @Autowired 注解，在属性的Setter方法上，甚至普通的方法上，都可以用@Autowired 注解来满足对象之间的依赖&lt;/strong&gt;，实现自动注入的功能——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造器实现自动装配
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Autowired&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man(QQCar car) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Setter方法实现自动装配
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; @Autowired&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCar(QQCar car) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通方法实现自动装配&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insertCar(QQCar car) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        car.drive();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;我们将Man类中添加不同的方法测试，依然是可以成功的。不过有一点要注意，在非构造器实现自动装配的时候，虽然我们没有自己new对象，但Spring创建实例会通过Man的默认的构造器，此时的Man类中如果定义了有参构造器，就一定要把默认构造器构造出来，不然会抛无默认构造器的异常，&lt;strong&gt;记住：一定养成类中写默认构造器的习惯，便于扩展。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;　　自动装配的歧义性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　  如果你足够细心，你会发现博主上面满足自动装配的测试代码中，注入的Car并没有采用多态的写法，代码显得很低级。其实我是为了测试通过，故意注入了具体的实现，实际业务中当然不会这么局限的去写代码。因为博主Car的接口还有一个奔驰车的实现类BenzCar，如果用多态的写法，自动装配会有产生歧义性问题，会抛 NoUniqueBeanDefinitionException 异常。那么，面对这种歧义性，如何去解决呢？你一定知道Spring容器管理的每个bean都会有一个ID作为唯一标识，在上面的示例中，我们描述QQCar类为Spring的组件的时候并没有明确的设置ID,但是&lt;strong&gt;Spring默认会将组件类的类名首字母小写来作为bean的ID&lt;/strong&gt;,而我们也可根据我们自己的业务需要自定义ID标识——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;span&gt; spring.impl;

&lt;span&gt;import&lt;span&gt; org.springframework.stereotype.Component;
&lt;span&gt;import&lt;span&gt; spring.facade.Car;
&lt;span&gt;//&lt;span&gt;这里指定 chenbenbuyi 为组件的ID 
@Component(&quot;chenbenbuyi&quot;&lt;span&gt;)
&lt;span&gt;public &lt;span&gt;class QQCar &lt;span&gt;implements&lt;span&gt; Car {
    @Override
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; drive() {
        System.out.println(&quot;开QQ车&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　可是测试发现，这并没有解决接口参数在自动装配时的歧义性问题，因为在组件上自定义ID是一种后发行为，当你让Spring在装配阶段从多个接口实现中选择要自动注入的对象实例时，Spring无法选择——就好比你只跟我说你要开一辆车，每辆车也都有唯一的车牌号，但我还是不知道你要开什么车。怎么办呢？这里有多种解决方案，我们可以通过 @Primary注解将我们明确需要自动注入的实现类标注为首选的bean，就想这样——&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Primary;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Primary
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzCar &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;开奔驰车&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;当自动装配的时候，Spring面对歧义性时，会优先选择被标注为首选的bean进行自动注入。当然，我们还可以采用限定符注解，在使用@Autowired 完成自动装配的时候限定只让某个bean作为自动注入的bean——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; spring.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; spring.facade.Car;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Man {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car car;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Man() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通方法实现自动装配&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     @Qualifier(&quot;chenbenbuyi&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;限定ID为 chenbenbuyi 的bean被装配进来&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; insertCar(Car car) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.car =&lt;span&gt; car;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        car.drive();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;span&gt;自&lt;/span&gt;&lt;span&gt;此，关于Spring的自动装配就阐述得差不多了，下一节系列文章会接着讲解Spring的另外两种常用的装配机制——&lt;span&gt;Java注解和XML配置。博文所述皆为原创，如要转载，请注明出处；如果阐述得不恰当的地方，欢迎指教，不胜感激。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 15:17:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/8245495.html</dc:identifier>
</item>
<item>
<title>解决AspNet Zero Core 5.0.1无法运行的问题 - Smile.X</title>
<link>http://www.cnblogs.com/xajh/p/8428818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xajh/p/8428818.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　最近在研究AspNet Zero Core 5.0.1时发现VS点击调试后就自动退出了，从ABP QQ群里得知作者加入了licensecode校验。经过一个周左右断断续续的折腾，算是破解了吧。原本想把加密类完全反编译出来，后来发现有些方法反编译不过来，所以有些方法就直接注释掉实现了(关键方法未能反编译，比较遗憾)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#Introduction&quot;&gt;一、说明&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#runeffect&quot;&gt;二、运行效果&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#tools&quot;&gt;三、工具软件&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#Decompile&quot;&gt;四、反编译过程&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;a href=&quot;http://www.cnblogs.com/xajh/p/8428818.html#GithubAddress&quot;&gt;五、源码Github地址&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一&lt;span&gt;、说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;如果对反编译不感兴趣的话，可以直接从github下载下来源码之后，把ABP文件下的两个工程Abp.AspNetZeroCore、Abp.AspNetZeroCore.Web编译一下拿到dll直接将AspNet Zero Core 5.0.1工程里的对应引用替换掉就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　拿到AspNet Zero Core 5.0.1源码后会发现有两个应用的dll在ABP github上是没有源码的，一个是在工程MyCompanyName.AbpZeroTemplate.Core里引用的Abp.AspNetZeroCore，另一个是在工程MyCompanyName.AbpZeroTemplate.Web.Core里引用的Abp.AspNetZeroCore.Web。分析之后做校验的代码在Abp.AspNetZeroCore这个dll中，具体方法为AbpAspNetZeroCoreModule类的PostInitialize方法中调用了另一个类AspNetZeroLicenseChecker的Check方法，破解的话直接将PostInitialize注释掉或去掉Check方法中的代码实现即可。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180209222724982-1831700046.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、&lt;strong&gt;运行效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;破解后的软件运行截图，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207225623123-516155359.jpg&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;395&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　前端界面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207225927873-1098425656.jpg&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;399&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、工具软件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　反编译过程中，我使用了两个软件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.Resharper套件之一，JetBrains dotPeek 2017.3.2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.ILSpy version 3.0.1.3459。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、反编译过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4.1.找到他们&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　取得源码用VS还原nuget包之后，会在系统盘目录(C:\Users\Administrator\.nuget\packages)中找到这两个dll(Abp.AspNetZeroCore.dll,Abp.AspNetZeroCore.Web.dll)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207232436216-1950758597.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;168&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4.2 使用dotPeek反编译并导出工程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　将两个dll使用dotPeek反编译，然后在dotPeek的程序集管理其中，选中工程在右键菜单中选择Export to Project&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207232749123-191114321.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;241&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　反编译完成之后比较尴尬的是生成工程的.net版本为.net framework 2.0，我们自己创建个.Net Standard工程然后把反编译出来的文件拷贝到创建的解决方案里就可以了。两个dll的处理方法类似。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　工程建立完之后引入到源代码里，引入之后我的工程目录结构如下所示，为了调试方便我把对ABP类库的引用都替换成了源代码工程引用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207234034904-1607781476.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;     4.3  反编译Abp.AspNetZeroCore.Web.dll&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这个dll比较简单，先从简单的入手吧，这个dll中主要就反编译一个类就可以了，如下图 　&lt;/span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207234453763-669434181.png&quot; alt=&quot;&quot; width=&quot;900&quot; height=&quot;413&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　这个类中4,5两处没看明白有什么用途，直接删掉了；2,3两处其实就是对应类实例的属性所以ctx.set_User(authenticateResult.get_Principal())直接改为ctx.User=val.Principal，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　authenticateResult.get_Succeeded() &amp;amp;&amp;amp; authenticateResult.get_Principal() != null直接改为val.Succeeded &amp;amp;&amp;amp; val.Principal != null。return 语句UseExtensions.Use这块儿实际&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上是方法参数app的扩展方法。所以整段代码整理之后如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207235052857-1653214729.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个dll主要反编译这一个类就可以了，其他反编译的类不需要做额外处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  4.4 反编译Abp.AspNetZeroCore.dll&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　这个就比较费劲了，一是代码量大，二是有些代码没看懂怎么反编译，这个dll主要反编译下面两个类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180207235343888-912342492.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  先看AspNetZeroBaseLicenseChecker这个类，这个类是AspNetZeroLicenseChecker类的基类，拿类的构造函数当 典型说一下一些个人的经验吧，未调整的反编译代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180209215106170-15585835.png&quot; alt=&quot;&quot; width=&quot;1051&quot; height=&quot;655&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对照上图标记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.这个特性暂未发现有什么用处，直接去掉；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.这个方法有对应的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;   [MethodImpl(MethodImplOptions.NoInlining)]
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; iZ5hxHC38E0NlGy6Ai([In] &lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj0)
    {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;object&lt;/span&gt;&lt;span&gt;) ((AspNetZeroConfiguration) obj0).LicenseCode;
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　实际上就是获取了调用参数的一个特性，所以可以直接修改为  this.LicenseCode = configuration.LicenseCode;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.这个循环稍微麻烦一点，按照执行步骤一步一步走就行了，名字混淆的方法直接用方法实现替换，这种代码少的好一些，理不乱，有些很长就有点儿头疼了，这整段代码搞来搞去其实就是两句，整理后的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;protected&lt;/span&gt; AspNetZeroBaseLicenseChecker(AspNetZeroConfiguration configuration, IAbpZeroConfig abpZeroConfig, &lt;span&gt;string&lt;/span&gt; configFilePath = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.LicenseCode =&lt;span&gt; configuration.LicenseCode;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._abpZeroConfig =&lt;span&gt; abpZeroConfig;
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其他的方法都可以按类似方式处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　AspNetZeroLicenseChecker这个类反编译方法类似，但是这个类中的Check方法就搞不定了，dotPeek反编译后的代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/158665/201802/158665-20180209220842263-695249057.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　红色方框中圈住的部分实在搞不懂是怎么回事儿。各位园友如果有思路的话，可以提供一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、源码Github地址&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;反编译后的代码放到github上了，有兴趣的朋友可以下载下来研究一下，&lt;span&gt;&lt;strong&gt;有问题欢迎留言讨论&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;https://github.com/YSmileX/AspNetZeroCore&quot; target=&quot;_blank&quot;&gt;https://github.com/YSmileX/AspNetZeroCore&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 09 Feb 2018 14:45:00 +0000</pubDate>
<dc:creator>Smile.X</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xajh/p/8428818.html</dc:identifier>
</item>
<item>
<title>python中的线程 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/8437027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/8437027.html</guid>
<description>&lt;h2 id=&quot;线程的创建&quot;&gt;1.线程的创建&lt;/h2&gt;
&lt;h3 id=&quot;通过thread类直接创建&quot;&gt;1.1 通过&lt;code&gt;thread&lt;/code&gt;类直接创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;,n)
    
    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;,n)
    
    s1=time.time()
    
    #创建一个线程实例t1,foo为这个线程要运行的函数
    t1=threading.Thread(target=foo,args=(3,))
    t1.start()    #启动线程t1
    
    #创建一个线程实例t2,bar为这个线程要运行的函数
    t2=threading.Thread(target=bar,args=(5,))
    t2.start()    #启动线程t2
    
    print(&quot;ending&quot;)
    
    s2=time.time()
    
    print(&quot;cost time:&quot;,s2-s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段程序里，一个函数会先休眠几秒钟，然后再打印一句话，第二个函数也是先休眠几秒钟，然后打印一句话。&lt;/p&gt;
&lt;p&gt;接着程序会实例化两个线程，并调用两个函数来执行，最后会打印程序问总共执行了多少时间&lt;/p&gt;
&lt;p&gt;程序运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ending
cost time: 0.002000093460083008
foo func: 3
bar func: 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序会先运行父线程，打印&lt;code&gt;&quot;ending&quot;&lt;/code&gt;,然后打印程序执行父线程的时间，最后才会运行子线程&lt;/p&gt;
&lt;h3 id=&quot;通过thread类来继承式创建&quot;&gt;1.2 通过&lt;code&gt;thread&lt;/code&gt;类来继承式创建&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    # 定义MyThread类，其继承自threading.Thread这个父类
    class MyThread(threading.Thread): 
    
        def __init__(self):
            threading.Thread.__init__(self)
    
        def run(self):
            print(&quot;ok&quot;)
            time.sleep(2)
            print(&quot;end t1&quot;)
    
    # 对类进行实例化
    t1=MyThread()
    
    # 启动线程
    t1.start()
    print(&quot;ending&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;thread类的一些常用方法&quot;&gt;2. Thread类的一些常用方法&lt;/h2&gt;
&lt;h3 id=&quot;join在子线程完成之前主线程将一直被阻塞&quot;&gt;2.1 &lt;code&gt;join()&lt;/code&gt;:在子线程完成之前，主线程将一直被阻塞****&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;线程的join方法必须在子线程的start方法之后定义&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在第一个例子中加入两行代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    
    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;,n)
    
    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;,n)
    
    s1=time.time()
    t1=threading.Thread(target=foo,args=(3,))
    t1.start()
    
    t2=threading.Thread(target=bar,args=(5,))
    t2.start()
    
    t1.join()       # 阻塞t1线程
    t2.join()       # 阻塞t2线程
    
    print(&quot;ending&quot;)
    s2=time.time()
    
    print(&quot;cost time:&quot;,s2-s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次执行程序，运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foo func: 3
bar func: 5
ending
cost time: 5.002285957336426&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行到子线程t1中的foo方法时会睡眠3秒钟，与此同时，子线程t2也在睡眠&lt;/p&gt;
&lt;p&gt;等到子线程t1睡眠完成后，开始打印foo函数中的print语句，然后子线程t1执行完成&lt;/p&gt;
&lt;p&gt;2秒钟之后，子线程t2睡眠完成，开始打印bar函数中的print语句，然后子线程t2也执行完成。&lt;/p&gt;
&lt;p&gt;而在这之前，主线程一直处于阻塞状态。等到子线程执行完成之后主线程才会执行&lt;/p&gt;
&lt;h3 id=&quot;setdeamontrue&quot;&gt;2.2 setDeamon(True)&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;setDaemon方法作用是将进程声明为守护线程，必须在`start()`方法调用之前，&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不设置为守护线程，程序会被无限挂起&lt;/p&gt;
&lt;p&gt;在程序执行过程中，执行一个主线程，主线程又创建一个子线程时，主线程和子线程会分别运行。&lt;/p&gt;
&lt;p&gt;当主线程运行完成时，会检验子线程是否执行完成，如果子线程执行完成，则主线程会等待子线程完成后再退出。&lt;/p&gt;
&lt;p&gt;但是有的时候只要主线程执行完成之后，不管子线程是否执行完成，都和主线程一起退出，这个就需要调用&lt;code&gt;setDeamon&lt;/code&gt;方法了。&lt;/p&gt;
&lt;p&gt;拿第一个例子来说吧，现在我想让子线程t1和t2随同主线程关闭，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    def foo(n):
        print(&quot;foo start&quot;)
        time.sleep(n)
        print(&quot;foo end...&quot;)
    
    def bar(n):
        print(&quot;bar start&quot;)
        time.sleep(n)
        print(&quot;bar end...&quot;)
    
    s1 = time.time()
    t1 = threading.Thread(target=foo, args=(3,))
    t1.setDaemon(True)
    t1.start()
    
    t2 = threading.Thread(target=bar, args=(5,))
    t2.setDaemon(True)
    t2.start()
    
    print(&quot;ending&quot;)
    s2 = time.time()
    
    print(&quot;cost time:&quot;, s2 - s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行结果如下 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;foo start
bar start
ending
cost time: 0.003000020980834961&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，把t1和t2都声明为守护线程后，程序自上而下执行，先执行子线程t1中的foo方法，打印foo函数中的第一条打印语句，然后子线程t1进入到睡眠状态。&lt;/p&gt;
&lt;p&gt;然后子线程t2执行，打印bar函数中的第一条print语句，然后子线程t2进入睡眠状态，程序切换到主线程运行&lt;/p&gt;
&lt;p&gt;主线程打印完&quot;ending&quot;语句，发现子线程t1和t2已经被设置为守护线程，所以主线程不需要再等待两个子线程执行完成，而是立即结束，打印整个程序的执行时间。&lt;/p&gt;
&lt;p&gt;整个程序就跟随主线程一起关闭了。&lt;/p&gt;
&lt;h3 id=&quot;子线程的一些其他方法&quot;&gt;2.3 子线程的一些其他方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;isAlive()           #判断一个线程是否是活动线程
getName()           #返回线程的名字
setName()           #设置线程的名字&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time
    
    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;, n)
    
    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;, n)
    
    s1 = time.time()
    t1 = threading.Thread(target=foo, args=(3,))
    t1.setDaemon(True)
    
    print(&quot;线程还未启动时，判断t1是否是活动的线程：&quot;, t1.isAlive())  # 线程还未启动，所以是False
    t1.start()  # 启动线程
    print(&quot;线程已启动时，判断t1是否是活动的线程：&quot;, t1.isAlive())  # 线程已启动，所以是True
    print(&quot;修改前的线程名为：&quot;,t1.getName())  # 获取线程名
    t1.setName(&quot;t1&quot;)        #设置线程名
    print(&quot;修改后的线程名为：&quot;,t1.getName())  # 获取线程名
    
    t1.join()
    
    print(&quot;线程执行完成时，判断t1是不否是活动的线程：&quot;, t1.isAlive())  # 线程已执行完成，所以是False
    
    # print(threading.activeCount())
    print(&quot;ending&quot;)
    s2 = time.time()
    
    print(&quot;cost time:&quot;, s2 - s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;线程还未启动时，判断t1是否是活动的线程： False
线程已启动时，判断t1是否是活动的线程： True
修改前的线程名为： Thread-1
修改后的线程名为： t1
foo func: 3
线程执行完成时，判断t1是不否是活动的线程： False
ending
cost time: 3.001171588897705&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;threading模块提供的一些方法&quot;&gt;3.threading模块提供的一些方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;threading.currentThread()   #返回当前的线程变量
threading.enumerate()       #返回一个包含正在运行的线程的列表，不包括启动前和终止后的线程
threading.activeCount()     #返回正在运行的线程数量，等同于len(threading.enumerate())&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    import threading
    import time

    def foo(n):
        time.sleep(n)
        print(&quot;foo func:&quot;, n)

    def bar(n):
        time.sleep(n)
        print(&quot;bar func:&quot;, n)

    s1 = time.time()
    t1 = threading.Thread(target=foo, args=(3,))
    t1.setDaemon(True)
    t1.start()

    t2 = threading.Thread(target=bar, args=(5,))
    t2.setDaemon(True)
    t2.start()

    print(&quot;程序中正在运行的线程数量：&quot;,threading.activeCount())
    print(&quot;程序中当前的线程变量：&quot;,threading.currentThread())
    print(&quot;当前正在运行的线程的列表：&quot;,threading.enumerate())
    print(&quot;ending&quot;)
    s2 = time.time()

    print(&quot;cost time:&quot;, s2 - s1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;程序中正在运行的线程数量： 3
程序中当前的线程变量： &amp;lt;_MainThread(MainThread, started 7064)&amp;gt;
当前正在运行的线程的列表： [&amp;lt;_MainThread(MainThread, started 7064)&amp;gt;, &amp;lt;Thread(Thread-1, started daemon 6384)&amp;gt;, &amp;lt;Thread(Thread-2, started daemon 2640)&amp;gt;]
ending
cost time: 0.002000093460083008&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 09 Feb 2018 14:26:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/8437027.html</dc:identifier>
</item>
<item>
<title>[搬运] DotNetAnywhere:可供选择的 .NET 运行时 - 张很水</title>
<link>http://www.cnblogs.com/chenug/p/8436819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenug/p/8436819.html</guid>
<description>&lt;blockquote readability=&quot;1.5760869565217&quot;&gt;
&lt;p&gt;原文 : &lt;a href=&quot;http://mattwarren.org/2017/10/19/DotNetAnywhere-an-Alternative-.NET-Runtime/&quot;&gt;DotNetAnywhere: An Alternative .NET Runtime&lt;/a&gt;&lt;br/&gt;作者 : &lt;a href=&quot;https://github.com/mattwarren/&quot;&gt;Matt Warren&lt;/a&gt;&lt;br/&gt;译者 : &lt;a href=&quot;https://www.jianshu.com/u/910143584bd2&quot;&gt;张很水&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我最近在收听一个名为&lt;a href=&quot;https://www.dotnetrocks.com/&quot;&gt;DotNetRock&lt;/a&gt; 的优质播客，其中有以&lt;a href=&quot;http://knockoutjs.com/&quot;&gt;Knockout.js&lt;/a&gt;而闻名的&lt;a href=&quot;https://twitter.com/stevensanderson&quot;&gt;Steven Sanderson&lt;/a&gt; 正在讨论 &lt;a href=&quot;https://www.dotnetrocks.com/?show=1455&quot;&gt;&quot; WebAssembly And Blazor &quot;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;也许你还没听过，&lt;a href=&quot;https://github.com/SteveSanderson/Blazor&quot;&gt;Blazor&lt;/a&gt; 正试图凭借&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;的魔力将 .NET 带入到浏览器中。如果您想了解更多信息，Scott Hanselmen 已经在 &lt;a href=&quot;https://www.hanselman.com/blog/NETAndWebAssemblyIsThisTheFutureOfTheFrontend.aspx&quot;&gt;&quot; .NET和WebAssembly——这会是前端的未来吗? &quot;&lt;/a&gt;一文中做了一番介绍。( 点击查看该文的&lt;a href=&quot;http://geek.csdn.net/news/detail/233214&quot;&gt;翻译&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;尽管 WebAssembly 非常酷炫，然而更让我感兴趣的是 Blazor 如何使用&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere&quot;&gt;DotNetAnywhere&lt;/a&gt;作为底层的 .NET 运行时。本文将讨论DotNetAnywhere 是什么，能做什么，以及同完整的 .NET Framework 做比较。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;首先值得指出的是，DotNetAnywhere (DNA) 被设计为一个完全兼容的 .NET 运行时，可以运行被完整的.NET 框架编译的 dll 和 exe 。除此之外 (至少在理论上) &lt;strong&gt;支持&lt;/strong&gt; 以下的&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere#supported-net-runtime-features&quot;&gt;.NET 运行时的功能&lt;/a&gt;，真是令人激动!&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;泛型&lt;/li&gt;
&lt;li&gt;垃圾收集和析构&lt;/li&gt;
&lt;li&gt;弱引用&lt;/li&gt;
&lt;li&gt;完整的异常处理 - try/catch/finally&lt;/li&gt;
&lt;li&gt;PInvoke&lt;/li&gt;
&lt;li&gt;接口&lt;/li&gt;
&lt;li&gt;委托&lt;/li&gt;
&lt;li&gt;事件&lt;/li&gt;
&lt;li&gt;可空类型&lt;/li&gt;
&lt;li&gt;一维数组&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;另外对于&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection&quot;&gt;反射&lt;/a&gt;提供&lt;strong&gt;部分支持&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;非常有限的只读方法&lt;br/&gt;typeof(), GetType(), Type.Name, Type.Namespace, Type.IsEnum(),&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;最后，还有一些目前不支持的功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;属性&lt;/li&gt;
&lt;li&gt;大部分的反射方法&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;li&gt;Unsafe 代码&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/issues?q=is%3Aissue+is%3Aclosed&quot;&gt;各种各样的错误或缺少的功能&lt;/a&gt;可能会让代码无法在 DotNetAnywhere下运行，但其中一些已经被&lt;a href=&quot;https://github.com/SteveSanderson/Blazor/pulls?utf8=%E2%9C%93&amp;amp;q=is:pr&quot;&gt;Blazor 修复&lt;/a&gt;，所以值得时不时检查 Blazor 的发布版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如今，DotNetAnywhere 的原始仓库&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere#this-project-is-inactive-no-issues-or-prs-will-be-dealt-with&quot;&gt;不再活跃&lt;/a&gt; (最后一个持续的活动是在2012年1月)，所以未来任何的开发或错误修复都可能在 Blazor 的仓库中执行。如果你曾经在 DotNetAnywhere 中修复过某些东西，可以考虑在那里发一个PR。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新：&lt;/strong&gt;还有其他版本的各种错误修复和增强：&lt;/p&gt;

&lt;p&gt;我觉得 DotNetAnywhere 运行时最令人印象深刻的一点是 &lt;strong&gt;只由一个人开发&lt;/strong&gt;，并且 &lt;strong&gt;只用了 40,000 行代码&lt;/strong&gt;！反观，完整的 .NET 框架仅是垃圾收集器就&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/gc/gc.cpp&quot;&gt;有将近37000 行代码&lt;/a&gt; ( 更多信息请我之前发布的&lt;a href=&quot;http://mattwarren.org/2017/03/23/Hitchhikers-Guide-to-the-CoreCLR-Source-Code/#overall-stats&quot;&gt;CoreCLR 源代码漫游指南&lt;/a&gt; )。&lt;/p&gt;
&lt;h2 id=&quot;机器码---共-17710-行&quot;&gt;机器码 - 共 17,710 行&lt;/h2&gt;
&lt;h2 id=&quot;托管代码---共-28783-行&quot;&gt;托管代码 - 共 28,783 行&lt;/h2&gt;
&lt;h2 id=&quot;关键组件&quot;&gt;关键组件&lt;/h2&gt;
&lt;p&gt;接下来，让我们看一下 DotNetAnywhere 中的关键组件，正是我们了解怎么兼容 .NET 运行时的好办法。同样我们也能看到它与微软 .NET Framework 的差异。&lt;/p&gt;
&lt;h2 id=&quot;加载-.net-dll&quot;&gt;加载 .NET dll&lt;/h2&gt;
&lt;p&gt;DotNetAnywhere 所要做的第一件事就是加载、解析包含在 .dll 或者.exe 中的 &lt;strong&gt;元数据和代码。&lt;/strong&gt;这一切都存放在&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/MetaData.c&quot;&gt;MetaData.c&lt;/a&gt;中，主要是在&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/MetaData.c#L302-L484&quot;&gt;LoadSingleTable(..)&lt;/a&gt; 函数中。通过添加一些调试代码，我能够从一般的 .NET dll 中获取所有类型的 &lt;strong&gt;元数据&lt;/strong&gt; 摘要，这是一个非常有趣的列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MetaData contains     1 Assemblies (MD_TABLE_ASSEMBLY)
MetaData contains     1 Assembly References (MD_TABLE_ASSEMBLYREF)
MetaData contains     0 Module References (MD_TABLE_MODULEREF)

MetaData contains    40 Type References (MD_TABLE_TYPEREF)
MetaData contains    13 Type Definitions (MD_TABLE_TYPEDEF)
MetaData contains    14 Type Specifications (MD_TABLE_TYPESPEC)
MetaData contains     5 Nested Classes (MD_TABLE_NESTEDCLASS)

MetaData contains    11 Field Definitions (MD_TABLE_FIELDDEF)
MetaData contains     0 Field RVA's (MD_TABLE_FIELDRVA)
MetaData contains     2 Propeties (MD_TABLE_PROPERTY)
MetaData contains    59 Member References (MD_TABLE_MEMBERREF)
MetaData contains     2 Constants (MD_TABLE_CONSTANT)

MetaData contains    35 Method Definitions (MD_TABLE_METHODDEF)
MetaData contains     5 Method Specifications (MD_TABLE_METHODSPEC)
MetaData contains     4 Method Semantics (MD_TABLE_PROPERTY)
MetaData contains     0 Method Implementations (MD_TABLE_METHODIMPL)
MetaData contains    22 Parameters (MD_TABLE_PARAM)

MetaData contains     2 Interface Implementations (MD_TABLE_INTERFACEIMPL)
MetaData contains     0 Implementation Maps? (MD_TABLE_IMPLMAP)

MetaData contains     2 Generic Parameters (MD_TABLE_GENERICPARAM)
MetaData contains     1 Generic Parameter Constraints (MD_TABLE_GENERICPARAMCONSTRAINT)

MetaData contains    22 Custom Attributes (MD_TABLE_CUSTOMATTRIBUTE)
MetaData contains     0 Security Info Items? (MD_TABLE_DECLSECURITY)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多关于 &lt;strong&gt;元数据&lt;/strong&gt; 的资料请参阅 &lt;a href=&quot;https://iobservable.net/blog/2013/05/12/introduction-to-clr-metadata/&quot;&gt;介绍 CLR 元数据&lt;/a&gt;，&lt;a href=&quot;https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-pe-headers/&quot;&gt;解析.NET 程序集—–关于 PE 头文件&lt;/a&gt; 和 &lt;a href=&quot;https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/&quot;&gt;ECMA 标准&lt;/a&gt; 等文章。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;执行-.net-il&quot;&gt;执行 .NET IL&lt;/h2&gt;
&lt;p&gt;DotNetAnywhere 的另一大功能是 &quot;即时编译器&quot; (JIT)，即执行 IL 的代码，从 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT_Execute.c&quot;&gt;JIT_Execute.c&lt;/a&gt;和&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT.c&quot;&gt;JIT.c&lt;/a&gt; 中开始执行。在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT.c#L232-L1606&quot;&gt;JITit(..) 函数&lt;/a&gt; 的主入口中 &quot;执行循环&quot;，其中最令人印象深刻的是在一个 1,374 行代码的 &lt;code&gt;switch&lt;/code&gt; 中就有 200 多个 &lt;code&gt;case&lt;/code&gt; !!&lt;/p&gt;
&lt;p&gt;从更高的层面看，它所经历的整个过程如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-5d0ebf77d8b76dd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;NET IL - DNA JIT Op-Codes&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与定义在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/CIL_OpCodes.h&quot;&gt;CIL_OpCodes.h&lt;/a&gt; (&lt;code&gt;CIL_XXX&lt;/code&gt;) .NET IL 操作码 ( Op-Codes)  不同，DotNetAnywhere JIT 操作码 (Op-Codes) 是定义在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT_OpCodes.h&quot;&gt;JIT_OpCodes.h&lt;/a&gt; (&lt;code&gt;JIT_XXX&lt;/code&gt;)中。&lt;/p&gt;
&lt;p&gt;有趣的是这部分 JIT 代码是 DotNetAnywhere 中唯一一处&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT_Execute.c#L184-L204&quot;&gt;使用汇编编写&lt;/a&gt; ，并且只是 &lt;code&gt;win32&lt;/code&gt; 。 它允许使用 &lt;code&gt;jump&lt;/code&gt; 或者 &lt;code&gt;goto&lt;/code&gt; 在 C 源码中跳转标签,所以当 IL 指令被执行时，实际上并不会离开 &lt;code&gt;JITit(..)&lt;/code&gt; 函数，控制（流程）只是从一处移动到别处，不必进行完整的方法调用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#ifdef __GNUC__

#define GET_LABEL(var, label) var = &amp;amp;&amp;amp;label

#define GO_NEXT() goto **(void**)(pCurOp++)

#else
#ifdef WIN32

#define GET_LABEL(var, label) \
    { __asm mov edi, label \
    __asm mov var, edi }

#define GO_NEXT() \
    { __asm mov edi, pCurOp \
    __asm add edi, 4 \
    __asm mov pCurOp, edi \
    __asm jmp DWORD PTR [edi - 4] }

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;il-差异&quot;&gt;IL 差异&lt;/h2&gt;
&lt;p&gt;在完整的 .NET framework 中，所有的 IL 代码在被 CPU 执行之前都是由  &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md&quot;&gt;Just-in-Time Compiler (JIT)&lt;/a&gt; 转换为机器码。&lt;/p&gt;
&lt;p&gt;如你所见, DotNetAnywhere &quot;解释&quot; (interprets) IL时是逐条执行指令，甚至会调用 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/JIT.c&quot;&gt;JIT.c&lt;/a&gt; 文件来完成。 &lt;strong&gt;没有机器码&lt;/strong&gt; 被反射发出 (emitted) ,所以这个命名还是有点奇怪!?&lt;/p&gt;
&lt;p&gt;或许这只是一个差异，但实在是无法让我搞清楚它是如何进行 &quot;解释&quot; (interpreting) 代码和 &quot;即时编译&quot; (JITting)，即使我再阅读完下面的文章还是不得其解!! (有人能指教一下吗?)&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h2&gt;
&lt;p&gt;所有关于 DotNetAnywhere 的垃圾回收(GC) 代码都在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c&quot;&gt;Heap.c&lt;/a&gt; 中，而且还是 600 行易于阅读的代码。给你一个概览吧，下面是它暴露的函数列表:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void Heap_Init();
void Heap_SetRoots(tHeapRoots *pHeapRoots, void *pRoots, U32 sizeInBytes);
void Heap_UnmarkFinalizer(HEAP_PTR heapPtr);
void Heap_GarbageCollect();
U32 Heap_NumCollections();
U32 Heap_GetTotalMemory();

HEAP_PTR Heap_Alloc(tMD_TypeDef *pTypeDef, U32 size);
HEAP_PTR Heap_AllocType(tMD_TypeDef *pTypeDef);
void Heap_MakeUndeletable(HEAP_PTR heapEntry);
void Heap_MakeDeletable(HEAP_PTR heapEntry);

tMD_TypeDef* Heap_GetType(HEAP_PTR heapEntry);

HEAP_PTR Heap_Box(tMD_TypeDef *pType, PTR pMem);
HEAP_PTR Heap_Clone(HEAP_PTR obj);

U32 Heap_SyncTryEnter(HEAP_PTR obj);
U32 Heap_SyncExit(HEAP_PTR obj);

HEAP_PTR Heap_SetWeakRefTarget(HEAP_PTR target, HEAP_PTR weakRef);
HEAP_PTR* Heap_GetWeakRefAddress(HEAP_PTR target);
void Heap_RemovedWeakRefTarget(HEAP_PTR target);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gc-差异&quot;&gt;GC 差异&lt;/h2&gt;
&lt;p&gt;就像我们对比 JIT/Interpreter 一样, 在 GC 上的差异同样可见。&lt;/p&gt;
&lt;h4 id=&quot;conservative-gc&quot;&gt;Conservative GC&lt;/h4&gt;
&lt;p&gt;首先，DotNetAnywhere 的 GC 是 &lt;a href=&quot;https://stackoverflow.com/questions/7629446/conservative-garbage-collector&quot;&gt;Conservative GC&lt;/a&gt;。简单地说，这意味着它不知道 (或者说肯定) 内存的哪些区域是对象的引用/指针，还是一个随机数 (看起来像内存地址)。而在.NET Framework 中 JIT 收集这些信息并存在&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/inc/gcinfo.h&quot;&gt;GCInfo structure&lt;/a&gt;中，所以它的 GC 可以有效利用，而 DotNetAnywhere 是做不到。&lt;/p&gt;
&lt;p&gt;相反, 在 &lt;code&gt;标记(Mark)&lt;/code&gt; 的阶段，GC &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c#L278-L345&quot;&gt;获取所有可用的 &quot; 根 (roots) &quot;&lt;/a&gt;, 将一个对象中的所有内存地址视为 &quot;潜在的&quot; 引用(因此说它是 &quot;&lt;em&gt;conservative&lt;/em&gt;&quot;)。然后它必须查找每个可能的引用，看看它是否真的指向 &quot;对象的引用&quot;。通过跟踪 &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_andersson.aspx&quot;&gt;平衡二叉搜索树&lt;/a&gt; (按内存地址排序) 来执行操作, 流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-c000e860ea48b322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Binary Tree with Pointers into the Heap&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这意味着所有的对象引用在分配时都必须存储在二叉树中，这会增加分配的开销。另外还需要额外的内存，每个堆多占用 20 个字节。我们看看 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c#L58-L83&quot;&gt;&lt;code&gt;tHeapEntry&lt;/code&gt; 的数据结构&lt;/a&gt; (所有的指针占用 4 字节, &lt;code&gt;U8&lt;/code&gt; 等于 1 字节，而 &lt;code&gt;padding&lt;/code&gt; 可忽略不计)， &lt;code&gt;tHeapEntry *pLink[2]&lt;/code&gt; 是启用二叉树查找所需的额外数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct tHeapEntry_ {
    // Left/right links in the heap binary tree
    tHeapEntry *pLink[2];
    // The 'level' of this node. Leaf nodes have lowest level
    U8 level;
    // Used to mark that this node is still in use.
    // If this is set to 0xff, then this heap entry is undeletable.
    U8 marked;
    // Set to 1 if the Finalizer needs to be run.
    // Set to 2 if this has been added to the Finalizer queue
    // Set to 0 when the Finalizer has been run (or there is no Finalizer in the first place)
    // Only set on types that have a Finalizer
    U8 needToFinalize;
    
    // unused
    U8 padding;

    // The type in this heap entry
    tMD_TypeDef *pTypeDef;

    // Used for locking sync, and tracking WeakReference that point to this object
    tSync *pSync;

    // The user memory
    U8 memory[0];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么 DotNetAnywhere 这样做呢?   DotNetAnywhere的作者&lt;a href=&quot;https://github.com/chrisdunelm&quot;&gt;Chris Bacon&lt;/a&gt; 是这样 &lt;a href=&quot;https://github.com/SteveSanderson/Blazor/pull/7#discussion_r136719427&quot;&gt;解释&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;告诉你吧，整个堆代码确实需要重写，减少每个对象的内存开销，并且不需要分配二叉树。一开始设计 GC 时没有考虑那么多,（现在做的话）会增加很多代码。这是我一直想做的事情，但从来没有动手。&lt;strong&gt;为了尽快使用 GC 而只好如此。&lt;/strong&gt; 在最初的设计中完全没有 GC。它的速度非常快，以至于内存也会很快用完。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多 &quot;Conservative&quot; 机制和 &quot;Precise&quot; GC机制的细节请看:&lt;/p&gt;
&lt;h3 id=&quot;gc-只做了-标记-扫描-不会做压缩&quot;&gt;&lt;strong&gt;GC 只做了 &quot;标记-扫描&quot;, 不会做压缩&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在 GC 方面另一个不同的行为是它不会在回收后做任何内存 &lt;strong&gt;压缩&lt;/strong&gt; ，正如 Steve Sanderson 在 &lt;a href=&quot;https://github.com/SteveSanderson/Blazor/blob/master/src/Blazor.Runtime/Interop/ManagedGCHandle.cs#L40-L43&quot;&gt;working on Blazor&lt;/a&gt; 中所说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;在服务器端执行期间，我们实际上并不需要任何内存固定 (pin)，在客户端执行过程中并没有任何互操作，所有的东西（实际上）都是固定的。&lt;strong&gt;因为 DotNetAnywhere 的 GC只做标记扫描,没有任何压缩阶段。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;此外，当一个对象被分配给 DotNetAnywhere 时，只是调用了 &lt;a href=&quot;http://www.cplusplus.com/reference/cstdlib/malloc/&quot;&gt;malloc()&lt;/a&gt;, 它的代码细节在 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Heap.c#L468&quot;&gt;Heap_Alloc(..) 函数&lt;/a&gt; 中。所以它也没有&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md#physical-representation-of-the-managed-heap&quot;&gt;&quot;Generations&quot; 或者 &quot;Segments&quot;&lt;/a&gt; 的概念，你在 .NET Framework GC 中见到的如 &quot;Gen 0&quot;、&quot;Gen 1&quot; 或者 &quot;大对象堆&quot; 等都不会出现。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;最后，我们来看看线程模型，它与 .NET Framework 中的线程模型截然不同。&lt;/p&gt;
&lt;h2 id=&quot;线程差异&quot;&gt;线程差异&lt;/h2&gt;
&lt;p&gt;DotNetAnywhere (表面上)乐于为你创建线程并执行代码, 然而这只是一种幻觉. 事实上它只会跑在 &lt;strong&gt;一个线程&lt;/strong&gt; 中， 不同的线程之间 &lt;strong&gt;切换上下文&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-f2cb400017eda542.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Thread Usage Explanation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可以通过下面的代码了解, ( 引用自 &lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/Thread.c#L112-L236&quot;&gt;Thread_Execute() 函数&lt;/a&gt;)将  &lt;code&gt;numInst&lt;/code&gt; 设置为 &lt;code&gt;100&lt;/code&gt; 并传入 &lt;code&gt;JIT_Execute(..)&lt;/code&gt; 中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (;;) {
    U32 minSleepTime = 0xffffffff;
    I32 threadExitValue;

    status = JIT_Execute(pThread, 100);
    switch (status) {
        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个有趣的副作用是 DotNetAnywhere 中&lt;code&gt;corlib&lt;/code&gt; 的实现代码将变得非常简单。如&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/corlib/System.Threading/Interlocked.cs#L28&quot;&gt;&lt;code&gt;Interlocked.CompareExchange()&lt;/code&gt; 函数&lt;/a&gt;的&lt;a href=&quot;https://github.com/chrisdunelm/DotNetAnywhere/blob/master/dna/System.Threading.Interlocked.c#L26-L37&quot;&gt;内部实现&lt;/a&gt; 所示, 你所期待的同步就缺失了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tAsyncCall* System_Threading_Interlocked_CompareExchange_Int32(
            PTR pThis_, PTR pParams, PTR pReturnValue) {
    U32 *pLoc = INTERNALCALL_PARAM(0, U32*);
    U32 value = INTERNALCALL_PARAM(4, U32);
    U32 comparand = INTERNALCALL_PARAM(8, U32);

    *(U32*)pReturnValue = *pLoc;
    if (*pLoc == comparand) {
        *pLoc = value;
    }

    return NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;作为性能测试, 我将使用&lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/program.php?test=binarytrees&amp;amp;lang=csharpcore&amp;amp;id=1&quot;&gt;C# 最简版本&lt;/a&gt; 实现的 &lt;a href=&quot;http://benchmarksgame.alioth.debian.org/u64q/binarytrees.html&quot;&gt;基于二叉树的计算机语言基准测试&lt;/a&gt;做对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：DotNetAnywhere 旨在运行于低内存设备，所以不意味着能与完整的 .NET Framework具有相同的性能。对比结果时切记!!&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;net-framework-4.6.1---0.36-seconds&quot;&gt;.NET Framework, 4.6.1 - 0.36 seconds&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Invoked=TestApp.exe 15
stretch tree of depth 16         check: 131071
32768    trees of depth 4        check: 1015808
8192     trees of depth 6        check: 1040384
2048     trees of depth 8        check: 1046528
512      trees of depth 10       check: 1048064
128      trees of depth 12       check: 1048448
32       trees of depth 14       check: 1048544
long lived tree of depth 15      check: 65535

Exit code      : 0
Elapsed time   : 0.36
Kernel time    : 0.06 (17.2%)
User time      : 0.16 (43.1%)
page fault #   : 6604
Working set    : 25720 KB
Paged pool     : 187 KB
Non-paged pool : 24 KB
Page file size : 31160 KB&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dotnetanywhere---54.39-seconds&quot;&gt;DotNetAnywhere - 54.39 seconds&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Invoked=dna TestApp.exe 15
stretch tree of depth 16         check: 131071
32768    trees of depth 4        check: 1015808
8192     trees of depth 6        check: 1040384
2048     trees of depth 8        check: 1046528
512      trees of depth 10       check: 1048064
128      trees of depth 12       check: 1048448
32       trees of depth 14       check: 1048544
long lived tree of depth 15      check: 65535

Total execution time = 54288.33 ms
Total GC time = 36857.03 ms
Exit code      : 0
Elapsed time   : 54.39
Kernel time    : 0.02 (0.0%)
User time      : 54.15 (99.6%)
page fault #   : 5699
Working set    : 15548 KB
Paged pool     : 105 KB
Non-paged pool : 8 KB
Page file size : 13144 KB&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，DotNetAnywhere 在这个基准测试中运行速度并不快（0.36秒/ 54秒）。然而，如果我们对比另一个基准测试，它的表现就好很多。DotNetAnywhere 在分配对象（&lt;code&gt;类&lt;/code&gt;）时有很大的开销，而在使用&lt;code&gt;结构&lt;/code&gt;时就不那么明显了。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Elapsed Time (secs)&lt;/td&gt;
&lt;td&gt;3.1&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;GC Collections&lt;/td&gt;
&lt;td&gt;96&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Total GC time (msecs)&lt;/td&gt;
&lt;td&gt;983.59&lt;/td&gt;
&lt;td&gt;439.73&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;最后，我要感谢 &lt;a href=&quot;https://github.com/chrisdunelm&quot;&gt;Chris Bacon&lt;/a&gt;。DotNetAnywhere 真是一个伟大的代码库，对于我们实现 .NET 运行时很有帮助。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;请在 &lt;a href=&quot;https://news.ycombinator.com/item?id=15514519&quot;&gt;Hacker News&lt;/a&gt;的 &lt;a href=&quot;https://www.reddit.com/r/programming/comments/77frgh/dotnetanywhere_an_alternative_net_runtime/&quot;&gt;/r/programming&lt;/a&gt; 中讨论本文。&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Fri, 09 Feb 2018 13:07:00 +0000</pubDate>
<dc:creator>张很水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenug/p/8436819.html</dc:identifier>
</item>
<item>
<title>【OCR技术系列之三】大批量生成文字训练集 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8436820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8436820.html</guid>
<description>&lt;p&gt;放假了，终于可以继续可以静下心写一写OCR方面的东西。上次谈到文字的切割，今天打算总结一下我们怎么得到用于训练的文字数据集。如果是想训练一个手写体识别的模型，用一些前人收集好的手写文字集就好了，比如中科院的&lt;a href=&quot;http://www.nlpr.ia.ac.cn/databases/handwriting/Offline_database.html&quot;&gt;这些数据集&lt;/a&gt;。但是如果我们只是想要训练一个专门用于识别印刷汉字的模型，那么我们就需要各种印刷字体的训练集，那怎么获取呢？借助强大的图像库，自己生成就行了！&lt;/p&gt;
&lt;p&gt;先捋一捋思路，生成文字集需要什么步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;确定你要生成多少字体，生成一个记录着汉字与label的对应表。&lt;/li&gt;
&lt;li&gt;确定和收集需要用到的字体文件。&lt;/li&gt;
&lt;li&gt;生成字体图像，存储在规定的目录下。&lt;/li&gt;
&lt;li&gt;适当的数据增强。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三步的生成字体图像最为重要，如果仅仅是生成很正规的文字，那么用这个正规文字集去训练模型，第一图像数目有点少，第二模型泛化能力比较差，所以我们需要对字体图像做大量的图像处理工作，以增大我们的印刷体文字数据集。&lt;/p&gt;
&lt;p&gt;我总结了一下，我们可以做的一些图像增强工作有这些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;文字扭曲&lt;/li&gt;
&lt;li&gt;背景噪声（椒盐）&lt;/li&gt;
&lt;li&gt;文字位置（设置文字的中心点）&lt;/li&gt;
&lt;li&gt;笔画粘连（膨胀来模拟）&lt;/li&gt;
&lt;li&gt;笔画断裂（腐蚀来模拟）&lt;/li&gt;
&lt;li&gt;文字倾斜（文字旋转）&lt;/li&gt;
&lt;li&gt;多种字体&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;做完以上增强后，我们得到的数据集已经非常庞大了。&lt;/p&gt;
&lt;p&gt;现在开始一步一步生成我们的3755个汉字的印刷体文字数据集。&lt;/p&gt;
&lt;h2 id=&quot;一生成汉字与label的对应表&quot;&gt;一、生成汉字与label的对应表&lt;/h2&gt;
&lt;p&gt;这里的汉字、label映射表的生成我使用了pickel模块，借助它生成一个id:汉字的映射文件存储下来。&lt;br/&gt;这里举个小例子说明怎么生成这个“汉字：id”映射表。&lt;/p&gt;
&lt;p&gt;首先在一个txt文件里写入你想要的汉字，如果对汉字对应的ID没有要求的话，我们不妨使用该汉字的排位作为其ID，比如“一二三四五”中，五的ID就是00005。如此类推，把汉字读入内存，建立一个字典，把这个关系记录下来，再使用pickle.dump存入文件保存。&lt;/p&gt;
&lt;h2 id=&quot;二收集字体文件&quot;&gt;二、收集字体文件&lt;/h2&gt;
&lt;p&gt;字体文件上网收集就好了，但是值得注意的是，不是每一种字体都支持汉字，所以我们需要筛选出真正适合汉字生成的字体文件才可以。我一共使用了十三种汉字字体作为我们接下来汉字数据集用到的字体，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210217982-1742939776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，如果需要进一步扩大数据集来增强训练得到的模型的泛化能力，可以花更多的时间去收集各类汉字字体，那么模型在面对各种字体时也能从容应对，给出准确的预测。&lt;/p&gt;
&lt;h2 id=&quot;三文字图像生成&quot;&gt;三、文字图像生成&lt;/h2&gt;
&lt;p&gt;首先是定义好输入参数，其中包括输出目录、字体目录、测试集大小、图像尺寸、图像旋转幅度等等。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def args_parse():
    #解析输入参数
    parser = argparse.ArgumentParser(
        description=description, formatter_class=RawTextHelpFormatter)
    parser.add_argument('--out_dir', dest='out_dir',
                        default=None, required=True,
                        help='write a caffe dir')
    parser.add_argument('--font_dir', dest='font_dir',
                        default=None, required=True,
                        help='font dir to to produce images')
    parser.add_argument('--test_ratio', dest='test_ratio',
                        default=0.2, required=False,
                        help='test dataset size')
    parser.add_argument('--width', dest='width',
                        default=None, required=True,
                        help='width')
    parser.add_argument('--height', dest='height',
                        default=None, required=True,
                        help='height')
    parser.add_argument('--no_crop', dest='no_crop',
                        default=True, required=False,
                        help='', action='store_true')
    parser.add_argument('--margin', dest='margin',
                        default=0, required=False,
                        help='', )
    parser.add_argument('--rotate', dest='rotate',
                        default=0, required=False,
                        help='max rotate degree 0-45')
    parser.add_argument('--rotate_step', dest='rotate_step',
                        default=0, required=False,
                        help='rotate step for the rotate angle')
    parser.add_argument('--need_aug', dest='need_aug',
                        default=False, required=False,
                        help='need data augmentation', action='store_true')   
    args = vars(parser.parse_args()) 
    return args
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来需要将我们第一步得到的对应表读入内存，因为这个表示ID到汉字的映射，我们在做一下转换，改成汉字到ID的映射，用于后面的字体生成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#将汉字的label读入，得到（ID：汉字）的映射表label_dict
label_dict = get_label_dict()

char_list=[]  # 汉字列表
value_list=[] # label列表
for (value,chars) in label_dict.items():
    print (value,chars)
    char_list.append(chars)
    value_list.append(value)

# 合并成新的映射关系表：（汉字：ID）
lang_chars = dict(zip(char_list,value_list)) 
font_check = FontCheck(lang_chars) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对旋转的角度存储到列表中，旋转角度的范围是[-rotate,rotate].&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if rotate &amp;lt; 0:
    roate = - rotate

if rotate &amp;gt; 0 and rotate &amp;lt;= 45:
    all_rotate_angles = []
    for i in range(0, rotate+1, rotate_step):  
        all_rotate_angles.append(i)
    for i in range(-rotate, 0, rotate_step):
        all_rotate_angles.append(i)
    #print(all_rotate_angles)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在说一下字体图像是怎么生成的，首先我们使用的工具是PIL。PIL里面有很好用的汉字生成函数，我们用这个函数再结合我们提供的字体文件，就可以生成我们想要的数字化的汉字了。我们先设定好我们生成的字体颜色为黑底白色，字体尺寸由输入参数来动态设定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210320013-473428024.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 生成字体图像
class Font2Image(object):

    def __init__(self,
                 width, height,
                 need_crop, margin):
        self.width = width
        self.height = height
        self.need_crop = need_crop
        self.margin = margin

    def do(self, font_path, char, rotate=0):
        find_image_bbox = FindImageBBox()
        # 黑色背景
        img = Image.new(&quot;RGB&quot;, (self.width, self.height), &quot;black&quot;)
        draw = ImageDraw.Draw(img)
        font = ImageFont.truetype(font_path, int(self.width * 0.7),)
        # 白色字体
        draw.text((0, 0), char, (255, 255, 255),
                  font=font)
        if rotate != 0:
            img = img.rotate(rotate)
        data = list(img.getdata())
        sum_val = 0
        for i_data in data:
            sum_val += sum(i_data)
        if sum_val &amp;gt; 2:
            np_img = np.asarray(data, dtype='uint8')
            np_img = np_img[:, 0]
            np_img = np_img.reshape((self.height, self.width))
            cropped_box = find_image_bbox.do(np_img)
            left, upper, right, lower = cropped_box
            np_img = np_img[upper: lower + 1, left: right + 1]
            if not self.need_crop:
                preprocess_resize_keep_ratio_fill_bg = \
                    PreprocessResizeKeepRatioFillBG(self.width, self.height,
                                                    fill_bg=False,
                                                    margin=self.margin)
                np_img = preprocess_resize_keep_ratio_fill_bg.do(
                    np_img)
            # cv2.imwrite(path_img, np_img)
            return np_img
        else:
            print(&quot;img doesn't exist.&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们写两个循环，外层循环是汉字列表，内层循环是字体列表，对于每个汉字会得到一个image_list列表，里面存储着这个汉字的所有图像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (char, value) in lang_chars.items():  # 外层循环是字
    image_list = []
    print (char,value)
    #char_dir = os.path.join(images_dir, &quot;%0.5d&quot; % value)
    for j, verified_font_path in enumerate(verified_font_paths):    # 内层循环是字体   
        if rotate == 0:
            image = font2image.do(verified_font_path, char)
            image_list.append(image)
        else:
            for k in all_rotate_angles: 
                image = font2image.do(verified_font_path, char, rotate=k)
                image_list.append(image)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将image_list中图像按照比例分为训练集和测试集存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        test_num = len(image_list) * test_ratio
        random.shuffle(image_list)  # 图像列表打乱
        count = 0
        for i in range(len(image_list)):
            img = image_list[i]
            #print(img.shape)
            if count &amp;lt; test_num :
                char_dir = os.path.join(test_images_dir, &quot;%0.5d&quot; % value)
            else:
                char_dir = os.path.join(train_images_dir, &quot;%0.5d&quot; % value)

            if not os.path.isdir(char_dir):
                os.makedirs(char_dir)

            path_image = os.path.join(char_dir,&quot;%d.png&quot; % count)
            cv2.imwrite(path_image,img)
            count += 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写好代码后，我们执行如下指令，开始生成印刷体文字汉字集。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python gen_printed_char.py --out_dir ./dataset --font_dir ./chinese_fonts --width 30 --height 30 --margin 4 --rotate 30 --rotate_step 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析一下上述指令的附属参数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;--out_dir 表示生成的汉字图像的存储目录&lt;/li&gt;
&lt;li&gt;--font_dir 表示放置汉字字体文件的路径&lt;/li&gt;
&lt;li&gt;--width --height 表示生成图像的高度和宽度&lt;/li&gt;
&lt;li&gt;--margin 表示字体与边缘的间隔&lt;/li&gt;
&lt;li&gt;--rotate 表示字体旋转的范围，[-rotate,rotate]&lt;/li&gt;
&lt;li&gt;--rotate_step 表示每次旋转的间隔&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;生成这么一个3755个汉字的数据集的所需的时间还是很久的，估计接近一个小时。其实这个生成过程可以用多线程、多进程并行加速，但是考虑到这种文字数据集只需生成一次就好，所以就没做这方面的优化了。数据集生成完我们可以发现，在dataset文件夹下得到train和test两个文件夹，train和test文件夹下都有3755个子文件夹，分别存储着生成的3755个汉字对应的图像，每个子文件的名字就是该汉字对应的id。随便选择一个train文件夹下的一个子文件夹打开，可以看到所获得的汉字图像，一共634个。&lt;/p&gt;
&lt;p&gt;dataset下自动生成测试集和训练集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210356545-1280275168.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试集和训练集下都有3755个子文件夹，用于存储每个汉字的图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210507951-532205948.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成出来的汉字图像&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210545763-206700772.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;额外的图像增强&quot;&gt;额外的图像增强&lt;/h2&gt;
&lt;p&gt;第三步生成的汉字图像是最基本的数据集，它所做的图像处理仅有旋转这么一项，如果我们想在数据增强上再做多点东西，想必我们最终训练出来的OCR模型的性能会更加优秀。我们使用opencv来完成我们定制的汉字图像增强任务。&lt;/p&gt;
&lt;p&gt;因为生成的图像比较小，仅仅是30*30，如果对这么小的图像加噪声或者形态学处理，得到的字体图像会很糟糕，所以我们在做数据增强时，把图片尺寸适当增加，比如设置为100×100，再进行相应的数据增强，效果会更好。&lt;/p&gt;
&lt;h3 id=&quot;噪点增加&quot;&gt;噪点增加&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def add_noise(cls,img):
    for i in range(20): #添加点噪声
        temp_x = np.random.randint(0,img.shape[0])
        temp_y = np.random.randint(0,img.shape[1])
        img[temp_x][temp_y] = 255
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;适当腐蚀&quot;&gt;适当腐蚀&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def add_erode(cls,img):
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3, 3))    
    img = cv2.erode(img,kernel) 
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;适当膨胀&quot;&gt;适当膨胀&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def add_dilate(cls,img):
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(3, 3))    
    img = cv2.dilate(img,kernel) 
    return img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后做随机扰动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def do(self,img_list=[]):
    aug_list= copy.deepcopy(img_list)
    for i in range(len(img_list)):
        im = img_list[i]
        if self.noise and random.random()&amp;lt;0.5:
            im = self.add_noise(im)
        if self.dilate and random.random()&amp;lt;0.25:
            im = self.add_dilate(im)
        if self.erode and random.random()&amp;lt;0.25:
            im = self.add_erode(im)    
        aug_list.append(im)
    return aug_list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入指令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python gen_printed_char.py --out_dir ./dataset2 --font_dir ./chinese_fonts --width 100 --height 100 --margin 10 --rotate 30 --rotate_step 1 --need_aug&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种生成的图像如下图所示，第一数据集扩大了两倍，第二图像的丰富性进一步提高，效果还是明显的。当然，如果要获得最好的效果，还需要调一下里面的参数，这里就不再详细说明了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180209210644091-99882600.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们所需的印刷体汉字数据集已经成功生成完毕，下一步要做的就是利用这些数据集设计一个卷积神经网络做文字识别了！完整的代码可以在&lt;a href=&quot;https://github.com/AstarLight/CPS-OCR-Engine/blob/master/ocr/gen_printed_char.py&quot;&gt;我的github&lt;/a&gt;获取。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 13:07:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8436820.html</dc:identifier>
</item>
<item>
<title>浅入浅出数据结构（24）——最短路径问题 - NSpt</title>
<link>http://www.cnblogs.com/mm93/p/8434056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mm93/p/8434056.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上一篇博文我们提到了图的最短路径问题：两个顶点间的最短路径该如何寻找？其实这个问题不应该叫“最短”路径问题，而应该叫“最便宜”路径问题，因为有时候我们会为图中的边赋权（weight），也叫权重，相当于经过一条边的“代价”，一般为正数。比如下图（边旁的数字即该边的权重）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208160653498-811264307.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如果单纯考虑一条路径上边的条数，那么从v0到v6的最短路径应该是：v0-v3-v6。但是如果考虑边的权重，从v0到v6的“最便宜”路径应该是：v0-v1-v4-v6，其总权重为3（路径中所有边的权重之和），而如果走v0-v3-v6的路径，总权重将是11。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　边有权重的图我们称之为赋权图，反之称为无权图，赋权图显然可以比无权图应用于更多场合，比如用赋权图来表示城市间公路，权重越大路况越差，或者权重越大，过路费用越高等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实不考虑权重的最短路径问题就是所有边的权重都是1的“最便宜”路径问题，比如将上图的所有边去掉权重后的无权图也可以这样表示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208160940591-978365534.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　方便起见，我们就将“最便宜”路径称为最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来让我们先从简单的无权情况开始，看看如何找两个顶点间的最短路径。不过到了这一步，一件有意思的事情需要说明一下，那就是：&lt;span&gt;找X到Y的最短路径，比找X到所有顶点的最短路径更慢&lt;/span&gt;（有权无权都是如此）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出现这个情况的原因我们可以简单的分析一波：找X到Y的最短路径，最直接的做法就是令程序从X出发沿着可行的边不断的走，直到走到Y处为止，但是当走到Y处时，没人能保证刚刚走的那条路就是最短的，除非你走遍了整个图的顶点，换句话说，你要确定走到Y处且走的路径是最短的，你就得走遍所有顶点，而且在这个过程中你必须不断记录各个路径的长度，不然当你发现到一个顶点有多条路径时怎么比较它们呢？所以，你要找X到Y的最短路径，你就得找出X到所有顶点的最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，也存在专门寻找点对点最短路径的思路，但是目前来说，单独找X到Y的最短路径不会比找X到所有顶点的最短路径更快，所以我们接下来探讨的问题其实都是：单源最短路径问题。即给定一个起点（源），求出其与所有顶点的最短路径。有了到所有顶点的最短路径，我们自然也就有了到给定顶点Y的最短路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对无权图进行单源最短路径寻找的思路，就是我们上面所说的“最直接的做法”。为了更方便讲解，我们假定若存在边（A，B），则B是被A“指向”的顶点。那么&lt;span&gt;对无权图进行单源最短路径寻找就是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们将起点的路径长设为0，其他顶点路径长设为负数（也可以是其他不可能的值，图例中用？表示），下例以v1作为起点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208220616045-605300545.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们将起点所指向的顶点的路径长设为1，可以肯定的是，只有被路径长为0的起点所指向的顶点的路径长为1，本例中即v3和v4：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208220657888-1622004471.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来，我们将路径长为1的顶点（v3和v4）所指向的顶点的路径长设为2，同样可以肯定，只有被路径长为1的顶点所指向的顶点的路径长为2。不过此时会遇到一个问题：v3是v4所指向的顶点，但v3的路径长显然不应该被设为2。所以我们&lt;strong&gt;需要对已知路径长的顶点设一个“已知”标记&lt;/strong&gt;，已知的顶点不再更改其路径长，具体做法在给出代码时将写明。本例中，路径长要被设为2的顶点是v2、v5、v6：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209011001263-772371778.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后我们继续这样的步骤，将路径长为2的顶点所指向的顶点的路径长设为3。不过本例中路径长为2的顶点所指向的顶点中已经没有未知顶点了，所以算法结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述步骤随着图的规模变大而变多，但不难发现其规律就是：&lt;span&gt;将路径长为i的顶点所指向的未知顶点的路径长设为i+1，i从0开始，结束条件即：当前路径长为i的顶点没有指向其它顶点，或所指向的顶点均为已知。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是结束条件的说法，我们并没有要求所有顶点都变为已知，因为确定某顶点为起点后，是有可能存在某个顶点无法由起点出发然后到达的，比如我们的例子中的v0，不存在从v1到v0的路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来要做的事情就是用代码实现我们所说的思路，此时我们需要注意是我们并不想在图上直接动手脚，因为图可能还有他用，并且直接在图上动手脚也不方便，因为图中顶点可能并没有用于表示是否已知的域和用于表示从起点到自身的最短路径长的域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以我们的做法是将最短路径的计算结果存于一个线性表中，其结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208223153138-69311074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中“一行”为线性表中的一个元素，每一行的四个单元格就是一个元素中的四个域：顶点、是否已知、与起点最短路径长、最短路径中自身的前一个顶点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么之前计算最短路径的过程用这个表来表示的话，就是下面这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208224018170-1589269912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208224106732-306823562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208224155810-2073817000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当我们想知道从起点到顶点Y的最短路径时，我们只需要找到Y顶点，查看其distance域即可知道，而想知道整条路径是怎么走的，我们也只要追溯Y的preV直到起点即可知道。下面是输出起点到给定终点的最短路径的一个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//路径表中的元素定义，我们假设顶点vx即数字x，所以元素没有vertex域&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pathNode
{
    &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; known;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; distance;
    &lt;span&gt;size_t&lt;/span&gt; preV;
}

&lt;span&gt;//路径表&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; pathNode pathTable[numVertex];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; printPath(size_t end,&lt;span&gt;struct&lt;/span&gt; node*&lt;span&gt; pathTable)
{
    size_t preV&lt;/span&gt;=&lt;span&gt;pathTable[end].preV;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pathTable[preV].distance!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        printPath(preV,pathTable);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,preV);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,end);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　下面是上述无权最短路径思路的一个简单伪代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无权最短路径计算，图存于邻接表graph，结果存入pathTable，起点即start&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; unweightedPath(Node* graph,&lt;span&gt;struct&lt;/span&gt; pathNode*&lt;span&gt; pathTable,size_t  start)
{
    pathTable[start].known&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    pathTable[start].distance&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若pathTable[x].distance为0，则其preV是无用的，我们不予理睬

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化pathTable中的其他元素

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;curDis即当前距离，我们要做的是令distance==curDis的顶点所指的未知顶点的distance=curDis+1&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; curDis=&lt;span&gt;0&lt;/span&gt;;curDis&amp;lt;numVertex;++&lt;span&gt;curDis)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;numVertex;++&lt;span&gt;i)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!pathTable[i].known&amp;amp;&amp;amp;pathTable[i].distance==&lt;span&gt;curDis)
            {
                pathTable[i].known&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历pathTable[i]所指向的顶点X&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;pathTable[X].known)
                    {
                        pathTable[X].preV&lt;/span&gt;=&lt;span&gt;i;
                        pathTable[X].distance&lt;/span&gt;=curDis+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　与上一篇博文的拓扑排序一样，上面的最短路径算法还有改进空间。当我们寻找符合distance==curDis条件的顶点时，我们用的是直接遍历数组的方法，这使得我们的算法时间复杂度达到了O(n&lt;sub&gt;v&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;)（n&lt;sub&gt;v&lt;/sub&gt;为顶点个数），所以&lt;span&gt;我们要改进的就是“寻找符合条件的顶点”的过程&lt;/span&gt;。我们可以创建一个队列来存储“需要处理的顶点”，该队列初始时只有起点，当我们修改了某个未知顶点的distance后，我们就将该顶点入队，而当我们令curDis递增后再次寻找distance==curDis的顶点时，我们只需要令队列元素出队即可获取到想要的顶点。这个过程口述难以表达清楚，下面是应该足够清晰了的伪代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无权最短路径计算，图存于邻接表graph，结果存入pathTable，起点即start&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; unweightedPath(Node* graph,&lt;span&gt;struct&lt;/span&gt; pathNode*&lt;span&gt; pathTable,size_t  start)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化pathTable

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建队列pendingQueue
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将起点start入队&lt;/span&gt;
&lt;span&gt;
    size_t curVertex;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;empty(pendingQueue))
    {
        curVertex&lt;/span&gt;=&lt;span&gt;Dequeue(pendingQueue);
        pathTable[curVertex].known&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历curVertex指向的顶点X&lt;/span&gt;
&lt;span&gt;        {
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;pathTable[X].known)
           {
               pathTable[X].distance&lt;/span&gt;=pathTable[curVertex].distance+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
               pathTable[X].preV&lt;/span&gt;=&lt;span&gt;curVertex;
               Enqueue(X,pendingQueue);
           }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这样一来，我们就将无权最短路径算法的时间复杂度由O(n&lt;sub&gt;v&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;)降低到了O(n&lt;sub&gt;v&lt;/sub&gt;+n&lt;sub&gt;e&lt;/sub&gt;)（n&lt;sub&gt;e&lt;/sub&gt;即边的条数）。此外，上述算法对于无向有圈图也是一样生效的，原因就不赘述了，道理是简单的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来的问题是如何对有权图进行单源最短路径的寻找。有权图的最短路径显然比无权图要难找，原因在于我们不能套用无权算法的思路，直接令已知顶点所指未知顶点的distance=curDis+weight（weight即两顶点间路径的权重，此处简写），以下图为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180208160653498-811264307.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　若我们令v0作为起点，然后令v0所指的未知顶点的distance=v0.distance+weight，那么v3的distance就会变成5，可是实际上v3的distance应改为2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解决的思路是：&lt;span&gt;我们罗列出所有已知顶点指向的所有未知顶点，看这些未知顶点中谁的distance被修改后会是最小的，最小的那个我们就修改其distance，并认为它已知。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　以上图为例，我们一步步走一遍来加深一下理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先是正常的初始化（我们将边的权重也标识出来），假设起点为v0：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004313451-758816477.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们罗列出所有已知顶点（只有v0）指向的所有未知顶点：v1、v2、v3。然后发现若修改它们的distance，则v1.distance=v0.distance+1=1，v2.distance=v0.distance+3=3，v3.distance=v0.distance+5=5。显然v1被修改后的distance是未知顶点中最小的，所以我们只修改v1的distance，并将v1设为已知，v2、v3不动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004335545-896153487.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们继续罗列出所有已知顶点（v0、v1）指向的所有未知顶点：v2、v3、v4。然后发现若修改它们的distance，则v2.distance=v0.distance+3=3，v4.distance=v1.distance+1=2，v3.distance=v1.distance+1=2（虽然v0也指向v3，但是通过v0到v3的路径长大于从v1到v3，所以v3的distance取其小者），其中v3和v4的新distance并列最小，我们任选其一比如v4，然后只修改v4的distance，并将v4设为已知，其它不动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004354029-860824386.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们罗列出所有已知顶点（v0、v1、v4）指向的所有未知顶点：v2、v3、v6，发现若修改，则v2.distance=3，v3.distance=2，v6.distance=3，所以我们只修改v3的distance，并将v3设为已知：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004419170-1563798837.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们罗列出所有已知顶点（v0、v1、v3、v4）指向的所有未知顶点：v2、v5、v6，发现若修改，则v2.distance=3，v5.distance=10，v6.distance=3，我们在v2和v6中任选一个如v2，只修改v2.distance，并将v2设为已知：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004637623-1867903903.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继续，我们罗列出所有已知顶点指向的所有未知顶点：v5、v6，发现若修改，则v5.distance=5，v6.distance=3，所以我们只修改v6：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004812420-376295739.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，罗列出的未知顶点只有v5，若修改，其distance=5，我们将其修改并设为已知，算法结束：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1127778/201802/1127778-20180209004938295-1066667231.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　其实&lt;span&gt;上述算法的核心部分就是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.找到所有已知顶点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.将所有已知顶点指向的所有未知顶点罗列出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.计算这些未知顶点的最小distance，然后再确定其中新distance最小的顶点X&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.只修改X的distance，并将X设为已知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.回到第二步，若所有已知顶点都没有指向未知顶点，则结束&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而这个算法就是Dijkstra算法的雏形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Dijkstra算法核心部分简化的说法就是：找到所有可确定distance的未知顶点中新distance最小的那个，修改它并将它设为已知。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用伪代码描述就是这样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有权最短路径计算，图存于邻接表graph，结果存入pathTable，起点即start&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; weightedPath(Node* graph,&lt;span&gt;struct&lt;/span&gt; pathNode*&lt;span&gt; pathTable,size_t  start)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化pathNode数组&lt;/span&gt;
&lt;span&gt;    
    size_t curV;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到可确定distance的未知顶点中新distance最小的那个，存入curV，若没有则跳出循环
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;令pathNode[curV].distance和pathNode[curV].prev修改为正确的值&lt;/span&gt;
        pathNode[curV].known=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　可以确定的是，Dijkstra算法也可以应用于无权图，只要给无权图中的每条边加个值为1的权重即可。并且如果你将无权算法与Dijkstra算法进行对比，就会发现那个无权算法其实就是Dijkstra算法的“特例”，在无权算法中，我们之所以不需要去找“distance最小的未知顶点”，是因为我们可以肯定已知顶点所指向的未知顶点就是“distance最小的未知顶点”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不用想都知道，Dijkstra算法中的循环中的两行伪代码其实意味着大量的操作：找到可以确定distance的未知顶点，计算它们的distance，比较出最小的那个，修改……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　显然，Dijkstra算法的核心部分是可以改进的，改进的思路与无权算法也很相像，即“&lt;span&gt;加快寻找符合条件的顶点的过程&lt;/span&gt;”。其中一种改进方式是计算出未知顶点的新distance后，将{未知顶点，新distance}对插入到以distance为关键字的优先队列中，而不是直接抛弃非最小distance的那些未知顶点（这是一个很大的浪费）。这样在下一次寻找“distance最小的未知顶点”时，我们可以通过优先队列的出队来获得，从而避免了遍历整个数组来寻找目标的情况。这个想法要细化实现的话，还有不少坑要避开，不过我写到这儿时深感表达之困难与疲惫，所以这篇博文就此打住，如果博文中有什么不对之处，可以在评论区指出，谢谢~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　附：如果有权图中存在权重为负值的情况，则计算单源最短路径将会更加困难，不过可以确定的是，如果有权图中存在圈与负权边，且负权边在圈中，使得圈的路径长为负，那么单源最短路径的计算是无法进行的，因为你可以在这个圈中永远走下去来使路径长不断“减小”。解决有负值权重边的图的最短路径算法是在Dijkstra的算法上进行改进得来的，本文不予讲解（或许以后会有一篇文章介绍），有兴趣的可以自行搜索。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 12:50:00 +0000</pubDate>
<dc:creator>NSpt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mm93/p/8434056.html</dc:identifier>
</item>
<item>
<title>1.C和C++区别,以及const分析 - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8436731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8436731.html</guid>
<description>&lt;p&gt;&lt;span&gt;从本章起开始从0学习C++,本章主要内容:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;C和C++的基本区别&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt;C和C++的const区别&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.C++&lt;span&gt;和&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; C++更强调语言的实用性,所有变量都可以在需要时再定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;100&lt;/span&gt;;i++);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.2&lt;/strong&gt;&lt;/span&gt; C++不允许定义多个同名全局变量,而C却可以重复定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.3&lt;/span&gt;&lt;/strong&gt; C++的register只是个兼容作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4&lt;/span&gt;&lt;/strong&gt; C++的所有标识符都必须有声明类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;比如&lt;/span&gt;,&lt;span&gt;在&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;f():  &lt;span&gt;表示&lt;/span&gt;默认&lt;span&gt;返回值是&lt;/span&gt;int,&lt;span&gt;可以接受任意个&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;型参数的函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int f() int f(void)表示&lt;span&gt;都一样&lt;/span&gt;&lt;span&gt;,没有&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;返回值为&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;型的函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int f(i): &lt;span&gt;由于&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;没声明类型&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会报错&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.5 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;结构体&lt;/span&gt;升级&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如,&lt;span&gt;在&lt;/span&gt;C&lt;span&gt;中&lt;/span&gt;定义一个结构体:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef student_type student;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student_type{
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
};

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; student student_info={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
student  student2&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;只需要这么写&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student_type{
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;name;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
};

student_type student2&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zhang&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;};   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不需要strcut再次声明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;C&lt;span&gt;和&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. C&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 &lt;span&gt;介绍&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C&lt;span&gt;语言中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;只是让变量变为&lt;span&gt;只读属性&lt;/span&gt;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;其本质还是变量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不是真正意义上的常量&lt;/span&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;只有&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt;枚举定义的才是常量&lt;/span&gt;&lt;span&gt;).&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;:&lt;/strong&gt;&lt;/span&gt;const&lt;span&gt;变量不能被直接赋值&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;但是可以通过&lt;span&gt;指针&lt;/span&gt;来修改&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;变量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于&lt;/span&gt;const&lt;span&gt;&lt;span&gt;局部变量&lt;/span&gt;会存在&lt;span&gt;栈&lt;/span&gt;里&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;&lt;span&gt;全局变量&lt;/span&gt;会存在&lt;span&gt;只读存储区&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以我们可以通过指针来修改&lt;/span&gt;const&lt;span&gt;局部变量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;但是修改&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;全局变量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会使程序崩溃&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;-&lt;/span&gt;&lt;span&gt;通过指针来修改&lt;/span&gt;&lt;span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;局部变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const局部变量&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt;* p = (&lt;span&gt;int&lt;/span&gt;*)&amp;amp;&lt;span&gt;c;
    &lt;/span&gt;*p = &lt;span&gt;5&lt;/span&gt;;          &lt;span&gt;//通过指针&lt;/span&gt;&lt;span&gt;修改const变量&lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194256373-615092994.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;span&gt;实例&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/span&gt;-&lt;/span&gt;&lt;span&gt;通过指针来修改&lt;/span&gt;&lt;span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;全局变量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const全局变量&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* p = (&lt;span&gt;int&lt;/span&gt;*)&amp;amp;&lt;span&gt;c;
    &lt;/span&gt;*p = &lt;span&gt;5&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改const变量&lt;/span&gt;&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194309482-3268690.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于指针修改只读存储区的数据&lt;/span&gt;,&lt;span&gt;所以导致程序崩溃&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. C++&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;C++&lt;span&gt;中&lt;/span&gt;&lt;span&gt;,const&lt;/span&gt;&lt;span&gt;变量则是真正的&lt;span&gt;常量&lt;/span&gt;了&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;定义时会将其放入&lt;span&gt;符号表&lt;/span&gt;中&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以编译途中遇到使用&lt;/span&gt;const&lt;span&gt;变量时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;则直接从符号表中取出常量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只要当该&lt;/span&gt;const&lt;span&gt;变量为全局&lt;/span&gt;&lt;span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt;&lt;span&gt;声明过&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;,&lt;/span&gt;&lt;span&gt;或者被使用&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&lt;span&gt;操作符&lt;/span&gt;时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;才会被分配存储空间&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来&lt;/span&gt;,&lt;span&gt;我们以一个例子来分析存储空间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;const局部变量&lt;/span&gt;

    &lt;span&gt;int&lt;/span&gt;* p = (&lt;span&gt;int&lt;/span&gt;*)&amp;amp;c; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用&amp;amp;操作符,会分配空间&lt;/span&gt;

    *p = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;  

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c = %d,*p=%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c,*&lt;span&gt;p);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194331295-2107653097.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;79&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;为什么输出结果会有两个不同的值?&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是因为使用&lt;/span&gt;&amp;amp;c&lt;span&gt;时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;会从符号表中取出&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;的值&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;并将&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;存在一个新的分配空间地址里&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;所以&lt;/span&gt;*p&lt;span&gt;修改的只是&lt;span&gt;分配出来的空间&lt;/span&gt;地址内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;还是常量&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 const&lt;span&gt;和&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;是不是感觉&lt;/span&gt;C++&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;和&lt;/span&gt; &lt;span&gt;define&lt;/span&gt;&lt;span&gt;宏定义一样？其实不一样&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;const&lt;span&gt;常量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;     &lt;/span&gt;&lt;span&gt;由编译器处理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;它会对&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;常量进行类型检查和作用域检查&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;define&lt;span&gt;宏定义&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;由预处理器处理&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;直接进行文本替换&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不会进行各种检查&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;(&lt;span&gt;预处理器是执行编译器之前运行的程序&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;用来删除注释&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;宏变量转换等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来&lt;/span&gt;,&lt;span&gt;我们以一个例子来分析&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;define&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; f()
{
    &lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; a 3        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义宏&lt;/span&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;4&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义局部变量&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{  
    f();   
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;b=%d&quot;,b);&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1182576/201802/1182576-20180209194339591-239308695.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是因为执行预处理器时&lt;/span&gt;,&lt;span&gt;会将遇见到的所有&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;变为&lt;/span&gt;&lt;span&gt;3,&lt;/span&gt;&lt;span&gt;所以&lt;span&gt;编译器&lt;/span&gt;看到的是&lt;/span&gt;&lt;span&gt;printf(&quot;a=%d&quot;,3);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而取消&lt;span&gt;//printf(&quot;b=%d&quot;,b);&lt;/span&gt; &lt;span&gt;屏蔽后&lt;/span&gt;,&lt;span&gt;程序则会报错&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;是因为&lt;/span&gt;b&lt;span&gt;的作用域只在&lt;/span&gt;f()&lt;span&gt;函数里有效&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 &lt;span&gt;指针&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指针&lt;/span&gt;const&lt;span&gt;分为两种&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;底层&lt;/span&gt;&lt;span&gt;const,&lt;/span&gt; &lt;span&gt;顶层&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(&lt;span&gt;&lt;span&gt;普通变量的&lt;/span&gt;&lt;span&gt;const(&lt;/span&gt;&lt;span&gt;或引用&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;永远是顶层&lt;/span&gt;&lt;span&gt;const,&lt;/span&gt;&lt;span&gt;也就是说&lt;/span&gt;&lt;span&gt;,const int&lt;/span&gt; &lt;span&gt;和&lt;/span&gt;&lt;span&gt;int const&lt;/span&gt;&lt;span&gt;本质都一样&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;底层&lt;/span&gt;&lt;span&gt;const&lt;strong&gt;&lt;span&gt;(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;位于&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;左侧&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;常量指针&lt;/span&gt;,&lt;span&gt;表示指向的对象是个常量&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;不能修改其内容&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;只能更改指针指向的地址&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是可以通过其它方式修改内容&lt;/span&gt;,&lt;span&gt;例如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;1&lt;/span&gt;,b=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *p=&amp;amp;a;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;底层const

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*p=2;              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误,无法修改*p指向的a里面内容&lt;/span&gt;
&lt;span&gt;
a&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确,通过其它方法来修改*p的内容&lt;/span&gt;&lt;span&gt;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*&lt;span&gt;p);

p&lt;/span&gt;=&amp;amp;b;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确,可以更改指针指向的地址&lt;/span&gt;&lt;span&gt;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*p);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输出结果&lt;/span&gt;:&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;顶层&lt;/span&gt;&lt;span&gt;const&lt;span&gt;&lt;strong&gt;(&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;位于&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;右侧&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;指针常量&lt;/span&gt;,&lt;span&gt;表示不能更改指针指向的地址&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;只能修改其内容&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;定义时必须被初始化&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;和引用非常相似&lt;/span&gt;,&lt;span&gt;例如&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int *const p;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误,没有被初始化&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;const&lt;/span&gt; p=&amp;amp;a;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶层const

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p=&amp;amp;b;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误,不能更改指针指向的地址&lt;/span&gt;

*p=&lt;span&gt;2&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确,修改a的值等于2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 本章结束,下章来学习:  &lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/8436764.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;C++中的bool类型,三目运算符,引用&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 12:12:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8436731.html</dc:identifier>
</item>
<item>
<title>SSIS 对数据排序 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4809730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4809730.html</guid>
<description>&lt;p&gt; 一般来说，数据排序有两种方式：使用Sort组件，使用TSQL命令Order by。使用Sort组件排序，对SSIS来说，是一种阻塞性的操作，这意味着，SSIS组件必须等到所有的数据都加载到内存之后，才能按照特定的字段对数据执行排序操作。然而，如果使用TSQL命令的Order by子句，在关系引擎中执行排序操作，然后，把有序的数据加载到内存中，这样对SSIS说，是一种流式操作，这意味着，SSIS组件不需要等到所有的数据都加载到内存中，就可以开始处理数据，不仅节省系统的内存资源，而且数据处理的流程更快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，使用Sort组件进行排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Sort组件对无序的数据进行排序，必须要设置排序键，排序列的位置，排序的类型（升序或降序）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/628084/201802/628084-20180209182031810-1955399789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SortType&lt;/strong&gt;：升序 ascending，降序 descending，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SortOrder&lt;/strong&gt;：排序列的位置，从1开始依次递增，&lt;/p&gt;
&lt;p&gt;Sort组件还有一个属性：Remove wors with duplicate sort values，该属性指定，当排序列重复时，Sort组件是否删除重复的行？这不同于distinct命令，distinct是输出的所有列不重复。如果选中该属性，只是保证排序列（输出列的一部分）不重复，该属性也可以从Sort Transformation Advanced Editor中查看和设置，默认值是False，不删除重复值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/628084/201509/628084-20150915121859929-2101229829.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二，使用TSQL命令的Order by 子句对数据进行排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据源中，数据访问模式选择为SQL command，通过编写TSQL代码，对数据排序。&lt;/p&gt;
&lt;p&gt;step1：使用OLEDB数据源组件对数据排序，该数据源组件向下传递的数据是有序的：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2015.cnblogs.com/blog/628084/201509/628084-20150915123440226-359286711.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step2，打开OLEDB的高级编辑器，查看输入和输出属性选项卡&lt;/p&gt;
&lt;p&gt;1，点击OLEDB Source Ouput，设置IsSorted属性为True，该属性设置为true不会对数据排序，只是告知下游组件，该输出数据已经排序。&lt;/p&gt;
&lt;p&gt;如果将IsSorted属性设置为True，实际数据并没有排序，在package 运行时会出错，所以必须提供已经排序的数据（在TSQL命令中使用order by子句对数据排序）&lt;/p&gt;
&lt;p&gt;2，点击Output Columns，逐个设置排序列（Order by Column_List)的SortKeyPosition属性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SortKeyPosition属性有Sort Position和Direction 两个metadata：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正整数表示按照升序排序，0表示不是排序列，负整数表示按照降序排序，数字代表排序列的序号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如，对于以下的TSQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; Col_1,Col_2,Col_3,Col_4
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; dbo.TableName
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; Col_1 &lt;span&gt;asc&lt;/span&gt;, Col_2 &lt;span&gt;desc&lt;/span&gt;,Col_3 &lt;span&gt;desc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Output Columns中需要逐个设置，Col_1,Col_2,Col_3,Col_4的SortKeyPosition&lt;br/&gt;由于Col_1,Col_2,Col_3是排序列，序号从1依次递增，而Col_4不是排序列，所以SortKeyPosition的配置如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Col_1 的SortKeyPosition是 1，第一个排序列，且按照升序排序&lt;/li&gt;
&lt;li&gt;Col_2 的SortKeyPosition是 -2，第二个排序列，且按照降序排序&lt;/li&gt;
&lt;li&gt;Col_3 的SortKeyPosition是 3，第三个排序列，且按照升序排序&lt;/li&gt;
&lt;li&gt;Col_4 的SortKeyPosition是 0，不是排序列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/628084/201509/628084-20150915123734242-1888149949.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/628084/201509/628084-20150915123726461-1384127525.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/628084/201509/628084-20150915123742195-124679462.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三，性能比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过测试，使用关系型数据库输出有序的数据流，能够充分利用关系型数据库的性能，加快SSIS 引擎处理海量数据任务的性能。因此，当需要从关系型数据库中加载有序的数据时，建议使用SQL命令对数据排序。&lt;/p&gt;
&lt;p&gt;对于需要从非关系型数据库中加载数据的数据源，这类数据量一般不大，对数据排序的时间和资源消耗较小，对Sort组件来说，能够很快完成。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/integration-services/data-flow/transformations/sort-data-for-the-merge-and-merge-join-transformations&quot; target=&quot;_blank&quot;&gt;Sort Data for the Merge and Merge Join Transformations &lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 10:30:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4809730.html</dc:identifier>
</item>
<item>
<title>radare2逆向笔记 - 有价值炮灰</title>
<link>http://www.cnblogs.com/pannengzhi/p/play-with-radare2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pannengzhi/p/play-with-radare2.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/676200/201802/676200-20180209181046357-545444.png&quot; alt=&quot;radare2&quot;/&gt;&lt;br/&gt;最近刚开始学习逆向(Reverse Engineering), 发现其学习曲线也是挺陡峭的, 而网上的&lt;br/&gt;许多writeup文章主旨总结就六个字:&quot;你们看我屌吗?&quot; ...几近炫技而对初学者不太友好.&lt;br/&gt;所以打算以初学者的身份来写写自己从入门到深入的经历.&lt;/p&gt;

&lt;p&gt;当前许多逆向的writeup倾向于使用IDA-Pro, 而且似乎都依赖于F5(反编译的快捷键), 直接&lt;br/&gt;从二进制文件转成了可读的C代码. 这对于实际工作来说也许是个捷径, 但对于学习来说却&lt;br/&gt;没什么好处. 所以本文逆向采用了另一个开源的(但也同样强大的)二进制分析工具--&lt;a href=&quot;https://github.com/radare/radare2&quot;&gt;Radare2&lt;/a&gt;.&lt;br/&gt;如果你是个资深的逆向人员, 那么从本文也可以了解下radare2的一些功能.&lt;/p&gt;
&lt;h2 id=&quot;知识准备&quot;&gt;知识准备&lt;/h2&gt;
&lt;p&gt;逆向软件的时候往往面对的是汇编代码, 所以对于指令集要有个大致的认识, 另外对于一些&lt;br/&gt;模式(pattern), 比如函数入口(prologue), 出口(epilogue)和函数调用约定(calling convention)&lt;br/&gt;等也要有所了解. 关于这类知识可以将&lt;a href=&quot;https://beginners.re/&quot;&gt;RE4B(Reverse Engineering for Beginners)&lt;/a&gt;&lt;br/&gt;这本书作为参考. 书虽然比较厚, 但比较全面, 包括了X86/ARM/MIPS的内容和许多有趣的历史典故,&lt;br/&gt;一开始可以粗略扫一遍, 遇到问题再回头仔细阅读相关部分即可.&lt;/p&gt;
&lt;h2 id=&quot;工具准备&quot;&gt;工具准备&lt;/h2&gt;
&lt;p&gt;当了解了基本汇编知识后(目前x86足矣), 就可以开始准备工具了. 说起工具我想起了一个寓言:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;年轻人学有所成, 出山前问师父: &quot;我准备练习武器, 请问哪种武器能让我战无不胜呢?&quot;&lt;br/&gt;师父说: &quot;武器? 如果你的武器比你的头脑更加锋利, 那你将一无是处&quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论何时, 个人的头脑和思维永远是最重要的, 而武器只是工具, 永远不要让工具取代了你的思考.&lt;br/&gt;当然也不是要你肉眼反汇编, 总之...你懂就行了! 我在Linux环境工作, 用到的几个工具如下:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文只用到了第一个, 因为还没有到需要动态分析调试的时候.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目标准备&quot;&gt;目标准备&lt;/h2&gt;
&lt;p&gt;初步打算是这一系列逆向文章使用IOLI的crackme文件来作为目标, 总共3个平台(Linux/Win32和Arm),&lt;br/&gt;每个平台有10个二进制文件, 都是从同样的源码编译而来的. 可以从&lt;a href=&quot;https://github.com/radare/radare2book/tree/master/crackmes/ioli/IOLI-crackme.tar.gz&quot;&gt;radare的git上&lt;/a&gt;下载.&lt;/p&gt;

&lt;p&gt;好的, 这是第一个目标, 首先了解你的敌人:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rabin2 -I crackme0x00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rabin2&lt;/code&gt;是&lt;code&gt;radare2&lt;/code&gt;套件中的一个工具, 主要用来提取二进制文件中的信息, 输出如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arch     x86
binsz    7537
bintype  elf
bits     32
canary   false
class    ELF32
crypto   false
endian   little
havecode true
intrp    /lib/ld-linux.so.2
lang     c
linenum  true
lsyms    true
machine  Intel 80386
maxopsz  16
minopsz  1
nx       true
os       linux
pcalign  0
pic      false
relocs   true
relro    partial
rpath    NONE
static   false
stripped false
subsys   linux
va       true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后查看&lt;code&gt;.rodata&lt;/code&gt;字段里的字符串:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rabin2 -z crackme0x00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;000 0x00000568 0x08048568  24  25 (.rodata) ascii IOLI Crackme Level 0x00\n
001 0x00000581 0x08048581  10  11 (.rodata) ascii Password: 
002 0x0000058f 0x0804858f   6   7 (.rodata) ascii 250382
003 0x00000596 0x08048596  18  19 (.rodata) ascii Invalid Password!\n
004 0x000005a9 0x080485a9  15  16 (.rodata) ascii Password OK :)\n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下该程序:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x00 
IOLI Crackme Level 0x00
Password: 123456
Invalid Password!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看样子是要输入密码, 从rabin2的字符串输出里看到&lt;code&gt;250382&lt;/code&gt;也许就是密码, 我们可以输入试试:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./crackme0x00 
IOLI Crackme Level 0x00
Password: 250382
Password OK :)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧! 看样子确实是. 毕竟是第一关, 有点简单了. 但我还是先假装不知道吧:)&lt;br/&gt;如果目的是进入到&lt;code&gt;Password OK&lt;/code&gt;分支, 那么我们可以有多种解法, 如分析密码的算法,&lt;br/&gt;修改原文件(打patch), 利用漏洞, fuzzy等, 下面挑几个说说.&lt;/p&gt;
&lt;h2 id=&quot;解法1-逆向分析&quot;&gt;解法1: 逆向分析&lt;/h2&gt;
&lt;p&gt;话不多说, 打开radare2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r2 -A crackme0x00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入后自动跳转到了函数入口0x08048360, 然后用pdf命令来查看汇编代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze len bytes of instructions for references (aar)
[x] Analyze function calls (aac)
[x] Use -AA or aaaa to perform additional experimental analysis.
[x] Constructing a function name for fcn.* and sym.func.* functions (aan)
 -- You can 'copy/paste' bytes using the cursor in visual mode 'c' and using the 'y' and 'Y' keys
[0x08048360]&amp;gt; pdf @ sym.main&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;pdf表示p(打印)d(反汇编)f(函数), @表示取地址, sym.main为函数符号, 也可以用十六进制整数地址表示.&lt;br/&gt;在r2中查看这些指令的帮助只要在后面输入&lt;code&gt;?&lt;/code&gt;即可, 比如&lt;code&gt;p?&lt;/code&gt;查看打印类的命令, &lt;code&gt;pd?&lt;/code&gt;查看打印反汇编类的命令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打印反汇编的输出如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            ;-- main:
/ (fcn) main 127
|   main ();
|           ; var int local_18h @ ebp-0x18
|           ; var int local_4h @ esp+0x4
|              ; DATA XREF from 0x08048377 (entry0)
|           0x08048414      55             push ebp
|           0x08048415      89e5           mov ebp, esp
|           0x08048417      83ec28         sub esp, 0x28               ; '('
|           0x0804841a      83e4f0         and esp, 0xfffffff0
|           0x0804841d      b800000000     mov eax, 0
|           0x08048422      83c00f         add eax, 0xf
|           0x08048425      83c00f         add eax, 0xf
|           0x08048428      c1e804         shr eax, 4
|           0x0804842b      c1e004         shl eax, 4
|           0x0804842e      29c4           sub esp, eax
|           0x08048430      c70424688504.  mov dword [esp], str.IOLI_Crackme_Level_0x00 ; [0x8048568:4]=0x494c4f49 ; &quot;IOLI Crackme Level 0x00\n&quot;
|           0x08048437      e804ffffff     call sym.imp.printf         ; int printf(const char *format)
|           0x0804843c      c70424818504.  mov dword [esp], str.Password: ; [0x8048581:4]=0x73736150 ; &quot;Password: &quot;
|           0x08048443      e8f8feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x08048448      8d45e8         lea eax, [local_18h]
|           0x0804844b      89442404       mov dword [local_4h], eax
|           0x0804844f      c704248c8504.  mov dword [esp], 0x804858c  ; [0x804858c:4]=0x32007325
|           0x08048456      e8d5feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0804845b      8d45e8         lea eax, [local_18h]
|           0x0804845e      c74424048f85.  mov dword [local_4h], str.250382 ; [0x804858f:4]=0x33303532 ; &quot;250382&quot;
|           0x08048466      890424         mov dword [esp], eax
|           0x08048469      e8e2feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
|           0x0804846e      85c0           test eax, eax
|       ,=&amp;lt; 0x08048470      740e           je 0x8048480
|       |   0x08048472      c70424968504.  mov dword [esp], str.Invalid_Password ; [0x8048596:4]=0x61766e49 ; &quot;Invalid Password!\n&quot;
|       |   0x08048479      e8c2feffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==&amp;lt; 0x0804847e      eb0c           jmp 0x804848c
|      ||      ; JMP XREF from 0x08048470 (main)
|      |`-&amp;gt; 0x08048480      c70424a98504.  mov dword [esp], str.Password_OK_: ; [0x80485a9:4]=0x73736150 ; &quot;Password OK :)\n&quot;
|      |    0x08048487      e8b4feffff     call sym.imp.printf         ; int printf(const char *format)
|      |       ; JMP XREF from 0x0804847e (main)
|      `--&amp;gt; 0x0804848c      b800000000     mov eax, 0
|           0x08048491      c9             leave
\           0x08048492      c3             ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个典型的32位Linux程序, 这时候要想起函数的调用约定是通过栈来传参, 如果忘了可以再看看&lt;a href=&quot;https://beginners.re/&quot;&gt;RE4B&lt;/a&gt;哦.&lt;br/&gt;看到main函数的汇编代码了, 就开始分析了, 我不想像一些文章那样贴个图就说&quot;显而易见, 这里的作用是XXX&quot;,&lt;br/&gt;毕竟我也只是个新手, 虽然这只是一个超简单的crackme, 但因为是第一次, 我还是把流程完整地走一遍.&lt;/p&gt;
&lt;p&gt;有了汇编接下来就开始分析了, r2和IDA一样可以自己写注释和修改变量名称, 在此之前我们先创建一个工程,&lt;br/&gt;以保存这些修改:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048360]&amp;gt; Ps ioli0x00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条指令的意思是保存一个名为&lt;code&gt;ioli0x00&lt;/code&gt;的(新)项目, 通常默认保存在&lt;code&gt;~/.config/radare2/projects&lt;/code&gt;里.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;以P开头的命令是项目工程管理相关(Project managment), 还记得之前说的吗,&lt;br/&gt;如果不记得命令, 可以通过&lt;code&gt;P?&lt;/code&gt;来查看帮助.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后跳转到main并打印本地局部变量:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048360]&amp;gt; s main
[0x08048414]&amp;gt; afv
var int local_4h @ esp+0x4
var int local_18h @ ebp-0x18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;s表示seek, 跳转后发现我们已经到了&lt;code&gt;0x08048414&lt;/code&gt;, afv表示a(分析)f(函数)v(变量), 可以看到有两个局部变量.&lt;br/&gt;(其实只有一个, 因为esp+0x4是传给子函数的参数).&lt;br/&gt;再回到前面的汇编看看, 从0x08048448到0x08048456这几条汇编可以发现&lt;code&gt;local_4h&lt;/code&gt;是&lt;code&gt;local_18h&lt;/code&gt;的地址(指针),&lt;br/&gt;而且&lt;code&gt;local_4h&lt;/code&gt;是scanf的第二个参数, scanf的第一个参数为0x804858c, 这个地址应该是个字符串, 我们打印下看看:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048414]&amp;gt; ps @ 0x804858c
%s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么&lt;code&gt;local_18h&lt;/code&gt;应该就是用户输入的字符串了, 我们先给他们改个好听的名字:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;afvn local_18h input
afv-local_4h&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;afv-&lt;/code&gt;表示删除某个名字, 这里删除了&lt;code&gt;local_4h&lt;/code&gt;因为它其实不是本地变量, 这时再次打印汇编就能看到改好的名字了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0x08048448      8d45e8         lea eax, [input]
0x0804844b      89442404       mov dword [esp+4], eax
0x0804844f      c704248c8504.  mov dword [esp], 0x804858c  ; [0x804858c:4]=0x32007325
0x08048456      e8d5feffff     call sym.imp.scanf          ; int scanf(const char *format)
0x0804845b      8d45e8         lea eax, [input]
0x0804845e      c74424048f85.  mov dword [esp+4], str.250382 ; [0x804858f:4]=0x33303532 ; &quot;250382&quot; 
0x08048466      890424         mov dword [esp], eax        ; 这句和上一句相当于push str.250382; push eax
0x08048469      e8e2feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
0x0804846e      85c0           test eax, eax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这下就能比较清楚的看出上述代码的核心目的了, 大约是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;char input[N];
scanf(&quot;%s&quot;, input)
strcmp(input, &quot;250382&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由前面的&lt;code&gt;sub esp, 0x28&lt;/code&gt;可知, 这里的N应该小于40(没错! 这里有一个栈溢出漏洞!). 不过对于函数&lt;br/&gt;prologue之后的几条汇编我还不是很明白作用是是啥, 希望有大神能告知一下~&lt;/p&gt;
&lt;p&gt;至此, crackme0x00的分析基本完成. 虽然有些步骤看起来很繁琐, 但对于分析大型项目还是很有用的.&lt;br/&gt;尤其是给变量/参数命名, 给函数/代码块命名, 这样会使得分析过程步步为营, 柳暗花明.&lt;/p&gt;
&lt;h2 id=&quot;解法2-修改程序&quot;&gt;解法2: 修改程序&lt;/h2&gt;
&lt;p&gt;当我们能直接接触程序并且有修改权限时, 那么修改该二进制文件也是个快速通关的好办法!&lt;br/&gt;回到刚刚的汇编输出, 我们看到&lt;code&gt;0x08048470&lt;/code&gt;这行有一个跳转分支:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     0x0804846e      85c0           test eax, eax
 ,=&amp;lt; 0x08048470      740e           je 0x8048480
 |   0x08048472      c70424968504.  mov dword [esp], str.Invalid_Password ; [0x8048596:4]=0x61766e49 ; &quot;Invalid Password!\n&quot;
 |   0x08048479      e8c2feffff     call sym.imp.printf         ; int printf(const char *format)
,==&amp;lt; 0x0804847e      eb0c           jmp 0x804848c
||      ; JMP XREF from 0x08048470 (main)
|`-&amp;gt; 0x08048480      c70424a98504.  mov dword [esp], str.Password_OK_: ; [0x80485a9:4]=0x73736150 ; &quot;Password OK :)\n&quot;
|    0x08048487      e8b4feffff     call sym.imp.printf         ; int printf(const char *format)
|       ; JMP XREF from 0x0804847e (main)
`--&amp;gt; 0x0804848c      b800000000     mov eax, 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test a, b&lt;/code&gt;的意思是&lt;code&gt;若a AND b为0, 则设置ZF位(以及SF/PF)&lt;/code&gt;, je表示&lt;code&gt;若ZF位被设置则跳转&lt;/code&gt;,&lt;br/&gt;说人话就是判断前一个函数的返回值是否为0(eax保存strcmp的返回值), 若为0则跳转到&lt;code&gt;0x8048480&lt;/code&gt;(打印&quot;Password OK :)\n&quot;),&lt;br/&gt;所以, 我们只需要把je改成无条件跳转&lt;code&gt;jmp&lt;/code&gt;就可以啦!&lt;br/&gt;不过这时候要重新打开r2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r2 -w crackme0x00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-w&lt;/code&gt;参数表示以可写的方式打开程序, 而之前我们的打开方式是只读滴! 或者在之前的会话中输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048414]&amp;gt; eval cfg.write=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也同样能获得修改文件的权限.&lt;/p&gt;
&lt;p&gt;改好之后首先我们先跳转到想要修改指令的地方:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048414]&amp;gt; s 0x08048470
[0x08048470]&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的机器码是&lt;code&gt;0x740e&lt;/code&gt;, 反汇编为&lt;code&gt;je 0x10&lt;/code&gt;, 不懂怎么反? 这时候就要介绍radare2中的另一个工具&lt;code&gt;rasm2&lt;/code&gt;了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 -a x86 -b 32 -d &quot;0x740e&quot;
je 0x10
$ rasm2 -a x86 -b 32 &quot;je 0x10&quot;
740e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;为CPU架构, &lt;code&gt;-b&lt;/code&gt;为CPU寄存器位数, &lt;code&gt;-d&lt;/code&gt;表示反汇编, 是不是很直观? 接下来我们要把jz改为jmp:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ rasm2 -a x86 -b 32 &quot;jmp 0x10&quot;
eb0e&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说把74改为eb就行了! 只改一个字节, 怎么操作? 如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[0x08048470]&amp;gt; px 20
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x08048470  740e c704 2496 8504 08e8 c2fe ffff eb0c  t...$...........
0x08048480  c704 24a9                                ..$.
[0x08048470]&amp;gt; wx eb
[0x08048470]&amp;gt; px 20
- offset -   0 1  2 3  4 5  6 7  8 9  A B  C D  E F  0123456789ABCDEF
0x08048470  eb0e c704 2496 8504 08e8 c2fe ffff eb0c  ....$...........
0x08048480  c704 24a9                                ..$.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;px&lt;/code&gt;表示以hexdump形式打印当前位置的N个字节, &lt;code&gt;wx&lt;/code&gt;表示在当前位置写入&lt;br/&gt;如果有疑问, 别忘了你的好帮手&lt;code&gt;?&lt;/code&gt;哦, &lt;code&gt;px?&lt;/code&gt;和&lt;code&gt;wx?&lt;/code&gt;都能查看对应的帮助.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK现在改好了, 退出r2, 再运行下试试:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./crackme0x00 
IOLI Crackme Level 0x00
Password: fuckme
Password OK :)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在输入任何密码都能通关啦!&lt;/p&gt;
&lt;h2 id=&quot;解法3-利用漏洞&quot;&gt;解法3: 利用漏洞&lt;/h2&gt;
&lt;p&gt;刚刚在说解法1时, 最后看到了在scanf函数的执行过程中, 存在一个栈溢出漏洞, 先写个小bash脚本验证下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;i&lt;/span&gt; in &lt;span class=&quot;dt&quot;&gt;{1..50}&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;do&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;input=$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; /dev/urandom &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;tr&lt;/span&gt; -dc &lt;span class=&quot;st&quot;&gt;'a-z0-9'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;head&lt;/span&gt; -c &lt;span class=&quot;ot&quot;&gt;$i)&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$input&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;./crackme0x00&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if [&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$?&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-ne&lt;/span&gt; 0&lt;span class=&quot;kw&quot;&gt; ]&lt;/span&gt;;&lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;OOOOOps!!! input(&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$input&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;) of length &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$i&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; crush this program!&quot;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;fi&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;done&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
...
550 Segmentation fault      | ./crackme0x00
OOOOOps!!! input(rvibn45fg3eugqg6257rtyazsqclz) of length 29 crush this program!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实锤溢出跑不掉了. 那么利用这个漏洞, 我们同样可以实现通关, 甚至可以获得任意系统命令执行!&lt;br/&gt;不过在这篇文章里先深入exploit的部分, 因为篇幅已经够长了, 为了保护脑细胞, 就留在以后专门来写吧!&lt;/p&gt;
&lt;h2 id=&quot;解法4-利用fuzzy&quot;&gt;解法4: 利用Fuzzy&lt;/h2&gt;
&lt;p&gt;这个方法综合了上述的一些方式, 我们可以用暴力破解的方式来获取密码, 也可以利用afl或者libFuzzer&lt;br/&gt;来自动化找出该程序潜在的bug(配合QEMU). 这种方式的坏处是太暴力了, 让妹子不敢靠近(逃)； 好处&lt;br/&gt;则是在一定程度上解放了大脑, 用计算机来帮我们计算, 算力越强就越有可能找到突破点!&lt;/p&gt;

&lt;p&gt;本来是想多写几个crackme的, 但是由于这是第一篇, 就讲详细一点, 以后会深入一些更复杂和的程序,&lt;br/&gt;写几篇真正意义上的writeup. 总结一下求解crackme类问题的方法, 1)逆向分析, 2)修改程序, 3)利用漏洞,&lt;br/&gt;4)利用Fuzzy. 通常我们在遇到实际问题时是会将这些方式结合起来用的, 比如虽然逆向分析了一部分代码,&lt;br/&gt;但某部分算法特别复杂, 那么就会借用Fuzzy的思想, 对这部分逻辑进行Symbolic Execution, 以最快的方式解决战斗!&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;能力有限, 文中错误在所难免, 欢迎交流!&lt;/li&gt;
&lt;li&gt;文章转载请注明来源: &lt;a href=&quot;https://www.pppan.net/&quot; class=&quot;uri&quot;&gt;https://www.pppan.net/&lt;/a&gt; 谢谢!&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 09 Feb 2018 10:13:00 +0000</pubDate>
<dc:creator>有价值炮灰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pannengzhi/p/play-with-radare2.html</dc:identifier>
</item>
<item>
<title>我是如何用单机实现亿级规模题库去重的？ - haolujun</title>
<link>http://www.cnblogs.com/haolujun/p/8399275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haolujun/p/8399275.html</guid>
<description>&lt;p&gt;最近工作中遇到了一个问题：如何对大规模题库去重？公司经过多年的积累，有着近亿道题目的题库，但是由于题目来源不一导致题库中有很多重复的题目，这些重复的题目在检索时，除了增加搜索引擎的计算量外，并不会提高准确率。此外由于题目过多，搜索引擎往往采取了截断策略，只对一部分题目进行计算，这导致了某些正确的题目反而得不到计算，拍搜准确率甚至不增反降。所以对于一个搜索引擎来说，虽然初期增加题目数量往往可以大幅提高拍搜准确率，但是当题目量大到一定程度时，反而会由于计算量跟不上导致准确率下降。如何尽可能的去除重复题目显得尤为重要。&lt;/p&gt;

&lt;h2 id=&quot;比较md5值&quot;&gt;比较MD5值&lt;/h2&gt;
&lt;p&gt;对每道题目计算其MD5值作为签名，这样在新增题目时，只要判断题库中是否有相同的MD5值即可。&lt;/p&gt;
&lt;p&gt;这种方案只适用于两道题目一模一样的情况，而现实中题目往往不只是这样。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“A比B大10&quot;与&quot;B比A小10”&lt;/li&gt;
&lt;li&gt;“小红买10本书”与“小明买10本书”&lt;/li&gt;
&lt;li&gt;“今天空气温度为10度”与“今天的空气温度为10度”&lt;br/&gt;这些应该是重复题，但是MD5值不同，没法去重。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用最长公共子序列和最小编辑距离算法&quot;&gt;利用最长公共子序列和最小编辑距离算法&lt;/h2&gt;
&lt;p&gt;利用最长公共子序列算法与最小编辑距离算法计算两个题目的相似度，如果相似度大于一定比例，例如大于90%，就认为是重复的题目。&lt;/p&gt;
&lt;p&gt;这个方法理论上可行，但是计算量太大。假如文档数为N，平均文档长度为M，那么计算量大致为：$ O(N^2*M^2) $ 。&lt;/p&gt;
&lt;p&gt;假设N=1000万，M=200，则计算量约为 $ 4*10^{18} $ ，笔者线下可用机器有限，没有这么大的计算能力。但是如果能够把相似的题目归拢到一起，然后去比较这一小撮题目中两两相似程度，这个还是可行的。&lt;/p&gt;
&lt;h2 id=&quot;jaccard相似度&quot;&gt;Jaccard相似度&lt;/h2&gt;
&lt;p&gt;为此，我特意看了两本书：《信息检索导论》的19.6章节以及《大数据-互联网大规模数据挖掘与分布式处理》的3.2与3.3节。这里面讲述了如何计算两个集合的Jaccard相似度：$ \frac{|A \cap B|}{|A \cup B|} $ 。这个公式对于去重来说没什么卵用，因为计算量还是那么大。所以这两本书还特意介绍了与其等价的算法：转换成随机全排列，基于概率算法去计算Jaccard的近似值。这个转换的证明本文不赘述，有兴趣的小伙伴直接去看这两本书。但是这里面有一个有意思的问题也是计算Jaccard相似度最关键的一步：如何对一个超级大的N生成一个0~N-1随机全排列？我这里给出一个近似算法，学过初等数论的小伙伴应该对下面的定理不陌生。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定理： $ y = (a*x+b) \mod n $ ，如果a与n互质（即a与n的最大公约数为1），当x取遍0~n-1时，y取遍0~n-1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;证明：假如存在两个数 $ x_1 $ 和 $ x_2 $，使得 $ y_1 = (a * x_1 + b) \mod n = y_2 = (a * x_2 + b) \mod n $ ，则 $ (a * x_1 + b) \% n = (a * x_2 + b) \% n $ ，得出 $ (a * x_1 + b - a * x_2 - b) \% n = 0 $ ，继而得到 $ a * (x_1 - x_2) \% n = 0 $。由于a与n互质，最大公约数为1，所以得出 $ x_1 - x_2 = k * n $ ，即 $ x_1 = x_2 + k * n $。当 $ x_1 $ 和 $ x_2 $ 都小于n时，k只能等于0，即 $ x_1 = x_2 $。这就说明当x取遍0~n-1时，其余数肯定不重复，由于余数的取值范围也是0~n-1，所以结论得证。&lt;/p&gt;
&lt;p&gt;这样，当我们知道n时，只要找到与n互质的100或者200个数就行，甚至可以找到小于n的100个或者200个素数（素数筛法大家自行百度），然后再随机生成100次到200次b，就能构造出一批这样的函数。&lt;br/&gt;例如，a = 3，b = 4, n = 8&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;code&gt;x = 0 y = 4
x = 1 y = 7
x = 2 y = 2
x = 3 y = 5
x = 4 y = 0
x = 5 y = 3
x = 6 y = 6
x = 7 y = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个概率算法能够降低一些计算量，但是我还是不能够接受。因为我们现在的关键问题是找出相似的一小撮，并在这一小撮中进行更精细化的判断策略，怎么找到这一小撮咧？&lt;/p&gt;

&lt;p&gt;正所谓具体情况具体分析，不能一味追求高科技却忽略现实条件。比如百度也有去重策略，但是其最后应用到线上的并不是Jaccard相似度，而是找文档中最长的几个句子，根据这几个句子是否一样判断两个文档是否重复，而且准确率出奇的好。所以，我们也要具体问题具体分析。&lt;/p&gt;
&lt;p&gt;观察一下拍搜流程，检索日志中会记录每次搜索结果中几个匹配程度最高的文档id，那么我就可以认为这几个文档是一个小簇，没有必要再重新聚簇。此外由于拍搜的优化策略极多，准确率极高，这比我自己再重新发明一个聚簇算法要省事并且效果好。有这么好的日志在手，就要充分利用起来。接下来我就详细说说我是如何实现去重策略的。&lt;/p&gt;
&lt;p&gt;日志格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[[1380777178,0.306],[1589879284,0.303],[1590076048,0.303],[1590131395,0.303],[1333790406,0.303],[1421645703,0.303],[1677567837,0.303],[1323001959,0.303],[1440815753,0.303],[1446379010,0.303]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个json数组，每个数组中有题目的ID和其得分。&lt;/p&gt;
&lt;h2 id=&quot;日志选取&quot;&gt;日志选取&lt;/h2&gt;
&lt;p&gt;选取题目ID得分比较高的日志作为候选日志。这么选取是因为线上的图像识别不能保证百分百准确，如果图片质量特别差，那么根据识别内容检索到的题目之间差别较大，可能根本不是一类。&lt;/p&gt;
&lt;h2 id=&quot;聚簇&quot;&gt;聚簇&lt;/h2&gt;
&lt;h3 id=&quot;初始集合建立&quot;&gt;初始集合建立&lt;/h3&gt;
&lt;p&gt;对于每条日志，由排在第一位的ID作为簇标识，其它元素作为簇中的元素。&lt;/p&gt;
&lt;h3 id=&quot;集合求并&quot;&gt;集合求并&lt;/h3&gt;
&lt;p&gt;看如下样例：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;code&gt;A -&amp;gt; B,C,D
E -&amp;gt; C,D,F&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于两个集合中有相同的ID，我们推测这两个集合其实属于一个簇，如何实现两个集合的并？利用并查集算法（自行百度之，参加过编程竞赛的小伙伴应该都不陌生，我写的一个样例代码：&lt;a href=&quot;https://github.com/haolujun/Algorithm/tree/master/union_find_set&quot; class=&quot;uri&quot;&gt;https://github.com/haolujun/Algorithm/tree/master/union_find_set&lt;/a&gt; ），并查集能够出色的完成集合合并操作。例如，可以利用并查集的join操作完成两条日志的合并。&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;code&gt;union_find_set.join(A,B)
union_find_set.join(A,C)
union_find_set.join(A,D)

union_find_set.join(E,C)
union_find_set.join(E,D)
union_find_set.join(E,F)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用完操作后，我们会发现A,B,C,D,E,F都属于同一个集合。&lt;/p&gt;
&lt;h3 id=&quot;集合元素限制&quot;&gt;集合元素限制&lt;/h3&gt;
&lt;p&gt;在实际测试时发现，某些集合中的题目数量可能会达到百万，这种情况出现是因为聚类过程中的计算偏差导致的。比如：A与B相似，B与C相似，我们会把A，B，C放到一个簇中，但是实际上A和C可能不相似，这是聚类过程中非常容易出现的问题。簇过大会加大后面的精细计算的计算量，这是一个比在大题库中去重稍简单的问题，但是也非常难。考虑到题库中重复题目不会太多，可以对每个集合大小设置上限元素数目，如果两个将要合并的集合元素总数大于上限，则不将这两个集合合并，这个利用并查集也非常容易实现。&lt;/p&gt;
&lt;h2 id=&quot;精细计算&quot;&gt;精细计算&lt;/h2&gt;
&lt;h3 id=&quot;如何判断两个题目是否重复&quot;&gt;如何判断两个题目是否重复&lt;/h3&gt;
&lt;p&gt;现在得到的簇是一个经过拍搜的结果聚合的，但是拍搜有一个问题就是检索使用的文字是由OCR识别生成的，其中难免会有识别错误，搜索引擎为了能容忍这种错误，加入了一定的模糊策略，这导致簇中的结果并不完全相似，所以精细计算是必要的。那么如何比较两个题目是否是重复的呢？特别是对于数学题这种数字和运算符、汉字混合的题目，该如何办？经过长时间分析发现，不能够把数字、字母与汉字同等比较。数字、字母如果不相等，那么八成这两道题是不同的；如果数字、字母相同那么汉字描述部分可以允许一些差异，但是差异也不要太大。这就得到了我最后的精细去重策略：分别提取题目的汉字和数字、字母、运算符，数字、字母、运算符完全相等并且汉字部分的相似度（可以使用最小编辑距离或者最长公共子序列）大于80%，就可以认为两道题目相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;“A比B大10&quot;与&quot;B比A小10”                                                 数字与字母组成的字符串不相等，不认为重复
“小红买10本书”与“小明买10本书”                                     数字字母相同，汉字相似度大于80%，认为重复
“今天空气温度为10度”与“今天的空气温度为10度”            数字字母相同，汉字相似度大于80%，认为重复&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然这个策略不能百分百去重所有重复题，但是能确保它能去重大部分重复题。&lt;/p&gt;
&lt;h3 id=&quot;保留哪些题目去除哪些题目&quot;&gt;保留哪些题目，去除哪些题目？&lt;/h3&gt;
&lt;p&gt;考虑到搜索引擎在存储倒排是按照题目ID大小进行排序的（存放ID与ID之间的差值），所以留下小的ID去掉大的ID非常必要，这个不难实现。&lt;/p&gt;
&lt;h3 id=&quot;周期性迭代&quot;&gt;周期性迭代&lt;/h3&gt;
&lt;p&gt;我们的去重算法是基于日志进行的去重，那么可以每次去重一部分，上线后再捞取一段时间内的日志进行去重，这样不断的迭代进行。&lt;/p&gt;
&lt;h2 id=&quot;计算量还大么&quot;&gt;计算量还大么？&lt;/h2&gt;
&lt;p&gt;根据单机的计算量，一次捞取一定数量的日志进行去重，单机就可以完成，不需要集群，不需要分布式。&lt;/p&gt;

&lt;p&gt;聪明的小伙伴可能发现，我投机取巧了。我并没有直接对题库去蛮力去重，而是从拍搜日志下手，增量的一步步的实现题库去重，只要迭代次数足够，可以最终去重所有题目，并且每次去重可以实实在在看到效果，可以更方便调整策略细节。所以，在面对一个问题时，换一个角度可能会有更简单的做法。&lt;/p&gt;
</description>
<pubDate>Fri, 09 Feb 2018 10:10:00 +0000</pubDate>
<dc:creator>haolujun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haolujun/p/8399275.html</dc:identifier>
</item>
</channel>
</rss>