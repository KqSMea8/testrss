<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>又要紧急集合了 - 军长喊我敲代码</title>
<link>http://www.cnblogs.com/banboom/p/9576458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/banboom/p/9576458.html</guid>
<description>&lt;ul readability=&quot;5.5&quot;&gt;&lt;li&gt;&lt;strong&gt;自我介绍&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;211414141&lt;/li&gt;
&lt;li&gt;我是退伍军人朱世杰&lt;/li&gt;
&lt;li&gt;很乐意做好每一件事&lt;/li&gt;
&lt;li&gt;不挑食，非得说食堂的话那就是大功率的干煸四季豆&lt;/li&gt;
&lt;li&gt;做什么事情都得拿出百分百的热情，直到成功！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;回答问题&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- （1）回想一下你初入大学时对本专业的畅想&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当初你是如何做出选择软件工程专业的决定的？&lt;br/&gt;选择这个专业是已经是考虑了两三年了为什么这么说，因为在14年高中毕业就想学计算机硬件软件之类的专业，说实话就是为了工资高来的，但是刚进入至诚没能如愿到软件工程专业学习，所以参军两年后回到至诚转专业到软件工程，并加入了这个大家庭，和同学们一起共同学习进步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;你认为过去两年中接触到的课程是否符合你对专业的期待，为什么？&lt;br/&gt;对于专业知识和课程本人觉得在对于计算机和软件方面的知识这知识入门级，因为在社会上这样的技能根本不足矣立足，所以我们学习的更多，至于期待，我更想多学习一些在社会工作岗位中能用到的技能，紧跟计算机潮流发展，打下基础&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;你觉得计算机是你喜欢的领域吗，它是你擅长的领域吗？&lt;br/&gt;计算机目前我还对它充满热情，也不是我擅长的领域，这个还是得一步步学习&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;将来你会选择从事计算机相关的工作吗？是的话给出你想去的城市、公司和岗位，否的话给出原因&lt;br/&gt;这个肯定会从事计算机工作的，要不然我也不会转专业来计算机，想去深圳上海杭州这样计算机行业发达一点的城市，工资高，学习的内容多，同事和公司水平都会比较高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;- （2）即将大三的你，对照前人们走过的路和描述未来发展
 - 现在的你自我感觉你已经具备的专业知识、技能、能力有哪些？
都已经大三了，说实话感觉不到自己学的东西是能够立足于社会的知识和技能，因为我关注网络公司比较多，我们的能力根本不够去面试的机会，现在有用的也就只有java，虽然我自己也自学过C#，用C#在部队写过几个软件，但是还是差远了

 -  离成为一个合格的计算机专业本科毕业生，在专业知识、技能、能力上还差距哪些？&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我觉得差距太大了，在作为一个合格的计算机专业人员来说应该要熟悉所有有关计算机专业的基本知识，并对本身专业达到一定的专业程度，比如还有即将学习的HTML、PHP、CSS、XML等，更多的是会灵活使用学到的专业知识去做出项目产品&lt;br/&gt;- （3）大三是一个人生选择的十字路口，考研、工作、考公、出国，不同的选择在大三就有不同的努力方向。而无论考研还是工作的每条路径，也有许多不同的分支&lt;br/&gt;- 对照以上你阅读的前人们的经历，你的选择是什么？&lt;br/&gt;首先还是先认真学习完学校安排的学习任务吧，多了解了解社会上计算机专业和程序员的变化，有时间自己多学学东西&lt;br/&gt;- 在这种选择下，你认为你相比其他同学来说有何优势，有何劣势？&lt;br/&gt;现在的情况我只能说我没有优势，自从退伍回来大部分精力都在给至诚学院带军训，帮忙处理各种关于军训任务和有关部队的东西，转专业掉的很多课都还没有补，不足的太多了说不下去了&lt;br/&gt;- 针对你的选择，你给自己的大三设定的规划安排是什么？&lt;br/&gt;先完成学业，有时间学习其他的专业知识。但愿有这个时间&lt;br/&gt;- 未来的期望&lt;br/&gt;- 不敢有什么期望，过好当前，一步步学习，一步步提高，一步步成功&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- 针对上述问题（2）、（3），你对这门课的期待是什么？你打算平均每周拿出多少个小时用在这门课上，以达成你的期待以及你在（2）或（3）的目标？
就希望老师们能交给我们更多的在社会上的实战经验，毕竟我们以后都是要走向社会去生存的，更多的还是尽快适应社会生存与社会上才好，毕竟计算机专业竞争的人太多了。打算结束了学校的军训任务就认认真真补起落下的课程，学习这门课的精髓所在，但前提还是得先争取学会专业知识保证不挂科&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;随笔随一下&quot;&gt;随笔随一下&lt;/h5&gt;
&lt;p&gt;作为一个转专业到计算机的同学，虽然已经过去一年了，课程也都完成了，但是因为大多时间都有其他的工作导致没有参加全部课程，也没学习到精髓，很多都是应付考试而已，所以还是很多不足，希望我的软工兄弟们别把自己学习的心得藏着了，拿出来和大家分享分享，帮帮我这种“毒瘤”。哎，真的不想说话了，我的时间永远不够，觉都不睡还是不够。自从这个作业布置下来就一直在工作，工作结束后加个班来完成这个作业真的是累啊。前几次课程也没法参加，老师，给个活口吧！&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 15:49:00 +0000</pubDate>
<dc:creator>军长喊我敲代码</dc:creator>
<og:description>将来的你一定会感谢现在拼命的自己 ========== 自我介绍 211414141 我是退伍军人朱世杰 很乐意做好每一件事 不挑食，非得说食堂的话那就是大功率的干煸四季豆 做什么事情都得拿出百分百的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/banboom/p/9576458.html</dc:identifier>
</item>
<item>
<title>Python中list的复制及深拷贝与浅拷贝探究 - Bil369</title>
<link>http://www.cnblogs.com/Bil369/p/9575659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Bil369/p/9575659.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;　　在Python中，经常要对一个list进行复制。对于复制，自然的就有深拷贝与浅拷贝问题。深拷贝与浅拷贝的区别在于，当从原本的list复制出新的list之后，修改其中的任意一个是否会对另一个造成影响，即这两个list在内存中是否储存在同一个区域，这也是区分深拷贝与浅拷贝的重要依据。接下来我们就针对Python中list复制的几种方法，来探究一下其是属于深拷贝还是浅拷贝。弄清楚这个问题，有助于我们在编程中规避错误，减少不必要的调试时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、非拷贝方法——直接赋值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果用=直接赋值，是非拷贝方法。这两个列表是等价的，修改其中任何一个列表都会影响到另一个列表。这也是Python作为动态语言与C这类静态语言在思想上的不同之处。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; old = [1, [1, 2, 3], 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; new =&lt;span&gt; old
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Before:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(new)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; new[0] = 3
&lt;span&gt;10&lt;/span&gt; new[1][0] = 3
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234219071-756643199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、浅拷贝的几种方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.copy()&lt;/strong&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来看以下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; old = [1, [1, 2, 3], 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; new =&lt;span&gt; old.copy()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Before:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(new)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; new[0] = 3
&lt;span&gt;10&lt;/span&gt; new[1][0] = 3
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234030211-558030062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于list的第一层，是实现了深拷贝，但对于嵌套的list，仍然是浅拷贝。这其实很好理解，内层的list保存的是地址，复制过去的时候是把地址复制过去了。嵌套的list在内存中指向的还是同一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234921971-424870131.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;使用列表生成式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用列表生成式产生新列表也是一个浅拷贝方法，只对第一层实现深拷贝。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; old = [1, [1, 2, 3], 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; new = [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; old]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Before:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(new)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; new[0] = 3
&lt;span&gt;10&lt;/span&gt; new[1][0] = 3
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234254847-1589282996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;用for循环遍历&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过for循环遍历，将元素一个个添加到新列表中。这也是一个浅拷贝方法，只对第一层实现深拷贝。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; old = [1, [1, 2, 3], 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; new =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(old)):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    new.append(old[i])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Before:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(new)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; new[0] = 3
&lt;span&gt;12&lt;/span&gt; new[1][0] = 3
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234400731-642774504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;strong&gt;使用切片&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过使用[:]切片，可以浅拷贝整个列表。同样的，只对第一层实现深拷贝。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; old = [1, [1, 2, 3], 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; new =&lt;span&gt; old[:]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Before:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(new)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; new[0] = 3
&lt;span&gt;10&lt;/span&gt; new[1][0] = 3
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234443757-575140754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、深拷贝的实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果用deepcopy()方法，则无论多少层，无论怎样的形式，得到的新列表都是和原来无关的，这是最安全最清爽最有效的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用时，要导入copy。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; old = [1, [1, 2, 3], 3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; new =&lt;span&gt; copy.deepcopy(old)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Before:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(new)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; new[0] = 3
&lt;span&gt;12&lt;/span&gt; new[1][0] = 3
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;After:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(old)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(new)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201809/1381257-20180902234600631-425310802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;以上，就是对list的复制及深拷贝与浅拷贝探究。鉴于本人水平有限，文中有不妥之处，还请在评论中指出。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 15:47:00 +0000</pubDate>
<dc:creator>Bil369</dc:creator>
<og:description>在Python中，经常要对一个list进行复制。对于复制，自然的就有深拷贝与浅拷贝问题。深拷贝与浅拷贝的区别在于，当从原本的list复制出新的list之后，修改其中的任意一个是否会对另一个造成影响，即</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Bil369/p/9575659.html</dc:identifier>
</item>
<item>
<title>安全的web服务器——使用mysqldump和mysqlbinlog实现MySQL全量与增量备份 - 初心不负丶</title>
<link>http://www.cnblogs.com/chuxinbufu/p/9576446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chuxinbufu/p/9576446.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;系统是Deepin15.6，数据库的版本号是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Server version: &lt;span&gt;5.7&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt; (Debian)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库引擎是：InnoDB。如何查看数据库版本和数据库引擎呢？&lt;/p&gt;
&lt;p&gt;终端登录MySQL数据库命令行的时候，就可以看见数据库版本。&lt;/p&gt;
&lt;p&gt;登录数据库后，使用如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
show engines;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会显示很多数据库引擎，其中，显示YES的指本数据库支持的引擎，显示default的是本数据库默认的引擎。&lt;/p&gt;
&lt;p&gt;也可以用如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show variables like &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%storage_engine%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来显示数据库引擎。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.全量备份&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全量备份很简单，备份的命令是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;#--databases,指定数据库&lt;/p&gt;
&lt;p&gt;#--flush-logs，产生新的日志文件，binlog文件，这个在后面的增量备份有讲到过&lt;/p&gt;
&lt;p&gt;#--delete-master-logs，删掉原来的日志文件，binlog文件&lt;/p&gt;
&lt;p&gt;#DumpFile是要备份的目标文件&lt;/p&gt;
&lt;p&gt;mysqldump -uroot -p123456 --databases wordpressdb --flush-logs --delete-master-logs --single-transaction &amp;gt; $DumpFile&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;恢复的命令是在MySQL命令行中执行的，要先手动创建一个数据库，然后再use这个数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; source $DumpFile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;3.增量备份&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个操作需要MySQL本身的日志文件支持，登陆mysql，检查log-bin是否开启：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show variables like 'log_bin';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; show variables like &lt;span&gt;'&lt;/span&gt;&lt;span&gt;log_bin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | OFF   |
+---------------+-------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示OFF的话，那就是没有开始日志服务。那么找到MySQL的配置文件，更改配置，这个地方看了网上的很多教程，但是都没有用。大概他们讲的都是centos上的配置步骤吧，而我用的是基于debian的deepin15.6（Ubuntu应该也是适用的）。配置文件的目录是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/mysql/mysql.conf.d/mysqld.cnf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在其中加入这么几项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1432102/201808/1432102-20180803220258751-2000085721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，在终端中输入：sudo service mysql restart 重启MySQL服务，再登陆上MySQL，执行命令&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;show variables like 'log_bin';看到如下结果，证明binlog配置成功。&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
+---------------------------------+--------------------------------+
| Variable_name                   | Value                          |
+---------------------------------+--------------------------------+
| log_bin                         | ON                             |
| log_bin_basename                | /var/log/mysql/mysql-bin       |
| log_bin_index                   | /var/log/mysql/mysql-bin.index |
| log_bin_trust_function_creators | OFF                            |
| log_bin_use_v1_row_events       | OFF                            |
+---------------------------------+--------------------------------+
&lt;span&gt;5&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于binlog日志的详细配置用法：&lt;a href=&quot;https://www.ilanni.com/?p=7816&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;binlog_format 此参数配置binlog的日志格式，默认为mixed。

max_binlog_size此参数配置binlog的日志最大值，最大和默认值是1GB。

max_binlog_cache_size此参数表示binlog使用最大内存的数。

binlog&lt;/span&gt;-&lt;span&gt;do&lt;/span&gt;-db=&lt;span&gt;db_name 此参数表示只记录指定数据库的二进制日志。

binlog&lt;/span&gt;-ignore-db=&lt;span&gt;db_name此参数表示不记录指定的数据库的二进制日志。

expire_logs_days 此参数表示binlog日志保留的时间，默认单位是天。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于binlog日志的操作命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.查看所有binlog日志列表
　　mysql&lt;/span&gt;&amp;gt;&lt;span&gt; show master logs;

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.查看master状态，即最后(最新)一个binlog日志的编号名称，及其最后一个操作事件pos结束点(Position)值，这个文件就是当前MySQL在使用的binlog文件。
　　mysql&lt;/span&gt;&amp;gt;&lt;span&gt; show master status;

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.刷新log日志，自此刻开始产生一个新编号的binlog日志文件
　　mysql&lt;/span&gt;&amp;gt;&lt;span&gt; flush logs;
　　注：每当mysqld服务重启时，会自动执行此命令，刷新binlog日志；在mysqldump备份数据时加 &lt;/span&gt;-&lt;span&gt;F 选项也会刷新binlog日志；

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.重置(清空)所有binlog日志
　　mysql&lt;/span&gt;&amp;gt; reset master;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想查看binlog日志的具体内容，登录MySQL命令行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; show binlog events [IN &lt;span&gt;'&lt;/span&gt;&lt;span&gt;log_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] [FROM pos] [LIMIT [offset,] row_count];
选项解析：
IN &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;log_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   指定要查询的binlog文件名(不指定就是第一个binlog文件)
FROM pos        指定从哪个pos起始点开始查起(不指定就是从整个文件首个pos点开始算)
LIMIT [offset,] 偏移量(不指定就是0)
row_count       查询总条数(不指定就是所有行)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如做一下查询，在mysql-bin.000002文件中查询pos在219之后的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; show binlog events &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql-bin.000002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; from &lt;span&gt;219&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+------------------+-----+------------+-----------+-------------+----------------------------------------+
| Log_name         | Pos | Event_type | Server_id | End_log_pos | Info                                   |
+------------------+-----+------------+-----------+-------------+----------------------------------------+
| mysql-bin.&lt;span&gt;000002&lt;/span&gt; | &lt;span&gt;219&lt;/span&gt; | Query      |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;298&lt;/span&gt; | BEGIN                                  |
| mysql-bin.&lt;span&gt;000002&lt;/span&gt; | &lt;span&gt;298&lt;/span&gt; | Table_map  |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;366&lt;/span&gt; | table_id: &lt;span&gt;241&lt;/span&gt; (wordpressdb.wp_options) |
| mysql-bin.&lt;span&gt;000002&lt;/span&gt; | &lt;span&gt;366&lt;/span&gt; | Write_rows |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;447&lt;/span&gt; | table_id: &lt;span&gt;241&lt;/span&gt; flags: STMT_END_F        |
| mysql-bin.&lt;span&gt;000002&lt;/span&gt; | &lt;span&gt;447&lt;/span&gt; | Xid        |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;478&lt;/span&gt; | COMMIT &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; xid=53 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;                    |
+------------------+-----+------------+-----------+-------------+----------------------------------------+
&lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们的binlog日志功能算是做好了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;4.恢复数据实战&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，建立一个数据库，并且插入一些数据：在MySQL程序中输入以下命令：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; create database AAA;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; use AAA;
Database changed
mysql&lt;/span&gt;&amp;gt; create table BBB(&lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.04&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; insert into BBB (&lt;span&gt;id&lt;/span&gt;) values (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; insert into BBB (&lt;span&gt;id&lt;/span&gt;) values (&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; insert into BBB (&lt;span&gt;id&lt;/span&gt;) values (&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时，数据库AAA中的数据库表BBB中的内容如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;span&gt; from BBB;
&lt;/span&gt;+------+
| &lt;span&gt;id&lt;/span&gt;   |
+------+
|    &lt;span&gt;1&lt;/span&gt; |
|    &lt;span&gt;2&lt;/span&gt; |
|    &lt;span&gt;3&lt;/span&gt; |
+------+
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，使用MySQL的全量备份，备份整个AAA数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 --databases AAA --flush-logs --single-transaction &amp;gt; /home/xu/AAA.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们再对数据库AAA中的数据库表BBB做一些操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; insert into BBB (&lt;span&gt;id&lt;/span&gt;) values (&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; update BBB set &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt; where &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
Rows matched: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  Changed: &lt;span&gt;1&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，数据库AAA中的数据库表BBB的内容如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;span&gt; from BBB;
&lt;/span&gt;+------+
| &lt;span&gt;id&lt;/span&gt;   |
+------+
|    &lt;span&gt;1&lt;/span&gt; |
|    &lt;span&gt;2&lt;/span&gt; |
|    &lt;span&gt;5&lt;/span&gt; |
|    &lt;span&gt;4&lt;/span&gt; |
+------+
&lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，不小心删掉了数据库AAA：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; drop database AAA;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.03&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，迅速的查看当前使用的binlog文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; show master status;
&lt;/span&gt;+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; |      &lt;span&gt;818&lt;/span&gt; |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，查看这个binlog文件的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; show binlog events &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql-bin.000003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+------------------+-----+----------------+-----------+-------------+-----------------------------------------+
| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                    |
+------------------+-----+----------------+-----------+-------------+-----------------------------------------+
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; |   &lt;span&gt;4&lt;/span&gt; | Format_desc    |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;123&lt;/span&gt; | Server ver: &lt;span&gt;5.7&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-log, Binlog ver: &lt;span&gt;4&lt;/span&gt; |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;123&lt;/span&gt; | Previous_gtids |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;154&lt;/span&gt; |                                         |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;154&lt;/span&gt; | Anonymous_Gtid |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;219&lt;/span&gt; | SET @@SESSION.GTID_NEXT= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ANONYMOUS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;219&lt;/span&gt; | Query          |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;290&lt;/span&gt; | BEGIN                                   |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;290&lt;/span&gt; | Table_map      |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;335&lt;/span&gt; | table_id: &lt;span&gt;254&lt;/span&gt; (AAA.BBB)                 |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;335&lt;/span&gt; | Write_rows     |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;375&lt;/span&gt; | table_id: &lt;span&gt;254&lt;/span&gt; flags: STMT_END_F         |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;375&lt;/span&gt; | Xid            |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;406&lt;/span&gt; | COMMIT &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; xid=1777 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;                   |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;406&lt;/span&gt; | Anonymous_Gtid |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;471&lt;/span&gt; | SET @@SESSION.GTID_NEXT= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ANONYMOUS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;471&lt;/span&gt; | Query          |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;542&lt;/span&gt; | BEGIN                                   |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;542&lt;/span&gt; | Table_map      |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;587&lt;/span&gt; | table_id: &lt;span&gt;254&lt;/span&gt; (AAA.BBB)                 |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;587&lt;/span&gt; | Update_rows    |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;633&lt;/span&gt; | table_id: &lt;span&gt;254&lt;/span&gt; flags: STMT_END_F         |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;633&lt;/span&gt; | Xid            |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;664&lt;/span&gt; | COMMIT &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; xid=1778 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;                   |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;664&lt;/span&gt; | Anonymous_Gtid |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;729&lt;/span&gt; | SET @@SESSION.GTID_NEXT= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ANONYMOUS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    |
| mysql-bin.&lt;span&gt;000003&lt;/span&gt; | &lt;span&gt;729&lt;/span&gt; | Query          |         &lt;span&gt;1&lt;/span&gt; |         &lt;span&gt;818&lt;/span&gt; | drop database AAA                       |
+------------------+-----+----------------+-----------+-------------+-----------------------------------------+
&lt;span&gt;14&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从中，我们可以看见，最后一个命令正式删除数据的操作。&lt;/p&gt;
&lt;p&gt;所以，先恢复全量备份的数据库文件AAA.sql, 在从增量备份文件mysql-bin.000003,恢复文件。因为恢复文件过程中，依然要在binlog中记录，所以首先要刷新binlog文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; flush logs;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.02&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; show master status;
&lt;/span&gt;+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.&lt;span&gt;000004&lt;/span&gt; |      &lt;span&gt;154&lt;/span&gt; |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，恢复过程中的记录就不会再记录到mysql-bin.000003中，造成死循环了。并且，在恢复过程中，一定要关闭对数据库AAA的操作。&lt;/p&gt;
&lt;p&gt;首先，手动创建数据库AAA，然后使用恢复全量文件AAA.sql:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; create database AAA;
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; use AAA;
Database changed
mysql&lt;/span&gt;&amp;gt; source /home/xu/&lt;span&gt;AAA.sql
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
(…………………………………………………………………………………………)
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，查询数据库，有如下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;span&gt; from BBB;
&lt;/span&gt;+------+
| &lt;span&gt;id&lt;/span&gt;   |
+------+
|    &lt;span&gt;1&lt;/span&gt; |
|    &lt;span&gt;2&lt;/span&gt; |
|    &lt;span&gt;3&lt;/span&gt; |
+------+
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，从增量文件mysql-bin.000003中恢复BBB数据库中的其他数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      恢复语法格式：
      # mysqlbinlog mysql&lt;/span&gt;-bin.0000xx | mysql -u用户名 -&lt;span&gt;p密码 数据库名

        常用选项：
          &lt;/span&gt;--start-position=&lt;span&gt;953&lt;/span&gt;&lt;span&gt;                   起始pos点
          &lt;/span&gt;--stop-position=&lt;span&gt;1437&lt;/span&gt;&lt;span&gt;                   结束pos点
          &lt;/span&gt;--start-datetime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2013-11-29 13:18:54&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 起始时间点
          &lt;/span&gt;--stop-datetime=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2013-11-29 13:21:53&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  结束时间点
          &lt;/span&gt;--database=&lt;span&gt;zyyshop                     指定只恢复zyyshop数据库(一台主机上往往有多个数据库，只限本地log日志)
            
        不常用选项：    
          &lt;/span&gt;-u --user=&lt;span&gt;name              Connect to the remote server as username.连接到远程主机的用户名
          &lt;/span&gt;-p --password[=&lt;span&gt;name]        Password to connect to remote server.连接到远程主机的密码
          &lt;/span&gt;-h --host=&lt;span&gt;name              Get the binlog from server.从远程主机上获取binlog日志
          &lt;/span&gt;--read-from-remote-server   Read binary logs from a MySQL server.从某个MySQL服务器上读取binlog日志
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，这里恢复命令是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
root@DESKTOP-M1SSCB1:/var/log/mysql# mysqlbinlog --stop-position=&lt;span&gt;729&lt;/span&gt; --database=AAA /var/log/mysql/mysql-bin.&lt;span&gt;000003&lt;/span&gt; | mysql -uroot -p123456 -v AAA
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在恢复的时候，一定要注意--stop-position这个命令，不然，很可能会使得drop命令还被执行。&lt;/p&gt;
&lt;p&gt;再观察数据库，可以看到数据库恢复成功：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; *&lt;span&gt; from BBB;
&lt;/span&gt;+------+
| &lt;span&gt;id&lt;/span&gt;   |
+------+
|    &lt;span&gt;1&lt;/span&gt; |
|    &lt;span&gt;2&lt;/span&gt; |
|    &lt;span&gt;5&lt;/span&gt; |
|    &lt;span&gt;4&lt;/span&gt; |
+------+
&lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; set (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;5.通过脚本实现定时的备份&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全量备份的脚本如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash
export LANG&lt;/span&gt;=en_US.UTF-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
BakDir&lt;/span&gt;=/home/xu/mysql/&lt;span&gt;backup
LogFile&lt;/span&gt;=/home/xu/mysql/backup/&lt;span&gt;bak.log
Date&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +%Y%m%d%H%M%&lt;span&gt;S`
Begin&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y年%m月%d日 %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`
cd $BakDir
DumpFile&lt;/span&gt;=&lt;span&gt;$Date.sql
GZDumpFile&lt;/span&gt;=&lt;span&gt;$Date.sql.tgz
#&lt;/span&gt;--&lt;span&gt;databases,指定数据库,所有表格的表结构及其数据
#&lt;/span&gt;--flush-&lt;span&gt;logs，产生新的日志文件，binlog文件，这个在后面的增量备份有讲到过
#&lt;/span&gt;--delete-master-&lt;span&gt;logs，删掉原来的日志文件，binlog文件
#DumpFile是要备份的目标文件
mysqldump &lt;/span&gt;-uroot -p123456 --databases wordpressdb --flush-logs --single-transaction &amp;gt;&lt;span&gt; $DumpFile
#&lt;/span&gt;&lt;span&gt;tar&lt;/span&gt; -&lt;span&gt;czvf $GZDumpFile $DumpFile
#&lt;/span&gt;&lt;span&gt;rm&lt;/span&gt;&lt;span&gt; $DumpFile

#只保留过去四周的数据库内容
count&lt;/span&gt;=$(&lt;span&gt;ls&lt;/span&gt; -l *.sql |&lt;span&gt;wc&lt;/span&gt; -&lt;span&gt;l)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ $count -ge &lt;span&gt;5&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
&lt;span&gt;file&lt;/span&gt;=$(&lt;span&gt;ls&lt;/span&gt; -l *.sql |&lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{print $9}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;|&lt;span&gt;awk&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NR==1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;rm&lt;/span&gt; -f $&lt;span&gt;file&lt;/span&gt;
&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;

 
Last&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y年%m月%d日 %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;`
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 开始:$Begin 结束:$Last $GZDumpFile succ &amp;gt;&amp;gt;&lt;span&gt; $LogFile

#恢复命令：在MySQL命令行里面使用source命令  mysql&lt;/span&gt;&amp;gt; source /home/xu/mysql/backup/&lt;span&gt;20180804104810&lt;/span&gt;.sql
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，通过crontab来设置定时运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi&lt;/span&gt; /etc/&lt;span&gt;crontab

#每个星期日凌晨3:00执行完全备份脚本
&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; * * &lt;span&gt;0&lt;/span&gt; /......../databak.&lt;span&gt;sh&lt;/span&gt; &amp;gt;/dev/&lt;span&gt;null&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使上述定时任务生效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
crontab /etc/crontab
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Sun, 02 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>初心不负丶</dc:creator>
<og:description>1.环境 系统是Deepin15.6，数据库的版本号是： 数据库引擎是：InnoDB。如何查看数据库版本和数据库引擎呢？ 终端登录MySQL数据库命令行的时候，就可以看见数据库版本。 登录数据库后，使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chuxinbufu/p/9576446.html</dc:identifier>
</item>
<item>
<title>Win32知识之窗口绘制.窗口第一讲 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9576439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9576439.html</guid>
<description>&lt;h2&gt;一丶摘要&lt;/h2&gt;
&lt;p&gt;　　在学习Win32的时候. 很多操作都是窗口进行操作的.那么今天就说一下窗口的本质是什么. &lt;/p&gt;
&lt;p&gt;窗口的本质是不断绘制.是windows通过消息机制进行绘制的.&lt;/p&gt;
&lt;p&gt;我们知道.内存分为高低2G 低2G是给应用程序使用的. 高2G是给操作系统使用的.而我们画图形的操作都是操作系统通过底层的 win32k.sys这个驱动来提供的.&lt;/p&gt;
&lt;p&gt;进程跟线程管理是通过notokerner.exe这个程序来管理的.但是三环不能使用.所以提供接口给三环. 分别是kerner32.dll 跟user32.dll gdi.dll&lt;/p&gt;
&lt;p&gt;那么他们之间的区别是什么.&lt;/p&gt;
&lt;p&gt;1.kerner32.dll  管理进程线程跟内存的一个dll&lt;/p&gt;
&lt;p&gt;2.user32.dll   窗口管理.图形界面管理.&lt;/p&gt;
&lt;p&gt;3.gdi.dll         自己绘制的的管理.&lt;/p&gt;
&lt;p&gt;而我们要认识一下窗口的创建.那么需要了解几个基础的只是.&lt;/p&gt;
&lt;p&gt;1.设备对象.&lt;/p&gt;
&lt;p&gt;2.DC设备上下文.&lt;/p&gt;
&lt;p&gt;3.图形对象.&lt;/p&gt;
&lt;h3&gt;1.设备对象是什么.&lt;/h3&gt;
&lt;p&gt;　　简而言之设备对象的意思就是你要画图形要往哪里画. 每一个窗口都有一个窗口句柄.而且是存放在全局窗口句柄表中的. 我们可以获取一下.使用Spy++获取.&lt;/p&gt;
&lt;h3&gt;2.DC设备上下文.&lt;/h3&gt;
&lt;p&gt;　　DC设备上下文其实就是这个窗口有一块内存是绘制用的. 我们想要往这个窗口绘制.需要先绘制到这个内存中才可以.这块内存就称为DC上下文.&lt;/p&gt;
&lt;h3&gt;3.图形对象.&lt;/h3&gt;
&lt;p&gt;　　图形对象就是指画笔 画刷 位图. 等等这些对象.因为我们要往内存中画的时候.可以画默认的.但是一般我们想改变一下形式.所以创建图形对象跟DC相关联.那么我们绘制就可以使用图形对象了.&lt;/p&gt;
&lt;h2&gt;二丶绘制窗口步骤&lt;/h2&gt;
&lt;p&gt;　　绘制窗口免不了使用API.但是使用之前.需要知道我们要操作的步骤.&lt;/p&gt;
&lt;p&gt;1.获取窗口句柄.也就是设备对象.&lt;/p&gt;
&lt;p&gt;2.获取窗口中的DC上下文.可以理解为获取指定窗口的绘图的那块内存.&lt;/p&gt;
&lt;p&gt;3.创建图形对象. 要想绘制.那么首先就需要你自定义的一个绘制的东西才可以.&lt;/p&gt;
&lt;p&gt;4.关联图形对象跟DC. 只要关联了.那么绘制的时候自动就使用你的图形对象了.&lt;/p&gt;
&lt;p&gt;5.进行你的绘图操作. 这里就是你写的绘图代码了.&lt;/p&gt;
&lt;p&gt;6.释放资源. 不管是窗口句柄也好. DC也好.图形对象也好.都是内核对象.所以我们需要进行释放.&lt;/p&gt;
&lt;p&gt;具体API:&lt;/p&gt;
&lt;p&gt;　1.获取指定窗口句柄.     FindWindowA/FindWindowW&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HWND FindWindowA(
  LPCSTR lpClassName,              窗口类名.字符串. 可以用Spy&lt;/span&gt;++&lt;span&gt;获取
  LPCSTR lpWindowName           窗口名称
);
返回窗口句柄.                          &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2.获取DC设备上下文.   GetDc()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HDC GetDC(
  HWND hWnd                    传入设备对象.也就是窗口句柄
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.创建图形对象.&lt;/p&gt;
&lt;p&gt;　PS: 创建图形对象.图形对象有很多. 有画笔. 画刷. 等等.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HPEN CreatePen(
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;      iStyle,                创建笔的风格, 意思就是你的画笔是实心的 还是虚线 还是其他.
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;      cWidth,              笔的宽度.如果实心的.笔的宽度则自定义设置.如果其他.不能超过1
  COLORREF color            RGB的颜色.  你的画笔是什么颜色的.是一串16进制可以在线取色
);
返回图形对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有常用的.创建矩形区域.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HRGN CreateRectRgn(
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x1,
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y1,                             坐标
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x2,
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y2
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体使用可以查询MSDN: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/desktop/gdi/windows-gdi&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/windows/desktop/gdi/windows-gdi&lt;/a&gt;  代码使用例子&lt;/p&gt;
&lt;p&gt;如果你安装了MSDN 2001版本.搜索SelectObject可以看到. 图形对象有很多.并且告诉你相应的API&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180902232045445-2072153518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bitmap  位图. 后面是操作的API&lt;/p&gt;
&lt;p&gt;Brush     画刷&lt;/p&gt;
&lt;p&gt;字体&lt;/p&gt;
&lt;p&gt;笔&lt;/p&gt;
&lt;p&gt;矩形&lt;/p&gt;
&lt;p&gt;4.关联DC跟图形对象.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
HGDIOBJ SelectObject(  HDC hdc,          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle to DC&lt;/span&gt;
  HGDIOBJ hgdiobj   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; handle to object);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 5.写你想要绘制的代码.&lt;/p&gt;
&lt;p&gt;这里如果是画线. 则用 LineTo(Hdc,x,y) 这个API  给定一个DC.给个x y坐标.则可以绘制.&lt;/p&gt;
&lt;p&gt;当然如果指定在哪里开始绘制则用MoveToEx指定起始位置.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BOOL MoveToEx(
  HDC     hdc,
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;     x,
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;     y,
  LPPOINT lppt
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.释放资源.&lt;/p&gt;
&lt;p&gt;释放资源很简单了. 如果是图形对象.同一使用DeleteObject(对象) 进行删除.&lt;/p&gt;
&lt;p&gt;如果是DC. 如果是创建的Dc.则用DeleteDc(DC对象)来进行删除.&lt;/p&gt;
&lt;p&gt;如果是获取的DC.则用ReleaseDc(Dc对象) 来进行删除.&lt;/p&gt;
&lt;p&gt;题外话. windows程序中还有一个API.可以获取DC中默认的图形对象.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HGDIOBJ GetStockObject(
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i                                  对象的类型.你想从DC中获取什么对象类型.
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图像类型如果是 &lt;span&gt;&lt;span&gt;DC_BRUSH 则是获取纯色刷.就不用自己创建色刷了.可以通过操作色刷的API进行操作.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;COLORREF SetDCBrushColor(
  HDC      hdc,
  COLORREF color                   RGB颜色
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三丶绘制图形.&lt;/p&gt;
&lt;h3&gt;1.绘制直线的代码例子.&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Windows.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取窗口句柄&lt;/span&gt;
    HWND hwnd = ::FindWindow(NULL, TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;计算器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取DC.&lt;/span&gt;
    HDC hdc =&lt;span&gt; ::GetDC(hwnd);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.创建图形对象.&lt;/span&gt;
    HPEN hPen = CreatePen(PS_SOLID, &lt;span&gt;10&lt;/span&gt;, RGB(&lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为红色画笔

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.关联图形对象跟DC&lt;/span&gt;
    HPEN oldPen = (HPEN)::SelectObject(hdc, hPen); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回旧的画笔
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.绘制直线.&lt;/span&gt;
    MoveToEx(hdc, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, NULL);
    LineTo(hdc, &lt;/span&gt;&lt;span&gt;600&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.释放资源.&lt;/span&gt;
    ::SelectObject(hdc, oldPen); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先还原旧画笔&lt;/span&gt;
    DeleteObject(hPen);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图形对象.&lt;/span&gt;
    ReleaseDC(hwnd,hdc);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放Dc&lt;/span&gt;
&lt;span&gt;
    system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行之后图片.注意不要遮挡计算器.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180902233658046-614385048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 2.绘制矩形.获取默认画刷.设置画刷区域颜色.&lt;/h3&gt;
&lt;p&gt; 绘制代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Windows.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获取窗口句柄&lt;/span&gt;
    HWND hwnd = ::FindWindow(NULL, TEXT(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;计算器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取DC.&lt;/span&gt;
    HDC hdc =&lt;span&gt; ::GetDC(hwnd);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.创建图形对象.&lt;/span&gt;
    HPEN hPen = CreatePen(PS_SOLID, &lt;span&gt;10&lt;/span&gt;, RGB(&lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为红色画笔&lt;/span&gt;
    HBRUSH hBru =&lt;span&gt; (HBRUSH)::GetStockObject(DC_BRUSH);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.关联图形对象跟DC&lt;/span&gt;
    HPEN oldPen = (HPEN)::SelectObject(hdc, hPen); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回旧的画笔&lt;/span&gt;
    SetDCBrushColor(hdc, RGB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置画刷颜色&lt;/span&gt;
    HBRUSH oldBrush =&lt;span&gt; (HBRUSH)::SelectObject(hdc, hBru);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.绘制句柄&lt;/span&gt;
    Rectangle(hdc, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6.释放资源.&lt;/span&gt;
    ::SelectObject(hdc, oldPen); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先还原旧画笔&lt;/span&gt;
    DeleteObject(hPen);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图形对象.&lt;/span&gt;
    ReleaseDC(hwnd,hdc);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放Dc&lt;/span&gt;
&lt;span&gt;
    system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中新用到的API就是绘制矩形的API. &lt;/p&gt;
&lt;p&gt;绘制完毕结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180902234024178-937634569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 02 Sep 2018 15:41:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>Win32知识之窗口本质 一丶摘要 在学习Win32的时候. 很多操作都是窗口进行操作的.那么今天就说一下窗口的本质是什么. 窗口的本质是不断绘制.是windows通过消息机制进行绘制的. 我们知道.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9576439.html</dc:identifier>
</item>
<item>
<title>【JavaScript动画基础】学习笔记（一）-- 旋转箭头 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9576385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9576385.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201809/417688-20180902221210599-831587140.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着鼠标的移动旋转箭头。&lt;/p&gt;
&lt;h3&gt;requestAnimationFrame&lt;/h3&gt;
&lt;p&gt;在requestAnimationFrame之前我们可以用setInterval来实现动画的循环：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawFrame(){
       ball.x&lt;/span&gt;+=1&lt;span&gt;;
       ball.draw(context);
     }
     window.setInterval(drawFrame,&lt;/span&gt;1000/60)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而html5中增加了window.requestAnimationFrame，它接收一个回调函数，确保在重绘前执行该函数，第二个参数可以指定一个html元素作为动画的执行区域。可以这样调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawFrame(){
 window.requestAnimationFrame(drawFrame,canvas);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;... &lt;/span&gt;
&lt;span&gt;
}());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;旋转：&lt;/h3&gt;
&lt;p&gt;旋转的根本在于求出鼠标位置相对于箭头中心坐标的角度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201809/417688-20180902222826769-1971605576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;求出dy的对角就能确定旋转的角度，而dy和dx构成了tan，可以通过反正切函数得到，JavaScript提供了两个反正切函数，一个是Math.atan,一个是Math.atan2,区别如下。&lt;/p&gt;
&lt;p&gt;atan接收一个参数，得到弧度，atan2接收两个参数，分别是对边y和底边x。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201809/417688-20180902232005991-1406565831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是得到代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
      window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas=document.getElementById('canvas'&lt;span&gt;),
       context&lt;/span&gt;=canvas.getContext('2d'&lt;span&gt;),
       mouse&lt;/span&gt;=&lt;span&gt;utils.captureMouse(canvas),
       arrow&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Arrow();
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arrow1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Arrow();

       arrow.x&lt;/span&gt;=canvas.width/3;
       arrow.y=canvas.height/2;
&lt;span&gt;       

       arrow1.x&lt;/span&gt;=canvas.width/1.5;
       arrow1.y=canvas.height/2;
&lt;span&gt;       

(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; drawFrame(){
 window.requestAnimationFrame(drawFrame,canvas);
 context.clearRect(&lt;/span&gt;0, 0&lt;span&gt;, canvas.width, canvas.height)
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dx=mouse.x-&lt;span&gt;arrow.x; 
 dy&lt;/span&gt;=mouse.y-&lt;span&gt;arrow.y;
&lt;span&gt; arrow.rotation&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt;Math.atan2(dy,dx);&lt;/span&gt;
 arrow.draw(context);

 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dx1=mouse.x-&lt;span&gt;arrow1.x;
 dy1&lt;/span&gt;=mouse.y-&lt;span&gt;arrow1.y;
 arrow1.rotation&lt;/span&gt;=-&lt;span&gt;Math.atan2(dy,dx);
 arrow1.draw(context);

}());

     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;captureMouse：&lt;/h3&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a3d16ada-0bb6-444c-83e0-b4b30a6586d6')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_a3d16ada-0bb6-444c-83e0-b4b30a6586d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a3d16ada-0bb6-444c-83e0-b4b30a6586d6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a3d16ada-0bb6-444c-83e0-b4b30a6586d6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a3d16ada-0bb6-444c-83e0-b4b30a6586d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
window.utils.captureMouse = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (element) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mouse = {x: 0, y: 0, event: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;},
      body_scrollLeft &lt;/span&gt;=&lt;span&gt; document.body.scrollLeft,
      element_scrollLeft &lt;/span&gt;=&lt;span&gt; document.documentElement.scrollLeft,
      body_scrollTop &lt;/span&gt;=&lt;span&gt; document.body.scrollTop,
      element_scrollTop &lt;/span&gt;=&lt;span&gt; document.documentElement.scrollTop,
      offsetLeft &lt;/span&gt;=&lt;span&gt; element.offsetLeft,
      offsetTop &lt;/span&gt;=&lt;span&gt; element.offsetTop;
  
  element.addEventListener(&lt;/span&gt;'mousemove', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; x, y;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (event.pageX ||&lt;span&gt; event.pageY) {
      x &lt;/span&gt;=&lt;span&gt; event.pageX;
      y &lt;/span&gt;=&lt;span&gt; event.pageY;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      x &lt;/span&gt;= event.clientX + body_scrollLeft +&lt;span&gt; element_scrollLeft;
      y &lt;/span&gt;= event.clientY + body_scrollTop +&lt;span&gt; element_scrollTop;
    }
    x &lt;/span&gt;-=&lt;span&gt; offsetLeft;
    y &lt;/span&gt;-=&lt;span&gt; offsetTop;
    
    mouse.x &lt;/span&gt;=&lt;span&gt; x;
    mouse.y &lt;/span&gt;=&lt;span&gt; y;
    mouse.event &lt;/span&gt;=&lt;span&gt; event;
  }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mouse;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;箭头：&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a28d4bd5-6bce-4c65-b235-87d5017475da')&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_a28d4bd5-6bce-4c65-b235-87d5017475da&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a28d4bd5-6bce-4c65-b235-87d5017475da&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a28d4bd5-6bce-4c65-b235-87d5017475da',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a28d4bd5-6bce-4c65-b235-87d5017475da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Arrow () {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color = &quot;#ffff00&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.rotation = 0&lt;span&gt;;
}

Arrow.prototype.draw &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (context) {
  context.save();
  context.translate(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.y);
  context.rotate(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.rotation);
  
  context.lineWidth &lt;/span&gt;= 2&lt;span&gt;;
  context.fillStyle &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color;
  context.beginPath();
  context.moveTo(&lt;/span&gt;-50, -25&lt;span&gt;);
  context.lineTo(&lt;/span&gt;0, -25&lt;span&gt;);
  context.lineTo(&lt;/span&gt;0, -50&lt;span&gt;);
  context.lineTo(&lt;/span&gt;50, 0&lt;span&gt;);
  context.lineTo(&lt;/span&gt;0, 50&lt;span&gt;);
  context.lineTo(&lt;/span&gt;0, 25&lt;span&gt;);
  context.lineTo(&lt;/span&gt;-50, 25&lt;span&gt;);
  context.lineTo(&lt;/span&gt;-50, -25&lt;span&gt;);
  context.closePath();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成轨迹&lt;/span&gt;
  context.fill();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;填充&lt;/span&gt;
  context.stroke();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画出边线&lt;/span&gt;
&lt;span&gt;  
   context.restore();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使得canvas原点回到save之前&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 02 Sep 2018 15:24:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<og:description>随着鼠标的移动旋转箭头。 requestAnimationFrame 在requestAnimationFrame之前我们可以用setInterval来实现动画的循环： 而html5中增加了windo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9576385.html</dc:identifier>
</item>
<item>
<title>Python从菜鸟到高手（2）：清空Python控制台 - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/9576368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/9576368.html</guid>
<description>&lt;p&gt;执行python命令会进入Python控制台。在Python控制台中可以用交互的方式执行Python语句。也就是执行一行Python语句，会立刻返回执行结果。&lt;/p&gt;
&lt;p&gt;  当Python控制台输入过多的Python语句时，有时需要将这些已经输入的语句和执行结果清空，并重新开始输入Python语句。例如，下图就是一个输入了多条Python语句，并输出相应结果的Python控制台。&lt;br/&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://geekori.com/images/editorUpload/18-08/uploadImg_385061533739795.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  当然，如果不想看到这些Python语句和输出结果，可以一直按“回车” 键，直到Python控制台中所有的内容都移到窗口上面为止。不过这样以来，光标还是在Python控制台的最下面，而且上面都是Python控制台的命令提示符，非常难看，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://geekori.com/images/editorUpload/18-08/uploadImg_183081533739859.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  如果读者用的是Mac OS X系统，在Python控制台中直接按Ctrl+L键就可以直接清空Python控制台。而在Windows中，是没有快捷键用来清空Python控制台的，所以需要我们编写Python代码来实现清空Python控制台的功能。因此，本节的目的到现在已经很清楚了，本节主要并不是教大家如何清空Python控制台，而是借用清空Python控制台这一操作，利用前面两节介绍的导入模块和声明变量的知识，编写一段Python程序，用来清空Python for Windows控制台。&lt;/p&gt;
&lt;p&gt;  在Windows下，如果要清空Windows控制台，执行cls命令即可。由于Python控制台是利用Windows控制台实现的，所以cls命令也同样可以清空Python控制台。不过在Python控制台不能直接执行cls命令。在Python控制台要想执行外部命令，需要调用os模块中的system函数。读者可以一行一行在Python控制台输入下面的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os               # 导入os模块
os.system('cls')        # 执行cls命令清空Python控制台
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  执行这两行代码，是把以前在Python控制台中输入的内容都清空了，但在Python控制台的第1行会输出一个“0”，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://geekori.com/images/editorUpload/18-08/uploadImg_147511533739985.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  其实这个“0”是os.system函数的返回值。Python控制台会输出每一条执行语句的返回值。os.system函数如果成功执行命令，返回“0”，如果执行命令失败，返回“1”。不过为了最求完美，现在就把这个“0”去掉。&lt;/p&gt;
&lt;p&gt;  之所以会输出这个“0”，是因为Python语言的标准输出默认指向的是Python控制台，所以所有的Python语句执行的结果都输出到了Python控制台。现在只要改变Python语言的标准输出，让其指向一个文件，那么os.system函数的执行结果就会直接写到这个文件中，而不是Python控制台了。&lt;/p&gt;
&lt;p&gt;  下面的例子会编写一个Python程序，用于清空Python控制台。&lt;br/&gt;清空Python控制台不输出“0”的步骤如下：&lt;/p&gt;
&lt;p&gt;（1）导入os模块和sys模块。&lt;/p&gt;
&lt;p&gt;（2）使用open函数以可写的方式打开一个文件，本例是out.log。&lt;/p&gt;
&lt;p&gt;（3）为了不影响在Python控制台输出其他语句的执行结果，应先将Python默认的标准输出保存到一个变量中，以便以后恢复默认的Python标准输出。使用sys.stdout可以获取Python标准输出的句柄（Handler）。&lt;/p&gt;
&lt;p&gt;（4）将Python标准输出指向第2步打开的文件。&lt;/p&gt;
&lt;p&gt;（5）使用os.system函数执行cls命令。&lt;/p&gt;
&lt;p&gt;（6）恢复Python默认的标准输出。&lt;/p&gt;
&lt;p&gt;  完整的实现代码如下。读者可以在Python控制台一行行输入这些代码，当执行到os.system(‘cls’)语句时，Python控制台被清空，不会再显示“0”。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os                           # 导入os模块
import sys                          # 导入sys模块
f_handler=open('out.log', 'w')      # 打开out.log文件
oldstdout = sys.stdout              # 保存默认的Python标准输出
sys.stdout=f_handler                # 将Python标准输出指向out.log
os.system('cls')                    # 清空Python控制台       
sys.stdout = oldstdout              # 恢复Python默认的标准输出
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.51cto.com/androidguy/2165688&quot;&gt;《Python从菜鸟到高手》已经出版，购买送视频课程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;《Python从菜鸟到高手》知识结构图。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://product.dangdang.com/25333314.html&quot;&gt;&lt;img src=&quot;https://images.gitbook.cn/d538caf0-ac45-11e8-8a14-814e96ebc1f4&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;扫描二维码关注“极客起源”公众号，技术文章、视频课程应有尽有&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://geekori.com&quot;&gt;&lt;img src=&quot;https://images.gitbook.cn/d7e26860-ab9b-11e8-87e9-ff1b5a533fcd&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注“Python开发者基地”公众号&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://geekori.com&quot;&gt;&lt;img src=&quot;https://images.gitbook.cn/78d92f20-ab9b-11e8-87ba-0f736030f91e&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 15:18:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>执行python命令会进入Python控制台。在Python控制台中可以用交互的方式执行Python语句。也就是执行一行Python语句，会立刻返回执行结果。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nokiaguy/p/9576368.html</dc:identifier>
</item>
<item>
<title>深入理解 Java 动态代理机制 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/9573202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/9573202.html</guid>
<description>&lt;p&gt;Java 有两种代理方式，一种是静态代理，另一种是动态代理。对于静态代理，其实就是通过依赖注入，对对象进行封装，不让外部知道实现的细节。很多 API 就是通过这种形式来封装的。&lt;/p&gt;
&lt;p&gt;代理模式结构图（图片来自《大话设计模式》）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/916005/201809/916005-20180902210616238-1002732111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面看下两者在概念上的解释：&lt;/p&gt;
&lt;h3 id=&quot;2静态代理&quot;&gt;静态代理&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;静态代理类：由程序员创建或者由第三方工具生成，再进行编译；在程序运行之前，代理类的.class文件已经存在了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态代理类通常只代理一个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态代理事先知道要代理的是什么。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3动态代理&quot;&gt;动态代理&lt;/h3&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;动态代理类：在程序运行时，通过反射机制动态生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;动态代理类通常代理接口下的所有类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;动态代理事先不知道要代理的是什么，只有在运行的时候才能确定。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;动态代理的调用处理程序必须事先InvocationHandler接口，及使用Proxy类中的newProxyInstance方法动态的创建代理类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java动态代理只能代理接口，要代理类需要使用第三方的CLIGB等类库。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;动态代理的好处&lt;/h3&gt;
&lt;p&gt;Java动态代理的优势是实现无侵入式的代码扩展，也就是方法的增强；让你可以在不用修改源码的情况下，增强一些方法；在方法的前后你可以做你任何想做的事情（甚至不去执行这个方法就可以）。此外，也可以减少代码量，如果采用静态代理，类的方法比较多的时候，得手写大量代码。&lt;/p&gt;
&lt;h2&gt;动态代理实例&lt;/h2&gt;
&lt;p&gt;静态代理的实例这里就不说了，比较简单。在 java 的 java.lang.reflect 包下提供了一个 Proxy 类和一个 InvocationHandler 接口，通过这个类和这个接口可以生成 JDK 动态代理类和动态代理对象。下面讲讲动态代理的实现。&lt;/p&gt;
&lt;p&gt;先定义一个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再定义一个学生 Student 类来实现 Person 接口，每一个学生都有一个自己的名字：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Student &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Person {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String mName;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student(String name) {
        mName &lt;/span&gt;=&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        mName &lt;/span&gt;=&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Student 类中，定义了一个私有变量 mName，用来表示 Student 的名字。接下去定义一个代理 handler，就是用来帮我们处理代理的 :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonHandler&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理的目标对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; T mTarget;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PersonHandler(T target) {
        mTarget &lt;/span&gt;=&lt;span&gt; target;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object o, Method method, Object[] objects) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用开始前的操作&lt;/span&gt;
&lt;span&gt;        ProxyUtil.start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用方法,通过反射的形式来调用 mTarget 的 method &lt;/span&gt;
        Object result =&lt;span&gt; method.invoke(mTarget, objects);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印改名前的名字&lt;/span&gt;
        ProxyUtil.log(objects[0&lt;span&gt;].toString());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用结束后的操作&lt;/span&gt;
&lt;span&gt;        ProxyUtil.finish();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现，我们在调用代码前后都做了一些操作，甚至可以直接拦截该方法，不让其运行。其中定义了一个 ProxyUtil 类，方便我们做一些操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyUtil {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TAG = &quot;ProxyUtil&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        Log.d(TAG, &lt;/span&gt;&quot;start: &quot; +&lt;span&gt; System.currentTimeMillis());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finish() {
        Log.d(TAG, &lt;/span&gt;&quot;finish: &quot; +&lt;span&gt; System.currentTimeMillis());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; log(String name) {
        Log.d(TAG, &lt;/span&gt;&quot;log: &quot; +&lt;span&gt; name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下去开始编写代理的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个实例对象，这个对象是被代理的对象&lt;/span&gt;
        Person zhangsan = &lt;span&gt;new&lt;/span&gt; Student(&quot;张三&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个与代理对象相关联的 InvocationHandler&lt;/span&gt;
        PersonHandler stuHandler = &lt;span&gt;new&lt;/span&gt; PersonHandler&amp;lt;&amp;gt;&lt;span&gt;(zhangsan);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个代理对象 stuProxy 来代理 zhangsan，代理对象的每个执行方法都会替换执行 Invocation 中的 invoke 方法&lt;/span&gt;
        Person stuProxy = (Person) Proxy.newProxyInstance(Person.&lt;span&gt;class&lt;/span&gt;.getClassLoader(), &lt;span&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[]{Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}, stuHandler);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理执行 setName 的方法&lt;/span&gt;
        stuProxy.setName(&quot;王五&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下打印输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/916005/201809/916005-20180902145053525-1168620764.png&quot; alt=&quot;&quot; width=&quot;838&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现代理成功了。并且我们在调用方式的之前之后，都做了一些操作。Spring 的 AOP 其就是通过动态代理的机制实现的。&lt;/p&gt;

&lt;p&gt;其中，我们将 stuProxy 的类名打印出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Log.d(TAG, &quot;onCreate: &quot; + stuProxy.getClass().getCanonicalName());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/916005/201809/916005-20180902145031794-1937126148.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;28&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 发现其名字竟然是 $Proxy0。具体原因下面会解释。&lt;/p&gt;
&lt;h2&gt;源码分析&lt;/h2&gt;
&lt;p&gt;上面我们利用 Proxy 类的 newProxyInstance 方法创建了一个动态代理对象，查看该方法的源码: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns an instance of a proxy class for the specified interfaces
     * that dispatches method invocations to the specified invocation
     * handler.
     *
     * &amp;lt;p&amp;gt;{&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance} throws
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; IllegalArgumentException} for the same reasons that
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Proxy.getProxyClass} does.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;   loader the class loader to define the proxy class
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;   interfaces the list of interfaces for the proxy class
     *          to implement
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;   h the invocation handler to dispatch method invocations to
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;  a proxy instance with the specified invocation handler of a
     *          proxy class that is defined by the specified class loader
     *          and that implements the specified interfaces
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt;  IllegalArgumentException if any of the restrictions on the
     *          parameters that may be passed to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; getProxyClass}
     *          are violated
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt;  SecurityException if a security manager, &amp;lt;em&amp;gt;s&amp;lt;/em&amp;gt;, is present
     *          and any of the following conditions is met:
     *          &amp;lt;ul&amp;gt;
     *          &amp;lt;li&amp;gt; the given {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; loader} is {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} and
     *               the caller's class loader is not {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null} and the
     *               invocation of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SecurityManager#checkPermission
     *               s.checkPermission} with
     *               {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; RuntimePermission(&quot;getClassLoader&quot;)} permission
     *               denies access;&amp;lt;/li&amp;gt;
     *          &amp;lt;li&amp;gt; for each proxy interface, {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; intf},
     *               the caller's class loader is not the same as or an
     *               ancestor of the class loader for {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; intf} and
     *               invocation of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SecurityManager#checkPackageAccess
     *               s.checkPackageAccess()} denies access to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; intf};&amp;lt;/li&amp;gt;
     *          &amp;lt;li&amp;gt; any of the given proxy interfaces is non-public and the
     *               caller class is not in the same {&lt;/span&gt;&lt;span&gt;@linkplain&lt;/span&gt;&lt;span&gt; Package runtime package}
     *               as the non-public interface and the invocation of
     *               {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SecurityManager#checkPermission s.checkPermission} with
     *               {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ReflectPermission(&quot;newProxyInPackage.{package name}&quot;)}
     *               permission denies access.&amp;lt;/li&amp;gt;
     *          &amp;lt;/ul&amp;gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt;  NullPointerException if the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; interfaces} array
     *          argument or any of its elements are {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null}, or
     *          if the invocation handler, {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; h}, is
     *          {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CallerSensitive
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object newProxyInstance(ClassLoader loader,
                                          Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt;[] interfaces,
                                          InvocationHandler h)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
    {&lt;br/&gt;&lt;span&gt;　　　　　// 判空，判断 h 对象是否为空，为空就抛出 NullPointerException
&lt;/span&gt;        Objects.requireNonNull(h);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] intfs =&lt;span&gt; interfaces.clone();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SecurityManager sm =&lt;span&gt; System.getSecurityManager();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {&lt;br/&gt;&lt;span&gt;　　　　　　　// 进行包访问权限、类加载器等权限检查
&lt;/span&gt;            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Look up or generate the designated proxy class.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Class&lt;/span&gt;&amp;lt;?&amp;gt; cl =&lt;span&gt; getProxyClass0(loader, intfs);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * Invoke its constructor with the designated invocation handler.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Constructor&amp;lt;?&amp;gt; cons =&lt;span&gt; cl.getConstructor(constructorParams);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; InvocationHandler ih =&lt;span&gt; h;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;&lt;span&gt;() {
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Void run() {
                        cons.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    }
                });
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[]{h});
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (IllegalAccessException|&lt;span&gt;InstantiationException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
            Throwable t &lt;/span&gt;=&lt;span&gt; e.getCause();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) t;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(t.toString(), t);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在生成代理类的过程中，会进行一些列检查，比如访问权限之类的。接下去我们来看 getProxyClass0 方法的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Generate a proxy class.  Must call the checkProxyAccess method
     * to perform permission checks before calling this.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; getProxyClass0(ClassLoader loader,
                                           Class&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt;... interfaces) {&lt;br/&gt;&lt;span&gt;　　　　 // 数量超过 65535 就抛出异常，665535 这个就不用说了吧
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interfaces.length &amp;gt; 65535&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;interface limit exceeded&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the proxy class defined by the given loader implementing
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the given interfaces exists, this will simply return the cached copy;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; otherwise, it will create the proxy class via the ProxyClassFactory&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxyClassCache.get(loader, interfaces);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后发现会对生成的代理类进行缓存，有了，就不直接返回，没有的，还得生成代理类，我们继续往下走：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
proxyClassCache = &lt;span&gt;new&lt;/span&gt; WeakCache&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; KeyFactory(), &lt;span&gt;new&lt;/span&gt; ProxyClassFactory());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 关键点在于  ProxyClassFactory 这个类，从名字也可以猜出来这个类的作用。看看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * A factory function that generates, defines and returns the proxy class given
     * the ClassLoader and array of interfaces.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyClassFactory
        &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt; BiFunction&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prefix for all proxy class names 定义前缀&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String proxyClassNamePrefix = &quot;$Proxy&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; next number to use for generation of unique proxy class names  原子操作，适用于多线程&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicLong nextUniqueNumber = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicLong();

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;&lt;span&gt;[] interfaces) {

            Map&lt;/span&gt;&amp;lt;Class&amp;lt;?&amp;gt;, Boolean&amp;gt; interfaceSet = &lt;span&gt;new&lt;/span&gt; IdentityHashMap&amp;lt;&amp;gt;&lt;span&gt;(interfaces.length);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; intf : interfaces) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * Verify that the class loader resolves the name of this
                 * interface to the same Class object.
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                Class&lt;/span&gt;&amp;lt;?&amp;gt; interfaceClass = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　&lt;span&gt;// 通过反射获取到接口类&lt;/span&gt;
                    interfaceClass &lt;/span&gt;= Class.forName(intf.getName(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, loader);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
                }&lt;br/&gt;&lt;span&gt;　　　　　　　　　// 所得到的接口类与传进来的不相等，说明不是同一个类
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interfaceClass !=&lt;span&gt; intf) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                        intf &lt;/span&gt;+ &quot; is not visible from class loader&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * Verify that the Class object actually represents an
                 * interface.
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;interfaceClass.isInterface()) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                        interfaceClass.getName() &lt;/span&gt;+ &quot; is not an interface&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * Verify that this interface is not a duplicate. &lt;br/&gt;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (interfaceSet.put(interfaceClass, Boolean.TRUE) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                        &lt;/span&gt;&quot;repeated interface: &quot; +&lt;span&gt; interfaceClass.getName());
                }
            }

            String proxyPkg &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; package to define proxy class in&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; accessFlags = Modifier.PUBLIC |&lt;span&gt; Modifier.FINAL;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Record the package of a non-public proxy interface so that the
             * proxy class will be defined in the same package.  Verify that
             * all non-public proxy interfaces are in the same package.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; intf : interfaces) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flags =&lt;span&gt; intf.getModifiers();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Modifier.isPublic(flags)) {
                    accessFlags &lt;/span&gt;=&lt;span&gt; Modifier.FINAL;
                    String name &lt;/span&gt;=&lt;span&gt; intf.getName();
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = name.lastIndexOf('.'&lt;span&gt;);
                    String pkg &lt;/span&gt;= ((n == -1) ? &quot;&quot; : name.substring(0, n + 1&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        proxyPkg &lt;/span&gt;=&lt;span&gt; pkg;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pkg.equals(proxyPkg)) {
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                            &lt;/span&gt;&quot;non-public interfaces from different packages&quot;&lt;span&gt;);
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if no non-public proxy interfaces, use com.sun.proxy package&lt;/span&gt;
                proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Choose a name for the proxy class to generate.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; num =&lt;span&gt; nextUniqueNumber.getAndIncrement();&lt;br/&gt;&lt;span&gt;　　　　　　　// 生产代理类的名字
&lt;/span&gt;            String proxyName &lt;/span&gt;= proxyPkg + proxyClassNamePrefix +&lt;span&gt; num;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Generate the specified proxy class.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] proxyClassFile =&lt;span&gt; ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defineClass0(loader, proxyName,
                                    proxyClassFile, &lt;/span&gt;0&lt;span&gt;, proxyClassFile.length);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassFormatError e) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(e.toString());
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里会通过反射获取接口的各种修饰符，包名等，然后根据规则命名代理类，最后调用 ProxyGenerator.generateProxyClass 生成了代理类。&lt;/p&gt;
&lt;p&gt; ProxyGenerator.generateProxyClass 具体实现在 eclipse 上打开后，说是找不到源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/916005/201809/916005-20180902203132902-1635239158.png&quot; alt=&quot;&quot; width=&quot;768&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 不过，从其他地方找到了部分代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] generateProxyClass(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; String name,  
                                           Class[] interfaces)  
   {  
       ProxyGenerator gen &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyGenerator(name, interfaces);  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里动态生成代理类的字节码，由于比较复杂就不进去看了  &lt;/span&gt;
       &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] classFile =&lt;span&gt; gen.generateClassFile();  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果saveGeneratedFiles的值为true，则会把所生成的代理类的字节码保存到硬盘上  &lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (saveGeneratedFiles) {  
           java.security.AccessController.doPrivileged(  
           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; java.security.PrivilegedAction&amp;lt;Void&amp;gt;&lt;span&gt;() {  
               &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Void run() {  
                   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
                       FileOutputStream file &lt;/span&gt;=  
                           &lt;span&gt;new&lt;/span&gt; FileOutputStream(dotToSlash(name) + &quot;.class&quot;&lt;span&gt;);  
                       file.write(classFile);  
                       file.close();  
                       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
                   } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {  
                       &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(  
                           &lt;/span&gt;&quot;I/O exception saving generated file: &quot; +&lt;span&gt; e);  
                   }  
               }  
           });  
       }  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回代理类的字节码  &lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; classFile;  
   }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以自己试试 ProxyGenerator.generateProxyClass 的功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyGeneratorUtils {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把代理类的字节码写到硬盘上 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; path 保存路径 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeProxyClassToHardDisk(String path) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取代理类的字节码  &lt;/span&gt;
        &lt;span&gt;byte&lt;/span&gt;[] classFile = ProxyGenerator.generateProxyClass(&quot;$Proxy11&quot;, Student.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getInterfaces());
 
        FileOutputStream out &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
 
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(path);
            out.write(classFile);
            out.flush();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                out.close();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main 方法里面进行调用 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ProxyGeneratorUtils.writeProxyClassToHardDisk(&lt;/span&gt;&quot;$Proxy0.class&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现，在根目录下生成了一个  $Proxy0.class 文件，文件内容反编译后如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.UndeclaredThrowableException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; proxy.Person;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; $Proxy0 &lt;span&gt;extends&lt;/span&gt; Proxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Person
{
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m1;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m2;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m3;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m0;
  
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白
  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个
  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。
  *
  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。
  *父类持有：protected InvocationHandler h;
  *Proxy构造方法：
  *    protected Proxy(InvocationHandler h) {
  *         Objects.requireNonNull(h);
  *         this.h = h;
  *     }
  *
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; $Proxy0(InvocationHandler paramInvocationHandler)
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; 
  {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(paramInvocationHandler);
  }
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个静态块本来是在最后的，我把它拿到前面来，方便描述&lt;/span&gt;
   &lt;span&gt;static&lt;/span&gt;&lt;span&gt;
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管&lt;/span&gt;
      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, &lt;span&gt;new&lt;/span&gt; Class[] { Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;) });
      m2 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, &lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
      m3 &lt;/span&gt;= Class.forName(&quot;proxy.Person&quot;).getMethod(&quot;giveMoney&quot;, &lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
      m0 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, &lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException localNoSuchMethodException)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodError(localNoSuchMethodException.getMessage());
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException localClassNotFoundException)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoClassDefFoundError(localClassNotFoundException.getMessage());
    }
  }
 
  &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 
  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。
  *this.h.invoke(this, m3, null);这里简单，明了。
  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，
  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; giveMoney()
    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; 
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m3, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error|&lt;span&gt;RuntimeException localError)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; localError;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable localThrowable)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(localThrowable);
    }
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jdk 为我们的生成了一个叫 $Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。&lt;/p&gt;
&lt;p&gt;我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，在 invoke 方法中调用了被代理对象的相应方法，而生成的代理类中持有中介类，因此，当我们在调用代理类的时候，就是再调用中介类的 invoke 方法，通过反射转为对被代理对象的调用。&lt;/p&gt;
&lt;p&gt;代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的 invoke 方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。&lt;/p&gt;
&lt;p&gt;生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了 Proxy 类，所以也就决定了 java 动态代理只能对接口进行代理，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/xiaoluo501395377/p/3383130.html&quot;&gt;java的动态代理机制详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/flyoung2008/p/3251148.html&quot;&gt;彻底理解JAVA动态代理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhangxinly/p/6974283.html&quot;&gt;java 1.8 动态代理源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/gonjan-blog/p/6685611.html&quot;&gt;java动态代理实现与原理详细分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 14:52:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>Java 有两种代理方式，一种是静态代理，另一种是动态代理。对于静态代理，其实就是通过依赖注入，对对象进行封装，不让外部知道实现的细节。很多 API 就是通过这种形式来封装的。 代理模式结构图（图片来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/9573202.html</dc:identifier>
</item>
<item>
<title>我的BRF+自学教程（三）：动态技术 - 氢氦</title>
<link>http://www.cnblogs.com/hhelibeb/p/9571707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhelibeb/p/9571707.html</guid>
<description>&lt;p&gt;开发者们可以在编程中使用各种动态技术，比如&lt;a href=&quot;https://blogs.sap.com/2017/09/29/dynamic-programming-in-abap-part-3-an-example-abap-rtts/&quot; target=&quot;_blank&quot;&gt;RTTS&lt;/a&gt;，比如通过动态的类创建和多态来实现功能的平滑扩展。BRF+对象也有一定动态能力。本文将介绍3种不同场景下的动态实践方式。其中第一种是纯配置的，第二和第三种是编程相关的。&lt;/p&gt;

&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 我的BRF+自学教程（三）：动态编程&quot; href=&quot;https://www.cnblogs.com/hhelibeb/p/9571707.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhelibeb/p/9571707.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的BRF+教程系列：&lt;a href=&quot;https://www.cnblogs.com/hhelibeb/tag/BRFplus/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hhelibeb/tag/BRFplus/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1，动态表达式（Dynamic Expression）&lt;/h2&gt;
&lt;p&gt;动态表达式是一种特殊类型的表达式，它可以用来实现对其它表达式的动态调用。动态表达式的应用场景之一是，有很多个表达式可以供用户选择，这些表达式使用基本一样的上下文对象，你不希望为每个表达式创建一个函数（因为创建它们的过程太繁琐），而是希望在一个统一的入口函数去调用。&lt;/p&gt;
&lt;h3&gt;1）选项&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;被调用的表达式（Called Expression）：选择一个表达式，将它分配给动态表达式。被分配的表达式会在运行期间被动态表达式调用。&lt;strong&gt;注意，虽然被称为被调用的表达式，但是它并不是被动态调用的表达式，&lt;/strong&gt;它的返回结果才是被动态调用的表达式的ID。Called Expression可以处理动态表达式的上下文，结果中必须包含一个表达式的ID，该表达式的结果会被传回给动态表达式。&lt;/li&gt;
&lt;li&gt;结果数据对象（Result Data Object：）结果数据对象可以使用任何种类的对象。然而，很重要的一点是确保第二个被调用的表达式的结果数据对象和动态表达式的结果数据对象是兼容的。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2）限制&lt;/h3&gt;
&lt;p&gt;动态表达式可以提供灵活性，但它也有缺陷，因为动态表达式类型的特质，使得某些大部分可以应用在其它BRF+表达式上的检查无法应用在动态表达式上面。所以这可能导致一些设计缺陷无法被检查出来，只有在运行期间才会暴露。此外，动态表达式是不支持代码生成模式的，只能使用解释模式，这使得它的性能不太好，在对时间要求高或数据负载量大的时候不建议使用它。&lt;/p&gt;
&lt;h3&gt;3）例子&lt;/h3&gt;
&lt;p&gt;实际操作部分比较简单，读完上面的文字之后应该可以很顺利地出来，这里就不再一图一图地贴了。可以参考&lt;a href=&quot;https://help.sap.com/viewer/9d5c91746d2f48199bd465c3a4973b89/1709%20000/en-US/e55a9aed3305496190d44181325b6776.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;2，动态创建决策表（Decision Table）&lt;/h2&gt;
&lt;p&gt;通过使用ABAP代码，可以动态地创建BRFplus中的decisiong table和function等对象。&lt;/p&gt;
&lt;p&gt;（本节的内容基本来自于&lt;a href=&quot;https://blogs.sap.com/2015/08/17/create-and-update-of-a-decision-table-expression-in-brf-workbench-through-api/&quot; target=&quot;_blank&quot;&gt;Create decision table &amp;amp; it’s entries dynamically in BRF + Workbench through API&lt;/a&gt;）&lt;/p&gt;
&lt;h3&gt;1）前提&lt;/h3&gt;
&lt;p&gt;要读懂本节，需要两方面的知识，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基本的ABAP面向对象知识。&lt;/li&gt;
&lt;li&gt;基本的BRF+知识。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;2）需求&lt;/h3&gt;
&lt;p&gt;通过一个简单的report程序来创建决策表和它的条目。&lt;/p&gt;
&lt;h3&gt;3）使用的接口&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;IF_FDT_FACTORY&lt;/li&gt;
&lt;li&gt;IF_FDT_DECISION_TABLE&lt;/li&gt;
&lt;li&gt;IF_FDT_FUNCTION&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;4）创建应用&lt;/h3&gt;
&lt;p&gt;在工作台中创建一个应用，接下来将会在这个应用中动态地创建决策表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201809/994049-20180902214027647-1239125478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5）复制代码&lt;/h3&gt;
&lt;p&gt;把以下代码粘贴到自定义程序中，代码的具体意义写在注释中，注意ID要替换成你自己创建的BRF+应用的ID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;110.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DATA&lt;/span&gt;: lo_factory        &lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_factory,
      lt_message        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;t_message,
      lv_message        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,
      lv_boolean        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; abap_bool,
      lo_element        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_element,
      lo_table          &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_table,
      lo_structure      &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_structure,
      lv_element1_id    &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;id,
      lv_element2_id    &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;id,
      lv_element3_id    &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;id,
      lv_structure_id   &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;id,
      lo_constant       &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_constant,
      ls_element        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_structure=&amp;gt;&lt;span&gt;s_element,
      lts_element       &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_structure=&amp;gt;&lt;span&gt;ts_element,
      lv_string         &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,
      ls_range          &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_decision_table=&amp;gt;&lt;span&gt;s_range,
      ls_table_data     &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_decision_table=&amp;gt;&lt;span&gt;s_table_data,
      lo_decision_table &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_decision_table,
      lo_function       &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_function,
      lo_context        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; if_fdt_context,
      lts_context_id    &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;ts_object_id,
      lts_table_data    &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_decision_table=&amp;gt;&lt;span&gt;ts_table_data,
      lts_column        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_decision_table=&amp;gt;&lt;span&gt;ts_column,
      lv_actv_failed    &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; abap_bool,
      lx_fdt            &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; cx_fdt,
      lv_dt_id          &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;id,
      ls_column         &lt;/span&gt;&lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;LINE&lt;/span&gt; &lt;span&gt;OF&lt;/span&gt;&lt;span&gt; lts_column.

&lt;/span&gt;&lt;span&gt;FIELD-SYMBOLS&lt;/span&gt;: &amp;lt;ls_message&amp;gt; &lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;s_message,

               &lt;/span&gt;&amp;lt;lv_value&amp;gt;   &lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; any.

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 获取FDT工厂实例，使用上面创建的应用ID&lt;/span&gt;&lt;span&gt;
lo_factory &lt;/span&gt;= cl_fdt_factory=&amp;gt;&lt;span&gt;if_fdt_factory~get_instance(
                           &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;005056A4CCA61ED8AA9AAF84A7712616&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ).&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
*&lt;/span&gt;&lt;span&gt;创建数据对象&lt;/span&gt;&lt;span&gt;
lo_element ?&lt;/span&gt;= lo_factory-&amp;gt;&lt;span&gt;get_data_object(
     iv_data_object_type &lt;/span&gt;= if_fdt_constants=&amp;gt;&lt;span&gt;gc_data_object_type_element ).

lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~enqueue( ).

lo_element&lt;/span&gt;-&amp;gt;if_fdt_admin_data~set_name( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IV_VAR1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ).

lo_element&lt;/span&gt;-&amp;gt;set_element_type( if_fdt_constants=&amp;gt;&lt;span&gt;gc_element_type_text ).

lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~activate(
   &lt;/span&gt;&lt;span&gt;IMPORTING&lt;/span&gt;&lt;span&gt;
     et_message           &lt;/span&gt;=&lt;span&gt; lt_message
     ev_activation_failed &lt;/span&gt;=&lt;span&gt; lv_boolean ).

&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; lv_boolean &lt;span&gt;EQ&lt;/span&gt;&lt;span&gt; abap_true.

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;如果激活失败，需要处理&lt;/span&gt;
&lt;span&gt;
  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~dequeue( ).

&lt;/span&gt;&lt;span&gt;ELSE&lt;/span&gt;&lt;span&gt;.

  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~save( ).

  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~dequeue( ).

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 通常需要把ID单独存下来，以便后续操作&lt;/span&gt;&lt;span&gt;
  lv_element1_id &lt;/span&gt;= lo_element-&amp;gt;&lt;span&gt;mv_id.

  ls_element&lt;/span&gt;-position = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.

  ls_element&lt;/span&gt;-element_id =&lt;span&gt; lv_element1_id.

  &lt;/span&gt;&lt;span&gt;APPEND&lt;/span&gt; ls_element &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; lts_element.

&lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; lv_element1_id &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_context_id.

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;创建另一个元素&lt;/span&gt;
&lt;span&gt;
lo_element ?&lt;/span&gt;= lo_factory-&amp;gt;&lt;span&gt;get_data_object(
     iv_data_object_type &lt;/span&gt;= if_fdt_constants=&amp;gt;&lt;span&gt;gc_data_object_type_element ).

lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~enqueue( ).

lo_element&lt;/span&gt;-&amp;gt;if_fdt_admin_data~set_name( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IV_VAR2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ).

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 设置元素类型(可以搜索if_fdt_constants=&amp;gt;gc_element_type_* 得到可用元素类型列表&lt;/span&gt;
&lt;span&gt;
lo_element&lt;/span&gt;-&amp;gt;set_element_type( if_fdt_constants=&amp;gt;&lt;span&gt;gc_element_type_text ).

lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~activate(
   &lt;/span&gt;&lt;span&gt;IMPORTING&lt;/span&gt;&lt;span&gt;
     et_message           &lt;/span&gt;=&lt;span&gt; lt_message
     ev_activation_failed &lt;/span&gt;=&lt;span&gt; lv_boolean ).

&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; lv_boolean &lt;span&gt;EQ&lt;/span&gt;&lt;span&gt; abap_true.&lt;/span&gt;
&lt;span&gt;
  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~dequeue( ).

&lt;/span&gt;&lt;span&gt;ELSE&lt;/span&gt;&lt;span&gt;.

  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~save( ).

  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~dequeue( ).&lt;/span&gt;
&lt;span&gt;
  lv_element2_id &lt;/span&gt;= lo_element-&amp;gt;&lt;span&gt;mv_id.

  ls_element&lt;/span&gt;-position = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.

  ls_element&lt;/span&gt;-element_id =&lt;span&gt; lv_element2_id.

  &lt;/span&gt;&lt;span&gt;APPEND&lt;/span&gt; ls_element &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; lts_element.

&lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; lv_element2_id &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_context_id.

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 创建结果数据元素&lt;/span&gt;
&lt;span&gt;
lo_element ?&lt;/span&gt;= lo_factory-&amp;gt;&lt;span&gt;get_data_object(
     iv_data_object_type &lt;/span&gt;= if_fdt_constants=&amp;gt;&lt;span&gt;gc_data_object_type_element ).

lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~enqueue( ).

lo_element&lt;/span&gt;-&amp;gt;if_fdt_admin_data~set_name( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;EV_RESULT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ).

lo_element&lt;/span&gt;-&amp;gt;set_element_type( if_fdt_constants=&amp;gt;&lt;span&gt;gc_element_type_text ).

lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~activate(
   &lt;/span&gt;&lt;span&gt;IMPORTING&lt;/span&gt;&lt;span&gt;
     et_message           &lt;/span&gt;=&lt;span&gt; lt_message
     ev_activation_failed &lt;/span&gt;=&lt;span&gt; lv_boolean ).

&lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; lv_boolean &lt;span&gt;EQ&lt;/span&gt;&lt;span&gt; abap_true.&lt;/span&gt;
&lt;span&gt;
  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~dequeue( ).

&lt;/span&gt;&lt;span&gt;ELSE&lt;/span&gt;&lt;span&gt;.

  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~save( ).

  lo_element&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~dequeue( ).&lt;/span&gt;
&lt;span&gt;
  lv_element3_id &lt;/span&gt;= lo_element-&amp;gt;&lt;span&gt;mv_id.

  ls_element&lt;/span&gt;-position = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.

  ls_element&lt;/span&gt;-element_id =&lt;span&gt; lv_element3_id.

  &lt;/span&gt;&lt;span&gt;APPEND&lt;/span&gt; ls_element &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; lts_element.

&lt;/span&gt;&lt;span&gt;ENDIF&lt;/span&gt;&lt;span&gt;.

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; lv_element3_id &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_context_id.

&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 填充第1列元素&lt;/span&gt;&lt;span&gt;
ls_column&lt;/span&gt;-col_no     = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.

ls_column&lt;/span&gt;-object_id =&lt;span&gt;   lv_element1_id.

ls_column&lt;/span&gt;-is_result  =&lt;span&gt; abap_false.

&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_column &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_column.

&lt;/span&gt;&lt;span&gt;* 填充第2列元素&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;80&quot;&gt;
&lt;span&gt; ls_column&lt;/span&gt;-col_no = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_column&lt;/span&gt;-object_id =&lt;span&gt; lv_element2_id. &lt;br/&gt;ls_column&lt;/span&gt;-is_result =&lt;span&gt; abap_false. &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_column &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_column. &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 填充结果列元素&lt;/span&gt; &lt;span&gt; &lt;br/&gt;ls_column&lt;/span&gt;-col_no = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_column&lt;/span&gt;-object_id =&lt;span&gt; lv_element3_id. &lt;br/&gt;ls_column&lt;/span&gt;-is_result =&lt;span&gt; abap_true. &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_column &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_column. &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 创建并设置决策表表达式&lt;/span&gt;&lt;span&gt;&lt;br/&gt;lo_decision_table ?&lt;/span&gt;= lo_factory-&amp;gt;&lt;span&gt;get_expression( iv_expression_type_id &lt;/span&gt;= if_fdt_constants=&amp;gt;&lt;span&gt;gc_exty_decision_table ). &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 对表达式加锁.&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_decision_table&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~enqueue( abap_true ).&lt;br/&gt;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 设置表列&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_decision_table&lt;/span&gt;-&amp;gt;set_columns( its_column =&lt;span&gt; lts_column ). &lt;br/&gt;lo_decision_table&lt;/span&gt;-&amp;gt;if_fdt_admin_data~set_name( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;DT_TEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ). &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user defined name. DT_TEST is the decision table Name&lt;/span&gt; &lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 使用工厂对象创建一个函数实例.&lt;/span&gt; &lt;br/&gt;&lt;span&gt; lo_function ?&lt;/span&gt;= lo_factory-&amp;gt;&lt;span&gt;get_function( ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 对函数加锁.&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_function&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~enqueue( ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 设置函数上下文对象.&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_function&lt;/span&gt;-&amp;gt;&lt;span&gt;set_context_data_objects( lts_context_id ). &lt;br/&gt;lo_function&lt;/span&gt;-&amp;gt;if_fdt_admin_data~set_name( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;FN_TEST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ). &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自定义函数名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 设置函数根表达式.&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_function&lt;/span&gt;-&amp;gt;set_expression( lo_decision_table-&amp;gt;&lt;span&gt;mv_id ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 设置单元格&lt;span&gt;(1,1)的条件&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;ls_table_data&lt;/span&gt;-row_no = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_table_data&lt;/span&gt;-col_no = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_range&lt;/span&gt;-position = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_range&lt;/span&gt;-sign = if_fdt_range=&amp;gt;&lt;span&gt;gc_sign_include. &lt;br/&gt;ls_range&lt;/span&gt;-option = if_fdt_range=&amp;gt;&lt;span&gt;gc_option_equal.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATA&lt;/span&gt; ls_range-r_low_value &lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;element_text. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASSIGN&lt;/span&gt; ls_range-r_low_value-&amp;gt;* &lt;span&gt;TO&lt;/span&gt; &amp;lt;lv_value&amp;gt;&lt;span&gt;. &lt;/span&gt;&amp;lt;lv_value&amp;gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MOURI&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_range &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; ls_table_data-&lt;span&gt;ts_range. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_table_data &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_table_data. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CLEAR&lt;/span&gt;&lt;span&gt; ls_table_data. . &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;设置单元格&lt;span&gt;(1,2)的条件&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;ls_table_data&lt;/span&gt;-row_no = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_table_data&lt;/span&gt;-col_no = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_range&lt;/span&gt;-position = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;ls_range&lt;/span&gt;-sign = if_fdt_range=&amp;gt;&lt;span&gt;gc_sign_include. &lt;br/&gt;ls_range&lt;/span&gt;-option = if_fdt_range=&amp;gt;&lt;span&gt;gc_option_equal. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATA&lt;/span&gt; ls_range-r_low_value &lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;element_text. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASSIGN&lt;/span&gt; ls_range-r_low_value-&amp;gt;* &lt;span&gt;TO&lt;/span&gt; &amp;lt;lv_value&amp;gt;&lt;span&gt;. &lt;/span&gt;&amp;lt;lv_value&amp;gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;TECH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_range &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; ls_table_data-&lt;span&gt;ts_range. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_table_data &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_table_data. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CLEAR&lt;/span&gt;&lt;span&gt; ls_table_data. &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;*在单元格(1, 3)得到结果&lt;/span&gt; &lt;span&gt; &lt;br/&gt;ls_table_data&lt;/span&gt;-row_no = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;. ls_table_data&lt;/span&gt;-col_no = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATA&lt;/span&gt; ls_table_data-r_value &lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;element_text. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASSIGN&lt;/span&gt; ls_table_data-r_value-&amp;gt;* &lt;span&gt;TO&lt;/span&gt; &amp;lt;lv_value&amp;gt;&lt;span&gt;. &lt;/span&gt;&amp;lt;lv_value&amp;gt; = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;MOURITECH&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;INSERT&lt;/span&gt; ls_table_data &lt;span&gt;INTO&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; lts_table_data. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CLEAR&lt;/span&gt;&lt;span&gt; ls_table_data. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 设置完全的表数据.&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_decision_table&lt;/span&gt;-&amp;gt;set_table_data( its_data =&lt;span&gt; lts_table_data ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; &lt;span&gt;保存&lt;/span&gt;并激活.&lt;/span&gt; &lt;span&gt; &lt;br/&gt;lo_function&lt;/span&gt;-&amp;gt;if_fdt_transaction~activate( &lt;br/&gt;&lt;span&gt;　　EXPORTING&lt;/span&gt; iv_deep　　　　　　　  =&lt;span&gt; abap_true &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　IMPORTING&lt;/span&gt; et_message 　　　　　　=&lt;span&gt; lt_message &lt;br/&gt;　　　　　　　　ev_activation_failed &lt;/span&gt;=&lt;span&gt; lv_actv_failed ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt; 如果成功，先保存对象。无论成功失败，释放全部锁&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IF&lt;/span&gt; lv_actv_failed &lt;span&gt;EQ&lt;/span&gt;&lt;span&gt; abap_true. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　lo_function-&amp;gt;if_fdt_transaction~dequeue( iv_deep =&lt;span&gt; abap_true ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　WRITE&lt;/span&gt; : / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Deep activation failed&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　&lt;span&gt;LOOP&lt;/span&gt; &lt;span&gt;AT&lt;/span&gt; lt_message ASSIGNING &amp;lt;ls_message&amp;gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　MESSAGE&lt;/span&gt; &lt;span&gt;ID&lt;/span&gt; &amp;lt;ls_message&amp;gt;-msgid &lt;span&gt;TYPE&lt;/span&gt; &amp;lt;ls_message&amp;gt;-msgty &lt;span&gt;NUMBER&lt;/span&gt; &amp;lt;ls_message&amp;gt;-&lt;span&gt;msgno &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　WITH&lt;/span&gt; &amp;lt;ls_message&amp;gt;-msgv1 &amp;lt;ls_message&amp;gt;-msgv2 &amp;lt;ls_message&amp;gt;-msgv3 &amp;lt;ls_message&amp;gt;-&lt;span&gt;msgv4 &lt;/span&gt;&lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; lv_message.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　WRITE&lt;/span&gt;: / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Reason : -&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,lv_message. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　ENDLOOP&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ELSE&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　TRY&lt;/span&gt;&lt;span&gt;.&lt;br/&gt;　　 lv_dt_id &lt;/span&gt;= lo_decision_table-&amp;gt;&lt;span&gt;mv_id. &lt;br/&gt;　　 lo_function&lt;/span&gt;-&amp;gt;&lt;span&gt;if_fdt_transaction~save(&lt;/span&gt; iv_deep =&lt;span&gt; abap_true ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　 WRITE&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;The ID of the decision table created is:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ,lv_dt_id. . &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　CATCH&lt;/span&gt; cx_fdt &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; lx_fdt. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　WRITE&lt;/span&gt; : / &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Save failed with exception&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;br/&gt;　　　&lt;/span&gt;&lt;span&gt;LOOP&lt;/span&gt; &lt;span&gt;AT&lt;/span&gt; lx_fdt-&amp;gt;mt_message ASSIGNING &amp;lt;ls_message&amp;gt;&lt;span&gt;.&lt;br/&gt;　　　　&lt;/span&gt;&lt;span&gt;WRITE&lt;/span&gt; :/ &amp;lt;ls_message&amp;gt;-&lt;span&gt;text. &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　  ENDLOOP&lt;/span&gt;&lt;span&gt;. &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　ENDTRY&lt;/span&gt;&lt;span&gt;. &lt;br/&gt;　　lo_function&lt;/span&gt;-&amp;gt;if_fdt_transaction~dequeue( iv_deep =&lt;span&gt; abap_true ). &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ENDIF&lt;/span&gt;.
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行后可以看到结果，如下图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201809/994049-20180902222513357-1019835308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前往BRF+工作台，按ID搜索对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201809/994049-20180902222548406-321538296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以查询到结果，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201809/994049-20180902222602781-1043300764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经成功创建了决策表，也可以在上文创建的应用下找到这个决策表，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201809/994049-20180902222650786-1375022816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3，动态获取函数参数&lt;/h2&gt;
&lt;p&gt;函数的参数是在创建BRF+函数时定义的，在某些场景下，我们需要动态地获取这些参数，以供程序使用。&lt;/p&gt;
&lt;p&gt;比如，用户创建了若干公式，公式中存在常量，也存在不同的需要用户输入的运算数，这些运算数即函数的参数。程序需要获取到用户所选择的公式中需要输入的运算数，这样才能告诉用户，需要在界面输入哪些变量的值。&lt;/p&gt;
&lt;p&gt;对于这个功能的实现方式，我曾经&lt;a href=&quot;https://answers.sap.com/questions/607641/get-brf-function-parameters-dynamically.html&quot; target=&quot;_blank&quot;&gt;在SCN上提问&lt;/a&gt;，最后自己找到了答案。现把答案转贴在这里。&lt;/p&gt;
&lt;p&gt;在调用BRG+函数时，需要获取上下文对象，而函数的参数的名字和ID，就位于上下文对象中的属性MT_NAME_VALUE中，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/994049/201809/994049-20180902223321911-236320104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以为类CL_FDT_CONTEXT创建增强，新增方法&lt;span class=&quot;pln&quot;&gt;GET_MT_NAME_VALUES&lt;/span&gt;，以读取私有属性MT_NAME_VALUE，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  methods&lt;/span&gt; GET_MT_NAME_VALUES
    &lt;span&gt;exporting&lt;/span&gt;
      value(ET_NAME_VALUE) type HASHED &lt;/span&gt;&lt;span&gt;TABLE&lt;/span&gt; .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法的实现如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;METHOD&lt;/span&gt;&lt;span&gt; get_mt_name_values .

  et_name_value &lt;/span&gt;= &lt;span&gt;me&lt;/span&gt;-&amp;gt;&lt;span&gt;mt_name_value.

&lt;/span&gt;&lt;span&gt;ENDMETHOD&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来在自己的程序中调用该方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;TYPES&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;OF&lt;/span&gt;&lt;span&gt; s_name_id_value,
    id               &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;id,
    name             &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; abap_parmname,
    data_object_type &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; if_fdt_types=&amp;gt;&lt;span&gt;data_object_type,
    value            &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; &lt;span&gt;REF&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt;&lt;span&gt; data,
    value_set        &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; abap_bool,
  &lt;/span&gt;&lt;span&gt;END&lt;/span&gt; &lt;span&gt;OF&lt;/span&gt;&lt;span&gt; s_name_id_value .
&lt;/span&gt;&lt;span&gt;TYPES&lt;/span&gt;&lt;span&gt;:
  t_name_id_value &lt;/span&gt;&lt;span&gt;TYPE&lt;/span&gt; HASHED &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;OF&lt;/span&gt;&lt;span&gt; s_name_id_value
                  &lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt;&lt;span&gt; UNIQUE KEY name .

&lt;/span&gt;&lt;span&gt;DATA&lt;/span&gt;: t_name &lt;span&gt;TYPE&lt;/span&gt;&lt;span&gt; t_name_id_value.

&lt;/span&gt;&lt;span&gt;DATA&lt;/span&gt;(lo_fuction) = cl_fdt_factory=&amp;gt;&lt;span&gt;if_fdt_factory~get_instance(
  )&lt;/span&gt;-&amp;gt;get_function( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;005056A4CCA61ED8A8924F0F3F4F1D98&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ).
&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;
&lt;span&gt;DATA&lt;/span&gt;(lo_context) = CAST cl_fdt_context( lo_fuction-&amp;gt;&lt;span&gt;get_process_context( ) ).

lo_context&lt;/span&gt;-&amp;gt;get_mt_name_values( &lt;span&gt;IMPORTING&lt;/span&gt; et_name_value = t_name ).
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以得到相关信息。&lt;/p&gt;



</description>
<pubDate>Sun, 02 Sep 2018 14:45:00 +0000</pubDate>
<dc:creator>氢氦</dc:creator>
<og:description>开发者们可以在编程中使用各种动态技术，比如RTTS，比如通过动态的类创建和多态来实现功能的平滑扩展。BRF+对象也有一定动态能力。本文将介绍3种不同场景下的动态实践方式。其中第一种是纯配置的，第二和第</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhelibeb/p/9571707.html</dc:identifier>
</item>
<item>
<title>职场小白初涉设计模式之责任链模式 - Shawn不要懒</title>
<link>http://www.cnblogs.com/nalanshawn/p/9574763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nalanshawn/p/9574763.html</guid>
<description>&lt;blockquote readability=&quot;32&quot;&gt;
&lt;p&gt;最近，接到一个需求，在数据计算之前，根据需求的具体内容对数据进行过滤，保留下需要计算的那部分。&lt;/p&gt;
&lt;p&gt;对于职场小白没经验的我来说，拿到需求，在确定于什么位置过滤数据以后，就开始义无反顾地码代码！！&lt;/p&gt;
&lt;p&gt;怎么码呢？当然是建立需要过滤的接口及实现类，然后在里面进行过滤的具体操作。&lt;/p&gt;
&lt;p&gt;由于过滤数据的两部分是对同一内容进行操作，于是在计算数据之前，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;嗯，调用第一个实现类方法得到要过滤的内容，循环过滤数据，过滤第一部分；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再来调用第二个实现类方法得到要过滤的内容，循环过滤数据，过滤第二部分。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到这里，需求的功能性基本上算是完成了。但这样的方式好么？！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果再来第三个第四个相同的过滤操作呢？！接着如上循环么？！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;明眼人都能看出来这种方式存在了很大的代码冗余，效率并不是很高，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;且后一部分的过滤在前一部分的过滤之后，耦合太紧，以后再看到的话肯定头疼。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;于是，在同事亦师父的林哥的耐心指导下，开始&lt;strong&gt;以责任链的形式&lt;/strong&gt;来优化这部分代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、对责任链的理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;责任链模式（Chain of Responsibility Pattern）即为请求创建一个接收者对象的链，给与请求类型，将请求发送者与接收者之间进行解耦。&lt;/strong&gt;请求的处理被每一个接收者进行接收并处理，如果能处理则按照接收者的既定规则处理，然后在该责任链上层层传递。也可以在每一个接收者中持有下一个接收者的引用，如果自己不能处理，则传给下一个进行处理。&lt;/p&gt;
&lt;p&gt;请求由责任链上的每个接收者进行处理，因此，客户在传入请求之后，不需要关心接收者的处理细节以及如何传递的，这就实现了请求的发送者和请求接收者之间进行了解耦。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（一）大致实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、首先创建一个Handler类，其包含对请求进行处理的方法HandlerRequest()；&lt;/p&gt;
&lt;p&gt;2、对于不同的请求处理方式，创建其相应的接收者类，并继承并重写Handler父类中的HandlerRequest()方法，以自己的方式进行实现；&lt;/p&gt;
&lt;p&gt;3、对于接收者类的传递上，是在每个接收者类中持有下一接收者的引用，这样处理不了的请求就传递给下一个接收者进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1445861/201809/1445861-20180902202535564-1886183761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; （二）优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;1、首先是责任的分担。每个类都只需承担自己的责任进行处理，如果不能处理就传递给下一个对象，明确各类的职责范围，符合类的最小封装原则。&lt;/p&gt;
&lt;p&gt;　　　 2、可以根据实际场景的需要自由组合处理流程。如需变更，只需要重新分配该对象链即可。&lt;/p&gt;
&lt;p&gt;　　　 3、类与类之间以松耦合的方式来传递请求，降低了耦合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点： &lt;/strong&gt;由于请求在各个接收者之间进行传递，而每个接收者处理的方式不同，可能会影响处理速度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（三）应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;责任链既然叫链，即是用于链式处理的场景中，使得工作流程化、处理过程流程化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：1、Web开发过程中对请求的各种filter处理，如请求处理和过滤、对Encoding的处理、获取客户端IP地址、获取客户证书等。（这个是大家最熟悉的部分）&lt;/p&gt;
&lt;p&gt;　　　2、JS的冒泡事件。（这个本人没太过深入研究，看了下，大致意思是某事件被触发，如鼠标点击了一下按钮，那么该事件会在该元素的所有祖先当中被触发，即自下而上的。）&lt;/p&gt;
&lt;p&gt;　　   3、多个对象处理一个请求时。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、我是如何来实现责任链的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 说完了个人对责任链的理解，接下来就通过一个简单的例子来讲解本人是如何实现责任链的。&lt;/p&gt;
&lt;p&gt;1、定义一个IRule接口，制定请求处理方法的规则，各接收者都将实现该接口并重写该方法；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_0bef9314-efc4-406e-9a5a-6e483a9c13f2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0bef9314-efc4-406e-9a5a-6e483a9c13f2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0bef9314-efc4-406e-9a5a-6e483a9c13f2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRule {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;     * 对字符串进行处理
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    Object handler();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2、定义一个RuleChain类，主要包含两部分，一部分是能接收传递进来的请求对象，一部分是对请求进行处理。&lt;/p&gt;
&lt;p&gt;　　这两个部分保证了在传递请求继续不同处理时，能将接收者加入到责任链中形成链式结构，后续在增加新的相关接收处理者对象时只需实现自身处理并加入到责任链中即可；同时每一个接收者都重写了该责任链的处理方法，这样在进行责任链处理时，如果是对相同数据进行处理，只需要一个循环来进行验证即可，避免了代码的冗余。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7bcf3433-731d-4fea-b0ba-f427da270df0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7bcf3433-731d-4fea-b0ba-f427da270df0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7bcf3433-731d-4fea-b0ba-f427da270df0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RuleChain {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *  装载各个接收者对象的链
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;IRule&amp;gt;&lt;span&gt; chain;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RuleChain() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         chain = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RuleChain addRule(IRule rule) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        chain.add(rule);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 各个接收者自行处理数据
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; handler(StringObj stringObj){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (IRule rule : chain){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             stringObj =&lt;span&gt; rule.handler();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3、接收者的实现方法&lt;/p&gt;
&lt;p&gt;　　这部分主要是实现RuleChain接口并根据自身情况重写其请求处理方法。这样RuleChain可以统一地进行请求处理，然后轮到该接收者时，就会调用其重写的请求处理方法进行处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_1fb0c825-fcd1-499a-99bb-1bc7f7810a95&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1fb0c825-fcd1-499a-99bb-1bc7f7810a95&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1fb0c825-fcd1-499a-99bb-1bc7f7810a95&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteHandlerA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IRule {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringObj str;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConcreteHandlerA(StringObj str){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.str =&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * 该方法在字符串上上添加“ConcreteHandlerA”
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringObj handler() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         String string=str.getStr()+&quot;ConcreteHandlerA接收者开始处理,&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        str.setStr(string);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;  str;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ca84e49b-a511-4106-8167-93ac09fd7412&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ca84e49b-a511-4106-8167-93ac09fd7412&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ca84e49b-a511-4106-8167-93ac09fd7412&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreteHandlerB &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IRule{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringObj str;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConcreteHandlerB(StringObj str){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.str =&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * 判断前面字符串的长度，
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringObj handler() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         String end = &quot;ConcreteHandlerB处理完毕，责任链结束&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         String string = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (str.getStr().length() &amp;gt; 10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             string=str.getStr()+ &quot;前面字符串长度为&quot;+str.getStr().length()+&quot;,&quot;+&lt;span&gt;end;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             string=str.getStr()+ &quot;前面字符串长度不足10，只有&quot;+str.getStr().length()+&quot;,&quot;+&lt;span&gt;end;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        str.setStr(string);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;  str;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4、Main方法验证实现及输出结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_1ecdfe2c-db9d-45c2-9d93-6a0acc56ce43&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1ecdfe2c-db9d-45c2-9d93-6a0acc56ce43&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1ecdfe2c-db9d-45c2-9d93-6a0acc56ce43&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         StringObj stringObj = &lt;span&gt;new&lt;/span&gt; StringObj(&quot;责任链开始,&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         RuleChain chain = &lt;span&gt;new&lt;/span&gt; RuleChain().addRule(&lt;span&gt;new&lt;/span&gt; ConcreteHandlerA(stringObj)).addRule(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcreteHandlerB(stringObj));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        chain.handler(stringObj);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        System.out.println(stringObj.getStr());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; ==================================================
&lt;span&gt;12&lt;/span&gt; 责任链开始,ConcreteHandlerA接收者开始处理,前面字符串长度为30,ConcreteHandlerB处理完毕，责任链结束
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、责任链实现的设计模式六大原则体现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 如上所示则为一个简答的责任链的大致实现过程。&lt;/p&gt;
&lt;p&gt;1、通过上面的例子我们可以看到，每一个类只进行自己的那部分处理方式，符合设计模式的&lt;strong&gt;单一职责原则，实现了高内聚低耦合的方针；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、在Main函数中的main方法中，对于RuleChain来说，我们只需在后续增加各个处理模块即可，然后在每个处理模块中实现自定义处理。在对各个处理模块的增加来说，我们只需实现IRule接口，并重写其handler方法，即可满足需求。这符合设计模式的&lt;strong&gt;开闭原则，即对扩展开放，对修改关闭&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3、接收者的各个类都统一实现了专门的IRule接口，而不会去实现不必要的其他接口，符合&lt;strong&gt;接口隔离原则&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;4、接收者的handler方法都实现了IRule中的方法，IRule负责抽象方法，而具体的实现细节都放在了各个接收者内部进行处理，符合&lt;strong&gt;依赖倒置原则&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;5、我们从上述例子中可以看到，接收者的类与类之间是不存在耦合的，其链接都是依靠RuleChain来进行的，因此符合&lt;strong&gt;迪米特法则&lt;/strong&gt;，类与类之间的耦合性降低。&lt;/p&gt;
&lt;p&gt;6、&lt;strong&gt;里氏替换原则&lt;/strong&gt;在这里暂时不是很明显。&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;四、其他&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;大致先说到这里，后续再进行补充。&lt;/p&gt;
&lt;p&gt;如有描述不足之处，请指教！&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 14:38:00 +0000</pubDate>
<dc:creator>Shawn不要懒</dc:creator>
<og:description>最近，接到一个需求，在数据计算之前，根据需求的具体内容对数据进行过滤，保留下需要计算的那部分。 对于职场小白没经验的我来说，拿到需求，在确定于什么位置过滤数据以后，就开始义无反顾地码代码！！ 怎么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nalanshawn/p/9574763.html</dc:identifier>
</item>
<item>
<title>你懂Java多线程吗（一）Java多线程技能 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9575698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9575698.html</guid>
<description>&lt;h2 id=&quot;进程和线程&quot;&gt;1、进程和线程&lt;/h2&gt;
&lt;p&gt;一个程序就是一个进程，而一个程序中的多个任务则被称为线程。&lt;/p&gt;
&lt;p&gt;进程是表示资源分配的基本单位，又是调度运行的基本单位。&lt;/p&gt;
&lt;p&gt;线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;打开你的计算机上的任务管理器，会显示出当前机器的所有进程，QQ，360等，当QQ运行时，就有很多子任务在同时运行。比如，当你边打字发送表情，边好友视频时这些不同的功能都可以同时运行，其中每一项任务都可以理解成“线程”在工作。&lt;/p&gt;
&lt;h2 id=&quot;使用多线程&quot;&gt;2、使用多线程&lt;/h2&gt;
&lt;p&gt;在Java的JDK开发包中，已经自带了对多线程技术的支持，可以很方便地进行多线程编程。实现多线程编程的方式有两种，一种是继承 Thread 类，另一种是实现 Runnable 接口。使用继承 Thread 类创建线程，最大的局限就是不能多继承，所以为了支持多继承，完全可以实现 Runnable 接口的方式。需要说明的是，这两种方式在工作时的性质都是一样的，没有本质的区别。如下所示：&lt;/p&gt;
&lt;p&gt;1.继承 Thread 类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {

    @Override
    public void run() {
        //...
    }
    
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.实现 Runnable 接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void main(String[] args) throws InterruptedException {
     new Thread(new Runnable() {
         @Override
         public void run() {
             //...
         }
     }).start();
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;Thread.java 类中的start()方法通知“线程规划器”此线程已经准备就绪，等待调用线程对象的run()方法。这个过程其实就是让系统安排一个时间来调用 Thread 中的 run() 方法，也就是使线程得到运行，多线程是异步的，线程在代码中启动的顺序不是线程被调用的顺序。&lt;/p&gt;
&lt;h3 id=&quot;thread构造方法&quot;&gt;Thread构造方法&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Thread()&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(Runnable target)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(Runnable target, String name)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(String name)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(ThreadGroup group, Runnable target)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(ThreadGroup group, Runnable target, String name)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象，以便将 &lt;code&gt;target&lt;/code&gt; 作为其运行对象，将指定的 &lt;code&gt;name&lt;/code&gt; 作为其名称，并作为 &lt;code&gt;group&lt;/code&gt; 所引用的线程组的一员。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(ThreadGroup group, Runnable target, String name, long stackSize)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象，以便将 &lt;code&gt;target&lt;/code&gt; 作为其运行对象，将指定的 &lt;code&gt;name&lt;/code&gt; 作为其名称，作为 &lt;code&gt;group&lt;/code&gt; 所引用的线程组的一员，并具有指定的&lt;em&gt;堆栈大小&lt;/em&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;Thread(ThreadGroup group, String name)&lt;/code&gt;&lt;br/&gt;分配新的 &lt;code&gt;Thread&lt;/code&gt; 对象。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;实例变量与线程安全&quot;&gt;3、实例变量与线程安全&lt;/h2&gt;
&lt;p&gt;自定义线程类中的实例变量针对其他线程可以有共享与不共享之分。当每个线程都有各自的实例变量时，就是变量不共享。共享数据的情况就是多个线程可以访问同一个变量。来看下面的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread implements Runnable {
    private int count = 5;

    @Override
    public void run() {
        count--;
        System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot; 计算 count = &quot;+count);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码定义了一个线程类，实现count变量减一的效果。运行类Runjava代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Ruu {

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread = new MyThread();
        Thread a = new Thread(myThread,&quot;A&quot;);
        Thread b = new Thread(myThread,&quot;B&quot;);
        Thread c = new Thread(myThread,&quot;C&quot;);
        Thread d = new Thread(myThread,&quot;D&quot;);
        Thread e = new Thread(myThread,&quot;E&quot;);
        a.start();
        b.start();
        c.start();
        d.start();
        e.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        线程C 计算 count = 3
        线程B 计算 count = 3
        线程A 计算 count = 2
        线程D 计算 count = 1
        线程E 计算 count = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程C，B的打印结果都是3，说明C和B同时对count进行了处理，产生了“非线程安全问题”。而我们想要的得到的打印结果却不是重复的，而是依次递减的。&lt;/p&gt;
&lt;p&gt;在某些JVM中，i--的操作要分成如下3步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;取得原有变量的值。&lt;/li&gt;
&lt;li&gt;计算i-1。&lt;/li&gt;
&lt;li&gt;对i进行赋值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这三个步骤中，如果有多个线程同时访问，那么一定会出现非线程安全问题。&lt;/p&gt;
&lt;p&gt;解决方法就是使用 synchronized 同步关键字 使各个线程排队执行run()方法。修改后的run()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread implements Runnable {
    private int count = 5;

    @Override
    synchronized public void run() {
        count--;
        System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot; 计算 count = &quot;+count);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;线程B 计算 count = 4
线程C 计算 count = 3
线程A 计算 count = 2
线程E 计算 count = 1
线程D 计算 count = 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于system.out.println方法&quot;&gt;关于System.out.println()方法&lt;/h3&gt;
&lt;p&gt;先来看System.out.println()方法源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void println(String x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然println()方法内部使用 synchronized 关键字，但如下所示的代码在执行时还是有可能出现非线程安全问题的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot; 计算 count = &quot;+count--);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因在于println()方法内部同步，但 i-- 操作却是在进入 println()之前发生的，所以有发生非线程安全问题的概率。&lt;/p&gt;
&lt;h2 id=&quot;多线程方法&quot;&gt;4、多线程方法&lt;/h2&gt;
&lt;h3 id=&quot;currentthread方法&quot;&gt;1. currentThread()方法&lt;/h3&gt;
&lt;p&gt;currentThread()方法可返回代码段正在被哪个线程调用的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread.currentThread().getName()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;isalive方法&quot;&gt;2. isAlive()方法&lt;/h3&gt;
&lt;p&gt;方法isAlive()的功能是判断当前的线程是否处于活动状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread.isAlive();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sleep方法&quot;&gt;3. sleep()方法&lt;/h3&gt;
&lt;p&gt;方法sleep()的作用是在指定的毫秒数内让当前&quot;正在执行的线程&quot;休眠（暂停执行）。这个&quot;正在执行的线程&quot;是指this.currentThread()返回的线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thread.sleep()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getid方法&quot;&gt;4. getId()方法&lt;/h3&gt;
&lt;p&gt;getId()方法的作用是取得线程的唯一标识。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread.getId()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;停止线程&quot;&gt;5、停止线程&lt;/h2&gt;
&lt;p&gt;停止线程是在多线程开发时很重要的技术点。停止线程并不像break语句那样干脆，需要一些技巧性的处理。&lt;/p&gt;
&lt;p&gt;在Java中有以下3种方法可以终止正在运行的线程：&lt;/p&gt;
&lt;p&gt;1）使用退出标志，使线程正常退出，也就是当run()方法完成后线程停止。&lt;/p&gt;
&lt;p&gt;2）使用stop()方法强行终止线程，但是不推荐使用这个方法，因为该方法已经作废过期，使用后可能产生不可预料的结果。&lt;/p&gt;
&lt;p&gt;3）使用interrupt()方法中断线程。&lt;/p&gt;
&lt;h3 id=&quot;暴力法停止线程&quot;&gt;1.暴力法停止线程&lt;/h3&gt;
&lt;p&gt;调用stop()方法时会抛出 java.lang.ThreadDeath 异常，但在通常的情况下，此异常不需要显示地捕捉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        try {
            myThread.stop();
        } catch (ThreadDeath e) {
            e.printStackTrace();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法stop()已经被作废，因为如果强制让线程停止线程则有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了“解锁”，导致数据得不到同步的处理，出现数据不一致的情况。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserPass {
    private String username = &quot;aa&quot;;
    private String password = &quot;AA&quot;;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    synchronized public void println(String username, String password){
        this.username = username;
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.password = password;
    }

    public static void main(String[] args) throws InterruptedException {
        UserPass userPass = new UserPass();
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                userPass.println(&quot;bb&quot;,&quot;BB&quot;);
            }
        });
        thread.start();
        Thread.sleep(500);
        thread.stop();
        System.out.println(userPass.getUsername()+&quot; &quot;+userPass.getPassword());
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bb AA&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常法停止线程&quot;&gt;2.异常法停止线程&lt;/h3&gt;
&lt;p&gt;使用interrupt()方法并不会真正的停止线程，调用interrupt()方法仅仅是在当前线程中打了一个停止的标记，并不是真的停止线程。&lt;/p&gt;
&lt;p&gt;那我们如何判断该线程是否被打上了停止标记，Thread类提供了两种方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interrupted() 测试当前线程是否已经中断。
isInterrupted() 测试线程是否已经中断。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;interrupted() 方法 不止可以判断当前线程是否已经中断，而且可以会清除该线程的中断状态。而对于isInterrupted() 方法，只会判断当前线程是否已经中断，不会清除线程的中断状态。&lt;/p&gt;
&lt;p&gt;仅靠上面的两个方法可以通过&lt;code&gt;while(!this.isInterrupted()){}&lt;/code&gt;对代码进行控制，但如果循环外还有其它语句，程序还是会继续运行的。这时可以抛出异常从而使线程彻底停止。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
    @Override
    public void run() {
        try {
            for (int i=0; i&amp;lt;50000; i++){
                if (this.isInterrupted()) {
                    System.out.println(&quot;已经是停止状态了！&quot;);
                    throw new InterruptedException();
                }
                System.out.println(i);
            }
            System.out.println(&quot;不抛出异常，我会被执行的哦！&quot;);
        } catch (Exception e) {
//            e.printStackTrace();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread =new MyThread();
        myThread.start();
        Thread.sleep(100);
        myThread.interrupt();
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
2490
2491
2492
2493
已经是停止状态了！&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注意&quot;&gt;注意&lt;/h4&gt;
&lt;p&gt;如果线程在sleep()状态下被停止，也就是线程对象的run()方法含有sleep()方法，在此期间又执行了&lt;code&gt;thread.interrupt()&lt;/code&gt; 方法，则会抛出&lt;code&gt;java.lang.InterruptedException: sleep interrupted&lt;/code&gt;异常，提示休眠被中断。&lt;/p&gt;
&lt;h3 id=&quot;return法停止线程&quot;&gt;3.return法停止线程&lt;/h3&gt;
&lt;p&gt;return法很简单，只需要把异常法中的抛出异常更改为return即可。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
    @Override
    public void run() {
        try {
            for (int i=0; i&amp;lt;50000; i++){
                if (this.isInterrupted()) {
                    System.out.println(&quot;已经是停止状态了！&quot;);
                    return;//替换此处
                }
                System.out.println(i);
            }
            System.out.println(&quot;不进行return，我会被执行的哦！&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过还是建议使用“抛异常”来实现线程的停止，因为在catch块中可以对异常的信息进行相关的处理，而且使用异常能更好、更方便的控制程序的运行流程，不至于代码中出现多个return，造成污染。&lt;/p&gt;
&lt;h2 id=&quot;暂停线程&quot;&gt;6、暂停线程&lt;/h2&gt;
&lt;p&gt;暂停线程意味着此线程还可以恢复运行。在Java多线程中，可以使用 suspend() 方法暂停线程，使用 resume()方法恢复线程的执行。&lt;/p&gt;
&lt;p&gt;这俩方法已经和stop()一样都被弃用了，因为如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
    private Integer i = 0;

    @Override
    public void run() {
        while (true) {
            i++;
            System.out.println(i);
        }
    }

    public Integer getI() {
        return i;
    }
    
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread =new MyThread();
        myThread.start();
        Thread.sleep(100);
        myThread.suspend();
        System.out.println(&quot;main end&quot;);
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
3398
3399
3400
3401&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上段程序永远不会终止，也就是卡死。出现这样的原因是，当程序运行到 println() 方法内部停止时，PrintStream对象同步锁未被释放。方法 println() 源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void println(String x) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这导致当前PrintStream对象的println() 方法一直呈“暂停”状态，并且锁未被myThread线程释放，而main()方法中的代码System.out.println(&quot;main end&quot;) 还在傻傻的排队等待，导致迟迟不能运行打印。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;使用 suspend() 和 resume() 方法也容易因为线程的暂停而导致数据不同步的情况，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserPass2 {
    private String username = &quot;aa&quot;;
    private String password = &quot;AA&quot;;

    public String getUsername() {
        return username;
    }


    public String getPassword() {
        return password;
    }


    public void setValue(String username, String password){
        this.username = username;
        if (Thread.currentThread().getName().equals(&quot;a&quot;)) {
            Thread.currentThread().suspend();
        }
        this.password = password;
    }

    public static void main(String[] args) throws InterruptedException {
        UserPass2 userPass = new UserPass2();
        new Thread(new Runnable() {
            @Override
            public void run() {
                userPass.setValue(&quot;bb&quot;,&quot;BB&quot;);
            }
        },&quot;a&quot;).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(userPass.getUsername()+&quot; &quot;+userPass.getPassword());
            }
        },&quot;b&quot;).start();

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bb AA&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;yield方法&quot;&gt;7、yield()方法&lt;/h2&gt;
&lt;p&gt;yield() 方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃的时间不确定，有可能刚刚放弃，马上又获得CPU时间片。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void yield()  暂停当前正在执行的线程对象，并执行其他线程。 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程的优先级&quot;&gt;8、线程的优先级&lt;/h2&gt;
&lt;p&gt;在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资源较多，也就是CPU优先执行优先级较高的线程对象中的任务。&lt;/p&gt;
&lt;p&gt;设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。&lt;/p&gt;
&lt;p&gt;设置线程优先级使用setPriority()方法，此方法的JDK源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public final void setPriority(int newPriority) {
        ThreadGroup g;
        checkAccess();
        if (newPriority &amp;gt; MAX_PRIORITY || newPriority &amp;lt; MIN_PRIORITY) {
            throw new IllegalArgumentException();
        }
        if((g = getThreadGroup()) != null) {
            if (newPriority &amp;gt; g.getMaxPriority()) {
                newPriority = g.getMaxPriority();
            }
            setPriority0(priority = newPriority);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Java中，线程优先级划分为1 ~ 10 这10个等级，如果小于1或大于10，则JDK抛出异常。&lt;/p&gt;
&lt;p&gt;从JDK定义的3个优先级常量可知，线程优先级默认为5。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public final static int MIN_PRIORITY = 1;

    public final static int NORM_PRIORITY = 5;

    public final static int MAX_PRIORITY = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程优先级具有继承性，比如A线程启动B线程，则B线程的优先级与A是一样的。&lt;/p&gt;
&lt;p&gt;线程优先级具有规则性，线程的优先级与在代码中执行start()方法的顺序无关，与优先级大小有关。&lt;/p&gt;
&lt;p&gt;线程优先级具有随机性，CPU尽量使线程优先级较高的先执行完，但无法百分百肯定。也就是说，线程优先级较高的不一定比线程优先级较低的先执行。&lt;/p&gt;
&lt;h2 id=&quot;守护线程&quot;&gt;9、守护线程&lt;/h2&gt;
&lt;p&gt;在Java中有两种线程，一种是用户线程，一种守护线程。&lt;/p&gt;
&lt;p&gt;什么是守护线程？守护线程是一种特殊的线程，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程也就没有了存在的必要了，自动销毁。可以简单地说：任何一个守护线程都是非守护线程的保姆。&lt;/p&gt;
&lt;p&gt;如何设置守护线程？通过Thread.setDaemon(false)设置为用户线程，通过Thread.setDaemon(true)设置为守护线程。如果不设置属性，默认为用户线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread.setDaemon(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyThread extends Thread {
    private int i = 0;
    @Override
    public void run() {
        try {
            while (true){
                i++;
                System.out.println(&quot;i=&quot;+i);
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        MyThread thread = new MyThread();
        thread.setDaemon(true);
        thread.start();
        Thread.sleep(5000);
        System.out.println(&quot;我离开后thread对象也就不再打印了&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i=1
i=2
i=3
i=4
i=5
我离开后thread对象也就不再打印了&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考与总结&quot;&gt;参考与总结&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;《Java多线程编程核心技术》高洪岩 著&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文主要介绍了Thread类的API，算是为学习多线程更深层次知识打下一些基础。本文是多线程系列的第一章，后续还会有。本文纯手打，若有错误请在评论区指正。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Sep 2018 14:10:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>1、进程和线程 一个程序就是一个进程，而一个程序中的多个任务则被称为线程。 进程是表示资源分配的基本单位，又是调度运行的基本单位。 线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。 举个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9575698.html</dc:identifier>
</item>
</channel>
</rss>