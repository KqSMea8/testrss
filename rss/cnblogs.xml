<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>VantPy自动化测试框架 - G2Bent</title>
<link>http://www.cnblogs.com/G2Bent/p/8046662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/G2Bent/p/8046662.html</guid>
<description>&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;1.&lt;/span&gt;&lt;/span&gt;必须要谈的一点，就是我们学习自动测试不是用来炫耀的，而是用来提升自身能力的。&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;2.&lt;/span&gt;&lt;/span&gt;这个框架不是通用框架，只是在这里灌输这个框架的思想，让每个人写框架都易如反掌&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;3.&lt;/span&gt;&lt;/span&gt;如果没有&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;python&lt;/span&gt;&lt;/span&gt;基础的同学，希望能够先学习&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;python&lt;/span&gt;&lt;/span&gt;基础知识，因为后面学的会越來越乱&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;4.&lt;/span&gt;&lt;/span&gt;学完之后，你能学到当前热门的自动化测试知识，你再也不是测试小白，提升了自身解决问题的能力。&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;5.框架是使用python3写的&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;我们先看一下这个框架到底有什么吧&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1215049/201712/1215049-20171216145846327-802359693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;现在我们来看看每个文件的内容吧。&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Autolt&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第一个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Autolt&lt;/span&gt;&lt;/span&gt;文件，这个文件的内容是，当你要在某个页面中要上传文件&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;/&lt;/span&gt;&lt;/span&gt;图片&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;/&lt;/span&gt;&lt;/span&gt;其他文件时候，&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;python&lt;/span&gt;&lt;/span&gt;没有一个好的方法可以提供给你，这时候我们就要用到第三方的软件，将我们要上传的文件打包成一个路径，给&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;python&lt;/span&gt;&lt;/span&gt;调用就可以了。&lt;strong&gt;&lt;span&gt;使用到的知识：&lt;a href=&quot;https://www.autoitscript.com/site/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Autolt&lt;/span&gt;&lt;/span&gt;的使用 &lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Common&lt;/span&gt;&lt;/span&gt;文件夹&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第二个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Common&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，将我们使用的共同文件都放在这里了，我现在就把测试用到的接口内容都放在里面了，还有就是&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;selenium&lt;/span&gt;&lt;/span&gt;的二次重构也放在这里。&lt;strong&gt;使用到的知识：&lt;/strong&gt;&lt;a href=&quot;http://docs.python-requests.org/zh_CN/latest/user/quickstart.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;python&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;&lt;a href=&quot;http://docs.python-requests.org/zh_CN/latest/user/quickstart.html&quot; target=&quot;_blank&quot;&gt;接口测试&lt;/a&gt;，获取接口内容&lt;/strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;strong&gt;;&lt;a href=&quot;https://pypi.python.org/pypi/selenium/&quot; target=&quot;_blank&quot;&gt;selenium&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://pypi.python.org/pypi/selenium/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;二次开发&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Data&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第三个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Data&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，直接理解为数据。是的，这个文件夹放的就是我们的数据，在我们在测试使用的数据，我们就可以全部都放在这里了。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用的知识：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://pypi.python.org/pypi/openpyxl&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;python&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;openpyxl&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;a href=&quot;https://pypi.python.org/pypi/openpyxl&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;的使用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，在当前很多框架中都是使用&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;xlrd&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;xlwt&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;两个库并用，可是&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;openpyxl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;已经足够了，又可以读又可以写&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Deletest&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第四个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Deletest&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，我个人写的一个删除手机号码的接口而已，这个文件夹之所以提供给大家，是因为当我们在进行自动化注册，或者是其他使用到的真实数据时，我们不能每次都跟开发沟通，删除该账户，再去自动化测试，这样使的我们工作的时间加长了好多。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用的知识：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;python&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;接口&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;post&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;请求&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Image&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第五个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Image&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，将我们每次进行的测试用例测试的结果进行截图保存，这使得我们自动化测试加多了一层验证操作，提高我们测试脚本的质量。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用的知识：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;python&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;screen&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Pages&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第六个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Pages&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，我们要测试的网页的所有元素都放在这里了，这提高了我们测试的时候使用的元素操作。让我们不用没有都对同一个元素进行多次的操作了。我们只需要去调用就可以了。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用到的知识：调用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;selenium&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;的方法，定位页面元素&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;;&lt;a href=&quot;https://pypi.python.org/pypi/unittest2/&quot; target=&quot;_blank&quot;&gt;unittest&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;https://pypi.python.org/pypi/unittest2/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;库的单元测试校验。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Result&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第七个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;Result&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，我们测试之后生成的测试报告，很多时候我们只是把&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;HTMLTestRunner&lt;/span&gt;&lt;/span&gt;放在&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;python&lt;/span&gt;&lt;/span&gt;的包里，这样对于我们后期进行的持续集成测试是不友善的，所以，我们必须将本身的包和测试服务器的包完全分开。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用的知识：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;a href=&quot;https://pypi.python.org/pypi/HTMLTestRunner&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;HTMLTestRunner&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;的调用和&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;Boostrape&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;的使用。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;TestCase&lt;/span&gt;&lt;/span&gt;文件夹&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;第八个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;TestCaase&lt;/span&gt;&lt;/span&gt;文件夹，这个文件夹的内容是，我们要进行的测试步骤操作，很多人希望可以使用&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;excel&lt;/span&gt;&lt;/span&gt;文件写测试用例，我的建议是，文件操作会使我们对代码的依赖减弱，所以，还是好好地写测试代码吧。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用的知识：调用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;selenium&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;的方法，执行测试步骤，&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;unittest&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;库的使用。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;index.py&lt;/span&gt;&lt;/span&gt;文件&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;这个&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;index.py&lt;/span&gt;&lt;/span&gt;文件，将我们所有的测试用例都集成在一起，每次我们需要全量测试，我们只需要执行这个文件就可以了。&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;使用的知识：编写测试集，调用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;HTMLTestRunner&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;生成测试报告，调用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;screen&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;方法生成截图，&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;unittest&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;库的使用。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;看完上面的内容，这就是坚持学习自动化测试需要学到的内容，缺少某一部分的知识都无法完成自动化测试的工作。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;strong&gt;&lt;span&gt;说在后面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;自动化测试不等于全自动化测试，自动化测试只是帮助我们执行我们已经测试过的内容，它无法帮我们测试未知的错误。那么自动化测试的作用在哪里呢？&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;1.&lt;/span&gt;&lt;/span&gt;提高测试的效率：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;传统测试：我们项目每更新一次版本，我们都需要手动去操作一遍，随着内容功能的增加，我们测试的的时间也随之增加，很多功能我们上一版本已经测试过了，这个版本我们还必须要手动去测试，这使得我们工作时间加长了&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;自动化测试：全量回归测试，我们每更新一次版本，测试脚本都会自动去执行上一版本的功能，生成测试报告，供给我们测试人员查看，那么我们是不是不用测试了？错的，我们还需要测试，但是我们更多时间是花在新开发的功能上和上一版本出现的&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;bug&lt;/span&gt;&lt;/span&gt;上了，这就是我们需要的探索性测试。&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;2.&lt;/span&gt;&lt;/span&gt;提高测试人员的代码能力：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;传统测试：很多测试人员只需要去点点点，这造成很多测试人员工作枯燥，无聊，使地这个测试行业给很多人的感觉就是，不需要能力都可以做测试工程师，小学生都会去点点点，降低了测试行业的重要性，使得测试工程师的价值一直被技术界贬低，所以，我们必须用其他方法去提升自身价值&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;自动化测试：我们需要编码，而且编码能力不能比开发差，所以我们需要去学习开发的知识内容，了解开发的知识框架，了解我们公司开发的总框架，这样我们可以跟开发更接近了一步，减少我们测试与开发之间的矛盾，也促进测试和开发的友好关系了。&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span lang=&quot;en-US&quot;&gt;3.&lt;/span&gt;&lt;/span&gt;未来的路更清晰：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;传统测试：当我们只是一直点点点，即使我们测试用例写得再好，我们也只会点点点，我们没有其他更突出的能力了，当我们点了几年之后，我们会担心自己未来的方向该往哪走，继续点点点，还是不点了。我们担心，年轻的一代点点点比我们快，导致我们失业，所以我们现在必须作出改变 &lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt;自动化测试：这是促进测试和开发行业的桥梁，当我们对测试知识理解到深层次，也理解到开发使用的框架，那么我们可以转什么职位呢？项目经理，产品经理，测试主管，项目主管这些都是我们可以在未来选择的职位的。在当前开发和产品不断有矛盾的时代，我们必须去改变这个行业中存在的矛盾，即使未来改变不了，至少我们也要为技术圈作出贡献。&lt;/p&gt;
&lt;p class=&quot;cjk&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;cjk&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 07:26:00 +0000</pubDate>
<dc:creator>G2Bent</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/G2Bent/p/8046662.html</dc:identifier>
</item>
<item>
<title>java基础进阶一：String源码和String常量池 - NiceCui</title>
<link>http://www.cnblogs.com/NiceCui/p/8046564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NiceCui/p/8046564.html</guid>
<description>&lt;p&gt;作者：NiceCui&lt;/p&gt;
&lt;h2 id=&quot;string-介绍常用方法源码分析&quot;&gt;1. String 介绍，常用方法源码分析&lt;/h2&gt;
&lt;h2 id=&quot;string-常量池分析&quot;&gt;2. String 常量池分析&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3 id=&quot;常用方法&quot;&gt;常用方法&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;equals&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trim&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replace&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;concat&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;split&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;startsWith 和 endsWith&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;substring&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;toUpperCase() 和 toLowerCase()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;compareTo&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;
&lt;h3 id=&quot;string-介绍&quot;&gt;String 介绍&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;String类被final所修饰，也就是说String对象是不可变量，并发程序最喜欢不可变量了。String类实现了Serializable, Comparable, CharSequence接口。&lt;/p&gt;
&lt;p&gt;从一段代码说起：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void stringTest(){
    String a = &quot;a&quot;+&quot;b&quot;+1;
    String b = &quot;ab1&quot;;
    System.out.println(a == b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家猜一猜结果如何？如果你的结论是true。好吧，再来一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void stringTest(){
    String a = new String(&quot;ab1&quot;);
    String b = &quot;ab1&quot;;
    System.out.println(a == b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如何呢？正确答案是false。&lt;/p&gt;
&lt;p&gt;让我们看看经过编译器编译后的代码如何&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//第一段代码
public void stringTest() {
    String a = &quot;ab1&quot;;
    String b = &quot;ab1&quot;;
    System.out.println(a == b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//第二段代码
public void stringTest() {
    String a1 = new String(&quot;ab1&quot;);
    String b = &quot;ab1&quot;;
    System.out.println(a1 == b);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说第一段代码经过了编译期优化，原因是编译器发现&quot;a&quot;+&quot;b&quot;+1和&quot;ab1&quot;的效果是一样的，都是不可变量组成。但是为什么他们的内存地址会相同呢？如果你对此还有兴趣，那就一起看看String类的一些重要源码吧。&lt;/p&gt;
&lt;p&gt;一、 String属性&lt;/p&gt;
&lt;p&gt;String类中包含一个不可变的char数组用来存放字符串，一个int型的变量hash用来存放计算后的哈希值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/** The value is used for character storage. */
private final char value[];

/** Cache the hash code for the string */
private int hash; // Default to 0

/** use serialVersionUID from JDK 1.0.2 for interoperability */
private static final long serialVersionUID = -6849794470754667710L;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二、 String构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//不含参数的构造函数，一般没什么用，因为value是不可变量
public String() {
    this.value = new char[0];
}

//参数为String类型
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}

//参数为char数组，使用java.utils包中的Arrays类复制
public String(char value[]) {
    this.value = Arrays.copyOf(value, value.length);
}

//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value
public String(byte bytes[], int offset, int length, String charsetName)
        throws UnsupportedEncodingException {
    if (charsetName == null)
        throw new NullPointerException(&quot;charsetName&quot;);
    checkBounds(bytes, offset, length);
    this.value = StringCoding.decode(charsetName, bytes, offset, length);
}

//调用public String(byte bytes[], int offset, int length, String charsetName)构造函数
public String(byte bytes[], String charsetName)
        throws UnsupportedEncodingException {
    this(bytes, 0, bytes.length, charsetName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三、 String常用方法&lt;/p&gt;
&lt;h4 id=&quot;equals&quot;&gt;1. equals&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;boolean equals(Object anObject)

public boolean equals(Object anObject) {
    //如果引用的是同一个对象，返回真
    if (this == anObject) {
        return true;
    }
    //如果不是String类型的数据，返回假
    if (anObject instanceof String) {
        String anotherString = (String) anObject;
        int n = value.length;
        //如果char数组长度不相等，返回假
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            //从后往前单个字符判断，如果有不相等，返回假
            while (n-- != 0) {
                if (v1[i] != v2[i])
                        return false;
                i++;
            }
            //每个字符都相等，返回真
            return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String e1 = &quot;good&quot;;
String e2 = &quot;good everyDay&quot;;
e1.equals(e2); // 返回 false&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;compareto&quot;&gt;2. compareTo&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;int compareTo(String anotherString)

public int compareTo(String anotherString) {
    //自身对象字符串长度len1
    int len1 = value.length;
    //被比较对象字符串长度len2
    int len2 = anotherString.value.length;
    //取两个字符串长度的最小值lim
    int lim = Math.min(len1, len2);
    char v1[] = value;
    char v2[] = anotherString.value;

    int k = 0;
    //从value的第一个字符开始到最小长度lim处为止，如果字符不相等，返回自身（对象不相等处字符-被比较对象不相等字符）
    while (k &amp;lt; lim) {
        char c1 = v1[k];
        char c2 = v2[k];
        if (c1 != c2) {
            return c1 - c2;
        }
        k++;
    }
    //如果前面都相等，则返回（自身长度-被比较对象长度）
    return len1 - len2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String co1 = &quot;hello&quot; ;
String co2 = &quot;hello&quot;;
String co3 = &quot;hello you&quot;;
         
System.out.println(co1.compareTo(co2)); // 0
System.out.println(co1.compareTo(co3)); // -4&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这个方法写的很巧妙，先从0开始判断字符大小。&lt;/li&gt;
&lt;li&gt;如果两个对象能比较字符的地方比较完了还相等，就直接返回自身长度减被比较对象长度，如果两个字符串长度相等，则返回的是0，巧妙地判断了三种情况。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;hashcode&quot;&gt;3.hashCode&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;int hashCode()

public int hashCode() {
    int h = hash;
    //如果hash没有被计算过，并且字符串不为空，则进行hashCode计算
    if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
        char val[] = value;

        //计算过程
        //s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
        for (int i = 0; i &amp;lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        //hash赋值
        hash = h;
    }
    return h;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String a = &quot;toyou&quot;;
char val[] = a.toCharArray();
char c1 = 't';
char c2 = 'a';
int f = c1; 
int e = c2;
         
System.out.println(e);           // 97   a
System.out.println(f);           // 116  t
System.out.println(31*val[0]);   // 3596
System.out.println(31*c1);       // 3596

// hashCode 计算中 因为char 字符可以自动转换成对应的 int 整形&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;String类重写了hashCode方法，Object中的hashCode方法是一个Native调用。&lt;/li&gt;
&lt;li&gt;String类的hash采用多项式计算得来，我们完全可以通过不相同的字符串得出同样的hash，所以两个String对象的hashCode相同，并不代表两个String是一样的。&lt;/li&gt;
&lt;li&gt;同一个String 对象 hashCode 一定相同， 但是 hashCode相同 ，不一定是同一个对象&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;startswith&quot;&gt;4.startsWith&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;boolean startsWith(String prefix,int toffset)

public boolean startsWith(String prefix, int toffset) {
    char ta[] = value;
    int to = toffset;
    char pa[] = prefix.value;
    int po = 0;
    int pc = prefix.value.length;
    // Note: toffset might be near -1&amp;gt;&amp;gt;&amp;gt;1.
    //如果起始地址小于0或者（起始地址+所比较对象长度）大于自身对象长度，返回假
    if ((toffset &amp;lt; 0) || (toffset &amp;gt; value.length - pc)) {
        return false;
    }
    //从所比较对象的末尾开始比较
    while (--pc &amp;gt;= 0) {
        if (ta[to++] != pa[po++]) {
            return false;
        }
    }
    return true;
}

public boolean startsWith(String prefix) {
    return startsWith(prefix, 0);
}

public boolean endsWith(String suffix) {
    return startsWith(suffix, value.length - suffix.value.length);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; String d = &quot;www.58fxp.com&quot;;
            
 System.out.println(d.startsWith(&quot;www&quot;)); // true
 System.out.println(d.endsWith(&quot;com&quot;));   // true&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;起始比较和末尾比较都是比较经常用得到的方法，例如在判断一个字符串是不是http协议的，或者初步判断一个文件是不是mp3文件，都可以采用这个方法进行比较。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;concat&quot;&gt;5.concat&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;String concat(String str)

public String concat(String str) {
    int otherLen = str.length();
    //如果被添加的字符串为空，返回对象本身
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String cat = &quot;much&quot;;
         
String newcat = cat.concat(&quot; yes&quot;); // much yes&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;concat方法也是经常用的方法之一，它先判断被添加字符串是否为空来决定要不要创建新的对象。&lt;/li&gt;
&lt;li&gt;1 如果 拼接的字符 长度为0 直接返回 原字符对象&lt;/li&gt;
&lt;li&gt;2 拼接的字符 不为空 返回 新的 字符对象&lt;/li&gt;
&lt;li&gt;判断字符长度 生成新对象&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;replace&quot;&gt;6.replace&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;String replace(char oldChar,char newChar)

public String replace(char oldChar, char newChar) {
    //新旧值先对比
    if (oldChar != newChar) {
        int len = value.length;
        int i = -1;
        char[] val = value; /* avoid getfield opcode */

        //找到旧值最开始出现的位置
        while (++i &amp;lt; len) {
            if (val[i] == oldChar) {
                break;
            }
        }
        //从那个位置开始，直到末尾，用新值代替出现的旧值
        if (i &amp;lt; len) {
            char buf[] = new char[len];
            for (int j = 0; j &amp;lt; i; j++) {
                buf[j] = val[j];
            }
            while (i &amp;lt; len) {
                char c = val[i];
                buf[i] = (c == oldChar) ? newChar : c;
                i++;
            }
            return new String(buf, true);
        }
    }
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String r1 = &quot;how do you do&quot;;
         
String r2 = r1.replace(&quot;do&quot;,&quot;is&quot;);
System.out.println(r2); // how is you is&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这个方法也有讨巧的地方，例如最开始先找出旧值出现的位置，这样节省了一部分对比的时间。&lt;/li&gt;
&lt;li&gt;replace(String oldStr,String newStr)方法通过正则表达式来判断。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;trim&quot;&gt;7.trim&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;String trim()

public String trim() {
    int len = value.length;
    int st = 0;
    char[] val = value;    /* avoid getfield opcode */

    //找到字符串前段没有空格的位置
    while ((st &amp;lt; len) &amp;amp;&amp;amp; (val[st] &amp;lt;= ' ')) {
        st++;
    }
    //找到字符串末尾没有空格的位置
    while ((st &amp;lt; len) &amp;amp;&amp;amp; (val[len - 1] &amp;lt;= ' ')) {
        len--;
    }
    //如果前后都没有出现空格，返回字符串本身
    return ((st &amp;gt; 0) || (len &amp;lt; value.length)) ? substring(st, len) : this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String t1 = &quot; public void &quot;; // 前后各一个空格
         
System.out.println(&quot;t1:&quot;+t1.length()); // 13 带空格长度
         
String t2 = t1.trim();
         
System.out.println(&quot;t2:&quot;+t2.length()); // 11 去掉空格
         
System.out.println(t2);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;intern&quot;&gt;8.intern&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;String intern()

public native String intern();&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;String dd = new String(&quot;bb&quot;).intern();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找等值的对象，&lt;/li&gt;
&lt;li&gt;如果没有找到则在常量池中开辟一片空间存放字符串并返回该对应String的引用，否则直接返回常量池中已存在String对象的引用。&lt;/li&gt;
&lt;li&gt;可以为new方法创建的 字符对象 也去强制查看常量池 是否已存在&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将引言中第二段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//String a = new String(&quot;ab1&quot;);
//改为
String a = new String(&quot;ab1&quot;).intern();&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;则结果为为真，原因在于a所指向的地址来自于常量池，而b所指向的字符串常量默认会调用这个方法，所以a和b都指向了同一个地址空间。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;int hash32()

private transient int hash32 = 0;
int hash32() {
    int h = hash32;
    if (0 == h) {
       // harmless data race on hash32 here.
       h = sun.misc.Hashing.murmur3_32(HASHING_SEED, value, 0, value.length);

       // ensure result is not zero to avoid recalcing
       h = (0 != h) ? h : 1;

       hash32 = h;
    }

    return h;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在JDK1.7中，Hash相关集合类在String类作key的情况下，不再使用hashCode方式离散数据，而是采用hash32方法。&lt;/li&gt;
&lt;li&gt;这个方法默认使用系统当前时间，String类地址，System类地址等作为因子计算得到hash种子，通过hash种子在经过hash得到32位的int型数值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public int length() {
    return value.length;
}
public String toString() {
    return this;
}
public boolean isEmpty() {
    return value.length == 0;
}
public char charAt(int index) {
    if ((index &amp;lt; 0) || (index &amp;gt;= value.length)) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return value[index];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是一些简单的常用方法。&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;String对象是不可变类型，返回类型为String的String方法每次返回的都是新的String对象，除了某些方法的某些特定条件返回自身。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;String对象的三种比较方式：&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;==内存比较：直接对比两个引用所指向的内存值，精确简洁直接明了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;equals字符串值比较：比较两个引用所指对象字面值是否相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;hashCode字符串数值化比较：将字符串数值化。两个引用的hashCode相同，不保证内存一定相同，不保证字面值一定相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;字符串常量池的设计思想&quot;&gt;字符串常量池的设计思想&lt;/h3&gt;
&lt;h4 id=&quot;一.字符串常量池设计初衷&quot;&gt;一.字符串常量池设计初衷&lt;/h4&gt;
&lt;p&gt;每个字符串都是一个String对象，系统开发中将会频繁使用字符串，如果像其他对像那样创建销毁将极大影响程序的性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JVM为了提高性能和减少内存开销，在实例化字符串的时候进行了优化&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;为字符串开辟了一个字符串常量池，类似于缓存区&lt;/li&gt;
&lt;li&gt;创建字符串常量时，首先判断字符串常量池是否存在该字符串&lt;/li&gt;
&lt;li&gt;存在该字符串返回引用实例，不存在，实例化字符串，放入池中&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;实现基础&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;实现该优化的基础是每个字符串常量都是final修饰的常量，不用担心常量池存在数据冲突&lt;/li&gt;
&lt;li&gt;运行时实例创建的全局字符串常量池中有一个表，总是为池中每个唯一的字符串对象维护一个引用,这就意味着它们一直引用着字符串常量池中的对象，所以，在常量池中的这些字符串不会被垃圾收集器回收&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;堆栈方法区&quot;&gt;堆、栈、方法区&lt;/h3&gt;
&lt;p&gt;了解字符串常量池，首先看一下 堆栈方法区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/113/869/1138695657-595126f06b2de&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;存储的是对象，每个对象都包含一个与之对应的class&lt;/li&gt;
&lt;li&gt;JVM只存在一个堆区，被所有线程共享，堆中不存在基本类型和对象引用，只存在对象本身&lt;/li&gt;
&lt;li&gt;对象由垃圾回收器负责回收，因此大小和生命周期不需要确定&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;每个线程都包含一个栈区，栈区只存放基础数据类型对象和自定义对象引用&lt;/li&gt;
&lt;li&gt;每个栈中的数据(原始类型和对象引用)都是私有的&lt;/li&gt;
&lt;li&gt;栈分为三个部分，基本类型变量区、执行环境上下文、操作指令区（存放操作指令）&lt;/li&gt;
&lt;li&gt;数据大小和生命周期是可以确定的，当没有引用指向这个数据时，这个数据就会消失&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;静态区，跟堆一样，被所有的线程共享&lt;/li&gt;
&lt;li&gt;方法区包含的都是在整个程序中永远唯一的元素，如class、static变量；&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;字符串常量池&quot;&gt;字符串常量池&lt;/h4&gt;
&lt;p&gt;字符串常量池存在于方法区&lt;/p&gt;
&lt;p&gt;代码：堆栈方法区存储字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String str1 = “abc”;
String str2 = “abc”;
String str3 = “abc”;
String str4 = new String(“abc”);
String str5 = new String(“abc”);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://sfault-image.b0.upaiyun.com/367/903/367903008-5951291f92d71&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;面试题&quot;&gt;面试题&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;String str4 = new String(“abc”) 创建多少个对象？&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;拆分： str4 = 、 new String（）、&quot;abc&quot;&lt;/li&gt;
&lt;li&gt;通过new 可以创建一个新的对象，new 方法创建实例化对象不会去常量池寻找是否已存在，只要new 都会实例化一个新的对象出来&lt;/li&gt;
&lt;li&gt;&quot;abc&quot;每个字符串 都是一个String 对象，如果常量池中没有则会创建一个新对象放入常量池，否则返回对象引用&lt;/li&gt;
&lt;li&gt;将对象地址赋值给str4,创建一个引用&lt;/li&gt;
&lt;li&gt;所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;String str1 = new String(&quot;A&quot;+&quot;B&quot;) ; 会创建多少个对象? String str2 = new String(&quot;ABC&quot;) + &quot;ABC&quot; ; 会创建多少个对象?&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 16 Dec 2017 07:01:00 +0000</pubDate>
<dc:creator>NiceCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NiceCui/p/8046564.html</dc:identifier>
</item>
<item>
<title>通过Javascript调用微软认知服务情感检测接口的两种实现方式 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8046542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8046542.html</guid>
<description>&lt;p&gt;这是今天在黑客松现场写的代码。我们的项目需要调用认知服务的情感识别接口。官方提供了一种方式，就是从一个远程图片进行识别。我另外写了一个从本地文件读取并上传进行识别的例子。&lt;/p&gt;

&lt;p&gt;官方文档，请参考 &lt;a title=&quot;https://docs.azure.cn/zh-cn/cognitive-services/emotion/quickstarts/javascript&quot; href=&quot;https://docs.azure.cn/zh-cn/cognitive-services/emotion/quickstarts/javascript&quot;&gt;https://docs.azure.cn/zh-cn/cognitive-services/emotion/quickstarts/javascript&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;     &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;script src=&quot;Scripts/jquery-3.2.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;     &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;br/&gt;         $(function () {&lt;br/&gt;             $(&quot;#test&quot;).click(function () {&lt;br/&gt;                 var params = {&lt;br/&gt;                     // Request parameters&lt;br/&gt;                 };&lt;br/&gt;                 $.ajax({&lt;br/&gt;                     url: &quot;&lt;a href=&quot;https://api.cognitive.azure.cn/emotion/v1.0/recognize&amp;quot;&quot;&gt;https://api.cognitive.azure.cn/emotion/v1.0/recognize&quot;&lt;/a&gt; + $.param(params),&lt;br/&gt;                     beforeSend: function (xhrObj) {&lt;br/&gt;                         // Request headers&lt;br/&gt;                         xhrObj.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;);&lt;/p&gt;
&lt;p&gt;                        // NOTE: Replace the &quot;Ocp-Apim-Subscription-Key&quot; value with a valid subscription key.&lt;br/&gt;                         xhrObj.setRequestHeader(&quot;Ocp-Apim-Subscription-Key&quot;, &quot;换成你的key&quot;);&lt;br/&gt;                     },&lt;br/&gt;                     type: &quot;POST&quot;,&lt;br/&gt;                     // Request body&lt;br/&gt;                     data: '{&quot;url&quot;: &quot;&lt;a href=&quot;https://tse3.mm.bing.net/th?id=OIP.4M-jZG7HnQUpUKJ0wowq7QDrEs&amp;amp;pid=1.7&amp;quot;}'&quot;&gt;https://tse3.mm.bing.net/th?id=OIP.4M-jZG7HnQUpUKJ0wowq7QDrEs&amp;amp;pid=1.7&quot;}'&lt;/a&gt;,&lt;br/&gt;                 })&lt;br/&gt;                     .done(function (data) {&lt;br/&gt;                         console.log(data)&lt;br/&gt;                     })&lt;br/&gt;                     .fail(function () {&lt;br/&gt;                         alert(&quot;error&quot;);&lt;br/&gt;                     });&lt;br/&gt;             });&lt;br/&gt;         });&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;     &amp;lt;button id=&quot;test&quot;&amp;gt;测试&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;



&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;     &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;br/&gt;     &amp;lt;title&amp;gt;File Emotion detecting&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;     &amp;lt;div id=&quot;page-wrapper&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;        &amp;lt;h1&amp;gt;Text File Reader&amp;lt;/h1&amp;gt;&lt;br/&gt;         &amp;lt;div&amp;gt;&lt;br/&gt;             Select a text file:&lt;br/&gt;             &amp;lt;input type=&quot;file&quot; id=&quot;fileInput&quot;&amp;gt;&lt;br/&gt;         &amp;lt;/div&amp;gt;&lt;br/&gt;         &amp;lt;pre id=&quot;fileDisplayArea&quot;&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;     &amp;lt;script src=&quot;Scripts/jquery-3.2.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;     &amp;lt;script&amp;gt;&lt;br/&gt;         window.onload = function () {&lt;br/&gt;             var fileInput = document.getElementById('fileInput');&lt;br/&gt;             var fileDisplayArea = document.getElementById('fileDisplayArea');&lt;/p&gt;
&lt;p&gt;            fileInput.addEventListener('change', function (e) {&lt;br/&gt;                 // Put the rest of the demo code here.&lt;br/&gt;                 var file = fileInput.files[0];&lt;br/&gt;                 var textType = /image.*/;&lt;br/&gt;                 if (file.type.match(textType)) {&lt;br/&gt;                     var reader = new FileReader();&lt;/p&gt;
&lt;p&gt;                    reader.onload = function (e) {&lt;br/&gt;                         fileDisplayArea.innerText = reader.result;&lt;/p&gt;
&lt;p&gt;                        var params = {&lt;br/&gt;                             // Request parameters&lt;br/&gt;                         };&lt;/p&gt;
&lt;p&gt;                        $.ajax({&lt;br/&gt;                             url: &quot;&lt;a href=&quot;https://api.cognitive.azure.cn/emotion/v1.0/recognize?&amp;quot;&quot;&gt;https://api.cognitive.azure.cn/emotion/v1.0/recognize?&quot;&lt;/a&gt; + $.param(params),&lt;br/&gt;                             beforeSend: function (xhrObj) {&lt;br/&gt;                                 xhrObj.setRequestHeader(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;);&lt;br/&gt;                                 xhrObj.setRequestHeader(&quot;Ocp-Apim-Subscription-Key&quot;, &quot;换成你的key&quot;);&lt;br/&gt;                             },&lt;br/&gt;                             type: &quot;POST&quot;,&lt;br/&gt;                             data: reader.result,&lt;br/&gt;                             processData: false&lt;br/&gt;                         })&lt;br/&gt;                             .done(function (data) {&lt;br/&gt;                                 alert(&quot;success&quot;);&lt;br/&gt;                             })&lt;br/&gt;                             .fail(function () {&lt;br/&gt;                                 alert(&quot;error&quot;);&lt;br/&gt;                             });&lt;br/&gt;                     }&lt;/p&gt;
&lt;p&gt;                    reader.readAsArrayBuffer(file);&lt;br/&gt;                 }&lt;br/&gt;                 else {&lt;br/&gt;                     fileDisplayArea.innerText = &quot;File not supported!&quot;;&lt;br/&gt;                 }&lt;br/&gt;             });&lt;br/&gt;         }&lt;br/&gt;     &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 06:44:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8046542.html</dc:identifier>
</item>
<item>
<title>Cesium中Clock控件及时间序列瓦片动态加载 - shoufengwei</title>
<link>http://www.cnblogs.com/shoufengwei/p/8046529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufengwei/p/8046529.html</guid>
<description>&lt;p&gt;前面已经写了两篇博客介绍Cesium，一篇整体上简单介绍了Cesium如何上手，还有一篇介绍了如何将Cesium与分布式地理信息处理框架Geotrellis相结合。Cesium的强大之处也在于其可以将时间运用到3维地球上，可以根据此时间进行动画、轨迹记录、地球的光照等等所有与时间相关的可视化效果。本文介绍Cesium中的Clock控件以及如何动态加载时间序列瓦片。&lt;/p&gt;

&lt;h2 id=&quot;控件显示和隐藏&quot;&gt;1.1 控件显示和隐藏&lt;/h2&gt;
&lt;p&gt;这里说的Clock控件包含两部分，Animation控件和Timeline控件，这二者基本是同时出现或隐藏的。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/704456/201712/704456-20171216143834749-56894939.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Cesium中Viewer默认开启这两个控件，如果你想要不显示这两个控件，可以在Viewer初始化中设置其为false，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; viewer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Viewer&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'cesiumContainer'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;animation&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;dt&quot;&gt;timeline&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这种方式只能在初始化时设置，无法动态的切换显示状态，灵活度上稍显不足。如下方式可以动态控制显示和隐藏，会动态调整布局。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;animation&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;container&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;visibility&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'visible'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;animation&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;container&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;visibility&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'hidden'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;timeline&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;container&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;visibility&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'visible'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;timeline&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;container&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;visibility&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'hidden'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;设置clock范围&quot;&gt;1.2 设置Clock范围&lt;/h2&gt;
&lt;p&gt;Clock中默认开始时间（startTime）为当前时间，终止时间（stopTime）为24小时后，并能获取当前时间（currentTime）。当然我们也可以通过如下代码手动设置时间轴上的时间范围：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; start &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;JulianDate&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fromIso8601&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'2015-07-30'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; end &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;JulianDate&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fromIso8601&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'2017-06-17'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;timeline&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;zoomTo&lt;/span&gt;(start&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; end)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; clock &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;clock&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; start&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;clock&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;endTime&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; end&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;clock&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; start&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;clock&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clockRange&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ClockRange&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;LOOP_STOP&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;clock&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;multiplier&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;86400&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中start和end分别代表起始和结束时间。multiplier表示时间轴进行速度，就是说此值表示真实世界时间进度与Cesium中的关系，值越大时间轴就走的越快，86400表示真实世界走过1s在Cesium中刻度走过1天，怎么有点南柯一梦的感觉。clockRange属性表示时间轴达到终点之后的行为，用户可以根据自己的需要来设置，默认为: UNBOUNDED&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CLAMPED：达到终止时间后停止&lt;/li&gt;
&lt;li&gt;LOOP_STOP：达到终止时间后重新循环&lt;/li&gt;
&lt;li&gt;UNBOUNDED：达到终止时间后继续读秒&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;时间序列瓦片&quot;&gt;2.1 时间序列瓦片&lt;/h2&gt;
&lt;p&gt;所谓时间序列瓦片是指存在多套瓦片，每套瓦片不是单独的，与时间有关。比如我们每天拍摄一遍地球影像，然后把每天的影像都做成一套瓦片，那么一年下来就会有365套瓦片，采用传统方案我们只能写365个页面每个页面加载一天的瓦片。这样非常麻烦，并且没有一个动态变化的效果也无法进行对比。我前面介绍过如何使用Geotrellis生成时间序列瓦片（见&lt;a href=&quot;http://www.cnblogs.com/shoufengwei/p/5895954.html&quot;&gt;geotrellis使用（二十三）动态加载时间序列数据&lt;/a&gt;），当然也不一定非要使用此种方式，简单的方式也可以是直接生成多套瓦片，每套瓦片的请求方式与其时间对应即可。&lt;/p&gt;
&lt;h2 id=&quot;cesium动态加载时间序列瓦片&quot;&gt;2.2 Cesium动态加载时间序列瓦片&lt;/h2&gt;
&lt;p&gt;在前面已经介绍了如何使用Cesium加载我们自己的瓦片，大致如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; imageryLayers &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;imageryLayers&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;imageryLayers&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addImageryProvider&lt;/span&gt;(provider)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中provider为我们自己创建的图层对象，时间序列瓦片与普通瓦片的区别正在此处。其创建时需要多指定与时间有关的参数。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; provider &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;WebMapTileServiceImageryProvider&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;url &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'https://gibs.earthdata.nasa.gov/wmts/epsg4326/{best}/{Layer}/{Style}/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;layer &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'AMSR2_Snow_Water_Equivalent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;style &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'default'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;tileMatrixSetID &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'2km'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;maximumLevel &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;format &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'image/png'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;viewer&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; times&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;credit &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Credit&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'NASA Global Imagery Browse Services for EOSDIS'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;dimensions&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;dt&quot;&gt;Layer &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'AMSR2_Snow_Water_Equivalent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;best&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'best'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;style参数会替换掉url中的{Style}字符串；tileMatrixSetID会替换掉{TileMatrixSet}字符串；{TileMatrix}/{TileRow}/{TileCol}表示z、x、y，无需手动设置；clock表示所使用的时钟，直接设置为系统时钟；cedit表示版权信息；dimensions里面的参数只要出现在url中全部会被其value替换掉。&lt;/p&gt;
&lt;p&gt;重点就是其中的times，需要传入一个TimeIntervalCollection对象。其创建方式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; times &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;TimeIntervalCollection&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fromIso8601&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;iso8601&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'2015-07-30/2017-06-16/P20D'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;dt&quot;&gt;leadingInterval&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;trailingInterval&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;isStopIncluded&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 
    &lt;span class=&quot;dt&quot;&gt;dataCallback&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; dataCallback
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iso8601参数为时间范围及间隔，用'/'分割，第一个表示开始时间，第二个表示结束时间，P20D表示间隔20天，还可以是P1M、P1Y、P1Y3M5DT6H7M30S等，代表不同的时间间隔。&lt;/p&gt;
&lt;p&gt;dataCallback表示在每个时间段内如何取值，比如时间间隔为20天，那么我们可以取第一天为请求瓦片的时间，也可以是最后一天，乃至范围内甚至是范围外的任意一天，这个就由dataCallback函数进行设置。示例如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;dataCallback&lt;/span&gt;(interval&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; index) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(index)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; time&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (index &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        time &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;JulianDate&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toIso8601&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;interval&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stop&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        time &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Cesium&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;JulianDate&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;toIso8601&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;interval&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;start&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; time
    &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;interval表示传入的时间区间，index表示是第几个区间，这两个参数也就分割了times中的完整时间段，所以我们可以给time赋值为任意想要设置的值。最后返回的是key、value形式，此处Time为key，而其必须与创建图层时候的{Time}字符串一致，否则请求的时候无法替换时间信息。&lt;/p&gt;

&lt;p&gt;本文简单介绍了Clock控件以及如何动态加载时间序列瓦片。合理运用Cesium中的Clock控件能够做出很多漂亮的可视化效果，甚至如同Flash一样只需要指定几个时间点对象的位置，Cesium就会自动插值成动画，这些我们在后面介绍。&lt;/p&gt;
&lt;p&gt;最后希望大家能在&lt;a href=&quot;http://www.itbang.me/goVote/215&quot;&gt;2017年度全网原创IT博主评选活动投票：http://www.itbang.me/goVote/215&lt;/a&gt;投上宝贵的一票（最勤奋博主：wsf），谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 06:39:00 +0000</pubDate>
<dc:creator>shoufengwei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufengwei/p/8046529.html</dc:identifier>
</item>
<item>
<title>javascript设计模式——中介者模式 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8042198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8042198.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　程序由大大小小的单一对象组成，所有这些对象都按照某种关系和规则来通信。当程序的规模增大，对象会越来越多，它们之间的关系也越来越复杂，难免会形成网状的交叉引用。当改变或删除其中一个对象的时候，很可能需要通知所有引用到它的对象。面向对象设计鼓励将行为分布到各个对象中，把对象划分成更小的粒度，有助于增强对象的可复用性，但由于这些细粒度对象之间的联系激增，又有可能会反过来降低它们的可复用性。中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系。本文将详细介绍中介者模式&lt;/p&gt;

&lt;h3&gt;泡泡堂&lt;/h3&gt;
&lt;p&gt;【初始版本】&lt;/p&gt;
&lt;p&gt;　　先定义一个玩家构造函数，它有3个简单的原型方法：Play.prototype.win、Play.prototype.lose以及表示玩家死亡的Play.prototype.die。因为玩家的数目是2，所以当其中一个玩家死亡的时候游戏便结束，同时通知它的对手胜利。这段代码看起来很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Player( name ){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.enemy = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敌人&lt;/span&gt;
&lt;span&gt;};

Player.prototype.win &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; won &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
Player.prototype.lose &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name +&lt;span&gt;'&lt;/span&gt;&lt;span&gt; lost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
Player.prototype.die &lt;/span&gt;=&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lose();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.enemy.win();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来创建2个玩家对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接下来创建2 个玩家对象：&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; player1 = &lt;span&gt;new&lt;/span&gt; Player( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaohuochai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player2 = &lt;span&gt;new&lt;/span&gt; Player( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　给玩家相互设置敌人：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给玩家相互设置敌人：&lt;/span&gt;
player1.enemy =&lt;span&gt; player2;
player2.enemy &lt;/span&gt;= player1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当玩家player1被泡泡炸死的时候，只需要调用这一句代码便完成了一局游戏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
player1.die();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：xiaohuochai lost、match won&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只有2个玩家其实没什么意思，真正的泡泡堂游戏至多可以有8个玩家，并分成红蓝两队进行游戏&lt;/p&gt;
&lt;p&gt;　　现在改进一下游戏。因为玩家数量变多，用下面的方式来设置队友和敌人无疑很低效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
player1.partners=&lt;span&gt;[player1,player2,player3,player4];
player1.enemies&lt;/span&gt;=&lt;span&gt;[player5,player6,player7,player8];

Player5.partners&lt;/span&gt;=&lt;span&gt;[player5,player6,player7,player8];
Player5.enemies&lt;/span&gt;=[player1,player2,player3,player4];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以定义一个数组players来保存所有的玩家，在创建玩家之后，循环players来给每个玩家设置队友和敌人:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; players=[];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再改写构造函数Player，使每个玩家对象都增加一些属性，分别是队友列表、敌人列表、玩家当前状态、角色名字以及玩家所在的队伍颜色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Player( name, teamColor ){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.partners = []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队友列表&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.enemies = []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 敌人列表&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.state = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;live&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家状态&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.name = name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 角色名字&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.teamColor = teamColor; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队伍颜色&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　玩家胜利和失败之后的展现依然很简单，只是在每个玩家的屏幕上简单地弹出提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Player.prototype.win = function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家团队胜利&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;winner: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name );
};
Player.prototype.lose &lt;/span&gt;= function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家团队失败&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;loser: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name );
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　玩家死亡的方法要变得稍微复杂一点，需要在每个玩家死亡的时候，都遍历其他队友的生存状况，如果队友全部死亡，则这局游戏失败，同时敌人队伍的所有玩家都取得胜利，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Player.prototype.die = function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家死亡&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; all_dead = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dead&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置玩家状态为死亡&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, partner; partner = &lt;span&gt;this&lt;/span&gt;.partners[ i++ ]; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历队友列表&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( partner.state !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dead&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果还有一个队友没有死亡，则游戏还未失败&lt;/span&gt;
            all_dead = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( all_dead === &lt;span&gt;true&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果队友全部死亡&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.lose(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知自己游戏失败&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, partner; partner = &lt;span&gt;this&lt;/span&gt;.partners[ i++ ]; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知所有队友玩家游戏失败&lt;/span&gt;
&lt;span&gt;            partner.lose();
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, enemy; enemy = &lt;span&gt;this&lt;/span&gt;.enemies[ i++ ]; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知所有敌人游戏胜利&lt;/span&gt;
&lt;span&gt;            enemy.win();
        }
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后定义一个工厂来创建玩家：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; playerFactory =&lt;span&gt; function( name, teamColor ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newPlayer = &lt;span&gt;new&lt;/span&gt; Player( name, teamColor ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新玩家&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, player; player = players[ i++ ]; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知所有的玩家，有新角色加入&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( player.teamColor === newPlayer.teamColor ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是同一队的玩家&lt;/span&gt;
            player.partners.push( newPlayer ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相互添加到队友列表&lt;/span&gt;
&lt;span&gt;            newPlayer.partners.push( player );
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            player.enemies.push( newPlayer ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相互添加到敌人列表&lt;/span&gt;
&lt;span&gt;            newPlayer.enemies.push( player );
        }
    }
    players.push( newPlayer );
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newPlayer;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在用这段代码创建8个玩家：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红队：&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; player1 = playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhao&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
player2 &lt;/span&gt;= playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;qian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
player3 &lt;/span&gt;= playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
player4 &lt;/span&gt;= playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;蓝队：&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; player5 = playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
player6 &lt;/span&gt;= playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
player7 &lt;/span&gt;= playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zheng&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
player8 &lt;/span&gt;= playerFactory( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wang&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在已经可以随意地为游戏增加玩家或者队伍，但问题是，每个玩家和其他玩家都是紧紧耦合在一起的。在此段代码中，每个玩家对象都有两个属性，this.partners和this.enemies，用来保存其他玩家对象的引用。当每个对象的状态发生改变，比如角色移动、吃到道具或者死亡时，都必须要显式地遍历通知其他对象&lt;/p&gt;
&lt;p&gt;　　如果在一个大型网络游戏中，画面里有成百上千个玩家，几十支队伍在互相厮杀。如果有一个玩家掉线，必须从所有其他玩家的队友列表和敌人列表中都移除这个玩家。游戏也许还有解除队伍和添加到别的队伍的功能，红色玩家可以突然变成蓝色玩家，这就不再仅仅是循环能够解决的问题了&lt;/p&gt;
&lt;p&gt;【中介者模式】&lt;/p&gt;
&lt;p&gt;　　现在开始用中介者模式来改造上面的泡泡堂游戏，首先仍然是定义Player构造函数和player对象的原型方法，在player对象的这些原型方法中，不再负责具体的执行逻辑，而是把操作转交给中介者对象，把中介者对象命名为playerDirector：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Player( name, teamColor ){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name = name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 角色名字&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.teamColor = teamColor; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队伍颜色&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.state = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家生存状态&lt;/span&gt;
&lt;span&gt;};

Player.prototype.win &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; won &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};

Player.prototype.lose &lt;/span&gt;=&lt;span&gt; function(){
    console.log( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name +&lt;span&gt;'&lt;/span&gt;&lt;span&gt; lost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************玩家死亡****************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Player.prototype.die &lt;/span&gt;=&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dead&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    playerDirector.reciveMessage( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;playerDead&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给中介者发送消息，玩家死亡&lt;/span&gt;
&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************移除玩家****************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Player.prototype.remove &lt;/span&gt;=&lt;span&gt; function(){
    playerDirector.reciveMessage( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;removePlayer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给中介者发送消息，移除一个玩家&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************玩家换队****************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Player.prototype.changeTeam &lt;/span&gt;=&lt;span&gt; function( color ){
    playerDirector.reciveMessage( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;changeTeam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;, color ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给中介者发送消息，玩家换队&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再继续改写之前创建玩家对象的工厂函数，可以看到，因为工厂函数里不再需要给创建的玩家对象设置队友和敌人，这个工厂函数几乎失去了工厂的意义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; playerFactory=&lt;span&gt;function(name,teamColor){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newPlayer=newPlayer(name,teamColor);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创造一个新的玩家对象&lt;/span&gt;
  playerDirector.reciveMessage(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;addPlayer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,newPlayer);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给中介者发送消息，新增玩家&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newPlayer;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，需要实现这个中介者playerDirector对象，一般有以下两种方式&lt;/p&gt;
&lt;p&gt;　　1、利用发布—订阅模式。将playerDirector实现为订阅者，各player作为发布者，一旦player的状态发生改变，便推送消息给playerDirector，playerDirector处理消息后将反馈发送给其他player&lt;/p&gt;
&lt;p&gt;　　2、在playerDirector中开放一些接收消息的接口，各player可以直接调用该接口来给playerDirector发送消息，player只需传递一个参数给playerDirector，这个参数的目的是使playerDirector可以识别发送者。同样，playerDirector接收到消息之后会将处理结果反馈给其他player&lt;/p&gt;
&lt;p&gt;　　这两种方式的实现没什么本质上的区别。在这里使用第二种方式，playerDirector开放一个对外暴露的接口reciveMessage，负责接收player对象发送的消息，而player对象发送消息的时候，总是把自身this作为参数发送给playerDirector，以便playerDirector识别消息来自于哪个玩家对象，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; playerDirector=&lt;span&gt; ( function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; players = {}, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存所有玩家&lt;/span&gt;
        operations = {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中介者可以执行的操作&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************新增一个玩家**************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    operations.addPlayer &lt;/span&gt;=&lt;span&gt; function( player ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; teamColor = player.teamColor; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家的队伍颜色&lt;/span&gt;
        players[ teamColor ] = players[ teamColor ] || []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果该颜色的玩家还没有成立队伍，则新成立一个队伍&lt;/span&gt;
        players[ teamColor ].push( player ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加玩家进队伍&lt;/span&gt;
&lt;span&gt;    };
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************移除一个玩家**************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    operations.removePlayer &lt;/span&gt;=&lt;span&gt; function( player ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; teamColor = player.teamColor, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家的队伍颜色&lt;/span&gt;
        teamPlayers = players[ teamColor ] || []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该队伍所有成员&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = teamPlayers.length - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i-- ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历删除&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( teamPlayers[ i ] ===&lt;span&gt; player ){
                teamPlayers.splice( i, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
            }
        }
    };
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************玩家换队**************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    operations.changeTeam &lt;/span&gt;= function( player, newTeamColor ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家换队&lt;/span&gt;
        operations.removePlayer( player ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从原队伍中删除&lt;/span&gt;
        player.teamColor = newTeamColor; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 改变队伍颜色&lt;/span&gt;
        operations.addPlayer( player ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加到新队伍中&lt;/span&gt;
&lt;span&gt;    };

    operations.playerDead &lt;/span&gt;= function( player ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家死亡&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; teamColor =&lt;span&gt; player.teamColor,
        teamPlayers &lt;/span&gt;= players[ teamColor ]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 玩家所在队伍&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; all_dead = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, player; player = teamPlayers[ i++&lt;span&gt; ]; ){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( player.state !== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dead&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){
                all_dead &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( all_dead === &lt;span&gt;true&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全部死亡&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, player; player = teamPlayers[ i++&lt;span&gt; ]; ){
                player.lose(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 本队所有玩家lose&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; color &lt;span&gt;in&lt;/span&gt;&lt;span&gt; players ){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( color !==&lt;span&gt; teamColor ){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; teamPlayers = players[ color ]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他队伍的玩家&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, player; player = teamPlayers[ i++&lt;span&gt; ]; ){
                        player.win(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其他队伍所有玩家win&lt;/span&gt;
&lt;span&gt;                    }
                }
            }
        }
    };
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reciveMessage =&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message = Array.prototype.shift.call( arguments ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arguments 的第一个参数为消息名称&lt;/span&gt;
        operations[ message ].apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
    };

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        reciveMessage: reciveMessage
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到，除了中介者本身，没有一个玩家知道其他任何玩家的存在，玩家与玩家之间的耦合关系已经完全解除，某个玩家的任何操作都不需要通知其他玩家，而只需要给中介者发送一个消息，中介者处理完消息之后会把处理结果反馈给其他的玩家对象。还可以继续给中介者扩展更多功能，以适应游戏需求的不断变化&lt;/p&gt;

&lt;h3&gt;购买商品&lt;/h3&gt;
&lt;p&gt;　　假设正在编写一个手机购买的页面，在购买流程中，可以选择手机的颜色以及输入购买数量，同时页面中有两个展示区域，分别向用户展示刚刚选择好的颜色和数量。还有一个按钮动态显示下一步的操作，需要查询该颜色手机对应的库存，如果库存数量少于这次的购买数量，按钮将被禁用并且显示库存不足，反之按钮可以点击并且显示放入购物车&lt;/p&gt;
&lt;p&gt;　　这个需求是非常容易实现的，假设已经提前从后台获取到了所有颜色手机的库存量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; goods ={    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机库存&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么页面有可能显示为如下几种场景：&lt;/p&gt;
&lt;p&gt;　　1、选择红色手机，购买4个，库存不足&lt;/p&gt;
&lt;p&gt;　　2、选择蓝色手机，购买5个，库存充足，可以加入购物车&lt;/p&gt;
&lt;p&gt;　　3、或者是没有输入购买数量的时候，按钮将被禁用并显示相应提示&lt;/p&gt;
&lt;p&gt;　　接下来将遇到至少5个节点，分别是：&lt;/p&gt;
&lt;p&gt;　　1、下拉选择框colorSelect&lt;/p&gt;
&lt;p&gt;　　2、文本输入框numberInput&lt;/p&gt;
&lt;p&gt;　　3、展示颜色信息colorInfo&lt;/p&gt;
&lt;p&gt;　　4、展示购买数量信息numberInfo&lt;/p&gt;
&lt;p&gt;　　5、决定下一步操作的按钮nextBtn&lt;/p&gt;
&lt;p&gt;【基础版本】&lt;/p&gt;
&lt;p&gt;　　从编写HTML代码开始&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;&lt;span&gt;
选择颜色: &lt;/span&gt;&amp;lt;&lt;span&gt;select&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;colorSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;请选择&amp;lt;/option&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;红色&amp;lt;/option&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;蓝色&amp;lt;/option&amp;gt;
&amp;lt;/&lt;span&gt;select&lt;/span&gt;&amp;gt;&lt;span&gt;
输入购买数量: &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numberInput&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;span&gt;
您选择了颜色: &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;colorInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;&lt;span&gt;
您输入了数量: &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numberInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;
&amp;lt;button id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nextBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; disabled=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;请选择手机颜色和购买数量&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来将分别监听colorSelect的onchange事件函数和numberInput的oninput事件函数，然后在这两个事件中作出相应处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
  &lt;span&gt;var&lt;/span&gt; colorSelect = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;colorSelect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      numberInput &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numberInput&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      colorInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;colorInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      numberInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numberInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      nextBtn &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nextBtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; goods = {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手机库存&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
  };
  colorSelect.onchange &lt;/span&gt;=&lt;span&gt; function(){ 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color = &lt;span&gt;this&lt;/span&gt;.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色&lt;/span&gt;
        number = numberInput.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数量&lt;/span&gt;
        stock = goods[ color ];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该颜色手机对应的当前库存&lt;/span&gt;
    colorInfo.innerHTML =&lt;span&gt; color;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;color ){ 
      nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择手机颜色&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ( ( number - &lt;span&gt;0&lt;/span&gt; ) | &lt;span&gt;0&lt;/span&gt; ) !== number - &lt;span&gt;0&lt;/span&gt; ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户输入的购买数量是否为正整数&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入正确的购买数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( number &amp;gt; stock ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前选择数量没有超过库存量&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; 
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;库存不足&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    }
    nextBtn.disabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
    nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;放入购物车&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当触发了colorSelect的onchange之后，首先要让colorInfo中显示当前选中的颜色，然后获取用户当前输入的购买数量，对用户的输入值进行一些合法性判断。再根据库存数量来判断nextBtn的显示状态&lt;/p&gt;
&lt;p&gt;　　接下来，编写numberInput的事件相关代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
numberInput.oninput =&lt;span&gt; function(){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color = colorSelect.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色&lt;/span&gt;
      number = &lt;span&gt;this&lt;/span&gt;.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数量&lt;/span&gt;
      stock = goods[ color ];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该颜色手机对应的当前库存&lt;/span&gt;
  numberInfo.innerHTML =&lt;span&gt; number; 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;color ){
    nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择手机颜色&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ( ( number - &lt;span&gt;0&lt;/span&gt; ) | &lt;span&gt;0&lt;/span&gt; ) !== number - &lt;span&gt;0&lt;/span&gt; ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入购买数量是否为正整数&lt;/span&gt;
    nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入正确的购买数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( number &amp;gt; stock ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前选择数量没有超过库存量&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; 
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;库存不足&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
  }
  nextBtn.disabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
  nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;放入购物车&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然目前顺利完成了代码编写，但随之而来的需求改变有可能给我们带来麻烦。假设现在要求去掉colorInfo和numberInfo这两个展示区域，就要分别改动colorSelect.onchange和numberInput.onput里面的代码，因为在先前的代码中，这些对象确实是耦合在一起的&lt;/p&gt;
&lt;p&gt;　　当这个页面里的节点激增到10个或者15个时，它们之间的联系可能变得更加错综复杂，任何一次改动都将变得很棘手。为了证实这一点，假设页面中将新增另外一个下拉选择框，代表选择手机内存。现在需要计算颜色、内存和购买数量，来判断nextBtn是显示库存不足还是放入购物车&lt;/p&gt;
&lt;p&gt;　　首先要增加两个HTML节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;&lt;span&gt;
  选择颜色:    &lt;/span&gt;&amp;lt;&lt;span&gt;select&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;colorSelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;请选择&amp;lt;/option&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;红色&amp;lt;/option&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;蓝色&amp;lt;/option&amp;gt;
  &amp;lt;/&lt;span&gt;select&lt;/span&gt;&amp;gt;&lt;span&gt;
  选择内存:    &lt;/span&gt;&amp;lt;&lt;span&gt;select&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memorySelect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;请选择&amp;lt;/option&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;32G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;32G&amp;lt;/option&amp;gt;
  &amp;lt;option value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;16G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;16G&amp;lt;/option&amp;gt;
  &amp;lt;/&lt;span&gt;select&lt;/span&gt;&amp;gt;&lt;span&gt;
  输入购买数量: &lt;/span&gt;&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numberInput&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&amp;lt;br/&amp;gt;&lt;span&gt;
  您选择了颜色: &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;colorInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;&lt;span&gt; 
  您选择了内存: &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;memoryInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;&lt;span&gt; 
  您输入了数量: &lt;/span&gt;&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;numberInfo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;br/&amp;gt;
  &amp;lt;button id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nextBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; disabled=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;请选择手机颜色和购买数量&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;script&amp;gt;
  &lt;span&gt;var&lt;/span&gt; colorSelect = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;colorSelect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ),
      numberInput &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numberInput&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      memorySelect &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;memorySelect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      colorInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;colorInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      numberInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numberInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      memoryInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;memoryInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      nextBtn &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nextBtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来修改表示存库的JSON对象以及修改colorSelect的onchange事件函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
  &lt;span&gt;var&lt;/span&gt; goods = {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手机库存&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red|32G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 红色 32G，库存数量为 3&lt;/span&gt;
    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red|16G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue|32G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue|16G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
  };

  colorSelect.onchange &lt;/span&gt;=&lt;span&gt; function(){ 
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value,
        memory &lt;/span&gt;=&lt;span&gt; memorySelect.value,
        stock &lt;/span&gt;= goods[ color + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; memory ];
    number &lt;/span&gt;= numberInput.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数量&lt;/span&gt;
    colorInfo.innerHTML =&lt;span&gt; color;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;color ){ 
      nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择手机颜色&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;memory ){ 
      nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择内存大小&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ( ( number - &lt;span&gt;0&lt;/span&gt; ) | &lt;span&gt;0&lt;/span&gt; ) !== number - &lt;span&gt;0&lt;/span&gt; ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入购买数量是否为正整数&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入正确的购买数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( number &amp;gt; stock ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前选择数量没有超过库存量&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; 
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;库存不足&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    }
    nextBtn.disabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
    nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;放入购物车&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  };
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当然同样要改写numberInput的事件相关代码，具体代码的改变跟colorSelect大同小异。最后还要新增memorySelect的onchange事件函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
  memorySelect.onchange &lt;/span&gt;=&lt;span&gt; function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color = colorSelect.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色 &lt;/span&gt;
    number = numberInput.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数量 &lt;/span&gt;
    memory = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value,
    stock &lt;/span&gt;= goods[ color + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + memory ];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该颜色手机对应的当前库存&lt;/span&gt;
    memoryInfo.innerHTML =&lt;span&gt; memory;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;color ){ 
      nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择手机颜色&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;memory ){ 
      nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择内存大小&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ( ( number - &lt;span&gt;0&lt;/span&gt; ) | &lt;span&gt;0&lt;/span&gt; ) !== number - &lt;span&gt;0&lt;/span&gt; ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入购买数量是否为正整数&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入正确的购买数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( number &amp;gt; stock ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前选择数量没有超过库存量&lt;/span&gt;
      nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; 
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;库存不足&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    }
    nextBtn.disabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
    nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;放入购物车&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
  };
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　仅仅是增加一个内存的选择条件，就要改变如此多的代码，这是因为在目前的实现中，每个节点对象都是耦合在一起的，改变或者增加任何一个节点对象，都要通知到与其相关的对象&lt;/p&gt;
&lt;p&gt;【引入中介者】&lt;/p&gt;
&lt;p&gt;　　现在来引入中介者对象，所有的节点对象只跟中介者通信。当下拉选择框colorSelect、memorySelect和文本输入框numberInput发生了事件行为时，它们仅仅通知中介者它们被改变了，同时把自身当作参数传入中介者，以便中介者辨别是谁发生了改变。剩下的所有事情都交给中介者对象来完成，这样一来，无论是修改还是新增节点，都只需要改动中介者对象里的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; goods = {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手机库存&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red|32G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red|16G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue|32G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue|16G&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mediator =&lt;span&gt; (function(){

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colorSelect = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;colorSelect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      memorySelect &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;memorySelect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      numberInput &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numberInput&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      colorInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;colorInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      memoryInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;memoryInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      numberInfo &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;numberInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ), 
      nextBtn &lt;/span&gt;= document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nextBtn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    changed: function( obj ){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; color = colorSelect.value,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色 &lt;/span&gt;
      memory = memorySelect.value,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内存 &lt;/span&gt;
      number = numberInput.value,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数量&lt;/span&gt;
      stock = goods[ color + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + memory ];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色和内存对应的手机库存数量&lt;/span&gt;

      &lt;span&gt;if&lt;/span&gt; ( obj === colorSelect ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果改变的是选择颜色下拉框&lt;/span&gt;
        colorInfo.innerHTML =&lt;span&gt; color;
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( obj ===&lt;span&gt; memorySelect ){ 
        memoryInfo.innerHTML &lt;/span&gt;=&lt;span&gt; memory;
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( obj ===&lt;span&gt; numberInput ){
        numberInfo.innerHTML &lt;/span&gt;=&lt;span&gt; number;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;color ){ 
        nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择手机颜色&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;memory ){ 
        nextBtn.disabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择内存大小&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( ( ( number - &lt;span&gt;0&lt;/span&gt; ) | &lt;span&gt;0&lt;/span&gt; ) !== number - &lt;span&gt;0&lt;/span&gt; ){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入购买数量是否为正整数&lt;/span&gt;
        nextBtn.disabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入正确的购买数量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
      nextBtn.disabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
      nextBtn.innerHTML &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;放入购物车&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    }
  }
})();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 事件函数：&lt;/span&gt;
colorSelect.onchange =&lt;span&gt; function(){ 
  mediator.changed( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; );
};
memorySelect.onchange &lt;/span&gt;=&lt;span&gt; function(){ 
  mediator.changed( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; );
};
numberInput.oninput &lt;/span&gt;=&lt;span&gt; function(){ 
  mediator.changed( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; );
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以想象，某天又要新增一些跟需求相关的节点，比如CPU型号，那只需要稍稍改动mediator对象即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; goods = {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手机库存&lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red|32G|800&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色 red，内存 32G，cpu800，对应库存数量为 3 &lt;/span&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;red|16G|801&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue|32G|800&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blue|16G|801&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mediator =&lt;span&gt; (function(){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; cpuSelect = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpuSelect&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    change: function(obj){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 略&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; cpu =&lt;span&gt; cpuSelect.value,
      stock &lt;/span&gt;= goods[ color + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + memory + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; cpu ];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( obj ===&lt;span&gt; cpuSelect ){ 
        cpuInfo.innerHTML &lt;/span&gt;=&lt;span&gt; cpu;
      }
    }
  }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;　　中介者模式是迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象应该尽可能少地了解另外的对象。如果对象之间的耦合性太高，一个对象发生改变之后，难免会影响到其他的对象。而在中介者模式里，对象之间几乎不知道彼此的存在，它们只能通过中介者对象来互相影响对方。因此，中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系。各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护&lt;/p&gt;
&lt;p&gt;　　不过，中介者模式也存在一些缺点。其中，最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介者对象自身往往就是一个难以维护的对象&lt;/p&gt;
&lt;p&gt;　　中介者模式可以非常方便地对模块或者对象进行解耦，但对象之间并非一定需要解耦。在实际项目中，模块或对象之间有一些依赖关系是很正常的。毕竟写程序是为了快速完成项目交付生产，而不是堆砌模式和过度设计。关键就在于如何去衡量对象之间的耦合程度。一般来说，如果对象之间的复杂耦合确实导致调用和维护出现了困难，而且这些耦合度随项目的变化呈指数增长曲线，那就可以考虑用中介者模式来重构代码&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 06:21:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8042198.html</dc:identifier>
</item>
<item>
<title>Android ListView与RecycleView的对比使用 - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/8045007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/8045007.html</guid>
<description>&lt;p&gt;&lt;span&gt;ListView，就如其名，是用来显示列表的一种View，而RecycleView，是其的加强版，今天带来的是这两个几乎具有相同的功能的对比使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先从ListView说起吧&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;ListView：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.在布局文件中使用ListView，并为其定义一个id，方便我们之后的调用，宽高与父控件相同&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.准备数据，将数据添加到ArrayAdapter适配器当中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.在Activity的java文件中使用findviewbyid找到ListView实例，为其设置Adapter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.实现ListView的item项点击事件,直接使用Listview定义的setitemonClick方法就行了&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里最为重要的一步其实是第二步，我们可以看到下面的代码，定义了一组String类型的数组，之后创建ArrayAdapter适配器,注意String，是一个泛型，后面的构造函数里的参数分别为上下文&lt;span&gt;&lt;strong&gt;android.R.Layout.simple_list_item 1&lt;/strong&gt;&lt;/span&gt;是安卓系统给的一个item布局，最后一项是String数组，也就是数据，之后寻找ListView的实例，调用setAdapter方法设置适配器&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;110.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MainActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AppCompatActivity {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String[] data = {&quot;Apple&quot; ，&quot;Banana&quot;,&quot;Orange&quot;,&quot;WatermeLon&quot;
                &quot;Pear&quot;,&quot;Grape&quot;,&quot;Pineapple&quot;,&quot;Strawberry&quot;,&quot;Cherry&quot;,&quot;Mango&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot; ，&quot;Watermelon&quot; ，&quot;Pear&quot; ，&quot;Grape&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Pineapple&quot;,&quot;Strawberry&quot;,&quot;Cherry&quot;,&quot;Mango&quot;&lt;span&gt;};
    
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
        setContentView(R.layout.activity.main);
        &lt;span&gt;&lt;strong&gt;ArrayAdapter&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; adapter = new ArrayAdapter&amp;lt;String(MainActivity.this, android.R.Layout.simple_list_item 1&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;, data);&lt;/strong&gt;&lt;/span&gt;
        ListView listView &lt;/span&gt;=&lt;span&gt; (ListView) findViewById(R.id.list _view);
        listView.setAdapter(adapter);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这是一个简单的例子，但是，我们知道第二个参数是安卓提供的一个item布局，这个布局过于简单，我们想要实现一个自定义布局怎么办？我们需要改造一下ArrayAdapter这个适配器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面便是自定义布局并使用的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.创建一个item的布局，也就是我们的自定义布局&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171215210755730-1523691446.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我定义了两个各占一半的textview，&lt;span&gt;记得根标签的高使用wrap_content&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.定义一个T类，作为适配器的泛型，（类似之前的String），里面需要一个构造方法，成员变量和get方法&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171215210532355-1343863358.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不知道为什么会有警告，用的public，可以正常使用，若是改为其他，另外那边调用就会出错了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.创建一个适配器类，使其继承ArrayAdapter&amp;lt;T&amp;gt;（T就是第二步定义的类），里面需要一个构造方法，还需要复写getView方法&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171215211013574-1442579347.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.准备数据，将数据添加到第三步的适配器类中，之后与上面所说的步骤一样，找到Listview的实例，设置适配器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171215211525121-981121824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171215211552371-115769801.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;532&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt; RecycleView：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于这个是Android团队新推出的，需要我们添加依赖才可以使用，记得点击sync now&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171215212518449-481592366.png&quot; alt=&quot;&quot; width=&quot;998&quot; height=&quot;502&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 使用步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.在布局文件中使用RecyclerView，定义id，宽高与空间相同&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.准备&lt;span&gt;RecyclerView的子项item布局，之后要在适配器类中使用，这里就不在赘述&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3.定义个泛型类，如之前在ListView中所说的T类，&lt;span&gt;适配器的泛型&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.定义一个适配器T类，使其继承RecyclerView.Adapter&amp;lt;T.ViewHolder&amp;gt;（ViewHolder是T类中的一个内部类），需要一个构造方法接收数据源，复写三个方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171216122015091-1303835763.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RecyclerAdapter是继承RecyclerView.Adapter&amp;lt;RecyclerAdapter.ViewHolder&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个尖括号里的本来应该是RecyclerView.ViewHolder,但是我们在RecyclerAdapter里定义了一个内部类ViewHolder，使其继承了RecyclerView.ViewHolder，所以我们就可以在尖括号里直接调用内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;我们先来看一下ViewHolder这个内部类，它里面有两个TextView的成员变量，之后，添加一个构造方法，参数是一个View，为这个两个textview通过findviewbyid找到实例&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来看RecycleAdapter这个类，在开头我们就声明了一个List的成员变量students，之后，添加构造方法，传入一个LIst，将其赋值给RecycleAdapter的成员变量students&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后需要复写三个方法，&lt;span&gt;OnCreateViewHolder，onBindViewHolder，getItemCount&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171216122958825-1046121799.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;onCreateViewHolder方法里面，首先就是通过LayoutInflater.from()方法接收一个context，之后，再通过inflate将item布局放进总布局中，之后再将这个view作为参数传到ViewHolder中去，同时，返回一个ViewHolder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;onBindViewHolder方法，由list的get方法，获得list里面的某个对象，之后，由holder调用两个TextView的setText方法进行设置，举一反三，如果是imageview的话，同样可以使用setresource设置其显示的图片，设置的参数，我们可以直接由Student类中的get方法获得&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; getItemCount 就是获得全部item的数量，这里item数量其实就是list中的项目，直接返回其的size就行了&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.准备数据，添加到适配器中&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.创建一个布局管理器LayoutManager，便于RecycleView设置布局，这里布局管理器有几种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种的像LIstView的垂直排列，LinearlayoutManager&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171216133725809-2011752322.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们也可以将其改为水平排列，只需调用linearLayoutManger的setOrientation，设置为LinearLayoutManager.HORIZONTAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171216134015872-345824872.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有GiidLayout网格布局 StaggerGildLayoutManager瀑布流布局，使用方法如上，不过，参数有所区别，想了解更多请转百度&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6.通过findviewbyid方法找到RecycleView的实例，为其设置LayoutManager，设置Adapter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171216134552716-2112098787.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 7.设置onClick方法，RecycleView里没有onClick方法，需要我们自己写，在哪里写呢？在RecycleAdapter中的onBindViewHolder方法中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1210268/201712/1210268-20171216142020499-1661235504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用Viewholder来找到子项，为其设置一个onClickListener，之后，为其设置onClick事件处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面这是比较简单的一种，还有其他几种方法，我在这也不一一测试，感兴趣的话可以自己研究研究&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考地址：http://blog.csdn.net/RaphetS/article/details/51254538&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;更多的RecycleView高级使用，请参考下面的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/skykingf/article/details/50827141&lt;/p&gt;
&lt;p&gt;http://www.jianshu.com/p/58ca20e1a5d6&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;br/&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 16 Dec 2017 05:57:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/8045007.html</dc:identifier>
</item>
<item>
<title>树的平衡 AVL Tree - 算法生活</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/8045240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/8045240.html</guid>
<description>&lt;p&gt;本篇随笔主要从以下三个方面介绍树的平衡：&lt;/p&gt;
&lt;p&gt;1）：BST不平衡问题&lt;/p&gt;
&lt;p&gt;2）：BST 旋转&lt;/p&gt;
&lt;p&gt;3）：AVL Tree&lt;/p&gt;
&lt;p&gt;一：BST不平衡问题的解析&lt;/p&gt;
&lt;p&gt;之前有提过普通BST的一些一些缺点，例如BST的高度是介于lgN和N之间的，如果是N的的话，显然效率很低，不是我们需要的；但是在实际情况中，BST的高度h = N的情况却经常出现，例如下图所示。在BST中search，insert的running time都等于BST的高度h，我们肯定希望高度h越小越好，best case就是lgN。下图的example 2的情况，我们会称之为这个BST是不平衡的。 所以如果遇到这种不平衡的BST，我们如何解决呢？如何将不平衡的BST转化成平衡的BST呢？如何将BST的高度h从N转化成lgN呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1287224/201712/1287224-20171203165052491-2079905959.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二：树的平衡&lt;/p&gt;
&lt;p&gt;下面我们就来介绍一下树的旋转 rotation。BST是可以经过一些旋转操作后，仍然保持BST的结构不变的，即对于每一个node，该node的left child的值总是小于这个node的值，而该node的right child的值总是大于这个node的值。经过总结，这个旋转主要可以分为4中模式，这四种模式如下面的两图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201712/1287224-20171215225027449-2126050637.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201712/1287224-20171215225117355-677818399.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这四种rotation的方式是由BST的特性所决定的，至于为什么这样旋转是是正确的，也是由BST的特点所确定的，我在这就不证明了。只要大家记住BST可以有这4中旋转模式即可。其实上面所示的rotation过程，都是为了平衡树的目的。 那么现在有一个问题来了，我们说了这么多平衡，不平衡的概念，前面我们都是通过直观的感受来体味平衡或者不平衡，那么到底有什么明确的指标可以指明一个BST到底是平衡还是不平衡的呢？？？这个指标到底是什么呢？那么下面就要解释AVL Tree的概念了。&lt;/p&gt;
&lt;p&gt;三：AVL Tree&lt;/p&gt;
&lt;p&gt;首先AVL Tree要满足以下2个条件：&lt;/p&gt;
&lt;p&gt;1. AVL Tree遵循BST的结构；即left child 小于当前node， right child大于当前node。&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;每一个node的2个 child nodes的高度相差不大于1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据上面的条件，我们可以看出AVL Tree其本质是一种特殊的BST。所以我们现在有一个定性的指标来判断一个BST是不是平衡的了，这个指标就是上面2个条件。当然了BST中有很多指标来判读一个BST是不是平衡的，我们这里只是用AVL Tree作为其中之一个指标，你也可以用其他的指标方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以AVL Tree是平衡的，其高度是h=lgN;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在AVL Tree中，每一个node的高度等于取其2个child node 的较大的高度值加1，即max[left child height, right child height]+1; 若node==NULL，则其高度默认为-1.&lt;/p&gt;
&lt;p&gt;当在构建AVL Tree的过程中，向其中insert node的时候，首先第一步跟BST insert一样，然后第二步是要检查insert后node的2个children之间的高度差，然后根据相应的高度差来判断相应的rotation的pattern，经过旋转后，使整个Tree仍然保持AVL Tree的特性，即满足上面的2个条件，所以仍然是平衡的。由于insert，search的操作的时间复杂度在BST中都是等于树的高度，AVL Tree作为一种特殊的BST，insert, search的操作的时间复杂度自然也是等于AVL的高度h=lgN. 这样的时间复杂度还是可以让我们满意的，其效率也要远远高于O（N）。AVL Tree的C++ 实现过程如下面的代码所示，以下代码实现了AVL Tree的insertion， sorting， rotation等功能。代码仅供学习交流等非盈利使用，不能用于商业目的，作者保留追溯的权利。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AVLTree.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

AVL_Tree::AVL_Tree(){
    
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root =&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AVL_Tree::setRoot(Node *&lt;span&gt;root){
    
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root =&lt;span&gt; root;
}
Node &lt;/span&gt;*&lt;span&gt;AVL_Tree::getRoot(){
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;root;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * height of tree or subtree
 *
 * a node's height equals the max of node's left child's height and node's right child's height plus 1
 *
 *parameters:
            1, node;//the node that we want to measure with
 *
 *return: the height of the node
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; AVL_Tree::height(Node *&lt;span&gt;node){
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !=&lt;span&gt; NULL) {
        
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l_height = height(node-&amp;gt;&lt;span&gt;getLeft());
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r_height = height(node-&amp;gt;&lt;span&gt;getRight());
        h &lt;/span&gt;= std::max(l_height,r_height) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; h;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * the height difference of two children nodes
 *
 *parameters:
 *          1, node;//the node which we want to know the differences of its two children
 *
 *return: int; the height difference of the two children nodes
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; AVL_Tree::heightDiff(Node *&lt;span&gt;node){
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l_height = height(node-&amp;gt;&lt;span&gt;getLeft());
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r_height = height(node-&amp;gt;&lt;span&gt;getRight());
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; l_height-&lt;span&gt;r_height;
    
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *
 *4 types of rotations
 *
 *1)left left pattern
 *2)left right pattern
 *3)right right pattern
 *4)right left pattern
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; AVL_Tree::ll_rotation(Node *&lt;span&gt;node){

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value = node-&amp;gt;&lt;span&gt;getData();
    Node &lt;/span&gt;*temp = node-&amp;gt;&lt;span&gt;getLeft();
    
    node&lt;/span&gt;-&amp;gt;setData(temp-&amp;gt;&lt;span&gt;getData());
    node&lt;/span&gt;-&amp;gt;setLeft(temp-&amp;gt;&lt;span&gt;getLeft());
    
    temp&lt;/span&gt;-&amp;gt;&lt;span&gt;setData(value);
    temp&lt;/span&gt;-&amp;gt;setLeft(temp-&amp;gt;&lt;span&gt;getRight());
    temp&lt;/span&gt;-&amp;gt;setRight(node-&amp;gt;&lt;span&gt;getRight());
    node&lt;/span&gt;-&amp;gt;&lt;span&gt;setRight(temp);
    
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AVL_Tree::lr_rotation(Node *&lt;span&gt;node){
 
    Node &lt;/span&gt;*temp = node-&amp;gt;&lt;span&gt;getLeft();
    node&lt;/span&gt;-&amp;gt;setLeft(temp-&amp;gt;&lt;span&gt;getRight());
    temp&lt;/span&gt;-&amp;gt;setRight(temp-&amp;gt;getRight()-&amp;gt;&lt;span&gt;getLeft());
    node&lt;/span&gt;-&amp;gt;getLeft()-&amp;gt;&lt;span&gt;setLeft(temp);
    ll_rotation(node);
    
    
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AVL_Tree::rr_rotation(Node *&lt;span&gt;node){
    
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value = node-&amp;gt;&lt;span&gt;getData();
    Node &lt;/span&gt;*temp = node-&amp;gt;&lt;span&gt;getRight();
    
    node&lt;/span&gt;-&amp;gt;setData(temp-&amp;gt;&lt;span&gt;getData());
    node&lt;/span&gt;-&amp;gt;setRight(temp-&amp;gt;&lt;span&gt;getRight());
    
    temp&lt;/span&gt;-&amp;gt;&lt;span&gt;setData(value);
    temp&lt;/span&gt;-&amp;gt;setRight(temp-&amp;gt;&lt;span&gt;getLeft());
    temp&lt;/span&gt;-&amp;gt;setLeft(node-&amp;gt;&lt;span&gt;getLeft());
    node&lt;/span&gt;-&amp;gt;&lt;span&gt;setLeft(temp);
    
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AVL_Tree::rl_rotation(Node *&lt;span&gt;node){
    
    Node &lt;/span&gt;*temp = node-&amp;gt;&lt;span&gt;getRight();
    node&lt;/span&gt;-&amp;gt;setRight(temp-&amp;gt;&lt;span&gt;getLeft());
    temp&lt;/span&gt;-&amp;gt;setLeft(node-&amp;gt;getRight()-&amp;gt;&lt;span&gt;getRight());
    node&lt;/span&gt;-&amp;gt;getRight()-&amp;gt;&lt;span&gt;setRight(temp);
    rr_rotation(node);
    
}



&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *Description: balancing the node whoes two children nodes' height difference is greater than 1 or smaller than -1
 *
 *parameters:
 *          1, node;//the node which we want to rotate with, it is the polar point of the rotation
 *
 *
 *return: void
 *
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; AVL_Tree::balance(Node *&lt;span&gt;node){
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; balance_factor = heightDiff(node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;differences of the node's two sub nodes.&lt;/span&gt;
    
    &lt;span&gt;if&lt;/span&gt; (balance_factor&amp;gt;&lt;span&gt;1&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;left side is heavy&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; (heightDiff(node-&amp;gt;getLeft())&amp;gt;&lt;span&gt;0&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;left left case&lt;/span&gt;
&lt;span&gt;            
            ll_rotation(node);
            
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;left right case&lt;/span&gt;
&lt;span&gt;            
            lr_rotation(node);
        }
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (balance_factor&amp;lt;-&lt;span&gt;1&lt;/span&gt;){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;right side heavy&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; (heightDiff(node-&amp;gt;getRight())&amp;lt;&lt;span&gt;0&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;right right case&lt;/span&gt;
&lt;span&gt;            
            rr_rotation(node);
            
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;right left case&lt;/span&gt;
&lt;span&gt;            
            rl_rotation(node);
        }
        
    }
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Description: insert a node into the AVL tree and keep the whole structure balanced after inserting
 *
 *Parameters:
 *          1, Node *node;//the node which needs to be inserted
 *          2, Node *root;//the root of the tree or subtree; 
 *
 *Return: Node *;//the parent node of the inserted node;
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

Node &lt;/span&gt;*AVL_Tree::insert(Node *node, Node *&lt;span&gt;root){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;root ==&lt;span&gt; NULL) {
        
        Node &lt;/span&gt;*root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        root&lt;/span&gt;-&amp;gt;&lt;span&gt;setLeft(NULL);
        root&lt;/span&gt;-&amp;gt;&lt;span&gt;setRight(NULL);
        root&lt;/span&gt;-&amp;gt;setData(node-&amp;gt;&lt;span&gt;getData());
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root =&lt;span&gt; root;
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root ==&lt;span&gt; NULL) {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(node-&amp;gt;getData() &amp;lt; root-&amp;gt;&lt;span&gt;getData()){
        
        root&lt;/span&gt;-&amp;gt;setLeft(insert(node, root-&amp;gt;&lt;span&gt;getLeft()));
        balance(root);
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;getData()&amp;gt;=root-&amp;gt;&lt;span&gt;getData()){
        
        root&lt;/span&gt;-&amp;gt;setRight(insert(node, root-&amp;gt;&lt;span&gt;getRight()));
        balance(root);
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *Description: print out the sorted nodes of the AVL tree of AVL subtree
 *
 *parameters:
 *          1, Node *node;//the root of the AVL tree of AVL subtree
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; AVL_Tree::inorderSort(Node *&lt;span&gt;node){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; NULL) {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    
    inorderSort(node&lt;/span&gt;-&amp;gt;&lt;span&gt;getLeft());
    std::cout&lt;/span&gt;&amp;lt;&amp;lt;node-&amp;gt;getData()&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    inorderSort(node&lt;/span&gt;-&amp;gt;&lt;span&gt;getRight());
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 16 Dec 2017 05:46:00 +0000</pubDate>
<dc:creator>算法生活</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tangxiaobo199181/p/8045240.html</dc:identifier>
</item>
<item>
<title>工作了八年之后，我准备去上海了 - 王磊的博客</title>
<link>http://www.cnblogs.com/vipstone/p/7921485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipstone/p/7921485.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　2008年来西安，一眨眼的功夫快十年了。也是从08年开始接触软件这个行业，从刚开始的懵懂无知，因为进北大青鸟很长一段时间，我也不知道“软件”到底是啥？自己想不明白给别人也讲不清楚，那时候只是单纯的觉得，计算机是以后发展的趋势，我想要做游戏，然后北大青鸟的咨询师告诉我，你的这些愿望只要来了这里都都可以实现！现在想想自己当初确实单纯，但所幸的是，我遇到了一个好时代，智能时代的到来，给予我们这些码农带来了一波红利，让我能在十年后的今天，依然无悔于当初的选择，即使我现在没能如愿以偿的做游戏（苦笑）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　按理来说只有每年的年末，我才会对自己做一个总结和展望，但今年比较特别，因为我要去上海了，离开工作了八年的西安，去一个崭新的环境开始新的生活，即使我有充足的准备，精心的安排，我依然不能违心的骗自己说我内心其实是平静的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　至于为什么要出去？原因有很多，但终究逃不出两个词：理想和金钱。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果单从字面上来理解的话，可能“理想”和“金钱”放在一起感觉特别别扭，一个是情感方面的，一个是物质方面的，就好像“情怀”和“商业”这两个东西，好像大多时候都是相反的背道而驰的，如果你是做公益的，你还要求资金回报似乎是一件不大说的过去的事情，但是老罗的出现，确实很好的诠释了“情怀”在某种刺激之下是可以很好的转化成“商业报酬”的，我这里不是重点要谈论理想和金钱配搭不配搭的事情，而是要谈谈我自己对于“为什么要离开西安去上海？”，做一个思想斗争之后的讨论和分享。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　想去外地的念头在我的脑海里面浮现已经是一年前的事情了，那时候没确定要去哪北上广深或许都是不错的选择，不是因为西安的雾霾排名第一，不是因为西安的天气干燥没有大海，只是觉得想去体验不同的生活场景，想去不同的地方看不同的风景，见不一样的人，听不一样的故事，这些看似鸡汤的陈词滥调，我想他是很多人梦寐以求的理想，只不过这些事情我们已经听得厌倦了，只是没有时间去做。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　有人说，人到了三十五岁就看是怠慢了，开始厌倦新事物，开始固守成规，这是人类基因传承中的一种自我保护意识，因为新的事物常常伴随着危险，而固有的经验虽然陈旧，但依然可以解决问题。坦然的说我很怕这种事情发生到我的身上，但我能意识到这些事情其实已经在发生了，比如我们听不懂00后喜欢的音乐，我们不能理解他们热捧的游戏或者是某款听了我们就不想打开的app，我想我们都会老去，而我想把这些时光推后一些，就像玩魂斗罗，我们总喜欢玩能无线续命的那版一样，我想尽可能让生活变得丰富多彩，而不是千篇一律，逃离舒适区是我不得不做的一个选择，因为我想去看看世界其他地方的精彩。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　我有一个理想，我的理想是，我可以有钱去遍我想去的国家和城市，我可以在任何我想居住的城市或者国家定居，而这种定居不可能是永久的，冬天冷了，去海南住几个月，想去滑雪了，就去长白山，我要的是生活体验和舒适度，而不是一辈子稳定的一成不变，这是我的理想。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　金钱就比较好理解了，他是所有人喜欢的物质，是所有人为之努力的动力，只要不是有悖于道德层面的努力，都能得到认可和肯定，上海的工资要比西安高一倍，租房几乎在一倍以内，吃饭多出0.5倍，这样稍微有点生活常识的人都会知道，那么最终的物质报酬的积累》=西安的1倍，在没有充分的资源和条件的情况下，请允许我对于金钱追求的格局，因为只要保证了我基础的物质生活之后，我才能有能力为这个社会做出自己的一点贡献。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　当然如果你和我一样接近或者超过而立之年，那一定要对自己的职业规划有清晰的认知和决定，你也应该明白选择一个好的行业，比暂时的薪资报酬要好的多，一个人能难改变一个行业的兴衰荣辱，改变自己远远比改变公司来的容易，尽自己的能力去创造和改变，选择时机坚持和抉择，没有人能替你做决定。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　还记得小时候学的那篇作文《小马过河》吗？没有人能替你做决定，也没有人的道路是完全适用于你的，选择好方向，坚定的执行，凡事都有取舍，胸怀天下，四海为家。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　最后用我非常喜欢的一句话结尾：纵身提刀上马，杀进满天黄沙！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Dec 2017 04:47:00 +0000</pubDate>
<dc:creator>王磊的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipstone/p/7921485.html</dc:identifier>
</item>
<item>
<title>[译]在Asp.Net Core 中使用外部登陆（google、微博...） - RocketRobin</title>
<link>http://www.cnblogs.com/rocketRobin/p/8046259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rocketRobin/p/8046259.html</guid>
<description>&lt;p&gt;原文出自&lt;a href=&quot;http://www.blinkingcaret.com/author/ruidfigueiredo/&quot;&gt;Rui Figueiredo&lt;/a&gt;的博文&lt;a href=&quot;http://www.blinkingcaret.com/2017/05/03/external-login-providers-in-asp-net-core/&quot;&gt;《External Login Providers in ASP.NET Core》&lt;/a&gt; (本文很长)&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;摘要：本文主要介绍了使用外部登陆提供程序登陆的流程，以及身份认证的流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了能够使用google、facebook、twitter、微博等外部登陆提供程序，从而避免创建本地账户以及电子邮件验证等繁琐步骤，我们一般会引用到外部登陆服务，将验证用户身份的任务委托给他们。外部验证最为流行的协议就是OAuth2和OpenId Connect。&lt;/p&gt;
&lt;p&gt;在Asp.Net中使用外部登陆提供商的文档非常少，更糟糕的是当地使用“File -&amp;gt; New Project”创建项目所生成的模板代码也很复杂，并不容易看得懂然后照着做。而且如果你不了解身份认证中间件在Asp.Net中是如何工作的，那么基本上是不可能弄懂那些模板代码的。&lt;/p&gt;
&lt;p&gt;为了真正了解如何在Asp.Net中使用外部登陆，那么必须先理解中间件管道以及特定的身份认证中间件是如何工作的，以及一点OAuth协议。&lt;/p&gt;
&lt;p&gt;本博客文章解释了所有这些部分是如何组合在一起的，并提供了有关如何利用身份验证中间件和外部登录提供程序本身和结合ASP.NET Core Identity的示例。&lt;/p&gt;

&lt;p&gt;当一个请求进入Asp.Net Core程序，请求会通过由中间件组成的&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware&quot;&gt;中间件管道&lt;/a&gt;。管道中的每个中间件都“有机会（译者注：如果一个中间件短路了那么后续的中间件就没机会了）”检查、处理请求，传递到下一个中间件，然后在后面的中间件都执行之后再做些额外的操作。&lt;/p&gt;
&lt;p&gt;管道在&lt;code&gt;Startup&lt;/code&gt;类中的&lt;code&gt;Config&lt;/code&gt;方法中定义，下面是一个添加到管道中的中间件的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    app.Use(async (HttpContext context, Func&amp;lt;Task&amp;gt; next) =&amp;gt;
    {
        // 在执行下一个中间件之前做些事
        await next.Invoke(); // 下一个中间件做的事
        // 在执行下一个中间件之后做些事    
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的一件重要的事情是所有的中间件都可以访问&lt;code&gt;HttpContext&lt;/code&gt;的实例。&lt;br/&gt;通过这个&lt;code&gt;httpContext&lt;/code&gt;实例，他们可以向其它的中间件“发送”信息。例如，如果管道末端的中间件通过执行类似&lt;code&gt;HttpContext.Items[“LoginProvider”] =“Google&lt;/code&gt;”的方式来更改&lt;code&gt;HttpContext&lt;/code&gt;，则所有位于其之前的中间件都将能够访问该值。&lt;/p&gt;
&lt;p&gt;另一个重要的事情是，任何中间件都可以停止管道（短路），即它可以选择不调用下一个中间件。这对外部登录提供程序（external login provider）尤其重要。&lt;/p&gt;
&lt;p&gt;例如，如果你用Google作为你的外部登录提供程序，则用户将在成功验证后重定向到&lt;code&gt;http://YourAppDomain.com/signin-google&lt;/code&gt;。如果你已经尝试了（使用默认的Visual Studio模板生成的代码）使用外部登录提供程序（本例子使用的是Google），那么你可能已经注意到没有&lt;code&gt;Controller&lt;/code&gt; 或者&lt;code&gt;Action&lt;/code&gt;，或者看起来没有其他任何响应上述URL的内容。&lt;/p&gt;
&lt;p&gt;发生了什么呢？其实 &lt;code&gt;GoogleAuthentication&lt;/code&gt; 中间件查找该URL，并且当它发现它时 &lt;code&gt;GoogleAuthentication&lt;/code&gt; 中间件将“接管”请求，然后也不会调用管道中的任何其他中间件，即MVC中间件。&lt;/p&gt;
&lt;p&gt;作为这种行为的结果，中间件运行的顺序非常重要。&lt;/p&gt;
&lt;p&gt;想象一下，你的程序支持多个外部登录提供程序（例如Facebook和Google）的情况。当他们运行时，需要有一个中间件，即 &lt;code&gt;CookieAuthentication&lt;/code&gt; 中间件，它能够将他们放入&lt;code&gt;HttpContext&lt;/code&gt;中的信息转换成代表登录用户的cookie（本文后面给出了示例）。&lt;/p&gt;

&lt;p&gt;使中间件成为认证中间件的原因是它继承了一个名为&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;的类，这个类只是创建一个&lt;code&gt;AuthenticationHandler&lt;/code&gt;。大部分身份认证功能都在&lt;code&gt;AuthenticationHandler&lt;/code&gt;里面。&lt;/p&gt;
&lt;p&gt;尽管我们不打算描述如何创建自己的身份验证中间件，我们将描述身份验证中间件如何进行交互，以及当你有多个认证中间件在管道中时，他们如何相互交互。&lt;/p&gt;
&lt;p&gt;在添加AuthenticationMiddleware时，你最少要指定三个值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;AuthenticationScheme&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutomaticAuthenticate&lt;/code&gt; 标志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutomaticChallenge&lt;/code&gt; 标志&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以将 &lt;code&gt;AuthenticationScheme&lt;/code&gt; 视为身份验证中间件的名称。 在以前的ASP.NET版本中，这被称为authentication type。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AutomaticAuthenticate&lt;/code&gt; 标志指定管道中的中间件应该在它拿到请求时就立即“认证”用户。例如，如果使用 &lt;code&gt;AutomaticAuthenticate = true&lt;/code&gt; 将cookie 中间件添加到管道，则会在请求中查找 authentication cookie，并使用它创建 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 并将其添加到 &lt;code&gt;HttpContext&lt;/code&gt; 。顺便说一句，这就是让用户“登录”的原因。&lt;/p&gt;
&lt;p&gt;如果你要使用 &lt;code&gt;AutomaticAuthenticate = false&lt;/code&gt; 设置 cookie 中间件，并且在该cookie中间件的请求中有一个 authentication cookie，则用户不会自动“登录”。&lt;/p&gt;
&lt;p&gt;在以前的ASP.NET版本中，具有 &lt;code&gt;AutomaticAuthenticate = true&lt;/code&gt; 的认证中间件被称为&lt;strong&gt;active&lt;/strong&gt;认证中间件，而 &lt;code&gt;AutomaticAuthenticate = false&lt;/code&gt; 被称为&lt;strong&gt;passive&lt;/strong&gt;认证中间件。&lt;/p&gt;

&lt;p&gt;你可以“Challenge”一个身份验证中间件。这是一个在ASP.NET Core之前不存在的新术语。我不知道把它称为Challenge的原因，所以我不会试图描述为什么这样叫。相反，我会给你一些中间件被“&lt;strong&gt;Challenged&lt;/strong&gt;”时会发生什么事情的例子。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译者注： challenge 有 挑战的意思，也有 质疑，质询，对...质询的意思，记住它的其他意思，会对你理解下文有帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如，Cookie中间件在“Challenged”时会将用户重定向到登录页面。Google身份验证中间件返回302响应，将用户重定向到Google的OAuth登录页面。通常challenge 认证中间件，你需要给它命名（通过它的&lt;code&gt;AuthenticationScheme&lt;/code&gt;属性）。例如，要challenge 一个带有 &lt;code&gt;AuthenticationScheme =“Google”&lt;/code&gt; 身份验证中间件，你可以在controller action 中执行此操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult DoAChallenge()
{
    return Challenge(&quot;Google&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，你可以发出一个“naked”的challenge（即不命名任何认证中间件，例如返回&lt;code&gt;Challenge&lt;/code&gt;），然后具有&lt;code&gt;AutomaticChallenge = true&lt;/code&gt;的认证中间件将是被选中的认证中间件。&lt;/p&gt;

&lt;p&gt;Challenge只是可以在认证中间件上“执行（performed）”的操作之一。The others are &lt;em&gt;Authenticate&lt;/em&gt;, &lt;em&gt;SignIn&lt;/em&gt; and &lt;em&gt;SignOut&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;例如，如果你向身份验证中间件“发起（issue）” &lt;em&gt;身份验证（Authenticate ）&lt;/em&gt;操作（假设此示例在controller action中）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var claimsPrincipal = await context.Authentication.AuthenticateAsync(&quot;ApplicationCookie&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6.6911764705882&quot;&gt;
&lt;p&gt;译者注：&lt;code&gt;context.Authentication.AuthenticateAsync&lt;/code&gt;在2.0中已经过时，只需将其修改为&lt;code&gt;context.AuthenticateAsync&lt;/code&gt;即可，不过返回值类型已经由 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 变为 &lt;code&gt;AuthenticateResult&lt;/code&gt; ，不过&lt;code&gt;AuthenticateResult&lt;/code&gt;中含有 &lt;code&gt;ClaimsPrincipal&lt;/code&gt;， &lt;a href=&quot;https://github.com/aspnet/Security/issues/1310&quot;&gt;参考信息&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这将导致中间件尝试认证并返回一个&lt;code&gt;ClaimsPrincipal&lt;/code&gt;。例如，cookie中间件会在请求中查找cookie，并使用cookie中包含的信息构建 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 和 &lt;code&gt;ClaimsIdentity&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;一般来讲，如果给认证中间件配置了&lt;code&gt;AutomaticAuthenticate = false&lt;/code&gt; ，那么你需要手动发起认证。&lt;/p&gt;
&lt;p&gt;也可以发起（issue）SignIn：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;await context.Authentication.SignInAsync(&quot;ApplicationCookie&quot;, claimsPrincipal);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者注：这个也过时了，参考上一个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果“ApplicationCookie”是一个cookie中间件，它将修改响应，以便在客户端创建一个cookie。该cookie将包含重新创建作为参数传递的 &lt;code&gt;ClaimsPrincipal&lt;/code&gt; 所需的所有信息。&lt;/p&gt;
&lt;p&gt;最后，SignOut，例如，cookie中间件将删除标识用户的cookie。下面这段代码展示了如何在名为“ApplicationCookie”的身份验证中间件上调用注销（sign out）的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;await context.Authentication.SignOutAsync(&quot;ApplicationCookie&quot;/*这里是中间件的AuthenticationScheme*/);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者注：这个也过时了，参考上一个&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果没有示例，那么很难想象这些东西是如何组合在一起的，接下来将展示一个使用cookie身份验证中间件的简单示例。&lt;/p&gt;
&lt;h2 id=&quot;使用-cookie-认证中间件登陆用户&quot;&gt;使用 cookie 认证中间件登陆用户&lt;/h2&gt;
&lt;p&gt;以下是Cookie身份验证和MVC中间件的设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{           
    app.UseCookieAuthentication(new CookieAuthenticationOptions{
        AuthenticationScheme = &quot;MyCookie&quot;,
        AutomaticAuthenticate = true,
        AutomaticChallenge = true,            
        LoginPath = new PathString(&quot;/account/login&quot;)                   
    });

    app.UseMvcWithDefaultRoute();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一个请求到达配置了这个管道的ASP.NET Core应用程序时，会发生什么情况呢？cookie身份验证中间件将检查请求并查找cookie。这是因为认证中间件配置了&lt;code&gt;AutomaticAuthenticate = true&lt;/code&gt;。如果cookie位于请求中，则将其解密并转换为&lt;code&gt;ClaimsPrincipal&lt;/code&gt;并在将其设置到&lt;code&gt;HttpContext.User&lt;/code&gt;上。之后，cookie中间件将调用管道中的下一个中间件，本例中是MVC。如果cookie不在请求中，cookie中间件将直接调用MVC中间件。&lt;/p&gt;
&lt;p&gt;如果用户执行了带有[Authorize]属性注释的controller action 请求，且用户未登录（即未设置HttpContext.User），例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Authorize]
public IActionResult ActionThatRequiresAnAuthenticatedUser()
{
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个 challenge 会被发起（issue），并且含有 &lt;code&gt;AutomaticChallenge = true&lt;/code&gt;的认证中间件会处理它。cookie中间件通过将用户重定向到LoginPath（将状态码设为302，和Location 头设为/account/login）来响应challenge。&lt;/p&gt;
&lt;p&gt;或者，如果你的身份验证中间件未设置为&lt;code&gt;AutomaticChallenge = true&lt;/code&gt;，并且你想“challenge”它，则可以指定&lt;code&gt;AuthenticationScheme&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Authorize(ActiveAuthenticationSchemes=&quot;MyCookie&quot;)]
public IActionResult ActionThatRequiresAnAuthenticatedUser()
{
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者注：&lt;code&gt;ActiveAuthenticationSchemes&lt;/code&gt;已经过时，使用&lt;code&gt;AuthenticationSchemes&lt;/code&gt;替换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了涵盖所有可能的方式来发出challenge，你也可以使用控制器中的&lt;code&gt;Challenge&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult TriggerChallenge()
{        
    return Challenge(&quot;MyCookie&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用这种方法手动发起challenge时需要注意一件重要事。如果你对身份验证中间件（例如“MyCookie”）发出了一个challenge，然后身份验证中间件“将用户登入”（在这种情况下，请求中有一个对应这个中间件的cookie），那么中间件会将challenge作为响应未经授权的访问，并将用户重定向到&lt;code&gt;/Account/ccessDenied&lt;/code&gt;。你可以通过在&lt;code&gt;CookieAuthenticationOptions&lt;/code&gt;中设置&lt;code&gt;AccessDeniedPath&lt;/code&gt;来更改该路径。&lt;/p&gt;
&lt;p&gt;这背后的原因是，如果用户已经登录，并且向签入该用户的中间件发出challenge，则这意味着用户没有足够的权限（例如，不具有所需的角色）。&lt;/p&gt;
&lt;p&gt;以前版本的ASP.NET中的行为是将用户重定向回登录页面。但是，如果使用外部登录提供程序，则会造成问题。&lt;/p&gt;
&lt;p&gt;外部登录提供程序会“记住”你已经登录。这就是为什么如果你已经登录到Facebook，并且你使用了一个允许你登录Facebook的网络应用，你将被重定向到Facebook，然后立即返回到网络应用（假设你已经授权在Facebook的网络应用程序）。如果你没有足够的权限，可能会导致&lt;a href=&quot;http://www.blinkingcaret.com/2016/01/20/authorization-redirect-loops-asp-net-mvc/&quot;&gt;重定向循环&lt;/a&gt;。因此，在这些情况下，为了避免导致重定向循环，ASP.NET Core中的身份验证中间件会将用户重定向到拒绝访问页面。&lt;/p&gt;

&lt;p&gt;依赖外部登录提供程序时，最简单的设置是配置一个cookie身份验证中间件，负责对用户进行登陆。然后再配置一个我们要使用的特定外部登录提供程序的中间件。&lt;/p&gt;
&lt;p&gt;如果我们想要使用Google登陆，我们可以像这样配置我们的管道：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseCookieAuthentication(new CookieAuthenticationOptions{
        AuthenticationScheme = &quot;MainCookie&quot;,
        AutomaticAuthenticate = true,
        AutomaticChallenge = false                
    });

    app.UseGoogleAuthentication(new GoogleOptions{
        AuthenticationScheme = &quot;Google&quot;,                        
        ClientId = &quot;YOUR_CLIENT_ID&quot;,
        ClientSecret = &quot;YOUR_CLIENT_SECRET&quot;,
        CallbackPath = new PathString(&quot;/signin-google&quot;),
        SignInScheme = &quot;MainCookie&quot;
    });

    app.UseMvcWithDefaultRoute();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;译者注：UseXyzAuthentication系列扩展方法已经过时，取而代之的是在ConfigService中的AddXyz()系列&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public void Configure(IApplicationBuilder app, ILoggerFactory loggerfactory) {
    app.UseIdentity();
    app.UseCookieAuthentication(new CookieAuthenticationOptions
       { LoginPath = new PathString(&quot;/login&quot;) });
    app.UseFacebookAuthentication(new FacebookOptions
       { AppId = Configuration[&quot;facebook:appid&quot;],  AppSecret = Configuration[&quot;facebook:appsecret&quot;] });
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services) {
    services.AddIdentity&amp;lt;ApplicationUser, IdentityRole&amp;gt;().AddEntityFrameworkStores();
    services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
                .AddCookie(o =&amp;gt; o.LoginPath = new PathString(&quot;/login&quot;))
                .AddFacebook(o =&amp;gt;
                {
                    o.AppId = Configuration[&quot;facebook:appid&quot;];
                    o.AppSecret = Configuration[&quot;facebook:appsecret&quot;];
                });
}
public void Configure(IApplicationBuilder app, ILoggerFactory loggerfactory) {
    app.UseAuthentication();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;每当有这个配置的请求进来，它将“通过”cookie中间件，cookie 中间件将检查它寻找一个属于他的cookie。cookie的名字决定了cookie是否属于特定的中间件。默认的是将&lt;code&gt;AuthenticationScheme&lt;/code&gt;加上.​​AspNetCore.。所以对于MainCookie 这个cookie的名字就是.AspNetCore.MainCookie。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i1.wp.com/www.blinkingcaret.com/wp-content/uploads/2017/04/MainCookieExample.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果请求中没有cookie，cookie身份验证中间件只是调用管道中的下一个中间件。在这个例子中是Google身份验证中间件。我们在这个例子中将Google身份验证中间件命名为“Google”。当我们使用外部登录提供者时，提供者必须知道我们的Web应用程序。总会有一个步骤，外部登陆提供者让你注册你的应用程序，你会得到一个ID和一个Secret （我们稍后将会详细说明为什么需要这些东西）。在示例是ClientId和ClientSecret属性。&lt;/p&gt;
&lt;p&gt;接下来我们定义了一个CallbackPath。当用户使用外部登录提供程序成功登录时，外部登录提供程序会发出重定向，以便将用户重定向回 发起登录进程的Web应用程序。CallbackPath 必须与外部登录提供程序将用户重定向到的位置 相匹配（稍后你会明白）。&lt;/p&gt;
&lt;p&gt;最后，SignInScheme指定在认证成功后，Google认证中间件将使用哪一个&lt;code&gt;AuthenticationScheme&lt;/code&gt;发起SignIn。&lt;/p&gt;
&lt;p&gt;外部登录提供商中间件将“干预”请求的唯一情况是中间件被“challenged”或请求与CallbackPath匹配。&lt;/p&gt;
&lt;p&gt;我们先来看看这个challenge。想象一下你有一个像这样的controller action：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult SignInWithGoogle()
{
    var authenticationProperties = new AuthenticationProperties{
        RedirectUri = Url.Action(&quot;Index&quot;, &quot;Home&quot;)
    };

    return Challenge(authenticationProperties, &quot;Google&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你发起challenge时，你可以指定&lt;code&gt;AuthenticationProperties&lt;/code&gt;的一个实例。&lt;code&gt;AuthenticationProperties&lt;/code&gt;类允许你指定用户在成功验证的情况下应该重定向到的其他选项。当发出这个challenge时，Google Authentication 中间件会将响应状态代码更改为302然后重定向到Google的OAuth2登录URL。它看起来像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://accounts.google.com/o/oauth2/auth?response_type=code&amp;amp;client_id=YOUR_CLIENT_ID&amp;amp;redirect_uri=http%3A%2F%www.yourdomain.com%2Fsignin-google&amp;amp;scope=openid%20profile%20email&amp;amp;state=....&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用户登录/授权Web应用程序，然后Google将其重定向回Web应用程序。例如，如果你在Google注册你的网络应用程序时将重定向URI定义为&lt;code&gt;http://www.yourdomain.com/signin-goole&lt;/code&gt;，那么在用户成功通过Google身份验证之后，他将被重定向到。&lt;code&gt;http://www.yourdomain.com/signin-goole&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当请求到来时，如果配置正确，它将匹配 CallbackPath（/signin-google），然后Google Authentication 中间件将接管该请求。&lt;/p&gt;
&lt;p&gt;这个请求看起来可能是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.yourdomain.com/signin-google?state=…&amp;amp;code=4/j5FtSwx5qyQwwl8XQgi4L6LPZcxxeqgMl0Lr7bG8SKA&amp;amp;authuser=0&amp;amp;session_state=…&amp;amp;prompt=none&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询字符串中的code值将用于向Google发出请求并获取有关用户的信息（这是OAuth2协议的一部分，将在下一部分中进行更详细的说明）。请注意，这是由Web应用程序向Google发送的请求。这对用户是透明的。通过对该请求（使用代码的那个）的响应，GoogleAuthentication中间件创建一个ClaimsPrincipal并调用配置中间件时提供的SignInScheme“登录”。最后，响应被更改为302重定向到challenge中的AuthenticationProperties中指定的重定向URL（在本例中是Home控制器中的Index aciton）。&lt;/p&gt;

&lt;p&gt;如果你曾尝试将默认Visual Studio模板与外部登录提供程序一起使用，那么你可能已经注意到，如果使用外部登录提供程序进行身份验证，则会将你带到要求你创建本地用户帐户的页面。&lt;br/&gt;用户在登录之前必须经过这个中间步骤。&lt;/p&gt;
&lt;p&gt;这是通过使用两个cookie身份验证中间件来实现的。&lt;/p&gt;
&lt;p&gt;一个主动查找请求中的cookie，并登录用户（AutomaticAuthenticate = true）。这个通常被称为ApplicationCookie，或者在我们的例子中叫做MainCookie。而另一个是被动的&lt;code&gt;（AutomaticAuthenticate = false&lt;/code&gt;，即它不会自动设置&lt;code&gt;HttpContext.User&lt;/code&gt;与各个Cookie中的&lt;code&gt;ClaimsIdentity&lt;/code&gt;用户）。这个通常被称为&lt;code&gt;ExternalCookie&lt;/code&gt;，因为它是外部登录提供者发起“登录”的地方。&lt;/p&gt;
&lt;p&gt;外部登录提供程序的SignInScheme设置为external cookie中间件（使用&lt;code&gt;AutomaticAuthenticate = false&lt;/code&gt;配置的中间件），并设置RedirectUri到指定的controller action，由这个action“手动”调用该SignInScheme中的“Authentication”来发起challenge。&lt;/p&gt;
&lt;p&gt;下面是示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseCookieAuthentication(new CookieAuthenticationOptions{
        AuthenticationScheme = &quot;MainCookie&quot;,
        AutomaticAuthenticate = true,
        AutomaticChallenge = false
    });

    app.UseCookieAuthentication(new CookieAuthenticationOptions{
        AuthenticationScheme = &quot;ExternalCookie&quot;,
        AutomaticAuthenticate = false,
        AutomaticChallenge = false                             
    });            

    app.UseGoogleAuthentication(new GoogleOptions{
        AuthenticationScheme = &quot;Google&quot;,
        SignInScheme = &quot;ExternalCookie&quot;,
        CallbackPath = new PathString(&quot;/signin-google&quot;),
        ClientId = &quot;YOUR_CLIENT_ID&quot;,
        ClientSecret = &quot;YOUR_CLIENT_SECRET&quot;
    });

    app.UseMvcWithDefaultRoute();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9.6455696202532&quot;&gt;
&lt;p&gt;译者注：上述方法已经过时，&lt;a href=&quot;https://github.com/aspnet/Security/issues/1310&quot;&gt;参考1&lt;/a&gt; &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/migration/1x-to-2x/identity-2x&quot;&gt;参考2&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;主要变化在于&lt;code&gt;AutomaticAuthenticate&lt;/code&gt;和&lt;code&gt;AutomaticChallenge&lt;/code&gt;被替代，因为这辆属性的意图其实只能用在一个中间件上，即只能让一个认证中间件，自动触发Authenticate 或者Challenge，所以他们移除了由 AddAuthentication(option) 指定，你可以先看这篇博客，因为不影响流程理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这和以前的情况唯一的区别是，现在有一个额外的身份验证中间件（ExternalCookie），外部登录提供程序中的SignInScheme也被设置到了这个中间件。&lt;/p&gt;
&lt;p&gt;当我们在这种情况下进行挑战时，我们必须将用户重定向到一个controller action，该action在ExternalCookie中“手动”触发Authenticate。代码看起来如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult Google()
{
    var authenticationProperties = new AuthenticationProperties
    {
        RedirectUri = Url.Action(&quot;HandleExternalLogin&quot;, &quot;Account&quot;)
    };

    return Challenge(authenticationProperties, &quot;Google&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Account controller中的 HandleExternalLogin 方法 :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public async Task&amp;lt;IActionResult&amp;gt; HandleExternalLogin()
{
    var claimsPrincipal = await HttpContext.Authentication.AuthenticateAsync(&quot;ExternalCookie&quot;);

    //do something the the claimsPrincipal, possibly create a new one with additional information
    //create a local user, etc

    await HttpContext.Authentication.SignInAsync(&quot;MainCookie&quot;, claimsPrincipal);
    await HttpContext.Authentication.SignOutAsync(&quot;ExternalCookie&quot;);
    return Redirect(&quot;~/&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者注：这里的代码到了2.0时略有变化，参见之前的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在这个控制器动作中所做的是在ExternalCookie中间件中“手动”触发一个Authenticate动作。这将返回从请求中的 cookie 重建的&lt;code&gt;ClaimsPrincipal&lt;/code&gt;。由于我们已经设置了&lt;code&gt;SignInScheme = ExternalCookie&lt;/code&gt;，所以在验证成功之后，该cookie由 Google Authentication 中间件设置。GoogleAuthentication中间件在内部将执行类似以下的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HttpContext.Authentication.SignInAsync(&quot;ExternalCookie&quot;, claimsPrincipalWithInformationFromGoogle);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是为什么ExternalCookie中间件创建cookie的原因。&lt;/p&gt;
&lt;p&gt;接下来我们可以使用ClaimsPrincipal中包含的信息做一些额外的操作，例如检查用户（通过ClaimsPrincipal.Claims中包含的电子邮件）是否已经有本地帐户，如果没有将用户重定向到提供创建本地帐户选项的页面（这是默认的Visual Studio模板所做的）。&lt;/p&gt;
&lt;p&gt;在这个例子中，我们简单地向MainCookie中间件发出SignIn操作，这将导致该Cookie中间件更改发送给用户的响应，以便创建encoded 的&lt;code&gt;ClaimsPrincipal&lt;/code&gt;的cookie（即，响应将具有编码&lt;code&gt;ClaimsPrincipal&lt;/code&gt;的名为.AspNetCore.MainCookie的cookie）。&lt;/p&gt;
&lt;p&gt;请记住，这个中间件是一个具有&lt;code&gt;AutomaticAuthenticate = true&lt;/code&gt;的中间件，这意味着在每个请求中它将检查它寻找一个cookie（名为.AspNetCore.MainCookie），如果它存在，它将被解码成&lt;code&gt;ClaimsPrincipal&lt;/code&gt;并设置在HttpContext.User上，然后使用户登录。最后，我们只需发起一个SignOut到ExternalCookie中间件。这会导致中间件删除相应的cookie。&lt;/p&gt;
&lt;p&gt;我们从用户的视角来回顾一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户请求了一个action ，这个action向Google认证中间件发起challenge，例如， /Account/SignInWithGoogle。challenge action定义了RedirectUrl，例如/Account/HandleExternalLogin&lt;/li&gt;
&lt;li&gt;响应将用户浏览器重定向到Google的OAuth登录页面&lt;/li&gt;
&lt;li&gt;成功验证和授权Web应用程序后，Google会将用户重定向回Web应用程序。例如/signin-google?code=…&lt;/li&gt;
&lt;li&gt;Google身份验证中间件将接管请求（CallBackPath匹配/signin-google），并将使用一次性使用的code来获取有关用户的信息。最后，它将发起SignIn到ExternalCookie，并发起重定向到第1步中定义的RedirectUrl。&lt;/li&gt;
&lt;li&gt;在RedirectUrl的controller action中，手动运行了ExternalCookie的Authenticaticate。这返回了一个包含谷歌的用户信息的ClaimsPrincipal，最后，向MainCookie发起一个SignIn并将&lt;code&gt;ClaimsPrincipal&lt;/code&gt;传递给它（如果需要的话，创建一个含有额外信息的新的&lt;code&gt;ClaimsPrincipal&lt;/code&gt;）。向​​ExternalCookie 发起SignOut，以便其Cookie被删除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上面的例子中，我们使用了一个client Id，一个client secret，一个 callback URL，我们简单地提到Google的回应包含了一个“code”，但是我们并没有用到所有这些信息。&lt;/p&gt;
&lt;p&gt;这些都是OAuth2协议的术语，具体来说就是“授权码工作流程”（你可以在&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&quot;&gt;这里&lt;/a&gt;找到更全面的OAuth2说明）。&lt;/p&gt;
&lt;p&gt;使用OAuth的第一步是注册客户端。在本文的例子中，客户端是你的Web应用程序，你必须注册，以便外部登录提供程序具有关于它的信息。这些信息是必需的，以便在向用户提交授权表单时，提供商以显示应用程序的名称，以及在用户接受或拒绝应用程序的“要求”后知道将用户重定向到哪里。&lt;/p&gt;
&lt;p&gt;在OAuth中，这些“requirements”被称为“scopes”。 Google的两个scopes“item”的示例是“profile”和“email”。&lt;br/&gt;当你的应用程序将用户重定向到Google并包含这些范围时，系统会询问用户是否可以访问profile和email信息。&lt;/p&gt;
&lt;p&gt;总之，当你向外部登录提供者注册你的应用程序时，你必须为你的应用程序提供（至少）一个名字，并且提供一个回调url(e.g. www.mydomain.com/signin-google)。&lt;/p&gt;
&lt;p&gt;然后你将得到一个客户端ID和一个客户端密钥。客户端ID和client密码是你的Web应用程序开始使用外部登录提供程序所需的全部东西。以下是用户浏览器，Web应用程序和外部登录提供程序之间的交互图。这里的术语我用的很随意，实际的术语应该是授权服务器，而实际上包含用户帐户的服务器就是资源服务器。他们可能是一样的。如果你需要对这些术语进行更加严格的描述，你应该阅读关于OAuth的 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2&quot;&gt;digitial ocean article about OAuth&lt;/a&gt;。&lt;br/&gt;图表：&lt;br/&gt;&lt;img src=&quot;https://i0.wp.com/www.blinkingcaret.com/wp-content/uploads/2017/04/Oauth.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是授权码授权。还有其他的工作流程，但是对于一个Web应用程序，这是你要使用的。这里需要注意的重要的事情是，code只能被使用一次，client secret永远不会发送到用户的浏览器。这样就很难让人冒充你的Web应用程序。如果有人想冒充你的应用程序，那么他们要拿到你的client secret ，为此，他们要能进入你的服务器才行。&lt;/p&gt;

&lt;p&gt;当你使用Visual Studio创建一个新项目并选择带有成员资格和授权的Web应用程序，并为外部登录提供程序添加一个身份验证中间件时，你将得到类似于以下的启动配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{

    //...

    app.UseIdentity();

    app.UseGoogleAuthentication(new GoogleOptions
    {
        ClientId = &quot;YOUR_CLIENT_ID&quot;,
        ClientSecret = &quot;CLIENT_SECRET&quot;
    });

    app.UseMvc(routes =&amp;gt;
    {
        routes.MapRoute(
            name: &quot;default&quot;,
            template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你看看UseIdentity扩展方法的源代码，你会发现类似这样的东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app.UseCookieAuthentication(identityOptions.Cookies.ExternalCookie);
app.UseCookieAuthentication(identityOptions.Cookies.TwoFactorRememberMeCookie);
app.UseCookieAuthentication(identityOptions.Cookies.TwoFactorUserIdCookie);
app.UseCookieAuthentication(identityOptions.Cookies.ApplicationCookie);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;译者注：在2.0中，由于Use系列方法被Add系列方法取代，所以这些代码会发生变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这与我们之前描述的很相似。不同的是，有两个新的外部认证中间件（TwoFactorRememberMeCookie和TwoFactorUserIdCookie 它们不在本文的讨论范围之内）以及“主要”认证中间件（具有AutomaticAuthenticate = true的中间件）和我们使用的存储外部登录提供程序认证结果（ExternalCookie）被交换（然而他们呢的执行顺序不会受到影响）。&lt;/p&gt;
&lt;p&gt;另外，GoogleAuthentication中间件配置了所有的默认选项。CallbackPath的默认值是 new PathString（“/ signin-google”）,还做了一些事情来指定你使用的特定的外部登陆提供器中间件。&lt;/p&gt;
&lt;p&gt;手动发起外部登陆提供器中间件的challenge被放在了 AccountController 的ExternalLogin 方法中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult ExternalLogin(string provider, string returnUrl = null)
{        
    var redirectUrl = Url.Action(nameof(ExternalLoginCallback), &quot;Account&quot;, new { ReturnUrl = returnUrl });
    var properties = _signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl);
    return Challenge(properties, provider);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你要查看SignInManager中ConfigureExternalAuthenticationProperties的源代码，你会发现它只是像我们前面的示例中那样创建一个AuthenticationProperties实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public virtual AuthenticationProperties ConfigureExternalAuthenticationProperties(string provider, string redirectUrl, string userId = null)
{
  AuthenticationProperties authenticationProperties = new AuthenticationProperties()
  {
    RedirectUri = redirectUrl
  };
  authenticationProperties.Items[&quot;LoginProvider&quot;] = provider;
  return authenticationProperties;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍后使用带有“LoginProvider”的“item”。我会在适当的时候突出显示它。&lt;/p&gt;
&lt;p&gt;从AccountController的ExternalLogin action中可以看出，RedirectUri在AccountController上也被设置为ExternalLoginCallback action。让我们看看这个action（我删除了不相关的部分）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public async Task&amp;lt;IActionResult&amp;gt; ExternalLoginCallback(string returnUrl = null, string remoteError = null)
{
    var info = await _signInManager.GetExternalLoginInfoAsync();

    var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);
    if (result.Succeeded)
    {
        return RedirectToLocal(returnUrl);
    }
    else
    {
        // If the user does not have an account, then ask the user to create an account.
        ViewData[&quot;ReturnUrl&quot;] = returnUrl;
        ViewData[&quot;LoginProvider&quot;] = info.LoginProvider;
        var email = info.Principal.FindFirstValue(ClaimTypes.Email);
        return View(&quot;ExternalLoginConfirmation&quot;, new ExternalLoginConfirmationViewModel { Email = email });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行，&lt;code&gt;var info = await _signInManager.GetExternalLoginInfoAsync();&lt;/code&gt;在external cookie中间件中触发一个Authentication 。但是返回的不是ClaimsPrincipal的实例，它将返回包含以下属性的ExternalLoginInfo类的实例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Principal (&lt;code&gt;ClaimsPrincipal&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;LoginProvider&lt;br/&gt;--- 这是从AuthenticationProperties的Items中读取的。在描述challenge的时候，我曾经提到带有“LoginProvider”键的item将会在以后被使用。这是使用它的地方。&lt;/li&gt;
&lt;li&gt;ProviderKey&lt;br/&gt;--- 这是ClaimsPrincipal中的声明&lt;code&gt;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier&lt;/code&gt;的值，你可以将其视为来自外部登录提供程序的UserId&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下一行&lt;code&gt;var result = await _signInManager.ExternalLoginSignInAsync(info.LoginProvider, info.ProviderKey, isPersistent: false);&lt;/code&gt;&lt;br/&gt;这将检查AspNetUserLogins表中是否有记录。此表将外部登录提供程序和“provider key”（这是外部登录提供程序的用户标识）链接到&lt;code&gt;AspNetUsers&lt;/code&gt;表中的用户（该表的主键是LoginProvider和ProviderKey的组合键） 。&lt;/p&gt;
&lt;p&gt;下面是该表中记录的示例：&lt;br/&gt;&lt;img src=&quot;https://i1.wp.com/www.blinkingcaret.com/wp-content/uploads/2017/04/AspNetUserLoginsExample.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，如果你使用Google登录，并且你的Google“用户ID”为123123123123123123，并且你之前已将你的本地用户（稍后会详细介绍）与此外部登录关联，则ExternalLoginSignInAsync将向 主 Cookie中间件发出signIn并向外部cookie中间件发出SignOut。&lt;/p&gt;
&lt;p&gt;当用户第一次访问时，AspNetUserLogins表中将不会有任何本地用户或记录，并且方法将简单地返回SignInResult.Failed。然后将用户重定向到ExternalLoginConfirmation页面：&lt;br/&gt;&lt;img src=&quot;https://i2.wp.com/www.blinkingcaret.com/wp-content/uploads/2017/04/ExternalLoginConfirmationExample.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个页面中，用户会被要求确认他想用来创建本地帐户的电子邮件（即AspNetUsers表中的记录）。&lt;/p&gt;
&lt;p&gt;当你单击注册按钮时，你将被带到AccountController中的ExternalLoginConfirmation action，这是它的简化版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public async Task&amp;lt;IActionResult&amp;gt; ExternalLoginConfirmation(ExternalLoginConfirmationViewModel model, string returnUrl = null)
{
    var info = await _signInManager.GetExternalLoginInfoAsync();

    var user = new ApplicationUser { UserName = model.Email, Email = model.Email };

    await _userManager.CreateAsync(user);

    await _userManager.AddLoginAsync(user, info);

    await _signInManager.SignInAsync(user, isPersistent: false);

    return RedirectToLocal(returnUrl);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行：&lt;code&gt;var info = await _signInManager.GetExternalLoginInfoAsync;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该行将获取存储在external Cookie中的信息并返回ExternalLoginInfo的实例。这与ExternalLoginCallback中完成的事完全相同。&lt;/p&gt;
&lt;p&gt;第二行：&lt;code&gt;var user = new ApplicationUser {UserName = model.Email，Email = model.Email};&lt;/code&gt;该行使用在用户单击Register的页面中输入的电子邮件创建ASP.NET Identity用户的新实例。&lt;/p&gt;
&lt;p&gt;第三行在AspNetUsers表中创建一个新用户： &lt;code&gt;await _userManager.CreateAsync（user）;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第四行： &lt;code&gt;await _userManager.AddLoginAsync（user，info）;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该行将新创建的用户与我们刚才使用的外部登录提供程序相关联。这意味着在AspNetUserLogins中创建一条新记录。&lt;/p&gt;
&lt;p&gt;此表中的记录有四列，LoginProvider（info.LoginProvider，例如“Google”），ProviderKey（info.ProviderKey，例如123123123123，你可以认为它是刚刚登录的用户的Google用户标识），ProviderDisplayName （至少在2017/04/29的ASP.NET Identity的这个版本中是这样的），最后是UserId，它是第三行中新创建的用户的用户标识。&lt;/p&gt;
&lt;p&gt;最后 &lt;code&gt;await _signInManager.SignInAsync(user, isPersistent: false);&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;14.851729818781&quot;&gt;
&lt;p&gt;译者注：最终的SignInAsync源码是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public virtual async Task SignInAsync(TUser user, AuthenticationProperties authenticationProperties, string authenticationMethod = null)
    {
        var userPrincipal = await CreateUserPrincipalAsync(user);
        // Review: should we guard against CreateUserPrincipal returning null?
        if (authenticationMethod != null)
        {
            userPrincipal.Identities.First().AddClaim(new Claim(ClaimTypes.AuthenticationMethod, authenticationMethod));
        }
        await Context.SignInAsync(IdentityConstants.ApplicationScheme,
            userPrincipal,
            authenticationProperties ?? new AuthenticationProperties());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aspnet/Identity/blob/dev/src/Microsoft.AspNetCore.Identity/SignInManager.cs&quot;&gt;参见&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为用户创建一个ClaimsPrincipal并向application Cookie发出一个SignIn。这个application Cookie是&lt;code&gt;AutomaticAuthenticate = true&lt;/code&gt;的cookie，这意味着在下一个请求中，该中间件将设置HttpContext.User与cookie中编码的用户，有使用户“登录”。请注意，外部cookie从未在此流程中被删除。这不是一个大问题，因为当用户最终退出时，SignInManager.SignOutAsync被调用，并且在内部向所有认证中间件发起SignOut。&lt;/p&gt;
&lt;p&gt;总结全文就是：如何在Asp.NetCore中使用外部登陆提供程序，包含只使用authentication中间件和与Identity共同使用。&lt;/p&gt;
&lt;p&gt;使用ASP.NET Core Identity和外部登录提供程序还有一些事情。你可以将其中多个外部登陆提供程序关联到本地用户帐户。而且你可以将他们全部移除，如果你确定不会“shoot yourself on the foot”，例如移除所有用户登录的方式，不过这可能成为另一篇博文的话题。&lt;/p&gt;
&lt;blockquote readability=&quot;3.865671641791&quot;&gt;
&lt;p&gt;译者注：全文完&lt;/p&gt;
&lt;p&gt;原文出自&lt;a href=&quot;http://www.blinkingcaret.com/author/ruidfigueiredo/&quot;&gt;Rui Figueiredo&lt;/a&gt;的博文&lt;a href=&quot;http://www.blinkingcaret.com/2017/05/03/external-login-providers-in-asp-net-core/&quot;&gt;《External Login Providers in ASP.NET Core》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处谢谢 :D&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 16 Dec 2017 04:18:00 +0000</pubDate>
<dc:creator>RocketRobin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rocketRobin/p/8046259.html</dc:identifier>
</item>
<item>
<title>Shell中处理方法返回值问题 - 小文字</title>
<link>http://www.cnblogs.com/avenwu/p/8046099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/avenwu/p/8046099.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://7u2jir.com1.z0.glb.clouddn.com/img/2017-12-15-01.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步发表：&lt;a href=&quot;http://blog.hacktons.cn/2017/12/13/shell-func-return/&quot; class=&quot;uri&quot;&gt;http://blog.hacktons.cn/2017/12/13/shell-func-return/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;通过shell编程，写一些工具批处理的时候，经常需要自定义函数。更复杂点的情况下，可能有需要返回一个值。&lt;br/&gt;由于在shell的世界中，并不像其他编程语言，它不支持我们所熟悉的方法返回。本文一起总结一下如何优雅的解决返回值问题？&lt;/p&gt;
&lt;h2 id=&quot;测试程序&quot;&gt;测试程序&lt;/h2&gt;
&lt;p&gt;我们一般通过&lt;code&gt;$?&lt;/code&gt;来获取上一个语句的输出。看一下下面得测试语句：&lt;/p&gt;
&lt;p&gt;新建&lt;code&gt;testReturn&lt;/code&gt;脚本&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;returnString(){
    return $1
}

returnString $1
result=$?
echo &quot;result=$result&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们有一个testReturn的脚本，里面有一个returnString的方法，我们希望它能够直接返回我们输入的参数。&lt;br/&gt;当我们分别以&lt;code&gt;hello&lt;/code&gt;,&lt;code&gt;500&lt;/code&gt;,&lt;code&gt;12&lt;/code&gt;作为输入参数时，他的执行和输出情况是一样的么？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./testReturn hello
./testReturn 500
./testReturn 12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在心中试着猜一下可能的情况，现在我们来揭晓答案：&lt;/p&gt;
&lt;h3 id=&quot;程序输出情况&quot;&gt;程序输出情况&lt;/h3&gt;
&lt;p&gt;在执行hello的时候，并没有输出hello，而是报了一个return只接受数字类型的错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aven-mac-pro-2:avenwu.github.io aven$ ./testReturn hello
./testReturn: line 23: return: hello: numeric argument required
result=255&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在执行500的时候，页没有输出500，而是输出了244&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 500
result=244&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行12的时候，终于正确了，返回12&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 12
result=12&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;异常分析&quot;&gt;异常分析&lt;/h2&gt;
&lt;p&gt;现在我们分析一下returnString这个方法，为什么会有这么多种输出情况呢？&lt;br/&gt;首先他的写法显然是不严谨的，但也不是完全错误，比如输入12他就正确返回了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt;本身是shell里面的buildin函数，笔者总结了下，他有以下几个特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;return可以返回数字状态，常常用于返回0，1,标识一个函数执行后是否成功&lt;/li&gt;
&lt;li&gt;注意return不可以返回非数字类型&lt;/li&gt;
&lt;li&gt;同时数字类型也有可能发生溢出现象&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;全局变量&quot;&gt;全局变量&lt;/h2&gt;
&lt;p&gt;如果我们就是要返回一个字符串，怎么办呢？可以通过定义全局变量来进行赋值，类似于静态变量/成员变量的写法，我们让他的作用域穿透整个上下文。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;result=&quot;&quot;
returnString(){
    result=$1
}

returnString $1
echo &quot;result=$result&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看一下输出，得到了我们需要的结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;aven-mac-pro-2:avenwu.github.io aven$ ./testReturn hello
result=hello
aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 500
result=500
aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 12
result=12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样写，会污染全局变量，并且result这个变量很容易在内部和外部都被修改，导致内部修改失效。&lt;/p&gt;
&lt;h2 id=&quot;eval&quot;&gt;eval&lt;/h2&gt;
&lt;p&gt;除了&lt;code&gt;return&lt;/code&gt;，还有其他一些buildin的关键字，比如&lt;code&gt;eval&lt;/code&gt;，&lt;code&gt;local&lt;/code&gt;。&lt;br/&gt;默认在当前脚本定义的变量都是全局变量，在方法中则可以通过local来定义局部变量，这样可以避免全局变量污染.&lt;br/&gt;同时结合eval赋值语句，来实现变量的修改&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;returnString(){
    local __result=$2
    eval $__result=$1
}

returnString $1 result
echo &quot;result=$result&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样我们也得到了希望的结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aven-mac-pro-2:avenwu.github.io aven$ ./testReturn hello
result=hello
aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 500
result=500
aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 12
result=12&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;echo&quot;&gt;echo&lt;/h2&gt;
&lt;p&gt;最后在介绍一种方法，通过&lt;code&gt;echo&lt;/code&gt;输出，结合&lt;code&gt;command substitution&lt;/code&gt;。&lt;br/&gt;这个&lt;code&gt;command substitution&lt;/code&gt;也没有找到比较合适的翻译，姑且按字面意思翻译&lt;code&gt;命令替换&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你的方法内部只有一处echo输出，那么也可以利用她来进行值得返回，不过这个就有点局限性，一定要确保方法内只有一次输出，否则就会出现赋值内容过多。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;returnString(){
    local __result=$1
    echo $__result
}
# 或者 result=`returnString $1`
result=$(returnString $1)
echo &quot;result=$result&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样可以得到预期结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aven-mac-pro-2:avenwu.github.io aven$ ./testReturn hello
result=hello
aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 500
result=500
aven-mac-pro-2:avenwu.github.io aven$ ./testReturn 12
result=12&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;越界问题&quot;&gt;越界问题&lt;/h2&gt;
&lt;p&gt;现在我们已经有几种办法可以返回字符串了，那么return返回数字有时候正确，有时候又不正确是为什么呢？&lt;/p&gt;
&lt;p&gt;我们知道return原本就是用于返回执行状态的，比如0，1.那么我们在返回500的时候，实际上是数据溢出了。&lt;/p&gt;
&lt;p&gt;根据测试，我们推断shell的内置return承接返回值用的是一个字节的大小，也就是8位，最多可以输出无符号0-255的整形，范围之外的数据全部溢出显示。因此在使用return的时候，务必留意数值大小。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;通过shell命令可以很方便的写出一些小脚本，但是如果遇到逻辑复杂，建议通过其他更合适的预览来实现，比如Python，Golang之类。&lt;/p&gt;
</description>
<pubDate>Sat, 16 Dec 2017 03:07:00 +0000</pubDate>
<dc:creator>小文字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/avenwu/p/8046099.html</dc:identifier>
</item>
</channel>
</rss>