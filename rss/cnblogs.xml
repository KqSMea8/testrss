<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mybatis全配置理解 - 疯狂阿贾克斯</title>
<link>http://www.cnblogs.com/caizhiqin/p/9883226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caizhiqin/p/9883226.html</guid>
<description>&lt;div class=&quot;ct-edit-catalog&quot; data-pm-slice=&quot;0 0 []&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;本文只论mybatis本身，不涉及与spring整合，文中探讨了mybatis最新版本提供的全部配置项的作用。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;首先要了解都有哪些配置项，mybatis的SqlSession来自SqlSessionFactory，SqlSessionFactory来自SqlSessionFactoryBuilder，从SqlSessionFactoryBuilder切入分析&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;Java&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
...
public SqlSessionFactory build(Reader reader, String environment, Properties properties) {
    try {
      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);
      return build(parser.parse());
    } catch (Exception e) {
      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);
    } finally {
      ErrorContext.instance().reset();
      try {
        reader.close();
      } catch (IOException e) {
        // Intentionally ignore. Prefer previous error.
      }
    }
}
...　
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;构造SqlSessionFactoryBuilder用到了XMLConfigBuilder，然后看XMLConfigBuilder&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;Java&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;19.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public Configuration parse() {
    if (parsed) {
      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);
    }
    parsed = true;
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
}

private void parseConfiguration(XNode root) {
    try {
      //issue #117 read properties first
      propertiesElement(root.evalNode(&quot;properties&quot;));
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      environmentsElement(root.evalNode(&quot;environments&quot;));
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}

private void settingsElement(Properties props) throws Exception {
    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(&quot;autoMappingBehavior&quot;, &quot;PARTIAL&quot;)));
    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(&quot;autoMappingUnknownColumnBehavior&quot;, &quot;NONE&quot;)));
    configuration.setCacheEnabled(booleanValueOf(props.getProperty(&quot;cacheEnabled&quot;), true));
    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(&quot;proxyFactory&quot;)));
    configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(&quot;lazyLoadingEnabled&quot;), false));
    configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(&quot;aggressiveLazyLoading&quot;), false));
    configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(&quot;multipleResultSetsEnabled&quot;), true));
    configuration.setUseColumnLabel(booleanValueOf(props.getProperty(&quot;useColumnLabel&quot;), true));
    configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(&quot;useGeneratedKeys&quot;), false));
    configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(&quot;defaultExecutorType&quot;, &quot;SIMPLE&quot;)));
    configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(&quot;defaultStatementTimeout&quot;), null));
    configuration.setDefaultFetchSize(integerValueOf(props.getProperty(&quot;defaultFetchSize&quot;), null));
    configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(&quot;mapUnderscoreToCamelCase&quot;), false));
    configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(&quot;safeRowBoundsEnabled&quot;), false));
    configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(&quot;localCacheScope&quot;, &quot;SESSION&quot;)));
    configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(&quot;jdbcTypeForNull&quot;, &quot;OTHER&quot;)));
    configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(&quot;lazyLoadTriggerMethods&quot;), &quot;equals,clone,hashCode,toString&quot;));
    configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(&quot;safeResultHandlerEnabled&quot;), true));
    configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(&quot;defaultScriptingLanguage&quot;)));
    @SuppressWarnings(&quot;unchecked&quot;)
    Class&amp;lt;? extends TypeHandler&amp;gt; typeHandler = (Class&amp;lt;? extends TypeHandler&amp;gt;)resolveClass(props.getProperty(&quot;defaultEnumTypeHandler&quot;));
    configuration.setDefaultEnumTypeHandler(typeHandler);
    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(&quot;callSettersOnNulls&quot;), false));
    configuration.setUseActualParamName(booleanValueOf(props.getProperty(&quot;useActualParamName&quot;), true));
    configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(&quot;returnInstanceForEmptyRow&quot;), false));
    configuration.setLogPrefix(props.getProperty(&quot;logPrefix&quot;));
    @SuppressWarnings(&quot;unchecked&quot;)
    Class&amp;lt;? extends Log&amp;gt; logImpl = (Class&amp;lt;? extends Log&amp;gt;)resolveClass(props.getProperty(&quot;logImpl&quot;));
    configuration.setLogImpl(logImpl);
    configuration.setConfigurationFactory(resolveClass(props.getProperty(&quot;configurationFactory&quot;)));
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;configuration节点为根节点。&lt;/p&gt;
&lt;p&gt;可以配置10个子节点：properties、settings、typeAliases、plugins、objectFactory、objectWrapperFactory、environments、databaseIdProvider、typeHandlers、mappers。&lt;/p&gt;

&lt;p&gt;这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;properties resource=&quot;jdbc.properties&quot;&amp;gt;&amp;lt;/properties&amp;gt; 
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;properties&amp;gt;
        &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/a&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
&amp;lt;/properties&amp;gt;settings 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;settings&amp;gt;
  &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&amp;gt;
  &amp;lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&amp;gt;
  &amp;lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&amp;gt;
  &amp;lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&amp;gt;
  &amp;lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&amp;gt;
  &amp;lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&amp;gt;
  &amp;lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&amp;gt;
  &amp;lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;懒加载&lt;/h2&gt;
&lt;p&gt;熟悉配置前需要知道什么是懒加载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Order {
        public Long id;
        public Long addressId;
        public Address address;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Address {
        public Long id;
        public String name;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- addressMapper.xml --&amp;gt;
&amp;lt;mapper namespace=&quot;addressMapperSpace&quot;&amp;gt;
        &amp;lt;select id=&quot;getAddressById&quot; parameterType=&quot;Long&quot; resultType=&quot;Address&quot;&amp;gt;
                select id,name from t_address 
                where id = #{id}
        &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- orderMapper.xml --&amp;gt;
&amp;lt;mapper namespace=&quot;...&quot;&amp;gt;
        &amp;lt;resultMap id=&quot;orderMap&quot; type=&quot;Order&quot;&amp;gt;
                &amp;lt;id property=&quot;id&quot; column=&quot;id&quot; /&amp;gt;
                &amp;lt;association property=&quot;address&quot; column=&quot;address_id&quot;
                        select=&quot;addressMapperSpace.getAddressById&quot; /&amp;gt;
        &amp;lt;/resultMap&amp;gt;
        &amp;lt;select id=&quot;getOrderById&quot; resultMap=&quot;orderMap&quot; parameterType=&quot;Long&quot;&amp;gt;
                select id,address_id from t_order
                where id = #{id}
        &amp;lt;select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是懒加载，那么访问order的address属性时才会去查询address。&lt;/p&gt;
&lt;h2&gt;参数介绍&lt;/h2&gt;
&lt;table data-pm-slice=&quot;0 0 []&quot;&gt;&lt;tbody readability=&quot;102.5&quot;&gt;&lt;tr&gt;&lt;th width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;/th&gt;
&lt;th width=&quot;168&quot; data-colwidth=&quot;168&quot;&gt;
&lt;p&gt;官方中文描述&lt;/p&gt;
&lt;/th&gt;
&lt;th width=&quot;319&quot; data-colwidth=&quot;319&quot;&gt;
&lt;p&gt;理解&lt;/p&gt;
&lt;/th&gt;
&lt;th width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;可选值&lt;/p&gt;
&lt;/th&gt;
&lt;th width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;默认值&lt;/p&gt;
&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;&lt;strong&gt;cacheEnabled&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;mybatis缓存，不支持集群环境，&lt;strong&gt;必须设置成false。&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;lazyLoadingEnabled&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot;&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;aggressiveLazyLoading&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考lazyLoadTriggerMethods).&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;当设置为true时，懒加载的对象可能被任何懒属性全部加载；否则，每个属性按需加载。一般不用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false (true in ≤3.4.1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;19&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;lazyLoadTriggerMethods&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定对象的哪个方法触发一次延迟加载。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;在lazyLoadingEnabled=true时有效，调用本方法会使得所有延迟加载属性被加载，如果有多个懒加载属性，可以使用这个方法把所有懒加载属性一起加载了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;用逗号分隔的方法列表。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;equals,clone,hashCode,toString&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;proxyFactory&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;mybatis延迟加载用的工具，旧版本使用的是CGLIB动态代理技术，新版本支持使用JAVASSIST（Javassist是一个运行时编译库，他能动态的生成或修改类的字节码）来完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;CGLIB | JAVASSIST&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;JAVASSIST (MyBatis 3.3 or above)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;multipleResultSetsEnabled&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;是否允许单一语句返回多结果集（需要兼容驱动）。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;sql与ResultSet一对多的用法， 没找到用法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;useColumnLabel&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;在Select字段的时候使用AS，用得上，由于默认true。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;&lt;strong&gt;useGeneratedKeys&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;strong&gt;我们使用mysql数据库自增主键，在xml的insert块中如果使用useGeneratedKeys来获得生成的主键，那这个属性必须设置成true。如果使用以下方法，那也可以不设置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Long&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;　SELECT LAST_INSERT_ID() &amp;lt;/selectKey&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;autoMappingBehavior&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;如果修改成FULL，会由于没及时更新model导致映射失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;NONE, PARTIAL, FULL&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;PARTIAL&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;autoMappingUnknownColumnBehavior&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定发现自动映射目标未知列（或者未知属性类型）的行为。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;NONE: 不做任何反应&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;WARNING: 输出提醒日志 ('org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'的日志等级必须设置为 WARN)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;FAILING: 映射失败 (抛出 SqlSessionException)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot;&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;NONE, WARNING, FAILING&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;NONE&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;19&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;defaultExecutorType&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;1.设为&quot;SIMPLE&quot;, 在执行dao.save()时，就相当于JDBC的stmt.execute(sql)；&lt;/p&gt;
&lt;p&gt;2.设为&quot;REUSE&quot;, 在执行dao.save()时，相当于JDBC重用一条sql，再通过stmt传入多项参数值，然后执行stmt.executeUpdate()或stmt.executeBatch()；重用sql的场景不太常见，因此用SIMPLE就可以了。&lt;/p&gt;
&lt;p&gt;3.设为&quot;BATCH&quot;, 在执行dao.save()时，相当于JDBC语句的 stmt.addBatch(sql)，即仅仅是将执行SQL加入到批量计划。 所以此时不会抛出主键冲突等运行时异常，而只有临近commit前执行stmt.execteBatch()后才会抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;SIMPLE REUSE BATCH&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;SIMPLE&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;&lt;strong&gt;defaultStatementTimeout&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;设置超时时间，它决定驱动等待数据库响应的秒数。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;这是以秒为单位的全局sql超时时间设置,当超出了设置的超时时间时,会抛出SQLTimeoutException。&lt;strong&gt;建议设置一个合理值。&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;任意正整数&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;Not Set (null)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;defaultFetchSize&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;mysql不支持fetchSize。&lt;/p&gt;
&lt;p&gt;一般使用分页插件即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;任意正整数&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;Not Set (null)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;safeRowBoundsEnabled&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;使用场景：&lt;em&gt;session.select(&quot;...&quot;, null, new RowBounds(1, 2),resultHandler);&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一般使用分页插件即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;safeResultHandlerEnabled&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;使用场景：&lt;em&gt;session.select(&quot;...&quot;, null, new RowBounds(1, 2),resultHandler);&lt;/em&gt;&lt;br/&gt;一般使用分页插件即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;&lt;strong&gt;mapUnderscoreToCamelCase&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;驼峰命名映射，手写mapper不去写resultMap时推荐开启。使用mybatis-generator时，不开启也ok。&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;localCacheScope&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;mybatis缓存，不支持集群环境，这个就不用管了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;SESSION | STATEMENT&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;SESSION&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;jdbcTypeForNull&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;正常情况下我们都配了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;JdbcType 常量. 大多都为: NULL, VARCHAR and OTHER&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;OTHER (java.lang.Object)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;defaultScriptingLanguage&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定动态 SQL 生成的默认语言。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;虽然官方名称叫做LanguageDriver，其实叫做解析器可能更加合理。MyBatis 从 3.2 开始支持可插拔的脚本语言，因此你可以在插入一种语言的驱动（language driver）之后来写基于这种语言的动态 SQL 查询比如mybatis除了XML格式外，还提供了mybatis-velocity，允许使用velocity表达式编写SQL语句。可以通过实现LanguageDriver接口的方式来插入一种语言。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;一个类型别名或完全限定类名。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;org.apache.ibatis.scripting.xmltags.XMLLanguageDriver&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;defaultEnumTypeHandler&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定 Enum 使用的默认 TypeHandler 。 (从3.4.5开始)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;默认的EnumTypeHandler存入数据库的是枚举的name，&lt;/p&gt;
&lt;p&gt;mybatis还提供了EnumOrdinalTypeHandler存入数据库的是枚举的位置。&lt;/p&gt;
&lt;p&gt;这俩都不太好用，如果想要把数据库查询结果与枚举自动转换，可以自定义typeHandler来实现。在查询或操作数据时以枚举传输优势并不大，只提供对应的枚举也可满足需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;一个类型别名或完全限定类名。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;org.apache.ibatis.type.EnumTypeHandler&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;19.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;callSettersOnNulls&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;假设将数据从DB中查询出来如果将字段映射为Map,而不想封装成Bean。默认情况下,Mybatis对Map的解析生成, 如果值(value)为null的话,那么key也不会被加入到map中.&lt;br/&gt;于是对Map遍历时，key就遍历不到。部分情况会有需要key存在，value=null的情况，依据多数实际场景来看，使用默认值false没问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;returnInstanceForEmptyRow&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;查询结果没有的时候，返回null是合理的，返回一个空对象容易硬气误会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;logPrefix&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定 MyBatis 增加到日志名称的前缀。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;日志前缀，要不要看个人喜好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;任何字符串&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;Not set&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;logImpl&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定 MyBatis 所用日志的具体实现，未指定时将自动查找。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot;&gt;
&lt;p&gt;&lt;strong&gt;不要设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;Not set&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;vfsImpl&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot;&gt;
&lt;p&gt;指定VFS的实现&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;VFS主要用来加载容器内的各种资源，比如jar或者class文件。mybatis提供了2个实现 JBoss6VFS 和 DefaultVFS，并提供了用户扩展点，用于自定义VFS实现，加载顺序是自定义VFS实现 &amp;gt; 默认VFS实现 取第一个加载成功的，默认情况下会先加载JBoss6VFS，如果classpath下找不到jboss的vfs实现才会加载默认VFS实现。&lt;br/&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;自定义VFS的实现的类全限定名，以逗号分隔。&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;Not set&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;useActualParamName&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的工程必须采用Java 8编译，并且加上-parameters选项。（从3.4.1开始）&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;22&quot;&gt;
&lt;p&gt;mybatis的全局配置useActualParamName决定了mapper中参数的写法，默认为true。此时无需再使用@Param。&lt;/p&gt;
&lt;p&gt;Order getOrderByCondition (Long id,Long addressId)&lt;/p&gt;
&lt;p&gt;&amp;lt;select id=&quot;getOrderByCondition&quot; resultType=&quot;Order&quot; &amp;gt; select * from t_order where id = #{id} and addressId = #{addressId} &amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;如果是false那么可写成&lt;/p&gt;
&lt;p&gt;&amp;lt;select id=&quot;getOrderByCondition&quot; resultType=&quot;Order&quot; &amp;gt; select * from t_order where id = #{0} and addressId = #{1} &amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;使用这个特性必须在jdk1.8场景。这是因为：在Java 8之前的版本，代码编译为class文件后，方法参数的类型是固定的，但参数名称却丢失了，这和动态语言严重依赖参数名称形成了鲜明对比。现在，Java 8开始在class文件中保留参数名，给反射带来了极大的便利。jdk8增加了类Parameter。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot;&gt;
&lt;p&gt;true | false&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td width=&quot;157&quot; data-colwidth=&quot;157&quot;&gt;
&lt;p&gt;configurationFactory&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;168&quot; data-colwidth=&quot;168&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;指定一个提供Configuration实例的类。 这个被返回的Configuration实例用来加载被反序列化对象的懒加载属性值。 这个类必须包含一个签名方法static Configuration getConfiguration(). (从 3.2.3 版本开始)&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;319&quot; data-colwidth=&quot;319&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;此时mybatis全局的Configuration将被开发者手动指定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建议不设置&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;124&quot; data-colwidth=&quot;124&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;类型别名或者全类名.&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84&quot; data-colwidth=&quot;84&quot;&gt;
&lt;p&gt;Not set&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，原理是用hashMap关联，存在的意义仅在于用来减少类完全限定名的冗余。例如:&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&quot;OrderMain&quot; type=&quot;order.center.domain.OrderMain&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;typeAliases&amp;gt;
  &amp;lt;package name=&quot;order.center.domain&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。&lt;/p&gt;
&lt;p&gt;可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个 JDBC 类型。&lt;/p&gt;
&lt;p&gt;下面是一个处理javaType=com.alibaba.fastjson.JSON时的例子&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;Java&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ExampleTypeHandler extends BaseTypeHandler&amp;lt;JSON&amp;gt; {
  @Override
  public void setNonNullParameter(PreparedStatement ps, int i, JSON parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i,parameter.toJSONString());
  }

  @Override
  public JSON getNullableResult(ResultSet rs, String columnName) throws SQLException {
    return JSON.parseObject(rs.getString(columnName));
  }

  @Override
  public JSON getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    return JSON.parseObject(rs.getString(columnIndex));
  }

  @Override
  public JSON getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    return JSON.parseObject(cs.getString(columnIndex));
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;typeHandlers&amp;gt;
  &amp;lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&amp;gt;
&amp;lt;/typeHandlers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- Ordermapper.xml中使用 --&amp;gt;
&amp;lt;result column=&quot;order_json&quot; typeHandler=&quot;org.mybatis.example.ExampleTypeHandle&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;orderJson&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。比如：&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;Java&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// ExampleObjectFactory.java
public class ExampleObjectFactory extends DefaultObjectFactory {
  public Object create(Class type) {
    return super.create(type);
  }
  public Object create(Class type, List&amp;lt;Class&amp;gt; constructorArgTypes, List&amp;lt;Object&amp;gt; constructorArgs) {
    return super.create(type, constructorArgTypes, constructorArgs);
  }
  public void setProperties(Properties properties) {
    super.setProperties(properties);
  }
  public &amp;lt;T&amp;gt; boolean isCollection(Class&amp;lt;T&amp;gt; type) {
    return Collection.class.isAssignableFrom(type);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&amp;gt;
  &amp;lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&amp;gt;
&amp;lt;/objectFactory&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般情况很少会使用到自定义ObjectFactory，如果需要使用的话，建议是在对象创建时需要做一些操作，或前或后，用于改变或者丰富被创建对象。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;最新的官方文档中已经找不到这个配置项。原用来提供自定义的ObjectWrapper&lt;/p&gt;

&lt;p&gt;MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ParameterHandler (getParameterObject, setParameters)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ResultSetHandler (handleResultSets, handleOutputParameters)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;StatementHandler (prepare, parameterize, batch, update, query)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏 MyBatis 的核心模块。 这些都是更低层的类和方法，所以使用插件的时候要特别当心。&lt;/p&gt;
&lt;p&gt;通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。&lt;/p&gt;
&lt;p&gt;例如配置pageHelper：&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;plugins&amp;gt;
    &amp;lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&amp;gt;
        &amp;lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&amp;gt;
        &amp;lt;property name=&quot;offsetAsPageNum&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&amp;gt;
        &amp;lt;property name=&quot;reasonable&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;property name=&quot;supportMethodsArguments&quot; value=&quot;false&quot;/&amp;gt;
        &amp;lt;property name=&quot;returnPageInfo&quot; value=&quot;none&quot;/&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者共享相同 Schema 的多个生产数据库， 想使用相同的 SQL 映射。许多类似的用例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不过要记住：尽管可以配置多个环境，每个 SqlSessionFactory 实例只能选择其一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：&lt;/p&gt;
&lt;p&gt;为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：&lt;/p&gt;
&lt;p&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, environment, properties);&lt;/p&gt;
&lt;p&gt;如果忽略了环境参数，那么默认环境将会被加载，如下所示：&lt;/p&gt;
&lt;p&gt;SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, properties);&lt;/p&gt;
&lt;p&gt;环境元素定义了如何配置环境。&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;environments default=&quot;development&quot;&amp;gt;
  &amp;lt;environment id=&quot;development&quot;&amp;gt;
    &amp;lt;!--Mybatis管理事务是分为两种方式:
   (1)使用JDBC的事务管理机制,就是利用java.sql.Connection对象完成对事务的提交
   (2)使用MANAGED的事务管理机制，这种机制mybatis自身不会去实现事务管理，而是让程序的容器（JBOSS,WebLogic）来实现对事务的管理
   --&amp;gt;
    &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
    &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
      &amp;lt;!-- 可以直接用properties也可以在这配 --&amp;gt;
      &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt;
      &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt;
      &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
      &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
    &amp;lt;/dataSource&amp;gt;
  &amp;lt;/environment&amp;gt;
  &amp;lt;environment id=&quot;test&quot;&amp;gt;
    &amp;lt;!-- mybatis提供的区分不同环境的数据库连接配置 --&amp;gt;
  &amp;lt;/environment&amp;gt;
&amp;lt;/environments&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可：&lt;/p&gt;
&lt;p&gt;我们实际使用中，不同数据库大概率是不同数据源，很低概率出现同一个mapper两种数据库使用，因此这个配置项几乎不可能用上。&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml --&amp;gt;
&amp;lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&amp;gt;
  &amp;lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&amp;gt;
  &amp;lt;property name=&quot;DB2&quot; value=&quot;db2&quot;/&amp;gt;        
  &amp;lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&amp;gt;
  &amp;lt;property name=&quot;Mysql&quot; value=&quot;mysql&quot; /&amp;gt;
&amp;lt;/databaseIdProvider&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mapper.xml --&amp;gt;
&amp;lt;insert id=&quot;insertTest&quot; ...&amp;gt;
    INSERT INTO users(name, age) VALUES('zhangsan', 1), ('wangwu', 2), ('zhaoliu', 3); 
&amp;lt;/insert&amp;gt;
&amp;lt;insert id=&quot;insertTest&quot; ... databaseId=&quot;oracle&quot;&amp;gt;
  INSERT ALL INTO users VALUES('zhangsan', 1)
        INTO users  VALUES ('wangwu', 2)
        INTO users  VALUES ('zhaoliu', 3);
&amp;lt;/insert&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义 SQL 映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。 Java 在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉 MyBatis 到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如：&lt;/p&gt;
&lt;div class=&quot;ct-code&quot; data-language=&quot;XML&quot; data-theme=&quot;xq-light&quot; data-title=&quot;代码块&quot; data-expand=&quot;true&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml 使用spring后可以在sqlSessionFactory里配置*.xml--&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/BlogMapper.xml&quot;/&amp;gt;
  &amp;lt;mapper resource=&quot;org/mybatis/builder/PostMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml 此方法mapper接口和xml必须同名放在一起--&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;package name=&quot;org.mybatis.builder&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!-- mybatis-config.xml 绝对路径，不可用--&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/AuthorMapper.xml&quot;/&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/BlogMapper.xml&quot;/&amp;gt;
  &amp;lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 31 Oct 2018 07:06:00 +0000</pubDate>
<dc:creator>疯狂阿贾克斯</dc:creator>
<og:description>本文只论mybatis本身，不涉及与spring整合，文中探讨了mybatis最新版本提供的全部配置项的作用。 本文只论mybatis本身，不涉及与spring整合，文中探讨了mybatis最新版本提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caizhiqin/p/9883226.html</dc:identifier>
</item>
<item>
<title>消息队列总结 - 朝向远方</title>
<link>http://www.cnblogs.com/LipeiNet/p/9877189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LipeiNet/p/9877189.html</guid>
<description>&lt;p&gt;     &lt;span&gt;前言：关于消息队列应该大家都不陌生,在实际的项目中消息队列也无处不在,今天我和大家分享一下关于消息队列的问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;消息队列大家又经常称为MQ(message queue),从字面的含义来看就是一个存放消息的容器。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2.1、异步处理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030175004936-264955811.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2、系统解耦&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030175153442-1984394895.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3、流量削峰&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030175246896-94933750.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  提到mq那么我们必然会讨论mq顺序性问题,比如生产者发送消息1,2,3...对于消费者必须按照1,2,3...这样的顺序来消费,那么消息队列应该怎么样去考虑这样事情呢,有人说了消息队列是先进先出不就保证了顺序性,其实并非如此,而且想通过队列来保证顺序性是非常困难的,那么我们来看看为什么说非常困难的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于生产者而言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;比如生产者连续发送1、2、3但是不久2和3返回结果成功,唯独1返回结果是失败,这个时候如果我们重发1那么顺序肯定就会乱了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对于存储端而言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 消息队列不可能分区进行存储,也就是一个topic的消息只能采用一个队列存储,如果一个topic采用多个队列就不可能保证顺序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于消费者而言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于消费端来说还不可以并行消费,也就是不可以开启多线程或者多个客户端来进行消费&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.1、消息队列顺序性分析1：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030193048319-349243589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们现在想要保证s1和s2两条消息顺序被消费可能想设计如上图所示,假定生产者先发送s1然后在发送s2,如果想保证s1先被消费,那么需要s1到达消费端后在通知mq2,然后mq2在发送消息。但是其实这是理想的模型,可能会出现如下2个问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、s1不一定要比s2先到mq集群(比如网络延迟)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、s2到达mq集群并且已经消费完毕,s1还没到达mq集群,这就会出现乱序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有我们想要s1比s2先消费最简单粗暴的方式就是s1和s2发送同一台server上,这样根据队列先进先出原则,肯定s1要比s2先消费&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.2、消息队列顺序性分析2：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030201228130-202026448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是这种模型仅仅是理论上的可行,因为可能出现网络延迟,比如s2比是s1先到达消费端,我们同样无法保证消息的顺序,这样一来我们可能发送s1等消费者响应后然后在发s2。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.3、消息队列顺序性分析3：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030202003105-190176266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是我们知道消费者可能出现2种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、消费者没有响应(可能消费成功没有响应,也可能消费失败没有响应)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、消费者响应成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于没有响应的mq集群可以进行重发消息,如果消费成功重发就会导致消息重新处理,这样一来就会带来新的问题,重复问题下面说&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上我们可以得出想保证消息顺序性最简单可行方式就是生产者-&amp;gt;mq-&amp;gt;消费者这样一一对应关系,但是同样会带来如下2个问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、吞吐量不足&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、可用性低&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.4、消息队列顺序性分析4：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;任何设计都离不开业务的本身,我们可以从业务来考虑顺序消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、不关注乱序的应用实际大量存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、队列无序不表示消息无序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030210147186-1407626886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注释：对于同一种消息放入同一个队列中,同一种消息可以通过topic主题来进行标记。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上我们可以可以总结出来为了保证消息的顺序性要从生产者、存储端、消费者三个角度来考虑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、生产端必须保证消息成功发送以后才能继续发送第二条&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、存储端必须要求同一种消息必须存放在同一个队列中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、消费端不可以采用并发消费&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030210948279-670101623.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;消息重复由业务端来保证如上图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;生产者：&lt;/span&gt;&lt;span&gt;ack确认机制&lt;/span&gt;&lt;span&gt;消息重发&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消费者：手动ack确认,消息重新请求,或者重试等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消息队列：如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、对于业务方进行限流,避免恶意刷消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、服务器采用负载均衡避免一台服务宕机而不可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、消息采用持久化,避免断电等原因导致消息丢失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030211238284-1414556853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;消息队列存储一般采用逻辑存储和物理存储如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、逻辑存储放入内存,主要存储偏移量、消息主题等,同时将存储内容刷入磁盘避免丢失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、物理采用文件进行存储,定期对文件进行归档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/549734/201810/549734-20181030211247448-515490765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6.1、服务可用性降低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加入消息队列后,如果出现mq集群宕机,那么就可能会导致服务不可用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.2、服务复杂度增加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加入消息队列以后就不得不考虑消息一致性、可靠性、重复性等问题无疑加大了服务的难度&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 31 Oct 2018 07:03:00 +0000</pubDate>
<dc:creator>朝向远方</dc:creator>
<og:description>前言：关于消息队列应该大家都不陌生,在实际的项目中消息队列也无处不在,今天我和大家分享一下关于消息队列的问题。 1、消息队列定义 消息队列大家又经常称为MQ(message queue),从字面的含义</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LipeiNet/p/9877189.html</dc:identifier>
</item>
<item>
<title>Java的“Goto”与标签 - 凉初</title>
<link>http://www.cnblogs.com/zouqf/p/9881968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zouqf/p/9881968.html</guid>
<description>&lt;p&gt;goto在Java中是一个保留字，但在语言中并没有用到它；Java没有goto。但是，Java也能完成一些类似于跳转的操作，主要是依靠：&lt;strong&gt;标签&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在迭代语句中，我们可以使用break和continue来中断当前循环。但如果出现循环嵌套的情况，使用break和continue只能中断内层循环，无法控制到外层的循环。这时，我们就可以使用标签结合break和continue，中断内层循环，跳转到标签所在的地方。&lt;/p&gt;

&lt;p&gt;标签的声明很简单，加个冒号就行，就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;label1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Java中，标签起作用的&lt;span&gt;唯一&lt;/span&gt;地方是在&lt;span&gt;迭代语句之前&lt;/span&gt;，注意“唯一”，也就是说不能在其它地方单独使用，只能结合迭代语句共同使用。&lt;/p&gt;
&lt;p&gt;下面这个例子展示了带标签的break以及continue语句在while循环中的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; zouqingfeng
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GotoLabelTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        label1: &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;----------------外层循环开始----------------&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                i&lt;/span&gt;++&lt;span&gt;;
                System.out.println(&lt;/span&gt;&quot;i=&quot; +&lt;span&gt; i);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 1&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot;continue&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 3&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot;continue label1&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt; label1;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 5&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot;break&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == 7&lt;span&gt;) {
                    System.out.println(&lt;/span&gt;&quot;break label1&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt; label1;
                }
                System.out.println(&lt;/span&gt;&quot;----------------内层循环结束----------------&quot;&lt;span&gt;);
            }
            System.out.println(&lt;/span&gt;&quot;----------------外层循环结束----------------&quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;End&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Output:
            ----------------外层循环开始----------------
            i=1
            continue
            i=2
            ----------------内层循环结束----------------
            i=3
            continue label1
            ----------------外层循环开始----------------
            i=4
            ----------------内层循环结束----------------
            i=5
            break
            ----------------外层循环结束----------------
            ----------------外层循环开始----------------
            i=6
            ----------------内层循环结束----------------
            i=7
            break label1
            End

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 从打印的结果可以看出&lt;/p&gt;
&lt;p&gt;当i==1时，执行continue后，没有执行“内层循环结束”打印语句，而是打印了“i=2”，说明continue使执行点回到内层循环起始处，并继续下一次迭代。&lt;/p&gt;
&lt;p&gt;当i==3时，执行continue label1后，没有执行“内层循环结束”打印语句，也没有执行“外层循环结束”，而是打印了“外层循环开始”，说明带标签的continue，对内外层循环都起作用，continue label1同时中断内外层循环，直接跳转到label1标签处，随后，从外部循环开始下一次的迭代。&lt;/p&gt;
&lt;p&gt;当i==5时，执行break后，没有执行“内层循环结束”，但执行了“外层循环结束”，说明break只中断并跳出内层循环，回到了外层循环中。&lt;/p&gt;
&lt;p&gt;当i==7时，执行break label1后，直接打印了“End”,说明带标签的break，对内外层循环都起作用，break label1同时中断内外层循环，直接跳转到label1标签处，但并不重新进入迭代。也就是说，break label1完全终止了两个循环。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;一般的continue只会对其所在的循环起作用，退回循环的开头，并继续执行。&lt;/li&gt;
&lt;li&gt;带标签的continue会使执行点到达标签的位置，并重新进入紧接在标签后的循环。&lt;/li&gt;
&lt;li&gt;一般的break会中断并跳出当前循环。&lt;/li&gt;
&lt;li&gt;带标签的break会中断并跳出标签所指的循环。&lt;/li&gt;
&lt;li&gt;在Java中，标签起作用的&lt;span&gt;唯一地方是在&lt;span&gt;迭代语句之前。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;在Java中，使用标签的唯一理由是有嵌套循环存在，并且想从多层嵌套中break或continue。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 31 Oct 2018 06:48:00 +0000</pubDate>
<dc:creator>凉初</dc:creator>
<og:description>循环嵌套时，怎样在内层循环中使用break以及continue中断外层循环</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zouqf/p/9881968.html</dc:identifier>
</item>
<item>
<title>Flume系列二之案例实战 - liuge36</title>
<link>http://www.cnblogs.com/liuge36/p/9883024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuge36/p/9883024.html</guid>
<description>&lt;h2 id=&quot;flume案例实战&quot;&gt;&lt;strong&gt;Flume案例实战&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;写在前面&lt;br/&gt;通过前面一篇文章http://blog.csdn.net/liuge36/article/details/78589505的介绍我们已经知道flume到底是什么？flume可以用来做什么？但是，具体怎么做，这就是我们这篇文章想要介绍的。话不多说，直接来案例学习。&lt;/p&gt;
&lt;h2 id=&quot;实战一实现官网的第一个简单的小案例-从指定端口采集数据输出到控制台&quot;&gt;实战一：实现官网的第一个简单的小案例-从指定端口采集数据输出到控制台&lt;/h2&gt;
&lt;p&gt;如何开始呢？&lt;br/&gt;看官网！！！！&lt;br/&gt;地址：http://flume.apache.org/FlumeUserGuide.html#flume-sources&lt;/p&gt;
&lt;p&gt;从官网的介绍中，我们知道需要new一个.conf文件，&lt;br/&gt;1.这里我们就在flume的conf文件夹下新建一个test1.conf&lt;/p&gt;
&lt;p&gt;2.把官网的A simple example拷贝进去，做简单的修改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[hadoop@hadoop000 conf]$ vim test1.conf 
# Name the components on this agent
 a1.sources = r1
 a1.sinks = k1
 a1.channels = c1
#
# # Describe/configure the source
 a1.sources.r1.type = netcat
 a1.sources.r1.bind = hadoop000
 a1.sources.r1.port = 44444

# # Describe the sink
 a1.sinks.k1.type = logger

# # Use a channel which buffers events in memory
 a1.channels.c1.type = memory

# # Bind the source and sink to the channel
 a1.sources.r1.channels = c1
 a1.sinks.k1.channel = c1

#不修改也是应该没有什么问题的
#:wq保存退出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.flume的agent启起来之后，就可以开始测试啦：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[hadoop@hadoop000 data]$ telnet hadoop000 44444
Trying 192.168.1.57...
Connected to hadoop000.
Escape character is '^]'.
你好         
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会发现，刚刚启动的agent界面有输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171121135618333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Z2UzNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，就实现第一个简单的flume案例,很简单是吧&lt;/p&gt;
&lt;p&gt;可以看出，使用Flume的关键就是写配置文件&lt;br/&gt;1） 配置Source&lt;br/&gt;2） 配置Channel&lt;br/&gt;3） 配置Sink&lt;br/&gt;4) 把以上三个组件串起来&lt;/p&gt;
&lt;p&gt;简单来说，使用flume，就是使用flume的配置文件&lt;/p&gt;
&lt;h2 id=&quot;实战二监控一个文件实时采集新增的数据输出到控制台&quot;&gt;实战二：监控一个文件实时采集新增的数据输出到控制台&lt;/h2&gt;
&lt;p&gt;思路？？&lt;br/&gt;前面说到，做flume就是写配置文件&lt;br/&gt;就面临选型的问题&lt;br/&gt;Agent选型，即source选择什么，channel选择什么，sink选择什么&lt;/p&gt;
&lt;p&gt;这里我们选择 exec source memory channel logger sink&lt;/p&gt;
&lt;p&gt;怎么写呢？&lt;br/&gt;按照之前说的那样1234步骤&lt;/p&gt;
&lt;p&gt;从官网中，我们可以找到我们的选型应该如何书写：&lt;br/&gt;1） 配置Source&lt;br/&gt;exec source&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Property Name   Default Description
channels    –    
type    –   The component type name, needs to be exec
command –   The command to execute
shell   –   A shell invocation used to run the command. e.g. /bin/sh -c. Required only for commands relying on shell features like wildcards, back ticks, pipes etc.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从官网的介绍中，我们知道我们的exec source得配置type=exec&lt;br/&gt;,配置自己的command，shell也是建议配置上的，其余的配置就不用配置了。是不是很简单。我们这里自己的配置就如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Describe/configure the source
a1.sources.r1.type = exec
a1.sources.r1.command = tail -F /home/hadoop/data/data.log
a1.sources.r1.shell = /bin/sh -c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2） 配置Channel&lt;br/&gt;memory channel&lt;br/&gt;官网介绍的是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Property Name   Default Description
type    –   The component type name, needs to be memory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应着写自己的Channel:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a1.channels.c1.type = memory&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3） 配置Sink&lt;br/&gt;logger sink&lt;br/&gt;官网介绍的是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Property Name   Default Description
channel –    
type    –   The component type name, needs to be logger&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应着写自己的Sink:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a1.sinks.k1.type = logger&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4) 把以上三个组件串起来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;按照1.2.3.4这个固定的套路写任何的agent都是没有问题的&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.我们new一个文件叫做test2.conf&lt;br/&gt;把我们自己的代码贴进去：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[hadoop@hadoop000 conf]$ vim test2.conf
a1.sources = r1
a1.sinks = k1
a1.channels = c1

a1.sources.r1.type = exec
a1.sources.r1.command = tail -F /home/hadoop/data/data.log
a1.sources.r1.shell = /bin/sh -c

a1.sinks.k1.type = logger

a1.channels.c1.type = memory

a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1 

#:wq保存退出&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.开启我们的agent&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flume-ng agent \
--name a1  \
--conf $FLUME_HOME/conf  \
--conf-file $FLUME_HOME/conf/test2.conf \
-Dflume.root.logger=INFO,console
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.开始测试数据&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171121134954623?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Z2UzNg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;export 到这里，我相信你一定学会如何去写flume了。强调一下，官网是一个好的学习资源，一定不要浪费。这里，我就先简单介绍这么两个小的案例实战，后面还会继续更新更多flume的使用...一起加油&lt;/p&gt;
</description>
<pubDate>Wed, 31 Oct 2018 06:43:00 +0000</pubDate>
<dc:creator>liuge36</dc:creator>
<og:description>Flume案例实战 写在前面 通过前面一篇文章http://blog.csdn.net/liuge36/article/details/78589505的介绍我们已经知道flume到底是什么？flum</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuge36/p/9883024.html</dc:identifier>
</item>
<item>
<title>Explain 执行计划 和 SQL优化 - 心大一点</title>
<link>http://www.cnblogs.com/keme/p/9882663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keme/p/9882663.html</guid>
<description>&lt;h3&gt;Explain 介绍&lt;/h3&gt;
&lt;p&gt;在分析查询性能时，考虑EXPLAIN关键字同样很管用。EXPLAIN关键字一般放在SELECT查询语句的前面，用于描述MySQL如何执行查询操作、以及MySQL成功返回结果集需要执行的行数。explain 可以帮助我们分析 select 语句,让我们知道查询效率低下的原因,从而改进我们查询,让查询优化器能够更好的工作，可以帮助选择更好的索引和写出更优化的查询语句。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;执行计划用来显示对应语句在MySQL中是如何执行的。 Explain语句对select，delete，update，insert，replace语句有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031140006508-793028330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;id列：&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;表示执行顺序，值越大则优先级越高；值相同则从上而下执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;select_type列&lt;/strong&gt;常见的有：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个
primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。 且只有一个
union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表 select_type都是union
dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响
union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null
subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery
dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响
derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌select
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;table列&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的&lt;code&gt;&amp;lt;derived N&amp;gt;&lt;/code&gt;就表示这个是临时表,后边的N就是执行计划 中的id，表示结果来自于这个查询产生。如果是尖括号括起来&amp;lt;union M,N&amp;gt;，与&lt;code&gt;&amp;lt;derived N&amp;gt;&lt;/code&gt;类似， 也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;Type列&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;：表示访问类型，性能从低到高依次是：ALL-&amp;gt;index-&amp;gt;range-&amp;gt;ref-&amp;gt;eq_ref-&amp;gt;const，&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;system-&amp;gt;NULL&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行
index：Full Index Scan(覆盖索引)index与ALL区别为index类型只遍历索引树
range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、 &amp;lt;、 &amp;gt;等的查询
unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值
index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重
ref：非唯一性索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引和唯一索引的非唯一前缀进行的查找
eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描的多表链接操作中
system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于
where列表中，MySQL就能将该 查询转换为一个常量。 System为表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表， type列在这个情况通常都是all或者index
const:使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描
NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;possible_keys列&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;表示MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则&lt;span&gt;该索引将被列出，但&lt;code&gt;不一定被查询使用&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Key列&lt;/strong&gt;：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;表示&lt;span&gt;&lt;code&gt;MySQL在查询中实际使用的索引&lt;/code&gt;&lt;/span&gt;，若没有使用索引，显示为NULL&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;key_len列&lt;/strong&gt;：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;Ref列&lt;/strong&gt;：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rows列&lt;/strong&gt;：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;表示MySQL根据表统计信息及索引选用情况，&lt;code&gt;估算的找到所需的记录所需要读取的行数&lt;/code&gt;，值越大性能越差&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;Extra列&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;包含不适合在其他列中显示但&lt;code&gt;十分重要的额外信息&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Using index：该值表示相应的select操作中使用了覆盖索引（Covering Index）
Using where：表示MySQL服务器在存储引擎收到(使用索引)记录后进行“后过滤”
Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询
Using filesort： MySQL中无法利用索引完成的排序操作称为“文件排序”，常见于order by和group by语句中
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-优化原则&quot;&gt;SQL 优化原则&lt;/h3&gt;
&lt;div&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li&gt;尽可能消除全表扫描，除非表数据量是在万条一下&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;增加适当的索引能提高查询的速度，但增加索引需要遵循一定的基本规则：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;a. 加在where条件上&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;b. 加在表之间join的键值上&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;c. 如果查询范围是少量字段，可以考虑增加覆盖索引（仅走索引）&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;d. 有多个查询条件时，考虑增加复合索引，并把最常使用的字段放在索引前面&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;e. 不要将索引加在区别率不高的字段上&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;f . 字段上增加函数，则字段上的索引用不了，需考虑改变写法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;去掉不影响查询结果的表&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;h3 id=&quot;慢查询日志&quot;&gt;慢查询日志&lt;/h3&gt;
&lt;p&gt;开启慢查询日志，分日里面执行时间很长语句 ， 可以针对性的对常用语句进行建立索引&lt;/p&gt;
&lt;p&gt;开启方法my.cnf：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
slow_query_log= on #开启
slow_query_log_file = /path/mysql-slow.log  #  慢查询文件存放位置
long_query_time= 2 #2秒以上的语句被记录
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;慢查询日志并不是只是记录的查出select 语句 ，dml 对数据语句都会记录&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;sql-优化练习&quot;&gt;SQL 优化测试&lt;/h3&gt;
&lt;p&gt;创建一个有索引的表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
create table students (
sid int,
sname varchar(64),
gender int,
dept_id int,
primary key(sid)
);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建一个什么索引都没有的表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
create table students_noindex (
sid int,
sname varchar(64),
gender int,
dept_id int
);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;利用存储过程, 分别给有索引的表和没有索引的表创建测试数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 有索引的 表
delimiter //
CREATE PROCEDURE `proc_students`()
Begin
Declare n int default 1;
while n&amp;lt;=500000 do
Insert into students values(n, concat('zhang
san',n),floor(1+rand()*2),floor(1+rand()*4));
Set n=n+1;
End while;
End;
//
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
# 没有索引的 表
delimiter //
CREATE PROCEDURE `proc_students_noindex`()
Begin
Declare n int default 1;
while n&amp;lt;=500000 do
Insert into students_noindex values(n, concat('zhang
san',n),floor(1+rand()*2),floor(1+rand()*4));
Set n=n+1;
End while;
End;
//
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果 表上所有字段都有索引的情况下，测试对插入性能的影响：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
create index idx_sname on students(sname);
create index idx_gender on students(gender);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看看两个表students，students_noindex结构&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031140936449-360935492.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分别在两个表插入数据看时间消耗&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
set autocommit=0;
call proc_students();
commit;

call proc_students_noindex();
commit;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141004500-1932600656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有索引的表插入数据更快&lt;/p&gt;
&lt;h4 id=&quot;考虑性能消耗的情况&quot;&gt;考虑性能消耗的情况&lt;/h4&gt;
&lt;p&gt; 这是500000万行的记录插入，&lt;span&gt;&lt;code&gt;有索引的插入时间更久 ，没有索引的插入更快&lt;/code&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;用时整体时间都比没有索引的插入数据慢 ， 反应情况来看是&lt;span&gt;&lt;code&gt;索引建的越多对SQL增删改消耗的性能越大&lt;/code&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; ,因为不仅会修改表数据，还会整理一些索引信息&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;如果是上亿条的数据记录插入，想想插入时间 ， 还&lt;span&gt;有大表数据迁移 在目标表都把索引给删掉，插入数据完成的，在目标表统一建立索引&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;打开autocommit和关闭autocommit插入数据的区别&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
truncate table students;
truncate table students_noindex;
set autocommit=1;
call proc_students();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141255604-441694207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入数据中途可以在打开一个会话窗口看插入了多少数据&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;select count(*) from students;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;自动提交开启插入500000条记录真的要花很长很长时间， 而自动提交关闭 几十秒的时间都把500000行数据插入完了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;是因为每条数据插入都会写入磁盘 ，而关闭autocommit 是在插入完数据在统一把500000条记录commit;写入到磁盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141341105-462676976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在把原来没有索引的students_noindex 数据插入回去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141439764-730433838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;测试单表在没有索引下全表扫描和走索引情况下的性能对比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141521283-132349136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;select 查询加上sql_no_cache 查询的时候不使用缓存 ，突出我的实验结果&lt;/p&gt;
&lt;p&gt;上面图片很明显是 走索引情况查询速度更快&lt;/p&gt;
&lt;p&gt;通过explain 看下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141601020-164138774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有索引走的全表扫描&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试通过区别度不高的字段（如gender）上查询和全表查询的性能对比：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
create temporary table a select * from students where gender=1;
create temporary table b  select * from students_noindex  where gender=1;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141651580-2120804549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在区别度很低 （gender上有索引）查询和全表查询 性能上差不多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试通过索引查询表中绝大多数数据和全表查询的性能对比：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
select SQL_NO_CACHE count(*) from students where sid&amp;gt;1; # 类似全表查询了
select SQL_NO_CACHE count(*) from students where sid&amp;gt;10000; # 查询表的大多数数据
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141731970-2146017136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查询时间是一样的 。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;使用查询条件更可能小的约束过滤范围&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;测试表链接关联字段走索引和不走索引的性能对比：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
create index idx_deptid on students(dept_id);
explain select count(*) from students a inner join dept b on a.dept_id=b.id;  # dept_id字段有索引
explain select count(*) from students_noindex a inner join dept b on a.dept_id=b.id; #students_noindex 的表没有任何索引
select SQL_NO_CACHE count(*) from students a inner join dept b on a.dept_id=b.id; 
select SQL_NO_CACHE count(*) from students_noindex a inner join dept b on a.dept_id=b.id
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033265/201810/1033265-20181031141842824-1592856331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在关联字段上加了索引 查询时间只用了0.07s 用时 比没有走索引的快了很多很多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;优化手段不只一种 ，要根据实际情况，很多情况都是以最低成本去处理， 例如&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;有可能加索引就能解决， 有可能解决不了，语句的写法的可能有问题（例如语句有函数，表达式），也有可能去改表的结构(例如增加冗余字段),有可能数据库瓶颈问题， 网络情况问题，服务器性能IO 问题，等等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 31 Oct 2018 06:22:00 +0000</pubDate>
<dc:creator>心大一点</dc:creator>
<og:description>Explain 介绍 在分析查询性能时，考虑EXPLAIN关键字同样很管用。EXPLAIN关键字一般放在SELECT查询语句的前面，用于描述MySQL如何执行查询操作、以及MySQL成功返回结果集需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keme/p/9882663.html</dc:identifier>
</item>
<item>
<title>线程：生命周期、实现方式、start()和run()的区别! - Java-live-begin</title>
<link>http://www.cnblogs.com/wang-Java-begining/p/9882693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-Java-begining/p/9882693.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1.线程的生命周期&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;一个完整的生命周期中通常要经历如下的五种状态：&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt; 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt; 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt; 运行：当就绪的线程被调度并获得处理器资源时,便进入运行状态，run()方法定义了线程的操作和功能&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt; 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt; 死亡：线程完成了它的全部工作或线程被提前强制性地中止 &lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171026231814414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGxhbnRpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; width=&quot;547&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2.创建线程的两种方式&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;（1）继承Thread类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    1) 定义子类继承Thread类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    2) 子类中重写Thread类中的run方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    3） 创建Thread子类对象，即创建了线程对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;span&gt;    4) 调用线程对象start方法：启动线程，调用run方法。&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（2）实现Runnable接口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    1）定义子类，实现Runnable接口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    2）子类中重写Runnable接口中的run方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    3）通过Thread类含参构造器创建线程对象。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造方法中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;两种实现方式的区别：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ①继承Thread:  线程代码存放Thread子类run方法中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ②实现Runnable：线程代码存在接口的子类的run方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.多线程程序的优点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    2.提高计算机系统CPU的利用率&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;    3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;线程中run()和start()的区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.run();  只是调用了一个普通方法，并没有启动另一个线程，程序还是会按照顺序执行相应的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.start();  则表示，重新开启一个线程，不必等待其他线程运行完，只要得到cup就可以运行该线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;pre name=&quot;code&quot; class=&quot;java&quot;&amp;gt;public class demo1 {
        public static void main(String args[]) {  
        Thread t = new Thread() {  
            public void run() {  
                pong();  
            }  
        };  
        t.start();  
//        t.run();
        System.out.print(&quot;ping&quot;);  
    }  
    static void pong() {  
        System.out.print(&quot;pong&quot;);  
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class demo2 {
        public static void main(String args[]) {  
        Thread t = new Thread() {  
            public void run() {  
                pong();  
            }  
        };  
 //       t.start();  
          t.run();
        System.out.print(&quot;ping&quot;);  
    }  
    static void pong() {  
        System.out.print(&quot;pong&quot;);  
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是：&lt;/p&gt;


</description>
<pubDate>Wed, 31 Oct 2018 06:07:00 +0000</pubDate>
<dc:creator>Java-live-begin</dc:creator>
<og:description>1.线程的生命周期 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的 一个完整的生命周期中通常要经历如下的五种状态： 新建：当一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-Java-begining/p/9882693.html</dc:identifier>
</item>
<item>
<title>轻量级锁与偏向锁 - JavaRecorder</title>
<link>http://www.cnblogs.com/xmsx/p/9866641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xmsx/p/9866641.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;锁级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁。只能升级不能降级。&lt;/p&gt;
&lt;p&gt;锁级别越高，获得锁和释放锁就越耗费性能。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;轻量级锁是一种多线程优化，通过 CAS 来避免进入开销较大的互斥操作。&lt;/li&gt;
&lt;li&gt;有线程竞争锁就会导致轻量级锁膨胀为重量级锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【加锁】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程访问同步块，JVM 会先在当前线程的栈桢中创建一个空间用于存储锁记录，并将对象头中的 Mark Word 复制于此。&lt;/li&gt;
&lt;li&gt;然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。
&lt;ul&gt;&lt;li&gt;如果成功，当前线程获得锁，对象头中锁标志位设置为&lt;code&gt;00&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，自旋一定次数后若还是失败，就会膨胀为重量级锁，因为重量级锁的互斥性，线程阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS：自旋虽然避免了线程切换的开销，但会消耗 CPU，因此要控制次数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【解锁】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CAS 操作来将 Mark Word 从锁记录替换回到对象头。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果成功，则表示没有竞争发生。&lt;/li&gt;
&lt;li&gt;如果失败，表示当前锁存在竞争，锁已膨胀成重量级锁，那就要在释放锁的同时，唤醒被挂起的线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【轻量级锁及膨胀流程图】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p6586lvnw.bkt.clouddn.com/FkXFSGr-pwhF4ng7lhdz_IVJbBqU.jpg&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;偏向锁只能在单线程下起作用。&lt;/li&gt;
&lt;li&gt;偏向锁，偏向于第一个访问锁的线程，如果接下来该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。&lt;/li&gt;
&lt;li&gt;本质上偏向锁就是为了消除 CAS，使获得锁的代价更低。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【加锁】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当一个线程访问同步块时，会在对象头中存储锁偏向的线程 ID（通过最开始的一次CAS），以后这个线程在进入这个同步块时就不需要进行 CAS 操作来加锁和解锁，只需要简单测试 Mark Word 中是否存储着指向当前线程的偏向锁。&lt;/li&gt;
&lt;li&gt;如果测试成功，则说明线程已经获取了锁。&lt;/li&gt;
&lt;li&gt;如果测试失败，则需再测试 Mark Word 中偏向锁的标识是否设置为 1（是否还是偏向锁）。&lt;/li&gt;
&lt;li&gt;如果没有设置，表示当前可能已经升级为轻量锁或重量锁了，则使用 CAS 竞争锁。&lt;/li&gt;
&lt;li&gt;如果设置了，表示当前还处于偏向锁层次只是此时没有线程占有锁，尝试使用 CAS 将对象头的偏向锁指向该线程（释放锁时，会将 Mark Word 中线程 ID 的这个位置置空，以便其他线程获取该偏向锁）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【解锁（锁撤销）】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程不会主动去释放偏向锁：只有其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。&lt;/li&gt;
&lt;li&gt;遇到其他线程竞争锁，持有偏向锁的线程会被挂起，若持有偏向锁的线程处于同步块内，将锁升级为轻量级锁，若持有偏向锁的线程已退出同步块，将锁置为无锁状态，最后唤醒暂停的线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【偏向锁的获得和撤销流程】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p6586lvnw.bkt.clouddn.com/Fj3ftkJeVRxda7aK-gzpmsr7hYz5.jpg&quot;/&gt;&lt;/p&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;偏向锁&lt;/td&gt;
&lt;td&gt;加锁解锁不需要额外消耗&lt;/td&gt;
&lt;td&gt;如果线程间存在锁竞争，会带来额外的锁撤销消耗&lt;/td&gt;
&lt;td&gt;适用于单线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;轻量级锁&lt;/td&gt;
&lt;td&gt;竞争的线程不会阻塞，提高了程序的相应速度&lt;/td&gt;
&lt;td&gt;如果始终得不到锁竞争的线程，使用自旋会消耗 CPU&lt;/td&gt;
&lt;td&gt;追求相应时间，同步块执行速度非常快&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;重量级锁&lt;/td&gt;
&lt;td&gt;线程竞争不使用自旋，不会消耗 CPU&lt;/td&gt;
&lt;td&gt;线程阻塞，响应时间缓慢&lt;/td&gt;
&lt;td&gt;追求吞吐量，同步块执行速度较长&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 31 Oct 2018 05:39:00 +0000</pubDate>
<dc:creator>JavaRecorder</dc:creator>
<og:description>锁级别由低到高依次为：无锁、偏向锁、轻量级锁、重量级锁。只能升级不能降级。 锁级别越高，获得锁和释放锁就越耗费性能。 [TOC] 轻量级锁 轻量级锁是一种多线程优化，通过 CAS 来避免进入开销较大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xmsx/p/9866641.html</dc:identifier>
</item>
<item>
<title>App遍历探讨(含源代码) - 不再有的年月</title>
<link>http://www.cnblogs.com/hhudaqiang/p/9882501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhudaqiang/p/9882501.html</guid>
<description>&lt;p&gt;好像好久没有更新博客了，之前写的几篇博客关于自动化的框架的居多，其中好多博友向我提了好多问题，我没有回复。&lt;span&gt;这里给博友道个歉&lt;/span&gt;&lt;span&gt;~ ~ &lt;span&gt;总结几点原因如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.我一般很少上博客，看到了都是好几天之前的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.比较懒~ ~这是主要原因，以后会更改！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.框架都是比较老了，现在已经对自动化单元测试框架，做了更高级的封装。(报告更加优美，功能也增加了：比如错误截图，后台异常搜集，可重复&lt;span&gt;多次&lt;/span&gt;执行，错误录屏，后台crash和anr异常·　　捕捉)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.打算最近重新把这一套完整的东西，放在github上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前从事的是APP测试，所以封装了minicap快速截图、监听器处理异常弹框(广告)、图形识别、OCR技术等公共方法与appium完美结合，关于图形识别和OCR的作用是明显的...当前这一套东西同样适应用web端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前我们的所有测试结果是放在平台上的。包括功能、性能、稳定性、兼容性测试等....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一块，我改天专门讲讲我在封装时的一些小心得.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天，我们的主题是遍历APP！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入主题，为什么要研究这个玩意？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;话说做app自动化测试或者功能测试对monkey这个玩意应该不陌生吗，在压力测试中经常跑这个然后搜集crash和anr信息。但是monkey的缺点是很明显：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.没有目的性，遍历效果比较差，一般很难比较系统的遍历玩app的&lt;span&gt;大部分&lt;/span&gt;页面！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.经常没事还把你wifi给断了，那么接下来的monkey是无意义的，有些app没有网就是废的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.可能陷入到一种死循环中，比如A-B-C-D-C-B-A 根本出不来，这时候如果看见了，可能狂按返回键帮他跳出整个死循环...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我也改造了monkey了 某种程度上让他看起来稍微智能和高效点，整个有感兴趣的博友可以留言讨论。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，说了这么多，&lt;span&gt;我们总想着如果有一种算法大致上能像人一样点完app的上所有按钮&lt;/span&gt;，然后在点击过程中收集一些性能信息比如耗电、cpu、上下行流量...更重要的是搜集一些crash和anr信息，对于一些比较固定且内容变化不大的app还可以进行图形对比，判断不同版本对应不同页面的截图差异！等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实，早就有这个东西了像百度的测试的那个所谓的深度遍历，还有其他的各种云的遍历，但是但是，效率是相当的差，因为不支持定制和一些过滤规则，根本遍历不了几个按钮就结束或者陷入死循环...而且tm的还要钱...我是试用了下，懒得再用了！然后再testhome上看见了一个大神写的app遍历：https://testerhome.com/search?q=AppCrawler&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感觉想法和思路很好！我非常佩服，但是我下载了下来用来遍历我们的这个比较比较变态的app，效率和遍历深度很差....这里没有其他的意思(&lt;span&gt;针对我的&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;这个app&lt;/span&gt;&lt;span&gt;)，&lt;span&gt;实话实说！原因呢可能有一下几点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.我们的这个app广告特别的多，不时弹出个广告，让你措手不及，这个不好处理！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.过滤规则我可能没太理解怎么用！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.有死循环出现。比如在A用户的个人主页面点击进了B的个人&lt;span&gt;profile&lt;/span&gt;然后进入C&lt;span&gt;的个人&lt;span&gt;profile，反正一直在&lt;span&gt;&lt;span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;页面遍历!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;还有一些缺点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.没有脱离appium,运行脚本建立在appium的基础上&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2.速度有点慢...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;那么，我也想写&lt;span&gt;个简单的遍历脚本&lt;/span&gt;（我希望他不断不简单)，当前可能不能和这位大神的&lt;span&gt;AppCrawler&lt;/span&gt;相比，但是也有我的一些小优点~~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.用的自生长的深度优先遍历算法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在一个初始页面获取所有自定义规则的element,然后点击其中的一个element，跳转或者不跳转到另外一个page,再次获取次也么的合法element添加路径和图的邻边...一直这样递归一直到一个page&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;无法获取新的element或到达设定的深度或设定的时间终止遍历！！如果不太了解可以看下深&lt;span&gt;&lt;span&gt;&lt;span&gt;度优先遍历算法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。不过我们的这个图和邻边是单向的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2.脱离了appium,利用appium的真正实现原理封装了针对于uiautomator2-server的方法，只要装有这个apk就行，省去了appium的安装成本和排除坑爹的&lt;span&gt;&lt;span&gt;&lt;span&gt;appium&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;错误的错误成本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3.同样支持规则引导&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4.目前自认为还可以的遍历效率和深度(对我这个app，当前还要不断增加逻辑和优化，这是我写这篇博客的主要目的！)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;5.遍历完生成思维导图和遍历截图（用jsmind）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;....&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其他的慢慢的再加上，我只想让他遍历高效点和准确点，工程我已经放在github上，写这篇博客的目的就是想引入这么个概念，然后想让感兴趣的一些拓展或修改这个框架，不管是过滤规则还是算法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我相信只有大家共同来想好怎么做这个工程才能做好！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;项目github的地址:&lt;a title=&quot;工程github地址&quot; href=&quot;https://github.com/zhoudaqiang/appCrawler&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;https://github.com/zhoudaqiang/appCrawler&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;最后，写的时候比较随意主要是让他能运行起来。如果大家对这个框架不太了解或者对其中的任何思想不明白可以留言加QQ详聊。希望能有人一起想好做好这个遍历工程，至少能比monkey高效点~&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 31 Oct 2018 05:33:00 +0000</pubDate>
<dc:creator>不再有的年月</dc:creator>
<og:description>好像好久没有更新博客了，之前写的几篇博客关于自动化的框架的居多，其中好多博友向我提了好多问题，我没有回复。这里给博友道个歉~ ~ 总结几点原因如下： 1.我一般很少上博客，看到了都是好几天之前的问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhudaqiang/p/9882501.html</dc:identifier>
</item>
<item>
<title>挑战常规--为什么不应该使用Jsonp进行跨域 - 我想嘿嘿</title>
<link>http://www.cnblogs.com/loveheihei/p/9882384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveheihei/p/9882384.html</guid>
<description>&lt;h3 id=&quot;常规跨域的方法&quot;&gt;常规跨域的方法&lt;/h3&gt;
&lt;p&gt;常见跨域的方法有:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加Access-Control-Allow-Origin&lt;/li&gt;
&lt;li&gt;后台服务器代理&lt;/li&gt;
&lt;li&gt;Jsonp&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;1、2两种方法都是安全可靠的,3是不安全不可靠的&lt;/p&gt;
&lt;h3 id=&quot;json的本质&quot;&gt;Json的本质&lt;/h3&gt;
&lt;p&gt;Json本质是&lt;strong&gt;引用并执行外部JavaScript脚本&lt;/strong&gt;,原理是&amp;lt;scrpit&amp;gt;标签不受域名的限制,通过动态创建&amp;lt;scrpit&amp;gt;来执行js函数&lt;/p&gt;
&lt;h3 id=&quot;jsonp的使用&quot;&gt;Jsonp的使用&lt;/h3&gt;
&lt;p&gt;jQuery执行Jsonp使用&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;$.ajax(url,{
        dataType:&quot;jsonp&quot;,
        error:function(jqXHR,textStatus,errorThrown)
        {
            //TODO
        },
        success:function(data)
        {
            //TODO
        }
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;jQuery3.3.1加载执行外部js&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function DOMEval( code, doc, node ) {
    doc = doc || document;

    var i,
        script = doc.createElement( &quot;script&quot; );

    script.text = code;
    if ( node ) {
        for ( i in preservedScriptAttributes ) {
            if ( node[ i ] ) {
                script[ i ] = node[ i ];
            }
        }
    }
    doc.head.appendChild( script ).parentNode.removeChild( script );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;不安全&quot;&gt;不安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用户输入不可信,外部脚本同样不可信&lt;/strong&gt;。若A网站引用了B网站的跨域脚本,那么A网站的安全受B网站牵制。&lt;/p&gt;
&lt;p&gt;安全情况下,safeapi.php&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
date_default_timezone_set('asia/shanghai');
$result=json_encode(array(&quot;msg&quot;=&amp;gt;&quot;你好,当前时间:&quot;.date(&quot;Y-m-d H:i:s e&quot;)));
if(isset($_REQUEST['callback']))
{
    header(&quot;Content-Type:text/javascript;charset=utf-8&quot;); 
    echo $_REQUEST['callback'].&quot;(&quot;.$result.&quot;)&quot;;
}else
{
    header(&quot;Content-Type:application/json;charset=utf-8&quot;);
    echo $result;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B网站受到攻击或恶意代码,danger.php&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
header(&quot;Content-Type:text/javascript;charset=utf-8&quot;); 
if(isset($_REQUEST['callback']))
{ 
    echo $_REQUEST['callback'].&quot;(&quot;; 
}else
{
    echo &quot;_(&quot;;  
}
echo json_encode(array(&quot;msg&quot;=&amp;gt;&quot;你好,当前时间:&quot;.date(&quot;Y-m-d H:i:s&quot;)));
echo &quot;);console.log('do something');&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在A网站下控制台输出 do something&lt;/p&gt;
&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;
&lt;p&gt;应该对网站安全进行隔离，不应轻易相信外部脚本,否则很容易造成账号泄漏等安全风险。如果的确需要引用执行外部脚本,可以使用CSP 策略指令进行白名单控制,如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Content-Security-Policy: default-src 'self' trustedscripts.foo.com&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 31 Oct 2018 05:26:00 +0000</pubDate>
<dc:creator>我想嘿嘿</dc:creator>
<og:description>常规跨域的方法 常见跨域的方法有: 1. 添加Access Control Allow Origin 2. 后台服务器代理 3. Jsonp 1、2两种方法都是安全可靠的,3是不安全不可靠的 Json</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loveheihei/p/9882384.html</dc:identifier>
</item>
<item>
<title>netty同端口监听tcp和websocket协议 - 望星辰大海</title>
<link>http://www.cnblogs.com/tohxyblog/p/9882478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tohxyblog/p/9882478.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　软件通信七层结构（osi模型）中由协议套协议最终组成最高级应用层协议（http等等），下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。&lt;/li&gt;
&lt;li&gt;　　七层结构的最主要功能就是帮助不同系统的主机在不同的网络中进行数据传输。&lt;/li&gt;
&lt;li&gt;　　数据传输层：tcp、udp协议，tcp协议依赖互联网协议（ip层协议）。&lt;/li&gt;
&lt;li&gt;　　socket在第五层会话层，它并不是一个协议，而是一组接口（api），更是一个规范，为了方便使用底层协议而存在的一种抽象层。&lt;/li&gt;
&lt;li&gt;　　websocket，http 等协议都是应用层协议（更面向于用户），依赖于传输层tcp协议。&lt;/li&gt;
&lt;li&gt;　　websocket 在进行通信时，使用了http进行一次握手，数据传输使用tcp通道传输。&lt;/li&gt;
&lt;li&gt;　　socket更像是一种网络编程的概念，是抽象出来的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;tcpSocket 与 websocket 的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;　tcpSocket是tcp的协议传输，直接进行tcp的三次握手：client向server发送请求报文，server回复ack报文并分配资源，client发送报文并分配资源，连接建立。&lt;/li&gt;
&lt;li&gt;　websocket是基于tcp的应用层协议，采用一次HTTP握手。其发送的请求报文和socket是有区别的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;本片文章目的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;使用netty同端口监听tcpsocket和websocket消息传输。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思想：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在netty编程中，对于不同的消息肯定需要不同的编解码来处理，所以我们需要利用netty具有动态增删处理器handle的功能。 &lt;/p&gt;
&lt;p&gt;　　而从上文中我们知道websocket第一次是采用http握手的，因此debug握手请求，知道他的请求头部是GET方式。&lt;/p&gt;
&lt;p&gt;　　所以我们需要根据这点来判断接收的消息是websocket还是tcpsocket。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.判断handle如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
/**
 * 协议初始化解码器.
 *
 * 用来判定实际使用什么协议.&amp;lt;/b&amp;gt;
 *
 */
public class SocketChooseHandle extends&lt;span&gt; ByteToMessageDecoder {
    /** 默认暗号长度为23 */
    private static final int MAX_LENGTH = 23&lt;span&gt;;
    /** WebSocket握手的协议前缀 */
    private static final String WEBSOCKET_PREFIX = &quot;GET /&quot;&lt;span&gt;;


    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) throws&lt;span&gt; Exception {
        String protocol =&lt;span&gt; getBufStart(in);
        if&lt;span&gt; (protocol.startsWith(WEBSOCKET_PREFIX)) {
            SpringApplicationContextHolder.getSpringBeanForClass(PipelineAdd.class&lt;span&gt;).websocketAdd(ctx);

            ctx.pipeline().remove(LengthFieldBasedFrameDecoder.class&lt;span&gt;);
            ctx.pipeline().remove(LengthFieldPrepender.class&lt;span&gt;);
            ctx.pipeline().remove(BytebufToByteHandle.class&lt;span&gt;);
        }

        in.resetReaderIndex();
        ctx.pipeline().remove(this&lt;span&gt;.getClass());

    }

    private&lt;span&gt; String getBufStart(ByteBuf in){
        int length =&lt;span&gt; in.readableBytes();
        if (length &amp;gt;&lt;span&gt; MAX_LENGTH) {
            length =&lt;span&gt; MAX_LENGTH;
        }

        // 标记读位置
&lt;span&gt;        in.markReaderIndex();
        byte[] content = new byte&lt;span&gt;[length];
        in.readBytes(content);
        return new&lt;span&gt; String(content);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：判断是否是GET /协议开始的消息，如果是，则是websocket，那么移除后面的socket编解码器，添加websocket编解码器。然后删除自己（将自身删除后，此连接之后的消息将不再进入这个handle，直接走安排好的对应handle串行处理器。而不是所有连接）。&lt;/p&gt;


&lt;p&gt;2.接下来我们将上述handle判断器加入到消息来的编解码器前方。&lt;/p&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1.socket方式服务
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置N秒没有读到数据，则触发一个READER_IDLE事件。&lt;/span&gt;
            pipeline.addLast(&lt;span&gt;new&lt;/span&gt; IdleStateHandler(readerIdleTime,0,0&lt;span&gt;, TimeUnit.SECONDS));
            pipeline.addLast(&lt;/span&gt;&quot;active&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelActiveHandle());
            pipeline.addLast(&lt;/span&gt;&quot;socketChoose&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketChooseHandle());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tcpsocket编码解码handle，如果是websocket链接，会将其删除&lt;/span&gt;
            pipeline.addLast(&quot;lengthEncode&quot;,&lt;span&gt;new&lt;/span&gt; LengthFieldPrepender(4, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
            pipeline.addLast(&lt;/span&gt;&quot;lengthDecoder&quot;,&lt;span&gt;new&lt;/span&gt; LengthFieldBasedFrameDecoder(2000, 0, 4,0, 4&lt;span&gt;));
            pipeline.addLast(bytebufToByteHandle);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为接收类型的泛型不对，所以在websocket握手的时候不会进入该handle
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此handle为最后的socket消息分解，web和tcp通用&lt;/span&gt;
            pipeline.addLast(&quot;byteToBuf&quot;&lt;span&gt;,byteToByteBufHandle);
            pipeline.addLast(&lt;/span&gt;&quot;protocolResolve&quot;,protocolResolveHandle);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
IdleStateHandler  心跳处理器
&lt;/pre&gt;
&lt;pre&gt;
active 活跃连接处理器
&lt;/pre&gt;
&lt;pre&gt;
socketChoose 前文所述的判断消息协议处理器
&lt;/pre&gt;
&lt;pre&gt;
lengthEncode tcp连接的拆包粘包编码处理器（用来在消息前面附加4个字节的长度信息）
&lt;/pre&gt;
&lt;pre&gt;
lengthDecoder tcp连接的拆包粘包解码处理器（长度判断）
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;bytebufToByteHandle  自定义处理器，用来将bytebuf转成我们需要的byte[]。&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
byteToBuf  自定义处理器，用来将要发出的消息从byte[]装成bytebuf。
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
protocolResolve 自定义处理器，处理消息，找到路由handle以及处理逻辑&lt;p&gt;&lt;strong&gt;3.websocket需要的编解码器&lt;/strong&gt;&lt;br/&gt;代码如下
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; websocketAdd(ChannelHandlerContext ctx){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HttpServerCodec：将请求和应答消息解码为HTTP消息&lt;/span&gt;
        ctx.pipeline().addBefore(&quot;byteToBuf&quot;,&quot;http-codec&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpServerCodec());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; HttpObjectAggregator：将HTTP消息的多个部分合成一条完整的HTTP消息&lt;/span&gt;
        ctx.pipeline().addBefore(&quot;byteToBuf&quot;,&quot;aggregator&quot;,&lt;span&gt;new&lt;/span&gt; HttpObjectAggregator(65535&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ChunkedWriteHandler：向客户端发送HTML5文件&lt;/span&gt;
        ctx.pipeline().addBefore(&quot;byteToBuf&quot;,&quot;http-chunked&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChunkedWriteHandler());

        ctx.pipeline().addBefore(&lt;/span&gt;&quot;byteToBuf&quot;,&quot;WebSocketAggregator&quot;,&lt;span&gt;new&lt;/span&gt; WebSocketFrameAggregator(65535&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在管道中添加我们自己的接收数据实现方法&lt;/span&gt;
        ctx.pipeline().addBefore(&quot;byteToBuf&quot;,&quot;ws-handShake&quot;&lt;span&gt;,wsHandShakeServerHandle);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后续直接走消息处理&lt;/span&gt;
        ctx.pipeline().addBefore(&quot;byteToBuf&quot;,&quot;wsPack&quot;&lt;span&gt;,wsPacketHandle);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码。将通用byteBuf编码成binaryWebSocketFrame.通过前面的编码器&lt;/span&gt;
        ctx.pipeline().addBefore(&quot;byteToBuf&quot;,&quot;bufToFrame&quot;&lt;span&gt;,bytebufToBinaryFrameHandle);


    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;wsPacketHandle   自定义处理器，将接收的&lt;/span&gt;BinaryWebSocketFrame消息转成byte[]供protocolResolve处理。
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;bytebufToBinaryFrameHandle  自定义处理器，将需要发送的byte转成&lt;/span&gt;BinaryWebSocketFrame供websocket的编码器处理。
&lt;/pre&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;详细代码请参考&lt;a href=&quot;https://gitee.com/huangxinyu/BC-NETTYGO&quot; target=&quot;_blank&quot;&gt;nafos-network&lt;/a&gt;: https://gitee.com/huangxinyu/BC-NETTYGO&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;http://thyrsi.com/t6/394/1540300684x-1404795810.png&quot; alt=&quot;&quot; width=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;h3 align=&quot;center&quot;&gt;NAFOS&lt;/h3&gt;
&lt;p align=&quot;center&quot;&gt;一个基于netty的轻量级高性能服务端框架。 &lt;/p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;nafos是一个基于netty的高性能服务器框架，其目的在于易上手，易扩展，让开发人员更致力于业务开发。 在前后端分离的web架构上，或者APP,手游，nafos都是一个很不错的选择。&lt;/p&gt;
&lt;p&gt;除此之外，sample中也给出了超简单的扩展方案，使得nafos在分布式扩展上能更胜一筹。&lt;/p&gt;
&lt;h2&gt;文档&lt;/h2&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;&lt;li&gt;1、简单易用：通过简单的配置文件即可建立完善的启动方案，然后就可以开心的关注业务代码了；&lt;/li&gt;
&lt;li&gt;2、串行设计 ：单用户的所有请求都是串行进行，完美解决单用户并发问题，减少锁的使用；&lt;/li&gt;
&lt;li&gt;3、高性能：网络层采用netty作为中间件，同等配置及优化条件下，相比tomcat性能可提升一倍；&lt;/li&gt;
&lt;li&gt;4、易扩展：整合了springBoot，可完美支持spring大家族系列；&lt;/li&gt;
&lt;li&gt;5、强兼容: 可单机同时支持HTTP,TCP,websocket等服务，小规模应用下不用多开占用资源；&lt;/li&gt;
&lt;li&gt;6、工具类丰富：封装所有开发中常见工具类可直接调用；&lt;/li&gt;
&lt;li&gt;7、房间策略：封装常见游戏的房间策略，开房，比赛，聊天可直接调用，无需多写；&lt;/li&gt;
&lt;li&gt;8、模块化：多个模块之间相互解耦，喜欢哪个用哪个，不喜欢直接丢弃。&lt;/li&gt;
&lt;li&gt;9、脚本支持：内有现成的shell脚本可以直接使用，开关机，数据库备份等；&lt;/li&gt;
&lt;li&gt;10、自带分布式限流器，有IP策略和总流量策略等漏桶限流，抵御攻击。&lt;/li&gt;
&lt;li&gt;11、丰富教程：除了详细文档外，在sample模块中还有多模块使用案例，开发无忧~&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Wed, 31 Oct 2018 05:26:00 +0000</pubDate>
<dc:creator>望星辰大海</dc:creator>
<og:description>前言： 软件通信七层结构（osi模型）中由协议套协议最终组成最高级应用层协议（http等等），下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tohxyblog/p/9882478.html</dc:identifier>
</item>
</channel>
</rss>