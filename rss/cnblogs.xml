<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C语言实现简易2048小游戏 - Andrew_qian</title>
<link>http://www.cnblogs.com/qsyll0916/p/8447481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qsyll0916/p/8447481.html</guid>
<description>&lt;p&gt;一直很喜欢玩这个小游戏，简单的游戏中包含运气与思考与策略，喜欢这种简约又不失内涵的游戏风格。于是萌生了用C语言实现一下的想法。&lt;/p&gt;
&lt;p&gt;具体代码是模仿这个：&lt;a href=&quot;https://www.cnblogs.com/judgeyoung/p/3760515.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/judgeyoung/p/3760515.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;博主分析的都很到位，很多算法技巧都值得借鉴，C语言实现2048的主要思想已经在那个博客中详细的分析了，但是我觉得在博主的代码中还是有很多很好的思想是值得我借鉴学习的。&lt;/p&gt;
&lt;p&gt;比如这个生成随机数，顺便规定随机数的概率：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 生成随机数 函数定义 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; add_rand_num()
{
    srand(time(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = rand() % get_null_count();&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确定在何处空位置生成随机数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;4&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (board[i][j] == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; n-- == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 定位待生成的位置 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            {
                board[i][j] &lt;/span&gt;= (rand() % &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;2&lt;/span&gt; : &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确定生成何值，设定生成2的概率是4的概率的两倍 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 首先是 srand() 函数，他是一个随机数发生器的初始化函数。&lt;/p&gt;
&lt;p&gt;原型为：void srand(unsigned seed)&lt;/p&gt;
&lt;p&gt;用法是：程序员需要为这个函数提供一个随机数的种子：srand（随机数），如果使用相同的种子，那么后面的rand（）函数就会每次运行都是生成一样的随机数，即伪随机数。&lt;/p&gt;
&lt;p&gt;如：srand（1），直接用1来初始化种子，后面都是一样的随机数 。&lt;/p&gt;
&lt;p&gt;为了生成真正的随机数，我们一般采用系统时间来作为随机数初始化函数的种子。使用time（）函数来获取系统时间：&lt;/p&gt;
&lt;p&gt;它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数，然后将time_t型数据转化为(unsigned)型再传给srand函数，即： srand((unsigned) time(&amp;amp;t));&lt;/p&gt;
&lt;p&gt;还有一个经常用法，不需要定义 time_t 型 t 变量,即： srand((unsigned) time(NULL)); 直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的 t 数据。&lt;/p&gt;
&lt;p&gt;第二句是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; n = rand() % get_null_count();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在空余格中生成一个随机位置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用随机数对剩余空格数目进行取余运算，得到小于剩余格数的随机数。&lt;/p&gt;
&lt;p&gt;最后一句是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (board[i][j] == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; n-- == &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机位置处为0时填入一个随机数，但是如果随机位置处不为0呢？&lt;/span&gt;
&lt;span&gt;            {
                board[i][j] &lt;/span&gt;= (rand() % &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;2&lt;/span&gt; : &lt;span&gt;4&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在随机生成的空白格处填上一个2或者4，利用三项表达式对3取余，得到1/3，2/3的概率。&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束函数&lt;/span&gt;
            }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是在格子中没有数字时并且在刚刚生成的随机数的位置处，填入一个数字2或者4，并且为了降低难度，固定生成2是生成4的概率的2倍。&lt;/p&gt;
&lt;p&gt;利用三目运算符和对3取余的特点，产生概率分布。&lt;/p&gt;
&lt;p&gt;rand（）随机数对3取余只有可能是0/1/2，而在三目运算符中，当第一个数不为0时，运算符的值就取中间那个数的值，否则取最后一个数。所以取2的可能性为2/3，取4的可能性为1/3，这样就产生了不同的概率。但是这种方法只能产生  n:1 的概率分布，如果要产生      4:5,    8:17  的概率时，这种方法就不在适用了。&lt;/p&gt;
&lt;p&gt;上面这些代码还是有一些漏洞的，因为游戏刚开始是需要有两个数的，一个数必为2，另一个数就是上面生成的那个数，但是如果第二个数恰好生成的随机位置处是第一个数，那么根据这儿代码，就什么也没有执行，最终导致出现刚开始界面就一个数字的情况。&lt;/p&gt;
&lt;p&gt;解决办法就是在刚开始生成的两个数的程序中不使用  get_null_count（），而是获取第一个数字2的准确位置，然后生成第二个数字时，在排除第一个数字的地方生成数字即可。&lt;/p&gt;
&lt;p&gt;程序的主体就是数字的上下左右移动，go_left（）和其他三个函数，他们的思想都是相似的，就拿go_left（）函数来分析一下：&lt;/p&gt;
&lt;p&gt;按照原作者的思想，移动的时候一共有三种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1083998/201802/1083998-20180219130431611-492713948.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果相邻的两个数一样，就合并，数字相加。&lt;/p&gt;
&lt;p&gt;如果相邻的数字不一样，简单的说，又分两种情况：数字需要移动和不需要移动。&lt;/p&gt;
&lt;p&gt;具体代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;左移函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; go_left(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;i遍历行下标&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;j为列下标，k为待比较项列下标，循环进入时k &amp;lt; j&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;,k = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;4&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;找出k后面第一个不为0的项&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (board[i][j] &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;情况1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (board[i][j] == board[i][k])        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个数相同就合并&lt;/span&gt;
&lt;span&gt;                {
                    scoer &lt;/span&gt;+= board[i][k++] &amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    board[i][j] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    if_need_add_num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并之后需要生成随机数和刷新界面&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;情况2&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (board[i][k] == &lt;span&gt;0&lt;/span&gt;)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k项为空，则把j格移到k格&lt;/span&gt;
&lt;span&gt;                {
                    board[i][k] &lt;/span&gt;=&lt;span&gt; board[i][j];
                    board[i][j] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    if_need_add_num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;情况3&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;else&lt;/span&gt;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;k项不为空，也不等于j项，此时两个都不需要动，只是下标需要变换&lt;/span&gt;
                    board[i][++k] = board[i][j];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把j项移到k项的紧挨着的右边&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (j != k)                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动过之后不相等说明之前他们不是紧挨着的&lt;/span&gt;
&lt;span&gt;                {
                    board[i][j] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    if_need_add_num &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时移动虽然没有消去一个数，但是也要添加一个随机数出来&lt;/span&gt;
&lt;span&gt;                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目完整代码在原博客中已经给出。&lt;/p&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1083998/201802/1083998-20180219131919423-1944249600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Feb 2018 05:21:00 +0000</pubDate>
<dc:creator>Andrew_qian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qsyll0916/p/8447481.html</dc:identifier>
</item>
<item>
<title>XGoServer  一个基础性、模块完整且安全可靠的服务端框架 - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/8453685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/8453685.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2179487179487&quot;&gt;
&lt;p&gt;腾讯云专栏： &lt;a href=&quot;https://cloud.tencent.com/developer/user/1148436/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/1148436/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;一个基础性、模块完整且安全可靠的服务端框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/af913337456/XGoServer&quot;&gt;https://github.com/af913337456/XGoServer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一版介绍文章：&lt;a href=&quot;https://juejin.im/post/5a76ce2b6fb9a0633a70d87f&quot;&gt;基于 xorm 的服务端框架 XGoServer&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;新添加模块&quot;&gt;新添加模块&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;自定义路由接口&lt;/li&gt;
&lt;li&gt;Token模块，&lt;code&gt;jwt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加解密模块，&lt;code&gt;cipher-AES&lt;/code&gt;，可自行拓展其他&lt;/li&gt;
&lt;li&gt;各模块对应的单元测试例子&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;共具备的&quot;&gt;共具备的&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;自定义路由接口&lt;/li&gt;
&lt;li&gt;Token模块，&lt;code&gt;jwt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加解密模块，&lt;code&gt;cipher-AES&lt;/code&gt;，可自行拓展其他&lt;/li&gt;
&lt;li&gt;日志模块，&lt;code&gt;alecthomas/log4go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;路由模块，&lt;code&gt;gorilla/mux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;硬存储 / 软存储 采用 &lt;code&gt;xorm&lt;/code&gt; 框架&lt;/li&gt;
&lt;li&gt;服务端通用的输出数据结构的整合，例如 json&lt;/li&gt;
&lt;li&gt;各模块对应的单元测试例子&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;自定义路由接口&quot;&gt;自定义路由接口&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;requireToken&lt;/code&gt; 标识该路由是否需要 &lt;code&gt;token&lt;/code&gt; 验证&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TokenData&lt;/code&gt; 是我们要组合到 &lt;code&gt;token&lt;/code&gt; 里面的数据结构 &lt;code&gt;struct&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type Context struct {
    TokenData TokenData
    TokenStr  string    `json:&quot;tokenStr&quot;`
    IpAddress string    `json:&quot;ipAddress&quot;`  // client 的 ip
    RoutePath string    `json:&quot;routePath&quot;`
}
type XHandler struct {
    handleFunc   func(*Context, http.ResponseWriter, *http.Request)
    requireToken bool
}
func (x XHandler) ServeHTTP(w http.ResponseWriter, r *http.Request)  {
    tokenStr := r.Header.Get(TokenAuth)
    c := &amp;amp;Context{}
    c.IpAddress = util.GetIpAddress(r)
    c.RoutePath = r.URL.Path
    if x.requireToken {
        tokenData,err := ParseToken(tokenStr) // 使用 token 模块进行解析
        if err != nil {
            util.RenderJson(w,util.GetCommonErr(err.Error()))
            return
        }
        c.TokenData = *tokenData
        c.TokenStr  = tokenStr
        // util.RenderJson(w,c)
        x.handleFunc(c,w,r)
        return
    }
    // 不需要 token
    util.LogInterface(c)
    x.handleFunc(c,w,r)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用法&quot;&gt;用法&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;router.Handle(&quot;/get1&quot;,&lt;code&gt;core.ApiNormalHandler(getToken)&lt;/code&gt;).Methods(&quot;GET&quot;)&lt;/li&gt;
&lt;li&gt;router.Handle(&quot;/get2&quot;,&lt;code&gt;core.ApiRequestTokenHandler(handleToken)&lt;/code&gt;).Methods(&quot;GET&quot;)&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;搭配使用：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;router.Handle(&quot;/getToken&quot;,core.ApiNormalHandler(getToken)).Methods(&quot;GET&quot;)
router.Handle(&quot;/handleToken&quot;,core.ApiRequestTokenHandler(handleToken)).Methods(&quot;GET&quot;)
router.HandleFunc(&quot;/enc&quot;,encOutput).Methods(&quot;GET&quot;)
router.HandleFunc(&quot;/dec&quot;,decOutput).Methods(&quot;POST&quot;)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;直接输出一条 json 给客户端&lt;/li&gt;
&lt;li&gt;登陆成功生成 token 返回&lt;/li&gt;
&lt;li&gt;直接输出解析后的 Context&lt;/li&gt;
&lt;li&gt;加密输出&lt;/li&gt;
&lt;li&gt;与数据库交互 ----- &lt;code&gt;important&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;直接输出一条-json-给客户端&quot;&gt;直接输出一条 json 给客户端&lt;/h4&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func main()  {
    router := new (mux.Router)
    router.HandleFunc(&quot;/&quot;,test2).Methods(&quot;GET&quot;)
    core.HttpListen(router)
}
func test2(w http.ResponseWriter,r *http.Request)  {
    // 非常简单的例子, 操作放在内部 , 可以使用 request 来获取自己的参数，再直接组织输出
    core.HandlerMapWithOutputJson(w, func() map[string]interface{} {
        m :=  map[string]interface{}{}
        m[&quot;msg&quot;] = &quot;blow me a kiss&quot;
        return m
    })
}
// 结果 ： {&quot;msg&quot;:&quot;blow me a kiss&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;登陆成功生成-token-返回&quot;&gt;登陆成功生成 token 返回&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;token&lt;/code&gt; 是具备过期时间的，皆可自定义&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func getToken(c *core.Context, w http.ResponseWriter, r *http.Request)  {
    core.HandlerMapWithOutputJson(w, func() map[string]interface{} {
        tokenStr,err := core.BuildDefaultToken(func(tokenData *core.TokenData) {
            tokenData.UserId = &quot;123456&quot;  // 用户 id
            tokenData.Roles  = &quot;normal&quot;  // 用户角色
        })
        if err != nil {
            return util.GetCommonErr(err.Error())
        }
        return util.GetCommonSuccess(tokenStr)
    })
}
结果：
{
    &quot;msg&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiMTIzNDU2Iiwicm9sZXMiOiJub3JtYWwiLCJwcm9wcyI6bnVsbCwiZXhwIjoxNTE5MDA2Njg4LCJpYXQiOjE1MTkwMDY2Mjh9.NsBsQ3xpOJNZUXO5Dc-Yk4p4m6p4EeDWgEfc5BaNKd4&quot;,
    &quot;ret&quot;: &quot;success&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;直接输出解析后的-context&quot;&gt;直接输出解析后的 Context&lt;/h4&gt;
&lt;p&gt;tokenStr 是 Context 一变量&lt;/p&gt;
&lt;p&gt;handleToken 方法对于的是 &lt;code&gt;ApiRequestTokenHandler&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func handleToken(c *core.Context, w http.ResponseWriter, r *http.Request)  {
    util.RenderJson(w,context)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;输出加密的数据&quot;&gt;输出加密的数据&lt;/h4&gt;
&lt;p&gt;tokenStr 是 Context 一变量&lt;/p&gt;
&lt;p&gt;handleToken 方法对于的是 &lt;code&gt;ApiRequestTokenHandler&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type IEncrypt interface {
    AesEncrypt(origData, key []byte) ([]byte, error)   // 加密
    AesDecrypt(encrypted, key []byte) ([]byte, error)  // 解密
}
// 加密输出
func encOutput(w http.ResponseWriter, r *http.Request)  {
    core.HandlerMapWithOutputJson(w, func() map[string]interface{} {
        d := &quot;狗年平安&quot;
        aes := encrypt.DefaultAES{}
        return util.GetCommonSuccess(aes.AesEncryptStr(d))
    })
}
输出：
{
    &quot;msg&quot;: &quot;\ufffd\u0002\ufffd\u001eu\ufffd\u001c\ufffd\u0013m\ufffdM\\\ufffd\ufffd\u0011&quot;,
    &quot;ret&quot;: &quot;success&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;与数据库交互&quot;&gt;与数据库交互&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; test3(w http.ResponseWriter,r *http.Request)  {
    core.HandlerMapWithOutputJson(w, &lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{} {
        &lt;span class=&quot;co&quot;&gt;// 插入一条评论&lt;/span&gt;
        item := &amp;amp;model.Comment{
            Id  :util.NewId(),         &lt;span class=&quot;co&quot;&gt;// 评论 id&lt;/span&gt;
            UserId  :&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;,             &lt;span class=&quot;co&quot;&gt;// 评论人 id&lt;/span&gt;
            Name    :&lt;span class=&quot;st&quot;&gt;&quot;LinGuanHong&quot;&lt;/span&gt;,        &lt;span class=&quot;co&quot;&gt;// 评论人名称&lt;/span&gt;
            Content :&lt;span class=&quot;st&quot;&gt;&quot;hello word&quot;&lt;/span&gt;,         &lt;span class=&quot;co&quot;&gt;// 评论内容&lt;/span&gt;
        }
        affect,_ := core.Engine.Insert(item)  &lt;span class=&quot;co&quot;&gt;// 执行插入，传入 struct 引用&lt;/span&gt;
        m :=  &lt;span class=&quot;kw&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;dt&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt;{}{}
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; affect &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; {
            m[&lt;span class=&quot;st&quot;&gt;&quot;ret&quot;&lt;/span&gt;] = &lt;span class=&quot;st&quot;&gt;&quot;insert success&quot;&lt;/span&gt;
            comments := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;([]model.Comment, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            core.Engine.Find(&amp;amp;comments)   &lt;span class=&quot;co&quot;&gt;// select 出来，获取所有评论输出&lt;/span&gt;
            m[&lt;span class=&quot;st&quot;&gt;&quot;msg&quot;&lt;/span&gt;] = comments
        }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;{
            m[&lt;span class=&quot;st&quot;&gt;&quot;ret&quot;&lt;/span&gt;] = &lt;span class=&quot;st&quot;&gt;&quot;insert failed&quot;&lt;/span&gt;
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; m
    })
}

输出的结果是：
{
  &lt;span class=&quot;st&quot;&gt;&quot;msg&quot;&lt;/span&gt;: [
    {
      &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;1kubpgh9pprrucy11e456fyytw&quot;&lt;/span&gt;,
      &lt;span class=&quot;st&quot;&gt;&quot;UserId&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;,
      &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;LinGuanHong&quot;&lt;/span&gt;,
      &lt;span class=&quot;st&quot;&gt;&quot;content&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;hello word&quot;&lt;/span&gt;
    }
  ],
  &lt;span class=&quot;st&quot;&gt;&quot;ret&quot;&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;insert success&quot;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;上述的功能结合使用便可做到牢固的安全性此外可以再结合-https-级别的路由使用&quot;&gt;上述的功能结合使用，便可做到牢固的安全性。此外，可以再结合 https 级别的路由使用。&lt;/h3&gt;
</description>
<pubDate>Mon, 19 Feb 2018 04:55:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/8453685.html</dc:identifier>
</item>
<item>
<title>线性一致性与全序广播------《Designing Data-Intensive Applications》读书笔记12 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/8453659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/8453659.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;上一篇聊了聊构建分布式系统所面临的困难，这篇将着重讨论构建容错分布式系统的算法与协议。构建容错系统的最佳方法是使用通用抽象，允许应用程序忽略分布式系统中的一些问题。本篇我们先聊一聊线性一致性，以及与线性一致性有关的技术，后续需要了解的分布式协调服务，如：ZooKeeper等，都是基于分布式系统的线性一致性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;更强的一致性&quot;&gt;1.更强的一致性&lt;/h3&gt;
&lt;p&gt;大多数分布式数据库至少提供了&lt;strong&gt;最终一致性&lt;/strong&gt;，这意味着如果停止对数据库的写操作并等待一段时间，最终所有读请求将返回相同的值。但是，这是一个非常弱的一致性保证，所谓的一段时间并不确定。如果写入一个值，然后立即读取它，就不能保证读取到刚才写入的值。&lt;/p&gt;
&lt;p&gt;最终一致性的模型对于应用程序开发人员来说是个大烦恼，当使用只提供弱一致性的数据库时，开发人员需要意识到它的问题，数据库可能会有很微妙的错误，因为应用程序可能大部分时间都工作得很好。而当系统中有故障（例如网络中断）或高并发性时，最终一致性的数据模型将会暴露很多问题。所以数据系统可以选择提供的更强的一致性模型,但是又会引入新的Trade-off:&lt;strong&gt;有更强一致性的系统虽然更容易正确使用，但是它可能比弱一致性的系统的性能更差或容错性更低，我们需要更好的理解它并且选择最适合需求的数据模型。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;线性一致性&quot;&gt;线性一致性&lt;/h4&gt;
&lt;p&gt;线性一致性的思想很简单，我们用下面两幅图来说明：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-edbb4d69d3798733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;并发读写引起的不确定性&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-d426b5d3e3b3109a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;线性一致性：任何一个读取返回了新值之后，所有后续读取也必须返回新值&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一个线性系统之中，一定会有某个时间点（开始和结束的写操作之间），x的值从0变成了1。因此，如果一个客户端的读取x时返回了新值1，所有后续的读取也必须返回新的值。&lt;/p&gt;
&lt;h5 id=&quot;线性化与串行化&quot;&gt;线性化与串行化&lt;/h5&gt;
&lt;p&gt;线性化与串行化不同，它不构成事务。因此不能完全保证并发写的安全性。数据库可以同时提供串行化和线性化，如两阶段锁便是可以同时提供串行化与线性化，而序列化的快照隔离不是线性化的。&lt;/p&gt;
&lt;h4 id=&quot;线性一致性可以解决什么问题&quot;&gt;线性一致性可以解决什么问题？&lt;/h4&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;分布式锁和Leader选举&lt;br/&gt;单Leader的系统需要确保只有一个Leader，多个Leader会导致脑裂的发生。而Leader选举的本质是锁的争用，每个节点试图获取锁，获取成功的节点成为Leader。&lt;strong&gt;而无论如何，这把锁必须是线性化：所有节点都必须同意哪个节点拥有锁，成为Leader&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;唯一性约束&lt;br/&gt;唯一性约束在数据库中很常见：例如，用户名或电子邮件地址必须唯一地标识一个用户，而在文件存储服务中，不能有两个具有相同路径和文件名的文件。如果你想为数据写入执行这一约束（例如，如果两人试图同时创建一个用户或一个具有相同名称的文件，其中将返回一个错误），你需要线性化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;如何实现线性化系统&quot;&gt;如何实现线性化系统？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;线性化意味着：如同一个单拷贝的数据，并对其所有的操作都是原子的。&lt;/strong&gt;最简单的答案就是真的只使用一个单一的数据复制。这种方式显然就失去了容错性，单一节点出现异常则系统将无法访问。而使系统容错的最常用方法是使用副本技术：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;单Leader多Follower机制&lt;br/&gt;在单Leader多Follower机制之中，Leader拥有主副本，Follower在其他节点上维护数据的备份副本。可以选择从Leader上读，或同步更新的Follower，可以在这个基础之上实现线性化系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一致性算法&lt;br/&gt;通过协商一致性协议算法可以防止脑裂和读取过期数据，通过一致性算法可以实现核心数据线性化的安全存储。这是ZooKeeper与Chubby等分布式协调服务的基础算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cap理论与一致性的代价&quot;&gt;CAP理论与一致性的代价&lt;/h4&gt;
&lt;p&gt;Eric Brewer在2000年提出CAP理论，简而言之便是：&lt;strong&gt;数据系统必须在一致性、可用性、分区容忍性的三角关系之中有所权衡，任何系统没有办法同时满足三种特性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以使用线性化的一致性自然会需要在可用性上做一些妥协， 在单Leader多Follower机制之下，需要满足线性化一致性的写入和读取的客户端必须连接到Leader。如果Leader产生中断，仍然可以读取Follower的数据，但此时就无法保证线性化的要求了。&lt;/p&gt;
&lt;h3 id=&quot;全序广播&quot;&gt;2.全序广播&lt;/h3&gt;
&lt;p&gt;上文已经提到过，可以通过单Leader多Follower机制与一致性算法来实现一个线性化的系统，但是，这里还有一个很重要的内容我们需要探讨：&lt;strong&gt;全序广播&lt;/strong&gt;。&lt;br/&gt;不过先不要着急，咱们先再聊一聊分布式系统之中的时序：&lt;/p&gt;
&lt;h4 id=&quot;lamport时间戳&quot;&gt;Lamport时间戳&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Lamport时间戳&lt;/strong&gt;是生成因果关系的序列号的一种方法，我们可以通过它理清分布式系统之中操作的顺序，Leslie Lamport 在1978年提出。Lamport时间戳的实现很简单，每个节点有一个唯一计数器标识符，并且每个节点都保存它的计数器。两个节点有时可能具有相同的计数器值，但在计数器值之中都包含节点id，所以每个计数器值都可以认为是唯一的时间戳。&lt;/p&gt;
&lt;p&gt;Lamport时间戳没有确切的物理时间，但它可以分布式系统之中的事件排序：&lt;strong&gt;存在两个时间戳，一个更大计数器的时间戳是更新的值；如果计数器的值是相同的，一个更大的节点ID是更大的时间戳。&lt;/strong&gt;下图展示了Lamport时间戳的工作原理，它能够符合分布式系统之中的因果关系：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8552201-bb89a445e7b7c900.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Lamport时间戳排序能够排序出因果关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是从Lamport时间戳的总顺序来看，无法判断两个操作是并发的，还是它们是因果相关的。虽然Lamport时间戳能够确认操作的因果关系，但是在分布式系统之中仍然存在一些问题：&lt;br/&gt;请考虑一个系统，该系统需要确保用户名唯一标识用户帐户。如果两个用户同时尝试创建具有相同用户名的帐户，则其中一个应该成功，另一个应该失败。显然，如果两个相同的用户名的账户创建，选择具有较低的时间戳的操作成功，因为Lamport时间戳是完全有序的，这种比较是有效的。但是为了确保没有其他节点在同时在较早的时间创建帐户，所以节点不得不与其他每个节点通信进行确认。如果出现网络问题，其他节点中的一个已经失效或无法到达，则系统也将失效。&lt;/p&gt;
&lt;p&gt;Lamport时间戳的问题在于：需要收集所有操作之后，操作的总顺序才会出现。如果另一个节点有其他操作，在不知道的情况下，无法构造操作的最终顺序。&lt;/p&gt;
&lt;h4 id=&quot;全序广播-1&quot;&gt;全序广播&lt;/h4&gt;
&lt;p&gt;全序广播的机制是使用：&lt;strong&gt;通过单Leader多Follower机制，在Leader节点上对所有操作进行排序，从而决定了整个操作顺序，并将操作顺序进行广播。&lt;/strong&gt;全序广播可以保证全局知晓信息，而解决Lamport时间戳面临的问题。但是全序广播同样要解决这样几个问题：如果吞吐量大于单Leader的处理量，那么如何扩展系统，以及出现Leader失效的情况，如何进行故障转移。&lt;/p&gt;
&lt;p&gt;全序广播要求满足如下两个属性总是被满足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可靠的交付,没有消息丢失：如果消息被传递到一个节点，它将被传递给所有节点。&lt;/li&gt;
&lt;li&gt;完全有序传递，消息以相同的顺序传递给每个节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个正确的全序广播算法必须保证节点和网络故障时的可靠性和有序性。一旦出现网路分化的现象，算法可以保持重试，仍然保持信息的有序性。全序广播对于分布式系统来说有十分重要的意义：如果每个消息表示对数据库的写入，并且每个副本以相同的顺序处理相同的写入，则副本将保持彼此一致，而各个节点的状态机也能够保持一致，可以通过这样的方式来实现状态机复制。&lt;/p&gt;
&lt;h3 id=&quot;通过全序广播实现线性化一致性&quot;&gt;3.通过全序广播实现线性化一致性&lt;/h3&gt;
&lt;p&gt;全序广播是异步的：消息保证以固定的顺序可靠地传递，但不能保证何时传递消息（因此存在节点可能落后于其他节点）。而线性化一致性能够保证：每次读操作能够读到最新值的写入。我们可以依托于全序广播，在存储上实现线性化一致性：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1.将消息append到日志中，添加要声明的用户名。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.节点通过内存之中的状态机检查，如果该用户名的第一条消息，则用户名写入成功。否则，终止该操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于全序广播保证了，消息是以相同的顺序传递给所有节点，假设存在并发写入，所有节点都会达成共识，第一个写入用户名的消息。虽然全序广播可以保证程序的线性写入，但是假设进行读操作的节点却不能保证线性读取，因为消息传递的延迟性，所以读操作的结果可能是过时的。&lt;/p&gt;
&lt;p&gt;当然这里可以通过返回最新日志消息的位置，通过查询位置，等待所有条目需要读取的条目被写入，再进行读操作，便能够达到读操作的线性一致性。（&lt;strong&gt;在ZooKeeper中通过sync()操作实现&lt;/strong&gt;），或者可以通过强制读取Leader节点的副，显然Leader节点上的数据一定是最新的结果。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通过全序广播的线性一致性，我们已经可以实现一个分布式系统的的协调服务了。下一篇将聊一聊分布式系统之中的一致性协议，也是分布式系统最核心的概念，我们怎么样能够让分布式的节点达成一致性，难者不会，会者不难，我们下一篇见。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 04:19:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/8453659.html</dc:identifier>
</item>
<item>
<title>汽车之家店铺数据抓取 DotnetSpider实战[一] - FunnyBoy</title>
<link>http://www.cnblogs.com/FunnyBoy/p/8453338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FunnyBoy/p/8453338.html</guid>
<description>&lt;p&gt;春节也不能闲着，一直想学一下爬虫怎么玩，网上搜了一大堆，大多都是Python的，大家也比较活跃，文章也比较多，找了一圈，发现园子里面有个大神开发了一个DotNetSpider的开源库，很值得庆幸的，该库也支持.Net Core，于是乘着春节的空档研究一下整个开源项目，顺便实战一下。目前互联网汽车行业十分火热，淘车，人人车，易车，汽车之家，所以我选取了汽车之家，芒果汽车这个店铺，对数据进行抓取。&lt;/p&gt;

&lt;p&gt;VS2017+.Net Core2.x+DotNetSpider+Win10&lt;/p&gt;

&lt;h2&gt;3.1新建.Net Core项目&lt;/h2&gt;
&lt;p&gt;新建一个.Net Core 控制台应用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180218225331921-1180131976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2通过Nuget添加DotNetSpider类库&lt;/h2&gt;
&lt;p&gt;搜索DotnetSpider，添加这两个库就行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180218225813421-5930575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 3.3分析需要抓取的网页地址&lt;/h2&gt;
&lt;p&gt;打开该网页https://store.mall.autohome.com.cn/83106681.html，红框区域就是我们要抓取的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180218230247093-1044832121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过Chrome的开发工具的Network抓取到这些信息的接口，在里面可以很清楚的知道HTTP请求中所有的数据，包括Header，Post参数等等，其实我们把就是模拟一个HTTP请求，加上对HTML的一个解析就可以将数据解析出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180218230552983-650575194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数page就是页码，我们只需要修改page的值就可以获取指定页码的数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180218230621968-759260400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;返回结果就是列表页的HTML。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180218230728624-2143620864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 3.4创建存储实体类AutoHomeShopListEntity&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AutoHomeShopListEntity : SpiderEntity 
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DetailUrl { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CarImg { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DelPrice { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Tip { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; BuyNum { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Title}|{Price}|{DelPrice}|{BuyNum}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.5创建AutoHomeProcessor&lt;/h2&gt;
&lt;p&gt;用于对于获取到的HTML进行解析并且保存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AutoHomeProcessor : BasePageProcessor
        {
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Handle(Page page)
            {
                List&lt;/span&gt;&amp;lt;AutoHomeShopListEntity&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;AutoHomeShopListEntity&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelHtmlList = page.Selectable.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//div[@class='list']/ul[@class='fn-clear']/li[@class='carbox']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Nodes();
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; modelHtml &lt;span&gt;in&lt;/span&gt;&lt;span&gt; modelHtmlList)
                {
                    AutoHomeShopListEntity entity &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutoHomeShopListEntity();
                    entity.DetailUrl &lt;/span&gt;= modelHtml.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//a/@href&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetValue();
                    entity.CarImg &lt;/span&gt;= modelHtml.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//a/div[@class='carbox-carimg']/img/@src&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetValue();
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; price = modelHtml.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//a/div[@class='carbox-info']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetValue(DotnetSpider.Core.Selector.ValueOption.InnerText).Trim().Replace(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Empty).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Empty).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;.Empty).TrimStart(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;¥&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).Split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;¥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (price.Length &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    {
                        entity.Price &lt;/span&gt;= price[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                        entity.DelPrice &lt;/span&gt;= price[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        entity.Price &lt;/span&gt;= price[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                        entity.DelPrice &lt;/span&gt;= price[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    }
                    entity.Title &lt;/span&gt;= modelHtml.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//a/div[@class='carbox-title']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetValue();
                    entity.Tip &lt;/span&gt;= modelHtml.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//a/div[@class='carbox-tip']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetValue();
                    entity.BuyNum &lt;/span&gt;= modelHtml.XPath(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.//a/div[@class='carbox-number']/span&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetValue();
                    list.Add(entity);
                }
                page.AddResultItem(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CarList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, list);
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.6创建AutoHomePipe&lt;/h2&gt;
&lt;p&gt;用于输出抓取到的结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AutoHomePipe : BasePipeline
        {

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Process(IEnumerable&amp;lt;ResultItems&amp;gt;&lt;span&gt; resultItems, ISpider spider)
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; resultItem &lt;span&gt;in&lt;/span&gt;&lt;span&gt; resultItems)
                {
                    Console.WriteLine((resultItem.Results[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CarList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; List&amp;lt;AutoHomeShopListEntity&amp;gt;&lt;span&gt;).Count);
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; (resultItem.Results[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CarList&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;as&lt;/span&gt; List&amp;lt;AutoHomeShopListEntity&amp;gt;&lt;span&gt;))
                    {
                        Console.WriteLine(item);
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.7创建Site&lt;/h2&gt;
&lt;p&gt;主要就是将HTTP的Header部信息放进去&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; site = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Site
            {
                CycleRetryTimes &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                SleepTime &lt;/span&gt;= &lt;span&gt;200&lt;/span&gt;&lt;span&gt;,
                Headers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
                {
                    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Accept&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html, */*; q=0.01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Referer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://store.mall.autohome.com.cn/83106681.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cache-Control&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no-cache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/x-www-form-urlencoded; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.167 Safari/537.36&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
                    


                }

            };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.8构造Request&lt;/h2&gt;
&lt;p&gt;因为我们所抓取到的接口必须用POST，如果是GET请求则这一部可以省略，参数就放在PostBody就行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            List&amp;lt;Request&amp;gt; resList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Request&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;33&lt;/span&gt;; i++&lt;span&gt;)
            {
                Request res &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Request();
                res.PostBody &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id=7&amp;amp;j=%7B%22createMan%22%3A%2218273159100%22%2C%22createTime%22%3A1518433690000%2C%22row%22%3A5%2C%22siteUserActivityListId%22%3A8553%2C%22siteUserPageRowModuleId%22%3A84959%2C%22topids%22%3A%22%22%2C%22wherePhase%22%3A%221%22%2C%22wherePreferential%22%3A%220%22%2C%22whereUsertype%22%3A%220%22%7D&amp;amp;page={i}&amp;amp;shopid=83106681&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                res.Url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://store.mall.autohome.com.cn/shop/ajaxsitemodlecontext.jtml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                res.Method &lt;/span&gt;=&lt;span&gt; System.Net.Http.HttpMethod.Post;

                resList.Add(res);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.9构造爬虫并且执行&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; spider = Spider.Create(site, &lt;span&gt;new&lt;/span&gt; QueueDuplicateRemovedScheduler(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutoHomeProcessor())
                .AddStartRequests(resList.ToArray())
                .AddPipeline(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutoHomePipe());
            spider.ThreadNum &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            spider.Run();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.10执行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180219110744080-783129574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我会将对商品的详情页数据（包括车型参数配置之类的）进行抓取，接口已经抓取到了，还在思考如果更加便捷获取到商品id，因为目前来看商品id是存储在页面的js全局变量中，抓取起来比较费劲。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/695198/201802/695198-20180219111708845-1280349250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;.Net 相对于别的语言感觉并不是那么活跃，DotnetSpider虽然时间不长，但是希望园子里面大伙都用起来，让他不断的发展，让我们的.Net能够更好的发展。&lt;/p&gt;
&lt;p&gt;第一次写博客，时间比较仓促，还有很多不足的地方，欢迎拍砖。&lt;/p&gt;
&lt;p&gt;祝大家新年快乐&lt;/p&gt;
&lt;p&gt;2018年2月19日&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 03:20:00 +0000</pubDate>
<dc:creator>FunnyBoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FunnyBoy/p/8453338.html</dc:identifier>
</item>
<item>
<title>新版Azure Automation Account 浅析（三） --- 用Runbook管理AAD Application Key - MeowMeow</title>
<link>http://www.cnblogs.com/meowmeow/p/8453567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meowmeow/p/8453567.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/meowmeow/p/8372207.html&quot;&gt;新版Azure Automation Account 浅析（三） --- 用Runbook&lt;/a&gt;&lt;/strong&gt;&lt;strong&gt;管理&lt;/strong&gt;&lt;strong&gt;AAD&lt;/strong&gt;&lt;strong&gt;应用的&lt;/strong&gt;&lt;strong&gt;Key&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前篇讲过有一个面向公众的Runbook库，社区和微软一直往其中加入新的Runbook，用户可以下载也可以在直接在Azure Portal中导入。这样大家都可以参考全世界范围内工程师怎样利用Runbook来解决工作中的难题，提高生产效率。&lt;a href=&quot;https://gallery.technet.microsoft.com/scriptcenter/site/search?f%5b0%5d.Type=RootCategory&amp;amp;f%5b0%5d.Value=WindowsAzure&amp;amp;f%5b1%5d.Type=SubCategory&amp;amp;f%5b1%5d.Value=WindowsAzure_automation&amp;amp;f%5b1%5d.Text=Automation&quot;&gt;https://gallery.technet.microsoft.com/scriptcenter/site/search?f[0].Type=RootCategory&amp;amp;f[0].Value=WindowsAzure&amp;amp;f[1].Type=SubCategory&amp;amp;f[1].Value=WindowsAzure_automation&amp;amp;f[1].Text=Automation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;所以呢，如果这一篇还是写用Runbook实现Azure 虚机自动开关机的话，估计就没人看了。正巧前段时间客户提了一个问题 ”为安全起见，在AzureAD注册应用时候会选择生成有效期为一年或者两年的key。 那能不能在key过期前2个月就自动发email提醒开发运维团队修改部署新key呢？每个应用在AD注册的时间不相同，要用人力来管理几十个应用的key的有效期不太现实”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219102829220-1142137660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个典型的用Runbook可以帮助简化工作流程提高运维效率的案例。我们以此为例来了解什么场景可以用runbook，怎么写runbook，怎么才能用好runbook。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;需求梳理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;做为公司Azure环境的运维团队，我需要一份自动生成的信息列表，其中包含在Azure AD注册的所有应用的key是不是在2个星期内，1个月内，2个月内即将过期的信息&lt;/li&gt;
&lt;li&gt;做为公司Azure环境的运维团队，我需要每星期都能收到email关于应用key过期最新状态的通知&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个Task的自动化可以分为2部分：&lt;/p&gt;
&lt;p&gt;第一部分是读取Azure AD内应用key信息，可以用Powershell AzureAD模块来获取，至于发送email 可以用powershell的SMTP 代码，在Runbook里有内嵌powershell的支持。&lt;/p&gt;
&lt;p&gt;另外一部分是这段代码必须可以每天固定时间段重复自动执行，用户不需要额外配置一台服务器来运行这段代码。 那Runbook的Schedules通过在portal的简单配置就可以实现这个需求&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在automation account里导入AzureAD模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219102949376-197637162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;在automation account里创建2个credential，一个是Azure AD的管理员登录所用credential，我们会用这个来获取AAD中应用的相关Key的信息。一个是发送key信息所用的email账号的credential，通常这是运维团队的team email信箱&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219103128564-1189882276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到在创建之后相关的密码都是不可见非明文的，安全上没有问题&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;创建一个名为 aadappkeymanagement的runbook， 首先代码需要读取我们在上一步创建的两个credential。 切记，这里需要用到的powershell 命令是 Get-AutomationPSCredential而不是Get-AzureRMAutomationCredential。后一个的用法我们下篇automation account的automation中涉及。代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$aadadmincredential = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aadadmin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

$opsteamemailcredential &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;opsteamemail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;$aadadmin&lt;/span&gt;=Get-AutomationPSCredential -&lt;span&gt;Name $aadadmincredential
    $opsteamemail&lt;/span&gt;=Get-AutomationPSCredential -&lt;span&gt;Name $opsteamemailcredential
 }
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!$aadadmin -&lt;span&gt;or $opsteamemail)
    {
        $ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Credential is not found.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; $ErrorMessage
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        Write&lt;/span&gt;-Error -&lt;span&gt;Message $_.Exception
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; $_.Exception
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　接着，我们连接Azure AD读取key的信息并且把在2个星期/1个月/2个月内即将过期的应用记录下来，存入各自的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Connect-AzureAD -Credential $aadadmin -&lt;span&gt;AzureEnvironmentName AzureChinaCloud

$2monthsresults &lt;/span&gt;=&lt;span&gt; @()
$1monthresults &lt;/span&gt;=&lt;span&gt; @()
$2weeksresults &lt;/span&gt;=&lt;span&gt; @()

&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;($AADapp &lt;span&gt;in&lt;/span&gt; Get-&lt;span&gt;AzureADApplication){

   $EndDate &lt;/span&gt;= (Get-AzureADApplicationPasswordCredential -&lt;span&gt;objectid $AADapp.objectid).Enddate
   $2monthsresults &lt;/span&gt;+= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + $AADapp.DisplayName)  | Where {$EndDate -lt $(&lt;span&gt;get&lt;/span&gt;-date).AddMonths(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)}
   $1monthresults &lt;/span&gt;+= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + $AADapp.DisplayName)  | Where {$EndDate -lt $(&lt;span&gt;get&lt;/span&gt;-date).AddMonths(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)}
   $2weeksresults &lt;/span&gt;+= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + $AADapp.DisplayName)  | Where {$EndDate -lt $(&lt;span&gt;get&lt;/span&gt;-date).Adddays(&lt;span&gt;14&lt;/span&gt;&lt;span&gt;)}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　最后把上一步获取的信息做一些格式化增强一下email的可读性，接着用smtpclient发送email。这里用的是O365的信箱做email发送，SMTP server是'smtp.office365.com'， 端口是587&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
$EmailBody =&lt;span&gt; @()

# Format the email body
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;META http-equiv=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; content=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=iso-8859-1&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; /&amp;gt;&amp;lt;TITLE&amp;gt;&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;BODY bgcolor=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;#FFFFFF&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; style=&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;font-size: Small; font-family: TAHOMA; color: #000000&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;P&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IT OPS Team &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;font face='arial' color='red'&amp;gt;The following applications' key will expire in two weeks.&amp;lt;/font&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$2weeksresults &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;font face='arial' color='red'&amp;gt;The following applications' key will expire in one month.&amp;lt;/font&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$1monthsresults&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;font face='arial' color='red'&amp;gt;The following applications' key will expire in two months.&amp;lt;/font&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$2monthsresults&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
$EmailBody &lt;/span&gt;+= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;


$SMTPClient &lt;/span&gt;= New-Object Net.Mail.SmtpClient(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.office365.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;587&lt;/span&gt;&lt;span&gt;)
$SMTPClient.EnableSsl &lt;/span&gt;= $&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
$SMTPClient.Credentials &lt;/span&gt;= New-&lt;span&gt;Object System.Net.NetworkCredential($opsteamemail.username , $opsteamemail.password);
$mail &lt;/span&gt;= New-Object Net.Mail.MailMessage($opsteamemail.username, $opsteamemail.username, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alert: some AAD application key will expire soon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, $EmailBody)
$mail.isBodyHtml &lt;/span&gt;= $&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
$SMTPClient.Send($mail)

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;把上述代码填写到Runbook后，我们接着看一下怎么用Runbook&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219103933626-387348813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;写完代码，点击Save。接下来需要测试一下我们的代码。按顺序点击Test Pane 和Start.&lt;/p&gt;
&lt;p&gt;Automation account的测试沙盒会运行刚刚保存的Runbook。我们的脚本里有发送email这一段，测试完检查一下信息，你会收到脚本发送的email。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219104025205-908150110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219104043205-233404794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;脚本里也可以加入debug输出信息，运行时测试窗口会显示这些信息。测试成功后，回到Runbook窗口，点击’Publish’. 我们的Runbook就正式发布了。发布之后任何对于代码的改动可以继续通过点击save-》test pane-》start进行测试而不影响已发布Runbook正常运行。有没有一丝testing和production感觉啊 ？而且还是Azure managed testing 环境哦。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;接下来我们开始部署Runbook的自动运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在发布好的Runbook主界面点击‘Schedule’创建一个北京时间每周一上午10:30运行runbook的Schedule。当然，也可以设置成每小时，每天或者每月的schedule&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219104123595-1898639349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;好了，接下来每周一上班时候运维团队就能收到email的通知，了解到AAD中application key是否将过期的汇总email了。有兴趣的同学还可以接着试一下用runbook自动更新即将过期的Key。&lt;/p&gt;
&lt;p&gt;另外，还可以在Automation account的job页面查看一下每次自动执行runbook是否成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1024893/201802/1024893-20180219105714314-1287288688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个automation account的runbook就是写完一段代码上传Azure配置好自动执行的Schedule，再没有必要为了运行运维脚本而单独维护一台甚至多台服务器了。而这个轻量级的无服务器化工具本身还集成了安全，源代码集成，多环境测试，生产环境rollback等多项功能。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 02:42:00 +0000</pubDate>
<dc:creator>MeowMeow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/meowmeow/p/8453567.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（2.12-2.18） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8453510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8453510.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · PowerShell 并行执行任务（sparkdev）· IT连创业系列：年终回顾录！（路过秋天）· 国外程序员陋习，写在农历狗年前（麦克*堂）· 一个开源的强类型客户端（.NET 中的 Open Fegin）— Rabbit Go（KAnts）· 万类之父——Object（OKev</description>
<pubDate>Mon, 19 Feb 2018 01:32:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8453510.html</dc:identifier>
</item>
<item>
<title>【深度学习】批归一化（Batch Normalization） - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8453498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8453498.html</guid>
<description>&lt;p&gt;BN是由Google于2015年提出，这是一个深度神经网络训练的技巧，它不仅可以加快了模型的收敛速度，而且更重要的是在一定程度缓解了深层网络中“梯度弥散”的问题，从而使得训练深层网络模型更加容易和稳定。所以目前BN已经成为几乎所有卷积神经网络的标配技巧了。&lt;/p&gt;
&lt;p&gt;从字面意思看来Batch Normalization（简称BN）就是对每一批数据进行归一化，确实如此，对于训练中某一个batch的数据{x1,x2,...,xn}，注意这个数据是可以输入也可以是网络中间的某一层输出。在BN出现之前，我们的归一化操作一般都在数据输入层，对输入的数据进行求均值以及求方差做归一化，但是BN的出现打破了这一个规定，我们可以在网络中任意一层进行归一化处理，因为我们现在所用的优化方法大多都是min-batch SGD，所以我们的归一化操作就成为Batch Normalization。&lt;/p&gt;
&lt;h2 id=&quot;我们为什么需要bn&quot;&gt;我们为什么需要BN？&lt;/h2&gt;
&lt;p&gt;我们知道网络一旦train起来，那么参数就要发生更新，除了输入层的数据外(因为输入层数据，我们已经人为的为每个样本归一化)，后面网络每一层的输入数据分布是一直在发生变化的，因为在训练的时候，前面层训练参数的更新将导致后面层输入数据分布的变化。以网络第二层为例：网络的第二层输入，是由第一层的参数和input计算得到的，而第一层的参数在整个训练过程中一直在变化，因此必然会引起后面每一层输入数据分布的改变。我们把网络中间层在训练过程中，数据分布的改变称之为：“Internal Covariate Shift”。BN的提出，就是要解决在训练过程中，中间层数据分布发生改变的情况。&lt;/p&gt;
&lt;h2 id=&quot;bn怎么做&quot;&gt;BN怎么做？&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084749642-1647361064.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，BN步骤主要分为4步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;求每一个训练批次数据的均值&lt;/li&gt;
&lt;li&gt;求每一个训练批次数据的方差&lt;/li&gt;
&lt;li&gt;使用求得的均值和方差对该批次的训练数据做归一化，获得0-1分布。其中&lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt;是为了避免除数为0时所使用的微小正数。&lt;/li&gt;
&lt;li&gt;尺度变换和偏移：将&lt;span class=&quot;math inline&quot;&gt;\(x_{i}\)&lt;/span&gt;乘以&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;调整数值大小，再加上&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;增加偏移后得到&lt;span class=&quot;math inline&quot;&gt;\(y_{i}\)&lt;/span&gt;，这里的&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;是尺度因子，&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;是平移因子。这一步是BN的精髓，由于归一化后的&lt;span class=&quot;math inline&quot;&gt;\(x_{i}\)&lt;/span&gt;基本会被限制在正态分布下，使得网络的表达能力下降。为解决该问题，我们引入两个新的参数：&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;。 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt;是在训练时网络自己学习得到的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;bn到底解决了什么&quot;&gt;BN到底解决了什么？&lt;/h2&gt;
&lt;p&gt;一个标准的归一化步骤就是减均值除方差，那这种归一化操作有什么作用呢？我们观察下图，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084810095-616879424.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084820533-1615172856.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;a中左图是没有经过任何处理的输入数据，曲线是sigmoid函数，如果数据在梯度很小的区域，那么学习率就会很慢甚至陷入长时间的停滞。减均值除方差后，数据就被移到中心区域如右图所示，对于大多数激活函数而言，这个区域的梯度都是最大的或者是有梯度的（比如ReLU），这可以看做是一种对抗梯度消失的有效手段。对于一层如此，如果对于每一层数据都那么做的话，数据的分布总是在随着变化敏感的区域，相当于不用考虑数据分布变化了，这样训练起来更有效率。&lt;/p&gt;
&lt;p&gt;那么为什么要有第4步，不是仅使用减均值除方差操作就能获得目的效果吗？我们思考一个问题，减均值除方差得到的分布是正态分布，我们能否认为正态分布就是最好或最能体现我们训练样本的特征分布呢？不能，比如数据本身就很不对称，或者激活函数未必是对方差为1的数据最好的效果，比如Sigmoid激活函数，在-1~1之间的梯度变化不大，那么非线性变换的作用就不能很好的体现，换言之就是，减均值除方差操作后可能会削弱网络的性能！针对该情况，在前面三步之后加入第4步完成真正的batch normalization。&lt;/p&gt;
&lt;p&gt;BN的本质就是利用优化变一下方差大小和均值位置，使得新的分布更切合数据的真实分布，保证模型的非线性表达能力。BN的极端的情况就是这两个参数等于mini-batch的均值和方差，那么经过batch normalization之后的数据和输入完全一样，当然一般的情况是不同的。&lt;/p&gt;
&lt;h2 id=&quot;预测时均值和方差怎么求&quot;&gt;预测时均值和方差怎么求？&lt;/h2&gt;
&lt;p&gt;在训练时，我们会对同一批的数据的均值和方差进行求解，进而进行归一化操作。但是对于预测时我们的均值和方差怎么求呢？比如我们预测单个样本时，那还怎么求均值和方法呀！其实是这种样子的，对于预测阶段时所使用的均值和方差，其实也是来源于训练集。比如我们在模型训练时我们就记录下每个batch下的均值和方差，待训练完毕后，我们求整个训练样本的均值和方差期望值，作为我们进行预测时进行BN的的均值和方差：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084832064-1303869519.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后测试阶段，BN的使用公式就是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084840923-25441349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084855392-663758217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于BN的使用位置，在CNN中一般应作用与非线性激活函数之前，s型函数s(x)的自变量x是经过BN处理后的结果。因此前向传导的计算公式就应该是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084908517-1405223541.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实因为偏置参数b经过BN层后其实是没有用的，最后也会被均值归一化，当然BN层后面还有个β参数作为偏置项，所以b这个参数就可以不用了。因此最后把BN层+激活函数层就变成了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1093303/201802/1093303-20180219084917923-1861811786.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cnn中的bn&quot;&gt;CNN中的BN&lt;/h2&gt;
&lt;p&gt;注意前面写的都是对于一般情况，对于卷积神经网络有些许不同。因为卷积神经网络的特征是对应到一整张特征响应图上的，所以做BN时也应以响应图为单位而不是按照各个维度。比如在某一层，batch大小为m，响应图大小为w×h，则做BN的数据量为m×w×h。&lt;/p&gt;
&lt;p&gt;BN在深层神经网络的作用非常明显：若神经网络训练时遇到收敛速度较慢，或者“梯度爆炸”等无法训练的情况发生时都可以尝试用BN来解决。同时，常规使用情况下同样可以加入BN来加速模型训练，甚至提升模型精度。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 00:50:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8453498.html</dc:identifier>
</item>
<item>
<title>运行自己的 DaemonSet - 每天5分钟玩转 Docker 容器技术（131） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8452453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8452453.html</guid>
<description>&lt;p&gt;&lt;span&gt;本节以 Prometheus Node Exporter 为例演示如何运行自己的 DaemonSet。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Prometheus 是流行的系统监控方案，Node Exporter 是 Prometheus 的 agent，以 Daemon 的形式运行在每个被监控节点上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是直接在 Docker 中运行 Node Exporter 容器，命令为：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;docker run -d \&lt;br/&gt;-v &quot;/proc:/host/proc&quot; \&lt;br/&gt;-v &quot;/sys:/host/sys&quot; \&lt;br/&gt;-v &quot;/:/rootfs&quot; \&lt;br/&gt;--net=host \  prom/node-exporter \&lt;br/&gt;--path.procfs /host/proc \&lt;br/&gt;--path.sysfs /host/sys \&lt;br/&gt;--collector.filesystem.ignored-mount-points &quot;^/(sys|proc|dev|host|etc)($|/)&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;将其转换为 DaemonSet 的 YAML 配置文件 node_exporter.yml：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180218071851140-1123794097.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① 直接使用 Host 的网络。&lt;br/&gt;② 设置容器启动命令。&lt;br/&gt;③ 通过 Volume 将 Host 路径 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/proc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;/sys&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 映射到容器中。我们将在后面详细讨论 Volume。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply -f node_exporter.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/775365/201802/775365-20180218071907515-2061186364.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DaemonSet &lt;/span&gt;&lt;code&gt;&lt;span&gt;node-exporter-daemonset&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 部署成功，k8s-node1 和 k8s-node2 上分别运行了一个 node exporter Pod。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DaemonSet 就讨论到这里，下一节我们学习另一个 Controller -- Job。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 22:29:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8452453.html</dc:identifier>
</item>
<item>
<title>JAVAEE——BOS物流项目04：学习计划、datagrid、分页查询、批量删除、修改功能 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/8453401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/8453401.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;span&gt;使用方法（重要）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;将静态&lt;/span&gt;HTML&lt;span&gt;渲染为&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;span&gt;样式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;发送&lt;/span&gt;ajax&lt;span&gt;请求获取&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;数据创建&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;使用&lt;/span&gt;easyUI&lt;span&gt;提供的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;创建&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;strong&gt;&lt;span&gt;（掌握）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;span&gt;、实现取派员分页查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;调整页面基于&lt;/span&gt;datagrid&lt;span&gt;发送&lt;/span&gt;&lt;span&gt;ajax&lt;/span&gt;&lt;span&gt;请求&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;创建&lt;/span&gt;PageBean&lt;span&gt;封装分页参数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 定义通用分页查询方法&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n &lt;span&gt;将分页查询结果转为&lt;/span&gt;json&lt;span&gt;返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;span&gt;、取派员批量删除&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 页面调整&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 服务端实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;span&gt;、取派员修改&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 页面调整&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;n 服务端实现&lt;/p&gt;



&lt;h2&gt;2.1 &lt;strong&gt;&lt;span&gt;将静态&lt;/span&gt;HTML&lt;span&gt;渲染为&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;span&gt;样式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 方式一：将静态HTML渲染为datagrid样式 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;easyui-datagrid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;field:'id'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;编号&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;field:'name'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;field:'age'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;001&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小明&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;90&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;002&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;老王&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;2.2 &lt;strong&gt;&lt;span&gt;发送&lt;/span&gt;ajax&lt;span&gt;请求获取&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;数据创建&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;提供&lt;/span&gt;json&lt;span&gt;文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000636108-245516506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 方式二：发送ajax请求获取json数据创建datagrid &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;url:'${pageContext.request.contextPath }/json/datagrid_data.json'&quot;&lt;/span&gt;&lt;span&gt; 
            class&lt;/span&gt;&lt;span&gt;=&quot;easyui-datagrid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;field:'id'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;编号&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;field:'name'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;data-options&lt;/span&gt;&lt;span&gt;=&quot;field:'age'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.3 &lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;easyUI&lt;span&gt;提供的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;创建&lt;/span&gt;&lt;span&gt;datagrid&lt;/span&gt;&lt;span&gt;（掌握）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 方式三：使用easyUI提供的API创建datagrid &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面加载完成后，创建数据表格datagrid&lt;/span&gt;
&lt;span&gt;            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#mytable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).datagrid({
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义标题行所有的列&lt;/span&gt;
&lt;span&gt;                columns:[[
                          {title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,field:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,checkbox:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;},
                          {title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,field:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                          {title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,field:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                          {title:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,field:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
                          ]],
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定数据表格发送ajax请求的地址&lt;/span&gt;
&lt;span&gt;                url:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;${pageContext.request.contextPath }/json/datagrid_data.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                rownumbers:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                singleSelect:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义工具栏&lt;/span&gt;
&lt;span&gt;                toolbar:[
                         {text:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,iconCls:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为按钮绑定单击事件&lt;/span&gt;
&lt;span&gt;                             handler:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                                 alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                              }
                         },
                         {text:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,iconCls:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-remove&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                         {text:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,iconCls:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-edit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
                         {text:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,iconCls:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-search&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
                         ],
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示分页条&lt;/span&gt;
&lt;span&gt;                pagination:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
            });
        });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果数据表格中使用了分页条，要求服务端响应的&lt;/span&gt;json&lt;span&gt;变为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000712390-1809805375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;请求：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000721280-592942260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;响应：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000726155-1424588925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;页面：&lt;/span&gt;WEB-INF/pages/base/staff.jsp&lt;/p&gt;

&lt;h2&gt;3.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;17&quot;&gt;l &lt;span&gt;修改页面中&lt;/span&gt;datagrid&lt;span&gt;的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000736140-2109870833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 &lt;strong&gt;服务端实现&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;3.2.1 &lt;strong&gt;&lt;span&gt;包装&lt;/span&gt;PageBean&lt;span&gt;工具类&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;封装分页相关的属性&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000744358-1396608854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;3.2.2 &lt;strong&gt;&lt;span&gt;在&lt;/span&gt;BaseDao&lt;span&gt;中扩展通用分页查询方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通用分页查询方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pageQuery(PageBean pageBean) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currentPage =&lt;span&gt; pageBean.getCurrentPage();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pageSize =&lt;span&gt; pageBean.getPageSize();
        DetachedCriteria detachedCriteria &lt;/span&gt;=&lt;span&gt; pageBean.getDetachedCriteria();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询total---总数据量&lt;/span&gt;
        detachedCriteria.setProjection(Projections.rowCount());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定hibernate框架发出sql的形式----》select count(*) from bc_staff;&lt;/span&gt;
        List&amp;lt;Long&amp;gt; countList = (List&amp;lt;Long&amp;gt;) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().findByCriteria(detachedCriteria);
        Long count &lt;/span&gt;= countList.get(0&lt;span&gt;);
        pageBean.setTotal(count.intValue());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询rows---当前页需要展示的数据集合&lt;/span&gt;
        detachedCriteria.setProjection(&lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定hibernate框架发出sql的形式----》select * from bc_staff;&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; firstResult = (currentPage - 1) *&lt;span&gt; pageSize;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxResults =&lt;span&gt; pageSize;
        List rows &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().findByCriteria(detachedCriteria, firstResult, maxResults);
        pageBean.setRows(rows);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.2.3 &lt;strong&gt;&lt;span&gt;在&lt;/span&gt;StaffAction&lt;span&gt;中提供分页查询方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性驱动，接收页面提交的分页参数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; page;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rows;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 分页查询方法
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String pageQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        PageBean pageBean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageBean();
        pageBean.setCurrentPage(page);
        pageBean.setPageSize(rows);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建离线提交查询对象&lt;/span&gt;
        DetachedCriteria detachedCriteria = DetachedCriteria.forClass(Staff.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        pageBean.setDetachedCriteria(detachedCriteria);
        staffService.pageQuery(pageBean);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用json-lib将PageBean对象转为json，通过输出流写回页面中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JSONObject---将单一对象转为json
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JSONArray----将数组或者集合对象转为json&lt;/span&gt;
        JsonConfig jsonConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonConfig();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定哪些属性不需要转json&lt;/span&gt;
        jsonConfig.setExcludes(&lt;span&gt;new&lt;/span&gt; String[]{&quot;currentPage&quot;,&quot;detachedCriteria&quot;,&quot;pageSize&quot;&lt;span&gt;});
        String json &lt;/span&gt;=&lt;span&gt; JSONObject.fromObject(pageBean,jsonConfig).toString();
        ServletActionContext.getResponse().setContentType(&lt;/span&gt;&quot;text/json;charset=utf-8&quot;&lt;span&gt;);
        ServletActionContext.getResponse().getWriter().print(json);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;在取派员表中存在一个删除标识位&lt;/span&gt;deltag&lt;span&gt;，&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;表示已删除 ，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;表示未删除&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;17&quot;&gt;l &lt;span&gt;数据表格&lt;/span&gt;datagrid&lt;span&gt;提供的方法，用于获取所有选中的行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000841358-1046367608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;修改删除按钮绑定的事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; doDelete(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取数据表格中所有选中的行，返回数组对象&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; rows = $(&quot;#grid&quot;).datagrid(&quot;getSelections&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(rows.length == 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有选中记录，弹出提示&lt;/span&gt;
            $.messager.alert(&quot;提示信息&quot;,&quot;请选择需要删除的取派员！&quot;,&quot;warning&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;选中了取派员,弹出确认框&lt;/span&gt;
            $.messager.confirm(&quot;删除确认&quot;,&quot;你确定要删除选中的取派员吗？&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(r){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(r){
                    
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定,发送请求&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有选中的取派员的id&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;rows.length;i++&lt;span&gt;){
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; staff = rows[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;json对象&lt;/span&gt;
                        &lt;span&gt;var&lt;/span&gt; id =&lt;span&gt; staff.id;
                        array.push(id);
                    }
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ids = array.join(&quot;,&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3,4,5&lt;/span&gt;
                    location.href = &quot;staffAction_deleteBatch.action?ids=&quot;+&lt;span&gt;ids;
                }
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;16&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;4.2 &lt;strong&gt;服务端实现&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一步：在StaffAction中创建deleteBatch批量删除方法



    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性驱动，接收页面提交的ids参数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ids;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取派员批量删除
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String deleteBatch(){
        staffService.deleteBatch(ids);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; LIST;
    }

第二步：在Ｓｅｒｖｉｃｅ中提供批量删除方法
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取派员批量删除
     * 逻辑删除，将deltag改为1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteBatch(String ids) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3,4&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isNotBlank(ids)){
            String[] staffIds &lt;/span&gt;= ids.split(&quot;,&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String id : staffIds) {
                staffDao.executeUpdate(&lt;/span&gt;&quot;staff.delete&quot;&lt;span&gt;, id);
            }
        }
    }
第三步：在Staff.hbm.xml中提供HQL语句，用于逻辑删除取派员
    &lt;/span&gt;&amp;lt;!-- 取派员逻辑删除 --&amp;gt;
    &amp;lt;query name=&quot;staff.delete&quot;&amp;gt;&lt;span&gt;
        UPDATE Staff SET deltag &lt;/span&gt;= '1' WHERE id = ?
    &amp;lt;/query&amp;gt;&lt;span&gt;
由于dtd约束，所以query和class是同级的，如果嵌套写入会报错。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.1 &lt;strong&gt;页面调整&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;第一步：为数据表格绑定双击事件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000939733-457790542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219000945796-1902344161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：复制页面中添加取派员窗口，获得修改取派员窗口&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1135185/201802/1135185-20180219001002405-197389377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：定义&lt;/span&gt;function&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据表格绑定的双击行事件对应的函数&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; doDblClickRow(rowIndex, rowData){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开修改取派员窗口&lt;/span&gt;
        $('#editStaffWindow').window(&quot;open&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用form表单对象的load方法回显数据&lt;/span&gt;
        $(&quot;#editStaffForm&quot;).form(&quot;load&quot;&lt;span&gt;,rowData);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.2 &lt;strong&gt;服务端实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;StaffAction&lt;span&gt;中创建&lt;/span&gt;&lt;span&gt;edit&lt;/span&gt;&lt;span&gt;方法，修改取派员信息&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 修改取派员信息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String edit(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显查询数据库，根据id查询原始数据&lt;/span&gt;
        Staff staff =&lt;span&gt; staffService.findById(model.getId());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用页面提交的数据进行覆盖&lt;/span&gt;
&lt;span&gt;        staff.setName(model.getName());
        staff.setTelephone(model.getTelephone());
        staff.setHaspda(model.getHaspda());
        staff.setStandard(model.getStandard());
        staff.setStation(model.getStation());
        staffService.update(staff);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; LIST;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 18 Feb 2018 16:15:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/8453401.html</dc:identifier>
</item>
<item>
<title>Docker小记 — Docker Engine - 捷义</title>
<link>http://www.cnblogs.com/youclk/p/8371108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youclk/p/8371108.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;用了Docker方才觉得生产环境终于有了他该有的样子，就像集装箱普及之后大型货轮的价值才逐渐体现出来，Docker详细说明可查阅&lt;a href=&quot;https://docs.docker.com&quot;&gt;“官方文档”&lt;/a&gt;。本篇为Docker Engine的笔记，也就是我们通常说的Docker，他包含了提供容器技术实现的Docker daemon及终端控制Docker CLI的应用程序。后续会继续发布Docker Compose和Docker Swarm的操作笔记，由于我的绝大部分应用案例都是云服务器，因此Docker Machine就略过了。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/801714/201801/801714-20180128143352428-704555727.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker安装-配置镜像加速器&quot;&gt;1. Docker安装 &amp;amp; 配置镜像加速器&lt;/h2&gt;
&lt;h3 id=&quot;a&quot;&gt;a：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# step 1：安装必要的一些系统工具&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;apt&lt;/span&gt; update
&lt;span class=&quot;kw&quot;&gt;apt&lt;/span&gt; -y install apt-transport-https ca-certificates curl software-properties-common

&lt;span class=&quot;co&quot;&gt;# step 2：安装GPG证书&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;apt-key&lt;/span&gt; add -

&lt;span class=&quot;co&quot;&gt;# Step 3：写入软件源信息&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;add-apt-repository&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu &lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;lsb_release&lt;/span&gt; -cs&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; stable&quot;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# Step 4：更新并安装 Docker-CE&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;apt&lt;/span&gt; -y update
&lt;span class=&quot;kw&quot;&gt;apt&lt;/span&gt; -y install docker-ce&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;b&quot;&gt;b：&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; -p /etc/docker
&lt;span class=&quot;kw&quot;&gt;tee&lt;/span&gt; /etc/docker/daemon.json &amp;lt;&amp;lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://jrzzvzok.mirror.aliyu&lt;span class=&quot;kw&quot;&gt;ncs.com&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;]&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;EOF&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;systemctl daemon-reload&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;systemctl restart docker&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;dockerfile详解&quot;&gt;2. Dockerfile详解&lt;/h2&gt;
&lt;p&gt;Docker的架构很有魅力，他拥有类似于虚拟机性质的隔离机制，但并不是严格意义上的虚拟机。我还是喜欢拿货轮举例，以前我们是一条小船运一个集装箱的货物，现在可以把N个集装箱扔到一条大货轮上。每个容器（集装箱）共用宿主机（货轮）的内核（运载力），Dockerfile就像是每个集装箱中的货物清单和说明书，一般由以下五部分构成：&lt;/p&gt;
&lt;h3 id=&quot;基础指令&quot;&gt;2.1 基础指令&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;FROM：&lt;/strong&gt; 指定基础镜像，且必须位于第一行，使用格式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode dockerfile&quot;&gt;
&lt;code class=&quot;sourceCode dockerfile&quot;&gt;&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; &amp;lt;image&amp;gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;
&lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; &amp;lt;image&amp;gt;@&amp;lt;digest&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Docker的原理基于Linux内核的隔离技术，且Linux From Scratch，因此&lt;code&gt;FROM scratch&lt;/code&gt;是docker中最基础的镜像，debian、ubuntu和centos等都基于scratch之上。在实际的运用中，如果必须从零开始搭建镜像的一般都选择&lt;code&gt;FROM debian&lt;/code&gt;作为基础镜像，不过大多数情况下一般都会以如下：&lt;code&gt;FROM python&lt;/code&gt;、&lt;code&gt;FROM nginx&lt;/code&gt;、&lt;code&gt;FROM java&lt;/code&gt;等为基础镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MAINTAINER：指定维护者信息，例：&lt;code&gt;MAINTAINER user user@mail.com&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;控制指令&quot;&gt;2.2 控制指令&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;RUN：&lt;/strong&gt; 在构建的过程中指定需要被执行的命令，使用格式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; command param1 param2 &lt;span class=&quot;co&quot;&gt;# 更推荐&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;RUN&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;executable&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;param1&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;param2&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;WORKDIR：&lt;/strong&gt; 用于切换构建过程中的工作目录，例：&lt;code&gt;WORKDIR project&lt;/code&gt;。可配合环境变量使用，例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ENV&lt;/span&gt; BASEDIR /project
&lt;span class=&quot;kw&quot;&gt;WORKDIR&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$BASEDIR&lt;/span&gt;/test&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ONBUILD: 在当前镜像被当做基础镜像时，执行其携带指令，例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ONBUILD&lt;/span&gt; RUN echo &lt;span class=&quot;st&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“hello world”会在子镜像被构建的过程中输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;引入指令&quot;&gt;2.3 引入指令&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;COPY：&lt;/strong&gt; 拷贝文件或目录，格式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;src&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;dest&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;COPY&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;src&amp;gt;&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;dest&amp;gt;&quot;&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;ADD：&lt;/strong&gt; 在COPY的基础之上，ADD可识别压缩文件，例：&lt;code&gt;ADD rootfs.tar.xz /&lt;/code&gt;。理论上也可添加网络地址，但还是建议在RUN指令中执行wget或curl命令，感觉这样更加可控。实际应用为了和COPY做功能区分，ADD一般只用作解压文件（仅我个人的使用习惯）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;执行指令&quot;&gt;2.4 执行指令&lt;/h3&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;CMD：&lt;/strong&gt; 容器启动时需要执行的命令，格式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CMD&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;executable&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;param1&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;param2&quot;&lt;/span&gt;] &lt;span class=&quot;co&quot;&gt;# 更推荐&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;CMD&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&quot;param1&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;param2&quot;&lt;/span&gt;]
&lt;span class=&quot;kw&quot;&gt;CMD&lt;/span&gt; command param1 param2 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若在docker run中指定启动命令，则CMD将被覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ENTRYPOINT：主程序启动前的准备指令，用于启动主程序所依赖的服务，格式同CMD（基本上没用过就不介绍了，而且容易出错，不推荐使用）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置指令&quot;&gt;2.5 配置指令&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;EXPOSE： 暴露容器端口，格式：&lt;code&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;...]&lt;/code&gt;，注意此处的暴露端口和docker run 中-p指定的映射端口是两个概念。&lt;/li&gt;
&lt;li&gt;ENV： 声明环境变量，格式：&lt;code&gt;ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; ...&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;LABEL： 标记，格式：&lt;code&gt;LABEL &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;...&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;USER： 设置启动容器的用户，格式：&lt;code&gt;USER daemo&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;ARG： 设置变量，格式同ENV。&lt;/li&gt;
&lt;li&gt;STOPSIGNAL： 容器停止时给应用程序发出的信号，例：&lt;code&gt;STOPSIGNAL SIGKELL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;SHELL： 指定shell，例：&lt;code&gt;SHELL [&quot;bash&quot;,&quot;-c&quot;]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;docker-命令详解&quot;&gt;3. Docker 命令详解&lt;/h2&gt;
&lt;p&gt;为了避免喧宾夺主，此处仅摘录我个人操作中较为常用的命令。&lt;/p&gt;
&lt;h3 id=&quot;生命周期管理&quot;&gt;3.1 生命周期管理&lt;/h3&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;10.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;run：&lt;/strong&gt; 创建并运行容器，格式：&lt;code&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG...]&lt;/code&gt;，参数说明：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;-d&lt;/span&gt; , --detach            &lt;span class=&quot;co&quot;&gt;# 后台运行&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-it&lt;/span&gt;, --interactive tty   &lt;span class=&quot;co&quot;&gt;# 交互终端形式运行&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-p&lt;/span&gt; , --publish list      &lt;span class=&quot;co&quot;&gt;# 指定端口&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-v&lt;/span&gt; , --volume list       &lt;span class=&quot;co&quot;&gt;# 挂载存储卷&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;--name&lt;/span&gt; string       &lt;span class=&quot;co&quot;&gt;# 定义名字&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;--rm&lt;/span&gt;                &lt;span class=&quot;co&quot;&gt;# 容器终止后自动删除（不支持在后台运行的容器）&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;--restart&lt;/span&gt; string    &lt;span class=&quot;co&quot;&gt;# no、on-failure（非正常退出时重启，on-failure:3最多重启三次）、always、unless-stopped&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;docker run的参数甚多，可通过&lt;code&gt;--help&lt;/code&gt;查询，后续这些复杂的配置都会移交给Docker Compose，以上几个足以应用70%~80%的场景，例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 类似ubuntu这类容器必须以-it交互终端形式运行，否则无法在后台保留&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -it -d --name my-ubuntu ubuntu&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 端口映射和挂载数据卷&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; run -d \
-p 8080:80 \
-v /data/www:/usr/share/nginx/html\
--name my-nginx nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;start/stop/restart：&lt;code&gt;docker start/stop/restart my-container&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;rm：移除容器，格式：&lt;code&gt;docker rm [OPTIONS] CONTAINER [CONTAINER...]&lt;/code&gt;，参数说明：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;-f&lt;/span&gt;, --force     Force the removal of a running container
&lt;span class=&quot;kw&quot;&gt;-l&lt;/span&gt;, --link      Remove the specified link
&lt;span class=&quot;kw&quot;&gt;-v&lt;/span&gt;, --volumes   Remove the volumes associated with the container&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;exec：在运行的容器中执行命令，不过更常用的还是先进入容器再执行命令，例子:&lt;code&gt;docker exec -it my-nginx bash&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;容器操作&quot;&gt;3.2 容器操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ps：&lt;/strong&gt; 列出容器，常用:&lt;code&gt;docker ps -anq&lt;/code&gt;，参数说明：all、n last（最新n个容器）、quiet（只显示容器编号）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;top：&lt;/strong&gt; 查看容器中的进程信息，例：&lt;code&gt;docker top my-container&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;logs：&lt;/strong&gt; 查看容器日志，常用:&lt;code&gt;docker logs -f --tail&lt;/code&gt;，参数说明：follow、--tail n（最新条日志）。&lt;/li&gt;
&lt;li&gt;port：查看端口映射情况，例：&lt;code&gt;docker port my-container&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;镜像仓库&quot;&gt;3.3 镜像仓库&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;login/logout：&lt;/strong&gt; 镜像仓库的登录和退出，格式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; login [OPTIONS] [SERVER]
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; logout  [SERVER]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是Docker Hub，则示例如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; login -u username -p passward
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; logout&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在生产环境中，我们一般会选择使用云厂商的镜像仓库，例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; login -u yo****@qq.com -p ****** registry-vpc.cn-hangzhou.aliyuncs.com
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; logout registry-vpc.cn-hangzhou.aliyuncs.com &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pull：&lt;/strong&gt; 拉取镜像，最常用的命令之一，格式：&lt;code&gt;docker pull [OPTIONS] NAME[:TAG|@DIGEST]&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;push：&lt;/strong&gt; 上传镜像，格式：&lt;code&gt;docker push [OPTIONS] NAME[:TAG]&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;本地镜像管理&quot;&gt;3.4 本地镜像管理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;images：&lt;/strong&gt; 列出本地镜像，常用&lt;code&gt;docker images -q&lt;/code&gt;，参数说明：quiet（只显示image Id）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rmi：&lt;/strong&gt; 删除本地镜像，常用&lt;code&gt;docker rmi -f&lt;/code&gt;，参数说明：force。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tag：&lt;/strong&gt; 标记镜像，归入仓库，格式：&lt;code&gt;docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]&lt;/code&gt;，例：&lt;code&gt;docker tag ubuntu youclk/my-ubuntu:v1&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;build：&lt;/strong&gt; 使用Dockerfile创建镜像，格式：&lt;code&gt;docker build [OPTIONS] PATH | URL | -&lt;/code&gt;，参数说明：-t tag 例：&lt;code&gt;docker build -t youclk/my-ubuntu:v1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;静夜听钟却念念不安，举首相望，恐知者唯灯而~哀哉！整理至此，小弟拙笔盼君悦之。&lt;/p&gt;
</description>
<pubDate>Sun, 18 Feb 2018 16:11:00 +0000</pubDate>
<dc:creator>捷义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youclk/p/8371108.html</dc:identifier>
</item>
</channel>
</rss>