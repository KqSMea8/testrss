<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vue-router 组件复用问题 - kMacro</title>
<link>http://www.cnblogs.com/zkh101/p/8324392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zkh101/p/8324392.html</guid>
<description>&lt;p&gt;组件系统是Vue的一个重要组成部分，它可以将一个复杂的页面抽象分解成许多小型、独立、可复用的组件，通过组合组件来组成应用程序，结合&lt;code&gt;vue-router&lt;/code&gt;的路由功能将各个组件映射到相应的路由上，通过路由的变化来告诉Vue要在哪里渲染他们，实现各个组件、各个页面之间的跳转导航。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;vue-router&lt;/code&gt;切换路由时会触发组件树的更新，根据定义的路由渲染一个新的组件树，大致的切换过程是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;停用并移除不需要的组件&lt;/li&gt;
&lt;li&gt;验证切换的可行性&lt;/li&gt;
&lt;li&gt;复用没有进行更新的组件&lt;/li&gt;
&lt;li&gt;启用并激活新的组件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;3.6&quot;&gt;
&lt;p&gt;具体路由切换控制流程请参考官方文档：&lt;a href=&quot;https://github.com/vuejs/vue-router/blob/1.0/docs/zh-cn/pipeline/README.md&quot;&gt;切换控制流水线&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;那&lt;code&gt;vue-router&lt;/code&gt;是怎么判断某一个组件可以复用的呢？&lt;/strong&gt; 我们看一下下面这条路由配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'post/:postId'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'post'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; resolve &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;st&quot;&gt;'./components/Post.vue'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;resolve)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是通过文章ID加载对应文章页面的路由，第一次访问时，&lt;code&gt;Post.vue&lt;/code&gt;这个组件会被渲染到组件树中，mounted安装组件时通过文章ID获取文章内容展示到页面上，当我们访问另一篇文章时，路由参数&lt;code&gt;:postId&lt;/code&gt;发生改变，按照我们的预期应该会展示新文章的内容，但是事与愿违。&lt;/p&gt;
&lt;p&gt;我们看到的还是之前的文章，虽然路由参数已发生更改，但是&lt;code&gt;vue-router&lt;/code&gt;会以为你访问的是&lt;code&gt;Post.vue&lt;/code&gt;这个组件，由于之前已经渲染过该组件，所以会直接复用之前的组件，并且&lt;strong&gt;不会&lt;/strong&gt;执行组件中的任何操作包括&lt;code&gt;mounted&lt;/code&gt;之类的生命周期函数。&lt;/p&gt;
&lt;p&gt;所以我们最终看到的还是原来组件的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那要怎么才能实现我们期望的效果呢？下面介绍一种有效的解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以使用&lt;code&gt;watch&lt;/code&gt;侦听器来监听路由的变化情况，根据路由参数的变化来响应相应的数据，具体实现过程是这样的：&lt;/p&gt;
&lt;h2 id=&quot;定义数据获取方法&quot;&gt;定义数据获取方法&lt;/h2&gt;
&lt;p&gt;首先定义一个获取文章的方法，根据文章ID从后台获取对应的文章信息。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;methods&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;getPost&lt;/span&gt;(postId) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;$http&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;`/post/get_post/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;postId&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;((response) &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;code&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;data&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;监听路由&quot;&gt;监听路由&lt;/h2&gt;
&lt;p&gt;接着是在路由切换的时候判断目标组件是否是&lt;code&gt;Post.vue&lt;/code&gt;组件，这里可以根据定义的路由名称&lt;code&gt;name&lt;/code&gt;实现，如果是，我们就可以从路由信息中获取目标文章ID来更新组件内容。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;watch&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'$route'&lt;/span&gt; (to&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;to&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'post'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getPost&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;to&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;params&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;postId&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;组件初始化&quot;&gt;组件初始化&lt;/h2&gt;
&lt;p&gt;这里需要注意的是，&lt;strong&gt;当组件首次被挂载到组件树上时，对路由的监听是无效的&lt;/strong&gt;，这时我们需要在生命周期钩子&lt;code&gt;mounted&lt;/code&gt;对组件进行初始化工作：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;mounted&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getPost&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;$route&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;params&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;postId&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过上面的方法就可以实现组件内容随路由参数的变化而更新了，有效解决了&lt;code&gt;vue-router&lt;/code&gt;组件复用导致路由参数失效的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;2.377358490566&quot;&gt;
&lt;p&gt;本文属&lt;a href=&quot;https://zkhdev.github.io/&quot;&gt;kMacro&lt;/a&gt;原创，转载请注明来源：&lt;a href=&quot;https://zkhdev.github.io/2018/01/21/vuejs-component-reuse/&quot; class=&quot;uri&quot;&gt;https://zkhdev.github.io/2018/01/21/vuejs-component-reuse/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 21 Jan 2018 07:29:00 +0000</pubDate>
<dc:creator>kMacro</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zkh101/p/8324392.html</dc:identifier>
</item>
<item>
<title>京东个性化推荐系统实战（下） - 杉枫</title>
<link>http://www.cnblogs.com/freedommovie/p/8267855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freedommovie/p/8267855.html</guid>
<description>&lt;p&gt;        推荐系统架构，推荐系统由品类平台，素材、特征召回平台、模型计算打分服务，排序服务构成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201801/942404-20180121134357959-1649452648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       将请求封装成QueryInfo对象，通过对象来向下完成一步步数据召回。首先是通过QueryInfo对象召回品类、分类信息。&lt;/p&gt;
&lt;p&gt;       前边有人问到是怎样实现通用化？好问题，当时答得不太好，现在梳理总结一下，分类平台通过配置品类、分类信息，&lt;/p&gt;
&lt;p&gt;配置选取个数、配置过滤品类信息，通过每一种配置情况构建分类信息，分类信息完全由配置文件构成。&lt;/p&gt;

&lt;p&gt;       召回品类扩展QueryInfo对象构成QueryInfoExtern对象，为下一步进行素材、特征召回做准备，因为品类、分类数据量&lt;/p&gt;
&lt;p&gt;少，传输时不会因为数据量消耗太多时间，而素材、特征召回量极大，可通过分布式形式将素材进行召回，此时召回量最大&lt;/p&gt;
&lt;p&gt;可满足线上服务要求，召回之后，每组分别进行打分计算，打分之后进行取前边数据进行返回。&lt;/p&gt;
&lt;p&gt;       再由品类召回节点合并将高分素材进行返回，熟悉ElasticSearch同学，会发现和ElasticSearch集群架构很像，其实推&lt;/p&gt;
&lt;p&gt;荐本身和搜索就有很多相似之处，研究搜索引擎对于推荐引擎构建也会大有益处。&lt;/p&gt;

&lt;p&gt;       数据返回之前由排序服务对数据按展示效果进行商品按照品类、分类进行分隔，文章内容按标签、主题进行分隔。分隔&lt;/p&gt;
&lt;p&gt;目的是为了好的展示效果，提升用户体验，通过上面这一系列过程构建成推荐系统大致过程。&lt;/p&gt;

&lt;p&gt;       除了上边架构逻辑，还存在存储以及数据流转体系。分类、素材、特征存储在redis、HBase中供服务读取使用。&lt;/p&gt;
&lt;p&gt;       对于实时反馈，用户点击、浏览会通过存储在redis中用于过滤，以及调整后续推荐分类、素材权重，已作为一种最实时&lt;/p&gt;
&lt;p&gt;反馈手段。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201801/942404-20180121134318709-1766150944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       上报特征本身通过JDQ消息队列进行上报，上报异步进行，通过先写日志文件再上报日志文件内容，来达到异步上报，&lt;/p&gt;
&lt;p&gt;以避免同步上报导致线上服务性能受影响。JDQ本身基于开源kafka打造。&lt;/p&gt;
&lt;p&gt;       JDQ本身为了资源情况限制上报速度为5M/s,为了更好利用上报机器资源，会构建内存队列，充分利用内存资源来控制发&lt;/p&gt;
&lt;p&gt;送速度，而不是一味通过扩容来解决问题。&lt;/p&gt;

&lt;p&gt;       日志白名单本身按照服务、属性、关键字进行存储，在ElasticSearch中可方便按属性、关键词检索使用，通过图形化界&lt;/p&gt;
&lt;p&gt;面展示，方便快速定位线上问题。&lt;/p&gt;
&lt;p&gt;       监控本身除了Ump对系统功能、性能、可用性进行监控，引擎本身就要配备全面监控避免程序某个分支存在问题，导致&lt;/p&gt;
&lt;p&gt;线上服务正确性、可用性存在问题，再有因为程序很多由配置文件动态构成，性能也要进行全面监控。&lt;/p&gt;

&lt;p&gt;       对于线上效果，线上模型与分支进行绑定，当分支A效果实时效果好于B效果，要将线上模型进行更新调整，监控时间&lt;/p&gt;
&lt;p&gt;以几个小时效果为准。线上效果也要进行相应监控，如效果不好要对效果进行报警，以便算法人员对情况进行处理。&lt;/p&gt;
&lt;p&gt;       推荐系统本身涉及算法层、数据层、业务层、线上服务多个层，实际也会涉及多个组，怎样沟通效率以及开发效率以及&lt;/p&gt;
&lt;p&gt;整个系统架构开发灵活性也是每个参与其中的人应该去思考的。其他公司同学也遇到类似问题，我们也进行相应沟通，能够&lt;/p&gt;
&lt;p&gt;效率最大化沟通就是我们一致的目标。&lt;/p&gt;
&lt;p&gt;       推荐系统抽象性需要对推荐业务有足够理解，并能跳脱推荐业务站在更高层次，将系统进行组件式、动态式、配置化设计&lt;/p&gt;
&lt;p&gt;以及实现。一是避免重复开发，一是留有更多时间去思考如何去做更有价值的事。&lt;/p&gt;

&lt;p&gt;       推荐系统不单单是去不断提升转化率、点击率、gmv，同时我们也要多考虑考虑怎么样给用户带去更多有价值内容，有价&lt;/p&gt;
&lt;p&gt;值信息，不单单是推荐一些低俗无底线内容来达成kpi，如果工作全部以kpi为导向，我们最终能获得多少提升呢？&lt;/p&gt;
&lt;p&gt;       最近一段时间对于推荐系统一点总结，以便后续查看，如对读者有些帮助，就更好了。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201712/942404-20171227131529708-1787940844.jpg&quot; alt=&quot;扫码关注公众号&quot; width=&quot;150&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            扫码关注&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 05:49:00 +0000</pubDate>
<dc:creator>杉枫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freedommovie/p/8267855.html</dc:identifier>
</item>
<item>
<title>把玩爬虫框架Gecco - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/geccodemo.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/geccodemo.html</guid>
<description>&lt;p&gt;如果你现在接到一个任务，获取某某行业下的分类。&lt;/p&gt;
&lt;p&gt;作为一个非该领域专家，没有深厚的运营经验功底，要提供一套摆的上台面且让人信服的行业分类，恐怕不那么简单。&lt;/p&gt;
&lt;p&gt;找不到专家没有关系，我们可以爬虫。把那些专家的心血抽丝剥茧爬出来再统计即可。&lt;/p&gt;
&lt;p&gt;确定好思路，我和即将要说的爬虫框架Gecco打了一天的交道。&lt;/p&gt;
&lt;h3 id=&quot;gecco简介&quot;&gt;Gecco简介&lt;/h3&gt;
&lt;p&gt;Gecco是一款用java语言开发的轻量化的易用的网络爬虫。Gecco整合了jsoup、httpclient、fastjson、spring、htmlunit、redission等优秀框架，让您只需要配置一些jquery风格的选择器就能很快的写出一个爬虫。Gecco框架有优秀的可扩展性，框架基于开闭原则进行设计，对修改关闭、对扩展开放。同时Gecco基于十分开放的MIT开源协议，无论你是使用者还是希望共同完善Gecco的开发者（摘自GitHub上的介绍）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要特征&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;简单易用，使用jquery风格的选择器抽取元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持爬取规则的动态配置和加载&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持页面中的异步ajax请求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持页面中的javascript变量抽取&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;利用Redis实现分布式抓取,参考gecco-redis&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;支持结合Spring开发业务逻辑,参考gecco-spring&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;支持htmlunit扩展,参考gecco-htmlunit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持插件扩展机制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持下载时UserAgent随机选取&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持下载代理服务器随机选取&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;GitHub：&lt;/strong&gt;&lt;a href=&quot;https://github.com/xtuhcy/gecco&quot; class=&quot;uri&quot;&gt;https://github.com/xtuhcy/gecco&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中文参考手册：&lt;/strong&gt;&lt;a href=&quot;http://www.geccocrawler.com/&quot; class=&quot;uri&quot;&gt;http://www.geccocrawler.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时GitHub上也提供了使用Gecco的实例，用于抓取京东商城分类以及分类下的商品信息。看到例子的第一眼就发现Gecco特别适合抓取这种分类以及分类下详情列表的数据。&lt;/p&gt;
&lt;p&gt;下面通过实例，边实战边说明Gecco的用法。&lt;/p&gt;
&lt;h3 id=&quot;gecco爬取分类数据&quot;&gt;Gecco爬取分类数据&lt;/h3&gt;
&lt;h4 id=&quot;爬取思路&quot;&gt;爬取思路&lt;/h4&gt;
&lt;p&gt;首先明确爬取的&lt;strong&gt;种子网站&lt;/strong&gt;：&lt;a href=&quot;http://news.iresearch.cn/&quot; class=&quot;uri&quot;&gt;http://news.iresearch.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;爬取区域&lt;/strong&gt;如下图所示&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/619240/201801/619240-20180121131402928-1275069789.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;爬取思路：&lt;/strong&gt;先选取最上面的“互联网+”分类，然后爬取下面的各个子分类（移动互联网+电子商务+互联网+网络销售+网络游戏），再爬取各个子分类下的所有文章，最后提取所有文章的文本信息（提取文本后需要使用IKanalyzer或ansj分词，然后进行词频统计，本篇不做详述）。&lt;/p&gt;
&lt;h4 id=&quot;编写爬虫启动入口&quot;&gt;编写爬虫启动入口&lt;/h4&gt;
&lt;p&gt;我新建的是maven项目，所以要使用Gecco，第一步是添加maven依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.geccocrawler&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;gecco&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.8&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后编写一个main函数作为爬虫的入口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public class Main {

    public static void main(String[] rags) {
        System.out.println(&quot;=======start========&quot;);
        HttpGetRequest startUrl = new HttpGetRequest(&quot;http://news.iresearch.cn/&quot;);
        startUrl.setCharset(&quot;GBK&quot;);
        GeccoEngine.create()
                //Gecco搜索的包路径
                .classpath(&quot;com.crawler.gecco&quot;)
                //开始抓取的页面地址
                .start(startUrl)
                //开启几个爬虫线程
                .thread(1)
                //单个爬虫每次抓取完一个请求后的间隔时间
                .interval(2000)
                .run();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;HttpGetRequest用于包裹种子网站，同时可以设置编码，这里设置的是“GBK”（一开始当时没有设置该参数时，爬出的文本都是乱码的）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;classpath是一个扫描路径，类似于Spring中的component-scan，用于扫描注解的类。这里主要用于扫描注解“@Gecco”所在的类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;解析获取所有子分类&quot;&gt;解析获取所有子分类&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
package com.crawler.gecco;

import com.geccocrawler.gecco.annotation.Gecco;
import com.geccocrawler.gecco.annotation.HtmlField;
import com.geccocrawler.gecco.annotation.Request;
import com.geccocrawler.gecco.request.HttpRequest;
import com.geccocrawler.gecco.spider.HtmlBean;

import java.util.List;

/**
 * Created by jackie on 18/1/15.
 */
@Gecco(matchUrl=&quot;http://news.iresearch.cn/&quot;, pipelines={&quot;consolePipeline&quot;, &quot;allSortPipeline&quot;})
public class AllSort implements HtmlBean {
    private static final long serialVersionUID = 665662335318691818L;

    @Request
    private HttpRequest request;

    // 移动互联网
    @HtmlField(cssPath=&quot;#tab-list &amp;gt; div:nth-child(1)&quot;)
    private List&amp;lt;Category&amp;gt; mobileInternet;

    // 电子商务
    @HtmlField(cssPath=&quot;#tab-list &amp;gt; div:nth-child(2)&quot;)
    private List&amp;lt;Category&amp;gt; electric;

    // 互联网
    @HtmlField(cssPath=&quot;#tab-list &amp;gt; div:nth-child(3)&quot;)
    private List&amp;lt;Category&amp;gt; internet;

    // 网络营销
    @HtmlField(cssPath=&quot;#tab-list &amp;gt; div:nth-child(4)&quot;)
    private List&amp;lt;Category&amp;gt; netMarket;

    // 网络游戏
    @HtmlField(cssPath=&quot;#tab-list &amp;gt; div:nth-child(5)&quot;)
    private List&amp;lt;Category&amp;gt; netGame;

    public List&amp;lt;Category&amp;gt; getMobileInternet() {
        return mobileInternet;
    }

    public void setMobileInternet(List&amp;lt;Category&amp;gt; mobileInternet) {
        this.mobileInternet = mobileInternet;
    }

    public List&amp;lt;Category&amp;gt; getElectric() {
        return electric;
    }

    public void setElectric(List&amp;lt;Category&amp;gt; electric) {
        this.electric = electric;
    }

    public List&amp;lt;Category&amp;gt; getInternet() {
        return internet;
    }

    public void setInternet(List&amp;lt;Category&amp;gt; internet) {
        this.internet = internet;
    }

    public List&amp;lt;Category&amp;gt; getNetMarket() {
        return netMarket;
    }

    public void setNetMarket(List&amp;lt;Category&amp;gt; netMarket) {
        this.netMarket = netMarket;
    }

    public List&amp;lt;Category&amp;gt; getNetGame() {
        return netGame;
    }

    public void setNetGame(List&amp;lt;Category&amp;gt; netGame) {
        this.netGame = netGame;
    }

    public HttpRequest getRequest() {
        return request;
    }

    public void setRequest(HttpRequest request) {
        this.request = request;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;2.602086438152&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;虽然代码很长，但是除去set和get方法，剩下的就是获取子分类标签的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.83082706766917&quot;&gt;
&lt;p&gt;&lt;a href=&quot;mailto:注解@Gecco告知该爬虫匹配的url格式&quot;&gt;注解@Gecco告知该爬虫匹配的url格式&lt;/a&gt;(matchUrl)和内容抽取后的bean处理类（pipelines处理类采用管道过滤器模式，可以定义多个处理类），这里matchUrl就是http://news.iresearch.cn/，意为从这个网址对应的页面中解析&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里pipelines参数可以添加多个管道处理类，意为下一步该执行哪些管道类，需要说明的是consolePipeline，是专门将过程信息输出到控制台的管道类，后面会说明&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.55555555555556&quot;&gt;
&lt;p&gt;&lt;a href=&quot;mailto:注解@HtmlField表示抽取html中的元素&quot;&gt;注解@HtmlField表示抽取html中的元素&lt;/a&gt;，cssPath采用类似jquery的css selector选取元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例说明，现在需要解析“移动互联网”分类下所有的列表并将列表结果包装为一个list，供后面进一步解析列表的具体内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
// 移动互联网
@HtmlField(cssPath=&quot;#tab-list &amp;gt; div:nth-child(1)&quot;)
private List&amp;lt;Category&amp;gt; mobileInternet;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里cssPath是用于指定需要解析的目标元素的css位置。&lt;/p&gt;
&lt;p&gt;如何获取这个区块的位置，先看页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/619240/201801/619240-20180121131500615-527974567.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要获取的是“移动互联网”下的所有列表，并将其包装为一个list集合。打开Chrome开发者工具，可以看到该列表模块被div标签包裹，只要定位到该模块的位置即可。&lt;/p&gt;
&lt;p&gt;如果通过人肉的方式获取cssPath确实有点伤眼，所以我们可以使用Chrome自带的工具获取css路径，在上图箭头所在位置右键，按照如下图所示操作，粘贴即可得到cssPath&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/619240/201801/619240-20180121131521021-1422469826.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依次操作，可以获取其他四个分类的分类列表。&lt;/p&gt;
&lt;h4 id=&quot;获取分类列表对应的url&quot;&gt;获取分类列表对应的url&lt;/h4&gt;
&lt;p&gt;通过上面的解析，我们得到了各个分类下的列表模块。通过Chrome开发者工具，我们可以发现每个列表项包含的信息很少，我们不应该直接抓取这些仅有的文本做分析，这样会漏掉很多文本信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/619240/201801/619240-20180121131547599-1189963277.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们应该先定位解析出所有的href超链接，即每个列表项对应的文章详情地址，然后解析文章详情的所有文本信息。&lt;/p&gt;
&lt;p&gt;所以这里的Category类如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.crawler.gecco;

import com.geccocrawler.gecco.annotation.HtmlField;
import com.geccocrawler.gecco.annotation.Text;
import com.geccocrawler.gecco.spider.HrefBean;
import com.geccocrawler.gecco.spider.HtmlBean;

import java.util.List;

/**
 * Created by jackie on 18/1/15.
 */
public class Category implements HtmlBean {
    private static final long serialVersionUID = 3018760488621382659L;

    @Text
    @HtmlField(cssPath=&quot;dt a&quot;)
    private String parentName;

    @HtmlField(cssPath=&quot;ul li&quot;)
    private List&amp;lt;HrefBean&amp;gt; categorys;

    public String getParentName() {
        return parentName;
    }

    public void setParentName(String parentName) {
        this.parentName = parentName;
    }

    public List&amp;lt;HrefBean&amp;gt; getCategorys() {
        return categorys;
    }

    public void setCategorys(List&amp;lt;HrefBean&amp;gt; categorys) {
        this.categorys = categorys;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;categorys即用于手机某个分类下所有列表对应的网址&lt;/p&gt;
&lt;p&gt;下面实现AllSortPipeline类，用于收集所有分类下的url&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.crawler.gecco;

import com.geccocrawler.gecco.annotation.PipelineName;
import com.geccocrawler.gecco.pipeline.Pipeline;
import com.geccocrawler.gecco.request.HttpRequest;
import com.geccocrawler.gecco.scheduler.SchedulerContext;
import com.geccocrawler.gecco.spider.HrefBean;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by jackie on 18/1/15.
 */
@PipelineName(&quot;allSortPipeline&quot;)
public class AllSortPipeline implements Pipeline&amp;lt;AllSort&amp;gt; {
    @Override
    public void process(AllSort allSort) {
        System.out.println(&quot;-=======-&quot;);
        List&amp;lt;Category&amp;gt; categorys = new ArrayList&amp;lt;Category&amp;gt;();
        categorys.addAll(allSort.getInternet());
        categorys.addAll(allSort.getElectric());
        categorys.addAll(allSort.getMobileInternet());
        categorys.addAll(allSort.getNetGame());
        categorys.addAll(allSort.getNetMarket());
        for(Category category : categorys) {
            List&amp;lt;HrefBean&amp;gt; hrefs = category.getCategorys();
            for(HrefBean href : hrefs) {
                System.out.println(&quot;title: &quot; + href.getTitle() + &quot; url: &quot; + href.getUrl());
                String url = href.getUrl();
                HttpRequest currRequest = allSort.getRequest();
                SchedulerContext.into(currRequest.subRequest(url));
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;categorys集合用于添加所有分类下的列表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过遍历的方式获取具体的url和每个url对应的title&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将url信息存储到SchedulerContext上下文中，用于后面爬虫&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到此为止，我们获取了所有的分类列表对应的url信息，并将url存储到上下文中，用于后续爬虫匹配。下面编写用于解析详情也的处理类。&lt;/p&gt;
&lt;h4 id=&quot;解析文章详情&quot;&gt;解析文章详情&lt;/h4&gt;
&lt;p&gt;新建注解类ProductDetail，用于匹配上边得到的url&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.crawler.gecco;

import com.geccocrawler.gecco.annotation.*;
import com.geccocrawler.gecco.spider.HtmlBean;

/**
 * Created by jackie on 18/1/15.
 */
@Gecco(matchUrl=&quot;http://news.iresearch.cn/content/{yeary}/{month}/{code}.shtml&quot;, pipelines={&quot;consolePipeline&quot;, &quot;productDetailPipeline&quot;})
public class ProductDetail implements HtmlBean {

    private static final long serialVersionUID = -377053120283382723L;

    /**
     * 文本内容
     */
//    @Text
    @HtmlField(cssPath=&quot;body &amp;gt; div.g-content &amp;gt; div.g-bd.f-mt-auto &amp;gt; div &amp;gt; div.g-mn &amp;gt; div &amp;gt; div.g-article &amp;gt; div.m-article&quot;)
    private String content;

    @RequestParameter
    private String code;

    @RequestParameter
    private String year;

    @RequestParameter
    private String month;

    /**
     * 标题
     */
    @Text
    @HtmlField(cssPath=&quot;body &amp;gt; div.g-content &amp;gt; div.g-main.f-mt-auto &amp;gt; div &amp;gt; div &amp;gt; div.title &amp;gt; h1&quot;)
    private String title;

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getYear() {
        return year;
    }

    public void setYear(String year) {
        this.year = year;
    }

    public String getMonth() {
        return month;
    }

    public void setMonth(String month) {
        this.month = month;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;matchUrl是每个文章的url格式，year、month和code是注入的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同理，我们定位到title所在的cssPath和 content所在的cssPath，用于解析得到具体的title和content值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面实现ProductDetailPipeline类，用于解析每篇文章的文本信息，并通过正则抽取所有的中文文本存储到result.txt中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
package com.crawler.gecco;

import com.geccocrawler.gecco.annotation.*;
import com.geccocrawler.gecco.pipeline.Pipeline;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/**
 * Created by jackie on 18/1/15.
 */
@PipelineName(&quot;productDetailPipeline&quot;)
public class ProductDetailPipeline  implements Pipeline&amp;lt;ProductDetail&amp;gt; {
    @Override
    public void process(ProductDetail productDetail) {
        System.out.println(&quot;~~~~~~~~~productDetailPipeline~~~~~~~~~~~&quot;);
        File resultFile = new File(&quot;result.txt&quot;);
        if (!resultFile.exists()) {
            try {
                resultFile.createNewFile();
            } catch (IOException e) {
                System.out.println(&quot;create result file failed: &quot; + e);
            }
        }

        FileWriter fileWriter = null;
        try {
            fileWriter = new FileWriter(&quot;result.txt&quot;, true);
        } catch (IOException e) {
            System.out.println(&quot;IOException&quot;);
        }

        try {
            fileWriter.write(RegrexUtil.match(productDetail.getContent()));
            fileWriter.flush();
        } catch (IOException e) {
            System.out.println(&quot;fileWriter.write failed: &quot; + e);
        } finally {
            try {
                fileWriter.close();
            } catch (IOException e) {
                System.out.println(&quot;fileWriter.close failed&quot;);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们通过Gecco获取到了互联网行业各分类下的所有文章，并提取到所有的文本信息。&lt;/p&gt;
&lt;p&gt;结果如下&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/619240/201801/619240-20180121131611662-1836578139.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/DMinerJackie/tour-project&quot; class=&quot;uri&quot;&gt;https://github.com/DMinerJackie/tour-project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如有问题，可以下方留言&lt;/p&gt;
&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 05:21:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/geccodemo.html</dc:identifier>
</item>
<item>
<title>《SpringMVC从入门到放肆》三、DispatcherServlet的url-pattern配置详解 - 王 二 麻 子</title>
<link>http://www.cnblogs.com/xinhudong/p/8323857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinhudong/p/8323857.html</guid>
<description>&lt;p&gt;上一篇我们详细解释了一下SrpingMVC的执行流程以及一些默认的配置，在Spring的思想中，就是默认大于配置。今天我们来详细的研究一下DispatcherServlet的url-pattern配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、DispatcherServlet的url-pattern配置&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;在没有特别要求的情况下，SpringMVC的中央调度器DispatcherServlet的url-pattern常使用后缀匹配方式进行配置，如*.do、*.action&lt;br/&gt;注意：这里的url-pattern不能写/*，因为DispatcherServlet会将向JSP的动态页面跳转请求也当作为普通的Controller来处理。中央调度器在调用处理器映射器来为其查找相应的处理器时，肯定找不到。所以在这种情况下，所有的JSP页面跳转都会变为404。&lt;br/&gt;最好也不要写成/，因为DispatcherServlet会将向静态资源的请求当作为普通的Controller来处理。如.css、.jpg、.js等。所以静态资源也会变成404。&lt;br/&gt;所以建议写成*.do、*.action之类的配置。当然也有一些时候不得不配置成/，当开发一些移动端接口采用restful请求时，需要配置成/。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、url-pattern配置为/时静态资源的访问&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;1：使用tomcat的默认Servlet解决&lt;/strong&gt;&lt;br/&gt;在web.xml中添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;default&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*.js&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：上方只处理*.js，如果需要大家可以再加几个拦截其它资源。使用该配置只需要配置servlet-mapping即可，default的Servlet配置在tomcat的conf/web.xml文件中。如下图：&lt;/p&gt;
&lt;p&gt;具体的解释在该段代码的上方注释里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/441889/201801/441889-20180121122619365-1365634217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- The &lt;span&gt;default&lt;/span&gt; servlet &lt;span&gt;for&lt;/span&gt; all web applications, that serves &lt;span&gt;static&lt;/span&gt; --&amp;gt;
&amp;lt;!-- resources. It processes all requests that are not mapped to other --&amp;gt;
&amp;lt;!-- servlets with servlet mappings (defined either here or in your own --&amp;gt;
&amp;lt;!-- web.xml file). This servlet supports the following initialization --&amp;gt;
&amp;lt;!-- parameters (&lt;span&gt;default&lt;/span&gt; values are in square brackets): --&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该default的servlet对所有的web应用程序生效，专门处理静态资源。（处理所有没有匹配到servlet mappings的请求）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2：使用SpringMVC的default-servlet-handler解决&lt;/strong&gt;&lt;br/&gt;在springmvc.xml中添加&amp;lt;mvc:default-servlet-handler/&amp;gt;。当然添加这个default-servlet-handler时，需要对当前xml添加mvc的约束xsd。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/441889/201801/441889-20180121122650521-1120467435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终springmvc.xml如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:default-servlet-handler&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册视图解析器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;prefix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;/WEB-INF/jsp/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suffix&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;.jsp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注册SpringMVC处理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;/my.do&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.wechatbao.controller.MyController&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：default-servlet-handler会对静态资源的访问请求通过handlerMapping映射到默认的Servlet请求处理器DefaultServletHttpRequestHandler类上。而该类最终调用的是Tomcat的defaultServlet来处理的请求。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/441889/201801/441889-20180121122738724-155163214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3：使用SpringMVC的resources解决&lt;/strong&gt;&lt;br/&gt;在springmvc.xml中添加如下代码：&lt;br/&gt;&amp;lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;&amp;gt;&amp;lt;/mvc:resources&amp;gt;&lt;br/&gt;其中的location和mapping为具体的静态资源文件夹，大家可以根据具体的项目来定义。&lt;br/&gt;注意：该方法是在spring3.0.4版本后，专门定义的一个静态资源的处理器ResourceHttpRequestHandler类，该种配置文件会将所有的静态资源映射到ResourceHttpRequestHandler该类&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 04:29:00 +0000</pubDate>
<dc:creator>王 二 麻 子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinhudong/p/8323857.html</dc:identifier>
</item>
<item>
<title>MyBatis之基于XML的属性与列名映射 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/8322076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/8322076.html</guid>
<description>&lt;p&gt;上一博客主要是对单表的增删改查，比较简单，而且每个属性与table表的列都是一一对应名字也一样，今天主要学习属性与table表列名不一致的处理，主要有两种一是属性与列名不一致，二是枚举的情况，这里暂时考虑的属性与列名不一致只是单表的情况，至于属性如果是其他model涉及表与表之间的关系的放在下一博客。不过先介绍几个其他的知识点。这些都是参考官网http://www.mybatis.org/mybatis-3/zh/index.html，大家也可以直接参考官网的。本篇博客还是在上一篇博客的基础上做的修改。&lt;/p&gt;
&lt;p&gt;一、Properties&lt;/p&gt;
&lt;p&gt;上一博客创建了一个DBConfig.xml,因为在上一博客只是做了关于数据库的配置，其实它不仅仅可以配置数据库的属性，还可以配置其他的好多属性，比如properties。所以从这篇开始把DBConfig.xml的名字改为了Config.xml。这里为了使用properties，先建了一properties文件:config.properties.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver=&lt;span&gt;com.mysql.jdbc.Driver
url&lt;/span&gt;=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:3306/mybatis&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Config.xml的configuration节点增加如下配置:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;properties resource=&quot;config.properties&quot;&amp;gt;
      &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
      &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot;/&amp;gt;
    &amp;lt;/properties&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果再配置数据库连接的话就可以使用properties。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_93128020-7d35-4a8c-9d4f-0e2922fffddd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_93128020-7d35-4a8c-9d4f-0e2922fffddd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93128020-7d35-4a8c-9d4f-0e2922fffddd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environments &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;environment &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;development&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transactionManager &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;JDBC&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置数据库连接信息 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataSource &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;POOLED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driver&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${driver}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;url&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${url}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environment&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;environments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;还有就是Properties在configuration节点设置的位置的问题，可以按照下图的顺序设置各个属性节点，因为在这个地方我也踩到了坑，就是在使用&lt;span class=&quot;tag&quot;&gt;typeAlias的时候，我把&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;typeAlias放在了mappers下面，然后就报错了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180120223749599-959553763.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;二、typeAlias&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;alias别名，这个在sql种也经常用到，在上一博客种我们在UserMapper.xml种如果要参数类型或返回值类型时都会这样Cuiyw.MyBatis.Model.User写上User的全称，其实我们可以使用typeAlias来简化它来减少冗余。这样在用到Cuiyw.MyBatis.Model.User的地方都可以用别名User代替。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAlias &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;Cuiyw.MyBatis.Model.User&quot;&lt;/span&gt;&lt;span&gt; alias&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果还觉得麻烦，可以直接指定包名就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Cuiyw.MyBatis.Model&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;typeAlias type=&quot;Cuiyw.MyBatis.Model.User&quot; alias=&quot;User&quot;/&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、属性与列名映射&lt;/p&gt;
&lt;p&gt;这是今天的主题，主要是两个内容，一是枚举类型映射，二是属性名与列名不一致怎么映射。&lt;/p&gt;
&lt;p&gt; 1.自带枚举&lt;/p&gt;
&lt;p&gt;如果想使用mybatis自带的枚举类处理，有2种方式，一个是EnumTypeHandler，一个是EnumOrdinalTypeHandler。2者的区别是EnumTypeHandler直接存储name值，而EnumOrdinalTypeHandler会存储enum类里的序号值，此时数据库表字段一般用int类型的处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;addUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;selectKey &lt;/span&gt;&lt;span&gt;resultType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; order&lt;/span&gt;&lt;span&gt;=&quot;AFTER&quot;&lt;/span&gt;&lt;span&gt; keyProperty&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          SELECT LAST_INSERT_ID()
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;selectKey&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        insert into user(name,age,status) values (#{name},#{age},#{status,typeHandler=org.apache.ibatis.type.EnumTypeHandler})
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;addUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;selectKey &lt;/span&gt;&lt;span&gt;resultType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt; order&lt;/span&gt;&lt;span&gt;=&quot;AFTER&quot;&lt;/span&gt;&lt;span&gt; keyProperty&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          SELECT LAST_INSERT_ID()
      &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;selectKey&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        insert into user(name,age,status) values (#{name},#{age},#{status,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler})
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面就是就是使用两种方式实现的新增，下面截图是两种方式在数据库的存储情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180121103746803-1694284607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.resultMap&lt;/p&gt;
&lt;p&gt;上面在sql中的status参数中配置，但对于select的操作没有参数那该怎么办呢？于是resultMap出现了。其实它的作用还有好多，今天主要用它做个简单的例子，同时也演示列名和属性名不一致的情况。虽然先只考虑单表的情况，有时候数据库表的字段名与类的属性名也可能不是一一对应的，这种怎么解决呢？我们可以使用resultMap，用它来做关系映射，这样以后在用到的地方也只需要在select中增加属性resultMap,引用的它id就好也特别方便。这里要注意就是在resultMap设置的typeHandler与在insert中设置的要一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;userResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;status&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;status&quot;&lt;/span&gt;&lt;span&gt; typeHandler&lt;/span&gt;&lt;span&gt;=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; 
        resultType&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; resultMap&lt;/span&gt;&lt;span&gt;=&quot;userResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from user where id=#{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是使用昨天的代码，先增加一个，然后把增加的通过id查询出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733213/201801/733213-20180121110339459-359114489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.自定义枚举&lt;/p&gt;
&lt;p&gt;有时候mybatis自带的枚举并不能满足需求，那我们也可以自定义枚举。MyBatis提供了org.apache.ibatis.type.BaseTypeHandler类用于我们自己扩展类型转换器，上面的EnumTypeHandler和EnumOrdinalTypeHandler也都实现了这个接口。&lt;/p&gt;
&lt;p&gt;User类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_09a3c5d0-37df-47dc-a1e6-66e797ca8a0a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_09a3c5d0-37df-47dc-a1e6-66e797ca8a0a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_09a3c5d0-37df-47dc-a1e6-66e797ca8a0a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.MyBatis.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; UserState {

    DISABLED(&lt;/span&gt;0&lt;span&gt;),
    AVAILABLE(&lt;/span&gt;1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status;
    UserState(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status=&lt;span&gt;status;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserState fromValue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(UserState userState:UserState.values())
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(userState.status==&lt;span&gt;value)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userState;
            }
        }
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Cannot create evalue from value: &quot; + value + &quot;!&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getStatus()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;EnumStatusHandler自定义枚举类  这里采用的EnumOrdinalTypeHandler模式，保存数字。在用的时候直接引用就好了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_4bec5c0d-a296-4196-b076-dafb7c2d8afd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4bec5c0d-a296-4196-b076-dafb7c2d8afd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4bec5c0d-a296-4196-b076-dafb7c2d8afd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.MyBatis.Model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.CallableStatement;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.PreparedStatement;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.type.BaseTypeHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.type.JdbcType;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EnumStatusHandler &lt;span&gt;extends&lt;/span&gt; BaseTypeHandler&amp;lt;UserState&amp;gt;&lt;span&gt; {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNonNullParameter(PreparedStatement ps, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, UserState parameter, JdbcType jdbcType)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        ps.setInt(i, parameter.getStatus());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserState getNullableResult(ResultSet rs, String columnName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UserState.fromValue(rs.getInt(columnName));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserState getNullableResult(ResultSet rs, &lt;span&gt;int&lt;/span&gt; columnIndex) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UserState.fromValue(rs.getInt(columnIndex));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserState getNullableResult(CallableStatement cs, &lt;span&gt;int&lt;/span&gt; columnIndex) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; UserState.fromValue(cs.getInt(columnIndex));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;userResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;status&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;status&quot;&lt;/span&gt;&lt;span&gt; typeHandler&lt;/span&gt;&lt;span&gt;=&quot;Cuiyw.MyBatis.Model.EnumStatusHandler&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.自定义枚举优化&lt;/p&gt;
&lt;p&gt;上面是针对每个枚举类型创建一个TypeHandler,那如果多的话岂不是很麻烦，那该怎么办呢？有什么优化的方法没？答案当然是有的啦。有单独的一个转到能应用多个，那就会联想的泛型。&lt;/p&gt;
&lt;p&gt;1.定义接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.MyBatis.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ValuedEnum {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.枚举实现接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_8262018f-2abb-4aba-9446-ed66dca3261f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8262018f-2abb-4aba-9446-ed66dca3261f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8262018f-2abb-4aba-9446-ed66dca3261f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.MyBatis.Model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; UserState &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ValuedEnum {

    DISABLED(&lt;/span&gt;0&lt;span&gt;),
    AVAILABLE(&lt;/span&gt;1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status;
    UserState(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status=&lt;span&gt;status;
    }
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public static UserState fromValue(int value)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        for(UserState userState:UserState.values())
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            if(userState.status==value)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                return userState;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        throw new IllegalArgumentException(&quot;Cannot create evalue from value: &quot; + value + &quot;!&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;    
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public int getStatus()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return status;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getValue() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; status;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3.定义EnumTypeHandler&lt;/p&gt;
&lt;p&gt;在ValuedEnumTypeHandler构造函数中使用了getEnumConstants()方法，它以声明顺序返回一个数组，该数组包含构成此 class 对象所表示的枚举类的值，或者在此 class 对象不表示枚举类型时返回 null，这样就可以把枚举值与数字值对应起来放在map中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_b4f1df8b-63c8-46f9-b7f4-ee56c45240d2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b4f1df8b-63c8-46f9-b7f4-ee56c45240d2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b4f1df8b-63c8-46f9-b7f4-ee56c45240d2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Cuiyw.MyBatis.Model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.CallableStatement;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.PreparedStatement;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.type.BaseTypeHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.type.JdbcType;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ValuedEnumTypeHandler &amp;lt;E &lt;span&gt;extends&lt;/span&gt; Enum&amp;lt;E&amp;gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; BaseTypeHandler&amp;lt;E&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Class&amp;lt;E&amp;gt;&lt;span&gt; type;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;Integer, E&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer, E&amp;gt;&lt;span&gt;();
    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValuedEnumTypeHandler(Class&amp;lt;E&amp;gt;&lt;span&gt; type) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Type argument cannot be null&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
        E[] enums &lt;/span&gt;=&lt;span&gt; type.getEnumConstants();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enums == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(type.getSimpleName() + &quot; does not represent an enum type.&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (E e : enums) {
            ValuedEnum valuedEnum &lt;/span&gt;=&lt;span&gt; (ValuedEnum) e;
            map.put(valuedEnum.getValue(), e);
        }
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setNonNullParameter(PreparedStatement ps, &lt;span&gt;int&lt;/span&gt; i, E parameter, JdbcType jdbcType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        ValuedEnum valuedEnum =&lt;span&gt; (ValuedEnum) parameter;
        ps.setInt(i, valuedEnum.getValue());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E getNullableResult(ResultSet rs, String columnName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rs.getInt(columnName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rs.wasNull()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getValuedEnum(i);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E getNullableResult(ResultSet rs, &lt;span&gt;int&lt;/span&gt; columnIndex) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rs.getInt(columnIndex);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (rs.wasNull()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getValuedEnum(i);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; E getNullableResult(CallableStatement cs, &lt;span&gt;int&lt;/span&gt; columnIndex) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; cs.getInt(columnIndex);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cs.wasNull()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getValuedEnum(i);
        }
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; E getValuedEnum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map.get(value);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                    &lt;/span&gt;&quot;Cannot convert &quot; + value + &quot; to &quot; + type.getSimpleName() + &quot; by value.&quot;&lt;span&gt;, ex);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;4.使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;User&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;userResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;status&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;status&quot;&lt;/span&gt;&lt;span&gt; typeHandler&lt;/span&gt;&lt;span&gt;=&quot;Cuiyw.MyBatis.Model.ValuedEnumTypeHandler&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 21 Jan 2018 04:28:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/8322076.html</dc:identifier>
</item>
<item>
<title>Inception服务的安装以及使用Python 3 实现MySQL的审计 - MSSQL123</title>
<link>http://www.cnblogs.com/wy123/p/8322162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wy123/p/8322162.html</guid>
<description>
&lt;p&gt;Inception服务的安装以及使用Python实现MySQL的审计&lt;/p&gt;

&lt;p&gt;Bison是Inception服务所依赖的包之一，但是某些Linux版本已安装的Bison，或者是通过yum安装的Bison，通常是Bison 3.0+版本的.&lt;br/&gt;对于Inception程序来说，其Bison版本是过高的，会导致Inception在编译的过程出错，按照官方的建议，最好需要Bison 2.5这个版本。&lt;br/&gt;因此需要手动安装Bison 2.5这个版本的依赖包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bison的安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bison下载&lt;/p&gt;
&lt;p&gt;　　下载地址，选择合适的版本和压缩文件 &lt;a href=&quot;http://ftp.gnu.org/gnu/bison/&quot; target=&quot;_blank&quot;&gt;http://ftp.gnu.org/gnu/bison/&lt;/a&gt;，这里下载的是&lt;a href=&quot;http://ftp.gnu.org/gnu/bison/bison-2.5.1.tar.xz&quot;&gt;bison-2.5.1.tar.xz&lt;/a&gt;这个版本的包。&lt;/p&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;　　xz -d bison-2.5.1.tar.xz&lt;br/&gt;　　tar -xvf bison-2.5.1.tar&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120220257943-1881308846.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;469&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装&lt;/p&gt;
&lt;p&gt;　　进入解压后的bison路径中，cd bison-2.5.1，按照正常的源码包依次编译安装即可。&lt;br/&gt;　　./configure&lt;br/&gt;　　make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120220851818-597658098.png&quot; alt=&quot;&quot; width=&quot;749&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完成安装，检查Bison的版本，bison  -V（记得之前要设置环境变量的，这里安装完之后直接就识别Bison命令了）。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120221134021-2021353163.png&quot; alt=&quot;&quot; width=&quot;713&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后安装其其他的相关依赖包&lt;br/&gt;　   yum install gcc gcc-c++ cmake openssl-devel ncurses-devel MySQL-python git –y&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;crayon-e&quot;&gt;Inception的安装　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　源码下载&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;crayon-e&quot;&gt;　 下载源代码 git &lt;span class=&quot;crayon-r&quot;&gt;clone &lt;a href=&quot;%20https://github.com/mysql-inception/inception.git&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;crayon-h&quot;&gt;&lt;span class=&quot;crayon-v&quot;&gt;https&lt;span class=&quot;crayon-o&quot;&gt;:&lt;span class=&quot;crayon-o&quot;&gt;/&lt;span class=&quot;crayon-o&quot;&gt;/&lt;span class=&quot;crayon-v&quot;&gt;github&lt;span class=&quot;crayon-e&quot;&gt;.com&lt;span class=&quot;crayon-o&quot;&gt;/&lt;span class=&quot;crayon-v&quot;&gt;mysql&lt;span class=&quot;crayon-o&quot;&gt;-&lt;span class=&quot;crayon-v&quot;&gt;inception&lt;span class=&quot;crayon-o&quot;&gt;/&lt;span class=&quot;crayon-v&quot;&gt;inception&lt;span class=&quot;crayon-e&quot;&gt;.git&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　 &lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120223856818-1668590350.png&quot; alt=&quot;&quot; width=&quot;909&quot; height=&quot;63&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　编译&amp;amp;&amp;amp;安装&lt;/p&gt;
&lt;p&gt;　　进入Inception目录之后执行：bash inception_build.sh debug [Xcode]&lt;br/&gt;　　经过十几分钟漫长的编译安装完成之后，确认安装成功。&lt;br/&gt;　　如果是第一次安装失败，可能是缺少依赖的包或者是依赖的包的版本不对，可以根据具体的错误进行处理，重新安装需要删除安装失败生成的debug目录，否则无法继续安装。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120225635021-659948235.png&quot; alt=&quot;&quot; width=&quot;755&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　添加一个最基本的Inception配置文件&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120230014443-848557102.png&quot; alt=&quot;&quot; width=&quot;835&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动Inception服务&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120230205318-1788082677.png&quot; alt=&quot;&quot; width=&quot;1033&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从本地连接至Inception服务&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180120230351303-175456717.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;673&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　至此，Inception服务已完全安装成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 使用Python（Python3）实现MySQL的审计作业&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　Inception在验证MySQL脚本的有效性的时候，有自己的特定的格式，因此要将带验证（执行）的sql脚本组装成Inception服务指定的格式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Inception开始标志&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;--user=username;--password=*****;--host=***.***.***.***;--enable-check;--port=3306;&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
inception_magic_start;  

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;中间开始是sql语句&lt;/span&gt;
&lt;span&gt;use&lt;/span&gt;&lt;span&gt; mysql;  
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; adaptive_office(id &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);  

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;Inception结束标志&lt;/span&gt;
inception_magic_commit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　网上大多数环境使用Python做Inception的审计，应该使用的是Python2，如果换做是Python3，发现根本无法正常连接至Inception服务。&lt;br/&gt;　　正常连接的时候，一直报错：“invalid literal for int() with base 10: 'Inception2'”&lt;br/&gt;　　原因应该是connections.py在连接到Inception服务参数解析类型转换的时候有一点问题。&lt;br/&gt;　　参考：&lt;a href=&quot;http://blog.51cto.com/amnesiasun/1947605&quot; target=&quot;_blank&quot;&gt;http://blog.51cto.com/amnesiasun/1947605&lt;/a&gt;，修改Python的connections.py文件中的_request_authentication方法&lt;br/&gt;　　这样才能使用Python3正常连接至Inception服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/380271/201801/380271-20180121103519193-1529494572.png&quot; alt=&quot;&quot; width=&quot;930&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如下是一个使用Python做MySQL脚本审计的一个demo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -\*-coding: utf-8-\*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys, os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行还是校验&lt;/span&gt;
operation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;--enable-check&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; operation = '--enable-execute;--enable-ignore-warnings;--enable-force'&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发布目标服务器列表，目标服务器&lt;/span&gt;
connstr_target = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;***.***.***.***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;inception_testdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8mb4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; inception server的配置&lt;/span&gt;
connstr_inception = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;***.***.***.***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 6669, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;''&lt;/span&gt;,  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8mb4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}



&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; inception格式要求&lt;/span&gt;
prefix_format = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/*--user={};--password={};--host={};{};--port={};*/ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(connstr_target[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                                                                      connstr_target[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                                                                      connstr_target[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                                                                      operation,
                                                                                      connstr_target[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]) \
                &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
                &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inception_magic_start;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
suffix_format &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inception_magic_commit;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt;待执行的sql语句&lt;/span&gt;
sql_demo1 = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt; use inception_testdb; 
            alter table test_inception 
            add column remark varchar(200);&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;


&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将待执行的sql语句组合成inception识别的格式&lt;/span&gt;
    sql_demo1_with_format = prefix_format + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + sql_demo1 + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; suffix_format

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(sql_demo1_with_format)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接至inception 服务器&lt;/span&gt;
    conn_inception = pymysql.connect(host=connstr_inception[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                      port&lt;/span&gt;=connstr_inception[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                      user&lt;/span&gt;=connstr_inception[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                      password&lt;/span&gt;=connstr_inception[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
                                      charset&lt;/span&gt;=connstr_inception[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])


    cur &lt;/span&gt;=&lt;span&gt; conn_inception.cursor()

    cur.execute(sql_demo1_with_format)
    result &lt;/span&gt;=&lt;span&gt; cur.fetchall()
    num_fields &lt;/span&gt;=&lt;span&gt; len(cur.description)
    field_names &lt;/span&gt;= [i[0] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cur.description]
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(field_names)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印出来Inception对MySQL语句的审计结果&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(row[0], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[1], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[2], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[3], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[4], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[5], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[6], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  row[7], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              row[&lt;/span&gt;8], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[9], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, row[10&lt;span&gt;])

    cur.close()
    conn_inception.close()

&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;  Exception as err:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(err)
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;****************&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;errlevel=0表示语句正常，1的话表示有警告信息，比如字段没有默认值，没有comment等，2的话表示严重的错误，比如往表中增加一个已经存在的字段等等。&lt;br/&gt;比如如下的审计结果中有一个errlevel=2的结果，原因是表中已经存在了remark字段，再增加一个同名的字段，肯定是通不过的，因此显示“Column 'remark' have existed.”这个错误，&lt;br/&gt;除了上述错误，也会显示执行alter table test_inception add column remark varchar(200);这个语句产生的其他类型的错误（或者警告）。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;需要了解的就是，一些潜在的不是严重错误级别的问题，其警告类型是可以配置化的，&lt;br/&gt;比如字段没有comment，可以在Inception服务一级配置为没有comment不显示警告，亦或是字段没有默认值，Inception也会给予一个警告，这些非严重错误，都可以根据情况进行配置（是否给出告警）&lt;br/&gt;当然，这里仅仅是一个demo，对于Inception审计出来的结果，可以根据具体要求做的更加可视化一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'ID', 'stage', 'errlevel', 'stagestatus', 'errormessage', 'SQL', 'Affected_rows', 'sequence', 'backup_dbname', 'execute_time', 'sqlsha1'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CHECKED &lt;span&gt;|&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Audit completed &lt;span&gt;|&lt;/span&gt; None &lt;span&gt;|&lt;/span&gt; &lt;span&gt;use&lt;/span&gt; inception_testdb &lt;span&gt;|&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0_0_0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; None &lt;span&gt;|&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CHECKED &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Audit completed &lt;span&gt;|&lt;/span&gt; &lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;remark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; have existed.
&lt;/span&gt;&lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;remark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_inception&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; have no comments.
&lt;/span&gt;&lt;span&gt;Column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;remark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_inception&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; allowed &lt;span&gt;to&lt;/span&gt;&lt;span&gt; been nullable.
&lt;/span&gt;&lt;span&gt;Set&lt;/span&gt; &lt;span&gt;Default&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;remark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_inception&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_inception 
            &lt;/span&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; remark &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;|&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0_0_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; 116_196_94_250_8000_inception_testdb &lt;span&gt;|&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于Inception审计结果，也不是完全合理的，比如mysql中创建索引的语句，支持两种语法，alter table的方式和create index的方式。&lt;br/&gt;　　早期的mysql版本都是通过alter table的语法增加索引的，后面的mysql支持了create index的语法，但是Inception对于create index的语句也是给予一个严重级别的告警的。&lt;br/&gt;　　另外对于DML的语句支持也有限，比如insert语句，如果insert语句插入一条与现在表中存在主键冲突的值，Inception也是检测不出来的，&lt;br/&gt;　　Inception更多的是检测语法这个层面的错误。　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　整体看Inception是一个功能非常强大的软件（服务），本文管中窥豹，仅粗略做了一下尝试，仅供参考，更多请参考&lt;a href=&quot;http://mysql-inception.github.io/inception-document/&quot; target=&quot;_blank&quot;&gt;http://mysql-inception.github.io/inception-document/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最后参考官方文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不得不说，Inception还是国内比较牛逼的审计（执行，回滚等）MySQL管理的利器之一了，最起码开源了，是骡子是马拉已经来出来遛了，认可程度还是比较高的，没有相当的实力，是拦不下这个瓷器活的。&lt;br/&gt;能正常使用Python连接至Inception实现最基本的SQL审计之后，就可以尝试适合自己的审计方式，以及发掘Inception更多的功能了。&lt;br/&gt;最好的当然是官方的参考文档了：&lt;a href=&quot;http://mysql-inception.github.io/inception-document/&quot; target=&quot;_blank&quot;&gt;http://mysql-inception.github.io/inception-document/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;http://mysql-inception.github.io/inception-document/&quot; target=&quot;_blank&quot;&gt;http://mysql-inception.github.io/inception-document/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://www.ywnds.com/?p=9423&quot; target=&quot;_blank&quot;&gt;http://www.ywnds.com/?p=9423&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;http://blog.51cto.com/amnesiasun/1947605&quot; target=&quot;_blank&quot;&gt;http://blog.51cto.com/amnesiasun/1947605&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 21 Jan 2018 03:45:00 +0000</pubDate>
<dc:creator>MSSQL123</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wy123/p/8322162.html</dc:identifier>
</item>
<item>
<title>14、ABPZero系列教程之拼多多卖家工具 新建微信公众号模块 - 李子深</title>
<link>http://www.cnblogs.com/shensigzs/p/8316358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shensigzs/p/8316358.html</guid>
<description>&lt;p&gt;　　说是模块，其实在MVC中就是区域，新建一个区域专门管理整个微信功能。&lt;/p&gt;

&lt;p&gt;在Web项目Areas目录下新建一个区域，名称为“Weixin&quot;,如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180119121346568-139757594.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;接着打开web.config，修改如下代码：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Web\Areas\Weixin\Views\web.config&lt;/p&gt;
&lt;p&gt;找到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pages &lt;/span&gt;&lt;span&gt;pageBaseType&lt;/span&gt;&lt;span&gt;=&quot;System.Web.Mvc.WebViewPage&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pages &lt;/span&gt;&lt;span&gt;pageBaseType&lt;/span&gt;&lt;span&gt;=&quot;MyCompanyName.AbpZeroTemplate.Web.Views.AbpZeroTemplateWebViewPageBase&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样视图就可以使用ABP封闭好的一些特性和功能。&lt;/p&gt;

&lt;p&gt;添加_ViewStart.cshtml文件，代码如下：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Web\Areas\Weixin\Views\_ViewStart.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    Layout = &quot;~/Areas/Weixin/Views/Layout/_Layout.cshtml&quot;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后把Mpa中Layout的功能照搬过来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：记得修改Layout控制器的命名空间，其它都不用变。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;添加HomeController.cs控制器，代码如下：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Web\Areas\Weixin\Controllers\HomeController.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : AbpZeroTemplateControllerBase
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Weixin/Home&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;添加Index.cshtml视图，代码如下：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Web\Areas\Weixin\Views\Home\Index.cshtml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewBag.Title = &quot;Index&quot;;
}

&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;@L(&quot;Weixin&quot;)&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;打开AbpZeroTemplate-zh-CN.xml文件，在末尾添加以下代码：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Core\Localization\AbpZeroTemplate\AbpZeroTemplate-zh-CN.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Weixin&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;微信&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在生成解决方案，浏览器访问http://localhost:8088/weixin/home,当看到页面中出现”微信“2个字就说明此区域整合好了，可以继续下面的步骤。&lt;/p&gt;

&lt;p&gt;接着AbpZeroTemplate-zh-CN.xml文件，再添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Weixin.Menu&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;菜单&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打开AppPermissions.cs文件，末尾添加如下代码：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abpweb\PddSellerAssistant\PddSellerAssistant.Core\Authorization\AppPermissions.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Pages_Weixin = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pages.Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Pages_Weixin_Menu = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pages.Weixin.Menu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打开AppAuthorizationProvider.cs文件，在SetPermissions方法末尾添加如下代码：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Core\Authorization\AppAuthorizationProvider.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; weixin = pages.CreateChildPermission(AppPermissions.Pages_Weixin, L(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            weixin.CreateChildPermission(AppPermissions.Pages_Weixin_Menu, L(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin.Menu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;打开PageNames.cs文件，&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Web\App_Start\Navigation\PageNames.cs&lt;/p&gt;
&lt;p&gt;在Command类中添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Weixin = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在40行位置添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Weixin
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Menu = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Menu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打开MpaNavigationProvider.cs文件，添加如下代码：&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Web\Areas\Mpa\Startup\MpaNavigationProvider.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
.AddItem(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItemDefinition(
                        PageNames.App.Common.Weixin,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个常量，控制菜单是否被选中&lt;/span&gt;
                        L(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单显示名称，在语言文件中配置&lt;/span&gt;
                        url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin/Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单路径&lt;/span&gt;
                        icon: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;icon-pie-chart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单图标&lt;/span&gt;
                        requiredPermissionName: AppPermissions.Pages_Weixin&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单权限，登录用户所在角色有此权限才会显示出来&lt;/span&gt;
                        ).AddItem(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MenuItemDefinition(
                        PageNames.App.Weixin.Menu,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个常量，控制菜单是否被选中&lt;/span&gt;
                        L(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin.Menu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单显示名称，在语言文件中配置&lt;/span&gt;
                        url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weixin/Menu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单路径&lt;/span&gt;
                        icon: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;icon-pie-chart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单图标&lt;/span&gt;
                        requiredPermissionName: AppPermissions.Pages_Weixin_Menu&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单权限，登录用户所在角色有此权限才会显示出来&lt;/span&gt;
&lt;span&gt;                        ))
                        )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;生成解决方案，浏览器打开http://localhost:8088，登录后在角色那里把微信相关2个菜单分配出来。效果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180119125949912-1292183040.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 至此，已经新建好了区域并且把相关菜单已经分配出来。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/shensigzs/p/8277860.html&quot; target=&quot;_blank&quot;&gt;返回总目录&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 21 Jan 2018 03:40:00 +0000</pubDate>
<dc:creator>李子深</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shensigzs/p/8316358.html</dc:identifier>
</item>
<item>
<title>Redis 数据结构与内存管理策略（上） - 王清培</title>
<link>http://www.cnblogs.com/wangiqngpei557/p/8323680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangiqngpei557/p/8323680.html</guid>
<description>&lt;p&gt;标签： Redis Redis数据结构 Redis内存管理策略 Redis数据类型 Redis类型映射&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;Redis 数据类型特点与使用场景
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;String&lt;/strong&gt;、&lt;strong&gt;List&lt;/strong&gt;、&lt;strong&gt;Hash&lt;/strong&gt;、&lt;strong&gt;Set&lt;/strong&gt;、&lt;strong&gt;Zset&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;案例：沪江团购系统大促 &lt;strong&gt;hot-top&lt;/strong&gt; 接口 &lt;strong&gt;cache&lt;/strong&gt; 设计&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 内存数据结构与编码
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OBJECT&lt;/strong&gt; encoding key、&lt;strong&gt;DEBUG OBJECT&lt;/strong&gt; key&lt;/li&gt;
&lt;li&gt;简单动态字符串（simple dynamic string）&lt;/li&gt;
&lt;li&gt;链表（linked list）&lt;/li&gt;
&lt;li&gt;字典（dict）&lt;/li&gt;
&lt;li&gt;跳表（skip list）&lt;/li&gt;
&lt;li&gt;整数集合（int set）&lt;/li&gt;
&lt;li&gt;压缩表（zip list）&lt;/li&gt;
&lt;li&gt;Redis Object 类型与映射&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 内存管理策略
&lt;ul&gt;&lt;li&gt;键 过期时间、生存时间&lt;/li&gt;
&lt;li&gt;过期键删除策略&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOF&lt;/strong&gt; 、&lt;strong&gt;RDB&lt;/strong&gt; 处理过期键策略&lt;/li&gt;
&lt;li&gt;Redis &lt;strong&gt;LRU&lt;/strong&gt; 算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 持久化方式
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;AOF&lt;/strong&gt; (Append-only file)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RDB&lt;/strong&gt; (Redis DataBase)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;redis-数据类型特点与使用场景&quot;&gt;Redis 数据类型特点与使用场景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 为我们提供了 &lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; 种数据类型，基本上我们使用频率最高的就是 &lt;strong&gt;string&lt;/strong&gt; ，而对其他四种数据类型使用的频次稍弱于 &lt;strong&gt;string&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;一方面是由于 &lt;strong&gt;string&lt;/strong&gt; 使用起来比较简单，可以方便存储复杂大对象，使用场景比较多。还有一个原因就是由于 &lt;strong&gt;redis expire time&lt;/strong&gt; 只能设置在 &lt;strong&gt;key&lt;/strong&gt; 上，像 &lt;strong&gt;list&lt;/strong&gt;、&lt;strong&gt;hash&lt;/strong&gt;、&lt;strong&gt;set&lt;/strong&gt;、&lt;strong&gt;zset&lt;/strong&gt; 属于集合类型，会管理一组 &lt;strong&gt;item&lt;/strong&gt;，我们无法在这些集合的 &lt;strong&gt;item&lt;/strong&gt; 上设置过期时间，所以使用 &lt;strong&gt;expire time&lt;/strong&gt; 来处理集合的 &lt;strong&gt;cache&lt;/strong&gt; 失效会变得稍微复杂些。但是 &lt;strong&gt;string&lt;/strong&gt; 使用 &lt;strong&gt;expire time&lt;/strong&gt; 来管理过期策略会比较简单，因为它包含的项少。这里说的集合是宽泛的类似集合。&lt;/p&gt;
&lt;p&gt;导致我们习惯性的使用 &lt;strong&gt;string&lt;/strong&gt; 而忽视其他四种数据类型的另一个深层次原因，大多是由于我们对另外四种数据类型的使用和原理不是太了解。这个时候往往会忽视在特定场景下使用某种数据类型可能会比 &lt;strong&gt;string&lt;/strong&gt; 性能高出很多，比如使用 &lt;strong&gt;hash&lt;/strong&gt; 结构来提高某个实体的某个项的修改等。&lt;/p&gt;
&lt;p&gt;这里我们不打算罗列这 &lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; 种数据类型的使用方法，这些资料网上有很多。我们主要讨论这 &lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; 种数据类型的功能特点，这些特点分别适合用于处理哪些现实的业务场景，最重要的是我们如何组合性的使用这 &lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; 种数据类型来解决复杂的 &lt;strong&gt;cache&lt;/strong&gt; 问题。&lt;/p&gt;
&lt;h2 id=&quot;stringlisthashsetzset&quot;&gt;String、List、Hash、Set、Zset&lt;/h2&gt;
&lt;h3 id=&quot;string&quot;&gt;&lt;strong&gt;&lt;em&gt;String&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;string&lt;/strong&gt; 是 &lt;strong&gt;redis&lt;/strong&gt; 提供的字符串类型。可以针对 &lt;strong&gt;string&lt;/strong&gt; 类型独立设置 &lt;strong&gt;expire time&lt;/strong&gt; 。通常用来存储长字符串数据，比如，某个对象的 &lt;strong&gt;json&lt;/strong&gt; 字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;string&lt;/strong&gt; 类型我们在使用上最巧妙的是可以动态拼接 &lt;strong&gt;key&lt;/strong&gt;。通常我们可以将一组 &lt;strong&gt;id&lt;/strong&gt; 放在 &lt;strong&gt;set&lt;/strong&gt; 里，然后动态查找 &lt;strong&gt;string&lt;/strong&gt; 还是否存在，如果不存在说明已经过期或者由于数据修改主动 &lt;strong&gt;delete&lt;/strong&gt; 了，需要再做一次 &lt;strong&gt;cache&lt;/strong&gt; 数据 &lt;strong&gt;load&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;虽然 &lt;strong&gt;set&lt;/strong&gt; 无法设置 &lt;strong&gt;item&lt;/strong&gt; 的过期时间，但是我们可以将 &lt;strong&gt;set item&lt;/strong&gt; 与 &lt;strong&gt;string key&lt;/strong&gt; 关联来达到相同的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/1.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的左边是一个 &lt;strong&gt;key&lt;/strong&gt; 为 &lt;strong&gt;set:order:ids&lt;/strong&gt; 的 &lt;strong&gt;set&lt;/strong&gt; 集合，它可能是一个全量集合，也可能是某个查询条件获取出来的一个集合。&lt;/p&gt;
&lt;p&gt;有时候复杂点的场景需要多个 &lt;strong&gt;set&lt;/strong&gt; 集合来支撑计算，在 &lt;strong&gt;redis 服务器&lt;/strong&gt; 里可能会有很多类似这样的集合。&lt;/p&gt;
&lt;p&gt;这些集合我们可以称为 &lt;strong&gt;功能数据&lt;/strong&gt;，这些数据是用来辅助 &lt;strong&gt;cache&lt;/strong&gt; 计算的，当进行各种集合运算之后会得出当前查询需要返回的子集，最后我们才会去获取某个订单真正的数据。&lt;/p&gt;
&lt;p&gt;这些 &lt;strong&gt;string:order:{orderId}&lt;/strong&gt; 字符串 &lt;strong&gt;key&lt;/strong&gt; 并不一定是为了服务一种场景，而是整个系统最底层的数据，各种场景最后都需要获取这些数据。那些 &lt;strong&gt;set&lt;/strong&gt; 集合可以认为是查询条件数据，用来辅助查询条件的计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 为我们提供了 &lt;strong&gt;&lt;em&gt;TYPE&lt;/em&gt;&lt;/strong&gt; 命令来查看某个 &lt;strong&gt;key&lt;/strong&gt; 的数据类型，如：&lt;strong&gt;string&lt;/strong&gt; 类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET string:order:100 order-100
TYPE string:order:100

string&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list&quot;&gt;&lt;strong&gt;&lt;em&gt;List&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;list&lt;/strong&gt; 在提高 &lt;strong&gt;throughput&lt;/strong&gt; 的场景中非常适用，因为它特有的 &lt;strong&gt;LPUSH&lt;/strong&gt;、&lt;strong&gt;RPUSH&lt;/strong&gt;、&lt;strong&gt;LPOP&lt;/strong&gt;、&lt;strong&gt;RPOP&lt;/strong&gt; 功能可以无缝的支持生产者、消费者架构模式。&lt;/p&gt;
&lt;p&gt;这非常适合实现类似 &lt;strong&gt;Java Concurrency&lt;/strong&gt; &lt;strong&gt;Fork/Join&lt;/strong&gt; 框架中的 &lt;strong&gt;&lt;em&gt;work-stealing 算法 (工作窃取)&lt;/em&gt;&lt;/strong&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;java fork/join&lt;/em&gt;&lt;/strong&gt; 框架使用并行来提高性能，但是会带来由于并发 &lt;strong&gt;take task&lt;/strong&gt; 带来的 &lt;strong&gt;race condition (竞态条件)&lt;/strong&gt; 问题，所以采用 &lt;strong&gt;&lt;em&gt;work-stealing 算法&lt;/em&gt;&lt;/strong&gt; 来解决由于竞争问题带来的性能损耗。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/2.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中模拟了一个典型的支付 &lt;strong&gt;callback&lt;/strong&gt; 峰值场景。在峰值出现的地方一般我们都会使用加 &lt;strong&gt;buffer&lt;/strong&gt; 的方式来加快请求处理速度，这样才能提高并发处理能力，提高 &lt;strong&gt;throughput&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;支付&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;gateway&lt;/strong&gt; 收到 &lt;strong&gt;callback&lt;/strong&gt; 之后不做任何处理直接交给 &lt;strong&gt;&lt;em&gt;分发器&lt;/em&gt;&lt;/strong&gt; 。&lt;strong&gt;&lt;em&gt;分发器&lt;/em&gt;&lt;/strong&gt; 是一个无状态的 &lt;strong&gt;cluster&lt;/strong&gt; ，每个 &lt;strong&gt;node&lt;/strong&gt; 通过向 &lt;strong&gt;&lt;em&gt;注册中心&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;pull handler queue list&lt;/strong&gt; ，也就是获取下游处理器注册到注册中心里的消息通道。&lt;/p&gt;
&lt;p&gt;每一个分发器 &lt;strong&gt;node&lt;/strong&gt; 会维护一个本地 &lt;strong&gt;queue list&lt;/strong&gt; ，然后顺序推送消息到这些 &lt;strong&gt;queue list&lt;/strong&gt; 即可。这里会有点小问题，就是 &lt;strong&gt;&lt;em&gt;支付&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;gateway&lt;/strong&gt; 调用分发器的时候是如何做 &lt;strong&gt;load balance&lt;/strong&gt; ，如果不是平均负载可能会有某个 &lt;strong&gt;queue list&lt;/strong&gt; 高出其他 &lt;strong&gt;queue list&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;而分发器不需要做 &lt;strong&gt;soft load balance&lt;/strong&gt; ，因为哪怕某个 &lt;strong&gt;queue list&lt;/strong&gt; 比其他 &lt;strong&gt;queue list&lt;/strong&gt; 多也无所谓，因为下游 &lt;strong&gt;message handler&lt;/strong&gt; 会根据 &lt;strong&gt;work-stealing&lt;/strong&gt; 算法来窃取其他消费慢的 &lt;strong&gt;queue list&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;redis list 的 &lt;strong&gt;LPUSH&lt;/strong&gt;、&lt;strong&gt;RPUSH&lt;/strong&gt;、&lt;strong&gt;LPOP&lt;/strong&gt;、&lt;strong&gt;RPOP&lt;/strong&gt; 特性确实可以在很多场景下提高这种横向扩展计算能力。&lt;/p&gt;
&lt;h3 id=&quot;hash&quot;&gt;&lt;strong&gt;&lt;em&gt;Hash&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;hash&lt;/strong&gt; 数据类型很明显是基于 &lt;strong&gt;hash&lt;/strong&gt; 算法的，对于项的查找时间复杂度是 &lt;strong&gt;O(1)&lt;/strong&gt; 的，在极端情况下可能出现项 &lt;strong&gt;hash&lt;/strong&gt; 冲突问题，&lt;strong&gt;redis&lt;/strong&gt; 内部是使用链表加 &lt;strong&gt;key&lt;/strong&gt; 判断来解决的。具体 &lt;strong&gt;redis&lt;/strong&gt; 内部的数据结构我们在后面有介绍，这里就不展开了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hash&lt;/strong&gt; 数据类型的特点通常可以用来解决带有映射关系，同时又需要对某些项进行更新或者删除等操作。如果不是某个项需要维护，那么一般可以通过使用 &lt;strong&gt;string&lt;/strong&gt; 来解决。&lt;/p&gt;
&lt;p&gt;如果有需要对某个字段进行修改，使用 &lt;strong&gt;string&lt;/strong&gt; 很明显是会多出很多开销，需要读取出来反序列化成对象然后操作，然后再序列化写回 &lt;strong&gt;redis&lt;/strong&gt; ，这中间可能还有并发问题。&lt;/p&gt;
&lt;p&gt;那我们可以使用 &lt;strong&gt;redis hash&lt;/strong&gt; 提供的实体属性 &lt;strong&gt;hash&lt;/strong&gt; 存储特性，我们可以认为 &lt;strong&gt;hash value&lt;/strong&gt; 是一个 &lt;strong&gt;hash table&lt;/strong&gt; ，实体的每一个属性都是通过 &lt;strong&gt;hash&lt;/strong&gt; 得到属性的最终数据索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/3.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图使用 &lt;strong&gt;hash&lt;/strong&gt; 数据类型来记录页面的 &lt;strong&gt;a/b metrics&lt;/strong&gt; ，左边的是首页 &lt;strong&gt;index&lt;/strong&gt; 的各个区域的统计，右边是营销 &lt;strong&gt;marketing&lt;/strong&gt; 的各个区域统计。&lt;/p&gt;
&lt;p&gt;在程序里我们可以很方便的使用 &lt;strong&gt;redis&lt;/strong&gt; 的 &lt;strong&gt;atomic&lt;/strong&gt; 特性对 &lt;strong&gt;hash&lt;/strong&gt; 某个项进行累加操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HMSET hash:mall:page:ab:metrics:index topbanner 10 leftbanner 5 rightbanner 8 bottombanner 20 productmore 10 topshopping 8
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;HGETALL hash:mall:page:ab:metrics:index
 1) &quot;topbanner&quot;
 2) &quot;10&quot;
 3) &quot;leftbanner&quot;
 4) &quot;5&quot;
 5) &quot;rightbanner&quot;
 6) &quot;8&quot;
 7) &quot;bottombanner&quot;
 8) &quot;20&quot;
 9) &quot;productmore&quot;
10) &quot;10&quot;
11) &quot;topshopping&quot;
12) &quot;8&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;HINCRBY hash:mall:page:ab:metrics:index topbanner 1
(integer) 11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;strong&gt;redis hash increment&lt;/strong&gt; 进行原子增加操作。&lt;strong&gt;HINCRBY&lt;/strong&gt; 命令可以原子增加任何给定的整数，也可以通过 &lt;strong&gt;HINCRBYFLOAT&lt;/strong&gt; 来原子增加浮点类型数据。&lt;/p&gt;
&lt;h3 id=&quot;set&quot;&gt;&lt;strong&gt;&lt;em&gt;Set&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt; 集合数据类型可以支持集合运算，不能存储重复数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt; 最大的特点就是集合的计算能力，&lt;strong&gt;&lt;em&gt;inter 交集&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;union 并集&lt;/em&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;em&gt;diff 差集&lt;/em&gt;&lt;/strong&gt;，这些特点可以用来做高性能的交叉计算或者剔除数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt; 集合在使用场景上还是比较多和自由的。举个简单的例子，在应用系统中比较常见的就是商品、活动类场景。用一个 &lt;strong&gt;set&lt;/strong&gt; 缓存有效商品集合，再用一个 &lt;strong&gt;set&lt;/strong&gt; 缓存活动商品集合。如果商品出现上下架操作只需要维护有效商品 &lt;strong&gt;set&lt;/strong&gt; ，每次获取活动商品的时候需要过滤下是否有下架商品，如果有就需要从活动商品中剔除。&lt;/p&gt;
&lt;p&gt;当然，下架的时候可以直接删除缓存的活动商品，但是活动是从 &lt;strong&gt;marketing&lt;/strong&gt; 系统中 &lt;strong&gt;load&lt;/strong&gt; 出来的，就算我将 &lt;strong&gt;cache&lt;/strong&gt; 里的活动商品删除，当下次再从 &lt;strong&gt;marketing&lt;/strong&gt; 系统中 &lt;strong&gt;load&lt;/strong&gt; 活动商品时候还是会有下架商品。当然这只是举例，一个场景有不同的实现方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/4.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中左右两边是两个不同的集合，左边是营销域中的可用商品ids集合，右边是营销域中活动商品ids集合，中间计算出两个集合的交集。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SADD set:marketing:product:available:ids 1000100 1000120 1000130 1000140 1000150 1000160&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SMEMBERS set:marketing:product:available:ids
1) &quot;1000100&quot;
2) &quot;1000120&quot;
3) &quot;1000130&quot;
4) &quot;1000140&quot;
5) &quot;1000150&quot;
6) &quot;1000160&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SADD set:marketing:activity:product:ids 1000100 1000120 1000130 1000140 1000200 1000300&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SMEMBERS set:marketing:activity:product:ids
1) &quot;1000100&quot;
2) &quot;1000120&quot;
3) &quot;1000130&quot;
4) &quot;1000140&quot;
5) &quot;1000200&quot;
6) &quot;1000300&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SINTER set:marketing:product:available:ids set:marketing:activity:product:ids
1) &quot;1000100&quot;
2) &quot;1000120&quot;
3) &quot;1000130&quot;
4) &quot;1000140&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一些复杂的场景中，也可以使用 &lt;strong&gt;SINTERSTORE&lt;/strong&gt; 命令将交集计算后的结果存储在一个目标集合中。 这在使用 &lt;strong&gt;pipeline&lt;/strong&gt; 命令管道中特别有用，将 &lt;strong&gt;SINTERSTORE&lt;/strong&gt; 命令包裹在 &lt;strong&gt;pipeline&lt;/strong&gt; 命令串中可以重复使用计算出来的结果集。&lt;/p&gt;
&lt;p&gt;由于 &lt;strong&gt;redis&lt;/strong&gt; 是 &lt;strong&gt;&lt;em&gt;Signle-Thread 单线程模型&lt;/em&gt;&lt;/strong&gt; ，基于这个特性我们就可以使用 &lt;strong&gt;redis&lt;/strong&gt; 提供的 &lt;strong&gt;pipeline 管道&lt;/strong&gt; 来提交一连串带有逻辑的命令集合，这些命令在处理期间不会被其他客户端的命令干扰。&lt;/p&gt;
&lt;h3 id=&quot;zset&quot;&gt;&lt;strong&gt;&lt;em&gt;Zset&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;zset&lt;/strong&gt; 排序集合与 &lt;strong&gt;set&lt;/strong&gt; 集合类似，但是 &lt;strong&gt;zset&lt;/strong&gt; 提供了排序的功能。在介绍 &lt;strong&gt;set&lt;/strong&gt; 集合的时候我们知道 &lt;strong&gt;set&lt;/strong&gt; 集合中的成员是无序的，&lt;strong&gt;zset&lt;/strong&gt; 填补了集合可以排序的空隙。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;zset&lt;/strong&gt; 最强大的功能就是可以根据某个 &lt;strong&gt;&lt;em&gt;score 比分值&lt;/em&gt;&lt;/strong&gt; 进行排序，这在很多业务场景中非常急需。比如，在促销活动里根据商品的销售数量来排序商品，在旅游景区里根据流入人数来排序热门景点等。&lt;/p&gt;
&lt;p&gt;基本上人们在做任何事情都需要根据某些条件进行排序。&lt;/p&gt;
&lt;p&gt;其实 &lt;strong&gt;zset&lt;/strong&gt; 在我们应用系统中能用到地方到处都是，这里我们举一个简单的例子，在团购系统中我们通常需要根据参团人数来排序成团列表，大家都希望参加那些即将成团的团。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/5.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是一个根据团购code创建的zset，&lt;strong&gt;&lt;em&gt;score 分值&lt;/em&gt;&lt;/strong&gt; 就是参团人数累加和。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZADD zset:marketing:groupon:group:codes 5 G_PXYJY9QQFA 8 G_4EXMT6NZJQ 20 G_W7BMF5QC2P 10 G_429DHBTGZX 8 G_KHZGH9U4PP&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ZREVRANGEBYSCORE zset:marketing:groupon:group:codes 1000 0
1) &quot;G_W7BMF5QC2P&quot;
2) &quot;G_ZMZ69HJUCB&quot;
3) &quot;G_429DHBTGZX&quot;
4) &quot;G_KHZGH9U4PP&quot;
5) &quot;G_4EXMT6NZJQ&quot;
6) &quot;G_PXYJY9QQFA&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ZREVRANGEBYSCORE zset:marketing:groupon:group:codes 1000 0 withscores
 1) &quot;G_W7BMF5QC2P&quot;
 2) &quot;20&quot;
 3) &quot;G_ZMZ69HJUCB&quot;
 4) &quot;10&quot;
 5) &quot;G_429DHBTGZX&quot;
 6) &quot;10&quot;
 7) &quot;G_KHZGH9U4PP&quot;
 8) &quot;8&quot;
 9) &quot;G_4EXMT6NZJQ&quot;
10) &quot;8&quot;
11) &quot;G_PXYJY9QQFA&quot;
12) &quot;5&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;zset&lt;/strong&gt; 本身提供了很多方法用来进行集合的排序，如果需要 &lt;strong&gt;score&lt;/strong&gt; 分值可以使用 &lt;strong&gt;withscore&lt;/strong&gt; 字句带出每一项的分值。&lt;/p&gt;
&lt;p&gt;在一些比较特殊的场合可能需要组合排序，可能有多个 &lt;strong&gt;zset&lt;/strong&gt; 分别用来对同一个实体在不同维度的排序，按时间排序、按人数排序等。这个时候就可以组合使用 &lt;strong&gt;zset&lt;/strong&gt; 带来的便捷性，利用 &lt;strong&gt;pipeline&lt;/strong&gt; 再结合多个 &lt;strong&gt;zset&lt;/strong&gt; 最终得出组合排序集合。&lt;/p&gt;
&lt;h2 id=&quot;案例沪江团购系统大促-hot-top-接口-cache-设计&quot;&gt;案例：沪江团购系统大促 &lt;strong&gt;hot-top&lt;/strong&gt; 接口 &lt;strong&gt;cache&lt;/strong&gt; 设计&lt;/h2&gt;
&lt;p&gt;我们总结了 &lt;strong&gt;redis&lt;/strong&gt; 提供的 &lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt; 种数据类型的各自特点和一般的使用场景。但是我们不仅仅可以分开使用这些数据类型，我们完全可以综合使用这些数据类型来完成复杂的 &lt;strong&gt;cache&lt;/strong&gt; 场景。&lt;/p&gt;
&lt;p&gt;下面我们分享一个使用多个 &lt;strong&gt;zset&lt;/strong&gt; 、&lt;strong&gt;string&lt;/strong&gt; 来优化 &lt;strong&gt;&lt;em&gt;团购系统&lt;/em&gt;&lt;/strong&gt; 前台接口的例子。由于篇幅和时间限制，这里只介绍跟本次案例相关的信息。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;hot-top&lt;/strong&gt; 接口是指热点、排名接口的意思，表示它的浏览量、并发量比较高，一般大促的时候都会有几个这种性能要求比较高的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先来分析一个查询接口所包含的常规信息。&lt;/p&gt;
&lt;p&gt;首先一个查询接口肯定是有 &lt;strong&gt;&lt;em&gt;query condition 查询条件&lt;/em&gt;&lt;/strong&gt; ，然后是 &lt;strong&gt;sort 排序信息&lt;/strong&gt;_ 、最后是 &lt;strong&gt;page 分页信息&lt;/strong&gt;_ 。这是一般接口所承担的基本职责，当然，特殊场景下还需要支持 &lt;strong&gt;&lt;em&gt;master/slave replication&lt;/em&gt;&lt;/strong&gt; 时关于数据 &lt;strong&gt;&lt;em&gt;session 一致性&lt;/em&gt;&lt;/strong&gt; 的要求，需要提供跟踪标记来回 &lt;strong&gt;master&lt;/strong&gt; 查询数据，这里就不展开了。&lt;/p&gt;
&lt;p&gt;我们可以抽象出这几个维度的信息：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;query condition&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;查询条件，companyid=100，sellerid=1010101 诸如此类。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;sort&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;排序信息，一般是默认一个列排序，但是在复杂的场景下会有可能让接口使用者定制排序字段，比如一些租户信息列。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;page&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;分页信息，简单理解就是数据记录排完序之后的第几行到第几行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于这里我们纯粹用 &lt;strong&gt;redis&lt;/strong&gt; 来提高 &lt;strong&gt;cache&lt;/strong&gt; 能力，不涉及到有关于任何搜索的能力，所以这里忽略其他复杂查询的情况。其实我们在复杂的地方使用了 &lt;strong&gt;elastcsearch&lt;/strong&gt; 来提高搜索能力。&lt;/p&gt;
&lt;p&gt;上述我们分析总结出了一个查询接口的基本信息，这里还有一个有关于高并发接口的设计原则就是将 &lt;strong&gt;hot-top&lt;/strong&gt; 接口和一般 &lt;strong&gt;search&lt;/strong&gt; 接口分离开，因为只有分而治之才能分别根据特点选用不同的技术。如果我们不分职责将所有的查询场景封装在一个接口里，那么在后面优化接口性能的时候基本就很麻烦了，有些场景是无法或者很难用 &lt;strong&gt;cache&lt;/strong&gt; 来解决的，因为接口里耦合了各种场景逻辑，就算勉强能实现性能也不会高。&lt;/p&gt;
&lt;p&gt;前面做这些铺垫是为了能在介绍案例的时候达成一个基本的共识。现在我们来看下这个团购系统的 &lt;strong&gt;hot-top&lt;/strong&gt; 接口的具体逻辑。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在大促的时候需要展现团购列表，这个接口的访问量是非常大的，团购活动需要根据参团人数倒序排序，并且分页返回指定数量的团列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们假设这个接口名为 &lt;strong&gt;&lt;em&gt;getTopGroups(getTopGroupsRequest request)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;query-condition-查询条件问题&quot;&gt;&lt;strong&gt;&lt;em&gt;query condition 查询条件问题&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们来仔细分析下，首先不同的查询条件从 &lt;strong&gt;DB&lt;/strong&gt; 里查询出来的数据是不一样的，也就是说查询出来的团列表是不一样的，可能有 &lt;strong&gt;&lt;em&gt;company 公司&lt;/em&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;em&gt;channel 渠道&lt;/em&gt;&lt;/strong&gt; 等过滤条件。由于一个团购活动下不会有太多团，顶多上百个是极限了，所以一个查询条件出来的团列表也顶多几十个，而且根据场景分析热点查询条件不会超过十个，所以我们选择将 &lt;strong&gt;&lt;em&gt;查询条件 hash&lt;/em&gt;&lt;/strong&gt; 出一个 &lt;strong&gt;code&lt;/strong&gt; 来缓存本次查询条件的全量团列表集合，但是这些结果集是没有任何排序的。&lt;/p&gt;
&lt;h3 id=&quot;sort-排序问题&quot;&gt;&lt;strong&gt;&lt;em&gt;sort 排序问题&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;再看根据参团人数排序问题，我们立刻就可以想到使用 &lt;strong&gt;zset&lt;/strong&gt; 来处理团排序问题，因为只有一个排序维度，所以一个 &lt;strong&gt;zset&lt;/strong&gt; 就够了。我们使用一个 __zset__来缓存所有团的参团人数集合，它是一个全量的团排序集合。&lt;/p&gt;
&lt;p&gt;那么我们如何将用户的查询条件出来的团列表根据参团人数排序尼，刚好可以使用 &lt;strong&gt;zset&lt;/strong&gt; 的交集运算直接计算出当前这个集合的 &lt;strong&gt;zset&lt;/strong&gt; 子集。&lt;/p&gt;
&lt;h3 id=&quot;page-分页问题&quot;&gt;&lt;strong&gt;&lt;em&gt;page 分页问题&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过对已经排序之后的团列表 &lt;strong&gt;zset&lt;/strong&gt; 使用 &lt;strong&gt;zrange&lt;/strong&gt; 来获取出分页集合。&lt;/p&gt;
&lt;p&gt;我们来看下完整的流程，如何处理查询、排序、分页的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/6.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图从 &lt;strong&gt;query condition&lt;/strong&gt; 计算 &lt;strong&gt;hash code&lt;/strong&gt; ，然后通过 &lt;strong&gt;DB&lt;/strong&gt; 查询出当前条件全量团列表。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;zset:marketing:groupon:hottop:available:group key&lt;/em&gt;&lt;/strong&gt; 表示全量团的参团人数，用一个 &lt;strong&gt;zset&lt;/strong&gt; 来缓存。接着将这两个 &lt;strong&gt;zset&lt;/strong&gt; 计算交集，就可以得出当前查询所需要的带有参团人数的 &lt;strong&gt;zset&lt;/strong&gt; ，最后在使用 &lt;strong&gt;zrevrange&lt;/strong&gt; 获取分页区间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZADD zset:marketing:groupon:hottop:condition:2986080 0 G4ZD5732YZQ 0 G5VW3YF42UC 0 GF773FEJ7CC 0 GFW8DUEND8S 0 GKPKKW8XEY9 0 GL324DGWMZM
(integer) 6&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ZADD zset:marketing:groupon:hottop:available:group 5 GN7KQH36ZWK 10 GS7VB22AWD4 15 GF773FEJ7CC 17 G5VW3YF42UC 18 G4ZD5732YZQ 32 GTYJKCEJBRR 40 GKPKKW8XEY9 45 GL324DGWMZM 50 GFW8DUEND8S 60 GYTKY4ACWLT
(integer) 10&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ZINTERSTORE zset:marketing:groupon:hottop:condition:interstore 2 zset:marketing:groupon:hottop:condition:2986080 zset:marketing:groupon:hottop:available:group
(integer) 6&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ZRANGE zset:marketing:groupon:hottop:condition:interstore 0 -1 withscores
 1) &quot;GF773FEJ7CC&quot;
 2) &quot;15&quot;
 3) &quot;G5VW3YF42UC&quot;
 4) &quot;17&quot;
 5) &quot;G4ZD5732YZQ&quot;
 6) &quot;18&quot;
 7) &quot;GKPKKW8XEY9&quot;
 8) &quot;40&quot;
 9) &quot;GL324DGWMZM&quot;
10) &quot;45&quot;
11) &quot;GFW8DUEND8S&quot;
12) &quot;50&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ZREVRANGE zset:marketing:groupon:hottop:condition:interstore 2 4 withscores
1) &quot;GKPKKW8XEY9&quot;
2) &quot;40&quot;
3) &quot;G4ZD5732YZQ&quot;
4) &quot;18&quot;
5) &quot;G5VW3YF42UC&quot;
6) &quot;17&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了返回的团 &lt;strong&gt;code&lt;/strong&gt; 集合之后就可以通过 &lt;strong&gt;mget&lt;/strong&gt; 来批量获取 &lt;strong&gt;string&lt;/strong&gt; 类型的团详情信息，这里就不贴出代码了。&lt;/p&gt;
&lt;p&gt;由于篇幅和时间关系，这里就不展开太多的业务场景介绍了。这其中还涉及到计算 &lt;strong&gt;cache&lt;/strong&gt; 过期时间的问题，这也跟促销活动的运营规则有关系，还涉及到有可能 &lt;strong&gt;&lt;em&gt;query condition hash&lt;/em&gt;&lt;/strong&gt; 冲突问题等，但是这些已经不与我们本节主题相关。&lt;/p&gt;
&lt;h2 id=&quot;redis-内存数据结构与编码&quot;&gt;Redis 内存数据结构与编码&lt;/h2&gt;
&lt;p&gt;我们已经了解了 &lt;strong&gt;redis&lt;/strong&gt; 提供的 &lt;strong&gt;5&lt;/strong&gt; 种数据类型，那么 &lt;strong&gt;redis&lt;/strong&gt; 内部到底是如何支持这 &lt;strong&gt;5&lt;/strong&gt; 种数据类型的，也就是说 &lt;strong&gt;redis&lt;/strong&gt; 到底是使用什么样的数据结构来存储、查找我们设置在内存中的数据。&lt;/p&gt;
&lt;p&gt;虽然我们使用 &lt;strong&gt;5&lt;/strong&gt; 种数据类型来缓存数据，但是 &lt;strong&gt;redis&lt;/strong&gt; 会根据我们存储数据的不同而选用不同的数据结构和编码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/7.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们日常使用的是 &lt;strong&gt;redis&lt;/strong&gt; 提供的 &lt;strong&gt;5&lt;/strong&gt; 种数据类型，但是这 &lt;strong&gt;5&lt;/strong&gt; 种数据类型在内存中的数据结构和编码有很多种。随着我们存储的数据类型的不同、数据量的大小不同都会引起内存数据结构的动态调整。&lt;/p&gt;
&lt;p&gt;本节只是做数据结构和编码的一般性介绍，不做过多细节讨论，一方面是关于 &lt;strong&gt;redis&lt;/strong&gt; 源码分析的资料网上有很多，还有一个原因就是 &lt;strong&gt;redis&lt;/strong&gt; 每一个版本的实现有很大差异，一旦展开细节讨论每一个点每一个数据结构都会很复杂，所以我们这里就不展开讨论这些，只是起到抛砖引玉作用。&lt;/p&gt;
&lt;h3 id=&quot;object-encoding-keydebug-object-key&quot;&gt;&lt;strong&gt;OBJECT&lt;/strong&gt; encoding key、&lt;strong&gt;DEBUG OBJECT&lt;/strong&gt; key&lt;/h3&gt;
&lt;p&gt;我们知道使用 &lt;strong&gt;type&lt;/strong&gt; 命令可以查看某个 &lt;strong&gt;key&lt;/strong&gt; 是否是 &lt;strong&gt;5&lt;/strong&gt; 种数据类型之一，但是当我们想查看某个 &lt;strong&gt;key&lt;/strong&gt; 底层是使用哪种数据结构和编码来存储的时候可以使用 &lt;strong&gt;&lt;em&gt;OBJECT encoding&lt;/em&gt;&lt;/strong&gt; 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SET string:orderid:10101010 10101010
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;OBJECT encoding string:orderid:10101010
&quot;int&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SET string:orderid:10101010 &quot;orderid:10101010&quot;
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;OBJECT encoding string:orderid:10101010
&quot;embstr&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样一个 &lt;strong&gt;key&lt;/strong&gt; ，但是由于我们设置的值不同而 &lt;strong&gt;redis&lt;/strong&gt; 选用了不同的内存数据结构和编码。虽然 &lt;strong&gt;redis&lt;/strong&gt; 提供的 &lt;strong&gt;string&lt;/strong&gt; 数据类型，但是 &lt;strong&gt;redis&lt;/strong&gt; 会自动识别我们 &lt;strong&gt;cache&lt;/strong&gt; 的数据类型是 &lt;strong&gt;int&lt;/strong&gt; 还是 &lt;strong&gt;string&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;如果我们设置的是字符串，且这个字符串长度不大于 &lt;strong&gt;39&lt;/strong&gt; 字节那么将使用 &lt;strong&gt;embstr&lt;/strong&gt; 来编码，如果大于 &lt;strong&gt;39&lt;/strong&gt; 字节将使用 &lt;strong&gt;raw&lt;/strong&gt; 来编码。&lt;strong&gt;redis 4.0&lt;/strong&gt; 将这个阀值扩大了 &lt;strong&gt;45&lt;/strong&gt; 个字节。&lt;/p&gt;
&lt;p&gt;除了使用 &lt;strong&gt;&lt;em&gt;OBJECT encoding&lt;/em&gt;&lt;/strong&gt; 命令外，我们还可以使用 &lt;strong&gt;&lt;em&gt;DEBUG OBJECT&lt;/em&gt;&lt;/strong&gt; 命令来查看更多详细信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG OBJECT string:orderid:10101010
Value at:0x7fd190500210 refcount:1 encoding:int serializedlength:5 lru:6468044 lru_seconds_idle:8&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;DEBUG OBJECT string:orderid:10101010
Value at:0x7fd19043be60 refcount:1 encoding:embstr serializedlength:17 lru:6465804 lru_seconds_idle:1942&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DEBUG OBJECT&lt;/strong&gt; 能看到这个对象的 &lt;strong&gt;&lt;em&gt;refcount 引用计数&lt;/em&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;em&gt;serializedlength 长度&lt;/em&gt;&lt;/strong&gt; 、&lt;strong&gt;&lt;em&gt;lru_seconds_idle 时间&lt;/em&gt;&lt;/strong&gt; ，这些信息决定了这个 &lt;strong&gt;key&lt;/strong&gt; 缓存清除策略。&lt;/p&gt;
&lt;h3 id=&quot;简单动态字符串simple-dynamic-string&quot;&gt;简单动态字符串（simple dynamic string）&lt;/h3&gt;
&lt;p&gt;简单动态字符串简称 &lt;strong&gt;SDS&lt;/strong&gt; ，在 &lt;strong&gt;redis&lt;/strong&gt; 中所有涉及到字符串的地方都是使用 &lt;strong&gt;SDS&lt;/strong&gt; 实现，当然这里不包括字面量。 &lt;strong&gt;SDS&lt;/strong&gt; 与传统 &lt;strong&gt;C&lt;/strong&gt; 字符串的区别就是 &lt;strong&gt;SDS&lt;/strong&gt; 是结构化的，它可以高效的处理分配、回收、长度计算等问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct sdshdr {
    unsigned int len;
    unsigned int free;
    char buf[];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是 &lt;strong&gt;redis 3.0&lt;/strong&gt; 版本的 &lt;strong&gt;sds.h&lt;/strong&gt; 头文件定义，&lt;strong&gt;3.0.0&lt;/strong&gt; 之后变化比较大。&lt;strong&gt;len&lt;/strong&gt; 表示字符串长度，&lt;strong&gt;free&lt;/strong&gt; 表示空间长度，&lt;strong&gt;buf&lt;/strong&gt; 数组表示字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SDS&lt;/strong&gt; 有很多优点，比如，获取长度的时间复杂度 &lt;strong&gt;O(1)&lt;/strong&gt; ，不需要遍历所有 &lt;strong&gt;char buf[]&lt;/strong&gt; 组数，直接返回 &lt;strong&gt;len&lt;/strong&gt; 值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static inline size_t sdslen(const sds s) {
    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
    return sh-&amp;gt;len;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然还有空间分配检查、空间预分配、空间惰性释放等，这些都是 &lt;strong&gt;SDS&lt;/strong&gt; 结构化字符串带来的强大的扩展能力。&lt;/p&gt;
&lt;h3 id=&quot;链表linked-list&quot;&gt;链表（linked list）&lt;/h3&gt;
&lt;p&gt;链表数据结构我们是比较熟悉的，最大的特点就是节点的增、删非常灵活。&lt;strong&gt;redis List&lt;/strong&gt; 数据类型底层就是基于链表来实现。这是 &lt;strong&gt;redis 3.0&lt;/strong&gt; 实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;redis 3.2.0&lt;/strong&gt; 版本的时候引入了 &lt;strong&gt;quicklist&lt;/strong&gt; 链表结构，结合了 &lt;strong&gt;linkedlist&lt;/strong&gt; 和 &lt;strong&gt;ziplist&lt;/strong&gt; 的优势。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all ziplists */
    unsigned int len;           /* number of quicklistNodes */
    int fill : 16;              /* fill factor for individual nodes */
    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */
} quicklist;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *zl;
    unsigned int sz;             /* ziplist size in bytes */
    unsigned int count : 16;     /* count of items in ziplist */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int extra : 10; /* more bits to steal for future usage */
} quicklistNode;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;quicklist&lt;/strong&gt; 提供了灵活性同时也兼顾了 &lt;strong&gt;ziplist&lt;/strong&gt; 的压缩能力，&lt;strong&gt;quicklist-&amp;gt;encoding&lt;/strong&gt; 指定了两种压缩算法。 &lt;strong&gt;quicklist-&amp;gt;compress&lt;/strong&gt; 表示我们可以进行 &lt;strong&gt;quicklist node&lt;/strong&gt; 的深度压缩能力。redis 提供了两个有关于压缩的配置。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;list-max-ziplist-size：ziplist长度控制&lt;br/&gt;list-compress-depth：控制链表两端节点的压缩个数，越是靠近两端的节点被访问的机率越大，所以可以将访问机率大的节点不压缩，其他节点进行压缩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对比 &lt;strong&gt;redis 3.2&lt;/strong&gt; 的 &lt;strong&gt;quicklist&lt;/strong&gt; 与 &lt;strong&gt;redis 3.0&lt;/strong&gt; ，很明显 &lt;strong&gt;quicklist&lt;/strong&gt; 提供了更加丰富的压缩功能。&lt;strong&gt;redis 3.0&lt;/strong&gt; 的版本是每个 &lt;strong&gt;listnode&lt;/strong&gt; 直接缓存值，而 &lt;strong&gt;quicklistnode&lt;/strong&gt; 还有强大的有关于压缩能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LPUSH list:products:mall 100 200 300
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;OBJECT encoding list:products:mall
&quot;quicklist&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 21 Jan 2018 03:05:00 +0000</pubDate>
<dc:creator>王清培</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangiqngpei557/p/8323680.html</dc:identifier>
</item>
<item>
<title>10 - JavaSE之网络编程 - Daotin</title>
<link>http://www.cnblogs.com/lvonve/p/8323667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvonve/p/8323667.html</guid>
<description>&lt;p&gt;网络编程&lt;/p&gt;
&lt;p&gt;网络通信协议分层思想&lt;/p&gt;
&lt;p&gt;为什么要分层呢？因为整个网络协议非常复杂，要涉及到方方面面的知识，而且还有对底层硬件的操作，利用分层的思想，我们可以将复杂的通信协议分割成一层层的形式，上一层可以调用下一层，而与再下一层不发生关系，各层之间互不影响，便于系统的开发。我们把用户程序作为最高层，把物理通信线路作为最底层，高层到底层一步步封装，我们不需要直接操作底层，而是操作最简单的最高层，这就是分层的意义。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考模型&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;OSI七层模型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;物理层、数据链路层、网络层、传输层、会话层、表示层、应用层&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TCP/IP参考模型&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;应用层、传输层（TCP/UDP层）、网络层（IP层）、数据链路层、物理层&lt;/p&gt;
&lt;p&gt;我们今天要讲的主要是传输层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/754332/201801/754332-20180121110025271-1607514729.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;IP协议&lt;/p&gt;
&lt;p&gt;IP层：给我们做的最大贡献就是提供了独一无二的IP地址。&lt;/p&gt;
&lt;p&gt;IP TCP UDP 网关 内网 子网掩码&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TCP是Transfer Control Protocol（传输控制协议）的简称，是一种面向连接的保证可靠传输的协议。一个TCP连接必须要经过三次“对话”才能建立起来。&lt;/li&gt;
&lt;li&gt;在TCP/IP协议中，IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一确定Internet上的一台主机。而TCP层则提供面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。&lt;/li&gt;
&lt;li&gt;发送方和接收方的成对的两个socket之间必须建立连接，以便在TCP协议的基础上进行通信。当一个socket（通常都是serversocket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送或接收操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;UDP是User Datagram Protocol的简称，是一种无连接的协议。UDP是从一台计算机向另一台计算机发送称为数据报的独立数据包的协议，该协议并不保证数据报是否能正确地到达目的地，它是一个非面向连接的协议。每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达时间以及内容的正确性都是不能保证的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TCP和UDP的比较&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;使用UDP时，每个数据报中都给出了完整的地址信息，因此无需建立发送方和接收方的连接。对于TCP协议，由于它是一个面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中多了一个连接建立的时间。&lt;/li&gt;
&lt;li&gt;使用UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。TCP没有这方面的限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大量的数据。&lt;/li&gt;
&lt;li&gt;UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方；TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。&lt;/li&gt;
&lt;li&gt;可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽。因此TCP传输的效率不如UDP高。&lt;/li&gt;
&lt;li&gt;TCP在网路通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。相比之下UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;两个 Java 应用程序可以通过一个双向的网络通信连接实现数据交换，这个双向链路的一端称为一个Socket。&lt;/li&gt;
&lt;li&gt;Socket 通常用来实现 client-server 连接。&lt;/li&gt;
&lt;li&gt;java.net 包中定义的两个类 Socket 和 ServerSocket ，分别用来实现双向连接的 client 和 server 端。&lt;/li&gt;
&lt;li&gt;建立连接时所需的寻址信息为远程计算机的 IP 地址和端口号（Port）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;端口：用于区分不同的网络应用程序 ，占两个字节，所以共有 65535 个端口号。不过系统会随时征用 1024 以下端口。&lt;/p&gt;
&lt;p&gt;端口又分TCP和UDP端口，各有 65535 个端口。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;TCP Socket 通信模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/754332/201801/754332-20180121110039334-2144233647.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;示例1：最简单的Socket模型：Client写数据务器读数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Server
import java.net.*;
import java.io.*;

public class Server {
    public static void main(String[] args) throws Exception {
        ServerSocket ss = new ServerSocket(6666); // 已经开始监听6666端口了      
        while(true) {
            Socket s = ss.accept(); // ss建立一个插座Socket，接受和客户端s的连接（阻塞式连接）,连接成功，相当于服务器和客户端之间连接了两根管道。读的管道（InputStream）和写的管道（OutputStream）。
            System.out.println(&quot;A Client has Connected!&quot;);
            DataInputStream dis = new DataInputStream(s.getInputStream());
            System.out.println(dis.readUTF());// 所以先获取管道，要说就获取写的管道，要听就获取读的管道。
            dis.close();
            s.close();
        }
    }
}

// Client
import java.net.*;
import java.io.*;

public class Client {
    public static void main(String[] args) throws Exception {
        Socket s = new Socket(&quot;127.0.0.1&quot;, 6666);// 申请和ss建立连接   
        DataOutputStream dos = new DataOutputStream(s.getOutputStream());       
        dos.writeUTF(&quot;Hello TCP.&quot;); // 连接好之后开始说话，通过管道流的方式来说话，所以先获取管道，要说就获取写的管道，要听就获取读的管道。   
        dos.flush();
        dos.close();
        s.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Client 端的 IP 地址不能随意指定，不知为何。&lt;/p&gt;
&lt;p&gt;示例2：服务器向客户端发送数据，客户端接收数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Server
import java.net.*;
import java.io.*;

public class Server {
    public static void main(String[] args) {
        try {
            ServerSocket ss = new ServerSocket(6666);       
            while(true) {
                Socket s = ss.accept();
                System.out.println(&quot;A Client has Connected!&quot;);
                DataOutputStream dos = new DataOutputStream(s.getOutputStream());
                dos.writeUTF(&quot;Hi [#IP:&quot; + s.getInetAddress() + &quot; #Port:&quot; + s.getPort() + &quot;], I'm Server.&quot;);
                dos.close();
                s.close();
            }
        } catch (IOException e) {
            System.out.println(&quot;Server Error!!!&quot;);
            e.printStackTrace();
        }
    }
}

// Client
import java.net.*;
import java.io.*;

public class Client {
    public static void main(String[] args) {
        try {
            Socket s = new Socket(&quot;127.0.0.1&quot;, 6666);       
            DataInputStream dis = new DataInputStream(s.getInputStream());      
            System.out.println(dis.readUTF());  
            dis.close();
            s.close();
        } catch(IOException e) {
            System.out.println(&quot;Client Error!!!&quot;);
            e.printStackTrace();
        }
    }
}
//I:\Java\Demo&amp;gt;java Client
//Hi [#IP:/127.0.0.1 #Port:15944], I'm Server.

//I:\Java\Demo&amp;gt;java Client
//Hi [#IP:/127.0.0.1 #Port:15953], I'm Server.

//I:\Java\Demo&amp;gt;java Client
//Hi [#IP:/127.0.0.1 #Port:15954], I'm Server.

//I:\Java\Demo&amp;gt;java Client
//Hi [#IP:/127.0.0.1 #Port:15955], I'm Server.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例3：服务器和客户端同时读写数据（当然一个先读一个先写喽，如果两个都读或都写的话就卡死啦）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Server
// 服务器先接收客户端的数据，然后再发送数据给客户端
import java.net.*;
import java.io.*;

public class Server {
    public static void main(String[] args) {
        try {
            ServerSocket ss = new ServerSocket(6666);
            Socket s = ss.accept();
            
            System.out.println(&quot;A Client has Connected!&quot;);
            
            DataInputStream dis = new DataInputStream(s.getInputStream());
            DataOutputStream dos = new DataOutputStream(s.getOutputStream());
            
            String str = null;
            if((str=dis.readUTF()) != null)
            {
                System.out.println(&quot;I'm reseaving message...&quot;);
                Thread.sleep(3000);
                dos.writeUTF(&quot;Hi [#IP:&quot; + s.getInetAddress() + &quot; #Port:&quot; + s.getPort() + &quot;], I hava reseaved: &quot; + str);
            }
            
            dis.close();
            dos.close();
            s.close();
        } catch (IOException e) {
            System.out.println(&quot;Server Error!!!&quot;);
            e.printStackTrace();
        }
        catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


// Client
// 客户端先发送数据给服务器，再接收服务器的回复。
import java.net.*;
import java.io.*;

public class Client {
    public static void main(String[] args) {
        try {
            Socket s = new Socket(&quot;localhost&quot;, 6666);
            
            DataInputStream dis = new DataInputStream(s.getInputStream());
            DataOutputStream dos = new DataOutputStream(s.getOutputStream());
            
            System.out.println(&quot;Hi Server, I'm sending message to you...&quot;);
            
            Thread.sleep(2000);
            
            dos.writeUTF(&quot;Hello HYJ.&quot;);
            System.out.println(dis.readUTF());
            
            dis.close();
            s.close();
        } catch(UnknownHostException e) {
            e.printStackTrace();
        } catch(IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：这里面使用的是 Socket s = new Socket(&quot;localhost&quot;, 6666);&lt;/p&gt;
&lt;p&gt;最后要 catch(UnknownHostException e)，UnknownHostException 小于 IOException 所以要放前面。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;UDP 通信模型&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// UDPServer 接收并打印来自客户端的数据
import java.net.*;
import java.io.*;

public class UDPServer {
    public static void main(String[] args) {
        try {
            byte[] buf = new byte[1024];
            DatagramPacket dp = new DatagramPacket(buf, buf.length);
            DatagramSocket ds = new DatagramSocket(8888);
            while(true) {
                ds.receive(dp);
                //ByteArrayInputStream bais = new ByteArrayInputStream(buf);
                //DataInputStream dis = new DataInputStream(bais);
                //System.out.println(&quot;UDPClient: &quot; + dis.readUTF());
               System.out.println(&quot;UDPClient: &quot; + new String(buf, 0, dp.getLength()));
            }           
        } catch (IOException e) {
            System.out.println(&quot;UDPServer Error!!!&quot;);
            e.printStackTrace();
        }
    }
}


// UDPClient 发送数据给服务器
import java.net.*;
import java.io.*;

public class UDPClient {
    public static void main(String[] args) {
        try {
            //ByteArrayOutputStream baos = new ByteArrayOutputStream();         
            //DataOutputStream dos = new DataOutputStream(baos);
            
            //dos.writeUTF(&quot;Hello HYJ!&quot;);
            //dos.flush();

            //byte[] buf = baos.toByteArray();
           byte[] buf = (new String(&quot;Hello HYJ!&quot;)).getBytes();
            System.out.println(&quot;buf.length = &quot; + buf.length);
            
            DatagramPacket dp = new DatagramPacket(buf, buf.length, new InetSocketAddress(&quot;127.0.0.1&quot;, 8888));
            DatagramSocket ds = new DatagramSocket(7777);
            
            ds.send(dp);
            ds.close();
            
        } catch(IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 21 Jan 2018 03:01:00 +0000</pubDate>
<dc:creator>Daotin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvonve/p/8323667.html</dc:identifier>
</item>
<item>
<title>全面总结： Golang 调用 C/C++，例子式教程 - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/8323487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/8323487.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;大部分人学习或者使用某样东西喜欢在直观上看到动手后的结果才会有继续下去的兴趣&quot;&gt;大部分人学习或者使用某样东西，喜欢在直观上看到动手后的结果，才会有继续下去的兴趣。&lt;/h4&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言：&lt;/h3&gt;
&lt;p&gt;Golang 调用 C/C++ 的教程网上很多，就我目前所看到的，个人见解就是比较乱，坑也很多。希望本文能在一定程度上，做到更通俗明了。&lt;/p&gt;
&lt;h4 id=&quot;下面-golang-简称-go-一如既往少说废话我们现在开始&quot;&gt;下面 golang 简称 go , 一如既往，少说废话，我们现在开始。&lt;/h4&gt;
&lt;hr/&gt;&lt;h2 id=&quot;go-调用-cc-函数的实现方式有&quot;&gt;go 调用 c/c++ 函数的实现方式有：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;直接&lt;code&gt;嵌套&lt;/code&gt;在go文件中使用，最简单直观的&lt;/li&gt;
&lt;li&gt;导入&lt;code&gt;动态库 .so 或 dll&lt;/code&gt; 的形式，最安全但是很不爽也比较慢的&lt;/li&gt;
&lt;li&gt;直接引用 c/c++ 文件的形式，层次分明，容易随时修改看结果的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第三个&lt;code&gt;直接引用 c/c++ 文件的形式&lt;/code&gt; 是我要介绍的重点。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;需要的环境支持&quot;&gt;需要的环境支持&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Linux 具备 gcc 与 g++ 即可&lt;/li&gt;
&lt;li&gt;Windows 需要安装 &lt;a href=&quot;http://www.mingw.org/&quot;&gt;mingw&lt;/a&gt;，否则编译时会有这类错：&lt;code&gt;cannot find -lmingwex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Mac 参考 Linux&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;直接嵌套在go文件&quot;&gt;1，直接嵌套在go文件&lt;/h2&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main
/*
// C 标志io头文件，你也可以使用里面提供的函数
#include &amp;lt;stdio.h&amp;gt; 

void pri(){
    printf(&quot;hey&quot;);
}

int add(int a,int b){
    return a+b;
}
*/
import &quot;C&quot;  // 切勿换行再写这个

import &quot;fmt&quot;

func main() {
    fmt.Println(C.add(2, 1))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码，直接拷贝运行就能输出结果：3&lt;/p&gt;
&lt;h4 id=&quot;结论&quot;&gt;结论：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;但凡要引用与 c/c++ 相关的内容，写到 go 文件的头部&lt;code&gt;注释&lt;/code&gt;里面&lt;/li&gt;
&lt;li&gt;嵌套的 c/c++ 代码必须符合其语法，不与 go 一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import &quot;C&quot;&lt;/code&gt; 这句话要紧随，注释后，不要换行，否则报错&lt;/li&gt;
&lt;li&gt;go 代码中调用 c/c++ 的格式是: &lt;code&gt;C.xxx()&lt;/code&gt;，例如 C.add(2, 1)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;导入动态库-.so-或-.dll-的形式&quot;&gt;2，导入动态库 .so 或 .dll 的形式&lt;/h2&gt;
&lt;h4 id=&quot;假设项目目录如下&quot;&gt;假设项目目录如下&lt;/h4&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;|-project
|  |-lib
|  |  |-libvideo.dll
|  |  |-libvideo.so
|  |-include
|  |  |-video.h
|  |-src
|  |  |-main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;头文件-.h-如下面这样&quot;&gt;头文件 .h 如下面这样&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;//video.h&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#ifndef VIDEO_H&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define VIDEO_H&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; exeFFmpegCmd(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* cmd); &lt;span class=&quot;co&quot;&gt;// 声明&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#endif&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;源文件-.c-如下面这样&quot;&gt;源文件 .c 如下面这样&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &quot;video.h&quot;&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; exeFFmpegCmd(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;* cmd){ &lt;span class=&quot;co&quot;&gt;// 实现&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// ....&lt;/span&gt;
    printf(&lt;span class=&quot;st&quot;&gt;&quot;finish&quot;&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;使用-gcc-或-g-生成-.so库或-win-下生成-dll&quot;&gt;使用 gcc 或 g++ 生成 .so库，或 win 下生成 dll&lt;/h4&gt;
&lt;p&gt;例如： &lt;code&gt;gcc video.c -fPIC -shared -o libvideo.so&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;最后-main.go&quot;&gt;最后 main.go&lt;/h4&gt;
&lt;p&gt;把动态库放到一个你喜欢的目录，也可以放到当前项目里面，像上面列出的例子一样。再引用&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;#cgo CFLAGS: -Iinclude&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;#cgo LDFLAGS: -Llib -llibvideo&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;#include &quot;video.h&quot;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;C&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    cmd := C.CString(&lt;span class=&quot;st&quot;&gt;&quot;ffmpeg -i ./xxx/*.png ./xxx/yyy.mp4&quot;&lt;/span&gt;)
    C.exeFFmpegCmd(&amp;amp;cmd)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;先回答为什么说这种是最安全的和最不爽的原因如下&quot;&gt;先回答为什么说这种是最安全的和最不爽的？原因如下：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;动态库破解十分困难，如果你的 go 代码泄露，核心动态库没那么容易被攻破&lt;/li&gt;
&lt;li&gt;动态库会在被使用的时候被加载，影响速度&lt;/li&gt;
&lt;li&gt;操作难度比方式一麻烦不少&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;结论-1&quot;&gt;结论&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CFLAGS: -I路径&lt;/code&gt; 这句话指明头文件所在路径，-Iinclude 指明 当前项目根目录的 include 文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LDFLAGS: -L路径 -l名字&lt;/code&gt; 指明动态库的所在路径，-Llib -llibvideo，指明在 lib 下面以及它的名字 video&lt;/li&gt;
&lt;li&gt;如果动态库不存在，将会爆&lt;code&gt;找不到定义之类&lt;/code&gt;的错误信息&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;直接引用-cc-文件的形式-重点&quot;&gt;3，直接引用 c/c++ 文件的形式 &lt;code&gt;（重点）&lt;/code&gt;&lt;/h2&gt;
&lt;h4 id=&quot;假设项目目录如下-1&quot;&gt;假设项目目录如下&lt;/h4&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;|-util
|  |-util.h
|  |-util.c
|  |-util.go&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;util.h&quot;&gt;util.h&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sum(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;util.c&quot;&gt;util.c&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &quot;util.h&quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sum(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; a,&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; b){
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (a+b);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;util.go&quot;&gt;util.go&lt;/h4&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package util

/*
#include &quot;util.c&quot;
*/
import &quot;C&quot;

import &quot;fmt&quot;

func GoSum(a,b int) int {
    s := C.sum(C.int(a),C.int(b))
    fmt.Println(s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;这样调用-main.go&quot;&gt;这样调用 main.go&lt;/h4&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

func main(){
    util.GoSum(4,5)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三种方式便是如此&lt;code&gt;简洁明了&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，补充一下，一般需要 go 调用 c/c++ 的，主要是使用一些著名的开源库，例如 &lt;code&gt;ffmpeg&lt;/code&gt;，&lt;code&gt;opencv&lt;/code&gt;，等这些源码是基于 c/c++ 语言的，除此之外还有一个很重要的点，便是运行速度！&lt;/p&gt;

</description>
<pubDate>Sun, 21 Jan 2018 02:19:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/8323487.html</dc:identifier>
</item>
</channel>
</rss>