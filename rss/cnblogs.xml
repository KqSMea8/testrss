<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Node: 如何控制子进程的输出 - samupanz18</title>
<link>http://www.cnblogs.com/samupanz18/p/8145737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/samupanz18/p/8145737.html</guid>
<description>&lt;p&gt;大家知道，在一个node程序中，如果当前进程想要生成一个子进程，它可以调用child_process模块的spawn方法。spawn方法签名如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
child_process.spawn(command[, args][, options])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中options对象的属性stdio用来控制子进程的输出。&lt;/p&gt;
&lt;p&gt;当设置options.stdio为inherit时，子进程的输出会被重定向到当前进程的stdout对象，也就是说子进程的输出会直接显示在当前进程的控&lt;/p&gt;
&lt;p&gt;制台中。&lt;/p&gt;
&lt;p&gt;当设置options.stdio为pipe时，子进程的输出会被重定向到spawn方法的返回值的stdout对象。这种情况稍微复杂一点。我来举一个这种&lt;/p&gt;
&lt;p&gt;场景的例子。假如我们想在当前进程中将node的版本号写入一个文件，可以写如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fs = require('fs'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; {spawn} = require('child_process'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; child = spawn('node', ['--version'&lt;span&gt;], {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     stdio: '&lt;span&gt;&lt;strong&gt;pipe&lt;/strong&gt;&lt;/span&gt;'
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; filePath = path.resolve('node-version.txt'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; destination =&lt;span&gt; fs.createWriteStream(filePath);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; child.stdout.pipe(destination);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;子进程的输出会被重定向到child.stdout, child.stdout是一个Readable stream, 所以可以用它的pipe方法将数据写入到最终的文件。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 15:37:00 +0000</pubDate>
<dc:creator>samupanz18</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/samupanz18/p/8145737.html</dc:identifier>
</item>
<item>
<title>如何用VSCode愉快的写Python - Pleiades</title>
<link>http://www.cnblogs.com/pleiades/p/8146658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pleiades/p/8146658.html</guid>
<description>&lt;p&gt;　　在学习Python的过程中，一直没有找到比较趁手的第三方编辑器，用的最多的还是Python自带的编辑器。由于本人用惯了宇宙第一IDE（Visual Studio），所以当Visual Studio Code出现时，心情有点小激动呢。从我的使用经验出发，可以说VSCode用来写Python真的是再合适不过了，你将体验到丝滑的编程体验和无限扩展的可能。而且，如果你的项目是包含多种语言的，比如Web开发，你不必再开多个编辑器和其他工具，因为这一切都可以在VSCode里完成了。&lt;/p&gt;

&lt;p&gt;　　在VSCode中搜索扩展Python，就是这货：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231544351-1086757768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　安装后，重新加载。上图中我因为已经装过了，所以显示的是禁用、卸载按钮。&lt;/p&gt;
&lt;p&gt;　　下面就可以愉快的和Python玩耍了。是不是超方便？&lt;/p&gt;

&lt;p&gt;　　快在VSCode开始你的第一段Python代码吧，Python插件自带的Pylint功能会在你输入的过程中给你自动提示，自动完成，以及错误提示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231551570-1679757842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这里需要提醒各位PythonER们，VSCode包括VS中，Tab都默认是4个空格。&lt;/p&gt;
&lt;p&gt;　　常用的几个操作快捷键，估计VSer们都能无痛转换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是F1/Ctrl+Shit+P万能键，谁用谁知道&lt;/li&gt;
&lt;li&gt;Ctrl+P：文件切换&lt;/li&gt;
&lt;li&gt;Ctrl+空格：自动提示&lt;/li&gt;
&lt;li&gt;F12/Ctrl+左键：跳转到定义&lt;/li&gt;
&lt;li&gt;Shift+F12：预览定义&lt;/li&gt;
&lt;li&gt;Ctrl+G：跳转行号&lt;/li&gt;
&lt;li&gt;Ctrl+/：注释切换&lt;/li&gt;
&lt;li&gt;Alt+↑↓：整行上下移动&lt;/li&gt;
&lt;li&gt;Ctrl+↑↓：编辑器垂直滚动条上下移动，光标不动&lt;/li&gt;
&lt;li&gt;Ctrl+Backspace/Delete：整词/连续空白删除&lt;/li&gt;
&lt;li&gt;Ctrl+→←：光标整词移动&lt;/li&gt;
&lt;li&gt;Ctrl+F查找/Ctrl+Shift+F在文件中查找，这都属于通用的，类似的就不说了啊。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　预览定义图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231557913-524700651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　随时随地，F5调试运行。注意，VSCode默认在调试后，会停在第一句，如下图。&lt;/p&gt;
&lt;p&gt;　　调试快捷键与VS基本相同。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;F5：调试/继续，&lt;/li&gt;
&lt;li&gt;F10：单步跳过，&lt;/li&gt;
&lt;li&gt;F11：单步进入，&lt;/li&gt;
&lt;li&gt;Shift+F11：跳出。&lt;/li&gt;
&lt;li&gt;F9：切换断点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231606038-829973399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　左侧Debug窗口显示的从上到下依次是调试所用的模式，变量（局部变量，监视），调用堆栈，断点等。基本上我们需要的功能都在这里了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231610882-812670725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　有个不太好的设计就是变量、监视这些地方宽度太小，查看一些长的变量不如VS方便。不过好在我们有调试控制台啊，直接敲上变量名就好了。&lt;/p&gt;
&lt;p&gt;　　这里需要提醒一下的是，左上角的下拉选择调试模式中，常用的两个是Python和Integrated Terminal/Console，第一个就是在插件自带的环境中调试运行，第二个就是集成的控制台中。问题是，第一种暂不支持input()输入，所以想调试带input的程序，就选择Integrated Terminal/Console或者External Terminal/Console也是可以的。&lt;/p&gt;

&lt;p&gt;　　集成了Git支持，这是很棒的功能，不仅在行首用不同颜色标识添加、删除、修改的行，点击行首色块，还能显示对比。资源管理器中也用不同颜色和标记提示修改的文件。如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231616288-1519110322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　想要提交时，只需要切换到左侧源代码管理，Commit就行了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/345405/201712/345405-20171229231621273-2145541785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　VSCode小巧、快速，跨平台，界面炫酷，各种扩展，是时候换用新的VSCode了。&lt;/p&gt;
&lt;p&gt;　　这毕竟是微软出品，随便从VisualStudio项目组拉几个人就能甩Sublime、Atom好几条街了（暂不提Vim），让我有一种一旦用起来就停不下来的感觉。&lt;/p&gt;
&lt;p&gt;　　下一篇，计划介绍一下几个好用的VSCode扩展。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 15:29:00 +0000</pubDate>
<dc:creator>Pleiades</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pleiades/p/8146658.html</dc:identifier>
</item>
<item>
<title>线程池的工作原理与源码解读 - metoy</title>
<link>http://www.cnblogs.com/qingquanzi/p/8146638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingquanzi/p/8146638.html</guid>
<description>&lt;p&gt; 随着cpu核数越来越多，不可避免的利用多线程技术以充分利用其计算能力。所以，多线程技术是服务端开发人员必须掌握的技术。&lt;/p&gt;

&lt;p&gt;线程的创建和销毁，都涉及到系统调用，比较消耗系统资源，所以就引入了线程池技术，避免频繁的线程创建和销毁。&lt;/p&gt;

&lt;p&gt;在Java用有一个Executors工具类，可以为我们创建一个线程池，其本质就是new了一个ThreadPoolExecutor对象。线程池几乎也是面试必考问题。本节结合源代码，说说ThreadExecutor的工作原理&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、线程池创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先看一下ThreadPoolExecutor参数最全的构造方法：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231216070-693632307.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/E8ABF32F4F2E4CD7B0D1AACA16127568&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①corePoolSize：线程池的核心线程数，说白了就是，即便是线程池里没有任何任务，也会有corePoolSize个线程在候着等任务。&lt;/p&gt;
&lt;p&gt;②maximumPoolSize:最大线程数，不管你提交多少任务，线程池里最多工作线程数就是maximumPoolSize。&lt;/p&gt;
&lt;p&gt;③keepAliveTime:线程的存活时间。当线程池里的线程数大于corePoolSize时，如果等了keepAliveTime时长还没有任务可执行，则线程退出。&lt;/p&gt;
&lt;p&gt;⑤unit：这个用来指定keepAliveTime的单位，比如秒:TimeUnit.SECONDS。&lt;/p&gt;
&lt;p&gt;⑥workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。&lt;/p&gt;
&lt;p&gt;⑦threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。&lt;/p&gt;
&lt;p&gt;⑧handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。&lt;/p&gt;
&lt;p&gt;以上就是创建线程池时用到的参数，面试中经常会有面试官问道这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、线程池执行流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里用一个图来说明线程池的执行流程&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/502A3968315E4681B53AD46B25E93560&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231231929-1280812291.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;任务被提交到线程池，会先判断当前线程数量是否小于corePoolSize，如果小于则创建线程来执行提交的任务，否则将任务放入workQueue队列，如果workQueue满了，则判断当前线程数量是否小于maximumPoolSize,如果小于则创建线程执行任务，否则就会调用handler，以表示线程池拒绝接收任务。&lt;/p&gt;

&lt;p&gt;这里以jdk1.8.0_111的源代码为例，看一下具体实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、先看一下线程池的executor方法&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231325648-245385391.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/960391D21F0040A8A8398DC4CC63857B&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①：判断当前活跃线程数是否小于corePoolSize,如果小于，则调用addWorker创建线程执行任务&lt;/p&gt;
&lt;p&gt;②：如果不小于corePoolSize，则将任务添加到workQueue队列。&lt;/p&gt;
&lt;p&gt;③：如果放入workQueue失败，则创建线程执行任务，如果这时创建线程失败(当前线程数不小于maximumPoolSize时)，就会调用reject(内部调用handler)拒绝接受任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、再看下addWorker的方法实现&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231554601-390531474.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/DC5277F6281B47A4A5B7A7819FE33992&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这块代码是在创建非核心线程时，即core等于false。判断当前线程数是否大于等于maximumPoolSize，如果大于等于则返回false，即上边说到的③中创建线程失败的情况。&lt;/p&gt;

&lt;p&gt;addWorker方法的下半部分：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231659117-129178066.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/A0FADFA4C77F430098AF77FC156BCE13&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①创建Worker对象，同时也会实例化一个Thread对象。&lt;/p&gt;
&lt;p&gt;②启动启动这个线程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、再到Worker里看看其实现&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231743648-994771431.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/EFAD863C971944EBB6112A56057537F2&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;可以看到在创建Worker时会调用threadFactory来创建一个线程。上边的②中启动一个线程就会触发Worker的run方法被线程调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、接下来咱们看看runWorker方法的逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231758929-977183448.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/EB2BF6D2A55A48DB8D40C35B67A1C1D0&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;线程调用runWoker，会while循环调用getTask方法从workerQueue里读取任务，然后执行任务。只要getTask方法不返回null,此线程就不会退出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、最后在看看getTask方法实现&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1287675/201712/1287675-20171229231901007-1866682344.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/0C425896BA9344CA894FFE51674D5364&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;①咱们先不管allowCoreThreadTimeOut，这个变量默认值是false。wc&amp;gt;corePoolSize则是判断当前线程数是否大于corePoolSize。&lt;/p&gt;
&lt;p&gt;②如果当前线程数大于corePoolSize，则会调用workQueue的poll方法获取任务，超时时间是keepAliveTime。如果超过keepAliveTime时长，poll返回了null，上边提到的while循序就会退出，线程也就执行完了。&lt;/p&gt;
&lt;p&gt;如果当前线程数小于corePoolSize，则会调用workQueue的take方法阻塞在当前。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 15:21:00 +0000</pubDate>
<dc:creator>metoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingquanzi/p/8146638.html</dc:identifier>
</item>
<item>
<title>消息服务框架（MSF）应用实例之分布式事务三阶段提交协议的实现 - 深蓝医生</title>
<link>http://www.cnblogs.com/bluedoctor/p/8146604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bluedoctor/p/8146604.html</guid>
<description>&lt;p&gt;在当前互联网，大数据和人工智能的热潮中，传统企业也受到这一潮流的冲击，纷纷响应国家“互联网+”的战略号召，企业开始将越来越多的应用从公司内网迁移到云端和移动端，或者将之前孤立的IT系统联网整合，或者将原来厚重的企业应用拆分重组，独立成一个个轻量级的应用对外提供服务，这对传统的业务处理的数据一致性，带来了严重的挑战，我们已经身处一个分布式的计算环境，分布式事务的需求越来越普遍。&lt;/p&gt;
&lt;p&gt;举一个例子，某行业电商网站经过几年的发展，业务数据累积越来越多，查询越来越慢。经过内部评审分析，认为系统的瓶颈就是数据库压力过大，如果要解决这问题，必须分表分库，比如将订单，商品，用户分布到不同的数据库去，但这样随之带来一个问题，原来处理业务的时候使用的是本地事务，分库后就需要使用分布式事务了。&lt;/p&gt;
&lt;p&gt;那么应该如何实现分布式事务呢？&lt;/p&gt;
&lt;p&gt;这里我们需要明确一点，并非数据库天然就是分布式的在执行操作的，事务都是在一个数据库实例上进行的，如果要执行一个分布式事务的操作，那么就需要协调多个分散的数据库上执行的事务操作。所以在分布式事务中，有2个概念：&lt;/p&gt;
&lt;p&gt;l  Distributed Transaction Resource Owner （简称DTR）：&lt;/p&gt;
&lt;p&gt;n  --&lt;strong&gt;分布式事务资源服务器&lt;/strong&gt;，拥有事务资源的服务器，如绝大部分关系数据库，一些消息队列，或者一些能够执行类似事务操作的应用。&lt;/p&gt;
&lt;p&gt;l  Distributed Transaction Coordinate Controller （简称DTC）：&lt;/p&gt;
&lt;p&gt;n  --&lt;strong&gt;分布式事务协调控制器&lt;/strong&gt;，它协调控制分布式事务环境中的事务资源服务器，发送指令给它们并且处理事务资源服务器返回的结果。&lt;/p&gt;



&lt;p&gt;在分布式事务的具体实现层面，可以在数据库层直接实现，也可以在应用服务层面实现。如果是在应用服务层面实现，本质上它也可能是调用本地的数据库事务。&lt;/p&gt;
&lt;p&gt;下面是DTR与DTC的拓扑关系图：&lt;/p&gt;
&lt;h2&gt;基于关系数据库层面接口实现的分布式事务&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225349085-832890410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于数据库的分布式事务，一般在应用程序的数据层调用系统的分布式事务组件，应用程序执行本地事务的时候，先选举出一个分布式事务协调器，然后协调器来协调各个本地事务的执行。由于是在应用程序的数据层进行的调用，所以它对远程数据库的操作是在本地进程内的。如果你的应用部署在多台服务器上，那么在每一台操作数据库的应用服务器上都要安装运行分布式事务协调器服务。&lt;/p&gt;
&lt;h2&gt;基于应用服务层面实现的分布式事务&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225423351-1514472994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于应用服务层面的分布式事务，是在应用服务层面进行的事务控制，它同样会有分布式事务协调控制器，和事务资源服务器。与基于数据库层面的分布式事务不同，事务的类型支持更广泛，比如消息队列访问，文件写入或者具有补偿操作的业务应用程序，都可以成为事务资源，并且不要求这些事务资源本身支持分布式事务。举个例子，事务资源A是Windows上的SQLSERVER数据库，事务B是Linux上的MySQL数据库，这时候事务B就没法使用Windows上的事务协调控制器MSDTC了。而基于服务层面的分布式事务，可以解决这个问题。&lt;/p&gt;

&lt;h2&gt;第一阶段（1PC）：提交投票阶段&lt;/h2&gt;
&lt;p&gt;协调器向事务资源服务器发出 CanCommit 的是否可以提交事务的询问指令，事务资源服务器收到此指令后，准备好要提交的事务资源，再向协调器回复 YES；如果没有准备好，比如执行事务中的操作出现了错误，应该回复 NO.如果某DTR无法回复，DTC也认为该DTR的结果是NO．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225447273-961295251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一阶段，全部回复为YES，代表各个事务资源服务器均已经准备好了提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225527726-284278746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一阶段，事务资源服务器DTR-2回复为NO，如果DTC等待DTR-2超过设定时间都没有得到回复，或者DTR-2与DTC断开了连接，也认为DTR-2的结果是NO&lt;/p&gt;

&lt;h2&gt;第二阶段（2 PC）：提交或终止阶段&lt;/h2&gt;
&lt;p&gt;协调器统计所有事物资源服务器的回复数量，如果全部回复为YES，则向所有事物资源服务器发出Commit指令，否则，发出Abort指令。资源服务器收到指令后，执行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225602929-998206664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225618742-2029747969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二阶段提交事务的数据不一致问题&lt;/h2&gt;
&lt;p&gt;在第二阶段（2PC），如果DTR没有收到DTC的指令改怎么办呢？&lt;/p&gt;
&lt;p&gt;如果等到超时都没有收到DTC的指令，DTR处于“可以提交”或者“不可以提交”的双重状态，也就是提交状态不可知。假设DTR1没有收到DTC的提交指令或者撤销指令，DTR1可以假设DTR2也不会收到指令，因为此时大概率是DTC宕机或者网络整体不良，那么DTR1最佳的做法是回滚事务。&lt;/p&gt;
&lt;p&gt;但是，如果仅仅是DTR1受网络影响没有收到提交指令，而DTR2收到了提交指令，那么DTR1回滚事务，DTR2提交了事务，整个分布式事务就是失败的，数据发生了不一致。&lt;/p&gt;
&lt;p&gt;因此，2阶段提交的分布式事务不是高可靠的分布式事务控制模型，需要在事务资源的提交环节做更多的验证，这便是3阶段提交的分布式事务。&lt;/p&gt;

&lt;p&gt;不过，对于大部分系统，2阶段提交的分布式事务已经能够满足应用了，因为通常情况下，都是基于数据库应用层实现的分布式事务，并且各个事务资源节点都在同一个局域网内，发生网络不稳定的概率非常小，并且现在不少数据库都会做高可靠性的数据库集群，发生宕机的可能性也非常小，最终出现数据不一致的概率也就非常小了。&lt;/p&gt;

&lt;p&gt;如果系统的应用环境不能满足上面说的任何一个条件，即分布式事务的控制不是在数据库应用层，子系统不在一个局域网，或者数据库没有做高可靠的集群，并且对于系统的事务一致性要求非常高，那么应该使用3阶段提交协议来实现分布式事务。&lt;/p&gt;

&lt;p&gt;对2阶段提交协议的分析我们发现，2PC的事务提交阶段状态是不确定的，整个事务容易出现不一致的情况。所以，我们队2PC的提交阶段，进一步拆分成“预提交”阶段和提交阶段，增加事务提交状态的确认过程。&lt;/p&gt;
&lt;h2&gt;第一阶段（1PC）：提交投票阶段&lt;/h2&gt;
&lt;p&gt;协调器向事务资源服务器发出 CanCommit 的是否可以提交事务的询问指令，事务资源服务器收到此指令后，准备好要提交的事务资源，再向协调器回复 YES；如果没有准备好，比如执行事务中的操作出现了错误，应该回复 NO.如果某DTR无法回复，DTC也认为该DTR的结果是NO．&lt;/p&gt;
&lt;p&gt;该阶段的处理过程跟2阶段提交协议的第一阶段是一样的，处理流程图参考前面，此略。&lt;/p&gt;

&lt;h2&gt;第二阶段（2 PC）：预提交或终止阶段&lt;/h2&gt;
&lt;h3&gt;预提交事务&lt;/h3&gt;
&lt;p&gt;协调器（DTC）统计所有事务资源服务器（DTR）的回复数量，如果全部回复为YES，则向所有事物资源服务器发出PreCommit指令，否则，发出Abort指令。资源服务器收到指令后，执行相应的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229225659804-1668514275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第二阶段，如果DTR收到PreCommit指令，则向DTC回复ACK消息，表示收到了指令，准备提交，接着，进入第三阶段，等待最终的提交指令。&lt;/p&gt;

&lt;h3&gt;终止事务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230015898-710850973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在第二阶段，如果在第一阶段有节点异常，DTC发出撤销指令，DTR收到了撤销指令，那么它执行回滚本地事务的操作。如果由于网络原因，某个DTR一直等到超时都没有收到PreCommit指令，那么它执行Abort撤销指令，回滚本地事务。&lt;/p&gt;

&lt;h2&gt;第三阶段（3 PC）：提交或终止阶段&lt;/h2&gt;
&lt;h3&gt;提交分布式事务&lt;/h3&gt;
&lt;p&gt;协调器（DTC）统计所有事务资源服务器（DTR）在第二阶段的回复数量，如果全部回复为ACK，则向所有DTR发出Commit指令。DTR收到指令后，执行事务提交操作，并返回Commit Done消息，DTC收到此消息，结束整个分布式事务过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230147820-2074775999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;回滚分布式事务&lt;/h3&gt;
&lt;p&gt;协调器（DTC）统计所有事务资源服务器（DTR）在第二阶段的回复数量，如果未收到全部回复为ACK，则它认为有节点可能出现了网络故障，此节点没有收到PreCommit指令或者虽然收到了却没有回复ACK，测试DTC应该向所有DTR节点发出撤销指令。各DTR收到撤销指令后，回滚本地事务，然后回复消息，DTC完成本次事务过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230231257-1165180646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三阶段提交事务也并不完美&lt;/h2&gt;
&lt;p&gt;考察第3阶段的提交分布式事务的情况，DTR1收到了Commit指令，但是由于网络原因，DTR2没有收到此指令，那么DTR2是提交本地事务还是回滚本地事务？&lt;/p&gt;
&lt;p&gt;站在DTR2的角度，它在本阶段可能收到Commit指令，也可能收到Abort指令，那么它既可以提交本地事务也可以回滚本地事务，两种操作是不确定的，所以，3阶段提交协议，仍然不是完美的，不能百分之百保证数据的最终一致性。&lt;/p&gt;
&lt;p&gt;既然3阶段提交协议仍然有不确定性，那么相比2阶段提交协议有什么意义呢？&lt;/p&gt;

&lt;p&gt;仔细想下，DTR2已经进入第3阶段了，那么肯定其它DTR都进入了第3阶段，而进入第3阶段的前提是各DTR节点都收到过PreCommit指令，都是已经准备好提交只等最后的提交指令了，否则各节点在第二阶段应该收到撤销指令，不会再进入第三阶段。既然各DTR节点都进入了第三阶段，它们都准备好提交事务了，那么即使没有收到最终的Commit指令，DTC发出Commit指令也是大概率的。所以，从概率上讲，如果在第三阶段，DTR没有收到Abort撤销指令，也没收到Commit提交指令，那么它默认应该指向Commit指令，提交本地事务。相比第二阶段某DTR节点没有收到指令而认为应该收到PreCommit指令的概率，要大得多。&lt;/p&gt;

&lt;p&gt;关于第三阶段没有收到指令而应该大概率执行Commit指令的问题，理解起来可能有点困难，我给同事讲的时候大部分同事也难以理解，可能是我表述的问题，大家有更好的解释方式，欢迎交流，不胜感激！&lt;/p&gt;


&lt;p&gt;本文将介绍一个基于服务层面而不是数据库层面的，3阶段提交的分布式事务中间件的设计开发过程。这个中间件必须解决下面几个问题：&lt;/p&gt;
&lt;p&gt;l  通信组件—分布式事务控制器（DTC），分布式事务资源服务器（DTR）都是独立的服务，这些服务部署在不同的通信节点，它们之间需要进行可靠的网络通信，因此通信组件是基础；&lt;/p&gt;
&lt;p&gt;l  数据访问组件—提供基础的数据读写操作，并且能够操作本地事务。&lt;/p&gt;
&lt;p&gt;l  服务组件—将DTC，DTR的功能代码编写为相应的SOA服务组件&lt;/p&gt;
&lt;p&gt;l  关系数据库—具有事务功能的关系数据库，可以是嵌入式的本地数据库，比如SQLite,也可以是服务器客户机模式的网络数据库,比如SQLSERVER。&lt;/p&gt;

&lt;p&gt;各组件的关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/114517/201712/114517-20171229230318351-1741662556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;PDF.NET的消息服务框架（MSF）具有开发服务组件基础的接口和一套消息通信组件，同时还有一个服务容器，可以承载本篇文章说的分布式事务控制器DTC，分布式事务资源服务DTR这些服务应用，同时PDF.NET还有一个强大的数据访问组件 PDF.NET SOD，下一篇文章，我们将来具体讨论基于MSF和SOD的3阶段分布式事务应用的实现过程，它的源码已经发布在 &lt;a href=&quot;https://github.com/bluedoctor/MSF-DistTransExample&quot;&gt;https://github.com/bluedoctor/MSF-DistTransExample&lt;/a&gt; ，大家可以先睹为快。&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 15:16:00 +0000</pubDate>
<dc:creator>深蓝医生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bluedoctor/p/8146604.html</dc:identifier>
</item>
<item>
<title>闲置的2017 - liliangel</title>
<link>http://www.cnblogs.com/liliangel/p/8146517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liliangel/p/8146517.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;异常闲而且懒散的一年，起码有200天是国企上班那种状态，以至于12月中旬我就想起了写年终总结。我几乎没有做一件可以说得出口的事情，简单点讲就是一无所获，尝试过各种反问、反思自己，最后得出一个结论：心态没以前好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2166524-afc23f37c59de309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;有多闲置如图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;怀旧&quot;&gt;怀旧&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;老人才怀旧吗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;怀念以前说走就走的冲动，那种跨过山河大海的轻松畅快。怀念上坡路上那个骑着自行车挥汗如雨的少年，不禁至此已成长了肚子的大叔。怀念以前充实的工作日，倒杯水都觉得浪费时间的峥嵘岁月。怀念以前会精心准备一顿晚餐的悸动，在平淡日子里添增几分色彩。大概只有闲的人才有时间怀旧吧，曾经我开导别人说：如果你不开心，那是因为自己没有真正忙碌起来，才会去想自己是否开心这个命题。也对，我有时间怀旧，为什么不去给未来充电呢？&lt;/p&gt;
&lt;h2 id=&quot;充电&quot;&gt;充电&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;React技术栈进阶&lt;/li&gt;
&lt;li&gt;webpack从入门到进阶&lt;/li&gt;
&lt;li&gt;sass深入&lt;/li&gt;
&lt;li&gt;微信支付探索使用&lt;/li&gt;
&lt;li&gt;小程序等待观望&lt;/li&gt;
&lt;li&gt;dubbo activemq了解&lt;/li&gt;
&lt;li&gt;linux基本操作&lt;/li&gt;
&lt;li&gt;layui深度使用&lt;/li&gt;
&lt;li&gt;编程思想、思维方式的历练、总结&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;技术上&quot;&gt;技术上&lt;/h3&gt;
&lt;p&gt;还是有一种渴求学习的状态，可能源自兴趣，可能源自生存压力，可能源自发展大潮流，却也依然面对各种层出不穷的新东西感到恐慌和疲倦。大概就是这么纠结的进步和却步着，彷徨而又奔跑着。&lt;/p&gt;
&lt;h4 id=&quot;java后台方面&quot;&gt;JAVA后台方面&lt;/h4&gt;
&lt;p&gt;依然是保留的状态，不过也有幸做了一个用了dubbo、activemq等的项目，算是了解、会简单使用。为了不对JAVA产生大生疏的距离，也搭了一个轻量的后台工程，基于springMVC、mybatis这些吃老本的东西，前端用gulp简单构建，做了一个地图的小项目。听说springboot很流行，觉得也有必要去了解一下&lt;/p&gt;
&lt;h4 id=&quot;服务器&quot;&gt;服务器&lt;/h4&gt;
&lt;p&gt;既然是独立做了一个小项目，那么肯定离不开服务器，甚至是域名申请、备案这些流程，而这一块应该说还是比较空白的，也趁此机会，稍微学习了基础的linux环境操作，如一些基本的命令、装个svn配置账号密码、安装配置nginx等，这些后续必须要加强&lt;/p&gt;
&lt;h4 id=&quot;人工智能&quot;&gt;人工智能&lt;/h4&gt;
&lt;p&gt;Python作为今年最火的语言，人工智能、深度学习、机器学习也是今年热门且高大上的关键字，看了一本李开复老师的书，算是对这方面有点点认识了，最近又听说python要作为学生教材语言了，那么我是不是也得跟进学习呢？&lt;/p&gt;
&lt;h4 id=&quot;前端&quot;&gt;前端&lt;/h4&gt;
&lt;p&gt;主要还是前端，这也是我工作岗位职称。那么面对五花八门的前端技术，我的态度是八个字：保持关注，适应需求。可以说前端还是在一个发展阶段，导致的就是一个水平参差不齐，有的人已经跑得很靠前了，有得有甚至还停留在原生js的点上，但是他们在一个团队，这该怎么去找一个平衡点呢？&lt;/p&gt;
&lt;p&gt;这一年，其实我更多的是在培养编程的意识、思路，以及去考虑团队协作中面对人员技术的一些差异性怎么去平衡，还有与产品/UI商量界面的交互、与后台对接接口时怎么更有效的沟通，也去思考面对一个新项目，怎么去根据其特殊性选择最合适的框架或者说技术栈，甚至是最后测试时的一些分歧怎么优雅处理。在不断的自我反思和自我完善中成长。&lt;/p&gt;
&lt;p&gt;其实真的有时候真的又觉得多学一门框架又能如何呢，现在假如现在把React玩溜了，把Vue玩转了，你的公司还在用jquery，你能怎么办呢？重构吗？走人吗？当然，都可以选择，只是觉得框架和API时刻在变化，唯有编程思想是精髓，有了好的编程思想，再借助提高效率的框架，才能达到事半功倍的效果。&lt;/p&gt;
&lt;p&gt;国内的小公司小团队的前端，其实还是有些尴尬的存在的，大多都是1-2个前端，甚至还是很古老的套路，一个做静态页面一个写js交互，我是很反感写静态页面的模式的，根本无法产出高质量的代码。而前端的发展如日中天，早已走向新时代了，可是还是有很多人认为写页面-那不是很简单的事情吗？2小时能搞定吧，这个网站2天能做完吧？&lt;/p&gt;
&lt;p&gt;最近听了很多类似的话，我也是默默地听着了，因为我知道就算闹个脾气也改变不了什么，反而会对自己的外在评价降分。为什么会造成这样的局面呢？思来想去，还是因为国内大部分的技术领导都是早期的后台出身，他们对前端的理解大多数还是停留在前几年的滞后状态，所以潜意识里面还是觉得这个要求不会太高，比较简单。加上运营大部分对技术也不太了解，当然运营活动的时效性也决定了给不了开发太多的时间，所以大部分的运营活动他们恨不得你分分钟能把所谓的“静态页面”输出。。 唉，太多的事与愿违，是缺乏工匠精神，还是没有拥有工匠精神的大环境？做为页面仔的你，是不是也曾经干过那种一个页面直接贴一张整图这种操蛋的事情呢？&lt;/p&gt;
&lt;p&gt;但是，也不要那么的悲观。前端出于高速发展的阶段，必然会有些矛盾的产生，也必然会越来越受人们重视，心理上的成熟，多运用沟通技巧，工作就是这样的。2018年一定要有一个好心态，更成熟的内心。&lt;/p&gt;
&lt;h3 id=&quot;生活上&quot;&gt;生活上&lt;/h3&gt;
&lt;h4 id=&quot;骑行&quot;&gt;骑行&lt;/h4&gt;
&lt;p&gt;今年总共里程不到1kkm，说出来其实是很丢人的，自行车已经落灰了。。下一个阳光灿烂的日子，带上头盔就出发吧，或许明天吧~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;骑行登顶梧桐山&lt;/li&gt;
&lt;li&gt;和女朋友一起骑行松山湖， &amp;gt; 100km + 跨市&lt;/li&gt;
&lt;li&gt;没了&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;阅读&quot;&gt;阅读&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今年看了几本书，有走马观花式阅读，也有受益匪浅的片段，有人说：清醒时做事，糊涂时看书。确实，大城市的年轻人们，其实很容易迷茫的，有时候还真需要一点鸡汤文来祭奠青春。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;列一下书单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Vue.js权威指南&lt;/li&gt;
&lt;li&gt;ES6标准入门&lt;/li&gt;
&lt;li&gt;我只是敢跟别人不一样&lt;/li&gt;
&lt;li&gt;人工智能 -李开复&lt;/li&gt;
&lt;li&gt;深入React技术栈 -陈屹&lt;/li&gt;
&lt;li&gt;React前端技术与工程实践&lt;/li&gt;
&lt;li&gt;浮躁 -贾平凹&lt;/li&gt;
&lt;li&gt;社会契约论&lt;/li&gt;
&lt;li&gt;少有人走的路&lt;/li&gt;
&lt;li&gt;Javascript高级程序设计&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;在深圳搬了第三次家&quot;&gt;在深圳搬了第三次家&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今年是在深圳的第三次搬家了，这回与以往不同，没有跨区没有叫搬家公司，只是在同一个小区里换了一间稍微大一点的，采光好一些的农民房。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单的装饰了一下，买了床、衣柜、餐具柜、书柜等，装了空调、热水器，比以前没有什么大区别，只是这些东西现在都是自己买的了，更有归属感一点吧？！&lt;/p&gt;
&lt;p&gt;网上很流行一句话：房子是租来的，生活是自己的！没错，谁都想过好点高质量的生活，但是是否有支撑这些的能力呢？想在深圳生存不难，想在深圳生活也不会太难，想在深圳生长太难太难了。所谓生长，就是生根发芽、买房落户，但凡是扯上这一点，瞬间就感觉怀疑人生了，面对高贵的房价，望而却步。&lt;/p&gt;
&lt;p&gt;那么就退而求其次吧，尽管不是那么的满意，如户型上的不足，未来发展潜力堪忧等，但是也至少赶上了限购前的末班车，也算是今年做成了的一件事，对自己美好生活向往迈出的第一步，长沙-离老家最近的省会城市，武广新城-早上从深圳做高铁可以回家吃午饭，应该是要高兴，也值得高兴的。&lt;/p&gt;
&lt;h4 id=&quot;秋刀鱼的滋味猫跟你都想了解&quot;&gt;秋刀鱼的滋味，猫跟你都想了解&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;深大地铁站，最近出现了几张很文艺的广告，女生+猫+周杰伦歌词的文艺照片。相信有很多人都看到了，有一种对广告怦然心动的感觉，原来广告也可以那么文艺、年轻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年9月份，从深大一个有爱心的学生那里领养了一直流浪猫，原名花生，我习惯叫他猫兄，躁动、亲人、不挑、短毛的橘色猫，会在我去上班的时候在门口目送我离开，会在我下班回来会在门后表示迎接（其实是饿了等食物），会在我看电视的时候蹲在我腿上一起看着屏幕，会在我写代码的时候来键盘上捣乱。尽管有时候是挺讨嫌的，但是已经是生活的一部分了，我会给他买好的猫粮，每天喂干净的水，开心时给他开罐头，不听话时把他关笼子里... 目前他已经打完猫三联和狂犬疫苗了，再过阵子可能要去做绝育，他还有10多天的时间做只正常男猫，哈哈！哦，对了，他还没了解过秋刀鱼~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2166524-7e37a87efd0c9103.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;此刻的猫兄&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;水浒做人三国处世&quot;&gt;水浒做人，三国处世&lt;/h4&gt;
&lt;p&gt;从小对古典文学抱有兴趣，水浒传原著、三国演义原著分别阅读和细读了一遍，这么多年来对性格养成产生了非常大的影响。10年四大名著电视剧翻拍，当时水浒传真的看得深夜恸哭。13年，重新再看了一遍新版水浒电视剧，到林冲恨不能杀高俅的桥段，揪心，扬言再不看水浒。然而今年上半年，闲暇时间，分别看了一遍新版三国、老版三国，对刘备有了新的看法，后还看了一遍老版水浒，再后来趁热打铁，又看了一遍新水浒... 对宋江、吴用也不同于七年前的认识，几字两言还真说不尽，打算个人理解的写一些书评，一直还没开这个头，也许来年会吧，至少要把《金圣叹批评本水浒》上下看完。&lt;/p&gt;
&lt;h2 id=&quot;团队重组的阵痛&quot;&gt;团队重组的阵痛&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;年中的时候公司技术团队大调整，融合、优化，总之，就是相当于离职一样到了一个陌生的地方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;融入&quot;&gt;融入&lt;/h3&gt;
&lt;p&gt;不过这又比离职好一点，至少周边环境不要重新熟悉，并且还有几个认识的人，当然所面临的项目也变化了，新的同事该怎么融入呢，面对角色的转变，唯有主动融入，比如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一起去吃午饭，从交流中互相了解 -&lt;/li&gt;
&lt;li&gt;该加班的时候加班，因为加班的时候大家可能比正常工作时间更放得开一些，可以大声交流，可以讨论一些琐事...&lt;/li&gt;
&lt;li&gt;有问题主动询问，通常情况下大家都是挺愿意帮助人的&lt;/li&gt;
&lt;li&gt;有问题主动回答，当团队中有不确定的方案在讨论时，如果你又更好的建议，不妨说出来一起讨论，这样也有利于提升自己价值&lt;/li&gt;
&lt;li&gt;不卑不亢，踏踏实实做事情，自然就能融入&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;面对不同的技术栈&quot;&gt;面对不同的技术栈&lt;/h3&gt;
&lt;p&gt;原来的项目因为业务没有发展起来现在只是维护，重点放在新的项目上，新的项目用的技术栈有新有旧，原来重点在微信公众号开发、h5+app混合开发上，这回突然要维护新项目的官网，pc端，兼容ie8，jsp! 确实心理上难以接受，不过这种问题其实也是意料之中的，就算是换工作也难免这种情况，一个程序员是否成熟其实也包含了是否愿意维护传统项目的心态，某种程度上而言这也是一种历练，所以不如欣然接受吧！在开发完需求的剩余时间里，重点还是在移动端React的深入研究上，期间也用React做过一个项目、一个demo。Webpack是不错的东西，在不断的尝试和使用中，最近整理了一套Webpack多页面+jQuery+ES6+Sass的一个方案，他介意新潮和传统之间，短期内我应该都会尝试使用和优化这套方案&lt;/p&gt;
&lt;h3 id=&quot;做好离开的准备&quot;&gt;做好离开的准备&lt;/h3&gt;
&lt;p&gt;人不为己，怕是个傻子吧！所有的充电，都是为了更好释放电流做准备。所有的技术学习，都是为将有一天能做更大型的项目做储备。我还是希望能有好的机会，去做一个庞大用户量的项目，高质量的项目，哪怕是一个很小的螺丝钉，他也至少置身于大型机器中！所以我依然是这样定位，时刻做好离开的准备。这个公司文化、公司项目有关系，扯不上忠诚度这个词，更不能说是一个喜欢跳槽的人。&lt;/p&gt;
&lt;h2 id=&quot;驾考&quot;&gt;驾考&lt;/h2&gt;
&lt;p&gt;上一次报考驾校时才3300吧，可是被驾校坑了，3个月不通知考科目一，最后算一下时间要毕业去深圳了也来不及考了，就退了，扣了好像是800块钱。其实主要是当时也还是没有把开车这个事情想得很近，总以为自行车还能玩好多年，包括现在很长一段时间我还是这么觉得，所以就一直也不去考虑考驾照这个事。随着身边的环境、朋友、经历等一些变化，如国庆坐朋友车走了一晚上高速回老家，如上上个星期去广西猫儿山那个山角山角里，必须自己开车才方便，加上最主要的是最近应该是有空闲的时间来做题学车，不能浪费这两个月的时间，抓住年前的这波机会，果断就报名了，清远外地班，目前已考科目一，正在练科二，目标是一把过，fighting！&lt;/p&gt;
&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;年度发现最佳辅助工具：最高效易用的自动标注工具，设计研发利器&lt;a href=&quot;http://www.fancynode.com.cn/pxcook&quot;&gt;PxCook&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用最好的前端文本编辑器（还不能称作IDE）： &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;vs code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;年中的时候，写了一篇博客，现在看来可能又有很多要优化的地方了，这就是成长吧！&lt;a href=&quot;http://www.cnblogs.com/liliangel/p/6732507.html&quot;&gt;前端项目从0到1的感悟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;做了一个个人网站，存放一些博客、感悟、民谣、骑行等生活琐事，不愿成为知识的过客，拥抱开源，崇尚共享，乐于交流，技术碰撞，共同进步。 &lt;a href=&quot;http://www.twobike.cn/&quot; class=&quot;uri&quot;&gt;http://www.twobike.cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 29 Dec 2017 14:29:00 +0000</pubDate>
<dc:creator>liliangel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liliangel/p/8146517.html</dc:identifier>
</item>
<item>
<title>java中的异常处理 - 曾将</title>
<link>http://www.cnblogs.com/GH0522/p/8146301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GH0522/p/8146301.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：异常的概念：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。&lt;br/&gt; 在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先查看一下异常类的树状体系结构，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171229162333288-152824885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;Thorwable类所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception） 和检查异常（Checked Exception）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1：Error和Exception&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Error是程序无法处理的错误，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，  Java虚拟机（JVM）一般会选择线程终止。&lt;/p&gt;&lt;p&gt;Exception是程序本身可以处理的异常，这种异常分两大类运行时异常（不可查异常）和非运行时异常（可查异常）。 程序中应当尽可能去处理这些异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2：运行时异常和非运行时异常&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等， 这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的， 程序应该从逻辑角度尽可能避免这类异常的发生。&lt;/p&gt;
&lt;p&gt;这类异常程序不要求必须去做处理。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。 如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。&lt;/p&gt;
&lt;p&gt;这类异常则要求我们对这个异常进行处理，要么使用try--catch--finally，要么使用throws去声明这个异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：异常的处理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先在java中，都是通过 try--catch--finally，throw，throws关键字进行的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1：异常处理的基本语法：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;try--catch--finally：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Enum;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能会出现异常的代码块&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;想要捕获的异常
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常的处理&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不管怎样都会被运行的语句，例如关闭链接资源，关闭连接对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1： try语句块，表示要尝试运行代码，try语句块中代码受异常监控，其中代码发生异常时，会抛出异常对象。 &lt;/p&gt;
&lt;p&gt;catch语句块会捕获try代码块中发生的异常并在其代码块中做异常处理，catch语句带一个Throwable类型的参数， 表示可捕获异常类型。当try中出现异常时，catch会捕获到发生的异常，并和自己的异常类型匹配， 若匹配，则执行catch块中代码，并将catch块参数指向所抛的异常对象。catch语句可以有多个，  用来匹配多个中的一个异常，一旦匹配上后，就不再尝试匹配别的catch块了，所以如果需要匹配多个异常就把异常的子类放到前面，父类放到后面。 通过异常对象可以获取异常发生时完整的JVM堆栈信息，以及异常信息和异常发生的原因等。&lt;/p&gt;
&lt;p&gt; finally语句块是紧跟catch语句后的语句块，这个语句块总是会在方法返回前执行，  而不管是否try语句块是否发生异常。并且这个语句块总是在方法返回前执行。 目的是给程序一个补救的机会。这样做也体现了Java语言的健壮性。&lt;/p&gt;

&lt;p&gt;2、 try、catch、finally三个语句块应注意的问题 ：&lt;br/&gt;    第一、try、catch、finally三个语句块均不能单独使用，三者可以组成 try...catch...finally、try...catch、&lt;br/&gt;    try...finally三种结构，catch语句可以有一个或多个，finally语句最多一个。&lt;br/&gt;    第二、try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。&lt;br/&gt;    如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。&lt;br/&gt;    第三、多个catch块时候，只会匹配其中一个异常类并执行catch块代码，而不会再执行别的catch块，&lt;br/&gt;    并且匹配catch语句的顺序是由上到下。&lt;/p&gt;


&lt;p&gt;throw、throws关键字&lt;/p&gt;
&lt;p&gt; throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常， 则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。 如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。 如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。有关异常的转译会在下面说明。&lt;/p&gt;&lt;p&gt;throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常， 该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出。&lt;/p&gt;

&lt;p&gt; 例如throws申明一个异常：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;ClassNotFoundException{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;3&lt;/span&gt; }&lt;/span&gt; &lt;/p&gt;

&lt;p&gt; 例如这个throw 观察一下有什么不同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassNotFoundException();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这很好的说明了 throw对与可查异常和不可查异常处理之间的差别&lt;/p&gt;


&lt;p&gt; Throwable类中的常用方法&lt;br/&gt;   　　 getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。&lt;br/&gt;   　　 getMessage()：返回异常的消息信息。&lt;br/&gt;   　　 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             
&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            e.getMessage();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            e.getCause();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 三&lt;/span&gt;&lt;span&gt;&lt;strong&gt;：异常的一般原则：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1、 能处理就早处理，抛出不去还不能处理的就想法消化掉或者转换为RuntimeException处理。&lt;br/&gt;    因为对于一个应用系统来说，抛出大量异常是有问题的，应该从程序开发角度尽可能的控制异常发生的可能。&lt;br/&gt; 2、 对于检查异常，如果不能行之有效的处理，还不如转换为RuntimeException抛出。&lt;br/&gt;    这样也让上层的代码有选择的余地――可处理也可不处理。&lt;br/&gt; 3、 对于一个应用系统来说，应该有自己的一套异常处理框架，这样当异常发生时，也能得到统一的处理风格，&lt;br/&gt;    将优雅的异常信息反馈给用户。&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;四&lt;span&gt;&lt;strong&gt;：自定义异常：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先 创建一个类继承异常类，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Exection;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Myexecption &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Myexecption(String message, Throwable cause, &lt;span&gt;boolean&lt;/span&gt; enableSuppression, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; writableStackTrace) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause, enableSuppression, writableStackTrace);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption(String message, Throwable cause) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption(String message) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Myexecption(Throwable cause) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(cause);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后编写代码 ，然后编写逻辑，这个异常什么时候需要使用，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; Exection;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; shang (&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Myexecption{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;(y==0&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            {  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Myexecption(&quot;您输入的是&quot;+y+&quot;,规定除数不能为负数!&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抛出异常  &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; x/&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Myexecption {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         shang(10, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在需要的地方抛出这个异常。&lt;/p&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1306245/201712/1306245-20171229210424617-486380165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了  异常就到这了；&lt;/p&gt;

</description>
<pubDate>Fri, 29 Dec 2017 13:06:00 +0000</pubDate>
<dc:creator>曾将</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GH0522/p/8146301.html</dc:identifier>
</item>
<item>
<title>为什么epoll会那么高效 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8146143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8146143.html</guid>
<description>&lt;p&gt;参考（原文简直超赞）：&lt;a id=&quot;url_1&quot; href=&quot;https://zhidao.baidu.com/question/687563051895364284.html&quot; target=&quot;_blank&quot;&gt;https://zhidao.baidu.com/question/687563051895364284.html&lt;/a&gt;&lt;br/&gt;下面是我结合原文写的，为了便于自己理解：&lt;br/&gt;关于阻塞和非阻塞的理解可以看这个：http://www.cnblogs.com/xcywt/p/8146123.html&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;1.举例子说明&lt;/span&gt;&lt;br/&gt;假设你在读大学，有个朋友F来找你，你住在A栋。但是不知道具体是哪个房间。于是你们约好在A栋门口见面。&lt;br/&gt;如果用阻塞IO模型来处理这个问题，你就相当于一直在A栋门口等着，这个时候你不能做别的事情，效率比较低，如果F一直不来你就得一直在那等着。&lt;br/&gt;接着来看用非阻塞模型来处理这个问题，主要有两种select/poll（这两个可以看成一种）和epoll：&lt;br/&gt;select大妈做的事情是这样：当朋友F到了楼下时，她带着F一个个房间了轮询的去找你。&lt;br/&gt;epoll大妈就比较高级了：大妈拿本子记录下你的房间号，当朋友F来的时候告诉F你的房间号。这样就不用整栋楼去跑了。&lt;br/&gt;在大并发服务器中，轮询IO是一件比较费时的操作，就跟select大妈一样。&lt;br/&gt;epoll大妈多用了一个本子，就有点用空间去换取时间的意思。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;2.select/poll为什么慢：&lt;/span&gt;&lt;br/&gt;1）select/poll 是遍历所有添加进fd_set的fd。并且需要将所有用户态的fd拷贝到内核态。数量巨大时这个效率比较慢&lt;br/&gt;2）并且返回之后，还要轮询将所有集合查询一次&lt;br/&gt;3）内核空间的数据需要拷贝到用户空间&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;3.epoll的实现原理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体使用方法可以参考：http://www.cnblogs.com/xcywt/p/8146094.html&lt;br/&gt;先说几个函数的作用&lt;br/&gt;       int epoll_create(int size); // 创建一个epoll对象，size是内核保证能够正确处理的最大句柄数。&lt;br/&gt;       int epoll_create1(int flags);// 上面的加强版本，参数只能是EPOLL_CLOEXEC&lt;br/&gt;       int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // 操作epoll对象&lt;br/&gt;       int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);// 在给定时间内，监控的所有句柄中有时间发生就返回&lt;br/&gt;下面我们来看具体做了什么：&lt;br/&gt;　　epoll在内核初始化的时候向内核注册了一个&lt;span&gt;文件系统，用于存储上述被监控的socket&lt;/span&gt;，同时还会开辟出epoll自己的内核高速cache区，用于安置需要监控的fd。这些fd以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说就是物理上分配好你想要的大小的内存对象，每次使用时都是使用空闲的已分配好的对象。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　每次调用epoll_create时，会在这个虚拟的&lt;span&gt;epoll文件系统里创建一个file节点&lt;/span&gt;，在内核cache中建立个红黑树来存储通过epoll_ctl添加进来的fd。这些fd其实已经在内核态了，当你再次调用epoll_wait时，&lt;span&gt;不需要再拷贝进内核态（select需要再全部拷贝到内核态）&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　同时还会建立&lt;span&gt;一个list链表，用来存储已经就绪的事件。被epoll_wait调用时，就去看这个list链表是不是为空，若不为空就返回，为空就等待指定的事件再返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　list链表是如何维护的呢：&lt;span&gt;当我们执行epoll_ctl时，会把对应fd放到红黑树中，还会给内核终端处理程序注册一个回调函数。如果这个句柄的中断到了，就把它放在list链表中去。&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;总结一下：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一棵红黑树和一个list链表就解决大并发的问题&lt;/span&gt;&lt;/strong&gt;。epoll_create时创建红黑树和就绪链表，epoll_ctl时添加到红黑树中（若存在则不添加）并向内核注册回调函数。epoll_wait时返回list就绪链表里面的数据就可以了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;4.epoll的两个工作模式：&lt;/span&gt;&lt;br/&gt;LT：只要一个句柄上的事件一次没有处理完，接着调用epoll_wait时仍然会返回这个句柄。&lt;br/&gt;ET：尽在空闲状态-&amp;gt;就绪状态返回一次。&lt;br/&gt;这件事是怎么做到的呢：当有fd'发生事件时，就放到list就绪链表中去了。然后epoll_wait返回，再然后清空准备list就绪链表。&lt;br/&gt;最后如果是LT模式，并且仍有未处理的事件，就把这个fd重新放回到list就绪链表中。&lt;br/&gt;如果是ET，就不管了，不管有没有事件未处理完都不再添加到list就绪链表中。&lt;/p&gt;
&lt;p&gt;就有点像下面的流程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wait返回 -&amp;gt;&lt;span&gt; 清空list就绪链表
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(LT模式）
{
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(存在未处理完的事件)
  {
    重新添加进list就绪链表中
  }
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ET 模式&lt;/span&gt;
&lt;span&gt;{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于触发模式详解，这里面也讲的比较详细：&lt;br/&gt;&lt;a id=&quot;url_2&quot; href=&quot;http://blog.csdn.net/weiyuefei/article/details/52242778&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/weiyuefei/article/details/52242778&lt;/a&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;5.ET模式被唤醒的条件&lt;/span&gt;：&lt;/span&gt;&lt;br/&gt;对于读取操作：&lt;br/&gt;1）buffer由不可读，变为可读的时候。&lt;br/&gt;2）buffer数据变多的时候，有新的数据到来&lt;br/&gt;3）当buffer不为空（有数据可读），且用户对相应fd进行epoll_mod  IN 事件时。（待会用代码演示）&lt;br/&gt;对于写操作：&lt;/p&gt;
&lt;p&gt;1）由不可写，变成可写&lt;br/&gt;2）buffer是数据变少的时候，也就是被读走了一部分3）buffer有可写空间，且用户对相应fd进行epoll_mod OUT 事件时。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;对于LT模式：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读操作：只要缓冲区中有数据，且读完一部分之后还不空的时候，就会返回&lt;/p&gt;
&lt;p&gt;写操作：当发送缓冲区没满，写了一下还不满的时候，epoll_wait返回读事件。&lt;/p&gt;
&lt;p&gt;补充一个例子1：验证ET模式的读取返回的前2个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLIN|EPOLLET; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记A，这里是ET模式
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ev.events = EPOLLIN; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记B。表示默认是LT模式&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加标准输入&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;read(STDIN_FILENO, buf, sizeof(buf)); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记C&lt;/span&gt;
                cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world, recv:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; buf &amp;lt;&amp;lt;&lt;span&gt; endl;
            }
        } 
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分三种情况讨论：&lt;/span&gt;&lt;br/&gt;1）打开标记A，注释B和C：这种情况运行，虽然输入缓冲区里面还有数据，但是“hello world”也不会一直打印。&lt;br/&gt;因为边沿触发，一定要等到下一次事件到来 wait才会返回。&lt;br/&gt;2）打开B，注释A和C：切换成了LT模式，只要缓冲区里面还有数据吗，wait会一直返回。所以helloworld会一直打印&lt;br/&gt;3）打开B和C，注释A：LT模式，但是每次wait之后把缓冲区里面的数据读完了，相当于处理完了这个事件。wait就不会返回了。除非标准输入中再输入数据。&lt;/p&gt;&lt;p&gt;例子2：验证ET模式的读取返回的第3个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLIN|&lt;span&gt;EPOLLET; 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &amp;lt;&amp;lt; endl;&lt;/span&gt;
                ev.data.fd =&lt;span&gt; STDIN_FILENO;
                ev.events &lt;/span&gt;= EPOLLIN|&lt;span&gt;EPOLLET;
                epoll_ctl(epfd, EPOLL_CTL_MOD, STDIN_FILENO, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对fd进行epoll_mod  IN 事件&lt;/span&gt;
&lt;span&gt;            }
        } 
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到当输入一次之后，依然会有死循环打印helloworld。&lt;/p&gt;&lt;p&gt;例子3：验证ET模式的写返回，前2个&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLOUT|&lt;span&gt;EPOLLET; 
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cout &amp;lt;&amp;lt; &quot;hello world&quot; &amp;lt;&amp;lt; endl; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记A&lt;/span&gt;
                cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标记B&lt;/span&gt;
&lt;span&gt;            }
        } 
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于ET模式。&lt;br/&gt;1）打开标记A，注释标记B：可以看到会死循环，因为这里有 endl 。标准输出为控制台的时候缓冲的“行缓冲”，所以换行符号导致buffer中的内容被清空。就相当于上面条件中的第二个，有数据发送走了。所以会一直循环&lt;br/&gt;2）打开B，注释A：不发送endl，就相当于buffer中一直有数据存在，所以wait不会一直返回。&lt;/p&gt;&lt;p&gt;例子4，ET模式的写返回第三个条件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;sys/epoll.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;  std;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd, ret;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
    ev.events &lt;/span&gt;= EPOLLOUT|&lt;span&gt;EPOLLET;

    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
    epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ret &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;5&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; ret; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd ==&lt;span&gt; STDIN_FILENO)
            {
                cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                ev.data.fd &lt;/span&gt;=&lt;span&gt; STDIN_FILENO;
                ev.events &lt;/span&gt;=&lt;span&gt; EPOLLOUT;
                epoll_ctl(epfd, EPOLL_CTL_MOD, STDIN_FILENO, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里对fd进行epoll_mod  OUT 事件&lt;/span&gt;
&lt;span&gt;            }
        } 
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每次输出helloworld后重新MOD OUT 事件。也会一直循环打印。&lt;br/&gt;注意：LT模式没有验证&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 12:12:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8146143.html</dc:identifier>
</item>
<item>
<title>JNI的使用总结初篇 - 孤竹牧歌</title>
<link>http://www.cnblogs.com/silentdoer/p/8145722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/silentdoer/p/8145722.html</guid>
<description>&lt;p&gt;前言：以下内容是个人在写JNI Demo前后进行查找理解总结得出的一些结论，如有错误的地方希望路过的朋友能够指正。&lt;/p&gt;
&lt;p&gt;一、JNI是Java native interface的简称，目前就我所知这类方法的实现方式是由C/C++实现并保存在动态链接库里；一般是这些方法需要能更有效率的执行所以将它们定义为JNI方法（权限似乎也是一方面？），JNI方法除了加上native关键字在返回类型前面以及实现方式由C/C++实现外在使用方式上和其它方法没有区别。&lt;/p&gt;
&lt;p&gt;二、个人用的开发环境是Windows7x64、IDEA2017.2.1x64、VS2015x64、JDK1.8x64，此次Demo只是做了一些JNI的简单使用，真正使用场景将会涉及到如数据转换等问题。&lt;/p&gt;
&lt;p&gt;三、个人对JNI原理的理解：Java代码里能够调用C/C++类库是因为有JVM为这两者做适配，因为JVM本身就是C/C++写的程序，自然它能够调用C/C++写的动态链接库，故当Java代码里请求调用一个JNI方法时，会将所需数据提交给JVM，然后JVM再将参数包装后去调用dll中对应的方法，然后dll中对应方法执行完毕后再由JVM将返回数据进行一定的转换后返回给请求的Java代码处。&lt;/p&gt;
&lt;p&gt;四、现在就让咱们一起用用这神秘的JNI方法吧，先是定义一个类JNIDemo类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; silentdoer.demo;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JNIDemo {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
        System.loadLibrary(&lt;/span&gt;&quot;JNIMethods01&quot;&lt;span&gt;);  // 这个是JNIMethods01.dll文件的前缀名
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compare(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hello();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sub(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);
}&lt;br/&gt;// 注：后面用javah命令时如果出现编码GBK的不可映射字符错误将中文删除即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着运行cmd，将路径切换到此项目的src目录，然后输入命令javah silentdoer.demo.JNIDemo按下回车键&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229184853945-1461609127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会在src目录下生成silentdoer_demo_JNIDemo.h头文件（也可以进入classes目录用上面的javah命令，不过这种方式如果此类里引用了其它地方的类会出现异常）&lt;/p&gt;
&lt;p&gt;五、接着打开VS2015，然后新建一个空解决方案起名为Demo.JNI，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229185403210-912012725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在生成的解决方案里右键添加-新建项目，然后添加一个C++的Win32项目起名为JNIMethods01：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229185533070-740084802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击确定然后点击下一步直到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229185605538-409870478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择应用程序类型Radio的DLL项点击完成（也可以取消勾选预编译头和安全开发生命周期检查）；&lt;/p&gt;
&lt;p&gt;六、由于我的开发环境都是64位的，故要将C++生成dll的类型也改为64位，顺便将Debug改为Release，如图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229190312476-173147990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将生成的头文件silentdoer_demo_JNIDemo.h复制到此项目的根目录下（不是解决方案），然后右键项目-添加-现有项&lt;/p&gt;
&lt;p&gt;将刚才的头文件添加到项目的头文件分类里，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229190058304-1619936541.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 此时添加的头文件里会报错，需要添加jni.h和jni_md.h两个头文件到项目的头文件分类里，这两个文件在JDK的include目录中，如图箭头：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229190541179-1324546290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jni_md.h在win32子目录里；复制到项目根目录后以同样的方式添加进项目里；&lt;/p&gt;
&lt;p&gt;这里需要改下silentdoer_demo_JNIDemo.h中#include &amp;lt;jni.h&amp;gt;为#include &quot;jni.h&quot;，因为&quot;jni.h&quot;才是从项目路径里搜索的方式。&lt;/p&gt;
&lt;p&gt;七、将silentdoer_demo_JNIDemo.h中的三个方法复制到JNIMethods01.cpp中并添加头文件引用，然后实现这三个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229191251054-481944464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229191141288-1343691696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 八、点击VS2015上边的生成-重新生成解决方案，然后找到此解决方案目录下的x64/Release目录，将JNIMethods01.dll复制到&lt;/p&gt;
&lt;p&gt;E:\MyJNILib目录里（也可以在其它目录里），然后添加Path环境变量，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/784440/201712/784440-20171229192930273-86289937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;九、此时可以在刚才的Java项目里添加main方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; silentdoer.demo.JNIDemo;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Entrance {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        JNIDemo.hello();
        System.out.println(JNIDemo.compare(&lt;/span&gt;3, 4) &amp;gt;= 0 ? &quot;a &amp;gt;= b&quot; : &quot;a &amp;lt; b&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; JNIDemo().sub(10, 6&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启一遍IDEA（因为IDEA只有启动时才加载Path环境变量），运行后输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
hello everyone, I'm silentdoer.
a &amp;lt;&lt;span&gt; b
&lt;/span&gt;4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此初篇完结，如有错误忘各位指正，也希望如果转载能带上本文的链接。&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 11:31:00 +0000</pubDate>
<dc:creator>孤竹牧歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/silentdoer/p/8145722.html</dc:identifier>
</item>
<item>
<title>挑战App Store，微信通过“跳一跳”秀了一下“小程序”的肌肉 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/8146013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/8146013.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;img-wrap&quot;&gt;&lt;img src=&quot;https://segmentfault.com/img/remote/1460000012643605&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000012643605&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201712/585973-20171229190553960-1550203228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2017年即将结束的时候，微信放了一个大招。随着最新的微信v6.6.1版本更新，基于小程序的“小游戏”板块正式上线。微信上首发的这款“小游戏”叫“跳一跳”，名字清新，画面可爱，上手简单，精通颇难，加上基于微信好友的排名系统，“跳一跳”短时间内成为热门游戏。&lt;/p&gt;
&lt;p&gt;“小游戏”的上线，小程序开始支持直播功能，以及新版微信在主界面加入小程序入口，意味着是微信小程序已经跳脱出“工具”的属性，开始正式挑战Apple Store以及国内的各大安卓市场。一个崭新的生态正在逐渐形成。&lt;/p&gt;
&lt;p&gt;苹果对iOS生态拥有绝对的话语权和控制权，开发者也不得不以苹果马首是瞻，想要让iOS用户使用自己的服务，必须开发App。微信小程序的出现，则撕开了iOS生态圈的一道口子，最大的想象空间就是成为iOS和在Android系统内的次级OS，开发者可以绕过Apple Store和各大安卓商店，直接通过微信为用户提供服务。对于终端用户也是如此：通过小程序能够实现的功能，何必单独下载一个App呢？&lt;/p&gt;
&lt;p&gt;微信“小程序”一旦成功，有可能引发类似Facebook等超级App的跟进，进而改变移动互联网的格局，重新分配流量红利。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201712/585973-20171229190609726-1375048728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/remote/1460000012643606&quot; alt=&quot;&quot; data-src=&quot;/img/remote/1460000012643606&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;articleHeader0&quot;&gt;“微信互联网”，或许不是一句玩笑。&lt;/h3&gt;
&lt;p&gt;前段时间，美丽联合集团CEO、蘑菇街创始人陈琪一句“国内不存在移动互联网，只有微信互联网”惊起一片波澜。“小程序”的此番更新，或许正是微信向着这个目标迈出的一大步。&lt;/p&gt;
&lt;p&gt;微信是国内最重要、用户最多的超级App，通过公众号打通了内容、营销，大大丰富了用户在微信里的使用场景，也极大拉长了用户使用微信的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201712/585973-20171229190631210-1041257712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; “小游戏”是微信进一步激活线上流量的杀手锏，同时也是“小程序”秀肌肉的一种方式。&lt;/p&gt;
&lt;p&gt;游戏需求市场巨大，必定能够吸引大量的开发者涌入，全面激活小程序生态。目前，“小游戏”已提供开发文档和工具，方便开发者先进行开发，待“小游戏”开放注册后，开发者还可注册和提交小游戏。&lt;/p&gt;
&lt;p&gt;至于“秀肌肉”，大致上可以这么理解：如果“小程序”都能承载手机游戏的运行，那还有什么功能是“小程序”不能提供的呢？&lt;/p&gt;
&lt;p&gt;随着“小程序”开放的API越来越丰富，提供的功能越来越完善，将会有越来越多的互联网服务通过“小程序”实现，围绕“小程序”展开的服务也越来越多。游戏、直播等功能的加入，主界面加入小程序入口，或许能够让小程序彻底狂奔起来，可视为微信给开发者送上的一份年终大礼。&lt;/p&gt;
&lt;h3 id=&quot;articleHeader1&quot;&gt;又拍云为小程序披荆斩棘&lt;/h3&gt;
&lt;p&gt;小程序属于基于微信端的轻量应用，开发者们普遍会遇上小程序发布内容超限（程序包小于1MB）、微信强制要求HTTPS访问、文件加载速度慢等问题，如果趁着红利准备涌进小程序的开发者，别忘了带上又拍云微信小程序SDK，问题就迎刃而解了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片压缩70%，体验流畅&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又拍云小程序SDK提供WebP格式转换，可以将jpg、png等格式一键转换成WebP格式，将图片大小缩减70%以上，为微信小程序提供流畅的图片加载体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/585973/201712/585973-20171229192405304-459354608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳脱1M限制，实现扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小程序要求安装包大小不超过1MB，通过又拍云的小程序SDK，可将文件上传又拍云进行压缩、优化，让小程序轻松“跳脱”1MB的容量限制。又拍云存储同时拥有上传下载加速，弹性扩容等功能，可轻松实现文件无限存储，快速读取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;升级HTTPS，增强防护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信小程序要求所有的网络链接都通过HTTPS协议进行访问，又拍云提供两款可以免费续期的SSL证书：Let’s Encrypt和Symantec，支持一键升级HTTPS，并可轻松切换不同证书，满足小程序各类开发需求。&lt;/p&gt;
&lt;p&gt;在小程序红利的风口，又拍云希望通过微信小程序SDK连接开发者，帮助开发者减轻后端部署、运维、证书配置等繁琐工作，减少开发成本的同时，提升用户体验。&lt;/p&gt;
&lt;p&gt;传送门：&lt;a href=&quot;https://github.com/upyun/wechat-sdk&quot; target=&quot;_blank&quot;&gt;又拍云小程序SDK&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Dec 2017 11:05:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/8146013.html</dc:identifier>
</item>
<item>
<title>Android 事件分发机制 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/8145959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/8145959.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;       点击事件的分发过程其实是对&lt;span&gt;MotionEvent事件分发过程&lt;/span&gt;，当一个MotionEvent产生以后，系统需要把这个事件传递给一个具体的View，而这个传递过程就是分发过程。点击事件的分发由三个重要的方法共同完成：dispatchTouchEvent,onInterceptTOuchEvent,onTouchEvent。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;View里，有两个回调函数 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; dispatchTouchEvent(MotionEvent ev)；
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onTouchEvent(MotionEvent ev);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ViewGroup里，有三个回调函数 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; dispatchTouchEvent(MotionEvent ev)；
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onInterceptTouchEvent(MotionEvent ev);
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onTouchEvent(MotionEvent ev);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Activity里，有两个回调函数 :&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; dispatchTouchEvent(MotionEvent ev)；
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onTouchEvent(MotionEvent ev);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Android中默认情况下事件传递是由最终的view的接收到，传递过程是从父布局到子布局，也就是&lt;span&gt;从Activity到ViewGroup到View的过程&lt;/span&gt;，默认情况，ViewGroup起到的是透传作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140227095525546&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         触摸事件是一连串ACTION_DOWN，ACTION_MOVE..MOVE…MOVE、最后ACTION_UP，触摸事件还有ACTION_CANCEL事件。事件都是从ACTION_DOWN开始的，&lt;span&gt;Activity的dispatchTouchEvent()&lt;/span&gt;首先接收到&lt;span&gt;ACTION_DOWN&lt;/span&gt;，执行super.dispatchTouchEvent(ev)，事件向下分发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt; dispatchTouchEvent()返回true&lt;span&gt;，后续事件（ACTION_MOVE、ACTION_UP）&lt;span&gt;会再传递&lt;/span&gt;，如果返回false，dispatchTouchEvent()&lt;span&gt;就接收不到ACTION_UP、ACTION_MOVE&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1 不消费ACTION_DOWN，后续收不到ACTION_MOVE、ACTION_UP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140226202907812&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;View中没有拦截器，只能调用onTouchEvent选择消费或者不消费该事件。上图中View的onTouchEvent方法返回false，一直将false返回最顶层的ViewGrouop，该事件后续的ACTION_MOVE,ACTION_UP都不会再调用。&lt;/p&gt;
&lt;p&gt;注： 如果View是可点击的（Button），onTouchEvent默认返回True，ImageView 则默认返回false。&lt;/p&gt;
&lt;h3&gt;2 消费ACTION_DOWN&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140226203028734&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后续ACTION_MOVE 和 UP 在不被拦截的情况下都会找到这个View&lt;/p&gt;

&lt;h3&gt;3 ACTION_MOVE 和 UP 被上层拦截&lt;img src=&quot;http://img.blog.csdn.net/20140226203125390&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140226203214000&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4 全部被上层拦截（包括ACTION_DOWN,ACTION_MOVE,ACTION_UP）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140226203301578&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;android中的Touch事件都是从ACTION_DOWN开始的：&lt;/p&gt;
&lt;p&gt;单手指操作：ACTION_DOWN---ACTION_MOVE----ACTION_UP&lt;/p&gt;
&lt;p&gt;多手指操作：ACTION_DOWN---ACTION_POINTER_DOWN---ACTION_MOVE--ACTION_POINTER_UP---ACTION_UP.&lt;/p&gt;
&lt;p&gt;参考：&lt;a title=&quot;http://www.eoeandroid.com/thread-319301-1-1.html?_dsign=495a5374&quot; href=&quot;http://www.eoeandroid.com/thread-319301-1-1.html?_dsign=495a5374&quot;&gt;http://www.eoeandroid.com/thread-319301-1-1.html?_dsign=495a5374&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5 源码解析&lt;/h3&gt;
&lt;p&gt;1/ dispatchTouchEvent 用来进行事件分发，如果事件能够传递到当前的View，那么此方法一定会被调用，返回结果受当前View的OnTouchEvent和下级View的,onInterceptTOuchEvent方法影响，表示是否消耗当前事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     *
     * @param event The motion event to be dispatched.
     * @return True if the event was handled by the view, false otherwise.
     */&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; dispatchTouchEvent(MotionEvent event)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2/ &lt;strong&gt;onInterceptTouchEvent&lt;/strong&gt;是ViewGroup提供的方法，默认返回false，返回true表示拦截。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
 * @param ev The motion event being dispatched down the hierarchy.
     * @&lt;span&gt;return&lt;/span&gt; Return &lt;span&gt;true&lt;/span&gt; to steal motion events from the children and have
     * them dispatched to &lt;span&gt;this&lt;/span&gt; ViewGroup through onTouchEvent().
     * The current target will receive an
&lt;/pre&gt;
&lt;span&gt;ACTION_CANCEL&lt;/span&gt;
&lt;pre&gt;
 event, and no further
     * messages will be delivered here.
     */
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onInterceptTouchEvent(MotionEvent ev) {
        &lt;span&gt;if&lt;/span&gt; (ev.isFromSource(InputDevice.SOURCE_MOUSE)
                &amp;amp;&amp;amp; ev.getAction() == MotionEvent.ACTION_DOWN
                &amp;amp;&amp;amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)
                &amp;amp;&amp;amp; isOnScrollbarThumb(ev.getX(), ev.getY())) {
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
        }
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3/ onTouchEvent  在 dispatchTouchEvent中被调用，用来处理点击事件，返回结果表示是否消耗此事件。如果不消耗，在同一事件序列中，当前View无法再次接受到事件。&lt;/p&gt;
&lt;h3&gt;6 事件分发与onClick/onTouch 的关系&lt;/h3&gt;
&lt;p&gt;为同一个button同时设置click和touch的Listener&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
button.setOnClickListener(&lt;span&gt;new&lt;/span&gt; OnClickListener() {
    @Override
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onClick(View v) {
        Log.d(&quot;&lt;span&gt;TAG&lt;/span&gt;&quot;, &quot;&lt;span&gt;onClick execute&lt;/span&gt;&quot;);
    }
});
button.setOnTouchListener(&lt;span&gt;new&lt;/span&gt; OnTouchListener() {
    @Override
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onTouch(View v, MotionEvent event) {
        Log.d(&quot;&lt;span&gt;TAG&lt;/span&gt;&quot;, &quot;&lt;span&gt;onTouch execute, action &lt;/span&gt;&quot; + event.getAction());
        
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;/span&gt;
&lt;pre&gt;
    }
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当点击这个Button时的log如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130614230234671&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，onTouch是优先于onClick执行的，并且onTouch执行了两次，一次是ACTION_DOWN，一次是ACTION_UP(你还可能会有多次ACTION_MOVE的执行，如果你手抖了一下)。因此事件传递&lt;span&gt;的顺序是先经过onTouch，再传递到onClick&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;问题1 ： 当把onTouch的方法返回值改成true时，&lt;span&gt;则onClick不再执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原因：  当事件分发到该Button时，会调用它的onDispatchTouchEvent方法，该方法源码中大致有一个这样的判断：如果onTouch方法返回true时，表示onTouch消耗了改事件直接返回true，onTouchEvent方法则不再被调用（当ACTION_UP事件传递进来时，onClick在该方法中被调用，所以onClick也不会被调用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; dispatchTouchEvent(MotionEvent event) {
    &lt;span&gt;if&lt;/span&gt; (mOnTouchListener != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp;
            mOnTouchListener.onTouch(&lt;span&gt;this&lt;/span&gt;, event)) {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
    }
    &lt;span&gt;return&lt;/span&gt; onTouchEvent(event);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注： 不同版本的可能上述代码实现不相同，但是思想一致。&lt;/p&gt;
&lt;p&gt;问题2：onTouch返回false时，在ACTION_DOWN事件中onDispatchTouchEvent应该返回false，后续的&lt;span&gt;ACTION_UP应该不会被调用，&lt;/span&gt;为什么还有log。&lt;/p&gt;
&lt;p&gt;原因： 分析onTouchEvent源码，如果view是可点击的，则默认返回true消耗该事件。如果view是不可点击的则返回false，例如ImageView。所以对于BUTTON第一次ACTION_DOWN的onDispatchTouchEvent返回的是true，而对于ImageView返回值为false，它的后续ACTION_MOVE/ACTION_UP不会再被调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_b09dcbac-6162-4801-bed5-2085c7e9f989&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b09dcbac-6162-4801-bed5-2085c7e9f989&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b09dcbac-6162-4801-bed5-2085c7e9f989&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; onTouchEvent(MotionEvent event) {
&lt;span&gt;  2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; x = event.getX();
&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; y = event.getY();
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; viewFlags = mViewFlags;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; action = event.getAction();
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((viewFlags &amp;amp; ENABLED_MASK) == DISABLED) {
&lt;span&gt;  8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (action == MotionEvent.ACTION_UP &amp;amp;&amp;amp; (mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
&lt;span&gt;  9&lt;/span&gt;                 setPressed(&lt;span&gt;false&lt;/span&gt;);
&lt;span&gt; 10&lt;/span&gt;             }
&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;// A disabled view that is clickable still consumes the touch&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;// events, it just doesn't respond to them.&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE
&lt;span&gt; 14&lt;/span&gt;                     || (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE)
&lt;span&gt; 15&lt;/span&gt;                     || (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
&lt;span&gt; 16&lt;/span&gt;         }
&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (mTouchDelegate != &lt;span&gt;null&lt;/span&gt;) {
&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (mTouchDelegate.onTouchEvent(event)) {
&lt;span&gt; 19&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
&lt;span&gt; 20&lt;/span&gt;             }
&lt;span&gt; 21&lt;/span&gt;         }
&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||
&lt;span&gt; 24&lt;/span&gt;                 (viewFlags &amp;amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
&lt;span&gt; 25&lt;/span&gt;                 (viewFlags &amp;amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt; (action) {
&lt;span&gt; 27&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; MotionEvent.ACTION_UP:
&lt;span&gt; 28&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; prepressed = (mPrivateFlags &amp;amp; PFLAG_PREPRESSED) != 0;
&lt;span&gt; 29&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0 || prepressed) {
&lt;span&gt; 30&lt;/span&gt;                         &lt;span&gt;// take focus if we don't have it already and we should in&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;                         &lt;span&gt;// touch mode.&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;                         &lt;span&gt;boolean&lt;/span&gt; focusTaken = &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt; 33&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (isFocusable() &amp;amp;&amp;amp; isFocusableInTouchMode() &amp;amp;&amp;amp; !isFocused()) {
&lt;span&gt; 34&lt;/span&gt;                             focusTaken = requestFocus();
&lt;span&gt; 35&lt;/span&gt;                         }
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (prepressed) {
&lt;span&gt; 38&lt;/span&gt;                             &lt;span&gt;// The button is being released before we actually&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;                             &lt;span&gt;// showed it as pressed.  Make it show the pressed&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;                             &lt;span&gt;// state now (before scheduling the click) to ensure&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;                             &lt;span&gt;// the user sees it.&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;                             setPressed(&lt;span&gt;true&lt;/span&gt;, x, y);
&lt;span&gt; 43&lt;/span&gt;                        }
&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
&lt;span&gt; 46&lt;/span&gt;                             &lt;span&gt;// This is a tap, so remove the longpress check&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;                             removeLongPressCallback();
&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt;                             &lt;span&gt;// Only perform take click actions if we were in the pressed state&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (!focusTaken) {
&lt;span&gt; 51&lt;/span&gt;                                 &lt;span&gt;// Use a Runnable and post this rather than calling&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;                                 &lt;span&gt;// performClick directly. This lets other visual state&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;                                 &lt;span&gt;// of the view update before click actions start.&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (mPerformClick == &lt;span&gt;null&lt;/span&gt;) {
&lt;span&gt; 55&lt;/span&gt;                                     mPerformClick = &lt;span&gt;new&lt;/span&gt; PerformClick();
&lt;span&gt; 56&lt;/span&gt;                                 }
&lt;span&gt; 57&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (!post(mPerformClick)) {
&lt;span&gt; 58&lt;/span&gt;                                     performClick();
&lt;span&gt; 59&lt;/span&gt;                                 }
&lt;span&gt; 60&lt;/span&gt;                             }
&lt;span&gt; 61&lt;/span&gt;                         }
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (mUnsetPressedState == &lt;span&gt;null&lt;/span&gt;) {
&lt;span&gt; 64&lt;/span&gt;                             mUnsetPressedState = &lt;span&gt;new&lt;/span&gt; UnsetPressedState();
&lt;span&gt; 65&lt;/span&gt;                         }
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (prepressed) {
&lt;span&gt; 68&lt;/span&gt;                             postDelayed(mUnsetPressedState,
&lt;span&gt; 69&lt;/span&gt;                                     ViewConfiguration.getPressedStateDuration());
&lt;span&gt; 70&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!post(mUnsetPressedState)) {
&lt;span&gt; 71&lt;/span&gt;                             &lt;span&gt;// If the post failed, unpress right now&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;                             mUnsetPressedState.run();
&lt;span&gt; 73&lt;/span&gt;                         }
&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;                         removeTapCallback();
&lt;span&gt; 76&lt;/span&gt;                     }
&lt;span&gt; 77&lt;/span&gt;                     mIgnoreNextUpEvent = &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt; 78&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;;
&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; MotionEvent.ACTION_DOWN:
&lt;span&gt; 81&lt;/span&gt;                     mHasPerformedLongPress = &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (performButtonActionOnTouchDown(event)) {
&lt;span&gt; 84&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;;
&lt;span&gt; 85&lt;/span&gt;                     }
&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;                     &lt;span&gt;// Walk up the hierarchy to determine if we're inside a scrolling container.&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;                     &lt;span&gt;boolean&lt;/span&gt; isInScrollingContainer = isInScrollingContainer();
&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;                     &lt;span&gt;// For views inside a scrolling container, delay the pressed feedback for&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;                     &lt;span&gt;// a short period in case this is a scroll.&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (isInScrollingContainer) {
&lt;span&gt; 93&lt;/span&gt;                         mPrivateFlags |= PFLAG_PREPRESSED;
&lt;span&gt; 94&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (mPendingCheckForTap == &lt;span&gt;null&lt;/span&gt;) {
&lt;span&gt; 95&lt;/span&gt;                             mPendingCheckForTap = &lt;span&gt;new&lt;/span&gt; CheckForTap();
&lt;span&gt; 96&lt;/span&gt;                         }
&lt;span&gt; 97&lt;/span&gt;                         mPendingCheckForTap.x = event.getX();
&lt;span&gt; 98&lt;/span&gt;                         mPendingCheckForTap.y = event.getY();
&lt;span&gt; 99&lt;/span&gt;                         postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
&lt;span&gt;100&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt; {
&lt;span&gt;101&lt;/span&gt;                         &lt;span&gt;// Not inside a scrolling container, so show the feedback right away&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                         setPressed(&lt;span&gt;true&lt;/span&gt;, x, y);
&lt;span&gt;103&lt;/span&gt;                         checkForLongClick(0, x, y);
&lt;span&gt;104&lt;/span&gt;                     }
&lt;span&gt;105&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;;
&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; MotionEvent.ACTION_CANCEL:
&lt;span&gt;108&lt;/span&gt;                     setPressed(&lt;span&gt;false&lt;/span&gt;);
&lt;span&gt;109&lt;/span&gt;                     removeTapCallback();
&lt;span&gt;110&lt;/span&gt;                     removeLongPressCallback();
&lt;span&gt;111&lt;/span&gt;                     mInContextButtonPress = &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt;112&lt;/span&gt;                     mHasPerformedLongPress = &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt;113&lt;/span&gt;                     mIgnoreNextUpEvent = &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt;114&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;;
&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; MotionEvent.ACTION_MOVE:
&lt;span&gt;117&lt;/span&gt;                     drawableHotspotChanged(x, y);
&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt;                     &lt;span&gt;// Be lenient about moving outside of buttons&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!pointInView(x, y, mTouchSlop)) {
&lt;span&gt;121&lt;/span&gt;                         &lt;span&gt;// Outside button&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;                         removeTapCallback();
&lt;span&gt;123&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; ((mPrivateFlags &amp;amp; PFLAG_PRESSED) != 0) {
&lt;span&gt;124&lt;/span&gt;                             &lt;span&gt;// Remove any future long press/tap checks&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;                             removeLongPressCallback();
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;                             setPressed(&lt;span&gt;false&lt;/span&gt;);
&lt;span&gt;128&lt;/span&gt;                         }
&lt;span&gt;129&lt;/span&gt;                     }
&lt;span&gt;130&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;;
&lt;span&gt;131&lt;/span&gt;             }
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
&lt;span&gt;134&lt;/span&gt;         }
&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
&lt;span&gt;137&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;参考：&lt;a title=&quot;http://blog.csdn.net/guolin_blog/article/details/9097463&quot; href=&quot;http://blog.csdn.net/guolin_blog/article/details/9097463&quot;&gt;http://blog.csdn.net/guolin_blog/article/details/9097463&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;7 ViewGroup的事件拦截&lt;/h3&gt;
&lt;p&gt;      一般情况下，如果Layout定义了onTouch事件，同时在Layout中添加了两个按钮。当点击按钮时，onTouch事件不会被调用（ViewGroup中源码可知，调用子View中Button的dispatchTouchEvent返回true，后面的onTouch事件不再被调用）。 但是点击除按钮之外的区域则onTouch事件会被调用。&lt;/p&gt;
&lt;p&gt;     当重写Layout中的onIntercreptTouchEvent函数，返回true时，则事件不会被传递到子View，直接调用Viewgroup的onTouchEvent处理事件，不管点击哪里，它的onTouch都会被执行。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://blog.csdn.net/guolin_blog/article/details/9153747&quot; href=&quot;http://blog.csdn.net/guolin_blog/article/details/9153747&quot;&gt;http://blog.csdn.net/guolin_blog/article/details/9153747&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;    1、 一个事件序列，ACTIVON_DOWN,ACTION_MOVE,ACTION_UP。 当DOWN事件时顶层ViewGroup的dispatchTouchEvent返回false时，后续事件都不再执行。&lt;/p&gt;
&lt;p&gt;   2、可点击View的onTouchEvent默认返回true，其它返回false&lt;/p&gt;
&lt;p&gt;   3、ViewGroup中dispatchTouchEvent和View中的该函数实现不同，View中该函数的onTouch都会执行，如果返回false，再执行onTouchEvnet。 ViewGroup中，如果子View消耗了这次事件则它的onTouch事件不会被执行。 &lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 29 Dec 2017 10:50:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/8145959.html</dc:identifier>
</item>
</channel>
</rss>