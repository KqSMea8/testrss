<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据加密算法--详解DES算法原理与实现 - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/9333753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/9333753.html</guid>
<description>&lt;p&gt;DES(Data Encryption Standard)是目前最为流行的加密算法之一。DES是对称的，也就是说它使用同一个密钥来加密和解密数据。&lt;/p&gt;&lt;p&gt;DES还是一种分组加密算法，该算法每次处理固定长度的数据段，称之为分组。DES分组的大小是64位，如果加密的数据长度不是64位的倍数，可以按照某种具体的规则来填充位。&lt;/p&gt;&lt;p&gt;从本质上来说，DES的安全性依赖于虚假表象，从密码学的术语来讲就是依赖于“混乱和扩散”的原则。混乱的目的是为隐藏任何明文同密文、或者密钥之间的关系，而扩散的目的是使明文中的有效位和密钥一起组成尽可能多的密文。两者结合到一起就使得安全性变得相对较高。&lt;/p&gt;&lt;p&gt;DES算法具体通过对明文进行一系列的排列和替换操作来将其加密。过程的关键就是从给定的初始密钥中得到16个子密钥的函数。要加密一组明文，每个子密钥按照顺序（1-16）以一系列的位操作施加于数据上，每个子密钥一次，一共重复16次。每一次迭代称之为一轮。要对密文进行解密可以采用同样的步骤，只是子密钥是按照逆向的顺序（16-1）对密文进行处理。&lt;/p&gt;&lt;p&gt;上面提到DES算法的第一步就是从初始密钥中计算得出16个子密钥。图示1展示了这个过程。DES使用一个56位的初始密钥，但是这里提供的是一个64位的值，这是因为在硬件实现中每8位可以用于奇偶校验，在软件实现中多出的位只是简单的忽略掉。要获得一个56位的密钥，可以执照表1的方式执行密钥转换。解释一下表1，按照从左往右从上往下的方式看，表格中每个位置P包含初始密钥中位在转换后的密钥中所占的位置。比如，初始密钥中的第57位就是转换后的密钥中的第1位，而初始密钥中的第49位则变成转换后的密钥中的第2位，以此类推...。（数据位的计数顺序按照从左到右从1开始的）&lt;/p&gt;&lt;p&gt;将密钥转换为56位后，接下来计算子密钥。首先，将56位的密钥分为两个28位的组。然后，针对每个子密钥，根据子密钥的序列值（也就是16个子密钥中的第几个）旋转这两组值（旋转的位数见表2），然后重新合并。之后，&lt;strong&gt;再按照表3所示对重组后的密钥进行置换，使56位的子密钥缩小为48位（注意表3只有48位，丢弃了8位）&lt;/strong&gt;。&lt;strong&gt;这个排列过程就称为置换选择&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;针对16个子密钥，每个子密钥重复一次该过程。这里的目的是保证将初始密钥中的不同位在每一轮排列后应用于加密的数据上。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;表2：针对DES子密钥每一轮的旋转次数（Round轮，Rotations旋转次数）(DesRotations)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;经过上述过程，我们已经准备好了子密钥。接着就可以加密和解密数据块了。图2展示了这个过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从表4所示的方式置换64位的数据块开始，该置换过程称为初始置换&lt;/strong&gt;。该过程并不会增加DES的安全性，但这种做法在16位和32位的总线出现之前将使得数据更容易加载到DES芯片中。虽然这种处理已经不合时宜，但该置换过程仍然保留以满足DES标准。&lt;/p&gt;&lt;p&gt;完成初始置换后，数据块将重复执行16轮一系列的操作。每一轮操作（i）的目的是计算出L&lt;sub&gt;i&lt;/sub&gt;和R&lt;sub&gt;i&lt;/sub&gt; ，这些结果将用在下一轮操作中直到最终得到数据R&lt;sub&gt;16&lt;/sub&gt;和L&lt;sub&gt;16&lt;/sub&gt;。&lt;/p&gt;&lt;p&gt;每一轮以L&lt;sub&gt;i-1&lt;/sub&gt;和R&lt;sub&gt;i-1&lt;/sub&gt;开始，然后根据表5所示进行扩展置换，&lt;strong&gt;&lt;span&gt;将R&lt;sub&gt;i-1&lt;/sub&gt;从32位扩展到48位&lt;/span&gt;&lt;/strong&gt;。该置换的主要目的是在加密数据的过程中制造一些&lt;strong&gt;雪崩效应&lt;/strong&gt;，使用数据块中的1位将在下一步操作中影响更多位，从而产生&lt;strong&gt;扩散效果&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;一旦扩展置换完成，&lt;span&gt;计算出48位的结果值与这一轮子密钥K&lt;sub&gt;i&lt;/sub&gt;的异或值&lt;/span&gt;（XOR，符号计为⊕）。&lt;strong&gt;这将产生48位的中间值，记为R&lt;/strong&gt;&lt;sub&gt;i&lt;strong&gt;nt&lt;/strong&gt;&lt;/sub&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;如果将E计为扩展置换的结果，则本轮到目前为止的操作可以表示为：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;下一步，&lt;strong&gt;&lt;span&gt;R&lt;/span&gt;&lt;sub&gt;int&lt;/sub&gt; 需要通过8个单独的S盒执行8次替换操作&lt;/strong&gt;。每个S盒（j）从R&lt;sub&gt;int&lt;/sub&gt;的6j 到 6j+6 的位置取出6位，并为其在表6中查出1个4位的值，将该值写到缓冲区的4j位置处（如图3）。&lt;/p&gt;&lt;p&gt;读表6，查找S盒（j）。通过前面取出的6位值，根据第1位和最后1位组成的2位值找到表6中的行号，而根据中间剩下的4位来确定表6中的列号。比如，在图3中，Rint中的第3个6位组是101011。因此，在表6中查找到的第3个S盒是9。因为行号等于11&lt;sub&gt;2&lt;/sub&gt; = 3，列号等于0101&lt;sub&gt;2&lt;/sub&gt; = 5（&lt;span&gt;查表时从索引0开始计数&lt;/span&gt;）。S盒为数据增加了不确定性，除了给DES带来安全性外，没什么特别的。&lt;/p&gt;&lt;p&gt;一旦完成了S盒替换，&lt;strong&gt;得到的结果又变为一个32位的值&lt;/strong&gt;。接下来再通过P盒来置换。如下表7所示。&lt;/p&gt;&lt;p&gt;到目前为止，我们把这一轮的操作想象为一个函数，&lt;strong&gt;一般记为f。如果 b&lt;sub&gt;j&lt;/sub&gt; 代表R&lt;sub&gt;int&lt;/sub&gt;中的第j个6位组，S&lt;sub&gt;j&lt;/sub&gt; 代表第j个S盒，而P代表P盒置换，则该函数可以定义为&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;每一轮的最后一个操作是&lt;span&gt;计算 f 的32位结果值与传入本轮操作的原始数据的左分组L&lt;/span&gt;&lt;sub&gt;i-1&lt;/sub&gt;之间的异或值。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;把所有的步骤连起来，在每一轮中计算Li和Ri的步骤可以精确表示为：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当全部的16轮操作都结束后，&lt;strong&gt;将最后的右分组R&lt;sub&gt;16&lt;/sub&gt;和最后剩下的左分组L&lt;sub&gt;16&lt;/sub&gt;连接起来，组成一个64位的分组R&lt;sub&gt;16&lt;/sub&gt;L&lt;sub&gt;16&lt;/sub&gt;&lt;/strong&gt;。（回顾一下，在最后一轮中左右分组并没有交换。最后的右分组在左边而最后的左分组在右边。）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;最后一步是将R&lt;sub&gt;16&lt;/sub&gt;L&lt;sub&gt;16&lt;/sub&gt;按照表8所示的置换进行置换。简而言之，就是撤消之前的初始置换。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;加密数据时，最终结果就是一个64位的密文，而当解密数据时，最终结果就是64位的明文了。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;void des_encipher(const unsigned char *plaintext, unsigned char *ciphertext, unsigned char *key);&lt;/p&gt;&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;采用DES算法，将明文plaintext的一个64位的明文组加密&lt;/strong&gt;。在key中指定64位的密钥（最后8位将被忽略掉，实际得到56位的密钥）。ciphertext是返回的64位的密文组。&lt;/p&gt;&lt;p&gt;由调用者负责管理ciphertext所需要的空间。要加密一段较大的数据，可以按照分组加密模式调用des_encipher。为了得到较高的效率，&lt;strong&gt;des_encipher可以重用之前的调用中计算出来的子密钥，这可以通过在之后的调用中将NULL传给key，以此来开启这种功能。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;void des_decipher(const unsigned char *ciphertext, unsigned char *plaintext, unsigned char *key);&lt;/p&gt;&lt;p&gt;&lt;strong&gt;描述&lt;/strong&gt;：&lt;strong&gt;采用DES算法将密文ciphertext的一个64位分组解密&lt;/strong&gt;。该函数假设ciphertext包含的是通过des_encipher加密过的密文。在key中指定64位的密钥（最后8位将被忽略掉，实际得到56位的密钥）。plaintext是返回的64位的明文组。由调用者负责管理plaintext所需要的空间。要解密一大段的数据，可以按照分组加密模式调用des_decipher。为了获得较高的效率，&lt;strong&gt;des_decipher可以重用之前调用中计算出来的子密钥。可以在随后的调用中将NULL传给key，以此来开启这种功能。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;考虑到DES算法中涉及的位操作很多，因此DES算法通常都是在硬件中实现。DES算法中的图表和术语（通过线、框画的流程图，以及诸如S盒、P盒这样的术语）使其更倾向于在硬件中实现，当然，软件实现也有它的价值所在。在软件开发中，通过几种基本的指令操作来帮助实现DES中的各种置换、转换以及替换操作都是很有效的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;由于DES的一个很好的特点是&lt;span&gt;同样的过程既能用来加密数据也能用来解密数据&lt;/span&gt;&lt;/strong&gt;，因此des_encipher只需要简单的调用des_main，而des_decipher同样也只需要调用des_main即可。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;函数des_main通过使用其&lt;span&gt;参数direction来确定到参数source提供的数据是明文还是密文&lt;/span&gt;&lt;/strong&gt;。direction参数只是简单地修改子密钥的顺序。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;函数des_main()首先检测参数key是否为NULL&lt;/strong&gt;。这将允许des_encipher的调用者重用上一次调用时计算出来的子密钥。将子密钥数组subkeys声明为static类型。如果key不为NULL，将计算子密钥。&lt;/p&gt;&lt;p&gt;要计算子密钥，可以按照前面介绍过的步骤（计算16个子密钥）来执行。&lt;strong&gt;key的转换是通过函数permute来实现的&lt;/strong&gt;，&lt;strong&gt;这里就是根据一个特定的表在一个缓冲区中置换位&lt;/strong&gt;。假设表中的每个位置（i）上都存在一个值p，函数permute通过将位置p的位移动到位置（i）上来完成对传入的buffer的置换。&lt;/p&gt;&lt;p&gt;要置换密钥，将表Des_Transform（同表1）传给函数permute。必要的旋转操作可以通过调用位操作bit_rot_left来实现。该操作将buffer按照指定的位数向左旋转。每一轮要正确旋转28位的子密钥分组，将表Des_Rotations（同表2）中合适的元素传给bit_rot_left。通过调用permute，并把传入表Des_permuted（同表3），来对每一个子密钥做置换选择。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;要加密一个数据块，首先要执行初始置换&lt;/strong&gt;。为实现这一步，首先调用函数permute并将表Des_Initial（同表4）传入。然后，将数据分为两个32位的分组：lblk以及rblk。回顾一下，加密数据的大部分工作都是将一系列的操作重复执行16轮。每一轮的主要工作都花在计算函数（f）的值上，将值保存在fblk中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;每一轮操作开始时，将对rblk执行一个扩展置换&lt;/strong&gt;。为了实现这个步骤，将调用函数permute，并把表Des_Expansion（同表5）传入。&lt;strong&gt;然后，通过调用位操作bit_xor来计算扩展后的rblk和某个适当的子密钥的异或值&lt;/strong&gt;。无论是加密还是解密数据，与本轮操作相关的子密钥都需要参与执行。&lt;strong&gt;一旦完成了异或计算，将对结果执行一系列的S盒替换操作&lt;/strong&gt;。Des_Sbox（同表6）定义了8个用于DES算法中的S盒。对于当前fblk中的每个6位分组，第1位和最后1位联合起来确定Des_Sbox中的行号，而中间的4位用来确定列号。&lt;strong&gt;最后执行P盒置换来完成函数f的计算&lt;/strong&gt;。通过调用permute函数并传入表Des_Pbox（同表7）来实现这个步骤。计算出lblk与函数f的值的异或结果，并交换lblk和rblk来结束一轮的操作。&lt;/p&gt;&lt;p&gt;将上述过程重复16次，每轮一次。&lt;strong&gt;当全部16轮操作完成后，将rblk拷贝到target的前32位中，将lblk拷贝到之后的32位中（按照要求，最后一轮不交换lblk和rblk）。最终，通过调用permute并把Des_Final（同表8）传入来完成最后的置换操作。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;des_encipher的时间复杂度是O（1），因为加密数据块的所有步骤都能在恒定的时间内完成。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;函数des_decipher将一个64位的密文分组通过DES算法进行解密。&lt;/strong&gt;同des_encipher一样，des_decipher实际通过调用des_main来完成解密任务，但&lt;strong&gt;这里direction需要设置为decipher&lt;/strong&gt;。因此，des_decipher的工作方式同des_encipher一样，只是这里的子密钥需要以逆序的方式参与。&lt;strong&gt;具体来说，就是在des_main中，针对每一轮i（从0开始计数），参与计算的子密钥为subkeys数组中下标为（15-i）的元素。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;des_decipher的时间复杂度为O（1），因为解密数据块中的所有步骤都可以在恒定的时间内完成。&lt;/p&gt;&lt;div readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;encrypt.h&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#ifndef ENCRYPT_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; ENCRYPT_H

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;在一个安全实现中，Huge 最少要400位10进制数字&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; Huge; 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为RSA公钥定义一个数据结构&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; RsaPubKey_
{
    Huge e;
    Huge n;
}RsaPubkey;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为RSA私钥定义一个数据结构&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; RsaPriKey_
{
    Huge d;
    Huge n;
}RsaPriKey;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;函数声明&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; des_encipher(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *plaintext, unsigned &lt;span&gt;char&lt;/span&gt; *ciphertext, &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;key);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; des_decipher(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *ciphertext, unsigned &lt;span&gt;char&lt;/span&gt; *plaintext, &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;key);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rsa_encipher(Huge plaintext, Huge *&lt;span&gt;ciphertext, RsaPubKey pubkey);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; rsa_decipher(Huge ciphertext,Huge *&lt;span&gt;plaintext, RsaPriKey prikey);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ENCRYPT_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;886&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;des.c&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;math.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bit.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;encrypt.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义一个密钥置换的映射&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesTransform[&lt;span&gt;56&lt;/span&gt;] =&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;57&lt;/span&gt;,&lt;span&gt;49&lt;/span&gt;,&lt;span&gt;41&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;58&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;59&lt;/span&gt;,&lt;span&gt;51&lt;/span&gt;,&lt;span&gt;43&lt;/span&gt;,&lt;span&gt;35&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;60&lt;/span&gt;,&lt;span&gt;52&lt;/span&gt;,&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;36&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;63&lt;/span&gt;,&lt;span&gt;55&lt;/span&gt;,&lt;span&gt;47&lt;/span&gt;,&lt;span&gt;39&lt;/span&gt;,&lt;span&gt;31&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;62&lt;/span&gt;,&lt;span&gt;54&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;61&lt;/span&gt;,&lt;span&gt;53&lt;/span&gt;,&lt;span&gt;45&lt;/span&gt;,&lt;span&gt;37&lt;/span&gt;,&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于计算子密钥的旋转次数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesRotations[&lt;span&gt;16&lt;/span&gt;] =&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于子密钥置换选择的映射&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesPermuted[&lt;span&gt;48&lt;/span&gt;] =&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;41&lt;/span&gt;,&lt;span&gt;52&lt;/span&gt;,&lt;span&gt;31&lt;/span&gt;,&lt;span&gt;37&lt;/span&gt;,&lt;span&gt;47&lt;/span&gt;,&lt;span&gt;55&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;40&lt;/span&gt;,&lt;span&gt;51&lt;/span&gt;,&lt;span&gt;45&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;,&lt;span&gt;48&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;49&lt;/span&gt;,&lt;span&gt;39&lt;/span&gt;,&lt;span&gt;56&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;53&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;,&lt;span&gt;36&lt;/span&gt;,&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;&lt;span&gt;    
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于数据块初始化转换的映射&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesInitial[&lt;span&gt;64&lt;/span&gt;] =&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;58&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;60&lt;/span&gt;,&lt;span&gt;52&lt;/span&gt;,&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;36&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;62&lt;/span&gt;,&lt;span&gt;54&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;64&lt;/span&gt;,&lt;span&gt;56&lt;/span&gt;,&lt;span&gt;48&lt;/span&gt;,&lt;span&gt;40&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;57&lt;/span&gt;,&lt;span&gt;49&lt;/span&gt;,&lt;span&gt;41&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;59&lt;/span&gt;,&lt;span&gt;51&lt;/span&gt;,&lt;span&gt;43&lt;/span&gt;,&lt;span&gt;35&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;61&lt;/span&gt;,&lt;span&gt;53&lt;/span&gt;,&lt;span&gt;45&lt;/span&gt;,&lt;span&gt;37&lt;/span&gt;,&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;63&lt;/span&gt;,&lt;span&gt;55&lt;/span&gt;,&lt;span&gt;47&lt;/span&gt;,&lt;span&gt;39&lt;/span&gt;,&lt;span&gt;31&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于数据块扩展转换的映射&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesExpansion[&lt;span&gt;48&lt;/span&gt;] =&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;18&lt;/span&gt;,&lt;span&gt;19&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;22&lt;/span&gt;,&lt;span&gt;23&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;24&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;26&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;29&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;31&lt;/span&gt;,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于数据块中S盒转换的S盒表&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesSbox[&lt;span&gt;8&lt;/span&gt;][&lt;span&gt;4&lt;/span&gt;][&lt;span&gt;16&lt;/span&gt;] =&lt;span&gt;
{
    {
        {&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;&lt;span&gt;},
    },
    {
        {&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;14&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;13&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;12&lt;/span&gt;,&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;11&lt;/span&gt;&lt;span&gt;},
    }
};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于数据块转换的P盒映射表&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesPbox[&lt;span&gt;32&lt;/span&gt;] =&lt;span&gt;
{

};
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义用于数据块最终转换的映射&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DesFinal[&lt;span&gt;64&lt;/span&gt;] =&lt;span&gt;
{

};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义一个枚举类型，用于选择是加密或是解密数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; DesEorD_ {encipher,decipher} DesEorD;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;permute函数  用于转换、改变位序列&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; permute(unsigned &lt;span&gt;char&lt;/span&gt; *bits, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *mapping, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *temp[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;使用n位映射映射缓冲区&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memset(temp, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)ceil(n/&lt;span&gt;8&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;n; i++&lt;span&gt;)
        bit_set(temp, i, bit_get(bits,mapping[i]&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));

    memcpy(bits, temp, (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;)ceil(n/&lt;span&gt;8&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;des_main函数  加密或解密数据的计算函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; des_main(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *source, unsigned &lt;span&gt;char&lt;/span&gt; *target, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;key, DesEorD direction)
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; subkeys[&lt;span&gt;16&lt;/span&gt;][&lt;span&gt;7&lt;/span&gt;&lt;span&gt;];
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; temp[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;],
                  lkey[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;],
                  rkey[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;],
                  lblk[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;],
                  rblk[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;],
                  fblk[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;],
                  xblk[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;],
                  sblk;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; row,col,i,j,k,p;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果key等于NULL，重用上次调用时计算出来的子密钥，否则计算子密钥&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(key !=&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;创建一个key的副本&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memcpy(temp,key,&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将key转换并压缩至56位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        permute(temp,DesTransform,&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将key分为两个28位的组&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memset(lkey,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
        memset(rkey,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;&lt;span&gt;28&lt;/span&gt;; j++&lt;span&gt;)
            bit_set(lkey, j, bit_get(temp,j));

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;&lt;span&gt;28&lt;/span&gt;; j++&lt;span&gt;)
            bit_set(rkey, j, bit_get(temp,j&lt;/span&gt;+&lt;span&gt;28&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算每一轮的子密钥&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;16&lt;/span&gt;; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;根据定义好的位数对每一块进行旋转&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            bit_rot_left(lkey,&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;,DesRotations[i]);
            bit_rot_left(rkey,&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;,DesRotations[i]);

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;重新合并两个块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;&lt;span&gt;28&lt;/span&gt;; j++&lt;span&gt;)
                bit_set(subkeys[i],j,bit_get(lkey,j));

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;&lt;span&gt;28&lt;/span&gt;; j++&lt;span&gt;)
                bit_set(subkeys[i],j&lt;/span&gt;+&lt;span&gt;28&lt;/span&gt;&lt;span&gt;,bit_get(rkey,j));

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;对子密钥做转换选择并压缩至48位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            permute(subkeys[i],DesPermuted,&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;创建source参数的副本&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(temp, source, &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始转换数据块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    permute(temp, DesInitial, &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将源数据块分为大小为32位的左右两个数据块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(lblk, &lt;/span&gt;&amp;amp;temp[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    memcpy(rblk, &lt;/span&gt;&amp;amp;temp[&lt;span&gt;4&lt;/span&gt;], &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;加密或解密源数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;16&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;开始f缓冲冲的计算&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memcpy(fblk,rblk,&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;置换、扩展右数据块的拷贝，使其达到48位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        permute(fblk, DesExpansion, &lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;根据direction的值来应用适当的子密钥&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(direction ==&lt;span&gt; encipher)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;加密数据，子密钥组以递增的顺序应用&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            bit_xor(fblk, subkeys[i], xblk, &lt;/span&gt;&lt;span&gt;48&lt;/span&gt;&lt;span&gt;);
            memcpy(fblk, xblk, &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;解密数据，子密钥组以递减的顺序应用&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            bit_xor(fblk, subkeys[&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;-i], xblk, &lt;span&gt;48&lt;/span&gt;&lt;span&gt;);
            meycpy(fblk, xblk, &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;执行S盒替换&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        p&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;&lt;span&gt;8&lt;/span&gt;; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算出S盒表中的行号和列号&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            row &lt;/span&gt;= (bit_get(fblk,(j*&lt;span&gt;6&lt;/span&gt;)+&lt;span&gt;0&lt;/span&gt;)*&lt;span&gt;2&lt;/span&gt;) + (bit_get(fblk,(j*&lt;span&gt;6&lt;/span&gt;)+&lt;span&gt;5&lt;/span&gt;)*&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            col &lt;/span&gt;= (bit_get(fblk,(j*&lt;span&gt;6&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;)*&lt;span&gt;8&lt;/span&gt;) + (bit_get(fblk,(j*&lt;span&gt;6&lt;/span&gt;)+&lt;span&gt;2&lt;/span&gt;)*&lt;span&gt;4&lt;/span&gt;) +&lt;span&gt;
                  (bit_get(fblk,(j&lt;/span&gt;*&lt;span&gt;6&lt;/span&gt;)+&lt;span&gt;3&lt;/span&gt;)*&lt;span&gt;2&lt;/span&gt;) + (bit_get(fblk,(j*&lt;span&gt;6&lt;/span&gt;)+&lt;span&gt;4&lt;/span&gt;)*&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为当前的6位数据块做S盒替换&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            sblk &lt;/span&gt;= (unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;)DesSbox[j][row][col];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (k=&lt;span&gt;4&lt;/span&gt;; k&amp;lt;&lt;span&gt;8&lt;/span&gt;; k++&lt;span&gt;)
            {
                bit_set(fblk,p,bit_get(&lt;/span&gt;&amp;amp;&lt;span&gt;sblk,k));
                p&lt;/span&gt;++&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为f缓冲区执行P盒替换&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        permute(fblk, DesPbox, &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;计算左数据块与f缓冲区的异或值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        bit_xor(lblk, fblk, xblk, &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置本轮的左数据块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memcpy(lblk, rblk, &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置本轮的右数据块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        memcpy(rblk, xblk, &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将目标正文设置为重新连接的左右两个数据块&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    memcpy(&lt;/span&gt;&amp;amp;target[&lt;span&gt;0&lt;/span&gt;], rblk, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    memcpy(&lt;/span&gt;&amp;amp;target[&lt;span&gt;4&lt;/span&gt;], lblk, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;执行最终置换&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    permute(target, DesFinal, &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;des_encipher DES加密数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; des_encipher(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *plaintext, unsigned &lt;span&gt;char&lt;/span&gt; *ciphertext, &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;key)
{
    des_main(plaintext, ciphertext, key, encipher);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;des_decipher DES解密数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; des_decipher(&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *ciphertext, unsigned &lt;span&gt;char&lt;/span&gt; *plaintext, &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;key)
{
    des_main(ciphertext, plaintext, key, decipher);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sun, 29 Jul 2018 22:53:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/9333753.html</dc:identifier>
</item>
<item>
<title>依赖注入[4]: 创建一个简易版的DI框架[上篇] - Artech</title>
<link>http://www.cnblogs.com/artech/p/net-core-di-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/net-core-di-04.html</guid>
<description>&lt;p&gt;本系列文章旨在剖析.NET Core的依赖注入框架的实现原理，到目前为止我们通过三篇文章（《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;控制反转&lt;/a&gt;》、《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;基于IoC的设计模式&lt;/a&gt;》和《 &lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入模式&lt;/a&gt;》）从纯理论的角度对依赖注入进行了深入论述，为了让读者朋友能够更好地理解.NET Core的依赖注入框架的设计思想和实现原理，我们创建了一个简易版本的DI框架，也就是我们在前面文章中多次提及的Cat。我们会上下两篇来介绍这个被称为为Cat的DI框架，上篇介绍编程模型，下篇关注设计实现。[源代码从&lt;a href=&quot;https://files.cnblogs.com/files/artech/Cat.7z&quot;&gt;这里&lt;/a&gt;下载]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、DI容器的层次结构与服务实例生命周期&lt;br/&gt;二、服务的注册于提取&lt;br/&gt;三、提供泛型服务&lt;br/&gt;四、多服务实例的提取&lt;br/&gt;五、服务实例的释放回收&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然我们对这个名为Cat的DI框架进行了最大限度的简化，但是与.NET Core的真实DI框架相比，Cat不仅采用了一致的设计，而且几乎具备了后者所有的功能特性。作为DI容器的Cat对象不仅仅是作为服务实例的提供者，它同时还需要维护提供服务实例的&lt;strong&gt;生命周期&lt;/strong&gt;。Cat提供了三种生命周期模式，如果要了解它们之间的差异，就必需对多个Cat之间的层次关系有充分的认识。一个代表DI容器的Cat用以来创建多个新的Cat对象，后者视前者为“&lt;strong&gt;父容器&lt;/strong&gt;”，所以多个Cat对象通过其“&lt;strong&gt;父子关系&lt;/strong&gt;”维系一个树形层次化结构。不过着仅仅是一个&lt;strong&gt;逻辑结构&lt;/strong&gt;而已，实际上每个Cat对象只会按照图1所示的方式引用整棵树的&lt;strong&gt;根&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180730063407380-1484806088.png&quot;&gt;&lt;img width=&quot;492&quot; height=&quot;240&quot; title=&quot;3-7&quot; alt=&quot;3-7&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180730063408344-1927338299.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图1 Cat之间的关系&lt;/p&gt;
&lt;p&gt;在了解了代表DI容器的多个Cat对象之间的关系之后，对于三种预定义的生命周期模式就很好理解了。如下所示的Lifetime枚举代表着三种生命周期模式，其中&lt;strong&gt;Transient&lt;/strong&gt;代表容器针对每次服务请求都会创建一个新的服务实例，它代表一种“即用即取，用完即弃”的消费方式；而&lt;strong&gt;Self&lt;/strong&gt;则是将提供服务实例保存在当前容器中，它代表针对某个容器的单例模式； &lt;strong&gt;Root&lt;/strong&gt;则是将每个容器提供的服务实例统一存放到根容器中，所以该模式能够在多个“同根”容器范围内确保提供的服务是单例的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Lifetime
{
    Root,
    Self,
    Transient
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
代表DI容器的Cat对象为我们提供所需服务实例的前提是相应的服务注册已经在此之前已经添加到容器之中。服务总是针对服务类型（接口、抽象类或者具体类型）来注册的，Cat通过定义的扩展方法提供了如下三种注册方式。除了以指定服务实例的形式外（默认采用Root模式），我们在注册服务的时候必须指定一个具体的生命周期模式。
&lt;ul&gt;&lt;li&gt;指定注册服务的实现类型；&lt;/li&gt;
&lt;li&gt;指定一个现有的服务实例；&lt;/li&gt;
&lt;li&gt;指定一个创建服务实例的工厂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们定义了如下的接口和对应的实现类型来演示针对Cat的服务注册和提取。其中Foo、Bar和Baz分别实现了对应的接口IFoo、IBar和IBaz，为了反映Cat对服务实例生命周期的控制，我们让它们派生于同一个基类Base。Base实现了IDisposable接口，我们在其构造函数和实现的Dispose方法中打印出相应的文字以确定对应的实例何时被创建和释放。我们还定义了一个泛型的接口IFoobar&amp;lt;T1, T2&amp;gt;和对应的实现类Foobar&amp;lt;T1, T2&amp;gt;来演示Cat针对泛型服务实例的提供。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoo {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBar {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IBaz {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IFoobar&amp;lt;T1, T2&amp;gt;&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Base : IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Base() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;An instance of {GetType().Name} is created.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt; Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The instance of {GetType().Name} is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo : Base, IFoo, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar : Base, IBar, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Baz : Base, IBaz, IDisposable { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Foobar&amp;lt;T1, T2&amp;gt;: IFoobar&amp;lt;T1,T2&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IBar Bar { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Foobar(IFoo foo, IBar bar)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Bar &lt;/span&gt;=&lt;span&gt; bar;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在如下所示的代码片段中我们创建了一个Cat对象并采用上面提到的方式针对接口IFoo、IBar和IBaz注册了对应的服务，它们采用的生命周期模式分别为Transient、Self和Root。接下来我们利用Cat对象创建了它的两个子容器，并利用调用后者的GetService&amp;lt;T&amp;gt;方法来提供相应的服务实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
            .Register&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;IBar&amp;gt;(_=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar(), Lifetime.Self) 
            .Register&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;( Lifetime.Root);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat1 =&lt;span&gt; root.CreateChild();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cat2 =&lt;span&gt; root.CreateChild();

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; GetServices&amp;lt;TService&amp;gt;&lt;span&gt;(Cat cat)
        {
            cat.GetService&lt;/span&gt;&amp;lt;TService&amp;gt;&lt;span&gt;();
            cat.GetService&lt;/span&gt;&amp;lt;TService&amp;gt;&lt;span&gt;();
        }

        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(cat1);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(cat1);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(cat1);
        Console.WriteLine();
        GetServices&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;(cat2);
        GetServices&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;(cat2);
        GetServices&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;(cat2);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
上面的程序运行之后会在控制台上输出如图2所示的结果，输出的内容不仅表明Cat能够根据添加的服务注册提供对应类型的服务实例，还体现了它对&lt;strong&gt;生命周期&lt;/strong&gt;的控制。由于IFoo被注册为Transient服务，所以Cat针对该接口类型的四次请求都会创建一个全新的Foo对象。IBar服务的生命周期模式为Self，如果我们利用同一个Cat对象来提供对应的服务实例，该Cat对象只会创建一个Bar对象，所以整个程序执行过程中会创建两个Bar对象。IBaz服务采用Root生命周期，所以具有同根的两个Cat对象提供的总是同一个Baz对象，后者只会被创建一次。
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180730063409222-969755053.png&quot;&gt;&lt;img width=&quot;325&quot; height=&quot;232&quot; title=&quot;3-8&quot; alt=&quot;3-8&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180730063409449-518932761.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图2 Cat按照服务注册对应的生命周期模式提供服务实例&lt;/p&gt;

&lt;p&gt;除了提供类似于IFoo、IBar和IBaz这样非泛型服务实例之外，如果具有对应的泛型定义（Generic Definition）的服务注册，Cat同样也能提供泛型服务实例。如下面的代码片段所示，在为创建的Cat对象添加了针对IFoo和IBar接口的服务注册之后，我们调用Register方法注册了针对泛型定义&lt;strong&gt;IFoobar&amp;lt;,&amp;gt;&lt;/strong&gt;的服务注册，实现的类型为&lt;strong&gt;Foobar&amp;lt;,&amp;gt;&lt;/strong&gt;。当我们利用该Cat对象提供一个类型为IFoobar&amp;lt;IFoo, IBar&amp;gt;的服务实例的时候，它会创建并返回一个&lt;strong&gt;Foobar&amp;lt;Foo, Bar&amp;gt;&lt;/strong&gt;对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;var&lt;/span&gt; cat = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
    .Register&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
    .Register&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;(Lifetime.Transient)
    .Register(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(IFoobar&amp;lt;,&amp;gt;), &lt;span&gt;typeof&lt;/span&gt;(Foobar&amp;lt;,&amp;gt;&lt;span&gt;), Lifetime.Transient);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = (Foobar&amp;lt;IFoo, IBar&amp;gt;)cat.GetService&amp;lt;IFoobar&amp;lt;IFoo, IBar&amp;gt;&amp;gt;&lt;span&gt;();
Debug.Assert(foobar.Foo &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; Foo);
Debug.Assert(foobar.Bar &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; Bar);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当我们在进行服务注册的时候，可以为同一个类型添加多个服务注册。不过由于扩展方法GetService&amp;lt;T&amp;gt;总是返回一个唯一的服务实例，我们对该方法采用了“&lt;strong&gt;后来居上&lt;/strong&gt;”的策略，即总是采用最近添加的服务注册来创建服务实例。如果我们调用另一个扩展方法GetServices&amp;lt;T&amp;gt;，它将利用返回所有服务注册提供的服务实例。&lt;/p&gt;
&lt;p&gt;如下面的代码片段所示，我们为创建的Cat对象添加了三个针对&lt;strong&gt;Base&lt;/strong&gt;类型的服务注册，对应的实现类型分别为Foo、Bar和Baz。我们最后将Base作为泛型参数调用了GetServices&amp;lt;Base&amp;gt;方法，该方法会返回包含三个Base对象的集合，集合元素的类型分别为Foo、Bar和Baz。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;var&lt;/span&gt; services = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
    .Register&lt;/span&gt;&amp;lt;Base, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
    .Register&lt;/span&gt;&amp;lt;Base, Bar&amp;gt;&lt;span&gt;(Lifetime.Transient)
    .Register&lt;/span&gt;&amp;lt;Base, Baz&amp;gt;&lt;span&gt;(Lifetime.Transient)
    .GetServices&lt;/span&gt;&amp;lt;Base&amp;gt;&lt;span&gt;();
Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Foo&amp;gt;&lt;span&gt;().Any());
Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Bar&amp;gt;&lt;span&gt;().Any());
Debug.Assert(services.OfType&lt;/span&gt;&amp;lt;Baz&amp;gt;().Any());&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果提供的服务实例实现了&lt;strong&gt;IDisposable&lt;/strong&gt;接口，我们应该适当的时候调用其Dispose方法释放该服务实例。由于服务实例的生命周期完全由作为DI容器的Cat对象来管理，通过调用Dispose方法来释放服务实例自然也应该由它来负责。Cat针对提供服务实例的释放策略取决于对应的服务注册采用的生命周期模式，具体的策略如下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Transient和Self：&lt;/strong&gt;所有实现了IDisposable接口的服务实例会被作为服务提供者的当前Cat对象保存起来，当Cat对象自身的Dispose方法被调用的时候，这些服务实例的Dispose方法会随之被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Root：&lt;/strong&gt;由于服务实例保存在作为根容器的Cat对象上，所以后者的Dispose方法的调用会触发针对服务实例的释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述的释放策略可以通过如下的演示实例来印证。我们在如下的代码片段中创建了一个Cat对象，并添加了针对IFoo、IBar和IBaz的服务注册。接下来我们调用了CreateChild方法创建代码子容器的Cat对象，并用后者提供了三个注册服务对应的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat()
            .Register&lt;/span&gt;&amp;lt;IFoo, Foo&amp;gt;&lt;span&gt;(Lifetime.Transient)
            .Register&lt;/span&gt;&amp;lt;IBar, Bar&amp;gt;&lt;span&gt;(Lifetime.Self)
            .Register&lt;/span&gt;&amp;lt;IBaz, Baz&amp;gt;&lt;span&gt;(Lifetime.Root))
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cat =&lt;span&gt; root.CreateChild())
            {
                cat.GetService&lt;/span&gt;&amp;lt;IFoo&amp;gt;&lt;span&gt;();
                cat.GetService&lt;/span&gt;&amp;lt;IBar&amp;gt;&lt;span&gt;();
                cat.GetService&lt;/span&gt;&amp;lt;IBaz&amp;gt;&lt;span&gt;();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Child cat is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Root cat is disposed.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
由于两个Cat对象的创建都是在using块中进行的，所有针对它们的Dispose方法都会在using块结束的地方被调用，为了确定方法被调用的时机，我们特意在控制台上打印了相应的文字。该程序运行之后会在控制台上输出如图3所示的结果，我们可以看到当作为子容器的Cat对象的Dispose方法被调用的时候，由它提供的两个生命周期模式分别为Transient和Self的两个服务实例（Foo和Bar）被正常释放了。至于生命周期模式为Root的服务实例Baz，它的Dispose方法会延迟到作为根容器Cat对象被释放的时候。
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180730063411198-1879864085.png&quot;&gt;&lt;img width=&quot;332&quot; height=&quot;232&quot; title=&quot;3-9&quot; alt=&quot;3-9&quot; src=&quot;https://images2018.cnblogs.com/blog/19327/201807/19327-20180730063411434-214460524.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;图3 Root服务实例的释放&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;依赖注入[1]: 控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;依赖注入[2]: 基于IoC的设计模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入[3]: 依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-04.html&quot;&gt;依赖注入[4]: 创建一个简易版的DI框架[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-05.html&quot;&gt;依赖注入[5]: 创建一个简易版的DI框架[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-06.html&quot;&gt;依赖注入[6]: .NET Core DI框架[编程体验]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-07.html&quot;&gt;依赖注入[7]: .NET Core DI框架[服务注册]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-08html&quot;&gt;依赖注入[8]: .NET Core DI框架[服务消费]&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 22:34:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/net-core-di-04.html</dc:identifier>
</item>
<item>
<title>Apollo 7 — ConfigService 消息扫描设计实现 - 莫那-鲁道</title>
<link>http://www.cnblogs.com/stateis0/p/9388598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stateis0/p/9388598.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;设计&lt;/li&gt;
&lt;li&gt;代码实现&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;设计&quot;&gt;1.设计&lt;/h2&gt;
&lt;p&gt;Apollo 为了减少依赖，将本来 MQ 的职责转移到了 Mysql 中。具体表现为 Mysql 中的 ReleaseMessage 表。&lt;/p&gt;
&lt;p&gt;具体官方文档可见：&lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1#211-%E5%8F%91%E9%80%81releasemessage%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&quot;&gt;发送ReleaseMessage的实现方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用张图简单的来表示一下 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-6d2573985f45307c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人肯定要问了，为什么 Admin Service 和 Config Service 不放在一起呢？我曾提过 issue 问过作者，大概的答案是：两者职责不同，部署的实例数也不同，通常 Admin 会少一些，因为只服务于 Portal，而 Config 则要部署的多一些，因为需要服务于 Client。&lt;/p&gt;
&lt;p&gt;第二则是两者的开发节奏也是不一样，Config Service 的更新会影响客户端，而 Admin 的更新则是影响 Portal，所以，分开他们，对服务的部署可以更加细粒度。&lt;/p&gt;
&lt;p&gt;关于这个 issue：&lt;a href=&quot;https://github.com/ctripcorp/apollo/issues/1204&quot;&gt;为什么 admin 和 config 不合在一起呢&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高可用的话，可参考下图或链接 &lt;a href=&quot;https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1#%E5%9B%9B%E5%8F%AF%E7%94%A8%E6%80%A7%E8%80%83%E8%99%91&quot;&gt;可用性考虑&lt;/a&gt;:&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-90043d3f9fdc395b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扯远了。&lt;/p&gt;
&lt;p&gt;回到我们之前说的，之所以要使用 Mysql，是因为要减少依赖，为了替代 MQ，而之所以要使用 MQ，是为了解耦 Config 和 Admin，而之所以要使用 Config 和 Admin，则是因为设计，部署，开发节奏等原因。&lt;/p&gt;
&lt;p&gt;那么，基于 Mysql 的消息的实现是怎么弄的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-c1122096ce2191a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是 apollo 文档对于&lt;code&gt;发送ReleaseMessage的实现方式&lt;/code&gt;的描述。&lt;/p&gt;
&lt;p&gt;我们来看看代码实现.&lt;/p&gt;
&lt;h2 id=&quot;代码实现&quot;&gt;2. 代码实现&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;com.ctrip.framework.apollo.biz.message&lt;/code&gt; 包下，有关于消息的实现，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-da2a33db3c377dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;麻雀虽小，五脏俱全。&lt;/p&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;MessageSender 接口定义了一个方法：&lt;code&gt;void sendMessage(String message, String channel);&lt;/code&gt;&lt;br/&gt;这个 channel 就是 topic 了。 message 就是消息的具体内容了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;目前只有一个实现类 &lt;code&gt;DatabaseMessageSender&lt;/code&gt;， 基于数据库的消息发送。就是把消息保存到 ReleaseMessage 表中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Topics 定义消息主题，目前只有一个：&lt;code&gt;apollo-release&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;ReleaseMessageListener 消息监听器接口，定义了一个方法：&lt;code&gt;void handleMessage(ReleaseMessage message, String channel)&lt;/code&gt;，需要实现此方法并注册到扫描器中，当有新的消息时，便会通知监听器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ReleaseMessageScanner 消息扫描器，用于扫描数据库的 ReleaseMessage 表，如果有新数据，则通知监听器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;目前监听器有以下实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-ef4f3d5f64d33763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从左到右：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ReleaseMessageServiceWithCache，ReleaseMessage 的缓存，用于长轮询判断是否以后新的消息。&lt;/li&gt;
&lt;li&gt;GrayReleaseRulesHolder，灰度规则变化监听器。&lt;/li&gt;
&lt;li&gt;ConfigService，分为缓存和默认，默认的 handleMessage 方法什么都不做，缓存实现则会对 cache 热身。&lt;/li&gt;
&lt;li&gt;NotificationControllerV2 监听器，当客户端被长连接 Hold 住时，消息如果更新则唤醒客户端立即返回，保证及时性。&lt;/li&gt;
&lt;li&gt;NotificationController 已废弃，不谈了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，每当 ReleaseMessageScanner 得到新的消息，都会触发这些监听器。这些监听器在哪里被添加的呢？&lt;/p&gt;
&lt;p&gt;位置:&lt;code&gt;com.ctrip.framework.apollo.configservice.ConfigServiceAutoConfiguration.java&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-75508923db204cb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ReleaseMessageScanner 的 afterPropertiesSet 方法会启动一个间隔 1 秒定时任务，执行 scanMessages 方法。&lt;/p&gt;
&lt;p&gt;具体方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private boolean scanAndSendMessages() {
    //current batch is 500 批处理 500 条
    // 根据 maxIdScanned 找到比这个 id 大的 500 条数据,
    List&amp;lt;ReleaseMessage&amp;gt; releaseMessages =
        releaseMessageRepository.findFirst500ByIdGreaterThanOrderByIdAsc(maxIdScanned);
    if (CollectionUtils.isEmpty(releaseMessages)) {
      return false;
    }
    // 开始通知 handleMessage 监听器
    fireMessageScanned(releaseMessages);
    int messageScanned = releaseMessages.size();// 消息数量
    maxIdScanned = releaseMessages.get(messageScanned - 1).getId();// 更新最大 id
    
    return messageScanned == 500;// 如果不足 500, 说明没有新消息了
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法很简单，首先根据最大的扫描 Id 找到 500 条消息，对这 500 条消息进行批处理，触发监听器。最后更新最大扫描 Id。如果此次取出的数据量超过 500 条，则认为还有数据，就继续处理。&lt;/p&gt;
&lt;p&gt;很明显，每次处理这么多消息肯定很耗时，那么假设处理这些消息要 5 秒，那么定时任务的间隔是多少了呢？答：6 秒。因为定时任务的模式是 scheduleWithFixedDelay 模式，固定的间隔，以当前任务结束时间 + period 时间作为下一个任务的开始时间。&lt;/p&gt;
&lt;p&gt;那么，admin 什么时候会向数据库发送消息（保存 ReleaseMessage）呢?&lt;/p&gt;
&lt;p&gt;那么就要查看 sendMessage 方法被哪些地方调用就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-e29490700794ebc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;NamespaceBranchController&lt;br/&gt;1.1 更新灰度规则 &lt;code&gt;updateBranchGrayRules&lt;/code&gt;&lt;br/&gt;1.2 删除灰度分支 &lt;code&gt;deleteBranch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;NamespaceService&lt;br/&gt;2.1 删除命名空间 &lt;code&gt;NamespaceController#deleteNamespace&lt;/code&gt;&lt;br/&gt;2.2 删除集群 &lt;code&gt;ClusterController#delete&lt;/code&gt;&lt;br/&gt;2.3 删除灰度 &lt;code&gt;NamespaceBranchController#deleteBranch&lt;/code&gt;&lt;br/&gt;2.4 删除命名空间分支&lt;code&gt;NamespaceService#deleteNamespace&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ReleaseController&lt;br/&gt;3.1 主/灰版本发布 &lt;code&gt;publish&lt;/code&gt;&lt;br/&gt;3.2 全量发布 &lt;code&gt;updateAndPublish&lt;/code&gt;&lt;br/&gt;3.3 回滚 &lt;code&gt;rollback&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些地方被触发的时候，都会发送消息到数据库。因此，可能会重复触发，导致 ConfigService 重复消费。。。例如在放弃灰度和全量发布的时候，就会重复发送消息。&lt;/p&gt;
&lt;p&gt;笔者就这个问题提了 issue，期待官方 fix 这个 bug。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;3. 总结&lt;/h2&gt;
&lt;p&gt;本文重点分析了 apollo 关系消息这块的设计： 每当有 app， cluster，namespace， Release 等操作的时候，都会发送消息到数据库，ConfigService 会定时扫描数据库，有新消息了，就会立即通知各个监听器，确保配置实时推送到客户端。&lt;/p&gt;
&lt;p&gt;同时，我们也发现了一个 bug，就是会重复发送消息，引起重复消费。&lt;/p&gt;
&lt;p&gt;迫于种种限制，apollo 使用了这种设计，获取，如果可以使用 MQ 的话，一切会更加的简单。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 22:15:00 +0000</pubDate>
<dc:creator>莫那-鲁道</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stateis0/p/9388598.html</dc:identifier>
</item>
<item>
<title>sharding(1)：谁都能读懂的分库、分表、分区 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9388407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9388407.html</guid>
<description>&lt;p&gt;本文通过大量图片来分析和描述分库、分表以及数据库分区是怎样进行的。&lt;/p&gt;


&lt;p&gt;在本文中，我打算用高考考生相关信息作为实验数据。请无视表的字段是否符合现实，也请无视表的设计是否符合范式。&lt;/p&gt;
&lt;p&gt;3张表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;考生表，存放全国所有高考考生信息，假设34个省、(直辖)市、(自治区、特别行政)区共3000W考生&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;学科表，分文理科，共9门课程(语文、数学、英语、历史、地理、政治、物理、化学、生物)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;成绩表，存过全国所有考生所有学科成绩，每个学生6门成绩，共1.8亿条成绩数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三张表放在名为&quot;gaokao_db&quot;的库中。所以，它们的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729222416861-107454321.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这三张表的大致存储方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729222552029-683288889.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729222625559-931466345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候数据存储方式是&lt;strong&gt;单库多表&lt;/strong&gt;。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;业务分库：按业务将不同表放进不同库。每个库可以放在不同数据库服务器上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，在这里将原始数据库gaokao_db中的3个表分开放进两个数据库中，stu_db存放考生表，score_db存放成绩表。&lt;/p&gt;
&lt;p&gt;还有一张学科表放在哪呢？对于那些很小、无需进行切片的表，可以将多个这样的表共同放在同一个库中，也可以根据联接特性将其分开放置在常与之进行联接的库中。在此处，学科表很小，没必要单独占用一个库甚至数据库服务器，且由于学科表只会和成绩表进行联接，所以将其放在score_db库中。&lt;/p&gt;
&lt;p&gt;业务分库如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729222856533-537666725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;stu_db和score_db可以放在同一数据库服务器上，也可以放在不同数据库服务器上，从而在整体上减轻系统的压力。但是，如果这两个库放在不同服务器上，因为跨数据库实例，将没法对stu_db和score_db中的表进行join操作。&lt;/p&gt;
&lt;p&gt;一般来说，对于可预见的、不断增长的数据，业务分库可能最先进行的sharding。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;垂直切分：将一个表按照字段分成多表，每个表存储一部分字段。表可以放在不同存储设备上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实，在最初设计数据库的时候，因为是关系型数据库，或多或少都会去遵守一些设计范式。&lt;strong&gt;当设计的数据库表满足第一范式、第二范式、第三范式等等范式要求时，其实就已经进行了所谓的垂直切分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;即使按照范式设计了数据库表，但有些表是宽表，有很多可能很少使用的字段，这些字段可能是按照稀疏列进行管理的，也可能是大BLOB后大text字段。此外，表中的字段还可以划分为&quot;热门字段和冷门字段&quot;，例如本文示例中，相比考生号、姓名、所属地区使用频繁程度，考生电话号码可能很少使用、身份证号也很少使用，所以这两个字段是冷门字段。&lt;/p&gt;
&lt;p&gt;所以，当表数据量很大时，即使满足了范式要求，还是可以&lt;strong&gt;强行将表按字段切开，将热门字段、冷门字段分开放置在不同库中&lt;/strong&gt;，这些库可以放在不同的存储设备上，避免IO争抢。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729224441719-914234376.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，垂直切分后的表，要能进行关联，所以在此处的其它信息表中加上了考生号字段。&lt;/p&gt;
&lt;p&gt;垂直切分其实是更深一步的范式设计，或者反范式设计。垂直切分带来的性能提升，主要集中在热门数据的操作效率上，而且磁盘争用情况减少。但如果想要将两个表中的数据再次联合起来，性能将比垂直切分前差的多。&lt;/p&gt;
&lt;p&gt;另外，有很多人将业务分库当作垂直切分，其实这都不重要，重要的是知道各种手段是干嘛的。不过在本文以及我后面的文章，将认为业务分库和垂直切分是不同sharding的分类。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;水平切分：将大表按条件切分到不同表中。每个表存储一部分满足条件的行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;水平切分通常有几种常用的切分方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接按字段条件切分&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;取模后切分&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;按月份、季度、年份切分，或者称之为按范围切分&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;水平切分对性能提升非常大，不仅可以避开服务器资源争用，还减小了索引大小以及每个库维护的表数据量。&lt;/p&gt;

&lt;h2 id=&quot;按字段条件进行切分&quot;&gt;4.1 按字段条件进行切分&lt;/h2&gt;
&lt;p&gt;例如本文的示例中，按照考生所属地区对考生表进行水平切分，这是按照字段条件进行切分。&lt;/p&gt;
&lt;p&gt;如下图，因为有34个省、市、区，所以分成34个考生表，每个考生表都放在地区命名的库中。各库可放在同一数据库服务器，也可以放在不同数据库服务器。例如，某些省市区的考生数量少，可以将多个这样的库放在同一个数据库服务器上，而山东、江西等高考大省，因为考生数量多，可以单独放在同一个数据库服务器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729231255007-92860377.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729230822663-1275357633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意上述&lt;strong&gt;按字段条件进行水平切分时，表名不变，创建新的按地区命名的库，将各地区的表放置在对应的库中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通常，&lt;strong&gt;按照字段条件进行水平却分时，其它表也很有可能也按这个条件进行切分，使得满足条件的表都放在同一个库中，这样能保证正常的join操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如，上面切分了考生表，还可以切分成绩表，让同一个地区的考生表、成绩表放在同一个库中(所以，不能将考生表、成绩表进行业务分库)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729231942144-1912920407.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729232027970-656597844.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样切分后，整个数据的分布情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729232519458-1877159984.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;按范围进行切分&quot;&gt;4.2 按范围进行切分&lt;/h2&gt;
&lt;p&gt;对于上面的成绩表，如果在此之前已经进行了业务分库，就无法让成绩表、考生表同时按照地区进行水平切分。这时可以进行范围切分，最常见的范围切分是按月份、季度、年份进行切分。&lt;/p&gt;
&lt;p&gt;例如，本文示例的成绩表，可以按考生号范围切片，可按考生号取模后切片，也可按学科类别切片。例如，按考生号范围切片，每张表500W考生共3000W条成绩数据，共切成6片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729233024239-2025607680.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729233125287-1080141690.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意按照范围(或者取模、年份、月份、季度等)切片后，数据库的命名。这些库可以放在同一个数据库服务器上，也可以放在不同数据库服务器上。&lt;/p&gt;
&lt;p&gt;如果对成绩表按照范围(或者取模、年份、月份、季度等)切片后，最好对考生表也按照同样的切分方式进行切片。举个反例很容易理解，这里的成绩表按照范围切分了，但是考生表按照地区切分，这两类库的名称之间将失去对应关系，对于数据维护来说可能会增加很大的难度。&lt;/p&gt;
&lt;p&gt;按照这种模式的水平切分后，整个数据的分布情况如下(假设考生表也按范围切片)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180729234620829-1262861877.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;取模切分&quot;&gt;4.3 取模切分&lt;/h2&gt;
&lt;p&gt;取模是对数值或能转换为数值的字段进行取模，要切分成几片，就除几。&lt;/p&gt;
&lt;p&gt;例如，按照取模切分的方式，将本文的考生表切分成6片。于是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;00000001 % 6 = 1   --&amp;gt; 放进stu_1库
00000002 % 6 = 2   --&amp;gt; 放进stu_2库
00000003 % 6 = 3   --&amp;gt; 放进stu_3库
00000004 % 6 = 4   --&amp;gt; 放进stu_4库
00000005 % 6 = 5   --&amp;gt; 放进stu_5库
00000006 % 6 = 0   --&amp;gt; 放进stu_0库
...
00000101 % 6 = 5   --&amp;gt; 放进stu_5库
00000102 % 6 = 0   --&amp;gt; 放进stu_0库
00000103 % 6 = 1   --&amp;gt; 放进stu_1库
00000104 % 6 = 2   --&amp;gt; 放进stu_2库
00000105 % 6 = 3   --&amp;gt; 放进stu_3库
00000106 % 6 = 4   --&amp;gt; 放进stu_4库
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，取模切片后的表名仍然为考生表，这些考生表放在对应的库里，这些库可以单独放在一个数据库服务器上，也可以多个库一起放在同一个数据库服务器上。&lt;/p&gt;


&lt;p&gt;数据库分区：将大表进行分区，不同分区可以放置在不同存储设备上，这些分区在逻辑上组成一个大表，对客户端透明&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分区方式和水平切片是类似的，分区方式也和水平切片方式类似，如范围切片，取模切片等&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;数据库分区是数据库自身的特性，切片则是外部强制手段控制完成的&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;数据库分区无法将分区跨库，更不能跨数据库服务器，但能保存在不同数据文件从而放置在不同存储设备上&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;数据库分区是数据库的特性，数据完整性、一致性等实现起来很方便，这一切都是数据库自身保证的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如，对考生表按照地区进行分区。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180730001921775-831580365.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在数据库切片流行之前，对大表的处理方式就是划分分区表。数据库分区相比于切片，最大的缺点在于无法跨库、跨服务器，所以在某些方面的压力得到不缓解。&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 16:38:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9388407.html</dc:identifier>
</item>
<item>
<title>go语言爬虫 - TapTap用户都喜欢些什么游戏 - 李嘉的博客</title>
<link>http://www.cnblogs.com/lijiajia/p/9388356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/9388356.html</guid>
<description>&lt;h2 id=&quot;前面的废话&quot;&gt;前面的废话&lt;/h2&gt;
&lt;p&gt;说到爬虫，首先想到的当然是python~ 它在机器学习、爬虫数据分析领域可谓是如日中天，十分热门。但我最近在学习go语言，所以就用go写了&lt;/p&gt;
&lt;h2 id=&quot;taptap社区&quot;&gt;TapTap社区&lt;/h2&gt;
&lt;p&gt;这是一个高品质的游戏分享社区，可以说是手机上的steam。上面的用户质量非常高，核心玩家多，看到他们那么用心的写那么多长评论，让我惊叹，所以这次打算拿它来爬取数据练练手，下面先看看成果&lt;/p&gt;
&lt;h2 id=&quot;先看效果这里的玩家都喜欢玩啥类型游戏呀&quot;&gt;先看效果，这里的玩家，都喜欢玩啥类型游戏呀？&lt;/h2&gt;
&lt;p&gt;根据 &lt;strong&gt;下载榜&lt;/strong&gt; 里游戏标签的词频统计出：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-13895deb659c2624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;br/&gt;发现单机、二次元、MOBA、策略等标签比较突出&lt;/p&gt;
&lt;p&gt;让我们加入玩家评分的权重，评分是根据数以万计的玩家打的分数来的，多个游戏相同标签会求平均值。&lt;br/&gt;看看有什么变化？&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-90b24829d0fb3bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;词云完全不一样了呢，视觉错位、脑洞、哲理等标签的评分较高，这些才是玩家真实的喜好，为啥加入评分权重变化这么大呢，让我们看一下究竟是哪些游戏评分这么高！&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-98fe0ccad1eb8365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来是纪念碑谷、猿骑、艾希等游戏。而纪念碑谷（&lt;a class=&quot;uri&quot;&gt;tag:视觉错位）的评分竟然达到了10分&lt;/a&gt;！！（7951条评价）&lt;/p&gt;
&lt;p&gt;不过这款游戏也确实让我服气，连我妈妈、老婆她们不太玩游戏的，都很喜欢这款游戏呢~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-225000ad14cc105b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-7506e5513a91de9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么下面就都把评分权重加进去，看看玩家心里的真实需求&lt;/p&gt;
&lt;h2 id=&quot;接着分析新品榜&quot;&gt;接着分析新品榜&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-e695fd0eb52d5ee3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;游戏名称（根据排名权重+评分权重）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-de858b9595ab528c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看看我们分析出来的跟榜单上的有什么不一样？&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-fd59de4d1382dbec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，加入评分权重后，像《我叫MT4》、《王牌战争：代号英雄》这种&lt;em&gt;&lt;span&gt;虽然排名靠前，但是口碑很差的游戏&lt;/span&gt;&lt;/em&gt;，几乎在我们的分析图上就看不见啦。（所以在taptap上，就算你花钱刷榜上去了，也并没有太多用，玩家的眼睛是雪亮的，哈哈哈）&lt;/p&gt;
&lt;h2 id=&quot;预约榜&quot;&gt;预约榜&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-42408bd734dd5f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;br/&gt;游戏名称（根据排名权重+评分权重）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-fd591cb7d4a414bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里可以看出未来市场的玩家需求，《全职觉醒》、《堡垒之夜》等都是期待比较高的&lt;/p&gt;
&lt;h2 id=&quot;热玩榜&quot;&gt;热玩榜&lt;/h2&gt;
&lt;p&gt;游戏名称（根据排名权重+评分权重）&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-29a18a8c2b2656c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;br/&gt;《绝地求生、刺激战场》也是突出游戏之一，看来taptap的玩家，也是很喜欢吃鸡的&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;实现方式&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;goquery解析html&lt;br/&gt;iconv-go进行编码转换&lt;br/&gt;sego用来中文分词&lt;br/&gt;wordart实现词云效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在先做了个简单的版本，完整版是还想实现抓取某个游戏的玩家评论，进行分词，情感分析的。&lt;/p&gt;
&lt;p&gt;先分析html结构，找到一个游戏信息里包含哪些html元素，然后用goquery解析&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-375a1f9d689167da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用谷歌浏览器，按F12可以很方便的找到元素哦&lt;/p&gt;
&lt;p&gt;然后定义一个结构体，用来存放数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type GameInfo struct {
    Rank     int      //排名
    TapTapID string   //游戏ID
    Name     string   //游戏名
    Company  string   //公司名
    Score    float64  //游戏评分
    IconUrl  string   //图标地址
    Type     string   //游戏类型
    tags     []string //标签
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析单个游戏信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//解析一个游戏信息
func ParseGameInfoCell(selection *goquery.Selection) {
    gameInfo := GameInfo{}
    nameA := selection.Find(&quot;.card-middle-title &quot;)
    gameInfo.TapTapID = nameA.AttrOr(&quot;href&quot;, &quot;&quot;)
    gameInfo.TapTapID = gameInfo.TapTapID[strings.LastIndex(gameInfo.TapTapID, &quot;/&quot;)+1:]
    gameInfo.Name = nameA.Find(&quot;h4&quot;).Text()
    gameInfo.Company = selection.Find(&quot;.card-middle-author&quot;).Find(&quot;a&quot;).Text()
    score, _ := strconv.ParseFloat(selection.Find(&quot;.middle-footer-rating&quot;).Find(&quot;span&quot;).Text(), 64)
    gameInfo.Score = score
    gameInfo.IconUrl = selection.Find(&quot;.card-left-image&quot;).Find(&quot;img&quot;).AttrOr(&quot;src&quot;, &quot;&quot;)
    tempRank, _ := strconv.ParseInt(selection.Find(&quot;.top-card-order-text&quot;).Text(), 10, 32)
    gameInfo.Rank = int(tempRank)

    gameInfo.Type = selection.Find(&quot;.card-middle-footer&quot;).Find(&quot;a&quot;).Text()

    tagsAList := selection.Find(&quot;.card-tags&quot;).Find(&quot;a&quot;)

    tagsAList.Each(func(i int, selectionA *goquery.Selection) {
        gameInfo.tags = append(gameInfo.tags, selectionA.Text())
    })

    GameInfoList = append(GameInfoList, gameInfo)
    //fmt.Printf(&quot;%v\n&quot;, gameInfo)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是很快就遇到了问题，因为排行榜的数据是分页的，我们请求一次只能得到30条数据，于是我们找到了“更多”按钮，发现里面通过ajax异步的请求了一条链接获取数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://www.taptap.com/ajax/top/played?page=2&amp;amp;total=30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;page就代表的页数，根据排行榜总数量150，每页30条可以得出一共有5页。这样我们就可以循环5次去请求所有的数据了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func ReqRankPage(page int) {
    res, err := http.Get(&quot;https://www.taptap.com/ajax/top/&quot; + rankTypeName + &quot;?page=&quot; + strconv.Itoa(page))
    if err != nil {
        log.Fatal(err)
    }
    defer res.Body.Close()
    if res.StatusCode != 200 {
        log.Fatalf(&quot;status code error: %d %s&quot;, res.StatusCode, res.Status)
    }

    jsonBs, err := ioutil.ReadAll(res.Body)
    tPageJson := TPageJson{}
    err = json.Unmarshal(jsonBs, &amp;amp;tPageJson)
    if err != nil {
        fmt.Println(&quot;解析json错误&quot;, err)
    }

    var htmlRead io.Reader = strings.NewReader(tPageJson.Data.Html)
    doc, err := goquery.NewDocumentFromReader(htmlRead)
    if err != nil {
        log.Fatal(err)
    }

    doc.Find(&quot;.taptap-top-card&quot;).Each(func(i int, selection *goquery.Selection) {
        ParseGameInfoCell(selection)
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全部代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;bytes&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;github.com/PuerkitoBio/goquery&quot;
    &quot;io&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
    &quot;math&quot;
)

type TPageJson struct {
    Success bool          `json:&quot;success&quot;`
    Data    TPageDataJson `json:&quot;data&quot;`
}

type TPageDataJson struct {
    Html string `json:&quot;html&quot;`
    Next string `json:&quot;next&quot;`
}

type GameInfo struct {
    Rank     int      //排名
    TapTapID string   //游戏ID
    Name     string   //游戏名
    Company  string   //公司名
    Score    float64  //游戏评分
    IconUrl  string   //图标地址
    Type     string   //游戏类型
    tags     []string //标签
}

var GameInfoList []GameInfo
var rankTypeName = &quot;reserve&quot;

var rankTypes = []string{&quot;download&quot;, &quot;new&quot;, &quot;reserve&quot;, &quot;sell&quot;, &quot;played&quot;}

func main() {

    for _, typeName := range rankTypes {
        GameInfoList = []GameInfo{}

        rankTypeName = typeName
        //每个排行榜有5页数据（根据总数150条，每页30条得出）
        for i := 1; i &amp;lt;= 5; i++ {
            ReqRankPage(i)
        }
        //生成标签词典
        GenerateTags()
        GenerateGameNames()
        fmt.Println(&quot;生成排行榜：&quot;, rankTypeName, &quot;完毕&quot;)
    }
}

func GenerateGameNames() {
    var tagsBuffer bytes.Buffer
    tagsBuffer.WriteString(&quot;word;weight\n&quot;)

    for _, gameInfo := range GameInfoList {
        //weightSize := 150 - gameInfo.Rank //把排名的权值加上
        //weightSize := int(math.Ceil(float64(150-gameInfo.Rank) * gameInfo.Score)) //把排名的权值加上
        weightSize := int(math.Ceil(gameInfo.Score*100)) //把排名的权值加上

        tagsBuffer.WriteString(gameInfo.Name)
        tagsBuffer.WriteString(&quot;;&quot;)
        tagsBuffer.WriteString(strconv.Itoa(weightSize))
        tagsBuffer.WriteString(&quot;\n&quot;)
    }

    WriteFile(rankTypeName+&quot;_names_score.csv&quot;, tagsBuffer.String())
}

func GenerateTags() {
    tagsCountDic := make(map[string]int)
    tagsScoreDic := make(map[string]float64)

    var tagsBuffer bytes.Buffer
    tagsBuffer.WriteString(&quot;word;weight;&quot;)

    for _, gameInfo := range GameInfoList {
        for _, tag := range gameInfo.tags {
            tagsCountDic[tag]++
            tagsScoreDic[tag] += gameInfo.Score*100
        }
    }

    for key, value := range tagsCountDic {
        tagsBuffer.WriteString(key)
        tagsBuffer.WriteString(&quot;;&quot;)
        //tagsBuffer.WriteString(strconv.Itoa( value))
        tagsBuffer.WriteString(strconv.Itoa( int(tagsScoreDic[key]/float64(value))))
        tagsBuffer.WriteString(&quot;\n&quot;)
    }
    WriteFile(rankTypeName+&quot;_tags_score.csv&quot;, tagsBuffer.String())
}

func WriteFile(name, content string) {
    data := []byte(content)
    if ioutil.WriteFile(name, data, 0644) == nil {
        fmt.Println(&quot;写入文件成功:&quot;, name)
    }
}

func ReqRankPage(page int) {
    res, err := http.Get(&quot;https://www.taptap.com/ajax/top/&quot; + rankTypeName + &quot;?page=&quot; + strconv.Itoa(page))
    if err != nil {
        log.Fatal(err)
    }
    defer res.Body.Close()
    if res.StatusCode != 200 {
        log.Fatalf(&quot;status code error: %d %s&quot;, res.StatusCode, res.Status)
    }

    jsonBs, err := ioutil.ReadAll(res.Body)
    tPageJson := TPageJson{}
    err = json.Unmarshal(jsonBs, &amp;amp;tPageJson)
    if err != nil {
        fmt.Println(&quot;解析json错误&quot;, err)
    }

    var htmlRead io.Reader = strings.NewReader(tPageJson.Data.Html)
    doc, err := goquery.NewDocumentFromReader(htmlRead)
    if err != nil {
        log.Fatal(err)
    }

    doc.Find(&quot;.taptap-top-card&quot;).Each(func(i int, selection *goquery.Selection) {
        ParseGameInfoCell(selection)
    })
}

//解析一个游戏信息
func ParseGameInfoCell(selection *goquery.Selection) {
    gameInfo := GameInfo{}
    nameA := selection.Find(&quot;.card-middle-title &quot;)
    gameInfo.TapTapID = nameA.AttrOr(&quot;href&quot;, &quot;&quot;)
    gameInfo.TapTapID = gameInfo.TapTapID[strings.LastIndex(gameInfo.TapTapID, &quot;/&quot;)+1:]
    gameInfo.Name = nameA.Find(&quot;h4&quot;).Text()
    gameInfo.Company = selection.Find(&quot;.card-middle-author&quot;).Find(&quot;a&quot;).Text()
    score, _ := strconv.ParseFloat(selection.Find(&quot;.middle-footer-rating&quot;).Find(&quot;span&quot;).Text(), 64)
    gameInfo.Score = score
    gameInfo.IconUrl = selection.Find(&quot;.card-left-image&quot;).Find(&quot;img&quot;).AttrOr(&quot;src&quot;, &quot;&quot;)
    tempRank, _ := strconv.ParseInt(selection.Find(&quot;.top-card-order-text&quot;).Text(), 10, 32)
    gameInfo.Rank = int(tempRank)

    gameInfo.Type = selection.Find(&quot;.card-middle-footer&quot;).Find(&quot;a&quot;).Text()

    tagsAList := selection.Find(&quot;.card-tags&quot;).Find(&quot;a&quot;)

    tagsAList.Each(func(i int, selectionA *goquery.Selection) {
        gameInfo.tags = append(gameInfo.tags, selectionA.Text())
    })

    GameInfoList = append(GameInfoList, gameInfo)
    //fmt.Printf(&quot;%v\n&quot;, gameInfo)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以把爬取下来的数据，写成文件，生成出一张张的词云进行分析啦&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;第一次玩爬虫，所以写的不是很好，爬虫还有很多技术，本文里都没有涉及。如防止反爬，账号登陆等。写这个也是想多写一点go代码，以后可能会把go作为我的主语言进行开发&lt;/p&gt;
&lt;p&gt;接下来研究下爬取网易云音乐~ 嘿嘿嘿&lt;/p&gt;
</description>
<pubDate>Sun, 29 Jul 2018 16:11:00 +0000</pubDate>
<dc:creator>李嘉的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiajia/p/9388356.html</dc:identifier>
</item>
<item>
<title>IP地址转换函数——inet_pton  inet_ntop inet_aton inet_addr inet_ntoa - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9388009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9388009.html</guid>
<description>&lt;h3 id=&quot;inet_pton&quot;&gt;inet_pton&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAME&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;inet_pton&lt;/strong&gt; - 将 IPv4 和 IPv6 地址从点分十进制转换为二进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;arpa/inet.h&amp;gt;
    int inet_pton(int af, const char *src, void *dst);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&lt;br/&gt;    该函数将字符串&lt;code&gt;src&lt;/code&gt;转换为&lt;code&gt;af&lt;/code&gt;地址类型协议簇的网络地址，并存储到&lt;code&gt;dst&lt;/code&gt;中。对于&lt;code&gt;af&lt;/code&gt;参数，必须为&lt;code&gt;AF_INET&lt;/code&gt;或&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RETURN VALUE&lt;/strong&gt;&lt;br/&gt;    &lt;code&gt;inept_pton&lt;/code&gt;转换成功则返回1,对于指定的地址类型协议簇，如果不是一个有效的网络地址，将转换失败，返回 0,如果指定的地址类型协议簇不合法，将返回-1并，并且&lt;code&gt;errno&lt;/code&gt;设置为&lt;code&gt;EAFNOSUPPORT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTES&lt;/strong&gt;&lt;br/&gt;    不同于&lt;code&gt;inept_aton&lt;/code&gt;和&lt;code&gt;inept——addr&lt;/code&gt;，&lt;code&gt;inept_pton&lt;/code&gt;支持 IPv6 地址。另一方面，&lt;code&gt;inet_pton&lt;/code&gt;仅支持点分十进制表示的 IPv4 地址，而&lt;code&gt;inet_aton&lt;/code&gt;和&lt;code&gt;inept_addr&lt;/code&gt;接受更通用的数字和点表示法（十六进制和八进制数字格式，以及格式不需要显式写入所有四个字节）。&lt;/p&gt;
&lt;h3 id=&quot;inet_ntop&quot;&gt;inet_ntop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAME&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;inet_ntop&lt;/strong&gt; - 将 IPv4 和 IPv6 地址从二进制转换为点分十进制&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;arpa/inet.h&amp;gt;
    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&lt;br/&gt;    该函数将地址类型协议簇为&lt;code&gt;af&lt;/code&gt;的网络地址&lt;code&gt;src&lt;/code&gt;转换为字符串，并将其存储到&lt;code&gt;dst&lt;/code&gt;中，其中&lt;code&gt;dst&lt;/code&gt;不能是空指针。调用者在参数&lt;code&gt;size&lt;/code&gt;中指定可使用的缓冲字节数。&lt;br/&gt;    &lt;code&gt;inet_ntop&lt;/code&gt;拓展自&lt;code&gt;inet_ntoa&lt;/code&gt;来支持多种地址类型协议簇，&lt;code&gt;inet_ntoa&lt;/code&gt;现在已经被弃用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RETURN VALUE&lt;/strong&gt;&lt;br/&gt;    &lt;code&gt;inet_ntop&lt;/code&gt;执行成功，返回一个指向&lt;code&gt;dst&lt;/code&gt;的非空指针，如果执行失败，将返回&lt;code&gt;NULL&lt;/code&gt;，并且&lt;code&gt;errno&lt;/code&gt;设置为相应的错误类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ERRORS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EAFNOSUPPORT&lt;br/&gt;&lt;code&gt;af&lt;/code&gt;并不是一个合法的地址类型协议簇&lt;/li&gt;
&lt;li&gt;ENOSPC&lt;br/&gt;要转换的字符串地址&lt;code&gt;src&lt;/code&gt;其字节大小超过了给定的缓冲字节大小&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;example&quot;&gt;EXAMPLE&lt;/h3&gt;
&lt;p&gt;    以下是关于&lt;code&gt;inet_pton&lt;/code&gt;和&lt;code&gt;inet_ntop&lt;/code&gt;函数使用的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[])
{
   unsigned char buf[sizeof(struct in6_addr)];
   int domain, s;
   char str[INET6_ADDRSTRLEN];

   if (argc != 3) {
       fprintf(stderr, &quot;Usage: %s {i4|i6|&amp;lt;num&amp;gt;} string\n&quot;, argv[0]);
       exit(EXIT_FAILURE);
   }

   domain = (strcmp(argv[1], &quot;i4&quot;) == 0) ? AF_INET :
            (strcmp(argv[1], &quot;i6&quot;) == 0) ? AF_INET6 : atoi(argv[1]);

   s = inet_pton(domain, argv[2], buf);
   if (s &amp;lt;= 0) {
       if (s == 0)
           fprintf(stderr, &quot;Not in presentation format&quot;);
       else
           perror(&quot;inet_pton&quot;);
       exit(EXIT_FAILURE);
   }

   if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {
       perror(&quot;inet_ntop&quot;);
       exit(EXIT_FAILURE);
   }

   printf(&quot;%s\n&quot;, str);

   exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;inet_aton-inet_addr-inet_ntoa&quot;&gt;inet_aton inet_addr inet_ntoa&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NAME&lt;/strong&gt;&lt;br/&gt;    &lt;strong&gt;inet_aton&lt;/strong&gt;, &lt;strong&gt;inet_addr&lt;/strong&gt;, &lt;strong&gt;inet_ntoa&lt;/strong&gt; - 网络地址操作例程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SYNOPSIS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #include &amp;lt;sys/socket.h&amp;gt;
    #include &amp;lt;netinet/in.h&amp;gt;
    #include &amp;lt;arpa/inet.h&amp;gt;
    
    typedef uint32_t in_addr_t;
    struct in_addr{
        in_addr_t s_addr;
    };

    int inet_aton(const char *cp, struct in_addr *inp);
    in_addr_t inet_addr(const char *cp);
    char *inet_ntoa(struct in_addr in);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DESCRIPTION&lt;/strong&gt;&lt;br/&gt;    &lt;code&gt;inet_aton&lt;/code&gt;函数将网络主机地址&lt;code&gt;cp&lt;/code&gt;从 IPv4 的数字点表示形式转换为二进制形式（以网络字节顺序）并且把它保存在&lt;code&gt;inp&lt;/code&gt;指针。如果地址是合法的，那么&lt;code&gt;inet_aton&lt;/code&gt;函数返回非0值，反之返回0值。&lt;code&gt;cp&lt;/code&gt;中提供的地址可以要有以下几种格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;u&gt;a.b.c.d&lt;/u&gt; 四个数字部分中的每一个指定地址的一个字节，字节按从左到右的顺序分配以产生二进制地址。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;a.b.c&lt;/u&gt; a和b指定二进制地址的前两个字节,c被解释为16位值,它定义二进制地址的最右边两个字节。此表示法适用于指定（过时的）B类网络地址。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;a.b&lt;/u&gt; a指定二进制地址的第一个字节,b被解释为24位值,它定义了二进制地址的最右边三个字节。此表示法适用于指定（过时的）A类网络地址。&lt;/li&gt;
&lt;li&gt;a a被解释为32位值,直接存储到二进制地址中而不进行任何字节重新排列。&lt;br/&gt;    在所有上述形式中，虚线标示的地址格式可以用十进制，八进制（带前导0）或十六进制指定（前导0X）。任何这些形式的地址统称为IPV4数字和点符号。使用正好四个十进制数称为 IPv4 点分十进制表示法。&lt;br/&gt;    如果提供的字符串地址被成功转换，&lt;code&gt;inet_aton&lt;/code&gt;函数返回1,如果提供的字符串地址不合法，返回0（此时&lt;code&gt;errno&lt;/code&gt;不会被设置为错误）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;code&gt;inet_addr&lt;/code&gt;函数将网络主机地址&lt;code&gt;cp&lt;/code&gt;从 IPv4 的数字点表示形式转换为以网络字节顺序的二进制形式。如果输入不合法，&lt;code&gt;INADDR_NONE&lt;/code&gt;（通常为-1）被返回。这个函数存在一个问题，因为-1是一个合法的地址（255.255.255.255）。可以使用&lt;code&gt;inet_aton&lt;/code&gt;函数、&lt;code&gt;inet_pton&lt;/code&gt;函数或者&lt;code&gt;getaddrinfo&lt;/code&gt;函数来代替使用它，这些函数提供了一种更清晰的方式来指示错误返回。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;inet_ntoa&lt;/code&gt;函数将网络主机地址&lt;code&gt;in&lt;/code&gt;转换为点分十格式的 IPv4 地址。该字符串在静态分配的缓冲区中返回，后续调用将覆盖该缓冲区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTES&lt;/strong&gt;&lt;br/&gt;    在 x86 架构中，主机字节顺序首先是最低有效字节（小端），而在因特网上使用的网络字节顺序是最高有效字节（大端）。&lt;/p&gt;
&lt;h3 id=&quot;example-1&quot;&gt;EXAMPLE&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main(int argc, char *argv[])
{
   unsigned char buf[sizeof(struct in6_addr)];
   int domain, s;
   char str[INET6_ADDRSTRLEN];

   if (argc != 3) {
       fprintf(stderr, &quot;Usage: %s {i4|i6|&amp;lt;num&amp;gt;} string\n&quot;, argv[0]);
       exit(EXIT_FAILURE);
   }

   domain = (strcmp(argv[1], &quot;i4&quot;) == 0) ? AF_INET :
            (strcmp(argv[1], &quot;i6&quot;) == 0) ? AF_INET6 : atoi(argv[1]);

   s = inet_pton(domain, argv[2], buf);
   if (s &amp;lt;= 0) {
       if (s == 0)
           fprintf(stderr, &quot;Not in presentation format&quot;);
       else
           perror(&quot;inet_pton&quot;);
       exit(EXIT_FAILURE);
   }

   if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {
       perror(&quot;inet_ntop&quot;);
       exit(EXIT_FAILURE);
   }

   printf(&quot;%s\n&quot;, str);

   exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Jul 2018 15:48:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9388009.html</dc:identifier>
</item>
<item>
<title>函数式编程之-模式匹配(Pattern matching) - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9388259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9388259.html</guid>
<description>&lt;p&gt;模式匹配在F#是非常普遍的，用来对某个值进行分支匹配或流程控制。&lt;/p&gt;
&lt;h2 id=&quot;模式匹配的基本用法&quot;&gt;模式匹配的基本用法&lt;/h2&gt;
&lt;p&gt;模式匹配通过match...with表达式来完成，一个完整的模式表达式长下面的样子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;match [something] with 
| pattern1 -&amp;gt; expression1
| pattern2 -&amp;gt; expression2
| pattern3 -&amp;gt; expression3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你第一次使用模式匹配，你可以认为他就是命令式语言中的switch...case或者说是if...else if...else。只不过模式匹配的能力要比switch...case强大的多。&lt;br/&gt;考虑下面的例子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 
    match 1 with 
    | 1 -&amp;gt; &quot;a&quot;
    | 2 -&amp;gt; &quot;b&quot;  
    | _ -&amp;gt; &quot;z&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，x此时的值是&quot;a&quot;，因为第一个匹配分支就匹配正确了。在这个表达式里第三个匹配分支有点特殊:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;| _ -&amp;gt; &quot;z&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通配符&lt;code&gt;_&lt;/code&gt;在这里起到了default的作用，上面的所有分支如果都匹配失败，则最终会匹配的这个分支。&lt;br/&gt;&lt;strong&gt;1.分支是有顺序的&lt;/strong&gt;&lt;br/&gt;但是这三个分支的顺序是可以随便改的，也就意味着我们可以把通配符分支放到第一个位置：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt; let x = 
    match 1 with 
    | _ -&amp;gt; &quot;z&quot; 
    | 1 -&amp;gt; &quot;a&quot;
    | 2 -&amp;gt; &quot;b&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，第一个匹配分支会胜出，同时编译器也会给出一个警告:其他的分支从来都不会被用到。&lt;br/&gt;这说明在模式匹配中，分支的顺序是非常重要的，应该把更加具体的匹配分支放在前面，包含通配符的分支应该放在最后面。&lt;br/&gt;&lt;strong&gt;2.模式匹配是一个表达式&lt;/strong&gt;&lt;br/&gt;模式匹配是一个表达式，所有的分支都应该返回同样的类型，考虑下面的例子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 
    match 1 with 
    | 1 -&amp;gt; 42
    | 2 -&amp;gt; true  // error wrong type
    | _ -&amp;gt; &quot;hello&quot; // error wrong type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同的分支应该返回想通类型的值。&lt;br/&gt;&lt;strong&gt;3.至少有一个分支能被匹配到&lt;/strong&gt;&lt;br/&gt;考虑下面的例子:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let x = 
    match 42 with 
    | 1 -&amp;gt; &quot;a&quot;
    | 2 -&amp;gt; &quot;b&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于两个分支都没有匹配到，编译器将会给出警告，你至少要写一个能够匹配到的分支，例如为其添加通配符分支。&lt;br/&gt;你可以通过添加通配符分支让编译器不在发出警告，但是在实际实践中，你应该尽可能的添加可能存在的分支，例如你在对一个&lt;code&gt;选择类型&lt;/code&gt;做模式匹配：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;type Choices = A | B | C
let x = 
    match A with 
    | A -&amp;gt; &quot;a&quot;
    | B -&amp;gt; &quot;b&quot;
    | C -&amp;gt; &quot;c&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果后来某一天你在Choices类型里添加了一个新的选项&lt;code&gt;D&lt;/code&gt;，编译器就会对之前的对Choices的模式匹配发出警告，提示你添加新的分支。试想如果你之前加了通配符,编译器就会吞掉这个警告，进而产生bug。&lt;/p&gt;
&lt;h2 id=&quot;匹配元组tuple&quot;&gt;匹配元组(Tuple)&lt;/h2&gt;
&lt;p&gt;模式匹配几乎可以匹配F#所有的类型，例如元组:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let y = 
    match (1,0) with 
    | (1,x) -&amp;gt; printfn &quot;x=%A&quot; x
    | (_,x) -&amp;gt; printfn &quot;other x=%A&quot; x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然第一个分支会被匹配到。&lt;br/&gt;你可以把多个模式写在同一个分支上，当多个模式是&lt;code&gt;或&lt;/code&gt;的关系时用&lt;code&gt;|&lt;/code&gt;隔开：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;type Choices = A | B | C | D
let x = 
    match A with 
    | A | B | C -&amp;gt; &quot;a or b or c&quot;
    | D -&amp;gt; &quot;d&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当多个模式是&lt;code&gt;与&lt;/code&gt;的关系时用&lt;code&gt;&amp;amp;&lt;/code&gt;隔开:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let y = 
    match (1,0) with 
    | (2,x) &amp;amp; (_,1) -&amp;gt; printfn &quot;x=%A&quot; x &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;匹配list&quot;&gt;匹配list&lt;/h2&gt;
&lt;p&gt;匹配list只有三种模式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[x;y;z]用来显示匹配list中的元素&lt;/li&gt;
&lt;li&gt;head::tail head会匹配到第一个元素，其他的元素会匹配到tail，这个模式常用来对list做递归&lt;/li&gt;
&lt;li&gt;[] 会匹配到空的list&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let rec loopAndPrint aList = 
    match aList with 
    | [] -&amp;gt; 
        printfn &quot;empty&quot; 
    | x::xs -&amp;gt; 
        printfn &quot;element=%A,&quot; x
        loopAndPrint xs 

loopAndPrint [1..5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当[]模式被匹配到，说明list已经为空，可以作为递归的终止条件；&lt;br/&gt;x::xs模式会将第一个元素匹配到x中，剩余的元素被匹配到xs，然后xs又被当做参数做下一次递归&lt;/p&gt;
&lt;h2 id=&quot;匹配recoard-type和descriminated-union-type...&quot;&gt;匹配Recoard type和Descriminated Union type...&lt;/h2&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;//record type
type Person = {First:string; Last:string}
let person = {First=&quot;john&quot;; Last=&quot;doe&quot;}
match person with 
| {First=&quot;john&quot;}  -&amp;gt; printfn &quot;Matched John&quot; 
| _  -&amp;gt; printfn &quot;Not John&quot; 

//union type
type IntOrBool= I of int | B of bool
let intOrBool = I 42
match intOrBool with 
| I i  -&amp;gt; printfn &quot;Int=%i&quot; i
| B b  -&amp;gt; printfn &quot;Bool=%b&quot; b&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.as关键字&lt;/strong&gt;&lt;br/&gt;你可以把模式用as关键字指向另一个名称：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let y = 
    match (1,0) with 
    | (x,y) as t -&amp;gt; 
        printfn &quot;x=%A and y=%A&quot; x y
        printfn &quot;The whole tuple is %A&quot; t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.匹配子类&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;:?&lt;/code&gt;用来匹配类型，例如第一个分支用来匹配int类型:&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let detectType v =
    match box v with
        | :? int -&amp;gt; printfn &quot;this is an int&quot;
        | _ -&amp;gt; printfn &quot;something else&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匹配类型并不是一种好的实践，正如你在OO语言里编写if type ==...一样。&lt;br/&gt;&lt;strong&gt;when条件&lt;/strong&gt;&lt;br/&gt;有时候你需要对匹配完成的值做一些条件判断：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let elementsAreEqual aTuple = 
    match aTuple with 
    | (x,y) -&amp;gt; 
        if (x=y) then printfn &quot;both parts are the same&quot; 
        else printfn &quot;both parts are different&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况可以通过在模式中添加&lt;code&gt;when&lt;/code&gt;条件来做到：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let elementsAreEqual aTuple = 
    match aTuple with 
    | (x,y) when x=y -&amp;gt; 
        printfn &quot;both parts are the same&quot; 
    | _ -&amp;gt;
        printfn &quot;both parts are different&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;active-pattern&quot;&gt;Active pattern&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;when&lt;/code&gt;语句尽管可以给模式添加一些条件，但是当语句过于复杂的时候可以考虑某个分支的模式定义为一个方法：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;open System.Text.RegularExpressions

// create an active pattern to match an email address
let (|EmailAddress|_|) input =
   let m = Regex.Match(input,@&quot;.+@.+&quot;) 
   if (m.Success) then Some input else None  

// use the active pattern in the match  
let classifyString aString = 
    match aString with 
    | EmailAddress x -&amp;gt; 
        printfn &quot;%s is an email&quot; x
        
    // otherwise leave alone
    | _ -&amp;gt; 
        printfn &quot;%s is something else&quot; aString

//test
classifyString &quot;alice@example.com&quot;
classifyString &quot;google.com&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 29 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9388259.html</dc:identifier>
</item>
<item>
<title>Python全栈工程师（Python3 所有基础内容都在这了  0-0） - ParisGabriel</title>
<link>http://www.cnblogs.com/ParisGabriel/p/9388030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ParisGabriel/p/9388030.html</guid>
<description>&lt;div align=&quot;left&quot;&gt;
&lt;p&gt;&lt;span&gt;ParisGabriel&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;         每天坚持手写  一天一篇  决定坚持几年 为了梦想为了信仰&lt;/p&gt;

&lt;div align=&quot;left&quot;&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1430617/201807/1430617-20180709225751471-608583048.png&quot; alt=&quot;&quot;/&gt; 开局一张图&lt;/div&gt;


&lt;p&gt;&lt;span&gt;Python一个月的基础语法 基本就到这咯&lt;/span&gt;    接下来是数据库了&lt;/p&gt;
&lt;p&gt;东西太多了  简单的整理一下&lt;/p&gt;
&lt;p&gt;大多数是关键字 部分单词  没有分类整理  按照顺序整理的&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;statements&lt;/span&gt; 　　　　　　　　语句&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;print&lt;/span&gt; 　　　　　　　　　 　 输出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;quit()&lt;/span&gt; 　　　　　　　　　　 退出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exit()&lt;/span&gt; 　　　　　　　　　　 退出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ctrl + d　&lt;/span&gt;　　　　　　　 　  (输入文件结束符)结束输入并退出&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;int&lt;/span&gt; 　　　　　　　　　　 　 整型数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;float&lt;/span&gt; 　　　　　　　　　 　  浮点型数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;complex&lt;/span&gt; 　　　　　　　   　 复数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bool&lt;/span&gt; 　　　　　　　　  　　 布尔&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;True&lt;/span&gt; 　　　　　　　　 　  　 真&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;False&lt;/span&gt; 　　　　　　　　　      假&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;str&lt;/span&gt; 　　　　　　　　　  　   字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;list　　　　　　　　　　　 &lt;/span&gt; 列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;None&lt;/span&gt; 　　　　　　　　　    空值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;expression&lt;/span&gt; 　　　　　　　  表达式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;del&lt;/span&gt; 　　　　　　　　　　     删除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;help（）&lt;/span&gt; 　　　　　　　　   帮助&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;is&lt;/span&gt; 　　　　　　 　　　　　　 是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;not is&lt;/span&gt; 　　　　　　　　　　 不是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;id( )　　　　&lt;/span&gt; 　　　　　        查询内存地址&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-5~256&lt;/span&gt;                                   小整数池&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;refrence count&lt;/span&gt; 　　　　　     引用计数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;abs&lt;/span&gt; 　　　　　　　　　　      取绝对值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;round&lt;/span&gt; 　　　　　　　　 　    vc 四舍五入&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pow&lt;/span&gt; 　　　　　　　　　    　 幂运算&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;input   　　　　　　　　　　&lt;/span&gt; 输入  &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sep&lt;/span&gt; 　　　　　　　　      　    两值之间分隔符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;end&lt;/span&gt; 　　　　　　　　　　　   结束（内容）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;if&lt;/span&gt; 　　　　　　　　　　　　   如果&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;elif&lt;/span&gt; 　　　　　　　　　　　　 否则如果&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;else&lt;/span&gt; 　　　　　　　　　　　   否则&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pass&lt;/span&gt; 　　　　　　　　　　　 过&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;not&lt;/span&gt; 　　　　　　　　　　　　 布尔 非&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;and&lt;/span&gt; 　　　　　　　　　　　   布尔 与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;or&lt;/span&gt; 　　　　　　　　　　　　 布尔 或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;man ascii&lt;/span&gt; 　　　　　　　　   终端查询命令&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ascii&lt;/span&gt; 　　　　　　　　　　　  编码表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Unicode&lt;/span&gt; 　　　　　　　　      统一编码表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Unicode16&lt;/span&gt; 　　　　　　　 　 16位&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Unicode32&lt;/span&gt; 　　　　　　　　   32位&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;len(x)&lt;/span&gt; 　　　　　　　　　　　  返回个数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;raw&lt;/span&gt; 　　　　　　　　　　　　 原始字符串（r&quot;hello&quot;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;in&lt;/span&gt; 　　　　　　　　　　 　　　 是否出现过&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;not in&lt;/span&gt; 　　　　　　　　　　     没有出现&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;index&lt;/span&gt; 　　　　　　　　　　　 索引（[ ]）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;slice&lt;/span&gt; 　　　　　　　　　　　　 切片（[ : : ]）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bin( )&lt;/span&gt; 　　　　　　　　　　　    整数转二进制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;oct( )&lt;/span&gt; 　　　　　　　　　　　    整数转八进制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;hex( )&lt;/span&gt; 　　　　　　　　　　　   整数转十六进制&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;max( )&lt;/span&gt; 　　　　　　　　　　     求最大值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;min( )&lt;/span&gt; 　　　　　　　　　　     最小值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ord( )&lt;/span&gt; 　　　　　　　　　　       字符对应（转）数字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;chr( )&lt;/span&gt; 　　　　　　　　  　　    数字对应（转）字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;while&lt;/span&gt; 　　　　　　　　　　　  循环&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;for&lt;/span&gt; 　　　　　　　　　　　　   循环（遍历）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;break&lt;/span&gt; 　　　　　　　　　　　  跳出循环&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;list&lt;/span&gt; 　　　　　　　　　　　　   列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;tuple&lt;/span&gt; 　　　　　　　　　　　　 元组&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;dict&lt;/span&gt; 　　　　　　　　　　　　  字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;range&lt;/span&gt; 　　　　　　　　　　　   整数序列生成器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;step&lt;/span&gt; 　　　　　　　　　　　　   步长&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;continue&lt;/span&gt; 　　　　　　　　　　   跳过循环&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;iterable&lt;/span&gt; 　　　　　　　　　　    可迭代对象&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sum( )&lt;/span&gt; 　　　　　　　　　　  　 求和&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;any( )&lt;/span&gt; 　　　　　　　　　　  　 一个为真则为真&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;all( )&lt;/span&gt; 　　　　　　　　　　　　 所有真为真&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;s.split(sep)&lt;/span&gt; 　　　　　　　　   sep：分隔符（分隔字符串返回列表）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;'#'.join( )&lt;/span&gt; 　　　　　　　　　　 [1, 2, 3] 返回 “1#2#3”&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;copy（shallow copy）&lt;/span&gt; 　　　　 潜拷贝&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;deepcopy&lt;/span&gt; 　　　　　　　　        深拷贝&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;reversed&lt;/span&gt; 　　　　　　　　         顺序翻转&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sorted（）&lt;/span&gt; 　　　　　　　　      排序序列&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;key&lt;/span&gt; 　　　　　　　　　　　　    键&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;value&lt;/span&gt; 　　　　　　　　　　　　 值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;set　　　　　　　　　　　　　&lt;/span&gt; 集合&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;frozenset&lt;/span&gt; 　　　　　　　　        固定集合&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;byte&lt;/span&gt; 　　　　　　　                    字节（0~255）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bytes（）&lt;/span&gt; 　　　　　　　　        字节串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;bytearray（）&lt;/span&gt; 　　　　　　　　 字节数组&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;def（function）&lt;/span&gt; 　　　　　　　 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;return&lt;/span&gt; 　　　　　　　　　　　  返回&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;args&lt;/span&gt; 　　　　　　　　　　　　 参数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;args=None&lt;/span&gt; 　　　　　　　　     缺省参数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;*args&lt;/span&gt; 　　　　　　　　　　　  元组传参&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;**kwargs&lt;/span&gt; 　　　　　　　　　　 字典传参&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;local variable&lt;/span&gt; 　　　　　　　　 局部变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;global variable&lt;/span&gt; 　　　　　　    全局变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;globals( )&lt;/span&gt; 　　　　　　　　　　 返回全局变量字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;locals( )&lt;/span&gt; 　　　　　　　　　　 返回局部变量字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Local(function) 　&lt;/span&gt;　 　　　　　     L 　　　　　　　　  局部（作用域）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Enclosing function locals 　　&lt;/span&gt;      E 　　　　　　　　  外部嵌套&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Global(module)&lt;/span&gt; 　　　　　　　　  G 　　　　　　　　 全局（模块）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Builtin(Python) 　&lt;/span&gt;　　　　　　   　B 　　　　　　　　 内建&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;global&lt;/span&gt; 　　　　　　　　　　    声明全局变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;nonlocal&lt;/span&gt; 　　　　　　　　      声明外部嵌套&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;lambda&lt;/span&gt; 　　　　　　　　　　 匿名函数（表达式）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;eval( )&lt;/span&gt; 　　　　　　　　　　   字符串当表达式执行&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exec( )&lt;/span&gt; 　　　　　　　　　　  字符串当程序执行&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;High Order Function 　　　　&lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;高阶函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;map（）&lt;/span&gt; 　　　　　　　　 　（函数， iterable）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;filter（）&lt;/span&gt; 　　　　 　　　 　 （函数， iterable）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sorted（）　　　　　　　 　&lt;/span&gt; (iterable, key=函数, reverse=False)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;recursion&lt;/span&gt; 　　　　　　　 　  递归&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;closure&lt;/span&gt; 　　　　　　　　   　 闭包&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Module&lt;/span&gt; 　　　　　　　　　   模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;builtins&lt;/span&gt; 　　　　　　　　 　  内建模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;import Module&lt;/span&gt; 　　　　　　 导入模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;from Module import *&lt;/span&gt; 　　    导入&lt;/strong&gt;模块内属性&lt;br/&gt;&lt;strong&gt;&lt;span&gt;dir（）&lt;/span&gt; 　　　　　　　　        返回所有属性列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;math&lt;/span&gt; 　　　　　　　　　　    数学模块（内建）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;time&lt;/span&gt; 　　　　　　　　　　　  时间模块 (内建）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;random&lt;/span&gt; 　　　　　　　　　　 随机模块&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sys 系统&lt;/span&gt;　　　　　　　　　　模块（内建）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;@ Function&lt;/span&gt; 　　　　　　        装饰器函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;pip3 installtensorflow&lt;/span&gt; 　　　  模块安装&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;sys.path&lt;/span&gt; 　　　　　　　　       路径列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__doc__ 　　　　　　　　     &lt;/span&gt; 文档字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__file__&lt;/span&gt; 　　　　　　　　　　 路径名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__name__&lt;/span&gt; 　　　　　　　　   模块自身名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__all__ 　　　　　　　　   　&lt;/span&gt; 可导出属的列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;package 　　　　　　　　    &lt;/span&gt; 包&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;_name&lt;/span&gt; 　　　　　　    　　     隐藏属性name&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__init__.py&lt;/span&gt; 　　　　　　　　   声明包文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;try-except&lt;/span&gt; 　　　　　　　　    接受处理异常&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;try-finally&lt;/span&gt; 　　　　　　　　    执行必要语句&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;try&lt;/span&gt; 　　　　　　　　　　 　　 异常&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;as&lt;/span&gt; 　　　　　　　　　　　　  改名&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;except&lt;/span&gt; 　　　　　　　　　　   截取异常类型&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;else&lt;/span&gt; 　　　　　　　　　　　　 正常结束&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;finally&lt;/span&gt; 　　　　　　　　　　   强制执行&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;raise&lt;/span&gt; 　　　　　　　　　　　 发送错误&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;assert&lt;/span&gt; 　　　　　　　　　　  限制条件发送错&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Iterator&lt;/span&gt; 　　　　　　　　        迭代器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;iter（）&lt;/span&gt; 　　　　　　　　　　 可迭代对象生成迭代器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;next（）&lt;/span&gt; 　　　　　　　　　   迭代器内顺序取值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Generator&lt;/span&gt; 　　　　　　　　 生成器&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;yield&lt;/span&gt; 　　　　　　　　　　   函数内表达式（生成器函数）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;(x for x in range() if )　　　　&lt;/span&gt;生成器表达式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;zip( )&lt;/span&gt; 　　　　　　　　　 　  两个或以上可迭代生成元组&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;enumerate( )&lt;/span&gt; 　　　　　　　  生成带索引对象 可定义开始下标&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;File&lt;/span&gt; 　　　　　　　　　　     文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;open（）&lt;/span&gt; 　　　　　　　　    打开文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;File.close( )&lt;/span&gt; 　　　　　　　　 关闭文件&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;gb2312&lt;/span&gt; 　　　　　　　　　　 6763汉字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;gbk&lt;/span&gt; 　　　　　　　　　　     国标21003汉字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;gb18030&lt;/span&gt; 　　　　　　　　    27533汉字&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;UTF-8&lt;/span&gt; 　　　　　　　　　　 Unicode&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;ASCII&lt;/span&gt; 　　　　　　　　　　 256字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Ojbect-Oriented Programing&lt;/span&gt; 面向对象&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　封装&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　多态&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　继承&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　多继承 &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;class&lt;/span&gt; 　　　　　　　　　　      类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;method&lt;/span&gt; 　　　　　　　　　　  实例&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;attribute&lt;/span&gt; 　　　　　　　　　　 实例属性（变量）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__init__（）&lt;/span&gt; 　　　　　　　　  初始化方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__del__（）&lt;/span&gt; 　　　　　　　　   析构方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__dict__&lt;/span&gt; 　　　　　　　　　　  自身变量的字典&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__class__&lt;/span&gt; 　　　　　　　　      实例的类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;type(obj)&lt;/span&gt; 　　　　　　　　　　 返回类型&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;isinstance（）&lt;/span&gt; 　　　　　　　  判断是否为某个类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;self&lt;/span&gt; 　　　　　　　　　　　 　 类方法必有的参数（自己）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;object&lt;/span&gt; 　　　　　　　　　　    对象（类）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;instance&lt;/span&gt; 　　　　　　　　　　 实例&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;@classmethod&lt;/span&gt; 　　　　　　　 装饰为类的方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;@staticmethod&lt;/span&gt; 　　　　　　　 静态方法（类内普通函数）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;inheritance 　　　　　　　　    &lt;/span&gt; 继承（单继承）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;multiple inheritance　&lt;/span&gt;　　　　  多继承&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;derived 　　　　　　　　　　　&lt;/span&gt; 派生&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;base class&lt;/span&gt; 　　　　　　　　　　 基类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;super class&lt;/span&gt; 　　　　　　　 　    超类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;father class&lt;/span&gt; 　　　　　　　 　    父类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;derived class&lt;/span&gt; 　　　　　　         派生类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;child class&lt;/span&gt; 　　　　　　　　　　 子类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;override&lt;/span&gt; 　　　　　　　　　　 覆盖&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;super（）&lt;/span&gt; 　　　　　　　　       调用父类覆盖方法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;enclosure&lt;/span&gt; 　　　　　　　　      封装&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__name&lt;/span&gt; 　　　　　　　　　　  私有属性name&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;polymorphic&lt;/span&gt; 　　　　　　　　 多态（静态/动态）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__mro__&lt;/span&gt; 　　　　　　　　　　 类的方法查找顺序列表&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;repr(obj)&lt;/span&gt; 　　　　　　　　　　 返回表达式字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;str(obj)&lt;/span&gt; 　　　　　　　　　　 返回字符串&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;内建函数重写&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;__repr__ 　　　　　　　　　　对象装字符串（&lt;span&gt;表达式字符串&lt;/span&gt;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__str__ 　　　　　　　　　　  函数重写（&lt;span&gt;字符串&lt;/span&gt;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__abs__ 　　　　　　　　　　 &lt;span&gt;绝对值&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__len__ 　　　　　　　　　　&lt;span&gt; 序列长度  &lt;/span&gt; &lt;span&gt;必须&lt;/span&gt;返回&lt;span&gt;整数&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__reversed__ 　　　　　　      &lt;span&gt;排序&lt;/span&gt; &lt;span&gt;必须&lt;/span&gt;返回&lt;span&gt;可迭代对象&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__round__ 　　　　　　           &lt;span&gt;四舍五入&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;数值转换函数重写&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;__complex__ 　　　　　　    &lt;span&gt;复数&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__int__ 　　　　　　　　       &lt;span&gt;整数&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__float__　　　　　　            &lt;span&gt;浮点数&lt;/span&gt; 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__bool__ 　　　　　　　　    &lt;span&gt;布尔&lt;/span&gt; 函数（&lt;span&gt;特殊&lt;/span&gt;）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__next__ 　　　　　　　　    &lt;span&gt;迭代器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;getattr&lt;/span&gt;（obj, &quot;name&quot;[default]） 　　　　　　 返回name 属性 （name为字符串）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;hasattr&lt;/span&gt;（obj, &quot;name&quot;） 　　　　　　　　　   判断有没有name属性&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;setattr&lt;/span&gt;（obj, &quot;name&quot;, value） 　　　　　　    name赋值为value&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;delattr&lt;/span&gt;（obj, &quot;name&quot;） 　　　　　　　　        删除name属性&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;with&lt;/span&gt; 　　　　　　　　　　     异常发时自动管理 环境管理器 &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__enter__&lt;/span&gt; 　　　　　　　　 with开始自动调用&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;__exit__&lt;/span&gt; 　　　　　　　　    with调用 判断是否异常&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__exit__(self, exc_type, exc_val, exc_tb)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exc_type&lt;/span&gt; 　　　　　　　　  错误类型&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exc_val&lt;/span&gt;　　　　　　　　     错误值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;exc_tb&lt;/span&gt; 　　　　　　　　      追踪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法名　　　　　　　　　　　　　 运算符和表达式 　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__add__(self, rhs)　　　　　　　　  self + rhs 　　　　　    加法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__sub__(self, rhs) 　　　　　 　　    self - rhs 　　　　　　 减法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__mul__(self, rhs) 　　　　　　　    self * rhs 　　　　　　  乘法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__truediv__(self, rhs) 　　　　　 　 self / rhs 　　　　　　  除法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__floordiv__(self, rhs) 　　　　　　 self // rhs 　　　　　　 地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__mod__(self, rhs) 　　　　　　       self % rhs 　　　　       取模(求余)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__pow__(self, rhs) 　　　　　　      self ** rhs 　　　　　　  幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rhs(right hand side) &lt;span&gt;右手边&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反向算术运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　　　　 运算符和表达式 　　　   说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__radd__(self, lhs)　　　　　　　  　 lhs + self 　　　　　　 加法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rsub__(self, lhs)　　　　　　　  　 lhs - self 　　　　　　  减法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rmul__(self, lhs) 　　　　　　　 　 lhs * self 　　　　　　  乘法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rtruediv__(self,　　　　　　　　 　lhs) lhs / self 　　　 　  除法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rfloordiv__(self, lhs)　　　　　  　 lhs // self 　　　　　　  地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rmod__(self, lhs) 　　　　　　　　 lhs % self 　　　　　　取模(求余)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rpow__(self, lhs) 　　　　　　　　 lhs ** self 　　　　　　 幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lhs(left hand side) &lt;span&gt;右手边&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;复合赋值算术运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　　　 运算符和表达式 　　　  　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__iadd__(self, lhs) 　　　　　　 　　 lhs += self 　　　　　　 加法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__isub__(self, lhs) 　　　　　　　 　 lhs -= self 　　　　　 　 减法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__imul__(self, lhs)　　　　　　　 　  lhs *= self 　　　　　　  乘法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__itruediv__(self, lhs)　　　　　　    lhs /= self 　　　　         除法&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ifloordiv__(self, lhs) 　　　　 　　 lhs //= self 　　  　　      地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__imod__(self, lhs) 　　　　　　  　  lhs %= self 　　　　　  取模(求余)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ipow__(self, lhs)　　　　　　　　 lhs **= self 　　　　　　 幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;优先调用x.__iadd__(y)没有时  (id 不变)&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;调用x = x.__add__(y)再不没有&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;TypeError异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复合赋值算术运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　　 运算符和表达式 　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__lt__(self, rhs) 　　　　　　　　    self &amp;lt; rhs 　　　　　　   小于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__le__(self, rhs) 　　　　　　　  　 self &amp;lt;= rhs 　　　　　　 小于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__gt__(self, rhs) 　　　　　　　 　 self &amp;gt; rhs 　　　　　　　大于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ge__(self, rhs) 　　　　　　　　 self &amp;gt;= rhs 　　　　　　  大于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__eq__(self, rhs) 　　　　　　　　 self == rhs 　　　　　　  等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ne__(self, rhs) 　　　　　　　　 self != rhs 　　　　　　   不等于&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;位运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　 运算符和表达式 　　　　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__invert__(self)　　　　　　　　 ~ self 　　　　　　　　       取反(一元运算符)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__and__(self, rhs) 　　　　　 　  self &amp;amp; rhs 　　　　　　　    位与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__or__(self, rhs) 　　　　　　      self | rhs 　　　　　　　　  位或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__xor__(self, rhs) 　　　　　   　 self ^ rhs 　　　　　　　　位异或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__lshift__(self, rhs) 　　　　　　 self &amp;lt;&amp;lt; rhs 　　　　　　　  左移&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rshift__(self, rhs)　　　　　　 self &amp;gt;&amp;gt; rhs 　　　　　　　   右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反向位运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　　  运算符和表达式 　　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rand__(self, lhs) 　　　　　　  lhs &amp;amp; self 　　　　　　　　 位与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ror__(self, lhs) 　　　　　　　lhs | self 　　　　　　　　   位或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rxor__(self, lhs)　　　　　　   lhs ^ self 　　　　　　　　  位异或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rlshift__(self, lhs)　　　　　    lhs &amp;lt;&amp;lt; self 　　　　　　      左移&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__rrshift__(self, lhs) 　　　　     lhs &amp;gt;&amp;gt; self 　　　　　　　    右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复合赋值位运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名　　　　　　　　　　      运算符和表达式 　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__iand__(self, rhs)　　　　　　  self &amp;amp;= rhs　　　　　　  位与&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ior__(self, rhs) 　　　　　　    self |= rhs 　　　　　　   位或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ixor__(self, rhs) 　　　　　　 self ^= rhs 　　　　　　  位异或&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__ilshift__(self, rhs)　　　　　   self &amp;lt;&amp;lt;= rhs 　　　　　    左移&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__irshift__(self, rhs) 　　　　　 self &amp;gt;&amp;gt;= rhs 　　　　　　 右移&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一元运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;方法名 　　　　　　　　　　 运算符和表达式 　　　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__invert__(self) 　　　　　    　 ~ self 　　　　　　           取反(一元运算符)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__pos__(self) 　　　　　　　　 + self 　　　　　　　  　  正号&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__neg__(self) 　　　　　　        - self 　　　　　　　 　     负号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;in / not in 运算符重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;__contains__&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;索引和切片运算符的重载&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;　　方法名 　　　　　　　　　　 运算符和表达式 　　　　 说明&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__getitem__(self, i) 　　　　　 　 x = self[i] 　　　　   索引/切片取值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__setitem__(self, i, val) 　　　  　self[i] = val 　　　　索引/切片赋值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;__delitem__(self, i) 　　　　　　 del self[i] 　　　　    删除索引/切片&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;slice(start=None, stop=None, step=None)&lt;/span&gt;等同于&lt;span&gt;[ : :]&lt;/span&gt; 切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;字符串　　　　　　 （str） 　　　　    是不可变序列　　　　　　　　　　 “”&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;列表 　　　　　　　 [list] 　　　　　   是可变的序列 　　　　　　　　　　 [ ]      　　　　　　    (索引、切片、索引切片赋值)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;元组　　　　　　     (tuple) 　　　　　是不可变的序列 　　　　　　　　　 ( )    　　　　　　     （索引、切片 不可变 不能赋值）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;字典 　　　　　　　{dict} 　　　　　  是可变无序的容器 　　　　　　　　 { } 　　　　 　　　　  (键索引，键赋值 没有创建 有则修改)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;集合 　　　　　　    {set} 　　　　      是可变的容器 　　　　　　　　　　 { } 　　　　　　 　　 （元素无法重复、索引切片）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;固定集合 　　　　　{frozenset} 　　   不可变  无序 唯一元素的集合　  　   { }　  　　　　　　　（索引切片）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;字节串　　　　　　 “bytes” 　　　　 是不可变的字节序列 　　　　　　　 “ ” 　　　　     　  　（索引切片）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;字节数组 　　　　   （bytearray） 　   是 可变的字节序列 　 　　　　　　（） 　　　　      　    （索引 切片 赋值）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推导式：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;L&lt;/span&gt;= [表达式 for 变量 in 可迭代对象 if 真值表达式]&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;D&lt;/span&gt; = {键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;S&lt;/span&gt; = {表达式 for 变量 in 可迭代对象 [if 真值表达式]}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;匿名函数表达式：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;lambda x, y: x + y&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;生成器表达式&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;(表达式 for 变量 in 可迭代对象 [if 真值表达式 ])&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;运算符：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;+ 　　　　　　   加&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;- 　　　　　　   减&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;* 　　　　　　   乘&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;/　　　　　　    除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;** 　　　　  　  幂&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;// 　　　　 　　 地板除&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;% 　　　　　　 取余&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;is 　　　　 　　  是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;is not 　　　　  不是&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;ni　　　　　　  在 &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;not in 　　　　  不在&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;= 　　　　　　 赋值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt; 　　　　　　 大于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt;= 　　　　　　 大于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;lt; 　　　　　　 小于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;lt;= 　　　　　　小于等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;== 　　　　　　 等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;!= 　　　　　　 不等于&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;amp; 　　　　　　 交集（集合）&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;| 　　　　　　 并集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;- 　　　　　　 补集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;^ 　　　　　　 对称补集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;gt; 　　　　　　 超集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&amp;lt; 　　　　　　 子集&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;== 　　　　　　 等&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;!= 　　　　　　 不等&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;转义符:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;\' 　　　　　　　　　　 单引号(')&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\&quot; 　　　　　　　　　　 双引号(&quot;)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\\ 　　　　　　　　　　 一个反斜杠&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\n 　　　　　　　　　　 换行&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\r 　　　　　　　　　　 返回光标至行首&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\t 　　　　　　　　　　 水平制表符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\v 　　　　　　　　　　 垂直制表符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\f 　　　　　　　　　　 换页&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\b 　　　　　　　　　  倒退&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\0 　　　　　　　　　　　 空字符，字符值为零&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\xXX 　　　　　　　　 　　 XX为两位十六进制表示的字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\uXXXX 　　　　　　　  　 XXXX为四个十六进制表示的Unicode16字符&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;\UXXXXXXXX 　　　　　　 8个十六进制表示的Unicode32字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;格式化字符串中的占位符和类型码:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;%s 　　　　　　　　 字符串,使用str(obj)转为字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%r 　　　　　　　　 字符串，使用repr(obj) 转为字符串&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%c 　　　　　　　　 整数转为字符串，使用chr(i) 函数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%d 　　　　　　　　 十进制整数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%o 　　　　　　　　 八进制整数&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%x 　　　　　　　　 十六进制整数(字符a-f小写)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%X 　　　　　　　　 十六进制整数(字符A-F大写)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%e 　　　　　　　　 指数型浮点数(e小写) 如 2.9e+10&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%E 　　　　　　　　 指数型浮点数(E大写) 如 2.9E+10&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%f,%F 　　　　　　 浮点十进制形式&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%g,%G 　　　　　　 进制进形式浮点或指数浮点自动转换&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;%% 　　　　　　　　 等同于一个%字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;占位符和类型码之间的格式语法:&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;% [- + 0 宽度.精度] 类型码&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-&lt;/span&gt; 　　　　   左对齐(默认是右对齐)&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;+&lt;/span&gt; 　　　　 显示正号&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;0&lt;/span&gt; 　　　　 左侧空白位置补零&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;宽度&lt;/span&gt;: 整个数据输出的宽度&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;精度&lt;/span&gt;: 保留小数点后多少位,默认6位&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%10d&quot; % 123 　　　　    # ' 123'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%+10d&quot; % 123 　　　　 # ' +123'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%-10d&quot; % 123 　　　 　 # '123 '&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%10s&quot; % &quot;ABC&quot; 　　      # ' ABC'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%05d&quot; % 123 　　　　  # '00123'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%f&quot; % 3.1416926535897932  　　　     　# '3.141593'&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&quot;%7.2f&quot; % 3.1416926535897932 　　　　 # ' 3.14'&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;


&lt;h2 id=&quot;python3-method&quot;&gt;Python3 中常用&lt;span&gt;字符串方法&lt;/span&gt;(method)&lt;/h2&gt;
&lt;h3 id=&quot;_1&quot;&gt;字符串的方法调用语法:&lt;/h3&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
对象.方法名(方法传参)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;_2&quot;&gt;字符串的属性读用法示例:&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&quot;abc&quot;.isalpha()  # 语法是对的
123.isalpha()    # 语法是错的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下假设字符串变量名为S&lt;/p&gt;
&lt;h3 id=&quot;_3&quot;&gt;常用字符串方法&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;31&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isdigit()&lt;/td&gt;
&lt;td&gt;判断字符串中的字符是否全为数字&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isalpha()&lt;/td&gt;
&lt;td&gt;判断字符串是否全为英文字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.islower()&lt;/td&gt;
&lt;td&gt;判断字符串所有字符是否全为小写英文字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isupper()&lt;/td&gt;
&lt;td&gt;判断字符串所有字符是否全为大写英文字母&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isspace()&lt;/td&gt;
&lt;td&gt;判断字符串是否全为空白字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.center(width[,fill])&lt;/td&gt;
&lt;td&gt;将原字符串居中，左右默认填充空格 width：所居中字符串的长度 fill：默认填充空格&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;S.count(sub[, start[,end]])&lt;/td&gt;
&lt;td&gt;获取一个字符串中子串的个数 sub：所要获取的字符串 start：起始位置 end：结束位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;S.find(sub[, start[,end]])&lt;/td&gt;
&lt;td&gt;获取字符串中子串sub的索引,失败返回-1 start：起始位置 end：结束位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.strip()&lt;/td&gt;
&lt;td&gt;返回去掉左右空白字符的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.lstrip()&lt;/td&gt;
&lt;td&gt;返回去掉左侧空白字符的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.rstrip()&lt;/td&gt;
&lt;td&gt;返回去掉右侧空白字符的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.upper()&lt;/td&gt;
&lt;td&gt;生成将英文转换为大写的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.lower()&lt;/td&gt;
&lt;td&gt;生成将英文转换为小写的字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;S.replace(old, new[, count])&lt;/td&gt;
&lt;td&gt;将原字符串的old用new代替，生成一个新的字符串 count：更换的次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;S.startswith(prefix[, start[, end]])&lt;/td&gt;
&lt;td&gt;返回S是否是以prefix开头，如果以prefix开头返回True,否则返回False,&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;S.endswith(suffix[, start[, end]])&lt;/td&gt;
&lt;td&gt;返回S是否是以suffix结尾，如果以suffix结尾返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;以下是不常用的&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.title()&lt;/td&gt;
&lt;td&gt;生成每个英文单词的首字母大写字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.isnumeric()&lt;/td&gt;
&lt;td&gt;判断字符串是否全为数字字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;python3method&quot;&gt;&lt;span&gt;Python3中常用的&lt;span&gt;列表方法&lt;/span&gt;（method)&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;见:help(list)&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;L.index(v [, begin[, end]])&lt;/td&gt;
&lt;td&gt;返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.insert(index, obj)&lt;/td&gt;
&lt;td&gt;将某个元素插放到列表中指定的位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.count(x)&lt;/td&gt;
&lt;td&gt;返回列表中元素的个数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.remove(x)&lt;/td&gt;
&lt;td&gt;从列表中删除第一次出现在列表中的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.copy()&lt;/td&gt;
&lt;td&gt;复制此列表（只复制一层，不会复制深层对象)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.append(x)&lt;/td&gt;
&lt;td&gt;向列表中追加单个元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.extend(lst)&lt;/td&gt;
&lt;td&gt;向列表追加另一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;L.clear()&lt;/td&gt;
&lt;td&gt;清空列表,等同于 L[:] = []&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.sort(reverse=False)&lt;/td&gt;
&lt;td&gt;将列表中的元素进行排序，默认顺序按值的小到大的顺序排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;L.reverse()&lt;/td&gt;
&lt;td&gt;列表的反转，用来改变原列表的先后顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;L.pop([index])&lt;/td&gt;
&lt;td&gt;删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h4 id=&quot;_1&quot;&gt;&lt;span&gt;字典的方法&lt;/span&gt;&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;D代表字典对象&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;D.clear()&lt;/td&gt;
&lt;td&gt;清空字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.pop(key)&lt;/td&gt;
&lt;td&gt;移除键，同时返回此键所对应的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;D.copy()&lt;/td&gt;
&lt;td&gt;返回字典D的副本,只复制一层(浅拷贝)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.update(D2)&lt;/td&gt;
&lt;td&gt;将字典 D2 合并到D中，如果键相同，则此键的值取D2的值作为新值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;D.get(key, default)&lt;/td&gt;
&lt;td&gt;返回键key所对应的值,如果没有此键，则返回default&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.keys()&lt;/td&gt;
&lt;td&gt;返回可迭代的 dict_keys 集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.values()&lt;/td&gt;
&lt;td&gt;返回可迭代的 dict_values 值对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;D.items()&lt;/td&gt;
&lt;td&gt;返回可迭代的 dict_items 对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h5 id=&quot;python3&quot;&gt;&lt;span&gt;Python3&lt;/span&gt; &lt;span&gt;集合的方法&lt;/span&gt;&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.add(e)&lt;/td&gt;
&lt;td&gt;在集合中添加一个新的元素e；如果元素已经存在，则不添加&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.remove(e)&lt;/td&gt;
&lt;td&gt;从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.discard(e)&lt;/td&gt;
&lt;td&gt;从集合S中移除一个元素e,在元素e不存在时什么都不做;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.clear()&lt;/td&gt;
&lt;td&gt;清空集合内的所有元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.copy()&lt;/td&gt;
&lt;td&gt;将集合进行一次浅拷贝&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.pop()&lt;/td&gt;
&lt;td&gt;从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.update(s2)&lt;/td&gt;
&lt;td&gt;用 S与s2得到的全集更新变量S&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.difference(s2)&lt;/td&gt;
&lt;td&gt;用S - s2 运算，返回存在于在S中，但不在s2中的所有元素的集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S.difference_update(s2)&lt;/td&gt;
&lt;td&gt;等同于 S = S - s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S.intersection(s2)&lt;/td&gt;
&lt;td&gt;等同于 S &amp;amp; s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S.intersection_update(s2)&lt;/td&gt;
&lt;td&gt;等同于S = S &amp;amp; s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.isdisjoint(s2)&lt;/td&gt;
&lt;td&gt;如果S与s2交集为空返回True,非空则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.issubset(s2)&lt;/td&gt;
&lt;td&gt;如果S与s2交集为非空返回True,空则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;S.issuperset(...)&lt;/td&gt;
&lt;td&gt;如果S为s2的子集返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;S.symmetric_difference(s2)&lt;/td&gt;
&lt;td&gt;返回对称补集,等同于 S ^ s2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;S.symmetric_difference_update(s2)&lt;/td&gt;
&lt;td&gt;用 S 与 s2 的对称补集更新 S&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S.union(s2)&lt;/td&gt;
&lt;td&gt;生成 S 与 s2的全集&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;python_1&quot;&gt;Python&lt;span&gt;运算符优先级&lt;/span&gt;&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;(), [], {key: value}, {}&lt;/td&gt;
&lt;td&gt;元组表达式、列表表达式、字典表达式、集合表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;x[index], x[index:index],&lt;br/&gt;x(arguments...), x.attribute&lt;/td&gt;
&lt;td&gt;索引，切片，&lt;br/&gt;函数调用，属性引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;指数 (最高优先级)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;~, +, -&lt;/td&gt;
&lt;td&gt;按位翻转, 正号,负号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*, /, %, //&lt;/td&gt;
&lt;td&gt;乘，除，取模和地板除&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;+, -&lt;/td&gt;
&lt;td&gt;加法, 减法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;gt;&amp;gt;, &amp;lt;&amp;lt;&lt;/td&gt;
&lt;td&gt;右移, 左移运算符&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;位与(AND)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;位异或(XOR)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;位或(OR)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td&gt;&amp;lt;=, &amp;lt;, &amp;gt;, &amp;gt;=, ==, !=,&lt;br/&gt;is, is not, in, not in&lt;/td&gt;
&lt;td&gt;比较,身份测试,成员资格测试&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;布尔非&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;布尔与&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;布尔或&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;if - else&lt;/td&gt;
&lt;td&gt;条件表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;lambda&lt;/td&gt;
&lt;td&gt;lambda表达式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;_1&quot;&gt;&lt;span&gt;文件&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;mode&quot;&gt;mode 模式字符的含义&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'r'&lt;/td&gt;
&lt;td&gt;以只读方式打开(默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;'w'&lt;/td&gt;
&lt;td&gt;以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;'x'&lt;/td&gt;
&lt;td&gt;创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生&quot;FileExistsError&quot;错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'a'&lt;/td&gt;
&lt;td&gt;以只写文件打开一个文件，如果有原文件则追加到文件末尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;'b'&lt;/td&gt;
&lt;td&gt;用二进制模式打开&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'t'&lt;/td&gt;
&lt;td&gt;文本文件模式打开 (默认)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;'+'&lt;/td&gt;
&lt;td&gt;为更新内容打开一个磁盘文件 (可读可写)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;缺省模式是 'rt'&lt;/li&gt;
&lt;li&gt;'w+b' 可以实现二进制随机读写，当打开文件时，文件内容将被清零&lt;/li&gt;
&lt;li&gt;'r+b' 以二进制读和更新模式打开文件,打开文件时不会清空文件内容&lt;/li&gt;
&lt;li&gt;'r+' 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;python_1&quot;&gt;python &lt;span&gt;文件常用方法&lt;/span&gt;:&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.close()&lt;/td&gt;
&lt;td&gt;关闭文件(关闭后文件不能再读写会发生ValueError错误)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.readline()&lt;/td&gt;
&lt;td&gt;读取一行数据, 如果到达文件尾则返回空行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;F.readlines(max_chars=-1)&lt;/td&gt;
&lt;td&gt;返回每行字符串的列表,max_chars为最大字符(或字节)数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.writelines(lines)&lt;/td&gt;
&lt;td&gt;将字符串的列表或字符串的列表中的内容写入文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;二进制文件操作方法&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.read(size=-1)&lt;/td&gt;
&lt;td&gt;从一个文件流中最多读取size个字符(文本文件)或字节(二进制文件),如果不给出参数，则默认读取文件中全部的内容并返回&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;F.write(text)&lt;/td&gt;
&lt;td&gt;写一个字符串到文件流中，返回写入的字符数(文本文件)或字节数(二进制文件)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.tell()&lt;/td&gt;
&lt;td&gt;返回当前文件流读写指针的绝对位置(字节为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seek(offset, whence=0)&lt;/td&gt;
&lt;td&gt;改变数据流读写指针的位置，返回新的绝对位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.flush()&lt;/td&gt;
&lt;td&gt;把写入文件对象的缓存内容写入到磁盘&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.readable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可读,可读返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;F.writable()&lt;/td&gt;
&lt;td&gt;判断这个文件是否可写,可写返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.seekable()&lt;/td&gt;
&lt;td&gt;返回这个文件对象是否支持随机定位&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;F.truncate(pos = None)&lt;/td&gt;
&lt;td&gt;剪掉 自pos位置之后的数据，返回新的文件长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3 id=&quot;time&quot;&gt;&lt;span&gt;时间模块 time&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;此模块提供了时间相关的函数，且一直可用&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_1&quot;&gt;时间简介&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;公元纪年是从公元 0000年1月1日0时开始的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;计算机元年是从1970年1月1日0时开始的,此时时间为0,之后每过一秒时间+1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;UTC 时间 (Coordinated Universal Time) 是从Greenwich时间开始计算的.&lt;br/&gt;UTC 时间不会因时区问题而产生错误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DST 阳光节约时间(Daylight Saving Time)，又称夏令时, 是一个经过日照时间修正后的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_2&quot;&gt;时间元组&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;时间元组是一个9个整型元素组成的,这九个元素自前至后依次为:
&lt;ul&gt;&lt;li&gt;四位的年(如: 1993)&lt;/li&gt;
&lt;li&gt;月 (1-12)&lt;/li&gt;
&lt;li&gt;日 (1-31)&lt;/li&gt;
&lt;li&gt;时 (0-23)&lt;/li&gt;
&lt;li&gt;分 (0-59)&lt;/li&gt;
&lt;li&gt;秒 (0-59)&lt;/li&gt;
&lt;li&gt;星期几 (0-6, 周一是 0)&lt;/li&gt;
&lt;li&gt;元旦开始日 (1-366)&lt;/li&gt;
&lt;li&gt;夏令时修正时间 (-1, 0 or 1).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;&lt;li&gt;如果年份值小于100,则会自动转换为加上1900后的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;time_1&quot;&gt;模块名: time&lt;/h4&gt;
&lt;h4 id=&quot;_3&quot;&gt;时间模块用法：&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
import time
# 或
from time import xxx
# 或
from time import *
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.altzone&lt;/td&gt;
&lt;td&gt;夏令时时间与UTC时间差(秒为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;time.daylight&lt;/td&gt;
&lt;td&gt;夏令时校正时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.timezone&lt;/td&gt;
&lt;td&gt;本地区时间与UTC时间差(秒为单位)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;time.tzname&lt;/td&gt;
&lt;td&gt;时区名字的元组， 第一个名字为未经夏令时修正的时区名,&lt;br/&gt;第一个名字为经夏令时修正后的时区名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注： CST为中国标准时间(China Standard Time UTC+8:00)&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.time()&lt;/td&gt;
&lt;td&gt;返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.sleep(secs)&lt;/td&gt;
&lt;td&gt;让程序按给定秒数的浮点数睡眠一段时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.gmtime([secs])&lt;/td&gt;
&lt;td&gt;用给定秒数转换为用UTC表达的时间元组&lt;br/&gt;(缺省返回当前时间元组)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.asctime([tuple])&lt;/td&gt;
&lt;td&gt;将时间元组转换为日期时间字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.mktime(tuple)&lt;/td&gt;
&lt;td&gt;将本地日期时间元组转换为新纪元秒数时间(UTC为准)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;time.localtime([secs])&lt;/td&gt;
&lt;td&gt;将UTC秒数时间转换为日期元组（以本地时间为准)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;math&quot;&gt;&lt;span&gt;数学模块 math&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;模块名: math&lt;/li&gt;
&lt;li&gt;注：
&lt;ul&gt;&lt;li&gt;linux下为内建模块&lt;/li&gt;
&lt;li&gt;Mac OS下为标准库模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_1&quot;&gt;数学模块用法：&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
import math
# 或
from math import *
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;变量&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;math.e&lt;/td&gt;
&lt;td&gt;自然对数的底e&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.pi&lt;/td&gt;
&lt;td&gt;圆周率pi&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.ceil(x)&lt;/td&gt;
&lt;td&gt;对x向上取整，比如x=1.2，返回2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.floor(x)&lt;/td&gt;
&lt;td&gt;对x向下取整，比如x=1.2，返回1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.sqrt(x)&lt;/td&gt;
&lt;td&gt;返回x的平方根&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.factorial(x)&lt;/td&gt;
&lt;td&gt;求x的阶乘&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;math.log(x[, base])&lt;/td&gt;
&lt;td&gt;返回以base为底x的对数, 如果不给出base,则以自然对数e为底&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;math.log10(x)&lt;/td&gt;
&lt;td&gt;求以10为底x的对数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.pow(x, y)&lt;/td&gt;
&lt;td&gt;返回 x**y (x的y次方)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.fabs(x)&lt;/td&gt;
&lt;td&gt;返回浮点数x的绝对值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;角度和弧度degrees互换&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.degree(x)&lt;/td&gt;
&lt;td&gt;将弧度x转换为角度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.radians(x)&lt;/td&gt;
&lt;td&gt;将角度x转换为弧度&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;三角函数&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.sin(x)&lt;/td&gt;
&lt;td&gt;返回x的正弦(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.cos(x)&lt;/td&gt;
&lt;td&gt;返回x的余弦(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.tan(x)&lt;/td&gt;
&lt;td&gt;返回x的正切(x为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.asin(x)&lt;/td&gt;
&lt;td&gt;返回x的反正弦(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.acos(x)&lt;/td&gt;
&lt;td&gt;返回x的反余弦(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;math.atan(x)&lt;/td&gt;
&lt;td&gt;返回x的反正切(返回值为为弧度)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h3 id=&quot;random&quot;&gt;&lt;span&gt;随机模块 random&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;_1&quot;&gt;说明：&lt;/h4&gt;
&lt;h5 id=&quot;random_1&quot;&gt;random模块是用于模拟或生成随机输出的模块.&lt;/h5&gt;
&lt;p&gt;import random as R&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;R.random()&lt;/td&gt;
&lt;td&gt;返回一个[0, 1) 之间的随机实数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;R.uniform(a,b)&lt;/td&gt;
&lt;td&gt;返回[a,b) 区间内的随机实数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;R.randrange([start,] stop[, step])&lt;/td&gt;
&lt;td&gt;返回range(start,stop,step)中的随机数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;R.choice(seq)&lt;/td&gt;
&lt;td&gt;从序列中返回随意元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;R.shuffle(seq[, random])&lt;/td&gt;
&lt;td&gt;随机指定序列的顺序(乱序序列）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;R.sample(seq,n)&lt;/td&gt;
&lt;td&gt;从序列中选择n个随机且不重复的元素&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3 id=&quot;sys&quot;&gt;&lt;span&gt;系统模块 sys&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;运行时系统相关的信息&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;sys_1&quot;&gt;sys模块的属性&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.path&lt;/td&gt;
&lt;td&gt;模块搜索路径 path[0] 是当前脚本程序的路径名，否则为 ''&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sys.modules&lt;/td&gt;
&lt;td&gt;已加载模块的字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sys.version&lt;/td&gt;
&lt;td&gt;版本信息字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.version_info&lt;/td&gt;
&lt;td&gt;版本信息的命名元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.platform&lt;/td&gt;
&lt;td&gt;操作系统平台名称信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.argv&lt;/td&gt;
&lt;td&gt;命令行参数 argv[0] 代表当前脚本程序路径名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.copyright&lt;/td&gt;
&lt;td&gt;获得Python版权相关的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.builtin_module_names&lt;/td&gt;
&lt;td&gt;获得Python内建模块的名称（字符串元组）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;sys_2&quot;&gt;sys模块的函数&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.exit([arg])&lt;/td&gt;
&lt;td&gt;退出程序，正常退出时sys.exit(0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.getrecursionlimit()&lt;/td&gt;
&lt;td&gt;得到递归嵌套层次限制（栈的深度）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sys.setrecursionlimit(n)&lt;/td&gt;
&lt;td&gt;得到和修改递归嵌套层次限制（栈的深度）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　　　　　　　内建函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;_1&quot;&gt;数值对象的构造(创建)函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;float(obj)&lt;/td&gt;
&lt;td&gt;用字符串或数字转换为浮点数, 如果不给出参数，则返回0.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int(x, base=10)&lt;br/&gt;int(x=0)&lt;/td&gt;
&lt;td&gt;用数字或字符串转换为整数,如果不给出参数，则返回0&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;complex(r=0.0, i=0.0)&lt;/td&gt;
&lt;td&gt;用数字创建一个复数(实部为r,虚部为i)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bool(x)&lt;/td&gt;
&lt;td&gt;用x创建一个布尔值(True/False)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_2&quot;&gt;预置(内建)的数值型函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;abs(x)&lt;/td&gt;
&lt;td&gt;取x的绝对值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;round(number[, ndigits])&lt;/td&gt;
&lt;td&gt;对数值进行四舍五入, ndigits是小数向右取整的位数, 负数表示向左取整&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;pow(x, y, z=None)&lt;/td&gt;
&lt;td&gt;相当于x ** y 或 x**y % z&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;help&quot;&gt;help() 查看函数帮助：&lt;/h3&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
help函数
&amp;gt;&amp;gt;&amp;gt; help(abs)  # 查看abs函数的帮助
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;_3&quot;&gt;基本输入输出&lt;/h2&gt;
&lt;h3 id=&quot;input&quot;&gt;基本输入 input&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;input('提示字符串')&lt;/td&gt;
&lt;td&gt;返回输入的字符串(仅Python3,'提示字符串' 可以是空)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;print&quot;&gt;基本输出函数 print&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)&lt;/td&gt;
&lt;td&gt;将一系列的值以字符串形式输出到&lt;br/&gt;标准输出设备上,默认为终端.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;_4&quot;&gt;参数选项&lt;/h4&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
选项的关键字参数为:
sep:   两个值之间的分隔符，默认为一个空格' '
end:   输出完毕后在流末尾自动追加一个字符串,默认为换行符'\n'
file:  流对象，默认为sys.stdout.
flush: 是否立即将流进行输出
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;_5&quot;&gt;字符串编码转换函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ord(c)&lt;/td&gt;
&lt;td&gt;返回一个字符的Unicode值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;chr(i)&lt;/td&gt;
&lt;td&gt;返回i这个值所对应的 字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_6&quot;&gt;整数转换为字符串函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;hex(i)&lt;/td&gt;
&lt;td&gt;将整数转换为十六进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;oct(i)&lt;/td&gt;
&lt;td&gt;将整数转换为八进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bin(i)&lt;/td&gt;
&lt;td&gt;将整数转换为二进制字符串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_7&quot;&gt;字符串构造函数&lt;/h3&gt;
&lt;div class=&quot;codehilite&quot;&gt;
&lt;pre&gt;
&quot;123&quot; + 1  # 不合法
&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;str(obj='')&lt;/td&gt;
&lt;td&gt;将对象转换为字符串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;range&quot;&gt;range()函数&lt;/h4&gt;
&lt;h5 id=&quot;_8&quot;&gt;格式:&lt;/h5&gt;
&lt;p&gt;(见:help(range))&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;range(stop)&lt;/td&gt;
&lt;td&gt;从零开始，每次生成一个整数后加1操作，直到stop为止（不包含stop)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;range(start,stop[,step])&lt;/td&gt;
&lt;td&gt;从start开始，每次生成一个整数后移动step，直到stop为止（不包含stop，且step可以是负整数)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;list&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　列表的构造(创建)函数list&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list()&lt;/td&gt;
&lt;td&gt;# 生成一个空的列表 等同于 []&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list(iterable)&lt;/td&gt;
&lt;td&gt;# 用可迭代对象创建一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;python3&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　Python3中常用的序列函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr&gt;&lt;td&gt;len(seq)&lt;/td&gt;
&lt;td&gt;返回序列的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;max(x)&lt;/td&gt;
&lt;td&gt;返回序列的最大值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;min(x)&lt;/td&gt;
&lt;td&gt;返回序列的最小值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;------以上是以前学的---------&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sum(x)&lt;/td&gt;
&lt;td&gt;返回序列中所有元素的和(元素必须是数值类型)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;any(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中其中一个值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;all(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中所有值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reversed(seq)&lt;/td&gt;
&lt;td&gt;返回原序列反向顺序的可迭代对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;sorted(iterable, reverse=False)&lt;/td&gt;
&lt;td&gt;返回已排序对象的&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;str(obj)&lt;/td&gt;
&lt;td&gt;将对象obj序列化为一个字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个元组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;tuple&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　元组的构造(创建)函数tuple&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple()&lt;/td&gt;
&lt;td&gt;生成一个空的元组，等同于 ()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个元组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_9&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　序列相关函数总结&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;len(seq)&lt;/td&gt;
&lt;td&gt;返回序列的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;max(x)&lt;/td&gt;
&lt;td&gt;返回序列的最大值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;min(x)&lt;/td&gt;
&lt;td&gt;返回序列的最小值的元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;sum(x)&lt;/td&gt;
&lt;td&gt;返回序列中所有元素的和&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;any(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中其中一个值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;all(x)&lt;/td&gt;
&lt;td&gt;真值测试，如果列表中所有值为真值则返回True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;str(obj)&lt;/td&gt;
&lt;td&gt;将对象obj序列化为一个字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;list(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;tuple(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象生成一个元组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reversed(seq)&lt;/td&gt;
&lt;td&gt;返回反向顺序的可迭代对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;sorted(iterable, key=None, reverse=False)&lt;/td&gt;
&lt;td&gt;返回已排序的列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;dictdict&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　dict的构造(创建)函数dict&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dict()&lt;/td&gt;
&lt;td&gt;# 生成一个空的字典 等同于 {}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dict(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象初始化一个字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dict(**kwargs)&lt;/td&gt;
&lt;td&gt;关键字传参形式生成一个字典&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;set&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　集合构造(创建)函数 set&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set()&lt;/td&gt;
&lt;td&gt;创建一个空的集合对象(不能用{}来创建空集合)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;set(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象创建一个新的集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;frozenset&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　固定集合构造(创建)函数 frozenset&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;frozenset()&lt;/td&gt;
&lt;td&gt;创建一个空的固定集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;frozenset(iterable)&lt;/td&gt;
&lt;td&gt;用可迭代对象创建一个新的固定集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;globals-locals&quot;&gt;　　　　　　　　　　　　　　　　　　　　globals() / locals() 函数&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;globals()&lt;/td&gt;
&lt;td&gt;返回当前全局作用域内变量的字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;locals()&lt;/td&gt;
&lt;td&gt;返回当前局部作用域内变量的字典&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;eval-exec&quot;&gt;　　　　　　　　　　　　　　　　　　　　　eval(), exec() 函数&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;eval(source, globals=None, locals=None)&lt;/td&gt;
&lt;td&gt;把一个字符串source当成一个表达式来执行，返回表达式执行后的结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;exec(source, globals=None, locals=None)&lt;/td&gt;
&lt;td&gt;把一个字符串source当成程序来执行．&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;high-order-function&quot;&gt;　　　　　　　　　　　　　　　　　　高阶函数 High Order Function&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;map(func, *iterables)&lt;/td&gt;
&lt;td&gt;用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象,&lt;br/&gt;当最短的一个可迭代对象不再提供数据时此可迭代对象生成结束&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;filter(function, iterable)&lt;/td&gt;
&lt;td&gt;筛选可迭代对象iterable中的数据,返回一个可迭代器对象，此可迭代对象&lt;br/&gt;将对iterable进行筛选.函数function 将对iterable中的每个元素进行求值，&lt;br/&gt;返回False则将此数据丢弃，返回True，则保留此数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;sorted(iterable, key=None, reverse=False)&lt;/td&gt;
&lt;td&gt;将原可迭代对象的数据进行排序，生成排序后的列表iterable 可迭代对象&lt;br/&gt;key 函数是用来提供一个值,这个值将作为排序的依据reverse 标志用来设&lt;br/&gt;置是否降序排序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;dir&quot;&gt;dir函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dir([对象])&lt;/td&gt;
&lt;td&gt;返回一个字符串列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;dir_1&quot;&gt;dir函数作用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如果没有参数调用，则返回当前作用域内的所有变量的列表&lt;/li&gt;
&lt;li&gt;如果给定一个对象作为参数，则返回这个对象的所有变量的列表
&lt;ul&gt;&lt;li&gt;对于一个模块,返回这个模块的全部变量&lt;/li&gt;
&lt;li&gt;对于一个类对象，返回类对象的所有变量，并递归的基类对象的所有变量&lt;/li&gt;
&lt;li&gt;对于其它对象返回所有变量、类变量和基类变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;iternext&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　迭代器函数iter和next&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;iter(iterable)&lt;/td&gt;
&lt;td&gt;从可迭代对象中返回一个迭代器,iterable必须是能提供一个迭代器的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;next(iterator)&lt;/td&gt;
&lt;td&gt;从迭代器iterator中获取一下个记录，如果无法获取一下条记录，则触发 StopIteration 异常&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_10&quot;&gt;迭代工具函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;迭代工具函数的作用是生成一个个性化可迭代对象&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;zip(iter1 [,iter2 [...]])&lt;/td&gt;
&lt;td&gt;返回一个zip对象, 此对象用于生成一个元组，此元组的个数由最小的可迭代对象决定&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;enumerate(iterable[, start])&lt;/td&gt;
&lt;td&gt;生成带索引的枚举对象，返回的迭代类型为索引-值对(index-value)对,默认索引从零开始，也可以用start指定&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;bytes&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　字节串的构造函数bytes&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bytes()&lt;/td&gt;
&lt;td&gt;# 生成一个空的字节串 等同于 b''&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;bytes(整型可迭代对象)&lt;/td&gt;
&lt;td&gt;# 用可迭代对象初始化一个字节串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bytes(整数n)&lt;/td&gt;
&lt;td&gt;生成n个值为0的字节串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;bytes(字符串, encoding='utf-8')&lt;/td&gt;
&lt;td&gt;用字符串的转换编码生成一个字节串&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;bytearray&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　字节数组的生成函数 bytearray&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;bytearray()&lt;/td&gt;
&lt;td&gt;创建空的字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;bytearray(整数)&lt;/td&gt;
&lt;td&gt;用可迭代对象初始化一个字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;bytearray(整型可迭代对象)&lt;/td&gt;
&lt;td&gt;生成n个值为0的字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;bytearray(字符串, encoding='utf-8')&lt;/td&gt;
&lt;td&gt;用字符串的转换编码生成一个字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_11&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　文件的打开函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;open(file, mode='rt')&lt;/td&gt;
&lt;td&gt;用于打开一个文件，返回此文件流对象. &lt;br/&gt;如果打开文件失败，则会触发OSError 错误! &lt;br/&gt;如果要打开的文件不存在，则会触发FileNotFoundError 错误!&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_12&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　用于类的函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;isinstance(obj, class_or_tuple)&lt;/td&gt;
&lt;td&gt;返回这个对象obj 是否是 某个类的对象,或者某些类&lt;br/&gt;中的一个类的对象,如果是返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;type(obj)&lt;/td&gt;
&lt;td&gt;返回对象的类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;super&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　super函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;super(cls, obj)&lt;/td&gt;
&lt;td&gt;返回绑定超类的实例(要求obj必须为cls类型的实例)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;super()&lt;/td&gt;
&lt;td&gt;返回绑定超类的实例,等同于:super(&lt;strong&gt;class&lt;/strong&gt;, 实例方法的第一个参数)，必须用在方法内调用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;_13&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　用于类的函数&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;issubclass(cls, class_or_tuple)&lt;/td&gt;
&lt;td&gt;判断一个类是否继承自其它的类,如果此类cls是class 或 tuple中的一个派生子类则返回True,否则返回False&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;_14&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　对象的属性管理函数&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;getattr(obj, name[, default])&lt;/td&gt;
&lt;td&gt;从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给&lt;br/&gt;出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;hasattr(obj, name)&lt;/td&gt;
&lt;td&gt;用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;setattr(obj, name, value)&lt;/td&gt;
&lt;td&gt;给对象obj的名为name的属性设置相应的值value, set(x, 'y', v) 等同于 x.y = v&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;delattr(obj, name)&lt;/td&gt;
&lt;td&gt;删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h4 id=&quot;python_1&quot;&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　Python全部的错误类型&lt;/span&gt;&lt;/h4&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;错误类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;26.5&quot;&gt;&lt;tr&gt;&lt;td&gt;以下内容必讲&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ZeroDivisionError&lt;/td&gt;
&lt;td&gt;除(或取模)零 (所有数据类型)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ValueError&lt;/td&gt;
&lt;td&gt;传入无效的参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;AssertionError&lt;/td&gt;
&lt;td&gt;断言语句失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;StopIteration&lt;/td&gt;
&lt;td&gt;迭代器没有更多的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;IndexError&lt;/td&gt;
&lt;td&gt;序列中没有此索引(index)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IndentationError&lt;/td&gt;
&lt;td&gt;缩进错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OSError&lt;/td&gt;
&lt;td&gt;输入/输出操作失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ImportError&lt;/td&gt;
&lt;td&gt;导入模块/对象失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NameError&lt;/td&gt;
&lt;td&gt;未声明/初始化对象 (没有属性)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;AttributeError&lt;/td&gt;
&lt;td&gt;对象没有这个属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;GeneratorExit&lt;/td&gt;
&lt;td&gt;生成器(generator)发生异常来通知退出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TypeError&lt;/td&gt;
&lt;td&gt;对类型无效的操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;KeyboardInterrupt&lt;/td&gt;
&lt;td&gt;用户中断执行(通常是输入^C)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OverflowError&lt;/td&gt;
&lt;td&gt;数值运算超出最大限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FloatingPointError&lt;/td&gt;
&lt;td&gt;浮点计算错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BaseException&lt;/td&gt;
&lt;td&gt;所有异常的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SystemExit&lt;/td&gt;
&lt;td&gt;解释器请求退出&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Exception&lt;/td&gt;
&lt;td&gt;常规错误的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;StandardError&lt;/td&gt;
&lt;td&gt;所有的内建标准异常的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ArithmeticError&lt;/td&gt;
&lt;td&gt;所有数值计算错误的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;EOFError&lt;/td&gt;
&lt;td&gt;没有内建输入,到达EOF 标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EnvironmentError&lt;/td&gt;
&lt;td&gt;操作系统错误的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WindowsError&lt;/td&gt;
&lt;td&gt;系统调用失败&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LookupError&lt;/td&gt;
&lt;td&gt;无效数据查询的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;KeyError&lt;/td&gt;
&lt;td&gt;映射中没有这个键&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MemoryError&lt;/td&gt;
&lt;td&gt;内存溢出错误(对于Python 解释器不是致命的)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UnboundLocalError&lt;/td&gt;
&lt;td&gt;访问未初始化的本地变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ReferenceError&lt;/td&gt;
&lt;td&gt;弱引用(Weak reference)试图访问已经垃圾回收了的对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RuntimeError&lt;/td&gt;
&lt;td&gt;一般的运行时错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NotImplementedError&lt;/td&gt;
&lt;td&gt;尚未实现的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SyntaxError Python&lt;/td&gt;
&lt;td&gt;语法错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TabError&lt;/td&gt;
&lt;td&gt;Tab 和空格混用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SystemError&lt;/td&gt;
&lt;td&gt;一般的解释器系统错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UnicodeError&lt;/td&gt;
&lt;td&gt;Unicode 相关的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UnicodeDecodeError&lt;/td&gt;
&lt;td&gt;Unicode 解码时的错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UnicodeEncodeError&lt;/td&gt;
&lt;td&gt;Unicode 编码时错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UnicodeTranslateError&lt;/td&gt;
&lt;td&gt;Unicode 转换时错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;以下为警告类型&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;警告的基类&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DeprecationWarning&lt;/td&gt;
&lt;td&gt;关于被弃用的特征的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FutureWarning&lt;/td&gt;
&lt;td&gt;关于构造将来语义会有改变的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;OverflowWarning&lt;/td&gt;
&lt;td&gt;旧的关于自动提升为长整型(long)的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;PendingDeprecationWarning&lt;/td&gt;
&lt;td&gt;关于特性将会被废弃的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RuntimeWarning&lt;/td&gt;
&lt;td&gt;可疑的运行时行为(runtime behavior)的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SyntaxWarning&lt;/td&gt;
&lt;td&gt;可疑的语法的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UserWarning&lt;/td&gt;
&lt;td&gt;用户代码生成的警告&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;详见：help(&lt;strong&gt;builtins&lt;/strong&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Sun, 29 Jul 2018 14:28:00 +0000</pubDate>
<dc:creator>ParisGabriel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ParisGabriel/p/9388030.html</dc:identifier>
</item>
<item>
<title>灵活使用Win+R快捷键提高工作效率 - 凉L</title>
<link>http://www.cnblogs.com/-lyl/p/RunAnything.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-lyl/p/RunAnything.html</guid>
<description>&lt;p&gt;大家平时一定都使用过Win+R运行快捷键，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729181317333-616537123.png&quot; alt=&quot;&quot; width=&quot;370&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在运行里可以快捷的打开一些系统软件，比如说输入mstsc是打开远程连接，输入explorer是打开文件管理器，输入regedit是打开注册表编辑器。&lt;/p&gt;
&lt;p&gt;输入最好的编程语言官网会。。。。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729220520957-290945628.gif&quot; alt=&quot;&quot; width=&quot;741&quot; height=&quot;431&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 那么问题来了，这么方便好用的一个快捷键如果只能打开系统软件岂不是太浪费了吗。&lt;/p&gt;
&lt;p&gt;接下来就是怎么调教下让它功能更加强大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先说下运行打开软件的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你在运行里面输入名字之后，运行会找到环境变量中的Path系统变量，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729211325173-270982768.png&quot; alt=&quot;&quot; width=&quot;839&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去Path中配置的目录中去寻找是否有这个软件或者快捷方式。&lt;/p&gt;
&lt;p&gt;如果有的话就打开，没有的话就提示找不到。&lt;/p&gt;
&lt;p&gt;知道了它的运行方式，接下来就好办了。&lt;/p&gt;
&lt;p&gt;咱们可以&lt;strong&gt;新建一个文件夹，在里面放上常用软件的快捷方式，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后将此文件夹配置到Path环境变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先在合适的地方新建一个文件夹&lt;/strong&gt;，名字可以随意起，quickstart或者ksqd都可以。下文会用ksqd文件夹代替。建议不要建在C盘，如果后期要增加新的快捷方式的话会提示管理员权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;建好ksqd文件夹之后，在文件夹上面点右键=&amp;gt;创建快捷方式，然后给快捷方式起个名字，&lt;strong&gt;尽量简短&lt;/strong&gt;，将快捷方式放到ksqd文件夹，这么做的意义就是，如果以后要修改快捷方式，可以通过运行直接打开ksqd文件夹，非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729212327141-756738116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;接下来把常用软件的快捷方式都放到ksqd文件夹中&lt;/strong&gt;。命名方式依旧是尽量简短，不然如果要输入一大串字符才能打开软件，那还不如直接去桌面找速度快。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关于浏览器的快捷方式：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;浏览器的快捷方式中可以设置默认打开的网址，具体设置方法是：&lt;/p&gt;
&lt;p&gt;在目标框中最后的单引号后面，加上你要打开的网址，比如www.cnblogs.com/-lyl/，当你在运行中打开此快捷方式时，它就会直接打开你设置的主页。&lt;/p&gt;
&lt;p&gt;这样可以给经常去的网站都设置成快捷方式。特别是在内网开发中特别方便，不用再输入各种IP地址。&lt;/p&gt;
&lt;p&gt;有些&lt;strong&gt;流氓软件&lt;/strong&gt;也会采取这种方式&lt;strong&gt;锁定主页，&lt;/strong&gt;如果你的主页修改没有效果，看下快捷方式是不是有问题吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729213002198-535116153.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;737&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将需要的快捷方式添加完成之后，配置环境变量&lt;/strong&gt;。这部分Java开发的同学想必很熟悉了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体步骤是，打开我的电脑=&amp;gt;属性=&amp;gt;环境变量，在系统变量里面找到Path变量。在最后面把ksqd文件夹的路径填进去。比如我的快捷方式是保存在D:\Program\QuickStart文件夹里，我的配置如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729214413487-961304230.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;604&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来就是测试了，Win+R打开运行窗口，输入ksqd文件夹中的快捷方式，看看是不是有什么神奇的事情发生呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注1：&lt;/strong&gt;如果要添加新的快捷方式，还记得之前我们已经将ksqd文件夹的快捷方式放到ksqd文件夹中了，只需要Win+R输入ksqd文件夹的快捷方式就可以打开ksqd文件夹，将要添加的快捷方式放到ksqd文件夹中即可，不需要再修改系统变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注2：&lt;/strong&gt;如果程序名字出现重复，则按照环境变量中的顺序优先打开靠前文件夹中的程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注3：&lt;/strong&gt;win 7系统的Path系统变量打开后是这个界面，与Win10不同，鼠标直接划到最后输入分号加ksqd文件夹路径即可，比如;D:\Program\QuickStart&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729215016379-1348926395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 以上就是去全部内容了，第一次使用博客，希望能给大家带来些帮助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111686/201807/1111686-20180729221304887-1970998467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 29 Jul 2018 14:18:00 +0000</pubDate>
<dc:creator>凉L</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-lyl/p/RunAnything.html</dc:identifier>
</item>
<item>
<title>【JDK源码分析】同步工具Exchanger，它的内部实现原理你看懂了吗？ - 还是搬砖踏实</title>
<link>http://www.cnblogs.com/d-homme/p/9387948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/d-homme/p/9387948.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-3&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;35&quot;&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Exchanger应该算并发包中工具使用相对少的，因为它主要用于线程之间交换数据，它的用法比较简单在不同线程之间使用exchange方法交换数据，但是内部实现比较巧妙，使用了unsafe的CAS原子操作、自旋来解决冲突问题，下面我们通过源码一探究竟。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-4&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32&quot;&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;先看看源码注释中关于核心算法的介绍&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;37.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (slot is empty) { 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot为空时，将item 设置到Node 中                   &lt;/span&gt;
&lt;span&gt;                place item in a Node;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (can CAS slot from empty to node) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当将node通过CAS交换到slot中时，挂起线程等待被唤醒&lt;/span&gt;
                    wait &lt;span&gt;for&lt;/span&gt;&lt;span&gt; release;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被唤醒后返回node中匹配到的item&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; matching item in node;
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (can CAS slot from node to empty) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; release
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将slot设置为空
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取node中的item，将需要交换的数据设置到匹配的item&lt;/span&gt;
&lt;span&gt;                get the item in node;
                set matching item in node;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒等待的线程&lt;/span&gt;
&lt;span&gt;                release waiting thread;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else retry on CAS failure&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如有2条线程A和B，A线程交换数据时，发现slot为空，则将需要交换的数据放在slot中等待其它线程进来交换数据，等线程B进来，读取A设置的数据，然后设置线程B需要交换的数据，然后唤醒A线程，原理就是这么简单。当时当多个线程之间进行交换数据时就会出现问题，所以Exchanger加入了slot数组。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h4 id=&quot;exchanger-属性及构造器&quot;&gt;Exchanger 属性及构造器&lt;/h4&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-7&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于左移Node数组下标，从而得出数据在内存中的偏移量来获取数据，避免伪共享&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ASHIFT = 7&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; note数组最大下标&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MMASK = 0xff&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于递增bound,每次加一个SEQ&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SEQ = MMASK + 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CPU核心数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NCPU =&lt;span&gt; Runtime.getRuntime().availableProcessors();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前数组最大的下标（多处理器情况下）&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FULL = (NCPU &amp;gt;= (MMASK &amp;lt;&amp;lt; 1)) ? MMASK : NCPU &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋次数，CPU核心为1个时，自旋被禁用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SPINS = 1 &amp;lt;&amp;lt; 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空对象，用于当线程exchange方法中参数为null时传递给其他线程的对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object NULL_ITEM = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于超时时传递的对象&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object TIMED_OUT = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Participant 继承了ThreadLocal，也就是说该对象用于获取每条线程中存放的值&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Participant participant;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 多个线程交换&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node[] arena;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于2个线程交换&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; Node slot;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该值主要用于与&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bound; 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过unsafe用于CAS操作&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; sun.misc.Unsafe U;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; BOUND;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; SLOT;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; MATCH;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; BLOCKER;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ABASE;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            U &lt;/span&gt;=&lt;span&gt; sun.misc.Unsafe.getUnsafe();
            Class&lt;/span&gt;&amp;lt;?&amp;gt; ek = Exchanger.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            Class&lt;/span&gt;&amp;lt;?&amp;gt; nk = Node.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            Class&lt;/span&gt;&amp;lt;?&amp;gt; ak = Node[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            Class&lt;/span&gt;&amp;lt;?&amp;gt; tk = Thread.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bound属性在Exchanger对象中的偏移地址&lt;/span&gt;
            BOUND =&lt;span&gt; U.objectFieldOffset
                (ek.getDeclaredField(&lt;/span&gt;&quot;bound&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot属性在Exchanger对象中的偏移地址   &lt;/span&gt;
            SLOT =&lt;span&gt; U.objectFieldOffset
                (ek.getDeclaredField(&lt;/span&gt;&quot;slot&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot属性在Node对象中的偏移地址&lt;/span&gt;
            MATCH =&lt;span&gt; U.objectFieldOffset
                (nk.getDeclaredField(&lt;/span&gt;&quot;match&quot;&lt;span&gt;));
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; parkBlocker属性在Thread对象中的偏移地址&lt;/span&gt;
            BLOCKER =&lt;span&gt; U.objectFieldOffset
                (tk.getDeclaredField(&lt;/span&gt;&quot;parkBlocker&quot;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Node[]数组中每个元素的大小，这里是4&lt;/span&gt;
            s =&lt;span&gt; U.arrayIndexScale(ak);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ABASE absorbs padding in front of element 0
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取Node[]数组中第一个元素的偏移地址 + 128&lt;/span&gt;
            ABASE = U.arrayBaseOffset(ak) + (1 &amp;lt;&amp;lt;&lt;span&gt; ASHIFT);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(e);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s &amp;amp; (s-1)) != 0 || s &amp;gt; (1 &amp;lt;&amp;lt;&lt;span&gt; ASHIFT))
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里是为了保证 Node数组中的元素不会争用一个缓存行&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Unsupported array scale&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h4 id=&quot;构造器及内部类&quot;&gt;构造器及内部类&lt;/h4&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-9&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Exchanger() {
        participant &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Participant();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部类，用于记录每个线程的状态&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Participant &lt;span&gt;extends&lt;/span&gt; ThreadLocal&amp;lt;Node&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Node initialValue() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(); }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 包含需要交换的数据等信息
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Contended为 JDK8 新增的注解，用于避免伪共享，提高程序性能&lt;/span&gt;
    @sun.misc.Contended &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; arana数组中的下标&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上一次记录的bound            &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bound;  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cas操作失败的次数            &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; collides; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于自旋的伪随机数         &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pseudo-random for spins
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前线程需要交换的数据&lt;/span&gt;
        Object item;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This thread's current item
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配线程交换的数据&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; Object match;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Item provided by releasing thread
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录当前挂起的线程&lt;/span&gt;
        &lt;span&gt;volatile&lt;/span&gt; Thread parked; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set to this thread when parked, else null&lt;/span&gt;
    }     
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h4 id=&quot;方法exchange&quot;&gt;方法exchange&lt;/h4&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-11&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;53.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换数据，参数X为本线程提供给其它线程的数据&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; V exchange(V x) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Object v;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当参数为null时需要将item设置为空的对象&lt;/span&gt;
        Object item = (x == &lt;span&gt;null&lt;/span&gt;) ? NULL_ITEM : x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; translate null args
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意到这里的这个表达式是整个方法的核心&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((arena != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
             (v &lt;/span&gt;= slotExchange(item, &lt;span&gt;false&lt;/span&gt;, 0L)) == &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp;&lt;span&gt;
            ((Thread.interrupted() &lt;/span&gt;|| &lt;span&gt;//&lt;/span&gt;&lt;span&gt; disambiguates null return&lt;/span&gt;
              (v = arenaExchange(item, &lt;span&gt;false&lt;/span&gt;, 0L)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (v == NULL_ITEM) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : (V)v;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细看if里的条件表达式，得知： &lt;br/&gt;&lt;span&gt;&lt;code&gt;只有当arena为null时，才会执行slotExchange方法；&lt;/code&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;code&gt;当arena不为null或者(arena为null且slotExchange方法返回null)时，此时线程未中断，才会执行arenaExchange方法;&lt;/code&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;code&gt;线程中断时，就会直接抛出线程中断异常。&lt;/code&gt; &lt;/span&gt;&lt;br/&gt;下面我们来看slotExchange方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed 为true表示设置了超时时间，ns为&amp;gt;0的值，反之没有设置超时时间&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object slotExchange(Object item, &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ns) {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程node对象&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         Node p =&lt;span&gt; participant.get();
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         Thread t =&lt;span&gt; Thread.currentThread();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (t.isInterrupted()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve interrupt status so caller can recheck
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程中断返回null&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Node q;;) {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将slot值赋给q&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((q = slot) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot 不为null，即表示已有线程已经把需要交换的数据设置在slot中了
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过CAS将slot设置成null&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, SLOT, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS操作成功后，将slot中的item赋值给对象v，以便返回。
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里也是就读取之前线程要交换的数据&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;                     Object v =&lt;span&gt; q.item;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前线程需要交给的数据设置在q中的match&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;                     q.match =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取被挂起的线程&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;                     Thread w =&lt;span&gt; q.parked;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (w != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果线程不为null，唤醒它&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;                        U.unpark(w);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回其他线程给的V&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS 操作失败，表示有其它线程竞争，在此线程之前将数据已取走
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; create arena on contention, but continue until slot null&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (NCPU &amp;gt; 1 &amp;amp;&amp;amp; bound == 0 &amp;amp;&amp;amp;
&lt;span&gt; 33&lt;/span&gt;                     U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, BOUND, 0&lt;span&gt;, SEQ))
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CPU为多核心
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; bound == 0 表示arena数组未初始化过，CAS操作bound将其增加SEQ
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化arena数组&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;                     arena = &lt;span&gt;new&lt;/span&gt; Node[(FULL + 2) &amp;lt;&amp;lt;&lt;span&gt; ASHIFT];
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上面分析过，只有当arena才会执行slotExchange方法的
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以表示刚好已有其它线程加入进来将arena初始化&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (arena != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就需要去执行arenaExchange&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; caller must reroute to arenaExchange&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里表示当前线程是以第一个线程进来交换数据
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 或者表示之前的数据交换已进行完毕，这里可以看作是第一个线程
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将需要交换的数据先存放在当前线程变量p中&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;                 p.item =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将需要交换的数据通过CAS设置到交换区slot&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, SLOT, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, p))
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换成功后跳出自旋&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; CAS操作失败，表示有其它线程刚好先于当前线程将数据设置到交换区slot
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前线程变量中的item设置为null，然后自旋获取其它线程存放在交换区slot的数据&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;                 p.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行到这里表示当前线程已将需要的交换的数据放置于交换区slot中了，
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待其它线程交换数据然后唤醒当前线程
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; await release&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; p.hash;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; end = timed ? System.nanoTime() + ns : 0L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋次数&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; spins = (NCPU &amp;gt; 1) ? SPINS : 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        Object v;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋等待直到p.match不为null，也就是说等待其它线程将需要交换的数据放置于交换区slot&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((v = p.match) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面的逻辑主要是自旋等待，直到spins递减到0为止&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (spins &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 h ^= h &amp;lt;&amp;lt; 1; h ^= h &amp;gt;&amp;gt;&amp;gt; 3; h ^= h &amp;lt;&amp;lt; 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (h == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     h = SPINS | (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)t.getId();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (h &amp;lt; 0 &amp;amp;&amp;amp; (--spins &amp;amp; ((SPINS &amp;gt;&amp;gt;&amp;gt; 1) - 1)) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                    Thread.yield();
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; slot 和 p本应该是相等，除非其它线程执行了第16行代码中的CAS操作将slot置为null，
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还未来得及设置match的值，此时只需要自旋等待第21行代码被其它线程执行，
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样p.match才会不为null跳出循环&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (slot !=&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 spins =&lt;span&gt; SPINS;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此处表示未设置超时或者时间未超时&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp; arena == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt; 83&lt;/span&gt;                      (!timed || (ns = end - System.nanoTime()) &amp;gt; 0L&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t被当前对象阻塞&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;                 U.putObject(t, BLOCKER, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给p挂机线程的值赋值&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;                 p.parked =&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (slot ==&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果slot还没有被置为null，也就表示暂未有线程过来交换数据，需要将当前线程挂起&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;                     U.park(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, ns);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程被唤醒，将被挂起的线程设置为null&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                 p.parked = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t未被任何对象阻塞&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;                 U.putObject(t, BLOCKER, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不是以上条件时（可能是arena已不为null或者超时）&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, SLOT, p, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; arena不为null则v为null,其它为超时则v为超市对象TIMED_OUT，并且跳出循环&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;                 v = timed &amp;amp;&amp;amp; ns &amp;lt;= 0L &amp;amp;&amp;amp; !t.isInterrupted() ? TIMED_OUT : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取走match值，并将p中的match置为null&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;         U.putOrderedObject(p, MATCH, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置item为null&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;         p.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         p.hash =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回交换值&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;52.5&quot;&gt;
&lt;p&gt;再来看arenaExchange方法，此方法被执行时表示多个线程进入交换区交换数据，arena数组已被初始化，此方法中的一些处理方式和slotExchange比较类似，它是通过遍历arena数组找到需要交换的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; timed 为true表示设置了超时时间，ns为&amp;gt;0的值，反之没有设置超时时间&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object arenaExchange(Object item, &lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; ns) {
        Node[] a &lt;/span&gt;=&lt;span&gt; arena;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程中的存放的node&lt;/span&gt;
        Node p =&lt;span&gt; participant.get();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index初始值0&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = p.index;;) {                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; access slot at i
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历，如果在数组中找到数据则直接交换并唤醒线程，
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如未找到则将需要交换给其它线程的数据放置于数组中&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; b, m, c; &lt;span&gt;long&lt;/span&gt; j;                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; j is raw array offset
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其实这里就是向右遍历数组，只是用到了元素在内存偏移的偏移量
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; q实际为arena数组偏移(i + 1) *  128个地址位上的node&lt;/span&gt;
            Node q = (Node)U.getObjectVolatile(a, j = (i &amp;lt;&amp;lt; ASHIFT) +&lt;span&gt; ABASE);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果q不为null，并且CAS操作成功，将下标j的元素置为null&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; U.compareAndSwapObject(a, j, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示当前线程已发现有交换的数据，然后获取数据，唤醒等待的线程&lt;/span&gt;
                Object v = q.item;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; release&lt;/span&gt;
                q.match =&lt;span&gt; item;
                Thread w &lt;/span&gt;=&lt;span&gt; q.parked;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (w != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    U.unpark(w);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; q 为null 并且 i 未超过数组边界&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i &amp;lt;= (m = (b = bound) &amp;amp; MMASK) &amp;amp;&amp;amp; q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将需要给其它线程的item赋予给p中的item&lt;/span&gt;
                p.item = item;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; offer&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (U.compareAndSwapObject(a, j, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, p)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换成功&lt;/span&gt;
                    &lt;span&gt;long&lt;/span&gt; end = (timed &amp;amp;&amp;amp; m == 0) ? System.nanoTime() + ns : 0L&lt;span&gt;;
                    Thread t &lt;/span&gt;= Thread.currentThread(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; wait
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自旋直到有其它线程进入，遍历到该元素并与其交换，同时当前线程被唤醒&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; h = p.hash, spins =&lt;span&gt; SPINS;;) {
                        Object v &lt;/span&gt;=&lt;span&gt; p.match;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其它线程设置的需要交换的数据match不为null
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将match设置null,item设置为null&lt;/span&gt;
                            U.putOrderedObject(p, MATCH, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                            p.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear for next use&lt;/span&gt;
                            p.hash =&lt;span&gt; h;
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (spins &amp;gt; 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递减自旋次数&lt;/span&gt;
                            h ^= h &amp;lt;&amp;lt; 1; h ^= h &amp;gt;&amp;gt;&amp;gt; 3; h ^= h &amp;lt;&amp;lt; 10; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; xorshift&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (h == 0)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialize hash&lt;/span&gt;
                                h = SPINS | (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)t.getId();
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (h &amp;lt; 0 &amp;amp;&amp;amp;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; approx 50% true&lt;/span&gt;
                                     (--spins &amp;amp; ((SPINS &amp;gt;&amp;gt;&amp;gt; 1) - 1)) == 0&lt;span&gt;)
                                Thread.yield();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; two yields per wait&lt;/span&gt;
&lt;span&gt;                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.getObjectVolatile(a, j) !=&lt;span&gt; p)
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 和slotExchange方法中的类似，arena数组中的数据已被CAS设置
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; match值还未设置，让其再自旋会等待match被设置&lt;/span&gt;
                            spins = SPINS;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; releaser hasn't set match yet&lt;/span&gt;
                        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!t.isInterrupted() &amp;amp;&amp;amp; m == 0 &amp;amp;&amp;amp;&lt;span&gt;
                                 (&lt;/span&gt;!timed ||&lt;span&gt;
                                  (ns &lt;/span&gt;= end - System.nanoTime()) &amp;gt; 0L&lt;span&gt;)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t被当前对象阻塞&lt;/span&gt;
                            U.putObject(t, BLOCKER, &lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; emulate LockSupport
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程t赋值&lt;/span&gt;
                            p.parked = t;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; minimize window&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (U.getObjectVolatile(a, j) ==&lt;span&gt; p)
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组中对象还相等，表示线程还未被唤醒，唤醒线程&lt;/span&gt;
                                U.park(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, ns);
                            p.parked &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程t未被任何对象阻塞&lt;/span&gt;
                            U.putObject(t, BLOCKER, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (U.getObjectVolatile(a, j) == p &amp;amp;&amp;amp;&lt;span&gt;
                                 U.compareAndSwapObject(a, j, p, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里给bound增加加一个SEQ&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (m != 0)                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; try to shrink&lt;/span&gt;
                                U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, BOUND, b, b + SEQ - 1&lt;span&gt;);
                            p.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            p.hash &lt;/span&gt;=&lt;span&gt; h;
                            i &lt;/span&gt;= p.index &amp;gt;&amp;gt;&amp;gt;= 1;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; descend&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timed &amp;amp;&amp;amp; m == 0 &amp;amp;&amp;amp; ns &amp;lt;= 0L&lt;span&gt;)
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TIMED_OUT;
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; expired; restart&lt;/span&gt;
&lt;span&gt;                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 交换失败，表示有其它线程更改了arena数组中下标i的元素&lt;/span&gt;
                    p.item = &lt;span&gt;null&lt;/span&gt;;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; clear offer&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时表示下标不在bound &amp;amp; MMASK或q不为null但CAS操作失败
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要更新bound变化后的值&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (p.bound != b) {                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; stale; reset&lt;/span&gt;
                    p.bound =&lt;span&gt; b;
                    p.collides &lt;/span&gt;= 0&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向遍历&lt;/span&gt;
                    i = (i != m || m == 0) ? m : m - 1&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((c = p.collides) &amp;lt; m || m == FULL ||
                         !U.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, BOUND, b, b + SEQ + 1&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录CAS失败的次数&lt;/span&gt;
                    p.collides = c + 1&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历&lt;/span&gt;
                    i = (i == 0) ? m : i - 1;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cyclically traverse&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时表示bound值增加了SEQ+1&lt;/span&gt;
                    i = m + 1;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; grow
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下标&lt;/span&gt;
                p.index =&lt;span&gt; i;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-1093&quot; class=&quot;wmd-preview-section preview-content markdown_views&quot; readability=&quot;32.01246882793&quot;&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;读到这里是不是还是感觉有很多疑问？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先看为什么&lt;code&gt;ASHIFT&lt;/code&gt;设置成7，这是为了尽量避免slot数组中不同的元素在同一个缓存行上，&lt;code&gt;&amp;lt;&amp;lt; ASHIFT&lt;/code&gt; 左移7位，表示至少移动了128地址位，而我们主流的缓存行大小一般为32字节到256字节，所以128个地址位基本覆盖到了常见的处理器平台。arena数组中元素的分布如图，它们之间间隔128个整数倍地址位，也就是说最小相差128个地址位。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20180729212029513?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2lmdWNraW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;arena数组&quot;/&gt;&lt;/li&gt;
&lt;li&gt;为什么Node类用&lt;code&gt;@sun.misc.Contended&lt;/code&gt;注解呢？该注解是jdk8新增的注解，是为了解决之前手动填充数据的问题。填充数据也是为了避免arena数组中的不同的元素共享同一个缓存行，导致多线程修改数据时性能受到影响。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;1.5714285714286&quot;&gt;
&lt;p&gt;参考： &lt;br/&gt;&lt;a href=&quot;http://ifeve.com/falsesharing/&quot;&gt;伪共享(False Sharing)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 29 Jul 2018 14:17:00 +0000</pubDate>
<dc:creator>还是搬砖踏实</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/d-homme/p/9387948.html</dc:identifier>
</item>
</channel>
</rss>