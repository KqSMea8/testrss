<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaScript观察者模式 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7702381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7702381.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;观察者模式&lt;br/&gt;&lt;/strong&gt;观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;* 它分为2个角色：（1）&lt;/span&gt;&lt;span&gt;观察者  （2）被观察者&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;* 观察者模式的目的：对程序的内在变化进行观察,当其有变化的时候，&lt;/span&gt;&lt;span&gt;你可以得知,并且可以做出相应的反应。&lt;br/&gt;现在我们通过一个需求来学习该模式：&lt;/span&gt;&lt;span&gt;模拟订阅者和报社之间的关系&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;在这个过程中：&lt;/span&gt;&lt;span&gt;实际的操作分为(推模式,拿模式)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;（1）推送--&amp;gt;长连接技术&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）拿模式--&amp;gt;定时去后台去取得&lt;br/&gt;使用代码实现如下：&lt;br/&gt;（1）发布类&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布类&lt;/span&gt;
&lt;span&gt;function BusinessOne(name){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅者集合&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.subscribers=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）扩展一个发布者的发布消息的方法（推模式）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布者的发送消息的方法(推模式)&lt;/span&gt;
BusinessOne.prototype.delive=&lt;span&gt;function (news) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给每一个订阅者发布消息&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscribers.forEach(function (fn) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用接受者处理信息的函数&lt;/span&gt;
&lt;span&gt;                  fn(news,self);
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）扩展公共订阅的函数,和取消订阅的函数&lt;/p&gt;
&lt;p&gt;订阅的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Function.prototype.subscribe=&lt;span&gt;function (publisher) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;some 访问数组度i型并且以参数的形式传回回调函数中
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要至少有一次返回是true那么some就是true&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; alreadyExists=&lt;span&gt;publisher.subscribers.some(function (el) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(el==&lt;span&gt;that){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理不能重复订阅的功能&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
        }
    });
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没用订阅你就可以订阅&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;alreadyExists){
        publisher.subscribers.push(that);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;取消的函数：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Function.prototype.unsubscribe =&lt;span&gt;function (publisher) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    publisher.subscribers&lt;/span&gt;=publisher.subscribers.filter(function (el) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤的实质是返回除开与当前对象相等的其余所用的对象集合&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(el!==&lt;span&gt;that){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; el;
        }
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt;（4）创建发布的实例&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建发布者的实例&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; b1 = &lt;span&gt;new&lt;/span&gt; BusinessOne(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CCTV&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b2 = &lt;span&gt;new&lt;/span&gt; BusinessOne(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中国国防部报社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）发布部分&lt;/p&gt;
&lt;p&gt;（5.1）使用门面模式--针对各浏览器的事件绑定兼容问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function addEventFacade(el,type,fn) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.addEventListener){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;firefox&lt;/span&gt;
&lt;span&gt;        el.addEventListener(type,fn);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(window.attachEvent){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用是IE&lt;/span&gt;
       el.attachEvent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;type,fn);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        el[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+type] =&lt;span&gt; fn;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5.2）创建主应用函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; inint=&lt;span&gt;function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建观察者&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; pageOne=&lt;span&gt;function (news) {
        document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我发现了： &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+arguments[&lt;span&gt;1&lt;/span&gt;].name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]发来的信息---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;news
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订阅1&lt;/span&gt;
&lt;span&gt;    pageOne.subscribe(b1).subscribe(b2);
    addEventFacade(document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cctv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,function () {
        b1.delive(document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cctvText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value);
    })
    //订阅2
    addEventFacade(document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gfb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,function () {
        b2.delive(document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gfbText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).value);
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，订阅者界面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;body onload=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inint()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;div01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;observer.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CCTV发送&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cctv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cctvText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;国防部报社发送&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gfb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gfbText&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&amp;lt;textarea id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; cols=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; rows=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/textarea&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Js/设计模式第三部分/观察者模式/lib.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Js/设计模式第三部分/观察者模式/观察者模式.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果为：&lt;/p&gt;
&lt;p&gt;（1）cctv模块的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171020232806646-1042858986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; （2）gfb的效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171020232841677-590940682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;补充：上述用到的forEach方法和filter方法代码为：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    Function.prototype.method =&lt;span&gt; function(name, fn) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prototype[name] =&lt;span&gt; fn;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    };
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Array.prototype.forEach) { 
      Array.method(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;forEach&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function(fn, thisObj) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scope = thisObj ||&lt;span&gt; window;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;len &amp;lt; &lt;span&gt;this&lt;/span&gt;.length; ++&lt;span&gt;i ) {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样写不是简单的函数调用,是在函数调用的同事把this重新定位&lt;/span&gt;
           fn.call(scope, &lt;span&gt;this&lt;/span&gt;[i], i, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
      });
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Array过滤器&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Array.prototype.filter ) {
      Array.method(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function(fn, thisObj) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scope = thisObj ||&lt;span&gt; window;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; &lt;span&gt;this&lt;/span&gt;.length; ++&lt;span&gt;i ) {
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;看看过滤函数,真留下来,假的删除&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; ( !fn.call(scope, &lt;span&gt;this&lt;/span&gt;[i], i, &lt;span&gt;this&lt;/span&gt;) ) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤的实质是返回除开与当前对象相等的其余所用的对象集合&lt;/span&gt;
                   &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
              }
              a.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[i]);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回新的数组&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
      });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/860581/201710/860581-20171020233721521-1217350494.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.支持简单的广播通信，自动通知所有的监听者。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.当页面载入后，被观察对象很容易与观察者有一种动态关联的关系，来增加灵活性。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.被观察对象，与观察者之间的抽象耦合关系能够单独的扩展和重用。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span/&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 20 Oct 2017 15:34:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7702381.html</dc:identifier>
</item>
<item>
<title>简说chart2.4的应用，以及Uncaught ReferenceError : require is not defined的解决 - 君无药</title>
<link>http://www.cnblogs.com/junwuyao/p/7702210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junwuyao/p/7702210.html</guid>
<description>&lt;p&gt;&lt;span&gt;  　　51呢最近在学习chart.js，然后呢就照着中文的帮助文档来然后就一直出Uncaught ReferenceError : require is not defined的问题查了挺多才知道是帮助文档跟chat.js不匹配的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　chart.js是分1.x和2.x版本的最新的版本是2.7.0，大家github下包的时候别下master分支包，下tags里的。然后引入的时候别引入src下的chart.js ，会报Uncaught ReferenceError : require is not defined 的错误。。，dist目录才是发布目录。。搞了半天，浪费时间。而且1.x和2.x的用法和options不一样，这里我主要调的2.x的版本。后面应用的主要是2.x版本的chart。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中文帮主文档呢，是1.11版本的下面是链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.bootcss.com/p/chart.js/docs/&quot; target=&quot;_blank&quot;&gt;http://www.bootcss.com/p/chart.js/docs/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对应的1.11的chart&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/chartjs/Chart.js/tags?after=v2.0.1&quot; target=&quot;_blank&quot;&gt;https://github.com/chartjs/Chart.js/tags?after=v2.0.1&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020221753146-1885263744.png&quot; alt=&quot;&quot; width=&quot;1026&quot; height=&quot;323&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是2.x的帮助文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.chartjs.org/docs/latest/general/interactions/events.html&quot; target=&quot;_blank&quot;&gt;http://www.chartjs.org/docs/latest/general/interactions/events.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是chart的链接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/chartjs/Chart.js/tags&quot; target=&quot;_blank&quot;&gt;https://github.com/chartjs/Chart.js/tags&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020222259631-952379103.png&quot; alt=&quot;&quot; width=&quot;1114&quot; height=&quot;713&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.x的链接打开后就是上面的样子箭头指的就是最新版本的chart，注意一定要是红框圈起来的，然后后面翻页能找到1.11版本的chart&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;又碰到两个问题,一个是图表适用retina屏的设置如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; myChart = echarts.init(document.getElementById('radar'&lt;span&gt;),{
devicePixelRatio: &lt;/span&gt;5 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;devicePixelRatio是指设备的像素比，简单来说就是设备物理像素和独立像素的比例，应该是比例越高图像越清晰&lt;/span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过这个设置用在PDF里还是不能高清显示，换了一种方式将图表转换成高分辨率的图片放到PDF里，问题解决了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Image();
img.src &lt;/span&gt;=&lt;span&gt; myChart.getDataURL({
　　pixelRatio: &lt;/span&gt;5,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片像素比&lt;/span&gt;
　　backgroundColor: '#fff'&lt;span&gt;
});
$(&lt;/span&gt;&quot;#radar&quot;).html(&quot;&quot;&lt;span&gt;).prepend(img);
$(&lt;/span&gt;&quot;#radar img&quot;).css({&quot;width&quot;:&quot;414px&quot;,&quot;height&quot;:&quot;300px&quot;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体用法如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 先是chart1.11的 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;110&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;chart.js 1.x&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/chart.1.11.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 展示canvas &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width:500px;height:500px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myChart&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; radarChartData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; { 
        labels: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JQuery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AngelaJS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;voe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;], 
        datasets: [ 
            { 
                label: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, 
                fillColor: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(0,55,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                strokeColor: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(66,0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                pointColor: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(255,0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                pointStrokeColor: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(0,0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                pointHighlightFill: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(0,0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                pointHighlightStroke: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(0,0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                data: [&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;&lt;span&gt;]
            }
        ]
    }; 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; options &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {  
                  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Boolean - If we show the scale above the chart data             &lt;/span&gt;
&lt;span&gt;    scaleOverlay : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Boolean - If we want to override with a hard coded scale  &lt;/span&gt;
&lt;span&gt;    scaleOverride : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;** Required if scaleOverride is true **  &lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Number - The number of steps in a hard coded scale  &lt;/span&gt;
&lt;span&gt;    scaleSteps : &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Number - The value jump in the hard coded scale  &lt;/span&gt;
&lt;span&gt;    scaleStepWidth : &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Y 轴的起始值  &lt;/span&gt;
&lt;span&gt;    scaleStartValue : &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Y/X轴的颜色  &lt;/span&gt;
&lt;span&gt;    scaleLineColor : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(0,0,0,.1)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; X,Y轴的宽度  &lt;/span&gt;
&lt;span&gt;    scaleLineWidth : &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刻度是否显示标签, 即Y轴上是否显示文字  &lt;/span&gt;
&lt;span&gt;    scaleShowLabels : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Y轴上的刻度,即文字  &lt;/span&gt;
&lt;span&gt;    scaleLabel : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;%=value%&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字体  &lt;/span&gt;
&lt;span&gt;    scaleFontFamily : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'Arial'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字大小  &lt;/span&gt;
&lt;span&gt;    scaleFontSize : &lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字样式  &lt;/span&gt;
&lt;span&gt;    scaleFontStyle : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;normal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文字颜色  &lt;/span&gt;
&lt;span&gt;    scaleFontColor : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#666&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,      
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示网格  &lt;/span&gt;
&lt;span&gt;    scaleShowGridLines : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 网格颜色  &lt;/span&gt;
&lt;span&gt;    scaleGridLineColor : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rgba(0,0,0,.05)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 网格宽度  &lt;/span&gt;
&lt;span&gt;    scaleGridLineWidth : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,   
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否使用贝塞尔曲线? 即:线条是否弯曲  &lt;/span&gt;
&lt;span&gt;    bezierCurve : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否显示点数  &lt;/span&gt;
&lt;span&gt;    pointDot : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 圆点的大小  &lt;/span&gt;
&lt;span&gt;    pointDotRadius : &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 圆点的笔触宽度, 即:圆点外层白色大小  &lt;/span&gt;
&lt;span&gt;    pointDotStrokeWidth : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据集行程  &lt;/span&gt;
&lt;span&gt;    datasetStroke : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线条的宽度, 即:数据集  &lt;/span&gt;
&lt;span&gt;    datasetStrokeWidth : &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否填充数据集  &lt;/span&gt;
&lt;span&gt;    datasetFill : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否执行动画  &lt;/span&gt;
&lt;span&gt;    animation : &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画的时间  &lt;/span&gt;
&lt;span&gt;    animationSteps : &lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;,  
      
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画的特效  &lt;/span&gt;
&lt;span&gt;    animationEasing : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;easeOutQuart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   
}  
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; myLine &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chart(document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myChart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).getContext(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)).Radar(radarChartData, options);
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020223604646-447489281.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是chart2.x的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;chart.js 2.x&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 展示canvas &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;width:500px;height:500px;&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;radar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;canvas &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myChart&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;canvas&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入 chartjs&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/chart.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/Chart.bundle.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置数据和参数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; radarChartData &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; { 
        labels: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PHP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;JQuery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AngelaJS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;voe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;], 
        datasets: [ 
            { 
                pointBorderColor:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#CF64A7&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;描点颜色&lt;/span&gt;
&lt;span&gt;                pointBackgroundColor:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;描点背景颜色&lt;/span&gt;
&lt;span&gt;                borderColor:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#C06700&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画线颜色&lt;/span&gt;
&lt;span&gt;                data: [&lt;/span&gt;&lt;span&gt;95&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;&lt;span&gt;]
            }
        ]
        
    };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置选项&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; options &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
        legend:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据项&lt;/span&gt;
&lt;span&gt;        scale: {
            ticks: {
                beginAtZero: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                stepSize:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴间隔&lt;/span&gt;
&lt;span&gt;                max:&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴最大值&lt;/span&gt;
&lt;span&gt;                min:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
                callback:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) { &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Y轴格式化&lt;/span&gt;
&lt;span&gt;            },
            angleLines:{
                display:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;雷达辐射轴                &lt;/span&gt;
&lt;span&gt;            },
            pointLabels:{
                fontSize:&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴文字&lt;/span&gt;
&lt;span&gt;            },
            
        },
        animation:{
            onComplete:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;radar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;img src='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; myBarChart.toBase64Image() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' /&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; ctx &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myChart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).getContext(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; myBarChart &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chart(ctx, {type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;radar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,data: radarChartData,options:options});
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020223547927-1001564124.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面的是雷达的图表，下面的是线型的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020224229756-1183213532.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是圆形的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020224512959-272414215.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是柱状图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020224620631-1244798108.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有前面的雷达作为例子后面的就好说了，把下面的类型改一改就可以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1175540/201710/1175540-20171020225145943-2004553422.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要把圈起来的改为line或者polarArea或者scatter就能够出对应的图表。其实chart.js还是挺简单的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要还是要注意到chart.js是否与帮助文档匹配的问题。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 14:59:00 +0000</pubDate>
<dc:creator>君无药</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/junwuyao/p/7702210.html</dc:identifier>
</item>
<item>
<title>shell编程/字库裁剪(1) - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/7679024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/7679024.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/7679024.html 

　　作者：窗户

　　QQ：&lt;span&gt;6679072&lt;/span&gt;

　　E-mail：&lt;span&gt;6679072@qq.com
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我写这个帖子的意图，在于三个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.用代码生成代码的思维。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.shell编程的思路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.裁剪字库的具体程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我打算分为三节来说：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一节讲裁剪词库的意义以及使用场合；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二节讲如何用shell来解决这个问题；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三节讲如何测试结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　很多带有点阵液晶的硬件项目可能需要显示汉字、ASCII字符，有的廉价的液晶里没有字库，有的液晶里带有了字库但可能需要其他字体的支持。这种时候我们就需要使用外置的字库了。一般一个字库需要几百K大小，当然对于有外置flash的情况下根本不算什么，但有些时候我们在设计硬件的时候出于硬件成本、PCB尺寸等因素考虑，并不会采用外部存储，现在的嵌入式处理器公司都会在SOC上给一定的flash，足够你正常的编程使用，比如我们熟悉的STM32系列，它由ST公司(意法半导体)出品的基于ARM的SOC，有着自己的相对统一的开发库，可选器件品类繁多，是裸机运行的首选。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SOC上的flash一般尺寸相对很小，几百K的字库很可能超标，甚至本身就没这么大。那么在这种情况下，如果还想使用字库，只好对字库进行裁剪，这也是笔者这个主题的背景情况。当然，也会有FPGA来控制液晶、VGA等情况的时候也需要裁剪字库，但不在我这个的考虑范围内，我这个题材只是针对C语言编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来试想一下，对于ASCII码，即便是16X8的字库，总共也就2k不到，基本可以完全忍受下来，所以主要考虑裁剪的是汉字。如果是完整的汉字字库，那么显示汉字可以直接根据GB2312码来算出二进制编码，这个可以在baidu里面搜索GB2312字库的偏移，里面可以查到很多文章可以说明GB2312字库的偏移，细节不在这里讨论。&lt;/span&gt;&lt;span&gt;直接写结果，GB2312的编码为两个字节，假设某个汉字的GB2312编码第一个字节为GBH，第二个字节为GBL，并且每个汉字字体在字库中的大小为s，那么这个汉字在字库中的偏移为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　offset = [ (GBH - 161) * 94 + (GBL - 161) ] * s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般使用的是16X16字库，那么s=16*16/8=32，当然也有使用其他大小，比如12X12，那么s=12*12/8=18。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果要用到繁体字，那么可以采用GBK编码和GBK字库，公式类似，本文只考虑GB2312。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在具体应用中，可以对于所有使用的汉字按照编码大小顺序提取，生成一个数组；然后有两种解决方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.&lt;/span&gt;&lt;span&gt;再建立一个所使用汉字编码大小顺序的有序数组，在寻找汉字字体的时候采用二分查找法找到汉字编码在数组中的偏移ofs，从而知道所选字体在字体数组中的偏移ofs/2*s。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.把程序中的汉字都替换成偏移，这可以换来更快的运行速度(虽然只快了那么微小的一点点)和更快的存储，但最后是以牺牲程序可读性为前提的，所以一般情况下不建议如此，代码不仅仅是给机器读也是要给人读的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 14:33:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/7679024.html</dc:identifier>
</item>
<item>
<title>Ubuntu配置OpenStack 一：主机环境配置以及问题总结 - Skylar-Giver</title>
<link>http://www.cnblogs.com/skylarzhan/p/7702078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skylarzhan/p/7702078.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文包含openstack配置的实验环境的基本步骤。在下面的步骤中将逐步讲解如何操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、准备三台虚拟机&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主机名字分别命名为controller、network、computer【desktop版或者server版都可以】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从网上了解到配置三台虚拟机的网络结点的配置各不同。controller只需要配置一个，network和computer需要配置三个，而且network中有一个结点是链接外部网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的操作都是在desktop版的虚拟机中的terminal操作，在server版中同样使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、准备安装ssh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：apt-get install ssh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记得要进入root用户：1、sudo su 后输入密码  或 2、sudo pw  root  后要输入三次密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020215732724-1973677784.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、ifconfig查看IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：ifconfig&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220518912-2111553479.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220531584-67328034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220539006-835623622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、更改主机名字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：vi /etc/hostname    输入后按   esc : wq!   退出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220558677-1756092107.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220608287-1588225386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220618943-446875402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、修改主机环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：vi /etc/network/interfaces   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220659177-928798038.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220716802-725072637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220726318-1873792902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 三台机器同时输入:reboot重启。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入： vi /etc/hosts  (三台都要注释掉本机的Ip地址【原先在localhost下面有127.0.1.1 computer，这个是要删除掉或者注释掉的】，再输入下面的三个IP地址加名字【三台都要输入这面的三个IP地址】) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020220750474-1344980697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、查看修改后的ip&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：ifconfig&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221221412-1258556528.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221211615-296662377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221228959-1676041808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、检查网络是否连通&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为三个都是一样的，所以我就只展示一个来示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入：ping ubuntu-cloud.archive.canonical.com（看到输出后记得按ctrl+c来停止）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221247896-612458239.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;输入：ping controller&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221256162-1262530092.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;输入：ping network&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221303193-1166973673.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;输入：ping computer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1008459/201710/1008459-20171020221315521-1838644938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、问题总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）注意“/”，一开始在修改主机名字的时候，使用vi etc/hostname ，这里缺少了一个“/”，使得我每次修改主机名字都不成功。正确使用是 vi /etc/hostname&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）操作时总觉得不能输入，这时候就要无比耐心了，先输入 i ,然后再按你想要的数字，多按几次，如果你想要删除，直接用delete，我发现每次用back space只是光标移动而已，所以删除就用delete。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）:wq!  这个注意了，一定要用半角。如果你用server版的话可以用英文版的，server版都是黑黑一片，没啥你需要看的。也可以用中文的，但是你输入结束时要记得切换到半角，不然保存不了的。你可以先暂停下进程ctrl+z，然后vi /etc/default/locale 修改下输入法。链接参考 http://blog.chinaunix.net/uid-26495963-id-3064653.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）配置主机环境：先查看你本身自带的ifconfig，然后修改最后一个为基准，对IP地址进行修改，比如我的是192.168.17.129开始，逐渐递增130，131，132，133。网关要查看一下，使用nm-tool。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）想要快速便捷，能使用复制粘贴的话，可以使用secureCRT。下载SSH就是为能够接连它进行快速操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;附加破解版网址：链接：http://pan.baidu.com/s/1c1N0GZQ 密码：qs5x&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Oct 2017 14:30:00 +0000</pubDate>
<dc:creator>Skylar-Giver</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skylarzhan/p/7702078.html</dc:identifier>
</item>
<item>
<title>在SQL Server中实现关系模型的阶梯到级别3的t -SQL DML - 701</title>
<link>http://www.cnblogs.com/lzy35/p/7701979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzy35/p/7701979.html</guid>
<description>&lt;p class=&quot;tgt&quot;&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;strong&gt;SQL Server&lt;/strong&gt;&lt;strong&gt;中实现关系模型的阶梯到级别&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;的&lt;/strong&gt;&lt;strong&gt;t -SQL DML&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;格雷戈里·拉森(Gregory Larsen)，2017/08/02(第一次出版:2011 /11/09)&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;原文链接：&lt;a href=&quot;http://www.sqlservercentral.com/articles/Stairway+Series/75775/&quot;&gt;http://www.sqlservercentral.com/articles/Stairway+Series/75775/&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;strong&gt;该系列&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;本文是系列的一部分：T-SQL的进阶&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;这个进阶将为您提供一个基本的理解，即如何使用SQL Server的transact - SQL(t - SQL)方言对SQL Server表中的数据进行处理。DML是数据操纵语言，是处理数据的语言的方面。它包括语句选择、插入、更新和删除。这个楼梯也将提供一些SQL语言的历史和一些关于集合理论的一般概念。每个级别都将建立在之前的级别上，因此，当您完成这些工作时，您将很好地理解如何从SQL Server中选择和修改数据。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;在这个楼梯的前一级，我提供了关于SQL的基本选择语句和历史的信息。这些级别为您提供了理解如何检索数据以及SQL环境如何随着技术和技术解决方案发生变化而变化的基础。在这个级别，我将探索如何实现基于关系模型的简单SQL Server数据库。在开始创建数据库之前，首先让我介绍一下关系模型的创建者的一些历史。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;strong&gt;关系数据建模之父&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;关系数据库设计的概念最初是由Edgar f . Codd在1970年提出的，论文标题为“大型共享数据银行的数据关系模型”。Codd在IBM工作时开发了这种建模理论。IBM在Codd的数据建模概念上跳得不够快，因此并不是第一个供应关系数据库引擎的供应商，它利用了Codd的新关系数据建模理论。Codd的关系建模概念现在是用来在SQL Server和其他关系数据库引擎中创建关系数据库的框架。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;Codd出生于英格兰的波特兰岛，在加入皇家空军之前学习了数学和化学，成为了第二次世界大战的飞行员。1948年，他搬到纽约，开始在IBM工作，在那里他是一名数学程序员。他漂流了好几年，最终搬到加州，在IBM圣何塞研究实验室工作。直到20世纪90年代，当他的健康状况不佳迫使他退休时，Codd继续努力完善并证明了关系数据模型的合理性。 Edgar F. Codd 于2003年4月18日去世，享年79岁。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;strong&gt;在&lt;/strong&gt;&lt;strong&gt;SQL Server&lt;/strong&gt;&lt;strong&gt;中实现关系模型&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;这个楼梯不是用来教你关系数据建模，或数据库设计，而是教你如何从一个关系模型创建一个SQL Server数据库。但是在我为创建SQL Server数据库提供代码块之前，我们首先需要探索一个将被实现的关系数据模型。我的简单模型将包含一些实体(数据表)，其中有主键定义和不同实体之间的一些关系(外键约束)。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;我的简单的关系模型将是一个简单的酒店预订系统。这个预订系统需要跟踪客户预订信息。图1说明了这个简单的关系模型，我将使用t - sql实现它:&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020220938599-1087588245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;tgt&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;图1:一个简单的关系数据库模型，由6个表组成&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;通过回顾这个模型，您可以看到它包含许多实体(由方框表示)来跟踪预订相关信息。每个实体都由一些属性(列)组成，其中一个或多个属性被标识为主键(粗体和下划线的名称)。也表示实体之间的一些关系(以箭头表示)，以显示不同的实体之间是如何相互关联的。我将使用实体、属性、主键和关系的模型，然后开发一个物理SQL Server数据库，它表示此关系模型的设计。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;要从这个模型构建物理数据库，我们需要在SQL Server中识别基于此模型定义的不同对象。对于图1中的每个实体或框，我将在SQL Server中创建一个表。对于每个实体的每个属性，我将在关联的表中创建一个列。对于每个主键，我将创建一个唯一的集群索引(注意，使用唯一的非聚集索引也可以创建主键)。更多信息索引参考索引在http://www.sqlservercentral.com/stairway/72399/上楼梯)。最后，对于每个关系，我将创建一个外键约束。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;要开始构建我的数据库，我首先需要创建一个SQL Server数据库来保存我计划创建的所有新数据库对象。我的数据库将被称为房间预订。我将使用以下的t - sql代码创建我的数据库:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221048334-132431958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要从我的模型中开始构建我的房间预订数据库对象，我将创建表对象。要在SQL服务器中创建表，我需要使用create table语句。使用CREATE TABLE语句，我将能够定义每个表和每个表中的所有列。下面是创建SQL Server表的简单语法:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221104646-530556399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;地点:&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&amp;lt;table_name&amp;gt; =表名&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&amp;lt;column_definition&amp;gt; = column_name data_type[NULL | NOT NULL]&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;对于CREATE TABLE语句的完整语法，请参见联机的SQL Server Books。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;我创建的第一个表将是Customer表，它是使用清单1中的代码创建的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221129006-409795918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单1:创建Customer表&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;在这段代码中，当我创建我的Customer表时，我创建了我需要的所有列，但我还指定了在插入或更新记录时，该列是否需要一个值。我通过在某些列上指定NOT NULL来实现这一点，而其他列则指定为NULL。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;如果一个列被定义为不为空，那意味着你不能创建一个记录，除非你用一个实际值填充这个列。而使用NULL规范定义一个列意味着您可以创建一行，而不必为这个列指定一个值，或者另一种方法是，该列允许空值。在上面的CREATE TABLE语句中，我允许columns Address2和EmailAddress支持NULLs，而其余的列都需要在创建行时提供一个值。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;这个CREATE TABLE语句并没有完全定义我的Customer表，因为它在上面的关系数据库模型中表示。我仍然需要在列CustomerID上创建一个主键约束。这个主键约束将确保该表中没有两个记录具有相同的CustomerID值。创建主键的代码如清单2所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221143552-573676368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单2:向Customer表添加主键约束&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;这个ALTER TABLE语句为我的Customer表添加了一个主键约束。主键将以集群索引PK_Customer的形式创建。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;在transact - sql语言中，通常有不止一种方法可以做同样的事情。或者，通过运行清单3中的CREATE table语句，我可以一次性创建客户表和主键。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221243006-971458338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单3:用主键创建Customer表的另一种方法&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;在这一点上，我已经向您展示了如何创建带有定义主键的表。剩下要展示的是如何创建外键约束。但在此之前，先让我先给您提供一个脚本，以在上面的关系数据库模型中创建其余的表和主键。您可以在清单4中找到它。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221301052-1608773124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221338365-831127963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单4:创建额外的表和主键约束&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;一个外键约束在两个相互关联的表之间强制引用完整性。外键约束定义的表是“引用表”，需要在另一个表中有相关的记录，称为“引用”表，任何时候在表中插入或更新一行。在图1的关系模型中，这些外键关系由箭头表示。外键约束只在关系中的一个表上定义。在我的图表中，外键约束将定义在具有箭头尾部(无尖端)的那些表上。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;为了在关系模型中定义这些外键约束，我需要修改每个引用表来添加约束。清单5是我可以用来在保留表上创建外键约束的t - sql代码。这个约束确保记录不会被插入或更新到预订表中，除非在Customer表中基于CustomerId找到匹配的记录。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221358021-1124861223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单5:在引用Customer表的预订表上创建一个外键约束&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;为了完成我的设计，我需要实现图1中模型中所标识的所有其他外键constUNK。清单6包含ALTER TABLE语句，用以在我的数据模型中创建额外的外键约束。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221411584-230100337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单6:创建额外的外键限制&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;验证数据库设计&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;一旦我完成了从数据模型构建数据库的工作，我应该验证所实现的设计，以确保它是正确的。这个验证过程是确保我在物理数据库中构建的所有数据完整性规则都正确地实现了。在我的设计中，我需要验证这些规则&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;﹒所有插入或更新的行必须对定义为NOT NULL的列有一个特定的值。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;﹒主键的列不允许重复的值&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;﹒具有外键const晕倒的列不允许在引用表中没有匹配记录的数据&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;在验证数据完整性规则之前，我首先需要用一些有效数据填充引用的表。我将使用清单7中的代码来填充那些有一些有效数据的表:&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221437224-985709778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单7:插入初始数据&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;为了验证我在数据库中构建的数据完整性规则，我将运行清单8中的INSERT语句。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221451802-1901336715.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;清单8:用INSERT语句测试各种约束&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;这些INSERT语句中的每一个都应该失败，因为它们违反了构建在RoomReservation数据库中的数据完整性规则。第一个INSERT语句违反了预订规则列的非空验证检查。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;第二个INSERT语句违反了放在RoomType表上的主键约束。这个INSERT语句试图为RoomTypeID列插入3的值。问题是在RoomType值为3的RoomType表中已经有了记录。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;最后一个INSERT语句违反了CustomerPaymentType表的外键约束。在这个特殊的INSERT语句中，Customer表中没有CustomerID值为2的值。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;要正确地插入这些记录，插入的数据值需要清理。一旦数据被清理干净，我就可以将这些新数据插入到合适的表中。清单9包含清除所有数据完整性检查并成功插入到房间预订数据库中的适当表的清理INSERT语句:&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1241987/201710/1241987-20171020221511490-1602692454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;strong&gt;关系数据库设计&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;我的预订示例演示了如何使用关系模型并使用它来实现SQL Server数据库。通过使用非NULL、主键和外键constUNK，我将数据完整性规则构建到数据库设计中。这允许我在底层数据库定义中执行这些规则，而不必在业务处理层中编写代码来验证这些数据规则。通过这样做，我允许SQL Server数据库引擎为我执行这些数据完整性检查。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;通过了解并在关系数据库模型周围创建数据库设计，您将构建一个健壮且高效的数据库实现，您可以在数据库中构建数据完整性检查。&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;这篇文章是t - sql DML进阶的一部分&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;注册到我们的RSS频道，一旦我们在阶梯上发布一个新的级别，就会得到通知!&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_46135&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 14:16:00 +0000</pubDate>
<dc:creator>701</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzy35/p/7701979.html</dc:identifier>
</item>
<item>
<title>基于连通性状态压缩的动态规划问题 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html</guid>
<description>&lt;p&gt;基于状态压缩的动态规划问题是一类以集合信息为状态且状态总数为指数级的特殊的动态规划问题．在状态压缩的基础上，有一类问题的状态中必须要记录若干个元素的连通情况，我们称这样的问题为基于连通性状态压缩的动态规划问题，本文着重对这类问题的解法及优化进行探讨和研究．&lt;/p&gt;
&lt;p&gt;本文主要从动态规划的几个步骤——划分阶段，确立状态，状态转移以及程序实现来介绍这类问题的一般解法，会特别针对到目前为止信息学竞赛中涌现出来的几类题型的解法作一个探讨．结合例题，本文还会介绍作者在减少状态总数和降低转移开销两个方面对这类问题优化的一些心得．总结自&lt;a href=&quot;https://wenku.baidu.com/view/4fe4ac659b6648d7c1c74633.html&quot; target=&quot;_blank&quot;&gt;CDQ论文&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;序言&lt;/h2&gt;
&lt;p&gt;先看一个非常经典的问题——旅行商问题(即TSP问题，Traveling Salesman Problem)：一个&lt;em&gt;n&lt;/em&gt;(&lt;em&gt;≤&lt;/em&gt;15)个点的带权完全图，求权和最小的经过每个点恰好一次的封闭回路．这个问题已经被证明是NP完全问题，那么对于这样一类无多项式算法的问题，搜索算法是不是解决问题的唯一途径呢? 答案是否定的．不难发现任何时候我们只需要知道哪些点已经被遍历过而遍历点的具体顺序对以后的决策是没有影响的，因此不妨以当前所在的位置&lt;em&gt;i&lt;/em&gt;，遍历过的点的集合&lt;em&gt;S&lt;/em&gt;为状态作动态规划：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020175648631-150837063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态规划的时间复杂度为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020175842162-1809876850.png&quot; alt=&quot;&quot;/&gt;，虽然为指数级算法，但是对于&lt;em&gt;n&lt;/em&gt; = 15的数据规模来说已经比朴素的的搜索算法&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020175912271-1491556502.png&quot; alt=&quot;&quot;/&gt;高效很多了．我们通常把这样一类以一个集合内的元素信息作为状态且状态总数为指数级别的动态规划称为&lt;strong&gt;基于状态压缩的动态规划或集合动态规划&lt;/strong&gt;．基于状态压缩的动态规划问题通常具有以下两个特点：1．数据规模的某一维或几维非常小；2．它需要具备动态规划问题的两个基本性质：&lt;strong&gt;最优性原理&lt;/strong&gt;和&lt;strong&gt;无后效性&lt;/strong&gt;．&lt;/p&gt;
&lt;p&gt;一般的状态压缩问题，压缩的是一个小范围内每个元素的决策，状态中元素的信息相对独立．而有些问题，仅仅记录每个元素的决策是不够的，不妨再看一个例子：给你一个&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt; (&lt;em&gt;m&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt;≤9) 的矩阵，每个格子有一个价值&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020175805209-2004710562.png&quot; alt=&quot;&quot;/&gt;，要求找一个连通块使得该连通块内所有格子的价值之和最大．按从上到下的顺序依次考虑每个格子选还是不选，下图为一个极端情况，其中黑色的格子为所选的连通块．只考虑前5行的时候，所有的黑色格子形成了三个连通块，而最后所有的黑色格子形成一个连通块．如果状态中只单纯地记录前一行或前几行的格子选还是不选，是无法准确描述这个状态的，因此压缩的状态中我们需要增加一维，记录若干个格子之间的连通情况．我们把这一类必须要在状态中记录若干个元素之间的连通信息的问题称为&lt;strong&gt;基于连通性状态压缩的动态规划问题&lt;/strong&gt;．本文着重对这类问题进行研究．&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020180031787-1563712277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;连通是图论中一个非常重要的概念，在一个无向图中，如果两个顶点之间存在一条路径，则称这两个点连通．而基于连通性状态压缩的动态规划问题与图论模型有着密切的关联，比如后文涉及到的哈密尔顿回路、生成树等等．通常这类问题的本身与连通性有关或者隐藏着连通信息．&lt;/p&gt;
&lt;p&gt;全文共有六个章节．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一章，问题的一般解法&lt;/strong&gt;，介绍解决基于连通性状态压缩的动态规划问题的一般思路和解题技巧；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二章，一类简单路径问题&lt;/strong&gt;，介绍一类基于棋盘模型的简单路径问题的状态表示的改进——括号表示法以及提出广义的括号表示法；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三章，一类棋盘染色问题&lt;/strong&gt;，介绍解决一类棋盘染色问题的一般思路；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四章，一类基于非棋盘模型的问题&lt;/strong&gt;，介绍解决一类非棋盘模型的连通性状态压缩问题的一般思路；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五章，一类最优性问题的剪枝技巧&lt;/strong&gt;，本章的重点是优化，探讨如何通过剪枝来减少扩展的状态的总数从而提高算法的效率；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六章，总结&lt;/strong&gt;，回顾前文，总结解题方法．&lt;/p&gt;
&lt;h2&gt;一. 问题的一般解法&lt;/h2&gt;
&lt;p&gt;基于连通性状态压缩的动态规划问题通常具有一个比较固定的模式，几乎所有的题目都是在这个模式的基础上变形和扩展的．本章选取了一个有代表性的例题来介绍这一类问题的一般解法．&lt;/p&gt;
&lt;h3&gt;【例1】Formula 1&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;&lt;strong&gt;[1]&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给你一个&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;的棋盘，有的格子是障碍，问共有多少条回路使得经过每个非障碍格子恰好一次．&lt;em&gt;m&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt; ≤ 12．&lt;/p&gt;
&lt;div readability=&quot;6.09375&quot;&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;7.5&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; Ural1519, Timus Top Coders : Third Challenge&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020180625427-1150140394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，&lt;em&gt;m&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt; = 4，(1, 1), (1, 2)是障碍，共有2条满足要求的回路．&lt;/p&gt;
&lt;h4&gt;算法分析&lt;/h4&gt;
&lt;p&gt;【&lt;strong&gt;划分阶段&lt;/strong&gt;】 这是一个典型的基于&lt;strong&gt;棋盘模型&lt;/strong&gt;的问题，&lt;span&gt;棋盘模型的特殊结构，&lt;/span&gt;&lt;span&gt;使得它成为连通性状态压缩动态规划问题最常见的“舞台”&lt;/span&gt;．通常来说，棋盘模型有三种划分阶段的方法：逐行，逐列，逐格．顾名思义，逐行即从上到下或从下到上依次考虑每一行的状态，并转移到下一行；逐列即从左到右或从右到左依次考虑每一列的状态，并转移到下一列；逐格即按一定的顺序(如从上到下，从左到右)依次考虑每一格的状态，并转移到下一个格子．&lt;/p&gt;
&lt;p&gt;对于本题来说，逐行递推和逐列递推基本类似&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;[1]&lt;/a&gt;，接下来我们会对逐行递推和逐格递推的状态确立，状态转移以及程序实现一一介绍．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020180810927-1390900328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;36.964346895075&quot;&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;68.933511777302&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; 有的题目, 逐行递推和逐列递推的状态表示有较大的区别, 比如本文后面会讲到的Rocket Mania一题&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;确立状态&lt;/strong&gt;】 先提出一个非常重要的概念——“插头”．对于一个4连通的问题来说，它通常有上下左右4个插头，一个方向的插头存在表示这个格子在这个方向可以与外面相连．本题要求回路的个数，观察可以发现所有的非障碍格子一定是从一个格子进来，另一个格子出去，即4个插头恰好有2个插头存在，共6种情况．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逐行递推&lt;/strong&gt;不妨按照从上到下的顺序依次考虑每一行．分析第&lt;em&gt;i&lt;/em&gt; 行的哪些信息对第&lt;em&gt;i&lt;/em&gt; + 1行有影响：我们需要记录第&lt;em&gt;i&lt;/em&gt;行的每个格子是否有下插头，这决定了第&lt;em&gt;i&lt;/em&gt;+1行的每个格子是否有上插头．仅仅记录插头是否存在是不够的，可能导致出现多个回路 (如图)，而本题要求一个回路，也就&lt;span&gt;隐含着最后所有的非障碍格子通过插头连接成了一个&lt;strong&gt;连通块&lt;/strong&gt;&lt;/span&gt;，因此还需要记录第&lt;em&gt;i&lt;/em&gt;行的&lt;em&gt;n&lt;/em&gt;个格子的&lt;strong&gt;连通情况&lt;/strong&gt;．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020180928068-2033937542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020180944740-1363667945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们称图中的蓝线为&lt;strong&gt;轮廓线&lt;/strong&gt;，任何时候只有轮廓线上方与其直接相连的格子和插头才会对轮廓线以下的格子产生直接的影响．通过上面的分析，可以写出动态规划的状态：&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181045177-1820431445.png&quot; alt=&quot;&quot;/&gt;表示前&lt;em&gt;i&lt;/em&gt;行，第&lt;em&gt;i&lt;/em&gt;行的&lt;em&gt;n&lt;/em&gt;个格子是否具有下插头的一个&lt;em&gt;n&lt;/em&gt;位的二进制数为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181136334-2094003071.png&quot; alt=&quot;&quot;/&gt;，第&lt;em&gt;i&lt;/em&gt;行的&lt;em&gt;n&lt;/em&gt;个格子之间的连通性为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181154740-458405934.png&quot; alt=&quot;&quot;/&gt;的方案总数．&lt;/p&gt;
&lt;p&gt;如何表示&lt;em&gt;n&lt;/em&gt;个格子的连通性呢? 通常给每一个格子标记一个正数，属于同一个的连通块的格子标记相同的数．比如{1,1,2,2}和{2,2,1,1}都表示第1,2个格子属于一个连通块，第3,4个格子属于一个连通块．为了避免出现同一个连通信息有不同的表示，一般会使用&lt;strong&gt;最小表示法&lt;/strong&gt;．&lt;/p&gt;
&lt;p&gt;一种最小表示法为：所有的障碍格子标记为0，第一个非障碍格子以及与它连通的所有格子标记为1，然后再找第一个未标记的非障碍格子以及与它连通的格子标记为2，……，重复这个过程，直到所有的格子都标记完毕．比如连通信息((1,2,5),(3,6),(4))表示为{1,1,2,3,1,2}．还有一种最小表示法，即一个连通块内所有的格子都标记成该连通块最左边格子的列编号，比如上面这个例子，我们表示为{1,1,3,4,1,3}．两种表示方法在转移的时候略有不同，本文后面将会提到&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;[1]&lt;/a&gt;．如上图三个状态我们可以依次表示为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181300412-449928942.png&quot; alt=&quot;&quot;/&gt;,&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181322131-1403653160.png&quot; alt=&quot;&quot;/&gt;,&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181347881-786806202.png&quot; alt=&quot;&quot;/&gt;.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;状态表示的优化&lt;/strong&gt; 通过观察可以发现如果轮廓线上方的&lt;em&gt;n&lt;/em&gt;个格子中某个格子没有下插头，那么它就不会再与轮廓线以下的格子直接相连，&lt;span&gt;它的连通性对轮廓线以下的格子不会再有影响，也就成为了“冗余”信息&lt;/span&gt;．不妨将记录格子的连通性改成记录插头的连通性，如果这个插头存在，那么就标记这个插头对应的格子的连通标号，如果这个插头不存在，那么标记为0．这样状态就从&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181425068-1408633674.png&quot; alt=&quot;&quot;/&gt;精简为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181442349-151297797.png&quot; alt=&quot;&quot;/&gt;，上图三个状态表示为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181503381-1317928481.png&quot; alt=&quot;&quot;/&gt;,&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181516537-1897245168.png&quot; alt=&quot;&quot;/&gt;,&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181530115-1838039221.png&quot; alt=&quot;&quot;/&gt;.&lt;/p&gt;
&lt;p&gt;优化后不仅状态表示更加简单，而且状态总数将会大大减少．&lt;/p&gt;
&lt;div readability=&quot;57.972284166932&quot;&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;115.44480726346&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt;因为第一种表示法更加直观, 本文如果不作特殊说明, 默认使用第一种最小表示法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逐格递推&lt;/strong&gt; 按照从上到下，从左到右的顺序依次考虑每一格．分析转移完(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)这个格子后哪些信息对后面的决策有影响：同样我们可以刻画出轮廓线，即轮廓线上方是已决策格子，下方是未决策格子．由图可知与轮廓线直接相连的格子有&lt;em&gt;n&lt;/em&gt;个，直接相连的插头有&lt;em&gt;n&lt;/em&gt;+1个，包括&lt;em&gt;n&lt;/em&gt;个格子的下插头以及(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的右插头．为了保持轮廓线的“连贯性”，不妨从左到右依次给&lt;em&gt;n&lt;/em&gt;个格子标号，&lt;em&gt;n&lt;/em&gt;+1个插头标号．类似地，我们需要记录与轮廓线直接相连的&lt;em&gt;n&lt;/em&gt;+1个插头是否存在以及&lt;em&gt;n&lt;/em&gt;个格子的连通情况．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181623443-1909902185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通过上面的分析，很容易写出动态规划的状态：&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181654521-140461339.png&quot; alt=&quot;&quot;/&gt;表示当前转移完(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)这个格子，&lt;em&gt;n&lt;/em&gt;+1个插头是否存在表示成一个&lt;em&gt;n&lt;/em&gt;+1位的二进制数&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;，以及&lt;em&gt;n&lt;/em&gt;个格子的连通性为&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;的方案总数．&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181727834-800243135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181748552-318349033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;逐行递推的时候我们提到了状态的优化，同样地，我们也可以把格子的连通性记录在插头上，新的状态为，上图3个状态依次为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181911599-1898978319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;,&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181855599-704162180.png&quot; alt=&quot;&quot;/&gt;,&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020181929834-1512876336.png&quot; alt=&quot;&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;【&lt;strong&gt;转移状态&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;状态的转移开销主要包含两个方面：每个状态转移的状态数，计算新的状态的时间．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逐行递推　&lt;/strong&gt;假设从第&lt;em&gt;i&lt;/em&gt;行转移到第&lt;em&gt;i&lt;/em&gt;+1行，我们需要枚举第&lt;em&gt;i&lt;/em&gt;+1行的每个格子的状态(共6种情况)，对于任何一个非障碍格子，它是否有上插头和左插头已知，因此最多只有2种情况，状态的转移数≤2&lt;sup&gt;n&lt;/sup&gt;．&lt;/p&gt;
&lt;p&gt;枚举完第&lt;em&gt;i&lt;/em&gt;+1行每个格子的状态后，需要计算第&lt;em&gt;i&lt;/em&gt;+1行&lt;em&gt;n&lt;/em&gt;个格子之间的连通性的最小表示，通常可以使用并查集的Father数组对其重新标号或者重新执行一次BFS/DFS，时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)，最后将格子的连通性转移到插头的连通性上．&lt;/p&gt;
&lt;p&gt;特别需要注意的是在转移的过程中，为了避免出现多个连通块，除了最后一行，任何时候一个连通分量内至少有一个格子有下插头．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逐格递推　&lt;/strong&gt;仔细观察下面这个图，当转移到时，轮廓线上&lt;em&gt;n&lt;/em&gt;个格子只有(&lt;em&gt;i&lt;/em&gt;-1, j)被改成(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)，&lt;em&gt;n&lt;/em&gt;+1个插头只有2个插头被改动，即(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;-1)的右插头修改成(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的下插头和(&lt;em&gt;i&lt;/em&gt;-1，&lt;em&gt;j&lt;/em&gt;)的下插头修改成(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的右插头．转移的时候枚举(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的状态分情况讨论．一般棋盘模型的逐格递推转移有3类情况：新建一个连通分量，合并两个连通分量，以及保持原来的连通分量．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182043865-661024873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面针对本题进行分析：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182101396-2039847304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;情况&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;新建一个连通分量，这种情况出现在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;i&lt;/em&gt;,&lt;em&gt;j&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;有右插头和下插头．新建的两个插头连通且不与其它插头连通，这种情况下需要将这两个插头连通分量标号标记成一个未标记过的正数，重新&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;扫描保证新的状态满足最小表示．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;情况&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt; &lt;span&gt;合并两个连通分量，这种情况出现在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;i&lt;/em&gt;,&lt;em&gt;j&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;有上插头和左插头．如果两个插头不连通，那么将两个插头所处的连通分量合并，标记相同的连通块标号，&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;扫描保证最小表示；如果已经连通，相当于出现了一个回路，这种情况只能出现在最后一个非障碍格子．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;情况&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; &lt;span&gt;保持原来的连通分量，这种情况出现在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;i&lt;/em&gt;,&lt;em&gt;j&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;的上插头和左插头恰好有一个，下插头和右插头也恰好有一个．下插头或右插头相当于是左插头或上插头的延续，连通块标号相同，并且不会影响到其他的插头的连通块标号，计算新的状态的时间为&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(1)&lt;/span&gt;&lt;span&gt;．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;注意当从一行的最后一个格子转移到下一行的第一个格子的时候，轮廓线需要特殊处理．值得一提的是，上面三种情况计算新的状态的时间分别为&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;), &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;), &lt;em&gt;O&lt;/em&gt;(1)&lt;/span&gt;&lt;span&gt;，如果使用前面提到的第二种最小表示方法，情况&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;只需要&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(1)&lt;/span&gt;&lt;span&gt;，但是情况&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;可能需要&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;重新扫描．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;比较一下逐行递推和逐格递推的状态的转移，逐行递推的每一个转移的状态总数为指数级，而逐格递推为&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(1)&lt;/span&gt;&lt;span&gt;，每次计算新的状态的时间两者最坏情况都为&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;，但是逐行递推的常数要比逐格递推大，从转移开销这个角度来看，逐格递推的优势是毋庸置疑的．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;【&lt;/span&gt;&lt;strong&gt;&lt;span&gt;程序实现&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;】&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;逐行递推和逐格递推的程序实现基本一致，下面以逐格递推为例来说明．&lt;/span&gt;&lt;span&gt;首先必须解决的一个问题是，对于像&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182240756-255623806.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;这样的一个状态我们该如何存储，可以开一个长度为&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;+1&lt;/span&gt;&lt;span&gt;的数组来存取&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;+1&lt;/span&gt;&lt;span&gt;个插头的连通性，但是数组判重并不方便，而且空间较大．不妨将&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;+1&lt;/span&gt;&lt;span&gt;个元素进行&lt;strong&gt;编码&lt;/strong&gt;，用一个或几个整数来存储，当我们需要取一个状态出来对它进行修改的时候再进行&lt;strong&gt;解码&lt;/strong&gt;．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;编码最简单的方法就是表示成一个&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;n&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;+1&lt;/span&gt;&lt;span&gt;位的&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;/em&gt;&lt;span&gt;进制数，&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;/em&gt;&lt;span&gt;可以取能够达到的最大的连通块标号加&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;a title=&quot;&quot; name=&quot;_ftnref1&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;/&gt;&lt;/span&gt;&lt;span&gt;，对本题来说，最多出现&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182308115-1950196142.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;个连通块，不妨取&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;/em&gt; &lt;span lang=&quot;EN-US&quot;&gt;= 7&lt;/span&gt;&lt;span&gt;．在不会超过数据类型的范围的前提下，建议将&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;/em&gt;&lt;span&gt;改成&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;的幂，因为位运算比普通的运算要快很多，本题最好采用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;8&lt;/span&gt;&lt;span&gt;进制来存储．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如需大范围修改连通块标号，最好将状态&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/span&gt; &lt;span&gt;解码到一个数组中，修改后再&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;O&lt;/span&gt;&lt;/em&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;n&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;计算出新的&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;p&lt;/span&gt;&lt;/em&gt;&lt;span&gt;进制数，而对于只需要局部修改几个标号的情况下，可以直接用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;x&lt;/em&gt; div &lt;em&gt;p&lt;sup&gt;i&lt;/sup&gt;&lt;/em&gt;&lt;sup&gt;-1&lt;/sup&gt;) mod &lt;em&gt;p&lt;/em&gt;&lt;/span&gt;&lt;span&gt;来获取第&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;i&lt;/span&gt;&lt;/em&gt;&lt;span&gt;位的状态，用&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182327943-1916477931.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;直接对第&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;i&lt;/span&gt;&lt;/em&gt;&lt;span&gt;位进行修改．&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;最后我们探讨一下实现的方法，一般有两种方法：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;．对所有可能出现的状态进行编码，枚举编码方式：预处理将所有可能的&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;连通性状态搜索出来，依次编号&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1, 2, 3,&lt;/span&gt; &lt;span&gt;…&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;em&gt;Tot&lt;/em&gt;&lt;/span&gt;&lt;span&gt;，那么状态为&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182345615-590389862.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;表示转移完&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)&lt;/span&gt;&lt;span&gt;后轮廓线状态编号为&lt;/span&gt;&lt;em&gt;&lt;span lang=&quot;EN-US&quot;&gt;k&lt;/span&gt;&lt;/em&gt;&lt;span&gt;的方案总数．将所有状态存入&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;Hash&lt;/span&gt;&lt;span&gt;表中，使得每个状态与编号一一对应，程序框架如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; For  i ← &lt;span&gt;1&lt;/span&gt;&lt;span&gt;  to  m
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; For  j ←&lt;span&gt;1&lt;/span&gt;&lt;span&gt;  to  n
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; For  k ← &lt;span&gt;1&lt;/span&gt;&lt;span&gt;  to  Tot
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;      For  x ← (i, j, State[k]) 的所有转移后的状态
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt; ← 状态x的编号
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt; ， 为 的后继格子． 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;       End For
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 2．记忆化宽度优先搜索：将初始状态放入队列中，每次取队首元素进行扩展，并用Hash对扩展出来的新的状态判重．程序框架如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;Queue.Push(所有初始状态) 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;While not Empty(Queue)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   p ← Queue.Pop()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       For  x ← p的所有转移后的状态
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;If  x之前扩展过 Then 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Sum [x] ← Sum[x] +&lt;span&gt; Sum[p]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;Else     
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Queue.Push(x)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;Sum[x] ← Sum[p] 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     End If
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;       End For
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; End While
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;比较上述两种实现方法，直接编码的方法实现简单，结构清晰，但是有一个很大的缺点：无效状态可能很多，导致了很多次空循环，而大大影响了程序的效率．下面是一组实验的比较数据：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;表1&lt;/strong&gt;&lt;strong&gt;．直接编码与宽度优先搜索扩展状态总数比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182554724-196844684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出直接编码扩展的无效状态的比率非常高，对于障碍较多的棋盘其对比更加明显，因此通常来说宽度优先搜索扩展比直接编码实现效率要高．&lt;/p&gt;
&lt;p&gt;Hash判重的优化：使用一个HashSize较小的Hash表，每转移一个(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)清空一次，每次判断状态&lt;em&gt;x&lt;/em&gt;是否扩展过的程序效率比用一个HashSize较大的Hash表每次判断状态(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;, &lt;em&gt;x&lt;/em&gt;)高很多．类似地，在不需要记录路径的情况下，也可以使用滚动的扩展队列来代替一个大的扩展队列．&lt;/p&gt;
&lt;p&gt;最后我们比较一下，不同的实现方法对程序效率的影响&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;[1]&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;Program 1 ：8-Based，枚举编码方式．&lt;/p&gt;
&lt;p&gt;Program 2 ：8-Based，队列扩展，HashSize = 3999997．&lt;/p&gt;
&lt;p&gt;Program 3 ：8-Based，队列扩展，HashSize = 4001，Hash表每次清空．&lt;/p&gt;
&lt;p&gt;Program 4 ：7-Based，队列扩展，HashSize = 4001，Hash表每次清空．&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;表2&lt;/strong&gt;&lt;strong&gt;．不同的实现方法的程序效率的比较&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6.6315789473684&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182632631-631434526.png&quot; alt=&quot;&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;8.5263157894737&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; 测试环境: Intel Core2 Duo T7100, 1.8GHz, 1G内存&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;本章从划分阶段，确立状态，状态转移以及程序实现四个方面介绍了基于连通性状态压缩动态规划问题的一般解法，并在每个方面归纳了一些不同的方法，最后对不同的算法的效率进行比较．在平时的解题过程中我们要学会针对题目的特点和数据规模“对症下药”，选择最合适的方法而达到最好的效果．&lt;/p&gt;
&lt;p&gt;由于逐格递推的转移开销比逐行递推小很多，下文如果不作特殊说明，我们都采用逐格的阶段划分．&lt;/p&gt;
&lt;h2&gt;二. 一类简单路径问题&lt;/h2&gt;
&lt;p&gt;这一章我们会针对一类基于棋盘模型的简单回路和简单路径问题的解法作一个探讨．简单路径，即除了起点和终点可能相同外，其余顶点均不相同的路径，而简单回路为起点和终点相同的简单路径．Formula 1是一个典型的棋盘模型的简单回路问题，这一章我们继续以这个题为例来说明．&lt;/p&gt;
&lt;p&gt;首先我们分析一下简单回路问题有什么特点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182739412-734467139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;仔细观察上面的图，可以发现轮廓线上方是由若干条互不相交的路径构成的，而每条路径的两个端口恰好对应了轮廓线上的两个&lt;strong&gt;插头&lt;/strong&gt;! 一条路径上的所有格子对应的是一个连通块，而每条路径的两个端口对应的两个插头是连通的而且不与其他任何一个插头连通．&lt;/p&gt;
&lt;p&gt;在上一章我们提到了逐格递推转移的时候的三种情况：新建一个连通分量，合并两个连通分量，保持原来的连通分量，它们分别等价于两个插头成为了一条新的路径的两端，两条路径的两个端口连接起来形成一条更长的路径或一条路径的两个端口连接起来形成一个回路以及延长原来的路径．&lt;/p&gt;
&lt;p&gt;通过上面的分析我们知道了简单回路问题一定满足任何时候轮廓线上每一个连通分量恰好有2个插头，那么这些插头之间有什么性质呢?　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020182843224-174106842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【性质】轮廓线上从左到右4个插头&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, &lt;em&gt;d&lt;/em&gt;，如果&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;连通，并且与&lt;em&gt;b&lt;/em&gt;不连通，那么&lt;em&gt;b&lt;/em&gt;, &lt;em&gt;d&lt;/em&gt;一定不连通．&lt;/p&gt;
&lt;p&gt;证明：反证法，如果&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;连通，&lt;em&gt;b&lt;/em&gt;, &lt;em&gt;d&lt;/em&gt;连通，那么轮廓线上方一定至少存在一条&lt;em&gt;a&lt;/em&gt;到&lt;em&gt;c&lt;/em&gt;的路径和一条&lt;em&gt;b&lt;/em&gt;到&lt;em&gt;d&lt;/em&gt;的路径．如图，两条路径一定会有交点，不妨设两条路径相交于格子&lt;em&gt;P&lt;/em&gt;，那么&lt;em&gt;P&lt;/em&gt;既与&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;连通，又与&lt;em&gt;b&lt;/em&gt;, &lt;em&gt;d&lt;/em&gt;连通，可以推出&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;与&lt;em&gt;b&lt;/em&gt;, &lt;em&gt;d&lt;/em&gt;连通，矛盾，得证．&lt;/p&gt;
&lt;p&gt;这个性质对所有的棋盘模型的问题都适用．&lt;/p&gt;
&lt;p&gt;“两两匹配”，“不会交叉”这样的性质，我们很容易联想到&lt;strong&gt;括号匹配&lt;/strong&gt;．将轮廓线上每一个连通分量中左边那个插头标记为左括号，右边那个插头标记为右括号，由于插头之间不会交叉，那么左括号一定可以与右括号一一对应．这样我们就可以使用3进制——0表示无插头，1表示左括号插头，2表示右括号插头记录下所有的轮廓线信息．不妨用#表示无插头，那么上面的三幅图分别对应的是(())#()，(()#)()，(()###)，即，我们称这种状态的表示方法为&lt;strong&gt;括号表示法&lt;/strong&gt;．&lt;/p&gt;
&lt;p&gt;依然分三类情况来讨论状态的转移：&lt;/p&gt;
&lt;p&gt;为了叙述方便，不妨称(&lt;em&gt;i&lt;/em&gt;,&lt;em&gt;j&lt;/em&gt;-1)的右插头为&lt;em&gt;p&lt;/em&gt;，(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)的下插头为&lt;em&gt;q&lt;/em&gt;，(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的下插头为p'，右插头为q'，那么每次转移相当于轮廓线上插头&lt;em&gt;p&lt;/em&gt;的信息修改成的信息p'，插头&lt;em&gt;q&lt;/em&gt;的信息修改成的信息q'，设&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;) = 0, 1, 2表示插头&lt;em&gt;x&lt;/em&gt;的状态．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;1 &lt;/strong&gt; 新建一个连通分量，这种情况下&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p)&lt;/em&gt; = 0，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q)&lt;/em&gt; = 0，p'，q'两个插头构建了一条新的路径，p'相当于为左括号，q'为右括号，即W(p')← 1，W(q')← 2，计算新的状态的时间为&lt;em&gt;O&lt;/em&gt;(1)．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2 &lt;/strong&gt; 合并两个连通分量，这种情况下&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p)&lt;/em&gt; &amp;gt; 0，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q)&lt;/em&gt; &amp;gt; 0，W(p')← 0，W(q')← 0，根据&lt;em&gt;p&lt;/em&gt;, &lt;em&gt;q&lt;/em&gt;为左括号还是右括号分四类情况讨论：&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2.1&lt;/strong&gt;  &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p)&lt;/em&gt; = 1，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q)&lt;/em&gt; = 1．那么需要将&lt;em&gt;q&lt;/em&gt;这个左括号与之对应的右括号&lt;em&gt;v&lt;/em&gt;修改成左括号，即&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;v&lt;/em&gt;) ← 1．&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2.2&lt;/strong&gt;  &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p)&lt;/em&gt; = 2，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q)&lt;/em&gt; = 2．那么需要将&lt;em&gt;p&lt;/em&gt;这个右括号与之对应的左括号&lt;em&gt;v&lt;/em&gt;修改成右括号，即&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;v&lt;/em&gt;)← 2．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020183220021-806612810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2.3&lt;/strong&gt;  &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) = 1，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) = 2，那么&lt;em&gt;p&lt;/em&gt;和&lt;em&gt;q&lt;/em&gt;是相对应的左括号和右括号，连接&lt;em&gt;p&lt;/em&gt;, &lt;em&gt;q&lt;/em&gt;相当于将一条路径的两端连接起来形成一个回路，这种情况下只能出现在最后一个非障碍格子．&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2.4&lt;/strong&gt;  &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) = 2，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) = 1，那么&lt;em&gt;p&lt;/em&gt;和&lt;em&gt;q&lt;/em&gt;连接起来后，&lt;em&gt;p&lt;/em&gt;对应的左括号和&lt;em&gt;q&lt;/em&gt;对应的右括号恰好匹配，不需要修改其他的插头的状态．&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020183242912-2077518307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;情况2.1, 2.2需要计算某个左括号或右括号与之匹配的括号，这个时候需要对三进制状态解码，利用类似模拟栈的方法．因此情况2.1, 2.2计算新的状态的时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)，2.3, 2.4时间复杂度为&lt;em&gt;O&lt;/em&gt;(1)．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;3 &lt;/strong&gt; 保持原来的连通分量，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;)，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;)中恰好一个为0，p'，q'中也恰好一个为0．那么无论p'，q'中哪个插头存在，都相当于是&lt;em&gt;p&lt;/em&gt;, &lt;em&gt;q&lt;/em&gt;中那个存在的插头的延续，括号性质一样，因此W(p')← &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) + &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;)，W(q')← 0或者W(q')← &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) + &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;)，W(p')← 0．计算新的状态的时间复杂度为&lt;em&gt;O&lt;/em&gt;(1)．&lt;/p&gt;
&lt;p&gt;通过上面的分析可以看出，括号表示法利用了简单回路问题的“一个连通分量内只有2个插头”的特殊性质巧妙地用3进制状态存储下完整的连通信息，插头的连通性标号相对独立，不再需要通过&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)扫描大范围修改连通性标号．实现的时候，我们可以用4进制代替3进制而提高程序运算效率，下面对最小表示法与括号表示法的程序效率进行比较：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;表3&lt;/strong&gt;&lt;strong&gt;．不同的状态表示的程序效率的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020183531302-1923111219.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看出，括号表示法的优势非常明显，加上它的思路清晰自然，实现也更加简单，因此对于解决这样一类简单回路问题是非常有价值的．&lt;/p&gt;
&lt;p&gt;类似的问题还有：NWERC 2004 Pipes，Hnoi2004 Postman，Hnoi2007 Park，还有一类非回路问题也可以通过棋盘改造后用简单回路问题的方法解决，比如 POJ 1739 Tony’s Tour：给一个&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;棋盘，有的格子是障碍，要求从左下角走到右下角，每个格子恰好经过一次，问方案总数．(m, n ≤ 8)&lt;/p&gt;
&lt;p&gt;只需要将棋盘改造一下，问题就等价于Formula 1了．&lt;/p&gt;
&lt;p&gt;                  .......&lt;/p&gt;
&lt;p&gt;#..  改造成  .#####.&lt;/p&gt;
&lt;p&gt;       ...          .##..#.&lt;/p&gt;
&lt;p&gt;                .......&lt;/p&gt;
&lt;p&gt;介绍完简单回路问题的解法，那么一般的简单路径问题又如何解决呢?&lt;/p&gt;
&lt;h3&gt;【例2】Formula 2&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;&lt;sup&gt;&lt;strong&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/strong&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给你一个&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;的棋盘，有的格子是障碍，要求从一个非障碍格子出发经过每个非障碍格子恰好一次，问方案总数．&lt;em&gt;m&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt; ≤ 10．&lt;/p&gt;
&lt;div readability=&quot;51.410417471975&quot;&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;97.829532276768&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; 改编自Formula 1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020183735568-1371983600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，一个2 * 2的无障碍棋盘，共有4条满足要求的路径．&lt;/p&gt;
&lt;h4&gt;算法分析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;确立状态：&lt;/strong&gt;按照从上到下，从左到右依次考虑每一个格子，设&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020183832427-1442698558.png&quot; alt=&quot;&quot;/&gt;表示转移完(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)这个格子，轮廓线状态为&lt;em&gt;S&lt;/em&gt;的方案总数．如果用一般的最小表示法，不仅需要记录每个插头的连通情况，还需要额外记录每个插头是否连接了路径的一端，状态表示相当复杂．依然从括号表示法这个角度来思考如何来存储轮廓线的状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020183858677-362353339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题跟简单回路问题最大的区别为：不是所有的插头都两两匹配，有的插头连接的路径的另一端不是一个插头而是整条路径的一端，我们称这样的插头为&lt;strong&gt;独立插头&lt;/strong&gt;．不妨将原来的3进制状态修改成4进制——0表示无插头，1表示左括号插头，2表示右括号插头，3表示独立插头，这样我们就可以用4进制完整地记录下轮廓线的信息，图中状态表示为(1203)&lt;sub&gt;4&lt;/sub&gt;．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移：&lt;/strong&gt;依然设(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;-1)的右插头为&lt;em&gt;p&lt;/em&gt;，(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)的下插头为&lt;em&gt;q&lt;/em&gt;，(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的下插头为p'，右插头为q'．部分转移同简单回路问题完全一样，这里不再赘述，下面分三类情况讨论与独立插头有关的转移：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;1 &lt;/strong&gt; &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) = 0，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) = 0．当前格子可能成为路径的一端，即右插头或下插头是独立插头，因此W(p')← &lt;em&gt;3&lt;/em&gt;，W(q')← 0或者W(q')← 3，W(p')← 0．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2 &lt;/strong&gt; &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) &amp;gt; 0，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) &amp;gt; 0，那么W(p')← 0，W(q')← 0&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2.1 &lt;/strong&gt; &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) =3，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) = 3，将插头&lt;em&gt;p&lt;/em&gt;和&lt;em&gt;q&lt;/em&gt;连接起来就相当于形成了一条完整的路径，这种情况只能出现在最后一个非障碍格子．&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;2.2 &lt;/strong&gt; &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) ，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) 中有一个为3，如果&lt;em&gt;p&lt;/em&gt;为独立插头，那么无论&lt;em&gt;q&lt;/em&gt;是左括号插头还是右括号插头，与&lt;em&gt;q&lt;/em&gt;相匹配的插头&lt;em&gt;v&lt;/em&gt;成为了独立插头，因此，&lt;/p&gt;
&lt;p&gt;&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;v&lt;/em&gt;)←3．如果&lt;em&gt;q&lt;/em&gt;为独立插头，类似处理．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt; &lt;em&gt;W&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;) ，&lt;em&gt;W&lt;/em&gt;(&lt;em&gt;q&lt;/em&gt;) 中有一个&amp;gt;0，即&lt;em&gt;p&lt;/em&gt;, &lt;em&gt;q&lt;/em&gt;中有一个插头存在．&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;3.1 &lt;/strong&gt; 如果这个插头为独立插头，若在最后一个非障碍格子，这个插头可以成为路径的一端，否则可以用右插头或下插头来延续这个独立插头．&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;情况&lt;/strong&gt;&lt;strong&gt;3.2 &lt;/strong&gt; 如果这个插头是左括号或右括号，那么我们以将这个插头“封住”，使它成为路径的一端，需要将这个插头所匹配的另一个插头的状态修改成为独立插头．&lt;/p&gt;
&lt;p&gt;情况2.2, 3.2需要计算某个左括号或右括号与之匹配的括号，计算新的状态的时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)，其余情况计算新的状态的时间复杂度为&lt;em&gt;O&lt;/em&gt;(1)．&lt;/p&gt;
&lt;p&gt;特别需要注意，任何时候轮廓线上独立插头的个数不可以超过2个．至此问题完整解决，&lt;em&gt;m&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt; = 10的无障碍棋盘，扩展的状态总数为3493315，完全可以承受．&lt;/p&gt;
&lt;p&gt;上面两类题目我们用括号表示法取得了很不错的效果，但是它存在一定的局限性，即插头必须满足两两匹配．那么对于更加一般的问题，一个连通分量内出现大于2个插头，上述的括号表示方法显得束手无策．下面将介绍一种括号表示法的变形，它可以适用于出现连通块内大于2个插头的问题，我们称之为&lt;strong&gt;广义的括号表示法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设一个连通分量从左到右有多个插头，不妨将最左边的插头标记为“&lt;strong&gt;(&lt;/strong&gt;”，最右边的插头标记为“&lt;strong&gt;)&lt;/strong&gt;”，中间的插头全部标记为“&lt;strong&gt;)(&lt;/strong&gt;”，那么能够匹配的括号对应的插头连通．如果问题中可能出现一个连通分量只有一个插头，那么这个插头标记为“&lt;strong&gt;( )&lt;/strong&gt;”，这样插头之间的连通性可用括号序列完整地记录下来，比如对于一个连通性状态为{1,2,2,3,4,3,2,1}，我们可以用&lt;strong&gt;(-(-)(-(-()-)-)-)&lt;/strong&gt;记录．&lt;/p&gt;
&lt;p&gt;这种广义的括号表示方法需要用4进制甚至5进制存储状态，而且直接对状态连通性进行修改情况非常多，最好还是将状态进行解码，修改后再重新编码．下文我们将会运用广义的括号表示法解决一些具体的问题．&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;本章针对一类简单路径问题，提出了一种新的状态表示方法——括号表示法，最后提出了广义的括号表示方法．相比普通的最小表示法，括号表示法巧妙地把连通块与括号匹配一一对应，使得状态更加简单明了，虽然不会减少扩展的状态总数，但是转移开销的常数要小很多，是一个不错的方法．&lt;/p&gt;
&lt;h2&gt;三. 一类棋盘染色问题&lt;/h2&gt;
&lt;p&gt;有一类这样的问题——给你一个&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;的棋盘，要求给每个格子染上一种颜色(共&lt;em&gt;k&lt;/em&gt;种颜色)，每种颜色的格子相互连通 (4连通)．本章主要对这类问题的解法进行探讨，我们从一个例题说起：&lt;/p&gt;
&lt;h3&gt;【例3】Black &amp;amp; White&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;&lt;strong&gt;[1]&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题描述&lt;/h4&gt;
&lt;p&gt;一个&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;的棋盘，有的格子已经染上黑色或白色，现在要求将所有的未染色格子染上黑色或白色，使得满足以下2个限制：&lt;/p&gt;
&lt;p&gt;1)      所有的黑色的格子是连通的，所有的白色格子也是连通的．&lt;/p&gt;
&lt;p&gt;2)      不会有一个2 * 2的子矩阵的4个格子的颜色全部相同．&lt;/p&gt;
&lt;p&gt;问方案总数．(&lt;em&gt;m&lt;/em&gt;, &lt;em&gt;n&lt;/em&gt; ≤ 8)&lt;/p&gt;
&lt;p&gt;  如下图，&lt;em&gt;m&lt;/em&gt; = 2，&lt;em&gt;n&lt;/em&gt; = 3，灰色格子为未染色格子，共有9种染色方案．&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020190846209-874938475.png&quot; alt=&quot;&quot;/&gt;
&lt;br clear=&quot;all&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; Source : Uva10572&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4&gt;算法分析&lt;/h4&gt;
&lt;p&gt;这是一个典型的棋盘染色问题，着色规则有：&lt;/p&gt;
&lt;p&gt;1) 只有黑白两种颜色，即&lt;em&gt;k&lt;/em&gt; = 2，并且同色的格子互相连通．&lt;/p&gt;
&lt;p&gt;2) 没有同色的2 * 2的格子．&lt;/p&gt;
&lt;p&gt;对于简单路径问题来说，相邻的格子是否连通取决于它们之间的插头是否存在，状态记录轮廓线上每个插头是否存在以及插头之间的连通性；而棋盘染色问题相邻的格子是否连通取决于它们的颜色是否相同，这就需要记录轮廓线上方&lt;em&gt;n&lt;/em&gt;个格子的颜色以及格子之间的连通性．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确立状态&lt;/strong&gt;　设当前转移完&lt;em&gt;Q&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)这个格子，对以后的决策产生影响的信息有：轮廓线上方&lt;em&gt;n&lt;/em&gt;个格子的染色情况以及它们的连通性，由第2条着色规则“没有同色的2 * 2的格子”可知&lt;em&gt;P&lt;/em&gt;(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)的颜色会影响到(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;+1)着色，因此我们还需要额外记录格子的颜色．动态规划的状态为：表示转移完(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)，轮廓线上从左到右&lt;em&gt;n&lt;/em&gt;个格子的染色情况为&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; (0 ≤ &lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt; &amp;lt; 2&lt;em&gt;&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;)，连通性状态为&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;，格子的颜色为&lt;em&gt;cp&lt;/em&gt;(0或1)的方案总数．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191012521-2049008542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态的精简&lt;/strong&gt;　如果相邻的2个格子不属于同一个连通块，那么它们必然不同色，因此只需要记录(&lt;em&gt;i&lt;/em&gt;, 1)和(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;+1)两个格子的颜色，利用&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;就可以推出&lt;em&gt;n&lt;/em&gt;个格子的颜色．这个精简不会减少状态的总数，仍然需要一个变量来记录两个格子的颜色，因此意义并不大，这里只是提一下．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移&lt;/strong&gt;　枚举当前格子(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的颜色，计算新的状态：&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;0&lt;/sub&gt;和&lt;em&gt;cp&lt;/em&gt;都很容易&lt;em&gt;O&lt;/em&gt;(1)计算出来．考虑计算&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;：轮廓线的变化相当于将记录(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)的连通性改成记录(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的连通性．根据当前格子与上面的格子和左边的格子是否同色分四类情况讨论．应当注意的是如果(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)和(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)不同色，并且(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)在轮廓线上为一个单独的一个连通块，那么(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)以后都不可能与其他格子连通，即剩余的格子都必须染上与(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)相反的颜色，需要特殊判断．转移的时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)．计算新状态的&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;程序框架如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 将前一个状态的S1解码，连通性存入c[&lt;span&gt;1&lt;/span&gt;],c[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;],…,c[n]．
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; If  (i, j) 与 (i-&lt;span&gt;1&lt;/span&gt;, j) 不同色并且 (i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, j) 为一个单独的连通块Then
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;特殊判断
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Else
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; If  (i, j) 与 (i-&lt;span&gt;1&lt;/span&gt;, j) 和 (i, j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 均同色Then 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; For k ← &lt;span&gt;1&lt;/span&gt;&lt;span&gt; to n
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  If c[k] =&lt;span&gt; c[j] Then
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      c[k] ← c[j-&lt;span&gt;1&lt;/span&gt;]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 合并两个连通块&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;               EndIf
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;Else 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; If  (i, j) 与 (i-&lt;span&gt;1&lt;/span&gt;, j) 和 (i, j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 均不同色Then  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; c[j] ← 最大可能出现的连通块标号 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (i, j) 新建一个连通块．&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;Else 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; If  (i, j) 与 (i, j-&lt;span&gt;1&lt;/span&gt;) 同色与 (i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, j) 不同色 Then 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; c[j] ← c[j-&lt;span&gt;1&lt;/span&gt;]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (i, j) 的连通性标号跟 (i, j-1)相同．&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;             EndIf
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;          EndIf
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;       EndIf
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     EndIf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对&lt;em&gt;c&lt;/em&gt;[] &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)扫描，修改成最小表示，利用&lt;em&gt;c&lt;/em&gt;[]编码计算出新的&lt;em&gt;S&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;．&lt;/p&gt;
&lt;p&gt;对于&lt;em&gt;m&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt; = 8的一个全部未染色的棋盘，扩展出来的状态总数为122395，转移需要时间为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt;)，因此总的时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;TotalState&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;) = 979160，运行时间&amp;lt;0.1&lt;em&gt;s&lt;/em&gt;．至此问题完整解决．类似可以解决的问题还有2007年重庆市选拔赛 Rect和IPSC 2007 Delicious Cake．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;上面提到的是4连通问题，如果要求8连通呢?&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4连通问题是两个格子至少有一条边重合为连通，而8连通问题是两个格子至少有一个顶点重合为连通，因此需要记录所有至少有一个顶点在轮廓线上的格子的连通和染色情况，即包括(&lt;em&gt;i&lt;/em&gt;-1, &lt;em&gt;j&lt;/em&gt;)在内的&lt;em&gt;n&lt;/em&gt;+1个格子．&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一个优化的方向&lt;/strong&gt;　扩展的状态中无效状态的总数很大程度上决定了算法的效率．比如Black &amp;amp; White中如果出现右图的状态，那么无论之后如何决策，都不可能满足同色的格子互相连通的性质，因此它是一个无效状态．对于任何一个&lt;em&gt;k&lt;/em&gt;染色棋盘问题，如果从左到右有4个相互不嵌套&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;[1]&lt;/a&gt;的连通块&lt;em&gt;a&lt;/em&gt;,&lt;em&gt;b&lt;/em&gt;,&lt;em&gt;c&lt;/em&gt;,&lt;em&gt;d&lt;/em&gt;，&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;同色, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;d&lt;/em&gt;同色且与&lt;em&gt;a&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;不同色，那么这个状态为无效状态．&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191248834-1018922545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;本章介绍了解决一类棋盘染色问题的一般思路．无论染色规则多么复杂，我们只要在基本状态即“轮廓线上方与其相连的格子的连通性以及染色情况”的基础上，根据题目的需要在状态中增加对以后的决策可能产生影响的信息，问题都可以迎刃而解了．&lt;/p&gt;
&lt;div readability=&quot;5.7692307692308&quot;&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;6.7307692307692&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt;“嵌套”的概念可以用广义的括号匹配的表示方法来理解&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2&gt;四. 一类基于非棋盘模型的问题&lt;/h2&gt;
&lt;p&gt;本章将会介绍一类基于非棋盘模型的连通性状态压缩动态规划问题，它虽然不具有棋盘模型的特殊结构，但是解法的核心思想又跟棋盘模型的问题有着异曲同工之处．&lt;/p&gt;
&lt;h3&gt;【例4】生成树计数&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;&lt;strong&gt;[1]&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题描述&lt;/h4&gt;
&lt;p&gt;给你一个&lt;em&gt;n&lt;/em&gt;个点的无向连通图，其边集为：任何两个不同的点&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;(1 ≤ &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt; ≤ &lt;em&gt;n&lt;/em&gt;)，如果|&lt;em&gt;i&lt;/em&gt; - &lt;em&gt;j&lt;/em&gt;| ≤ &lt;em&gt;k&lt;/em&gt;，那么有一条无向边&amp;lt;&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;&amp;gt;．已知&lt;em&gt;n&lt;/em&gt;和&lt;em&gt;k&lt;/em&gt;，求这个图的生成树个数．&lt;/p&gt;
&lt;p&gt;    &lt;em&gt;n&lt;/em&gt; ≤ 10&lt;sup&gt;15&lt;/sup&gt;，2 ≤ &lt;em&gt;k&lt;/em&gt; ≤ 5．&lt;/p&gt;
&lt;h4&gt;算法分析&lt;/h4&gt;
&lt;p&gt;这个题给我们的第一印象是：&lt;em&gt;n&lt;/em&gt;非常大，&lt;em&gt;k&lt;/em&gt;却非常小．&lt;/p&gt;
&lt;p&gt;    生成树最重要的两个性质：无环，连通．那么如果按照1,2,…,&lt;em&gt;n&lt;/em&gt;的顺序依次考虑每一个点与前面的哪些点相连，并且保证任何时候都不会出现环，最后统计所有的点全部在一个连通分量内的方案总数即为最终的答案．&lt;/p&gt;
&lt;p&gt;在棋盘模型的问题中，我们提出了轮廓线这个概念，任何时候只有轮廓线上方与其直接相连的格子对以后的决策会产生影响．类似地我们分析一下这个问题，当我们确定了1~&lt;em&gt;i&lt;/em&gt;的所有点的连边情况后，哪些信息对以后的决策会产生影响：1~&lt;em&gt;i–k&lt;/em&gt;这些点与&lt;em&gt;i&lt;/em&gt;之后的点一定没有边相连，那么对&lt;em&gt;i&lt;/em&gt;以后的点的决策不会产生直接的影响，因此我们需要记录的仅仅是&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;+1~&lt;em&gt;i&lt;/em&gt;这&lt;em&gt;k&lt;/em&gt;个点的连通信息!&lt;/p&gt;
&lt;p&gt;如下图，我们不妨也称蓝线为轮廓线，因为只有轮廓线上的点的信息会对轮廓线右边的点的决策产生直接的影响．这样我们就很容易&lt;strong&gt;确立状态&lt;/strong&gt;：&lt;/p&gt;
&lt;div readability=&quot;6.09375&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191345084-171875622.png&quot; alt=&quot;&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;7.5&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; Source : Noi2007 Day2 生成树计数, Count&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;设&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191450818-1286051379.png&quot; alt=&quot;&quot;/&gt;表示考虑完前&lt;em&gt;i&lt;/em&gt;个点的连边情况后，&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;+1 .. &lt;em&gt;i&lt;/em&gt;这&lt;em&gt;k&lt;/em&gt;个点的连通情况为&lt;em&gt;S&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转移状态&lt;/strong&gt;：&lt;em&gt;O&lt;/em&gt;(2&lt;sup&gt;k&lt;/sup&gt;)依次枚举点&lt;em&gt;i&lt;/em&gt;与&lt;em&gt;i&lt;/em&gt;-1，…，&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;这&lt;em&gt;k&lt;/em&gt;个点是否相连．转移的时候需要注意：&lt;em&gt;i&lt;/em&gt;-1, …, &lt;em&gt;i&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;这&lt;em&gt;k&lt;/em&gt;个点，任何一个连通块，&lt;em&gt;i&lt;/em&gt;最多只能与其中的一个点相连，这样可以避免环的出现．如果&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;在轮廓线上为一个单独的连通块，那么&lt;em&gt;i&lt;/em&gt;必然与&lt;em&gt;i&lt;/em&gt;-&lt;em&gt;k&lt;/em&gt;相连，这样可以避免出现孤立的连通块．比如对于一个&lt;em&gt;k&lt;/em&gt; = 5的状态&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191549990-997084025.png&quot; alt=&quot;&quot;/&gt;来说，如果点&lt;em&gt;i&lt;/em&gt;与&lt;em&gt;i&lt;/em&gt;-2和&lt;em&gt;i&lt;/em&gt;-1相连，那么新的状态为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191702943-1585875489.png&quot; alt=&quot;&quot;/&gt;．这样我们就可以在O(2&lt;sup&gt;k&lt;/sup&gt;*&lt;em&gt;k&lt;/em&gt;)的时间复杂度内完成状态的转移．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法实现：&lt;/strong&gt;设&lt;em&gt;T&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt;表示&lt;em&gt;k&lt;/em&gt;个点的本质不同的连通情况的个数，搜索可知&lt;em&gt;T&lt;/em&gt;&lt;sub&gt;5&lt;/sub&gt;=52．动态规划的时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; * &lt;em&gt;T&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt; * 2&lt;sup&gt;k&lt;/sup&gt; * &lt;em&gt;k&lt;/em&gt;)，依然太大．可以发现当&lt;em&gt;i&lt;/em&gt; ≥ &lt;em&gt;k&lt;/em&gt;，状态是否可以转移到只与有关，这样我们就可以用矩阵乘法实现动态规划加速，由于这不是本文的重点，这里不再详细介绍．最终的时间复杂度为&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;T&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt;&lt;sup&gt;3&lt;/sup&gt;*log&lt;sub&gt;2&lt;/sub&gt;&lt;em&gt;n&lt;/em&gt;)，对于&lt;em&gt;k&lt;/em&gt; = 5, &lt;em&gt;T&lt;/em&gt;&lt;sub&gt;k&lt;/sub&gt; = 52的数据规模来说已经完全可以承受了，至此问题完整解决．&lt;/p&gt;
&lt;p&gt;本题中的无向图非常特殊，每个点只和距离它不超过&lt;em&gt;k&lt;/em&gt;的点有边相连，并且&lt;em&gt;k&lt;/em&gt;非常小．对于棋盘模型的问题，可以抽象成一个特殊的无向图——&lt;em&gt;m&lt;/em&gt; * &lt;em&gt;n&lt;/em&gt;个点，每个点只与它上下左右四个点有边相连．那么对于一个与连通性有关的无向图问题，无向图具备怎样的特点才可以用基于状态压缩的动态规划来解决?　分析以上几个问题，不难发现它们有一个共同点：给无向图中的点找一个序，在这个序中有边相连的两个点的距离不超过&lt;em&gt;p&lt;/em&gt;(&lt;em&gt;p&lt;/em&gt;很小)，这样我们就可以以当前决策完序中前&lt;em&gt;i&lt;/em&gt;个，最后&lt;em&gt;p&lt;/em&gt;个点的连通性为状态作动态规划．棋盘模型的问题中序即为从上到下，从左到右或从左到右，从上到下，&lt;em&gt;p&lt;/em&gt;为&lt;em&gt;m&lt;/em&gt;或&lt;em&gt;n&lt;/em&gt;，因此棋盘模型的问题&lt;em&gt;m&lt;/em&gt;和&lt;em&gt;n&lt;/em&gt;中至少有一个数会非常小．&lt;/p&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;本章写得比较简略，但是依然能够给我们很多的启示．处理这样的一类非棋盘模型的问题，一般的思路是寻找某一个序依次考虑每个点的决策，并分析哪些信息对以后的决策会产生影响，找到问题中的“轮廓线”，以轮廓线的信息来确立动态规划的状态．通常来说，轮廓线上的信息比较少，这也是能够作状态压缩动态规划的基础，像本题中&lt;em&gt;k&lt;/em&gt;≤5这样的条件往往能成为解决问题的突破口．&lt;/p&gt;
&lt;h2&gt;五. 一类最优性问题的剪枝技巧&lt;/h2&gt;
&lt;p&gt;基于连通性状态压缩的动态规划问题的算法的效率主要取决于状态的总数和转移的开销，减少状态总数和降低转移开销成为了优化的核心内容．前面的章节我们提到了一些优化的技巧，这一章我们选取了一个非常有趣的题目Rocket Mania来介绍针对这样的一类最优性问题，如何通过剪枝使状态总数大大减少而提高算法效率．&lt;/p&gt;
&lt;h3&gt;【例5】Rocket Mania&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;&lt;strong&gt;[1]&lt;/strong&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题描述&lt;/h4&gt;
&lt;p&gt;这个题目的背景是幻想游戏的“中国烟花”：&lt;/p&gt;
&lt;p&gt;给你一个9 * 6的棋盘，棋盘的左边有9根火柴，右边有9个火箭．棋盘中的每一个格子可能是一个空格子也可能是一段管道，管道的类型有4种：&lt;/p&gt;
&lt;div readability=&quot;6.1320754716981&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191824896-2063861328.png&quot; alt=&quot;&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;7.5471698113208&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt; Source : Zju 2125, Online Contest of Fantasy Game&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;一个火箭能够被发射当且仅当存在一条由管道组成的从一根点燃的火柴到这个火箭的路径．&lt;/p&gt;
&lt;p&gt;给你棋盘的初始状态以及&lt;em&gt;X&lt;/em&gt;，你的目标是旋转每个格子内的管道0，90，180或270度，使得当点燃左边第&lt;em&gt;X&lt;/em&gt;根火柴后，被发射的火箭个数尽可能多．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020191859334-891818230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;算法分析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;确立状态&lt;/strong&gt;：按照从左到右，从上到下的顺序依次考虑每一个格子，我们需要记录每个插头是否已经点燃以及它们之间的连通情况．因此状态为&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020194853396-1750730232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表示转移完(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)，轮廓线上10个插头的连通性为&lt;em&gt;S&lt;/em&gt;(把每个插头是否存在记录在&lt;em&gt;S&lt;/em&gt;中), 10个插头是否被点燃的2进制数&lt;em&gt;fired&lt;/em&gt;的状态能否达到．&lt;/p&gt;
&lt;p&gt;那么最后的答案为所有可以达到的状态&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020194936506-2064606756.png&quot; alt=&quot;&quot;/&gt;中 &lt;em&gt;Ones&lt;/em&gt;[&lt;em&gt;fired&lt;/em&gt;]的最大值，其中&lt;em&gt;Ones&lt;/em&gt;[&lt;em&gt;x&lt;/em&gt;]表示二进制数&lt;em&gt;x&lt;/em&gt;的1的个数．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移：&lt;/strong&gt;依次枚举每一个格子的旋转方式(最多4种)，根据当前格子是否可以与上面的格子和左边的格子通过插头连接起来分情况讨论，&lt;em&gt;O(m&lt;/em&gt;)扫描计算出新的状态．前面的题目我们已经很详细地介绍过棋盘模型的问题的转移方法，这里不再赘述．&lt;/p&gt;
&lt;p&gt;如果直接按照上面的思路作动态规划，Sample也需要运行&amp;gt; 60s，实在令人无法满意．优化，势在必行．如何通过剪枝优化来减少扩展的状态总数，尽可能舍去无效状态成为了现在所面临的问题：&lt;/p&gt;
&lt;p&gt;剪枝通常可以分为两类：一．可行性剪枝，即将无论之后如何决策，都不可能满足题目要求的状态剪掉；二．最优性剪枝，即对于最优性问题，将不可能成为最优解的状态给剪掉．我们从这两个角度入手来考虑问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪枝一&lt;/strong&gt;：如果轮廓线上所有的插头全部都未被点燃，那么最后所有的火箭都不可能发射，所以这个状态可以舍去．这个剪枝看上去非常显然，对于大部分数据却可以剪掉近乎一半的状态．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪枝二&lt;/strong&gt;：如果轮廓线上有一个插头&lt;em&gt;p&lt;/em&gt;，它没有被火柴点燃且没有其它的插头与它连通，那么这个插头可以认为是“无效”插头．因为即使这个插头所在的路径以后会被点燃而可以发射某个火箭，那么一定存在另一条路径可以不经过这个插头而发射火箭，如图．这种情况下将插头设置为不存在．这是最重要的一个剪枝，大部分数据的状态总数可以缩小七八倍，甚至十几倍．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020195019412-1922557110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪枝三&lt;/strong&gt;：这是一个最优性问题，我们考虑&lt;strong&gt;最优性剪枝&lt;/strong&gt;：对于一个格子(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)的两个状态，，如果第一个状态的每一个存在的插头在第二个状态中不仅存在而且都被点燃，那么无论以后如何决策，第二个状态点燃的火箭个数不会少于第一个状态，这样我们就可以果断地舍去第一个状态．对于每一个(&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;j&lt;/em&gt;)，选择&lt;em&gt;Ones&lt;/em&gt;[&lt;em&gt;Fired&lt;/em&gt;]最多的一个状态&lt;em&gt;Best&lt;/em&gt;，如果一个状态一定不比&lt;em&gt;Best&lt;/em&gt;好，就可以舍去．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;剪枝四&lt;/strong&gt;：从&lt;strong&gt;边界情况&lt;/strong&gt;入手，边界状态非常特殊，也非常容易导致产生无效状态．分析一下，转移完最后一列的某个格子(&lt;em&gt;i&lt;/em&gt;, 6)后，如果I类插头中某个插头&lt;em&gt;p&lt;/em&gt;没有被点燃，并且II类插头中没有插头与它连通，那么这个插头就成了“无效”插头．&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020195049662-1980704185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比较以上四种剪枝的效果，由于不同的棋盘初始状态扩展的状态总数差异较大，因此选取10组不同的棋盘初始状态来测试扩展状态的总数．10组数据大致分布如下：Test 1~4依次为全部“—”，“L”,“T”，“+”，Test 5为奇数行“L”，偶数行为空，Test 6为“L”，“T”交替．Test 7~10为随机数据，“L”，“T”分布较多，Test 10的“—”较多&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;[1]&lt;/a&gt;．&lt;/p&gt;
&lt;div readability=&quot;22.893927747886&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;表4&lt;/strong&gt;&lt;strong&gt;．四种剪枝扩展的状态总数的比较&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;http://images2017.cnblogs.com/blog/1100338/201710/1100338-20171020195126365-462207951.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;由上表可以看出，优化后扩展的状态总数已经非常少了，剪枝的效果非常明显．我们从可行性和最优性两个角度，从一般情况和边界情况入手提出了4种剪枝方法，虽然有的剪枝看上去微不足道，但是它产生的效果确是惊人的．当然剪枝方法远远不止这4种，只要抓住问题的特征不断分析，就可以提出更多更好的剪枝方法．&lt;/p&gt;
&lt;p&gt;值得一提的是&lt;em&gt;S&lt;/em&gt;的状态表示，如果用普通的最小表示法，需要用10进制存储状态．由剪枝2可知如果一个插头属于一个单独的连通块，那么它一定被火柴点燃．如果使用广义的括号表示法，可以将无插头状态和单独的连通块插头都有“&lt;strong&gt;( )&lt;/strong&gt;”表示，利用&lt;em&gt;fired&lt;/em&gt;来区别，这样就可以用“&lt;strong&gt;(&lt;/strong&gt;”，“&lt;strong&gt;)&lt;/strong&gt;”，“&lt;strong&gt;)(&lt;/strong&gt;”，“&lt;strong&gt;( )&lt;/strong&gt;”——4进制完整记录下&lt;em&gt;n&lt;/em&gt;个格子的连通性，相比10进制有一定的常数优势．&lt;/p&gt;
&lt;p&gt;至此，问题完整解决，60多组测试数据运行时间&amp;lt;1.5s，实际效果确实不错．&lt;/p&gt;
&lt;p&gt;这个问题还有一个加强版&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftn1&quot;&gt;[1]&lt;/a&gt;：跟本题唯一不同的是，左边所有的火柴全部点燃，那么只要把初始状态中9个右插头全部设置为点燃，且为一个连通块即可．&lt;/p&gt;
&lt;div readability=&quot;5.3793103448276&quot;&gt;&lt;br clear=&quot;all&quot;/&gt;&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;div readability=&quot;6.2758620689655&quot;&gt;
&lt;p&gt;&lt;a title=&quot;&quot; href=&quot;http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html#_ftnref1&quot;&gt;[1]&lt;/a&gt;Zju 2126 Rocket Mania Plus&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr align=&quot;left&quot; size=&quot;1&quot; width=&quot;33%&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;小结&lt;/h3&gt;
&lt;p&gt;本章我们以RocketMania一题为例介绍了解决一类最优性的连通性状态压缩动态规划问题的剪枝技巧，从可行性和最优性这两个角度出发而达到减少状态总数的目的．在解题的过程中，要抓住问题的主要特征，多思考，多尝试，才能做的越来越好，&lt;strong&gt;优化是无止境的&lt;/strong&gt;．&lt;/p&gt;
&lt;h2&gt;六.总结&lt;/h2&gt;
&lt;p&gt;本文立足于基于连通性状态压缩动态规划问题的解法和优化两个方面．&lt;/p&gt;
&lt;p&gt;全文介绍了基于连通性状态压缩的动态规划问题的一般解法及其相关概念；针对一类特殊的问题——简单回路和简单路径问题，提出了括号表示法以及括号表示法的改进，最后从特殊问题回归到一般问题，提出了广义的括号表示法，这是文章的核心内容；接着对于一类棋盘染色问题和基于非棋盘模型的问题的解法作一个探讨；最后我们把重点放在了剪枝优化上，结合一个非常有趣的例题谈针对这类动态规划问题剪枝的重要性．&lt;/p&gt;
&lt;p&gt;当然本文不可能涵盖基于连通性状态压缩动态规划问题的方方面面，因此关键是要掌握解决问题的思路，在解题的过程中抓住问题的特征，深入分析，灵活运用．从上面的例题中可以发现，细节是不可忽略的因素，它很大程度上决定了算法的效率．因此平时我们要养成良好的编程习惯，注意细节，注重常数优化．做到多思考，多分析，多实验，不断优化，精益求精．&lt;strong&gt;让我们做得越来越好&lt;/strong&gt;&lt;strong&gt;!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;【1】    《算法艺术与信息学竞赛》 刘汝佳、黄亮&lt;/p&gt;
&lt;p&gt;【2】    金恺 2004年国家集训队作业 《Black &amp;amp; White》解题报告　&lt;/p&gt;
&lt;p&gt;【3】    毛子青 2001年国家集训队论文《动态规划算法的优化技巧》　&lt;/p&gt;
&lt;p&gt;【4】    Uva在线题库：&lt;a href=&quot;http://icpcres.ecs.baylor.edu/onlinejudge&quot;&gt;http://icpcres.ecs.baylor.edu/onlinejudge&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【5】    Ural在线题库：&lt;a href=&quot;http://acm.timus.ru&quot;&gt;http://acm.timus.ru&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【6】    Zju在线题库：&lt;span&gt;http://acm.zju.edu.cn&lt;/span&gt;&lt;/p&gt;





</description>
<pubDate>Fri, 20 Oct 2017 11:55:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/7701257.html</dc:identifier>
</item>
<item>
<title>Linux-Nand Flash驱动(分析MTD层并制作NAND驱动) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/7701181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/7701181.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.本节使用的nand flash型号为K9F2G08U0M,它的命令如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174037693-1016769043.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1我们以上图的read id(读ID)为例,它的时序图如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174046427-1205791076.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;首先需要使能CE片选&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;1)使能CLE&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2)发送0X90命令,并发出WE写脉冲&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;3)复位CLE,然后使能ALE&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;4)发送0X00地址,并发出WE写脉冲&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;5)设CLE和ALE为低电平&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;6)读出8个I/O的数据,并发出RE上升沿脉冲&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;(我们的nand flash为8个I/O口,所以型号为K9F2G08U0M)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2 nand flash 控制器介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在2440中有个nand flash 控制器,它会自动控制CLE,ALE那些控制引脚,我们只需要配置控制器,就可以直接写命令,写地址,读写数据到它的寄存器中便能完成(读写数据之前需要判断RnB脚),如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174059162-1494562079.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若在nand flash 控制器下,我们读ID就只需要如下几步(非常方便):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)将寄存器NFCONT(0x4E000004)的bit1=0,来使能片选&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)写入寄存器NFCMMD(0x4E000008)=0X90,发送命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3)写入寄存器NFADDR(0x4E00000C)=0X00,发送地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4)读取寄存器NFDATA(0x4E000010),来读取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3 我们在uboot中测试,通过md和mw命令来实现读id(x要小写)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,最终读取出&lt;span&gt;0XEC  0XDA  0X10  0X95&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174111693-2098948514.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;314&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚好对应了我们nand flash手册里的数据(其中0XEC表示厂家ID, 0XDA表示设备ID):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174119709-2062744976.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若我们要退出读ID命令时,只需要reset就行,同样地,要退出读数据/写数据时,也是reset&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4 reset的命令为0xff,它的时序图如下所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174125787-273022603.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;132&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.5 同样地,我们再参考读地址时序图来看看:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174145427-1283703938.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;378&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;span&gt;column Address&lt;/span&gt;对应列地址,表示某页里的2k地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;row Address&lt;/span&gt;对应行地址,表示具体的哪一页&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5个地址的周期的图,如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174202224-703585917.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为我们的nand flash=256MB=(2k*128M)b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以&lt;span&gt;row Address&lt;/span&gt;=128M=2^17(A27~A11)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以&lt;span&gt;column Address&lt;/span&gt;=2k=2^11( A10~A0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.接下来我们来参考自带的nand flash驱动,位于drivers/mtd/nand/s3c2410.c中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 为什么nand在mtd目录下？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为mtd(memory technology device 存储 技术设备 ) 是用于访问 memory 设备（ ROM 、 flash ）的Linux 的子系统。 MTD 的主要目的是为了使新的 memory 设备的驱动更加简单，为此它在硬件和上层之间提供了一个抽象的接口&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2首先来看s3c2410.c的入口函数:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __init s3c2410_nand_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
       printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;S3C24XX NAND Driver, (c) 2004 Simtec Electronics\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
       platform_driver_register(&lt;/span&gt;&amp;amp;&lt;span&gt;s3c2412_nand_driver);　　　　 
       platform_driver_register(&lt;/span&gt;&amp;amp;&lt;span&gt;s3c2440_nand_driver);　　　　 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; platform_driver_register(&amp;amp;&lt;span&gt;s3c2410_nand_driver);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在入口函数中,注册了一个platform平台设备驱动,也是说当与nandflash设备匹配时,就会调用s3c2440_nand_driver -&amp;gt;probe来初始化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们进入probe函数中,看看是如何初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s3c24xx_nand_probe(&lt;span&gt;struct&lt;/span&gt; platform_device *&lt;span&gt;pdev, &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; s3c_cpu_type cpu_type)
{
... ...

err &lt;/span&gt;=&lt;span&gt; s3c2410_nand_inithw(info, pdev);       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化硬件hardware,设置TACLS 、TWRPH0、TWRPH1通信时序等&lt;/span&gt;
&lt;span&gt;
s3c2410_nand_init_chip(info, nmtd, sets);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化芯片&lt;/span&gt;
&lt;span&gt;
nmtd&lt;/span&gt;-&amp;gt;scan_res = nand_scan(&amp;amp;nmtd-&amp;gt;mtd, (sets) ? sets-&amp;gt;nr_chips : &lt;span&gt;1&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.扫描nandflash&lt;/span&gt;&lt;span&gt;
... ...
s3c2410_nand_add_partition(info, nmtd, sets);         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.&lt;/span&gt;&lt;span&gt;调用add_mtd_partitions()来添加mtd分区&lt;/span&gt;
&lt;span&gt;... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 通过上面代码和注释,得出:驱动主要调用内核的nand_scan()函数,add_mtd_partitions()函数,来完成注册nandflash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.上面probe()里的 nand_scan()扫描函数 位于/drivers/mtd/nand/nand_base.c &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它会调用nand_scan()-&amp;gt;nand_scan_ident()-&amp;gt;nand_get_flash_type()来获取flash存储器的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以及nand_scan()-&amp;gt;nand_scan_ident()-&amp;gt;nand_scan_tail()来构造mtd设备的成员(实现对nandflash的读,写,擦除等)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1其中nand_get_flash_type()函数如下所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; nand_flash_dev *nand_get_flash_type(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd,&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_chip *&lt;span&gt;chip,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; busw, &lt;span&gt;int&lt;/span&gt; *&lt;span&gt;maf_id)
{
&lt;/span&gt;&lt;span&gt; struct&lt;/span&gt; nand_flash_dev *type =&lt;span&gt; NULL;
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, dev_id, maf_idx;
&lt;/span&gt;&lt;span&gt; chip&lt;/span&gt;-&amp;gt;select_chip(mtd, &lt;span&gt;0&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用nand_chip结构体的成员select_chip使能flash片选&lt;/span&gt;
&lt;span&gt;
 chip&lt;/span&gt;-&amp;gt;cmdfunc(mtd, NAND_CMD_READID, &lt;span&gt;0x00&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.2调用nand_chip结构体的成员cmdfunc,发送读id命令,最后数据保存在mtd结构体里&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;*maf_id = chip-&amp;gt;read_byte(mtd); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取厂家ID，&lt;/span&gt;
&lt;span&gt;
  dev_id &lt;/span&gt;= chip-&amp;gt;read_byte(mtd);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取设备ID&lt;/span&gt;

&lt;span&gt;   /*&lt;/span&gt;&lt;span&gt; 3.3for循环匹配nand_flash_ids[]数组,找到对应的nandflash信息&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;     for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; nand_flash_ids[i].name != NULL; i++&lt;span&gt;) &lt;br/&gt;{  
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dev_id ==&lt;span&gt; nand_flash_ids[i].id) 　　　　//匹配设备ID&lt;br/&gt;{type &lt;/span&gt;=  &amp;amp;&lt;span&gt;nand_flash_ids[i];
           &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;}&lt;br/&gt;　　}
       ... ...

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 3.4 匹配成功,便打印nandflash参数   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
printk(KERN_INFO &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NAND device: Manufacturer ID:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 0x%02x, Chip ID: 0x%02x (%s %s)\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;maf_id,
                     dev_id, nand_manuf_ids[maf_idx].name, mtd&lt;/span&gt;-&amp;gt;&lt;span&gt;name);  
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面代码和注释得出, nand_chip结构体就是保存与硬件相关的函数(后面会讲这个结构体)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 其中NAND_CMD_READID定义为0x90,也就是发送0X90命令,和0x00地址来读id,最后放到mtd中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 nand_flash_ids[]数组是个全局变量,这里通过匹配设备ID，来确定我们的nand flash是个多大的存储器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,在芯片手册中,看到nand flash的设备ID=0XDA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174222959-666919528.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以就匹配到nand_flash_ids[]里的0XDA:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174232021-1239713994.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;157&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4 然后打印出nand flash参数,我们启动内核就可以看到:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174244881-1509932734.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. probe()里的s3c2410_nand_add_partition()函数主要是注册mtd设备的nand flash&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终它调用了s3c2410_nand_add_partition()-&amp;gt;add_mtd_partitions() -&amp;gt; add_mtd_device()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中add_mtd_partitions()函数主要实现多个分区创建,也就是多次调用add_mtd_device()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当只设置nand_flash为一个分区时,就直接调用add_mtd_device()即可.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 add_mtd_partitions()函数原型如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; add_mtd_partitions(&lt;span&gt;struct&lt;/span&gt; mtd_info *master, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_partition *parts,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nbparts);　　//创建多个分区mtd设备
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函　数　成　员　介　绍　: &lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;master:就是要创建的mtd设备
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;parts:分区信息的数组,它的结构体是mtd_partition,该结构体如下所示:&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;
struct mtd_partition {
       char *name;                  //分区名,比如bootloader、params、kernel、root
       u_int32_t size;               //分区大小
       u_int32_t offset;            //分区所在的偏移值
       u_int32_t mask_flags;            //掩码标志
       struct nand_ecclayout *ecclayout; //OOB布局
       struct mtd_info **mtdp;              //MTD的指针,不常用
};
&lt;/span&gt;&lt;span&gt;*/&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nbparts:等于分区信息的数组个数,表示要创建分区的个数 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;比如我们启动内核时,也能找到内核自带的nandflash的分区信息:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174301474-58318578.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 其中add_mtd_device()函数如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; add_mtd_device(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个mtd设备&lt;/span&gt;&lt;span&gt;
{
&lt;/span&gt;&lt;span&gt; struct&lt;/span&gt; list_head *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
 ... ...
    list_for_each(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &amp;amp;mtd_notifiers)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.3找mtd_notifiers链表里的list_head结构体&lt;br/&gt;&lt;/span&gt;  {
   &lt;span&gt;struct&lt;/span&gt; mtd_notifier *not = list_entry(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mtd_notifier, list); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过list_head找到struct mtd_notifier *not&lt;/span&gt;
&lt;span&gt;   not&lt;/span&gt;-&amp;gt;add(mtd);    　　　　　　　　&lt;span&gt;//最后&lt;/span&gt;&lt;span&gt;调用mtd_notifier 的add()函数&lt;/span&gt;
&lt;span&gt;  }
 ... ...
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3 我们搜索上面函数里的mtd_notifiers链表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看看里面的list_head结构体,在哪里放入的,就能找到执行的add()是什么了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4 如下图,发现list_head在register_mtd_user()里放到mtd_notifiers链表中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174311584-733064517.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5 继续搜索register_mtd_user(),被哪个调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174317584-1938858176.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;42&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图,找到被&lt;span&gt;&lt;strong&gt;drivers/mtd/mtdchar.c&lt;/strong&gt;、&lt;strong&gt;drivers/mtd/mtd_blkdevs.c&lt;/strong&gt;&lt;/span&gt;调用(4.6节和4.7节会分析)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是因为mtd层既提供了字符设备的操作接口(mtdchar.c)， 也实现了块设备的操作接口(mtd_blkdevs.c)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在控制台输入ls -l /dev/mtd*,也能找到块MTD设备节点和字符MTD设备节点,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174345052-1041340583.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中,可以看到共创了4个分区的设备,每个分区都包含了两个字符设备(mtd%d,mtd%dro)、一个块设备(mtdblock0).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 其中MTD的块设备的主设备号为31,MTD的字符设备的主设备号为90 (后面会讲到在哪被创建)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6 我们进入上面搜到的drivers/mtd/mtdchar.c, 找到它的入口函数是init_mtdchar():&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __init init_mtdchar(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;创建字符设备mtd,主设备号为90 ,cat /proc/devices 可以看到 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt; (register_chrdev(MTD_CHAR_MAJOR, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;mtd_fops)) {
          printk(KERN_NOTICE &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Can't allocate major number %d for Memory Technology Devices.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,MTD_CHAR_MAJOR);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EAGAIN;
       }&lt;br/&gt;mtd_class &lt;/span&gt;= class_create(THIS_MODULE, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建类&lt;/span&gt;

       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (IS_ERR(mtd_class)) {
              printk(KERN_ERR &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error creating mtd class.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
              unregister_chrdev(MTD_CHAR_MAJOR, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PTR_ERR(mtd_class);
       }

       register_mtd_user(&lt;/span&gt;&amp;amp;notifier);              &lt;span&gt;//调用register_mtd_user(),&lt;/span&gt;&lt;span&gt;将notifier添加到mtd_notifiers链表中&lt;/span&gt;

       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;之所以上面没有创建设备节点,是因为此时没有nand flash驱动.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.6.1&lt;/strong&gt;&lt;/span&gt;发现上面的notifiers&lt;/span&gt;&lt;span&gt;是 mtd_notifier结构体的:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174356052-1582146137.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;4.6.2&lt;/span&gt; &lt;/strong&gt;&lt;/strong&gt;如上图,我们进入notifie的mtd_notify_add ()函数看看:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mtd_notify_add(&lt;span&gt;struct&lt;/span&gt; mtd_info*&lt;span&gt; mtd)
{
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;mtd)
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;其中MTD_CHAR_MAJOR主设备定义为90 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       class_device_create(mtd_class, NULL, MKDEV(MTD_CHAR_MAJOR, mtd&lt;/span&gt;-&amp;gt;index*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;),NULL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtd%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, mtd-&amp;gt;&lt;span&gt;index);
                                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建mtd%d字符设备节点&lt;/span&gt;
&lt;span&gt;
       class_device_create(mtd_class, NULL,MKDEV(MTD_CHAR_MAJOR, mtd&lt;/span&gt;-&amp;gt;index*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),NULL, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mtd%dro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, mtd-&amp;gt;&lt;span&gt;index);
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建mtd%dro字符设备节点&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;该函数创建了两个字符设备(mtd%d, mtd%dro ),其中ro的字符设备表示为只读&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结出:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mtdchar.c的入口函数 将notifie添加到mtd_notifiers链表中,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在add_mtd_device()函数中当查找到mtd字符设备的list_head时,就调用mtd_notifiers-&amp;gt;add()来创建两个字符设备(mtd%d,mtd%dro)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.7 同样,我们也进入mtd_blkdevs.c (&lt;/strong&gt;MTD块设备&lt;/span&gt;)中,找到注册到mtd_notifiers链表的是blktrans_notifier变量:&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174423240-1395488649.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.7.1&lt;/strong&gt;&lt;/span&gt; 然后进入blktrans_notifier变量的blktrans_notify_add ()函数:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; blktrans_notify_add(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; list_head *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mtd-&amp;gt;type ==&lt;span&gt; MTD_ABSENT)
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
 
       list_for_each(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &amp;amp;blktrans_majors) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找blktrans_majors链表里的list_head结构体&lt;/span&gt;
　　　　{
        &lt;span&gt;struct&lt;/span&gt; mtd_blktrans_ops *tr = list_entry(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mtd_blktrans_ops, list);
        tr&lt;/span&gt;-&amp;gt;add_mtd(tr, mtd);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行mtd_blktrans_ops结构体的add_mtd()&lt;/span&gt;&lt;span&gt;
       }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面的代码和注释得出:块设备的add()是查找blktrans_majors链表,然后执行mtd_blktrans_ops结构体的add_mtd()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.7.2&lt;/strong&gt;&lt;/span&gt; 我们搜索blktrans_majors链表,看看mtd_blktrans_ops结构体在哪里添加进去的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到该链表在register_mtd_blktrans()函数中:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; register_mtd_blktrans(&lt;span&gt;struct&lt;/span&gt; mtd_blktrans_ops *&lt;span&gt;tr)
{
       ... ...
ret &lt;/span&gt;= register_blkdev(tr-&amp;gt;major, tr-&amp;gt;name);              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册块设备&lt;/span&gt;&lt;span&gt;
tr&lt;/span&gt;-&amp;gt;blkcore_priv-&amp;gt;rq=blk_init_queue(mtd_blktrans_request, &amp;amp;tr-&amp;gt;blkcore_priv-&amp;gt;&lt;span&gt;queue_lock);
                                                                             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配一个请求队列&lt;/span&gt;&lt;span&gt;
... ...
       list_add(&lt;/span&gt;&amp;amp;tr-&amp;gt;list, &amp;amp;blktrans_majors);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将tr-&amp;gt;list 添加到blktrans_majors链表&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;继续搜索register_mtd_blktrans(),如下图,找到被drivers/mtd/Mtdblock.c、Mtdblock_ro.c调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174439521-17482075.png&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;39&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.7.3&lt;/strong&gt;&lt;/span&gt; 我们进入drivers/mtd/Mtdblock.c函数中,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174450021-855669270.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到执行mtd_blktrans_ops结构体的add_mtd()函数,就是上图的mtdblock_add_mtd()函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在mtdblock_add_mtd()函数中最终会调用add_mtd_blktrans_dev()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.7.4&lt;/strong&gt;&lt;/span&gt; add_mtd_blktrans_dev()函数如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; add_mtd_blktrans_dev(&lt;span&gt;struct&lt;/span&gt; mtd_blktrans_dev *&lt;span&gt;new&lt;/span&gt;&lt;span&gt;)
{
       ... ...
       gd &lt;/span&gt;= alloc_disk(&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; tr-&amp;gt;part_bits);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配一个gendisk结构体&lt;/span&gt;
&lt;span&gt;
       gd&lt;/span&gt;-&amp;gt;major = tr-&amp;gt;major;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置gendisk的主设备号&lt;/span&gt;
&lt;span&gt;
       gd&lt;/span&gt;-&amp;gt;first_minor = (&lt;span&gt;new&lt;/span&gt;-&amp;gt;devnum) &amp;lt;&amp;lt; tr-&amp;gt;part_bits;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置gendisk的起始此设备号&lt;/span&gt;
&lt;span&gt;
       gd&lt;/span&gt;-&amp;gt;fops = &amp;amp;mtd_blktrans_ops;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置操作函数&lt;/span&gt;&lt;span&gt;
       ... ...        

       gd&lt;/span&gt;-&amp;gt;queue = tr-&amp;gt;blkcore_priv-&amp;gt;rq;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置请求队列&lt;/span&gt;
&lt;span&gt;
       add_disk(gd);                                           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向内核注册gendisk结构体&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结出:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mtd_blkdevs()块设备的入口函数 将blktrans_notifier添加到mtd_notifiers链表中,并创建块设备,请求队列.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在add_mtd_device()函数中,当查找到有blktrans_notifier时,就调用blktrans_notifier-&amp;gt;add()来分配设置注册gendisk结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.显然在内核中,mtd已经帮我们做了整个框架,而我们的nand flash驱动只需要以下几步即可:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1)&lt;/strong&gt;设置mtd_info结构体成员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2)&lt;/strong&gt;设置nand_chip结构体成员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;设置硬件相关(设置nand控制器时序等)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;通过nand_scan()来扫描nandflash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5)&lt;/strong&gt;通过add_mtd_partitions()来添加分区,创建MTD字符/块设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.1 mtd_info结构体介绍:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要是实现对nandflash的read()、write()、read_oob()、write_oob()、erase()等操作,属于软件的部分,它会通过它的成员priv来找到对应的nand_chip结构体,来调用与硬件相关的操作.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;5.2 nand_chip结构体介绍:&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它是mtd_info结构体的priv成员,主要是对MTD设备中的nandflash硬件相关的描述.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们不设置nand_chip的成员时,以下的成员就会被mtd自动设为默认值,&lt;/span&gt;&lt;span&gt;代码位于: nand_scan()-&amp;gt;nand_scan_ident()-&amp;gt;nand_set_defaults()&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; nand_chip {
　　　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;  __iomem      *IO_ADDR_R;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 需要读出数据的nandflash地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　　　　&lt;span&gt;void&lt;/span&gt;  __iomem      *IO_ADDR_W;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 需要写入数据的nandflash地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 

       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 从芯片中读一个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       uint8_t    (&lt;/span&gt;*read_byte)(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd);           
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 从芯片中读一个字 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       u16         (&lt;/span&gt;*read_word)(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd);         
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将缓冲区内容写入nandflash地址, len:数据长度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;void&lt;/span&gt; (*write_buf)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;const&lt;/span&gt; uint8_t *buf, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len); 
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 读nandflash地址至缓冲区, len:数据长度   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;void&lt;/span&gt; (*read_buf)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, uint8_t *buf, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 验证芯片和写入缓冲区中的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;          (*verify_buf)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;const&lt;/span&gt; uint8_t *buf, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 选中芯片,当chip==0表示选中,chip==-1时表示取消选中 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　　　　&lt;span&gt;void&lt;/span&gt; (*select_chip)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; chip);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 检测是否有坏块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;          (*block_bad)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, loff_t ofs, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getchip);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 标记坏块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;          (*block_markbad)(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd, loff_t ofs);
　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 命令、地址控制函数 ,  dat :要传输的命令/地址 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　　　　&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;当ctrl=2表示要发送的dat是命令,否则就是dat就是地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　　　　&lt;span&gt;void&lt;/span&gt; (*cmd_ctrl)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;int&lt;/span&gt; dat,unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ctrl);
　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设备是否就绪,当该函数返回的RnB引脚的数据等于1,表示nandflash已就绪 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　　　　&lt;span&gt;int&lt;/span&gt; (*dev_ready)(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd);
　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 实现命令发送,最终调用nand_chip -&amp;gt; cmd_ctrl来实现  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;void&lt;/span&gt; (*cmdfunc)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, unsigned command, &lt;span&gt;int&lt;/span&gt; column, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; page_addr);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;等待函数,通过nand_chip -&amp;gt;dev_ready来等待nandflash是否就绪 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;          (*waitfunc)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;struct&lt;/span&gt; nand_chip *&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 擦除命令的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;void&lt;/span&gt; (*erase_cmd)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; page);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 扫描坏块 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;          (*scan_bbt)(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd);
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;          (*errstat)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;struct&lt;/span&gt; nand_chip *&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; state, &lt;span&gt;int&lt;/span&gt; status, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; page);
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 写一页 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;          (*write_page)(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;struct&lt;/span&gt; nand_chip *&lt;span&gt;chip,&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint8_t *buf, &lt;span&gt;int&lt;/span&gt; page, &lt;span&gt;int&lt;/span&gt; cached, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; raw);

       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;          chip_delay;                   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 由板决定的延迟时间 &lt;/span&gt;&lt;span&gt;*/&lt;br/&gt;&lt;/span&gt;
       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 与具体的NAND芯片相关的一些选项，默认为8位宽nand,
　   　比如设置为NAND_BUSWIDTH_16,表示nand的总线宽为16 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;   options; 


       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用位表示的NAND芯片的page大小，如某片NAND芯片
        * 的一个page有512个字节，那么page_shift就是9
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;&lt;span&gt;          page_shift;

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用位表示的NAND芯片的每次可擦除的大小，如某片NAND芯片每次可
        * 擦除16K字节(通常就是一个block的大小)，那么phys_erase_shift就是14
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;&lt;span&gt;          phys_erase_shift;

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用位表示的bad block table的大小，通常一个bbt占用一个block，
        * 所以bbt_erase_shift通常与phys_erase_shift相等
        &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;&lt;span&gt;          bbt_erase_shift;
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用位表示的NAND芯片的容量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;&lt;span&gt;          chip_shift;
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; NADN FLASH芯片的数量 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt;&lt;span&gt;          numchips;
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; NAND芯片的大小 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       uint64_t chipsize;

       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;          pagemask;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;          pagebuf;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;          subpagesize;
       uint8_t    cellinfo;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;          badblockpos;
       nand_state_t   state;
       uint8_t           &lt;/span&gt;*&lt;span&gt;oob_poi;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_hw_control  *&lt;span&gt;controller;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_ecclayout   *ecclayout;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ECC布局 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ECC校验结构体,若不设置, ecc.mode默认为NAND_ECC_NONE(无ECC校验) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;可以为硬件ECC和软件ECC校验,比如:设置ecc.mode=NAND_ECC_SOFT(软件ECC校验)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
　　　　&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; nand_ecc_ctrl ecc;      
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_buffers *&lt;span&gt;buffers;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; nand_hw_control hwcontrol;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mtd_oob_ops ops;
       uint8_t           &lt;/span&gt;*&lt;span&gt;bbt;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_bbt_descr   *&lt;span&gt;bbt_td;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_bbt_descr   *&lt;span&gt;bbt_md;
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; nand_bbt_descr   *&lt;span&gt;badblock_pattern;
       &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;        *&lt;span&gt;priv;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3本节驱动我们需要设置nand_chip的成员如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IO_ADDR_R(提供读数据)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IO_ADDR_W(提供写数据)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;select_chip(提供片选使能/禁止)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cmd_ctrl(提供写命令/地址)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dev_ready(提供nandflash的RnB脚,来判断是否就绪)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ecc.mode(设置ECC为硬件校验/软件校验)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其它成员会通过nand_scan()-&amp;gt;nand_scan_ident()-&amp;gt;nand_set_defaults()来设置为默认值.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.接下来我们就来写nand flash块设备驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考:  drivers/mtd/nand/at91_nand.c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         drivers/mtd/nand/s3c2410.c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.1本节需要用到的函数如下所示:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; nand_scan(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;int&lt;/span&gt; maxchips);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描nandflash,扫描成功返回0&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; add_mtd_partitions(&lt;span&gt;struct&lt;/span&gt; mtd_info *master,&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_partition *parts,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nbparts);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将nandflash分成nbparts个分区,会创建多个MTD字符/块设备,成功返回0
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;master:就是要创建的mtd设备
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;parts:分区信息的数组,它的结构体是mtd_partition
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nbparts:要创建分区的个数,比如上图,那么就等于4&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; del_mtd_partitions(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;master);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卸载分区,并会卸载MTD字符/块设备&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.2 在init入口函数中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1)通过kzalloc()来分配结构体: mtd_info和nand_chip&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2)通过ioremap()来分配获取nand flash 寄存器虚拟地址&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3)设置mtd_info结构体成员&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4)设置nand_chip结构体成员&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5)设置硬件相关&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;     -&amp;gt;5.1) 通过clk_get()和clk_enable()来使能nand flash 时钟&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;     -&amp;gt;5.2)设置时序&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;     -&amp;gt;5.3)关闭片选,并开启nand flash 控制器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;6)通过nand_scan()来扫描nandflash&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;7)通过add_mtd_partitions()来添加分区,创建MTD字符/块设备&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.3 在exit入口函数中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1)卸载分区,卸载字符/块设备&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2)释放mtd&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3)释放nand flash寄存器&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4)释放nand_chip&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;驱动代码如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
#include &amp;lt;linux/module.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/types.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/init.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/ioport.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/platform_device.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/delay.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/err.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/slab.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/clk.h&amp;gt;&lt;span&gt; 
#include &lt;/span&gt;&amp;lt;linux/mtd/mtd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mtd/nand.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mtd/nand_ecc.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mtd/partitions.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/io.h&amp;gt;&lt;span&gt; 
#include &lt;/span&gt;&amp;lt;asm/arch/regs-nand.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/arch/nand.h&amp;gt;

&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;  mynand_regs {
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nfconf  ;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x4E000000&lt;/span&gt;
    unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfcont  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfcmd   ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfaddr  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfdata  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfeccd0 ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfeccd1 ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfeccd  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfstat  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfestat0;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfestat1;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfmecc0 ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfmecc1 ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfsecc  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfsblk  ;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; nfeblk  ;
};
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mynand_regs *my_regs;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nand寄存器&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;my_mtd;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; nand_chip *&lt;span&gt;mynand_chip;      

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; mtd_partition mynand_part[] =&lt;span&gt; {
    [&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootloader&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .size   &lt;/span&gt;= &lt;span&gt;0x00040000&lt;/span&gt;&lt;span&gt;,
        .offset    &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    },
    [&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .offset &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND,
        .size   &lt;/span&gt;= &lt;span&gt;0x00020000&lt;/span&gt;&lt;span&gt;,
    },
    [&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kernel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .offset &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND,
        .size   &lt;/span&gt;= &lt;span&gt;0x00200000&lt;/span&gt;&lt;span&gt;,
    },
    [&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] =&lt;span&gt; {
        .name   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        .offset &lt;/span&gt;=&lt;span&gt; MTDPART_OFS_APPEND,
        .size   &lt;/span&gt;=&lt;span&gt; MTDPART_SIZ_FULL,
    }
};

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;nand flash  :CE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mynand_select_chip(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; chipnr)
{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(chipnr==-&lt;span&gt;1&lt;/span&gt;)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CE Disable&lt;/span&gt;
&lt;span&gt;       {
        my_regs&lt;/span&gt;-&amp;gt;nfcont|=(&lt;span&gt;0x01&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bit1置1&lt;/span&gt;
&lt;span&gt;       }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CE Enable&lt;/span&gt;
&lt;span&gt;       {
        my_regs&lt;/span&gt;-&amp;gt;nfcont&amp;amp;=~(&lt;span&gt;0x01&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bit1置0&lt;/span&gt;&lt;span&gt;  
       }            
}
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;命令/地址控制函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mynand__cmd_ctrl(&lt;span&gt;struct&lt;/span&gt; mtd_info *mtd, &lt;span&gt;int&lt;/span&gt; dat, unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ctrl)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ctrl &amp;amp; NAND_CLE)                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前为command状态 ,   &lt;/span&gt;
          my_regs-&amp;gt;nfcmd=&lt;span&gt;dat;   
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前为地址状态 ,  if  (ctrl &amp;amp; NAND_ALE)   &lt;/span&gt;
         my_regs-&amp;gt;nfaddr=&lt;span&gt;dat;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; nand flash 设备就绪函数(获取RnB引脚状态 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mynand__device_ready(&lt;span&gt;struct&lt;/span&gt; mtd_info *&lt;span&gt;mtd)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (my_regs-&amp;gt;nfstat&amp;amp;&lt;span&gt;0x01&lt;/span&gt;);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取RnB状态,0:busy       1:ready&lt;/span&gt;
&lt;span&gt;}
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;init入口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; mynand_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; clk *&lt;span&gt;nand_clk;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; res;
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;1.分配结构体: mtd_info和nand_chip &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   my_mtd&lt;/span&gt;=kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mtd_info), GFP_KERNEL);      
   mynand_chip&lt;/span&gt;=kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; nand_chip), GFP_KERNEL);
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2.获取nand flash 寄存器虚拟地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
     my_regs&lt;/span&gt;=ioremap(&lt;span&gt;0x4E000000&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; mynand_regs));

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3.设置mtd_info&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    my_mtd&lt;/span&gt;-&amp;gt;owner=&lt;span&gt;THIS_MODULE;
    my_mtd&lt;/span&gt;-&amp;gt;priv=mynand_chip;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;私有数据&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.设置nand_chip&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    mynand_chip&lt;/span&gt;-&amp;gt;IO_ADDR_R=&amp;amp;my_regs-&amp;gt;nfdata;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置读data&lt;/span&gt;
    mynand_chip-&amp;gt;IO_ADDR_W=&amp;amp;my_regs-&amp;gt;nfdata;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置写data&lt;/span&gt;
    mynand_chip-&amp;gt;select_chip=mynand_select_chip;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置CE &lt;/span&gt;
    mynand_chip-&amp;gt;cmd_ctrl = mynand__cmd_ctrl;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置写command/address&lt;/span&gt;
    mynand_chip-&amp;gt;dev_ready = mynand__device_ready;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置RnB
    &lt;/span&gt;&lt;span&gt;mynand_chip-&amp;gt;ecc.mode = NAND_ECC_SOFT;                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置软件ECC&lt;/span&gt;


    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;5.设置硬件相关&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;    
        &lt;span&gt;/*5.1&lt;/span&gt;&lt;span&gt;使能nand flash 时钟&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        nand_clk&lt;/span&gt;=clk_get(NULL,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        clk_enable(nand_clk); &lt;br/&gt;&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;5.2设置时序&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;#define&lt;/span&gt; TACLS       0                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0nS&lt;/span&gt;
        &lt;span&gt;#define&lt;/span&gt; TWRPH0   1                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;15nS&lt;/span&gt;
        &lt;span&gt;#define&lt;/span&gt; TWRPH1   0                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5nS&lt;/span&gt;&lt;span&gt;
        my_regs&lt;/span&gt;-&amp;gt;nfconf = (TACLS&amp;lt;&amp;lt;&lt;span&gt;12&lt;/span&gt;) | (TWRPH0&amp;lt;&amp;lt;&lt;span&gt;8&lt;/span&gt;) | (TWRPH1&amp;lt;&amp;lt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;5.3       bit1:关闭片选,       bit0:开启nand flash 控制器&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        my_regs&lt;/span&gt;-&amp;gt;nfcont=(&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;)|(&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;6.扫描NAND&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (nand_scan(my_mtd, &lt;span&gt;1&lt;/span&gt;)) {                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1:表示只扫描一个nand flash 设备&lt;/span&gt;
        res = -&lt;span&gt;ENXIO;
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
    }
            
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;7.添加分区,创建字符/块设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    res &lt;/span&gt;= add_mtd_partitions(my_mtd, mynand_part, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;); 
    if(res)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;:
    del_mtd_partitions(my_mtd);                 　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卸载分区,卸载字符/块设备&lt;/span&gt;
    kfree(my_mtd);                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放mtd&lt;/span&gt;
    iounmap(my_regs);                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放nand flash寄存器&lt;/span&gt;
    kfree(mynand_chip);                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放nand_chip&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;exit出口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mynand_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    del_mtd_partitions(my_mtd);     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卸载分区,卸载字符/块设备&lt;/span&gt;
    kfree(my_mtd);                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放mtd&lt;/span&gt;
    iounmap(my_regs);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放nand flash寄存器&lt;/span&gt;
    kfree(mynand_chip);                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放nand_chip&lt;/span&gt;&lt;span&gt;
}

module_init(mynand_init);
module_exit(mynand_exit);
MODULE_LICENSE(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.编译启动内核&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.1 重新设置编译内核(去掉默认的nand flash驱动)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;make menuconfig ,进入menu菜单重新设置内核参数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进入-&amp;gt; Device Drivers-&amp;gt; Memory Technology Device (MTD) support-&amp;gt; NAND Device Support&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt; &amp;gt;   NAND Flash support &lt;span&gt;for&lt;/span&gt; S3C2410/S3C2440 SoC    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉默认的nandflash驱动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后make uImage 编译内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将新的nandflash驱动模块放入nfs文件系统目录中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.2然后烧写内核,启动内核&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图,发现内核启动时,卡住了,是因为我们使用的文件系统是存在nand flash上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174510912-812252226.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以设置为nfs文件系统才行.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.挂载nand flash 驱动&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.1如下图,可以看到共添了4个分区: bootloader、params、kernel、root、&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚好对应了程序中的mynand_part数组里面的分区信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174525662-1039737997.png&quot; alt=&quot;&quot; width=&quot;730&quot; height=&quot;230&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.2 如下图,可以看到/dev下共创建了4个MTD块设备(mtdblock%d),4个MTD字符设备(mtd%d、mtd%dro)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174534302-617298196.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;236&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8.3 如下图,使用cat /proc/partitions ,可以看到分区信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174543021-1467156378.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;146&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中blocks表示分区的容量,每个blocks是1KB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9. 使用mount来挂载mtd块设备&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mount /dev/mtdblock3        /mnt/             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;挂载, mount会自动获取该设备的文件类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;进入mnt,可以看到里面就是我们之前存在nand flash上的文件系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174553427-667810030.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10. 使用mtd-util 工具擦除mtdblock3(使用nand之前最好擦除一次)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;因为flash的&lt;span&gt;特性如&lt;/span&gt;&lt;span&gt;下:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写入，只能把数据(bit)从1改为0；擦除，只能把所有数据(bit)从0改为1。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;所以，要想写入数据之前必须先擦除。因为flash只能写0,写1时其实是保持原来的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;10.1 使用mtd-util工具步骤如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
tar -xjf mtd-utils-&lt;span&gt;05.07&lt;/span&gt;.&lt;span&gt;23&lt;/span&gt;.tar.bz2       　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解压mtd-util工具&lt;/span&gt;&lt;span&gt;
cd mtd&lt;/span&gt;-utils-&lt;span&gt;05.07&lt;/span&gt;.&lt;span&gt;23&lt;/span&gt;/util /                 　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入util目录&lt;/span&gt;&lt;span&gt;
vi Makefile                                     /&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;修改交叉编译改为: CROSS=arm-linux-&lt;/span&gt;&lt;span&gt;
make                                          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译,生成flashcp 、flash_erase、flash_eraseall等命令&lt;/span&gt;&lt;span&gt;
cp  flash_erase  flash_eraseall  &lt;/span&gt;/nfs文件系统目录   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;复制命令&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.2mtd-util工具的常用命令介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;命令:&lt;span&gt;flashcp&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用:&lt;/strong&gt; copy数据到 flash 中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实例:&lt;/strong&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./flashcp   fs.yaffs2  /dev/mtd0      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将文件系统yaffs2复制到mtd0中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;命令:&lt;span&gt;flash_erase&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用:&lt;/strong&gt;擦除某个分区的指定范围 (其中指定位置必须以0x20000(128K)为倍数)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实例:&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
./flash_erase  /dev/mtd0 &lt;span&gt;0x20000&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;擦除mtd0从0x20000开始的5块数据 ,128K/块&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;命令:&lt;span&gt;flash_eraseall&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作用:&lt;/strong&gt;擦除整个分区的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实例:&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./flash_eraseall  /dev/mtd0        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;擦除mtd0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.3为什么这里的实例都是对mtd字符设备进行操作,而不是mtdblock块设备？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为每个分区的字符设备，其实就是对应着每个分区块设备。即/dev/mtd3对应/dev/mtdblock3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flash_eraseall, flash_erase那些命令是以ioctl等基础而实现, 而块设备不支持ioctl, 只有字符设备支持&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.4 使用flash_eraseall来擦除分区3&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
umount /mnt                                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;擦除之前需要使用umount mnt来取消之前的挂载&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;/flash_eraseall  /dev/mtd3                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;擦除mtd3&lt;/span&gt;&lt;span&gt;
mount &lt;/span&gt;-t yaffs /dev/mtdblock3 /mnt/                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用yaffs类型来挂载mtdblock3块设备
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为当前的mtdblock3为空,mount命令无法自动获取mtdblock3的文件类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图,可以看到分区3已经为空了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201710/1182576-20171020174605443-1882517256.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;88&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 11:29:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/7701181.html</dc:identifier>
</item>
<item>
<title>我的three.js学习记录（三） - 156庄威龙</title>
<link>http://www.cnblogs.com/lger/p/7700405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lger/p/7700405.html</guid>
<description>&lt;p&gt;此次的亮点不是three.js的3d部分，而是通过调用摄像头然后通过摄像头的图像变化进行简单的判断后进行一些操作。上篇中我通过简单的示例分析来学习three.js，这次是通过上一篇的一些代码来与摄像头判断部分的代码相互结合，弄一个新的东西，可以看下图&lt;br/&gt;&lt;img src=&quot;https://files.cnblogs.com/files/lger/GIF%E5%8A%A8%E7%94%BB%E5%BD%95%E5%88%B6%E5%B7%A5%E5%85%B720171020151958.gif&quot; alt=&quot;示例&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;说明&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;这次的示例是我们可以通过一个摄像头隔空控制我们屏幕中的视频的播放。&lt;br/&gt;原理其实也是很简单，我们看到的摄像头图像其实是通过获取到的图像数据然后再通过&lt;code&gt;canvas&lt;/code&gt; 画上去的，这里有两层&lt;code&gt;canvas&lt;/code&gt; 一层是我们的正常的摄像头输出，一层是我们的播放按钮和暂停按钮。然后还有一层&lt;code&gt;canvas&lt;/code&gt;被我们隐藏了，这层隐藏的就是将我们的上次的图像输出记录下来作为缓存的作用。这层隐藏的&lt;code&gt;canvas&lt;/code&gt;和图像输出的进行特定区域（按钮区域）的RGB值的判断，如果判断到波动了一定的范围，那么我们就进行特定的操作。&lt;/p&gt;
&lt;blockquote readability=&quot;3.4081632653061&quot;&gt;
&lt;p&gt;&lt;strong&gt;相关&lt;/strong&gt;&lt;br/&gt;我们这里除了需要用到我们three.js的相关知识还需要用到&lt;code&gt;canvas&lt;/code&gt;和js调用摄像头的工作，所以这里我给出一些链接，希望有用&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/getUserMedia&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/getUserMedia&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qq_16559905/article/details/51743588&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_16559905/article/details/51743588&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.w3school.com.cn/tags/html_ref_canvas.asp&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/tags/html_ref_canvas.asp&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.w3school.com.cn/tags/tag_canvas.asp&quot; class=&quot;uri&quot;&gt;http://www.w3school.com.cn/tags/tag_canvas.asp&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;准备工作&quot;&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;通过以上的说明，我们现在开始工作&lt;br/&gt;在准备工作中我们需要用到&lt;a href=&quot;http://blog.csdn.net/lger_pro/article/details/78250542&quot;&gt;我的three.js学习记录（一）&lt;/a&gt;和&lt;a href=&quot;http://blog.csdn.net/lger_pro/article/details/78251782&quot;&gt;我的three.js学习记录（二）&lt;/a&gt;的一些东西，这里就不一一列举出来了。&lt;br/&gt;首先，我们先来看一下html代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;webcam_demo&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            overflow: hidden;
        }
    &amp;lt;/style&amp;gt;
    &amp;lt;script src=&quot;js/three.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/stats.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/dat.gui.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/Detector.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/DDSLoader.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/day1020.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;js/OrbitControls.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;!--加载我们要看的视频--&amp;gt;
&amp;lt;video id=&quot;video&quot; src=&quot;video/sintel.ogv&quot; style=&quot;display: none; left: 15px; top: 75px;&quot;&amp;gt;&amp;lt;/video&amp;gt;
&amp;lt;!--加载我们的摄像机的图像--&amp;gt;
&amp;lt;video id=&quot;webcam&quot; autoplay style=&quot;display: none; width: 320px; height: 240px;&quot;&amp;gt;&amp;lt;/video&amp;gt;

&amp;lt;div id=&quot;canvasLayers&quot; style=&quot;position: relative; left: 0; top: 0;&quot;&amp;gt;
    &amp;lt;!--画摄像头输出图像--&amp;gt;
    &amp;lt;canvas id=&quot;videoCanvas&quot; width=&quot;320&quot; height=&quot;240&quot; style=&quot;z-index: 1; position: absolute; left:0; top:0; opacity:0.5;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
    &amp;lt;!--画出按钮--&amp;gt;
    &amp;lt;canvas id=&quot;layer2&quot;  width=&quot;320&quot; height=&quot;240&quot; style=&quot;z-index: 2; position: absolute; left:0; top:0; opacity:0.5;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;canvas id=&quot;blendCanvas&quot; style=&quot;display: none; position: relative; left: 320px; top: 240px; width: 320px; height: 240px;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;

&amp;lt;!--加载摄像机，主要是将我们的摄像机获取的图像数据放入video#webcam中--&amp;gt;
&amp;lt;script&amp;gt;
    navigator.getUserMedia = navigator.getUserMedia ||
        navigator.webkitGetUserMedia ||
        navigator.mozGetUserMedia;

    if (navigator.getUserMedia) {
        navigator.getUserMedia({ audio: false, video: { width: 1280, height: 720 } },
            function(stream) {
                var video = document.querySelector('#webcam');
                video.srcObject = stream;
                video.onloadedmetadata = function(e) {
                    video.play();
                };
            },
            function(err) {
                console.log(&quot;当前错误：&quot; + err.name);
            }
        );
    } else {
        console.log(&quot;设备不支持&quot;);
    }
&amp;lt;/script&amp;gt;

&amp;lt;!--用作渲染器的容器--&amp;gt;
&amp;lt;div id=&quot;webgl&quot; style=&quot;position: absolute; left: 0; top: 0;&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!--这里的js文件是操作我们图像处理部分的--&amp;gt;
&amp;lt;script src=&quot;js/webcam.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    threeStart();
&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的html代码主要是布局还有将我们需要的视频以及我们的摄像机需要的图像数据加载进来，其他的处理部分则是调用了&lt;code&gt;threeStart()&lt;/code&gt;来实现&lt;/p&gt;
&lt;h4 id=&quot;开发&quot;&gt;&lt;strong&gt;开发&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;现在我们已经搭建好了一切我们需要的（上两篇博客中已经有了，只是沿用上次的进行开发），现在我们来处理我们获取到的图像数据，然后进行判断图像的变化，如果变化的量超过了一定的值我们就进行特定的操作。&lt;/p&gt;
&lt;p&gt;这里不同于上一篇博客&lt;a href=&quot;http://blog.csdn.net/lger_pro/article/details/78251782&quot;&gt;我的three.js学习记录（二）&lt;/a&gt;的地方除了减少了一些东西外，我们的&lt;code&gt;arimate()&lt;/code&gt;函数也做了一些变化，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 回调函数，重画整个场景
 */
var isPlayTv = false;
function arimate() {

    if (isPlayTv &amp;amp;&amp;amp; video.readyState === video.HAVE_ENOUGH_DATA) {
        if (texture) texture.needsUpdate = true;
        // video.play();
    }
    //将我们的摄像头的图像和按钮图片分别放入两层canvas中
    renderWebcam();
    blender();
    checkUpdate(function (msg) {
        if (msg === 'play') {
            isPlayTv = true;
            video.play();
        } else {
            isPlayTv = false;
            video.pause();
        }
    });
    //渲染
    renderer.render(scene, camera);
    //fps状态更新
    stats.update();
    //重新调用arimate
    requestAnimationFrame(arimate);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们来看看上面的三个函数，分别是&lt;code&gt;renderWebcam()&lt;/code&gt;，&lt;code&gt;blender()&lt;/code&gt;，&lt;code&gt;checkUpdate(func)&lt;/code&gt;&lt;br/&gt;这三个函数的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//我们从摄像机获取的图像数据就存放于video#webcam
var webcam = document.getElementById('webcam');
//画出我们的摄像机图像
var videoCanvas = document.getElementById('videoCanvas');
var videoContext = videoCanvas.getContext('2d');

//专门用于画出按钮（播放和暂停）
var layer2Canvas = document.getElementById('layer2');
var layer2Context = layer2Canvas.getContext('2d');

var blendCanvas = document.getElementById('blendCanvas');
//这里主要是用于缓冲，储存上一个视频图像与下一个视频图像之间的变化
var blendContext = blendCanvas.getContext('2d');

//这里是加入我们的两个按钮（分别都是图片）
var buttons = [];

var button1 = new Image();
button1.src =&quot;img/play.png&quot;;
var buttonData2 = { name:&quot;play&quot;, image:button1, x:320 - 64 - 20, y:10, w:32, h:32 };
buttons.push( buttonData2 );

var button2 = new Image();
button2.src =&quot;img/pause.png&quot;;
var buttonData3 = { name:&quot;pause&quot;, image:button2, x:320 - 32 - 10, y:10, w:32, h:32 };
buttons.push( buttonData3 );

// 这里能将视频反转，缺一不可，是一个搭配
videoContext.translate(320, 0);
videoContext.scale(-1, 1);

// 设置背景颜色，如果没有视频输出显示该颜色
videoContext.fillStyle = '#005337';
videoContext.fillRect( 0, 0, videoCanvas.width, videoCanvas.height );

var lastImage;
/**
 * 功能：主要是拿我们当前的canvas#videoCanvas上下文中的图像数据，与我们上次的数据lastImage作比较
 * 然后将我们比较后的数据的结果放入canvas#blendCanvas的上下文，当我们调用checkUpdate(func)
 * 就能调用canvas#blendCanvas的上下文的数据做判断是否按钮区域的rgb是否变化然后调用func
 */
function blender() {
    var width = videoCanvas.width;
    var height = videoCanvas.height;

    //获取摄像机视频中的图像资源信息，包括了rgba，是一个数组，数组大小是像素的4倍（rgba）
    //r = temp[0]; g = temp[1]; b = temp[2]; a = temp[3];
    var source = videoContext.getImageData(0, 0, width, height);
    //创建一个跟视频cavas一样大小的图像数据区
    var blend = videoContext.createImageData(width, height);
    //如果没有上次的数据则置入本次的图像数据
    if (!lastImage)lastImage = videoContext.getImageData(0, 0, width, height);
    //判断我们rgb的值有没有变化
    differenceAccuracy(blend.data, source.data, lastImage.data);
    //将我们判断后的数据blend放入blendCanvas上下文
    blendContext.putImageData(blend, 0, 0);
    //将我们上次的数据置为本次
    lastImage = source;

    /**
     * 混合源rgb值和前rgb值，得到当前像素点是否发生改变 改变用1表示，不改变用0表示
     * @param targetData 转换的目标rgba数组
     * @param sourceData 源，即当前的视频图像rgba数组
     * @param lastData 上一个图像数组
     */
    function differenceAccuracy(targetData, sourceData, lastData) {
        if (sourceData.length !== lastData.length) return null;
        var i = 0;
        //这里sourceData.length * 0.25只是获取图像的1/4
        //这里用一维数组获取数据是因为整个图像rbga二维值都使用一维数组
        while (i &amp;lt; (sourceData.length * 0.25))
        {
            //这里每隔4个像素点获取一个像素rgba值
            var average1 = (sourceData[4*i] + sourceData[4*i+1] + sourceData[4*i+2]) / 3;
            var average2 = (lastData[4*i] + lastData[4*i+1] + lastData[4*i+2]) / 3;
            //算出我们的上一个和当前的图像数据的值是否超过一个规定的值（可以理解为对变化的敏感度）
            //如果是则将diff置为0xFF，否0
            var diff = threshold(Math.abs(average1 - average2));
            
            //将算出的值放入targetData
            targetData[4*i]   = diff;
            targetData[4*i+1] = diff;
            targetData[4*i+2] = diff;
            targetData[4*i+3] = 0xFF;
            ++i;
        }

        function threshold(value)
        {
            return (value &amp;gt; 0x15) ? 0xFF : 0;
        }
    }
}

function renderWebcam() {
    if ( webcam.readyState === webcam.HAVE_ENOUGH_DATA ){
        //将我们video#webcam的图像数据使用videoCanvas画出来
        videoContext.drawImage(webcam, 0, 0, videoCanvas.width, videoCanvas.height);
        //画出我们的图片按钮播放和暂停
        for ( var i = 0; i &amp;lt; buttons.length; i++ )
            layer2Context.drawImage( buttons[i].image, buttons[i].x, buttons[i].y, buttons[i].w, buttons[i].h );
    }
}

/**
 * 判断canvas#blendCanvas的上下文数据总体上是否变化，如果是则调用func
 * @param func 回调
 */
function checkUpdate(func) {
    //我们这里是循环按钮的个数，我们这里有两个按钮，有可能两个按钮都有变化
    for (var i = 0; i &amp;lt; buttons.length; i++){
        var data = blendContext.getImageData(buttons[i].x, buttons[i].y, buttons[i].w, buttons[i].h).data;
        //储存当前区域的countPixels数量的rgb相加的总值
        var sum = 0;
        //countPixels是我们区域中所有的像素点的1/4
        var countPixels = data.length * 0.25;
        for (var j = 0; j &amp;lt; countPixels; j++){
            //因为我们countPixels所有的像素点的1/4，所以每一次需要*4
            sum += data[4*j] + data[4*j+1] + data[4*j+2];
        }
        //做出平均值
        var average = Math.round((sum / (3 * countPixels)));
        //如果平均值大于某个值则判断为变化了，就调用func将我们按钮区域的名字传过去
        if (average &amp;gt; 50){
            func(buttons[i].name);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码就是我们处理图像的核心，通过以上的代码可以判断我们的按钮区域的rgb值是否在总体上变化，如果变化就进行调用&lt;code&gt;func&lt;/code&gt;，这里也就进入尾声了&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;本次的调用摄像头来进行隔空的操作需要感谢http://stemkoski.github.io/本链接提供的东西，里面有很多操作，可以供我们学习，这篇博客个人感觉写的不是很好，毕竟思路还是没有理清晰，可能是因为对于代码的不完全理解吧，希望海涵&lt;/p&gt;
&lt;p&gt;以上代码已经上传&lt;a href=&quot;https://github.com/Mr-Pro/three.js-demo&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 09:09:00 +0000</pubDate>
<dc:creator>156庄威龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lger/p/7700405.html</dc:identifier>
</item>
<item>
<title>【node】nvm进行node多版本管理 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7696127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7696127.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;nvm&lt;/strong&gt;&lt;/span&gt;（nodejs version manager）是nodejs的管理工具，如果你需要快速更新node版本，并且不覆盖之前的版本；或者想要在不同的node版本之间进行切换；&lt;/p&gt;
&lt;p&gt;使用nvm来安装我们的node开发环境是绝佳的选择！&lt;/p&gt;
&lt;p&gt;今天我使用vue-cli初始化项目，发现自己卡在了项目描述，重复了好几次，无论怎么回车或者尝试其他去解决也无济于事，终于找到了原因所在：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171019214302302-521744711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因其实是我的&lt;span&gt;node版本过高，或者不是稳定版本，需要降低node版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么就让我们使用nvm管理我们的node版本吧！&lt;/p&gt;

&lt;p&gt;下载使用之前，避免不必要的麻烦，先将之前的node版本删除（同时清除相应的多余的环境变量也是一个好习惯）；&lt;/p&gt;
&lt;p&gt; 现在nvm-windows的版本是1.1.6,最新稳定的版本是1.1.5；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;a title=&quot;okaychen&quot; href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/coreybutler/nvm-windows/releases&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171019215514537-69035209.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不需要关注其他的话，下载&lt;span&gt;nvm-setup.zip&lt;/span&gt;即可；&lt;/p&gt;
&lt;p&gt;1、下载解压后&lt;span&gt;nvm-setup.exe&lt;/span&gt;点击：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个路径&lt;/span&gt;是你的nvm安装的路径，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171019220054146-64403248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个路径&lt;/span&gt;是node快捷启动的路径（使用nvm下载后的node默认在nvm文件中，这个路径是创建的一个快捷方式的路径）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171019220105302-292023429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后通过 &lt;span&gt;&lt;strong&gt;nvm -v &lt;/strong&gt;&lt;/span&gt;查看是否安装成功&lt;/p&gt;

&lt;p&gt;2、接下来打开&lt;span&gt;setting.txt&lt;/span&gt;文件，添加如下：（root和path路径是安装的时候选择好的，setting.txt已经同步到，没有需要的话不用修改）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
arch: 64&lt;span&gt;  
proxy&lt;/span&gt;:&lt;span&gt; none
node_mirror&lt;/span&gt;: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;npm.taobao.org/mirrors/node/ &lt;/span&gt;
npm_mirror: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;npm.taobao.org/mirrors/npm/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、然后我们就需要添加环境变量了：（其实只需要将root和path的路径添加到环境变量中即可）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171019221440084-761086446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、那么我们来下载一个版本的node，并使用它吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nvm install 6.2.0     *&lt;span&gt;选择安装node 版本
nvm &lt;/span&gt;&lt;span&gt;list&lt;/span&gt;                  *&lt;span&gt;列出已安装版本
nvm &lt;/span&gt;&lt;span&gt;use&lt;/span&gt; 6.2.0        *切换使用的node版本    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们下载了node 6.2.0版本，通过&lt;span&gt;nvm use 版本号&lt;/span&gt; 来使用它，通过这样我们可以切换node版本。&lt;/p&gt;

&lt;p&gt;那么在来证实一下上面说的安装过程中的第二个路径的问题：&lt;/p&gt;
&lt;p&gt;当我们install之后，发现第二个路径下没有添加nodejs文件，但是当我们使用nvm use命令后，发现该文件下多了一个快捷方式的文件；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171019222010193-694967683.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;几个常用的命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
nvm install 6.2.0        *&lt;span&gt;选择安装node 版本
nvm &lt;/span&gt;&lt;span&gt;use&lt;/span&gt; 6.2.0            *&lt;span&gt;切换使用的node版本  
nvm &lt;/span&gt;&lt;span&gt;list&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查看已安装的 node 版本&lt;/span&gt;

    7.2.0
   *6.2.0(Currently using 64-&lt;span&gt;bit executable)
    &lt;/span&gt;4.4.4&lt;span&gt; 

nvm uninstall &lt;/span&gt;6.2.0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;卸载对应的版本&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 20 Oct 2017 09:01:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7696127.html</dc:identifier>
</item>
<item>
<title>[js插件开发教程]原生js仿jquery架构扩展开发选项卡插件 - ghostwu</title>
<link>http://www.cnblogs.com/ghostwu/p/7700288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghostwu/p/7700288.html</guid>
<description>&lt;p&gt;jquery插件一般是这么干的： $.fn.插件名称 = function(){}， 把插件的名称加在.fn上，在源码里面实际上是扩展到构造函数的原型对象上，如果你没看过jquery的源代码，或者你曾经看过，但是不知道为什么把插件扩展到fn上，那么本篇文章就能解答你的疑惑。关于jquery插件开发方式，可以参考我的这篇文章：&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/ghostwu/p/7449318.html&quot;&gt;[js高手之路]jquery插件开发实战-选项卡详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于选项卡这个功能具体怎么做，不在这里详解，这个是入门级的功能，本文重在讨论插件开发的架构，扩展，以及参数设置。&lt;/p&gt;
&lt;p&gt;如果你使用过jquery的选项卡插件，或者其他类型的插件，他们一般都是这么调用的：&lt;/p&gt;
&lt;p&gt;$( &quot;.tab&quot; ).tabs( {} )&lt;/p&gt;
&lt;p&gt;$(&quot;.tab&quot;).tabs( function(){} );&lt;/p&gt;
&lt;p&gt;一种是传递参数定制插件行为&lt;/p&gt;
&lt;p&gt;一种是传递函数定制插件行为&lt;/p&gt;
&lt;p&gt;$(&quot;.tab&quot;) 选择到元素，然后返回的是jquery对象&lt;/p&gt;
&lt;p&gt;tabs方法扩展在fn上就是扩展都jquery构造函数的原型对象上， 那么对象( $(&quot;.tab&quot;) )调用原型对象上的方法( tabs )当然就顺利成章了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以jquery插件扩展本质就是： 构造函数 + 原型对象扩展方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义一个构造+原型的方式，下面代码的原理，我在这篇文章有详细论述：&lt;a id=&quot;CategoryEntryList1_ctl00_rptEntries_TitleUrl_28&quot; class=&quot;PostTitle&quot; href=&quot;http://www.cnblogs.com/ghostwu/p/7427277.html&quot;&gt;[js高手之路] 设计模式系列课程 - jQuery的链式调用与灵活的构造函数&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5d0fd324-545e-4606-a9a5-95da16cf794b')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_5d0fd324-545e-4606-a9a5-95da16cf794b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d0fd324-545e-4606-a9a5-95da16cf794b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5d0fd324-545e-4606-a9a5-95da16cf794b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d0fd324-545e-4606-a9a5-95da16cf794b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; G = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( selectors, context ){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; G.fn.init( selectors, context );
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     G.fn = G.prototype =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         length : 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        constructor : G,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         size : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.length;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         init : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( selector, context ){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.length = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             context = context ||&lt;span&gt; document;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( selector.indexOf( '#' ) == 0&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;[0] = document.getElementById( selector.substring( 1&lt;span&gt; ) );
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.length = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; aNode =&lt;span&gt; context.querySelectorAll( selector );
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0, len = aNode.length; i &amp;lt; len; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;[i] =&lt;span&gt; aNode[i];
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.length =&lt;span&gt; len;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.selector =&lt;span&gt; selector;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     G.fn.init.prototype = G.fn;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;接下来，我们还要添加一个插件扩展机制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('87a0ba70-9e40-494f-85dd-f9d4c3078b06')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_87a0ba70-9e40-494f-85dd-f9d4c3078b06&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_87a0ba70-9e40-494f-85dd-f9d4c3078b06&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('87a0ba70-9e40-494f-85dd-f9d4c3078b06',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_87a0ba70-9e40-494f-85dd-f9d4c3078b06&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; G.extend = G.fn.extend = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; i = 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             len =&lt;span&gt; arguments.length,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             dst = arguments[0&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            j;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (dst.length ===&lt;span&gt; undefined) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             dst.length = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             dst = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arguments[i]) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 dst[j] =&lt;span&gt; arguments[i][j];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 dst.length++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dst;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     };
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在这篇文章：&lt;a id=&quot;CategoryEntryList1_ctl00_rptEntries_TitleUrl_27&quot; class=&quot;PostTitle&quot; href=&quot;http://www.cnblogs.com/ghostwu/p/7428026.html&quot;&gt;[js高手之路] 设计模式系列课程 - jQuery的extend插件机制&lt;/a&gt; 有详细的论述，extend插件扩展机制&lt;/p&gt;
&lt;p&gt;像使用jquery一样暴露接口：&lt;/p&gt;
&lt;pre&gt;
var $ = function( selectors, context ){&lt;br/&gt;return G( selectors, context );&lt;br/&gt;}&lt;br/&gt;window.$ = $;
&lt;/pre&gt;
&lt;p&gt;这个插件的扩展机制和元素选择机制就完成了，如果要扩展插件，只要在&lt;/p&gt;
&lt;p&gt;G.fn上扩展插件的名称即可，如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; G.fn.tabs = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( options ){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     options = options ||&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; defaults =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         contentClass : 'tab-content'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         navClass : 'tab-nav'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         activeClass : 'active'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         triggerElements : '*'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         activeIndex : 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         evType : 'click'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         effect : 'none'
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; opt =&lt;span&gt; G.extend( {}, defaults, options );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，我们就在G的原型对象上扩展了一个tabs( 选项卡 )插件&lt;/p&gt;
&lt;p&gt;options可以定制插件的行为：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
contentClass : 'tab-content',     选项卡内容区域的class名称&lt;br/&gt;navClass : 'tab-nav',             标签卡区域的class名称 &lt;br/&gt;activeClass : 'active',           标签卡默认选择的class名称:active&lt;br/&gt;triggerElements : '*',            标签卡默认触发元素&lt;br/&gt;activeIndex : 0,                  默认选中第几个标签卡&lt;br/&gt;evType : 'click',                 选项卡触发的事件类型&lt;br/&gt;effect : 'none'                   是否有过渡特效：如透明度&lt;p&gt;&lt;strong&gt;&lt;span&gt;var opt = G.extend( {}, defaults, options );&lt;/span&gt;&lt;/strong&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;这一段是把定制的配置和默认配置合成到一个对象opt里面，后面的插件行为，就可以根据opt的配置进行定制，这是插件开发参数定制中，常用的一招。&lt;/p&gt;
&lt;p&gt;这样做的好处，可以防止污染默认配置defaults&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; tabContent = &lt;span&gt;this&lt;/span&gt;[0].querySelector( &quot;.&quot; +&lt;span&gt; opt.contentClass );
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabContentEle =&lt;span&gt; tabContent.children;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabNavEle = &lt;span&gt;this&lt;/span&gt;[0].querySelectorAll( &quot;.&quot; + opt.navClass + '&amp;gt;' +&lt;span&gt; opt.triggerElements );
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _contentLen =&lt;span&gt; tabContentEle.length;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _index = opt.activeIndex;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取对应的元素。&lt;/p&gt;
&lt;p&gt;有了选项卡的元素和配置，我们就开始做业务处理（为所有选项卡添加处理的事件，进行选项卡切换）&lt;/p&gt;
&lt;p&gt;定义一个专门的对象_api = {}， 扩展业务api&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('260f7b86-fd05-446d-a907-79df167626d0')&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_260f7b86-fd05-446d-a907-79df167626d0&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_260f7b86-fd05-446d-a907-79df167626d0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('260f7b86-fd05-446d-a907-79df167626d0',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_260f7b86-fd05-446d-a907-79df167626d0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; G.fn.tabs = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( options ){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         options = options ||&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; defaults =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             contentClass : 'tab-content'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             navClass : 'tab-nav'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             activeClass : 'active'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             triggerElements : '*'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             activeIndex : 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             evType : 'click'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             effect : 'none'
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; opt =&lt;span&gt; G.extend( {}, defaults, options );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabContent = &lt;span&gt;this&lt;/span&gt;[0].querySelector( &quot;.&quot; +&lt;span&gt; opt.contentClass );
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabContentEle =&lt;span&gt; tabContent.children;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabNavEle = &lt;span&gt;this&lt;/span&gt;[0].querySelectorAll( &quot;.&quot; + opt.navClass + '&amp;gt;' +&lt;span&gt; opt.triggerElements );
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _contentLen =&lt;span&gt; tabContentEle.length;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _index =&lt;span&gt; opt.activeIndex;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _api =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         _api.setIndex = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( index ){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前标签加上active样式，其余标签删除active样式&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; _contentLen; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ( tabNavEle[i].classList.contains( 'active'&lt;span&gt; ) ) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     tabNavEle[i].classList.remove('active'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             tabNavEle[index].classList.add( 'active'&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; ( opt.effect ){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; 'fade'&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; _contentLen; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                         tabContentEle[i].style.display = 'none'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     tabContentEle[index].style.display = 'block'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     _index =&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         _api.setIndex( _index ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认的选项卡&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的标签绑定事件&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0, len = tabNavEle.length; i &amp;lt; len; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             tabNavEle[i].index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             tabNavEle[i].addEventListener( opt.evType, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                _api.setIndex( i );
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;完整的插件代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3799dcad-ab7d-4a9e-a7da-791f79d8bac4')&quot; readability=&quot;44&quot;&gt;&lt;img id=&quot;code_img_closed_3799dcad-ab7d-4a9e-a7da-791f79d8bac4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3799dcad-ab7d-4a9e-a7da-791f79d8bac4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3799dcad-ab7d-4a9e-a7da-791f79d8bac4',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3799dcad-ab7d-4a9e-a7da-791f79d8bac4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt; * Created by ghostwu(吴华).
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; G = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( selectors, context ){
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; G.fn.init( selectors, context );
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     G.fn = G.prototype =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         length : 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;        constructor : G,
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         size : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.length;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         init : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( selector, context ){
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.length = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             context = context ||&lt;span&gt; document;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( selector.indexOf( '#' ) == 0&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;[0] = document.getElementById( selector.substring( 1&lt;span&gt; ) );
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.length = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; aNode =&lt;span&gt; context.querySelectorAll( selector );
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0, len = aNode.length; i &amp;lt; len; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                     &lt;span&gt;this&lt;/span&gt;[i] =&lt;span&gt; aNode[i];
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.length =&lt;span&gt; len;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.selector =&lt;span&gt; selector;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     G.fn.init.prototype =&lt;span&gt; G.fn;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     G.extend = G.fn.extend = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; i = 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             len =&lt;span&gt; arguments.length,
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             dst = arguments[0&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;            j;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (dst.length ===&lt;span&gt; undefined) {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             dst.length = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; len) {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             dst = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (; i &amp;lt; len; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; arguments[i]) {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 dst[j] =&lt;span&gt; arguments[i][j];
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                 dst.length++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dst;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     G.fn.tabs = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( options ){
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         options = options ||&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; defaults =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             contentClass : 'tab-content'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             navClass : 'tab-nav'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             activeClass : 'active'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             triggerElements : '*'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             activeIndex : 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             evType : 'click'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             effect : 'none'
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; opt =&lt;span&gt; G.extend( {}, defaults, options );
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabContent = &lt;span&gt;this&lt;/span&gt;[0].querySelector( &quot;.&quot; +&lt;span&gt; opt.contentClass );
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabContentEle =&lt;span&gt; tabContent.children;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tabNavEle = &lt;span&gt;this&lt;/span&gt;[0].querySelectorAll( &quot;.&quot; + opt.navClass + '&amp;gt;' +&lt;span&gt; opt.triggerElements );
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _contentLen =&lt;span&gt; tabContentEle.length;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _index =&lt;span&gt; opt.activeIndex;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; _api =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         _api.setIndex = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( index ){
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前标签加上active样式，其余标签删除active样式&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; _contentLen; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ( tabNavEle[i].classList.contains( 'active'&lt;span&gt; ) ) {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     tabNavEle[i].classList.remove('active'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             tabNavEle[index].classList.add( 'active'&lt;span&gt; );
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; ( opt.effect ){
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; 'fade'&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; _contentLen; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                         tabContentEle[i].style.display = 'none'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                     tabContentEle[index].style.display = 'block'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                     _index =&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;         _api.setIndex( _index ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认的选项卡&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;所有的标签绑定事件&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = 0, len = tabNavEle.length; i &amp;lt; len; i++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             tabNavEle[i].index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             tabNavEle[i].addEventListener( opt.evType, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.index;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                _api.setIndex( i );
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;             }, &lt;span&gt;false&lt;/span&gt;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; $ = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;( selectors, context ){
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; G( selectors, context );
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     window.$ =&lt;span&gt; $;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; })();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;选项卡布局：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e88f35b2-fdac-42ac-ba91-c8e9d5544525')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e88f35b2-fdac-42ac-ba91-c8e9d5544525&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e88f35b2-fdac-42ac-ba91-c8e9d5544525&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e88f35b2-fdac-42ac-ba91-c8e9d5544525',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e88f35b2-fdac-42ac-ba91-c8e9d5544525&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;作者:ghostwu(吴华)&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;选项卡插件 - by ghostwu&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;css/tab.css&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./js/tab.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        window.onload &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            console.log( $(&quot;.tab1 .tab-nav li&quot;) );&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;            $( &quot;.tab1&quot; ).tabs( { 'evType' : 'mouseenter' } );&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            $( &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.tab1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ).tabs();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tab tab1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tab-nav&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;active&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;javascript:;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;标签4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;tab-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;内容4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;选项卡插件样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('96e73d65-bb86-4a8d-9409-f867b7cf8030')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_96e73d65-bb86-4a8d-9409-f867b7cf8030&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_96e73d65-bb86-4a8d-9409-f867b7cf8030&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('96e73d65-bb86-4a8d-9409-f867b7cf8030',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_96e73d65-bb86-4a8d-9409-f867b7cf8030&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;* &lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    margin&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    padding&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; }
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;body &lt;/span&gt;{
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    font-size&lt;/span&gt;:&lt;span&gt; 14px&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    font-family&lt;/span&gt;:&lt;span&gt; Tahoma, Verdana,&quot;Microsoft Yahei&quot;&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; }
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;{
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt;#000&lt;/span&gt;;
&lt;span&gt;12&lt;/span&gt; }
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;ul,li&lt;/span&gt;{
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    list-style-type&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; }
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;img &lt;/span&gt;{
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    border&lt;/span&gt;:&lt;span&gt;none&lt;/span&gt;;
&lt;span&gt;18&lt;/span&gt; }
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;.main &lt;/span&gt;{
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    width&lt;/span&gt;:&lt;span&gt;960px&lt;/span&gt;;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    margin&lt;/span&gt;:&lt;span&gt;20px auto&lt;/span&gt;;
&lt;span&gt;22&lt;/span&gt; }
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;.tab&lt;/span&gt;{
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    margin&lt;/span&gt;:&lt;span&gt; 0 auto 20px&lt;/span&gt;;
&lt;span&gt;25&lt;/span&gt; }
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;.tab1 .tab-nav&lt;/span&gt;{
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    margin-bottom&lt;/span&gt;:&lt;span&gt;8px&lt;/span&gt;;
&lt;span&gt;28&lt;/span&gt; }
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;.tab .tab-nav &lt;/span&gt;{
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    overflow&lt;/span&gt;:&lt;span&gt;hidden&lt;/span&gt;;
&lt;span&gt;31&lt;/span&gt; }
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;.tab1 .tab-nav .active&lt;/span&gt;{
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    border-bottom&lt;/span&gt;:&lt;span&gt;1px solid #000&lt;/span&gt;;
&lt;span&gt;34&lt;/span&gt; }
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;.tab1 .tab-nav li &lt;/span&gt;{
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    float&lt;/span&gt;:&lt;span&gt;left&lt;/span&gt;;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    margin&lt;/span&gt;:&lt;span&gt;0 10px&lt;/span&gt;;
&lt;span&gt;38&lt;/span&gt; }
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;.tab1 .tab-nav li a &lt;/span&gt;{
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    line-height&lt;/span&gt;:&lt;span&gt;40px&lt;/span&gt;;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    display&lt;/span&gt;:&lt;span&gt;block&lt;/span&gt;;
&lt;span&gt;42&lt;/span&gt; }
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;.tab1 .tab-content &lt;/span&gt;{
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt;250px&lt;/span&gt;;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    overflow&lt;/span&gt;:&lt;span&gt;hidden&lt;/span&gt;;
&lt;span&gt;46&lt;/span&gt; }
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;.tab1 .tab-content p &lt;/span&gt;{
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt;250px&lt;/span&gt;;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    background&lt;/span&gt;:&lt;span&gt;#eee&lt;/span&gt;;
&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最终效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171020164800443-828355673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Oct 2017 08:49:00 +0000</pubDate>
<dc:creator>ghostwu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ghostwu/p/7700288.html</dc:identifier>
</item>
</channel>
</rss>