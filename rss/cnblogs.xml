<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ASP.NET Core 2.0 : 五.服务是如何加载并运行的, Kestrel、配置与环境 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_5.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_5.html</guid>
<description>&lt;p&gt;&quot;跨平台&quot;后的ASP.Net Core是如何接收并处理请求的呢? 它的运行和处理机制和之前有什么不同?&lt;/p&gt;
&lt;p&gt;本章从&quot;宏观&quot;到&quot;微观&quot;地看一下它的结构以及不同时期都干了些什么.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本章主要内容如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core 的运行机制: &quot;宏观&quot;的看一下Http请求的处理流程. &lt;/p&gt;
&lt;p&gt;ASP.NET Core 的配置与运行: 2倍放大后的ASP.NET Core Application, Kestrel服务器、启动与配置&lt;/p&gt;
&lt;p&gt;ASP.NET Core 的环境变量.&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201802/548134-20180220195943455-548897477.jpg&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                   图1&lt;/p&gt;
&lt;p&gt;ASP.NET Core 的运行机制如上图所示, 现在做一下详细说明.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①Web Server:&lt;/span&gt; ASP.NET Core提供两种服务器可用, 分别是Kestrel和HTTP.sys(Core 1.x 中被命名为 WebListener), &lt;/p&gt;
&lt;p&gt;A. Kestrel是一个跨平台的Web服务器;&lt;/p&gt;
&lt;p&gt;B. HTTP.sys只能用在Windows系统中. &lt;/p&gt;
&lt;p&gt;&lt;span&gt;②Internet:&lt;/span&gt; 当需要部署在Internal Network 中并需要 Kestrel 中没有的功能（如 Windows 身份验证）时，可以选择HTTP.sys。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③IIS、Apache、Nginx:&lt;/span&gt; Kestrel 可以单独使用 ，也可以将其与反向代理服务器（如 IIS、Nginx 或 Apache）结合使用。 请求经这些服务器进行初步处理后转发给Kestrel(即图中虚线的可选流程).&lt;/p&gt;

&lt;p&gt;大概的运行机制就是这样, 那么&lt;span&gt;&lt;span&gt;具体到ASP.NET Core Application是如何运行的呢? 我们将图1中&lt;/span&gt;ASP.NET Core Application这个红框框放大一下&lt;span&gt;,看下一节.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;看一下将图1的ASP.NET Core Application放大后的样子:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/548134/201802/548134-20180226205246611-2084276237.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                    图2&lt;/p&gt;
&lt;p&gt;④Main方法, 程序的起点.&lt;/p&gt;
&lt;p&gt;⑤创建并配置WebHostBuilder: 首先调用Create­DefaultBuilder( 如图所示, 它是一系列配置的大综合,下文做详细介绍), 进行一系列配置之后, 调用 &lt;span&gt;UseStartup&amp;lt;T&amp;gt;(),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指定&lt;span&gt;⑩Startup&lt;/span&gt;为启动配置文件. 在Startup中, 将进行两个比较重要的工作, &lt;span&gt;⑧服务的依赖注入&lt;/span&gt;和&lt;span&gt;⑨配置管道&lt;/span&gt;, 后文将对这一部分详细的介绍.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;⑥生成WebHostBuilder并进行了一系列配置之后, 通过这个WebHostBuilder来Build出一个IWebHost.&lt;/p&gt;
&lt;p&gt;⑦调用IWebHost的Run方法使之开始运行.&lt;/p&gt;

&lt;p&gt;ASP.NET Core 应用程序本质上是控制台应用程序，所以它也是以一个我们熟悉的Main方法作为程序的起点.&lt;/p&gt;
&lt;p&gt;打开Program.cs文件, 默认是如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; Program
{
    public static void Main(string&lt;span&gt;[] args)
    {
        BuildWebHost(args).Run();
    }

    public static IWebHost BuildWebHost(string[] args) =&amp;gt;&lt;span&gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;()
            .Build();
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了一个BuildWebHost方法, 在Main中调用它返回一个IWebHost, 并使这个IWebHost&quot;Run起来&quot;. 再看BuildWebHost方法内部, 通过调用CreateDefaultBuilder&lt;/p&gt;
&lt;p&gt;创建了一个IWebHostBuilder, 然后用这个Builder来Build出一个IWebHost.&lt;/p&gt;
&lt;p&gt;简单来说就是 创建IWebHostBuilder=&amp;gt;Builder=&amp;gt;Build()=&amp;gt;IWebHost=&amp;gt;Run().&lt;/p&gt;

&lt;p&gt;系统离不开各种各样的配置, 比如常见的读取配置文件, 指定日志处理程序等, 我们详细的看一下.&lt;/p&gt;
&lt;h2&gt;Create­DefaultBuilder&lt;/h2&gt;
&lt;p&gt;CreateDefaultBuilder, 顾名思义, 它是一个默认配置 . 如图2所示, 它主要是调用了各种ConfigureXXX和UseXXX, 首先看一下它的源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateDefaultBuilder(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebHostBuilder()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        .UseKestrel()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        .UseContentRoot(Directory.GetCurrentDirectory())
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; env =&lt;span&gt; hostingContext.HostingEnvironment;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             config.AddJsonFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                   .AddJsonFile($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.{env.EnvironmentName}.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, optional: &lt;span&gt;true&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; appAssembly = Assembly.Load(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(env.ApplicationName));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (appAssembly != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     config.AddUserSecrets(appAssembly, optional: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            config.AddEnvironmentVariables();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (args != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                config.AddCommandLine(args);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         .ConfigureLogging((hostingContext, logging) =&amp;gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             logging.AddConfiguration(hostingContext.Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            logging.AddConsole();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            logging.AddDebug();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        .UseIISIntegration()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         .UseDefaultServiceProvider((context, options) =&amp;gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             options.ValidateScopes =&lt;span&gt; context.HostingEnvironment.IsDevelopment();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的源码中我们看到它这些ConfigureXXX和UseXXX的过程, 而在Core 1.0版本中是没有CreateDefaultBuilder这个方法的,&lt;/p&gt;
&lt;p&gt;系统默认是逐个调用这些ConfigureXXX和UseXXX的,在Core 2.0中, 为了代码简洁和使用方便, 将这些常规情况下需要调用的方法放到了这个名为CreateDefaultBuilder的方法中.&lt;/p&gt;

&lt;p&gt;一般情况下，调用Create­DefaultBuilder 执行其中的这些的默认配置足够用了。但既然这是默认配置,  我们就可以根据自身情况自定义.&lt;/p&gt;
&lt;p&gt;因为这些配置都是对 WebHostBuilder进行修改, 而修改后再次返回修改后的 WebHostBuilder, 所以在Create­DefaultBuilder不符合现实需求的情况下可以通过如下的方法进行自定义.&lt;/p&gt;
&lt;p&gt;1)不调用Create­DefaultBuilder, 将上面讲到的这些配置选择性的执行, 甚至可以添加、替换里面的某些配置, 如将UseKestrel改为UseHttpSys.&lt;/p&gt;
&lt;p&gt;2)小幅改动, 即调用Create­DefaultBuilder之后再对其返回的WebHostBuilder调用自定义的其他配置方法. 例如可以再次调用 ConfigureAppConfiguration，从而添加更多的配置源.&lt;/p&gt;

&lt;p&gt;下面来介绍一下这些ConfigureXXX和UseXXX.&lt;/p&gt;
&lt;h2&gt;A. UseKestrel&lt;/h2&gt;
&lt;p&gt;用于指定服务器使用 Kestrel, 若使用HttpSys, 需使用UseHttpSys。&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;24e91-105&quot;&gt;Kestrel 是跨平台 ASP.NET Core Web 服务器，它基于 libuv（一个跨平台异步 I/O 库）。 &lt;span data-ttu-id=&quot;24e91-106&quot;&gt;Kestrel 是 Web 服务器，默认包括在 ASP.NET Core 项目模板中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;24e91-107&quot;&gt;Kestrel 支持以下功能：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span data-ttu-id=&quot;24e91-108&quot;&gt;HTTPS&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;24e91-109&quot;&gt;用于启用 WebSocket 的不透明升级&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;24e91-110&quot;&gt;用于获得 Nginx 高性能的 Unix 套接字.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span data-ttu-id=&quot;24e91-110&quot;&gt;&lt;span data-ttu-id=&quot;24e91-145&quot;&gt;默认情况下，ASP.NET Core 项目模板使用的是 Kestrel。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;24e91-110&quot;&gt;&lt;span data-ttu-id=&quot;24e91-145&quot;&gt;我们可以再次调用UseKestrel来修改Kestrel的配置, 例如限制请求正文的最大值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
    WebHost.CreateDefaultBuilder(args)
        .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
        .UseKestrel(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            options.Limits.MaxRequestBodySize = &lt;span class=&quot;hljs-number&quot;&gt;10 * &lt;span class=&quot;hljs-number&quot;&gt;1024;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        })
        .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;B. UseContentRoot&lt;/h2&gt;
&lt;p&gt;为应用程序指定根目录。需注意这和 StaticFiles的根&lt;span&gt;是不同的, 虽然&lt;/span&gt;默认情况下StaticFiles的根是以ContentRoot为依据 ([ContentRoot]/wwwroot)。&lt;/p&gt;
&lt;h2&gt;C. ConfigureAppConfiguration&lt;/h2&gt;
&lt;p&gt;读取配置。如上代码会读取 &lt;span class=&quot;cnblogs_code&quot;&gt;appsettings.json&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;appsettings.{env.EnvironmentName}.json&lt;/span&gt; , env.EnvironmentName指的是环境, 例如Development. 当在Development环境的时候, 还会读取&lt;span&gt;用户密钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这部分在学习系统配置的时候详细介绍.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;D. ConfigureLogging&lt;/h2&gt;
&lt;p&gt;配置日志处理程序,控制台和调试日志提供程序, 学习日志的时候再详讲.&lt;/p&gt;
&lt;h2&gt;E. UseIISIntegration&lt;/h2&gt;
&lt;p&gt;将应用程序配置为在 IIS 中运行。上面已经讲过, 这里仍需要使用 UseKestrel, 而IIS 起到反向代理的作用，而 Kestrel 仍用作主机。&lt;/p&gt;
&lt;p&gt;如果应用程序没有使用 IIS 作为反向代理，那么 UseIISIntegration 不会有任何效果。因此，即使应用程序在非 IIS 方案中运行，也可以安全调用这种方法。&lt;/p&gt;
&lt;h2&gt;F.UseDefaultServiceProvider&lt;/h2&gt;
&lt;p&gt; 设置默认的依赖注入容器, 这部分在后面学习依赖注入的时候再详讲.&lt;/p&gt;


&lt;p&gt;在 ASP.NET Core 中，有个非常重要而且常用的东西叫环境变量, 它由 ASPNETCORE_ENVIRONMENT 环境变量指定。&lt;/p&gt;
&lt;p&gt;我们可以根据需要将此变量设置为任意值，但通常使用的是值 Development、Staging 和 Production。它定义了当前应用程序的运行环境, 我们经常会根据这个变量来让应用采用不同的处理方式.&lt;/p&gt;
&lt;p&gt;在上面的例子中, 就有这样的用法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
{
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; appAssembly = Assembly.Load(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(env.ApplicationName));
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (appAssembly != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
     {
          config.AddUserSecrets(appAssembly, optional: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;_Layout  View  中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &amp;lt;environment include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/lib/bootstrap/dist/css/bootstrap.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
        &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/css/site.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/environment&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因此，如果在run 之前将 ASPNETCORE_ENVIRONMENT 变量设置为 Development（或在 launchSettings.json 文件中设置此环境变量），&lt;/p&gt;
&lt;p&gt;应用程序会在 Development 模式下运行，而不是 Production 模式（这是不设置任何变量时的默认模式）。&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;0627d-115&quot;&gt;注意：在 Windows 和 macOS 上，环境变量和值不区分大小写。&lt;span class=&quot;sxs-lookup&quot;&gt;&lt;span data-stu-id=&quot;0627d-115&quot;&gt;&lt;span data-ttu-id=&quot;0627d-116&quot;&gt;Linux 环境变量和值区分大小写。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 通过上面的内容大概对ASP.NET Core 2.0 的服务启动、配置与运行, 运行环境等做了大概的了解, 其中涉及的部分内容如读取配置、日志等, 将在后期单独介绍.&lt;/p&gt;
&lt;p&gt;除了上述内容, ASP.NET Core留给我们作为扩展的地方主要放在了Startup文件中, 即图2中的&lt;span&gt;⑩Startup,&lt;/span&gt; 这里进行了两个比较重要的工作, &lt;span&gt;⑧服务的依赖注入&lt;/span&gt;和&lt;span&gt;⑨配置管道&lt;/span&gt;,&lt;/p&gt;
&lt;p&gt;下文我们将图2的&lt;span&gt;⑩Startu&lt;/span&gt;&lt;span&gt;p这个红框框放大一些, 看看这里都做了些什么.&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Feb 2018 22:40:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_5.html</dc:identifier>
</item>
<item>
<title>Android硬件编解码与软件编解码 - 小小情意</title>
<link>http://www.cnblogs.com/xiaoxiaoqingyi/p/8476839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiaoqingyi/p/8476839.html</guid>
<description>&lt;p&gt;       最近做了一个android项目用到编解码功能。大概需求是：通过摄像头拍摄一段视频，然后抽帧，生成一个短视频，以及倒序视频，刚开始直接用 H.264 编码格式，没有使用MP4容器封装。做了这些功能后，反而觉得使用MP4格式更加兼容各机型，减少BUG出现。举个明显例子：在Android硬编的时候，常常会用到 MediaCodec和MediaExtractor 相结合。但是，如果你用的 H.264 裸视频文件，MediaExtractor 的 setSource 函数会报异常，它在某些机型（如魅族Note2，系统是5.1）无法解析该视频文件。&lt;/p&gt;
&lt;div readability=&quot;11.252060004226&quot;&gt;
&lt;div readability=&quot;12.86684073107&quot;&gt;      得到大概的需求后，最初我们使用FFmpeg来做视频编解码，所谓软件编解码。由于在处理的过程中速率太慢，且需要在解码后快速展示，所以该方案无法达到我们的预想效果(一个FFmpeg视频解码，并保存为jpeg例子：&lt;a href=&quot;https://github.com/xiaoxiaoqingyi/ffmpeg-android-video-decoder&quot;&gt;https://github.com/xiaoxiaoqingyi/ffmpeg-android-video-decoder&lt;/a&gt;)。但其也有一些优点，比如在兼容方面，颜色转换方面都做得很好，毕竟不是硬件编解码（国内这么多机型，你懂的），其次FFmpeg能输出指定帧，而Android硬解（MediaCodec）不能输出指定帧，需要输入好几帧到解码器，才能解码出一帧。目前我还是没有找到输入一帧解出一帧的方案，哪位大神知道的，可以指导指导。&lt;/div&gt;
&lt;div readability=&quot;11.295007564297&quot;&gt;
&lt;p&gt;       在软件编解码不太适合的情况下，就只能考虑用硬件编解码了(MediaCodec)。在前些日子，我参加了腾讯2017LIVE 直播开发者大会，了解到，现在的直播已经大部分使用硬件来编解码了。刚说了，有些机型不能使用MediaExtractor来解析 h.264文件，为了兼容大部分的机型，需要自己来解析，通过分析h.264文件的每一个字节区分每一帧位置且是什么类型帧。实现该需求，首先在从摄像头获取的数据，如果使用 Camera，一般设置为NV21格式， 但有些人使用Camera2，设置的格式是IMAGE。不管是哪种格式，最终都需要转换成yuv420sp或yuv420p(注意：在转码时候，最好使用jni，用C/C++来转格式，效率会高很多倍)，才能供MediaCodec编码，然后保存h.264文件。在创建MediaCodec实例化的时候，除了设置必须参数外，也要注意一些地方，比如，选择哪种编码器，一般情况会选择如下：&lt;/p&gt;
&lt;div readability=&quot;15.202935222672&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 MediaCodec.createEncoderByType(&quot;video/avc&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;9.1588785046729&quot;&gt;这看上去其实没什么问题，大概原理就是获取最优的Encoder，获取Android系统中编码器注册表最前的一个，一般都是硬件解码(MediaCodec也能调用软件编解码)。这样创建编码器其实不太靠谱，虽然官网也是这么推荐，但是在国内众多的Android机型中，有些手机就会出问题，有的编码出现蓝屏，有些直接就闪退了。有个国外的例子，大概的意思就是先获取 &quot;video/avc&quot; 类型的编码器，然后通过 try catch 一个个试验，如果没问题，就选用这个编码器。源码：&lt;a href=&quot;https://github.com/ldm520/android_mediacodec_rtsp_h264&quot;&gt;https://github.com/ldm520/android_mediacodec_rtsp_h264&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;还有一个问题就是在设置 I 帧间隔的时候，有些手机不起作用，如下设置：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mediaFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, interval);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;针对这种情况，需要使用另外一种设置I帧的方式，强制设置:&lt;/p&gt;

&lt;div readability=&quot;14.582879762494&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Bundle params = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bundle();
params.putInt(MediaCodec.PARAMETER_KEY_REQUEST_SYNC_FRAME, &lt;/span&gt;0&lt;span&gt;);
mMediaCodec.setParameters(params);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在编解码时，当把所有的数据都输入编解码器的时候，要记得输入结束符，编解码器才会输出所有的帧。&lt;/p&gt;

&lt;p&gt;    还有一个抽帧问题，如果使用MediaCodec来抽帧，生成一个新的视频。是否可以直接把H.264文件里的帧去掉就行了？这样不行的，通常会出现花屏。这需要重新把h.264文件输入到解码器，然后获取到自己想要的帧，再输入到一个新的编码器中，生成你想要的H.264文件。在这里还有一个格式问题，并不是从解码器解码出来的数据，就能直接使用编码器来编码，有部分手机可以，有些会出现蓝屏，甚至闪退的情况。这时候需要统一解码器处理的格式。如果你使用这种形式获取：&lt;/p&gt;

&lt;div readability=&quot;11.742342342342&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mMediaCodec.getOutputBuffer()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;出来的格式各种各样，你很难去兼容。google已经推出了一种新的格式：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mMediaCodec.getOutputImage(outIndex)
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;9.6091954022989&quot;&gt;得出的是一个Image 对象，该对象可以保存为 JPEG格式图片，也可以转换成NV21(参考：&lt;a href=&quot;http://www.cnblogs.com/welhzh/p/6079631.html&quot;&gt;http://www.cnblogs.com/welhzh/p/6079631.html&lt;/a&gt;)，像上面拍摄部分，转换成yuv422格式，再输入到编码器编码。这样不管什么机型都可以兼容了（我试用10多部不同厂商手机），虽然绕了很多弯路。&lt;/div&gt;

&lt;div readability=&quot;8.0892857142857&quot;&gt;
&lt;p&gt;        在使用MediaCodec还是遇到比较多的问题，毕竟官网都说它是一个轻量的编解码器封装。该总结适合使用过MediaCodec或有一定的解码编码经验的童鞋们。如果你还没了解过 MediaCodec，可以参考官网:&lt;/p&gt;



&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;     在使用MediaCodec的时候还遇到很多问题，这里没有一一列举出来， 欢迎有遇到同样问题或类似问题的童鞋留言讨论！&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 26 Feb 2018 17:39:00 +0000</pubDate>
<dc:creator>小小情意</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiaoqingyi/p/8476839.html</dc:identifier>
</item>
<item>
<title>sql语句的执行顺序 - 熔遁丶螺旋手里剑</title>
<link>http://www.cnblogs.com/baiyb/p/8476790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baiyb/p/8476790.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天思考on，where，having的执行顺序，联想到了整个sql语句的执行顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sql语句的执行顺序为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1) from&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(2) on&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(3) join&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(4) where&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(5) group by, count, sum, avg&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(6) having&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(7) select&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(8) distinct&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(9) order by&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(10)top&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从这个顺序中我们可以看出所有的查询语句都是从from开始执行的，在执行过程中，每个步骤都会生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. from后如果存在多张表，那么先取出前两张表，以行数较小的表为基础表，两张表执行笛卡尔积，生成结果表vtb1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 将on中的逻辑表达式将应用到vtb1上，以筛选出满足逻辑表达式的行，生成结果表vtb2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一般的sql编辑器都要求join和on搭配使用，因为如果没有on，将生成笛卡尔积。如果你就是想要笛卡尔积作为结果的话，那么on后的表达式可以写1=1这种恒等式，来绕过join，on必须搭配的限制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 如果使用的是outer join，那么就需要添加外部行，left outer jion将左表在第二步中过滤的行添加进来，反之将右表在第二步中过滤的行添加进来，生成虚拟表vtb3。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果from后的表的数量大于2，那么将vtb3作为第一张表，继续重复执行前三步，得到最终的vtb3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 将where中的逻辑表达式将应用到vtb3上，以筛选出满足逻辑表达式的行，生成结果表vtb4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 将group by后字段中的唯一的值组合成为一组，得到虚拟表vtb5。之后的count，sum，avg等聚合操作都是针对组的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 将having中的逻辑表达式将应用到vtb5上，以筛选出满足逻辑表达式的行，生成vtb6。(having筛选器是唯一应用到已分组数据的筛选器)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7. 将select的列从vtb6中筛选出来。生成vtb7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8. 依据distinct语句，将vtb7中相同的行移除，生成vtb8。如果使用了group by那么就无需使用distinct，因为group by的结果中所有的行都不相同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9. 按照order_by指定的列排序vtb8，生成vtb9。排序是很消耗资源的，除非对结果有顺序要求，否则建议不使用order by&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.根据top的列数返回给&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在网上看到一张图片，可以直观的展示sql语句执行顺序，希望对大家有所帮助&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317562/201802/1317562-20180227002951495-501851711.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 26 Feb 2018 16:28:00 +0000</pubDate>
<dc:creator>熔遁丶螺旋手里剑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baiyb/p/8476790.html</dc:identifier>
</item>
<item>
<title>Java中简单Http请求 - 谷堆曲线</title>
<link>http://www.cnblogs.com/caoshenglu/p/8476593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caoshenglu/p/8476593.html</guid>
<description>&lt;h3&gt;&lt;span&gt;1. 概述&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在这篇快速教程中，我们将使用Java内置类HttpUrlConnection来实现一个Http请求。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. HttpUrlConnection&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;HttpUrlConnection类允许我们不用添加其他任何类库就能实现基本的Http请求。所有需要的类都包含在 java.net包内。缺点是，相比于其他http类库，该方法有点笨重，而且也没有提供一些高级特性的API，比如添加请求头，添加认证等。不过这些都不要紧。你完全可以将这个实现封装一下，添加一些高级特性也不是很复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你只是想快速地进行些Http请求而不想添加一些类库的话，本文的这些代码就足够了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，如果你对java的http请求基本实现不很了解，本文给出的代码也会有些帮助。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 创建请求&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;HttpUrlConnection类的创建是通过URL 类的openConnection()方法。这个方法只是创建一个连接对象，并不建立连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过设置requestMethod属性，HttpUrlConnection类可以创建各种请求类型——包括GET, POST, HEAD, OPTIONS, PUT, DELETE, TRACE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如创建一个GET请求：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;URL url = &lt;span&gt;new&lt;/span&gt; URL(&quot;www.baidu.com&quot;&lt;span&gt;); 
HttpURLConnection con &lt;/span&gt;=&lt;span&gt; (HttpURLConnection) url.openConnection(); 
con.setRequestMethod(&lt;/span&gt;&quot;GET&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4. 添加请求参数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果我们想要添加请求参数，我们需要设置doOutput 为true，然后将请求参数拼接成字符串，格式param1=value&amp;amp;param2=value，以流的形式写入到HttpUrlConnection 实例的OutputStream中。示例代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Map&amp;lt;String, String&amp;gt; parameters = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; parameters.put(&quot;param1&quot;, &quot;val&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt; con.setDoOutput(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; DataOutputStream out = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataOutputStream(con.getOutputStream());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;out.writeBytes(ParameterStringBuilder.getParamsString(parameters));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;out.flush();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; out.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;为方便转换字符串参数，我写了个工具类&lt;em&gt;ParameterStringBuilder&lt;/em&gt;。类中包含一个静态方法&lt;em&gt;getParamsString()&lt;/em&gt;将Map转换成对应格式的字符串：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParameterStringBuilder {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getParamsString(Map&amp;lt;String, String&amp;gt;&lt;span&gt; params) 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         StringBuilder result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt;&lt;span&gt; entry : params.entrySet()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;           result.append(URLEncoder.encode(entry.getKey(), &quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           result.append(&quot;=&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           result.append(URLEncoder.encode(entry.getValue(), &quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;           result.append(&quot;&amp;amp;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  
&lt;span&gt;13&lt;/span&gt;         String resultString =&lt;span&gt; result.toString();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; resultString.length() &amp;gt; 0
&lt;span&gt;15&lt;/span&gt;           ? resultString.substring(0, resultString.length() - 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;          : resultString;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }　　　　　　　　
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 5. 添加请求头&lt;/h3&gt;
&lt;p&gt;通过&lt;em&gt;setRequestProperty() &lt;/em&gt;方法可以添加请求头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; con.setRequestProperty(&quot;Content-Type&quot;, &quot;application/json&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过&lt;em&gt;getHeaderField()&lt;/em&gt;方法可以读取响应头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String contentType = con.getHeaderField(&quot;Content-Type&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 6. 配置超时时间&lt;/h3&gt;
&lt;p&gt;类允许我们设置连接超时时间和读取超时时间。这些值决定了连接建立的最大等待时间间隔或读取到达数据的最大等待时间间隔。&lt;/p&gt;
&lt;p&gt;设置超时时间，我们可以调用方法&lt;em&gt;setConnectTimeout()&lt;/em&gt; 和方法&lt;em&gt;setReadTimeout()&lt;/em&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; con.setConnectTimeout(5000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; con.setReadTimeout(5000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个例子中我们将超时时间设为5秒。&lt;/p&gt;
&lt;h3&gt;7.  处理Cookies&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;java.net&lt;/em&gt; 包包含的类&lt;em&gt;CookieManager，&lt;/em&gt;HttpCookie等能很便捷地处理Cookies.&lt;/p&gt;
&lt;p&gt;首先，从响应中读取cookies，我们先获取相应头里的Set-Cookie值，然后解析成&lt;em&gt;HttpCookie&lt;/em&gt;对象的List.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String cookiesHeader = con.getHeaderField(&quot;Set-Cookie&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;HttpCookie&amp;gt; cookies = HttpCookie.parse(cookiesHeader);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接下来，我们将cookies存储起来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; cookies.forEach(cookie -&amp;gt; cookieManager.getCookieStore().add(&lt;span&gt;null&lt;/span&gt;, cookie));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们检查cookies中是否包含一个username属性，如果不包含，我们把一个叫zhangsan的username添加进去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Optional&amp;lt;HttpCookie&amp;gt; usernameCookie =&lt;span&gt; cookies.stream()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   .findAny().filter(cookie -&amp;gt; cookie.getName().equals(&quot;username&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (usernameCookie == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     cookieManager.getCookieStore().add(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; HttpCookie(&quot;username&quot;, &quot;john&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后，将cookies添加到请求中去，我们需要在关闭连接和重新打开连接后，添加&lt;em&gt;Cookie&lt;/em&gt;请求头 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;con.disconnect();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; con =&lt;span&gt; (HttpURLConnection) url.openConnection();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  
&lt;span&gt;4&lt;/span&gt; con.setRequestProperty(&quot;Cookie&quot;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   StringUtils.join(cookieManager.getCookieStore().getCookies(), &quot;;&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;  8. 处理重定向&lt;/h3&gt;
&lt;p&gt;我们可以通过调用方法&lt;em&gt;setInstanceFollowRedirects&lt;/em&gt;()，设置为true或者false，来控制是否允许一个特定连接自动跟随重定向：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; con.setInstanceFollowRedirects(&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 也可以全局设置所有的连接是否允许自动跟随重定向：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; HttpUrlConnection.setFollowRedirects(&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 默认是允许自动跟随重定向的。&lt;/p&gt;
&lt;p&gt;请求返回状态码301，302表示重定向，我们可以获取响应头的&lt;em&gt;Location&lt;/em&gt;属性并用新的URL创建一个新的连接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (status ==&lt;span&gt; HttpURLConnection.HTTP_MOVED_TEMP
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   || status ==&lt;span&gt; HttpURLConnection.HTTP_MOVED_PERM) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     String location = con.getHeaderField(&quot;Location&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     URL newUrl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(location);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     con =&lt;span&gt; (HttpURLConnection) newUrl.openConnection();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 9. 读取响应&lt;/h3&gt;
&lt;p&gt;通过读取&lt;em&gt;HttpUrlConnection&lt;/em&gt;实例的&lt;em&gt;InputStream&lt;/em&gt;流来读取响应。&lt;/p&gt;
&lt;p&gt;读取响应常用方法有&lt;em&gt;getResponseCode(), connect(), getInputStream() &lt;/em&gt;or&lt;em&gt; getOutputStream()&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;比如，读取响应状态码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; status = con.getResponseCode();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，读取响应头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String contentType = con.getHeaderField(&quot;Content-Type&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，读取响应文本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BufferedReader in = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(con.getInputStream()));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;String inputLine;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; StringBuffer content = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; ((inputLine = in.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    content.append(inputLine);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; in.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关闭连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; con.disconnect();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;在这篇文章中，我们展示了如何通过&lt;em&gt;HttpUrlConnection&lt;/em&gt;类来时间Http请求。以下代码可以直接拷贝使用。由于太简单，就不传github了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_7ccbecc5-3341-44ad-89ad-b8cad32e922c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7ccbecc5-3341-44ad-89ad-b8cad32e922c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7ccbecc5-3341-44ad-89ad-b8cad32e922c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.shlugood.utils;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.HttpURLConnection;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URL;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URLEncoder;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpUtil {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String POST = &quot;POST&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String GET = &quot;GET&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String CONTENT_TYPE_URLENCODED = &quot;application/x-www-form-urlencoded&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String CONTENT_TYPE_JSON = &quot;application/json&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String httpRequest(String method, String contentType, String urlStr, HashMap&amp;lt;String,String&amp;gt;&lt;span&gt; paras)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         URL url = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; URL(urlStr);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         HttpURLConnection con =&lt;span&gt; (HttpURLConnection) url.openConnection();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         con.setConnectTimeout(5000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         con.setReadTimeout(5000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         con.setRequestMethod(&quot;POST&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         con.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(paras != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;paras.isEmpty()){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             con.setDoOutput(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             DataOutputStream out = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataOutputStream(con.getOutputStream());
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            out.writeBytes(ParameterStringBuilder.getParamsString(paras));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            out.flush();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            out.close();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         BufferedReader in = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InputStreamReader(con.getInputStream()));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        String inputLine;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         StringBuffer content = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((inputLine = in.readLine()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            content.append(inputLine);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        in.close();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        con.disconnect();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; content.toString();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParameterStringBuilder {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String getParamsString(Map&amp;lt;String, String&amp;gt;&lt;span&gt; params)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; UnsupportedEncodingException {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             StringBuilder result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt;&lt;span&gt; entry : params.entrySet()) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 result.append(URLEncoder.encode(entry.getKey(), &quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 result.append(&quot;=&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 result.append(URLEncoder.encode(entry.getValue(), &quot;UTF-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 result.append(&quot;&amp;amp;&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;             String resultString =&lt;span&gt; result.toString();
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; resultString.length() &amp;gt; 0
&lt;span&gt;60&lt;/span&gt;                     ? resultString.substring(0, resultString.length() - 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    : resultString;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt; 
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String httpGetRequest(String url){
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; httpRequest(GET, CONTENT_TYPE_URLENCODED, url, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String httpPostRequest(String url, HashMap&amp;lt;String,String&amp;gt;&lt;span&gt; paras){
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; httpRequest(POST, CONTENT_TYPE_URLENCODED, url, paras);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 26 Feb 2018 16:15:00 +0000</pubDate>
<dc:creator>谷堆曲线</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caoshenglu/p/8476593.html</dc:identifier>
</item>
<item>
<title>简单http文件服务器 - sxhlinux</title>
<link>http://www.cnblogs.com/sxhlinux/p/8476708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sxhlinux/p/8476708.html</guid>
<description>&lt;div&gt;&lt;span&gt;　　日常工作中，主要是通过ssh终端（putty等）远程开发，经常涉及到传输文件，因为本地系统为Win10，所以没办法利用强大的linux脚本来进行文件传输。之前用过python的SimpleHttp模块写了一个简单的文件服务器（&lt;a href=&quot;http://www.cnblogs.com/sxhlinux/p/6694904.html&quot;&gt;http://www.cnblogs.com/sxhlinux/p/6694904.html&lt;/a&gt;），但是缺少GUI，且仍然依赖curl等相关命令。所以，就想着写一个简单的http文件服务器，满足普通的文件上传、下载文件。&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        代码采用python 3.4版本，结构如下&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032090/201802/1032090-20180226234523188-496672146.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h4 class=&quot;brush:python;gutter:true;&quot;&gt;#### server.py ####&lt;/h4&gt;
&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#!/usr/bin/python3
 
import sys
from http.server import BaseHTTPRequestHandler, HTTPServer, CGIHTTPRequestHandler
 
if __name__ == '__main__':
    try:
        handler = CGIHTTPRequestHandler
        handler.cgi_directories = ['/cgi-bin', '/htbin']
        port = int(sys.argv[1])
        print('port is %d'% port)
        server = HTTPServer(('', port), handler)
        print('Welcome to my website !')
        server.serve_forever()
 
    except KeyboardInterrupt:
        print ('^C received, shutting down server')
        server.socket.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 class=&quot;brush:html;gutter:true;&quot;&gt;#### index.html ####&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;File Server&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form action=&quot;/cgi-bin/download.py&quot; method=&quot;get&quot;&amp;gt;
        要下载的文件: &amp;lt;input type=&quot;text&quot; name=&quot;filename&quot; /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;download&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
 
    &amp;lt;form enctype=&quot;multipart/form-data&quot; action=&quot;/cgi-bin/upload.py&quot; method=&quot;post&quot;&amp;gt;
        要上传的文件: &amp;lt;input type=&quot;file&quot; name=&quot;filename&quot; /&amp;gt;
        &amp;lt;input type=&quot;submit&quot; value=&quot;upload&quot;&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;#### download.py ####&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#!/usr/bin/python3
 
import os
import sys
import cgi
 
form = cgi.FieldStorage()
 
filename = form.getvalue('filename')
 
dir_path = &quot;/home/sxhlinux/data/&quot;
target_path = dir_path + str(filename)
if os.path.exists(target_path) == True:
    print ('Content-Type: application/octet-stream')
    print ('Content-Disposition: attachment; filename = &quot;%s&quot;' % filename)
 
    sys.stdout.flush()
    fo = open(target_path, &quot;rb&quot;)
    sys.stdout.buffer.write(fo.read())
    fo.close()
else:
    print(&quot;&quot;&quot;\
        Content-type: text/html\n
        &amp;lt;html&amp;gt;
        &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;File server&amp;lt;/title&amp;gt;
        &amp;lt;/head&amp;gt;
        &amp;lt;body&amp;gt;
        &amp;lt;h1&amp;gt; %s doesn't exist in the server:
        files in the server list below: &amp;lt;/h1&amp;gt;&quot;&quot;&quot; % filename)
 
    for line in os.popen(&quot;ls -lh ~/data/&quot;):
        name = line.strip().split(' ', 8)
        if len(name) == 9:
            print('''&amp;lt;form action=&quot;/cgi-bin/download.py&quot; method=&quot;get&quot;&amp;gt;
                %s &amp;lt;input type=&quot;submit&quot; name=&quot;filename&quot; value=&quot;%s&quot;&amp;gt;
                &amp;lt;/form&amp;gt;''' % (line, name[8]))
 
    print('&amp;lt;/body&amp;gt; &amp;lt;html&amp;gt;')
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt; #### upload.py ####&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
#!/usr/bin/python3
 
import cgi, os
 
form = cgi.FieldStorage()
 
item = form['filename']
 
if item.filename:
    fn = os.path.basename(item.filename)
    open('/home/sxhlinux/data/' + fn, 'wb').write(item.file.read())
    msg = 'File ' + fn + ' upload successfully !'
else:
    msg = 'no file is uploaded '
 
print(&quot;&quot;&quot;\
Content-type: text/html\n
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;Hello world&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;名称: %s&amp;lt;/h2&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;html&amp;gt;
&quot;&quot;&quot; % (msg,))
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;6.4579124579125&quot;&gt;将上述代码按照前面的目录结构放好，然后执行命令 &lt;span&gt;&lt;span&gt;&lt;strong&gt;nohup /usr/bin/python3 server.py 8001 &amp;gt;/dev/null &amp;amp;&lt;/strong&gt; &lt;/span&gt; 启动文件服务端，监听8001端口，远程可以在浏览器中 输入 &lt;a href=&quot;http://server_addr:8001/&quot;&gt;&lt;strong&gt;http://SERVER_ADDR:8001&lt;/strong&gt;&lt;/a&gt; 来访问该文件服务器进行相关的文件上传下载操作。&lt;/span&gt;&lt;/div&gt;

&lt;div readability=&quot;8.793893129771&quot;&gt;注：&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://files.cnblogs.com/files/sxhlinux/server.zip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;附件&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;中是整个demo的代码（&lt;em&gt;&lt;strong&gt;download.py，upload.py两个文件中的目录路径 /home/sxhlinux/data 需要改成自己要存储文件的文件夹路径&lt;/strong&gt;&lt;/em&gt;），有兴趣的小伙伴可以下载修改，刚学习python，欢迎大家多多提意见。&lt;/div&gt;

&lt;div&gt;参考引用：

&lt;/div&gt;
</description>
<pubDate>Mon, 26 Feb 2018 15:48:00 +0000</pubDate>
<dc:creator>sxhlinux</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sxhlinux/p/8476708.html</dc:identifier>
</item>
<item>
<title>Halcon一日一练：图像拼接技术 - 超帆越浪</title>
<link>http://www.cnblogs.com/amosyang/p/8472932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amosyang/p/8472932.html</guid>
<description>&lt;p&gt;图像拼接技术就是针对同一场景的一系列图片，根据图片的特征，比如位置，重叠部分等，拼接成一张大幅的宽视角的图像。&lt;/p&gt;
&lt;p&gt;图像拼接要求拼接后图像最大程度的与原图一致，失真尽可能的小，并且要尽量做到天衣无缝即没有明显的拼接线或其他拼接痕迹。&lt;/p&gt;
&lt;p&gt;图像拼接不能损失原始图像信息&lt;/p&gt;
&lt;p&gt;为达到以上目标，图像拼接要求具备以下条件：&lt;/p&gt;
&lt;p&gt;1：图像应具有一定的特征性能，拼接正是通过这些特征来进行的。&lt;/p&gt;
&lt;p&gt;2：图像需要具有重叠部分，一般情况下，这些重叠部分点图像的1/4以上较为合理。&lt;/p&gt;
&lt;p&gt;3、图像的背景亮度差异不能太大，应该低于10个灰度值，否则难以拼接成功。&lt;/p&gt;
&lt;p&gt;4、图像的方位差异不能太大，图像应该来源同一方位。&lt;/p&gt;
&lt;p&gt;5、拼合边界过渡应平滑，以消除接拼痕迹&lt;/p&gt;

&lt;p&gt;图像拼接前，根据图像情况，可以进行图像预处理，主要是对图像进行校正和噪声滤波&lt;/p&gt;
&lt;p&gt;1、校正&lt;/p&gt;
&lt;p&gt;根据图像失真原因，建立相应的校正模型，从失真的图像中提取所需要的信息。从图像失真的逆过程来恢复图像。这个过程也可以理解为设计一个滤波器，使用其能从失真图像中计算得到真实图像的估值，从而最大程度的恢复真实图像。&lt;/p&gt;
&lt;p&gt;2、噪声滤波&lt;/p&gt;
&lt;p&gt;  噪声在图像上分布主要有两种型式：&lt;/p&gt;
&lt;p&gt;1、位置随机，幅值基本相同，一般称之为 椒盐噪声；&lt;/p&gt;
&lt;p&gt;2、幅值随机，但基本上每个点都存在，从幅值的分布统计来看，主要有高斯型，瑞利型，又有如频谱均匀的噪声。&lt;/p&gt;
&lt;p&gt;对于这些噪声，处理方法有如下几种：&lt;/p&gt;
&lt;p&gt;1、均值滤波&lt;/p&gt;
&lt;p&gt;      就是用均值替代原图像中的各个像素。具体方法是：对将处理的像素，选择一个模板，此模板为其邻近的若干像素组成，用模板中的像素的均值去替代原来的像素值 。&lt;/p&gt;
&lt;p&gt;2、中值滤波&lt;/p&gt;
&lt;p&gt;      中值滤波是一种非线性平滑技术，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中值.&lt;br/&gt;      中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个邻域中各点值的中值代替，让周围的像素值接近的真实值，从而消除孤立的噪声点。方法是用某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为g（x,y）=med{f(x-k,y-l),(k,l∈W)} ，其中，f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为3*3，5*5区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。&lt;/p&gt;
&lt;p&gt; 图像配比：&lt;/p&gt;
&lt;p&gt;    包含以下几个要素&lt;/p&gt;
&lt;p&gt;1、选定特征空间&lt;/p&gt;
&lt;p&gt;      特征空间是由不参与匹配的图像特征构成。特征可以为图像的灰度特征，也可以是边界，轮廓，显著特征（如角点，线交叉点，高曲率点），统计特征（如矩不变量，中心），高层结构描述与句法描述等；这里其实是定义了配准的空间范围。&lt;/p&gt;
&lt;p&gt;2、相似度&lt;/p&gt;
&lt;p&gt;     评估待匹配特征之间的相似性，它通常定义为某种代价函数或者是距离函数。这里定义为需要选定的某种算法。&lt;/p&gt;
&lt;p&gt;3、搜索空间&lt;/p&gt;
&lt;p&gt;      待估计参数组成的空间就称为搜索空间，也就是说，搜索空间是指所有可能的变换组成的空间。这其实就定义了搜索算法的空间复杂度&lt;/p&gt;
&lt;p&gt;4、搜索策略&lt;/p&gt;
&lt;p&gt;     用合适的方法在搜索空间中找出平移，旋转等变换参数的最佳估计，使得相似度达到最大值，这其实也就是定义了搜索算法的时间复杂度。&lt;/p&gt;

&lt;p&gt;拼接方法：&lt;/p&gt;
&lt;p&gt;1、基于区域的配准方法&lt;/p&gt;
&lt;p&gt;     采用拼接图像的灰度值检测，对待配准图你中一块区域与参考图像中的相机尺寸的区域使用最小二乘法或者其它数学方法计算其灰度值的差异，对此差异比较后来判断待拼接图像重叠区域的相似度，由此得到待拼接图像重叠区域的范围和位置，从而实现图像拼接。也可以通过FFT变换将图像由时域变换到频域，然后再进行配准。对位移量比较大的图像，可以先校正图像的旋转，然后建立两幅图像之间的映射关系，总而言之，这种方法有很多不足，已经不是主流了。&lt;/p&gt;
&lt;p&gt;2、基于特征的配准方法&lt;/p&gt;
&lt;p&gt;     基于特征的图像配准方法有很多形式及其改进方式，其总体特点是：不直接利用图像的像素，而是通过像素值导出图像内容最抽像的描述和符号特征，并用此特征为匹配模板，通过二维高斯模糊过滤，把几幅待配准图像的灰度局总最大值，边界边缘轮廓，边缘点，边缘线段，组织（纹理）结构，角、项点，拐点，交叉点，封闭曲线低级对应特征点及利用特征图像关系图等高级特征，构造方程组，通过数值计算得到变换数来进行图像对齐，进而确定两者的匹配位置，实现特征点，特征线等拼接，并且可以提高运算速度。&lt;/p&gt;

</description>
<pubDate>Mon, 26 Feb 2018 15:40:00 +0000</pubDate>
<dc:creator>超帆越浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amosyang/p/8472932.html</dc:identifier>
</item>
<item>
<title>网页版仿Excel效果组件--handsontable拓展运用 - 谎言让你心安</title>
<link>http://www.cnblogs.com/wbsndbf/p/8476642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbsndbf/p/8476642.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;span&gt;前段时间项目需要实现网页版的excel表格功能，瞬间就想到了handsontable，为什么呢？理由如下：该UI组件功能齐全多样，展示效果也更贴近bootstrap风格，兼容所有现代浏览器和IE9+，然后开源，api相当给力。&lt;br/&gt;　　唯一美中不足的是没有中文版的api，也有些分享中文api的文章，也不完整（有就不错了，不满意自己去看官网api啊,啦啦啦~），闲言少叙，进入正文：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;我们先看一下功能操作栏（红框部分为部分我们需要实现的功能）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　上图中的 input 会同步响应我们所选单元格的数据，其他的方法如图所示。&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;首先我们既然是表格，那么我们的操作对象基本都是单元格，但同时我们肯定也希望能够满足范围性操作，比如说批量修改样式。当然我们不仅需要考虑到展示效果，还需要考虑到储存和数据渲染，&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　我们需要的做到以下几点：所选范围、所选范围里的单元格、如何储存数据、如何通过loadData一次性加载数据（包括样式及自定义属性），带着这些问题我们去看api，我们需要找到我们需要方法以及了解如何使用它们。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里附上官方api链接：https://docs.handsontable.com/pro/1.16.0/tutorial-introduction.html&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　阅读过程小生这里就不做赘述了（唔...一把辛酸泪），首先我们需要清楚的是，我们需要获取到被选择的单元格对象，而要获取单元格对象我们要知道所选范围（单个单元格也是一个范围，这里不需要另作判断），而要知道所选范围我们要用到  getSelected()  方法，而此方法应该在我们选择范围后触发，所以我们需要用到钩子函数：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;afterOnCellMouseDown&lt;/span&gt;,具体用法可以到api里自行查阅&lt;/p&gt;&lt;p&gt; 　　万事俱备，接下来该做什么呢？当然是做我们最爱做的事:撸代码！~&lt;/p&gt;&lt;div readability=&quot;1045&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　var&lt;/span&gt; data = [
&lt;span&gt;         [, , , , , , , , , , , , , , , , , , , , ],  
           [&lt;/span&gt;&quot;2001&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2002&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2003&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2004&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2005&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2006&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2007&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2008&quot;, 10, 11, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,87,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2009&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,8,6,78,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2010&quot;, 30, 15, 12, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,52,6,3,5,3,8,6,8,5,6,56,355,6,3,66,23,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2011&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,26,3,5,26,3,5,3,8,6,8,5,56,6,35,6,3,6,23,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2012&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,666,5,8,6,3,9,6,3,5,56,3,5,3,78,6,58,55,6,6,35,6,23,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2013&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,68,6,3,9,6,3,5,26,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2014&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,26,3,5,3,8,6,58,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2015&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,29,26,3,5,6,3,5,3,78,76,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2016&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,55,6,3,5,3,8,6,28,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2017&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,43,9,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2018&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,62,3,29,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2019&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,48,6,3,9,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2020&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,68,6,3,9,6,3,5,6,3,5,3,8,6,8,5,6,6,345,6,3,64,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2021&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,6,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,8,38,3&lt;span&gt;],  
          [&lt;/span&gt;&quot;2022&quot;, 20, 11, 14, 13,14,15,16,17,18,19,20,21,22,22,3,3,55,66,5,8,6,3,9,66,3,5,6,3,5,3,8,6,8,5,6,6,35,6,3,6,3,48,38,23&lt;span&gt;]  
      ];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　汉化右键菜单：如果不需要右键菜单可以设置为false，&lt;/span&gt;&lt;/span&gt;contextMenu : false&lt;/p&gt;&lt;p&gt;　　自定义菜单及回调函数：自定义菜单也是在 contextMenu里面，格式如下（如上图中的 setAlias 设置别名，设置属性方法我们在后面再说明）：&lt;/p&gt;&lt;p&gt;　　Crow：所选单元格的行，Ccol：所选单元格的列，valT：所选单元格的值，selectRange：所选范围，selectRangeArr：所选单元格数组&lt;/p&gt;&lt;p&gt;　　获取所选区域单元格数组，当前单元格高亮：这里需要补充的一点是，handsontable本身在表格失去焦点时会移除所有当前高亮类，而我们在点击按钮修改样式时又需要所选高亮来满足我们的“心中有数”，所以这里我们需要自定义一个高亮的类，看代码：&lt;/p&gt;&lt;p&gt;　　我们可以在控制台查看一下令我们心动的 selectRange 和 selectRangeArr ：&lt;/p&gt;&lt;p&gt;　　修改单元格样式（字体样式和对齐方式）：switch条件语句在这种事件触发对象判断中用起来是相当地令人愉快..&lt;/p&gt;&lt;p&gt;　　　　1、如果对象是合并单元格，那么在赋值和修改样式上需要区别对待，看代码（具体区别请调试代码自己体会o(∩_∩)o ）；&lt;/p&gt;&lt;p&gt;　　　　2、在方法里我们可以看到运用了 &lt;span&gt;setCellMeta() &lt;span&gt;方法，单纯的前端效果我们不需要用到此方法，这里是为了便于储存和渲染数据，如此在初始化表格渲染数据的时候我们能将每一个单元格所对应的样式类名也添加进去，简而言之：每一次初始化表格我们只需要渲染一次，开心~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　自定义背景色、字体颜色、边框色：这里我们用到了插件 bootstrap-colorpicker.js  ：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　　看效果图：　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;/p&gt;&lt;p&gt;　　自定义属性：假设我们现在需要给某些单元格添加任意属性，这里我们以设置别名为例，并且希望能在右键菜单中可以直接操作：&lt;/p&gt;&lt;p&gt;　　对的，此处应该有弹窗，这里小生强烈推荐用 layer.js，快准狠还高大上...这里附上 layer.js的官网地址，具体用法有空亲们可以自行琢磨：http://www.layui.com/doc/modules/layer.html，下面看设置别名回调函数：&lt;/p&gt;&lt;p&gt;　　这里需要注意的一点是，setCellMeta添加的属性是单元格的属性，而不是单元格的DOM属性，所以我们用attr或者prop方法是获取不到的（小生不可能告诉亲们当初经历了什么~），我们可以在设置完成以后将所选单元格的属性打印出来：&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;这次分享到这里就结束了，希望对大家有所帮助，有疑问或者建议都可以留言交流，新年快乐，摸摸踹~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;</description>
<pubDate>Mon, 26 Feb 2018 15:16:00 +0000</pubDate>
<dc:creator>谎言让你心安</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wbsndbf/p/8476642.html</dc:identifier>
</item>
<item>
<title>CSS预处理器之Less详解 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8476602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8476602.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8476602.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;css-预处理器&quot;&gt;CSS 预处理器&lt;/h2&gt;
&lt;h3 id=&quot;为什么要有-css-预处理器&quot;&gt;为什么要有 CSS 预处理器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CSS基本上是设计师的工具，不是程序员的工具&lt;/strong&gt;。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难以组织和维护。&lt;/p&gt;
&lt;p&gt;很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“&lt;strong&gt;CSS预处器&lt;/strong&gt;（CSS Preprocessor）”。&lt;/p&gt;
&lt;h3 id=&quot;什么是-css-预处理器&quot;&gt;什么是 CSS 预处理器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;是 CSS 语言的&lt;strong&gt;超集&lt;/strong&gt;，比CSS更丰满。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;CSS 预处理器定义了一种新的语言，其基本思想是：&lt;strong&gt;用一种专门的编程语言，为CSS增加了一些编程的特性&lt;/strong&gt;，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。&lt;/p&gt;
&lt;p&gt;通俗的说，&lt;strong&gt;CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件&lt;/strong&gt;，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。&lt;/p&gt;
&lt;p&gt;CSS预处理器技术已经非常成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：&lt;strong&gt;Sass（SCSS）、LESS&lt;/strong&gt;、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。&lt;/p&gt;
&lt;p&gt;到目前为止，在众多优秀的CSS预处理器语言中就属&lt;strong&gt;Sass、LESS和Stylus最优秀&lt;/strong&gt;，讨论的也多，对比的也多。本文将分别从他们产生的背景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。&lt;/p&gt;
&lt;h2 id=&quot;less-的介绍&quot;&gt;less 的介绍&lt;/h2&gt;
&lt;p&gt;less 是一款比较流行的&lt;strong&gt;预处理 CSS&lt;/strong&gt;，支持变量、混合、函数、嵌套、循环等特点。&lt;/p&gt;
&lt;h2 id=&quot;less-的语法&quot;&gt;less 的语法&lt;/h2&gt;
&lt;h3 id=&quot;注释&quot;&gt;注释&lt;/h3&gt;
&lt;p&gt;less 的注释可以有两种。&lt;/p&gt;
&lt;p&gt;第一种注释：模板注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 模板注释 这里的注释转换成CSS后将会删除&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 less 要转换为 css才能在浏览器中使用。转换成 css 之后，这种注释会被删除（毕竟 css 不识别这种注释）。&lt;/p&gt;
&lt;p&gt;第二种注释：CSS 注释语法&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;
/* CSS 注释语法 转换为CSS后让然保留 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：如果在less中写注释，我们推荐写第一种注释。除非是类似于版权等内容，就采用第二种注释。&lt;/p&gt;
&lt;h3 id=&quot;定义变量&quot;&gt;定义变量&lt;/h3&gt;
&lt;p&gt;我们可以把&lt;strong&gt;重复使用或经常修改的值&lt;/strong&gt;定义为变量，在需要使用的地方引用这个变量即可。这样可以避免很多重复的工作量。&lt;/p&gt;
&lt;p&gt;（1）在less文件中，定义一个变量的格式：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@变量名: 变量值;        //格式

@bgColor: #f5f5f5;      //格式举例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）同时，在 less 文件中引用这个变量。&lt;/p&gt;
&lt;p&gt;最终，less文件的完整版代码如下：&lt;/p&gt;
&lt;p&gt;main.less：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;// 定义变量
@bgColor: #f5f5f5;

// 引用变量
body{
    background-color: @bgColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将上面的less文件编译为 css 文件后（下一段讲less文件的编译），自动生成的代码如下：&lt;/p&gt;
&lt;p&gt;main.css：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f5f5f5&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;使用嵌套&quot;&gt;使用嵌套&lt;/h3&gt;
&lt;p&gt;在 css 中经常会用到子代选择器，效果可能是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f40&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f50&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码嵌套了很多层，写起来很繁琐。可如果用 less 的嵌套语法来写这段代码，就比较简洁。&lt;/p&gt;
&lt;p&gt;嵌套的举例如下：&lt;/p&gt;
&lt;p&gt;main.less:&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;.container {
  width: @containerWidth;

  &amp;gt; .row {
    height: 100%;
    a {
      color: #f40;

      &amp;amp;:hover {
        color: #f50;
      }

    }
  }

  div {
    width: 100px;

    .hello {
      background-color: #00f;
    }

  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上面的less文件编译为 css 文件后，自动生成的代码如下：&lt;/p&gt;
&lt;p&gt;main.css&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f40&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; &amp;gt; &lt;span class=&quot;fl&quot;&gt;.row&lt;/span&gt; a&lt;span class=&quot;dv&quot;&gt;:hover&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#f50&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; div &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;fl&quot;&gt;.container&lt;/span&gt; div &lt;span class=&quot;fl&quot;&gt;.hello&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#00f&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;mixin&quot;&gt;Mixin&lt;/h3&gt;
&lt;p&gt;Mixin 的作用是把&lt;strong&gt;重复的代码&lt;/strong&gt;放到一个类当中，每次只要引用类名，就可以引用到里面的代码了，非常方便。&lt;/p&gt;
&lt;p&gt;（1）在 less 文件中定义一个类：（将重复的代码放到自定义的类中）&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;/* 定义一个类 */
.roundedCorners(@radius: 5px) {
  -moz-border-radius: @radius;
  -webkit-border-radius: @radius;
  border-radius: @radius;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，第一行里面，括号里的内容是参数：这个参数是&lt;strong&gt;缺省值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（2）在 less 文件中引用上面这个类：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;#header {
  .roundedCorners;
}
#footer {
  .roundedCorners(10px);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上方代码中，header 中的引用没有带参数，表示参数为缺省值； footer 中的引用带了参数，那就用这个参数。&lt;/p&gt;
&lt;h3 id=&quot;import&quot;&gt;Import&lt;/h3&gt;
&lt;p&gt;在开发阶段，我们可以将不同的样式放到多个文件中，&lt;a href=&quot;mailto:最后通过@import&quot;&gt;最后通过@import&lt;/a&gt; 的方式合并。意思就是，当出现多个 less 文件时，怎么引用它们。&lt;/p&gt;
&lt;p&gt;这个很好理解， css 文件可以有很多个，less文件也可以有很多个。&lt;/p&gt;
&lt;p&gt;（1）定义一个被引用的less文件，名为&lt;code&gt;_button1.less&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_button1.less:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;.btn{
  line-height: 100px;
  color: @btnColor;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS1：被引用的less文件，我们习惯在前面加&lt;strong&gt;下划线&lt;/strong&gt;，表示它是&lt;strong&gt;部分文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;PS2：&lt;code&gt;_button1.less&lt;/code&gt;里可以引用&lt;code&gt;main.css&lt;/code&gt;里的自定义变量。&lt;/p&gt;
&lt;p&gt;（2）在 &lt;code&gt;main.css&lt;/code&gt; 中引用上面的 &lt;code&gt;_button1.less&lt;/code&gt;：（代码的第二行）&lt;/p&gt;
&lt;p&gt;main.css：&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;@btnColor: red;

@import url(`_button1.less:');    //这里的路径写的是相对路径

body{
  width: 1024px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 上面的main.less 编译为 main.css之后，自动生成的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.btn&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;line-height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;

body &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1024px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;内置函数&quot;&gt;内置函数&lt;/h3&gt;
&lt;p&gt;less 里有一些内置的函数，这里讲一下 lighten 和 darken 这两个内置函数。&lt;/p&gt;
&lt;p&gt;main.less:&lt;/p&gt;
&lt;pre class=&quot;less&quot;&gt;
&lt;code&gt;body {
  background-color: lighten(#000, 10%);   // 让黑色变亮 10%
  color: darken(#fff, 10%);               // 让白色变暗 10%
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 上面的 main.less 编译为 main.css 之后，自动生成的代码如下：&lt;/p&gt;
&lt;p&gt;main.css：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;body &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#1a1a1a&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#e6e6e6&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果还有什么不懂的，可以看 api 文档，在上面的第二段附上了链接。&lt;/p&gt;
&lt;h2 id=&quot;在-index.html中直接引用-less.js&quot;&gt;在 index.html中直接引用 less.js&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;做法一：写完 less文件后，将其编译为 css 文件，然后在代码中引用css文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;做法二：在代码中直接用引用 less 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;产品上线后，当然是使用做法一，因为做法二会多出编译的时间。&lt;/p&gt;
&lt;p&gt;平时开发或演示demo的时候可以用做法二。&lt;/p&gt;
&lt;p&gt;这一段，我们讲一下做法二，其实是浏览器在本地在线地把 less 文件转换为 css 文件。&lt;/p&gt;
&lt;p&gt;（1）在 less 官网下载 less.js 文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2131.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把下载好的文件放在工程文件的lib文件夹里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2143.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在 index.html 中引入 less.js 和我们自己写的 main.less。位置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;copy 红框那部分的代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;link&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; rel=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;stylesheet/less&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;../main.less&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以在打开的网页中，通过控制台看到效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2150.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，我们要在服务器中打开 html 文件，否则，看不到效果。&lt;/p&gt;
&lt;p&gt;这里也告诉了我们：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;不提倡将 less 引入页面，因为 less 需要编译，因此你就需要再引入一个less.js, 多了一个HTTP 请求，同时当浏览器禁用了 js 你的样式就不起作用了，less 编译应该在服务端或使用 grunt 自动编译。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工程文件：（工程文件中，我引用的less.js版本是 2.5.3）&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;h2 id=&quot;less-的编译&quot;&gt;less 的编译&lt;/h2&gt;
&lt;p&gt;less 的编译指的是将写好的 less 文件 生成为 css 文件。&lt;/p&gt;
&lt;p&gt;less 的编译，依赖于 NodeJS 环境。因此，我们需要先安装 NodeJS。&lt;/p&gt;
&lt;h3 id=&quot;安装-node.js&quot;&gt;1、安装 Node.js&lt;/h3&gt;
&lt;p&gt;去 &lt;a href=&quot;https://nodejs.org/zh-cn/&quot;&gt;Node.js&lt;/a&gt;的官网下载安装包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一路 next 进行安装。&lt;/p&gt;
&lt;p&gt;安装完成后，配置环境变量：&lt;/p&gt;
&lt;p&gt;在 path 变量中追加安装路径：&lt;code&gt;;C:\Program Files\nodejs&lt;/code&gt;。重启资源管理器，即可生效。&lt;/p&gt;
&lt;p&gt;PS：我发现，我安装的 node.js v8.9.4 版本，已经自动添加了环境变量。&lt;/p&gt;
&lt;p&gt;在 cmd 命令行，输入&lt;code&gt;node.exe -v&lt;/code&gt;，可以查看 node.js 的版本。&lt;/p&gt;
&lt;h3 id=&quot;安装-less-的编译环境&quot;&gt;2、安装 less 的编译环境&lt;/h3&gt;
&lt;p&gt;将 &lt;a href=&quot;http://download.csdn.net/download/smyhvae/10260414&quot;&gt;npm.zip&lt;/a&gt; 解压，将解压后的文件拷贝到路径&lt;code&gt;C:\Users\smyhvae\AppData\Roaming\npm&lt;/code&gt;下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2212.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重启资源管理器（或者重启电脑）。在 cmd 中输入 &lt;code&gt;lessc&lt;/code&gt;，如果能看到下面的效果，说明 less编译环境安装成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180226_2217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你用的是 linux 系统，可以输入下面的命令安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g less&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;将-less-文件编译为-css-文件&quot;&gt;3、将 less 文件编译为 css 文件&lt;/h3&gt;
&lt;p&gt;在 less 所在的路径下，输入 &lt;code&gt;lessc xxx.less&lt;/code&gt;，即可编译成功。或者，如果输入 &lt;code&gt;lessc xxx.less &amp;gt; ..\xx.css&lt;/code&gt;，表示输出到指定路径。&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 15:01:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8476602.html</dc:identifier>
</item>
<item>
<title>Java集合中的Map接口 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/8476573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/8476573.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;jdk1.8.0_144　　&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　Map是Java三种集合中的一种位于java.util包中，Map作为一个接口存在定义了这种数据结构的一些基础操作，它的最终实现类有很多：HashMap、TreeMap、SortedMap等等，这些最终的子类大多有一个共同的抽象父类AbstractMap。在AbstractMap中实现了大多数Map实现公共的方法。本文介绍Map接口定义了哪些方法，同时JDK8又新增了哪些。&lt;/p&gt;
&lt;p&gt;　　Map翻译为“映射”，它如同字典一样，给定一个key值，就能直接定位value值，它的存储结构为“key : value&quot;形式，核心数据结构在Map内部定义了一个接口——Entry，这个数据结构包含了一个key和它对应的value。首先来窥探Map.Entry接口定义了哪些方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;interface Map.Entry&amp;lt;K, V&amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;K getKey()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　获取key值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V getValue()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　获取value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V setValue(V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　存储value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean equals(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int hashCode()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两个方法我在&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8445910.html&quot; target=&quot;_blank&quot;&gt;《万类之父——Object》&lt;/a&gt;中提到过，这是Object类中的方法，这两个方法通常是同时出现，也就是说要重写equals方法时为了保证不出现问题往往需要重写intCode方法。而重写equals则需要满足5个规则（自反性、对称性、传递性、一致性、非空性）。当然具体是如何重写的，此处作为接口并不做解释而是交由它的子类完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K extends Comparable&amp;lt;? super K&amp;gt;, V&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; comparingByKey()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K, V extends Comparable&amp;lt;? super V&amp;gt;&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; comparingByValue()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K, V&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; comparingByKey(Comparator&amp;lt;? super K&amp;gt; cmp)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;public static &amp;lt;K, V&amp;gt; Comparator&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; comparingByValue(Comparator&amp;lt;? super V&amp;gt; cmp)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这四个方法放到一起是因为这都是JDK8针对Map更为简单的排序新增加的泛型方法，这里的泛型方法看似比较复杂，我们针对第一个方法先来简单回顾一下泛型方法。&lt;/p&gt;
&lt;p&gt;　　一个泛型方法的基本格式就是泛型参数列表需要定义在返回值前。这个方法的返回值返回的是Comparator&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt;，也就是说它的泛型参数列表是“&amp;lt;K extends Comparable&amp;lt;? super K&amp;gt;, V&amp;gt;”，有两个泛型参数K和V。参数K需要实现Comparable接口。&lt;/p&gt;
&lt;p&gt;　　既然这是JDK8为Map排序新增的方法，那它是如何使用的呢？ 不妨回忆下JDK8以前对Map是如何排序的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('f74e6fcb-3e7e-488c-8ffe-6145c138fedd')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_f74e6fcb-3e7e-488c-8ffe-6145c138fedd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f74e6fcb-3e7e-488c-8ffe-6145c138fedd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('f74e6fcb-3e7e-488c-8ffe-6145c138fedd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f74e6fcb-3e7e-488c-8ffe-6145c138fedd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Sort a Map by Keys.——JDK7
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map To be sorted Map.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Sorted Map.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; sortedByKeys(Map&amp;lt;String, Integer&amp;gt;&lt;span&gt; map) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     List&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;(map.entrySet());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Collections.sort(list, &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compare(Map.Entry&amp;lt;String, Integer&amp;gt; o1, Map.Entry&amp;lt;String, Integer&amp;gt;&lt;span&gt; o2) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.getKey().compareTo(o2.getKey());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     Map&amp;lt;String, Integer&amp;gt; linkedMap = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     Iterator&amp;lt;Map.Entry&amp;lt;Strin    g, Integer&amp;gt;&amp;gt; iterator =&lt;span&gt; list.iterator();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Map.Entry&amp;lt;String, Integer&amp;gt; entry =&lt;span&gt; iterator.next();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        linkedMap.put(entry.getKey(), entry.getValue());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; linkedMap;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　从JDK7版本对Map排序的代码可以看到，首先需要定义泛型参数为Map.Entry类型的List，利用Collections.sort对集合List进行排序，再定义一个LinkedHashMap，遍历集合List中的元素放到LinkedHashMap中，也就是说并没有一个类似Collections.sort(Map, Comparator)的方法对Map集合类型进行直接排序。JDK8对此作了改进，通过Stream类对Map进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Sort a Map by Keys.——JDK8
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; map To be sorted Map.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Sorted Map.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; sortedByKeys(Map&amp;lt;String, Integer&amp;gt;&lt;span&gt; map) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     Map&amp;lt;String, Integer&amp;gt; result = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     map.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEachOrdered(x -&amp;gt;&lt;span&gt; result.put(x.getKey(), x.getValue()));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可见代码量大大减少，简而言之，这四个方法是JDK8利用Stream类和Lambda表达式弥补Map所缺少的排序方法。&lt;/p&gt;
&lt;p&gt;　　comparingByKey() //利用key值进行排序，但要求key值类型需要实现Comparable接口。&lt;/p&gt;
&lt;p&gt;　　comparingByValue() //利用value值进行排序，但要求key值类型需要实现Comparable接口。&lt;/p&gt;
&lt;p&gt;　　comparingByKey(Comparator) //利用key值进行排序，但key值并没有实现Comparable接口，需要传入一个Comparator比较器。&lt;/p&gt;
&lt;p&gt;　　comparingByValue(Comparator) //利用value值进行排序，但value值并没有实现Comparable接口，需要传入一个Comparator比较器。&lt;/p&gt;
&lt;p&gt;　　再多说一句，Comparator采用的是&lt;strong&gt;策略模式&lt;/strong&gt;，即不修改原有对象，而是引入一个新的对象对原有对象进行改变，此处即如果key(或value)并没有实现Comparable接口，此时可在不修改原有代码的情况下传入一个Comparator比较器进行排序，对原有代码进行修改是一件糟糕的事情。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　参考链接：&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8452379.html&quot; target=&quot;_blank&quot;&gt;《JDK8的新特性——Lambda表达式》&lt;/a&gt;&lt;a href=&quot;http://www.cnblogs.com/yulinfeng/p/8460569.html&quot; target=&quot;_blank&quot;&gt;《似懂非懂的Comparable与Comparator》&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Map.Entry接口中定义的方法到此结束，下面是Map接口中锁定义的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int size()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回Map中key-value键值对的数量，最大值是Integer.MAX_VALUE（2^31-1）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean isEmpty()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map是否为空，可以猜测如果size() = 0，Map就为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean containsKey(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map是否包含key键值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean containsValue(Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Map是否包含value值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V get(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过key值获取对应的value值。如果Map中不包含key值则返回null，也有可能该key值对应的value值本身就是null，此时要加以区别的话可以先使用containsKey方法判断是否包含key值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V put(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　向Map中存入key-value键值对，并返回插入的value值。&lt;/p&gt;
&lt;p&gt;　　Map从JDK5过后就改为了泛型类，get方法的参数不是泛型K，而是一个Object对象呢？包括上面的containsKey(Object)和containsValue(Object)参数也是Object而不是泛型。在这个地方似乎是使用泛型更加合适。思考以下场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最开始我写了一段代码，定义HashMap&amp;lt;String, String&amp;gt;，定义HashMap&amp;lt;String, String&amp;gt;，此时我put(&quot;a&quot;, &quot;a&quot;)，同时我通过get(&quot;a&quot;)获取值。&lt;/li&gt;
&lt;li&gt;写着写着，我发现我应该定义为HashMap&amp;lt;Integer, String&amp;gt;，此时IDE 会自动的在put(&quot;a&quot;, &quot;a&quot;)方法报错，因为Map的泛型参数类型key修改为了Integer，我能很好的发现它并改正。但是，我的get(&quot;a&quot;)并不会有任何提示，因为它的参数是Object能接收任意类型的值，假如我get方法同样使用了泛型此时IDE就会提醒我这个地方参数类型不对，应该是Integer类型。那么为什么会出现get方法是使用Object类型，而不是泛型呢？难道JDK的作者没有想到这一点吗？明明能在编译时就能发现的问题，为什么要在运行时再去判断？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　这个问题在StackOverflow上也有讨论，链接：&lt;a href=&quot;https://stackoverflow.%20com/questions/1926285/why-does-hashmapcontainskey-take-an-parameter-of-type-object&quot; target=&quot;_blank&quot;&gt;https://stackoverflow. com/questions/1926285/why-does-hashmapcontainskey-take-an-parameter-of-type-object&lt;/a&gt;，&lt;a href=&quot;http://smallwig.blogspot.com/2007/12/why-does-setcontains-take-object-not-e.html&quot; target=&quot;_blank&quot;&gt;http://smallwig.blogspot.com/2007/12/why-does-setcontains-take-object-not-e.html&lt;/a&gt; 我大致翻译了一下这可能有以下几个方面的原因：　&lt;/p&gt;
&lt;p&gt;　　1.这是为了保证兼容性 泛型是在JDK1.5才出现的，而HashMap则是在JDK1.2才出现，在泛型出现的时候伴随着不少兼容性问题，为了保证其兼容性不得不做了一些处理，例如泛型类型的擦除等等。假设在JDK1.5之前存在以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; HashMap hashMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ArrayList arrayList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; hashMap.put(arrayList, &quot;this is list&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;System.out.println(hashMap.get(arrayList));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; LinkedList linkedList = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; System.out.println(hashMap.get(linkedList));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这段代码在不使用泛型的时候能运行的很好，如果此时get方法中的参数变成了泛型，而不是Object，那么此时hashMap.get(linkedList)这句话将会在编译时出错，因为它不是ArrayList类型。&lt;/p&gt;
&lt;p&gt;　　2.无法确定Key的类型。这里有一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashMapTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     HashMap&amp;lt;SubFoo, String&amp;gt; hashMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();          
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SubFoo是Foo类的子类&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     test(hashMap);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译时出错&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test(HashMap&amp;lt;Foo, String&amp;gt; hashMap) {     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数为HashMap，key值是Foo类，但是不能接收它的子类&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     System.out.println(hashMap.get(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Foo()));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这种情况把test方法中的参数类型修改为HashMap&amp;lt;? extends Foo, String&amp;gt;即可。但是这是在get方法的参数类型是Object情况下才正确，如果get方法的参数类型是泛型，那它对于“? extends Foo”是一无所知的，换句话说，编译器不知道它应该接收Foo类型还是SubFoo类型，甚至是SubSubFoo类型。对于第二个假设，不少网友指出，get方法的参数类型可以是“&amp;lt;T extends E&amp;gt;”，这就能避免第二个问题了。&lt;/p&gt;
&lt;p&gt;　　在国外网友的讨论中，我还是比较倾向于第一种兼容性问题，毕竟泛型相对来说较晚出现，对于作者John也说过，他们尝试把它泛型化，但泛型化过后产生了一系列的问题，这不得不使得他们放弃将其泛型化。其实在源码的get方法注释中能看到put以前也是Object类型，在泛型出现过后，put方法能成功的改造成泛型，而get由于要考虑兼容性问题不得不放弃将它泛型化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;V remove(Object key)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　删除Map中的key-value键值对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法的参数是一个Map，将传入的Map全部放入此Map中，当然对参数Map有要求，“? extends K”意味着传入的Map其key值需要是此Map的key或者是子类，value同理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void clear()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　移除Map中所有的key-value键值对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&amp;lt;K&amp;gt; keyset()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回key的set集合，注意set是无序且不可存储重复的值，当然Map中也不可能存在重复的key值，也没有有序无序一说。其实这个方法的运用还是有点意思的，这会涉及到Java对象引用相关的一些知识。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Map&amp;lt;String, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Integer&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; map.put(&quot;a&quot;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; map.put(&quot;b&quot;, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; System.out.println(map.keySet());        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: [a, b]&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; Set&amp;lt;String&amp;gt; sets =&lt;span&gt; map.keySet();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; sets.remove(&quot;a&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; System.out.println(map.keySet());        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: [b]&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; sets.add(&quot;c&quot;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;output: throws UnsupportedOperationException&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; System.out.println(map.keySet());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第4行的输出的是Map中key的set集合，即“[a,b]” 。&lt;/p&gt;
&lt;p&gt;　　接着创建一个set对象指向map.keySet()方法返回set的集合，并且通过这个set对象删除其中的“a”元素。此时再来通过map.keySet()方法打印key的集合，会发现此时打印“[b]”。这是因为我们在&lt;strong&gt;虚拟机栈&lt;/strong&gt;上定义的sets对象其指针指向的是map.keySet()返回的对象，也就是说这两者指向的是同一个地址，那么只要任一一个对其改变都会影响这个对象本身，这也是Map接口对这个方法的定义，同时Map接口对该方法还做了另外一个限制，不能通过keySet()返回的Set对象对其进行add操作，此时将会抛出UnsupportedOperationException异常，原因很简单如果给Set对象add了一个元素，相对应的Map的key有了，那么它对应的value值呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection&amp;lt;V&amp;gt; values()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回value值的Collection集合。这个集合就直接上升到了集合的顶级父接口——Collection。为什么不是Set对象了呢？原因也很简单，key值不能重复返回Set对象很合理，但是value值肯定可以重复，返回Set对象显然不合适，如果仅仅返回List对象，那也不合适，索性返回顶级父接口——Collection。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Set&amp;lt;Map.Entry&amp;lt;K, V&amp;gt;&amp;gt; entrySet()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　返回Map.Entry的Set集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boolean equals(Object o)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int hashCode()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　equals在Object类中只是用“==”简单的实现，对于比较两个Map是否值相等显然需要重写equals方法，重写equals方法通常需要重写hashCode方法。重写equals方法需要遵守5个原则：自反性、对称性、传递性、一致性、非空性。在满足了这个几个原则后还需要满足：两个对象equals比较相等，它们的hashCode散列值也一定相等；但hashCode散列值相等，两个对象equals比较不一定相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V getOrDefault(Object key, V defaultValue)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是JDK8才出现的，并且使用了JDK8的一个新特性，在接口中实现一个方法，叫做default方法，和抽象类类似，default方法是一个具体的方法。这个方法主要是弥补在编码过程中遇到的这样场景：如果一个Map不存在某个key值，则存入一个value值。以前是会写一个判断使用contanisKey方法，现在则只需要一句话就可以搞定map.put(&quot;a&quot;, map.getOrDefault(&quot;a&quot;, 2)); 它的实现也很简单，就是判断key值在Map中是否存在，不存在则存入getOrDefault中的defaultValue参数，存在则再存入一次以前的value参数。 (((v = get(key)) != null) || containsKey(key)) ? v : defaultValue;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default void forEach(BiConsumer&amp;lt;? super K, ? super V&amp;gt; action)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法也是JDK8新增的，为了更方便的遍历，这个方法几乎新增在JDK8的集合中，使用这个新的API能方便的遍历集合中的元素，这个方法的使用需要结合Lambda表达式：map.forEach((k, v) -&amp;gt; System.out.println(&quot;key=&quot; + k + &quot;, value=&quot; + v))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default void replaceAll(BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; function)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　替换Map中的value值，Lambda表达式作为参数，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; map.replaceAll((k, v) -&amp;gt; 10);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Map中的所有值替换为10&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; map.replaceAll((k, v) -&amp;gt; {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Map中的key值等于a，其value则替换为10&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (k.equals(&quot;a&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;default V putIfAbsent(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在ConcurrentHashMap中也有一个putIfAbsent方法，那个方法指的key值不存在就插入，存在则不插入。JDK8中在Map中直接也新增了这个方法，这个方法ConcurrentHashMap#putIfAbsent含义相同，这个方法等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;map.containsKey(key, value)) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    map.put(key, value);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    map.get(key);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在之前提到了一个方法和这个类似——getOrDefault。注意不要搞混了，调用putIfAbsent会直接插入，而getOrDefault不会直接插入到Map中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default boolean remove(Object key, Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　原来的remove方法是直接传递一个key从Map中移除对应的key-value键值对。新增的方法需要同时满足key和value同时在Map有对应键值对时才删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default boolean replace(K key, V oldValue, V newValue)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　和replaceAll类似，当参数中的key-oldValue键值对在Map存在时，则使用newValue替换oldValue。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V replace(K key, V value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是上面方法的重载，不会判断key值对应的value值，而是直接使用value替换key值原来对应的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V computeIfAbsent(K key, Function&amp;lt;? super K, ? extends V&amp;gt; mappingFunction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果Map中不存在key值，则调用Lambda表达式中的函数主体计算value值，再放入Map中，下次再获取的时候直接从Map中获取。这其实在Map实现本地缓存中随处可见，这个方法类似于下列代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (map.get(key) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     value = func(key);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算value值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    map.put(key, value);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; map.get(key);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;default V computeIfPresent(K key, BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法给定一个key值，通过Lambda表达式可计算自定义key和value产生的新value值，如果新value值为null，则删除Map中对应的key值，如果不为空则用新的替换旧的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V compute(K key, BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个方法是上面两个方法的结合，有同时使用到上面两个的地方可使用这个方法代替，其中Lambda表达式的函数主体使用三木运算符。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;default V merge(K key, V value, BiFunction&amp;lt;? super V, ? super V, ? extends V&amp;gt; remappingFunction) 　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　“合并”，意味着旧值和新值都会参与计算并复制。给定key和value值参数，如果key值在Map中存在，则将旧value和给定的value一起计算出新value值作为key的值，如果新value为null，那么则从Map中删除key。如果key不存在，则将给定的value值直接作为key的值。&lt;/p&gt;
&lt;p&gt;　　Map映射集合类型作为Java中最重要以及最常用的数据结构之一，Map接口是它们的基类，在这个接口中定义了许多基础方法，而具体的实习则由它的子类完成。JDK8在Map接口中新值了许多default方法，这也为我们在实际编码中提供了很大的便利，如果是使用JDK8作为开发环境不妨多多学习使用新的API。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Feb 2018 14:54:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/8476573.html</dc:identifier>
</item>
<item>
<title>OpenCV亚像素角点cornerSubPixel()源代码分析 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/8476456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/8476456.html</guid>
<description>&lt;p&gt;　　上一篇博客中讲到了goodFeatureToTrack（）这个API函数能够获取图像中的强角点。但是获取的角点坐标是整数，但是通常情况下，角点的真实位置并不一定在整数像素位置，因此为了获取更为精确的角点位置坐标，需要角点坐标达到亚像素（subPixel）精度。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1. 求取亚像素精度的原理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　找到一篇讲述原理非常清楚的文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xueyayang.github.io/pdf_posts/%E4%BA%9A%E5%83%8F%E7%B4%A0%E8%A7%92%E7%82%B9%E7%9A%84%E6%B1%82%E6%B3%95.pdf&quot; target=&quot;_blank&quot;&gt;https://xueyayang.github.io/pdf_posts/%E4%BA%9A%E5%83%8F%E7%B4%A0%E8%A7%92%E7%82%B9%E7%9A%84%E6%B1%82%E6%B3%95.pdf&lt;/a&gt;，贴上来，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221630159-75261050.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;608&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221542589-598721322.png&quot; alt=&quot;&quot; width=&quot;832&quot; height=&quot;818&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221739311-454213270.png&quot; alt=&quot;&quot; width=&quot;844&quot; height=&quot;832&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226221840746-1648214134.png&quot; alt=&quot;&quot; width=&quot;864&quot; height=&quot;694&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt; 2. OpenCV源代码分析&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　OpenCV中有cornerSubPixel（）这个API函数用来针对初始的整数角点坐标进行亚像素精度的优化，该函数原型如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cv::cornerSubPix( InputArray _image, InputOutputArray _corners,
                       Size win, Size zeroZone, TermCriteria criteria )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　_image为输入的单通道图像；_corners为提取的初始整数角点（比如用goodFeatureToTrack提取的强角点）；win为求取亚像素角点的窗口大小，比如设置Size（11,11），需要注意的是11为半径，则窗口大小为23x23；zeroZone是设置的“零区域”，在搜索窗口内，设置的“零区域”内的值不会被累加，权重值为0。如果设置为Size(-1,-1)，则表示没有这样的区域；critteria是条件阈值，包括迭代次数阈值和误差精度阈值，一旦其中一项条件满足设置的阈值，则停止迭代，获得亚像素角点。&lt;/p&gt;
&lt;p&gt;　　这个API通过下面示例的语句进行调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
cv::cornerSubPix(grayImg, pts, cv::Size(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;), cv::Size(-&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;), cv::TermCriteria(CV_TERMCRIT_EPS + CV_TERMCRIT_ITER, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;0.1&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　首先看criteria包含的两个条件阈值在代码中是怎么设置的。如下所示，最大迭代次数为100次，误差精度为eps*eps，也就是0.1*0.1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ITERS = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; win_w = win.width * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;, win_h = win.height * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j, k;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max_iters = (criteria.type &amp;amp; CV_TERMCRIT_ITER) ? MIN(MAX(criteria.maxCount, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;), MAX_ITERS) : MAX_ITERS;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; eps = (criteria.type &amp;amp; CV_TERMCRIT_EPS) ? MAX(criteria.epsilon, &lt;span&gt;0&lt;/span&gt;.) : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    eps &lt;/span&gt;*= eps; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use square of error in comparsion operations&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后是高斯权重的计算，如下所示，窗口中心附近权重高，越往窗口边界权重越小。如果设置的有“零区域”，则权重值设置为0。计算出的权重分布如下图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Mat maskm(win_h, win_w, CV_32F), subpix_buf(win_h+&lt;span&gt;2&lt;/span&gt;, win_w+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, CV_32F);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* mask = maskm.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; win_h; i++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; y = (&lt;span&gt;float&lt;/span&gt;)(i - win.height)/&lt;span&gt;win.height;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; vy = std::exp(-y*&lt;span&gt;y);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; win_w; j++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; x = (&lt;span&gt;float&lt;/span&gt;)(j - win.width)/&lt;span&gt;win.width;
            mask[i &lt;/span&gt;* win_w + j] = (&lt;span&gt;float&lt;/span&gt;)(vy*std::exp(-x*&lt;span&gt;x));
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; make zero_zone&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;( zeroZone.width &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; zeroZone.height &amp;gt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
        zeroZone.width &lt;/span&gt;* &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt; &amp;lt; win_w &amp;amp;&amp;amp; zeroZone.height * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt; &amp;lt;&lt;span&gt; win_h )
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( i = win.height - zeroZone.height; i &amp;lt;= win.height + zeroZone.height; i++&lt;span&gt; )
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( j = win.width - zeroZone.width; j &amp;lt;= win.width + zeroZone.width; j++&lt;span&gt; )
            {
                mask[i &lt;/span&gt;* win_w + j] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138496/201802/1138496-20180226222728726-364960247.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;343&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来就是针对每个初始角点，按照上述公式，逐个进行迭代求取亚像素角点，代码如下。&lt;/p&gt;
&lt;p&gt;　　① 代码中CI2为本次迭代获取的亚像素角点位置，CI为上次迭代获取的亚像素角点位置，CT是初始的整数角点位置。&lt;/p&gt;
&lt;p&gt;　　② 每次迭代结束计算CI与CI2之间的欧式距离err，如果两者之间的欧式距离err小于设定的阈值，或者迭代次数达到设定的阈值，则停止迭代。&lt;/p&gt;
&lt;p&gt;　　③停止迭代后，需要再次判断最终的亚像素角点位置和初始整数角点之间的差异，如果差值大于设定窗口尺寸的一半，则说明最小二乘计算中收敛性不好，丢弃计算得到的亚像素角点，仍然使用初始的整数角点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do optimization loop for all the points&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; pt_i = &lt;span&gt;0&lt;/span&gt;; pt_i &amp;lt; count; pt_i++&lt;span&gt; )
    {
        Point2f cT &lt;/span&gt;= corners[pt_i], cI =&lt;span&gt; cT;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iter = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            Point2f cI2;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;, b = &lt;span&gt;0&lt;/span&gt;, c = &lt;span&gt;0&lt;/span&gt;, bb1 = &lt;span&gt;0&lt;/span&gt;, bb2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            getRectSubPix(src, Size(win_w&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;, win_h+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;), cI, subpix_buf, subpix_buf.type());
            &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;* subpix = &amp;amp;subpix_buf.at&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; process gradient&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;( i = &lt;span&gt;0&lt;/span&gt;, k = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; win_h; i++, subpix += win_w + &lt;span&gt;2&lt;/span&gt;&lt;span&gt; )
            {
                &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; py = i -&lt;span&gt; win.height;

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; win_w; j++, k++&lt;span&gt; )
                {
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; m =&lt;span&gt; mask[k];
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tgx = subpix[j+&lt;span&gt;1&lt;/span&gt;] - subpix[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tgy = subpix[j+win_w+&lt;span&gt;2&lt;/span&gt;] - subpix[j-win_w-&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxx = tgx * tgx *&lt;span&gt; m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxy = tgx * tgy *&lt;span&gt; m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gyy = tgy * tgy *&lt;span&gt; m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; px = j -&lt;span&gt; win.width;

                    a &lt;/span&gt;+=&lt;span&gt; gxx;
                    b &lt;/span&gt;+=&lt;span&gt; gxy;
                    c &lt;/span&gt;+=&lt;span&gt; gyy;

                    bb1 &lt;/span&gt;+= gxx * px + gxy *&lt;span&gt; py;
                    bb2 &lt;/span&gt;+= gxy * px + gyy *&lt;span&gt; py;
                }
            }

            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; det=a*c-b*&lt;span&gt;b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( fabs( det ) &amp;lt;= DBL_EPSILON*&lt;span&gt;DBL_EPSILON )
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2x2 matrix inversion&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; scale=&lt;span&gt;1.0&lt;/span&gt;/&lt;span&gt;det;
            cI2.x &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(cI.x + c*scale*bb1 - b*scale*&lt;span&gt;bb2);
            cI2.y &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(cI.y - b*scale*bb1 + a*scale*&lt;span&gt;bb2);
            err &lt;/span&gt;= (cI2.x - cI.x) * (cI2.x - cI.x) + (cI2.y - cI.y) * (cI2.y -&lt;span&gt; cI.y);
            cI &lt;/span&gt;=&lt;span&gt; cI2;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( cI.x &amp;lt; &lt;span&gt;0&lt;/span&gt; || cI.x &amp;gt;= src.cols || cI.y &amp;lt; &lt;span&gt;0&lt;/span&gt; || cI.y &amp;gt;=&lt;span&gt; src.rows )
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;( ++iter &amp;lt; max_iters &amp;amp;&amp;amp; err &amp;gt;&lt;span&gt; eps );

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if new point is too far from initial, it means poor convergence.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leave initial point as the result&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( fabs( cI.x - cT.x ) &amp;gt; win.width || fabs( cI.y - cT.y ) &amp;gt;&lt;span&gt; win.height )
            cI &lt;/span&gt;=&lt;span&gt; cT;

        corners[pt_i] &lt;/span&gt;=&lt;span&gt; cI;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;　　自己参照OpenCV源代码写了一个&lt;/span&gt;&lt;span&gt;myCornerSubPix（）接口函数以便加深理解，如下，仅供参考：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//获取窗口内子图像&lt;/span&gt;&lt;br/&gt;bool&lt;/span&gt; getSubImg(cv::Mat srcImg, cv::Point2f currPoint, cv::Mat &amp;amp;&lt;span&gt;subImg)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; subH =&lt;span&gt; subImg.rows;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; subW =&lt;span&gt; subImg.cols;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;int&lt;/span&gt;(currPoint.x+&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;int&lt;/span&gt;(currPoint.y+&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; initx = x - subImg.cols / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; inity = y - subImg.rows / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initx &amp;lt; &lt;span&gt;0&lt;/span&gt; || inity &amp;lt; &lt;span&gt;0&lt;/span&gt; || (initx+subW)&amp;gt;=srcImg.cols || (inity+subH)&amp;gt;=srcImg.rows )   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    cv::Rect imgROI(initx, inity, subW, subH);
    subImg &lt;/span&gt;=&lt;span&gt; srcImg(imgROI).clone();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;span&gt;//亚像素角点提取
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; myCornerSubPix(cv::Mat srcImg, vector&amp;lt;cv::Point2f&amp;gt; &amp;amp;&lt;span&gt;pts, cv::Size winSize, cv::Size zeroZone, cv::TermCriteria criteria)
{&lt;br/&gt;　　&lt;span&gt;//搜索窗口大小
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; winH = winSize.width * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; winW = winSize.height * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; winCnt = winH*&lt;span&gt;winW;&lt;br/&gt;　　&lt;span&gt;//迭代阈值限制
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; MAX_ITERS = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max_iters = (criteria.type &amp;amp; CV_TERMCRIT_ITER) ? MIN(MAX(criteria.maxCount, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;), MAX_ITERS) : MAX_ITERS;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; eps = (criteria.type &amp;amp; CV_TERMCRIT_EPS) ? MAX(criteria.epsilon, &lt;span&gt;0&lt;/span&gt;.) : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    eps &lt;/span&gt;*= eps; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use square of error in comparsion operations

    &lt;/span&gt;&lt;span&gt;//生成高斯权重&lt;/span&gt;
    cv::Mat weightMask =&lt;span&gt; cv::Mat(winH, winW, CV_32FC1);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; winH; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; winW; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; wx = (&lt;span&gt;float&lt;/span&gt;)(j - winSize.width) /&lt;span&gt; winSize.width;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; wy = (&lt;span&gt;float&lt;/span&gt;)(i - winSize.height) /&lt;span&gt; winSize.height;
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; vx = exp(-wx*&lt;span&gt;wx);
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; vy = exp(-wy*&lt;span&gt;wy);
            weightMask.at&lt;/span&gt;&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(i, j) = (&lt;span&gt;float&lt;/span&gt;)(vx*&lt;span&gt;vy);
        }
    }
　　&lt;span&gt;//遍历所有初始角点，依次迭代
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; pts.size(); k++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; a, b, c, bb1, bb2;
        
        cv::Mat subImg &lt;/span&gt;= cv::Mat::zeros(winH+&lt;span&gt;2&lt;/span&gt;, winW+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, CV_8UC1);
        cv::Point2f currPoint &lt;/span&gt;=&lt;span&gt; pts[k];
        cv::Point2f iterPoint &lt;/span&gt;=&lt;span&gt; currPoint;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iterCnt = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; err = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;迭代&lt;/span&gt;
        &lt;span&gt;do&lt;/span&gt;&lt;span&gt; 
        {
            a &lt;/span&gt;= b = c = bb1 = bb2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//提取以当前点为中心的窗口子图像（为了方便求sobel微分，窗口各向四个方向扩展一行（列）像素）&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ( !getSubImg(srcImg, iterPoint, subImg)) &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            uchar &lt;/span&gt;*pSubData = (uchar*)subImg.data+winW+&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;span&gt;//如下计算参考上述推导公式，窗口内累加
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; winH; i ++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; winW; j++&lt;span&gt;)
                {&lt;br/&gt;　　　　　　　　　　　　&lt;span&gt;//读取高斯权重值
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; m = weightMask.at&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i, j);&lt;br/&gt;&lt;span&gt;//sobel算子求梯度
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sobelx = &lt;span&gt;double&lt;/span&gt;(pSubData[i*(winW+&lt;span&gt;2&lt;/span&gt;) + j + &lt;span&gt;1&lt;/span&gt;] - pSubData[i*(winW+&lt;span&gt;2&lt;/span&gt;) + j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sobely = &lt;span&gt;double&lt;/span&gt;(pSubData[(i+&lt;span&gt;1&lt;/span&gt;)*(winW+&lt;span&gt;2&lt;/span&gt;) + j] - pSubData[(i - &lt;span&gt;1&lt;/span&gt;)*(winW+&lt;span&gt;2&lt;/span&gt;) +&lt;span&gt; j]);
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxx = sobelx*sobelx*&lt;span&gt;m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gxy = sobelx*sobely*&lt;span&gt;m;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; gyy = sobely*sobely*&lt;span&gt;m;
                    a &lt;/span&gt;+=&lt;span&gt; gxx;
                    b &lt;/span&gt;+=&lt;span&gt; gxy;
                    c &lt;/span&gt;+=&lt;span&gt; gyy;
                    &lt;span&gt;//邻域像素p的位置坐标
                    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; px = j -&lt;span&gt; winSize.width;
                    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; py = i -&lt;span&gt; winSize.height;

                    bb1 &lt;/span&gt;+= gxx*px + gxy*&lt;span&gt;py;
                    bb2 &lt;/span&gt;+= gxy*px + gyy*&lt;span&gt;py;
                }
            }
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; det = a*c - b*&lt;span&gt;b;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fabs(det) &amp;lt;= DBL_EPSILON*&lt;span&gt;DBL_EPSILON)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求逆矩阵&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; invA = c /&lt;span&gt; det;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; invC = a /&lt;span&gt; det;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; invB = -b /&lt;span&gt; det;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;角点新位置&lt;/span&gt;
&lt;span&gt;            cv::Point2f newPoint;
            newPoint.x &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(iterPoint.x + invA*bb1 + invB*&lt;span&gt;bb2);
            newPoint.y &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;)(iterPoint.y + invB*bb1 + invC*&lt;span&gt;bb2);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;和上一次迭代之间的误差&lt;/span&gt;
            err = (newPoint.x - iterPoint.x)*(newPoint.x - iterPoint.x) + (newPoint.y - iterPoint.y)*(newPoint.y -&lt;span&gt; iterPoint.y);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新角点位置&lt;/span&gt;
            iterPoint =&lt;span&gt; newPoint;
            iterCnt&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (iterPoint.x &amp;lt; &lt;span&gt;0&lt;/span&gt; || iterPoint.x &amp;gt;= srcImg.cols || iterPoint.y &amp;lt; &lt;span&gt;0&lt;/span&gt; || iterPoint.y &amp;gt;=&lt;span&gt; srcImg.rows)
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (err &amp;gt; eps &amp;amp;&amp;amp; iterCnt &amp;lt;&lt;span&gt; max_iters);
       &lt;span&gt; //判断求得的亚像素角点与初始角点之间的差异，即：最小二乘法的收敛性
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fabs(iterPoint.x - currPoint.x) &amp;gt; winSize.width || fabs(iterPoint.y - currPoint.y) &amp;gt;&lt;span&gt; winSize.height)
            iterPoint &lt;/span&gt;=&lt;span&gt; currPoint;
　　　&lt;span&gt;　//保存算出的亚像素角点&lt;/span&gt;
        pts[k] &lt;/span&gt;=&lt;span&gt; iterPoint;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　夜已深，结束。&lt;/p&gt;
&lt;p&gt;　&lt;br/&gt;  &lt;/p&gt;






</description>
<pubDate>Mon, 26 Feb 2018 14:50:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/8476456.html</dc:identifier>
</item>
</channel>
</rss>