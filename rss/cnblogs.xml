<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>eShopOnWeb 知多少 - 『圣杰』</title>
<link>http://www.cnblogs.com/sheng-jie/p/9616675.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng-jie/p/9616675.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-2d0ef7aac287507d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;构建现代Web应用&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnWeb&quot;&gt;eShopOnWeb&lt;/a&gt;是基于ASP.NET Core构建，官方创建这样一个示例项目的目的，我想无非以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;推广ASP.NET Core&lt;/li&gt;
&lt;li&gt;指导利用ASP.NET Core如何进行架构设计&lt;/li&gt;
&lt;li&gt;普及架构设计思想&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;eShopOnWeb&lt;/strong&gt; 与另外一个&lt;a href=&quot;https://github.com/dotnet/eShopOnContainers&quot;&gt;&lt;strong&gt;eShopOnContainers&lt;/strong&gt;&lt;/a&gt;互相补充。eShopOnContainers是基于微服务和容器技术的应用程序架构，支持多重部署。而eShopOnWeb相较于它就简单的多，其是基于传统Web应用开发，仅支持单一部署。&lt;/p&gt;
&lt;p&gt;本文就简单梳理下自己的所学所得。&lt;/p&gt;

&lt;p&gt;eShopOnWeb的示例项目中包含两个Web项目，一个是基于MVC创建的MPA多页面应用，一个是基于Razor创建的SPA单页面应用。在此之间我该如何选择呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是否需要丰富的交互行为？&lt;/li&gt;
&lt;li&gt;是否足够的前端技术积累？&lt;/li&gt;
&lt;li&gt;是否主要通过API进行交互？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-034d0772c574eb98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;决策表：Mpa or Spa&quot;/&gt;&lt;/p&gt;

&lt;p&gt;eShopOnWeb中应用了DDD和整洁架构的部分思想，值得了解一下。&lt;/p&gt;
&lt;h2 id=&quot;架构原则&quot;&gt;3.1 架构原则&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;关注点分离&lt;/strong&gt;：简称SOP。在分层架构设计中，关注点分离是核心设计思想，每一层独自负责不同的职责。从架构上讲，可以通过将核心业务与基础设施和用户界面逻辑分离来实现。该原则旨在避免紧耦合，又可确保各个模块独立发展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;：封装的是什么？是对象的状态和行为。外部对象无需关注其内部的实现机制。&lt;br/&gt;在类中，通过使用访问修饰符来限制外部的访问来实现封装。 如果外部想要操纵对象的状态，它应该通过定义良好的函数（或属性设置器）来实现，而不是直接访问对象的私有状态。&lt;br/&gt;而不同模块之间通过公开定义良好的接口进行方法调用，来实现封装。以隔离内部的实现机制。通过封装来确保应用程序间不同部分之间的隔离，正确使用封装有助于在应用程序设计中实现松耦合和模块化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;依赖倒置&lt;/strong&gt;：简称DIP。高层模块不应该依赖低层模块，均应该依赖与抽象；抽象不应该依赖于细节；细节应该依赖于抽象。DIP是构建松耦合应用的关键部分，从而确保应用程序模块化，更易于测试和维护。 通过遵循DIP，可以应用依赖注入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-a58ef4444bc70697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;显式依赖&lt;/strong&gt;：方法和类应明确指定所需的协作对象（依赖）以确保正常运行。简单来说，对于类而言，提供明确的构造函数（即在构造函数参数中指定该类需要正常工作所需的依赖对象），以便调用者正确传参以正确实例化对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;单一职责&lt;/strong&gt;：简称SRP。SRP作为面向对象设计的原则之一，也适用于架构原则。其与SOP类似。它强调对象应该只有一个责任，他们只应该仅有一个改变的理由。换言之，对象应该改变的唯一情况是它的职责需要被更新。遵守该原则，可以编写松耦合和模块化的应用。因为大量的新的行为都应该创建新类去实现，而不是添加到已经存在的类中。添加新类永远比修改一个类安全，因为尚无代码依赖于新类。&lt;br/&gt;在复杂的大型应用中，可以将SRP应用到分层应用的各个层。展现职责应保留在UI项目中，而数据访问职责应保留在基础设施项目中， 业务逻辑应该保留在应用程序核心项目中。如此，即易于测试又可以独立于其他职责持续演化。&lt;br/&gt;该原则的更高级应用，就是微服务了。每个微服务负责独立的职责。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;摒弃重复&lt;/strong&gt;：当出现重复时，应该实施重构。避免当功能改进时，需要同时修改多个部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;透明持久化&lt;/strong&gt;：要求可以轻松切换持久化技术，而实现持久化无感知（透明持久化）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;限界上下文&lt;/strong&gt;：该概念是DDD战略设计的一部分，通过限界上下文来划分领域，作为领域的显式边界，为领域提供上下文语境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;传统分层架构和整洁架构&quot;&gt;3.2. 传统分层架构和整洁架构&lt;/h2&gt;
&lt;p&gt;传统的分层架构是大家所熟知的三层架构。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-e59a507d227caf9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;传统三层架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-a3b465f4fbe46c76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三层架构示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的架构的缺点是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;依赖关系由上至下，不易解耦&lt;/li&gt;
&lt;li&gt;不易测试，需要测试数据库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那如何解决三层架构的问题呢，借助【依赖倒置原则】。&lt;br/&gt;DDD的分层架构思想和整洁架构中都是借助【依赖倒置原则】实现层与层之间强依赖关系的解耦。我们来看下整洁架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-bac0a5d64ee2606e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;整洁架构——洋葱视图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从该洋葱视图中我们可以看到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;依赖关系由外而内。&lt;/li&gt;
&lt;li&gt;处于核心的是实体和接口，不依赖任何其他项。其次是领域服务，仅依赖实体和接口，也相对独立。它们统称为&lt;strong&gt;应用程序内核&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;应用程序内核之外是基础架构层和展现层，彼此也不一定依赖。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于应用程序内核不依赖于基础设施层，所以可以很容易编写单元测试。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-157a4b2586bad670.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单元测试位置&quot;/&gt;&lt;br/&gt;由于UI层也不直接依赖于基础设施层，所以我们可以轻松置换基础设施层的实现（比如使用内存数据库），以进行集成测试。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-99c8cdd80e1f773b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;集成测试位置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-9eda26ea3624e0a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;整洁架构——水平视图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们就来看看eShopOnWeb是如何应用整洁架构的。&lt;/p&gt;

&lt;p&gt;首先我们看下模板架构的项目结构。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-891658b86b8ccadb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;eShopOnWeb Solution&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图来看其项目结构十分简单，简单的三层，加上三个测试项目。&lt;br/&gt;三层对应：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ApplicationCore：领域层&lt;/li&gt;
&lt;li&gt;Infrastructure：基础设施层&lt;/li&gt;
&lt;li&gt;Web/WebRazorPages：展现层&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-5328151cf46d4eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;DDD使用的传统分层架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实该项目架构是DDD经典四层架构，只不过其将应用层集成到展现层中去了。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-07d90d6a11c8b4e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Web应用服务&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基础设施层&quot;&gt;4.1 基础设施层&lt;/h2&gt;
&lt;p&gt;主要提供通用的基础服务和持久化。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-cf890e4aae447b80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Infrastructure&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图的代码结构我们可以看出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Data文件夹下定义了用于持久化的商品目录数据库上下文&lt;code&gt;CatalogContext&lt;/code&gt;和泛型仓储&lt;code&gt;EfRepository&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Identity文件夹下定义了身份数据库上下文的。&lt;/li&gt;
&lt;li&gt;Logging文件夹定义了一个日志适配器。&lt;/li&gt;
&lt;li&gt;Services定义了一个通用的邮件发送基础服务。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;领域层&quot;&gt;4.2. 领域层&lt;/h2&gt;
&lt;p&gt;领域层是一个项目的核心，用来定义业务规则并实现。其主要用来实体、值对象、聚合、仓储、领域服务和领域事件等。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-a9b947007a68e623.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ApplicationCore&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图来看：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Entities文件夹下定义了三个聚合根和相关的实体及值对象。&lt;/li&gt;
&lt;li&gt;Exceptions文件夹定义了公共的异常。&lt;/li&gt;
&lt;li&gt;Interfaces文件夹定义了系列接口。&lt;/li&gt;
&lt;li&gt;Services文件夹定义了两个领域服务。&lt;/li&gt;
&lt;li&gt;Specifications文件夹下是实现的规约模式。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;聚合根的相关实现&quot;&gt;4.2.1. 聚合根的相关实现&lt;/h3&gt;
&lt;p&gt;这里我们来看下聚合根的相关定义和实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;///抽象的聚合根空接口
public interface IAggregateRoot
    { }
//所有的实体基类
public class BaseEntity
    {
        public int Id { get; set; }
    }

//购物车聚会根
public class Basket : BaseEntity, IAggregateRoot
{
    public string BuyerId { get; set; }
    private readonly List&amp;lt;BasketItem&amp;gt; _items = new List&amp;lt;BasketItem&amp;gt;();
    public IReadOnlyCollection&amp;lt;BasketItem&amp;gt; Items =&amp;gt; _items.AsReadOnly();

    public void AddItem(int catalogItemId, decimal unitPrice, int quantity = 1)
    {
        if (!Items.Any(i =&amp;gt; i.CatalogItemId == catalogItemId))
        {
            _items.Add(new BasketItem()
            {
                CatalogItemId = catalogItemId,
                Quantity = quantity,
                UnitPrice = unitPrice
            });
            return;
        }
        var existingItem = Items.FirstOrDefault(i =&amp;gt; i.CatalogItemId == catalogItemId);
        existingItem.Quantity += quantity;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个实现中我们可以学习到：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过定义一个空的接口&lt;code&gt;IAggregateRoot&lt;/code&gt;，要求所有的聚会根来实现它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样做的体现了什么思想：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;面向接口编程&lt;/li&gt;
&lt;li&gt;约定大于配置&lt;/li&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过定义一个&lt;code&gt;BaseEntity&lt;/code&gt;，要求所有的实体继承它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么这样做？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因为实体的特征是具有唯一的身份标识，所以通过在父类来定义&lt;code&gt;Id&lt;/code&gt;属性来实现。这也就是&lt;strong&gt;层超类型&lt;/strong&gt;的实现方式。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样做有什么缺点？&lt;br/&gt;因为所有实体的主键类型不一定都是int类型，所以这个基类型最好改成泛型。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Basket聚合根中将Items定位为Readonly，是为了封装集合，避免子项被其他地方更改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;仓储的相关实现&quot;&gt;4.2.2. 仓储的相关实现&lt;/h3&gt;
&lt;p&gt;仓储是用来透明持久化领域对象的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IRepository&amp;lt;T&amp;gt; where T : BaseEntity
{
    T GetById(int id);
    T GetSingleBySpec(ISpecification&amp;lt;T&amp;gt; spec);
    IEnumerable&amp;lt;T&amp;gt; ListAll();
    IEnumerable&amp;lt;T&amp;gt; List(ISpecification&amp;lt;T&amp;gt; spec);
    T Add(T entity);
    void Update(T entity);
    void Delete(T entity);
}
public interface IAsyncRepository&amp;lt;T&amp;gt; where T : BaseEntity
{
    Task&amp;lt;T&amp;gt; GetByIdAsync(int id);
    Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; ListAllAsync();
    Task&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; ListAsync(ISpecification&amp;lt;T&amp;gt; spec);
    Task&amp;lt;T&amp;gt; AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(T entity);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上代码我们可以学到两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;面向接口编程&lt;/li&gt;
&lt;li&gt;职责分离，同步异步接口分离。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;领域服务相关实现&quot;&gt;4.2.3. 领域服务相关实现&lt;/h3&gt;
&lt;p&gt;领域服务用来实现业务逻辑的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IOrderService
{
    Task CreateOrderAsync(int basketId, Address shippingAddress);
}
public class OrderService : IOrderService
{
    private readonly IAsyncRepository&amp;lt;Order&amp;gt; _orderRepository;
    private readonly IAsyncRepository&amp;lt;Basket&amp;gt; _basketRepository;
    private readonly IAsyncRepository&amp;lt;CatalogItem&amp;gt; _itemRepository;
    public OrderService(IAsyncRepository&amp;lt;Basket&amp;gt; basketRepository,
        IAsyncRepository&amp;lt;CatalogItem&amp;gt; itemRepository,
        IAsyncRepository&amp;lt;Order&amp;gt; orderRepository)
    {
        _orderRepository = orderRepository;
        _basketRepository = basketRepository;
        _itemRepository = itemRepository;
    }
    public async Task CreateOrderAsync(int basketId, Address shippingAddress)
    {
        var basket = await _basketRepository.GetByIdAsync(basketId);
        Guard.Against.NullBasket(basketId, basket);
        var items = new List&amp;lt;OrderItem&amp;gt;();
        foreach (var item in basket.Items)
        {
            var catalogItem = await _itemRepository.GetByIdAsync(item.CatalogItemId);
            var itemOrdered = new CatalogItemOrdered(catalogItem.Id, catalogItem.Name, catalogItem.PictureUri);
            var orderItem = new OrderItem(itemOrdered, item.UnitPrice, item.Quantity);
            items.Add(orderItem);
        }
        var order = new Order(basket.BuyerId, shippingAddress, items);
        await _orderRepository.AddAsync(order);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上代码我们可以学习到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;依赖注入&lt;/li&gt;
&lt;li&gt;领域服务负责实现真正的业务逻辑&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;应用层和展现层&quot;&gt;4.3. 应用层和展现层&lt;/h2&gt;
&lt;p&gt;如上面所阐述，在示例项目中应用层和展现层合二为一。应用层负责展现层与领域层之间的协调，协调业务对象来执行特定的应用程序。&lt;/p&gt;

&lt;p&gt;eShopOnWeb中也提到了AOP，介绍了在ASP.NET Core中如何应用过滤器来进行AOP，比如：身份验证、模型验证、输出缓存和错误处理等。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-7306156f28ae58b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;通过过滤器和请求管道执行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-55b0e5ea31e557ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;执行顺序&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在eShopOnWeb中，也对DDD的概念，是否使用，何时使用，何时不用，都略有介绍。这里就摘录一二，当然也可以参考我之前的写的&lt;a href=&quot;https://www.jianshu.com/p/6e2917551e63&quot;&gt;DDD理论学习系列&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;DDD首先是一个方法论，其注重于领域的合理建模，分为战略建模和战术建模。&lt;/li&gt;
&lt;li&gt;如果你不知道你需要它，那么你可能不需要它。&lt;/li&gt;
&lt;li&gt;如果你不知道到DDD用于解决什么问题，那么你可能没有遇到这些问题。&lt;/li&gt;
&lt;li&gt;DDD倡导者也经常指出其仅适用于大型项目 （&amp;gt;6个月）。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;DDD是用来对真实世界系统或流程的建模。&lt;/li&gt;
&lt;li&gt;使用DDD时，你需要和领域专家紧密合作，领域专家能够解释真实的系统该如何运行。在和领域专家的交流中确定&lt;em&gt;通用语言&lt;/em&gt;，其主要用来描述系统中的一些概念。而之所以是&lt;strong&gt;通用&lt;/strong&gt;，是因为不管是开发人员还是领域专家都应能够读懂。而通用语言描述的概念将构成面向对象设计的基础。其体现在代码中的理想状态是&lt;strong&gt;代码即设计&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;战术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;值对象：不可变。&lt;/li&gt;
&lt;li&gt;实体：具有唯一标识符可变。&lt;/li&gt;
&lt;li&gt;聚会根：在DDD中，用来表示整体与部分的关系，聚合是将相关联的领域对象进行显式分组，来表达整体的概念（也可以是单一的领域对象）。比如将表示订单与订单项的领域对象进行组合，来表达领域中订单这个整体概念。&lt;/li&gt;
&lt;li&gt;仓储：一种持久化的模式，用于隔离具体持久化措施，实现透明持久化。&lt;/li&gt;
&lt;li&gt;工厂：用于对象的创建。&lt;/li&gt;
&lt;li&gt;服务：应用服务和领域服务。领域服务负责业务逻辑，应用服务用于表达业务用例和用户故事。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;战略&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;限界上下文：来为领域提供上下文语境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。&lt;/li&gt;
&lt;li&gt;上下文映射图：限界上下文之间的关联关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在eShopOnWeb中，还示例了三个测试项目，来指导我们合理的进行测试。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2799767-f02ba05589fc816f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单元测试、集成测试和功能测试的区别&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总体而言，示例项目简单容易理解，也主要是为了便于推广和演示。但里面涉及的知识点并没有想象的那么简单，从架构原则到设计和应用，每一个环节都包含不简单的知识体系。&lt;/p&gt;
&lt;p&gt;所以等什么呢？结合&lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnWeb&quot;&gt;示例项目&lt;/a&gt;和官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/modern-web-apps-azure-architecture/&quot;&gt;使用 ASP.NET Core 和 Azure 构建新式 Web 应用程序&lt;/a&gt;开始学习吧，相信你也会收获颇丰。&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 23:20:00 +0000</pubDate>
<dc:creator>『圣杰』</dc:creator>
<og:description>1.引言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheng-jie/p/9616675.html</dc:identifier>
</item>
<item>
<title>使用装饰者模式做有趣的事情 - 陈陈jg</title>
<link>http://www.cnblogs.com/chenjg/p/9616616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjg/p/9616616.html</guid>
<description>&lt;h4 id=&quot;什么是装饰者模式&quot;&gt;什么是装饰者模式&lt;/h4&gt;
&lt;p&gt;装饰者模式是一种为函数或类增添特性的技术，它可以让我们在不修改原来对象的基础上，为其增添新的能力和行为。它本质上也是一个函数(在javascipt中，类也只是函数的语法糖)。&lt;/p&gt;
&lt;h4 id=&quot;我们什么时候可以弄到它呢&quot;&gt;我们什么时候可以弄到它呢&lt;/h4&gt;
&lt;p&gt;我们来假设一个场景，一个自行车商店有几种型号的自行车，现在商店允许用户为每一种自行车提供一些额外的配件，比如前灯、尾灯、铃铛等。每选择一种或几种配件都会影响自行车的售价。&lt;/p&gt;
&lt;p&gt;如果按照比较传统的创建子类的方式，就等于我们目前有一个自行车基类，而我们要为每一种可能的选择创建一个新的类。可是由于用户可以选择一种或者几种任意的配件，这就导致最终可能会生产几十上百个子类，这明显是不科学的。然而，对这种情况，我们可以使用装饰者模式来解决这个问题。&lt;/p&gt;
&lt;p&gt;自行车的基类如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class Bicycle {
    // 其它方法
    wash () {}
    ride () {}
    getPrice() {
        return 200;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们可以先创建一个装饰者模式基类&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class BicycleDecotator {
    constructor(bicycle) {
        this.bicycle = bicycle;
    }
    wash () {
        return this.bicycle.wash();
    }
    ride () {
        return this.bicycle.ride();
    }
    getPrice() {
        return this.bicycle.getPrice();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个基类其实没有做什么事情，它只是接受一个Bicycle实例，实现其对应的方法，并且将调用其方法返回而已。&lt;/p&gt;
&lt;p&gt;有了这个基类之后，我们就可以根据我们的需求对原来的Bicycle类为所欲为了。比如我可以创建一个添加了前灯的装饰器以及添加了尾灯的装饰器：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class HeadLightDecorator extends BicycleDecorator {
    constructor(bicycle) {
        super(bicycle);
    }
    getPrice() {
        return this.bicycle.getPrice() + 20;
    }
}
class TailLightDecorator extends BicycleDecorator {
    constructor(bicycle) {
        super(bicycle);
    }
    getPrice() {
        return this.bicycle.getPrice() + 20;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，接下来我们就可以来对其自由组合了:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let bicycle = new Bicycle();
console.log(bicycle.getPrice()); // 200
bicycle = new HeadLightDecorator(bicycle); // 添加了前灯的自行车
console.log(bicycle.getPrice());  // 220
bicycle = new TailLightDecorator(bicycle); // 添加了前灯和尾灯的自行车
console.log(bicycle.getPrice()); // 240&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样写的好处是什么呢?假设说我们有10个配件，那么我们只需要写10个配件装饰器，然后就可以任意搭配成不同配件的自行车并计算价格。而如果是按照子类的实现方式的话，10个配件可能就需要有几百个甚至上千个子类了。&lt;/p&gt;
&lt;p&gt;从例子中我们可以看出装饰者模式的适用场合：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;如果你需要为类增添特性或职责，可是从类派生子类的解决方法并不太现实的情况下，就应该使用装饰者模式。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在例子中，我们并没有对原来的Bicycle基类进行修改，因此也不会对原有的代码产生副作用。我们只是在原有的基础上增添了一些功能。因此，&lt;strong&gt;如果想为对象增添特性又不想改变使用该对象的代码的话，则可以采用装饰者模式。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;装饰者模式除了可以应用在类上之外，还可以应用在函数上（其实这就是高阶函数）。比如，我们想测量函数的执行时间，那么我可以写这么一个装饰器：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function func() {
    console.log('func');
}
function timeProfileDecorator(func) {
    return function (...args) {
        const startTime = new Date();
        func.call(this, ...args);
        const elapserdTime = (new Date()).getTime() - startTime.getTime();
        console.log(`该函数消耗了${elapserdTime}ms`);
    }
}
const newFunc = timeProfileDecorator(func);
console.log(newFunc());&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;做一些有趣的事情&quot;&gt;做一些有趣的事情&lt;/h4&gt;
&lt;p&gt;既然知道了装饰者模式可以在不修改原来代码的情况下为其增添一些新的功能，那么我们就可以来做一些有趣的事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以为一个类的方法提供性能分析的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;class TimeProfileDecorator {
  constructor(component, keys) {
    this.component = component;
    this.timers = {};
    const self = this;
    for (let i in keys) {
      let key = keys[i];
        if (typeof component[key] === 'function') {
          this[key] = function(...args) {
            this.startTimer(key);
            // 解决this引用错误问题
            component[key].call(component, ...args);
            this.logTimer(key);
          }
        }
    }
  }
  startTimer(namespace) {
    this.timers[namespace] = new Date();
  }
  logTimer(namespace) {
    const elapserdTime = (new Date()).getTime() - this.timers[namespace].getTime();
    console.log(`该函数消耗了${elapserdTime}ms`);
  }
}
// example
class Test {
  constructor() {
    this.name = 'cjg';
    this.age = 22;
  }
  sayName() {
    console.log(this.name);
  }
  sayAge() {
    console.log(this.age);
  }
}

let test1 = new Test();
test1 = new TimeProfileDecorator(test1, ['sayName', 'sayAge']);
console.log(test1.sayName());
console.log(test1.sayAge());&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对函数进行增强&quot;&gt;对函数进行增强&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;节流函数or防抖函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function throttle(func, delay) {
    const self = this;
    let tid;
    return function(...args) {
        if (tid) return;
        tid = setTimeout(() =&amp;gt; {
            func.call(self, ...args);
            tid = null;
        }, delay);
    }
}

function debounce(func, delay) {
    const self = this;
    let tid;
    return function(...args) {
        if (tid) clearTimeout(tid);
        tid = setTimeout(() =&amp;gt; {
            func.call(self, ...args);
            tid = null;
        }, delay);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;缓存函数返回值&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 缓存函数结果，对于一些计算量比较大的函数效果比较明显。
function memorize(func) {
    const cache = {};
    return function (...args) {
        const key = JSON.stringify(args);
        if (cache[key]) {
          console.log('缓存了');
          return cache[key];
        }
        const result = func.call(this, ...args);
        cache[key] = result;
        return result;
    };
}

function fib(num) {
  return num &amp;lt; 2 ? num : fib(num - 1) + fib(num - 2);
}

const enhanceFib = memorize(fib);
console.log(enhanceFib(40));
console.log(enhanceFib(40));
console.log(enhanceFib(40));
console.log(enhanceFib(40));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构造React高阶组件,为组件增加额外的功能&lt;/strong&gt;，比如为组件提供shallowCompare功能：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react';
const { Component } = react;

const ShadowCompareDecorator = (Instance) =&amp;gt; class extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    return !shallowCompare(this.props, nextProps) ||
      !shallowCompare(this.state, nextState);
  }
  render() {
    return (
      &amp;lt;Instance {...this.props} /&amp;gt;
    );
  }
};

export default ShadowCompareDecorator;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你如果用过react-redux的话，你肯定也用过connect。其实connect也是一种高阶组件的方式。它通过装饰者模式，从Provider的context里拿到全局的state，并且将其通过props的方式传给原来的组件。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;使用装饰者模式可以让我们为原有的类和函数增添新的功能，并且不会修改原有的代码或者改变其调用方式，因此不会对原有的系统带来副作用。我们也不用担心原来系统会因为它而失灵或者不兼容。就我个人而言，我觉得这是一种特别好用的设计模式。&lt;/p&gt;
&lt;p&gt;一个好消息就是，js的装饰器已经加入了es7的草案里啦。它让我们可以更加优雅的使用装饰者模式，如果有兴趣的可以添加下babel的plugins插件提前体验下。阮一峰老师的这个&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/decorator&quot;&gt;教程&lt;/a&gt;也十分浅显易懂。&lt;/p&gt;
&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Javascript设计模式&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 18:57:00 +0000</pubDate>
<dc:creator>陈陈jg</dc:creator>
<og:description>什么是装饰者模式 装饰者模式是一种为函数或类增添特性的技术，它可以让我们在不修改原来对象的基础上，为其增添新的能力和行为。它本质上也是一个函数(在javascipt中，类也只是函数的语法糖)。 我们什</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjg/p/9616616.html</dc:identifier>
</item>
<item>
<title>你不知道的JS（2）深入了解闭包（非常重要） - 汕大小吴</title>
<link>http://www.cnblogs.com/wuguanglin/p/closure.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuguanglin/p/closure.html</guid>
<description>&lt;p&gt;很久之前就想写一篇关于闭包的博客了，但是总是担心写的不够完全、不够好，不管怎样，还是要把我理解的闭包和大家分享下，比较长，希望耐心看完。&lt;/p&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;说实话，给闭包下一个定义是很困难的，原因在于javascript设计的时候并没有专门设计闭包这样一个规则，闭包是随着作用域链、函数可以作为一等公民这样的规则而诞生的。&lt;/p&gt;
&lt;p&gt;尽管不能下一个很完美的定义，但是我们还是可以给闭包下一个尽量准确的定义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。&lt;/p&gt;

&lt;h3&gt;哪些是闭包？&lt;/h3&gt;
&lt;p&gt;来看下面这个例子1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
        console.log( a ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;    }
    bar();
}
foo();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于词法作用域的查找规则，函数bar() 可以访问外部作用域中的变量a（这个例子中的是一个RHS 引用查询）。&lt;/p&gt;
&lt;p&gt;那么这个是闭包吗？&lt;strong&gt;很遗憾不是，因为bar函数执行在其定义的词法作用域处。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;不过稍加修改后就是个闭包了，例子2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
        console.log( a );
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baz =&lt;span&gt; foo();
baz(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 —— 朋友，这就是闭包的效果。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;baz函数执行实际上只是通过不同的标识符引用调用了内部的函数bar()&lt;/p&gt;
&lt;p&gt;bar()函数显然可以被正常执行，也就是&lt;strong&gt;在自己定义的词法作用域以外的地方执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据作用域的规则，函数bar()函数能够访问foo()的内部作用域，因此foo()执行完后，其内部作用域并不会被回收，bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。&lt;/p&gt;

&lt;p&gt;这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。&lt;/p&gt;
&lt;p&gt;当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;来看例子3：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz() {
        console.log( a ); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;span&gt;    }
    bar( baz );
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar(fn) {
    fn(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 妈妈快看呀，这就是闭包！&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，这也是个闭包，&lt;strong&gt;这里将baz传递出去了在bar()函数中执行，而不是在自己定义的词法作用域中执行，但是它却保留这对定义时词法作用域的引用&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;再看例子4：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; fn;
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz() {
        console.log( a );
    }
    fn &lt;/span&gt;= baz; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将baz 分配给全局变量&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
    fn(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 妈妈快看呀，这就是闭包！&lt;/span&gt;
&lt;span&gt;}
foo();
bar(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的没错，这还是个闭包，&lt;strong&gt;无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;那我们看一个难一点的例子5：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; wait(message) {
　　setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
　　　　console.log( message );
　　}, &lt;/span&gt;1000&lt;span&gt; );
}
wait( &lt;/span&gt;&quot;Hello, closure!&quot; );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是闭包吗？答案是的，在这里我们&lt;strong&gt;向setTimeOut传入timer()函数，并且timer函数可以访问wait的内部作用域&lt;/strong&gt;，保持着对wait内部作用域的引用，比如里面的message变量。&lt;/p&gt;
&lt;p&gt;这时候你肯定会心生疑惑：不对呀？这在哪执行呢？不是说要在定义的词法作用域以外执行吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传入的timer函数当然会被执行，只是内部引擎调用执行的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;深入到引擎的内部原理中，内置的工具函数setTimeout(..) 持有对一个参数的引用，这个参数也许叫作fn 或者func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的timer 函数，而词法作用域在这个过程中保持完整，time函数保持着对wait内部作用域的引用。&lt;/p&gt;

&lt;h3&gt;IIFE（立即执行函数）是闭包吗？&lt;/h3&gt;
&lt;p&gt;例子6：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; IIFE() {
console.log( a );
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照我们的定义来说，这不是闭包。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;尽管IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。&lt;/p&gt;
&lt;p&gt;这也是为什么很难给闭包下定义的地方，因为如果从内存或者作用来看，IIFE创建了闭包（也就是在内存中创建了一块区域，这块区域保存着作用域链上作用域的引用，稍后可见例子9），或者说效果等同于创建了闭包。&lt;/p&gt;
&lt;p&gt;而如果从闭包的定义来看，这却不是闭包。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我们来看例子7：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=1; i&amp;lt;=5; i++&lt;span&gt;) {
　　setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
　　　　console.log( i );
　　}, i&lt;/span&gt;*1000&lt;span&gt; );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家都知道这段代码会输出五次6，为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为setTimeOut()是异步函数，也就是等循环结束后才去执行setTimeOut()中的回调函数，而在for循环中，并不存在着块级作用域，也就是这个i声明在全局作用域中，并且自始至终只有一个i(因为var声明会变量声明提升，也就是其实只声明了一次)，而在for循环结束后，这个i的值是6。setTimeOut()中的回调函数timer()保持着对i的引用，但是5次timer()函数引用的只是同一个i，所以输出5次6。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;例子8：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=1; i&amp;lt;=5; i++&lt;span&gt;) {
    (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
            console.log( i );
        }, i&lt;/span&gt;*1000&lt;span&gt; );
    })();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样有效果么？答案是没有的，虽然通过IIFE每次都创建了一个作用域，但是这个作用域是空的（也就是创建了一个空作用域），所以还会沿着词法作用域链去上一层找i，结果找到的还是全局作用域中的i，也就是只有一个i，还是会输出五次6。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;所以我们需要这样改，来看例子9：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 它需要有自己的变量，用来在每个迭代中储存i 的值：&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=1; i&amp;lt;=5; i++&lt;span&gt;) {
    (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; j =&lt;span&gt; i;
        setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
            console.log( j );
        }, j&lt;/span&gt;*1000&lt;span&gt; );
    })();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 行了！它能正常工作了！。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 可以对这段代码进行一些改进：&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=1; i&amp;lt;=5; i++&lt;span&gt;) {
    (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(j) {
        setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
            console.log( j );
        }, j&lt;/span&gt;*1000&lt;span&gt; );
    })( i );
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然你也可以这样写&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=1; i&amp;lt;=5; i++&lt;span&gt;) {
    (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i) {
        setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
            console.log( i );
        }, i&lt;/span&gt;*1000&lt;span&gt; );
    })( i );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在迭代内使用IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好在ES6出来了let的解决方案，let并不会变量声明提升，并且具有块级作用域的效果，也就是这里会产生5个i的内存空间，被五个timer()函数引用着。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例子10：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (let i=1; i&amp;lt;=5; i++&lt;span&gt;) {
　　setTimeout( &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
　　　　console.log( i );
　　}, i&lt;/span&gt;*1000&lt;span&gt; );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;关于闭包的垃圾回收&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题1：闭包会造成内存泄漏吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们常说闭包会造成内存泄漏，这是真的吗？答案是不会的。&lt;/p&gt;
&lt;p&gt;之所以之前一直说闭包会造成垃圾泄露是由于IE9 之前的版本对JavaScript 对象（标记清除）和COM 对象（引用计数）使用不同的垃圾收集方法。因此闭包在IE 的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;例子11：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; assignHandler(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; element = document.getElementById(&quot;someElement&quot;&lt;span&gt;);
    element.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        alert(element.id);
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码创建了一个作为element 元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assignHandler()的活动对象的引用，因此就会导致无法减少element 的引用数。只要匿名函数存在，element 的引用数至少也是1，因此它所占用的内存就永远不会被回收。&lt;/p&gt;
&lt;p&gt;解决办法就是把element.id 的一个副本保存在一个变量中，从而消除闭包中该变量的循环引用同时将element变量设为null。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;例子12：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; assignHandler(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; element = document.getElementById(&quot;someElement&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id =&lt;span&gt; element.id;
    element.onclick &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        alert(id);
    };
    element &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;问题2：闭包中没有使用的变量会被回收吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是会的。&lt;/p&gt;
&lt;p&gt;来看例子13：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; x =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y = &quot;whatever&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
        alert(y);
    };
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; z = foo();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里x没有被使用，那么x会被回收吗？答案是的。&lt;/p&gt;
&lt;p&gt;理论上来说，bar函数保存着foo作用域中的引用，那么x不应该会被回收。但是现代javascript引擎是非常智能的，对这里进行了优化。&lt;/p&gt;
&lt;p&gt;javascript引擎经过&lt;strong&gt;逃逸分析&lt;/strong&gt;（分析函数调用关系，以判断变量是否“逃逸”出当前作用域范围）后判断出来x没有在闭包中使用到，那么它就会把x从堆中的作用域中移除出去。&lt;/p&gt;
&lt;p&gt;一般是如何分析呢？很简单，如果闭包中没有引用到这个变量，并且没有使用 &lt;code&gt;eval&lt;/code&gt; 或者 &lt;code&gt;new Function，那么javascript引擎可以知道闭包的内存中的作用域不需要这个变量x.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体测试可以看之前司徒正美的一篇文章：&lt;a href=&quot;http://www.cnblogs.com/rubylouvre/p/3345294.html&quot; target=&quot;_blank&quot;&gt;JS闭包测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者可以看看stackoverflow上的一篇解答：&lt;a href=&quot;http://www.cnblogs.com/wuguanglin/p/JavaScript%20Closures%20Concerning%20Unreferenced%20Variables&quot;&gt;JavaScript Closures Concerning Unreferenced Variables&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题3：闭包中函数里的变量是分配在堆中还是栈中？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在简单的解释器实现里，函数里的变量是分配在堆而不是在栈上的。现代 JS 引擎当然就比较牛逼了，通过逃逸分析是可以知道哪些可以分配在栈上，哪些需要分配在堆上的。&lt;/p&gt;
&lt;p&gt;也就是闭包中使用到的变量会分配在堆中，没有使用到的会分配在栈中（针对简单类型而言），以方便回收。&lt;/p&gt;
&lt;p&gt;比如例子13的x，没有被闭包使用，不过是一个复杂类型，所以它在内存中是变量x存储在栈中，同时栈中x的值是堆中的对象{}的地址，大概是下面这样&lt;/p&gt;
&lt;p&gt;【栈x】----&amp;gt;（堆{}）&lt;/p&gt;

&lt;p&gt;例子13中的y，被闭包使用了，闭包的函数就基于原先的词法作用域单独在堆中分配了内存，也就是闭包保存在了堆，同时其使用的变量也随着闭包一起保存在堆，大概是下面这样。&lt;/p&gt;
&lt;p&gt;（堆（闭包（y：“whatever”）））&lt;/p&gt;


&lt;p&gt;好了，以上这就是我的个人理解了，如果有什么疑问或者建议欢迎讨论。&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 18:23:00 +0000</pubDate>
<dc:creator>汕大小吴</dc:creator>
<og:description>很久之前就想写一篇关于闭包的博客了，但是总是担心写的不够完全、不够好，不管怎样，还是要把我理解的闭包和大家分享下，比较长，希望耐心看完。 定义 说实话，给闭包下一个定义是很困难的，原因在于javasc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuguanglin/p/closure.html</dc:identifier>
</item>
<item>
<title>资深架构师Sum的故事：正则！入门就是这样简单 - 程序员VIP</title>
<link>http://www.cnblogs.com/programmerVIP/p/9616607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/programmerVIP/p/9616607.html</guid>
<description>&lt;p&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;故事背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　职场如战场！Sum带领三个小队友用了两周，成功把代理功能给干出来了。如果说产品经理是最魔鬼的指挥官，那测试就是最魔鬼的教官。这两周，让Sum深深领略了什么是X市的日出。&lt;/p&gt;
&lt;p&gt;　　不过话又说回来，战斗时光是酸苦且甘甜的，每每回忆，嘴角都会泛起流糖般的微笑，那是年轻时月亮的背影，那是年轻时初升太阳的轮廓。&lt;/p&gt;
&lt;p&gt;　　不知道其他热爱程序的人是不是这样想的，但Sum是这么认为的。&lt;/p&gt;
&lt;p&gt;　　Sum依旧按部就班。&lt;/p&gt;
&lt;p&gt;　　这日Sum早早到公司了，8点，太阳才刚微热。晨雾还未散去，站在落地窗向外看，世界就像打开馒头蒸笼般冒着热腾腾的蒸汽。&lt;/p&gt;
&lt;p&gt;　　Sum打开电脑，趁着开机消耗的时间，去泡了杯咖啡。回到座位，电脑早已经开好。&lt;/p&gt;
&lt;p&gt;　　看了下工作日程，和往常一样，审计代码、梳理需求、开会，开会，还是开会。&lt;/p&gt;
&lt;p&gt;　　那就从审计昨日代码开始吧，Sum从git下载了昨日的代码（因为X公司有固定发布日，所以代码提交后，第二天由Sum等项目负责人去负责审计），下载完成后，Sum打开了zendstudio（因为Sum负责公司的PHP模块开发，所以负责审计这部分代码），导入最新的工程，对照更新日志，打开对应的修改过文件，一遍喝着咖啡，一遍看着代码。&lt;/p&gt;
&lt;p&gt;　　Sum在看到一个功能函数库文件的时候，发现一个&lt;strong&gt;curlApi（$url,$param,$type=1）&lt;/strong&gt;函数，实现过程有一段这样的代码，看起来很别扭，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;strpos&lt;/span&gt;(&lt;span&gt;$response&lt;/span&gt;,&quot;__callback(&quot;)!==&lt;span&gt;false&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;$response&lt;/span&gt;=&lt;span&gt;str_replace&lt;/span&gt;(&lt;span&gt;array&lt;/span&gt;(&quot;__callback(&quot;,&quot;)&quot;),&lt;span&gt;array&lt;/span&gt;(&quot;&quot;,&quot;&quot;),&lt;span&gt;$response&lt;/span&gt;&lt;span&gt;);    
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;$returnData&lt;/span&gt; = json_decode(&lt;span&gt;$response&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;$returnData&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果看起来很正常，就是curl一个API，返回的$response有可能包含了__callback字符串，不是纯的json文本，所以这位队友就在返回结果做了个判断，如果存在__callback(的字符串，就要替换成空，再近些json转数组的操作。但是，在Sum开起来，这里面埋了一个雷，什么雷呢？如果接口提供方哪天心情不好了，把__callback换成了__query，而且不通知到技术部，那这个用法就废了，怎么办呢？Sum第一个念头就是使用正则表达式，去匹配这类特殊的响应值。&lt;/p&gt;
&lt;p&gt;　　心中有了想法，Sum就想做一个教程，给团队的成员普及一下，于是乎，Sum打开了PPT，准备起了培训材料。。。。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Sum要做一分通俗易懂，易于宣讲的正则表达式的教程。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Sum觉得，要能下意识的想到用正则表达式，那必须要把正则表达式的表，给背熟，融入到骨子里去，然后再经过多个demo的练习，形成如果需要处理字符串或者文本（比如爬虫），首先想到的就是正则表达式。所以，Sum就在PPT的首章，贴出了正则表达式的规则表。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;普通字符：&lt;/span&gt;&lt;strong&gt;普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号&lt;/strong&gt;。&lt;span&gt;比如/demo/，就是匹配字符串或者文本，有无demo这个字眼&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;非打印字符&lt;/span&gt;（指在计算机中有一些字符是确确实实存在,但是它们不能够显示或者打印出来，以&lt;a href=&quot;https://www.baidu.com/s?wd=ASCII%E7%A0%81%E8%A1%A8&amp;amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;amp;rsv_dl=gh_pc_zhidao&quot; target=&quot;_blank&quot;&gt;ASCII码表&lt;/a&gt;为例，&lt;a href=&quot;https://www.baidu.com/s?wd=ascii%E7%A0%81&amp;amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;amp;rsv_dl=gh_pc_zhidao&quot; target=&quot;_blank&quot;&gt;ascii码&lt;/a&gt;值在0-31的为&lt;a href=&quot;https://www.baidu.com/s?wd=%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6&amp;amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;amp;rsv_dl=gh_pc_zhidao&quot; target=&quot;_blank&quot;&gt;控制字符&lt;/a&gt;，无法显示和打印）：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;strong&gt;非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列&lt;/strong&gt;：&lt;/p&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;th width=&quot;20%&quot;&gt;字符&lt;/th&gt;
&lt;th width=&quot;80%&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;\cx&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\f&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配一个换页符。等价于 \x0c 和 \cL。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\n&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配一个换行符。等价于 \x0a 和 \cJ。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\r&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配一个回车符。等价于 \x0d 和 \cM。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\t&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配一个制表符。等价于 \x09 和 \cI。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\v&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配一个垂直制表符。等价于 \x0b 和 \cK。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　特殊字符：&lt;/span&gt;所谓特殊字符，就是一些有特殊含义的字符，如上面说的 &lt;span class=&quot;marked&quot;&gt;runoo*b 中的 &lt;span class=&quot;marked&quot;&gt;*，简单的说就是表示任何字符串的意思。如果要查找字符串中的 &lt;span class=&quot;marked&quot;&gt;* 符号，则需要对 &lt;span class=&quot;marked&quot;&gt;* 进行转义，即在其前加一个 &lt;span class=&quot;marked&quot;&gt;\: &lt;span class=&quot;marked&quot;&gt;runo\*ob 匹配 runo*ob。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　  许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符&quot;转义&quot;，即，将反斜杠字符&lt;span class=&quot;marked&quot;&gt;\ 放在它们前面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　下表列出了正则表达式中的特殊字符：&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr&gt;&lt;th width=&quot;20%&quot;&gt;特别字符&lt;/th&gt;
&lt;th width=&quot;80%&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;( )&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;[&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;标记一个中括号表达式的开始。要匹配 [，请使用 \[。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;\&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 &quot;\&quot;，而 '\(' 则匹配 &quot;(&quot;。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;{&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;标记限定符表达式的开始。要匹配 {，请使用 \{。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;|&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;指明两项之间的一个选择。要匹配 |，请使用 \|。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt; 　　&lt;span&gt;限定符：&lt;/span&gt;限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;strong&gt;正则表达式的限定符有：&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr&gt;&lt;th width=&quot;20%&quot;&gt;字符&lt;/th&gt;
&lt;th width=&quot;80%&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于{0,}。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 、 &quot;does&quot; 中的 &quot;does&quot; 、 &quot;doxy&quot; 中的 &quot;do&quot; 。? 等价于 {0,1}。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 &quot;Bob&quot; 中的 'o'，但是能匹配 &quot;food&quot; 中的两个 o。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;{n,}&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 &quot;Bob&quot; 中的 'o'，但能匹配 &quot;foooood&quot; 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;m 和 n 均为非负整数，其中n &amp;lt;= m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o{1,3}&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;　　&lt;span&gt;定位符：&lt;/span&gt;定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。定位符用来描述字符串或单词的边界，&lt;span class=&quot;marked&quot;&gt;^ 和 &lt;span class=&quot;marked&quot;&gt;$ 分别指字符串的开始与结束，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;　　　　　　　　&lt;span class=&quot;marked&quot;&gt;\b 描述单词的前或后边界，&lt;span class=&quot;marked&quot;&gt;\B 表示非单词边界。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;&lt;span class=&quot;marked&quot;&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　正则表达式的定位符有：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;reference&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;th width=&quot;20%&quot;&gt;字符&lt;/th&gt;
&lt;th width=&quot;80%&quot;&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;匹配一个字边界，即字与空格间的位置。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;非字边界匹配。&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 　　&lt;strong&gt;&lt;span&gt;一定要背熟！！一定要背熟！！！！一定要背熟！！！！！！！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 　　Sum洋洋洒洒的在PPT上写下这行字，还特地标注这行，让字显得更加醒目！&lt;/p&gt;
&lt;p&gt; 　　跟代码打交道多年的Sum，知道最有说服力的方式，就是编写一个个demo，进行知识点的拆解。而正则表达式使用最多的场景，便是爬虫（应用层面，当然还有编译器等等深层次的使用），于是他选择了一个网页的源码（&lt;a href=&quot;https://www.cnblogs.com/programmerVIP/p/9567514.html&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;　　 把源码保存成文本，Sum决定由浅入深的编写正则的demo，便在PPT把自己的demo顺序敲上去：&lt;/p&gt;
&lt;p&gt;　　《获取网页标题--入门就是这样简单》&lt;/p&gt;
&lt;p&gt;　　《删掉那些没用标签--想取得便要先舍去》&lt;/p&gt;
&lt;p&gt;　　《根据类名取标签--指哪取哪》&lt;/p&gt;
&lt;p&gt;　　《批量取匹配标签--我的子集我做主》&lt;/p&gt;
&lt;p&gt;　　《成对标签--让数据更准确》&lt;/p&gt;
&lt;p&gt;　　demo 的索引目录写进PPT之后，Sum就对这些目录进行展开编码，时不我待，马上开干。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;《获取网页标题--入门就是这样简单》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;写过静态页面的都知道，网页的标题，都是在头部进行定义，并且包含在&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;标签之间。如图：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/979747/201809/979747-20180910010216648-1511072836.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　并且，规范的html代码，标题都是唯一的，换句话说，title标签，仅此一个。所以对于抓取html标题，那就变得容易了，只要写一个规则，匹配html的title标签，再给正则表达式做一个子规则提取到标题的内容即可。&lt;/p&gt;
&lt;p&gt;　　于是Sum便打开了编辑器，用php写下了一个函数，用于匹配该部分的html代码，并取出title的内容。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/979747/201809/979747-20180910013942817-810447684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　图上，便是Sum写的getTitle()函数，核心的正则表达式是&lt;strong&gt;/\&amp;lt;title\&amp;gt;(.*)\&amp;lt;\/title\&amp;gt;/&lt;/strong&gt;；由于&amp;lt;、/、&amp;gt;是正则表达式的符号，所以PHP制定正则规则时，就要对这些字符进行转义（PS：还有哪些字符是需要转义的呢？大家可以在评论区回复）&lt;/p&gt;
&lt;p&gt;　　Sum在这个规则上写上了注释，为了解释为什么这条规则就能匹配到标题。&lt;/p&gt;
&lt;p&gt;　　1.&amp;lt;title&amp;gt;在文本中查找由&amp;lt;title&amp;gt;开始的字符串，并从该位置进行往后匹配&lt;/p&gt;
&lt;p&gt;　　2. (.*)子匹配规则，.表示除了换行之外的任何字符，那我们分析下我们要抓取的html代码，&lt;strong&gt;&amp;lt;title&amp;gt;资深架构师Sum的故事：（Mysql）InnoDB下，存储过程中事务的处理 - 程序员VIP - 博客园&amp;lt;/title&amp;gt;&lt;/strong&gt;，我们要抓取的内容，恰好在一行，所以适合用.去做通配符,*号表示0到多个和.匹配的字符。那就是如果内容在一行的话，都能匹配到。&lt;/p&gt;
&lt;p&gt;　　3.&amp;lt;/title&amp;gt;在规则中，写了指定的字符作为结尾的话，那匹配的结尾符便是该字符串。&lt;/p&gt;
&lt;p&gt;　　4.我们都知道，正则有贪婪模式和非贪婪模式（也就是懒惰模式），上图中使用的preg_match便是懒惰模式，这恰好表达了只有第一个满足以&amp;lt;title&amp;gt;开始以&amp;lt;/title&amp;gt;结束的字符匹配到，就结束匹配。这正是我们想要的。毕竟网站的title只有一个。&lt;/p&gt;

&lt;p&gt;　　上面匹配的结果打印如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/979747/201809/979747-20180910020403145-252128060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　Sum写完了这些注释，再看看代码，却发现了一个问题，那如果得到的文本，title中的内容如果含有换行符怎么办？就比如下面的代码变种↓&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/979747/201809/979747-20180910020519485-707126759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　问题来了，这样的代码，正则表达式又应该如何写呢？&lt;/p&gt;
&lt;p&gt;　　这正是Sum抛给组员的问题，正在看《资深架构师Sum的故事》的你，是否也有你的答案呢？欢迎在评论区进行作答&lt;/p&gt;
&lt;p&gt;　　《本章节未完待续》&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 18:09:00 +0000</pubDate>
<dc:creator>程序员VIP</dc:creator>
<og:description>| 故事背景 职场如战场！Sum带领三个小队友用了两周，成功把代理功能给干出来了。如果说产品经理是最魔鬼的指挥官，那测试就是最魔鬼的教官。这两周，让Sum深深领略了什么是X市的日出。 不过话</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/programmerVIP/p/9616607.html</dc:identifier>
</item>
<item>
<title>babel 用法及其 .babelrc 的配置详解，想做前端架构，拒绝一知半解... - 小结巴巴吧</title>
<link>http://www.cnblogs.com/jiebba/p/9613248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiebba/p/9613248.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;Babel&lt;/h2&gt;

&lt;p&gt;官方介绍：将 ECMAScript 2015 及其版本以后的 javascript 代码转为旧版本浏览器或者是环境中向后兼容版本的  javascript 代码。&lt;/p&gt;
&lt;p&gt;简而言之，就是把不兼容的 JavaScript 代码转为可兼容，可以执行的 JavaScript 代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　功能：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　　　语法转换 &lt;/p&gt;
&lt;p&gt;　　　　添加一些兼容性的 polyfill 功能&lt;/p&gt;
&lt;p&gt;　　　　源码转换等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　简单配置预览：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
    &quot;plugins&quot;: [],  // 插件配置
    &quot;presets&quot;: []   // 预设配置
}

// 这里 .babelrc 配置的


// 官网建议用 module 的形式来配置，bable.config.js

const presets = []
const plugins = []
module.exports =  { presets, plugins }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;　　配置介绍：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　presets ：是某一类 plugin 的集合，包含了某一类插件的所有功能。&lt;/p&gt;
&lt;p&gt;　　　　plugin ： 将某一种需要转化的代码，转为浏览器可以执行代码。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　编译的执行顺序：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　1、执行 plugins 中所有的插件&lt;/p&gt;
&lt;p&gt;　　　　2、plugins 的插件，按照顺序依赖编译&lt;/p&gt;
&lt;p&gt;　　　　3、所有 plugins 的插件执行完成，在执行 presets 预设。&lt;/p&gt;
&lt;p&gt;　　　　4、presets 预设，按照倒序的顺序执行。(从最后一个执行)&lt;/p&gt;
&lt;p&gt;　　　　5、完成编译。&lt;/p&gt;

&lt;h3&gt;　　1、主要插件介绍&lt;/h3&gt;

&lt;p&gt;　　　　&lt;strong&gt;babel-preset-es2015 ( ES2015 / ES6 插件集合 )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;span&gt;将 ES2015(es6) 的 javascript 代码 转化 浏览器兼容 javascript 代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　arrow-functions　　：箭头函数&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　block-scoped-functions　　：函数命名的方式转话，改为赋值的形式&lt;/p&gt;
&lt;p&gt;　　　　block-scoping　　：let  转为 var&lt;/p&gt;
&lt;p&gt;　　　　classes　　： es6 的类转化&lt;/p&gt;
&lt;p&gt;　　　　computed-properties　　：属性命名的转化，如：var obj = { ['x'+a]: 1 }&lt;/p&gt;
&lt;p&gt;　　　　destructuring　　：析构函数转化&lt;/p&gt;
&lt;p&gt;　　　　duplicate-keys　　：属性优化&lt;/p&gt;
&lt;p&gt;　　　　for-of　　：for of 的转化&lt;/p&gt;
&lt;p&gt;　　　　function-name　　：优化函数命名&lt;/p&gt;
&lt;p&gt;　　　　instanceof　　：instanceof 转化&lt;/p&gt;
&lt;p&gt;　　　　literals　　：不同类型复制优化&lt;/p&gt;
&lt;p&gt;　　　　new-target　　：继承 extends 转化&lt;/p&gt;
&lt;p&gt;　　　　object-super　　：super 转化&lt;/p&gt;
&lt;p&gt;　　　　parameters　　：params ，(a=1,b=2)=&amp;gt;{} , 默认参数转化&lt;/p&gt;
&lt;p&gt;　　　　shorthand-properties　　：对象属性转化 {a,b} =&amp;gt; {a:a,b:b}&lt;/p&gt;
&lt;p&gt;　　　　spread　　：扩展属性转化 {...other}&lt;/p&gt;
&lt;p&gt;　　　　sticky-regex　　：regex 优化，用 new Regex构建&lt;/p&gt;
&lt;p&gt;　　　　template-literals　　：字符串模版 &lt;/p&gt;
&lt;p&gt;　　　　typeof-symbol　　：symbol 转化&lt;/p&gt;
&lt;p&gt;　　　　unicode-regex　　：将正则的匹配字符串转为 unicode&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　babel-preset-es2016 （ ES2016 / ES7 插件集合 ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;将 ES2016(es7) 的 javascript 代码 转为 浏览器兼容代码&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;　exponentiation-operator　　：幂运算转化  x **= 3 ，x的3次幂&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;　　babel-preset-es2017（ ES2017 / es8 插件集合 ）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;span&gt;　将 ES2017(es8) 的代码进行转化　&lt;/span&gt;　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　async-to-generator　　： 转化 async/await 转为 generator 函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;strong&gt;　babel-preset-stage-x （ ES2018/stage 插件集合 ）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;span&gt;　将 stage 阶段的代码转化&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　　　async-generator-function　　：将异步函数进行转化&lt;/p&gt;
&lt;p&gt;　　　　dotall-regex　　：点号正则优化&lt;/p&gt;
&lt;p&gt;　　　　object-rest-spread　　：解析构优化&lt;/p&gt;
&lt;p&gt;　　　　optional-catch-binding　　：catch 加 finally 优化&lt;/p&gt;
&lt;p&gt;　　　　unicode-proprty-regex　　&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　　　Modules&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;/strong&gt;　modules-amd / modules-commonjs / modules-systemjs / modules-umd&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;将不同的 export default x  转为不同的模块形式 amd / commonjs / systemjs / umd&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　　　&lt;strong&gt;Experiental （ 试验阶段 ）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;class-properties　　：class 的静态属性转化&lt;/p&gt;
&lt;p&gt;　　　　decorators　　　　：装饰器转化&lt;/p&gt;
&lt;p&gt;　　　　do-expressions　　&lt;/p&gt;
&lt;p&gt;　　　　export-default-from　　：export 优化&lt;/p&gt;
&lt;p&gt;　　　　export-namespace-from　　：export 优化&lt;/p&gt;
&lt;p&gt;　　　　function-bind　　：bind 函数转化，obj::fun =&amp;gt; fun.bind(obj)  ::obj.fun =&amp;gt; obj.fun(obj)&lt;/p&gt;
&lt;p&gt;　　　　function-sent　　&lt;/p&gt;
&lt;p&gt;　　　　logical-assignment-operators　　　&lt;/p&gt;
&lt;p&gt;　　　　nullish-coalescing-operaor&lt;/p&gt;
&lt;p&gt;　　　　numeric-separator&lt;/p&gt;
&lt;p&gt;　　　　optional-chaining&lt;/p&gt;
&lt;p&gt;　　　　pipeline-opertor&lt;/p&gt;
&lt;p&gt;　　　　throw-expressions　　　　&lt;/p&gt;

&lt;p&gt; 　　　  &lt;strong&gt;Minification（ babel-minify ）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　运用代码压缩优化插件预设&lt;/p&gt;

&lt;p&gt;　　　　...&lt;/p&gt;
&lt;p&gt;　　　　这里自行可以去官网上查看...&lt;/p&gt;


&lt;p&gt;　　　　&lt;strong&gt;babel-preset-react ( react 集合 )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　react 的相关编译转化...&lt;/p&gt;
&lt;p&gt;　　　　jsx 和 element 的一下转化&lt;/p&gt;
&lt;p&gt;　　　　直接添加 react 的预设就可以了。&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;　　Other 其他一些插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　　　jscript　　：严格模式命名&lt;/p&gt;
&lt;p&gt;　　　　object-assgin　　：assgin 转化&lt;/p&gt;
&lt;p&gt;　　　　regenerator　　：generator 函数的转化&lt;/p&gt;
&lt;p&gt;　　　　object-set-prototype-of-to-assign　　：setPrototype 转化&lt;/p&gt;
&lt;p&gt;　　　　runtime　&lt;/p&gt;


&lt;h3&gt;　　2、主要 presets 介绍&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;　　　　@babel/preset-dev&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　　　是一个智能预设。&lt;/p&gt;
&lt;p&gt;　　　　根据浏览器和运行环境，自动的确定 babel 插件和 polyfills 。&lt;/p&gt;
&lt;p&gt;　　　　没有任何配置的情况下，和 babel-preset-latest 一样 ( es2015/es2016/es2017一起使用 )。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
  &quot;presets&quot;: [ &quot;dev&quot; ]  
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　配置及其详解：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
　　&quot;presets&quot;: [
　　　　[
　　　　　　'@babel/preset-env',
　　　　　　{
　　　　　　　　'target':{
　　　　　　　　　　&quot;browser&quot;:[&quot;ie&amp;gt;=8&quot;,&quot;chrome&amp;gt;=62&quot;],
　　　　　　　　　　&quot;node&quot;:&quot;8.9.0&quot;,
　　　　　　　　　　&quot;safari&quot;:&quot;tp&quot;
　　　　　　　　},
　　　　　　　　&quot;modules&quot;:false,
　　　　　　　　&quot;debug&quot;:true,
　　　　　　　　&quot;uglify&quot;:true
　　　　　　　　&quot;useBuiltIns&quot;:true
　　　　　　}
　　　　]
　　]
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　target : 描述您为项目配置的 支持/定位 的环境&lt;/p&gt;
&lt;p&gt;　　　　browsers ：浏览器的支持情况，将返回支持浏览器列表。 会被 target.ie 覆盖&lt;/p&gt;
&lt;p&gt;　　　　　　[ 'ie&amp;gt;=8' ]    支持 ie8 的环境&lt;/p&gt;
&lt;p&gt;　　　　　　&quot;default&quot;     默认&lt;/p&gt;
&lt;p&gt;　　　　node ：指定是 node 环境，且可以指定版本&lt;/p&gt;
&lt;p&gt;　　　　safari : safari 版本&lt;/p&gt;
&lt;p&gt;　　modules : 启用将 es6 转为其他模块&lt;/p&gt;
&lt;p&gt;　　debug ： 是否启用 console.log　&lt;/p&gt;
&lt;p&gt;　　include / exclude : 必须启用的 plugin 功能 / 不启用的 plugin 功能&lt;/p&gt;
&lt;p&gt;　　uglify : 压缩代码&lt;/p&gt;
&lt;p&gt;　　useBuiltIns ： &lt;/p&gt;
&lt;p&gt;　　　　false ： 引用所有的 babel-polyfill ， 在 webpack 中添加 babel-polyfill 入口处：&lt;/p&gt;
&lt;p&gt;　　　　　　　   entry:[ 'babel-polyfill' , 'index.js' ] , 引用所有的 polyfill，体积变大&lt;/p&gt;
&lt;p&gt;　　　　true ： 引用部分，根据配置的 preset-env 环境，引用 polyfill ，&lt;/p&gt;
&lt;p&gt;　　　　　　　  在入口文件中要引用 babel-polyfill&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;@babel/preset-react&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这都是一些 react 相关的集合&lt;/p&gt;
&lt;p&gt;　　不需要介绍了，有需要自己去官网浏览下.&lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;Stage-x&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　草案中的预设..&lt;/p&gt;
&lt;p&gt;　　该插件集合不存在 preset-env 集合中，所以需要引用....&lt;/p&gt;


&lt;h3&gt;　　3、babel-polyfill 兼容方法&lt;/h3&gt;

&lt;p&gt;　　babel的 preset-dev 中只会转化新的 Javascript 语法，不会转化新的 api。&lt;/p&gt;
&lt;p&gt;　　例如：Generator / Set / Map 等 &lt;/p&gt;
&lt;p&gt;　　就是实现 babel 转化后的代码中，仍有不兼容的代码的转化。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　babel-folyfill 是修改全局的对象的原型，添加不兼容的 api 方法，或者修改不兼容的 api 方法。&lt;/p&gt;


&lt;p&gt;　&lt;strong&gt;　用法：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　1、在入口文件的顶部添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
require('@babel-polyfill');

import '@babel-polyfill'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2、webpack 中添加&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
　　entry:['@babel-polyfill','./app.js']
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 webpack 的配置文件中添加。&lt;/p&gt;

&lt;p&gt;　　3、直接在 html 中引用，在打包 js 的文件之前&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;script src = './babel-polyfill.js' &amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;　&lt;strong&gt;　4、transform-runtime 插件&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　对 babel 转化后的代码，进行再次转化，与 babel-polyfill 一样，解决不兼容的全局 api 。&lt;/p&gt;
&lt;p&gt;　　与 babel-polyfill 不同是它不是添加/修改全局对象。&lt;/p&gt;
&lt;p&gt;　　它是对不兼容的方法进行特殊处理，也就是添加辅助方法来做兼容。&lt;/p&gt;
&lt;p&gt;　　并且 transform-runtime 是在需要进行兼容转化时候引用。&lt;/p&gt;
&lt;p&gt;　　transform-runtime 是依赖 babel-runtime ，且辅助方法都是引用的 babel-runtime&lt;/p&gt;


&lt;p&gt;　　特点：&lt;/p&gt;
&lt;p&gt;　　不会污染全局变量，因为不会修改全局对象&lt;/p&gt;
&lt;p&gt;　　没有修改实例的方法，所以有些方法不能实现。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
 [&quot;transform-runtime&quot;, {&lt;br/&gt;　　　　&quot;corejs&quot;:false,
      &quot;helpers&quot;: false,
      &quot;polyfill&quot;: false,
      &quot;regenerator&quot;: true,
      &quot;moduleName&quot;: &quot;babel-runtime&quot;
 }]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　helpers ： 是否使用 @babel-runtime/helpers 来代替内部的 helpers&lt;/p&gt;
&lt;p&gt;　　coresjs ： 是否用 @babel-runtime/corejs 中的辅助方法来替换 Map / Set 等方法&lt;/p&gt;
&lt;p&gt;　　polyfill : 是否用 @babel-runtime 的辅助函数来代替 polyfill&lt;/p&gt;
&lt;p&gt;　　regenerator ： 是否用 辅助函数来代替 async / generator 函数&lt;/p&gt;
&lt;p&gt;　　moduleName ： 引用时候名字&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;　　5、@babel-register&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;通过 @babel-register 来注册当前所有的代码需要转码&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var fs = require('fs');
var babelConfig = JSON.parse(fs.readFileSync('./.babelrc'));
require('babel-register')(babelConfig);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　很显然，这里可以传入一个 .babelrc 配置文件来进行转码时候的配置。&lt;/p&gt;
&lt;p&gt;　　只需要添加到入口文件中。&lt;/p&gt;
&lt;p&gt;　　node 端就可以这这样实现 babel 的转码。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;　　6、tools&lt;/h3&gt;
&lt;p&gt;　　babel-parser  : babel 的解析器，用于解析 Javascript / jsx / Typescript / flow 等代码&lt;/p&gt;
&lt;p&gt;　　babel-core ： babel 的核心文件，用于转码的&lt;/p&gt;
&lt;p&gt;　　babel-generator ： 代码的转化，源码和转化代码&lt;/p&gt;
&lt;p&gt;　　babel-code-frame : 代码转化位置等转码映射&lt;/p&gt;
&lt;p&gt;　　babel-helpers ： 辅助器方法&lt;/p&gt;
&lt;p&gt;　　babel-runtime ： 提供了一些列的辅助方法，与 polyfill 类似&lt;/p&gt;
&lt;p&gt;　　...&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;@bable/babel-cli 命令行工具&lt;/h2&gt;

&lt;p&gt;　　用于命令行编译文件，可以进行配置以及输出等操作。&lt;/p&gt;

&lt;h3&gt;　　用法：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
babel  input.js -options
// 编译 input.js  文件
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　配置 ：&lt;/h3&gt;
&lt;p&gt;　　-o ： 输出路径&lt;/p&gt;
&lt;p&gt;　　-w ：监听编译文件，实时编译&lt;/p&gt;
&lt;p&gt;　　-s  ：输出source-map ，可以内敛&lt;/p&gt;
&lt;p&gt;　　-d  ：当编译一个目录时候，-d 输出目录&lt;/p&gt;
&lt;p&gt;　　--ignore ： 忽略的文件&lt;/p&gt;
&lt;p&gt;　　--plugins ： 使用插件，用 , 隔开&lt;/p&gt;
&lt;p&gt;　　--presets ： 使用预设，用 , 隔开&lt;/p&gt;
&lt;p&gt;　　--config-file ： 使用 .babelrc 文件路径&lt;/p&gt;



&lt;h2&gt;.babelrc 配置详解&lt;/h2&gt;

&lt;h3&gt;　　配置转化起 babel 三种不同作用：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、用于语法转义的配置。 preset-env / stage-x 主要用于 es 的语法转义，&lt;/p&gt;
&lt;p&gt;　　　　2、用于补丁的配置，即 polyfill 的配置。主要是 transform-runtime 。&lt;/p&gt;
&lt;p&gt;　　　　3、用于不同框架的配置，如：react的jsx /flow 等&lt;/p&gt;

&lt;h3&gt;　　例子：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
{
　　&quot;presets&quot;:[
　　　　&quot;react&quot;,
　　　　[&quot;env&quot;,{...}],
　　　　&quot;stage-0&quot;
　　],
　　&quot;plugins&quot;:[
　　　　&quot;pluginName&quot;,
　　　　[&quot;transform-runtime&quot;,{...}]
　　],
　　&quot;ignore&quot;:[&quot;path&quot;,'file'],
　　&quot;miniied&quot;:boolean,
　　&quot;comments&quot;:boolean,
　　&quot;env&quot;:{
　　　　&quot;test&quot;:{
　　　　　　&quot;presets&quot;:[],
　　　　　　&quot;plugins&quot;:[]
　　　　}
　　},
　　...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;　　主要几个配置&lt;/h3&gt;
&lt;p&gt;　　　　presets ： 预设，插件的集合，倒序执行&lt;/p&gt;
&lt;p&gt;　　　　plugins ： 插件，先执行插件，在执行预设，顺序执行&lt;/p&gt;
&lt;p&gt;　　　　ignore ： 忽略的文件&lt;/p&gt;
&lt;p&gt;　　　　minify ： 压缩代码&lt;/p&gt;
&lt;p&gt;　　　　common : 是否需要注释&lt;/p&gt;
&lt;p&gt;　　　　env ： 设置不同的环境，应用不同的配置，配置取值：BABEL_ENV，如若没有取 NODE_ENV 的值，默认为 development.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　　　其他可以自行在官网浏览...&lt;/strong&gt;&lt;/p&gt;



&lt;h3&gt;　　常见预设&lt;/h3&gt;
&lt;p&gt;　　env  ： 用于替换 es2015 /  es2016 / es2017 的预设。根据环境引入插件&lt;/p&gt;
&lt;p&gt;　　react ：react的插件集合&lt;/p&gt;
&lt;p&gt;　　react-optimize ： react 代码优化，如去除 propsType 减少生产上面代码&lt;/p&gt;
&lt;p&gt;　　stage-x ：草案代码插件集合&lt;/p&gt;
&lt;p&gt;　　flow ： flow 插件集合&lt;/p&gt;
&lt;p&gt;　　minify ： 代码优化的集合&lt;/p&gt;
&lt;p&gt;　　typescript ： typescript 插件集合&lt;/p&gt;


&lt;h3&gt;　　常用插件&lt;/h3&gt;
&lt;p&gt;　　transform-async-to-generator ： 异步函数 async/await 插件&lt;/p&gt;
&lt;p&gt;　　transform-decorators-leagacy : 装饰器插件&lt;/p&gt;
&lt;p&gt;　　syntax-dynamic-import ：import() 插件&lt;/p&gt;
&lt;p&gt;　　transform-runtime ： 辅助器插件，用于ployfill&lt;/p&gt;
&lt;p&gt;　　transform-object-rest-spread : 用于合并 var test = {a:1,b2};var t = {...test,n:1}&lt;/p&gt;
&lt;p&gt;　　transform-funciton-bind : 用于编译 obj::fun =&amp;gt; fun.bind(obj)&lt;/p&gt;


&lt;p&gt;　　transform-es2015-modules-commonjs ：es6 module 在 node 使用&lt;/p&gt;

&lt;p&gt;　　 &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: babel 用法及其 .babelrc 的配置详解，想做前端架构，拒绝一知半解...&quot; href=&quot;https://www.cnblogs.com/jiebba/p/9613248.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jiebba/p/9613248.html&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;   我的博客 ： &lt;a href=&quot;https://gilea.cn/index&quot; target=&quot;_blank&quot;&gt; XiaoLong's Blog&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;   &lt;a href=&quot;https://www.cnblogs.com/jiebba&quot; target=&quot;_blank&quot;&gt;博客园小结巴巴： https://www.cnblogs.com/jiebba&lt;/a&gt;&lt;/h3&gt;


</description>
<pubDate>Sun, 09 Sep 2018 18:06:00 +0000</pubDate>
<dc:creator>小结巴巴吧</dc:creator>
<og:description>Babel 官方介绍：将 ECMAScript 2015 及其版本以后的 javascript 代码转为旧版本浏览器或者是环境中向后兼容版本的 javascript 代码。 简而言之，就是把不兼容的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiebba/p/9613248.html</dc:identifier>
</item>
<item>
<title>PHP常用函数（一）:数组常用函数 - 邹杰君写字的地方</title>
<link>http://www.cnblogs.com/zoujiejun96/p/9616451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zoujiejun96/p/9616451.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、list()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;list() 和 array() 一样，不是一个函数，而是一个语言结构，作用是为一组变量赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;/span&gt;&lt;span&gt;PHP手册中的介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909203322209-1904342963.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;623&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用详情　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设现在想为$a $b $c三个变量赋值，采用info数组中的内容&lt;/span&gt;

&lt;span&gt;$info&lt;/span&gt; = ['this is a','this is b','this is c'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;(&lt;span&gt;$a&lt;/span&gt;,&lt;span&gt;$b&lt;/span&gt;,&lt;span&gt;$c&lt;/span&gt;) = &lt;span&gt;$info&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&amp;lt;&amp;lt;&amp;lt;&lt;span&gt;EOT
&lt;/span&gt;&lt;span&gt;$a&lt;/span&gt;
&amp;lt;br&amp;gt;
&lt;span&gt;$b&lt;/span&gt;
&amp;lt;br&amp;gt;
&lt;span&gt;$c&lt;/span&gt;
&amp;lt;br&amp;gt;&lt;span&gt;
EOT;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909203900026-296497307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、each()&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909204523587-863133475.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例代码 遍历$arr&lt;/span&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt; = ['a'=&amp;gt;'this is a','b'=&amp;gt;'this is b','c'=&amp;gt;'this is c'&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;$tmp&lt;/span&gt; = &lt;span&gt;each&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;))
    {
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$tmp&lt;/span&gt;['key'].':'.&lt;span&gt;$tmp&lt;/span&gt;['value'].'&amp;lt;br&amp;gt;'&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909205109514-717248945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、数组指针操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;&lt;span&gt;current()&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;key()&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;next()&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;prev()&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;end()&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;span&gt;reset()&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
1 current();  //读取指针位置的内容
2 key();      //读取当前指针指向内容的索引值
3 next();     //将数组中的内部指针指向下一单元
4 prev();     //将数组内部指针倒回一位
5 end();      //将数组内部指针指向最后一个元素
6 reset();    //将目前指针指向第一个索引位置
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;$info&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'a' =&amp;gt; 'this is a',
    'b' =&amp;gt; 'this is b',
    'c' =&amp;gt; 'this is c',
    'd' =&amp;gt; 'this is d'&lt;span&gt;
];

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).':'.&lt;span&gt;current&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).'&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).':'.&lt;span&gt;current&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).'&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).':'.&lt;span&gt;current&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).'&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;reset&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).':'.&lt;span&gt;current&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;).'&amp;lt;br&amp;gt;';
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909211021769-1998282503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、键值操作函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php&lt;/span&gt;

&lt;span&gt;$info&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'a' =&amp;gt; 'apple',
    'b' =&amp;gt; 'blog',
    'c' =&amp;gt; 'cat',
    'd' =&amp;gt; 'dog'&lt;span&gt;
];

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'keys:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出info数组的所有键&lt;/span&gt;
&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_keys&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'values:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出info数组的所有值&lt;/span&gt;
&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_values&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换info数组 键值互换&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'flips:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_flip&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;搜索apple&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'search:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'apple key is :'.&lt;span&gt;array_search&lt;/span&gt;('apple',&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;元素翻转&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'reverse:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_reverse&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查元素&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'in?&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'blog is in $info? '.&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;in_array&lt;/span&gt;('blog',&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查键&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'key in?&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'b is in $info? '.&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_key_exists&lt;/span&gt;('b',&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计值的出现次数&lt;/span&gt;
&lt;span&gt;$info&lt;/span&gt;[] = 'blog'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$info&lt;/span&gt;[] = 'blog'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; 'value count&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_count_values&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除重复的值&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'before unique&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;after unique&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;array_unique&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909221701745-2140104510.png&quot; alt=&quot;&quot; width=&quot;1109&quot; height=&quot;491&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 5、回调函数&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;　　示例数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$info&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'a' =&amp;gt; 'apple',
    'b' =&amp;gt; 'blog',
    'c' =&amp;gt; 'cat',
    'd' =&amp;gt; 'dog'&lt;span&gt;
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　array_filter();&lt;/p&gt;
&lt;p&gt;　　PHP手册参考：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909224826484-810239260.png&quot; alt=&quot;&quot; width=&quot;809&quot; height=&quot;702&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_filter();

//不使用flag&lt;/span&gt;
&lt;span&gt;$filter_arr&lt;/span&gt; = &lt;span&gt;array_filter&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$value&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$value&lt;/span&gt;) == 3&lt;span&gt;;
});
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$filter_arr&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用flag&lt;/span&gt;
&lt;span&gt;$filter_arr&lt;/span&gt; = &lt;span&gt;array_filter&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$key&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;in_array&lt;/span&gt;(&lt;span&gt;$key&lt;/span&gt;,['a','c'&lt;span&gt;]);
}&lt;/span&gt;,&lt;span&gt;ARRAY_FILTER_USE_KEY);
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$filter_arr&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;$filter_arr&lt;/span&gt; = &lt;span&gt;array_filter&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$value&lt;/span&gt;,&lt;span&gt;$key&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;in_array&lt;/span&gt;(&lt;span&gt;$key&lt;/span&gt;,['a','c']) &amp;amp;&amp;amp; &lt;span&gt;$value&lt;/span&gt; == 'apple'&lt;span&gt;;
}&lt;/span&gt;,&lt;span&gt;ARRAY_FILTER_USE_BOTH);
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$filter_arr&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909233731284-1411845408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　array_walk();&lt;/p&gt;
&lt;p&gt;　　PHP手册参考：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909233902918-1249397693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_walk();

//不使用 userdata&lt;/span&gt;
&lt;span&gt;array_walk&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$value&lt;/span&gt;,&lt;span&gt;$key&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&lt;span&gt;$key&lt;/span&gt;:&lt;span&gt;$value&lt;/span&gt;   &quot;&lt;span&gt;;
});
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;br&amp;gt;&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用 userdata&lt;/span&gt;
&lt;span&gt;array_walk&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;function&lt;/span&gt;(&amp;amp;&lt;span&gt;$value&lt;/span&gt;,&lt;span&gt;$key&lt;/span&gt;,&lt;span&gt;$userdata&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;$value&lt;/span&gt; = &lt;span&gt;$userdata&lt;/span&gt;.'-'.&lt;span&gt;$value&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;,'php'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;br&amp;gt;&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909235713202-1686276961.png&quot; alt=&quot;&quot; width=&quot;1053&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　array_map();&lt;/p&gt;
&lt;p&gt;　　PHP手册参考：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180909235809630-189700387.png&quot; alt=&quot;&quot; width=&quot;1009&quot; height=&quot;757&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_map();
//单个数组&lt;/span&gt;
&lt;span&gt;array_map&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$n&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&lt;span&gt;$n&lt;/span&gt;  &quot;&lt;span&gt;;
}&lt;/span&gt;,&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;&amp;lt;br&amp;gt;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个数组&lt;/span&gt;
&lt;span&gt;$info_2&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'e' =&amp;gt; 'egg',
    'f' =&amp;gt; 'filco',
    'g' =&amp;gt; 'good'&lt;span&gt;
];
&lt;/span&gt;&lt;span&gt;array_map&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;$n1&lt;/span&gt;,&lt;span&gt;$n2&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;1:&lt;span&gt;$n1&lt;/span&gt;-2:&lt;span&gt;$n2&lt;/span&gt;  &quot;&lt;span&gt;;
}&lt;/span&gt;,&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;$info_2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180910000339152-548046802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; 6、数组分割&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　array_slice()&lt;/p&gt;
&lt;p&gt;　　PHP手册参考&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180910001015947-1105886515.png&quot; alt=&quot;&quot; width=&quot;926&quot; height=&quot;761&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　array_splice()&lt;/p&gt;
&lt;p&gt;　　PHP手册参考:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180910001348125-1812848737.png&quot; alt=&quot;&quot; width=&quot;878&quot; height=&quot;982&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　array_chunk()&lt;/p&gt;
&lt;p&gt; 　　PHP手册：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180910002112830-1943831421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;$info&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'a' =&amp;gt; 'apple',
    'b' =&amp;gt; 'blog',
    'c' =&amp;gt; 'cat',
    'd' =&amp;gt; 'dog'&lt;span&gt;
];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_slice()&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_slice:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;array_slice&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,0,3&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;&amp;lt;hr&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_splice();&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_splice:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '原数组：&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换掉前两位&lt;/span&gt;
&lt;span&gt;$tmp&lt;/span&gt; = &lt;span&gt;array_splice&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,0,2,['king','queen'&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '替换后的数组：&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '替换掉数组：&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;$tmp&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;&amp;lt;hr&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;恢复原数组&lt;/span&gt;
&lt;span&gt;$info&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'a' =&amp;gt; 'apple',
    'b' =&amp;gt; 'blog',
    'c' =&amp;gt; 'cat',
    'd' =&amp;gt; 'dog'&lt;span&gt;
];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_chunk();&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_splice:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '替换后的数组：&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$tmp&lt;/span&gt; = &lt;span&gt;array_chunk&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$tmp&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180910002417060-1895893122.png&quot; alt=&quot;&quot; width=&quot;956&quot; height=&quot;379&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;7、数组运算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　测试代码：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;$info&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'a' =&amp;gt; 'apple',
    'b' =&amp;gt; 'blog',
    'c' =&amp;gt; 'cat',
    'd' =&amp;gt; 'dog'&lt;span&gt;
];

&lt;/span&gt;&lt;span&gt;$info_2&lt;/span&gt; =&lt;span&gt; [
    &lt;/span&gt;'e' =&amp;gt; 'apple',
    'f' =&amp;gt; 'egg',
    'g' =&amp;gt; 'java',
    'h' =&amp;gt; 'cat'&lt;span&gt;
];

&lt;/span&gt;&lt;span&gt;$info_num&lt;/span&gt; = [120,10,1&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_sum&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_sum:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;array_sum&lt;/span&gt;(&lt;span&gt;$info_num&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;array_sum&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只对元素中的数值进行求和&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;&amp;lt;hr&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_merge&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_merge:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;array_merge&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;$info_2&lt;/span&gt;,&lt;span&gt;$info_num&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;&amp;lt;hr&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_diff - 返回在info中但不在其他arr中的值&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_diff:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;array_diff&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;$info_2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;&amp;lt;hr&amp;gt;'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array_intersect - 返回在info中也在在其他arr中的值&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; 'array_intersect:&amp;lt;br&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;print_r&lt;/span&gt;(&lt;span&gt;array_intersect&lt;/span&gt;(&lt;span&gt;$info&lt;/span&gt;,&lt;span&gt;$info_2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; '&amp;lt;br&amp;gt;&amp;lt;hr&amp;gt;';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372111/201809/1372111-20180910004052633-1771245596.png&quot; alt=&quot;&quot; width=&quot;1025&quot; height=&quot;356&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;8、数组的栈和队列操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;9、数组的排序操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;10、其他常用函数　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 17:14:00 +0000</pubDate>
<dc:creator>邹杰君写字的地方</dc:creator>
<og:description>1、list() list() 和 array() 一样，不是一个函数，而是一个语言结构，作用是为一组变量赋值。 PHP手册中的介绍 使用详情 运行结果 2、each() 运行结果： 3、数组指针操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zoujiejun96/p/9616451.html</dc:identifier>
</item>
<item>
<title>在国企的日子(第三章中部 出差) - 心灵之火</title>
<link>http://www.cnblogs.com/dgcjiayou/p/9616165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgcjiayou/p/9616165.html</guid>
<description>&lt;p&gt;&lt;span&gt;来到805房间，把房卡插进去，滴的一声，用手轻轻的把扶手往下使点力，门就开了，房间里透着浅浅的黄色光线，空气中弥漫着淡淡的香味，给人很温馨的感觉。我转过身来把门关上，把房卡插到墙上的白色取电的槽里面，房间灯全亮了。突然看到地上掉了二张有颜色的卡片，有那么1，2秒钟的惊讶，捡起来一看，其中一张卡片整体布局是左右框架布局，右边占了大半的空间，上面就一个女的，长发披肩，薄而透明的衣服，包臀穿了条肉丝，坐在地板上，两条腿往上翘起，左边留了电话号码，并且几个红色的字体大大的写在上面，男人另外的港湾。拿起另外一张卡片一看，这张属于上下框架布局，上面是文字，内容简单粗暴，写着什么妹什么姐还有妇之类的字眼，下面是一些小图像，有3个，有年纪小点的，稍微大点的，更加成熟点的都有。我微微一笑，将卡片直接扔到刚才捡起来的位置，原封不动。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;卫生间在进门的左边最外面，我推开玻璃门，里面看了一眼，右边是洗漱用的面盆，上面有2个用薄纸包起来的玻璃杯，边上有两套那种一次性的洗漱用具牙膏牙刷之类，面盆前面的镜面擦的很光亮，一眼就可以看到我有三天没刮的胡须。右面里面是白色的马桶，说实话，我有点失落，我不习惯坐在上面出恭，因为我感觉使不上力，就算使上来的力都停留在了小脚没法往上移，所以如果不是很急的时候我都是搬一条凳子放在边，蹲在上面慢慢来。马桶上面放了三条用薄纸包起来的白色毛巾，纸上面写着已消毒，请放心使用。我才不使用呢，我随身带着毛巾呢？带了一条粉红色的，洗脸洗澡都是它。左边的浴室我比较喜欢，简单概括就是七天酒店的那种，拥有绝对领域权，浴室里面的地上没有任何水，墙上写着24小时热水。整体来说浴室还是比较和我心意，毕竟在这里要住一周，要住的舒服嘛。从卫生间出来，走到桌子边我把电脑包放下，把手提运动包往床上一扔，一屁股坐在椅子上，先休息休息。我是很喜欢安静的人，安静能让我用心去思考外界的事物，也能恢复一天的舟车劳顿。大概10分钟后，稍微觉得有点无聊，我打开电视，拿起桌上的遥控，躺在床上，搜索着自己感兴趣的电视，绝大部分是需要付费的，只能看一些回顾频道，随便打开一个，让房间稍微有点声音，半躺半睡大概又过了40多分钟，看了下手机，快到5点了，站起来稍微整理了下，开门，拔卡，偷偷的瞄了下那两张卡片，静静的躺在那里，微微一笑，出门。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在下楼电梯口碰到了汪伟，他换了件灰色夹克，也没有戴他的那个嘻哈帽了，头发梳的齐刷刷地朝前冲去。我们打了招呼，一会儿常林过来，三人坐电梯下去。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下楼走到大堂，问了前台附近有什么地方吃饭了没，前台指着马路对面一条路，说那里有很多饭店，我们一路走过去，果然这应该是个美食街，虽然显得有点拥挤狭窄的，但是小巷子里汇聚了各式各样的美味小吃，品种都别具特色，路边有卖烧烤的，有推出车卖臭豆腐，各种精美小吃的应有具有。我们找了家装饰古朴清雅，门面看起来精雕细刻的湘菜馆，里面看起来很干净，现在这个时间点吃饭的人貌似不多，我们找了个靠里面窗户的四人位置，坐了下来，服务员过来我们点2个干锅，2个时令小菜，1碟花生米，6瓶啤酒，然后坐在位置上等，大家都闲来无事，各自在玩手机，我打开微信，看到发现那里有红点，有好友发布的最新消息，我点击一看，最上面一条就是贾珍珍发的朋友圈，写了一行文字，春花秋月何时了，往事知多少。然后下面配了几2图，有一张应该公园的景物，无人物。还有一张应该是她大学时代的寝室照片，她和2个女同学一起拍的照片，她站在中间，穿了件红色羽绒服，笑的很甜美。我心里在想，这个有故事啊，很明显是叙事性很强的故事，而且略带悲情，我前面讲过，我是一个感同身受能力很强的人，对方的一段文字我就大概能感觉到这个人的内心，更何况还配了图片场景，我更加觉得八九不离十了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实我对心理学业余也有一些研究，要想了解一个人的的精神世界，比如兴趣、爱好、理想、知识面等其实都可以从他们的作品里面反映出来，尤其是现在的人很喜欢发朋友圈，通过一些文字来描述现在的喜怒哀乐，这个里面有赤裸裸的表明的，也有通过相反的方式来表达的，其实都有，看个人性格的表现方式而已，如果一个人经常发朋友圈，就算我不认识这个人，但是我大概也能猜的到这个人平时的性格而已。贾珍珍发的这段话，来自南唐李煜后期的作品，当时李煜已经亡国了，被囚禁，他经常回想起以前的美好时光，但是这个话当时处于的意境是属于悲情的，贾珍珍配了2张图，其中有一张是她和寝室同学的照片，这个里面有同学之情，表现是欢乐，但是另外一张图片有景无人，表现的是回忆，但是回忆的人物不愿意出现在景物里面，说明她曾经到现在和这些人物开始有隔阂，当然，也可能这是一张纯景物图而已，但是贾珍珍不傻，她肯定想用欢乐去掩盖悲情，不管怎么样，我的直觉告诉我有故事，为了更加准确的论证我的分析，我需要更多的材料来辅助，于是我不断的翻她前面的朋友圈记录，但是被设置了只能看到三天的记录，有点可惜，没办法，我继续沉浸在我的思路里面。这个时候，传来一阵略带长声的滴滴声音，一听就知道是陌陌的信息是声音，我抬头一看，是汪伟在玩陌陌，他在看附近的人的功能好像还在发信息，嘴角边略带着一丝笑容，那种笑容我都不想用文字去形容了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;怎么现在还有人玩陌陌啊&quot;，常林问道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;陌陌LBS距离定位功能最全，精度最高，是一个拉近人和陌生人之间的距离的最好神器&quot;，汪伟翻着白眼看着我们。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对于网管这个职业大家应该都很清楚了，除了装机搞局域网，最擅长的就是装软件玩软件了，我没想到汪伟还是能说的出一个专业话题的人的。我半打趣的问道，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;现在除了qq，微信，陌陌，还有什么好的类似交友的聊天工具的&quot;，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;米聊啊，也挺好用的&quot;，汪伟边说边打开手机的米聊app给我们看，我喵了一眼，也是个类似差不多的聊天的工具。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;这不都差不多嘛&quot;，常林问道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;它里面有很多群的功能，群里面经常可以看到别人发的短视频，内容很丰富，你们自己下载下来看看不就知道&quot;，汪伟一本正经说道，好像我们现在就要当着他的面非装个不可。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;手机配置一般，装这么多东西，卡&quot;，我说道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;服务员拿着拿着干锅架过来，用打火机点上，把菜放上去，然后菜接着一个个端过来，瞬间上齐，大家都饿了，直接开吃。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;服务员，麻烦拿个开瓶器过来&quot;，我嘴巴刚落音，就听到啪的一声，汪伟直接拿起啤酒瓶在桌子一角用手猛的一拍，就开了，瞬间很多泡沫往外面溢出，汪伟直接拿嘴巴接上，咕噜咕噜半瓶啤酒已经下肚。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;爽&quot;，汪伟露出很满足的表情。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我拿开瓶器打开2瓶啤酒，一瓶递给常林，自己往杯子满上，然后大家随便吃喝起来，我们不是那种在酒桌上非要你进我酒我进你酒来来回回走几圈的人，大家很自觉，自己倒自己喝，一会儿，我们这边已经每人喝了一瓶，汪伟已经第3瓶了，他看到就好像不太够，又叫服务员拿了5瓶过来，买10送1嘛。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;今天的菜很合我胃口，一碗米饭已经下肚，我喝酒前，一般先吃饭，饭吃饱了我再和你慢慢喝，常林酒量应该不大，一瓶啤酒下去脸上已经微微泛红，他自己也推脱说不能再喝了，我们也就不再勉强，我和汪伟把酒分了，他4瓶我3瓶，两个人正式进入状态喝起来，酒喝多了，话自然也多了，感觉距离也近了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我一直认为，搞IT这个行业，同事与同事之间要想成为很好的知己朋友，其实都是不太那么容易的，平时工作中可能除了工作上的事情交流外，其余的时间大家都在忙自己的，更加别说聊一些工作之外的话题了，尤其是个人，家庭私生活甚至个人喜怒的情感事情了。把自己私人方面的信息和他人诉说，这个在心理学里面叫自我暴露，自我暴露是一种人际沟通中的一种行为技巧，掌握的好很容易拉近自己和他人的距离从而形成一种共鸣，双方的信任和接纳程度也会慢慢提高。我记得之前有个同事我们在一起工作1年多了，我问他为什么我们认识这么久了大家的关系还停留在普通同事关系，只聊聊工作，而新来不久的同事你们聊的东西却那么多，他这样和我说，因为你不抽烟，我和新来的同事经常去楼道外抽烟，抽烟在一起的时间长了，大家聊的东西就多了。事情其实就这么回事，今天和汪伟喝酒，很明显其实他是一个很健谈的人，吊儿郎当冷酷的外表下掩盖了他也有铁血柔情的一面，男人嘛，聊女人，除了聊漂亮的，聊性感的，聊和自己相关或者无关的都能聊，但是汪伟今天给我们聊的这个女人，让我重新刷新了对他的认知，我觉得这个朋友我想交。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;汪伟是家里面的独子，他家是农村的，从小被寄予厚望，属于要光宗耀祖的那种，那年刚大学毕业就让家里面催着结婚，结果亲戚朋友介绍下，和一个比自己小2岁的女的谈了半年后就结婚了，那女的很漂亮，皮肤很白，平时也挺会打扮，两个人走在一起，汪伟觉得很自豪，都说结婚后的男人特别拼，他每天都努力的工作，只为月底和年底的时候发奖金能发拿点，这样的日子大概过了1年不到，有天这个女的和他说，和你过这样的日子，受够了，我只希望自己的日子能够过得好一点，而你却不能满足我，然后，那个女的和另外的人跑了，那晚，他喝了很多酒，直至不省人事。第二天醒来，他向自己发誓，从此不再相信爱情、相信女人，就这样一个人迷迷糊糊过了4年日子，直到弥留之际的母亲哭着求他再婚，他便找了现在的妻子，一个小他1岁，又黑又矮的女人。他当时只是看了她一眼，便订下这门亲事。他其实并不爱她，娶她进门，只是为了了却母亲的遗愿，新婚那天，他跑到母亲的墓碑前，一个下午都在那里。有人给他送饭过来，他转头，看见一张难看的脸，便喝令她离开。他只想带喜爱的女人来给母亲看，而她不是。婚后，他的脾气变得又怪又差，总是挑她的刺，嫌她做的菜难吃、做事太慢，而他说这些时，往往坐在沙发上喝着茶，悠闲地看着电视。她总是笑嘻嘻地说改，她对他越好，他的脾气就越大，开始他只是骂她，大声吼她，后面他都懒的理她，家里面就当这个人不存在，累了，他就跑到外面去找女人。而她总是逆来顺受。有天晚上回家，下了雨路有点滑，他的鞋子沾了雨水，上楼梯的时候出了意外，从楼梯上摔了下去，摔断了腿。接下来，他在医院治疗了大半个月。而她，也在医院照顾了他大半个月，毫无怨言。直到这时，他才真正明白，这个世界上还有母亲以外的女人如此疼他。临床的病友对他说：“真羡慕你，有真么疼你的老婆！”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;汪伟说到这里，看着我道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“男人在外面不管怎么玩，但是这个心里面一定只有一个位置是给一个人的，那个就是老婆”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;说实话，我不喜欢汪伟的这个故事，我当时能肯定，这个故事是真的，但是这个故事让我心里泛起一阵阵伤感，我不知道是羡慕还是难受，我觉得他不应该把这个故事讲给我这种连什么叫爱情都没实战经验的人，我一方面渴望爱情，另外一方面却把其它的东西，如成就，地位，名利好的权利看得重于爱情。我一方面用感性在享受感情带来的快乐和幸福，另外一方面却用理性在保护自己，隔绝快乐和幸福，我就是这么茅盾。现在的人一旦进入到社会，真正想寻找属于自己的爱情成本变得越来越高，我发现在这个城市我都快找不到我这个门槛的爱情了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这顿饭吃了2个多小时，出来的时候已经快8点了，喧闹了一天的城市开始了夜间的繁华，霓虹灯下，人行道旁随处可见匆匆赶路的身影，周围酒店商场都是休闲消遣的人群，这是一座快节奏的城市，我偶尔在问自己，我的路在哪里，我属于哪里呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;三人在附近超市买了点水，直接回酒店，然后各自回了自己的房间，汪伟的故事是一针消毒剂，让我躁动的欲望的心变得有点阳痿，我洗完澡后，打开电视躺在床上，摸起手机我想起下午贾珍珍的朋友圈的信息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;贾珍珍是一个让我有欲望的女人，这种欲望更多的是情感，可能孤独的时间太长，突然出现这么一个能对我笑，对我关注的人，我长期压抑的情感被慢慢引出，我需要把这股情感投入出去。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;以我们现在顶多是个同事关系，如果我冒冒失失打个电话过去，我又不知道能聊些什么，我只能通过微信给她发消息，我打开微信点开她的头像，发了一段文字过去。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“我们已经到了xx省移动，在附近宾馆住下了，刚吃了饭各自回酒店房间了”，发完消息，迅速把聊天窗口切换出来，我不想让她看到我正在等她回复消息的状态，突然心里觉得有种冒失的感觉，我们住下不住下没必要和她汇报啊，转而又是一种强烈的迫切想见到她的感觉，心情很复杂，一半的希望她回消息，一半的又不希望她回消息。手机进入智能关屏，我手指一滑动又打开了微信，就这样，来来回回3，4次。一会，她终于回消息了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“太好了，一天辛苦了吧，在那边还适应吧”。文字后面还带了个可爱的笑脸。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“嗯，这边天气挺好的，今晚在外面吃饭挺合胃口的，城市也挺漂亮的，一切都不错”，我笑着回复文字。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“那就好，早点休息，明天你们还要去见移动那边的人”， 文字后面还带了个挥手拜拜的表情。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;别啊，这刚开始呢立马就要聊死的节奏，我得换话题继续下去，我想起她的朋友圈。于是我问道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“你今天发的朋友圈我看到了，请问是不是有什么心事不开心呢”，我发了信息过去。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10分钟无信息回复，我心里想，估计今天到此结束。我下床去拿起桌子上矿泉水喝了口水又回到床上躺下，拿起手机看了下时间，已经9点多点了，于是我从包里面拿出我的粉红毛巾去浴室先洗个澡再说，推门进浴室无意中又看到那2张小卡片依然静静躺在那里。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里的热水来的很快，我调好水温，在浴室墙边的蓝色盒子里面挤了点洗发水涂到头发上，又从白色盒子挤了一大把沐浴露，全身涂上，然后让任莹莹的水珠从头发淋到脚跟，真舒服。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;洗澡具体过程不详情描述，虽然在洗的过程中脑海里面有卡片，也有贾珍珍，但是也是按常规洗完，中间没有做其它多余的事情。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;回到床上，拿起手机一看，贾珍珍给我回信息了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“刚才忙去了，不好意思”，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“为什么说我有心事不开心呢”，贾珍珍问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实我也没有把握，为了让聊天更久点，我拿出心理分析的那套理论一点点分析给她听。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“哇，你居然…….”，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“居然什么?”，我心里想，难道真猜对了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“你居然懂这些，为什么懂这些？” 贾珍珍问道，要是在眼前，我猜贾珍珍的表情一定很惊讶。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“以前对这些略有研究”，然后我把压箱子的心理学方面的知识点全巴拉巴拉讲给她听，什么精神分析，行为主义，人本主义，催眠，解梦等等全部一起撸出。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;贾珍珍显然对这些感兴趣，不断的在我一些这方面的知识点，我一个个非常详细的解释给她听。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“你会解梦，周公解梦?”，贾珍珍问道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“不是，不是周公解梦那种，梦见什么就是象征什么，这个解梦是最初精神分析流派提出的一直挖掘人的潜意识的方法”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然后我和她耐心解释，人有意识，前意识，潜意识三层，前意识就是你任何时刻觉察到的感觉和体验，比如你现在正在和我聊天，前意识是你自己适当的努力或注意就可以提取的事件，比如你想起昨天有个事情没做，今天要去做的。潜意识是人在正常情况下不能简单注意就能意觉察到的，比如一个人被狗咬了，咬怕了，后面某天做梦都吓醒，这个人在白天正常时间不能觉察这个怕，只能到晚上通过梦表现出来，其实这个就是压抑。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“嗯，嗯，你接着说，我在听”，贾珍珍表现的很感兴趣，说实话和一般的人聊这些，如果对方不怎么感兴趣，我都懒的聊太多，免得人家说我是神经病，既然对方感兴趣，而且又是贾珍珍，我就表现的更加卖力。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“其实人的这三层意识对应着人的人格组成，也就是本我，自我，超我三部分，本我位于潜意识，这里面都是些人的原始欲望，人不愿意去提起的伤心往事什么的也在里面，自我位于前意识，和人保持的最亲密最近，就像刚才说的稍微去注意下就能去做的事情，超我属于社会层面，道德良心法律等等”，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我哗哗在手机上打着字，我生怕让贾珍珍慢等一秒钟，我甚至恨现在要是有台电脑就好了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“给你觉个例子啊”，我故意打完字停了下，我想看看贾珍珍还在不在听。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“快说”， 贾珍珍立马回复。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我心里一阵窃喜。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“举个例子，比如一个男人喜欢一个女人，想亲她抱她，这个属于本我，这个男人又没把握这个女人能不能接受他，这个属于自我，这个男人不敢直接去强行推到，去亲去抱，毕竟有道德和法律约束，这个是超我，这个男的久儿久之，压抑的很厉害，晚上做梦梦见和这个女的在一起，你看这个不就是通过梦表现出来了吗？”，我说道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“那为什么晚上超我没用呢”， 贾珍珍的傻乎乎的问道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“超我晚上也要睡觉啊，保安站立一天的岗，也困了啊，这个小子瞧保安不注意就溜出去干坏事了啊”，我笑着说道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“啊，这样啊”， 贾珍珍发来一段加了个翻白脸的表情。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“嗯，是这样的，你以后晚上做了什么梦，我可以给你分析分析”，我打趣问道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“我才不要呢”，贾珍珍发了个吐舌头的表情。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我觉得差不多了，我再次问她。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“你是不是有什么心事，可以说来让我这个朋友听听吗？”，我本来打了同事二个字，我又擦掉，换成朋友二个字，我想通过每次聊天把距离稍微拉近点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“你刚才把我朋友圈发的文字结合我的二张照片已经解剖的淋漓尽致了，还要故意来问吗”， 贾珍珍说道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;果然这样，我的信心突然大增。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“是不是感情方面的呢”，我进一步试探。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“雷刚，你交过女朋友没？”，贾珍珍突然直乎其名，又问了个这么让我内伤的问题，我突然不知道怎么回答，我说的头头是道，我扮演的一个情感专家在这里，但是自己长这么大了的确没交过女朋友啊，这个事情说出去其实是有点丢人的，大学四年都是和同学通宵混网吧，白天哪里有体力去谈恋爱，工作3年又过的是屌丝生活，更加没这个机会啊。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“没有”，在一个比自己年纪小又有那么点感觉的女孩面前说出这2个字，其实是需要勇气的，这2个字说完，我立马感觉她现在是情感专家，我反而是咨询者了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“嘻嘻，你都没谈过，确定长这么大了都没有？”，果然，主动权现在不在我这里了，贾珍珍依然不依不饶。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“确实没有”，我硬着头皮上。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“这么大没有追过喜欢的女生？”，我突然觉得这是一种病，一个男的27岁从来没有追求个别人，我心里突然想起一个事情，我高中的时候给一个女的写过情书，当初写完交给另外一个女的让她给我拿给她，后面不知道有没有真给她，这是一宗悬案，事情就那么结束了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“高中写过一封情书”，我依然应道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“你啊，怎么说到我身上去了，我看到你发的朋友圈是你不开心，想看看能不能帮你”，我不等她回消息立马一个回马枪。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;果然有效。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“雷刚，你很厉害，自己没经历过的事情，却能把这些事剖析的这么清晰”， 贾珍珍赞道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“秀才不出门，能知天下事”， 没吃过猪肉还没见过猪跑吗”，我打趣道。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“那么可以聊聊你的不开心的事情，让我能帮到什么吗”，我知道她已经退无可退，必须正面回答这个问题了，我心里窃窃惊喜，我知道一旦聊这些话题，我和她的距离就会更近了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“啊，已经快11点了，我要早点休息了，明天上班了”，贾珍珍发来一段文字，我立马心就拔凉拔凉了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“下次回来我再和你说”， 贾珍珍发来一个笑脸。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“嗯，嗯，好的，早点休息”，我回复。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;双方互相拜拜后，发现手机快没电了，调好明天的闹钟，我把手机声音设置为静音，插上充电器，回味刚才的聊天中，估计今晚会失眠。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一会，床头的电话响起来，我拿起接听，电话那头传来一个柔声柔气的女声音。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“先生，请问需要服务吗”。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;擦，我擦，今晚绝对失眠，吓得我立马挂掉电话。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一夜在半睡半醒中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;…………&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第二天早上9点我们三人达到移动大厦，被里面的大厅MM给拦住了，一个身材高高穿着白短袖包臀工装的MM问我们找谁，我们就说找局方这边陈某某陈工，陈工是我们这次的接头人，之前在邮件里面有沟通过。然后大厅MM去她的电脑查了下打电话并确认了，就叫我们先等下。一会陈工从电梯里面下来了，我们都握手互相介绍了下，然后每个人去前台填了登记表，并把身份证放在那里，后面我们每次进来都要填登记表，然后把身份证放那里，等出来的时候再去填表拿身份证。填完登记表后，陈工带我们三人坐电梯去了4楼，走出电梯一看，是个大大的办公大厅，里面至少坐了将近有500多个人，里面按照区域一块块分的很整齐，每块区域位置上都贴了标签，乍眼一看，有很多熟悉的大公司都在里面，我看到了有中软，软通，文思，中兴，亚信等等都在里面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;嚯，这么说吧，搞IT程序员，基本上能说的上名字的公司在这些区域里面都有一块，场面有点大，里面台式机嗡嗡的声音感觉这里是个巨大的电流磁场，这种地方长期办公我估计人的身体肯定会受到辐射影响吧，果然我看到好的女的身上都穿了五颜六色的防辐射服，养家糊口大家都不容易啊。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;陈工带我们到了最里面一个区域，这个区域没有贴标签，大概有7，8个工位，上面都是清一色的戴尔台式电脑，位置全空，陈工给我们安排坐在前面，很热情的给我们倒了杯水，然后叫我们稍等下，就走进隔壁的办公室。我们三人边喝水边打量的周围，隔壁的区域是软通的，里面大概有10个人左右，大部分都在忙碌的敲着键盘，有1，2人在来来回回的走动，好像在沟通什么功能，其中有个脸上刻满了饱经风霜的皱纹，眼圈深深地凹陷下去，充满了血丝的眼睛的小伙子在说道昨天晚上上线通宵到现在都没合过眼，想早点搞完回去休息什么的，在不断的催促着坐在位置上的那位同事快点搞，仔细一瞧那位被催的人，其实也好不到那里去，眼球同样充满了血丝，与青黑的眼袋成了装饰，一张蜡黄营养不良的脸上写满了无声的控诉，好像在说，你催个毛，我和你一样在熬夜，这破工作我真TM不想干了。我大概知道了，这一班子人估计昨天晚上全部在通宵熬夜。我工作这些年来熬夜的机会几乎是没有，好像三年来曾经有过一次，也是项目上线上线到白天7点多，当时人已经很累了，基本是没有任何战斗力了，脑袋里面只想着回去睡觉，再加上通宵熬夜各种情绪，当时也差点发飙想打人，所以我是很能理解这班人现在的痛楚。我看着常林，说我们这次上线会不会也这样搞，搞通宵搞的白天还在搞。说实话，虽然我现在正值热血青年，论熬夜的话，我比那些技术比我好，经验比我多，年纪比我大的的开发人员绝对拥有话语权的，但是我最近一段时间总是隐隐感觉我的腰子不太好，时间坐的久了有时候有点酸痛，我有点担心这种工作强度，再说通宵熬夜白天至少要补一天的觉甚至到了第二天头还是晕乎乎的，太伤身体了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常林表示一脸无助，他说他也不清楚，然后他接着说道，按常理来说问题不是很大，毕竟这次上线的功能不多无非就是绑定充值解绑退款四个流程，这四个流程其实遇支付这边早就代码测试通过的，我这边到前置机这边也是测试OK的，最后就是遇支付通过我这边到前置机整个流程在出差前就反复测试过的，现在最大的不可控的因素无非就和移动这边的联调，还有和BOSS系统的联调这两块。我们在闲聊着，过了一会陈工和一位男的走的出来，陈工给我们介绍这位是亚信那边的负责这次BOSS系统联调工作的宋工，我们握手互相介绍，然后寒暄了一阵，最后我们把这次的联调工作计划如下。1.今天是周四，陈工会安排人和汪伟这边去机房安装前置机和相关配置，我这边今天就将我这边线上平台配置切换到这个前置机，并配置相关网络防火墙白名单(只有常林这边可通讯)，并和常林做好测试相关工作。2.周五常林这边和亚信以及移动这边开始在测试环境做联调，我这边协助。3.周六晚上凌晨12点正式上线，所有人都在现场。也就是说一切顺利的话，我们周日即可回去，不需要一周时间，我心里暗暗窃喜，太好了，可以早点回去不需要呆在这个磁场里面了，还可以早点见到某人了。计划安排完毕后，大家各自忙去了，汪伟说道，周6晚上上线加班，这种加班和平时的加班不一样，我问他什么情况，他这样算给我们听，平常晚上12点前加班是1.5倍工资，周6是2倍工资，但是周6是凌晨上线加班，也就是按3.5倍工资来算，我当时听的不太懂，常林说是这样的，我问我试用期阶段是不是也是这样算，他们说道当然算的，然后汪伟开始写加班申请邮件，把我们三人名字一起写上去，前面我有说过，国企是不要求加班的，如果非要加班一定要提前申请，汪伟是人精，自从昨天和他喝酒后我觉得这个人其实还是蛮好的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一会后，移动这边有人来找汪伟了，王伟跟着他去移动机房装机去了，我和常林在工位上，我们打开桌上电脑，先把要准备的工作提前做好，免得到时候手忙脚乱，输入刚才陈工给的系统密码后进去，电脑好不好用其实不重要，配置只要不让电脑无辜死机就行，因为我和常林都不需要在本机安装环境开发，我们的代码打包都已经上传到线上linux服务器，服务器在外网，我们只需要有个远程连接到外网自己的一台windows服务器，通过这台windows服务器操作线上linux服务器即可，就算要修改代码BUG也是在这台windows服务器上改，改完后发包。但是我们发现这两台电脑都不能上外网，于是找来陈工，陈工填申请单签字帮忙找人开通外网，一切都顺利成章。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;汪伟大概中午11点就回来了，我问他是不是搞定了，他的头点的像个啄米的鸡一样快，说道除了他在装机和装软件过程中，有个人像防则贼似的睁着两双铜陵般的眼睛一直看到他不爽外，其它一切顺利。中午我们三人下楼去大厅拿了身份证后就在附近的快餐店吃了个便饭，其实大家都想早点回去，不太愿意出差这么久，所有大家心情都比较愉快，吃完饭后回到4楼，发现里面一片漆黑，过道里面摆满了折叠床，原来是中午午睡时间，我们三人趴在位置上各自休息。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下午基本上只花了10分钟不到，我这边就和前置机打通，常林这边和我也是通顺，由于BOSS系统要明天才联调，所以我们今天的工作基本做完，汪伟一个下午都在玩手机，依然在玩米聊，玩陌陌，有个不知道是哪个厂商的女的路过走道，听到汪伟的手机里面发出陌陌的信息声，一种鄙视的眼神，我有点想笑，我不是笑汪伟，我是想笑这个女的，本身长的就有点胖，穿个绿色运动衫裤立在那里很像一个邮筒似的，我们开玩笑说叫汪伟去问她要陌陌号敢不敢，打赌今天的晚餐，实在玩的无聊了，我们三个人站起来环视大厅说哪个女的身材看起来还可以，不知道长的漂亮不漂亮，结果我们还真的一个个人走过去找个机会去看她的脸，回来后再一起评论一番，最无聊的是我们赌一排的位置上有几个女的穿丝袜，汪伟还真的路过过道低头去看了下，就这样三个人在不影响到别人的工作中各种扯淡渡过。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;晚上还是去昨天那个美食街寻找吃的，找了家东北饺子店，三人点了一盘水饺，白菜馅的，三鲜馅的，韭菜馅的，冬菇馅的，反正各种的都来了一点，三人一起吃了将近有40多个，吃的我有点想吐，然后在周围走了一圈，没什么太多新鲜玩意，大家都各自上楼回去休息去了，今晚晚上没什么太多的故事可讲，第一，我推开门的时候没有掉卡片，昨天的那两张卡片也不见了。第二，我没有给贾珍珍发信息，因为我找不到理由了。第三，本来最抱希望的那个床头上的电话居然也没响，我觉得有点失落。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;今晚睡的好香。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;………&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第二天依然早上9点达到移动大厦，还是昨天的那个大厅MM，一样的衣服，一样的包臀，一样的笑容，一样的填表，一样的上四楼。我们刚到工位上，亚信那边的宋工抱了台电脑坐过来，说方便沟通联调，同样局方那边的陈工也一样叫了个小弟抱了台电脑坐了过来，大家开始平平淡淡，偶尔紧紧张张，转而又开开心心的利用半天时间就打通了所有流程，简直有点不可思议，中间几乎没有任何扯皮，没有推卸责任，有什么问题都是互相去帮忙一起看下，甚至连不懂java的汪伟也把脑袋凑过去看代码假装很严肃的在思考这个问题，我知道他有点担心，担心测试环境联调的进度，如果不顺，意味着我们停留在这里的时间要往后延期，其实我何尝不是，所以大家都很卖力在做自己的事情，同时也尽力在帮别人，虽然我没帮到啊。中午我们三个加宋工，陈工一起吃饭，陈工做东，带我们去了一家地方菜馆，他说这个地方是他们经常去的地方，味道还可以的，在我眼里，除了湘菜馆，吃其他的地方菜我都不是特别爱吃，可能不太习惯吧。五个男人在一起不能聊女人，我们大多聊的是工作上的事情，然后就是地方城市的特色，房价什么的都已经是天花板了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下午和上午差不多，为了准保万一，我们又走了几次流程，测试都很通顺，因为有局方的陈工和亚信的宋工在身边，我们三人无故事。突然想起，今天隔壁的软通的兄弟一整天不见踪影，我们开玩笑的说是不是都跑路了，宋工说他们最近连续一个月都是晚上加班，可能今天都休息了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;晚上我们三人没有去美食街那边寻食，周五晚上感觉人特别多，所以在宾馆附近找了家快餐店随便吃了点，吃完饭在附近超市逛了下，买了点水和水果分了，各自回了自己的房间。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 16:17:00 +0000</pubDate>
<dc:creator>心灵之火</dc:creator>
<og:description>来到805房间，把房卡插进去，滴的一声，用手轻轻的把扶手往下使点力，门就开了，房间里透着浅浅的黄色光线，空气中弥漫着淡淡的香味，给人很温馨的感觉。我转过身来把门关上，把房卡插到墙上的白色取电的槽里面，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgcjiayou/p/9616165.html</dc:identifier>
</item>
<item>
<title>Spring之AOP - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9615948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9615948.html</guid>
<description>&lt;p&gt;一、AOP的引入&lt;br/&gt;这里可以把单个模块当做是一圆柱，假如没有aop，在做日志处理的时候，我们会在每个模块中添加日志或者权限处理，日志或权限类似圆柱体的部分圆柱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909230546751-573513561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般大多数的日志或权限处理代码是相同的，为了实现代码复用，我们可能把日志处理抽离成一个新的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909230622546-1806214387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这样我们仍然必须手动插入这些方法，而且这两个方法就是强耦合的，假如此时我们不需要这个功能了，或者想换成其他功能，那么就必须一个个修改。&lt;br/&gt;通过动态代理，可以在指定位置执行对应流程。这样就可以将一些横向的功能抽离出来形成一个独立的模块，然后在指定位置插入这些功能。这样的思想，被称为面向切面编程，亦即AOP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909230721814-1012946703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、AOP主要概念&lt;/p&gt;
&lt;p&gt;上小节介绍了引入AOP的好处，本小节来了解下AOP的几个核心概念。&lt;br/&gt;1.横切关注点&lt;br/&gt;AOP把一个业务流程分成几部分，例如权限检查、业务处理、日志记录，每个部分单独处理，然后把它们组装成完整的业务流，每部分被称为切面或关注点。&lt;br/&gt;2.切面&lt;br/&gt;类是对物体特征的抽象，切面就是对横切关注点的抽象。可以每部分抽象成一叠纸一样一层一层的，那每张纸都是一切面。&lt;br/&gt;3.连接点&lt;br/&gt;被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器.其实Spring只支持方法类型的连接点就包含字段和构造器。为啥呢？因为字段它是通过get，set方法，构造器它其实也是方法。Spring只支持方法类型的连接点和连接点是字段或者构造器它们是包含关系。&lt;br/&gt;4.切入点&lt;br/&gt;对连接点进行拦截的定义，连接点可以很多，但并不一定每个连接点都进行操作，比如莲藕，藕段与藕段之间它们是有连接点的，但不一定都切开。&lt;br/&gt;5.通知&lt;br/&gt;通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类，这个有点类似把藕段与藕段断开之后要做的事情，是往里面加蜂蜜还是做什么。&lt;br/&gt;6.目标对象&lt;br/&gt;代理的目标对象，就是动态代理的target,在实际操作中一般会先实现AOP的接口，然后配置这些接口作用到哪些对象上，被作用的对象就是目标对象。&lt;br/&gt;7.织入&lt;br/&gt;切面是独立的，目标对象也是独立的，它们是不耦合的，那它怎么把切面放到目标对象中呢，这时就需要进行织入操作，就类似一中的，怎么把target和打印日志联系到一起呢，那就需要动态代理，在spring中aop.framework.ProxyFactory就是用作织入器，来进行横切逻辑的织入。&lt;br/&gt;8.引入&lt;br/&gt; 不改代码的同时，为类动态的添加方法或字段。&lt;/p&gt;
&lt;p&gt;三、AOP实现&lt;/p&gt;
&lt;p&gt;前面小节主要介绍了AOP的理论知识，本小节通过示例进一步理解Spring中AOP的使用。主要介绍AOP的三种实现方式：经典的基于代理的AOP、AspectJ基于XML的配置、AspectJ基于注解的配置。&lt;/p&gt;
&lt;p&gt;一、经典的基于代理的AOP&lt;/p&gt;
&lt;p&gt;基于代理的AOP主要介绍MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice三个接口的使用。&lt;br/&gt;MethodBeforeAdvice：见名知意，通过方法名就可以猜到是它的作用。方法前拦截器在执行指定方法前调用，参数分别为被调用的方法、执行时被传入的参数、被拦截的bean。&lt;br/&gt;AfterReturningAdvice：返回后拦截器在执行完指定方法并返回之后调用。如果有返回值可以获取到返回值，否则为null。参数分别为方法返回值、被调用的方法、执行时被传入的参数、被拦截的bean。&lt;br/&gt;ThrowsAdvice：异常拦截器在指定方法抛出异常时被调用。该接口并未定义方法，因此不需要实现任何方法。那它是怎么拦截的呢？我们可以查看该接口的定义，在定义类文档中有如下图的说明。如果在实现该接口的类中定义了如public void afterThrowing(Exception ex)、public void afterThrowing(Method method, Object[] args, Object target, Exception ex)方法抛出异常时就会被调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909231146420-422839724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在软件开发中推荐面向接口的编程，所以这里创建了一个IAOPServices接口，并定义了两个方法。withAopMethod方法将使用拦截器拦截的方法，withNoAopMethod方法不会被拦截器拦截。接口代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IAOPServices {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withNoAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;在AOPServicesImpl类中实现了该接口，并在该类中定义了String类型的description属性，以及对应的getter、setter方法。两个接口方法将返回该description属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e04c54d4-1c2a-4bce-8640-c9c8ca428da2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e04c54d4-1c2a-4bce-8640-c9c8ca428da2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e04c54d4-1c2a-4bce-8640-c9c8ca428da2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AOPServicesImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IAOPServices {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDescription() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDescription(String description) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.description =&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;AOP函数运行方法:withAopMethod&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(description.trim().length()==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;description属性不能为空&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String withNoAopMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;无AOP函数运行方法:withNoAopMethod&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; description;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面把要使用AOP拦截的方法准备好了，下面就是定义AOP拦截器方法了。这里在AOPInterceptor类中实现了上面的AfterReturningAdvice,MethodBeforeAdvice,ThrowsAdvice三个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_f9264553-6d3c-44df-8e33-60f7e1ebcf56&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f9264553-6d3c-44df-8e33-60f7e1ebcf56&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f9264553-6d3c-44df-8e33-60f7e1ebcf56&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.AfterReturningAdvice;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.MethodBeforeAdvice;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.aop.ThrowsAdvice;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AOPInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AfterReturningAdvice,MethodBeforeAdvice,ThrowsAdvice {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; afterReturning(Object value, Method method, Object[] args, Object instance) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        
        System.out.println(&lt;/span&gt;&quot;方法&quot;+method.getName()+&quot;运行结束,返回值为:&quot;+&lt;span&gt;value);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; before(Method method, Object[] args, Object instance) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;执行MethodBeforeAdvice，即将执行的方法:&quot;+&lt;span&gt;method.getName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(instance &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AOPServicesImpl)
        {
            String description&lt;/span&gt;=&lt;span&gt;((AOPServicesImpl)instance).getDescription();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(description==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;description属性不能为null&quot;&lt;span&gt;);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowing(Exception ex){
        System.out.println(&lt;/span&gt;&quot;抛出了异常:&quot;+&lt;span&gt;ex.getMessage());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowing(Method method, Object[] args, Object target, Exception ex){
        System.out.println(&lt;/span&gt;&quot;方法&quot;+method.getName()+&quot;抛出了异常:&quot;+&lt;span&gt;ex.getMessage());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这里要拦截的方法和拦截器都准备好了，那怎么将该拦截器用于拦截该方法呢？这里就需要进行配置。首先在pom.xml中引入依赖，这里引入spring-aop、spring-context。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b61b36f0-7806-4914-9894-610cf9817abd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b61b36f0-7806-4914-9894-610cf9817abd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b61b36f0-7806-4914-9894-610cf9817abd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;BasicAOP&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.0.0.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;spring.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-context&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-aop&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${spring.version}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;实际上Spring无法将Services实现类与拦截器直接组装，因为没有对应的setter、getter方法。安装时借助 Spring中的代理类，将自定义拦截器注入到NameMatchMethodPointcutAdvisor类中的advice属性中，再将定义好的NameMatchMethodPointcutAdvisor对象注入到ProxyFactoryBean。这里将自定义的AOPInterceptor拦截器注入到NameMatchMethodPointcutAdvisor中，然后将NameMatchMethodPointcutAdvisor对象注入到ProxyFactoryBean中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_60fb42f5-16f6-44eb-9a57-ad6a3265fd51&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_60fb42f5-16f6-44eb-9a57-ad6a3265fd51&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_60fb42f5-16f6-44eb-9a57-ad6a3265fd51&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/aop
           http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aopInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;advice&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;basicAop.AOPInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mappedName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;withAopMethod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;aopService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aopInterceptor&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;target&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;basicAop.AOPServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;basicAop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。Spring会在withAopMethod()方法前后添加拦截器，在withNoAopMethod()方法前后并不会添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_117927ed-1226-410d-9f2a-1067004dd2b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_117927ed-1226-410d-9f2a-1067004dd2b6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_117927ed-1226-410d-9f2a-1067004dd2b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; basicAop;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;



&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;applicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IAOPServices services&lt;/span&gt;=(IAOPServices)context.getBean(&quot;aopService&quot;&lt;span&gt;);
        services.withAopMethod();
        services.withNoAopMethod();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909231758245-1094614868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、AspectJ基于XML的配置&lt;br/&gt;AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。我们还是利用IAOPServices接口、AOPServicesImpl类实现AspectJ基于XML的AOP编程。下表是AspectJ主要的配置元素。使用AspectJ时需要引入两个依赖项aopalliance、aspectjweaver。在引入这两个依赖项时需要注意，有时报错误，更新下两个依赖项的版本就好了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e2ff9b31-98eb-489f-ac14-599f6023f9e0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e2ff9b31-98eb-489f-ac14-599f6023f9e0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2ff9b31-98eb-489f-ac14-599f6023f9e0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.demo&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;AutoScanAOP&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;spring.version&amp;gt;5.0.0.RELEASE&amp;lt;/spring.version&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
      &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;aopalliance&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aopalliance&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/org.aspectj/aspectjweaver --&amp;gt;&lt;/span&gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.8.11&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;176&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;AOP&lt;span&gt;配置元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;390&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:config&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;顶层的&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;配置元素，大多数的&lt;/span&gt;&lt;span&gt;&amp;lt;aop:*&amp;gt;&lt;/span&gt;&lt;span&gt;元素必须包含在&lt;/span&gt;&lt;span&gt;&amp;lt;aop:config&amp;gt;&lt;/span&gt;&lt;span&gt;元素内&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:aspect&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义切面&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:aspect-autoproxy&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;启用&lt;span&gt;@AspectJ&lt;/span&gt;&lt;span&gt;注解驱动的切面&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:pointcut&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义切点&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:advisor&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;通知器&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:before&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;前置通知&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:after&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;后置通知（不管被通知的方法是否执行成功）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:after-returning&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;定义成功返回后的通知&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:after-throwing&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;定义抛出异常后的通知&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:around&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot;&gt;
&lt;p&gt;定义&lt;span&gt;AOP&lt;/span&gt;&lt;span&gt;环绕通知&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;176&quot;&gt;
&lt;p&gt;&amp;lt;aop:declare-parents&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;390&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;为被通知的对象引入额外的接口，并透明地实现&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里定义了XMLAdvice拦截器方法，用于演示前置、后置、成功返回、异常返回、环绕通知。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_2256f8cf-3788-411b-98ee-032d038faad0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2256f8cf-3788-411b-98ee-032d038faad0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2256f8cf-3788-411b-98ee-032d038faad0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Services;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XMLAdvice {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeAdvice() {
        System.out.println(&lt;/span&gt;&quot;前置通知执行了&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterAdvice() {
        System.out.println(&lt;/span&gt;&quot;后置通知执行了&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturnAdvice(String result) {
        System.out.println(&lt;/span&gt;&quot;返回通知执行了&quot; + &quot;运行业务方法返回的结果为&quot; +&lt;span&gt; result);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        String result &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;环绕通知开始执行了&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            result &lt;/span&gt;=&lt;span&gt; (String) proceedingJoinPoint.proceed();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
            System.out.println(&lt;/span&gt;&quot;环绕通知执行结束了&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;执行业务方法共计：&quot; + (end - start) + &quot;毫秒。&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; throwingAdvice(JoinPoint joinPoint, Exception e) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        stringBuffer.append(&lt;/span&gt;&quot;异常通知执行了.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;方法:&quot;).append(joinPoint.getSignature().getName()).append(&quot;出现了异常.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;异常信息为:&quot;&lt;span&gt;).append(e.getMessage());
        System.out.println(stringBuffer.toString());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;上面把拦截器定义完成，之后就是把定义好的拦截器与Services关联在一起。使用AOP配置元素将Services与拦截器中的方法关联上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8a2e357f-f157-45c3-bf47-ca34bcf929b8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8a2e357f-f157-45c3-bf47-ca34bcf929b8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8a2e357f-f157-45c3-bf47-ca34bcf929b8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceImplA&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Services.AOPServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;basicAop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceAspectBean&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Services.XMLAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspect &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceAspect&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;serviceAspectBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:pointcut &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; expression&lt;/span&gt;&lt;span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;  
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:before &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;beforeAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;    
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:after &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;afterAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;   
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:after-returning &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;afterReturnAdvice&quot;&lt;/span&gt;&lt;span&gt; returning&lt;/span&gt;&lt;span&gt;=&quot;result&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;     
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:around &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;aroundAdvice&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;     
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:after-throwing &lt;/span&gt;&lt;span&gt;pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;servicePointcut&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;throwingAdvice&quot;&lt;/span&gt;&lt;span&gt; throwing&lt;/span&gt;&lt;span&gt;=&quot;e&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:aspect&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;配置完之后还是和经典的基于代理的AOP一样，运行代码从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。Spring会在withAopMethod()方法前后添加拦截器，在withNoAopMethod()方法前后并不会添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5bce50f3-2ce5-401c-86f4-d5d70e1703bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5bce50f3-2ce5-401c-86f4-d5d70e1703bd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5bce50f3-2ce5-401c-86f4-d5d70e1703bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; AspectJAOP;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; Services.IAOPServices;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        
        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;applicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        IAOPServices services&lt;/span&gt;=(IAOPServices)context.getBean(&quot;serviceImplA&quot;&lt;span&gt;);
        services.withAopMethod();
        services.withNoAopMethod();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909233205903-1679002581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、AspectJ基于注解的配置&lt;br/&gt;AspectJ基于XML的配置还是需要在XML中配置AOP元素，现在一般提倡使用注解来进行编程，AspectJ也提供了基于注解的实现方式。基于注解的AOP配置其实和基于XML的一样，可以参照基于XML的来进行理解。这里定义了AnnontationAdvice，并用@Aspect注解定义切面。在XML中的配置元素改成了注解关键字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_fcb1ec9c-5987-4b4b-a384-1a9586c7ef04&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fcb1ec9c-5987-4b4b-a384-1a9586c7ef04&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fcb1ec9c-5987-4b4b-a384-1a9586c7ef04&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; Services;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.After;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.AfterReturning;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.AfterThrowing;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Around;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Aspect;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnontationAdvice {
    
    @Before(&lt;/span&gt;&quot;execution(* Services.*.withAop*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeAdvice() {
        System.out.println(&lt;/span&gt;&quot;前置通知执行了&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;execution(* Services.*.withAop*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterAdvice() {
        System.out.println(&lt;/span&gt;&quot;后置通知执行了&quot;&lt;span&gt;);
    }

    @AfterReturning(value&lt;/span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;,returning=&quot;result&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturnAdvice(String result) {
        System.out.println(&lt;/span&gt;&quot;返回通知执行了&quot; + &quot;运行业务方法返回的结果为&quot; +&lt;span&gt; result);
    }
    
    @Around(value&lt;/span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        String result &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;环绕通知开始执行了&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
            result &lt;/span&gt;=&lt;span&gt; (String) proceedingJoinPoint.proceed();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; end =&lt;span&gt; System.currentTimeMillis();
            System.out.println(&lt;/span&gt;&quot;环绕通知执行结束了&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;执行业务方法共计：&quot; + (end - start) + &quot;毫秒。&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {

        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    @AfterThrowing(value&lt;/span&gt;=&quot;execution(* Services.*.withAop*(..))&quot;,throwing=&quot;e&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; throwingAdvice(JoinPoint joinPoint, Exception e) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
        stringBuffer.append(&lt;/span&gt;&quot;异常通知执行了.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;方法:&quot;).append(joinPoint.getSignature().getName()).append(&quot;出现了异常.&quot;&lt;span&gt;);
        stringBuffer.append(&lt;/span&gt;&quot;异常信息为:&quot;&lt;span&gt;).append(e.getMessage());
        System.out.println(stringBuffer.toString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在配置文件中只需配置下自动扫描的包名，并配置下&amp;lt;aop:aspectj-autoproxy&amp;gt;即可，比XML的配置简单一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3dc09446-d728-4074-b4e8-8d6c2a68a672&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3dc09446-d728-4074-b4e8-8d6c2a68a672&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3dc09446-d728-4074-b4e8-8d6c2a68a672&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;&lt;span&gt;
xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
http://www.springframework.org/schema/mvc
http://www.springframework.org/schema/mvc/spring-mvc.xsd
http://www.springframework.org/schema/aop
http://www.springframework.org/schema/aop/spring-aop.xsd
&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置自动扫描的包 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;Services&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context:component-scan&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 自动为切面方法中匹配的方法所在的类生成代理对象。 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:aspectj-autoproxy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;serviceImplA&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Services.AOPServicesImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;description&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;basicAop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后还是从Spring容器中获取IAOPServices对象，并分别执行IAOPServices中的两个方法。运行结果如下图，从打印的日志可以看到拦截器拦截了withAopMethod()方法，withNoAopMethod()并未拦截。&lt;/p&gt;
&lt;p&gt;运行结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201809/733213-20180909234326432-768894538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 09 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>一、AOP的引入这里可以把单个模块当做是一圆柱，假如没有aop，在做日志处理的时候，我们会在每个模块中添加日志或者权限处理，日志或权限类似圆柱体的部分圆柱。 一般大多数的日志或权限处理代码是相同的，为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9615948.html</dc:identifier>
</item>
<item>
<title>mysql执行sql语句过程 - 精品唯居</title>
<link>http://www.cnblogs.com/liyasong/p/mysql_zhixingguocheng.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyasong/p/mysql_zhixingguocheng.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　开发人员基本都知道，我们的数据存在数据库中（目前最多的是mysql和oracle，由于作者更擅长mysql，所以这里默认数据库为mysql），服务器通过sql语句将查询数据的请求传入到mysql数据库。数据库拿到sql语句以后。都是进行了哪些操作呢？这里向大家介绍下我的个人的理解，欢迎大家评论区批评指正。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;流程概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　mysql得到sql语句后，大概流程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.sql的解析器：负责解析和转发sql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.预处理器：对解析后的sql树进行验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.查询优化器：得到一个执行计划&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.查询执行引擎：得到数据结果集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.将数据放回给调用端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程图如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104082/201809/1104082-20180909231508219-1821647882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;分发器及缓存阶段&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　首先，如果系统的缓存功能开启着的话，sql语句进入mysql后，sql进行判断，是否为select关键字。如果是，那么先去查询缓存中进行查询，如果在查询缓存中可以命中sql语句，那么直接返回查询缓存中的查询语句对应的value值（在缓存中，把查询语句做一个hash运算，结果作为key值，查询的结果集为value）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果命中缓存的话，查询速度是相当快的。但是查询缓存也有它相应的缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，开启缓存的话，服务器会消耗大量的内存空间；其次，缓存有的时候并不适用；最后，有的情况下，开启缓存也不会将对应的sql语句写入缓存。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;缓存不适用的情况：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　缓存的锁的力度比较大，而且对于动态sql的支持度不够。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　缓存在数据进行更新的时候，是进行的表级锁，更新结束后，会把所有与更新内容相关的缓存全部删除。所以，如果表的写入比较多的话，缓存是比较浪费性能的。如果写入特别多，可能缓存反而会导致mysql变慢。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;查询不到缓存的情况：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1.查询条件有不确定数据：如now ，current_time等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.缓存对大小写敏感，如select * from test 和SELECT* FROM test 就不会解析为同一条sql&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;查询带来的额外开销：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　1.开始前需要先检查缓存是否命中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.结果输出的时候，需要额外进行数据的缓存操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.写入数据时，mysql会将对应表的所有缓存都设置为失效。当缓存内存较大的时候，会导致系统消耗较大。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;sql的解析器与预处理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　sql解析器是在命令分发之后，将对应的sql语句，解析为sql解析树。sql解析树是Mysql本身内部的语法规则和解析查询。验证是否使用错误的关键字，sql语法顺序是否正确等。（语法层面的错误）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解析完成后，进行查询语句预处理器，根据mysql的规则，检查解析树是否合法。（表格是否存在，别名是否有歧义等）&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;查询优化器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　查询优化器获取到执行计划然后由查询执行引擎执行相应的操作。查询优化器，是数据库l的一个核心模块，分为cbo和rbo两种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中，rbo是基于规则的优化器。（rbo在oracle早期版本中使用，现在也保留，不过默认为cbo。mysql没有rbo优化器）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这些规则是硬编码在数据库的代码中的。rbo会根据输入的sql语句可以匹配到的优先级最高的规则去作为执行计划。例如：在rbo中有这么一条规则：有索引的情况下，使用索引。那么所有的带有索引的表在执行的时候，都会走索引。rbo最大的问题在于，通过固定规则来决定执行计划。并不会考虑sql中涉及的对象的数量和分布。有可能选出来的规则不是最优的执行计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　cbo 是基于成本的优化器（基于统计信息），从目标诸多的执行路径中选择一个成本最小的执行路径来作为执行计划。成本指的是mysql根据相关的统计信息，算出来sql语句对应的io，cpu等的消耗的一个估计值。计算过程涉及到索引、表、行等数据，过程比较复杂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.查询优化器使用统计信息为sql选择执行计划。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.mysql没有数据直方图，也无法手工删除统计信息。（oracle有）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.在服务器曾有查询优化器，却没有保存数据和索引统计信息。统计信息由存储引擎实现，不同的存储引擎会存储不同的统计信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.统计信息分为索引的统计信息和表的统计信息。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;查看统计信息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　索引统计信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　show index from table 或information_schema.statistics表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　表统计信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　show table status like 或 information_schema.tables表&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;查询执行引擎+返回数据给客户端&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　得到执行计划后，根据已有的执行计划，查询执行引擎，mysql的SQL Layer层，调用Storage Engine Layer层的接口，从mysql的存储引擎中获取到相对应的结果集，然后返回给用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　执行完成后，将结果返回给客户端，如果是查询语句，并且开启了缓存，那么，mysql会同时将结果集放到查询缓存中。然后将查到的结果集返回。如果是增删改操作，那么返回执行语句后受影响的行数。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>精品唯居</dc:creator>
<og:description>开发人员基本都知道，我们的数据存在数据库中（目前最多的是mysql和oracle，由于作者更擅长mysql，所以这里默认数据库为mysql），服务器通过sql语句将查询数据的请求传入到mysql数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyasong/p/mysql_zhixingguocheng.html</dc:identifier>
</item>
<item>
<title>Scala的映射和元组操作 - codegeekgao</title>
<link>http://www.cnblogs.com/codegeekgao/p/9615925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codegeekgao/p/9615925.html</guid>
<description>&lt;h2 id=&quot;映射和元组操作&quot;&gt;映射和元组操作&lt;/h2&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;    // 构造一个不可变的MAP映射，类似与key -&amp;gt; value这样的组合叫做对偶
    val score = Map(&quot;Jack&quot; -&amp;gt; 12, &quot;Bob&quot; -&amp;gt; 20)
    // 也可以这种创建一个Map映射
    val score1 = Map((&quot;Jack&quot;, 12), (&quot;Bob&quot;, 20))
    // 根据key获取value，类似java中的map.get(key)若是获取一个不存在的key则会报错而不是null
    println(score(&quot;Jack&quot;))
    // 获取元素不存在给出无元素提醒
    val flag = if (score.contains(&quot;haha&quot;)) score.get(&quot;haha&quot;) else &quot;no such element&quot;
    val flag1 = score.getOrElse(&quot;haha&quot;, &quot;no such element&quot;)
    // 创建可变Map
    val score = scala.collection.mutable.Map(&quot;Jack&quot; -&amp;gt; 12, &quot;Bob&quot; -&amp;gt; 20)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新映射中的值&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;在可变的映射中，可以更新某个映射的值，在=号左侧使用():
// 更新可变的Map的值
scores(&quot;Bob&quot;) = 10
// 添加新的key-value
scores(&quot;haha&quot;)=7
// 也可以使用+=操作和创建映射关系
scores +=(&quot;Michael&quot; -&amp;gt; 22)
// 移除某个键对应的值
score -=(&quot;Michael&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;迭代映射&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;for((k,v) &amp;lt;- 映射) 这种可以得到每一个的键值对
// 和java一样可以使用keySet和values方法，values方法将会返回一个iterable
score.keySet // 返回类似(&quot;Bob&quot;,&quot;Michael&quot;)
// 获取map的value
for (v &amp;lt;- score.values) println(v)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;排序映射&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;操作映射时，需要选定一个实现---哈希表或者平衡树，默认情况Scala中式hash表，若想顺序访问所有的键，因此需要一个树形映射&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;val scores = scala.collection.immutable.SortedMap(&quot;Bob&quot; -&amp;gt; 10,&quot;michael&quot; -&amp;gt; 12)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;与java的互操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// import scala.collection.javaConversions.mapAsScalaMap 然后指定Scala映射类型触发转换
val scores:scala.collection.mutable.Map[String,Int] = new java.util.TreeMap[String,Int]
// import scala.collection.javaConversions.propertiesAsScalaMap
val props :scala.collection.Map[String,String] = System.getProperties()
// 以上都是将java的map转为Scala的map，可以将Scala的map转为java的mao
import scala.collection.javaConversions.mapAsJavaMap&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;映射式键值对的集合，对偶式元组(tuple)的最简单的形态---而元组式不同类型值得聚集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;(1,95.27,&quot;Bob&quot;) 是一个元组类型为(Int,Double,java.lang.String)可以方法_1,_2,_3访问元组例如以下元组：
    val l = (1,2.34,&quot;哈哈&quot;)
    println(l._2)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;拉链操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 使用元组可以将他们映射起来使用zip方法
    val symbols = Array(&quot;&amp;lt;&quot;,&quot;-&quot;,&quot;&amp;gt;&quot;)
    val counts = Array(2,10,2)
    val pairs = symbols.zip(counts)
    println(pairs.toBuffer)
    // 打印&amp;lt;&amp;lt;----------&amp;gt;&amp;gt;
    for ((s,n) &amp;lt;- pairs) Console.print(s * n)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 09 Sep 2018 15:42:00 +0000</pubDate>
<dc:creator>codegeekgao</dc:creator>
<og:description>映射和元组操作 构造Map 更新映射中的值 迭代映射 scala val scores = scala.collection.immutable.SortedMap(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codegeekgao/p/9615925.html</dc:identifier>
</item>
</channel>
</rss>