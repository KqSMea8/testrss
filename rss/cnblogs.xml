<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于学习python的一点小建议 - 我有我的小念想</title>
<link>http://www.cnblogs.com/pythonpipiha/p/9830225.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonpipiha/p/9830225.html</guid>
<description>&lt;p&gt;Python是最容易入门的编程语言，没有之一。如果初学者接触的第一门语言是C或者C++，对他们来说最难的不是语法，而是容易出现内存泄漏、指针等问题。有时候排查这些问题对初学者的打击很大，尤其是没掌握排查BUG技巧时。&lt;/p&gt;
&lt;p&gt;如果初学者接触的第一门语言是Python，学习曲线则会平滑得多，掌握一些基本语法和Python内置的数据结构，已经可以上手写一些小工具或者小型应用。这对初学者来说，非常重要。因为学习的过程是一个突破舒适区的过程，会面临很多痛苦，如果学习过程得不到激励，很容易半途而废，类似我们开玩笑说的「从入门到放弃」。Python还有很多优点：上手快，第三方库丰富，资料丰富，很容易做出“可见可得”的应用。比如你要拿C或者C++做web服务，这上手门槛就有点高了。所以很多工科学生，甚至是科班学生会问学了C/C++到底有什么用，因为想上手做一些“可见可得”的应用太难。Python就大不同，你想搞Web开发？上来一个Flask框架立马就撸。想搞点数据分析？上来一个Panda+数据可视化，撸起来轻松愉快甚有快感。想抓取什么数据？你自己基于request撸一个小爬虫采集点网站信息，app信息都不是什么难事。&lt;/p&gt;
&lt;p&gt;也是因为这样，学习Python的过程几乎接近“无痛”，有很好的学习正反馈过程，学一点知识就能做一点小东西，能看得到自己成长和进步。安利了这么多好处，来看看学Python分几个阶段吧。&lt;/p&gt;
&lt;p&gt;如果对python感兴趣，想了解，学习的话，可以点击文末&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;articleHeader1&quot;&gt;1.基础知识&lt;/h2&gt;
&lt;p&gt;Python最基本的语言特性和语法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;数据类型与数据结构&lt;/li&gt;
&lt;li&gt;输入和输出&lt;/li&gt;
&lt;li&gt;运算符、表达式、语句&lt;/li&gt;
&lt;li&gt;控制流(顺序控制，选择控制和循环控制)&lt;/li&gt;
&lt;li&gt;面向过程编程&lt;/li&gt;
&lt;li&gt;面向对象编程&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;li&gt;组织代码&lt;/li&gt;
&lt;li&gt;标准库、第三方库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对面向对象这一块需要重点的讲一下，为什么会有面向对象？以及我们如何设计面向对象系统？这个思考的过程有助于你理解面向对象编程思想。&lt;/p&gt;
&lt;p&gt;可以说「一切皆对象」这句话普适性是很强的，大家都在玩的王者农药，里面每一个对战英雄，每一个野怪，每一张地图都是通过面向对象的思想构建起来的。如果一开始你觉得太复杂，大可把用「分而治之」的思想把复杂的对象break down，分解成多个简单合理的对象。任何复杂的系统都可以由若干个简单可靠的系统组成，多个简单可靠的系统有序地组织起来是可以实现强大功能的。举个例子，还拿农药来说，”英雄“是可以作为一个基类的对吧，每个英雄都有血条，移动速度，AD，AP，物防，法扛等等。李白平A后裔一下，这是对象之间的通信（或者说交互）。后裔放大打中李白，李白眩晕，这一系列的触发过程都可以通过面向对象来建模。&lt;/p&gt;
&lt;p&gt;在掌握了语法特点，掌握了面向对象的思想之后，我们应该能够在控制台（windows或者mac的命令行）里边实现一个有意思的程序。这个程序应该解决现实生活中的一个实际问题。比如出现一个职位的发布和管理系统。有以下功能。我们可以录入职位信息。保存到文件上。我们还可以加载职位信息。按多种条件去查询，比如按关键字按城市。按薪资范围。按商圈工作年限等等。&lt;/p&gt;
&lt;p&gt;在做这个的过程中，自己需要设计一个很好的面向对象系统。也把Python里常用的语言基本特性都用到了。达到这个阶段算是勉强及格了吧，不过仅仅是在语言掌握层面。如果想当一个合格的研发工程师，还需要掌握很多其他技能。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader2&quot;&gt;2. 进阶的阶段&lt;/h2&gt;
&lt;p&gt;现在的开发大部分是基于web的，比如app要调web接口，pc端肯定也要调web接口，所以我们不能光在控制台里面玩。这个时候需要了解，http协议和Python web开发。我们可以重做前面提到的求职发布系统，学习基于Python web如何实现。这个时候你需要实现若干个接口：&lt;/p&gt;
&lt;p&gt;用户端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户注册&lt;/li&gt;
&lt;li&gt;用户登录&lt;/li&gt;
&lt;li&gt;请求首页刷出默认的职位列表&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;筛选职位列表&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据城市&lt;/li&gt;
&lt;li&gt;根据关键字&lt;/li&gt;
&lt;li&gt;根据薪酬&lt;/li&gt;
&lt;li&gt;根据工作商圈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;管理后台：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;登录&lt;/li&gt;
&lt;li&gt;发布职位&lt;/li&gt;
&lt;li&gt;更新职位&lt;/li&gt;
&lt;li&gt;删除职位&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了实现以上接口，你需要弄清楚什么是GET，什么是POST请求，什么场景下用GET，什么场景用POST。你还需要明白一个Python web开发框架，要明白一个http请求到了web框架之后，框架做了什么事情，如何在里面实现业务逻辑。哪些数据是服务共享的，哪些数据是用户/请求独享的。&lt;/p&gt;
&lt;p&gt;此外，应该学会Python如何操作数据库实现增删改查，大部分的任务都离不开增删改查。比如我提到的发布职位就是create的过程，更新就是update，还有删除是delete，读是read。江湖有一个戏称CRUD boy。&lt;/p&gt;
&lt;p&gt;如果能顺利度过进阶阶段，你应该能举一反三实现其他类似系统了。比如现在很火的分销，拼团，还有新闻Feeds等等。&lt;/p&gt;
&lt;p&gt;好像我没怎么提数据结构和算法，这个要看个人追求。如果你要在最短时间内学会Python开发，恐怕是没时间学好数据结构和算法了，能掌握自带的数据结构用法就行。如果你的学习时间充足，我的建议是一定要学数据结构和算法。为了以后长期的发展，为了人民币，一定要学好数据结构和算法，我简直苦口婆心地劝啊。&lt;/p&gt;
&lt;h2 id=&quot;articleHeader3&quot;&gt;3. 工业界经验&lt;/h2&gt;
&lt;p&gt;最后一个阶段是实际的工业经验。这个阶段，你应该对公司用的基础架构，如RPC，数据库缓存消息系统中间件，烂熟于心。同时应该掌握最基本的系统设计的技巧。知道如何根据一个实际需求，设计一个高可用，高性能高扩展性的系统。&lt;/p&gt;
&lt;p&gt;实际上我觉得第一个阶段是最容易的，第二个阶段会碰到一些坑，有时候不好解决。在第二个阶段，你可能需要比较好的自学能力，或者有一个好的学长导师。第三个阶段需要比较体系化的训练和思考。&lt;/p&gt;
&lt;p&gt;如果说你的系统设计能力ok，甚至经验丰富，再加上你不错的算法，你肯定有一份好工作，薪资可能说多了显浮夸，但优秀的应届生很多人超过30w，甚至50w已经是常态了。工作3-5年的过百万的也大有人在。&lt;/p&gt;
&lt;p&gt;这个时代，程序员虽然辛苦了一点，但无疑碰上最好的时代了。&lt;/p&gt;
&lt;p&gt;PS：辛苦是因为知识更新很快，行业发展也很快，逼着程序员也要往前走。保持学习才是从业者的基本素养，而不是掌握某门语言某门技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a title=&quot;阅读原文&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 07:14:00 +0000</pubDate>
<dc:creator>我有我的小念想</dc:creator>
<og:description>Python是最容易入门的编程语言，没有之一。如果初学者接触的第一门语言是C或者C++，对他们来说最难的不是语法，而是容易出现内存泄漏、指针等问题。有时候排查这些问题对初学者的打击很大，尤其是没掌握排</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythonpipiha/p/9830225.html</dc:identifier>
</item>
<item>
<title>【DataMagic】如何在万亿级别规模的数据量上使用Spark - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9830196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9830196.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.7307692307692&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/1642104?fromSource=waitui&quot;&gt;鹅厂新鲜事儿&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/2305?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;作者：张国鹏 | 腾讯 运营开发工程师&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark作为大数据计算引擎，凭借其快速、稳定、简易等特点，快速的占领了大数据计算的领域。本文主要为作者在搭建使用计算平台的过程中，对于Spark的理解，希望能给读者一些学习的思路。文章内容为介绍Spark在DataMagic平台扮演的角色、如何快速掌握Spark以及DataMagic平台是如何使用好Spark的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、Spark在DataMagic平台中的角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1642104/lztrse55uy.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;图 2-1&lt;/p&gt;
&lt;p&gt;整套架构的主要功能为日志接入、查询(实时和离线)、计算。离线计算平台主要负责计算这一部分，系统的存储用的是COS(公司内部存储)，而非HDFS。&lt;/p&gt;
&lt;p&gt;下面将主要介绍Spark on Yarn这一架构，抽取出来即图2-2所示，可以看到Spark on yarn的运行流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1642104/mxm48h6kb4.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;图2-2&lt;/p&gt;
&lt;p&gt;三、&lt;strong&gt;如何快速掌握Spark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于理解Spark，我觉得掌握下面4个步骤就可以了。&lt;/p&gt;
&lt;p&gt;1．理解Spark术语&lt;/p&gt;
&lt;p&gt;对于入门，学习Spark可以通过其架构图，快速了解其关键术语，掌握了关键术语，对Spark基本上就有认识了，分别是结构术语Shuffle、Patitions、MapReduce、Driver、Application Master、Container、Resource Manager、Node Manager等。API编程术语关键RDD、DataFrame，结构术语用于了解其运行原理，API术语用于使用过程中编写代码，掌握了这些术语以及背后的知识，你就也知道Spark的运行原理和如何编程了。&lt;/p&gt;
&lt;p&gt;2．掌握关键配置&lt;/p&gt;
&lt;p&gt;Spark在运行的时候，很多运行信息是通过配置文件读取的，一般在spark-defaults.conf，要把Spark使用好，需要掌握一些关键配置，例如跟运行内存相关的，spark.yarn.executor.memoryOverhead、spark.executor.memory，跟超时相关的spark.network.timeout等等，Spark很多信息都可以通过配置进行更改，因此对于配置需要有一定的掌握。但是使用配置时，也要根据不同的场景，这个举个例子，例如spark.speculation配置，这个配置主要目的是推测执行，当worker1执行慢的情况下，Spark会启动一个worker2，跟worker1执行相同的任务，谁先执行完就用谁的结果，从而加快计算速度，这个特性在一般计算任务来说是非常好的，但是如果是执行一个出库到Mysql的任务时，同时有两个一样的worker，则会导致Mysql的数据重复。因此我们在使用配置时，一定要理解清楚，直接google spark conf就会列出很多配置了。&lt;/p&gt;
&lt;p&gt;3．使用好Spark的并行&lt;/p&gt;
&lt;p&gt;我们之所以使用Spark进行计算，原因就是因为它计算快，但是它快的原因很大在于它的并行度，掌握Spark是如何提供并行服务的，从而是我们更好的提高并行度。&lt;/p&gt;
&lt;p&gt;对于提高并行度，对于RDD，需要从几个方面入手，1、配置num-executor。2、配置executor-cores。3、配置spark.default.parallelism。三者之间的关系一般为spark.default.parallelism=num-executors*executor-cores的2~3倍较为合适。对于Spark-sql，则设置spark.sql.shuffle.partitions、num-executor和executor-cores。&lt;/p&gt;
&lt;p&gt;4．学会如何修改Spark代码&lt;/p&gt;
&lt;p&gt;新手而言，特别是需要对Spark进行优化或者修改时，感到很迷茫，其实我们可以首先聚焦于局部，而Spark确实也是模块化的，不需要觉得Spark复杂并且难以理解，我将从修改Spark代码的某一角度来进行分析。&lt;/p&gt;
&lt;p&gt;首先，Spark的目录结构如图3-1所示，可以通过文件夹，快速知道sql、graphx等代码所在位置，而Spark的运行环境主要由jar包支撑，如图3-2所示，这里截取部分jar包，实际上远比这多，所有的jar包都可以通过Spark的源代码进行编译，当需要修改某个功能时，仅需要找到相应jar包的代码，修改之后，编译该jar包，然后进行替换就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1642104/ilsyq05zq5.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;图3-1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1642104/kh5y6m3fbk.jpg?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;图3-2&lt;/p&gt;
&lt;p&gt;而对于编译源代码这块，其实也非常简单，安装好maven、scala等相关依赖，下载源代码进行编译即可，掌握修改源码技巧对于使用好开源项目十分重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、DataMagic平台中的Spark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark在DataMagic中使用，也是在边使用边探索的过程，在这过程中，列举了其比较重要的特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1．快速部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在计算中，计算任务的数量以及数据的量级每天都会发生变化，因此对于Spark平台，需要有快速部署的特性，在实体机上，有一键部署脚本，只要运行一个脚本，则可以马上上线一个拥有128G内存、48cores的实体机，但是实体机通常需要申请报备才能获得，因此还会有docker来支持计算资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2．巧用配置优化计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark大多数属性都是通过配置来实现的，因此可以通过配置动态修改Spark的运行行为，这里举个例子，例如通过配置自动调整exector的数量。&lt;/p&gt;
&lt;p&gt;2.1 在nodeManager的yarn-site.xml添加配置&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt; &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;mapreduce_shuffle,spark_shuffle&amp;lt;/value&amp;gt;
   &amp;lt;/property&amp;gt;
   &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;yarn.nodemanager.aux-services.spark_shuffle.class&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;org.apache.spark.network.yarn.YarnShuffleService&amp;lt;/value&amp;gt;
   &amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.2 将spark-2.2.0-yarn-shuffle.jar文件拷贝到hadoop-yarn/lib目录下（即yarn的库目录）&lt;/p&gt;
&lt;p&gt;2.3 在Spark的spark-default.xml添加配置&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;spark.dynamicAllocation.minExecutors 1 #最小Executor数
spark.dynamicAllocation.maxExecutors 100 #最大Executor数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这种配置，可以达到自动调整exector的目的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3．合理分配资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个平台，其计算任务肯定不是固定的，有的数据量多，有的数据量少，因此需要合理分配资源，例如有些千万、亿级别的数据，分配20核计算资源就足够了。但是有些数据量级达到百亿的，就需要分配更多的计算资源了。参考第三章节的第3点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4．贴合业务需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算的目的其实就是为了服务业务，业务的需求也理应是平台的追求，当业务产生合理需求时，平台方也应该尽量去满足。如为了支持业务高并发、高实时性查询的需求下，Spark在数据出库方式上，支持了Cmongo的出库方式。&lt;/p&gt;
&lt;p&gt;sc = SparkContext(conf=conf) sqlContext = SQLContext(sc) database = d = dict((l.split('=') for l in dbparameter.split())) parquetFile = sqlContext.read.parquet(file_name) parquetFile.registerTempTable(tempTable) result = sqlContext.sql(sparksql) url = &quot;mongodb://&quot;+database['user']+&quot;:&quot;+database['password']+&quot;@&quot;+database['host']+&quot;:&quot;+database['port'] result.write.format(&quot;com.mongodb.spark.sql&quot;).mode('overwrite').options(uri=url,database=database['dbname'],collection=pg_table_name).save()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5．适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark作为通用的计算平台，在普通的应用的场景下，一般而言是不需要额外修改的，但是DataMagic平台上，我们需要“在前行中改变”。这里举个简单的场景，在日志分析中，日志的量级达到千亿/日的级别，当底层日志的某些字段出现utf-8编码都解析不了的时候，在Spark任务中进行计算会发生异常，然后失败，然而如果在数据落地之前对乱码数据进行过滤，则有可能会影响数据采集的效率，因此最终决定在Spark计算过程中解决中这个问题，因此在Spark计算时，对数据进行转换的代码处加上异常判断来解决该问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6．Job问题定位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark在计算任务失败时候，需要去定位失败原因，当Job失败是，可以通过yarn logs -applicationId application 来合并任务log，打开log，定位到Traceback，一般可以找到失败原因。一般而言，失败可以分成几类。&lt;/p&gt;
&lt;p&gt;a. 代码问题，写的Sql有语法问题，或者Spark代码有问题。&lt;/p&gt;
&lt;p&gt;b. Spark问题，旧Spark版本处理NULL值等。&lt;/p&gt;
&lt;p&gt;c. 任务长时间Running状态，则可能是数据倾斜问题。&lt;/p&gt;
&lt;p&gt;d. 任务内存越界问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7．集群管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spark集群在日常使用中，也是需要运营维护的，从而运营维护，发现其存在的问题，不断的对集群进行优化，这里从以下几个方面进行介绍，通过运营手段来保障集群的健壮性和稳定性，保证任务顺利执行。&lt;/p&gt;
&lt;p&gt;a. 定时查看是否有lost node和unhealthy node，可以通过脚本来定时设置告警，若存在，则需要进行定位处理。&lt;/p&gt;
&lt;p&gt;b. 定时扫描hdfs的运行log是否满了，需要定时删除过期log。&lt;/p&gt;
&lt;p&gt;c. 定时扫描集群资源是否满足计算任务使用，能够提前部署资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文主要是通过作者在搭建使用计算平台的过程中，写出对于Spark的理解，并且介绍了Spark在当前的DataMagic是如何使用的，当前平台已经用于架平离线分析，每天计算分析的数据量已经达到千亿~万亿级别。&lt;/p&gt;
&lt;blockquote readability=&quot;0.4390243902439&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/123819?fromSource=waitui&quot;&gt;Spark 优化怎么做？&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1157948?fromSource=waitui&quot;&gt;腾讯云游戏多媒体解决方案&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1158006?fromSource=waitui&quot;&gt;惧怕羊毛党？腾讯云为你保驾护航&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1150162?fromSource=waitui&quot;&gt;AI从入门到放弃：CNN的导火索，用MLP做图像分类识别？&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1128?fromSource=waitui&quot;&gt;【每日课程推荐】机器学习实战！快速入门在线广告业务及CTR相应知识&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1092587?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 07:12:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9830196.html</dc:identifier>
</item>
<item>
<title>.netcore中使用EFCore连接SQL Server并部署至Ubuntu - andywangguanxi</title>
<link>http://www.cnblogs.com/gxwang/p/9829803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gxwang/p/9829803.html</guid>
<description>&lt;p&gt;前面一篇记录了如何在windows下开发asp.net core程序，并部署至ubuntu系统中。但仅仅是建立了一个demo项目，项目本身并没有实现多少功能。多数时候，我们的项目是要和数据库打交道。EntityFramework作为微软提供的基于ADO.NET的ORM解决方案，在dotnet core中，轻量级的EFCore也已经发布。话不多说，直接操作。&lt;/p&gt;
&lt;p&gt;1.项目中添加引用&lt;/p&gt;
&lt;p&gt;新建asp.net core web应用程序，右键项目，选择NuGet管理，搜索Microsoft.EntityFrameworkCore.SqlServer，Microsoft.EntityFrameworkCore.Tools两个包进行安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/742255/201810/742255-20181022141908629-1951577795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.VS菜单上的工具--&amp;gt;NuGet包管理器--&amp;gt;程序包管理器控制台，打开控制台后，输入如下代码，创建上下文（DBContext）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Scaffold-DbContext &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数据库连接字符串&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -Tables Employee
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据库连接字符串，和使用ado.net连接数据库时，web.config中配置的连接字符串一样。连接到你的数据库服务器即可。-Tables 可以用来指定针对数据库中某个或某几个表生成实体类，如果不加这个参数，会将数据库里的所有表生成实体。注意：如果项目所在目录有中文的话，这条命令执行可能会报错。&lt;/p&gt;
&lt;p&gt;命令执行完成后你会发现，项目下多了一个Models目录，并且多了两个文件：MyDbContext.cs和Employee.cs。打开MyDbContext.cs文件，找到OnConfiguring方法，将其注释掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/742255/201810/742255-20181022144138696-1329459103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.通过依赖关系注入上下文&lt;/p&gt;
&lt;p&gt;打开Startup.cs文件，添加Microsoft.EntityFrameworkCore引用。找到ConfigureServices方法，在该方法末尾加入以下两行代码。MyDbContext需要添加应用（放在项目下的Models中），&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; connection = &lt;span&gt;@&quot;数据库连接字符串&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
services.AddDbContext&lt;/span&gt;&amp;lt;MyDbContext&amp;gt;(options =&amp;gt; options.UseSqlServer(connection));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，接下来就可以在控制器中使用MyDbContext了。我们可以在项目自带的ValuesController中加一个方法，来试试看。在ValuesController中添加如下代码，并修改ValuesCotroller默认的路由方案&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)] 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ValuesController添加下面代码，用来获取Employee表中的数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; MyDbContext _context;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(MyDbContext context)
        {
            _context &lt;/span&gt;=&lt;span&gt; context;
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;Employee&amp;gt;&lt;span&gt; GetEmployees()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _context.Employee.ToList();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行项目，在浏览器地址后面输入路由规则 localhost:xxxxx/api/values/GetEmployees 返回如下内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/742255/201810/742255-20181022145926926-82960873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;恭喜你，已经成功将数据库中Employee表中数据取出，返回成json格式。&lt;/p&gt;
&lt;p&gt;4. 打包并部署至ubuntu&lt;/p&gt;
&lt;p&gt;可以参考上一篇中的步骤，将项目部署至ubuntu系统中。这里需要注意的是，如果你其他功能访问正常，但连接数据库时出错（通过supervisor配置的输出日志/var/log/youapp.out.log 查看错误），检查你的数据库版本。需要SQL Server2008R2 sp3版本以上才可以，如果你时sql server 2008R2，可以通过下面连接下载补丁包安装，完成后重启sqlserver服务即可。&lt;/p&gt;
&lt;p&gt;补丁下载：&lt;/p&gt;
&lt;p&gt;https://www.microsoft.com/en-us/download/details.aspx?id=44271&lt;/p&gt;

&lt;p&gt;参考连接：&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/ef/core/get-started/aspnetcore/existing-db&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/weiweithe/p/7810803.html&lt;/p&gt;

</description>
<pubDate>Mon, 22 Oct 2018 07:05:00 +0000</pubDate>
<dc:creator>andywangguanxi</dc:creator>
<og:description>前面一篇记录了如何在windows下开发asp.net core程序，并部署至ubuntu系统中。但仅仅是建立了一个demo项目，项目本身并没有实现多少功能。多数时候，我们的项目是要和数据库打交道。E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gxwang/p/9829803.html</dc:identifier>
</item>
<item>
<title>Python并行编程(十三)：进程池和mpi4py模块 - 杜先生的博客</title>
<link>http://www.cnblogs.com/dukuan/p/9811057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dukuan/p/9811057.html</guid>
<description>&lt;p&gt;1、基本概念&lt;/p&gt;
&lt;p&gt;      多进程库提供了Pool类来实现简单的多进程任务。Pool类有以下方法：&lt;/p&gt;
&lt;p&gt;      - apply()：直到得到结果之前一直阻塞。&lt;/p&gt;
&lt;p&gt;      - apply_async()：这是apply()方法的一个变体，返回的是一个result对象。这是一个异步的操作，在所有的子类执行之前不会锁住主进程。&lt;/p&gt;
&lt;p&gt;      - map()：这是内置的map函数的并行版本，在得到结果之前一直阻塞，此方法将可迭代的数据的每一个元素作为进程池的一个任务来执行。&lt;/p&gt;
&lt;p&gt;      - map_async()：这是map的一个变体，返回一个result对象。如果指定了回调函数，回调函数应该是callable的，并且只接受一个参数。当result准备好时，会自动调用回调函数，除非调用失败。回调函数应该立即完成，否则，持有result的进程将被阻塞。&lt;/p&gt;

&lt;p&gt;2、测试用例&lt;/p&gt;
&lt;p&gt;      创建四个进程池，然后使用map方法进行一个简单的计算。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; multiprocessing

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; function_square(data):
    result &lt;/span&gt;= data *&lt;span&gt; data
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    inputs &lt;/span&gt;= list(range(100&lt;span&gt;))
    pool &lt;/span&gt;= multiprocessing.Pool(processes=4&lt;span&gt;)
    pool_outputs &lt;/span&gt;=&lt;span&gt; pool.map(function_square, inputs)
    pool.close()
    pool.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pool: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pool_outputs)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      pool.map方法将一些独立的任务提交给进程池。pool.map和内置map的执行结果相同，但pool.map是通过多个并行进程计算的。&lt;/p&gt;

&lt;p&gt;3、mpi4py模块&lt;/p&gt;
&lt;p&gt;      Python提供了很多MPI模块写并行程序。其中mpi4py在MPI-1/2顶层构建，提供了面向对象的接口，紧跟C++绑定的MPI-2。MPI是C语言用户可以无需学习新的接口就可以使用这个库。&lt;/p&gt;
&lt;p&gt;      此模块包含的主要的应用：&lt;/p&gt;
&lt;p&gt;      - 点对点通讯&lt;/p&gt;
&lt;p&gt;      - 集体通讯&lt;/p&gt;
&lt;p&gt;      - 拓扑&lt;/p&gt;
&lt;p&gt;4、安装mpi4py&lt;/p&gt;
&lt;p&gt;      安装mpich：https://www.microsoft.com/en-us/download/confirmation.aspx?id=56727&lt;/p&gt;
&lt;p&gt;      下载并安装msmpisetup.exe&lt;/p&gt;
&lt;p&gt;       安装完成后安装目录如下：&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019100738476-1291286137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      将bin目录添加到系统环境中：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019100841605-424768067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      用cmd输入并显示如下即为安装成功&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019101216845-1116488953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      安装mpi4py&lt;/p&gt;
&lt;p&gt;      pip install mpi4py&lt;/p&gt;
&lt;p&gt;      MPI测试用例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mpi_test(rank):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I am rank %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;rank)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:

    comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
    rank &lt;/span&gt;=&lt;span&gt; comm.Get_rank()
    mpi_test(rank)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello world from process&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, rank)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      使用mpi运行文件&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019103255696-1670523618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      在MPI中，并行程序中不同进程用一个非负整数来区别，如果我们有P个进程，那么rank会从0到P-1分配。&lt;/p&gt;
&lt;p&gt;      MPI拿到rank的函数如下：rank = comm.Get_rank()&lt;/p&gt;
&lt;p&gt;      这个函数返回调用它的进程的rank，comm叫做交流者，用于区别不同的进程集合：comm = MPI.COMM_WORLD&lt;/p&gt;
&lt;p&gt; 5、MPI点对点通讯&lt;/p&gt;
&lt;p&gt;      MPI提供的最实用的一个特性是点对点通讯。两个不同的进程之间可以通过点对点通讯交换数据：一个进程是接收者，一个进程是发送者。&lt;/p&gt;
&lt;p&gt;      Python的mpi4py通过下面两个函数提供了点对点通讯功能：&lt;/p&gt;
&lt;p&gt;      - Comm.Send(data, process_destination)：通过它在交流组中的排名来区分发送给不同进程的数据。&lt;/p&gt;
&lt;p&gt;      - Comm.Recv(process_source)：接收来自源进程的数据，也是通过在交流组中的排名来分分的。&lt;/p&gt;
&lt;p&gt;      Comm变量表示交流着，定义了可以互相通讯的进程组：&lt;/p&gt;
&lt;p&gt;      comm  = MKPI.COMM_WORLD&lt;/p&gt;
&lt;p&gt;      交换信息测试用例： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
rank &lt;/span&gt;=&lt;span&gt; comm.rank
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My rank is :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,rank)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank ==&lt;span&gt; 0:
    data &lt;/span&gt;= 10000000&lt;span&gt;
    destination_process &lt;/span&gt;= 4&lt;span&gt;
    comm.send(data, dest&lt;/span&gt;=&lt;span&gt;destination_process)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(data, destination_process))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 1&lt;span&gt;:
    destination_process &lt;/span&gt;= 8&lt;span&gt;
    data &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello,I am rank 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

    comm.send(data, dest&lt;/span&gt;=&lt;span&gt;destination_process)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(data, destination_process))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 4&lt;span&gt;:
    data &lt;/span&gt;= comm.recv(source=&lt;span&gt;0)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;data)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 8&lt;span&gt;:
    data1 &lt;/span&gt;= comm.recv(source=1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %data1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      运行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019115156873-2144384394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      通过mpiexec -n 9运行9个互相通讯的进程，使用rank的值来区分每个进程。&lt;/p&gt;
&lt;p&gt;      整个过程分为两部分，发送者发送数据，接收者接收数据，二者必须都指定发送方/接收方，source=为指定发送者。如果有发送的数据没有被接收，程序会阻塞。&lt;/p&gt;
&lt;p&gt;      comm.send()和comm.recv()函数都是阻塞的函数，他们会一直阻塞调用者，直到数据使用完成，同时在MPI中，有两种方式发送和接收数据：&lt;/p&gt;
&lt;p&gt;      - buffer模式&lt;/p&gt;
&lt;p&gt;      - 同步模式&lt;/p&gt;
&lt;p&gt;      在buffer模式中，只要需要发送的数据被拷贝到buffer中，执行权就会交回到主程序，此时数据并非已经发送/接收完成。在同步模式中，只有函数真正的结束发送/接收任务之后才会返回。&lt;/p&gt;

&lt;p&gt;6、避免死锁&lt;/p&gt;
&lt;p&gt;      mpi4py没有提供特定的功能来解决这种情况，但是提供了一些程序员必须遵守的规则来避免死锁的问题。&lt;/p&gt;
&lt;p&gt;      出现死锁的情况：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
rank &lt;/span&gt;=&lt;span&gt; comm.rank
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my rank is :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,rank)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 1&lt;span&gt;:
    data_send &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    destination_process &lt;/span&gt;= 5&lt;span&gt;
    source_process &lt;/span&gt;= 5&lt;span&gt;
    data_received &lt;/span&gt;= comm.recv(source=&lt;span&gt;source_process)
    comm.send(data_send, dest&lt;/span&gt;=&lt;span&gt;destination_process)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(data_send, destination_process))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;data_received)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 5&lt;span&gt;:
    data_send &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    destination_process &lt;/span&gt;= 1&lt;span&gt;
    source_process &lt;/span&gt;= 1&lt;span&gt;
    data_received &lt;/span&gt;= comm.recv(source=&lt;span&gt;source_process)
    comm.send(data_send, dest&lt;/span&gt;=&lt;span&gt;destination_process)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (data_send, destination_process))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % data_received)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      运行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019142616250-2089618437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      进程1和进程5产生阻塞，程序阻塞。&lt;/p&gt;
&lt;p&gt;      此时两个进程都在等待对方，发生阻塞，因为recv和send都是阻塞的，两个函数都先使用的recv，所以调用者都在等待他们完成。所以讲上述代码改为如下即可解决阻塞：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
rank &lt;/span&gt;=&lt;span&gt; comm.rank
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my rank is :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,rank)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 1&lt;span&gt;:
    data_send &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    destination_process &lt;/span&gt;= 5&lt;span&gt;
    source_process &lt;/span&gt;= 5&lt;span&gt;
    comm.send(data_send, dest&lt;/span&gt;=&lt;span&gt;destination_process)
    data_received &lt;/span&gt;= comm.recv(source=&lt;span&gt;source_process)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(data_send, destination_process))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;data_received)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 5&lt;span&gt;:
    data_send &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    destination_process &lt;/span&gt;= 1&lt;span&gt;
    source_process &lt;/span&gt;= 1&lt;span&gt;
    data_received &lt;/span&gt;= comm.recv(source=&lt;span&gt;source_process)
    comm.send(data_send, dest&lt;/span&gt;=&lt;span&gt;destination_process)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (data_send, destination_process))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % data_received)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      将其中一个函数的recv和send顺序调换。&lt;/p&gt;
&lt;p&gt;      运行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019142943065-39428718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      也可通过Sendrecv函数解决，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
rank &lt;/span&gt;=&lt;span&gt; comm.rank
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my rank is :&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,rank)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 1&lt;span&gt;:
    data_send &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    destination_process &lt;/span&gt;= 5&lt;span&gt;
    source_process &lt;/span&gt;= 5
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; comm.send(data_send, dest=destination_process)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; data_received = comm.recv(source=source_process)&lt;/span&gt;
    data_received = comm.sendrecv(data_send, dest=destination_process, source=&lt;span&gt;source_process)

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(data_send, destination_process))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;data_received)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank == 5&lt;span&gt;:
    data_send &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    destination_process &lt;/span&gt;= 1&lt;span&gt;
    source_process &lt;/span&gt;= 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; data_received = comm.recv(source=source_process)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; comm.send(data_send, dest=destination_process)&lt;/span&gt;
    data_received = comm.sendrecv(data_send, dest=destination_process, source=&lt;span&gt;source_process)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sending data %s to process %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (data_send, destination_process))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data received is = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % data_received)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      运行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019143401681-1836138641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、集体通讯：Broadcast&lt;/p&gt;
&lt;p&gt;      在并行代码的开发中，会经常需要在多个进程间共享某个变量运行时的值，或操作多个进程提供的变量。MPI库提供了在多个进程之间交换信息的方法，将所有进程变成通讯者的这种方法叫做集体交流。因此，一个集体交流通常是2个以上的进程，也可以称为广播——一个进程将消息发送给其他进程。mpi4py模块通过以下方式提供广播的功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
buf = comm.bcast(data_to_share, rank_of_root_process)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      这个函数将root消息中包含的信息发送给属于comm通讯组其他的进程，每个进程必须通过相同的root和comm来调用它。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019152911198-1562690982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
rank &lt;/span&gt;=&lt;span&gt; comm.Get_rank()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank ==&lt;span&gt; 0:
    variable_to_share &lt;/span&gt;= 100
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    variable_to_share &lt;/span&gt;=&lt;span&gt; None

variable_to_share &lt;/span&gt;= comm.bcast(variable_to_share, root=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;process = %d  variable shared = %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(rank, variable_to_share))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      运行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019155136898-1744479578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      rank等于0的root进程初始化了一个变量，variable_to_share，值为100，然后声明了一个广播variable_to_share = comm.bcast(variable_to_share, root=0)&lt;/p&gt;
&lt;p&gt;      这个变量将通过通讯组发送给其他进程。&lt;/p&gt;
&lt;p&gt;      集体通讯允许组中的多个进程同时进行数据交流。在mpi4py模块中，只提供了阻塞版本的集体通讯(阻塞调用者，直到缓存中的数据全部安全发送。)&lt;/p&gt;
&lt;p&gt;      广泛应用的集体通讯应该是：&lt;/p&gt;
&lt;p&gt;            - 组中的进程提供通讯的屏障&lt;/p&gt;
&lt;p&gt;            - 通讯方式包括：&lt;/p&gt;
&lt;p&gt;                  - 将一个进程的数据广播到组中其他进程中&lt;/p&gt;
&lt;p&gt;                  - 从其他进程收集数据发给一个进程&lt;/p&gt;
&lt;p&gt;                  - 从一个进程散播数据到其他进程中&lt;/p&gt;
&lt;p&gt;            - 减少操作&lt;/p&gt;
&lt;p&gt; 8、集体通讯：Scatter&lt;/p&gt;
&lt;p&gt;      scatter函数和广播很像，但是不同的是comm.bcast将相同的数据发送给所有在监听的进程，comm.scatter可以将数据放在数据中，发送给不同的进程。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019163936480-2146818012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      comm.scatter函数接收一个array，根据进程的rank将其中的元素发给不同的进程，第一个元素发送给进程0，第二个元素发给进程1，以此类推。&lt;/p&gt;
&lt;p&gt;      测试用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
rank &lt;/span&gt;=&lt;span&gt; comm.Get_rank()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; array_to_share = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;]&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; rank ==&lt;span&gt; 0:
    array_to_share &lt;/span&gt;= [0,1,2,3,4,5,6,7,8,9&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    array_to_share &lt;/span&gt;=&lt;span&gt; None

recvbuf &lt;/span&gt;= comm.scatter(array_to_share, root=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Process = %d  recvbuf = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(rank, recvbuf))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      执行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019164732535-399075072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      注意：列表中的元素个数，需要个进程保持一致。否则会出现如下错误。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019165002404-1395321471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 9、集体通讯：gather&lt;/p&gt;
&lt;p&gt;      gather函数基本上是反向的scatter，即收集所有进程发送到root进程数据。方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
recvbuf = comm.gather(sendbuf, rank_of_root_process)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      sendbuf是要发送的数据，rank_of_root_process代表要接收数据的进程。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019171441437-602087030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      测试用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI


comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
size &lt;/span&gt;=&lt;span&gt; comm.Get_size()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(size)&lt;/span&gt;
rank =&lt;span&gt; comm.Get_rank()
data &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;process %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;rank
&lt;/span&gt;&lt;span&gt;# print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;data)
data &lt;/span&gt;= comm.gather(data, root=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;# print&lt;/span&gt;&lt;span&gt;(data)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; rank ==&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rank = %s receiving data to other process&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;rank)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;, size):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;data[i] = (i+1) ** 2&lt;/span&gt;
        value =&lt;span&gt; data[i]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;process %s receiving %s from process %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(rank, value, i))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(data)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      执行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181019173941439-2146636800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 10、使用Alltoall通讯&lt;/p&gt;
&lt;p&gt;      Alltoall集体通讯结合了scatter和gather的功能。在mpi4py中，有以下三类的Alltoall集体通讯。&lt;/p&gt;
&lt;p&gt;      - comm.Alltoall(sendbuf, recvbuf);&lt;/p&gt;
&lt;p&gt;      - comm.Alltoallv(sendbuf, recvbuf);&lt;/p&gt;
&lt;p&gt;      - comm.Alltoallw(sendbuf, recvbuf);&lt;/p&gt;
&lt;p&gt;      Alltoall测试用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
size &lt;/span&gt;=&lt;span&gt; comm.Get_size()
rank &lt;/span&gt;=&lt;span&gt; comm.Get_rank()

a_size &lt;/span&gt;= 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;numpy arange: %s&quot; %numpy.arange(size, dtype=int))&lt;/span&gt;
senddata = (rank+1)*numpy.arange(size, dtype=&lt;span&gt;int)
recvdata &lt;/span&gt;= numpy.empty(size * a_size, dtype=&lt;span&gt;int)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;senddata is %s , recvdata is %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(senddata, recvdata))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;Recvdata is %s: , \n numpy.empty is %s&quot; %(recvdata, numpy.empty(size * a_size, dtype=int)))&lt;/span&gt;
&lt;span&gt;
comm.Alltoall(senddata, recvdata)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;process %s sending %s, receiving %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(rank, senddata, recvdata))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      运行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181022110509571-909374627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      comm.alltoall方法将task j的sendbuf的第j个对象拷贝到task i中，recvbuf的第j个对象，一一对应。发送过程如图：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181022110645667-278950697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      可以将左右两个方格看做xy轴，结果一一对应，如左图的(0,0)对应的值为0，其对应的有图的值为右图的(0,0)也为0。左图的3,4对应的值为16，右图(4,3)也为16。&lt;/p&gt;
&lt;p&gt;      P0包含的数据[0 1 2 3 4]，它将值0赋值给自己，1传给进程P1，2传给进程P2，3传给进程P3，以此类推。&lt;/p&gt;
&lt;p&gt;      相同的P1的数据为[0 2 4 6 8] ， 它将0传给P0，2传给P1，4传给P2，以此类推。&lt;/p&gt;
&lt;p&gt;      All-to-all定制通讯也叫全部交换，这种操作经常用于各种并发算法中，比如快速傅里叶变换，矩阵变换，样本排序以及一些数据库的 Join 操作。&lt;/p&gt;
&lt;p&gt; 11、简化操作&lt;/p&gt;
&lt;p&gt;      同comm.gather一样，comm.reduce接收一个数组，每一个元素是一个进程的输入，然后返回一个数组，每一个元素是进程的输出，返回给root进程。输出的元素包含了简化的结果。&lt;/p&gt;
&lt;p&gt;      简化定义如下：comm.Reduce(sendbuf, recvbuf, rank_of_root_process, op = type_of_reduction_operation)&lt;/p&gt;
&lt;p&gt;      这里需要注意的是，参数op和comm.gather不同，它代表你想应用在数据上的操作，mpi4py模块代表定义了一系列的简化操作，包括：&lt;/p&gt;
&lt;p&gt;      - MPI.MAX：返回最大的元素&lt;/p&gt;
&lt;p&gt;      - MPI.MIN：返回最小的元素&lt;/p&gt;
&lt;p&gt;      - MPI.SUM：对所有的元素相加&lt;/p&gt;
&lt;p&gt;      - MPI.PROD：对所有元素相乘&lt;/p&gt;
&lt;p&gt;      - MPI.LAND：对所有元素进行逻辑操作&lt;/p&gt;
&lt;p&gt;      - MPI.MAXLOC：返回最大值，以及拥有它的进程&lt;/p&gt;
&lt;p&gt;      - MPI.MINLOC：返回最小值，以及拥有它的进程&lt;/p&gt;
&lt;p&gt;      测试用例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; mpi4py &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MPI

comm &lt;/span&gt;=&lt;span&gt; MPI.COMM_WORLD
size &lt;/span&gt;=&lt;span&gt; comm.size
rank &lt;/span&gt;=&lt;span&gt; comm.rank
array_size &lt;/span&gt;= 3&lt;span&gt;
recvdata &lt;/span&gt;= np.zeros(array_size, dtype=&lt;span&gt;np.int)
senddata &lt;/span&gt;= (rank+1)*np.arange(size, dtype=&lt;span&gt;np.int)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+++++++++++++%s+++++++++++++%s++++++++++++&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(recvdata, senddata))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Process %s sending %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(rank, senddata))
comm.Reduce(senddata, recvdata, root&lt;/span&gt;=0, op=&lt;span&gt;MPI.SUM)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on task %s, after Reduce: data = %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(rank, recvdata))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      执行结果：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181022142700991-1309201219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      MPI.SUM为求和操作，过程如下：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201810/1095387-20181022143216420-1965465083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      简化操作将每个task的第i个元素相加，然后放回到P0进程(root进程)的第i个元素中。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 06:42:00 +0000</pubDate>
<dc:creator>杜先生的博客</dc:creator>
<og:description>1、基本概念 多进程库提供了Pool类来实现简单的多进程任务。Pool类有以下方法： - apply()：直到得到结果之前一直阻塞。 - apply_async()：这是apply()方法的一个变体，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dukuan/p/9811057.html</dc:identifier>
</item>
<item>
<title>Java 弱引用 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9829993.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9829993.html</guid>
<description>&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;弱引用是使用WeakReference创建的引用，弱引用也是用来描述非必需对象的，它是比软引用更弱的引用类型。在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;弱引用，从名字来看就很弱嘛，这种引用指向的对象，一旦在GC时被扫描到，就逃脱不了被回收的命运。&lt;/p&gt;
&lt;p&gt;但是，弱引用指向的对象也并不一定就马上会被回收，如果弱引用对象较大，直接进到了老年代，那么就可以苟且偷生到Full GC触发前，所以弱引用对象也可能存在较长的一段时间。一旦一个弱引用对象被垃圾回收器回收，便会加入到一个引用队列中（如果有的话）。&lt;/p&gt;
&lt;p&gt;弱引用对应的类为WeakReference，举个栗子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String s = new String(&quot;Frank&quot;);    
WeakReference&amp;lt;String&amp;gt; weakRef = new WeakReference&amp;lt;String&amp;gt;(s);
s = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们把s设置为null后，字符串对象便只有弱引用指向它。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;弱可达&lt;br/&gt;如果一个对象与GC Roots之间仅存在弱引用，则称这个对象为&lt;code&gt;弱可达(weakly reachable)&lt;/code&gt;对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;br/&gt;在垃圾回收器回收一个对象前，WeakReference类所提供的get方法会返回其引用对象的强引用，一旦垃圾回收器回收掉该对象之后，get方法将返回null。所以在获取弱引用对象的代码中，一定要判断是否为null，以免出现NullPointerException异常导致应用崩溃。&lt;/p&gt;
&lt;p&gt;下面的代码会让s再次持有对象的强引用：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;s = weakRef.get();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在weakRef包裹的对象被回收前，用强引用关联该对象，那这个对象又会变成强可达状态。&lt;/p&gt;
&lt;p&gt;来看一个简单的栗子了解一下WeakReference引用的对象是何时被回收的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeakReferenceTest {
    private static final List&amp;lt;Object&amp;gt; TEST_DATA = new LinkedList&amp;lt;&amp;gt;();
    private static final ReferenceQueue&amp;lt;TestClass&amp;gt; QUEUE = new ReferenceQueue&amp;lt;&amp;gt;();

    public static void main(String[] args) {
        TestClass obj = new TestClass(&quot;Test&quot;);
        WeakReference&amp;lt;TestClass&amp;gt; weakRef = new WeakReference&amp;lt;&amp;gt;(obj, QUEUE);
        //可以重新获得OOMClass对象，并用一个强引用指向它
        //oomObj = weakRef.get();

        // 该线程不断读取这个弱引用，并不断往列表里插入数据，以促使系统早点进行GC
        new Thread(() -&amp;gt; {
            while (true) {
                TEST_DATA.add(new byte[1024 * 100]);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    Thread.currentThread().interrupt();
                }
                System.out.println(weakRef.get());
            }
        }).start();

        // 这个线程不断读取引用队列，当弱引用指向的对象呗回收时，该引用就会被加入到引用队列中
        new Thread(() -&amp;gt; {
            while (true) {
                Reference&amp;lt;? extends TestClass&amp;gt; poll = QUEUE.poll();
                if (poll != null) {
                    System.out.println(&quot;--- 弱引用对象被jvm回收了 ---- &quot; + poll);
                    System.out.println(&quot;--- 回收对象 ---- &quot; + poll.get());
                }
            }
        }).start();

        //将强引用指向空指针 那么此时只有一个弱引用指向TestClass对象
        obj = null;

        try {
            Thread.currentThread().join();
        } catch (InterruptedException e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

    static class TestClass {
        private String name;

        public TestClass(String name) {
            this.name = name;
        }

        @Override
        public String toString() {
            return &quot;TestClass - &quot; + name;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置一下虚拟机参数：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;-verbose:gc -Xms4m -Xmx4m -Xmn2m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[GC (Allocation Failure)  1017K-&amp;gt;464K(3584K), 0.0014345 secs]
[GC (Allocation Failure)  1483K-&amp;gt;536K(3584K), 0.0017221 secs]
[GC (Allocation Failure)  1560K-&amp;gt;648K(3584K), 0.0036572 secs]
TestClass - Test
TestClass - Test
TestClass - Test
[GC (Allocation Failure)  1621K-&amp;gt;984K(3584K), 0.0011455 secs]
--- 弱引用对象被jvm回收了 ---- java.lang.ref.WeakReference@51a947fe
--- 回收对象 ---- null
null
...省略n个null和几次GC信息
[Full GC (Ergonomics)  2964K-&amp;gt;2964K(3584K), 0.0025450 secs]
[Full GC (Allocation Failure)  2964K-&amp;gt;2964K(3584K), 0.0021907 secs]
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid6860.hprof ...
Heap dump file created [3912229 bytes in 0.011 secs]
Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space
    at weakhashmap.WeakReferenceTest.lambda$main$0(WeakReferenceTest.java:22)
    at weakhashmap.WeakReferenceTest$$Lambda$1/764977973.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:748)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，其实弱引用也并不是一发生GC就被回收掉了。&lt;/p&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;p&gt;如果一个对象仅仅是偶尔使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来引用该对象。&lt;/p&gt;
&lt;p&gt;弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;一般来说，很少直接使用WeakReference，而是使用WeakHashMap。在WeakHashMap中，内部有一个引用队列，插入的元素会被包裹成WeakReference，并加入队列中，用来做缓存再合适不过。&lt;/p&gt;
&lt;p&gt;在Tomcat的缓存中，其实就用到了WeakHashMap：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final class ConcurrentCache&amp;lt;K,V&amp;gt; {
    private final int size;
    private final Map&amp;lt;K,V&amp;gt; eden;
    private final Map&amp;lt;K,V&amp;gt; longterm;

    public ConcurrentCache(int size) {
        this.size = size;
        this.eden = new ConcurrentHashMap&amp;lt;&amp;gt;(size);
        this.longterm = new WeakHashMap&amp;lt;&amp;gt;(size);
    }

    public V get(K k) {
        // 先从eden中取
        V v = this.eden.get(k);
        if (v == null) {
            // 如果取不到再从longterm中取
            synchronized (longterm) {
                v = this.longterm.get(k);
            }
            // 如果取到则重新放到eden中
            if (v != null) {
                this.eden.put(k, v);
            }
        }
        return v;
    }

    public void put(K k, V v) {
        if (this.eden.size() &amp;gt;= size) {
            // 如果eden中的元素数量大于指定容量，将所有元素放到longterm中
            synchronized (longterm) {
                this.longterm.putAll(this.eden);
            }
            this.eden.clear();
        }
        this.eden.put(k, v);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有eden和longterm的两个map，如果对jvm堆了解的话，可以看出tomcat在这里是使用ConcurrentHashMap和WeakHashMap做了类似分代缓存的操作。&lt;/p&gt;
&lt;p&gt;在put方法里，在插入键值对时，先检查eden缓存的容量是否超出设定的大小。如果没有则直接放入eden缓存，如果超了则锁定longterm将eden中所有的键值对都放入longterm。再将eden清空并插入该键值对。&lt;/p&gt;
&lt;p&gt;在get方法中，也是优先从eden中找对应的key，如果没有则进入longterm缓存中查找，找到后就加入eden缓存并返回。&lt;/p&gt;
&lt;p&gt;经过这样的设计，相对常用的对象都能在eden缓存中找到，不常用（有可能被销毁的对象）的则进入longterm缓存。而longterm的key的实际对象没有其他引用指向它时，gc就会自动回收heap中该弱引用指向的实际对象，并将弱引用放入其引用队列中。&lt;/p&gt;
&lt;h2 id=&quot;弱引用与软引用对比&quot;&gt;弱引用与软引用对比&lt;/h2&gt;
&lt;p&gt;弱引用与软引用的区别在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只具有弱引用的对象拥有更短暂的生命周期。&lt;/li&gt;
&lt;li&gt;被垃圾回收器回收的时机不一样，在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。而被软引用关联的对象只有在内存不足时才会被回收。&lt;/li&gt;
&lt;li&gt;弱引用不会影响GC，而软引用会一定程度上对GC造成影响。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相似之处：都是用来描述非必需对象的。&lt;/p&gt;
&lt;p&gt;那么什么时候用SoftReference，什么时候用WeakReference呢？&lt;/p&gt;
&lt;p&gt;如果缓存的对象是比较大的对象，使用频率相对较高的对象，那么使用SoftReference会更好，因为这样能让缓存对象有更长的生命周期。&lt;/p&gt;
&lt;p&gt;如果缓存对象都是比较小的对象，使用频率一般或者相对较低，那么使用WeakReference会更合适。&lt;/p&gt;
&lt;p&gt;当然，如果实在不知道选哪个，一般而言，用作缓存时使用WeakHashMap都不会有太大问题。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;弱引用是比软引用更弱的引用类型&lt;/li&gt;
&lt;li&gt;弱引用不能延长对象的生命周期，一旦对象只剩下弱引用，它就随时可能会被回收&lt;/li&gt;
&lt;li&gt;可以通过弱引用获取对象的强引用&lt;/li&gt;
&lt;li&gt;弱引用适合用作缓存&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 22 Oct 2018 06:41:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<og:description>定义 弱引用是使用WeakReference创建的引用，弱引用也是用来描述非必需对象的，它是比软引用更弱的引用类型。在发生GC时，只要发现弱引用，不管系统堆空间是否足够，都会将对象进行回收。 说明 弱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9829993.html</dc:identifier>
</item>
<item>
<title>Spring Boot与Logback的运用（自定义异常+AOP） - Mr.chengJQ</title>
<link>http://www.cnblogs.com/qiyuan880794/p/9829854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyuan880794/p/9829854.html</guid>
<description>&lt;p&gt;在开发以及调试过程中，程序员对日志的需求是非常大的，出了什么问题，都要通过日志去进行排查，但是如果日志不清或者杂乱无章，则不利于维护&lt;/p&gt;
&lt;p&gt;这边就比较详细的列举几种类型的日志，供大家参考&lt;/p&gt;
&lt;p&gt;首先明白logback日志是Spring Boot自带的，不需要引入额外的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;logback-access&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${logback.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${logback.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${logback.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点进pom里的核心依赖，就能看见上面几个，是由Spring Boot自动依赖配置好的，我们只要直接使用就好了&lt;/p&gt;
&lt;p&gt;比较简单的是直接在application的配置文件里 写参数配置就行了，他提供了日志级别，日志输出路径等，也能满足基本的日志输出&lt;/p&gt;
&lt;p&gt;我们这通过xml文件进行配置 logback-spring.xml&lt;/p&gt;
&lt;p&gt;这样就能直接引用到xml了，但是为什么能引用到了&lt;/p&gt;
&lt;p&gt;就是在logback里有个默认的机制，内部会有几种标准的文件格式，在LogbackLoggingSystem里标注了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String[] getStandardConfigLocations() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[] { &quot;logback-test.groovy&quot;, &quot;logback-test.xml&quot;, &quot;logback.groovy&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;logback.xml&quot;&lt;span&gt; };
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以最为标准的为这里面的四种文件格式，但是如果项目中没有，他还提供了扩展文件格式 就是在后面拼上-spring，例如logback.xml 扩展为logback-spring.xml&lt;/p&gt;
&lt;p&gt;ok&lt;/p&gt;
&lt;p&gt;下面看下xml里面的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration debug=&quot;false&quot;&amp;gt;
    &amp;lt;!--定义日志文件的存储地址 可以在LogBack 的配置中使用相对路径--&amp;gt;
    &amp;lt;property name=&quot;LOG_HOME&quot; value=&quot;logs&quot; /&amp;gt;
    

    &amp;lt;!-- 彩色日志 --&amp;gt;
    &amp;lt;!-- 彩色日志依赖的渲染类 --&amp;gt;
    &amp;lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&amp;gt;
    &amp;lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&amp;gt;
    &amp;lt;conversionRule conversionWord=&quot;wEx&quot;&lt;span&gt;
                    converterClass&lt;/span&gt;=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&amp;gt;
    &amp;lt;!-- 彩色日志格式 --&amp;gt;
    &amp;lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;&lt;span&gt;
              value&lt;/span&gt;=&quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot; /&amp;gt;
    &amp;lt;!-- Console 输出设置 --&amp;gt;
    &amp;lt;appender name=&quot;CONSOLE&quot; &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;${CONSOLE_LOG_PATTERN}&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;utf8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 按照每天生成日志文件 --&amp;gt;
    &amp;lt;appender name=&quot;FILE&quot;  &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!--日志文件输出的文件名--&amp;gt;
            &amp;lt;FileNamePattern&amp;gt;${LOG_HOME}/category-server-log.%d{yyyy-MM-dd}.log&amp;lt;/FileNamePattern&amp;gt;
            &amp;lt;!--日志文件保留天数--&amp;gt;
            &amp;lt;MaxHistory&amp;gt;30&amp;lt;/MaxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;encoder &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt;
            &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&amp;gt;
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
        &amp;lt;!--&lt;span&gt;日志文件最大的大小
        &lt;/span&gt;&amp;lt;triggeringPolicy &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&amp;gt;
            &amp;lt;MaxFileSize&amp;gt;10MB&amp;lt;/MaxFileSize&amp;gt;
        &amp;lt;/triggeringPolicy&amp;gt;--&amp;gt;
        &amp;lt;filter &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;WARN&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;DENY&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;NEUTRAL&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;filter &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;ERROR&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;DENY&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;NEUTRAL&amp;lt;/onMismatch&amp;gt;
        &amp;lt;/filter&amp;gt;

    &amp;lt;/appender&amp;gt;

    &amp;lt;!-- 出错日志 appender  --&amp;gt;
    &amp;lt;appender name=&quot;ERROR_FILE&quot; &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!-- 按天回滚 daily --&amp;gt;
            &amp;lt;!-- log.dir 在maven profile里配置 --&amp;gt;
            &amp;lt;FileNamePattern&amp;gt;${LOG_HOME}/category-server-error-log.%d{yyyy-MM-dd}.log&amp;lt;/FileNamePattern&amp;gt;
            &amp;lt;!-- 日志最大的历史 60天 --&amp;gt;
            &amp;lt;maxHistory&amp;gt;60&amp;lt;/maxHistory&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;filter &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;WARN&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;encoder&amp;gt;
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&amp;lt;/pattern&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
    
    &amp;lt;!-- 自己打印的日志文件，用于记录重要日志信息 --&amp;gt;
    &amp;lt;appender name=&quot;MY_INFO_FILE&quot;  &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;rollingPolicy &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&amp;gt;
            &amp;lt;!--日志文件输出的文件名--&amp;gt;
            &amp;lt;FileNamePattern&amp;gt;${LOG_HOME}/category-server-myinfo-log.%d{yyyy-MM-dd}.%i.log&amp;lt;/FileNamePattern&amp;gt;
            &amp;lt;!--日志文件保留天数--&amp;gt;
            &amp;lt;MaxHistory&amp;gt;15&amp;lt;/MaxHistory&amp;gt;
            &amp;lt;!--日志文件最大的大小--&amp;gt;
            &amp;lt;MaxFileSize&amp;gt;10MB&amp;lt;/MaxFileSize&amp;gt;
        &amp;lt;/rollingPolicy&amp;gt;
        &amp;lt;filter &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;DEBUG&amp;lt;/level&amp;gt;
            &amp;lt;onMatch&amp;gt;ACCEPT&amp;lt;/onMatch&amp;gt;
            &amp;lt;onMismatch&amp;gt;DENY&amp;lt;/onMismatch&amp;gt;  
        &amp;lt;/filter&amp;gt;
        &amp;lt;encoder &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&amp;gt;
            &amp;lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&amp;gt;
            &amp;lt;pattern&amp;gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&amp;lt;/pattern&amp;gt;
            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;
        &amp;lt;/encoder&amp;gt;
    &amp;lt;/appender&amp;gt;
    &amp;lt;logger name=&quot;my_info&quot; additivity=&quot;true&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;MY_INFO_FILE&quot;/&amp;gt;
    &amp;lt;/logger&amp;gt;
    &amp;lt;!--myibatis log configure--&amp;gt;
    &amp;lt;logger name=&quot;com.example.demo&quot; level=&quot;TRACE&quot;/&amp;gt;
    &amp;lt;logger name=&quot;java.sql.Connection&quot; level=&quot;DEBUG&quot;/&amp;gt;
    &amp;lt;logger name=&quot;java.sql.Statement&quot; level=&quot;DEBUG&quot;/&amp;gt;
    &amp;lt;logger name=&quot;java.sql.PreparedStatement&quot; level=&quot;DEBUG&quot;/&amp;gt;
        &amp;lt;!-- 日志输出级别 --&amp;gt;
        &amp;lt;root level=&quot;INFO&quot;&amp;gt;
            &amp;lt;appender-ref ref=&quot;CONSOLE&quot; /&amp;gt;
            &amp;lt;appender-ref ref=&quot;FILE&quot; /&amp;gt;
            &amp;lt;appender-ref ref=&quot;ERROR_FILE&quot; /&amp;gt;
        &amp;lt;/root&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里一共有四块内容，第一是console的日志输出，第二是系统运行日志，第三是警告以上的日志输出（基本上是程序出错日志），第四种是自定义日志&lt;/p&gt;
&lt;p&gt;每一块日志由一个appender标签引入&lt;/p&gt;
&lt;p&gt;CONSOLE是控制台日志输出，只要规定个格式就行了&lt;/p&gt;
&lt;p&gt;FILE是系统运行日志，系统的所有运行信息都会保留，正常我们会把这部分信息保存在硬盘日志文件中，按天按文件大小保存，因为这个内容实在是比较多&lt;/p&gt;
&lt;p&gt;ERROR_FILE是WARN级别以上的日志，这块是开发人员和运维人员最多关注的，因为基本上所有的bug都会在这个里面体现&lt;/p&gt;
&lt;p&gt;MY_INFO_FILE是自定义日志，想定义自己的日志文件，记录一些重要的信息&lt;/p&gt;
&lt;p&gt;这里的日志都是以文件的形式保存在本地，当然像WARN级别以上日志可以异步保存到数据库&lt;/p&gt;

&lt;p&gt;日志文件定义好后，接下来就要开始定义业务逻辑了&lt;/p&gt;
&lt;p&gt;在针对一些异常日志，我们想尽可能完整准确的抛出异常，一眼就能知道是什么问题，这里我们就需要自定义异常，最多的就是像空指针，数组越界等常见异常&lt;/p&gt;
&lt;p&gt;定义基础异常类BaseException继承他的父类RuntimeException&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseException &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RuntimeException {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseException() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BaseException(String message, Throwable cause, &lt;span&gt;boolean&lt;/span&gt; enableSuppression, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; writableStackTrace) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause, enableSuppression, writableStackTrace);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseException(String message, Throwable cause) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message, cause);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseException(String message) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(message);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseException(Throwable cause) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(cause);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }
    
    
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后全局异常处理类：GlobalExceptionHandler&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@CrossOrigin
@RestControllerAdvice
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GlobalExceptionHandler{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(GlobalExceptionHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String APPLICATION_JSON = &quot;application/json&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String UTF_8 = &quot;UTF-8&quot;&lt;span&gt;;
     
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * BaseException 处理类
    * @Title: HandleBaseException  
    * @Description: TODO
    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt; &lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e
    * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt; &lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
    * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; ResponseMsg
    * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @ExceptionHandler(BaseException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseMsg HandleBaseException(RuntimeException e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只能输出捕获到的异常，未捕获到的异常不输出到日志，或者通过aop拦截器拦截所有方法&lt;/span&gt;
&lt;span&gt;        LOGGER.error(getExceptionDetail(e));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回失败信息&lt;/span&gt;
        Route route = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Route();
        ResponseMsg responseMsg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResponseMsg(route,ReturnMsgEnum.INTERNAL_ERROR.getCode(),
                 ReturnMsgEnum.INTERNAL_ERROR.getMsg(), &lt;/span&gt;&quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseMsg;
    }
    
    @ExceptionHandler(GlobalException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseMsg HandleGlobalException(Exception e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只能输出捕获到的异常，未捕获到的异常不输出到日志，或者通过aop拦截器拦截所有方法&lt;/span&gt;
&lt;span&gt;        LOGGER.error(getExceptionDetail(e));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回失败信息&lt;/span&gt;
        Route route = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Route();
        ResponseMsg responseMsg &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResponseMsg(route,ReturnMsgEnum.INTERNAL_ERROR.getCode(),
                 ReturnMsgEnum.INTERNAL_ERROR.getMsg(), &lt;/span&gt;&quot;系统未捕获该异常&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseMsg;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getExceptionDetail(Exception e) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuffer(e.toString() + &quot;\n&quot;&lt;span&gt;);
        StackTraceElement[] messages &lt;/span&gt;=&lt;span&gt; e.getStackTrace();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; messages.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
            stringBuffer.append(&lt;/span&gt;&quot;\t&quot;+messages[i].toString()+&quot;\n&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stringBuffer.toString();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;span&gt;@RestControllerAdvice:表明他是一个Controller 并且是异常拦截的统一处理类&lt;br/&gt;定义针对自定义异常的处理方法：用&lt;/span&gt;@ExceptionHandler(BaseException.class)注解标注&lt;br/&gt;BaseException就是刚才的自定义异常&lt;br/&gt;之后所有抛出的BaseException都会由他处理&lt;p&gt;自定义异常我们都能轻松捕获到了，并且输出到日志里了&lt;/p&gt;&lt;p&gt;如果有些异常我们没有捕获到，我们就可以定义一个切面，让所有方法都经过这个切面处理
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 处理未捕获到的异常
* @ClassName: SpringAOP  
* &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Mr.Chengjq
* @date 2018年10月17日  
* @Description: TODO
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringAOP {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger = LoggerFactory.getLogger(SpringAOP.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
     
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定义切点Pointcut
     * 第一个*号：表示返回类型， *号表示所有的类型
     * 第二个*号：表示类名，*号表示所有的类
     * 第三个*号：表示方法名，*号表示所有的方法
     * 后面括弧里面表示方法的参数，两个句点表示任何参数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Pointcut(&lt;/span&gt;&quot;execution(* com.example.demo..*.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; executionService() {
 
    }
 
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法调用之前调用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; joinPoint
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Before(value &lt;/span&gt;= &quot;executionService()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doBefore(JoinPoint joinPoint){
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加日志打印&lt;/span&gt;
        String requestId =&lt;span&gt; String.valueOf(UUID.randomUUID());
        MDC.put(&lt;/span&gt;&quot;requestId&quot;&lt;span&gt;,requestId);
        logger.info(&lt;/span&gt;&quot;=====&amp;gt;@Before：请求参数为：{}&quot;&lt;span&gt;,Arrays.toString(joinPoint.getArgs()));
 
    }
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法之后调用
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; joinPoint
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; returnValue 方法返回值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @AfterReturning(pointcut &lt;/span&gt;= &quot;executionService()&quot;,returning=&quot;returnValue&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  doAfterReturning(JoinPoint joinPoint,Object returnValue){
 
        logger.info(&lt;/span&gt;&quot;=====&amp;gt;@AfterReturning：响应参数为：{}&quot;&lt;span&gt;,returnValue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理完请求，返回内容&lt;/span&gt;
&lt;span&gt;        MDC.clear();
    }
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 统计方法执行耗时Around环绕通知
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; joinPoint
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Around(&lt;/span&gt;&quot;executionService()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object timeAround(ProceedingJoinPoint joinPoint) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable{
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始执行的时间&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义返回对象、得到方法需要的参数&lt;/span&gt;
        Object obj = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object[] args = joinPoint.getArgs();&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            obj &lt;/span&gt;=&lt;span&gt; joinPoint.proceed();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: handle exception&lt;/span&gt;
&lt;span&gt;            logger.error(getExceptionDetail(e));
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GlobalException();
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取执行结束的时间&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; endTime =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String methodName = signature.getDeclaringTypeName() + &quot;.&quot; + signature.getName();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印耗时的信息&lt;/span&gt;
        logger.info(&quot;=====&amp;gt;处理本次请求共耗时：{} ms&quot;,endTime-&lt;span&gt;startTime);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getExceptionDetail(Throwable e) {
        StringBuffer stringBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuffer(e.toString() + &quot;\n&quot;&lt;span&gt;);
        StackTraceElement[] messages &lt;/span&gt;=&lt;span&gt; e.getStackTrace();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; messages.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
            stringBuffer.append(&lt;/span&gt;&quot;\t&quot;+messages[i].toString()+&quot;\n&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stringBuffer.toString();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;这个切面里未捕获到的异常也全部做特定处理&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 22 Oct 2018 06:21:00 +0000</pubDate>
<dc:creator>Mr.chengJQ</dc:creator>
<og:description>在开发以及调试过程中，程序员对日志的需求是非常大的，出了什么问题，都要通过日志去进行排查，但是如果日志不清或者杂乱无章，则不利于维护 这边就比较详细的列举几种类型的日志，供大家参考 首先明白logba</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyuan880794/p/9829854.html</dc:identifier>
</item>
<item>
<title>Kafka 入门三问 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9829742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9829742.html</guid>
<description>&lt;p&gt;当我在学习一个新技术的时候， 入门阶段， 基本上都遵循&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;是什么-&amp;gt;为什么-&amp;gt;怎么用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样的原则。&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;1.1 背景&lt;/h2&gt;
&lt;p&gt;Kafka 最初是 LinkedIn 的一个内部基础设施系统， 后续捐赠给了 Apache, 目前是 Apache 的一个顶级项目。&lt;/p&gt;
&lt;h2 id=&quot;定位&quot;&gt;1.2 定位&lt;/h2&gt;
&lt;p&gt;在官网中， 现定位是&lt;strong&gt;分布式流处理平台&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;可以让你发布和订阅流式的记录。这一方面与消息队列或者企业消息系统类似&lt;/li&gt;
&lt;li&gt;可以储存流式的记录，并且有较好的容错性&lt;/li&gt;
&lt;li&gt;可以在流式记录产生时就进行处理&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;它可以用于两大类别的应用:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;构造实时流数据管道，它可以在系统或应用之间可靠地获取数据。 (相当于message queue)&lt;/li&gt;
&lt;li&gt;构建实时流式应用程序，对这些流数据进行转换或者影响。 (就是流处理，通过kafka stream topic和topic之间内部进行变化)&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;OK, 暂时了解这些就够了。&lt;/p&gt;
&lt;h2 id=&quot;产生的原因&quot;&gt;1.3 产生的原因&lt;/h2&gt;
&lt;p&gt;Kafka 产生的原因， 与其他类似的系统产生的原因相似。&lt;/p&gt;
&lt;p&gt;在日常的程序中， 我们除了需要处理业务逻辑之外， 还需要对我们的程序进行一些额外的工作， 举个两类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;业务系统和应用程序的性能监控指标数据。&lt;/li&gt;
&lt;li&gt;用户操作行为数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;刚开始， 类似此类情况我们可以让程序直接连接到度量显示度量指标的应用程序上， 通过此连接将相应的数据推送过去， 进行显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135023857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;基础监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是比较基础的方案。 后面， 随着需求的增长， 需要分析更长时间片段的度量指标， 原先的一个性能监控服务器满足不了需求， 我们又增加了一台性能监控服务器。 在后面， 我们又多了几个应用， 又陆续增加了很多监控相关的服务器。 后续由于各种原因， 又增加了很多服务器。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135050728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;多数据监控&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显得一团糟糕。 此时， 维护成本就增加了。 因此， 我们决定进行改进， 专门做一个应用程序进行采集， 并给其他系统进行查询。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135111877?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;简单的发布与订阅系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时， 一个发布与订阅的系统就建成了。&lt;/p&gt;
&lt;p&gt;那这只是度量指标的一个系统， 公司还有其他的， 比如日志， 用户行为跟踪， 如果都使用相同的方式创建这些系统， 则系统就变成这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135136881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;多发布与订阅系统&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着公司规模的增长， 需要搭建类似的系统越来越多， 相应又需要付出很多维护成本。同时， 系统之间的无法实现交互。&lt;/p&gt;
&lt;p&gt;很显然， 我们需要对这些系统进行大一统， 同时进行改进。&lt;/p&gt;
&lt;p&gt;因此， Kafka 就诞生了。&lt;/p&gt;
&lt;p&gt;Kafka 在设计之初的目标：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;为生产者和消费者提供一套简单的 API。&lt;/li&gt;
&lt;li&gt;降低网络传输和磁盘存储开销；&lt;/li&gt;
&lt;li&gt;具有高伸缩架构&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;很显然， 这 3 点目标都做到了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135214375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;Kafka&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;kafka-有哪些特征&quot;&gt;1.4 Kafka 有哪些特征&lt;/h2&gt;
&lt;h3 id=&quot;消息和批次&quot;&gt;消息和批次&lt;/h3&gt;
&lt;p&gt;消息： Kafka 的数据单元。 一条消息在 Kafka 中可以看出数据库中的一条记录。 消息由字节数组组成， 对应有一个键， 键是在消息以可控的方式写入到分区时需要用到的。&lt;/p&gt;
&lt;p&gt;批次： 一组消息， 这些消息属于同一个主题和分析。 如果每个消息但单独传输， 会大致大量的网络开销， 分批次传输可以降低。 但批次越大， 对应单位时间内需要处理的消息越多， 单个消息的传输时间越长。&lt;/p&gt;
&lt;h3 id=&quot;模式&quot;&gt;模式&lt;/h3&gt;
&lt;p&gt;消息在 Kafka 中以字节数组存储， 因此， 如果我们以额外的结构来定义这些消息， 就可以让消息更好的被理解。&lt;/p&gt;
&lt;p&gt;如 JSON, XML, 大家都很熟悉， 用起来也不错。 但在 Kafka 中推荐使用 Apache Avro， 是 Hadoop 的一款序列化的框架。&lt;/p&gt;
&lt;h3 id=&quot;主题和分区&quot;&gt;主题和分区&lt;/h3&gt;
&lt;p&gt;Kafka 的消息通过主题进行分类。 主题就好比数据库的表， 或者系统文件中的文件夹。&lt;/p&gt;
&lt;p&gt;主题可以被分为若干分区， 一个分区就是一个提交日志。 通过分区， Kafka 可以实现数据的冗余和伸缩性。 同时， 分区可以在不同的服务器上， 达到一个主题跨越多个服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135243431?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;分区&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，offset用来唯一的标识分区中每一条记录。&lt;/p&gt;
&lt;p&gt;在每一个消费者中唯一保存的元数据是offset（偏移量）即消费在log中的位置.偏移量由消费者所控制:通常在读取记录后，消费者会以线性的方式增加偏移量，但是实际上，由于这个位置由消费者控制，所以消费者可以采用任何顺序来消费记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135313737?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;消费者offset&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息以追加的方式写入分区， 然后以先入先出的顺序读取。 由于分区的存在， 无法保证主题消息的顺序， 但可以保证单个分区的顺序。&lt;/p&gt;
&lt;h3 id=&quot;生产者和消费者&quot;&gt;生产者和消费者&lt;/h3&gt;
&lt;p&gt;Kafka 的客户端就是 Kafka 的系统用户， 可以被分成两类： 生产者和消费者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者&lt;/strong&gt;产生消息。 一般情况下， 一个消息会被发布到一个主题上。 在默认情况下， 生产者会把消息均衡的分布到主题的所有分区中， 不需要关心特定消息具体在哪个区。 但在某些情况下， 生产者会把消息直接写到指定的分区。 通常是通过分区器和键来实现的， 分区器为键生成一个散列， 并将其映射到指定的分区上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消费者&lt;/strong&gt;订阅消息。 消费者订阅一个或多个主题， 并按照消息生成的顺序读取它们。 消费者使用一个消费组 名称来进行标识，即会有一个或多个消费者共同读取一个主题。 群组用来保证每个分区只能被一个消费者使用（但一个消费者可以消费多个分区）。 消费者和分区的映射， 通常称之为所有权关系。&lt;/p&gt;
&lt;h3 id=&quot;broker-和-集群&quot;&gt;broker 和 集群&lt;/h3&gt;
&lt;p&gt;broker 是一个独立的 Kafka 服务器。 broker 接收来自生产者的消息， 为消息设置偏移量， 并提交到磁盘中保存。 broker 为消费者提供服务， 对读取扥去的请求作出响应， 返回磁盘上的消息。 单个 broker 可以轻松处理数千分区和每秒百万级的消息量。&lt;/p&gt;
&lt;p&gt;broker 是集群的组成部分。 每个集群有一个 broker 同时充当了集群控制器的角色。 负责将分区分配给 broker 和监控 broker。 在集群中， 一个分区从属于一个broker, 该 broker 被称为分区的首领。&lt;/p&gt;
&lt;h2 id=&quot;kafka-可以做什么&quot;&gt;1.5 Kafka 可以做什么&lt;/h2&gt;
&lt;h3 id=&quot;kafka作为消息系统&quot;&gt;Kafka作为消息系统&lt;/h3&gt;
&lt;p&gt;Kafka 作为一款优秀的消息系统， 具有高吞吐量， 内置的分区， 备份冗余分布式等特点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的消息队列&lt;/strong&gt;：在队列中，消费者池从server读取数据，每条记录被池子中的一个消费者消费， 但队列队列不是多订阅者模式的—一旦一个进程读取了数据，数据就会被丢弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;发布-订阅系统&lt;/strong&gt;： 记录被广播到所有的消费者。 发布-订阅系统允许你广播数据到多个进程，但是无法进行扩展处理，因为每条消息都会发送给所有的订阅者&lt;/p&gt;
&lt;p&gt;Kafka 消息队列， 在队列中，消费组允许你将处理过程分发给一系列进程(消费组中的成员)。 在发布订阅中，Kafka允许你将消息广播给多个消费组。&lt;/p&gt;
&lt;h3 id=&quot;kafka-作为存储系统&quot;&gt;Kafka 作为存储系统&lt;/h3&gt;
&lt;p&gt;数据写入Kafka后被写到磁盘，并且进行备份以便容错。直到完全备份，Kafka才让生产者认为完成写入，即使写入失败Kafka也会确保继续写入&lt;/p&gt;
&lt;p&gt;Kafka使用磁盘结构，具有很好的扩展性—50kb和50TB的数据在server上表现一致。&lt;/p&gt;
&lt;p&gt;可以存储大量数据，并且可通过客户端控制它读取数据的位置，您可认为Kafka是一种高性能、低延迟、具备日志存储、备份和传播功能的分布式文件系统。&lt;/p&gt;
&lt;h3 id=&quot;kafka用做流处理&quot;&gt;Kafka用做流处理&lt;/h3&gt;
&lt;p&gt;Kafka 流处理不仅仅用来读写和存储流式数据，它最终的目的是为了能够进行实时的流处理。&lt;/p&gt;
&lt;p&gt;将 Kafka 已收集的数据提供给其他流式计算框架进行处理。&lt;/p&gt;
&lt;h3 id=&quot;批处理&quot;&gt;批处理&lt;/h3&gt;
&lt;p&gt;通过组合存储和低延迟订阅，流式应用程序可以以同样的方式处理过去和未来的数据。 一个单一的应用程序可以处理历史记录的数据，并且可以持续不断地处理以后到达的数据，而不是在到达最后一条记录时结束进程&lt;/p&gt;

&lt;h2 id=&quot;多个生产者&quot;&gt;2.1 多个生产者&lt;/h2&gt;
&lt;p&gt;Kafka 支持多个生产者， 不管客户端在使用单个主题还是多个主题。&lt;/p&gt;
&lt;h2 id=&quot;多个消费者&quot;&gt;2.2 多个消费者&lt;/h2&gt;
&lt;p&gt;Kafka 支持多个消费者从一个单独的流系统上读取数据。 而且消费者之间互不影响。 多个消费者组成一个群组， 共享一个消息流， 并保证整个群主对每个给定消息只处理一次。&lt;/p&gt;
&lt;h2 id=&quot;磁盘数据存储&quot;&gt;2.3 磁盘数据存储&lt;/h2&gt;
&lt;p&gt;Kafka 不仅支持多个消费者， 还允许消费者非实时地读取消息， 这要归功于 Kafka 的数据保留特性。 每个主题可以单独设置保留规则， 以便满足不同消费者的需求。 同时， 消费者可能因为处理速度慢或突发的流量高峰导致无法及时读取消息， 持久化可以保证数据不会丢失。&lt;/p&gt;
&lt;h2 id=&quot;伸缩性&quot;&gt;2.4 伸缩性&lt;/h2&gt;
&lt;p&gt;用户可以开始时只使用单个 broker， 后续随着数据量的增加， 不断的增加 broker 的数量。 多个 broker 可以很好的进行容错，容灾处理。&lt;/p&gt;
&lt;h2 id=&quot;高性能&quot;&gt;2.5 高性能&lt;/h2&gt;
&lt;p&gt;通过进行横向扩展生产者， 消费者和 broker, Kafka 可以轻松的处理巨大的数据流。&lt;/p&gt;

&lt;p&gt;我这次的使用安装是在 windows 上的（单机版）。&lt;/p&gt;
&lt;h2 id=&quot;安装-jdk&quot;&gt;3.1 安装 JDK&lt;/h2&gt;
&lt;p&gt;JDK 怎么安装就不说了， 网上搜一下就出来了。&lt;/p&gt;
&lt;h2 id=&quot;安装-zookeeper&quot;&gt;3.2 安装 zookeeper&lt;/h2&gt;
&lt;h3 id=&quot;下载&quot;&gt;3.2.1 下载&lt;/h3&gt;
&lt;p&gt;网址 &lt;a href=&quot;http://zookeeper.apache.org/releases.html#download&quot; class=&quot;uri&quot;&gt;http://zookeeper.apache.org/releases.html#download&lt;/a&gt;， 从中选择一个镜像地址， 下载最新的稳定版本， 我的版本是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;zookeeper-3.4.13.tar.gz&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解压&quot;&gt;3.2.2 解压&lt;/h3&gt;
&lt;p&gt;解压到指定的目录下， 我的 zookeeper 目录&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;D:\Program Files\zookeeper-3.4.13&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;修改配置文件&quot;&gt;3.2.3 修改配置文件&lt;/h3&gt;
&lt;p&gt;首先， 需要重命名， 打开&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;zookeeper-3.4.13\conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将 “&lt;strong&gt;zoo_sample.cfg&lt;/strong&gt;” 重命名为 “&lt;strong&gt;zoo.cfg&lt;/strong&gt; ”。&lt;/p&gt;
&lt;p&gt;打开 zoo.cfg, 更改数据目录&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dataDir=D:\Program Files\zookeeper-3.4.13\temp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;添加系统变量&quot;&gt;3.2.4 添加系统变量&lt;/h3&gt;
&lt;p&gt;在系统环境变量中添加 &lt;strong&gt;ZOOKEEPER_HOME&lt;/strong&gt;， 值为 &lt;strong&gt;D:\Program Files\zookeeper-3.4.13&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;编辑已有的 &lt;strong&gt;path&lt;/strong&gt; 系统变量，添加路径：&lt;strong&gt;%ZOOKEEPER_HOME%\bin&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试安装是否成功&quot;&gt;3.2.5 测试安装是否成功&lt;/h3&gt;
&lt;p&gt;以&lt;strong&gt;管理员的权限&lt;/strong&gt;打开 &lt;strong&gt;cmd&lt;/strong&gt;， 运行 &lt;strong&gt;zkServer&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135438479?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;zookeeper运行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试成功。&lt;/p&gt;
&lt;h2 id=&quot;安装-kafka&quot;&gt;3.3 安装 Kafka&lt;/h2&gt;
&lt;h3 id=&quot;下载-1&quot;&gt;3.3.1 下载&lt;/h3&gt;
&lt;p&gt;网址 &lt;a href=&quot;http://kafka.apache.org/downloads&quot; class=&quot;uri&quot;&gt;http://kafka.apache.org/downloads&lt;/a&gt;， 选择指定的版本（我的是 kafka_2.12-1.0.0.tgz）， 并选择相应的镜像进行下载。&lt;/p&gt;
&lt;h3 id=&quot;解压-1&quot;&gt;3.3.2 解压&lt;/h3&gt;
&lt;p&gt;解压到指定的目录下， 我的 zookeeper 目录&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;D:\Program Files\kafka_2.12-1.0.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;修改配置文件-1&quot;&gt;3.3.3 修改配置文件&lt;/h3&gt;
&lt;p&gt;打开&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;kafka_2.12-1.0.0\config\server.properties&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找到以下配置， 并修改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// log 目录
log.dirs=D:\\Program Files\\kafka_2.12-1.0.0\\kafka-logs
// zookeeper
zookeeper.connect=localhost:2181&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;3.4 测试&lt;/h2&gt;
&lt;h3 id=&quot;启动-zookeeper&quot;&gt;3.4.1 启动 zookeeper&lt;/h3&gt;
&lt;p&gt;以&lt;strong&gt;管理员的权限&lt;/strong&gt;打开 &lt;strong&gt;cmd&lt;/strong&gt;， 运行 &lt;strong&gt;zkServer&lt;/strong&gt;。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135438479?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;zookeeper运行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要关闭&lt;/strong&gt;！！&lt;/p&gt;
&lt;h3 id=&quot;启动-kafka-服务器&quot;&gt;3.4.2 启动 Kafka 服务器&lt;/h3&gt;
&lt;p&gt;打卡 cmd 命令窗口， 打开kafka所在安装目录。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;D:\Program Files\kafka_2.12-1.0.0&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135547616?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;打开kafka所在安装目录&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\bin\windows\kafka-server-start.bat .\config\server.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功， &lt;strong&gt;不要关闭&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建-topic&quot;&gt;3.4.3 创建 topic&lt;/h3&gt;
&lt;p&gt;打卡 cmd 命令窗口， 打开kafka所在安装目录。&lt;/p&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018102213562519?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;创建hello话题&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建生产者&quot;&gt;3.4.4 创建生产者&lt;/h3&gt;
&lt;p&gt;打卡 cmd 命令窗口， 打开kafka所在安装目录。&lt;/p&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135658881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;创建生产者&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以随便输入一些内容&lt;/p&gt;
&lt;h3 id=&quot;创建消费者&quot;&gt;3.4.4 创建消费者&lt;/h3&gt;
&lt;p&gt;打卡 cmd 命令窗口， 打开kafka所在安装目录&lt;/p&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic hello --from-beginning&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181022135718780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;创建消费者&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到之前生产者输出的东西。&lt;/p&gt;
&lt;p&gt;此时， 在生产者处在发送消息， 消费者就可以接收到。&lt;/p&gt;
</description>
<pubDate>Mon, 22 Oct 2018 06:02:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>当我在学习一个新技术的时候， 入门阶段， 基本上都遵循 是什么 为什么 怎么用 这样的原则。 1 Kafka 是什么？ 1.1 背景 Kafka 最初是 LinkedIn 的一个内部基础设施系统， 后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9829742.html</dc:identifier>
</item>
<item>
<title>[十三]基础数据类型之AbstractStringBuilder - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9829659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9829659.html</guid>
<description>
&lt;p&gt;&lt;span&gt;String内部是一个private final char value[];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就意味着每次调用的各种处理方法，返回的字符串都是一个新的，性能上，显然....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，对于可变字符序列的需求是很明确的&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;类的层次结构设计，有的时候是自顶而下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的时候是总结归纳，然后抽象出来一个新的类，这很正常&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;尽管StringBuffer 要比StringBuilder 和 AbstractStringBuilder要早得多了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是StringBuffer 现在也继承了这个类&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134413047-1068514102.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_1137&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134413867-516631551.png&quot; alt=&quot;image_5bcd62fe_1137&quot; width=&quot;447&quot; height=&quot;67&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以说，抛开发展历史的过程不说，直接从类的层级结构设计的角度看的话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以认为AbstractStringBuilder 就是对于&lt;strong&gt;&lt;span&gt;可变字符序列&lt;/span&gt;&lt;/strong&gt;的这一概念的描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他提供了可变字符序列的一个基本协议约定，也就是基本的功能方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作为一个抽象类， 并且也提供了一部分默认的实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;StringBuffer和StringBuilder都是可变的字符序列，所以他们都实现了AbstractStringBuilder&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134414400-45761214.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_2581&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134415048-717450858.png&quot; alt=&quot;image_5bcd62fe_2581&quot; width=&quot;308&quot; height=&quot;147&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;属性简介&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;内部是一个&lt;strong&gt;&lt;span&gt;char[] value&lt;/span&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;span&gt;不再是final&lt;/span&gt;&lt;/strong&gt;的了，也就意味着可变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他实现了CharSequence接口意味着他是一个字符序列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现了Appendable接口，意味着他遵循了追加相关的协议&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134415598-242510118.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_7963&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134415848-1414519259.png&quot; alt=&quot;image_5bcd62fe_7963&quot; width=&quot;658&quot; height=&quot;434&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15.5&quot;&gt;&lt;td readability=&quot;27&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内部使用char[] value进行数据存储&lt;/span&gt;&lt;/strong&gt; ， 这个char[] value 是核心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他是有容量大小的，因为数组必然有长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果长度没有超出此容量，就无需分配新的内部缓冲区数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果内部缓冲区溢出，则此容量自动增大&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用&lt;strong&gt;&lt;span&gt;count 记录已经使用的字符个数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;还可以通过有参数的构造方法进行初始化设置value这个字符数组的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然构造方法不是给你用的，是给子类用的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;既然本质是一个char[] 字符数组，所以可以说所有的操作都是对于数组的操作&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;那么对于一个字符序列，有哪些方法是刚需呢?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也无外乎添加元素/删除元素/更新元素/获取元素 这几种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加有可能是插入中间或者在最后追加&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们知道，数组是顺序存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以对于插入这种操作必然会出现大量的元素移动情况&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;属性获取&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;既然是内部维护了字节数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必然这个数组本身属性，长度 ，使用个数的获取，以及数组的扩大也有相对应的方法可以使用&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;length() 获取实际数据的个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;capacity() 数组的大小 所以是容量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134416418-555511848.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_1c6e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134416856-2145900975.png&quot; alt=&quot;image_5bcd62fe_1c6e&quot; width=&quot;306&quot; height=&quot;169&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt;public void setLength(int newLength)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;&lt;span&gt;设置为指定长度&lt;/span&gt;
&lt;p&gt;&lt;span&gt;如果 newLength 参数小于当前长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则长度将更改为指定的长度， 截断，数据不变&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果 newLength 参数大于或等于当前长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则将追加有效的 null 字符 ('\u0000')，使长度满足 newLength 参数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;&lt;span&gt;public void ensureCapacity(int minimumCapacity)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;确保容量至少等于指定的最小值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果 minimumCapacity 参数为非正数，则此方法不执行任何操作并返回&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134417123-600505805.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_2467&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134417506-1758845117.png&quot; alt=&quot;image_5bcd62fe_2467&quot; width=&quot;480&quot; height=&quot;76&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;参数大于当前容量才会执行扩展&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134417820-1015790535.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_119a&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134418256-1592407261.png&quot; alt=&quot;image_5bcd62fe_119a&quot; width=&quot;551&quot; height=&quot;152&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;新容量的大小应大于：minimumCapacity 参数 并且大于 旧容量的两倍加 2  &lt;/span&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;public void trimToSize()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;尝试缩减空间&lt;br/&gt;如果实际使用的个数小于容量，那么进行缩减&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134418691-977713455.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_7157&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134419404-940073742.png&quot; alt=&quot;image_5bcd62fe_7157&quot; width=&quot;430&quot; height=&quot;118&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;添加方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;就像我们刚才说的那样，添加元素，分为&lt;strong&gt;&lt;span&gt;尾部追加元素&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;中间插入元素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加元素的方法也分为了两大阵营&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;26&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(Object obj)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， Object obj) &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(boolean b)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， boolean b)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(char c)&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， char c)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(int i)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， int i)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(long l)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， long l)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(float f)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， float f)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(double d)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， double d)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(CharSequence s)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int dstOffset， CharSequence s)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(CharSequence s， int start， int end)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;AbstractStringBuilder insert(int dstOffset， CharSequence s，int start， int end)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(char[] str)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， char[] str)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(char str[]， int offset， int len)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;AbstractStringBuilder insert(int index， char[] str， int offset， int len)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(String str)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;AbstractStringBuilder insert(int offset， String str)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder append(StringBuffer sb)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder appendCodePoint(int codePoint)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div&gt;


&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;从上表可以看得出来，给各种数据类型都提供了append和insert方法&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;对于insert 是插入，既然是插入，那么就需要指定位置&lt;br/&gt;所以与append对应的方法的方法签名上，都多了一个索引&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;所有的方法的返回类型都是AbstractStringBuilder&lt;br/&gt;其实都是&lt;br/&gt;return this;&lt;br/&gt;因为他是可变的，所以变化直接体现在了this中，所以返回this就好了&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;appendCodePoint(int codePoint) 与  append(char c)  可以说是一样的&lt;br/&gt;但是对于辅助平面显然又不一样，char不支持辅助平面&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;获取方法&lt;/strong&gt;&lt;/span&gt;  &lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;获取代码点&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;代码点相关的五个方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;charAt(int) / codePointAt(int) / codePointBefore(int) / codePointCount(int， int) / offsetByCodePoints(int， int)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们与String中的是一模一样的，代码也是一样的(就有个变量名变动)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;复制&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;getChars(int， int， char[]， int)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将字符从此序列复制到目标字符数组 dst  与String中的方法也几乎一致&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;索引下标&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;int indexOf(String str)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int indexOf(String str， int fromIndex)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;第一次出现的指定子字符串在该字符串中的索引&lt;br/&gt;可以指定索引&lt;br/&gt;指定索引就从索引处开始查找匹配&lt;br/&gt;满足的条件为startsWith true (并且在范围内 如果有设置)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;int lastIndexOf(String str)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int lastIndexOf(String str， int fromIndex)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;返回最右边出现的指定子字符串在此字符串中的索引 &lt;br/&gt;也就是最后一个&lt;br/&gt;可以指定索引&lt;br/&gt;指定索引就从索引处 反向匹配&lt;br/&gt;满足的条件也是startsWith true (并且在范围内 如果有设置)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;获取子串&lt;/span&gt;&lt;/h4&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;public &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String substring(int start， int end)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;根据索引返回子串&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134420144-1960628336.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_780d&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134420686-2038747944.png&quot; alt=&quot;image_5bcd62fe_780d&quot; width=&quot;576&quot; height=&quot;190&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;public String substring(int start)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;substring(int start， int end)的简化方法&lt;br/&gt;指定开始位置，默认结束位置为最后&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134420849-2099288066.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_5e54&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134421230-1564097856.png&quot; alt=&quot;image_5bcd62fe_5e54&quot; width=&quot;387&quot; height=&quot;70&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;public&lt;br/&gt;CharSequence subSequence(int start， int end)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;为了实现CharSequence方法&lt;br/&gt;内部调用的substring&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134421757-1596962783.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_37b8&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134422366-1029174851.png&quot; alt=&quot;image_5bcd62fe_37b8&quot; width=&quot;505&quot; height=&quot;92&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;更新方法&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;更新方法比较少，因为是数组&lt;br/&gt;数组的访问按照下标进行设置就好了&lt;br/&gt;还提供了替换的功能，也算是更新操作&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134422625-928261909.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_5494&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134423113-705143337.png&quot; alt=&quot;image_5bcd62fe_5494&quot; width=&quot;548&quot; height=&quot;108&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder replace(int start， int end， String str)&lt;br/&gt;使用str替换对象中从start 开始到end结束的这一段 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;删除方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder delete(int start， int end)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;删除指定范围的char&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134423790-49292461.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62fe_59d5&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134424420-1873461532.png&quot; alt=&quot;image_5bcd62fe_59d5&quot; width=&quot;748&quot; height=&quot;281&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;AbstractStringBuilder deleteCharAt(int index) &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;删除某个位置的char&lt;br/&gt;&lt;/span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134424804-1229879530.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bcd62ff_71c3&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201810/897393-20181022134425394-1050928128.png&quot; alt=&quot;image_5bcd62ff_71c3&quot; width=&quot;757&quot; height=&quot;151&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;reverse()&lt;br/&gt;按照字符进行翻转&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;将此字符序列用其反转形式取代&lt;br/&gt;就是翻转每一个char，注意可不是翻转比特位，也不是翻转字节，反转的是代码单元&lt;br/&gt;不过对于辅助平面的字符的代码点，他们会按照字符进行翻转，也就是高代理低代理顺序不会改变&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;执行操作前未成对的低代理项和高代理项将成为代理项对&lt;br/&gt;例如，反转 &quot;\uDC00\uD800&quot; 将生成有效的代理项对 &quot;\uD800\uDC00&quot;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如同我们上面说的，AbstractStringBuilder就是  可变 字符序列的一个纲领&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它规定了可变字符序列应该有的行为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如 添加字符/删除字符/更新字符/获取字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为可变，所以对于可变的支持，自然是必不可少的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，他作为String在很多方面的一个替代，必然也是提供了String的一些功能方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;否则与String API 变化巨大 也是毫无意义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为毕竟本身就是为了描述字符序列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以对于AbstractStringBuilder  只需要彻底理解了他作为 可变字符序列的标准接口即可&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 22 Oct 2018 05:51:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>本文对进行了AbstractStringBuilder简单介绍,对AbstractStringBuilder进行源码分析,从方法列表的解读去理解AbstractStringBuilder,Abstra</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9829659.html</dc:identifier>
</item>
<item>
<title>在Bootstrap开发框架中使用bootstrap-datepicker插件 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/9829673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/9829673.html</guid>
<description>&lt;p&gt;在基于Boostrap的Web开发中，往往需要录入日期内容，基于Boostrap的插件中，关于日期的录入可以使用bootstrap-datepicker这个非常不错的插件，以替代默认的type=date这种不太友好的日期录入控件，本篇介绍的是我在我的Boostrap开发框架中利用bootstrap-datepicker插件实现日期的录入处理。&lt;/p&gt;
&lt;h3&gt;1、bootstrap-datepicker插件的介绍&lt;/h3&gt;
&lt;p&gt;关于bootstrap-datepicker插件的相关的项目地址如下所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bootcss.com/p/bootstrap-datetimepicker%20&quot; target=&quot;_blank&quot;&gt;http://www.bootcss.com/p/bootstrap-datetimepicker &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/uxsolutions/bootstrap-datepicker&quot; target=&quot;_blank&quot;&gt;https://github.com/uxsolutions/bootstrap-datepicker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用这个插件，和其他插件使用类似，只需要引入对应的JS文件和CSS样式即可，如下是该插件的引用文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/js/bootstrap-datepicker.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/css/bootstrap-datepicker3.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要使用本地语言，引入语言文件即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/locales/bootstrap-datepicker.zh-CN.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插件的文件目录如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022125226539-283005964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插件的使用界面效果如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022130954929-1699872358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在MVC框架中，使用插件的时候，往往是把对应的CSS和JS，通过打包的方式进行引入，如在C#代码里面BundleConfig.cs的代码如下所示&lt;/p&gt;
&lt;p&gt;CSS文件引入如下代码所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022130028490-1514794309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JS文件类似，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022130317224-1763300924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而我们在开发Boostrap项目的时候，我们可以使用母版的方式引入对应的JS和CSS文件，在子页面则不需要再关注这些应用了，这些是基于MVC的Boostrap开发常见的处理，在这里就不再赘述了。&lt;/p&gt;

&lt;h3&gt;2、bootstrap-datepicker插件的项目使用代码&lt;/h3&gt;
&lt;p&gt;初始化bootstrap-datepicker插件也比较简单，最简单的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;datetimepicker&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$('#datetimepicker'&lt;span&gt;).datetimepicker({
    format: &lt;/span&gt;'yyyy-mm-dd hh:ii'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.form_datetime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).datetimepicker();
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而一般使用的时候，我们需要设置语言，格式，按钮等属性，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            $('.input-daterange input').each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).datepicker({
                    language: &lt;/span&gt;'zh-CN', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语言&lt;/span&gt;
                    autoclose: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择后自动关闭&lt;/span&gt;
                    clearBtn: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除按钮&lt;/span&gt;
                    format: &quot;yyyy-mm-dd&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期格式&lt;/span&gt;
&lt;span&gt;                });
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在查询数据的界面中，我们一般需要一个区间的时间，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022131122292-1871581664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而该界面的代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;input-group input-daterange&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;WHC_PayDate&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;WHC_PayDate&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;付款日期(起)&quot;&lt;/span&gt;&lt;span&gt; data-date-format&lt;/span&gt;&lt;span&gt;=&quot;yyyy-mm-dd&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;input-group-addon&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;~&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;WHC_PayDate2&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;WHC_PayDate&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;付款日期(止)&quot;&lt;/span&gt;&lt;span&gt; data-date-format&lt;/span&gt;&lt;span&gt;=&quot;yyyy-mm-dd&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以及录入界面明细的时候，选择单个日期的界面如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022131320529-1981332557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    $('.input-date input').each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        $(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).datepicker({
            language: &lt;/span&gt;'zh-CN', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;语言&lt;/span&gt;
            autoclose: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择后自动关闭&lt;/span&gt;
            clearBtn: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除按钮&lt;/span&gt;
            format: &quot;yyyy-mm-dd&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期格式&lt;/span&gt;
&lt;span&gt;        });
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用插件的时候，我们不可能为每个input初始化bootstrap-datepicker插件，因此使用了类选择器的处理方式实现所有日期插件的初始化。&lt;/p&gt;
&lt;p&gt;插件可选的日期格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;ul&gt;&lt;li&gt;yyyy-mm-dd&lt;/li&gt;
&lt;li&gt;yyyy-mm-dd hh:ii&lt;/li&gt;
&lt;li&gt;yyyy-mm-ddThh:ii&lt;/li&gt;
&lt;li&gt;yyyy-mm-dd hh:ii:ss&lt;/li&gt;
&lt;li&gt;yyyy-mm-ddThh:ii:ssZ&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;最后看看整体的界面效果吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8867/201810/8867-20181022134545624-893356970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 22 Oct 2018 05:47:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<og:description>在基于Boostrap的Web开发中，往往需要录入日期内容，基于Boostrap的插件中，关于日期的录入可以使用bootstrap-datepicker这个非常不错的插件，以替代默认的type=dat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhuacong/p/9829673.html</dc:identifier>
</item>
<item>
<title>koa-connect源码解析 - -云-</title>
<link>http://www.cnblogs.com/cloud-/p/9829576.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-/p/9829576.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文中提到的koa均为koa2&lt;/strong&gt;&lt;br/&gt;提到nodejs, 想必大家都知道express和koa.&lt;br/&gt;express: 大&lt;br/&gt;koa: 小&lt;br/&gt;比较的的是功能, 社区, 中间件,相关资源等&lt;/p&gt;
&lt;p&gt;这里我就专门说说中间件吧, 很多人可能说express插件丰富啊. 其实除了中间件, 其余什么的和express koa本身并没有多大关系, 不都是基于nodejs http(https)的封装嘛.&lt;/p&gt;
&lt;p&gt;express中间件是非常的丰富, 但是提个醒, express的中间件是可以跑在koa下面的.到这里就要提到 &lt;a href=&quot;https://github.com/vkurchatkin/koa-connect&quot;&gt;koa-connect&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;那么,我们就来简单看看这个koa-connect是怎么实现的.&lt;br/&gt;其源码一共才38行, 一半多注释, 3个方法.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;koaConnect: 对外公布的方法, 对express的中间件的参数进行分析,分别调用noCallbackHandler和withCallbackHandler&lt;/li&gt;
&lt;li&gt;noCallbackHandler : 处理无回调的express的中间件&lt;/li&gt;
&lt;li&gt;withCallbackHandler : 处理有回调的express的中间件&lt;br/&gt;&lt;strong&gt;这里的回调就是有无next方法, next方法就是进入下一个中间件&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * If the middleware function does declare receiving the `next` callback
 * assume that it's synchronous and invoke `next` ourselves
 */
function noCallbackHandler(ctx, connectMiddleware, next) {
  connectMiddleware(ctx.req, ctx.res)
  return next()
}

/**
 * The middleware function does include the `next` callback so only resolve
 * the Promise when it's called. If it's never called, the middleware stack
 * completion will stall
 */
function withCallbackHandler(ctx, connectMiddleware, next) {
  return new Promise((resolve, reject) =&amp;gt; {
    connectMiddleware(ctx.req, ctx.res, err =&amp;gt; {
      if (err) reject(err)
      else resolve(next())
    })
  })
}

/**
 * Returns a Koa middleware function that varies its async logic based on if the
 * given middleware function declares at least 3 parameters, i.e. includes
 * the `next` callback function
 */
function koaConnect(connectMiddleware) {
  const handler = connectMiddleware.length &amp;lt; 3
    ? noCallbackHandler
    : withCallbackHandler
  return function koaConnect(ctx, next) {
    return handler(ctx, connectMiddleware, next)
  }
}

module.exports = koaConnect&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;koaconnect方法&quot;&gt;koaConnect方法&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function koaConnect(connectMiddleware) {
  const handler = connectMiddleware.length &amp;lt; 3
    ? noCallbackHandler
    : withCallbackHandler
  return function koaConnect(ctx, next) {
    return handler(ctx, connectMiddleware, next)
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;kaoConnect返回的是一个koa版本的中间件.&lt;/p&gt;
&lt;p&gt;connectMiddleware.length是express中间件参数的长度, 如果你这个中间件使用了arguments进行参数解析或者使用了rest参数, 那么这个length本身就准确了.&lt;/p&gt;
&lt;p&gt;通过express中间件参数的长度分别调用有回调和无回调的方法.&lt;/p&gt;
&lt;h3 id=&quot;nocallbackhandler方法&quot;&gt;noCallbackHandler方法&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function noCallbackHandler(ctx, connectMiddleware, next) {
  connectMiddleware(ctx.req, ctx.res)
  return next()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接调用express方法, ctx.req 和 ctx.res作为参数传入.&lt;br/&gt;ctx.req: Node 的 request 对象.&lt;br/&gt;ctx.res: Node 的 Reponse 对象.&lt;/p&gt;
&lt;p&gt;这说明express的中间的req 和 res 和koa中间件的ctx.req 和res就是一个玩意.&lt;/p&gt;
&lt;p&gt;因为express中间件没有调用next, 所以被调用完毕, 直接调用koa中间件的next&lt;/p&gt;
&lt;h3 id=&quot;withcallbackhandler方法&quot;&gt;withCallbackHandler方法&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function withCallbackHandler(ctx, connectMiddleware, next) {
  return new Promise((resolve, reject) =&amp;gt; {
    connectMiddleware(ctx.req, ctx.res, err =&amp;gt; {
      if (err) reject(err)
      else resolve(next())
    })
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回一个Promise, 因为koa中有 await next()的形式调用, 这就很好的满足了需求.&lt;br/&gt;express中间里面假如有第三个参数next,调用表示进入下一个中间件.&lt;br/&gt;express中间件next调用的时候可以传入Error,&lt;br/&gt;可以参考&lt;a href=&quot;http://www.expressjs.com.cn/guide/error-handling.html&quot;&gt;express error handling&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;app.get(&quot;/&quot;, function (req, res, next) {
  fs.readFile(&quot;/file-does-not-exist&quot;, function (err, data) {
    if (err) {
      next(err); // Pass errors to Express.
    }
    else {
      res.send(data);
    }
  });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到我们的withCallbackHandler方法&lt;br/&gt;这里express的中间件的next方法即为&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;err =&amp;gt; {
      if (err) reject(err)
      else resolve(next())
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当有错误的时候,reject&lt;br/&gt;当没有错误的时候, 调用koa中间件的next, 继续下面的执行.&lt;/p&gt;
&lt;p&gt;koa-connect就分析完毕了, 核心就两点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过express中间件的参数长度来区分处理&lt;/li&gt;
&lt;li&gt;改造express中间件的next方法&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 22 Oct 2018 05:19:00 +0000</pubDate>
<dc:creator>-云-</dc:creator>
<og:description>文中提到的koa均为koa2 提到nodejs, 想必大家都知道express和koa. express: 大 koa: 小 比较的的是功能, 社区, 中间件,相关资源等 这里我就专门说说中间件吧,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-/p/9829576.html</dc:identifier>
</item>
</channel>
</rss>