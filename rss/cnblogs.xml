<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>canvas之fillStyle - WuMon</title>
<link>http://www.cnblogs.com/wumon/p/9211486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wumon/p/9211486.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.runoob.com/tags/ref-canvas.html&quot; target=&quot;_blank&quot;&gt;菜鸟canvas&lt;/a&gt;  &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  cvs = document.getElementById(&quot;canvas&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var  ctx = cvs.getContext(&quot;2d&quot;);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ctx.fillStyle = &lt;span&gt;wumon&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;　　那么这里的&lt;span&gt;wumon&lt;/span&gt;是什么呢？&lt;/p&gt;
&lt;p&gt;　　ctx.fillStyle = color | grdient | pattern;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;color&lt;/span&gt;，十六进制、rgb、rgba、HSL、HSLA······。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;gradient&lt;/span&gt;，有两种：&lt;/p&gt;
&lt;p&gt;　　　　线性：ctx.createLinearGradient(x,y,x1,y1);其中x、y为渐变开始的坐标，x1、y1为渐变结束时坐标;&lt;/p&gt;
&lt;p&gt;　　　　放射：ctx.createRadialGradient(x,y,r,x1,y1,r1);其中x、y、r为渐变开始坐标及半径，x1、y1、r1为渐变结束坐标及半径;&lt;/p&gt;
&lt;p&gt;　　　　同时还有一个addColorStop(stop,color);用来配合渐变使用，stop为0.0-1.0之间值，color为stop颜色，addColorStop可多次调用来调节渐变。&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;　　　　　　　var linear = ctx.createLinearGradient(x,y,x1,y1);&lt;/p&gt;
&lt;p&gt;　　　　　　　linear.addColorStop(0,&quot;red&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　　linear.addColorStop(1,&quot;blue&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　　ctx.fillStyle = linear;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;pattern&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;　　　　ctx.createPattern(imageEle,&quot;repeat&quot; | &quot;repeat-x&quot; | &quot;repeat-y&quot; | &quot;no-repeat&quot;);&lt;/p&gt;
&lt;p&gt;　　　　示例：&lt;/p&gt;
&lt;p&gt;　　　　　　var img = document.getElementById(&quot;img&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　var pat = ctx.createPattern(img,&quot;repeat&quot;);&lt;/p&gt;
&lt;p&gt;　　　　　　ctx.fillStyle = pat;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 15:42:00 +0000</pubDate>
<dc:creator>WuMon</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wumon/p/9211486.html</dc:identifier>
</item>
<item>
<title>Java关键字(四)——final - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9202015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9202015.html</guid>
<description>&lt;p&gt;　　对于Java中的 final 关键字，我们首先可以从字面意思上去理解，百度翻译显示如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621080149078-282773135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也就是说 final 英文意思表示是最后的，不可更改的。那么对应在 Java 中也是表达这样的意思，可以用 final 关键字修饰变量、方法和类。不管是用来修饰什么，其本意都是指 “它是无法更改的”，这是我们需要牢记的，为什么要无法更改？无非就是设计所需或者能提高效率，与前面介绍 static 关键字需要记住其与对象无关的理念一样，牢记 final 的不可变的设计理念后再来了解 final 关键字的用法，便会顺其自然了。&lt;/p&gt;
&lt;h3&gt;1、修饰变量&lt;/h3&gt;
&lt;p&gt;　　稍微有点Java基础的都知道用final关键字修饰的变量称为常量，常量的意思是不可更改。变量为基本数据类型，不可更改很容易理解，那么对于引用类型呢？不可能改的是其引用地址，还是对象的内容？&lt;/p&gt;
&lt;p&gt;　　我们首先构造一个实体类：Person&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('04b5c81c-dbb8-464a-b309-dd77c561c953')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_04b5c81c-dbb8-464a-b309-dd77c561c953&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_04b5c81c-dbb8-464a-b309-dd77c561c953&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('04b5c81c-dbb8-464a-b309-dd77c561c953',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_04b5c81c-dbb8-464a-b309-dd77c561c953&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Create by YSOcean
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String name;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　接着根据创建一个 Person 对象：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621203318523-67929805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，首先通过 final 关键字修饰一个对象 p，然后接着将 p 对象指向另一个新的对象，发现报错，也就是说final修饰的引用类型是不能改变其引用地址的。&lt;/p&gt;
&lt;p&gt;　　接着我们改动 p 对象的 name 属性：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621203519749-361874978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　发现程序没有报错。&lt;/p&gt;
&lt;p&gt;　　结论：被 final 修饰的变量不可更改其引用地址，但是可以更改其内部属性。&lt;/p&gt;
&lt;h3&gt;2、修饰方法&lt;/h3&gt;
&lt;p&gt;　　final 关键字修饰的方法不可被覆盖。&lt;/p&gt;
&lt;p&gt;　　在《Java编程思想》第 4 版 7.8.2 章节 final 方法p176 页这样描述：使用 final 方法原因有两个：&lt;/p&gt;
&lt;p&gt;　　①、第一个原因是把方法锁定，以防止任何继承类修改它的含义，这是出于设计的考虑：想要确保在继承中使方法的行为保持不变，并且不会被覆盖。&lt;/p&gt;
&lt;p&gt;　　②、第二个原因是效率，在 Java 的早期实现中，如果将一个方法声明为 final，就是同意编译器将针对该方法的所有调用都转为内嵌调用，内嵌调用能够提高方法调用效率，但是如果方法很大，内嵌调用不会提高性能。而在目前的Java版本中（JDK1.5以后），虚拟机可以自动进行优化了，而不需要使用 final 方法。&lt;/p&gt;
&lt;p&gt;　　所以&lt;strong&gt;final 关键字只有明确禁止覆盖方法时，才使用其修饰方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　PS：《Java编程思想》中指出类中所有的 private 方法都隐式指定为 final 的，所以对于 private 方法，我们显式的声明 final 并没有什么效果。但是我们创建一个父类，并在父类中声明一个 private 方法，其子类中是能够重写其父类的private 方法的，这是为什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　父类：Parent.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Create by YSOcean
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        System.out.println(&lt;/span&gt;&quot;parent&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　子类：Son.class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.bean;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Create by YSOcean
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Parent {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; say(){
        System.out.println(&lt;/span&gt;&quot;son&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实仔细看看，这种写法是方法的覆盖吗？我们通过多态的形式并不能调用到父类的 say() 方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621210117804-1988915508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　并且，如果我们在子类的 say() 方法中，添加 @Override 注解也是会报错的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621210206647-794954558.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　所以这种形式并不算方法的覆盖。&lt;/p&gt;
&lt;h3&gt;3、修饰类&lt;/h3&gt;
&lt;p&gt;　　final 修饰类表示该类不可被继承。&lt;/p&gt;
&lt;p&gt;　　也就是说不希望某个类有子类的时候，用final 关键字来修饰。并且由于是用 final 修饰的类，其类中所有的方法也被隐式的指为 final 方法。&lt;/p&gt;
&lt;p&gt;　　在 JDK 中有个最明显的类 String ，就是用 final 修饰的，将 String 类用 final 修饰很重要的一个原因是常量池。关于 String 类的描述，可以&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/8571426.html&quot; target=&quot;_blank&quot;&gt;参考我的这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201806/1120165-20180621210937598-1783125709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 15:36:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9202015.html</dc:identifier>
</item>
<item>
<title>.Net Core小技巧 - Swagger适配虚拟目录及二级目录 - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/9195803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/9195803.html</guid>
<description>&lt;p&gt;　　随着前后端分离模式与微服务架构的出现，Web API变得越来越重要及普遍。而后出现的网关技术，使开发者更倾向于使用二级/多级目录来暴露Web API，一是暴露的端口更少，方便管理；二是在网关中可以处理一些公共的事务，如认证。但swagger默认是适配根（root）目录的，想要适配二级/多级目录，需要额外处理，同时还要区分开发环境与其它环境。一种思路是在开发环境就让Web API是处于二级目录，此时可以在本机通过nginx和iis虚拟目录来模拟，但这种思路明显略微麻烦。另一种思路是通过配置多环境的方式实现。&lt;/p&gt;


&lt;p&gt;1. 安装Swagger&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-Package Swashbuckle.AspNetCore
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.  配置Swagger服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddSwaggerGen(c =&amp;gt;&lt;span&gt;
{
    c.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 配置swagger中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; virtualPath = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;virtualPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

app.UseSwagger(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    c.PreSerializeFilters.Add((swaggerDoc, httpReq) &lt;/span&gt;=&amp;gt; swaggerDoc.BasePath =&lt;span&gt; virtualPath);
});

app.UseSwaggerUI(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    c.SwaggerEndpoint(virtualPath &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    c.RoutePrefix &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 配置appsettings.json&lt;/p&gt;
&lt;p&gt;在appsettings.json中添加virtualPath的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;virtualPath&quot;: &quot;/sg&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设二级目录或虚拟目录是/sg&lt;/span&gt;
  &quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IncludeScopes&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;Debug&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Default&quot;: &quot;Warning&quot;&lt;span&gt;
      }
    },
    &lt;/span&gt;&quot;Console&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Default&quot;: &quot;Warning&quot;&lt;span&gt;
      }
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在appsettings.Development.json中添加virtualPath的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;virtualPath&quot;: &quot;&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用根目录&lt;/span&gt;
  &quot;Logging&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;IncludeScopes&quot;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;LogLevel&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;Default&quot;: &quot;Debug&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;System&quot;: &quot;Information&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;Microsoft&quot;: &quot;Information&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1. 开发环境测试&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180618192259870-718003380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180618192400511-1121668063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2. 模拟生产环境测试&lt;/p&gt;
&lt;p&gt;修改launchSettings.json，改变环境变量参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180618192727472-2011656542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180621225603674-1509635474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;准备nginx.conf，并启动nginx。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
worker_processes  1&lt;span&gt;;

events {
    worker_connections  &lt;/span&gt;1024&lt;span&gt;;
}

http {
    include       mime.types;
    default_type  application&lt;/span&gt;/octet-stream;
&lt;span&gt;    sendfile        on;
    keepalive_timeout  &lt;/span&gt;65&lt;span&gt;;

    server {
        listen       &lt;/span&gt;80&lt;span&gt;;
        server_name  localhost;

        location &lt;/span&gt;/sg/&lt;span&gt; {
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:30925/;  &lt;/span&gt;
&lt;span&gt;            
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;访问二级目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201806/182190-20180621225942064-2047527546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　本文涉及的代码并不多，主要想表达的是设计思路，以及对多环境的处理方案，不得不说的是，.Net Core在环境适配以及其它方面的设计都十分优秀。&lt;/p&gt;
&lt;p&gt;　　二级目录适配虽然是个很小的问题，但是却是微服务实践中一个很常见的问题。&lt;/p&gt;
&lt;p&gt;　　二级目录适配能否自动适配而非配置适配，也是一个值得思考的问题。　　&lt;/p&gt;


&lt;p&gt;　　&lt;a href=&quot;https://github.com/ErikXu/.NetCoreTips/tree/master/SwaggerVirtualPath&quot; target=&quot;_blank&quot;&gt;https://github.com/ErikXu/.NetCoreTips/tree/master/SwaggerVirtualPath&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 15:24:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erik_Xu/p/9195803.html</dc:identifier>
</item>
<item>
<title>jq选择器 - 所爱隔山隔海</title>
<link>http://www.cnblogs.com/zhengleilei/p/9211392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengleilei/p/9211392.html</guid>
<description>&lt;p&gt;                          基本选择器&lt;br/&gt;    1.获取唯一id:$(&quot;#&quot;)&lt;br/&gt;    $(&quot;#myid&quot;).css(&quot;color&quot;,&quot;blue&quot;);&lt;br/&gt;    2.获取所有class:$(&quot;.&quot;)&lt;br/&gt;    $(&quot;.class&quot;).css(&quot;color&quot;,&quot;yellow&quot;);&lt;br/&gt;    3.获取所有元素:$(&quot;*&quot;)&lt;br/&gt;    $(&quot;*&quot;).css(&quot;color&quot;,&quot;green&quot;);&lt;br/&gt;    4.获取所有标签:$(&quot;标签&quot;)&lt;br/&gt;    $(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    5.获取同时满足两个选择器的元素:$(&quot;选择器1选择器2&quot;)&lt;br/&gt;   $(&quot;#id,.class&quot;).css(&quot;color&quot;,&quot;orange&quot;);&lt;br/&gt;                                层叠选择器&lt;br/&gt;    1.父元素中包含的所有元素:($&quot;选择器1  选择器2&quot;)&lt;br/&gt;     $(&quot;#second .second&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    2.父元素的子元素:($&quot;选择器1&amp;gt;选择器2&quot;)&lt;br/&gt;     $(&quot;#second&amp;gt;div&quot;).css(&quot;color&quot;,&quot;grey&quot;);&lt;br/&gt;    3.相邻的下一个兄弟元素:$(&quot;选择器1+选择器2&quot;)&lt;br/&gt;      $(&quot;h2+h3&quot;).css(&quot;color&quot;,&quot;orange&quot;);&lt;br/&gt;    4.后面的所有兄弟元素&lt;br/&gt;    $(&quot;#as1~div&quot;).css(&quot;color&quot;,&quot;orange&quot;);&lt;br/&gt;                            方法选择器&lt;br/&gt;    1.符合条件的第一个元素&lt;br/&gt;    $(&quot;.first:first&quot;).css(&quot;color&quot;,&quot;yellow&quot;);&lt;br/&gt;    2.符合条件的最后一个元素&lt;br/&gt;    $(&quot;.first:last&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    3.符合条件的索引为偶数的元素&lt;br/&gt;    $(&quot;.first:even&quot;).css(&quot;color&quot;,&quot;red&quot;);&lt;br/&gt;    4.符合条件的索引为奇数的元素&lt;br/&gt;    $(&quot;.first:odd&quot;).css(&quot;color&quot;,&quot;green&quot;);   &lt;br/&gt;    5.符合条件的索引值元素&lt;br/&gt;       $(&quot;.first:eq(0)&quot;).css(&quot;color&quot;,&quot;greenyellow&quot;);&lt;br/&gt;    6.符合条件的大于索引值的元素&lt;br/&gt;       $(&quot;.first:gt(0)&quot;).css(&quot;color&quot;,&quot;blue&quot;);&lt;br/&gt;    7.符合条件的小于索引值的元素    &lt;br/&gt;     $(&quot;.first:lt(1)&quot;).css(&quot;color&quot;,&quot;green&quot;);&lt;br/&gt;    8.获取满足第一个条件且不满(满足)足第二个条件(empty、checked...)的元素:$(&quot;选择器:条件&quot;)&lt;br/&gt;    $(&quot;div:not(empty)&quot;).css(&quot;background&quot;,&quot;yellow&quot;);&lt;br/&gt;    $(&quot;div:empty&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;    9.所有标题元素&lt;br/&gt;    $(&quot;:header&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;    10.所有动画元素&lt;br/&gt;    $(&quot;:animated&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;    11.包含指定字符串的所有元素&lt;br/&gt;    $(&quot;div:contains('child')&quot;).css(&quot;width&quot;,&quot;500px&quot;);&lt;br/&gt;    12.所有带有匹配选择的元素&lt;br/&gt;    $(&quot;h5,.child_child,#myid&quot;).css(&quot;background&quot;,&quot;green&quot;);&lt;br/&gt;             属性选择器&lt;br/&gt;    1.属性等于属性值的元素&lt;br/&gt;    $(&quot;[href='#']&quot;);&lt;br/&gt;    2.属性不等于属性值的元素&lt;br/&gt;    $(&quot;[href!='#']&quot;);&lt;br/&gt;    3.属性以属性值结尾的元素&lt;br/&gt;    $(&quot;[href$='.jpg']&quot;);&lt;br/&gt;    4.带有某属性的元素&lt;br/&gt;    $(&quot;[href]&quot;);&lt;br/&gt;            表单选择器&lt;br/&gt;    1.所有input元素&lt;br/&gt;    $(&quot;:input&quot;);&lt;br/&gt;    2.通过input的类型选则元素&lt;br/&gt;    $(&quot;:text&quot;);文字框&lt;br/&gt;    $(&quot;:password&quot;);密码框&lt;br/&gt;    $(&quot;:radio&quot;);单选框&lt;br/&gt;    $(&quot;:checkbox&quot;);复选框&lt;br/&gt;    $(&quot;:submit&quot;);提交按钮&lt;br/&gt;    $(&quot;:buttom&quot;);普通按钮&lt;br/&gt;    $(&quot;:reset&quot;);重置按钮&lt;br/&gt;    $(&quot;:image&quot;);图片按钮&lt;br/&gt;    $(&quot;:file&quot;);上传文件&lt;br/&gt;    3.通过input的状态选则元素&lt;br/&gt;    $(&quot;:endabled&quot;);所有激活的input元素&lt;br/&gt;    $(&quot;:disable&quot;);所有禁用的input元素&lt;br/&gt;    $(&quot;:selecte&quot;);所有被选取的input元素&lt;br/&gt;    $(&quot;:checked&quot;);所有被选中的input元素&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 15:14:00 +0000</pubDate>
<dc:creator>所爱隔山隔海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhengleilei/p/9211392.html</dc:identifier>
</item>
<item>
<title>JAVA | 学生选课系统 - M-William</title>
<link>http://www.cnblogs.com/mz-xiansheng/p/9211383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mz-xiansheng/p/9211383.html</guid>
<description>&lt;p&gt;这里使用JAVA语言编写的简易的学生选课系统，展现的都是这个系统核心代码。&lt;/p&gt;
&lt;p&gt;其中有不足欢迎批评和指正！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;链接数据库的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;package connection;&lt;br/&gt;//连接数据库student&lt;/p&gt;
&lt;p&gt;import java.sql.Connection;&lt;br/&gt;import java.sql.DriverManager;&lt;br/&gt;//import java.sql.Statement;&lt;br/&gt;import java.sql.SQLException;&lt;/p&gt;
&lt;p&gt;public class xu{&lt;/p&gt;&lt;p&gt;private static Connection conn = null;&lt;br/&gt;static {&lt;br/&gt;try {&lt;br/&gt;// 注册驱动&lt;br/&gt;Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;);&lt;br/&gt;// 获得一个数据库连接&lt;br/&gt;conn = DriverManager.getConnection(&quot;jdbc:sqlserver://localhost:1433;DatabaseName=student&quot;,&quot;sa&quot;,&quot;123456&quot;);&lt;br/&gt;}catch(ClassNotFoundException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} catch (SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static Connection getConnection() {&lt;br/&gt;return conn;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;选课的操作代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;package connection;&lt;/p&gt;
&lt;p&gt;import java.sql.*;&lt;br/&gt;import java.util.*;&lt;/p&gt;
&lt;p&gt;public class test1{&lt;/p&gt;&lt;p&gt;private static String ID; // 此处的ID设为全局变量，在下面某些方法里会用到&lt;br/&gt;private static Scanner console = new Scanner(System.in);&lt;br/&gt;private static String managerPass = &quot;123456&quot;;&lt;br/&gt;private static Connection conn = xu.getConnection();&lt;/p&gt;&lt;p&gt;public static void main(String [] args) throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Welcome to the student selection system!\n\n&quot;&lt;br/&gt;+&quot;if you are maneger please choose 6、7、8、9、10\n&quot;&lt;br/&gt;+&quot;if you are student Please choose 1、2、3、4、5、10\n&quot;);&lt;br/&gt;ShowMenu();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void ShowMenu() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;-----------option-------------\n&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;1--Student login&quot;); // 学生登录&lt;br/&gt;System.out.println(&quot;2--Change password&quot;); // 学生修改密码&lt;br/&gt;System.out.println(&quot;3--Choose course&quot;); // 学生选课&lt;br/&gt;System.out.println(&quot;4--Get course list&quot;); // 学生查看自己的课程表&lt;br/&gt;System.out.println(&quot;5--Student rigistration&quot;); // 学生注册账号&lt;br/&gt;System.out.println(&quot;6--Create student&quot;); // 管理员创建学生&lt;br/&gt;System.out.println(&quot;7--Create course&quot;); // 管理员创建课表&lt;br/&gt;System.out.println(&quot;8--Get student list&quot;); // 管理员查看学生表&lt;br/&gt;System.out.println(&quot;9--Get course list1&quot;); // 管理员查看选课表里的课程&lt;br/&gt;System.out.println(&quot;10--exit\n&quot;); // 退出&lt;/p&gt;&lt;p&gt;Test();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void Test() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;manager choose 1 ,student choose 0&quot;);&lt;br/&gt;int choose1 = console.nextInt(); //int 用nextInt()&lt;/p&gt;&lt;p&gt;if(choose1 == 1) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your password :&quot;);&lt;br/&gt;String password = console.next(); //String 用next()&lt;/p&gt;&lt;p&gt;if(password.equals(managerPass)) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Welcome manager!\n&quot;);&lt;br/&gt;ManagerMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Your password is worry!&quot;); }&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else if(choose1 == 0) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Welcome Student!&quot;);&lt;br/&gt;StudentMenu1();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*管理员操作菜单*/&lt;br/&gt;public static void ManagerMenu1() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;----------Manager----------\n&quot;);&lt;br/&gt;System.out.println(&quot;Please choose option&quot;);&lt;br/&gt;int choose2 = console.nextInt();&lt;/p&gt;&lt;p&gt;switch(choose2) {&lt;/p&gt;&lt;p&gt;case 1 :&lt;br/&gt;case 2 :&lt;br/&gt;case 3 :&lt;br/&gt;case 4 :&lt;br/&gt;case 5 :&lt;br/&gt;System.out.println(&quot;This is student`s option,try again!&quot;);&lt;br/&gt;ManagerMenu1();&lt;br/&gt;break;&lt;br/&gt;case 6 : CreateStu();break;&lt;br/&gt;case 7 : CreateCourse();break;&lt;br/&gt;case 8 : GetStudentList();break;&lt;br/&gt;case 9 : GetCourseList1();break;&lt;br/&gt;case 10 : System.exit(0);break;&lt;br/&gt;default : System.out.println(&quot;Please input an right number , try again!&quot;); ManagerMenu1();&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生操作菜单*/&lt;br/&gt;public static void StudentMenu1() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;----------Student----------\n&quot;);&lt;br/&gt;System.out.println(&quot;Please input option&quot;);&lt;br/&gt;int choose3 = console.nextInt();&lt;/p&gt;&lt;p&gt;switch(choose3) {&lt;/p&gt;&lt;p&gt;case 1 : StuLogin();break;&lt;br/&gt;case 2 : ChangePass();break;&lt;/p&gt;&lt;p&gt;//在进行Choose course,Get course list之前都要求学生进行StuLogin操作&lt;/p&gt;&lt;p&gt;case 3 :&lt;br/&gt;case 4 : System.out.println(&quot;you must login before you can do it!\n&quot;);StuLogin();break;&lt;br/&gt;case 5 : StuRigistration();break;&lt;br/&gt;case 6 :&lt;br/&gt;case 7 :&lt;br/&gt;case 8 :&lt;br/&gt;case 9 : System.out.println(&quot;This is manager`s option,try again!&quot;);StudentMenu1();break;&lt;br/&gt;case 10 : System.exit(0);break;&lt;br/&gt;default : System.out.println(&quot;Please input an right number,try again!&quot;);StudentMenu1();&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;/*管理员创建课程*/&lt;br/&gt;public static void CreateCourse() throws SQLException{&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;/* 通过connection数据库链接对象 创建一个statement对象数据库操作对象,stat对象再获取一个执行sql的语句。&lt;br/&gt;* stat对象就是java程序与Database的一个连接通道*/&lt;/p&gt;&lt;p&gt;Statement stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;insert into course(couID,couName,couTeacher)values(1,'软件工程','黄伟国')&quot;;&lt;br/&gt;String sql2 = &quot;insert into course(couID,couName,couTeacher)values(2,'数据库','韦美雁')&quot;;&lt;br/&gt;String sql3 = &quot;insert into course(couID,couName,couTeacher)values(3,'算法设计','黎明')&quot;;&lt;br/&gt;String sql4 = &quot;insert into course(couID,couName,couTeacher)values(4,'大学英语','章琴')&quot;;&lt;br/&gt;String sql5 = &quot;insert into course(couID,couName,couTeacher)values(5,'Java','唐雅媛')&quot;;&lt;/p&gt;&lt;p&gt;int a = stat.executeUpdate(sql1);&lt;br/&gt;int b = stat.executeUpdate(sql2);&lt;br/&gt;int c = stat.executeUpdate(sql3);&lt;br/&gt;int d = stat.executeUpdate(sql4);&lt;br/&gt;int e = stat.executeUpdate(sql5);&lt;/p&gt;&lt;p&gt;int sum = a + b + c + d + e;&lt;br/&gt;System.out.println(&quot;成功添加&quot;+ sum + &quot;行课程数据&quot;);&lt;br/&gt;ManagerMenu1();&lt;/p&gt;&lt;p&gt;} catch (SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;// e.printStackTrace();&lt;br/&gt;System.out.println(&quot;Course already exists&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*管理员创建学生*/&lt;br/&gt;public static void CreateStu() throws SQLException {&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;Statement stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;insert into student(stuID,stuName) Values(20160501,'徐明正')&quot;;&lt;/p&gt;&lt;p&gt;// 这里对学生信息的输入也必须一个一个输入，这是系统的缺陷，问题待解决&lt;/p&gt;&lt;p&gt;int a = stat.executeUpdate(sql1);&lt;br/&gt;System.out.println(&quot;成功添加&quot;+ a + &quot;行学生数据&quot;);&lt;br/&gt;ManagerMenu1();&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;System.out.println(&quot;The student already exists&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生登录*/&lt;br/&gt;public static void StuLogin() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your stuID&quot;); // 输入账号&lt;br/&gt;ID = console.next();&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your Password&quot;); // 输入密码&lt;br/&gt;String stuPassword = console.next();&lt;/p&gt;&lt;p&gt;String stuID = null;&lt;br/&gt;String Password = null;&lt;/p&gt;&lt;p&gt;Statement stat ;&lt;br/&gt;ResultSet rs ;&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;select * from login &quot;; /* 从login表中查询其所有属性值，则stuID 和 Password都有了。&lt;br/&gt;rs是结果集。查询出的记录是一个列表，初始时指针指向的是第一条记录之前的。*/&lt;br/&gt;boolean flag;&lt;br/&gt;rs = stat.executeQuery(sql1);&lt;/p&gt;&lt;p&gt;while(flag = rs.next()) { // rs.next(); //返回值为true or false&lt;/p&gt;&lt;p&gt;stuID = rs.getString(&quot;stuID&quot;);&lt;br/&gt;Password = rs.getString(&quot;Password&quot;);&lt;/p&gt;&lt;p&gt;if( ID.equals(stuID) &amp;amp;&amp;amp; stuPassword.equals(Password)) // 注意这里，跳出循环的条件很重要&lt;/p&gt;&lt;p&gt;break;&lt;/p&gt;&lt;p&gt;// 如果在数据库里没有找到与用户输入的stuID和Password相匹配的stuID和Password,flag则变为false&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;if(!flag){ // 当flag 为 false 时&lt;/p&gt;&lt;p&gt;System.out.println(&quot;The ID or Password is worry!Please input your ID and Password again\n&quot;);&lt;br/&gt;StuLogin();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else {&lt;br/&gt;System.out.println(&quot;***&quot;+ID+&quot;***&quot;+stuID +&quot;***&quot;+stuPassword+&quot;***&quot;+Password+&quot;***&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Login Successful!\n&quot;);&lt;br/&gt;System.out.println(&quot;------------------Please choose option------------------\n&quot;&lt;br/&gt;// +&quot;If you want to Change Password ,Please choose 2\n&quot;&lt;br/&gt;+&quot;If you want to Choose Course,Please choose 3\n&quot;+&quot;If you want to Get Course List,Please choose 4\n&quot;&lt;br/&gt;+&quot;If you want to exit ,Please choose 8\n&quot;);&lt;/p&gt;&lt;p&gt;int choose4 = console.nextInt();&lt;/p&gt;&lt;p&gt;switch(choose4) {&lt;/p&gt;&lt;p&gt;// case 2 : ChangePass();break;&lt;br/&gt;case 3 : ChooseCourse();break;&lt;br/&gt;case 4 : GetCourseList();break;&lt;br/&gt;case 10 : System.exit(0);break;&lt;br/&gt;default : System.out.println(&quot;You input an invalid number!&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;} catch (SQLException e) {&lt;/p&gt;&lt;p&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;/*在这里说明一下 方法execute 、executeQuery、executeUpdate三者的区别&lt;br/&gt;* 方法executeQuery 用于单个结果集的语句，如select。他会把查询的结果放入ResultSet类对象中供使用。&lt;br/&gt;* 方法executeUpdate 用于执行insert、update或delete语句&amp;lt;返回值为整数&amp;gt;以及SQL DDL（数据定义语言），如create table 和 drop table &amp;lt;返回值为零&amp;gt;。&lt;br/&gt;* 方法execute 用于执行返回多个结果集、多个更新计数或二者组合的语句。*/&lt;/p&gt;&lt;p&gt;/*学生修改密码*/&lt;br/&gt;public static void ChangePass() throws SQLException {&lt;/p&gt;&lt;p&gt;// System.out.println(ID);&lt;/p&gt;&lt;p&gt;/*此处的ID应该必须要重新输入，否则当选择对数据库中某个ID更新的Password进行修改时，没有对应的ID*/&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your ID&quot;);&lt;br/&gt;String ID = console.next();&lt;br/&gt;System.out.println(&quot;Please input your new Password&quot;);&lt;br/&gt;String NewPassword = console.next();&lt;/p&gt;&lt;p&gt;Statement stat ;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement(); // 两种写法都可以&lt;br/&gt;// stat = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);&lt;br/&gt;String sql =&quot;UPDATE login SET Password =&quot; + &quot;&quot; + NewPassword + &quot; where stuID =&quot;+ ID;&lt;/p&gt;&lt;p&gt;//注意，此处的NewPassword 和 ID 没有要用''括起来&lt;/p&gt;&lt;p&gt;// String sql1 =&quot;UPDATE login SET Password = 111 where stuID = 20156022&quot;;&lt;/p&gt;&lt;p&gt;int a = stat.executeUpdate(sql);&lt;br/&gt;System.out.println(a);&lt;/p&gt;&lt;p&gt;if(a != 0) {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;成功修改&quot;+a+&quot;行记录&quot;);&lt;br/&gt;System.out.println(&quot;Your new Password is &quot;+ NewPassword);&lt;/p&gt;&lt;p&gt;StudentMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;else System.out.println(&quot;\n&quot;+&quot;Changing the Password is failed!&quot;);&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;/p&gt;&lt;p&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;/*学生选课*/&lt;br/&gt;public static void ChooseCourse() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(ID);&lt;br/&gt;String couID = null;&lt;br/&gt;String couName = null;&lt;br/&gt;String couTeacher = null;&lt;/p&gt;&lt;p&gt;Statement stat;&lt;br/&gt;ResultSet rs;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from course&quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;--------可选课程的信息-------&quot;);&lt;br/&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;couID = rs.getString(&quot;couID&quot;);&lt;br/&gt;couName = rs.getString(&quot;couName&quot;);&lt;br/&gt;couTeacher = rs.getString(&quot;couTeacher&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(couID + &quot; &quot; + couName + &quot; &quot; + couTeacher);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n Please choose your course \n&quot;);&lt;/p&gt;&lt;p&gt;stat= conn.createStatement();&lt;/p&gt;&lt;p&gt;// 此处stuID固定位学生登录时所用的ID,这样可以保证登录自己的账号却能选别的账号的课程&lt;/p&gt;&lt;p&gt;System.out.println(&quot;input CourseID&quot;);&lt;br/&gt;int ID1 = console.nextInt();&lt;br/&gt;int ID2 = console.nextInt();&lt;br/&gt;int ID3 = console.nextInt();&lt;/p&gt;&lt;p&gt;// 这样写 ，学生选课的数目必须固定为3门，问题待解决&lt;/p&gt;&lt;p&gt;String sql1 = &quot;insert into stuCourse(stuID,couID1,couID2,couID3)VALUES(&quot; + ID + &quot;,&quot;+ ID1 + &quot;,&quot; + ID2 + &quot;,&quot; +ID3 +&quot;)&quot;;&lt;br/&gt;int i = stat.executeUpdate(sql1);&lt;/p&gt;&lt;p&gt;if(i != 0) {&lt;br/&gt;System.out.println(&quot;成功选入课程&quot;);&lt;/p&gt;&lt;p&gt;GetCourseList();&lt;br/&gt;}&lt;br/&gt;else System.out.println(&quot;选课错误&quot;);&lt;/p&gt;&lt;p&gt;} catch (SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生获取已选课程列表*/&lt;br/&gt;public static void GetCourseList() throws SQLException {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\nHere is your course that you have choose\n&quot;);&lt;/p&gt;&lt;p&gt;Statement stat = null;&lt;br/&gt;ResultSet rs = null;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from stuCourse &quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;String stuID = null;&lt;br/&gt;String couID1 = null;&lt;br/&gt;String couID2 = null;&lt;br/&gt;String couID3 = null;&lt;br/&gt;String couID4 = null;&lt;/p&gt;&lt;p&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;stuID = rs.getString(&quot;stuID&quot;);&lt;br/&gt;couID1 = rs.getString(&quot;couID1&quot;);&lt;br/&gt;couID2 = rs.getString(&quot;couID2&quot;);&lt;br/&gt;couID3 = rs.getString(&quot;couID3&quot;);&lt;br/&gt;couID4 = rs.getString(&quot;couID4&quot;);&lt;/p&gt;&lt;p&gt;if(stuID.equals(ID))&lt;/p&gt;&lt;p&gt;System.out.println(stuID + &quot; &quot; + couID1 + &quot; &quot; + couID2 + &quot; &quot; + couID3 + &quot; &quot; + couID4 + &quot;\n&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/*学生注册*/&lt;br/&gt;public static void StuRigistration() throws SQLException{&lt;/p&gt;&lt;p&gt;System.out.println(&quot;Please input your ID &quot;);&lt;br/&gt;String ID = console.next();&lt;br/&gt;System.out.println(&quot;Please input your Password&quot;);&lt;br/&gt;String Password = console.next();&lt;/p&gt;&lt;p&gt;try {&lt;br/&gt;Statement stat = conn.createStatement();&lt;br/&gt;String sql1 = &quot;insert into login(stuID,Password)Values(&quot; + ID + &quot;, &quot; + Password + &quot;)&quot;;&lt;br/&gt;//这里密码只能输入数字,问题待解决&lt;/p&gt;&lt;p&gt;int a = stat .executeUpdate(sql1);&lt;br/&gt;System.out.println(&quot;成功注册&quot;+ a +&quot;个账号&quot;);&lt;/p&gt;&lt;p&gt;StudentMenu1();&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;System.out.println(&quot;ID already exists&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 管理员查看学生表 */&lt;br/&gt;public static void GetStudentList() {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n Here is student` information \n&quot;);&lt;/p&gt;&lt;p&gt;Statement stat = null;&lt;br/&gt;ResultSet rs = null;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from student &quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;String stuID = null;&lt;br/&gt;String stuName = null;&lt;/p&gt;
&lt;p&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;stuID = rs.getString(&quot;stuID&quot;);&lt;br/&gt;stuName= rs.getString(&quot;stuName&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(stuID + &quot; &quot; + stuName + &quot;\n&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;/* 管理员查看选课表里的课程*/&lt;br/&gt;public static void GetCourseList1() {&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n Here is course`information \n&quot;);&lt;/p&gt;&lt;p&gt;Statement stat = null;&lt;br/&gt;ResultSet rs = null;&lt;/p&gt;&lt;p&gt;try {&lt;/p&gt;&lt;p&gt;stat = conn.createStatement();&lt;br/&gt;String sql = &quot;select * from course &quot;;&lt;br/&gt;rs = stat.executeQuery(sql);&lt;/p&gt;&lt;p&gt;String couID = null;&lt;br/&gt;String couName = null;&lt;br/&gt;String couTeacher = null;&lt;/p&gt;&lt;p&gt;while(rs.next()) {&lt;/p&gt;&lt;p&gt;couID = rs.getString(&quot;couID&quot;);&lt;br/&gt;couName = rs.getString(&quot;couName&quot;);&lt;br/&gt;couTeacher = rs.getString(&quot;couTeacher&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(couID + &quot; &quot; + couName + &quot; &quot; + couTeacher + &quot;\n&quot;);&lt;/p&gt;&lt;p&gt;ManagerMenu1();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}catch(SQLException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 15:11:00 +0000</pubDate>
<dc:creator>M-William</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mz-xiansheng/p/9211383.html</dc:identifier>
</item>
<item>
<title>社招面试总结 - 玉菲莎</title>
<link>http://www.cnblogs.com/zllwebstudy/p/9211349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zllwebstudy/p/9211349.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;span&gt;前言&lt;/span&gt;：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　对没错，时隔上一次更新是1年又x月（懒得算了），之前的更新内容都是我校招的经历和为了准备校招而做的项目总结和学习记录，这次，终于！Finally！又更新了，结果还是因为面试哈哈哈😂可以说平时真的很懒了，而且在安全区太舒适不想写东西orz而今天之所以更新，确实是因为心里有非常多想说的话，所以写下来，也把我的社招的经历分享给大家，希望能够让大家在面试准备中更好的规划重点，同样也记录下这一段时间自己的状态，闲话放在最后跟大家扯，接下来正文，我会把这段时间中面试的国内大小知名不知名公司的社招面试写在下面，后续的话，希望还有更新吧，或许大约也不会了😂&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;正文：【以下问题根据面试官提到的次数排序，次数多的排在前面】&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1、Javascript部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1)ES6【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：面试官问到的问题，如：“你对ES6有没有了解？”或者“你在平时的工作中会用到ES6语法吗？”&lt;/p&gt;
&lt;p&gt;　　　　答：当面试官问出这种语法结构的问题时，ta就是在试探你对于ES6的了解，这个时候呢，ta希望能够听到你说出你了解到的尽可能多的ES6语法，然后ta会再在你说出的中，挑出ta觉得有必要深入的内容，更加详细的询问你。所以，你这个时候可以很平淡的抛出“有了解（用到过），像是let，const，解构，class定义类，Promise这些”，然后面试官就会根据你说出的内容，挑出一些ta认为很重要的或者本身就是难点的跟你继续详细让你说明你的理解呀，或者这个知识点的用处呀之类的，所以，如果你想面试前端，怎么能不了解ES6呢？什么？你问ES6是什么！？➡️赶紧点开教程学起来吧！&lt;a title=&quot;阮一峰 ES6入门教程&quot; href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;阮一峰ECMAScript 6 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2)闭包【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：“你说说JS里面的闭包是什么吧”“你知道什么是闭包么？”&lt;/p&gt;
&lt;p&gt;　　　　答：当面试官问出这类问题时，请你一定要在心里偷笑😏我已经不知道该什么告诉你面试前端会可能不问闭包的？emmmm如果有对闭包心里没得x数的，请你先不要投简历浪费自己和面试官的时间了，先把闭包的定义、实现方法以及用处好好在心里滚瓜烂熟到一听面试官问这个问题，就在心里窃喜拿下一道送分题的程度，OK，我也不说你了，不会的赶紧学起来➡️&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot; target=&quot;_blank&quot;&gt;学习Javascript闭包&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)原型链【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：“讲讲原型链把”“JS里的原型链是用于做什么的”&lt;/p&gt;
&lt;p&gt;　　　　答：嗯，吐槽不想多说了，如果看到这三个字就能自动巴拉巴拉得自动把考点难点都跟面试官解释清楚的，就放下手机给自己鼓鼓掌👏吧，至于不会的小可爱，没事啦，大牛都是小菜🐦一步一步努力变的，多多学习吸取别人总结的经验吧😁一点都不了解或者说不清楚原型链的看这个➡️&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499763408e24c210985d34edcabbca944b4239e20000&quot; target=&quot;_blank&quot;&gt;面向对象编程&lt;/a&gt; 如果对ES5中的继承方式有不清楚的可以看这篇➡️&lt;a href=&quot;https://www.cnblogs.com/humin/p/4556820.html&quot; target=&quot;_blank&quot;&gt;JS实现继承的几种方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;4)算法题【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　问：问题不一定呀，这个看面试官心情，但是总体来说，给前端出的算法真心不难，而且如果你爱刷leetcode，那就肯定没问题的，说不定还能看到原题😂我就遇到两次原题&lt;/p&gt;
&lt;p&gt;　　　　答：说一下我遇到的算法题吧。&lt;br/&gt;　　　　　　a)问题：“现在有100个台阶，你每次能够走一步或者两步，最后走到100个台阶有几种走法？” 思路提示：f(n) = f(n-1) + f(n-2) &lt;/p&gt;
&lt;p&gt;　　　　　　b)问题：“我输入一个串数字比如12345，最后输出‘一万二千三百四十五’，考虑边界情况比如10010” 思路提示： 一个数字对应中文的obj，一个放置单位的arr，每次取数字最后一位，然后依次往前添加单位和对应的中文，最后将最前面的数字拼接到最前面。&lt;/p&gt;
&lt;p&gt;　　　　　　c)问题：“列举出尽可能多的数组去重的方法” 思路提示：这个我当时只想出了5种，后来看到网上有人给出了10种解法，大家可以看看-&amp;gt; &lt;a href=&quot;https://www.jb51.net/article/121410.htm&quot; target=&quot;_blank&quot;&gt;数组去重的10种方法&lt;/a&gt; 我觉得按这个文章算解法不止10种😂总之大家可以开动你们可爱的小脑瓜给出尽可能多的解法，面试官对你的印象会大大加分的～&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2、CSS部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1)CSS3特性【必考指数：五星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　问：“都用到过什么CSS3的特性”“display：flex有用过么”&lt;/p&gt;
&lt;p&gt;　　　　　　答：如果问的是一个问题，那你可以拿第二个问题的知识点去回答，也就是解释一下flex布局，如果问到的是第二个点，那你就没得选了，乖乖解释一下flex布局，总而言之，CSS3特性中的flex布局，你不得不掌握，推荐一个教程，让你分分钟学会flex布局，戳这里➡️&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&quot; target=&quot;_blank&quot;&gt;我是打火机快来点我呀&lt;/a&gt; 如果第一个问题用flex回答以后，面试官不满意或者很满意，ta可能会继续追问你，除了这个，你还有别的了解吗？这个时候你可以说transform或者transition以及@media媒体查询，知识点预习复习来这里 &lt;a href=&quot;http://www.runoob.com/css3/css3-2dtransforms.html&quot; target=&quot;_blank&quot;&gt;小可爱们跟我一起学习CSS3呀&amp;lt;(￣︶￣)&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2)reflow和repaint【必考指数：四星半】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　问：“你对前端性能优化有没有什么了解？”“你能说出哪些css元素会触发重排，哪些会触发重绘吗？”&lt;/p&gt;
&lt;p&gt;　　　　　　答：老实说，我被问到这两个问题的时候更本没有把它们联系起来，但是后来去了解后，觉得可以把这两个问题放在一起说，当然前端的性能优化并不只包括减少重排和重绘，我之所以把这两个问题放在一起，是方便大家将这两个问题联系起来，并且如果面试官在问到你后面这个问题，你可以在先讲清楚哪些元素触发重排和重绘后，引申到前端性能优化问题，我觉得应该会是加分的操作👋&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html&quot; target=&quot;_blank&quot;&gt;想了解性能问题点这里&lt;/a&gt;&amp;amp;&lt;a href=&quot;http://caibaojian.com/css-reflow-repaint.html&quot; target=&quot;_blank&quot;&gt;哪些元素重排哪些重绘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)布局【必考指数：四星】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　问：“如何实现垂直布局？说出你知道的所有方法”“如何实现一个左侧定宽，右侧宽度不定，两个元素的高度撑满屏幕的布局？”“如何实现子元素的宽高固定为屏幕的一半，并且随屏幕大小自适应”&lt;/p&gt;
&lt;p&gt;　　　　　　答：考到布局一般会让你写一下关键的样式，并且说明一下思路，不论是垂直布局的实现，还是左右结构圣杯结构，又或者自适应的视图，都是比较考验切图的基础功的，解法都不唯一，大家可以留言提供一下自己比较得意的解法呀，楼楼期待拜读一下大家的高作~(￣▽￣)~* 当然还是提供一下楼楼在网上看到的还不错的文，大家没有思路的可以参考一下 &lt;a href=&quot;https://www.cnblogs.com/zhouhuan/p/vertical_center.html&quot; target=&quot;_blank&quot;&gt;垂直居中戳这里&lt;/a&gt; | &lt;a href=&quot;https://www.jianshu.com/p/f9bcddb0e8b4&quot; target=&quot;_blank&quot;&gt;圣杯布局看这里&lt;/a&gt; | &lt;a href=&quot;http://caibaojian.com/web-app-rem.html&quot; target=&quot;_blank&quot;&gt;rem实现自适应布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;3、不分类技术问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　1)跨域问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：emmm这个几乎每个面试都被问到了，所以如果你还不知道什么是跨域以及常用的解决方法，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot;&gt;那就快戳这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;2)从用户输入url到网页展示到用户面前的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：已经有非常多大牛的详细解释了，我也不再多做赘述，传送门在此👋&lt;a href=&quot;https://segmentfault.com/a/1190000006879700&quot; target=&quot;_blank&quot;&gt;戳我戳我戳我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)浏览器缓存机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：这个问题被问到两次，楼楼都没有答好orz所以还要赶紧恶补一下知识盲区呀&lt;a href=&quot;https://segmentfault.com/a/1190000011212929&quot; target=&quot;_blank&quot;&gt;快来一起学习呀&lt;/a&gt;　　　　&lt;/p&gt;

&lt;p&gt;　　　　&lt;strong&gt;4)事件代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：来来来，瞧一瞧看一看了呀，你买不了吃亏买不了上当，&lt;a href=&quot;https://www.cnblogs.com/liugang-vip/p/5616484.html&quot; target=&quot;_blank&quot;&gt;看一眼不会死呀(￣ε(#￣)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;5)XSS攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：楼楼当时答得很不好，语言组织不行，答到最后都没有底气了，只能认栽跟面试官说，这一块确实是知识盲区，了解不多orz所以平时多学点知识是好的，就不会在面试的时候那么囧了，如果你也跟楼楼一样对XSS是啥玩意儿都不了解的话，&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/09/csp.html&quot; target=&quot;_blank&quot;&gt;赶紧来一起学习一下(￣&amp;gt;￣)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4、非技术问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1)未来职业规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：这个就是看个人随机答的了，我觉得可以从宏观到细节的剖析一下你自己的内心独白，如果能够说得面试官动容的话，我就叫你一声大爷👍&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2)平时如何度过非工作时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：这个也是比较个人的问题，你当然可以着实说，也可以编一段感天动地的故事，甚至可以讲一段脱口秀，总之，聚光灯，麦克风，音响调到最大，来，请开始你的表演🎤&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3)你还有什么要问我的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　答：没有了。。。（╯‵□′）╯︵┴─┴ 你想面到最后面直接挂掉吗！？面试官这么问你，十有一二三四五是有戏的，人家给你个机会让你了解一下你可能即将上岗的公司和岗位，你直接一句话回绝了，不论面试官觉得你是缺心眼还是对这个岗位抱着可有可无的心态，总归会对你的印象分扣上几分嘛，当然如果你就是那种，老子对这个岗位无所谓面着玩的态度，当然随便你怎么说了，如果你想在最后给面试官刷一下好印象，可以问一些，比如，“会不会有每周的分享会呀？”“我以后会得到哪些技术成长的助力呀？”大概这种表现你积极向上，求知欲旺盛的套路，嗯，套路，都是套路，楼楼之前就是那种傻傻的说，没有了的人，后来总觉得面试官看我的眼神，像是在看一个二傻子，所以后来在网上一搜，哦，原来最后还有这种套路呀😂嗯，所以大家就不要再踩楼楼，嗯，坑太深有水，大家就不要往里面跳了(-ω- )&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;后话：&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　啊啊啊啊啊嗷嗷哦嗷嗷，楼楼一口气写这篇社招的总结容易么！写了3个小时容易么！你都看到这了还不给我点赞评论你有理么！嘻嘻嘻嘻嘻嘻点个赞评论一下就当交个盆友咯，楼楼是喜欢蓝孩子的可爱的抠脚大汉（em？好像没什么问题？）如果不想看楼楼碎碎念的，可以点赞评论然后退出了，但是请一定不要忘记点赞评论（正经脸）&lt;/p&gt;
&lt;p&gt;　　好，我要开始我的表演了，emmmm，其实写这么就是为了吐槽😂或者正经点说是为了记录一下最近两周准备面试的心路历程吧（播放背景音乐“浪奔～浪流～🌊🌊🌊”）准备面试真的很累，心情大概是一边埋冤自己平时都太安逸了，不思进取不多学点技术，一边又不得不调整心情，告诉自己，现在想这些有的没的根本没有任何帮助，保持一个高度集中和高效率的学习状态，将不必要的负面情绪都丢出脑外才是最有用的做法。总之，准备面试的时候，晚上做梦都在写代码debug然后又去把不会的恶补一下orz醒过来就安慰自己，没事没事，等开始面试了就好了，然后就又美滋滋的喝奶茶去了orz不是楼楼不怕月半，这个呢其实是一种科学的心里鼓励机制（正经脸）而且吃甜的是可以保持好心情，然后高效率的学习，算了，编不下去了，跳过这个段落，直接讲开始面试了。&lt;/p&gt;
&lt;p&gt;　　楼楼刚刚说了，自己本来想的是开始面试了嘛，就没那么累了，总比一整天一整天没事就看书看博客看文章查漏补缺还一边鄙视自己的纠结心情好吧？然而，我错了，我真的错了，我错在一开始就不应该来到这个伤心的地方，我果然还是应该回我的阿米拉密达虫洞次时空暗极宇宙姆星中去，但是我开启宇宙飞船的钥匙被人偷走了，所以我不得不暂留🌍请好心人救救孩子，嗯，拿错剧本了，有点跳戏，回来回来，讲到开始面试了，然后绝望的发现，面试T*D累得**orz身心俱疲，所以真的面试这件事，是一个耗时耗力的事，大家如果觉得面试找工作很累，没关系，你不是一个人😂&lt;/p&gt;
&lt;p&gt;　　不过，累还是值得的，说真的，从开始准备面试到面试了各个大公司小公司，这几天的成长速度很快，楼楼每天都觉得很充实，而且就在今天洗澡的时候悟出了一个道理，不知道哪个名人或者不知名的人说的，人的灵感蓬勃爆发的时期有两个，一个是在澡堂子，一个是在马桶上，嗯，吾与子同orz哦，对，说楼楼悟出来的道理，其实真的，你得感谢这些面试官，你去面试能当面试官的总归比你资历高些吧？人家专门花时间花经历的给你挑刺，让你知道自己的知识盲区，从而查漏补缺，快速进步，而且另外一方面，还给你时间听你哔哩吧啦，让你练习你的表达能力，多好，所以呀，想对曾经害怕面试的我（如果你去看我之前校招写的总结就能多少感觉到我内心对于面试的抗拒和整个过程中的不安）以及正在看这篇文章，想要学习一些面经的你说，不要怕，大家都是一步一个脚印走出来的，现在的你不行，那就努力，等回过头来看，如果没有曾经那么不服输那么挣扎着努力的自己，也就不会有现在的你了，而如果想要在将来成为一个了不起的人，那现在的你就努力努力吧～(=￣ω￣=)&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 15:04:00 +0000</pubDate>
<dc:creator>玉菲莎</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zllwebstudy/p/9211349.html</dc:identifier>
</item>
<item>
<title>微信小程序小结 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9191303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9191303.html</guid>
<description>&lt;p&gt; 前几日抽空看了下小程序，发现挺好玩的，mvvm的结构，语法比vue要简单，内置了一系列的组件，很方便。然后开发者工具直接上传代码，提交审核，然后发布，感觉挺好。虽然不打算做个工具类的，但是做个介绍类小程序就很合适了。不用去做什么官网，也不用买服务器域名什么的，用邮箱注册个号，把自己想介绍的东西方式去，手机上发给别人也挺方便。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;01.语法结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201806/417688-20180621214457879-1826536751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结构上很好理解，app.js可以直接获取用户的登录信息，也可以什么都不做，关键还是app.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;pages&quot;&lt;span&gt;:[
    &lt;/span&gt;&quot;pages/index/index&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages/about/about&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages/location/location&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;pages/logs/logs&quot;&lt;span&gt;
  ],
  &lt;/span&gt;&quot;window&quot;&lt;span&gt;:{
    &lt;/span&gt;&quot;backgroundTextStyle&quot;:&quot;light&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;navigationBarTitleText&quot;: &quot;书山有路&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;navigationBarTextStyle&quot;:&quot;black&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;tabBar&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;list&quot;&lt;span&gt;: [{
      &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/index/index&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;text&quot;: &quot;首页&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;iconPath&quot;: &quot;images/m.png&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;images/m1.png&quot;&lt;span&gt;
    },
    {
      &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/location/location&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;text&quot;: &quot;位置&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;iconPath&quot;: &quot;images/w.png&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;images/w1.png&quot;&lt;span&gt;
    },{
      &lt;/span&gt;&quot;pagePath&quot;: &quot;pages/about/about&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;text&quot;: &quot;关注&quot;&lt;span&gt;,
     &lt;/span&gt;&quot;iconPath&quot;: &quot;images/g.png&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;selectedIconPath&quot;: &quot;images/g1.png&quot;&lt;span&gt;
    }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每一个页面必须在pages中进行注册，window是一些基本的外观配置，tabBar就是用来设置一个页底导航。基本上每个页面都包含了.js，.wxml和.wxss文件，.js以&lt;/p&gt;
&lt;p&gt;Page({})开始，设置数据和方法，很简单。wxml也就是页面文件，有很多微信自己定义的元素，比如view，text和image，可以分别对应div,span和img。wxss就和css一样。&lt;/p&gt;
&lt;h3&gt;02.滑动&lt;/h3&gt;
&lt;p&gt;swiper挺方便的，有个问题就是不能自适应高度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;swiper &lt;/span&gt;&lt;span&gt;indicator-dots&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
  autoplay&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; interval&lt;/span&gt;&lt;span&gt;=&quot;{{interval}}&quot;&lt;/span&gt;&lt;span&gt; duration&lt;/span&gt;&lt;span&gt;=&quot;{{duration}}&quot;&lt;/span&gt;&lt;span&gt;  style&lt;/span&gt;&lt;span&gt;='height:{{Hei}}' &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;block &lt;/span&gt;&lt;span&gt;wx:for&lt;/span&gt;&lt;span&gt;=&quot;{{imgUrls}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;swiper-item &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;{{item}}&quot;&lt;/span&gt;&lt;span&gt; mode&lt;/span&gt;&lt;span&gt;=&quot;widthFix&quot;&lt;/span&gt;&lt;span&gt;  bindload&lt;/span&gt;&lt;span&gt;=&quot;imgH&quot;&lt;/span&gt;&lt;span&gt;   class&lt;/span&gt;&lt;span&gt;=&quot;slide-image&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;swiper-item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;swiper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找了个网友的办法，亲测有效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  imgH: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; winWid = wx.getSystemInfoSync().windowWidth;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前屏幕的宽度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgh = e.detail.height;　　　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片高度&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; imgw =&lt;span&gt; e.detail.width;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; swiperH = winWid * imgh / imgw + &quot;px&quot;　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等比设置swiper的高度。  即 屏幕宽度 / swiper高度 = 图片宽度 / 图片高度    ==》swiper高度 = 屏幕宽度 * 图片高度 / 图片宽度&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setData({
      Hei: swiperH　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置高度&lt;/span&gt;
&lt;span&gt;    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要忘了在data里面设置Hei属性。&lt;/p&gt;
&lt;h3&gt;03.地图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201806/417688-20180621220531096-810494271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地图&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/map.html#map&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;说的很详细，我也没必要说了，主要是用百度找经纬度：&lt;a href=&quot;http://api.map.baidu.com/lbsapi/getpoint/index.html&quot; target=&quot;_blank&quot;&gt;拾取坐标系统&lt;/a&gt;，很方面。&lt;/p&gt;
&lt;h3&gt;04.获取用户信息&lt;/h3&gt;
&lt;p&gt;在默认的app.js里面已经提供了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取用户信息&lt;/span&gt;
&lt;span&gt;    wx.getSetting({
      success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.authSetting['scope.userInfo'&lt;span&gt;]) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框&lt;/span&gt;
&lt;span&gt;          wx.getUserInfo({
            success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以将 res 发送给后台解码出 unionId&lt;/span&gt;
              &lt;span&gt;this&lt;/span&gt;.globalData.userInfo =&lt;span&gt; res.userInfo
              console.log(res.userInfo)

              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回&lt;/span&gt;
              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以此处加入 callback 以防止这种情况&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userInfoReadyCallback) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userInfoReadyCallback(res)
              }
            }
          })
        }
      }
    })
  },
  globalData: {
    userInfo: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们要在别的页面用userInfo&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = getApp();&lt;span&gt;//
&lt;/span&gt;&lt;span&gt;Page({
data:{
 userInfo:{}
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt; onLoad() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;span&gt;setData&lt;/span&gt;({ userInfo: app.globalData.userInfo })
  }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对data对象复制都需要使用setData。这样你就可以在页面显示用户的头像和名称。&lt;/p&gt;
&lt;h3&gt;05.长按扫码 &lt;/h3&gt;
&lt;p&gt;这个功能其实有点鸡肋，因为只能扫小程序的二维码，如果用户都已经进了这个页面，扫码还有个什么意义，因为小程序肯定已经下载了。关键用户还是想扫微信二维码或者公众号的二维码。微信确实管的比较严。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  previewImage: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        wx.previewImage({
      current: &lt;/span&gt;'http://images.cnblogs.com/xxxxx', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前显示图片的http链接     &lt;/span&gt;
      urls: ['http://images.cnblogs.com/xxxx'] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要预览的图片http链接列表     &lt;/span&gt;
&lt;span&gt;    })

  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;image &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='img' &lt;/span&gt;&lt;span&gt;bindtap&lt;/span&gt;&lt;span&gt;=&quot;&lt;span&gt;previewImage&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;  src&lt;/span&gt;&lt;span&gt;='images/actv.jpg' &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的current和urls必须是http链接，没法用相对路径。于是最简单的，我就把图片传到了博客园的图册里面... 这样用户点击图片就能出现保存，发送给朋友，收藏。只有小程序二维码才会出现扫码识别.... &lt;/p&gt;
&lt;h3&gt;06.图标&lt;/h3&gt;
&lt;p&gt;我们需要一些图标，个人毕竟不想去找美工。发现阿里的这个还不错：&lt;a href=&quot;http://www.iconfont.cn/&quot; target=&quot;_blank&quot;&gt;http://www.iconfont.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201806/417688-20180621222331619-1174824584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然还有https://www.easyicon.net/，不过这家有时候不稳定。&lt;/p&gt;
&lt;p&gt;小结：以上只是些简单功能的小程序开发，整体感觉不错，开发速度很快，只是这个流量和转化有点难，但确实方便。而且这名称就相当于是pc时代的域名了，如果用户有了搜一搜小程序的习惯，想在微信上看你们家东西，如果没有搜到是不是有点遗憾。早点占个名字也行。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 14:29:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9191303.html</dc:identifier>
</item>
<item>
<title>好代码是管出来的——.Net中的代码规范工具及使用 - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/9209254.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/9209254.html</guid>
<description>&lt;p&gt;　　上一篇文章介绍了编码标准中一些常用的工具，本篇就具体来介绍如何使用它们来完成代码管理。&lt;br/&gt;　　本文主要内容有：&lt;/p&gt;
&lt;h2&gt;Roslyn简介&lt;/h2&gt;
&lt;p&gt;　　Roslyn是一个开源的C#、VB编译器，它提供了丰富的代码分析API，第三方应用可以基于这些API来开发自己的代码分析工具。Roslyn应用在VS2015及以上版本。&lt;/p&gt;
&lt;h3&gt;开发基于Roslyn的代码分析器&lt;/h3&gt;
&lt;p&gt;　　Roslyn提供了相关的SDK，可以通过SDK来开发自己的代码分析器：&lt;br/&gt;　　1. 首先需要安装.Net Compiler Platform SDK：&lt;br/&gt;　　VS2017 15.5之前的版本可以通过下面连接下载并安装：&lt;br/&gt;　　&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.NETCompilerPlatformSDK&quot; target=&quot;_blank&quot;&gt;https://marketplace.visualstudio.com/items?itemName=VisualStudioProductTeam.NETCompilerPlatformSDK&lt;/a&gt;&lt;br/&gt;　　VS2017 15.5之后的版本可以通过Visual Studio Installer进行安装：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621140848705-2099161824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 创建一个Analyzer with Code Fix的项目：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621140909308-376433346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 分析器代码简介：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码结构：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　创建的项目中一共有三个子项目，分别是分析器、分析器测试项目以及vsix安装包项目如下图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621140948804-56073080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中分析器项目中包含了分析器(Analyzer1Analyzer)、代码修复器(Analyzer1CodeFixProvider)和相关的资源(Resources.resx)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分析器(Analyzer1Analyzer)：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　分析器代码的核心内容是注册一个命名符号处理器(用于处理类名、接口名等)，处理器的工作是判断分析的符合(名称)中是否包含小写字符，如果包含那么给出诊断信息(诊断信息定义包含在资源文件中)。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141033630-482355616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码修复器：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　将小写字符转换为大写：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141110675-1398295538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码调试：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　将vsix项目设为启动项目，就可以对分析器进行调试，调试时VS会在沙盘中启动一个新的VS实例，通过这个VS创建一个项目，编写代码时即可看到分析器给出的诊断结果和代码修复：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141158174-1598890302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　诊断信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141216977-91781576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修复结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141240850-1360792053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看语法树：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141306132-1293494400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;常用的基于Roslyn的代码分析器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Microsoft.CodeAnalysis.FxCopAnalyzers：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　FxCop是.Net Framework中用来分析托管代码的应用程序，它主要关注的&lt;strong&gt;&lt;span&gt;代码的设计、国际化、可维护性、性能和安全性&lt;/span&gt;&lt;/strong&gt;等方面，并按照这些类别定义了一个规则集：　　&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/code-quality/code-analysis-for-managed-code-warnings&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/visualstudio/code-quality/code-analysis-for-managed-code-warnings&lt;/a&gt;&lt;br/&gt;　　FxCopAnalyzers安装： &lt;a href=&quot;%20https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers&quot; target=&quot;_blank&quot;&gt;https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;StyleCop.Analyzers&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　StyleCop本身就是一个用于规范代码格式的工具，所以它的规则也是&lt;span&gt;面向代码格式&lt;/span&gt;的，如注释、布局、命名、排序、可维护性、可读性等，StyleCop的规则集参考：&lt;a href=&quot;https://github.com/DotNetAnalyzers/StyleCopAnalyzers/tree/master/documentation&quot; target=&quot;_blank&quot;&gt;https://github.com/DotNetAnalyzers/StyleCopAnalyzers/tree/master/documentation&lt;/a&gt;&lt;br/&gt;　　StyleCop.Analyzers的项目主页：&lt;a href=&quot;https://github.com/DotNetAnalyzers/StyleCopAnalyzers&quot; target=&quot;_blank&quot;&gt;https://github.com/DotNetAnalyzers/StyleCopAnalyzers&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Codecracker.CSharp:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　Codecracker.CSharp也是以个开源的代码分析器，它的规则主要是&lt;span&gt;设计、命名、性能、代码风格、代码使用以及重构&lt;/span&gt;，具体参见：&lt;a href=&quot;http://code-cracker.github.io/diagnostics.html&quot; target=&quot;_blank&quot;&gt;http://code-cracker.github.io/diagnostics.html&lt;/a&gt;&lt;br/&gt;项目主页：&lt;a href=&quot;https://github.com/code-cracker/code-cracker&quot; target=&quot;_blank&quot;&gt;https://github.com/code-cracker/code-cracker&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　注：Codecracker.CSharp可以通过安装VS拓展工具的方式实现代码分析：&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=GiovanniBassi-MVP.CodeCrackerforC&quot; target=&quot;_blank&quot;&gt;https://marketplace.visualstudio.com/items?itemName=GiovanniBassi-MVP.CodeCrackerforC&lt;/a&gt;，其它大部分Roslyn分析器需要安装Nuget包。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SonarAnalyzer.CSharp:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　SonarAnalyzer.CSharp是一个非常强大的代码分析器，它现阶段一共有343条规范并且主要是面向了代码的使用，包含了&lt;span&gt;缺陷检测、性能、约定、错误处理、事件、异步、测试&lt;/span&gt;等等多类规则，规则参见：&lt;a href=&quot;https://rules.sonarsource.com/csharp&quot; target=&quot;_blank&quot;&gt;https://rules.sonarsource.com/csharp&lt;/a&gt;&lt;br/&gt;　　另外SonarAnalyzer还有针对其它语言的分析器，并且还保持持续更新，项目主页：&lt;a href=&quot;https://www.sonarsource.com/products/codeanalyzers/sonarcsharp.html&quot; target=&quot;_blank&quot;&gt;https://www.sonarsource.com/products/codeanalyzers/sonarcsharp.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;在.Net Framework项目中使用代码分析器&lt;/h2&gt;
&lt;p&gt;　　本文使用StyleCop.Analyzers为例，对项目添加代码分析器。&lt;/p&gt;
&lt;h3&gt;安装StyleCop Analyzer&lt;/h3&gt;
&lt;p&gt;　　在VS中使用Roslyn的代码分析器时，其中一种方法就是通过Nuget包的方式在每一个项目中添加相应的分析器，下面就以StyleCop Analyzer为例进行介绍：&lt;br/&gt;　　通过包管理器安装StyleCop.Analyzers：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621141924135-456617813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当完成安装后分析器就回对开打的代码文件进行分析，下图是StyleCop Analyzer对默认文件的分析结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142202763-1484871002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时在项目的References/Analyzers下能看到刚安装的分析器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142225780-118589810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;设置规则&lt;/h3&gt;
&lt;p&gt;　　每一个分析器都有自己的规则集，但不是每一项规则都适合自己或团队，所以需要对相应的规则集的严重程度，严重程度分别有：None、Hidden、Info、Warning、Error，其中None是忽略规则不检测，Hidden是检测但隐藏错误。&lt;br/&gt;　　在VS中对.Net Framework项目的规则设置只需要在Analyzers的右键菜单中选择“Open Active Rule Set”即可：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142258644-179285706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就会打开一个ruleset文件的编辑窗口，窗口中包含了已生效的规则集合：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142321959-22712850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：除StyleCop Analyzers外，其它是VS中内置的规则集(最小需求规则集)，VS内置规则集信息可以选中其中一条规则，然后在属性窗口中查看(包括规则集描述、名称、资源文件、程序集所在路径等等)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142341218-1854377593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过ruleset编辑窗口可以简单的通过勾选、设置严重程度来编辑规则，当修改完成保存时，会根据项目名称创建一个ruleset文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142412112-1640113777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修改规则严重程度后原有代码会出现一下错误信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142433624-1568862260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时生成了一个名称为App.ruleset的规则集文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142503207-1421096782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;将自定义的规则使用到整个解决方案&lt;/h3&gt;
&lt;p&gt;　　上面的方式需要对每一个项目都进行独立配置，不但工作量大，而且容易出错导致不同项目中规则集不一致，为了解决这个问题，需要在一个解决方案中共享同一个规则集文件。&lt;br/&gt;　　1. 将已编辑好的规则集文件转移至一个“固定”位置(App.ruleset文件放置在与项目目录平行的目录中)：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142757720-1129363451.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621142940135-1795649863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 在项目属性窗口中的，&quot;Code Analysis&quot;选项卡中设置项目的规则集，使用放在固定位置的规则集：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143008774-1765263456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：需要重复以上操作，将解决方案内所有项目规则集设置。&lt;/span&gt;&lt;br/&gt;　　3. 开启或关闭全解决方案的代码分析功能：&lt;br/&gt;　　一般情况代码分析工具仅对已打开的代码文件，如果需要分析解决方案中的所有代码文件需要在菜单：Tools-&amp;gt;Options-&amp;gt;Text Editor-&amp;gt;C#-&amp;gt;Advanced下勾选“Enable full solution analysis”：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143037036-1791116657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当启用全解决方案代码分析时，在不打开任何代码文件的情况下会自动对所有代码进行分析，并给出相应结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143214107-1586440356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;修复代码&lt;/h3&gt;
&lt;p&gt;　　当代码分析器发现不符合规则时会把相应的信息（包括普通、警告、错误3个不同等级）显示到错误列表窗口中，双击信息即可到达有问题的代码处，通过quickly action对代码进行修复，下图是将using语句放到命名空间下的代码修复：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143247582-31640493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　注：在修复代码时，修复器提供了3种修复的范围，分别是当前文档、当前项目和解决方案，如果不符合规则的代码遍布解决方案中，那么选择一次修复解决方案会省下非常多的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143602239-1893314025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　修复结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143622771-1191467867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果遇到无法修复、修复后代码出错的情况，可以对错误进行压制(suppress)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143932537-96409406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在源代码中压制：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621143959956-1283547115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用全局压制文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144021382-472384421.png&quot; alt=&quot;&quot;/&gt;　　&lt;span&gt;注：压制菜单只会出现在对应代码行最左边的快捷活动标签上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;没有压制菜单：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144051914-980302278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;有压制菜单：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144111819-586035577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用StyleCop.Json&lt;/h3&gt;
&lt;p&gt;　　StyleCop Analyzers除了支持ruleset文件配置规则外，还支持它自己的StyleCop.Json文件配置，另外StyleCop Analyzers提供的一个自动为代码添加文件头的功能(文件头包含了文件以及修改信息)。&lt;br/&gt;　　1. 通过SA1633警告，添加一个StyleCop.Json文件：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144155453-1681329602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 将“build Action”设置为“AdditionalFiles”&lt;span&gt;(注：.Net Standard或者.Net Core中需要选择C# analyzer additional file)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144218624-1816028736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3. 编辑StyleCop.Json:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144239643-1010209157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：配置文件中的智能提示由&quot;$schema&quot;控制，并且可以在打开文件时通过右键菜单重新加载智能提示的schema。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　4. 生成文件头信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144317258-816217296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5. 通过Nuget Package的形式重用ruleset文件和StyleCop.Json，更多信息查看文档：　　&lt;a href=&quot;https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md&quot; target=&quot;_blank&quot;&gt;https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/Configuration.md&lt;/a&gt; 的Sharing configuration among solutions小节。&lt;/p&gt;
&lt;h2&gt;在.Net Core/.Net Standard项目中使用代码分析器&lt;/h2&gt;
&lt;p&gt;　　在.Net Core项目中使用代码分析器与.Net Framework项目中使用方法相似，但有一些不同的地方。&lt;br/&gt;　　1. 首先同样需要对解决方案内的所有项目安装分析器：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621144423830-1822324588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装后，出现的警告信息：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621150702481-1326745947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 修改规则集：&lt;br/&gt;　　&lt;span&gt;注：.Net Core项目没有“Open Active Rule Set”菜单，刚开始只能对特定分析器的特定规则设置严重性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621150717646-1072257364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　与此同时，当前项目生成一个以项目名称命名的ruleset文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621150737180-2088446289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　双击打开该文件时可以使用规则编辑窗口即可对该规则集进行修改：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621150807362-1180727229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：目前为止VS对.Net Core项目的代码分析支持有些细节尚未完善，本例使用VS17 15.7.3版本进行演示，一些版本相对较老的VS版本可能会出现无法创建ruleset文件(需手动根据项目名称创建)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621150836896-1942103728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　或者编辑ruleset文件时无法显示规则内容等情况：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621150918638-1956092163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时在编辑ruleset文件时，需要将Project选择All，才能看到所有的规则集。&lt;br/&gt;　　3. 解决方案共享一个规则集：&lt;br/&gt;　　&lt;span&gt;注：VS对于.Net Core类型的项目，在查看其项目属性时，没有Code Analysis选项卡，所以如果要共享规则集，除了先将规则集移动到一个固定位置外，还需要手动在每一个项目文件中添加下面XML片段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup &lt;/span&gt;&lt;span&gt;Condition&lt;/span&gt;&lt;span&gt;=&quot;'$(Configuration)|$(Platform)'=='Release|AnyCPU'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CodeAnalysisRuleSet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;..\RuleSets\My.ruleset&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CodeAnalysisRuleSet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PropertyGroup &lt;/span&gt;&lt;span&gt;Condition&lt;/span&gt;&lt;span&gt;=&quot;'$(Configuration)|$(Platform)'=='Debug|AnyCPU'&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CodeAnalysisRuleSet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;..\RuleSets\My.ruleset&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CodeAnalysisRuleSet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;PropertyGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为项目指定一个相对路径的规则集文件。&lt;br/&gt;　　当配置完规则集后，其它使用方法与.Net framework中使用方法一致。&lt;/p&gt;
&lt;h2&gt;跨IDE的代码规范解决方案&lt;/h2&gt;
&lt;p&gt;　　EditorConfig是一个用于不同编辑器或IDE之间定义、维护代码一致性的项目，它由一个代码定义格式文件和一系列的插件组成，在VS2017中微软引入对EditorConfig的支持。&lt;/p&gt;
&lt;h3&gt;在VS2017中使用EditorConfig&lt;/h3&gt;
&lt;p&gt;　　为了能够快速的添加、编辑EditorConfig文件，首先可以安装一个名为EditorConfig Language Service的拓展工具，它不仅可以快速创建editorConfig文件，还可以在编辑时提供智能提示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151301028-1211677346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建一个editorConfig文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151325607-1133163023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编辑editorConfig文件：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151346540-33684413.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;注：修改editorConfig后，需要重启VS后才会生效，不确定是否由于个别环境影响。&lt;/span&gt;&lt;br/&gt;　　VS中支持editorConfig标准规则(除每行最大长度外)、C#分析规则与.Net分析规则，标准规则主要是用于统一代码布局风格，而C#与.Net分析规则则是充分利用C#与.Net的特性给出的一些最佳实践。相同的内容还可以通过Tools-&amp;gt;Options-&amp;gt;Text Editor-&amp;gt;C#-&amp;gt;Code Style中设置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151447915-77140998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下图是字段需要通过this访问这一规则，检测出的错误信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151514733-1142771556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;在VS Code中使用代码规范工具&lt;/h3&gt;
&lt;p&gt;　　VS Code是一个轻量级的跨平台编辑器，使用VS Code开发.Net Core项目是一个非常不错的选择，并且随着时间VS Code对代码规范工具的支持也在不断完善。&lt;/p&gt;
&lt;h4&gt;使用Roslyn代码分析器&lt;/h4&gt;
&lt;p&gt;　　当一个项目通过VS配置好相应的规则集时，使用VS Code打开项目并进行编译，如果代码有未修改的代码将会出现以下提示信息：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151653879-2091949893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　相对于VS的主动分析代码来说，VS Code是被动的，需要在编译的时候才能知道有哪些代码有问题，VS Code中对C#开发是由C#组件提供支持的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151735124-1997843418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同时该组件也在关注实时检测代码的功能，更多信息参考：&lt;a href=&quot;https://github.com/OmniSharp/omnisharp-vscode/issues/43&quot; target=&quot;_blank&quot;&gt;https://github.com/OmniSharp/omnisharp-vscode/issues/43&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;使用EditorConfig&lt;/h4&gt;
&lt;p&gt;　　在VS Code中安装EditorConfig拓展：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151805275-1180008358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后就可以在VS中使用EditorConfig规范代码格式，但要注意的是，VS Code中Editor仅支持EditorConfig的标准规则。&lt;/p&gt;
&lt;h3&gt;CodeMaid&amp;amp;代码重构&lt;/h3&gt;
&lt;p&gt;　　CodeMaid是一个用于清理、简化代码的VS拓展工具，使用CodeMaid可以对代码风格进行设定(包括空行、空格、访问器、文件头，甚至还支持StyleCop的SA1504和SA1502规则)，最重要的是CodeMaid可以在保存代码时自动格式化代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151910570-755577723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　CodeMaid的配置(部分)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151923731-1778532601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码保存前：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621151941289-459404720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码保存后：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/640251/201806/640251-20180621152004370-455895190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　CodeMaid除了可以对代码风格进行自动格式化以外，还对代码的重构提供了一些有用的功能，如对代码内容根据类型(如字段、方法等)进行排序(自动或手动拖拽)。另外还对代码进行了圈复杂度(参考：&lt;a href=&quot;https://baike.baidu.com/item/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6&quot; target=&quot;_blank&quot;&gt;https://baike.baidu.com/item/%E5%9C%88%E5%A4%8D%E6%9D%82%E5%BA%A6&lt;/a&gt;)分析，当圈复杂度越高是，表示代码越难维护。&lt;br/&gt;　　&lt;span&gt;注：圈复杂度关注于代码的可测试性和维护性，与空间/时间复杂度关注性能的复杂度不同。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　本文主要介绍了.Net中常用的代码规范工具，分别是基于Roslyn的代码分析器、基于VS和EditorConfig的代码规范工具以及Code Maid一类的VS拓展工具。&lt;br/&gt;其中最强大的工具是基于Roslyn的代码分析器，这些分析器除了处理代码风格上的规范还有处理程序性能、安全性等方面的规范，同时如果代码被检测出错误时，代码是无法编译成功的，唯一的缺点是每个项目都要安装相应的代码分析器(注：有一些分析器可以通过VS拓展安装，仅需要安装一次就可以应用到所有项目)，但不管是VS还是VS Code都可以使用Roslyn的代码分析器。&lt;br/&gt;　　EditorConfig是一个轻量级代码规范工具它除了代码布局规则外还兼顾了语言本身的一些特性，如果只是对代码有简单风格要求，并且使用VS作为开发工具，那么EditorConfig是一项非常好的选择。&lt;br/&gt;　　而CodeMaid是一个不同于前两者的工具，它更直接一些，可以在保存时就应用相应的规则。&lt;br/&gt;　　合理的使用代码规范工具可以大大的提高代码质量并提高开发效率。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/code-quality/code-analysis-for-managed-code-warnings&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/visualstudio/code-quality/code-analysis-for-managed-code-warnings&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://codehollow.com/2016/08/use-code-analyzers-csharp-improve-code-quality/&quot; target=&quot;_blank&quot;&gt;https://codehollow.com/2016/08/use-code-analyzers-csharp-improve-code-quality/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://github.com/dotnet/roslyn&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/roslyn&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.c-sharpcorner.com/UploadFile/vendettamit/introducing-stylecop-with-code-analyzer-in-visual-studio-201/&quot; target=&quot;_blank&quot;&gt;https://www.c-sharpcorner.com/UploadFile/vendettamit/introducing-stylecop-with-code-analyzer-in-visual-studio-201/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://blogs.msdn.microsoft.com/devfish/2017/11/09/rigging-up-roslyn-analyzers-in-net-core/&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/devfish/2017/11/09/rigging-up-roslyn-analyzers-in-net-core/&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.guru99.com/cyclomatic-complexity.html&quot; target=&quot;_blank&quot;&gt;https://www.guru99.com/cyclomatic-complexity.html&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/visualstudio/ide/create-portable-custom-editor-options&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb429476(v=vs.80).aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/bb429476(v=vs.80).aspx&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/visualstudio/code-quality/how-to-configure-code-analysis-for-a-managed-code-project&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/visualstudio/code-quality/how-to-configure-code-analysis-for-a-managed-code-project&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb429476(v=vs.80).aspx&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/bb429476(v=vs.80).aspx&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://www.linkedin.com/pulse/stylecop-analyzer-better-code-optimization-arpit-gupta&quot; target=&quot;_blank&quot;&gt;https://www.linkedin.com/pulse/stylecop-analyzer-better-code-optimization-arpit-gupta&lt;/a&gt;&lt;br/&gt;　　&lt;a href=&quot;https://github.com/OmniSharp/omnisharp-vscode/issues/43&quot; target=&quot;_blank&quot;&gt;https://github.com/OmniSharp/omnisharp-vscode/issues/43&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 好代码是管出来的——.Net中的代码规范工具及使用&quot; href=&quot;https://www.cnblogs.com/selimsong/p/9209254.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/selimsong/p/9209254.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_8675028&quot; href=&quot;https://www.cnblogs.com/selimsong/p/8675028.html&quot;&gt;好代码是管出来的——浅谈.Net Core的代码管理方法与落地（更新中...）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Jun 2018 14:22:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/9209254.html</dc:identifier>
</item>
<item>
<title>【JVM虚拟机】（2）---GC 算法与种类 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9211095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9211095.html</guid>
<description>&lt;p&gt;  对于垃圾收集（GC）, 我们需要考虑三件事情：哪些内存需要回收？如何判断是垃圾对象？垃圾回收算法有哪些？&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、GC的工作区域&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、不是GC的工作区域&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    (1)程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭；&lt;/p&gt;
&lt;p&gt;    (2)栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作，每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具有确定性。&lt;/p&gt;
&lt;p&gt;在这几个区域不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、GC的工作区域（哪些内存需要GC回收？）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1)垃圾回收重点关注的是堆和方法区部分的内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       因为一个接口中的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分&lt;/p&gt;
&lt;p&gt;配和回收都是动态的，所以垃圾回收器所关注的主要是这部分的内存。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、垃圾对象的判定&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，哪些还活着。对象死去的时候才需要回收。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、引用计数法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。&lt;/p&gt;
&lt;p&gt;如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1)可即刻回收垃圾，每个对象都知道自己的被引用数，当counter为0时，对象就会把自己作为空闲空间连接到空闲链表，也就是在对象变成垃圾的同时就会被回收.&lt;/p&gt;
&lt;p&gt;    2）最大暂停时间短，每次通过指向mutator生成垃圾时，这部分垃圾都会被回收，大幅削减了mutator的最大暂停时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1)引用和去引用伴随加法和减法，影响性能&lt;/p&gt;
&lt;p&gt;    2)很难处理循环引用&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、可达性分析算法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      这种算法的基本思路是&lt;span&gt;通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Java语言是通过可达性分析算法来判断对象是否存活的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180621212836385-64372595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java语言里，可作为GC Roots的对象包括下面几种：&lt;/p&gt;
&lt;p&gt;      (1)虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/p&gt;
&lt;p&gt;      (2)方法区中的类静态属性引用的对象。&lt;/p&gt;
&lt;p&gt;      (3)方法区中的常量引用的对象。&lt;/p&gt;
&lt;p&gt;      (4)本地方法栈中JNI（Native方法）的引用对象。&lt;/p&gt;

&lt;h2&gt; &lt;span&gt;三、垃圾回收算法&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1、标记-清除算法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;简单来说有两个步骤：标记、清除。&lt;/p&gt;
&lt;p&gt;  (1). &lt;span&gt;标记阶段：找到所有可访问的对象，做个标记&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  (2). &lt;span&gt;清除阶段：遍历堆，把未被标记的对象回收&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180621213112064-1445464345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 缺  点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   (1)因为涉及大量的内存遍历工作，所以执行性能较低，这也会导致“stop the world”时间较长，java程序吞吐量降低；&lt;/p&gt;
&lt;p&gt;   (2)对象被清除之后，被清除的对象留下内存的空缺位置会造成内存不连续，空间浪费。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、标记整理(压缩)算法 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;标记-整理算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。&lt;/p&gt;
&lt;p&gt;     (1)、标记阶段：它的第一个阶段与标记/清除算法是一模一样的。&lt;/p&gt;
&lt;p&gt;     (2)、整理阶段：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180621213518377-283931527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲&lt;/p&gt;
&lt;p&gt;列表显然少了许多开销。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     标记/整理算法唯一的缺点就是效率也不高。不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 &lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、复制算法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      复制算法简单来说就是把内存一分为二，但只使用其中一份，在垃圾回收时，将正在使用的那份内存中存活的对象复制到另一份空白的内存中，最后将正在使用的内存空间的对象清除，完成垃圾回收。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180621213541943-2048983954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;br/&gt;       复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。&lt;br/&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;br/&gt;       复制算法的代价是将内存缩小为原来的一半，这个太要命了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意（重要）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一块为Eden（伊面区）和两块较小的&lt;/p&gt;
&lt;p&gt;Survivor（幸存区）空间(默认比例-&amp;gt;8:1:1)。每次使用Eden和其中的一块Survivor，垃圾回收时候将上述两块中存活的对象复制到另外一块Survivor上，同时清理上述Eden和Survivor。所以每次新生代就可以使用90%&lt;/p&gt;
&lt;p&gt;的内存。只有10%的内存是浪费的。(不能保证每次新生代都少于10%的对象存活，当在垃圾回收复制时候如果一块Survivor不够时候，需要老年代来分担，大对象直接进入老年代) &lt;/p&gt;
&lt;p&gt;总的来讲：&lt;span&gt;复制算法不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt; 4、三种算法总结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;相同点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      (1)三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。&lt;/p&gt;
&lt;p&gt;      (2)在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三种算法比较：&lt;/p&gt;
&lt;p&gt;       效率：&lt;span&gt;复制算法&amp;gt;标记-整理算法&amp;gt;标记-清除算法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       内存整齐度：&lt;span&gt;复制算法=标记-整理算法&amp;gt;标记-清除算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       内存利用率：&lt;span&gt;标记-整理算法=标记-清除算法&amp;gt;复制算法&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt; 5、分代收集算法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      首先这不是一种新算法，它是一种思想。现在使用的Java虚拟机并不是只是使用一种内存回收机制，而是分代收集的算法。就是将内存根据对象存活的周期划分为几块。一般是把堆分为新生代、和老年代。短命对&lt;/p&gt;
&lt;p&gt;象存放在新生代中，长命对象放在老年代中。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180621214050767-1145517463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这个图是我拷贝来的，但要记住java8以后，已经没有永久区了，之前永久区存放的东西基本上放到了元空间中。&lt;/p&gt;
&lt;p&gt;对于不同的代，采用不同的收集算法：&lt;/p&gt;
&lt;p&gt;      &lt;span&gt; 新生代：由于存活的对象相对比较少，因此可以采用复制算法该算法效率比较快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt; 老年代：由于存活的对象比较多哈，可以采用标记-清除算法或是标记-整理算法。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;   1、&lt;a href=&quot;https://www.cnblogs.com/xiaoxi/p/6486852.html&quot; target=&quot;_blank&quot;&gt;Java垃圾回收（GC）机制详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   2、&lt;a href=&quot;https://www.jianshu.com/p/424e12b3a08f&quot; target=&quot;_blank&quot;&gt;深入理解JVM：Java垃圾收集&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。少校【16】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Jun 2018 13:50:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9211095.html</dc:identifier>
</item>
<item>
<title>从头到尾谈一下HTTPS - _wind</title>
<link>http://www.cnblogs.com/wind-lanyan/p/9211037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wind-lanyan/p/9211037.html</guid>
<description>&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;“你能谈一下HTTPS吗？”&lt;/p&gt;
&lt;p&gt;“一种比HTTP安全的协议。”&lt;/p&gt;
&lt;p&gt;“...”&lt;/p&gt;
&lt;p&gt;如果面试这样说的话那差不多就gg了，其实HTTPS要展开回答的话内容还挺丰富的。本篇文章详细介绍了HTTPS是什么、为什么安全以及实现安全的方法，一起来学习吧。&lt;/p&gt;
&lt;p&gt;本文略长，请保持耐心。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;https是什么？&lt;/h2&gt;
&lt;p&gt;HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版。之所以安全是因为它在将HTTP报文发送给TCP之前，先将其发送给了一个安全层(通过SSL协议实现)对报文进行加密。&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641d56811b07830?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/6/20/1641d56811b07830?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;716&quot; data-height=&quot;375&quot;/&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;报文加密的优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;保证客户端和服务器的对话不会被其他人窃听&lt;/li&gt;
&lt;li&gt;保证双方发送的数据不会中途被修改&lt;/li&gt;
&lt;li&gt;确保双方的身份是真实客户端/服务器而不是伪造的客户端/服务器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不妨将报文想象成A给B写的一封信，A将信放在一个有锁的盒子里，那么旁人就不能获取信的内容也不能篡改信了。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;加密机制&lt;/h2&gt;
&lt;p&gt;先了解几个术语&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;明文：未加密的报文&lt;/li&gt;
&lt;li&gt;密文：通过加密算法加密后的报文&lt;/li&gt;
&lt;li&gt;密钥：改变加密算法行为的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如我们有一个加密函数，算法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; E(key, p) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将p的每一个字母向右移动key位，比如key为3则A--&amp;gt;D、B--&amp;gt;E...&lt;/span&gt;
&lt;span&gt;}

E(&lt;/span&gt;3, &quot;AB&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DE  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;明文： &quot;AB&quot; ------ 密文： &quot;DE&quot; ------ 密钥：3&lt;/p&gt;
&lt;p&gt;如果我们的密钥不一样那么我们的加密函数执行结果就会不同。&lt;/p&gt;
&lt;p&gt;下面来看一下常见的几种加密机制。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;对称加密&lt;/h3&gt;
&lt;p&gt;我们之前说过，让报文加密是为了保证我两的聊天内容是秘密的，只有我两能看懂，别人看不懂。那么我们要约定一个加密方式，比如咱俩递小纸条交流的时候把小纸条装在一个盒子里，然后只有我们有这个盒子的钥匙。其他人就算拿到这个盒子他也打不开，那就无从窃取内容了。&lt;/p&gt;
&lt;p&gt;对称加密就是这个意思：&lt;strong&gt;发送方用密钥将明文加密，接收方用同样的密钥解密。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然安全性得到了保障，但是还是存在两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送双方约定密钥时需要将密钥在网络传输，可能会造成密钥泄露，安全得不到保障。&lt;/li&gt;
&lt;li&gt;就是发送方与接收方在互相对话之前一定要有有一个共享密钥。试想，如果N个客户端都要与服务器建立安全通信，那么服务器需要保存N个密钥，N和客户端和N个服务器通信，那么将有N^2个密钥，管理起来非常不便。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;非对称加密和对称加密是反着干的，对称加密是使用同一个密钥，而非对称加密使用了两个不同的密钥：公钥、私钥，&lt;strong&gt;一个密钥加密的内容只能由另一个密钥解开。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公钥是众所周知的，而私钥只有主机才持有。&lt;/p&gt;
&lt;p&gt;服务器生成了公钥A和私钥B，当客户端想给该服务器发送报文时，首先找到服务器的公钥，然后根据公钥A将报文加密，服务器用私钥B解密。同理，当服务器想给该客户端发送报文时，首先找到客户端的公钥，然后根据公钥A将报文加密，客户端用私钥B解密。&lt;/p&gt;
&lt;p&gt;在确保了信息安全的同时又可以方便密钥的管理。&lt;/p&gt;
&lt;p&gt;由此，对称加密和非对称加密的区别是：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;.&lt;/th&gt;
&lt;th&gt;对称加密&lt;/th&gt;
&lt;th&gt;非对称加密&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;密钥&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;加密解密用相同密钥&lt;/td&gt;
&lt;td&gt;公钥、私钥，一个加密另一个解密&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;密钥管理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;密钥数量大，不方便&lt;/td&gt;
&lt;td&gt;每个主机只需管理一对公钥、私钥&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;安全性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不安全（并非该机制不安全，而是双方在约定密钥时可能会密钥泄露）&lt;/td&gt;
&lt;td&gt;安全（不需要通过对话约定密钥）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;加/解密速度&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;那HTTPS是采用的什么机制呢？&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;HTTPS加密机制&lt;/h2&gt;
&lt;p&gt;剧透，HTTPS&lt;strong&gt;对报文&lt;/strong&gt;采用的对称加密。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;完整的一次HTTPS交流&lt;/h3&gt;
&lt;p&gt;(1) 客户端通过TCP三次握手建立到服务器端口443（HTTPS的默认端口）的TCP连接&lt;/p&gt;
&lt;p&gt;(2) 客户端通过SSL握手建立安全层&lt;/p&gt;
&lt;p&gt;(3) 客户端发送http报文到SSL安全层，安全层将报文加密后发给TCP --&amp;gt; IP --&amp;gt; ...&lt;/p&gt;
&lt;p&gt;(4) 同理服务器发送响应，客户端接收后通过SSL安全层解密发给应用层&lt;/p&gt;
&lt;p&gt;(5) SSL安全层关闭通知&lt;/p&gt;
&lt;p&gt;(6) TCP关闭连接&lt;/p&gt;
&lt;p&gt;从上面的描述可以清晰的看到我们的报文加密/解密都是在SSL安全层执行。&lt;/p&gt;
&lt;p&gt;那么安全层是怎么加密的？密钥又是怎么约定的？这一切的一切都得仔细聊聊第(2)步骤。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;SSL握手&lt;/h3&gt;
&lt;p&gt;(1) 客户端向服务器发送可供选择的加密算法并请求证书。&lt;/p&gt;
&lt;p&gt;客户端说：“嘿，小子。我这里有一堆我支持的加密算法，你选一个你喜欢的发给我。对了，顺便把你的身份证复印件发给我看看，我怕我连接的服务器是伪造的。”&lt;/p&gt;
&lt;p&gt;(2) 服务器发送选中的加密算法和证书&lt;/p&gt;
&lt;p&gt;服务器说：“emmm...我看加密算法A挺好的，咱俩就用这个吧。证书也发给你，证明我不是坏人。”&lt;/p&gt;
&lt;p&gt;(3) 客户端保存服务器选择的加密算法和秘钥A以作为日后加密，将A用服务器的公钥B加密后发给服务器，服务器用自己的秘钥C解密后得到A，从此客户端和服务器都用约定的加密算法以及秘钥A进行对称加密。&lt;/p&gt;
&lt;p&gt;（看到了伐？先用非对称加密在网络中传输对称加密的秘钥A，之后对报文都是采用对称加密啦。）&lt;/p&gt;
&lt;p&gt;(4) 客户端和服务器互相告知，开始加密过程。&lt;/p&gt;
&lt;p&gt;在SSL握手之后我们就可以开开心心的发送和接收加密报文啦。&lt;/p&gt;
&lt;p&gt;以上是HTTPS加密的全过程，不过还不足以构成完整的HTTPS，&lt;strong&gt;因为完整的HTTPS要保障两个方面的安全：报文安全、身份安全&lt;/strong&gt;，加密只能保证报文是安全的，不能保证身份是正确的。&lt;/p&gt;
&lt;p&gt;试想，A和B互相写信并且交换盒子钥匙，然后将信放盒子里寄出去，上面的加密行为可以让A和B之间写的信内容不会被他人获取，但是如果一开始和A通信的就不是B呢？是窃取者C伪装成B和A通信，那么A会和C在SSL的时候就交流钥匙然后C可以窃取A写给B的信的内容。&lt;/p&gt;
&lt;p&gt;身份的认证我们用数字证书。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-9&quot;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;含有数字证书的报文的结构：&lt;/p&gt;
&lt;p&gt;刚刚SSL握手的第(1)步还记得伐？客户端向服务器索要证书，这个证书是服务器可以证明自己身份的东西，该证书里包含了服务器的一些基本信息，比如站点的DNS主机名、该站点组织名、站点的公钥（发公钥就是为了让客户端SSL方便执行握手(3)）等，以及证书的序列号、证书签名算法、过期日期等证书信息。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-10&quot;&gt;数字签名&lt;/h3&gt;
&lt;p&gt;证书是一个站点的身份证，但是身份证也可以被伪造，为了保证这个证书是真的我们需要数字签名。我们会将证书内容用签名算法生成一个值，我们称之为“摘要”。然后将该摘要用主机的私钥加密，加密后的内容就是我们的数字签名。&lt;/p&gt;

&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/6/21/1642270899ce9210?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/6/21/1642270899ce9210?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;217&quot; data-height=&quot;377&quot;/&gt; 当客户端收到附带数字签名的数字证书时，会通过数字证书中的证书签名算法将该证书生成一个摘要，在用服务器众所周知的公钥解密数字签名，看得到的摘要是否相同，相同那就说明证书是真的。

&lt;p&gt;如果公钥解密后得到的摘要与生成的摘要不符那么可能有两种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送方身份不是目的主机&lt;/li&gt;
&lt;li&gt;目的主机发送的证书被篡改&lt;/li&gt;
&lt;/ul&gt;
&lt;img class=&quot;lazyload inited loaded&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/6/21/164226a52610057f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot; data-src=&quot;https://user-gold-cdn.xitu.io/2018/6/21/164226a52610057f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; data-width=&quot;950&quot; data-height=&quot;502&quot;/&gt;
&lt;p&gt;数字证书和加密就构成了一个完整的HTTPS事务。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-11&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;HTTPS之所以安全是因为有两个保障
&lt;ul&gt;&lt;li&gt;双方的会话内容加密，旁人不能窃取&lt;/li&gt;
&lt;li&gt;双方的身份是真实的，防止窃取者伪造身份&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;内容安全
&lt;ul&gt;&lt;li&gt;非对称加密机制加密“对称加密所需密钥”&lt;/li&gt;
&lt;li&gt;对称加密机制加密报文&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;身份安全
&lt;ul&gt;&lt;li&gt;数字证书&lt;/li&gt;
&lt;li&gt;数字签名
&lt;ul&gt;&lt;li&gt;确认发送方身份&lt;/li&gt;
&lt;li&gt;确认证书未被篡改&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;参考书籍：&lt;/p&gt;
&lt;p&gt;《HTTP权威指南》&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 21 Jun 2018 13:30:00 +0000</pubDate>
<dc:creator>_wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wind-lanyan/p/9211037.html</dc:identifier>
</item>
</channel>
</rss>