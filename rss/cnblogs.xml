<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>mysql8.0 在window环境下的部署与配置 - Jack2014</title>
<link>http://www.cnblogs.com/jackmary/p/9746454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackmary/p/9746454.html</guid>
<description>&lt;p&gt;今天在阿里云window服务器上配置mysql环境，踩了一些坑，分享出来。需要的朋友可以看看。额，或许有人要吐槽我为什么不在linux上去配置，额，因为我window的那台服务器配置相对高些。本人技术方面偏向于.net,现在接触php项目所以搭建LAMP环境。只不过我的数据库放在window上的这台服务器。&lt;/p&gt;&lt;p&gt;言归正传&lt;/p&gt;

&lt;p&gt;先选择版本，到&lt;strong&gt;&lt;a href=&quot;https://www.mysql.com/downloads/&quot; target=&quot;_blank&quot;&gt;mysql官方网站&lt;/a&gt;&lt;/strong&gt;下载，你会发现各宗版本看得眼花缭乱的，不要惊慌先选择MySQL Community Edition版， 然后再跳转的页面下，你会发现还会有很多子版本要选，英文要不好的同学，选择上会有点吃力，可选子版本有两个：&lt;/p&gt;
&lt;p&gt;（1）先说 一个是最省事的版本 ，直接下一步下一步安装就好，有点像sqlserver  纯界面展示。 https://dev.mysql.com/downloads/installer/  ,配置比较高的服务器，或懒得去搞一堆命令行的朋友可以直接下载这个。看完这里可以直接省略下面的内容了。&lt;/p&gt;
&lt;p&gt;  (2) 第二个版本，&lt;a href=&quot;http://www.cnblogs.com/jackmary/p/mysqld%20--console%20--skip-grant-tables%20--shared-memory&quot; target=&quot;_blank&quot;&gt;MySQL Community Server&lt;/a&gt;版本。 这个版本比较适合服务器安装。占用资源较小。部署也比较灵活。缺点如果不熟悉的话坑会比较多。  &lt;/p&gt;
&lt;p&gt; 我们先快速的说下 安装的步骤，先下载文件，解压缩到目标文件夹位置.比如 D:/mysql 。&lt;/p&gt;
&lt;p&gt;1，在mysql文件夹 下新建一个文件名为my.ini , 然后录入信息如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8 
[mysqld]
#设置3306端口
port = 3306 
# 设置mysql的安装目录
basedir=D:/mysql
# 设置mysql数据库的数据的存放目录
datadir=D:/mysql/data
# 允许最大连接数
max_connections=500
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2，这个时候打开CMD（记得以管理员身份运行），&lt;span&gt;否则输入命令时会出现install/remove of the service denied错误，&lt;span&gt;进入mysql文件夹。&lt;span&gt;&lt;span&gt;c&lt;/span&gt;&lt;/span&gt;d d:/mysql/bin（如果不想每次都cd进到这个目录，可以将该路径添加到 path路径下）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;录中输入命令mysqld install&lt;/p&gt;&lt;p&gt;2显示成功之后再输入mysqld --initialize 此时无任何提示(电脑卡就等一会)&lt;/p&gt;&lt;p&gt;3再输入：net start mysql 显示：服务正在启动...服务已经启动启动成功！&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;好！！接着我来说说我遇到的坑&lt;/p&gt;
&lt;p&gt;问题1： 安装mysql服务时提示“找不到msvcp140.dll？&lt;/p&gt;
&lt;p&gt;我服务器的版本是windows server 2012 r2 版本的。刚开始输入命令行的时候报这个错。是因为缺少这个补丁Microsoft Visual C++ 2015 Redistributable Update 3&lt;/p&gt;
&lt;p&gt;下载地址  https://www.microsoft.com/en-us/download/details.aspx?id=53587&lt;/p&gt;

&lt;p&gt;问题2：安装好服务后，有的时候运气好，默认初始版本密码是空的。但有的时候密码为空是登陆不进去的。好问题来了，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
D:\mysql\bin&amp;gt;mysql -uroot -p
Enter password:
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;密码为空 ，登陆不进去，很是烦躁一万只草泥马路过，看了很多帖子，都是处理mysql5.11 的 现在8.0 处理不了。接着找办法&lt;/p&gt;&lt;p&gt;这个时候需要 关闭sql服务，在控制面板里面的服务，找到mysql关掉。 也可以用命令行 net stop mysql 是关闭MySQL服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/636205/201810/636205-20181006001748471-357221825.png&quot; alt=&quot;&quot; width=&quot;982&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;br/&gt;在服务器上用以下方式跳过登陆，进入mysql，在cmd中安装一下方式操作 &lt;span&gt;mysqld --console --skip-grant-tables --shared-memory&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;br/&gt;D:\mysql\bin&amp;gt;mysqld --console --skip-grant-tables --shared-memory&lt;br/&gt;2018-10-05T16:22:02.055800Z 0 [System] [MY-010116] [Server] D:\mysql\bin\mysqld.exe (mysqld 8.0.12) starting as process 9440&lt;br/&gt;2018-10-05T16:22:06.832563Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.&lt;br/&gt;2018-10-05T16:22:06.914520Z 0 [System] [MY-010931] [Server] D:\mysql\bin\mysqld.exe: ready for connections. Version: '8.0.12'  socket: ''  port: 0  MySQL Community Server - GPL.&lt;br/&gt;2018-10-05T16:22:06.977960Z 0 [Warning] [MY-011311] [Server] Plugin mysqlx reported: 'All I/O interfaces are disabled, X Protocol won't be accessible'&lt;br/&gt;2018-10-05T16:22:12.006067Z 0 [System] [MY-013105] [Server] D:\mysql\bin\mysqld.exe: Normal shutdown.&lt;br/&gt;D:\mysql\bin&amp;gt;2018-10-05T16:22:13.198096Z 0 [System] [MY-010910] [Server] D:\mysql\bin\mysqld.exe: Shutdown complete (mysqld 8.0.12)  MySQL Community Server - GPL.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;
&lt;pre readability=&quot;8&quot;&gt;
此时，重新打开一个CMD窗口 ，之前的窗口保留着不要关闭！。按如下步骤操作&lt;p&gt;mysql -u root;     # 这里切记不要 加 -p。 要不会强制要你输入密码才能登陆
update user set authentication_string='' where user='root';   # 此时密码一定要留空！数据库里面的密码默认是加密过的，以前的password（123）函数在8.0版本后就不能用了。
flush privileges;　(不提交不生效)
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 root帐户终于有了初始密码，此时密码为空!!,也只能为空！！否则你会登陆不进去的 ，存储进去会像md5 一样加密过的字符串在表里。&lt;/p&gt;

&lt;p&gt;问题3 ， 如何修改root 密码&lt;/p&gt;
&lt;p&gt;alter user 'root'@'%' identified by '123';&lt;/p&gt;
&lt;p&gt;或&lt;br/&gt;alter user 'root'@'localhost' identified by '123';&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;退出 quit； 打开cmd  ，进入mysql安装目录/bin&lt;br/&gt;mysqladmin -uroot -p password 123 &lt;/p&gt;

&lt;p&gt;此时，基本上解决 了mysql的服务端的问题了，现在我们把焦点移动到客户端。  假设现在的场景服务端和客户端不在同一台机子上。 我们需要安装下客户端的工具&lt;/p&gt;
&lt;p&gt;推荐两个工具 第一个是mysql的 &lt;a href=&quot;https://dev.mysql.com/downloads/workbench/&quot; target=&quot;_blank&quot;&gt;MySQL Workbench&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/636205/201810/636205-20181006003905132-1456632461.png&quot; alt=&quot;&quot; width=&quot;1143&quot; height=&quot;669&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第二个是 Navicat Premium 12 工具，破解版就自己去找啦。相对 这个工具可以帮你剩下很多事，比如对命令行比较不在行的同学可以选下的这个版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/636205/201810/636205-20181006003858374-1101022925.png&quot; alt=&quot;&quot; width=&quot;1096&quot; height=&quot;458&quot;/&gt;&lt;/p&gt;

&lt;p&gt;问题4 ，无法远程登陆访问远程服务器上面的mysql&lt;/p&gt;
&lt;p&gt;就是用上面两个客户端工具 ，都无法登陆服务器，因为默认mysql是不让客户端远程登陆的，这个时候 第一步需要检查阿里云服务器的安全组策略，添加3306 端口的入口，&lt;/p&gt;
&lt;p&gt;第二步，回到服务器 ，进入cmd ，将原先表中的数据 localhost改成 ‘%’ ， 也可以改成 指定的ip地址 如 ‘192.168.0.0，192.168.0.1，192.168.0.2’&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mysql -u root -pvmwaremysql&amp;gt;use mysql;
mysql&amp;gt;update user set host = '%' where user = 'root';
mysql&amp;gt;select user, authentication_string from user;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改好后，这时 ，&lt;a href=&quot;https://dev.mysql.com/downloads/workbench/&quot; target=&quot;_blank&quot;&gt;MySQL Workbench&lt;/a&gt; ，你会发现可以登陆进去了。但是 Navicat Premium ，会报出“客户端连接caching-sha2-password问题” 这个是由于mysql 不太愿意让第三方工具接入客户端查询，&lt;/p&gt;
&lt;p&gt;在密码反编译的时候故意没有对接好。接着我们来处理最后一个问题.&lt;/p&gt;

&lt;p&gt;问题5 : Navicat Premium 客户端连接caching-sha2-password问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; #修改加密规则

  ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; #更新一下用户的密码  

 FLUSH PRIVILEGES; #刷新权限 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意了！ 如果你在问题4中已经把localhost 改成 % 的 ，  上面的语句 也要跟着改  比如：'root'@'%'，如果是跟着ip的 也以此类推！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再重置下密码：alter user 'root'@'localhost' identified by '123qwe';&lt;/p&gt;

&lt;p&gt;最后 基本上常见的坑就踩完了，写的有点粗糙，熬夜分销的一点心得，大家凑乎这看吧。&lt;/p&gt;

</description>
<pubDate>Fri, 05 Oct 2018 16:54:00 +0000</pubDate>
<dc:creator>Jack2014</dc:creator>
<og:description>今天在阿里云window服务器上配置mysql环境，踩了一些坑，分享出来。需要的朋友可以看看。额，或许有人要吐槽我为什么不在linux上去配置，额，因为我window的那台服务器配置相对高些。本人技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackmary/p/9746454.html</dc:identifier>
</item>
<item>
<title>Java中的设计模式（七）：观察者模式 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9746433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9746433.html</guid>
<description>&lt;p&gt;观察者模式是行为设计模式之一。当您对对象的状态感兴趣并希望在有任何更改时收到通知时，观察者设计模式非常有用。在观察者模式中，监视另一个对象状态的对象称为Observer，正在被监视的对象称为Subject。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181006002813149-404293060.png&quot;/&gt;&lt;br/&gt;根据GoF，观察者设计模式的意图是;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;定义对象之间的一对多依赖关系，以便当一个对象更改状态时，将自动通知和更新其所有依赖项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Subject&lt;/strong&gt;包含一个观察者列表，用于通知其状态的任何变化，因此它应该提供观察者可以注册和注销自己的方法。Subject还包含一种方法，用于通知所有观察者任何更改，并且可以在通知观察者时发送更新，或者它可以提供另一种方法来获取更新。&lt;/p&gt;
&lt;p&gt;Observer应该有一个方法来设置要监视的对象，以及Subject将使用的另一个方法来通知它们任何更新。&lt;br/&gt;Java提供了内置平台，用于通过java.util.Observable类和java.util.Observer接口实现Observer模式。但是它没有被广泛使用，因为实现非常简单，并且大多数时候我们不希望最终扩展类只是为了实现Observer模式，因为java不在类中提供多重继承。&lt;/p&gt;
&lt;p&gt;Java消息服务（JMS）使用Observer设计模式以及Mediator模式，允许应用程序订阅数据并将数据发布到其他应用程序。&lt;/p&gt;
&lt;p&gt;模型 - 视图 - 控制器（MVC）框架也使用Observer模式，其中Model是Subject，而Views是观察者，可以注册以获得对模型的任何更改的通知。&lt;/p&gt;

&lt;p&gt;对于我们的观察者模式java程序示例，我们将实现一个简单的Subject，观察者可以注册到这个Subject。每当有任何新消息发布到Subject时，将通知所有寄存器观察者并且他们可以使用该消息。&lt;/p&gt;
&lt;p&gt;根据Subject的要求，这里是基础Subject接口，它定义了由任何具体Subject实现的契约方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.observer;

public interface Subject {

    //methods to register and unregister observers
    public void register(Observer obj);
    public void unregister(Observer obj);
    
    //method to notify observers of change
    public void notifyObservers();
    
    //method to get updates from subject
    public Object getUpdate(Observer obj);
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们将为Observer创建契约，将有一个方法将Subject附加到观察者，以及Subject要用来通知任何更改的另一个方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.observer;

public interface Observer {
    
    //method to update the observer, used by subject
    public void update();
    
    //attach with subject to observe
    public void setSubject(Subject sub);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们的契约准备好了，让我们继续我们Subject的具体实施。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.observer;

import java.util.ArrayList;
import java.util.List;

public class MyTopic implements Subject {

    private List&amp;lt;Observer&amp;gt; observers;
    private String message;
    private boolean changed;
    private final Object MUTEX= new Object();
    
    public MyTopic(){
        this.observers=new ArrayList&amp;lt;&amp;gt;();
    }
    @Override
    public void register(Observer obj) {
        if(obj == null) throw new NullPointerException(&quot;Null Observer&quot;);
        synchronized (MUTEX) {
        if(!observers.contains(obj)) observers.add(obj);
        }
    }

    @Override
    public void unregister(Observer obj) {
        synchronized (MUTEX) {
        observers.remove(obj);
        }
    }

    @Override
    public void notifyObservers() {
        List&amp;lt;Observer&amp;gt; observersLocal = null;
        //synchronization is used to make sure any observer registered after message is received is not notified
        synchronized (MUTEX) {
            if (!changed)
                return;
            observersLocal = new ArrayList&amp;lt;&amp;gt;(this.observers);
            this.changed=false;
        }
        for (Observer obj : observersLocal) {
            obj.update();
        }

    }

    @Override
    public Object getUpdate(Observer obj) {
        return this.message;
    }
    
    //method to post message to the topic
    public void postMessage(String msg){
        System.out.println(&quot;Message Posted to Topic:&quot;+msg);
        this.message=msg;
        this.changed=true;
        notifyObservers();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册和取消注册观察者的方法实现非常简单，额外的方法是postMessage()，户端应用程序将使用它将String消息发布到主题。请注意布尔变量，以跟踪主题状态的变化并用于通知观察者。此变量是必需的，因此如果没有更新并且某人调用notifyObservers()，则它不会向观察者发送错误通知。&lt;/p&gt;
&lt;p&gt;还要注意在notifyObservers()方法中使用同步，以确保仅将通知发送给在将消息发布到主题之前注册的观察者。&lt;/p&gt;
&lt;p&gt;以下是将观察主题的观察者的实施。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.observer;

public class MyTopicSubscriber implements Observer {
    
    private String name;
    private Subject topic;
    
    public MyTopicSubscriber(String nm){
        this.name=nm;
    }
    @Override
    public void update() {
        String msg = (String) topic.getUpdate(this);
        if(msg == null){
            System.out.println(name+&quot;:: No new message&quot;);
        }else
        System.out.println(name+&quot;:: Consuming message::&quot;+msg);
    }

    @Override
    public void setSubject(Subject sub) {
        this.topic=sub;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意update()方法的实现，它调用Subject getUpdate()方法来获取要使用的消息。我们可以通过将message作为参数传递给update()方法来避免这种调用。&lt;/p&gt;
&lt;p&gt;这是一个简单的测试程序，用于使用我们的Subject主题实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.observer;

public class ObserverPatternTest {

    public static void main(String[] args) {
        //create subject
        MyTopic topic = new MyTopic();
        
        //create observers
        Observer obj1 = new MyTopicSubscriber(&quot;Obj1&quot;);
        Observer obj2 = new MyTopicSubscriber(&quot;Obj2&quot;);
        Observer obj3 = new MyTopicSubscriber(&quot;Obj3&quot;);
        
        //register observers to the subject
        topic.register(obj1);
        topic.register(obj2);
        topic.register(obj3);
        
        //attach observer to subject
        obj1.setSubject(topic);
        obj2.setSubject(topic);
        obj3.setSubject(topic);
        
        //check if any update is available
        obj1.update();
        
        //now send message to subject
        topic.postMessage(&quot;New Message&quot;);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们运行上面的程序时，我们得到以下输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Obj1:: No new message
Message Posted to Topic:New Message
Obj1:: Consuming message::New Message
Obj2:: Consuming message::New Message
Obj3:: Consuming message::New Message&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181006002748583-753140917.png&quot;/&gt;&lt;br/&gt;观察者设计模式也称为发布 - 订阅模式。其中一些实现是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Swing中的java.util.EventListener&lt;/li&gt;
&lt;li&gt;javax.servlet.http.HttpSessionBindingListener&lt;/li&gt;
&lt;li&gt;javax.servlet.http.HttpSessionAttributeListener&lt;/li&gt;
&lt;li&gt;java.util.Observer&lt;/li&gt;
&lt;li&gt;java.util.EventListener&lt;/li&gt;
&lt;li&gt;javax.servlet.http.HttpSessionBindingListener&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在以下任何一种情况下使用Observer模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个对象中进行更改会导致其他对象发生更改&lt;/li&gt;
&lt;li&gt;当抽象有两个方面时，一个依赖于另一个。将这些方面封装在单独的对象中可让您独立地改变和重用它们。&lt;/li&gt;
&lt;li&gt;当一个对象的更改需要更改其他对象时，您不知道需要更改多少个对象。&lt;/li&gt;
&lt;li&gt;当一个对象应该能够通知其他对象而不假设这些对象是谁。换句话说，您不希望这些对象紧密耦合。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是java中的Observer设计模式，我希望你喜欢它。与评论分享您的爱，并与他人分享。&lt;br/&gt;翻译于：&lt;a href=&quot;https://www.journaldev.com/1739/observer-design-pattern-in-java&quot;&gt;observer-design-pattern-in-java&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 16:29:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>介绍 观察者模式是行为设计模式之一。当您对对象的状态感兴趣并希望在有任何更改时收到通知时，观察者设计模式非常有用。在观察者模式中，监视另一个对象状态的对象称为Observer，正在被监视的对象称为Su</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9746433.html</dc:identifier>
</item>
<item>
<title>Java网络编程-HTTP协议 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9746384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9746384.html</guid>
<description>&lt;p&gt;这篇文章暂时不研究HTTP底层的TCP/IP的握手和挥手过程，只从表面的交互流程分析HTTP协议。&lt;/p&gt;
&lt;p&gt;HTTP英文全称是Hypertext Transfer Protpcol，也就是超文本传输协议。HTTP是一个标准，定义了Web客户端如何与服务器对话以及数据如何从服务器传回到客户端。在日常开发和使用过程中，HTTP经常被认为是一种用于传输HTML文件和文件中内嵌的图片的协议或者手段，实际上HTTP是一种通用的网络数据传输格式，它的传输内容不仅仅局限于HTML文件或者图片，也可以用来传输Microsoft Word文档甚至是Windows的exe文件等等，所有可以用字节序列表示的数据都可以使用HTTP进行传输。&lt;/p&gt;
&lt;p&gt;HTTP通过TCP/IP进行数据传输，如果忽略底层的TCP协议的握手和挥手的细节，对于从客户端到服务器的每一个请求和请求的响应，在HTTP1.0有下面几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、默认情况下，客户端在端口80开启与服务器的一个TCP连接，当然也可以指定其他的端口。&lt;/li&gt;
&lt;li&gt;2、客户端向服务器发送消息，请求指定路径上的资源。一个HTTP请求包括一个首部，可选项包括一个空行和这次请求的数据。&lt;/li&gt;
&lt;li&gt;3、服务器向客户端发送响应。响应以响应码开头，接着是包含元数据的首部，可选项包括一个空行以及所请求的文档数据或者错误信息。&lt;/li&gt;
&lt;li&gt;4、服务器关闭TPC连接。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在HTTP1.1(目前最常用的就是HTTP1.1)以及以后的HTTP版本中，可以通过一个TCP连接连续发送多个请求和接收多个响应。也就是说，上面的1和4步骤中间的2和3步骤可以反复执行多次。另外，HTTP1.1中，请求数据和响应数据可以分块发送，提高了扩展性。&lt;/p&gt;

&lt;p&gt;HTTP中定义了多种请求方法，用于标识当次请求需要完成什么类型的操作，常用的HTTP请求方法有GET、HEAD、PUT、POST、PATCH、TRACE、OPTIONS、DELETE。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;通常用于请求服务器获取某个资源&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;类似于GET，但是响应结果中不包含响应体，只包含协议信息和首部，通常用于测试资源是否存在或者是否被修改&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;POST&lt;/td&gt;
&lt;td&gt;客户端向服务器提交数据(支持HTML的表单数据)，可能会导致新的资源的建立或者已有资源的修改&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PUT&lt;/td&gt;
&lt;td&gt;从客户端向服务器传送的数据取代指定的文档的内容(全部取代)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PATCH&lt;/td&gt;
&lt;td&gt;客户端向服务器传送的数据取代指定的文档的内容(部分取代)&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TRACE&lt;/td&gt;
&lt;td&gt;回显客户端请求服务器的原始请求报文，用于&quot;回环&quot;诊断&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td&gt;请求服务器获取服务器支持的各种功能，可以询问服务器支持什么类型的HTTP方法，一般用于性能测试&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DELETE&lt;/td&gt;
&lt;td&gt;请求服务器删除指定的资源&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面说到的&quot;是否安全&quot;的选项是&quot;是&quot;，意味着使用该种HTTP请求方法不会发生任何数据的修改或者更新动作，也就是请求多次也不会影响到资源的状态。如果&quot;是否幂等&quot;的选项是&quot;是&quot;，意味着使用该HTTP请求方法请求多次HTTP调用，无论调用多少次，请求结果或者资源的状态是一样的(可以理解为只有首次调用是真正修改了资源的状态，从第二次调用开始后面的调用只获取到第一次调用的结果)。HTTP方法的安全性和幂等性是我们在设计HTTP接口时候需要重点考虑的两个因素。&lt;/p&gt;
&lt;p&gt;值得注意的是：上面提到的POST和PUT方法的功能可以理解为相同的，两者的主要区别在于POST不是幂等的，而PUT是幂等的。在目前的Web开发中，POST方法已经被滥用，一般很少人会使用PUT，除非是推崇RESTFUL风格编程。PUT方法和PATCH方法的功能类似，都是用客户端请求的数据去替换掉服务器中指定文档中的内容，不过PUT方法是全部替换，而PATCH方法是部分替换。&lt;/p&gt;
&lt;p&gt;PS：上面的方法只是HTTP协议中的请求方法的一些规范，没有硬性规定一定要遵循。&lt;/p&gt;

&lt;p&gt;JDK中常见的HTTP状态码可以在类java.net.HttpURLConnection中找到，总结一下如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;26&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;信息状态码。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不常见，暂不考虑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;服务器准备接受请求主体，客户端发送请求主体；这允许客户端在请求发送大量数据之前询问服务器是否接受请求。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不常见，暂不考虑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Switching Protocols&lt;/td&gt;
&lt;td&gt;服务器接受客户端在Upgrade首部字段中要求改变应用的协议请求，如从HTTP转换为WebSockets。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;不常见，暂不考虑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;表示请求成功。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;最常见的响应码，代表请求成功。如果请求方法是GET或者POST，所请求的数据与正常的首部都包含在响应体中。如果请求方法是HEAD，则只包含首部信息。&lt;/td&gt;
&lt;td&gt;HTTP_OK&lt;/td&gt;
&lt;td&gt;处理请求成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;服务器已经在响应体中指定的URL创建了对应的资源。客户端现在应当尝试加载该URL。这个响应码只在响应POST请求时发送。&lt;/td&gt;
&lt;td&gt;HTTP_CREATED&lt;/td&gt;
&lt;td&gt;创建成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;202&lt;/td&gt;
&lt;td&gt;Accepted&lt;/td&gt;
&lt;td&gt;表示请求已经被处理，但是处理尚未结束，所以不会返回任何响应数据。&lt;/td&gt;
&lt;td&gt;HTTP_ACCEPTED&lt;/td&gt;
&lt;td&gt;接受请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;203&lt;/td&gt;
&lt;td&gt;Non-Authoritative Information&lt;/td&gt;
&lt;td&gt;由缓存代理或者其他本地源返回资源的表示，不能保证是最新的。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_AUTHORITATIVE&lt;/td&gt;
&lt;td&gt;无权威的返回结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;No Content&lt;/td&gt;
&lt;td&gt;服务器已经成功处理了该请求，但是没有信息发回给客户端。一般是由于服务器上的表单处理逻辑的问题，只接收数据不返回数据。&lt;/td&gt;
&lt;td&gt;HTTP_NO_CONTENT&lt;/td&gt;
&lt;td&gt;无返回内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;205&lt;/td&gt;
&lt;td&gt;Reset Content&lt;/td&gt;
&lt;td&gt;服务器已经成功处理了该请求，但是没有信息发回给客户端。客户端应该清除发送请求的表单信息。&lt;/td&gt;
&lt;td&gt;HTTP_RESET&lt;/td&gt;
&lt;td&gt;重置内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial Content&lt;/td&gt;
&lt;td&gt;服务器返回客户端请求的资源的部分内容，而不是整个文档。&lt;/td&gt;
&lt;td&gt;HTTP_PARTIAL&lt;/td&gt;
&lt;td&gt;部分内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;重定向。&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;Multiple Choices&lt;/td&gt;
&lt;td&gt;服务器为所请求的文档提供一组不同的表示。&lt;/td&gt;
&lt;td&gt;HTTP_MULT_CHOICE&lt;/td&gt;
&lt;td&gt;多重选择&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;资源已经移动到一个新的URL。客户端应当自动加载这个URL的资源。&lt;/td&gt;
&lt;td&gt;HTTP_MOVE_PERM&lt;/td&gt;
&lt;td&gt;永久移动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Moved Temporarity&lt;/td&gt;
&lt;td&gt;资源暂时移动到一个新的URL，但其位置在不久的将来还会再次改变。&lt;/td&gt;
&lt;td&gt;HTTP_MOVE_TEMP&lt;/td&gt;
&lt;td&gt;临时移动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;客户端错误&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;客户端向服务器发出的请求使用了不正确的语法。&lt;/td&gt;
&lt;td&gt;HTTP_BAD_REQUEST&lt;/td&gt;
&lt;td&gt;错误请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;访问这个URL需要身份验证，一般是用户名和口令。&lt;/td&gt;
&lt;td&gt;HTTP_UNAUTHORIZED&lt;/td&gt;
&lt;td&gt;未授权&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;服务器理解请求，但是有意拒绝进行处理。&lt;/td&gt;
&lt;td&gt;HTTP_FORBIDDEN&lt;/td&gt;
&lt;td&gt;禁止访问&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;最常见的错误响应，指示服务器找不到所请求的资源。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_FOUND&lt;/td&gt;
&lt;td&gt;未找到资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;Method Not Allowed&lt;/td&gt;
&lt;td&gt;请求方法不支持用于请求指定的资源。&lt;/td&gt;
&lt;td&gt;HTTP_BAD_METHOD&lt;/td&gt;
&lt;td&gt;方法禁用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;406&lt;/td&gt;
&lt;td&gt;Not Acceptable&lt;/td&gt;
&lt;td&gt;所请求的资源不能以客户端希望的格式提供，客户端期望的格式由请求HTTP首部Accept字段指定。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_ACCEPTABLE&lt;/td&gt;
&lt;td&gt;不接受&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;服务端错误&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internale Server Error&lt;/td&gt;
&lt;td&gt;服务器内部异常。&lt;/td&gt;
&lt;td&gt;HTTP_SERVER_ERROR&lt;/td&gt;
&lt;td&gt;服务器异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;501&lt;/td&gt;
&lt;td&gt;Not Implemented&lt;/td&gt;
&lt;td&gt;服务器不具备完成请求的功能。&lt;/td&gt;
&lt;td&gt;HTTP_NOT_IMPLEMENTED&lt;/td&gt;
&lt;td&gt;尚未实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;502&lt;/td&gt;
&lt;td&gt;Bad Gateway&lt;/td&gt;
&lt;td&gt;服务器作为网关或代理，从上游服务器收到无效响应。&lt;/td&gt;
&lt;td&gt;HTTP_BAD_GATEWAY&lt;/td&gt;
&lt;td&gt;错误网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;503&lt;/td&gt;
&lt;td&gt;Service Unavailable&lt;/td&gt;
&lt;td&gt;服务器暂时无法处理请求，可能是超负荷或者维护等原因。&lt;/td&gt;
&lt;td&gt;HTTP_UNAVAILABLE&lt;/td&gt;
&lt;td&gt;服务不可用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;简单概括如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应码100-199表示一个提供信息的响应。&lt;/li&gt;
&lt;li&gt;响应码200-299表示请求成功。&lt;/li&gt;
&lt;li&gt;响应码300-399表示重定向。&lt;/li&gt;
&lt;li&gt;响应码400-499表示一个客户端引发的错误。&lt;/li&gt;
&lt;li&gt;响应码500-599表示一个服务器引发的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单列举一些比较常用的首部以及它们的作用。&lt;/p&gt;
&lt;h2 id=&quot;user-agent&quot;&gt;User-Agent&lt;/h2&gt;
&lt;p&gt;User-Agent一般作为请求首部，用于告知服务器当前客户端使用的是什么浏览器，翻译过来就是用户代理，作用是允许服务器响应请求时候针对客户端用户代理的类型优化返回的数据或者文件。例如使用Chrome发送请求时，User-Agent如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;host&quot;&gt;Host&lt;/h2&gt;
&lt;p&gt;Host一般作为请求首部，用于指定接收该请求的服务器的主机名和端口号。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Host: www.importnew.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;accept&quot;&gt;Accept&lt;/h2&gt;
&lt;p&gt;Accept一般作为请求首部，它的作用是告知服务器它可以使用或者想要什么已经不能使用或者不想要什么。下面是几个Accept首部以及它们的作用：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些字符集&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;告知服务器客户端可以接收和处理哪些语言&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Accept首部用于指定接收媒体类类型的时候，需要指定类型和子类型，这是因为媒体类型(MIME)本来就是按二级分类的，例如JPEG图像的媒体类型是image/jpeg，类型是image，子类型是jpeg。MIME已经定义了八种顶级的类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;text/*表示人可读的文字。&lt;/li&gt;
&lt;li&gt;image/*表示图片。&lt;/li&gt;
&lt;li&gt;model/*表示3D模型，如VRML文件。&lt;/li&gt;
&lt;li&gt;audio/*表示音频。&lt;/li&gt;
&lt;li&gt;video/*表示多媒体图片、视频，也可能是音频。&lt;/li&gt;
&lt;li&gt;application/*表示二进制数据。&lt;/li&gt;
&lt;li&gt;message/*表示协议特定的信封，如Email消息和HTTP响应。&lt;/li&gt;
&lt;li&gt;muitipart/*表示多个文档和资源的容器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，如果客户端只接收JSON数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Accept: application/json&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;referer&quot;&gt;Referer&lt;/h2&gt;
&lt;p&gt;Referer一般作为请求首部，它提供了包含当前请求的URL的文档的URL，也就是当前请求的上一个来源的文档，一般用作防盗链。例如&lt;code&gt;www.baidu.com/search?name=doge&lt;/code&gt;，服务器在处理此请求的时候，需要判断Referer是否为&lt;code&gt;www.baidu.com&lt;/code&gt;，&lt;code&gt;www.baidu.com/search&lt;/code&gt;的上一个文档来源必须是&lt;code&gt;www.baidu.com&lt;/code&gt;，否则服务器应该拒绝该请求。&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt;
&lt;p&gt;Cookie一般作为请求首部，客户端通过它向服务器传送一个或者多个令牌，原则上Cookie并不是安全的首部，Cookie的内容也会缓存在客户端。一般在Servlet应用中，Cookie是识别当前用户，实现持久会话的最佳方式。从过期时间分类来看，Cookie分为会话Cookie和持久Cookie，会话Cookie的过期时间比较短，持久Cookie的过期时间比较长或者不会过期，Cookie的过期策略等控制应该由服务端控制。由于Cookie是直接暴露在客户端，一般不能使用Cookie存放敏感的数据，需要存放敏感数据可以考虑使用数据加密处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cookie: uid=10086; domain=&quot;localhost&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;set-cookie&quot;&gt;Set-Cookie&lt;/h2&gt;
&lt;p&gt;Set-Cookie一般作为响应首部，和Cookie对应，表示服务器设置成功的Cookie。&lt;/p&gt;
&lt;h2 id=&quot;cache-control&quot;&gt;Cache-Control&lt;/h2&gt;
&lt;p&gt;Cache-Control一般作为请求首部，告知服务器对当前的请求的响应结果进行缓存相关操作。Cache-Control支持的值比较多，这里不展开细节，常见的如&lt;code&gt;no-cache&lt;/code&gt;表示在没有成功通过源站校验的情况下不得使用缓存，如&lt;code&gt;max-age&lt;/code&gt;表示响应结果需要缓存到指定的最大时间。&lt;/p&gt;
&lt;h2 id=&quot;content-type&quot;&gt;Content-Type&lt;/h2&gt;
&lt;p&gt;Content-Type是通用首部，可以作为请求首部或者响应首部，它的作用是告知服务器或者客户端当前请求或者响应结果的内容(媒体)类型。&lt;/p&gt;
&lt;h2 id=&quot;content-length&quot;&gt;Content-Length&lt;/h2&gt;
&lt;p&gt;Content-Length是通用首部，可以作为请求首部或者响应首部，它的作用是告知服务器或者客户端当前请求或者响应数据体的长度。&lt;/p&gt;
&lt;h2 id=&quot;content-encoding&quot;&gt;Content-Encoding&lt;/h2&gt;
&lt;p&gt;Content-Encoding一般作为响应首部，与Accept-Encoding对应，用于服务器告知客户端当前响应结果的内容编码。&lt;/p&gt;
&lt;h2 id=&quot;content-language&quot;&gt;Content-Language&lt;/h2&gt;
&lt;p&gt;Content-Language一般作为响应首部，与Accept-Language对应，用于服务器告知客户端当前响应结果的内容语言。&lt;/p&gt;
&lt;h2 id=&quot;connection&quot;&gt;Connection&lt;/h2&gt;
&lt;p&gt;Connection一般作为请求首部，表示是否需要持久连接。在HTTP1.1中，如果指定为Keep-Alive，可以提供持久连接，提高Socket的复用率从而降低多次连接的性能消耗。下面有一个小节专门介绍Keep-Alive。&lt;/p&gt;
&lt;h2 id=&quot;orgin&quot;&gt;Orgin&lt;/h2&gt;
&lt;p&gt;Origin一般作为请求首部，指明当前的请求是一个针对跨域资源共享的请求(该请求要求服务器在响应中加入一个Access-Control-Allow-Origin的消息头，表示访问控制所允许的来源)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Origin: http://www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;access-control-allow-origin&quot;&gt;Access-Control-Allow-Origin&lt;/h2&gt;
&lt;p&gt;Access-Control-Allow-Origin一般作为响应首部，和Origin对应，表示服务器允许的该跨域资源共享的请求来源。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Access-Control-Allow-Origin: http://www.baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;server&quot;&gt;Server&lt;/h2&gt;
&lt;p&gt;Server一般作为响应首部，用于告知客户端服务器的相关信息。&lt;/p&gt;

&lt;p&gt;如果采用GET请求方法，只需要向远处服务器提供URL，URL中的路径和查询字符串就可以匹配到需要查询的资源。但是URL中无法提供详细的客户端信息。另外，像POST和PUT这些请求方法所携带的数据体有可能比较大，无法放在URL的查询字符串。因此HTTP需要请求体。HTTP请求体包括下面四个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、一个起始请求行，包括HTTP方法、路径、查询字符串以及HTTP版本。&lt;/li&gt;
&lt;li&gt;2、HTTP请求的首部。&lt;/li&gt;
&lt;li&gt;3、一个空行(两个连续的回车或者换行对)。&lt;/li&gt;
&lt;li&gt;4、请求数据体。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文字描述可能比较抽象，用图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/http-1.png&quot; alt=&quot;http-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：space代表空格，\r\n代表换行。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET /wp-admin/admin-ajax.php?postviews_id=23996&amp;amp;action=postviews&amp;amp;_=1538708851063 HTTP/1.1
Host: www.importnew.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Accept: */*
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.81 Safari/537.36
Referer: http://www.importnew.com/23996.html
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9

postviews_id=23996&amp;amp;action=postviews&amp;amp;_=1538708851063&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;响应体和请求体的格式类似，主要是返回服务器的响应数据到客户端，包括服务器的一些信息和响应数据体。HTTP响应体主要包括下面的四个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、一个起始响应行，包括HTTP版本、状态码、状态码描述。&lt;/li&gt;
&lt;li&gt;2、HTTP响应的首部。&lt;/li&gt;
&lt;li&gt;3、一个空行(两个连续的回车或者换行对)。&lt;/li&gt;
&lt;li&gt;4、响应数据体。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文字描述可能比较抽象，用图表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/http-2.png&quot; alt=&quot;http-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：space代表空格，\r\n代表换行。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP/1.1 200 OK
Server: nginx
Date: Fri, 05 Oct 2018 03:07:37 GMT
Content-Type: text/html; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Keep-Alive: timeout=2
Vary: Accept-Encoding
X-Powered-By: PHP/5.3.3
X-Robots-Tag: noindex
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
Content-Encoding: gzip

2995&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在使用HTTP1.0的时候会为每个请求打开一个新的TCP连接，实际上，这导致了一个典型Web会话中打开和关闭所有连接所花费的事件远远大于实际传输数据所消耗的时间，特别是响应结果包含很多小文档的会话。对于使用SSL或者TLS加密的HTTPS连接，这个问题更加严重，因为建立一个安全的Socket的握手过程远比建立常规的Socket需要更多的工作。&lt;/p&gt;
&lt;p&gt;在HTTP1.1和后面的版本中，服务器不必在返送响应之后就关闭连接。已经建立的连接可以保持打开，在同一个Socket上等待来自客户端的新请求。简单来说，就是可以在一个TCP连接上连续发送多个请求和连续进行多个请求的响应。&lt;/p&gt;
&lt;p&gt;客户端可以在HTTP请求首部中添加一个Connection请求头，指定值为Keep-Alive，这样就能实现Socket的重用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Connection: Keep-Alive&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTTP1.1或者之后的版本，Keep-Alive是默认开启的，不需要显式指定，如果需要关闭可以设置为close：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Connection: close&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦开启了Keep-Alive，服务器在关闭一个Socket连接之前，如果有新的客户端再次连接到服务器，那么就是重用Socket。在JDK中可以通过系统属性来控制如果使用HTTP的Keep-Alive：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;http.keepAlive：默认值为true，默认开启HTTP的Keep-Alive。&lt;/li&gt;
&lt;li&gt;http.maxConnections：同时保持打开的Socket数量的最大值，默认值为5。&lt;/li&gt;
&lt;li&gt;http.keepAlive.remainingData：默认值为false，如果设置为true，则JDK在丢弃连接之后会完成剩余数据的清理。&lt;/li&gt;
&lt;li&gt;sun.net.http.errorstream.enableBuffering：默认值为false，如果设置为true，则尝试缓存400和500状态码的相对小的错误流，从而能释放连接以备后续使用。&lt;/li&gt;
&lt;li&gt;sun.net.http.errorstream.bufferSize：为缓存错误流的缓冲区的字节大小，默认值为4096字节，只有上一项为true的时候才有意义。&lt;/li&gt;
&lt;li&gt;sun.net.http.errorstream.timeout：默认值为300ms，读取错误流超时的毫秒数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很多网站使用一些小文本串在连接之间存储持久的客户端状态，这些小文本串称为Cookie(中文翻译为：小甜点)。Cookie在请求和响应的首部从服务器传到客户端，再从客户端传回服务器，服务器使用Cookie来指示sessionID、购物车内容、登录凭据等。&lt;br/&gt;除了简单的&lt;code&gt;name=value&lt;/code&gt;对，Cookie可以有多个属性来控制它们的作用域,包括过期日期、路径、域、端口、版本和安全选项。&lt;/p&gt;
&lt;p&gt;JDK中java.net.CookieStore类提供了对Cookie的增删查操作，它的默认实现是java.net.InMemoryCookieStore，如果实现CookieStore，JDK中的Cookie默认是存放在内存中的。另外，java.net.CookieManager内部持有CookiePolicy和CookieStore，定义了一系列管理Cookie的方法，一般通过CookieManager操作Cookie，当然也可以通过实现CookieStore，覆盖默认的CookieManager来实现Cookie的自定义管理。&lt;/p&gt;

&lt;p&gt;(本文完 c-2-d e-20181005)&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:52:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>HTTP协议的定义 这篇文章暂时不研究HTTP底层的TCP/IP的握手和挥手过程，只从表面的交互流程分析HTTP协议。 HTTP英文全称是Hypertext Transfer Protpcol，也就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9746384.html</dc:identifier>
</item>
<item>
<title>koa源码解读 - 沧浪一剑</title>
<link>http://www.cnblogs.com/lightzone/p/9746334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lightzone/p/9746334.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;koa是有express原班人马打造的基于node.js的下一代web开发框架。koa 1.0使用generator实现异步，相比于回调简单和优雅和不少。koa团队并没有止步于koa 1.0， 随着node.js开始支持async/await，他们又马不停蹄的发布了koa 2.0，koa2完全使用Promise并配合async/await来实现异步，使得异步操作更臻完美。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;一、快速开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;koa使用起来非常简单，安装好node.js后执行以下命令安装koa：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm init&lt;/p&gt;
&lt;p&gt;npm install --save koa&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个简单的Hello World程序开场,&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;//index.js&lt;/p&gt;
&lt;p&gt;const Koa = require('koa')&lt;/p&gt;
&lt;p&gt;const app = new Koa()&lt;/p&gt;

&lt;p&gt;app.use( async ctx  =&amp;gt; {&lt;/p&gt;
&lt;p&gt;ctx.body = 'Hello World'&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;

&lt;p&gt;app.listen(3000,()=&amp;gt;{&lt;/p&gt;
&lt;p&gt;console.log(&quot;server is running at 3000 port&quot;);&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命令行执行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;node index.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开浏览器查看http://localhost:3000就可以看到页面输出的 Hello World。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中间件 middleware&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Koa中使用 app.use()用来加载中间件，基本上Koa 所有的功能都是通过中间件实现的。&lt;/p&gt;

&lt;p&gt;中间件的设计非常巧妙，多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是 next函数。只要调用 next函数，就可以把执行权转交给下一个中间件，最里层的中间件执行完后有会把执行权返回给上一级调用的中间件。整个执行过程就像一个剥洋葱的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQxqlKeecNuAkxNic43wOrV6gEOegbhmR2Yboicpg2DEkhLgIOSRSQvIbkSIlKQBaVBgz6RAUIvGLByZhZasePiaw/640?wx_fmt=png&quot; alt=&quot;&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9100418410041841&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;

&lt;p&gt;比如你可以通过在所有中间件的顶端添加以下中间件来打印请求日志到控制台：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;app.use(async function (ctx, next) {&lt;/p&gt;
&lt;p&gt;let start = new Date()&lt;/p&gt;
&lt;p&gt;await next()&lt;/p&gt;
&lt;p&gt;let ms = new Date() - start&lt;/p&gt;
&lt;p&gt;console.log('%s %s - %s', ctx.method, ctx.url, ms)&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;常用的中间件列表可以在这里找到： https://github.com/koajs/koa/wiki&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、koa源码解读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开项目根目录下的node_modules文件夹，打开并找到koa的文件夹，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cSOoQAk3WeLia3WMgNJQVlUmDiaOKpCH5CHWZjlRALyWIp1znlkGia9lyLqE3Iwa1Jia2LoM0s364YxGFAia2ort4YQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;1.4368600682593857&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开lib文件夹，这里一共有4个文件，&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;application.js - koa主程序入口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;context.js - koa中间件参数ctx对象的封装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;request.js - request对象封装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;response.js - response对象封装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们这里主要看下application.js，我这里摘取了主要功能相关的 代码如下：&lt;/p&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Shorthand for:&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  *    http.createServer(app.callback()).listen(...)&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @param {Mixed} ...&lt;/p&gt;
&lt;p&gt;  * @return {Server}&lt;/p&gt;
&lt;p&gt;  * @api public&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;listen(...args) {&lt;/p&gt;
&lt;p&gt;debug('listen');&lt;/p&gt;
&lt;p&gt;const server = http.createServer(this.callback());&lt;/p&gt;
&lt;p&gt;return server.listen(...args);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Use the given middleware `fn`.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * Old-style middleware will be converted.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @param {Function} fn&lt;/p&gt;
&lt;p&gt;  * @return {Application} self&lt;/p&gt;
&lt;p&gt;  * @api public&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;use(fn) {&lt;/p&gt;
&lt;p&gt;if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');&lt;/p&gt;
&lt;p&gt;if (isGeneratorFunction(fn)) {&lt;/p&gt;
&lt;p&gt;deprecate('Support for generators will be removed in v3. ' +&lt;/p&gt;
&lt;p&gt;'See the documentation for examples of how to convert old middleware ' +&lt;/p&gt;
&lt;p&gt;'https://github.com/koajs/koa/blob/master/docs/migration.md');&lt;/p&gt;
&lt;p&gt;fn = convert(fn);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;debug('use %s', fn._name || fn.name || '-');&lt;/p&gt;
&lt;p&gt;this.middleware.push(fn);&lt;/p&gt;
&lt;p&gt;return this;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Return a request handler callback&lt;/p&gt;
&lt;p&gt;  * for node's native http server.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @return {Function}&lt;/p&gt;
&lt;p&gt;  * @api public&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;callback() {&lt;/p&gt;
&lt;p&gt;const fn = compose(this.middleware);&lt;/p&gt;

&lt;p&gt;if (!this.listenerCount('error')) this.on('error', this.onerror);&lt;/p&gt;

&lt;p&gt;const handleRequest = (req, res) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;const ctx = this.createContext(req, res);&lt;/p&gt;
&lt;p&gt;return this.handleRequest(ctx, fn);&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;

&lt;p&gt;return handleRequest;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;p&gt;  * Handle request in callback.&lt;/p&gt;
&lt;p&gt;  *&lt;/p&gt;
&lt;p&gt;  * @api private&lt;/p&gt;
&lt;p&gt;  */&lt;/p&gt;

&lt;p&gt;handleRequest(ctx, fnMiddleware) {&lt;/p&gt;
&lt;p&gt;const res = ctx.res;&lt;/p&gt;
&lt;p&gt;res.statusCode = 404;&lt;/p&gt;
&lt;p&gt;const onerror = err =&amp;gt; ctx.onerror(err);&lt;/p&gt;
&lt;p&gt;const handleResponse = () =&amp;gt; respond(ctx);&lt;/p&gt;
&lt;p&gt;onFinished(res, onerror);&lt;/p&gt;
&lt;p&gt;return fnMiddleware(ctx).then(handleResponse).catch(onerror);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;通过注释我们可以看出上面代码主要干的事情是初始化http服务对象并启动。我们注意到 callback()方法里面有这样一段代码 :&lt;/p&gt;
&lt;p&gt;const fn = compose(this.middleware);&lt;/p&gt;

&lt;p&gt;compose其实是Node模块koa-compose，它的作用是&lt;strong&gt;将多个中间件函数合并成一个大的中间件函数，然后调用这个中间件函数就可以依次执行添加的中间件函数，执行一系列的任务。遇到await next()时就停止当前中间件函数的执行并把执行权交个下一个中间件函数，最后next()执行完返回上一个中间件函数继续执行下面的代码。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它是用了什么黑魔法实现的呢？我们打开node_modules/koa-compose/index.js，代码如下 ：&lt;/p&gt;
&lt;p&gt;function compose(middleware) {&lt;/p&gt;
&lt;p&gt;    return function (context, next) {&lt;/p&gt;
&lt;p&gt;        // last called middleware #&lt;/p&gt;
&lt;p&gt;        let index = -1&lt;/p&gt;
&lt;p&gt;        return dispatch(0)&lt;/p&gt;
&lt;p&gt;        function dispatch(i) {&lt;/p&gt;
&lt;p&gt;            if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))&lt;/p&gt;
&lt;p&gt;            index = i&lt;/p&gt;
&lt;p&gt;            let fn = middleware[i]&lt;/p&gt;
&lt;p&gt;            if (i === middleware.length) fn = next&lt;/p&gt;
&lt;p&gt;            if (!fn) return Promise.resolve()&lt;/p&gt;
&lt;p&gt;            try {&lt;/p&gt;
&lt;p&gt;                return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));&lt;/p&gt;
&lt;p&gt;            } catch (err) {&lt;/p&gt;
&lt;p&gt;                return Promise.reject(err)&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;乍一看好难好复杂，没事，我们一步一步的来梳理一下。&lt;/p&gt;

&lt;p&gt;这个方法里面的核心就是dispatch函数（废话，整个compose方法就返回了一个函数）。没有办法简写，但是我们可以将dispatch函数类似递归的调用展开，以三个中间件为例：&lt;/p&gt;
&lt;p&gt;第一次，此时第一个中间件被调用，dispatch(0)，展开：&lt;/p&gt;
&lt;p&gt;Promise.resolve(function(context, next){&lt;/p&gt;
&lt;p&gt;    //中间件一第一部分代码&lt;/p&gt;
&lt;p&gt;    await/yield next();&lt;/p&gt;
&lt;p&gt;    //中间件一第二部分代码}());&lt;/p&gt;
&lt;p&gt;很明显这里的next指向dispatch(1)，那么就进入了第二个中间件；&lt;/p&gt;
&lt;p&gt;第二次，此时第二个中间件被调用，dispatch(1)，展开：&lt;/p&gt;
&lt;p&gt;Promise.resolve(function(context, 中间件2){&lt;/p&gt;
&lt;p&gt;    //中间件一第一部分代码&lt;/p&gt;
&lt;p&gt;    await/yield Promise.resolve(function(context, next){&lt;/p&gt;
&lt;p&gt;        //中间件二第一部分代码&lt;/p&gt;
&lt;p&gt;        await/yield next();&lt;/p&gt;
&lt;p&gt;        //中间件二第二部分代码&lt;/p&gt;
&lt;p&gt;    }())&lt;/p&gt;
&lt;p&gt;    //中间件一第二部分代码}());&lt;/p&gt;
&lt;p&gt;很明显这里的next指向dispatch(2)，那么就进入了第三个中间件；&lt;/p&gt;
&lt;p&gt;第三次，此时第二个中间件被调用，dispatch(2)，展开：&lt;/p&gt;
&lt;p&gt;Promise.resolve(function(context, 中间件2){&lt;/p&gt;
&lt;p&gt;    //中间件一第一部分代码&lt;/p&gt;
&lt;p&gt;    await/yield Promise.resolve(function(context, 中间件3){&lt;/p&gt;
&lt;p&gt;        //中间件二第一部分代码&lt;/p&gt;
&lt;p&gt;        await/yield Promise(function(context){&lt;/p&gt;
&lt;p&gt;            //中间件三代码&lt;/p&gt;
&lt;p&gt;        }());&lt;/p&gt;
&lt;p&gt;        //中间件二第二部分代码&lt;/p&gt;
&lt;p&gt;    })&lt;/p&gt;
&lt;p&gt;    //中间件一第二部分代码}());&lt;/p&gt;
&lt;p&gt;此时中间件三代码执行完毕，开始执行中间件二第二部分代码，执行完毕，开始执行中间一第二部分代码，执行完毕，所有中间件加载完毕。&lt;/p&gt;
&lt;p&gt;再举一个例子加深下理解。新建index.js并粘贴如下代码：&lt;/p&gt;
&lt;p&gt;const compose = require('koa-compose')&lt;/p&gt;

&lt;p&gt;const middleware1 = (ctx, next) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;console.log('here is in middleware1, before next:');&lt;/p&gt;
&lt;p&gt;next();&lt;/p&gt;
&lt;p&gt;console.log('middleware1 end');&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;const middleware2 = (ctx, next) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;console.log('here is in middleware2, before next:');&lt;/p&gt;
&lt;p&gt;next();&lt;/p&gt;
&lt;p&gt;console.log('middleware2 end');&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;const middleware3 = (ctx, next) =&amp;gt; {&lt;/p&gt;
&lt;p&gt;console.log('here is in middleware3, before next:');&lt;/p&gt;
&lt;p&gt;next();&lt;/p&gt;
&lt;p&gt;console.log('middleware3 end');&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;const middlewares = compose([middleware1, middleware2, middleware3])&lt;/p&gt;
&lt;p&gt;console.dir(middlewares())&lt;/p&gt;

&lt;p&gt;在命令行输入node index.js执行，输出结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;here is in middleware1, before next:&lt;/p&gt;
&lt;p&gt;here is in middleware2, before next:&lt;/p&gt;
&lt;p&gt;here is in middleware3, before next:&lt;/p&gt;
&lt;p&gt;middleware3 end&lt;/p&gt;
&lt;p&gt;middleware2 end&lt;/p&gt;
&lt;p&gt;middleware1 end&lt;/p&gt;
&lt;p&gt;Promise { undefined }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以看到每个中间件都按照“剥洋葱”的流程一次执行。当我们初始化app对象并调用app.use()时，就是在不断往app.middleware数组里添加中间件函数，当调用app.listen()再执行组合出来的函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-END-&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;转载请注明来源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扫描下方二维码，或者搜索 &lt;span&gt;前端提高班&lt;/span&gt; 关注公众号，即可获取最新走心文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记得把我设为星标或置顶哦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cSOoQAk3WeLia3WMgNJQVlUmDiaOKpCH5CwWEXFC0h07iaBJbWUuaWiaC0IpLSHyDI6dje4TsOZhBzCHy9BN35AzKw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在公众号后台回复 &lt;span&gt;前端资源&lt;/span&gt; 即可获取最新前端开发资源&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:30:00 +0000</pubDate>
<dc:creator>沧浪一剑</dc:creator>
<og:description>koa是有express原班人马打造的基于node.js的下一代web开发框架。koa 1.0使用generator实现异步，相比于回调简单和优雅和不少。koa团队并没有止步于koa 1.0， 随着n</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lightzone/p/9746334.html</dc:identifier>
</item>
<item>
<title>我是如何学习数据结构与算法的？ - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9746328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9746328.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;88.38125&quot;&gt;
&lt;p&gt;数据结构与算法的地位对于一个程序员来说不言而喻。今天这篇文章不是来劝你们学习数据结构与算法的，也不是来和你们说数据结构与算法有多重要。&lt;br/&gt;主要是最近几天后台有读者问我是如何学习数据结构与算法的，有没有什么捷径，是要看视频还是看书，去哪刷题等…..而且有些还是大三大四的，搞的我都替你们着急、担心…..&lt;br/&gt;所以我今天就分享下自己平时都是怎么学习的。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;学习算法的捷径就是多刷题&lt;/h4&gt;
&lt;p&gt;说实话，要说捷径，我觉得就是脚踏实地着多动手去刷题，多刷题。&lt;br/&gt;但是，如果你是小白，也就是说，你连常见的数据结构，如链表、树以及常见的算法思想，如递归、枚举、动态规划这些都没学过，那么，我不建议你去刷题的。而是先去找本书先去学习这些，然后再去刷题。&lt;/p&gt;
&lt;p&gt;也就是说，假如你要去诸如leetcode这些网站刷题，那么，你要先具备一定的基础，这些基础包括：&lt;br/&gt;1、常见数据结构：链表、树(如二叉树)。&lt;br/&gt;2、常见算法思想：贪婪法、分治法、穷举法、动态规划，回溯法。&lt;br/&gt;以上列出来的算是最基本的吧。就是说你刷题之前，要把这些过一遍再去刷题。如果你连这些最基本的都不知道的话，那么你再刷题的过程中，会很难受的，思路也会相对比较少。&lt;br/&gt;总之，千万不要急，先把这些基本的过一遍，力求理解，再去刷题。这些基础的数据结构与算法，我是在大一第二学期学的，我没看视频，我是通过看书学的，那时候看的书是：&lt;br/&gt;1、算法分析与分析基础：这本比较简单，推荐新手看。&lt;br/&gt;2、数据结构与算法分析—-C语言描述：代码用C写的，推荐看。&lt;br/&gt;3、挑战程序设计竞赛(第二版)：也是很不错的一本书，推荐看。&lt;br/&gt;具体可以看我的另外一篇文章，里面是介绍这几本书的：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ckhKXayxxxJHJotoaoWHDg&quot;&gt;算法与数据结构书籍与视频福利&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话，我那一学期的时间几乎都花在数据结构与算法上，但刷的题很少，只是书本上的一些例题。所以当我把这些基本的过一遍之后，再去一些网站刷题依旧非常菜。&lt;br/&gt;所以你们千万别指望以为自己把这些思想学完之后刷题会很牛，只有多刷题，只有多动手实践，你的灵敏度才会提高起来。&lt;br/&gt;在这里说一下前阵子有个非常火爆的专栏—-【数据结构与算法之美】&lt;/p&gt;
&lt;p&gt;我没买这个专栏，我想说的是，买了就一定要去看，千万别浪费。也千万不要觉得学完这个专栏你就会变的多牛逼，如果你只是跟着进度去学习这个专栏，自己没有花时间去刷题、去动手时间。那我可以保证，你学完之后还是那么菜。&lt;br/&gt;总结下：&lt;br/&gt;提高数据结构与算法没啥捷径，最好的捷径就是多刷题。但是，刷题的前提是你要先学会一些基本的数据结构与算法思想。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;追求完美&lt;/h4&gt;
&lt;p&gt;如何刷题？如何对待一道算法题？&lt;br/&gt;我觉得，在做题的时候，一定要&lt;strong&gt;追求完美&lt;/strong&gt;，千万不要把一道题做出来之后，提交通过，然后就赶紧下一道。&lt;br/&gt;算法能力的提升和做题的数量是有一定的关系，但并不是线性关系。也就是说，在做题的时候，要力求一题多解，如果自己实在想不出来其他办法了，可以去看看别人是怎么做的，千万不要觉得模仿别人的做法是件丢人的事。&lt;br/&gt;我做题的时候，我一看到一道题，可能第一想法就是用很粗糙的方式做，因为很多题采用&lt;strong&gt;暴力法&lt;/strong&gt;都会很容易做，就是时间复杂度很高。之后，我就会慢慢思考，看看有没其他方法来降低时间复杂度或空间复杂度。最后，我会去看一下别人的做法，当然，并不是每道题都会这样执行。&lt;br/&gt;衡量一道算法题的好坏无非就是&lt;strong&gt;时间复杂度&lt;/strong&gt;和&lt;strong&gt;空间复杂度&lt;/strong&gt;，所以我们要力求完美，就要把这两个降到最低，令他们相辅相成。&lt;br/&gt;我举道例题吧：&lt;br/&gt;&lt;strong&gt;问题：&lt;/strong&gt; 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;br/&gt;这道题我在以前的分章分析过，不懂的可以先看下之前写的：&lt;a href=&quot;https://mp.weixin.qq.com/s/_KRK7_Xtx11aSiXV5h6zIQ&quot;&gt;递归与动态规划—-基础篇1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法1：&lt;/strong&gt;：暴力递归&lt;br/&gt;这道题不难，或许你会采取下面的做法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static int solve(int n){
    if(n == 1 || n == 2){
        return 1;
    }else if(n &amp;lt;= 0){
        return 0;
    }else{
        return solve(n-1) + solve(n-2);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种做法的时间复杂度很高，指数级别了。但是如果你提交之后侥幸通过了，然后你就接着下一道题了，那么你就要好好想想了。&lt;br/&gt;&lt;strong&gt;方法二&lt;/strong&gt;：空间换时间&lt;br/&gt;&lt;strong&gt;力求完美&lt;/strong&gt;，我们可以考虑用空间换时间：这道题如何你去仔细想一想，会发现有很多是重复执行了。所以可以采取下面的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//用一个HashMap来保存已经计算过的状态
static Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap();
public static int solve(int n){
    if(n &amp;lt;= 0)return 0;
    else if(n &amp;lt;= 2){
        return 1;
    }else{//是否计算过
        if(map.containsKey(n)){
            return map.get(n);
        }else{
            int m = solve(n-1) + solve(n-2);
            map.put(n, m);
            return m;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，可以大大缩短时间。也就是说，当一道题你做了之后，发现时间复杂度很高，那么可以考虑下，是否有更好的方法，是否可以用空间换时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;：斐波那契数列&lt;br/&gt;实际上，我们可以把空间复杂度弄的更小，不需要HashMap来保存状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static int solve(int n){
    if(n &amp;lt;= 0)
       return 0;
    if(n &amp;lt;= 2){
        return 1;
    }

    int f1 = 0;
    int f2 = 1;
    int sum = 0;
    for(int i = 1; i&amp;lt;= n; i++){
        sum = f1 + f2;
        f1 = f2;
        f2 = sum;
    }
    return sum;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我弄这道题给你们看，并不是在教你们这道题怎么做，而是有以下目的：&lt;br/&gt;1、在刷题的时候，我们要力求完美。&lt;br/&gt;2、我想不到这些方法啊，怎么办？那么你就可以去看别人的做法，之后，遇到类似的题，你就会更有思路，更知道往哪个方向想。&lt;br/&gt;3、可以从简单暴力入手做一道题，在考虑空间与时间之间的衡量，一点点去优化。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;推荐一些刷题网站&lt;/h4&gt;
&lt;p&gt;我一般是在leetcode和牛客网刷题，感觉挺不错，题目难度不是很大。&lt;br/&gt;在牛客网那里，我主要刷剑指Offer,不过那里也有个在线刷leetcode，不过里面的题量比较少。牛客网刷题有个非常方便的地方就是有个讨论区，那里会有很多大佬分享他们的解题方法，不用我们去百度找题解。所以你做完后，实在想不出，可以很方便着去看别人是怎么做的。&lt;br/&gt;至于leetcode，也是大部分题目官方都有给出答案，也是个不错的刷题网站。你们可以两个挑选一个，或者两个都刷。&lt;br/&gt;当然，还有其他刷题的网站，不过，其他网站没刷过，不大清除如何。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;再说数据结构&lt;/h4&gt;
&lt;p&gt;前面我主要是说了我平时都是怎么学习算法的。在数据结构方法，我只是列举了你们一定要学习&lt;strong&gt;链表&lt;/strong&gt;和&lt;strong&gt;树(二叉堆)&lt;/strong&gt;，但这是最基本的，刷题之前要掌握的，对于数据结构，我列举下一些比较重要的：&lt;br/&gt;1、链表（如单向链表、双向链表）。&lt;br/&gt;2、树（如二叉树、平衡树、红黑树）。&lt;br/&gt;3、图（如最短路径的几种算法）。&lt;br/&gt;4、队列、栈、矩阵。&lt;br/&gt;对于这些，自己一定要动手实现一遍。你可以看书，也可以看视频，新手可以先看视频，不过前期可以看视频，之后我建议是一定要看书。&lt;br/&gt;视频和书我以前有推荐过：&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ckhKXayxxxJHJotoaoWHDg&quot;&gt;算法与数据结构书籍与视频福利&lt;/a&gt;&lt;br/&gt;例如对于平衡树，可能你跟着书本的代码实现之后，过阵子你就忘记，不过这不要紧，虽然你忘记了，但是如果你之前用代码实现过，理解过，那么当你再次看到的时候，会很快就记起来，很快就知道思路,而且你的抽象能力等等会在不知不觉中提升起来。之后再学习红黑树啊，什么数据结构啊，都会学的很快。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;最最重要&lt;/h4&gt;
&lt;p&gt;动手去做，动手去做，动手去做。重要的话说三遍。&lt;br/&gt;千万不要找了一堆资源，订好了学习计划，我要留到某某天就来去做…..&lt;br/&gt;千万不要这样，而是当你激情来的时候，就马上去干，千万不要留到某个放假日啊什么鬼了，很多这种想法的人，最后会啥也没做的。&lt;br/&gt;也不要觉得要学习的有好多啊，不知道从哪学习起。我上面说了，可以先学习最基本的，然后刷题，刷题是一个需要长期坚持的事情，一年，两年。在刷题的过程中，可以穿插和学习其他数据结构。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;最后&lt;/h4&gt;
&lt;p&gt;今天就说这么多，以上主要是我自己的学习方法，希望对你有所帮助。&lt;br/&gt;对了，我很久之前就建过一个交流群，不过该群还是挺安静的，我也很少提到，如果你想加入，公众号右下方有加入方式。你有什么问题，可以在群里提问，我看到的话，会尽量解答。&lt;br/&gt;最后说下我这个公众号(&lt;strong&gt;苦逼的码农&lt;/strong&gt;)，我主要写【计算机网络】、【数据结构与算法】、【Java】。一般90%都会是原创的，偶尔有些转载的文章，只会比我自己写的文章更好。&lt;br/&gt;一般我会一阵子更新这个模块、一阵子更新另一个模块的方式来写文章。&lt;br/&gt;如果你觉得有帮助，可以分享给更多的朋友哦，这便是对我最大的支持 。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本公众号（&lt;strong&gt;苦逼的码农&lt;/strong&gt;）专注于写【Java】、【计算机网络】、【数据结构与算法】，期待你加入交流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:26:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>数据结构与算法的地位对于一个程序员来说不言而喻。今天这篇文章不是来劝你们学习数据结构与算法的，也不是来和你们说数据结构与算法有多重要。主要是最近几天后台有读者问我是如何学习数据结构与算法的，有没有什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9746328.html</dc:identifier>
</item>
<item>
<title>为什么JAVA对象需要实现序列化？ - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9746310.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9746310.html</guid>
<description>&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;序列化是一种用来&lt;code&gt;处理对象流&lt;/code&gt;的机制。&lt;/p&gt;
&lt;/li&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所谓对象流：就是将对象的内容进行流化。可以对流化后的对象&lt;code&gt;进行读写操作&lt;/code&gt;，也可将流化后的对象&lt;code&gt;传输于网络&lt;/code&gt;之间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;序列化是为了解决在对对象流进行读写操作时所引发的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;序列化的实现：将需要被序列化的类实现&lt;code&gt;Serializable接口(标记接口)&lt;/code&gt;，该接口没有需要实现的方法，implements Serializable只是为了&lt;code&gt;标注&lt;/code&gt;该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象；接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;什么时候使用序列化呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一：对象序列化可以&lt;code&gt;实现分布式对象&lt;/code&gt;。&lt;br/&gt;主要应用例如：&lt;code&gt;RMI(即远程调用Remote Method Invocation)&lt;/code&gt;要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。&lt;/li&gt;
&lt;li&gt;二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。&lt;br/&gt;可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的&quot;&lt;strong&gt;深复制&lt;/strong&gt;&quot;，即&lt;code&gt;复制对象本身及引用的对象本身&lt;/code&gt;。序列化一个对象可能得到整个对象序列。&lt;/li&gt;
&lt;li&gt;三：序列化可以将内存中的类写入文件或数据库中。&lt;br/&gt;比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据&lt;code&gt;反序列化&lt;/code&gt;就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。总的来说就是&lt;code&gt;将一个已经实例化的类转成文件存储&lt;/code&gt;，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。&lt;/li&gt;
&lt;li&gt;四： 对象、文件、数据，有许多不同的格式，很难统一传输和保存。&lt;br/&gt;序列化以后就都是字节流了，无论原来是什么东西，都能&lt;code&gt;变成一样的东西&lt;/code&gt;，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因为JAVA中要将对象序列化为 &lt;code&gt;流的形式&lt;/code&gt; 进行传输。&lt;/p&gt;
&lt;/li&gt;
</description>
<pubDate>Fri, 05 Oct 2018 15:21:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>序列化是一种用来处理对象流的机制。 所谓对象流：就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决在对对象流进行读写操作时所引发的问题。 序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9746310.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中使用表达式树创建URL - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9746274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9746274.html</guid>
<description>&lt;p&gt;当我们在ASP.NET Core中生成一个action的url会这样写：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var url=_urlHelper.Action(&quot;Index&quot;, &quot;Home&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的写法存在的问题在于我们传递了两个字符串类型的参数，而我们又无法避免对action和controller做重命名操作, 例如将index重命名为default, 你无法通过IDE在重命名action的过程中，将&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;_urlHelper.Action(&quot;Index&quot;, &quot;Home&quot;); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重构为&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;UrlHelper.Action(&quot;Default&quot;, &quot;Home&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们的目标是：设计出具有静态检查的API，让IDE提示出这个错误来，甚至是重命名时直接把相关代码都能重命名。&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;目标&lt;/h2&gt;
&lt;p&gt;设计出类似两组API:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var url = _urlHelper.Action((HomeController c) =&amp;gt; c.Index());
//期待输出 /home/index
var link = _urlHelper.Link((ProductController c) =&amp;gt; c.Details(10));
//期待输出 http://locahost/product/details/10&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设计api&quot;&gt;设计API&lt;/h2&gt;
&lt;p&gt;根据上面的需求，定义两组API:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static string Action&amp;lt;TController&amp;gt;(this IUrlHelper helper, 
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; action)
where TController : Controller
{
   //实现
}

public static string Link&amp;lt;TController&amp;gt;(this IUrlHelper helper, 
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; action,
string protocal = null, string host = null)
where TController : Controller
{
   //实现
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现api&quot;&gt;实现API&lt;/h2&gt;
&lt;p&gt;我们实际上最终还是要依赖ASP.NET Core提供的API：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var link = helper.Action(action: actionName, controller: 
controllerName, values: routes);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以问题变成了如何根据(HomeController c) =&amp;gt; c.Index()这样的表达式来解析出actionName, ControllerName以及routeValues。&lt;/p&gt;
&lt;h3 id=&quot;解析controllername&quot;&gt;1. 解析ControllerName&lt;/h3&gt;
&lt;p&gt;解析ControllerName比较简单粗暴，因为我们已经从表达式树中得到了HomeController这个类型，直接取&lt;code&gt;Home&lt;/code&gt;字符串即可：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static string GetControllerName(Type controllerType)
{
    var controllerName = controllerType.Name.EndsWith(&quot;Controller&quot;)
        ? controllerType.Name.Substring(0,
        controllerType.Name.Length - &quot;Controller&quot;.Length)
        : controllerType.Name;
    return controllerName;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析actionname&quot;&gt;2. 解析ActionName&lt;/h3&gt;
&lt;p&gt;由于表达式&lt;code&gt;(HomeController c) =&amp;gt; c.Index()&lt;/code&gt;是一个&lt;code&gt;MethodCallExpression&lt;/code&gt;类型，而Action的名字就是方法名：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static MethodCallExpression
GetMethodCallExpression&amp;lt;TController&amp;gt;(
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; actionSelector)
{
    var call = actionSelector.Body as MethodCallExpression;
    if (call == null)
    {
        throw new ArgumentException(&quot;You must call a method on &quot; +
        typeof(TController).Name, &quot;actionSelector&quot;);
    }
    
    return call;
}

var methodCallExpression = GetMethodCallExpression(action);
var actionName = methodCallExpression.Method.Name;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析routevalues&quot;&gt;3. 解析RouteValues&lt;/h3&gt;
&lt;p&gt;上面两步已经解析出了ControllerName和ActionName，也就是说通过上面的分析已经能完成下面的调用：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var action = helper.Action(action: &quot;index&quot;, controller: &quot;home&quot;, values: null);
//等价于
var url = _urlHelper.Action((HomeController c) =&amp;gt; c.Index());
//输出 /home/index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是考虑下面的Action：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[HttpGet,Route(&quot;product/{id}&quot;)]
public IActionResult Details(int id)
{
   //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Action期待传入一个int类型的id，也就是说你要通过这样的方式来生成url:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var action = helper.Action(action: &quot;details&quot;, controller: 
&quot;product&quot;, values: new { id = 10 });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以要想让我们的API正常工作，还需要生成一个object类型：new { id = 10 }。而这个object类型里面的属性正好可以来自于表达式树的方法调用参数：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var action = _urlHelper.Action((ProductController c) =&amp;gt; c.Details(10));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想生成这个匿名对象，需要遍历方法调用表达式的所有参数，分别解析出属性名，例如id; 以及值，例如10。最后再把解析出来的参数字典生成为dynamic类型的对象：&lt;br/&gt;如何解析表达式树请查看&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/&quot;&gt;expression-trees&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RouteValueExtractor
{
    public static object GetRouteValues(MethodCallExpression call)
    {
        var routes = new Dictionary&amp;lt;string, object&amp;gt;();

        var parameters = call.Method.GetParameters();
        var pairs = call.Arguments.Select((a, i) =&amp;gt; new
        {
            Argument = a,
            ParamName = parameters[i].Name
        });
        foreach (var item in pairs)
        {
            string name = item.ParamName;
            object value = GetValue(item.Argument);
            if (value != null)
            {
                var valueType = value.GetType();
                if (valueType.IsValueType)
                {
                    routes.Add(name, value);
                }
                else
                {
                    throw new NotSupportedException(&quot;Unsupported parameter type {0}&quot;);
                }

            }
        }

        return DictionaryToObject(routes);
    }

    private static object GetValue(Expression expression)
    {
        if (expression.NodeType == ExpressionType.Constant)
        {
            return ((ConstantExpression) expression).Value;
        }

        throw new NotSupportedException(&quot;Unsupported parameter expression&quot;);
    }

    private static dynamic DictionaryToObject(IDictionary&amp;lt;string, object&amp;gt; dictionary)
    {
        var expandoObj = new ExpandoObject();
        var expandoObjCollection = (ICollection&amp;lt;KeyValuePair&amp;lt;string, object&amp;gt;&amp;gt;) expandoObj;

        foreach (var keyValuePair in dictionary)
        {
            expandoObjCollection.Add(keyValuePair);
        }

        dynamic eoDynamic = expandoObj;
        return eoDynamic;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个完整的API实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static string Action&amp;lt;TController&amp;gt;(this IUrlHelper helper, 
Expression&amp;lt;Action&amp;lt;TController&amp;gt;&amp;gt; action)
where TController : Controller
{
    var controllerName = GetControllerName(typeof(TController));
    var methodCallExpression = GetMethodCallExpression(action);
    var actionName = methodCallExpression.Method.Name;

    var routes = RouteValueExtractor.GetRouteValues(methodCallExpression);

    var link = helper.Action(action: actionName, controller: 
    controllerName, values: routes);

    return link;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 05 Oct 2018 15:17:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>当我们在ASP.NET Core中生成一个action的url会这样写： 这样的写法存在的问题在于我们传递了两个字符串类型的参数，而我们又无法避免对action和controller做重命名操作, 例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9746274.html</dc:identifier>
</item>
<item>
<title>JavaSE集合基础总览 - 秀常</title>
<link>http://www.cnblogs.com/byuc/p/9744060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/byuc/p/9744060.html</guid>
<description>&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 举例部分Collections的算法排序，具体看API
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Collections {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         List l1 = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt;= 9; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             l1.add(&quot;a&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         * 目前l1的值排序为： [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         Collections.reverse(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 逆序排序&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         System.out.println(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a9,a8,a7,a6,a5,a4,a3,a2,a1,a0]&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         Collections.shuffle(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 随机排序&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         System.out.println(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a1,a3,a8,a9,a4,a6,a5,a2,a0,a7]&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Collections.sort(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正序排序&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         System.out.println(l1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9]&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         System.out.println(Collections.binarySearch(l1, &quot;a5&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Fri, 05 Oct 2018 15:09:00 +0000</pubDate>
<dc:creator>秀常</dc:creator>
<og:description>Java集合 Java集合，也称之为容器。基本上你写所有的Java程序，都必须要用到一个包。该API基本都位于java.util工具类包中，是JavaSE中的重中之重。简单可以总结为“1136”，分别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/byuc/p/9744060.html</dc:identifier>
</item>
<item>
<title>MIT-6.828  环境搭建 - 活在未来的人</title>
<link>http://www.cnblogs.com/gatsby123/p/9746193.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/9746193.html</guid>
<description>&lt;p&gt;MIT 6.828是操作系统中最经典的一门课程。完成所有的lab就相当于完成了一个迷你的操作系统。我跟的是2018年的课程，课程首页在&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/schedule.html&quot; title=&quot;6.828课程官网&quot;&gt;6.828课程官网&lt;/a&gt;。当然所有资料都是英文的，所以难度也不低，这里推荐几本非常有用的参考书：《x86汇编语言-从实模式到保护模式》，《程序员的自我修养-链接、装载与库》，《深入理解计算机系统》，很多知识在这些书中都有提到，参考着看会有奇效。&lt;/p&gt;
&lt;h2 id=&quot;一段话概括&quot;&gt;一段话概括&lt;/h2&gt;
&lt;p&gt;本文主要讲解实验前的环境搭建，主要分为两个部分，一个是x86模拟器QEMU的安装，另一个是编译工具链。参考资料：&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/labguide.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验环境&quot;&gt;实验环境&lt;/h2&gt;
&lt;p&gt;我的机子装的win10的系统，现在win10支持&lt;a href=&quot;https://baike.baidu.com/item/wsl/20359185?fr=aladdin&quot; title=&quot;WSL&quot;&gt;WSL&lt;/a&gt;，在windows上也能享受到原生linux一样的体验。我一般用&lt;a href=&quot;https://baike.baidu.com/item/Xshell/5659054?fr=aladdin&quot; title=&quot;Xshell&quot;&gt;Xshell&lt;/a&gt;登陆本地WSL，体验很不错。&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;前期准备&lt;/h2&gt;
&lt;p&gt;首先从官网clone实验的框架代码到本地：&lt;code&gt;git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;编译工具链&quot;&gt;编译工具链&lt;/h2&gt;
&lt;p&gt;编译工具链是一个工具集包括c编译器，汇编编译器，连接器。在命令行下执行&lt;code&gt;gcc -m32 -print-libgcc-file-name&lt;/code&gt;，如果输出&lt;code&gt;/usr/lib/gcc/i486-linux-gnu/version/libgcc.a 或 /usr/lib/gcc/x86_64-linux-gnu/version/32/libgcc.a&lt;/code&gt;就说明没有问题了。否则执行&lt;code&gt;sudo apt-get install -y build-essential gdb&lt;/code&gt;进行安装（Ubuntu系统下）。在64位的机器上还需要安装32位支持库&lt;code&gt;sudo apt-get install gcc-multilib&lt;/code&gt;否则后面make的时候可能会出现&quot;__udivdi3 not found&quot;的情况。&lt;/p&gt;
&lt;h2 id=&quot;qemu模拟器安装&quot;&gt;QEMU模拟器安装&lt;/h2&gt;
&lt;p&gt;QEMU是一款模拟器，按照&lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2018/labguide.html&quot;&gt;官方文档&lt;/a&gt;的提示我们需要从源码安装针对课程定制过的QEMU。步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;clone源码：git clone &lt;a href=&quot;https://github.com/mit-pdos/6.828-qemu.git&quot; class=&quot;uri&quot;&gt;https://github.com/mit-pdos/6.828-qemu.git&lt;/a&gt; qemu （或git clone &lt;a href=&quot;http://web.mit.edu/ccutler/www/qemu.git&quot; class=&quot;uri&quot;&gt;http://web.mit.edu/ccutler/www/qemu.git&lt;/a&gt; -b 6.828-2.3.0）&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;./configure --disable-kvm --target-list=&quot;i386-softmmu x86_64-softmmu&quot;&lt;/code&gt;。这一步可能会报错：
&lt;ol&gt;&lt;li&gt;问题1：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: Python not found. Use --python=/path/to/python&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：添加&lt;code&gt;--python=python3&lt;/code&gt;，还是不行提示&lt;code&gt;Note that Python 3 or later is not yet supported&lt;/code&gt;。安装python2.7，然后使用&lt;code&gt;--python2.7&lt;/code&gt;选项&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题2：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: pkg-config binary 'pkg-config' not found&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：执行&lt;code&gt;apt-get install -y pkg-config&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题3：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: zlib check failed. Make sure to have the zlib libs and headers installed.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：执行&lt;code&gt;sudo apt-get install zlib1g-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题4：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: glib-2.12 gthread-2.0 is required to compile QEMU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：&lt;code&gt;sudo apt-get install libglib2.0-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题5：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;ERROR: pixman &amp;gt;= 0.21.8 not present.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：&lt;code&gt;sudo apt-get install libpixman-1-dev&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;问题6：
&lt;ol&gt;&lt;li&gt;出现：&lt;code&gt;vl.c: In function ‘main’: vl.c:2778:5: error: ‘g_mem_set_vtable’ is deprecated [-Werror=deprecated-declarations] g_mem_set_vtable(&amp;amp;mem_trace); ^ In file included from /usr/include/glib-2.0/glib/glist.h:32:0, from /usr/include/glib-2.0/glib/ghash.h:33, from /usr/include/glib-2.0/glib.h:50, from vl.c:59: /usr/include/glib-2.0/glib/gmem.h:357:7: note: declared here void g_mem_set_vtable (GMemVTable *vtable); ^ cc1: all warnings being treated as errors rules.mak:57: recipe for target 'vl.o' failed make: *** [vl.o] Error 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;解决：QEMU源码根目录下的Makefile文件最后加上一行 QEMU_CFLAGS+=-w&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;。至此QEMU安装完毕。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在lab源码根目录下执行make，如果看到&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499627/201810/1499627-20181005224752678-357941935.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就说明编译成功了。然后执行make qume，看到如下信息就说明环境搭建好了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499627/201810/1499627-20181005224808107-1782243723.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Oct 2018 14:52:00 +0000</pubDate>
<dc:creator>活在未来的人</dc:creator>
<og:description>MIT 6.828是操作系统中最经典的一门课程。完成所有的lab就相当于完成了一个迷你的操作系统。我跟的是2018年的课程，课程首页在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gatsby123/p/9746193.html</dc:identifier>
</item>
<item>
<title>设计模式——建造者模式 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9744580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9744580.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前在家看两个小外甥玩轨道车，拆开包装，一堆小零件，兄弟两一个拼桥梁、弯道、路标，一个装车、搭立交、组装上下坡。不一会儿轨道就全拼好了，两兄弟用代表自己的车子在轨道上追逐，玩的很开心。我看了下轨道车包装，根据使用零件多少不同，组拼顺序不同，摆放不同可以创建不同的轨道和街道，有椭圆形的，上下立交式的，单层的……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;忽然想到用程序来表述玩轨道车的流程，如果用类图描述轨道车的玩法，可以简单表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181005151722141-1784167619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分为两个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;红色为轨道车的各个部件，Road规定了轨道车可以有 坡度、弯道、桥梁、路标、汽车、立交这几个部分；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;蓝色部分为建造不同的轨道，环形轨道（AnnularBuilder）和立交轨道（InterchangeBuilder）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Road为模板方法的变形形式，轨定轨道车的部件和各个部件的组装顺序，实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Road {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;坡度&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; slope();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弯道&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; curve();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;桥梁&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bridge();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路标&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; guide();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;汽车&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; car();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;立交&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interchange();

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; create() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
        Method[] methods &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass().&lt;span&gt;getDeclaredMethods&lt;/span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String method : list) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; methods.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (methods[i].getName().equals(method)) {
                    methods[i].invoke(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setList(List&amp;lt;String&amp;gt;&lt;span&gt; methods){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; methods;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组装轨道车的部件实现方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TrackRoad &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Road {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;坡度&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; slope() {
        System.out.println(&lt;/span&gt;&quot;建造上下坡……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弯道&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; curve() {
        System.out.println(&lt;/span&gt;&quot;建造曲线车道……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;桥梁&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bridge() {
        System.out.println(&lt;/span&gt;&quot;建造桥梁……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路标&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; guide() {
        System.out.println(&lt;/span&gt;&quot;放置公路路标……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;汽车&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;p&lt;span&gt;rotected&lt;/span&gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; car() {
        System.out.println(&lt;/span&gt;&quot;建造汽车……&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;立交&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interchange() {
        System.out.println(&lt;/span&gt;&quot;建造立交……&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;抽象创建轨道车类Builder定义了轨道车的组装部件和获取组装的轨道车&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Builder {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 不同部件的创建
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPart(List&amp;lt;String&amp;gt;&lt;span&gt; methods);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 建造轨道
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; TrackRoad buildRoad() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体轨道车玩法建造类（立交轨道车）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterchangeBuilder &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Builder {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; TrackRoad road = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrackRoad();
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPart(List&amp;lt;String&amp;gt;&lt;span&gt; methods) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.road.setList(methods);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackRoad buildRoad() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.road;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想创建一个立交轨道，可以这么创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
InterchangeBuilder interchangeBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterchangeBuilder();
List&lt;/span&gt;&amp;lt;String&amp;gt; interMethods = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
interMethods.add(&lt;/span&gt;&quot;slope&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;bridge&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;guide&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;interchange&quot;&lt;span&gt;);
interMethods.add(&lt;/span&gt;&quot;car&quot;&lt;span&gt;);
interchangeBuilder.setPart(interMethods);
interchangeBuilder.buildRoad().create();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;建造上下坡……&lt;br/&gt;建造桥梁……&lt;br/&gt;放置公路路标……&lt;br/&gt;建造立交……&lt;br/&gt;建造汽车……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;引入导演类&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;坡度、弯道、桥梁、路标、汽车、立交不同组装方式可以构造不同的轨道，为了方便&lt;/span&gt;支持的很多不同的轨道，可以增加个导演类（Director）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181005173408946-318885490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;导演类封装立交轨道和环形轨道的实现，对外提供直接获取的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Director {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt; steps = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; InterchangeBuilder interchangeBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterchangeBuilder();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AnnularBuilder annularBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AnnularBuilder();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackRoad getInterchangeBuilder(){
        System.out.println(&lt;/span&gt;&quot;===========================建造立交车道===========================&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.steps.clear();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;slope&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;bridge&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;guide&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;interchange&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;car&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interchangeBuilder.setPart(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.steps);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interchangeBuilder.buildRoad();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrackRoad getAnnularBuilder(){
        System.out.println(&lt;/span&gt;&quot;===========================建造曲线车道===========================&quot;&lt;span&gt;);&lt;br/&gt;　　　　 this.steps.clear();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;curve&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;bridge&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;guide&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.steps.add(&quot;car&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.annularBuilder.setPart(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.steps);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.annularBuilder.buildRoad();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;客户端不关注如何实现，只需要拿来即用（可玩）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testDerictor() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InvocationTargetException, IllegalAccessException {
        Director director &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Director();
        director.getAnnularBuilder().create();

        director.getInterchangeBuilder().create();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实这就是建造者模式，由导演类决定如何构建具体的对象（产品）。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;建造者模式&lt;/h2&gt;
&lt;h3&gt;定义&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181005144118361-1938243474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四要素&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;建造者模式中有以下4个角色：&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Product产品类&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;通常是实现模板方法模式（有模板方法和基本方法的类），例子里的&lt;span&gt;TrackRoad（轨道）&lt;/span&gt;就属于产品类。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Builder抽象建造者&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;规范产品的组建，一般是抽象类，约定功能由子类去实现具体的建造方法，对应例子里的Builder。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;ConcreteBuilder具体建造者&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;实现抽象建造者的所有方法。例子里的InterchangeBuilder和AnnularBuilder就是具体轨道的建造者。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Director导演类&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;封装具体建造者，提供简单易用的构建产品类方法。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;h3&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;封装性：将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建造者独立，容易扩展：增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;缺点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;使用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;相同的方法，不同的执行顺序，产生不同的事件结果时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 05 Oct 2018 14:14:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>引言 之前在家看两个小外甥玩轨道车，拆开包装，一堆小零件，兄弟两一个拼桥梁、弯道、路标，一个装车、搭立交、组装上下坡。不一会儿轨道就全拼好了，两兄弟用代表自己的车子在轨道上追逐，玩的很开心。我看了下轨</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9744580.html</dc:identifier>
</item>
</channel>
</rss>