<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 操作Word书签（二）——插入图片、表格到书签；读取、替换书签 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/9336062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/9336062.html</guid>
<description>&lt;h2&gt;&lt;span&gt;概要&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;书签的设置可以帮助我们快速的定位某段文字，使用起来很方便，也很节省时间。在前一篇文章“&lt;a href=&quot;http://www.cnblogs.com/Yesi/p/7520695.html&quot; target=&quot;_blank&quot;&gt;C# 如何添加/删除Word书签&lt;/a&gt;”中介绍了插入、删除书签的方法，本篇文章将对C# 操作Word书签的功能做进一步介绍。示例内容将包含以下要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在现有书签位置插入图片&lt;/li&gt;
&lt;li&gt;在现有书签位置插入表格&lt;/li&gt;
&lt;li&gt;读取书签位置的文档内容&lt;/li&gt;
&lt;li&gt;替换现有书签位置内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;使用工具&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ps:下载安装该类库后，注意添加引用Spire.Doc.dl到项目程序，dll文件可在安装路径的Bin文件夹中获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201807/706090-20180719142440352-1629981255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;示例代码（供参考）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;测试文档如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201807/706090-20180719143156794-1285551836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;【示例1】 在现有书签位置插入图片&lt;/h3&gt;
&lt;p&gt;步骤 1： 添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Fields;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Drawing;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：主要代码段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建实例，加载文档&lt;/span&gt;
Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
document.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化BookmarksNavigator类,指定需要添加图片的书签“Bookmark1”&lt;/span&gt;
BookmarksNavigator bn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookmarksNavigator(document);
bn.MoveToBookmark(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bookmark1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加段落，加载图片并插入到段落&lt;/span&gt;
Section section0 =&lt;span&gt; document.AddSection();
Paragraph paragraph &lt;/span&gt;=&lt;span&gt; section0.AddParagraph();
Image image &lt;/span&gt;= Image.FromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
DocPicture picture &lt;/span&gt;=&lt;span&gt; paragraph.AppendPicture(image);
bn.InsertParagraph(paragraph);
document.Sections.Remove(section0);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档并打开&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; output = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
document.SaveToFile(output, FileFormat.Docx);
System.Diagnostics.Process.Start(output);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图片插入效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201807/706090-20180719143359133-1275881652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c4df0ef6-3f8e-4043-9df2-b979678e170a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c4df0ef6-3f8e-4043-9df2-b979678e170a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c4df0ef6-3f8e-4043-9df2-b979678e170a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Fields;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; InsertImgToBookmark_Doc
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建实例，加载文档&lt;/span&gt;
            Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            document.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化BookmarksNavigator类,指定需要添加图片的书签“Bookmark1”&lt;/span&gt;
            BookmarksNavigator bn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookmarksNavigator(document);
            bn.MoveToBookmark(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bookmark1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加段落，加载图片并插入到段落&lt;/span&gt;
            Section section0 =&lt;span&gt; document.AddSection();
            Paragraph paragraph &lt;/span&gt;=&lt;span&gt; section0.AddParagraph();
            Image image &lt;/span&gt;= Image.FromFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            DocPicture picture &lt;/span&gt;=&lt;span&gt; paragraph.AppendPicture(image);
            bn.InsertParagraph(paragraph);
            document.Sections.Remove(section0);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档并打开&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; output = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            document.SaveToFile(output, FileFormat.Docx);
            System.Diagnostics.Process.Start(output);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt; 【示例 2】在现有书签位置插入表格&lt;/h3&gt;
&lt;p&gt;步骤 1：添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System.Data;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：创建文档，加载文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Document doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
doc.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：创建表格&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Table对象&lt;/span&gt;
Table table = &lt;span&gt;new&lt;/span&gt; Table(doc, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建模拟数据&lt;/span&gt;
DataTable dt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YTD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));                     
dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YTD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAIC EC-Series&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.719&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;64.910&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tesla Model S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.889&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;46.951&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nissan Leaf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.817&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;46.423&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据填充至表格&lt;/span&gt;
&lt;span&gt;table.ResetCells(dt.Rows.Count, dt.Columns.Count);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; dt.Rows.Count; i++&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; dt.Columns.Count; j++&lt;span&gt;)
    {
        table.Rows[i].Cells[j].AddParagraph().AppendText(dt.Rows[i][j].ToString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4 ：插入表格到书签位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定书签位置&lt;/span&gt;
BookmarksNavigator navigator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookmarksNavigator(doc);
navigator.MoveToBookmark(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;origin2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将表格添加至TextBodyPart&lt;/span&gt;
TextBodyPart part =&lt;span&gt; navigator.GetBookmarkContent();
part.BodyItems.Add(table);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换原有书签内容&lt;/span&gt;
navigator.ReplaceBookmarkContent(part);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 5 ：保存文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存并打开文件&lt;/span&gt;
doc.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Docx2013);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 表格插入效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201807/706090-20180719144241433-1956018954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_20d3b2bc-16a8-4020-b719-b907e52dab6c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20d3b2bc-16a8-4020-b719-b907e52dab6c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20d3b2bc-16a8-4020-b719-b907e52dab6c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; InsertTableToBookmark_Doc
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建文档，加载文件&lt;/span&gt;
            Document doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            doc.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Table对象&lt;/span&gt;
            Table table = &lt;span&gt;new&lt;/span&gt; Table(doc, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建模拟数据&lt;/span&gt;
            DataTable dt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
            dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
            dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
            dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));
            dt.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YTD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;));                     
            dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nov.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;YTD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BAIC EC-Series&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.719&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;64.910&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tesla Model S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.889&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;46.951&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            dt.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Nissan Leaf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.817&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;46.423&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据填充至表格&lt;/span&gt;
&lt;span&gt;            table.ResetCells(dt.Rows.Count, dt.Columns.Count);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; dt.Rows.Count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; dt.Columns.Count; j++&lt;span&gt;)
                {
                    table.Rows[i].Cells[j].AddParagraph().AppendText(dt.Rows[i][j].ToString());
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定书签位置&lt;/span&gt;
            BookmarksNavigator navigator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookmarksNavigator(doc);
            navigator.MoveToBookmark(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;origin2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将表格添加至TextBodyPart&lt;/span&gt;
            TextBodyPart part =&lt;span&gt; navigator.GetBookmarkContent();
            part.BodyItems.Add(table);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换书签内容&lt;/span&gt;
&lt;span&gt;            navigator.ReplaceBookmarkContent(part);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存并打开文件&lt;/span&gt;
            doc.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, FileFormat.Docx2013);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;output.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;【示例3】读取书签位置的内容&lt;/h3&gt;
&lt;p&gt;步骤 1 ：添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Fields;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; System;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：获取书签位置的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化BookmarkNavigator类对象&lt;/span&gt;
BookmarksNavigator navigator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookmarksNavigator(doc);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位到指定书签位置，获取书签位置的文档内容&lt;/span&gt;
navigator.MoveToBookmark(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookmark1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
TextBodyPart textBodyPart &lt;/span&gt;= navigator.GetBookmarkContent();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：读取书签内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历书签内容中的子项目，并将文本信息提取至string类型变量中&lt;/span&gt;
&lt;span&gt;string&lt;/span&gt; text = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; textBodyPart.BodyItems)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Paragraph)
    {
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; childObject &lt;span&gt;in&lt;/span&gt; (item &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Paragraph).ChildObjects)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childObject &lt;span&gt;is&lt;/span&gt;&lt;span&gt; TextRange)
            {
                text &lt;/span&gt;+= (childObject &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TextRange).Text;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制台输出文本&lt;/span&gt;
&lt;span&gt;Console.WriteLine(text);
Console.ReadLine();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 读取结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201807/706090-20180719145811185-63368506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_65f538ca-f950-486d-bada-b229b0b3d76b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_65f538ca-f950-486d-bada-b229b0b3d76b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_65f538ca-f950-486d-bada-b229b0b3d76b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Fields;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; GetTextOfBookmark_Doc
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化Document类，加载测试文档&lt;/span&gt;
            Document doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            doc.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化BookmarkNavigator类对象&lt;/span&gt;
            BookmarksNavigator navigator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookmarksNavigator(doc);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位到指定书签位置，获取书签位置的文档内容&lt;/span&gt;
            navigator.MoveToBookmark(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookmark1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            TextBodyPart textBodyPart &lt;/span&gt;=&lt;span&gt; navigator.GetBookmarkContent();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历书签内容中的子项目，并将文本信息提取至string类型变量中&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; text = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; textBodyPart.BodyItems)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Paragraph)
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; childObject &lt;span&gt;in&lt;/span&gt; (item &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Paragraph).ChildObjects)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (childObject &lt;span&gt;is&lt;/span&gt;&lt;span&gt; TextRange)
                        {
                            text &lt;/span&gt;+= (childObject &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TextRange).Text;
                        }
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制台输出文本&lt;/span&gt;
&lt;span&gt;            Console.WriteLine(text);
            Console.ReadLine();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;【示例4】替换现有书签内容&lt;/p&gt;
&lt;p&gt;步骤 1 ：添加using指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; Spire.Doc.Fields;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 2 ：加载文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
document.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 3 ：添加段落及文字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Section sec = document.AddSection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加section&lt;/span&gt;
sec.AddParagraph().AppendText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Welcome Back, \n My Friend!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加段落到section，并添加字符串内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 4 ：获取段落&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取段落内容 &lt;/span&gt;
ParagraphBase firstReplacementParagraph = sec.Paragraphs[&lt;span&gt;0&lt;/span&gt;].Items.FirstItem &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ParagraphBase;
ParagraphBase lastReplacementParagraph &lt;/span&gt;= sec.Paragraphs[sec.Paragraphs.Count - &lt;span&gt;1&lt;/span&gt;].Items.LastItem &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ParagraphBase;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化类TextBodySelection和TextBodyPart&lt;/span&gt;
TextBodySelection selection = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextBodySelection(firstReplacementParagraph, lastReplacementParagraph);
TextBodyPart part &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TextBodyPart(selection);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 5 ：替换书签内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
BookmarksNavigator bookmarkNavigator = &lt;span&gt;new&lt;/span&gt; BookmarksNavigator(document);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化BookmarksNavigator类 &lt;/span&gt;
bookmarkNavigator.MoveToBookmark(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookmark1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位到书签“bookmark1”所在段落的位置&lt;/span&gt;
bookmarkNavigator.DeleteBookmarkContent(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除原有书签位置的内容&lt;/span&gt;
bookmarkNavigator.ReplaceBookmarkContent(part, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用新添加段落的内容替换掉原书签的内容并保留格式&lt;/span&gt;
document.Sections.Remove(sec); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除section&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤 6 ：保存文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档并打开&lt;/span&gt;
document.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换书签.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换书签.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;替换效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/706090/201807/706090-20180719151544453-1967724256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全部代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_648db396-2762-46ac-b790-60358c8201dd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_648db396-2762-46ac-b790-60358c8201dd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_648db396-2762-46ac-b790-60358c8201dd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Documents;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Spire.Doc.Fields;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; EditOrReplaceBookmark_Doc
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Document类实例，加载文档 &lt;/span&gt;
            Document document = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Document();
            document.LoadFromFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Section sec &lt;/span&gt;= document.AddSection();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加section&lt;/span&gt;
            sec.AddParagraph().AppendText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Welcome Back, \n My Friend!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加段落到section，并添加字符串内容

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取段落内容 &lt;/span&gt;
            ParagraphBase firstReplacementParagraph = sec.Paragraphs[&lt;span&gt;0&lt;/span&gt;].Items.FirstItem &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ParagraphBase;
            ParagraphBase lastReplacementParagraph &lt;/span&gt;= sec.Paragraphs[sec.Paragraphs.Count - &lt;span&gt;1&lt;/span&gt;].Items.LastItem &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ParagraphBase;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化类TextBodySelection和TextBodyPart&lt;/span&gt;
            TextBodySelection selection = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextBodySelection(firstReplacementParagraph, lastReplacementParagraph);
            TextBodyPart part &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TextBodyPart(selection);

            BookmarksNavigator bookmarkNavigator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BookmarksNavigator(document);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化BookmarksNavigator类 &lt;/span&gt;
            bookmarkNavigator.MoveToBookmark(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookmark1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位到书签“bookmark1”所在段落的位置&lt;/span&gt;
            bookmarkNavigator.DeleteBookmarkContent(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除原有书签位置的内容&lt;/span&gt;
            bookmarkNavigator.ReplaceBookmarkContent(part, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用新添加段落的内容替换掉原书签的内容并保留格式            &lt;/span&gt;
            document.Sections.Remove(sec); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除section

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存文档并打开&lt;/span&gt;
            document.SaveToFile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换书签.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.Diagnostics.Process.Start(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;替换书签.docx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;以上是本次关于C# 操作Word书签功能的补充介绍，如需转载，请注明出处。&lt;/p&gt;
&lt;p&gt;（本文完）&lt;/p&gt;

</description>
<pubDate>Thu, 19 Jul 2018 07:26:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/9336062.html</dc:identifier>
</item>
<item>
<title>【安富莱】【RL-TCPnet网络教程】第8章  RL-TCPnet网络协议栈移植（RTX） - 席萌0209</title>
<link>http://www.cnblogs.com/armfly/p/9336000.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/armfly/p/9336000.html</guid>
<description>&lt;p&gt;&lt;span&gt;本章教程为大家讲解RL-TCPnet网络协议栈的RTX操作系统移植方式，学习了第6章讲解的底层驱动接口函数之后，移植就比较容易了，主要是添加库文件、配置文件和驱动文件即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本章教程含STM32F407开发板和STM32F429开发板的移植。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.1  移植前准备工作说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.2  STM32F407移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.3  STM32F429移植RL-TCPnet协议栈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8.4   总结&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;8.1  移植前准备工作说明&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、学习本章节前，务必要优先学习第6章的底层驱动讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、RL-TCPnet只有库，没有源码。库分为两个版本，一个用于调试的版本TCPD_CM3.lib和一个正式版本TCP_CM3.lib，当前的例子统一使用调试版本。另外注意，虽然是CM3版本的，但可同时用于CM3和CM4内核的MCU，因为官方没有专门的CM4内核库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、测试时，请将网线接到路由器或者交换机上面测试，因为已经使能了DHCP，可以自动获取IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      而且使能了NetBIOS局域网域名，用户只需在电脑端ping armfly，就可以获得板子的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果要使用固定IP进行测试，请看第57章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、网口使用的是DM9161/9162（紧挨着9帧串口座的网口），而不是DM9000。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、找一个简单的工程，最好是跑马灯之类的，越简单越好，我们就在这个简单的工程上面移植即可。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;8.2   STM32F407移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;8.2.1      RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的RTX工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151009750-788482006.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分4步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们RTX模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151021540-831975421.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151029330-1229944580.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别注意一点，由于新添加的RL-ARM文件里面已经包含了RTX操作系统，建议大家使用此文件里面的RTX系统源码，将自己工程模板里面的删掉，然后重新添加下即可。这样做的目的是方便RTX操作系统及其中间件的头文件统一管理。还有一个原因是防止大家工程模板里面的头文件与新添加的RL-ARM文件夹里面的头文件冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加完毕后的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151053830-1195495093.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第3步：添加相应的头文件路径，在原来工程模板的基础上新添加的几个路径：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151059613-560898541.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第4步：也是最后一步，添加预定义宏，点击MDK的option -&amp;gt; c/c++选项，添加上__RTX（&lt;span&gt;注意，字母RTX前面有两个下划线的&lt;/span&gt;），添加这个宏定义才可以使能RL-TCPnet的多任务支持。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151105813-1329468936.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.2.2     RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151117025-478151964.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151123156-553686410.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151129586-778688131.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151136589-1696659489.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151144347-2134717175.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151150412-1419737023.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.2.3     RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151204126-1830287147.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都是关闭的，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151211487-1093058948.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.2.4     RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V5-1001_RL-TCPnet实验_工程移植模板（RTX）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151222384-978686712.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RTX&lt;/strong&gt;&lt;strong&gt;操作系统创建的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过上面的移植和配置之后，在 main.c 文件中添加如下代码，代码中创建了5个用户任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskUserIF任务   ：按键消息处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskLED任务     ：LED闪烁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskMsgPro任务 ：按键检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskTCPMain任务：RL-TCPnet测试任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskStart任务    ：启动任务，也是最高优先级任务，这里实现RL-TCPnet的时间基准更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                   函数声明

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskUserIF(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskLED(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskMsgPro(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskTCPMain(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskStart(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                    变量

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskUserIFStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskLEDStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskMsgProStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskTCPMainStk[&lt;span&gt;2048&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;]; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskStartStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

OS_TID HandleTaskUserIF &lt;/span&gt;=&lt;span&gt; NULL;

OS_TID HandleTaskMsgPro &lt;/span&gt;=&lt;span&gt; NULL;

OS_TID HandleTaskLED &lt;/span&gt;=&lt;span&gt; NULL;

OS_TID HandleTaskTCPMain &lt;/span&gt;=&lt;span&gt; NULL;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{   

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化外设 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建启动任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     os_sys_init_user (AppTaskStart,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;5&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &amp;amp;AppTaskStartStk,          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;sizeof&lt;/span&gt;(AppTaskStartStk));  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskUserIF

*    功能说明: 按键消息处理     

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 1  (数值越小优先级越低，这个跟uCOS相反)

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskUserIF(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t ucKeyCode;

 

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K1键按下，直接发送事件标志给任务AppTaskTCPMain，bit0被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       os_evt_set (KEY1_BIT0, HandleTaskTCPMain);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2键按下，直接发送事件标志给任务AppTaskTCPMain，bit1被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       os_evt_set (KEY2_BIT1, HandleTaskTCPMain);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3键按下，直接发送事件标志给任务AppTaskTCPMain，bit2被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       os_evt_set (KEY3_BIT2, HandleTaskTCPMain);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

        

         os_dly_wait(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskLED

*    功能说明: LED闪烁。

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 2 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskLED(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t usFrequency = &lt;span&gt;500&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     os_itv_set(usFrequency);

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         bsp_LedToggle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

 

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; os_itv_wait是绝对延迟，os_dly_wait是相对延迟。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         os_itv_wait();

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskMsgPro

*    功能说明: 按键检测

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 3 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskMsgPro(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         bsp_KeyScan();

         os_dly_wait(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskTCPMain

*    功能说明: RL-TCPnet测试任务

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 4 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskTCPMain(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         TCPnetTest();

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskStart

*    功能说明: 启动任务，也是最高优先级任务，这里实现RL-TCPnet的时间基准更新。

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 5

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskStart(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化RL-TCPnet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     init_TcpNet ();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppTaskCreate();

    

     os_itv_set (&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         os_itv_wait ();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet时间基准更新函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCreate

*    功能说明: 创建应用任务

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     HandleTaskUserIF &lt;/span&gt;= os_tsk_create_user(AppTaskUserIF,             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;1&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &amp;amp;AppTaskUserIFStk,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;sizeof&lt;/span&gt;(AppTaskUserIFStk)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     HandleTaskLED &lt;/span&gt;= os_tsk_create_user(AppTaskLED,              &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                        &lt;span&gt;2&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                        &amp;amp;AppTaskLEDStk,          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                        &lt;span&gt;sizeof&lt;/span&gt;(AppTaskLEDStk));  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     HandleTaskMsgPro &lt;/span&gt;= os_tsk_create_user(AppTaskMsgPro,             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;3&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &amp;amp;AppTaskMsgProStk,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;sizeof&lt;/span&gt;(AppTaskMsgProStk)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

    HandleTaskTCPMain &lt;/span&gt;= os_tsk_create_user(AppTaskTCPMain,             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;4&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &amp;amp;AppTaskTCPMainStk,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;sizeof&lt;/span&gt;(AppTaskTCPMainStk)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

 

     bsp_InitDWT();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化DWT &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量（必须在 bsp_InitTimer() 之前调用） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，主要功能是创建了一个TCP Server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t iCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     OS_RESULT xResult;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t usMaxBlockTime = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER|TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet处理函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         main_TcpNet();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键消息的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt;((os_evt_wait_or(&lt;span&gt;0xFFFF&lt;/span&gt;, usMaxBlockTime) == OS_R_EVT)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              xResult &lt;/span&gt;=&lt;span&gt; os_evt_get ();

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (xResult)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY1_BIT0:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY2_BIT1:       

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY3_BIT2:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                      maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，裸机方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.2.5     RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F407开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151254171-297983456.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151301359-799955378.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151306889-2042873475.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151313325-6050238.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;8.3  STM32F429移植RL-TCPnet协议栈&lt;/h2&gt;
&lt;h3&gt;8.3.1     RL-TCPnet网络协议栈移植&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先准备好一个简单的RTX工程模板，工程模板的制作就不做讲解了，这里的重点是教大家移植RL-TCPnet协议栈。准备好的工程模板如下图所示（&lt;span&gt;大家也可以制作其它任意的工程模板，不限制&lt;/span&gt;）：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151330051-1085520376.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备好工程模板后，就可以开始移植了。首先要做的就是将所有需要的文件放到工程模板里面。下面分4步跟大家进行说明，当然，不限制必须使用下面的方法添加源码到工程，只要将需要的文件添加到工程模板即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第1步：将我们RTX模板中制作好的RL-ARM文件夹复制粘贴到大家准备好的工程模板中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151335916-1192223090.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-ARM文件夹中有如下七个文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151341493-1115721514.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Config文件夹用于存放RTX及其中间件的配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Driver文件夹用于存放中间件的驱动文件，也就是底层移植文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-CAN文件夹用于存放CAN总线的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-FlashFS文件夹用于存放文件系统RL-FlashFS的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-RTX文件夹用于存放RTX的源码文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet文件夹用于存放网络协议栈RL-TCPnet的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-USB文件夹用于存放USB协议栈RL-USB的库文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许有用户会问：我们不是仅仅需要移植RL-TCPnet的相关文件就行了吗，为什么把RTX及其所有中间件都添加进来了？这样做的目的是为了以后升级的方便，如果需要添加USB、文件系统、CAN等组件，直接添加到工程即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些文件全部来自MDK4.74的安装目录，库文件位于路径：C:\Keil_v474\ARM\RV31下，而驱动和配置文件位于路径：C:\Keil_v474\ARM\RL下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别注意一点，由于新添加的RL-ARM文件里面已经包含了RTX操作系统，建议大家使用此文件里面的RTX系统源码，将自己工程模板里面的删掉，然后重新添加下即可。这样做的目的是方便RTX操作系统及其中间件的头文件统一管理。还有一个原因是防止大家工程模板里面的头文件与新添加的RL-ARM文件夹里面的头文件冲突了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第2步：添加RL-TCPnet的库文件、配置文件和驱动文件到工程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;添加完毕后的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151347594-216914300.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Net_Config.c和NET_Debug.c在RL-ARM文件夹的Config文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCPD_CM3.lib在RL-ARM文件夹的RL-TCPnet文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ETH_STM32F4xx.c和ETH_STM32F4xx.h在RL-ARM文件夹的Driver文件里面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第3步：添加相应的头文件路径，在原来工程模板的基础上新添加的几个路径：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151353007-1231314422.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第4步：也是最后一步，添加预定义宏，点击MDK的option -&amp;gt; c/c++选项，添加上__RTX（&lt;span&gt;注意，字母RTX前面有两个下划线的&lt;/span&gt;），添加这个宏定义才可以使能RL-TCPnet的多任务支持。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151358860-1795358187.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，RL-TCPnet的移植工作就完成了，剩下就是系统配置和应用了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.3.2     RL-TCPnet配置说明（Net_Config.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的配置工作是通过配置文件Net_Config.c实现。在MDK工程中打开文件Net_Config.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151404965-1024757847.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet要配置的选项非常多，我们这里把几个主要的配置选项简单介绍下。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151410357-1144324076.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;System Definitions&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Local Host Name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网域名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里起名为armfly，使用局域网域名限制为15个字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Memory Pool size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参数范围1536-262144字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存池大小配置，单位字节。另外注意一点，配置向导这里显示的单位是字节，如果看原始定义，MDK会做一个自动的4字节倍数转换，比如我们这里配置的是8192字节，那么原始定义是#define MEM_SIZE  2048，也就是8192/4 = 2048。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Tick Timer interval&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可取10，20，25，40，50，100，200，单位ms&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统滴答时钟间隔，也就是网络协议栈的系统时间基准，默认情况下，取值100ms。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151417052-1818056975.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，勾选了此选项就可以配置了，如果没有使能DHCP的话，将使用这里配置的固定IP&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）MAC Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局域网内可以随意配置，只要不跟局域网内其它设备的MAC地址冲突即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）IP Address&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Subnet mask&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子网掩码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Gateway&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认网关。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151425079-920401349.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Ethernet Network Interface&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以太网接口配置，这个配置里面还有如下两项比较重要的配置需要说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）NetBIOS Name Service&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;NetBIOS局域网域名服务，这里打上对勾就使能了。这样我们就可以通过前面配置的Local Host Name局域网域名进行访问，而不需要通过IP地址访问了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Dynaminc Host Configuration&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即DHCP，这里打上对勾就使能了。使能了DHCP后，RL-TCPnet就可以从外接的路由器上获得动态IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151432477-687195025.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;UDP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of UDP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的UDP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1 – 20。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151438352-14262150.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP Sockets&lt;/strong&gt;&lt;strong&gt;配置，打上对勾就使能了此项功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）Number of TCP Sockets&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置可创建的TCP Sockets数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Number of Retries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围0-20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置重试次数，TCP数据传输时，如果在设置的重试时间内得不到应答，算一次重试失败，这里就是配置的最大重试次数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Retry Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-10，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试时间。如果发送的数据在重试时间内得不到应答，将重新发送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）Default Connect Timeout in seconds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围1-600，单位秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用于配置默认的保持连接时间，即我们常说的Keep Alive时间，如果时间到了将断开连接。常用于HTTP Server，Telnet Server等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）Maximum Segment Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-1460，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MSS定义了TCP数据包能够传输的最大数据分段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）Receive Window Size&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围536-65535，单位字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP接收窗口大小。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.3.3     RL-TCPnet调试说明（Net_Debug.c）&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;span&gt;重要说明，RL-TCPnet的调试是通过串口打印出来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RL-TCPnet的调试功能是通过配置文件Net_Debug.c实现。在MDK工程中打开文件Net_Debug.c，可以看到下图所示的工程配置向导：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151445940-938635807.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Print Time Stamp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;勾选了此选项的话，打印消息时，前面会附带时间信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;其它所有的选项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，所有的调试选项都关闭了，每个选项有三个调试级别可选择，这里我们以Memory Management Debug为例，点击下拉列表，可以看到里面有Off，Errors only和Full debug三个调试级别可供选择，每个调试选项里面都是这三个级别。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151452278-483330919.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Off：表示关闭此选项的调试功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Errors only：表示仅在此选项出错时，将其错误打印出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Full debug：表示此选项的全功能调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于调试功能的使用会在第11章详细为大家讲解，移植阶段将其全部关闭即可。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.3.4     RL-TCPnet应用实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了验证移植的RL-TCPnet是否可以使用，需要添加测试代码。下面是编写的测试代码，配套的测试例子完整版是：V6-1001_RL-TCPnet实验_工程移植模板（RTX）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151458330-1166883206.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RTX&lt;/strong&gt;&lt;strong&gt;操作系统创建的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过上面的移植和配置之后，在 main.c 文件中添加如下代码，代码中创建了5个用户任务：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskUserIF任务   ：按键消息处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskLED任务     ：LED闪烁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskMsgPro任务 ：按键检测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskTCPMain任务：RL-TCPnet测试任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AppTaskStart任务    ：启动任务，也是最高优先级任务，这里实现RL-TCPnet的时间基准更新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                   函数声明

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskUserIF(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskLED(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskMsgPro(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskTCPMain(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskStart(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

**********************************************************************************************************

                                                    变量

**********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskUserIFStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskLEDStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskMsgProStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskTCPMainStk[&lt;span&gt;2048&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;]; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; uint64_t AppTaskStartStk[&lt;span&gt;1024&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;];   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务句柄 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

OS_TID HandleTaskUserIF &lt;/span&gt;=&lt;span&gt; NULL;

OS_TID HandleTaskMsgPro &lt;/span&gt;=&lt;span&gt; NULL;

OS_TID HandleTaskLED &lt;/span&gt;=&lt;span&gt; NULL;

OS_TID HandleTaskTCPMain &lt;/span&gt;=&lt;span&gt; NULL;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: main

*    功能说明: 标准c程序入口。

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; main (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{   

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化外设 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_Init();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建启动任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     os_sys_init_user (AppTaskStart,              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;5&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &amp;amp;AppTaskStartStk,          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                       &lt;span&gt;sizeof&lt;/span&gt;(AppTaskStartStk));  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskUserIF

*    功能说明: 按键消息处理     

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 1  (数值越小优先级越低，这个跟uCOS相反)

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskUserIF(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t ucKeyCode;

 

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         ucKeyCode &lt;/span&gt;=&lt;span&gt; bsp_GetKey();

        

         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ucKeyCode !=&lt;span&gt; KEY_NONE)

         {

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (ucKeyCode)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K1键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K1:

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K1键按下，直接发送事件标志给任务AppTaskTCPMain，bit0被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       os_evt_set (KEY1_BIT0, HandleTaskTCPMain);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K2键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K2:

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K2键按下，直接发送事件标志给任务AppTaskTCPMain，bit1被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       os_evt_set (KEY2_BIT1, HandleTaskTCPMain);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; K3键按下，直接发送事件标志给任务AppTaskTCPMain，设置bit2 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY_DOWN_K3:

                       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K3键按下，直接发送事件标志给任务AppTaskTCPMain，bit2被设置\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                       os_evt_set (KEY3_BIT2, HandleTaskTCPMain);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

        

         os_dly_wait(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskLED

*    功能说明: LED闪烁。

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 2 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskLED(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t usFrequency = &lt;span&gt;500&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     os_itv_set(usFrequency);

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         bsp_LedToggle(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

 

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; os_itv_wait是绝对延迟，os_dly_wait是相对延迟。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         os_itv_wait();

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskMsgPro

*    功能说明: 按键检测

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 3 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskMsgPro(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         bsp_KeyScan();

         os_dly_wait(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskTCPMain

*    功能说明: RL-TCPnet测试任务

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 4 

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskTCPMain(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         TCPnetTest();

     }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskStart

*    功能说明: 启动任务，也是最高优先级任务，这里实现RL-TCPnet的时间基准更新。

*    形    参: 无

*    返 回 值: 无

*   优 先 级: 5

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

__task &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; AppTaskStart(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化RL-TCPnet &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     init_TcpNet ();

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 创建任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     AppTaskCreate();

    

     os_itv_set (&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

    

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

    {

         os_itv_wait ();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet时间基准更新函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         timer_tick ();

    }

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: AppTaskCreate

*    功能说明: 创建应用任务

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AppTaskCreate (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     HandleTaskUserIF &lt;/span&gt;= os_tsk_create_user(AppTaskUserIF,             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;1&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &amp;amp;AppTaskUserIFStk,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;sizeof&lt;/span&gt;(AppTaskUserIFStk)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     HandleTaskLED &lt;/span&gt;= os_tsk_create_user(AppTaskLED,              &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                        &lt;span&gt;2&lt;/span&gt;,                       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                        &amp;amp;AppTaskLEDStk,          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                        &lt;span&gt;sizeof&lt;/span&gt;(AppTaskLEDStk));  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

     HandleTaskMsgPro &lt;/span&gt;= os_tsk_create_user(AppTaskMsgPro,             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;3&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &amp;amp;AppTaskMsgProStk,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;sizeof&lt;/span&gt;(AppTaskMsgProStk)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    

    HandleTaskTCPMain &lt;/span&gt;= os_tsk_create_user(AppTaskTCPMain,             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;4&lt;/span&gt;,                         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务优先级 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &amp;amp;AppTaskTCPMainStk,         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                                           &lt;span&gt;sizeof&lt;/span&gt;(AppTaskTCPMainStk)); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 任务栈大小，单位字节数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;硬件外设初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硬件外设的初始化是在 bsp.c 文件实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: bsp_Init

*    功能说明: 初始化所有的硬件设备。该函数配置CPU寄存器和外设的寄存器并初始化一些全局变量。只需要调用一次

*    形    参：无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; bsp_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

         由于ST固件库的启动文件已经执行了CPU系统时钟的初始化，所以不必再次重复配置系统时钟。

         启动文件配置了CPU主时钟频率、内部Flash访问速度和可选的外部SRAM FSMC初始化。

 

         系统时钟缺省配置为168MHz，如果需要更改，可以修改 system_stm32f4xx.c 文件

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 优先级分组设置为4，可配置0-15级抢占式优先级，0级子优先级，即不存在子优先级。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);

 

     SystemCoreClockUpdate();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 根据PLL配置更新系统时钟频率变量 SystemCoreClock &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

     bsp_InitDWT();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化DWT &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitUart();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化串口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitKey();     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始化按键变量（必须在 bsp_InitTimer() 之前调用） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

 

     bsp_InitExtIO();   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; FMC总线上扩展了32位输出IO, 操作LED等外设必须初始化 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

     bsp_InitLed();    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 初始LED指示灯端口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;RL-TCPnet&lt;/strong&gt;&lt;strong&gt;功能测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里专门创建了一个app_tcpnet_lib.c文件用于RL-TCPnet功能的测试，这里是创建了一个TCP Server。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;includes.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 

 

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_debug printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_debug(...)

&lt;span&gt;#endif&lt;/span&gt;

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PORT_NUM       1001    /* TCP服务器监听端口号 */

 

 

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                         变量

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t socket_tcp;

 

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: tcp_callback

*    功能说明: TCP Socket的回调函数

*    形    参: soc  TCP Socket类型

*             evt  事件类型

*             ptr  事件类型是TCP_EVT_DATA，ptr指向的缓冲区记录着接收到的TCP数据，其余事件记录IP地址

*             par  事件类型是TCP_EVT_DATA，记录接收到的数据个数，其余事件记录端口号

*    返 回 值:

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

U16 tcp_callback (U8 soc, U8 evt, U8 &lt;/span&gt;*&lt;span&gt;ptr, U16 par)

{

     &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;50&lt;/span&gt;&lt;span&gt;];

     uint16_t i;

    

     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 确保是socket_tcp的回调 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

     &lt;span&gt;if&lt;/span&gt; (soc !=&lt;span&gt; socket_tcp)

     {

         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

     }

 

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (evt)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

              远程客户端连接消息

             1、数组ptr存储远程设备的IP地址，par中存储端口号。

             2、返回数值1允许连接，返回数值0禁止连接。

         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONREQ:

              sprintf(buf, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;远程客户端请求连接IP: %d.%d.%d.%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, ptr[&lt;span&gt;0&lt;/span&gt;], ptr[&lt;span&gt;1&lt;/span&gt;], ptr[&lt;span&gt;2&lt;/span&gt;], ptr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:%s  port:%d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf, par);

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接终止 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ABORT:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Socket远程连接已经建立 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CONNECT:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket is connected to remote peer\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 连接断开 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_CLOSE:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connection has been closed\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 发送的数据收到远程设备应答 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_ACK:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到TCP数据帧，ptr指向数据地址，par记录数据长度，单位字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_EVT_DATA:

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data length = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, par);

              &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; par; i++&lt;span&gt;)

              {

                   printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ptr[%d] = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, ptr[i]);

              }

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCP_StatusCheck

*    功能说明: 检测TCP的连接状态，主要用于网线插拔的判断

*    形    参: 无

*    返 回 值: __TRUE  连接

*             __FALSE 断开

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

uint8_t TCP_StatusCheck(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{

     uint8_t res;

    

     &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (tcp_get_state(socket_tcp))

     {

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_FREE:

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CLOSED:

              res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

              printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_LISTEN:

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        

         &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TCP_STATE_CONNECT:

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__TRUE);

             

         &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 

              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

     }

    

     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (__FALSE);

}

 

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*    函 数 名: TCPnetTest

*    功能说明: TCPnet应用

*    形    参: 无

*    返 回 值: 无

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; TCPnetTest(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)

{ 

     int32_t iCount;

     uint8_t &lt;/span&gt;*&lt;span&gt;sendbuf;

     uint8_t tcp_status;

     uint16_t maxlen;

     uint8_t res;

     OS_RESULT xResult;

     &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; uint16_t usMaxBlockTime = &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 延迟周期 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

 

     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

        创建TCP Socket并创建监听，客户端连接服务器后，10秒内无数据通信将断开连接。

        但是由于这里使能了TCP_TYPE_KEEP_ALIVE，会一直保持连接，不受10秒的时间限制。

     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    socket_tcp &lt;/span&gt;= tcp_get_socket (TCP_TYPE_SERVER|TCP_TYPE_KEEP_ALIVE, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;, tcp_callback);

     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(socket_tcp != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

     {

         res &lt;/span&gt;=&lt;span&gt; tcp_listen (socket_tcp, PORT_NUM);

         printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp listen res = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, res);

     }

    

     &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

     {

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; RL-TCPnet处理函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         main_TcpNet();

        

         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 用于网线插拔的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

         tcp_status &lt;/span&gt;=&lt;span&gt; TCP_StatusCheck();

        

          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 按键消息的处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;if&lt;/span&gt;((os_evt_wait_or(&lt;span&gt;0xFFFF&lt;/span&gt;, usMaxBlockTime) == OS_R_EVT)&amp;amp;&amp;amp;(tcp_status ==&lt;span&gt; __TRUE))

         {

              xResult &lt;/span&gt;=&lt;span&gt; os_evt_get ();

              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (xResult)

              {

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K1键按下，给远程TCP客户端发送8字节数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY1_BIT0:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                {

                                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

 

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K2键按下，给远程TCP客户端发送1024字节的数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY2_BIT1:       

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                     maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);                      

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                      

                   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 接收到K3键按下，给远程TCP客户端发送5MB数据 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;case&lt;/span&gt;&lt;span&gt; KEY3_BIT2:              

                       printf_debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tcp_get_state(socket_tcp) = %d\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, tcp_get_state(socket_tcp));

                       iCount &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

                       &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;

                       {

                            main_TcpNet();

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcp_check_send (socket_tcp) ==&lt;span&gt; __TRUE)

                            {

                                 maxlen &lt;/span&gt;=&lt;span&gt; tcp_max_dsize (socket_tcp);

                                 iCount &lt;/span&gt;-=&lt;span&gt; maxlen;

                                

                                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(iCount &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                                 {

                                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这么计算没问题的 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                      maxlen &lt;/span&gt;= iCount +&lt;span&gt; maxlen;

                                 }

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 这里仅初始化了每次所发送数据包的前8个字节 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 sendbuf &lt;/span&gt;=&lt;span&gt; tcp_get_buf(maxlen);

                                 sendbuf[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                 sendbuf[&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;h&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

                                

                                 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 测试发现只能使用获取的内存 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

                                 tcp_send (socket_tcp, sendbuf, maxlen);

                            }

                           

                       }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(iCount &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                  

                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 其他的键值不处理 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

                   &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:                    

                       &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

              }

         }

     }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;至此，裸机方式移植的RL-TCPnet就可以运行了。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;8.3.5     RL-TCPnet实验测试和实验现象&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;测试前，先将开发板上面的DM9161/9162网口通过网线接到路由器或者交换机上面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;RJ45&lt;/strong&gt;&lt;strong&gt;网络变压器插座上绿灯和黄灯现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种网卡、交换机等网络设备都不一样，一般来讲：绿灯分为亮或不亮（代表网络速度），黄灯分为闪烁或不闪烁（代表是否有数据收发）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;绿灯：长亮代表100M； 不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黄灯：长亮代表无数据收发； 闪烁代表有数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也有些千兆网卡的灯以颜色区分，不亮代表10M / 绿色代表100M / 黄色代表1000M。现在10M的网络基本看不到了，如果一个灯长亮，基本可以说明100M网络或更高，而另一个灯时而闪烁，那代表有数据收发，具体要看你的网络设备了。甚至有些低等网卡如TP-LINK，只有一个灯，亮代表连通，闪烁代表数据收发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于STM32F429开发板上面的RJ45网络变压器插座上面的灯而言，绿灯代表数据收发，长亮的话表示无数据收发，闪烁代表有数据收发。黄灯代表网络速度，长亮代表100M，不亮代表10M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;底层驱动执行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了验证RL-TCPnet底层驱动接口函数是否有问题，专门在ETH_STM32F4xx.c文件中配置了串口调试打印函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

*********************************************************************************************************

*                                      用于本文件的调试

*********************************************************************************************************

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;#if&lt;/span&gt; 1

     &lt;span&gt;#define&lt;/span&gt; printf_eth printf

&lt;span&gt;#else&lt;/span&gt;

     &lt;span&gt;#define&lt;/span&gt; printf_eth(...)

&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;如果底层驱动正常执行了，打印的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151512190-315689191.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ping&lt;/strong&gt;&lt;strong&gt;是否正确&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ping命令的主要作用是通过发送数据包并接收应答信息来检测两台设备之间的网络是否连通。ping命令成功说明当前主机与目的主机之间存在连通的路径。如果不成功，需要查看网线是否连通、网卡设置是否正确、IP地址是否可用等。测试方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）WIN+R组合键打开“运行”窗口，输入cmd。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151517919-1109225024.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）弹出的命令窗口中，输入ping armfly，因为在前面的配置中我们使能了NetBIOS局域网域名，并将名字设置为armfly，而且使能了DHCP，通过ping命令还可以获得板子自动获取的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151522917-390516082.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）输入ping armfly后，回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1379107/201807/1379107-20180719151528593-687785327.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收发相同，没有数据丢失，说明ping命令也是成功的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;电脑端创建一个TCP Client与板子上面的TCP Server通信&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体测试方法，查看第13章的13.6小节即可，因为配套例子实现的功能是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;8.4  总结&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;本章节为大家讲解了RL-TCPnet网络协议栈的RTX操作系统移植方法，移植相对比较简单。另一个重要内容是Net_Config.c配置向导文件的说明，这个比较重要，初学者要好好熟悉下。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 19 Jul 2018 07:18:00 +0000</pubDate>
<dc:creator>席萌0209</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/armfly/p/9336000.html</dc:identifier>
</item>
<item>
<title>redis初识 - 金发只是水一下</title>
<link>http://www.cnblogs.com/wicfhwffg/p/9335595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wicfhwffg/p/9335595.html</guid>
<description>&lt;h2 id=&quot;linux环境搭建&quot;&gt;linux环境搭建&lt;/h2&gt;
&lt;h3 id=&quot;环境准备介绍&quot;&gt;环境准备介绍&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;Oracle VM VirtualBox&lt;/strong&gt;，虚机管理工具，免费好用，用过就知道&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;3台centos虚拟机&lt;/strong&gt;，为后续搭建redis集群环境以及最简单的redis哨兵模式（一主二从，至少3台）&lt;/p&gt;
&lt;h3 id=&quot;配置虚机网络&quot;&gt;配置虚机网络&lt;/h3&gt;
&lt;p&gt;​ 用centos7.ova导入VirtualBox，创建3台centos7虚拟机，内存跟cpu看自身笔记本硬件情况，需要注意的是，创建完成之后，这里的网络设置需要设置成桥接模式，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719142604241-2097621052.png&quot; alt=&quot;1-1虚拟机网络设置桥接模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 在创建完3台centos虚拟机后（这里使用的系统是centos7），将三台机子分别命名为eshop-cache01、eshop-cache02、eshop-cache03，方便称呼与后续管理（总比起三个ip地址为服务器名来的好吧）&lt;/p&gt;
&lt;p&gt;​ 接下来配置下3台虚机的网络，先来看下eshop-cache01的网络&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;centos7的查看ip指令是ip addr，centos7以下是ifconfig&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719142634737-566089216.png&quot; alt=&quot;1-2eshop-cache01的ip地址&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 然后关闭防火墙，避免因为防火墙导致ssh工具连接不上&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;service iptables stop
service ip6tables stop
chkconfig iptables off
chkconfig ip6tables off&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 然后采用ssh工具连接，此处采用SecureCRT，使用SecureCRT登录上eshop-cache01之后，修改eshop-cache01的网络，将ip设置成静态ip并且设置网络随机子启动而主动连接（不采用动态地址导致地址更换频繁的浪费时间去纠正ip）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vi /etc/sysconfig/network-scripts/ifcfg-enp0s3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 如下，修改的地方已用红框标注起来，首先修改ip分配方式为static，在文件末尾追加静态ip地址、子网掩码以及网关地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144208040-945188620.png&quot; alt=&quot;1-3eshop-cache01修改ifcfg-enp0s3图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 如下是我本地eshop-cache01的ifcfg-enp0s3文件内容&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;TYPE=&quot;Ethernet&quot;
BOOTPROTO=&quot;static&quot;
DEFROUTE=&quot;yes&quot;
PEERDNS=&quot;yes&quot;
PEERROUTES=&quot;yes&quot;
IPV4_FAILURE_FATAL=&quot;no&quot;
IPV6INIT=&quot;yes&quot;
IPV6_AUTOCONF=&quot;yes&quot;
IPV6_DEFROUTE=&quot;yes&quot;
IPV6_PEERDNS=&quot;yes&quot;
IPV6_PEERROUTES=&quot;yes&quot;
IPV6_FAILURE_FATAL=&quot;no&quot;
NAME=&quot;enp0s3&quot;
UUID=&quot;f17ed393-95ad-4bdd-ab43-4228af6a64c3&quot;
DEVICE=&quot;enp0s3&quot;
ONBOOT=&quot;yes&quot;

IPADDR=172.29.45.168
NETMASK=255.255.255.128
GATEWAY=172.29.45.129&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ ifcfg-enp0s3文件修改完之后，重启网络&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;service network restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144229269-450873647.png&quot; alt=&quot;1-4eshop-cache01重启网络图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ eshop-cache02与eshop-cache03如法炮制，最终配置完三台虚拟机的网络之后，三台虚拟机的ip地址如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;eshop-cache01&lt;/td&gt;
&lt;td&gt;172.29.45.168&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;eshop-cache02&lt;/td&gt;
&lt;td&gt;172.29.45.170&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;eshop-cache03&lt;/td&gt;
&lt;td&gt;172.29.45.171&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;修改host&quot;&gt;修改host&lt;/h3&gt;
&lt;p&gt;​ 在三台虚拟机的host中，添加三者的ip以及服务器域名，后续搭建集群时，可以通过域名去请求虚机，不去拷贝ip，不好记又容易乱&lt;/p&gt;
&lt;p&gt;​ host文件内容如下&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
172.29.45.168 eshop-cache01
172.29.45.170 eshop-cache02
172.29.45.171 eshop-cache03&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置虚机间ssh免密码登录&quot;&gt;配置虚机间ssh免密码登录&lt;/h3&gt;
&lt;p&gt;​ 修改host文件完成后，在eshop-cache01可以用ssh指令去连接eshop-02，但是每次连接都要求输入密码，很不方便。有这样一个场景，就是eshop-cache01有个文件的配置与另外两台服务器的配置是一样，如果我们用SecureCRT去操作的话，需要将文件拷贝到本机，然后再在本机上传到另外两台，但是这样机器少还好，机器多就容易乱，我们可以用scp指令去拷贝文件到另外两台服务器，方便快捷，但是使用scp指令在服务器之间传文件也需要提供密码，也是个耗时的操作，所以这里有必要将三台虚机相互通讯配置免密登录。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#生成本机的公钥，过程中不断敲回车即可，ssh-keygen命令默认会将公钥放在/root/.ssh目录下
ssh-keygen -t rsa

#将公钥复制为authorized_keys文件，此时使用ssh连接本机就不需要输入密码了
cd /root/.ssh
cp id_rsa.pub authorized_keys

#使用ssh-copy-id -i hostname命令将本机的公钥拷贝到指定机器的authorized_keys文件中
ssh-copy-id -i  eshop-cache02&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 然后eshop-cache02与eshop-cache03也如法炮制。&lt;/p&gt;
&lt;p&gt;​ 再提一个方法，就是这里我们只有3台服务器，但是如果再加几台，干这种工作也可能会让你干奔溃，所以有一个办法，就是在每个服务器上生成各自的公钥，然后使用&lt;code&gt;ssh-copy-id -i eshop-cache01&lt;/code&gt;指令将其他服务器的authorized_keys集中复制到eshop-cache01，此时其他服务器的authorized_keys会在eshop-cache01中追加，最后将eshop-cache01的authorized_keys复制到其他的服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144545768-1511185709.png&quot; alt=&quot;1-5eshop-cache01的authorized_keys文件内容&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置yum&quot;&gt;配置yum&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;yum clean all
yum makecache
yum install wget&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装perl&quot;&gt;安装perl&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#安装perl之前需要先安装gcc，如果确认自己的机子已经安装过gcc可以跳过该指令
yum install -y gcc

wget http://www.cpan.org/src/5.0/perl-5.16.1.tar.gz
tar -xzf perl-5.16.1.tar.gz
cd perl-5.16.1
./Configure -des -Dprefix=/usr/local/perl
make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install
perl -v&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 为什么要装perl？我们整个大型电商网站的系统，复杂。应用架构是java+nginx+lua，需要perl。&lt;/p&gt;
&lt;p&gt;​ perl，是一个基础的编程语言的安装，tomcat，跑java web应用&lt;/p&gt;
&lt;h2 id=&quot;安装单机版redis及其配置&quot;&gt;安装单机版redis及其配置&lt;/h2&gt;
&lt;h3 id=&quot;安装redis&quot;&gt;安装redis&lt;/h3&gt;
&lt;p&gt;redis安装包：&lt;a href=&quot;https://files.cnblogs.com/files/wicfhwffg/redis-3.2.8.tar.gz&quot;&gt;redis-3.2.8.tar.gz&lt;/a&gt;&lt;br/&gt;tcl安装包：&lt;a href=&quot;https://files.cnblogs.com/files/wicfhwffg/tcl8.6.1-src.tar.gz&quot;&gt;tcl8.6.1-src.tar.gz&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#安装redis之前需要先安装tcl，否则在make的时候，会报错，安装不成功
wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz
tar -xzvf tcl8.6.1-src.tar.gz
cd  /usr/local/tcl8.6.1/unix/
./configure  
make &amp;amp;&amp;amp; make install

#使用redis-3.2.8.tar.gz（截止2017年4月的最新稳定版）
tar -zxvf redis-3.2.8.tar.gz
cd redis-3.2.8
make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置redis&quot;&gt;配置redis&lt;/h3&gt;
&lt;p&gt;（1）redis安装目录的utils目录下，有个redis_init_script脚本&lt;/p&gt;
&lt;p&gt;（2）将redis_init_script脚本拷贝到linux的/etc/init.d目录中，将redis_init_script重命名为redis_6379，6379是我们希望这个redis实例监听的端口号&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cp /var/local/redis-3.2.8/utils/redis_init_script /etc/init.d/redis_6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）修改redis_6379脚本的第6行的REDISPORT，设置为相同的端口号（默认就是6379）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144649595-1740407358.png&quot; alt=&quot;2-1eshop-cache01的redis_6379内容&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）创建两个目录：/etc/redis（存放redis的配置文件），/var/redis/6379（存放redis的持久化文件）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#/etc目录已经存在，直接创建redis目录
mkdir /etc/redis
#/var/redis的目录不存在，需要递归地创建目录加参数-p
mkdir -p /var/redis/6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）修改redis配置文件（默认在根目录下，redis.conf），拷贝到/etc/redis目录中，修改名称为6379.conf&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cp /var/local/redis-3.2.8/redis.conf /etc/redis/6379.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）修改redis.conf中的部分配置为生产环境&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#让redis以daemon进程运行
daemonize yes
#设置redis的pid文件位置
pidfile /var/run/redis_6379.pid
#设置redis的监听端口号
port 6379
#设置持久化文件的存储位置
dir /var/redis/6379&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）启动redis&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd /etc/init.d
chmod 777 redis_6379
./redis_6379 start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（8）确认redis进程是否启动&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ps -ef | grep redis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（9）让redis跟随系统启动自动启动&lt;/p&gt;
&lt;p&gt;​ 在redis_6379脚本中，最上面，在#!/bin/sh下，加入两行注释&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# chkconfig:   2345 90 10
# description:  Redis is a persistent key-value database&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 然后执行如下指令，让redis跟随系统启动自动启动&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chkconfig redis_6379 on&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试redis安装成功&quot;&gt;测试redis安装成功&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#使用redis-cli指令连接eshop-cache01的redis服务器
redis-cli -h eshop-cache01 -p 6379
#连接成功，设置值
set mykey1 v1
#获取值
get mykey1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144715590-310349622.png&quot; alt=&quot;2-2eshop-cache01测试redis是否安装成功&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis持久化&quot;&gt;redis持久化&lt;/h2&gt;
&lt;p&gt;​ &lt;strong&gt;redis做持久化的意义在于故障恢复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 有这样的场景：你的电商项目部署了一个redis，作为cache缓存，当然也可以保存一些较为重要的数据，如果没有持久化的话，redis遇到灾难性故障的时候，就会丢失所有的数据，如果通过持久化将数据考一份儿在磁盘上去，然后定期比如说同步和备份到一些云存储服务上去，那么就可以保证数据不丢失全部，还是可以恢复一部分数据回来的。&lt;/p&gt;
&lt;p&gt;​ 如果不做持久化，当redis挂了，所有缓存数据丢失，所有请求都会去重查数据库，网站的吞吐量会立马下降，然后碰上高峰期，数据库就会被搞崩溃，然后网站就GG了。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;所以，redis做持久化很有必要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144734571-19743504.png&quot; alt=&quot;3-1redis持久化的意义&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 如果redis做了持久化，当redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录中，然后重新启动redis，redis就会自动根据持久化数据文件中的数据，去恢复内存中的数据，继续对外提供服务&lt;/p&gt;
&lt;p&gt;​ redis的持久化有两种方式，RDB与AOF&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果我们想要redis仅仅作为纯内存的缓存来用，那么可以禁止RDB和AOF所有的持久化机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;rdb&quot;&gt;RDB&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;RDB持久化机制，对redis中的数据执行周期性的持久化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 简单的说，RDB是比较简单粗暴，在配置开启RDB之后（redis默认开启），redis会根据配置的周期性时间将内存数据的快照保存到本地文件。&lt;/p&gt;
&lt;p&gt;​ 也即，RDB，就是一份数据文件，恢复的时候，直接加载到内存中即可。&lt;/p&gt;
&lt;p&gt;​ 所以，RDB非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据。&lt;/p&gt;
&lt;p&gt;​ RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。&lt;/p&gt;
&lt;p&gt;​ 但是RDB也不是完美的，RDB也有&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;​ （1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据&lt;/p&gt;
&lt;p&gt;​ （2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒&lt;/p&gt;
&lt;h4 id=&quot;rdb持久化的工作流程&quot;&gt;RDB持久化的工作流程&lt;/h4&gt;
&lt;p&gt;​ （1）redis根据配置自己尝试去生成rdb快照文件&lt;br/&gt;（2）fork一个子进程出来&lt;br/&gt;（3）子进程尝试将数据dump到临时的rdb快照文件中&lt;br/&gt;（4）完成rdb快照文件的生成之后，就替换之前的旧的快照文件&lt;/p&gt;
&lt;h4 id=&quot;rdb的配置及实验&quot;&gt;RDB的配置及实验&lt;/h4&gt;
&lt;p&gt;​ 修改redis.conf文件，也就是/etc/redis/6379.conf，去配置持久化&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#每隔60s，如果有超过1000个key发生了变更，那么就生成一个新的dump.rdb文件，就是当前redis内存中完整的数据快照，这个操作也被称之为snapshotting，快照
save 60 1000    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 也可以手动调用save或者bgsave命令，同步或异步执行rdb快照生成&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;save可以设置多个，就是多个snapshotting检查点，每到一个检查点，就会去check一下，是否有指定的key数量发生了变更，如果有，就生成一个新的dump.rdb文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144812117-1400583191.png&quot; alt=&quot;3-2redis的RDB持久化默认配置&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;shutdown指令redis实验&quot;&gt;SHUTDOWN指令redis实验&lt;/h5&gt;
&lt;p&gt;​ 默认配置不改的情况下，进行如下实验&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#用redis-cli连接eshop-cache01的redis服务器
redis-cli -h eshop-cache01 -p 6379
#查询所有key
keys *
#添加数据
set key1 v1
set key2 v2
set key3 v3
#查询所有key
keys *
#退出客户端
exit
#关闭eshop-cache01的redis服务器
redis-cli -h eshop-cache01 -p 6379 SHUTDOWN
#查看redis进程
ps -ef|grep redis
#找到启动脚本目录，重新启动
cd /etc/init.d/
./redis_6379 start
#用客户端连接重新查询数据
redis-cli -h eshop-cache01 -p 6379
keys *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144830131-1887498522.png&quot; alt=&quot;3-3redis的RDB持久化SHUTDOWN实验初试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 通过上述操作，我们可以知道，最后是可以查出数据的，理论上应该不能查到数据才对，因为默认的配置是1分钟有一万条数据更改、或5分钟有10条数据更改、或15分钟15分钟有一条数据更改，就生成dump.rdb文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144848999-487756385.png&quot; alt=&quot;3-4redis的RDB持久化SHUTDOWN实验结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;这是由于，当我们调用 &lt;code&gt;redis-cli -h eshop-cache01 -p 6379 SHUTDOWN&lt;/code&gt;指令停掉redis时，其实是一种安全退出的模式，redis在退出的时候会将内存中的数据立即生成一份完整的rdb快照&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;删除dump文件重启实验&quot;&gt;删除dump文件重启实验&lt;/h5&gt;
&lt;p&gt;​ 如果我们此时把dump.rdb文件移动到一个别的地方，然后删除掉/var/redis/6379下的dump.rdb文件，重新启动redis服务器，再进行查询key就会发现数据不见了，因为rdb文件被我们删除了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144913427-1696965097.png&quot; alt=&quot;3-5redis的RDB持久化SHUTDOWN之后移动dump文件结果&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;kill进程重启实验&quot;&gt;kill进程重启实验&lt;/h5&gt;
&lt;p&gt;​ 实验步骤也很简单，连接客户端添加键值对之后，退出客户端把redis服务进程给kill即可，实验结果如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144934124-587313456.png&quot; alt=&quot;3-6redis的RDB持久化kill进程实验&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 上面的实验也正好证实了，rdb持久化会丢失部分数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719144950235-2147174948.png&quot; alt=&quot;3-7redis的RDB丢失数据的问题&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;rdb恢复实验&quot;&gt;RDB恢复实验&lt;/h5&gt;
&lt;p&gt;​ 恢复实验过程也很简单，就是将一份dump.rdb的文件拷贝到redis持久化的目录下，重启redis服务器即可，实际上一个实验也体现了RDB持久化的数据恢复，这里就不再演示了。&lt;/p&gt;
&lt;p&gt;​ 在实际的生产环境中，如果只做rdb持久化的情况下，最好是设置多个snapshotting检查点，如一个小时一次，以及2天一次，保证48小时内每个小时间隔的数据都做了备份（具体看自己系统的业务量而定），然后写个脚本将dump备份同步到云上去，当发生redis故障时，可以根据具体的情况恢复想要的数据。&lt;/p&gt;
&lt;h3 id=&quot;aof&quot;&gt;AOF&lt;/h3&gt;
&lt;p&gt;​ AOF不像RDB流程那样简单直接fork一个子进程，保存内存中的数据快照，然后替换旧的dump文件。&lt;/p&gt;
&lt;p&gt;​ 如下，是RDB与AOF的流程对比图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719145009555-23476529.png&quot; alt=&quot;3-8RDB和AOF的介绍&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。&lt;/p&gt;
&lt;p&gt;​ AOF开启后，redis每次接收到一条写命令，就会写入日志文件中，当然是先写入os cache的，然后每隔一定时间再fsync一下。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;所以，相对来说，AOF的日志文件是人可以看懂的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;aof持久化的工作流程&quot;&gt;AOF持久化的工作流程&lt;/h4&gt;
&lt;p&gt;（1）AOF在接收到写命令之后，将指令写到os cache中&lt;/p&gt;
&lt;p&gt;（2）根据配置os cache的更新策略，将os cache的指令写入到日志中，默认是1秒钟刷新一次os cache&lt;/p&gt;
&lt;h4 id=&quot;aof的rewrite流程&quot;&gt;AOF的Rewrite流程&lt;/h4&gt;
&lt;p&gt;​ redis中的数据其实有限的，很多数据可能会自动过期，可能会被用户删除，可能会被redis用缓存清除的算法清理掉。redis中的数据会不断淘汰掉旧的，就一部分常用的数据会被自动保留在redis内存中，所以可能很多之前的已经被清理掉的数据，对应的写日志还停留在AOF中，AOF日志文件就一个，会不断的膨胀，到很大很大&lt;/p&gt;
&lt;p&gt;​ 所以AOF会自动在后台每隔一定时间做rewrite操作，比如日志里已经存放了针对100w数据的写日志了; redis内存只剩下10万; 基于内存中当前的10万数据构建一套最新的日志，到AOF中; 覆盖之前的老日志; 确保AOF日志文件不会过大，保持跟redis内存数据量一致&lt;/p&gt;
&lt;p&gt;​ redis 2.4之前，还需要手动，开发一些脚本，crontab，通过BGREWRITEAOF命令去执行AOF rewrite，但是redis 2.4之后，会自动进行rewrite操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719145051790-41797090.png&quot; alt=&quot;3-9AOF的rewrite原理剖析&quot;/&gt;&lt;/p&gt;
&lt;p&gt;rewrite流程：&lt;/p&gt;
&lt;p&gt;（1）redis fork一个子进程&lt;br/&gt;（2）子进程基于当前内存中的数据，构建日志，开始往一个新的临时的AOF文件中写入日志&lt;br/&gt;（3）redis主进程，接收到client新的写操作之后，在内存中写入日志，同时新的日志也继续写入旧的AOF文件&lt;br/&gt;（4）子进程写完新的日志文件之后，redis主进程将内存中的新日志再次追加到新的AOF文件中&lt;br/&gt;（5）用新的日志文件替换掉旧的日志文件&lt;/p&gt;
&lt;h4 id=&quot;aof的配置及实验&quot;&gt;AOF的配置及实验&lt;/h4&gt;
&lt;p&gt;​ &lt;strong&gt;AOF持久化，默认是关闭的，默认是打开RDB持久化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ appendonly yes，可以打开AOF持久化机制，在生产环境里面，&lt;strong&gt;一般来说AOF都是要打开的，除非你的系统业务随便丢个几分钟的数据也无所谓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719145116301-1895548503.png&quot; alt=&quot;3-10redis的AOF持久化默认配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 如果AOF和RDB都开启了，redis重启的时候，也是&lt;strong&gt;优先通过AOF进行数据恢复的&lt;/strong&gt;，因为AOF数据比较完整&lt;/p&gt;
&lt;p&gt;​ AOF可以配置fsync策略，有三种策略可以选择：&lt;/p&gt;
&lt;p&gt;always: 每次写入一条数据，立即将这个数据对应的写日志fsync到磁盘上去，性能非常非常差，吞吐量很低; 确保说redis里的数据一条都不丢，那就只能这样了&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;mysql -&amp;gt; 内存策略，大量磁盘，QPS到多少，一两k。QPS，每秒钟的请求数量&lt;/p&gt;
&lt;p&gt;redis -&amp;gt; 内存，磁盘持久化，QPS到多少，单机，一般来说，上万QPS没问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;everysec: 每秒将os cache中的数据fsync到磁盘，这个最常用的，生产环境一般都这么配置，性能很高，QPS还是可以上万的&lt;/p&gt;
&lt;p&gt;no: redis仅仅负责将数据写入os cache就撒手不管了，然后后面os自己会时不时有自己的策略将数据刷入磁盘，不可控了&lt;/p&gt;
&lt;h5 id=&quot;修改aof配置之后shutdown重启实验&quot;&gt;修改AOF配置之后SHUTDOWN重启实验&lt;/h5&gt;
&lt;p&gt;​ 实验步骤是先修改/etc/redis/6379.conf配置文件，开启AOF持久化，然后重启应用查看结果&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#开启AOF持久化
appendonly yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719145136628-182000599.png&quot; alt=&quot;3-11redis的AOF持久化配置之后测试结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 上图就是redis开启AOF持久化配置之后的测试结果，从上面的结果中，我们可以知道另外一个事情，就是如果同时开启RDB与AOF持久化时，优先从AOF中恢复，那么，如果开始你的redis是RDB备份的，现在需要添加开启AOF持久化，通过上面这种方式就显然是有问题的，原本系统的redis缓存数据全部丢失了，虽然还有dump.rdb文件，当发生数据变更，触发RDB持久化的周期备份，那么rdb的数据也没了！！也间接说明冷备很重要！冷备很重要！冷备很重要！&lt;/p&gt;
&lt;p&gt;​ 回到上述问题，那如果出现这种场景，开始你的redis是RDB备份的，现在需要添加开启AOF持久化，那应该如何操作，才不会导致原有的数据丢失呢？&lt;/p&gt;
&lt;p&gt;​ 恢复到之前的场景，将6379.conf中的appendonly的配置项改为no&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;appendonly no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719145159005-1181867730.png&quot; alt=&quot;3-12redis在已有rdb持久化的情况开启aof的数据场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 在已开启rdb的情况，正确开启aof持久化的做法如下，&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#启动redis服务
/etc/init.d/redis_6379 start
Starting Redis server...
[root@localhost 6379]# pwd
/var/redis/6379
[root@localhost 6379]# ll
total 4
-rw-r--r--. 1 root root 114 Jul 19 01:42 dump.rdb
#客户端连接redis服务
[root@localhost 6379]# redis-cli -h eshop-cache01 -p 6379
eshop-cache01:6379&amp;gt; keys *
1) &quot;mykey1&quot;
2) &quot;mykey3&quot;
3) &quot;mykey2&quot;
#热修改配置参数，将appendonly设置为yes，但此时6379.conf配置文件并没有修改appendonly项
eshop-cache01:6379&amp;gt; config set appendonly yes
OK
eshop-cache01:6379&amp;gt; config get appendonly
1) &quot;appendonly&quot;
2) &quot;yes&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 在查看到aof持久化文件有数据后，可以将服务停掉，然后修改6379.conf配置文件，将appendonly改为yes，然后重启服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/937492/201807/937492-20180719145221054-1840659762.png&quot; alt=&quot;3-13redis在已有rdb持久化的情况开启aof的正确操作&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;h4 id=&quot;rdb持久化机制的优点&quot;&gt;RDB持久化机制的优点&lt;/h4&gt;
&lt;p&gt;（1）RDB会生成多个数据文件，每个数据文件都代表了某一个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说Amazon的S3云服务上去，在国内可以是阿里云的ODPS分布式存储上，以预定好的备份策略来定期备份redis中的数据&lt;/p&gt;
&lt;p&gt;RDB也可以做冷备，生成多个文件，每个文件都代表了某一个时刻的完整的数据快照&lt;br/&gt;AOF也可以做冷备，只有一个文件，但是你可以，每隔一定时间，去copy一份这个文件出来&lt;/p&gt;
&lt;p&gt;RDB做冷备，优势在哪儿呢？由redis去控制固定时长生成快照文件的事情，比较方便; AOF，还需要自己写一些脚本去做这个事情，各种定时&lt;br/&gt;RDB数据做冷备，在最坏的情况下，提供数据恢复的时候，速度比AOF快&lt;/p&gt;
&lt;p&gt;（2）RDB对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可&lt;/p&gt;
&lt;p&gt;RDB，每次写，都是直接写redis内存，只是在一定的时候，才会将数据写入磁盘中&lt;br/&gt;AOF，每次都是要写文件的，虽然可以快速写入os cache中，但是还是有一定的时间开销的,速度肯定比RDB略慢一些&lt;/p&gt;
&lt;p&gt;（3）相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复redis进程，更加快速&lt;/p&gt;
&lt;p&gt;AOF，存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据的&lt;br/&gt;RDB，就是一份数据文件，恢复的时候，直接加载到内存中即可&lt;/p&gt;
&lt;p&gt;结合上述优点，RDB特别适合做冷备份，冷备&lt;/p&gt;
&lt;h4 id=&quot;rdb持久化机制的缺点&quot;&gt;RDB持久化机制的缺点&lt;/h4&gt;
&lt;p&gt;（1）如果想要在redis故障时，尽可能少的丢失数据，那么RDB没有AOF好。一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis进程宕机，那么会丢失最近5分钟的数据&lt;/p&gt;
&lt;p&gt;这个问题，也是rdb最大的缺点，就是不适合做第一优先的恢复方案，如果你依赖RDB做第一优先恢复方案，会导致数据丢失的比较多&lt;/p&gt;
&lt;p&gt;（2）RDB每次在fork子进程来执行RDB快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒&lt;/p&gt;
&lt;p&gt;一般不要让RDB的间隔太长，否则每次生成的RDB文件太大了，对redis本身的性能可能会有影响的&lt;/p&gt;
&lt;h4 id=&quot;aof持久化机制的优点&quot;&gt;AOF持久化机制的优点&lt;/h4&gt;
&lt;p&gt;（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据&lt;/p&gt;
&lt;p&gt;每隔1秒，就执行一次fsync操作，保证os cache中的数据写入磁盘中&lt;/p&gt;
&lt;p&gt;redis进程挂了，最多丢掉1秒钟的数据&lt;/p&gt;
&lt;p&gt;（2）AOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复&lt;/p&gt;
&lt;p&gt;（3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在rewrite log的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的merge后的日志文件ready的时候，再交换新老日志文件即可。&lt;/p&gt;
&lt;p&gt;（4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据&lt;/p&gt;
&lt;h4 id=&quot;aof持久化机制的缺点&quot;&gt;AOF持久化机制的缺点&lt;/h4&gt;
&lt;p&gt;（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大&lt;/p&gt;
&lt;p&gt;（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的&lt;/p&gt;
&lt;p&gt;如果你要保证一条数据都不丢，也是可以的，AOF的fsync设置成没写入一条数据，fsync一次，那就完蛋了，redis的QPS大降&lt;/p&gt;
&lt;p&gt;（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过AOF就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。&lt;/p&gt;
&lt;p&gt;（4）唯一的比较大的缺点，其实就是做数据恢复的时候，会比较慢，还有做冷备，定期的备份，不太方便，可能要自己手写复杂的脚本去做，做冷备不太合适&lt;/p&gt;
&lt;h4 id=&quot;rdb和aof到底该如何选择&quot;&gt;RDB和AOF到底该如何选择&lt;/h4&gt;
&lt;p&gt;（1）不要仅仅使用RDB，因为那样会导致你丢失很多数据&lt;/p&gt;
&lt;p&gt;（2）也不要仅仅使用AOF，因为那样有两个问题，第一，你通过AOF做冷备，没有RDB做冷备，来的恢复速度更快; 第二，RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug&lt;/p&gt;
&lt;p&gt;（3）综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择; 用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复&lt;/p&gt;
&lt;h4 id=&quot;aof和rdb同时工作&quot;&gt;AOF和RDB同时工作&lt;/h4&gt;
&lt;p&gt;（1）如果RDB在执行snapshotting操作，那么redis不会执行AOF rewrite; 如果redis再执行AOF rewrite，那么就不会执行RDB snapshotting&lt;br/&gt;（2）如果RDB在执行snapshotting，此时用户执行BGREWRITEAOF命令，那么等RDB快照生成之后，才会去执行AOF rewrite&lt;br/&gt;（3）同时有RDB snapshot文件和AOF日志文件，那么redis重启的时候，会优先使用AOF进行数据恢复，因为其中的日志更完整&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 07:17:00 +0000</pubDate>
<dc:creator>金发只是水一下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wicfhwffg/p/9335595.html</dc:identifier>
</item>
<item>
<title>跨域 webpack + vue-cil 中 proxyTable 处理跨域 - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/9335952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/9335952.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; app.all('*', (req, res, next)=&amp;gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,Content-Length, Authorization, Accept,X-Requested-With&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     res.header(&quot;X-Powered-By&quot;,' 3.2.1'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(req.method==&quot;OPTIONS&quot;) res.send(200);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;让options请求快速返回&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt; next();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; });
&lt;/pre&gt;</description>
<pubDate>Thu, 19 Jul 2018 07:11:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/9335952.html</dc:identifier>
</item>
<item>
<title>Spark入门——什么是Hadoop，为什么是Spark? - wing1995</title>
<link>http://www.cnblogs.com/wing1995/p/9300120.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wing1995/p/9300120.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;span&gt;#Spark入门#这个系列课程，是综合于我从2017年3月分到今年7月份为止学习并使用Spark的使用心得感悟，暂定于每周更新，以后可能会上传讲课视频和PPT，目前先在博客园把稿子打好。注意：这只是一个草稿，里面关于知识的误解还请各大网友监督，我们互相进步。总而言之，网络上的知识学会断舍离，学会带着辩证的眼光去学习就能进步。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　谈到Spark，实际上从16年本科实习的时候就已经开始接触，那个时候是从Pig入门大数据Hadoop的，有兴趣的朋友可以看&lt;a href=&quot;https://www.cnblogs.com/wing1995/p/5161511.html&quot; target=&quot;_blank&quot;&gt;Hadoop家族之Pig入门&lt;/a&gt;；当时大家基本都在使用Pig，Pig我也没有接触太深，大概两个月后开始跟着当时的师父（当时是实习的硕士，后来就业去了阿里）学了Spark，整个公司就他在写Spark，他是一个我很佩服的人，属于全栈工程师类型的人，前后端数据分析以及数据挖掘的算法都会，所以就跟着使用Python写着Spark的一些入门程序，可见我另外一个博客Spark2.0系列&lt;a href=&quot;https://www.cnblogs.com/wing1995/p/6803630.html&quot; target=&quot;_blank&quot;&gt;RDDVs.DataSetVs.DataFrame&lt;/a&gt;，实际上这里关于Dataset的介绍是非常不全面的，接下来我也会在这个Spark入门系列讲的更为详细一点。目前看来，大数据相关的职位那么吃香，很多学计算机的，学数学的，学统计的，半路上培训的，各种各样的人都来投Spark工程师的岗位，因为薪资高的原因吧，但是真正喜欢这个职业的又有几个，希望大家能一直坚持下去，见证大数据技术的更新迭代！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;第一个问题，什么是Hadoop&lt;sup&gt;TM&lt;/sup&gt;？&lt;/strong&gt;&lt;/span&gt;实际上这个答案&lt;a href=&quot;http://hadoop.apache.org/&quot; target=&quot;_blank&quot;&gt;Hadoop官网&lt;/a&gt;已经给的很明确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Hadoop是&lt;a href=&quot;https://www.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache软件基金会&lt;/a&gt;支持可靠的、可扩展的一个开源的分布式计算框架的工程。（PS：Apache软件基金会真是扛下了开源世界的半壁江山，旗下支持的开源的大数据项目大家有兴趣可以去官网访问一下。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体而言，Apache Hadoop软件库是一个允许使用简单编程模型跨计算机集群处理大型数据集合的框架，其设计的初衷是将单个服务器扩展成上千个机器组成的一个集群为大数据提供计算服务，其中每个机器都提供本地计算和存储服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Hadoop工程包括以下模块：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;Hadoop Common：&lt;/strong&gt;支持其他Hadoop模块的通用工具。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Hadoop Distributed File System(HDFS&lt;sup&gt;TM&lt;/sup&gt;)：&lt;/strong&gt;提供高吞吐量的访问应用数据的一个分布式文件系统。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Hadoop YARN：&lt;/strong&gt;一种作业调度和集群资源管理的框架。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;Hadoop MapReduce：&lt;/strong&gt;一种基于Yarn来处理大数据集合的系统。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　Apache中其他Hadoop相关的项目包括：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://ambari.apache.org/&quot; target=&quot;_blank&quot;&gt;Ambari&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种用于提供、管理和监督Apache Hadoop集群的基于Web UI的且易于使用的Hadoop管理工具。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://avro.apache.org/&quot; target=&quot;_blank&quot;&gt;Avro&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种数据序列化系统。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://cassandra.apache.org/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Cassandra&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种无单点故障的可扩展的分布式数据库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://chukwa.apache.org/&quot; target=&quot;_blank&quot;&gt;Chukwa&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种用于管理大型分布式系统的数据收集系统。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://hbase.apache.org/&quot; target=&quot;_blank&quot;&gt;HBase&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种支持存储大型表的结构化存储的可扩展的分布式数据库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://hive.apache.org/&quot; target=&quot;_blank&quot;&gt;Hive&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种提供数据汇总和特定查询的数据仓库。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://mahout.apache.org/&quot; target=&quot;_blank&quot;&gt;Mahout&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种可扩展的机器学习和数据挖掘库（Scala语言实现，可结合Spark后端）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://pig.apache.org/&quot; target=&quot;_blank&quot;&gt;Pig&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种高级的数据流语言且支持并行计算的执行框架（2017年发布的最新版本0.17.0是添加了Spark上的Pig应用）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://spark.apache.org/&quot; target=&quot;_blank&quot;&gt;Spark&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种用于Hadoop数据的快速通用计算引擎。Spark提供一种支持广泛应用的简单而易懂的编程模型，包括ETL（ Extract-Transform-Load）、机器学习、流处理以及图计算。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://tez.apache.org/&quot; target=&quot;_blank&quot;&gt;Tez&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种建立在Hadoop YARN上数据流编程框架，它提供了一个强大而灵活的引擎来任意构建DAG（Directed-acyclic-graph）任务去处理用于批处理和交互用例的数据。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://zookeeper.apache.org/&quot; target=&quot;_blank&quot;&gt;ZooKeeper&lt;/a&gt;&lt;/strong&gt;&lt;sup&gt;TM&lt;/sup&gt;：一种给分布式应用提供高性能的协同服务系统。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;第二个问题，既然Hadoop生态家族这么庞大，我们为什么要选择Spark作为对于大数据进行数据分析和数据挖掘的基本计算框架？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;这个问题的答案实际上&lt;a href=&quot;http://spark.apache.org/&quot; target=&quot;_blank&quot;&gt;Spark官网&lt;/a&gt;已经给的很明确了，我就照样搬砖过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Apache Spark拥有先进的DAG调度器、查询优化器以及物理执行引擎从而高性能的实现批处理和流数据处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://paste.ubuntu.org.cn/i4349992&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;212&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;易用性&lt;/strong&gt;（可以使用Java，Scala，Python，R以及SQL快速的写Spark应用）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Spark提供80个以上高级算子便于执行并行应用，并且可以使用Scala、Python、R以及SQL的shell端交互式运行Spark应用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过Spark的Python的DataFrame的API读取JSON文件&lt;/span&gt;
df = spark.read.json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logs.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
df.where(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age &amp;gt; 21&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).show()
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;通用性&lt;/strong&gt;(支持SQL，流数据处理以及复杂分析)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Spark拥有一系列库，包括SQL和DataFrame，用于机器学习的MLib,支持图计算GraphX以及流计算模块Streaming。你可以在一个应用中同时组合这些库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/752212/201807/752212-20180718145714789-1098265391.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;支持多种模式运行&lt;/strong&gt;（平台包括Hadoop,Apache Mesos,Kubernete,standalone或者云上，也可以获取各种数据源上的数据）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Spark可以直接运行以自身的&lt;a href=&quot;http://spark.apache.org/docs/latest/spark-standalone.html&quot; target=&quot;_blank&quot;&gt;standalone&lt;/a&gt;集群模式运行，也可以在&lt;a href=&quot;https://github.com/amplab/spark-ec2&quot; target=&quot;_blank&quot;&gt;亚马逊EC2&lt;/a&gt;上运行，不过企业级用的比较多的是&lt;a href=&quot;https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html&quot; target=&quot;_blank&quot;&gt;Hadoop Yarn&lt;/a&gt;模式，当然也有&lt;a href=&quot;https://mesos.apache.org/&quot; target=&quot;_blank&quot;&gt;Mesos&lt;/a&gt;和&lt;a href=&quot;https://kubernetes.io/&quot; target=&quot;_blank&quot;&gt;Kubernetes&lt;/a&gt;模式。可以获取不限于来自于&lt;a href=&quot;https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html&quot; target=&quot;_blank&quot;&gt;HDFS&lt;/a&gt;、&lt;a href=&quot;https://cassandra.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Cassandra&lt;/a&gt;、&lt;a href=&quot;https://hbase.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache HBase&lt;/a&gt;和&lt;a href=&quot;https://hive.apache.org/&quot; target=&quot;_blank&quot;&gt;Apache Hive&lt;/a&gt;等上百种数据源。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;那么，&lt;span&gt;第三个问题，Hadoop和Spark之间的关系是什么？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先要从Hadoop的MapReduce编程框架说起，如果说MapReduce是第一代计算引擎，那么Spark就是第二代计算引擎。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　MapReduce将复杂的并行计算过程高度的抽象到了两个函数：Map函数和Reduce函数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/752212/201807/752212-20180718165614837-1240576834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　MapReduce的核心是“分而治之”策略。数据在其MapReduce的生命周期中过程中需要经过六大保护神的洗礼，分别是：Input、Split、Map、Shuffule、Reduce和Output。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/752212/201807/752212-20180718165941240-100218578.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　MapReduce框架采用Master/Slave架构，一个Master对应多个Slave，Master运行JobTracker，Slave运行TaskTracker；JobTracker充当一个管理者，负责Client端提交的任务能够由手下的TaskTracker执行完成，而TaskTracker充当普通员工执行的Task分为Map Task（Split and Map）和Reduce Task(Shuffle and Reduce)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/752212/201807/752212-20180718171138797-72325112.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　现在，我们普通的开发人员只要会用MapReduce的API就可以实现高大上的并行计算了，但是对于非科班毕业的数据分析（例如我这样半路出家的统计学毕业）人员而言，MapReduce存在的局限性不仅仅是在于其代码的又长又臭，固定的框架等，总而言之其短板可见以下列表：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;抽象层次低，具体的Map和Reduce实现起来代码量大并且对于数据挖掘算法中复杂的分析需要大量的Job来支持，且Job之间的依赖需要开发者定义，导致开发的难度高而代码的可读性不强；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中间结果也存放在HDFS文件系统中，导致中间结果不能复用（需要重新从磁盘中读取），不适宜数据挖掘算法中的大量迭代操作，ReduceTask需要等待所有的MapTask执行完毕才可以开始；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;只适合批处理场景，不支持交互式查询和数据的实时处理。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;span&gt;要知道，我们通常意义上的Hadoop往往是Hadoop生态圈，意味着很多技术对Hadoop本身具有的局限进行了扩展和改进，从而有了Pig、Hive将SQL语言翻译成MapReduce程序，让我们从繁琐的MapReduce程序中释放出来。如果说Pig这类的类SQL语言解决了MapReduce中存在的大量手写代码，那么Tez就解决是去除了Map和Reduce两个任务之间的屏障从而提升了整体的性能，从而将多个MapReduce任务在一个Tez任务中处理完。&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/752212/201807/752212-20180718175606952-913554170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;随着大数据处理的应用场景越来越多，人们对Hadoop的要求也越来越高，开发出的对应的系统也越来越多，人们迫切的需要一个综合的计算框架，Spark应运而生，我们可以看看Spark可以干些什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/752212/201807/752212-20180718180017944-508657541.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么为什么Spark能做到这些？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们需要理解Spark中的三大概念：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;RDD（Resilient Distributed Dataset）&lt;/strong&gt;。实际上对与开发人员而已它是以一种对象的形式作为数据的一种表现形式而存在，可以理解为一种你可以操作的只读的分布式数据集，之所以称之为有弹性，在于：&lt;/span&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;RDD可以在内存和磁盘存储间手动或自动切换；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RDD拥有Lineage（血统）信息，及存储着它的父RDD以及父子之间的关系，当数据丢失时，可通过Lineage关系重新计算并恢复结果集，使其具备高容错性；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当血统链太长时，用户可以建立checkpoint将数据存放到磁盘上持久化存储加快容错速度（建议通过saveAsTextFile等方式存储到文件系统），而persist方式可以将数据存储到内存中用于后续计算的复用；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;RDD的数据重新分片可以手动设置。在Spark中执行重新分片操作的方法有repartition和coalesce两个方法，这两个方法都是手动设置RDD的分区数量，repartition只是coalesce接口中参数shuffle=true的实现；是否重新分区对性能影响比较大，如果分区数量大，可以减少每个分区的占存，减少OOM（内存溢出）的风险，但如果分区数量过多同时产生了过多的碎片，消耗过多的线程去处理数据，从而浪费计算资源。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;Transformations。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;转换发生在当你将现有的RDD转换成其他的RDD的时候。比如当你打开一个文件然后读取文件内容并通过map方法将字符串类型RDD转换成另外一个数组类型RDD就是一种转换操作，常用的转换操作有map,filer,flatMap,union,distinct,groupByKey等。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;Actions。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;动作发生在你需要系统返回一个结果的时候。比如你需要知道RDD的第一行数据是什么样的内容，比如你想知道RDD一共有多少行这样类似的操作就是一种动作，常用的动作操作有reduce,collect,count,first,take(),saveAsTextFile(),foreach()等。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　有意思的是Spark使用“lazy evaluation”，意味着执行Transformations操作的时候实际上系统并没有发生任何操作，只有在遇到Actions操作的时候Spark才开始真正从头运行程序执行一系列转换并返回结果。因为有了这种惰性求值方式加上RDD的血缘依赖关系导致程序在一系列连续的运算中形成了DAG，而这种DAG（Directed Acyclic Graph）可以优化整个执行计划（参照上图中的Tez）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;最后再强调一下，&lt;span&gt;为什么要选择Spark？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先，Spark通过RDD的lineage血统依赖关系提供了一个完备的数据恢复机制；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其次，Spark通过使用DAG优化整个计算过程；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;最后，Spark对RDD进行Transformation和Action的一系列算子操作使得并行计算在粗粒度上就可以简单执行，而且Spark生态系统提供了一系列的开发包使得数据科学家可以执行一系列的SQL、ML、Streaming以及Graph操作，而且还支持很多其他的第三方包括一些交互式框架类似于&lt;a href=&quot;https://hortonworks.com/apache/zeppelin/&quot; target=&quot;_blank&quot;&gt;Apache Zeppelin&lt;/a&gt;，地理数据可视化框架&lt;a href=&quot;http://geospark.co.uk/&quot; target=&quot;_blank&quot;&gt;GeoSpark&lt;/a&gt;以及一些比较流行的深度学习框架&lt;a href=&quot;https://www.h2o.ai/sparkling-water/&quot; target=&quot;_blank&quot;&gt;Sparking-water&lt;/a&gt;,&lt;a href=&quot;https://deeplearning4j.org/&quot; target=&quot;_blank&quot;&gt;Deeplearning4j&lt;/a&gt;,&lt;a href=&quot;https://sparknet.net/&quot; target=&quot;_blank&quot;&gt;SparkNet&lt;/a&gt;等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　我们都知道Spark最初是由UC伯克利大学的AMP实验室研究出来的，强烈推荐这个实验室的&lt;a href=&quot;https://amplab.cs.berkeley.edu/projects&quot; target=&quot;_blank&quot;&gt;Projects&lt;/a&gt;！Happy Coding!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 07:08:00 +0000</pubDate>
<dc:creator>wing1995</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wing1995/p/9300120.html</dc:identifier>
</item>
<item>
<title>SSH框架整合中Hibernate实现Dao层常用结构 - 四季写爱</title>
<link>http://www.cnblogs.com/ya-qiang/p/9335844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ya-qiang/p/9335844.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、疑惑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一直以来，我在使用SSH框架的时候经常会发现后者有疑虑到底使用hibernate的那种方法或者如何配置hibernate来操作数据库，经过&lt;/p&gt;
&lt;p&gt;一段时间的学习下面我来总结一下，常用的dao层配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、常用的hibernate操作dao &lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;第一种，通过继承HibernateDaoSupport来操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第二种，通过HibernateTemplate来操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第三种，通过使用Hibernate的session来操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第四种，直接写JDBC来实现数据库操作&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、四种常用方法介绍及配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;通过继承HibernateDaoSupport来操作&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　　　spring为Hibernate的Dao提供的工具类，其底层是通过HibernateTemplate来实现来数据库的操作，但我觉得使用它的时候需要向每个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Dao层注入sessionFactory感觉有点不方便，因为这样注解就不方便了，但使用的时候就不需要在Dao层里面写SessionFactory的set方法了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接在配置文件中进行配置就可以了。可以看源码发现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256944/201807/1256944-20180719143629713-1901210186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用的配置：applicationContext.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;

    &amp;lt;!-- 配置连接池： --&amp;gt;
    &amp;lt;!-- 引入外部属性文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&quot;classpath:c3p0-db.properties&quot;/&amp;gt;
    &amp;lt;!-- 配置c3p0数据源 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driverClass}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;${jdbc.user}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 配置hibernate的相关信息 --&amp;gt;
    &amp;lt;!-- 配置SessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!--配置数据源 注入连接池--&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;!-- 配置hibernate的其他属性 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.connection.autocommit&quot;&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 配置hibernate的映射文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;com/itwang/entity/User.hbm.xml&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;com/itwang/entity/Category.hbm.xml&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 事务管理 --&amp;gt;
    &amp;lt;!-- 配置一个事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 开启注解事务  --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    &amp;lt;!-- Dao的配置 =============================--&amp;gt;
&lt;strong&gt;&lt;span&gt;    &amp;lt;!-- 用户的Dao --&amp;gt;
    &amp;lt;bean id=&quot;userDao&quot; class=&quot;com.itwang.dao.UserDao&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 一级分类的Dao --&amp;gt;
    &amp;lt;bean id=&quot;categoryDao&quot; class=&quot;com.itwang.dao.CategoryDao&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 二级分类的Dao --&amp;gt;
    &amp;lt;bean id=&quot;categorySecondDao&quot; class=&quot;com.itwang.dao.CategorySecondDao&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!--商品的Dao  --&amp;gt;
    &amp;lt;bean id=&quot;productDao&quot; class=&quot;com.itwang.dao.ProductDao&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256944/201807/1256944-20180719144032906-1203011264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　使用直接继承，方法里面通过this.getHibernateTemplate()直接使用HibernateTemplate操作数据库&lt;/p&gt;
&lt;p&gt;　　　可以看到这种方法有点繁琐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2. 通过HibernateTemplate来操作（推荐）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1256944/201807/1256944-20180719144327650-331642676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当然在配置文件中也可以只需要配置hibernateTemplate对象就可以了，因为可以在dao层直接使用注解方式（@Autowired,@Repository）来注入属性和创建Bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到hibernateTemplate对象&lt;/span&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HibernateTemplate hibernateTemplate;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add() {
        User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setAddress(&lt;/span&gt;&quot;japan&quot;&lt;span&gt;);
        user.setUsername(&lt;/span&gt;&quot;rose&quot;&lt;span&gt;);;
        hibernateTemplate.save(user);
    }&lt;br/&gt;}　　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种方式是不是很方便，只需要在配置文件中配置一个HibernateTemplate对象就可以了。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　3. 通过使用Hibernate的session来操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　这一种是Hibernate的最基础的方式，也是最灵活的一种方式，以为Session实现了hibernate的所有数据库操作方法，所谓越原始越灵活。&lt;/p&gt;
&lt;p&gt;　　这种方式只需要在Dao层注入SessionFactory对象即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 配置SessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!--配置数据源 注入连接池--&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;!-- 配置hibernate的其他属性 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.connection.autocommit&quot;&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!-- 配置hibernate的映射文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;com/itwang/entity/User.hbm.xml&amp;lt;/value&amp;gt;
                &amp;lt;value&amp;gt;com/itwang/entity/Category.hbm.xml&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Repository
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SessionFactory sessionFactory;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveUser() {
        Session session &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        Transaction tx &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            session &lt;/span&gt;=&lt;span&gt; sessionFactory.getCurrentSession();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启事务&lt;/span&gt;
            tx =&lt;span&gt; session.beginTransaction();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;
            User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
            user.setAddress(&lt;/span&gt;&quot;American&quot;&lt;span&gt;);
            user.setUsername(&lt;/span&gt;&quot;老王&quot;&lt;span&gt;);
            session.save(user);
            tx.commit();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回滚事务&lt;/span&gt;
&lt;span&gt;            tx.rollback();
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            session.close();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　4. 直接写JDBC来实现数据库操作，这种方式我就不多说了，以为这种方式太原始了，不推荐&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 06:57:00 +0000</pubDate>
<dc:creator>四季写爱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ya-qiang/p/9335844.html</dc:identifier>
</item>
<item>
<title>基于winserver的Apollo配置中心分布式&amp;集群部署实践（正确部署姿势） - 陈珙</title>
<link>http://www.cnblogs.com/skychen1218/p/9335797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skychen1218/p/9335797.html</guid>
<description>&lt;p&gt;&lt;span&gt;前几天对Apollo配置中心的demo进行一个部署试用，现公司已决定使用，这两天进行分布式部署的时候，每一步都踩着坑过来的。因此写文档与需要的朋友分享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此篇文章不代表官方部署流程，只是自己的部署的实践方式，屏蔽了一些官方的多余的部署讲解。如果有问题还请到Apollo的wiki文档进行查看：https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，真想吐槽下Apollo配置中心部署恶心度真的是……，吐槽归吐槽，但是Apollo配置中心的功能强大而且具有非常高的可用性，在同类型产品里也算是数一数二。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在进行分布式部署前我还是建议用Apollo的quick start版本进行试用。可以参考我这篇文章&lt;a href=&quot;https://www.cnblogs.com/skychen1218/p/9300745.html&quot; target=&quot;_blank&quot;&gt;《基于winserver部署Apollo初次体验（附.net客户端demo）》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;ol&gt;&lt;li&gt;&lt;span&gt;apollo-configservice&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作为客户端的获取配置的接口服务，与客户端进行Http long polling&lt;span&gt;，&lt;span&gt;实现配置更新的退送与拉取&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;apollo-adminservice&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;作为管理后台的接口服务，提供配置管理、修改、发布&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;apollo-portal&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;Web&lt;span&gt;管理配置后台&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;以下正式开始部署&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;源码\scripts\sql下两脚本，到mysql执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;apolloconfigdb.sql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;apolloportaldb.sql&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;切换到上面已下载阿波罗源码\scripts目录下，运行build.bat。需要等待几分钟，编译完成后，准备三个服务部署，部署顺序也如下&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;apollo-configservice&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;apollo-adminservice&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;apollo-porta&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;源码\apollo-configservice\target\apollo-configservice-0.11.0-SNAPSHOT-github.zip&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解压到需要部署的服务器文件夹&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;添加文件application-github.properties，内容如下：&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;spring.datasource.url=jdbc:mysql://10.1.20.143:3306/ApolloConfigDB?characterEncoding=utf8

spring.datasource.username=root

spring.datasource.password=12345678
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;编辑\scripts\startup.sh，修改日志目录&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LOG_DIR=D:/apollo/apollo-configservice-&lt;span&gt;0.11&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-SNAPSHOT-github/log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双击startup.sh启动服务。&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;启动完后查看日志，如果出现下面信息，请耐心等待几分钟，输入localhost:8080尝试&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;com.sun.jersey.api.client.ClientHandlerException: java.net.ConnectException: Connection refused&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;源码\apollo-adminservice\target\apollo-adminservice-0.11.0-SNAPSHOT-github.zip&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;同上步骤2、3、4、5（注意数据库信息、日志目录对应修改）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;localhost:8090尝试&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;源码\apollo-portal\target\apollo-portal-0.11.0-SNAPSHOT-github.zip&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解压到需要部署的服务器文件夹&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;&lt;span&gt;添加文件application-github.properties，内容如下（注意数据库连接与前两者不一样）&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring.datasource.url=jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.1.20.143:3306/ApolloPortalDB?characterEncoding=utf8&lt;/span&gt;
&lt;span&gt;
spring.datasource.username&lt;/span&gt;=&lt;span&gt;root

spring.datasource.password&lt;/span&gt;=&lt;span&gt;12345678&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;&lt;span&gt;编辑\scripts\startup.sh，修改日志目录与端口号&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LOG_DIR=D:/apollo/apollo-portal-&lt;span&gt;0.11&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-SNAPSHOT-github/&lt;span&gt;log

SERVER_PORT&lt;/span&gt;=&lt;span&gt;8070&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双击startup.sh启动服务&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;输入localhost:8070尝试，如日志没其他异常，等待几分钟再次尝试访问&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在C:\opt\settings 添加文件server.properties内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;env=DEV&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上为单机部署的流程，下面讲解集群部署的流程：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/488722/201807/488722-20180719143618263-243007962.png&quot; alt=&quot;&quot; width=&quot;964&quot; height=&quot;562&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Eureka与apollo-configservice为同一个JVM进程，为了好描述拆开了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在apollo-configservice与apollo-adminservice启动时会向Eureka进行服务注册，Apollo客户端和apollo-Portal会从Eureka进行服务查找，然后通过服务地址直接访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个服务都是无状态的，因此横向扩展相对比较简单&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;update apolloconfigdb.serverconfig set value = 'http://10.1.20.137:8080/eureka/' where id = 1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;到B服务器重复上述两个服务的部署步骤（注意基本环境的安装）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;输入http://10.1.20.137:8080进行查看，eureka管理界面status出现多台主机名称为部署成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/488722/201807/488722-20180719143728012-1262825767.png&quot; alt=&quot;&quot; width=&quot;1065&quot; height=&quot;407&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上为我与大家分享的部署流程，如有问题可以及时在下方评论与我，我会尽快回复&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 06:50:00 +0000</pubDate>
<dc:creator>陈珙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skychen1218/p/9335797.html</dc:identifier>
</item>
<item>
<title>监控报I/O问题，怎么办？ - 阿龙along</title>
<link>http://www.cnblogs.com/along21/p/9335453.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/9335453.html</guid>
<description>&lt;p&gt;　　Linux系统出现了性能问题，一般我们可以通过top、iostat、free、vmstat等命令来查看初步定位问题。其中iostat可以给我们提供丰富的IO状态数据。&lt;/p&gt;
&lt;h2&gt;一、查询命令基本使用&lt;/h2&gt;
&lt;h3&gt;1、命令介绍&lt;/h3&gt;
&lt;p&gt;$iostat -d -k 1 10&lt;/p&gt;
&lt;p&gt;　　-d 表示，显示设备（磁盘）使用状态；&lt;/p&gt;
&lt;p&gt;　　-k某些使用block为单位的列强制使用Kilobytes为单位；&lt;/p&gt;
&lt;p&gt;　　1 10表示，数据显示每隔1秒刷新一次，共显示10次。&lt;/p&gt;

&lt;h3&gt;2、用法展示&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# iostat -x &lt;span&gt;1&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
Linux &lt;/span&gt;&lt;span&gt;2.6&lt;/span&gt;.&lt;span&gt;18&lt;/span&gt;-&lt;span&gt;92&lt;/span&gt;.el5xen    &lt;span&gt;02&lt;/span&gt;/&lt;span&gt;03&lt;/span&gt;/&lt;span&gt;2009&lt;/span&gt;&lt;span&gt;
avg&lt;/span&gt;-cpu:  %user   %nice %system %iowait  %steal   %&lt;span&gt;idle
           &lt;/span&gt;&lt;span&gt;1.10&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;4.82&lt;/span&gt;   &lt;span&gt;39.54&lt;/span&gt;    &lt;span&gt;0.07&lt;/span&gt;   &lt;span&gt;54.46&lt;/span&gt;&lt;span&gt;
Device:         rrqm&lt;/span&gt;/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   &lt;span&gt;await&lt;/span&gt;  svctm  %&lt;span&gt;util
sda               &lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;3.50&lt;/span&gt;  &lt;span&gt;0.40&lt;/span&gt;  &lt;span&gt;2.50&lt;/span&gt;     &lt;span&gt;5.60&lt;/span&gt;    &lt;span&gt;48.00&lt;/span&gt;    &lt;span&gt;18.48&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.97&lt;/span&gt;   &lt;span&gt;0.97&lt;/span&gt;   &lt;span&gt;0.28&lt;/span&gt;&lt;span&gt;
sdb               &lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;
sdc               &lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;
sdd               &lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;
sde               &lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.10&lt;/span&gt;  &lt;span&gt;0.30&lt;/span&gt;  &lt;span&gt;0.20&lt;/span&gt;     &lt;span&gt;2.40&lt;/span&gt;     &lt;span&gt;2.40&lt;/span&gt;     &lt;span&gt;9.60&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;1.60&lt;/span&gt;   &lt;span&gt;1.60&lt;/span&gt;   &lt;span&gt;0.08&lt;/span&gt;&lt;span&gt;
sdf              &lt;/span&gt;&lt;span&gt;17.40&lt;/span&gt;     &lt;span&gt;0.50&lt;/span&gt; &lt;span&gt;102.00&lt;/span&gt;  &lt;span&gt;0.20&lt;/span&gt; &lt;span&gt;12095.20&lt;/span&gt;    &lt;span&gt;5.60&lt;/span&gt;   &lt;span&gt;118.40&lt;/span&gt;     &lt;span&gt;0.70&lt;/span&gt;    &lt;span&gt;6.81&lt;/span&gt;   &lt;span&gt;2.09&lt;/span&gt;  &lt;span&gt;21.36&lt;/span&gt;&lt;span&gt;
sdg             &lt;/span&gt;&lt;span&gt;232.40&lt;/span&gt;     &lt;span&gt;1.90&lt;/span&gt; &lt;span&gt;379.70&lt;/span&gt;  &lt;span&gt;0.50&lt;/span&gt; &lt;span&gt;76451.20&lt;/span&gt;    &lt;span&gt;19.20&lt;/span&gt;   &lt;span&gt;201.13&lt;/span&gt;    &lt;span&gt;4.94&lt;/span&gt;   &lt;span&gt;13.78&lt;/span&gt;   &lt;span&gt;2.45&lt;/span&gt;  &lt;span&gt;93.16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3、参数讲解&lt;/h3&gt;
&lt;p&gt;（1）参数如下：&lt;/p&gt;
&lt;p&gt;rrqm/s：　   每秒进行 merge 的读操作数目。即 delta(rmerge)/s&lt;/p&gt;
&lt;p&gt;wrqm/s：     每秒进行 merge 的写操作数目。即 delta(wmerge)/s&lt;/p&gt;
&lt;p&gt;r/s：　　　  每秒完成的读 I/O 设备次数。即 delta(rio)/s&lt;/p&gt;
&lt;p&gt;w/s：　　    每秒完成的写 I/O 设备次数。即 delta(wio)/s&lt;/p&gt;
&lt;p&gt;rsec/s：　　每秒读扇区数。即 delta(rsect)/s&lt;/p&gt;
&lt;p&gt;wsec/s：      每秒写扇区数。即 delta(wsect)/s&lt;/p&gt;
&lt;p&gt;rkB/s：         每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)&lt;/p&gt;
&lt;p&gt;wkB/s：        每秒写K字节数。是 wsect/s 的一半。(需要计算)&lt;/p&gt;
&lt;p&gt;avgrq-sz：   平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)&lt;/p&gt;
&lt;p&gt;avgqu-sz：  平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。&lt;/p&gt;
&lt;p&gt;await：        平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)&lt;/p&gt;
&lt;p&gt;svctm：       平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)&lt;/p&gt;
&lt;p&gt;%util：         一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)&lt;/p&gt;

&lt;p&gt;（2）参数分析：&lt;/p&gt;
&lt;p&gt;如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。&lt;/p&gt;
&lt;p&gt;await小于70% IO压力就较大了,一般读取速度有较多的wait.&lt;/p&gt;
&lt;p&gt;同时可以结合vmstat 查看查看bi参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)&lt;/p&gt;

&lt;p&gt;（3）另外还可以参考，一般情况:&lt;/p&gt;
&lt;p&gt;① svctm &amp;lt; await (因为同时等待的请求的等待时间被重复计算了)，&lt;/p&gt;
&lt;p&gt;② svctm的大小一般和磁盘性能有关:CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm的增加。&lt;/p&gt;
&lt;p&gt;③ await: await的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。&lt;/p&gt;
&lt;p&gt;④ 如果 svctm 比较接近 await，说明I/O 几乎没有等待时间；&lt;/p&gt;
&lt;p&gt;⑤ 如果 await 远大于 svctm，说明 I/O队列太长，应用得到的响应时间变慢，&lt;/p&gt;
&lt;p&gt;⑥ 如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator算法，优化应用，或者升级 CPU。&lt;/p&gt;
&lt;p&gt;⑦ 队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。&lt;/p&gt;

&lt;h2&gt;二、I/O理解与实例分析&lt;/h2&gt;
&lt;h3&gt;1、一个不错的例子，瞬间理解I/O (I/O 系统 vs. 超市排队)&lt;/h3&gt;
&lt;p&gt;（1）超市例子：&lt;/p&gt;
&lt;p&gt;　　举一个例子，我们在超市排队 checkout 时，怎么决定该去哪个交款台呢? 首当是看排的队人数，5个人总比20人要快吧?除了数人头，我们也常常看看前面人购买的东西多少，如果前面有个采购了一星期食品的大妈，那么可以考虑换个队排了。还有就是收银员的速度了，如果碰上了连钱都点不清楚的新手，那就有的等了。另外，时机也很重要，可能 5分钟前还人满为患的收款台，现在已是人去楼空，这时候交款可是很爽啊，当然，前提是那过去的 5 分钟里所做的事情比排队要有意义(不过我还没发现什么事情比排队还无聊的)。&lt;/p&gt;
&lt;p&gt;（2）I/O 系统也和超市排队有很多类似之处&lt;/p&gt;
&lt;p&gt;① r/s+w/s 类似于交款人的总数&lt;/p&gt;
&lt;p&gt;② 平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数&lt;/p&gt;
&lt;p&gt;③ 平均服务时间(svctm)类似于收银员的收款速度&lt;/p&gt;
&lt;p&gt;④ 平均等待时间(await)类似于平均每人的等待时间&lt;/p&gt;
&lt;p&gt;⑤ 平均I/O数据(avgrq-sz)类似于平均每人所买的东西多少&lt;/p&gt;
&lt;p&gt;⑥ I/O 操作率 (%util)类似于收款台前有人排队的时间比例。&lt;/p&gt;
&lt;p&gt;我们可以根据这些数据分析出 I/O 请求的模式，以及 I/O 的速度和响应时间。&lt;/p&gt;

&lt;h3&gt;2、参数的实例分析&lt;/h3&gt;
&lt;p&gt;（1）实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# iostat -x &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
avg&lt;/span&gt;-cpu:  %user   %nice    %sys   %&lt;span&gt;idle
&lt;/span&gt;&lt;span&gt;16.24&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;4.31&lt;/span&gt;   &lt;span&gt;79.44&lt;/span&gt;&lt;span&gt;
Device:     rrqm&lt;/span&gt;/s wrqm/s  r/s    w/s   rsec/s  wsec/s   rkB/s    wkB/s avgrq-sz avgqu-sz  &lt;span&gt;await&lt;/span&gt;  svctm  %&lt;span&gt;util
&lt;/span&gt;/dev/vda &lt;span&gt;   0&lt;/span&gt;&lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;44.90&lt;/span&gt;  &lt;span&gt;1.02&lt;/span&gt;    &lt;span&gt;27.55&lt;/span&gt;  &lt;span&gt;8.16&lt;/span&gt;   &lt;span&gt;579.59&lt;/span&gt;   &lt;span&gt;4.08&lt;/span&gt;     &lt;span&gt;289.80&lt;/span&gt;   &lt;span&gt;20.57&lt;/span&gt; &lt;span&gt;22.35&lt;/span&gt;     &lt;span&gt;78.21&lt;/span&gt;  &lt;span&gt;5.00&lt;/span&gt;  &lt;span&gt;14.29&lt;/span&gt;
/dev/vdb    0&lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;44.90&lt;/span&gt;  &lt;span&gt;1.02&lt;/span&gt;    &lt;span&gt;27.55&lt;/span&gt;  &lt;span&gt;8.16&lt;/span&gt;   &lt;span&gt;579.59&lt;/span&gt;   &lt;span&gt;4.08&lt;/span&gt;     &lt;span&gt;289.80&lt;/span&gt;   &lt;span&gt;20.57&lt;/span&gt; &lt;span&gt;22.35&lt;/span&gt;     &lt;span&gt;78.21&lt;/span&gt;  &lt;span&gt;5.00&lt;/span&gt;  &lt;span&gt;14.29&lt;/span&gt;
/dev/vbc    0&lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;    &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;     &lt;span&gt;0.00&lt;/span&gt;  &lt;span&gt;0.00&lt;/span&gt;      &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;   &lt;span&gt;0.00&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）分析&lt;/p&gt;
&lt;p&gt;① 上面的 iostat 输出表明秒有 28.57 次设备 I/O 操作: 总IO(io)/s = r/s(读) +w/s(写) = 1.02+27.55 = 28.57 (次/秒) 其中写操作占了主体 (w:r = 27:1)。&lt;/p&gt;
&lt;p&gt;② 平均每次设备 I/O 操作只需要 5ms 就可以完成，但每个 I/O 请求却需要等上 78ms，为什么? 因为发出的 I/O 请求太多 (每秒钟约 29 个)，假设这些请求是同时发出的，那么平均等待时间可以这样计算:&lt;/p&gt;
&lt;p&gt;平均等待时间 = 单个 I/O 服务时间 * ( 1 + 2 + ... + 请求总数-1) / 请求总数&lt;/p&gt;
&lt;p&gt;③ 应用到上面的例子: 平均等待时间 = 5ms * (1+2+...+28)/29 = 70ms，和 iostat 给出的78ms 的平均等待时间很接近。这反过来表明 I/O 是同时发起的。&lt;/p&gt;
&lt;p&gt;④ 每秒发出的 I/O 请求很多 (约 29 个)，平均队列却不长 (只有 2 个 左右)，这表明这 29 个请求的到来并不均匀，大部分时间 I/O 是空闲的。&lt;/p&gt;
&lt;p&gt;⑤ 一秒中有 14.29% 的时间 I/O 队列中是有请求的，也就是说，85.71% 的时间里 I/O 系统无事可做，所有 29 个 I/O 请求都在142毫秒之内处理掉了。&lt;/p&gt;
&lt;p&gt;⑥ delta(ruse+wuse)/delta(io) = await = 78.21 =&amp;gt; delta(ruse+wuse)/s=78.21 * delta(io)/s = 78.21*28.57 =2232.8，表明每秒内的I/O请求总共需要等待2232.8ms。所以平均队列长度应为 2232.8ms/1000ms = 2.23，而iostat 给出的平均队列长度 (avgqu-sz) 却为 22.35，为什么?! 因为 iostat 中有 bug，avgqu-sz值应为 2.23，而不是 22.35。&lt;/p&gt;

&lt;h2&gt;三、iostat用法升级&lt;/h2&gt;
&lt;h3&gt;1、Input Output statistics (  iostat )&lt;/h3&gt;
&lt;p&gt;　　iostat反映了终端、磁盘I/O情况和CPU活动。输出结果的第一行是从系统启动到现在为止的这段时间的结果，接下去的每一行是interval时间段内的结果。Kernel里有一组计数器用来跟踪这些值。&lt;/p&gt;
&lt;p&gt;　　iostat的默认参数是tdc(terminal,  disk, and CPU)。如果任何其他的选项被指定，这个默认参数将被完全替代，例如，iostat -d将只反映磁盘的统计结果。&lt;/p&gt;

&lt;h3&gt;2、语法介绍&lt;/h3&gt;
&lt;p&gt;基本语法： iostat  &amp;lt;options&amp;gt;;   interval  count&lt;/p&gt;
&lt;p&gt;　　option - 让你指定所需信息的设备，像磁盘、cpu或者终端(-d , -c , -t  or -tdc ) 。x 选项给出了完整的统计结果（gives the extended statistic）。&lt;/p&gt;
&lt;p&gt;　　interval -  在两个samples之间的时间（秒）。&lt;/p&gt;
&lt;p&gt;　　count  - 就是需要统计几次&lt;/p&gt;

&lt;h3&gt;3、例子&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ iostat -xtc &lt;span&gt;5&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                          extended disk statistics       tty         cpu
     disk r&lt;/span&gt;/s  w/s Kr/s Kw/s wait actv svc_t  %w  %&lt;span&gt;b  tin tout us sy wt id
     sd0   &lt;/span&gt;&lt;span&gt;2.6&lt;/span&gt; &lt;span&gt;3.0&lt;/span&gt; &lt;span&gt;20.7&lt;/span&gt; &lt;span&gt;22.7&lt;/span&gt; &lt;span&gt;0.1&lt;/span&gt;  &lt;span&gt;0.2&lt;/span&gt;  &lt;span&gt;59.2&lt;/span&gt;   &lt;span&gt;6&lt;/span&gt;   &lt;span&gt;19&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;   &lt;span&gt;84&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt;  &lt;span&gt;85&lt;/span&gt; &lt;span&gt;11&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
     sd1   &lt;/span&gt;&lt;span&gt;4.2&lt;/span&gt; &lt;span&gt;1.0&lt;/span&gt; &lt;span&gt;33.5&lt;/span&gt;  &lt;span&gt;8.0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.2&lt;/span&gt;  &lt;span&gt;47.2&lt;/span&gt;   &lt;span&gt;2&lt;/span&gt;   &lt;span&gt;23&lt;/span&gt;&lt;span&gt;
     sd2   &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;   &lt;span&gt;0.0&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
     sd3  &lt;/span&gt;&lt;span&gt;10.2&lt;/span&gt; &lt;span&gt;1.6&lt;/span&gt; &lt;span&gt;51.4&lt;/span&gt; &lt;span&gt;12.8&lt;/span&gt; &lt;span&gt;0.1&lt;/span&gt;  &lt;span&gt;0.3&lt;/span&gt;  &lt;span&gt;31.2&lt;/span&gt;   &lt;span&gt;3&lt;/span&gt;   &lt;span&gt;31&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4、参数详解&lt;/h3&gt;
&lt;p&gt;disk：磁盘名称&lt;/p&gt;
&lt;p&gt;r / s：每秒读取数&lt;/p&gt;
&lt;p&gt;w / s：每秒写入数&lt;/p&gt;
&lt;p&gt;Kr / s：每秒读取的千字节数&lt;/p&gt;
&lt;p&gt;Kw / s：每秒写入的千字节数&lt;/p&gt;
&lt;p&gt;等待：等待服务的平均交易次数（Q长度）&lt;/p&gt;
&lt;p&gt;actv：正在服务的平均事务数（从队列中删除但尚未完成）&lt;/p&gt;
&lt;p&gt;％w：等待服务的事务的时间百分比（队列非空）&lt;/p&gt;
&lt;p&gt;％b：磁盘忙碌的时间百分比（正在进行的事务）&lt;/p&gt;

&lt;h3&gt;5、结果和解决方案&lt;/h3&gt;
&lt;p&gt;（1）从iostat输出结果中需要注意的值：&lt;/p&gt;
&lt;p&gt;　　Reads/writes  per second (r/s , w/s)&lt;/p&gt;
&lt;p&gt;　　Percentage busy (%b)&lt;/p&gt;
&lt;p&gt;　　Service time (svc_t)&lt;/p&gt;

&lt;p&gt;（2）如果磁盘显示长时间的高reads/writes，并且磁盘的percentage busy (%b)也远大于5%，同时average service time  (svc_t)也远大于30 milliseconds，这以下的措施需要被执行：&lt;/p&gt;
&lt;p&gt;① 调整应用，令其使用磁盘i/o更加有效率，可以通过修改磁盘队列、使用应用服务器的cache&lt;/p&gt;
&lt;p&gt;② 将文件系统分布到2个或多个磁盘上，并使用volume manager/disksuite的条带化特点&lt;/p&gt;
&lt;p&gt;③ 增加系统参数值，如inode cache  , ufs_ninode。Increase the system parameter values for inode cache  , ufs_ninode ,  which is  Number of inodes to be held in memory. Inodes are cached globally (for UFS), not on a per-file system basis  &lt;/p&gt;
&lt;p&gt;④ 将文件系统移到更快的磁盘/控制器，或者用更好的设备来代替&lt;/p&gt;

</description>
<pubDate>Thu, 19 Jul 2018 06:10:00 +0000</pubDate>
<dc:creator>阿龙along</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/9335453.html</dc:identifier>
</item>
<item>
<title>Android Weekly Notes Issue #317 - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/android-weekly-issue-317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/android-weekly-issue-317.html</guid>
<description>&lt;p&gt;July 8th, 2018&lt;/p&gt;

&lt;p&gt;本期主要内容包括&quot;重磅&quot;的Udacity放弃RN(其实是因为他们RN写的那个Feature不要了),还包括如七部使用Google Page Lib,如何用Room设计与创建可维护的数据库等Code Guide的文章,以及Android P字体渲染,放大镜,Google新版Universal Music Play Sample,还有Retrofit如何工作,如何通过Kotlin Extension Generation来改善Dagger Butterknife使用体验,等等.&lt;/p&gt;
&lt;h2 id=&quot;articles-tutorials&quot;&gt;ARTICLES &amp;amp; TUTORIALS&lt;/h2&gt;

&lt;p&gt;Kotlin状态的一些列数据,包括它的使用率,渗透率,在项目中的应用率等多种多样的数据,并且可以订阅.&lt;/p&gt;
&lt;p&gt;一切数据表明,Kotlin在过去的一年中发展迅速,使用量Double,并且好评如潮.&lt;/p&gt;

&lt;p&gt;文章讲述了Retrofit如何工作,实际上是通过Proxy而非Processor去生成代码来实现的.文章表示在运行速度与编译速度上的Compromise是一个值得思考的问题.&lt;/p&gt;

&lt;p&gt;Android P提供了放大镜功能,并且TextView默认就实现了.&lt;br/&gt;国内用户应该不是很陌生,几年前国内的一些大Android浏览器厂商在WebView里面也有类似的功能,不过主要是Android copy了 iOS的默认属性...&lt;/p&gt;

&lt;p&gt;文章介绍了CI上使用&lt;a href=&quot;http://www.stathat.com/manual/start&quot;&gt;StatHat&lt;/a&gt;上传APK的一些数据,比如size等,然后发现问题后通过&lt;a href=&quot;http://danger.systems/ruby/&quot;&gt;Danger&lt;/a&gt;给Github的PR上面发出报警.&lt;/p&gt;
&lt;p&gt;这两个都是Ruby的应用.&lt;/p&gt;

&lt;p&gt;文章介绍了自己给Dagger与Butterknife写的ktx.&lt;/p&gt;
&lt;p&gt;由于Dagger使用了生成文件进行注入,所以必须先编译一边才能通过Compiler生成文件,使用起来不便.&lt;/p&gt;
&lt;p&gt;而ButterKnife使用了反射通过类名将自己Generate的辅助类在运行时创建,我们想消除这个反射.&lt;/p&gt;
&lt;p&gt;这些原因都因为Processor只能生成文件,而无法改变已有文件.&lt;/p&gt;
&lt;p&gt;所以作者使用了Kotlin Extension,首先在Lib里定义了一些Mock的接口,所以编译之前可以调用这些空实现.而在编译过程中,Compiler会生成对应的扩展方法,这样Dagger与Butterknife的问题都得以解决.&lt;/p&gt;

&lt;p&gt;Android P在TextView上下了狠功夫,增加了很多功能.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PrecomputedText&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;复杂字体Font在显示的时候实际上90%的时间都耗费在Measure计算上, 可以在后台线程通过&lt;code&gt;PrecomputedText&lt;/code&gt;计算,然后在UI线程set&lt;/p&gt;
&lt;p&gt;放大镜,上篇有提到.TextView自己默认实现了.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Smart Linkify&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TextView方按选中可以通过Google的ML处理解析,提供可能相关的应用显示在Copy Cut Paste旁边,这一切都是通过&lt;code&gt;TextClassifier&lt;/code&gt;实现的.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Line Height &amp;amp; Baseline Alignment&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;提供了几个Attribute控制文字行高,以及baseline的top与bottom margin.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;app:lineHeight
app:firstBaselineToTopHeight
app:lastBaselineToBottomHeight&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Udacity也放弃了RN,看了整片博客,感觉是他们可能只是为了凑个热度.&lt;/p&gt;
&lt;p&gt;首先他们放弃的最主要原因是他们就一个Feature用了RN,而且当时也是因为它很独立,然后尝试了RN,现在这个Feature不用了,就删掉了.&lt;/p&gt;
&lt;p&gt;然后他们的Android Dev细数了RN的十宗罪,但是都是我们大概能想到的.&lt;/p&gt;
&lt;p&gt;比如实际上两个平台尤其android还是需要通过改code来修bug或者特殊需求,RN与native互通麻烦,RN导致CI编译长,包增大,启动变慢,RN文档欠缺,代码变更太快,自身bug多,不同设备不同表现,遇到问题常常需要改源码等等等等.&lt;/p&gt;
&lt;p&gt;而之所以当初要使用,主要原因是为了省事,可惜后来发现还是费事了,所以以后再也不会考虑RN了.&lt;/p&gt;

&lt;p&gt;作者介绍了他们的应用是如何保证质量的,答案就是写测试,一般feature手工只测一遍,剩下就得自动化测试.&lt;/p&gt;
&lt;p&gt;测试他们分为三类, UT是开发来写, 基本覆盖每一个函数,集成测试用Robolectric是QA负责来写,End to End test使用Espresso,Instrument Test等,整个跑下来不能超过三小时.&lt;/p&gt;

&lt;p&gt;从Android P开始基于Clang编译器做了很多优化,提升了稳定性,降低了被攻击的风险.&lt;/p&gt;
&lt;p&gt;如CFI (Control Flow Integrity&lt;br/&gt;) 技术,主要是增加了虚函数指针偏移指向地址的检查,如果发现指向非法地址就会终止编译.&lt;/p&gt;
&lt;p&gt;IOS (Integer Overflow Sanitization&lt;br/&gt;) 技术会检测有符号或者无符号的Integer在算法中溢出的问题,并且优化后运用到了一些库的编译中,如libui, libnl,libexif等...&lt;/p&gt;

&lt;p&gt;文章介绍了如何使用Google Architecture Component里面的Page来实现分页加载.&lt;/p&gt;
&lt;p&gt;总共有七步,关键是实现PageKeyedDataSource接口封装MutableLiveData. 实现DataSource.Factory将DataSource封装成Factory.&lt;/p&gt;
&lt;p&gt;然后就可以通过LivePagedListBuilder来生成数据了.&lt;/p&gt;

&lt;p&gt;鉴于大家对Google的Universal Music Player的喜爱,推出V2版,采用Kotlin与MVVM的架构,但是还有一些小功能没有加进来.&lt;/p&gt;

&lt;p&gt;作者在网上找如何上传jcenter,找了很多说法不一的,所以一怒之下自己写了一篇.&lt;/p&gt;

&lt;p&gt;作者通过实现一个天气预报软件的数据库,来介绍如何设计以及使用正确的方案来确保软件架构正确与维护的成本.&lt;/p&gt;
&lt;p&gt;PS:使用的是Room.&lt;/p&gt;
&lt;h2 id=&quot;libraries-code&quot;&gt;LIBRARIES &amp;amp; CODE&lt;/h2&gt;

&lt;p&gt;Kotlin写的快速滑动的滚动条,按照首字母.&lt;/p&gt;

&lt;p&gt;Vector实现的石英表,适配各种屏幕.&lt;/p&gt;

&lt;p&gt;可以将带JS的HTML5页面转换为多个Android Layout.&lt;/p&gt;

&lt;p&gt;Google重写的UAMP&lt;/p&gt;

&lt;p&gt;替代系统DatePicker的一个第三方组件.&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 05:49:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengdd/p/android-weekly-issue-317.html</dc:identifier>
</item>
<item>
<title>Linux的内存分页管理 - Vamei</title>
<link>http://www.cnblogs.com/vamei/p/9329278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vamei/p/9329278.html</guid>
<description>&lt;p&gt;内存是计算机的主存储器。内存为进程开辟出进程空间，让进程在其中保存数据。我将从内存的物理特性出发，深入到内存管理的细节，特别是了解虚拟内存和内存分页的概念。&lt;/p&gt;

&lt;h3&gt;内存&lt;/h3&gt;
&lt;p&gt;简单地说，内存就是一个数据货架。内存有一个最小的存储单位，大多数都是一个字节。内存用内存地址（memory address）来为每个字节的数据顺序编号。因此，内存地址说明了数据在内存中的位置。内存地址从0开始，每次增加1。这种线性增加的存储器地址称为线性地址（linear address）。为了方便，我们用十六进制数来表示内存地址，比如0x00000003、0x1A010CB0。这里的“0x”用来表示十六进制。“0x”后面跟着的，就是作为内存地址的十六进制数。&lt;/p&gt;
&lt;p&gt;内存地址的编号有上限。地址空间的范围和地址总线（address bus）的位数直接相关。CPU通过地址总线来向内存说明想要存取数据的地址。以英特尔32位的80386型CPU为例，这款CPU有32个针脚可以传输地址信息。每个针脚对应了一位。如果针脚上是高电压，那么这一位是1。如果是低电压，那么这一位是0。32位的电压高低信息通过地址总线传到内存的32个针脚，内存就能把电压高低信息转换成32位的二进制数，从而知道CPU想要的是哪个位置的数据。用十六进制表示，32位地址空间就是从0x00000000 到0xFFFFFFFF。&lt;/p&gt;
&lt;p&gt;内存的存储单元采用了随机读取存储器（RAM， Random Access Memory）。所谓的“随机读取”，是指存储器的读取时间和数据所在位置无关。与之相对，很多存储器的读取时间和数据所在位置有关。就拿磁带来说，我们想听其中的一首歌，必须转动带子。如果那首歌是第一首，那么立即就可以播放。如果那首歌恰巧是最后一首，我们快进到可以播放的位置就需要花很长时间。我们已经知道，进程需要调用内存中不同位置的数据。如果数据读取时间和位置相关的话，计算机就很难把控进程的运行时间。因此，随机读取的特性是内存成为主存储器的关键因素。&lt;/p&gt;
&lt;p&gt;内存提供的存储空间，除了能满足内核的运行需求，还通常能支持运行中的进程。即使进程所需空间超过内存空间，内存空间也可以通过少量拓展来弥补。换句话说，内存的存储能力，和计算机运行状态的数据总量相当。内存的缺点是不能持久地保存数据。一旦断电，内存中的数据就会消失。因此，计算机即使有了内存这样一个主存储器，还是需要硬盘这样的外部存储器来提供持久的储存空间。&lt;/p&gt;

&lt;h3&gt;虚拟内存&lt;/h3&gt;
&lt;p&gt;内存的一项主要任务，就是存储进程的相关数据。我们之前已经看到过进程空间的程序段、全局数据、栈和堆，以及这些这些存储结构在进程运行中所起到的关键作用。有趣的是，尽管进程和内存的关系如此紧密，但进程并不能直接访问内存。在Linux下，进程不能直接读写内存中地址为0x1位置的数据。进程中能访问的地址，只能是虚拟内存地址（virtual memory address）。操作系统会把虚拟内存地址翻译成真实的内存地址。这种内存管理方式，称为虚拟内存（virtual memory）。&lt;/p&gt;
&lt;p&gt;每个进程都有自己的一套虚拟内存地址，用来给自己的进程空间编号。进程空间的数据同样以字节为单位，依次增加。从功能上说，虚拟内存地址和物理内存地址类似，都是为数据提供位置索引。进程的虚拟内存地址相互独立。因此，两个进程空间可以有相同的虚拟内存地址，如0x10001000。虚拟内存地址和物理内存地址又有一定的对应关系，如图1所示。对进程某个虚拟内存地址的操作，会被CPU翻译成对某个具体内存地址的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180718150754636-308113815.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;206&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1 虚拟内存地址和物理内存地址的对应&lt;/p&gt;
&lt;p&gt;应用程序来说对物理内存地址一无所知。它只可能通过虚拟内存地址来进行数据读写。程序中表达的内存地址，也都是虚拟内存地址。进程对虚拟内存地址的操作，会被操作系统翻译成对某个物理内存地址的操作。由于翻译的过程由操作系统全权负责，所以应用程序可以在全过程中对物理内存地址一无所知。因此，C程序中表达的内存地址，都是虚拟内存地址。比如在C语言中，可以用下面指令来打印变量地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; v = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;void&lt;/span&gt;*)&amp;amp;v);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本质上说，虚拟内存地址剥夺了应用程序自由访问物理内存地址的权利。进程对物理内存的访问，必须经过操作系统的审查。因此，掌握着内存对应关系的操作系统，也掌握了应用程序访问内存的闸门。借助虚拟内存地址，操作系统可以保障进程空间的独立性。只要操作系统把两个进程的进程空间对应到不同的内存区域，就让两个进程空间成为“老死不相往来”的两个小王国。两个进程就不可能相互篡改对方的数据，进程出错的可能性就大为减少。&lt;/p&gt;
&lt;p&gt;另一方面，有了虚拟内存地址，内存共享也变得简单。操作系统可以把同一物理内存区域对应到多个进程空间。这样，不需要任何的数据复制，多个进程就可以看到相同的数据。内核和共享库的映射，就是通过这种方式进行的。每个进程空间中，最初一部分的虚拟内存地址，都对应到物理内存中预留给内核的空间。这样，所有的进程就可以共享同一套内核数据。共享库的情况也是类似。对于任何一个共享库，计算机只需要往物理内存中加载一次，就可以通过操纵对应关系，来让多个进程共同使用。IPO中的共享内存，也有赖于虚拟内存地址。&lt;/p&gt;

&lt;h3&gt;内存分页&lt;/h3&gt;
&lt;p&gt;虚拟内存地址和物理内存地址的分离，给进程带来便利性和安全性。但虚拟内存地址和物理内存地址的翻译，又会额外耗费计算机资源。在多任务的现代计算机中，虚拟内存地址已经成为必备的设计。那么，操作系统必须要考虑清楚，如何能高效地翻译虚拟内存地址。&lt;/p&gt;
&lt;p&gt;记录对应关系最简单的办法，就是把对应关系记录在一张表中。为了让翻译速度足够地快，这个表必须加载在内存中。不过，这种记录方式惊人地浪费。如果树莓派1GB物理内存的每个字节都有一个对应记录的话，那么光是对应关系就要远远超过内存的空间。由于对应关系的条目众多，搜索到一个对应关系所需的时间也很长。这样的话，会让树莓派陷入瘫痪。&lt;/p&gt;
&lt;p&gt;因此，Linux采用了分页（paging）的方式来记录对应关系。所谓的分页，就是以更大尺寸的单位页（page）来管理内存。在Linux中，通常每页大小为4KB。如果想要获取当前树莓派的内存页大小，可以使用命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$getconf PAGE_SIZE
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到结果，即内存分页的字节数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;4096&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;返回的4096代表每个内存页可以存放4096个字节，即4KB。Linux把物理内存和进程空间都分割成页。&lt;/p&gt;
&lt;p&gt;内存分页，可以极大地减少所要记录的内存对应关系。我们已经看到，以字节为单位的对应记录实在太多。如果把物理内存和进程空间的地址都分成页，内核只需要记录页的对应关系，相关的工作量就会大为减少。由于每页的大小是每个字节的4000倍。因此，内存中的总页数只是总字节数的四千分之一。对应关系也缩减为原始策略的四千分之一。分页让虚拟内存地址的设计有了实现的可能。&lt;/p&gt;
&lt;p&gt;无论是虚拟页，还是物理页，一页之内的地址都是连续的。这样的话，一个虚拟页和一个物理页对应起来，页内的数据就可以按顺序一一对应。这意味着，虚拟内存地址和物理内存地址的末尾部分应该完全相同。大多数情况下，每一页有4096个字节。由于4096是2的12次方，所以地址最后12位的对应关系天然成立。我们把地址的这一部分称为偏移量（offset）。偏移量实际上表达了该字节在页内的位置。地址的前一部分则是页编号。操作系统只需要记录页编号的对应关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180718150907259-1604778032.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;402&quot;/&gt;&lt;br/&gt;图2 地址翻译过程&lt;/p&gt;

&lt;h3&gt;多级分页表&lt;/h3&gt;
&lt;p&gt;内存分页制度的关键，在于管理进程空间页和物理页的对应关系。操作系统把对应关系记录在分页表（page table）中。这种对应关系让上层的抽象内存和下层的物理内存分离，从而让Linux能灵活地进行内存管理。由于每个进程会有一套虚拟内存地址，那么每个进程都会有一个分页表。为了保证查询速度，分页表也会保存在内存中。分页表有很多种实现方式，最简单的一种分页表就是把所有的对应关系记录到同一个线性列表中，即如图2中的“对应关系”部分所示。&lt;/p&gt;
&lt;p&gt;这种单一的连续分页表，需要给每一个虚拟页预留一条记录的位置。但对于任何一个应用进程，其进程空间真正用到的地址都相当有限。我们还记得，进程空间会有栈和堆。进程空间为栈和堆的增长预留了地址，但栈和堆很少会占满进程空间。这意味着，如果使用连续分页表，很多条目都没有真正用到。因此，Linux中的分页表，采用了多层的数据结构。多层的分页表能够减少所需的空间。&lt;/p&gt;
&lt;p&gt;我们来看一个简化的分页设计，用以说明Linux的多层分页表。我们把地址分为了页编号和偏移量两部分，用单层的分页表记录页编号部分的对应关系。对于多层分页表来说，会进一步分割页编号为两个或更多的部分，然后用两层或更多层的分页表来记录其对应关系，如图3所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413416/201807/413416-20180718151003294-400375060.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;444&quot;/&gt;&lt;br/&gt;图3 多层分页表&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在图3的例子中，页编号分成了两级。第一级对应了前8位页编号，用2个十六进制数字表示。第二级对应了后12位页编号，用3个十六进制编号。二级表记录有对应的物理页，即保存了真正的分页记录。二级表有很多张，每个二级表分页记录对应的虚拟地址前8位都相同。比如二级表0x00，里面记录的前8位都是0x00。翻译地址的过程要跨越两级。我们先取地址的前8位，在一级表中找到对应记录。该记录会告诉我们，目标二级表在内存中的位置。我们再在二级表中，通过虚拟地址的后12位，找到分页记录，从而最终找到物理地址。&lt;/p&gt;
&lt;p&gt;多层分页表就好像把完整的电话号码分成区号。我们把同一地区的电话号码以及对应的人名记录同通一个小本子上。再用一个上级本子记录区号和各个小本子的对应关系。如果某个区号没有使用，那么我们只需要在上级本子上把该区号标记为空。同样，一级分页表中0x01记录为空，说明了以0x01开头的虚拟地址段没有使用，相应的二级表就不需要存在。正是通过这一手段，多层分页表占据的空间要比单层分页表少了很多。&lt;br/&gt;多层分页表还有另一个优势。单层分页表必须存在于连续的内存空间。而多层分页表的二级表，可以散步于内存的不同位置。这样的话，操作系统就可以利用零碎空间来存储分页表。还需要注意的是，这里简化了多层分页表的很多细节。最新Linux系统中的分页表多达3层，管理的内存地址也比本章介绍的长很多。不过，多层分页表的基本原理都是相同。&lt;/p&gt;

&lt;p&gt;综上，我们了解了内存以页为单位的管理方式。在分页的基础上，虚拟内存和物理内存实现了分离，从而让内核深度参与和监督内存分配。应用进程的安全性和稳定性因此大为提高。&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 05:43:00 +0000</pubDate>
<dc:creator>Vamei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vamei/p/9329278.html</dc:identifier>
</item>
</channel>
</rss>