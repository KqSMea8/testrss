<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RabbitMQ一个简单可靠的方案(.Net Core实现) - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/9515208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/9515208.html</guid>
<description>&lt;p&gt;　　最近需要使用到消息队列相关技术，于是重新接触RabbitMQ。其中遇到了不少可靠性方面的问题，归纳了一下，大概有以下几种：&lt;/p&gt;
&lt;p&gt;　　1. 临时异常，如数据库网络闪断、http请求临时失效等；&lt;/p&gt;
&lt;p&gt;　　2. 时序异常，如A任务依赖于B任务，但可能由于调度或消费者分配的原因，导致A任务先于B任务执行；&lt;/p&gt;
&lt;p&gt;　　3. 业务异常，由于系统测试不充分，上线后发现某几个或某几种消息无法正常处理；&lt;/p&gt;
&lt;p&gt;　　4. 系统异常，业务中间件无法正常操作，如网络中断、数据库宕机等；&lt;/p&gt;
&lt;p&gt;　　5. 非法异常，一些伪造、攻击类型的消息。&lt;/p&gt;

&lt;p&gt;　　针对这些异常，我采用了一种基于消息审计、消息重试、消息检索、消息重发的方案。&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180822000500168-1613678738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1. 消息均使用&lt;strong&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;/strong&gt;进行通讯，方式可以是direct或topic，不建议fanout。&lt;/p&gt;
&lt;p&gt;　　2. 根据业务在Exchange下分配一个或多个Queue，同时设置一个&lt;strong&gt;&lt;span&gt;审计线程(Audit)&lt;/span&gt;&lt;/strong&gt;监听所有Queue，用于记录消息到&lt;strong&gt;&lt;span&gt;MongoDB&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，同时又不阻塞正常业务处理&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　3. &lt;strong&gt;&lt;span&gt;生产者(Publisher)&lt;/span&gt;&lt;/strong&gt;在发布消息时，基于&lt;a href=&quot;http://www.rabbitmq.com/amqp-0-9-1-reference.html&quot; target=&quot;_blank&quot;&gt;AMQP&lt;/a&gt;协议，生成消息标识MessageId和时间戳Timestamp，根据消息业务添加头信息Headers便于跟踪。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180826210807044-312537621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4. &lt;strong&gt;&lt;span&gt;消费者(Comsumer)&lt;/span&gt;&lt;/strong&gt;消息处理失败时，则把消息发送到&lt;strong&gt;&lt;span&gt;重试交换机(Retry Exchange)&lt;/span&gt;&lt;/strong&gt;，并设置过期（重试）时间及更新重试次数；如果超过重试次数则删除消息。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5. 重试交换机Exchange设置&lt;strong&gt;&lt;span&gt;死信交换机(Dead Letter Exchange)&lt;/span&gt;&lt;/strong&gt;，消息过期后自动转发到业务交换机(Exchange)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6. &lt;strong&gt;&lt;span&gt;WebApi&lt;/span&gt;&lt;/strong&gt;可以根据消息标识MessageId、时间戳Timestamp以及头信息Headers在MongoDB中对消息进行检索或重试。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;em&gt;&lt;span&gt;注：选择MongoDB作为存储介质的主要&lt;em&gt;原因&lt;/em&gt;是其对头信息（headers）的动态查询支持较好，同等的替代产品还可以是Elastic Search这些。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　1. 设置断线自动恢复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory
　　{
    　　Uri &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amqp://guest:guest@192.168.132.137:5672&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    　　AutomaticRecoveryEnabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
　　};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 定义Exchange，模式为direct&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　channel.ExchangeDeclare(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3. 根据业务定义QueueA和QueueB&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
　　channel.QueueDeclare(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
　　channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

　　channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
　　channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4. 启动消息发送确认机制，即需要收到RabbitMQ服务端的确认消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　channel.ConfirmSelect();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5. 设置消息持久化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; properties =&lt;span&gt; channel.CreateBasicProperties();
　　properties.Persistent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　6. 生成消息标识MessageId、时间戳Timestamp以及头信息Headers&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　properties.MessageId = Guid.NewGuid().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　properties.Timestamp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds());
　　properties.Headers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
　　{
    　　{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i}
　　};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7. 发送消息，偶数序列发送到QueueA（RouteA），奇数序列发送到QueueB（RouteB）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　channel.BasicPublish(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, properties, body);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　8. 确定收到RabbitMQ服务端的确认消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; isOk =&lt;span&gt; channel.WaitForConfirms();
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isOk)
　　{
    　　&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The message is not reached to the server!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b7434f8b-cbce-45ae-8637-19c60e0c34c5')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_b7434f8b-cbce-45ae-8637-19c60e0c34c5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b7434f8b-cbce-45ae-8637-19c60e0c34c5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b7434f8b-cbce-45ae-8637-19c60e0c34c5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b7434f8b-cbce-45ae-8637-19c60e0c34c5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory
{
    Uri &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;amqp://guest:guest@localhost:5672&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    AutomaticRecoveryEnabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
{
    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
    {
        channel.ExchangeDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        channel.ConfirmSelect();

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; channel.CreateBasicProperties();
            properties.Persistent &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            properties.MessageId &lt;/span&gt;= Guid.NewGuid().ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            properties.Timestamp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeMilliseconds());

            properties.Headers &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i}
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; message = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body =&lt;span&gt; Encoding.UTF8.GetBytes(message);

            channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, i % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, properties, body);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isOk =&lt;span&gt; channel.WaitForConfirms();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isOk)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The message is not reached to the server!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　效果：QueueA和QueueB各一条消息，QueueAudit两条消息&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180826223250884-1619209740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;&lt;em&gt;注：Exchange下必须先声明Queue才能接收到消息，上述代码并没有QueueAudit的声明；需要手动声明，或者先执行下面的消费者程序进行声明。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　1. 设置预取消息，避免&lt;strong&gt;&lt;a href=&quot;http://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html&quot; target=&quot;_blank&quot;&gt;公平轮训&lt;/a&gt;&lt;/strong&gt;问题，可以根据需要设置预取消息数，这里是1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　_channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180827001105974-36895420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 声明Exchange和Queue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
　　_channel.ExchangeDeclare(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　_channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
　　_channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3. 编写回调函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(_channel);
　　consumer.Received &lt;/span&gt;+= (model, ea) =&amp;gt;&lt;span&gt;
　　{
    　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The QueueA is always successful.&lt;/span&gt;
    　　&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    　　{
        　　_channel.BasicAck(ea.DeliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    　　}
    　　&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AlreadyClosedException ex)
    　　{
        　　_logger.LogCritical(ex, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RabbitMQ is closed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    　　}
　　};

　　_channel.BasicConsume(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;注：设置了RabbitMQ的断线恢复机制，当RabbitMQ连接不可用时，与MQ通讯的操作会抛出AlreadyClosedException的异常，导致主线程退出，哪怕连接恢复了，程序也无法恢复，因此，需要捕获处理该异常。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;　　1. 设置预取消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　_channel.BasicQos(0, 1, false);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 声明Exchange和Queue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
　　_channel.ExchangeDeclare(&quot;Exchange&quot;, &quot;direct&quot;&lt;span&gt;);
　　_channel.QueueDeclare(&quot;QueueB&quot;, true, false, false&lt;span&gt;);
　　_channel.QueueBind(&quot;QueueB&quot;, &quot;Exchange&quot;, &quot;RouteB&quot;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.  设置死信交换机(Dead Letter Exchange)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; retryDic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
　　{
    　　{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    　　{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-routing-key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
　　};

　　_channel.ExchangeDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　_channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, retryDic);
　　_channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4. 重试设置，3次重试；第一次1秒，第二次10秒，第三次30秒&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　_retryTime = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;
　　{
    　　&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;,
    　　&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;,
    　　&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;
　　};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5. 获取当前重试次数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; retryCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ea.BasicProperties.Headers != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ea.BasicProperties.Headers.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retryCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
　　{
    　　retryCount &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)ea.BasicProperties.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retryCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    　　_logger.LogWarning($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{DateTime.Now:yyyy-MM-dd HH:mm:ss}]Message:{ea.BasicProperties.MessageId}, {++retryCount} retry started...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　6. 发生异常，判断是否可以重试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; CanRetry(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; retryCount)
　　{
    　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; retryCount &amp;lt;= _retryTime.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　7. 可以重试，则启动重试机制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SetupRetry(&lt;span&gt;int&lt;/span&gt; retryCount, &lt;span&gt;string&lt;/span&gt; retryExchange, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; retryRoute, BasicDeliverEventArgs ea)
　　{
    　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body =&lt;span&gt; ea.Body;
    　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; ea.BasicProperties;
    　　properties.Headers &lt;/span&gt;= properties.Headers ?? &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
    　　properties.Headers[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retryCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; retryCount;
    　　properties.Expiration &lt;/span&gt;=&lt;span&gt; _retryTime[retryCount].ToString();

    　　&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    　　{
        　　_channel.BasicPublish(retryExchange, retryRoute, properties, body);
    　　}
    　　&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AlreadyClosedException ex)
    　　{
        　　_logger.LogCritical(ex, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RabbitMQ is closed!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    　　}
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7ad2d26f-9ba3-4674-9669-6a310b5640c0')&quot; readability=&quot;48&quot;&gt;&lt;img id=&quot;code_img_closed_7ad2d26f-9ba3-4674-9669-6a310b5640c0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7ad2d26f-9ba3-4674-9669-6a310b5640c0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7ad2d26f-9ba3-4674-9669-6a310b5640c0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7ad2d26f-9ba3-4674-9669-6a310b5640c0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
    _channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    
    _channel.ExchangeDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    _channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; retryDic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;
    {
        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
        {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-dead-letter-routing-key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
    };
    
    _channel.ExchangeDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    _channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, retryDic);
    _channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(_channel);
    consumer.Received &lt;/span&gt;+= (model, ea) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The QueueB is always failed.&lt;/span&gt;
        &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; canAck;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; retryCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ea.BasicProperties.Headers != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ea.BasicProperties.Headers.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retryCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        {
            retryCount &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)ea.BasicProperties.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;retryCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            _logger.LogWarning($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{DateTime.Now:yyyy-MM-dd HH:mm:ss}]Message:{ea.BasicProperties.MessageId}, {++retryCount} retry started...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            Handle();
            canAck &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            _logger.LogCritical(ex, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CanRetry(retryCount))
            {
                SetupRetry(retryCount, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ea);
                canAck &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                canAck &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (canAck)
            {
                _channel.BasicAck(ea.DeliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                _channel.BasicNack(ea.DeliveryTag, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AlreadyClosedException ex)
        {
            _logger.LogCritical(ex, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RabbitMQ is closed！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    };
    
    _channel.BasicConsume(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;　　1. 声明Exchange和Queue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
　　_channel.ExchangeDeclare(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

　　_channel.QueueDeclare(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueAudit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
　　_channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueAudit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
　　_channel.QueueBind(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QueueAudit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RouteB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2. 排除死信Exchange转发过来的重复消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　if&lt;/span&gt; (ea.BasicProperties.Headers == &lt;span&gt;null&lt;/span&gt; || !ea.BasicProperties.Headers.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x-death&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
　　{
    　　...
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3. 生成消息实体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　var&lt;/span&gt; message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message
　　{
    　　MessageId &lt;/span&gt;=&lt;span&gt; ea.BasicProperties.MessageId,
    　　Body &lt;/span&gt;=&lt;span&gt; ea.Body,
    　　Exchange &lt;/span&gt;=&lt;span&gt; ea.Exchange,
    　　Route &lt;/span&gt;=&lt;span&gt; ea.RoutingKey
　　};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　4. RabbitMQ会用bytes来存储字符串，因此，要把头中bytes转回字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　if&lt;/span&gt; (ea.BasicProperties.Headers != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
　　{
    　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; headers = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();

    　　&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; header &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ea.BasicProperties.Headers)
    　　{
        　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (header.Value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes)
        　　{
            　　headers[header.Key] &lt;/span&gt;=&lt;span&gt; Encoding.UTF8.GetString(bytes);
        　　}
        　　&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        　　{
            　　headers[header.Key] &lt;/span&gt;=&lt;span&gt; header.Value;
        　　}
    　　}

    　　message.Headers &lt;/span&gt;=&lt;span&gt; headers;
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　5. 把Unix格式的Timestamp转成UTC时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　if&lt;/span&gt; (ea.BasicProperties.Timestamp.UnixTime &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
　　{
    　　message.TimestampUnix &lt;/span&gt;=&lt;span&gt; ea.BasicProperties.Timestamp.UnixTime;
    　　&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset =&lt;span&gt; DateTimeOffset.FromUnixTimeMilliseconds(ea.BasicProperties.Timestamp.UnixTime);
    　　message.Timestamp &lt;/span&gt;=&lt;span&gt; offset.UtcDateTime;
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　6. 消息存入MongoDB&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　_mongoDbContext.Collection&amp;lt;Message&amp;gt;().InsertOne(message, cancellationToken: cancellationToken);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　MongoDB记录：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180827011033856-665362313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　重试记录：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180827010935896-192368779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　1. 通过消息Id检索消息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180827012913904-907874552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　2. 通过头消息检索消息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201808/182190-20180827012941233-1813930052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 18:16:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<og:description>前言 最近需要使用到消息队列相关技术，于是重新接触RabbitMQ。其中遇到了不少可靠性方面的问题，归纳了一下，大概有以下几种： 1. 临时异常，如数据库网络闪断、http请求临时失效等； 2. 时序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erik_Xu/p/9515208.html</dc:identifier>
</item>
<item>
<title>Mysql系列七：分库分表技术难题之分布式全局唯一id解决方案 - 小不点啊</title>
<link>http://www.cnblogs.com/leeSmall/p/9471848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leeSmall/p/9471848.html</guid>
<description>&lt;p&gt;在前面的文章&lt;a href=&quot;https://www.cnblogs.com/leeSmall/p/9440101.html&quot; target=&quot;_blank&quot;&gt;Mysql系列四：数据库分库分表基础理论&lt;/a&gt;中，已经说过分库分表需要应对的技术难题有如下几个：&lt;/p&gt;
&lt;p&gt;1. 分布式全局唯一id&lt;/p&gt;
&lt;p&gt;2. 分片规则和策略&lt;/p&gt;
&lt;p&gt;3. 跨分片技术问题&lt;/p&gt;
&lt;p&gt;4. 跨分片事物问题&lt;/p&gt;
&lt;p&gt;下面我们来看一下Mycat是如何解决分布式全局唯一id的问题的&lt;/p&gt;

&lt;p&gt;Mycat保证id唯一的方式有如下几个：&lt;/p&gt;
&lt;p&gt;1）本地文件方式&lt;/p&gt;
&lt;p&gt;2）数据库方式&lt;/p&gt;
&lt;p&gt;3）时间戳方式&lt;/p&gt;
&lt;p&gt;4）ZKID生成器&lt;/p&gt;
&lt;p&gt;5）ZK递增ID&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐使用第&lt;/span&gt;4，5&lt;span&gt;种&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;以上5中方式都要统一在server.xml文件中开启全局序列号的配置和在schema.xml文件中配置逻辑表的autoIncrement属性为true(2个必须步骤)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）sequnceHandlerType进行相应全局序列号策略选项设置（server.xml），在mycat中对应的源码是MyCATSequnceProcessor.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　sequnceHandlerType可取的值有以下几个：&lt;/p&gt;
&lt;p&gt;　　　　0：本地文件方式&lt;br/&gt;　　　　1：数据库方式&lt;br/&gt;　　　　2：时间戳方式&lt;br/&gt;　　　　3：ZKID生成器&lt;br/&gt;　　　　4：ZK递增ID&lt;/p&gt;
&lt;p&gt;2）autoIncrement属性为true（schema.xml）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hotnews&quot;&lt;/span&gt;&lt;span&gt; primaryKey&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; autoIncrement&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; dataNode&lt;/span&gt;&lt;span&gt;=&quot;dn1,dn2,dn3&quot;&lt;/span&gt;&lt;span&gt;  rule&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1. 本地文件方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用到的mycat源码：io.mycat.route.sequence.handler.IncrSequenceHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在server.xml文件中开启全局序列号的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用到的配置文件：sequence_conf.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#default global sequence
GLOBAL.HISIDS=
GLOBAL.MINID=10001
GLOBAL.MAXID=20000
GLOBAL.CURID=10000

# self define sequence
COMPANY.HISIDS=
COMPANY.MINID=1001
COMPANY.MAXID=2000
COMPANY.CURID=1000

CUSTOMER.HISIDS=
CUSTOMER.MINID=1001
CUSTOMER.MAXID=2000
CUSTOMER.CURID=1000

ORDER.HISIDS=
ORDER.MINID=1001
ORDER.MAXID=2000
ORDER.CURID=1000

HOTNEWS.HISIDS=
HOTNEWS.MINID=1001
HOTNEWS.MAXID=2000
HOTNEWS.CURID=1000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;拿HOTNEWS这个表的配置来说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HOTNEWS.HISIDS=       #HOTNEWS这张表历史使用的自增id，一般不配置
HOTNEWS.MINID=1001    #HOTNEWS这张表使用的最小自增id
HOTNEWS.MAXID=2000    #HOTNEWS这张表使用的最大自增id
HOTNEWS.CURID=1000    #HOTNEWS这张表当前使用的自增id&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当Mycat重新发布后，自增ID恢复到初始值。原因是因为sequnceHandlerType定义的是静态变量，不推荐使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;h3&gt;1.1 在mycat的schema.xml文件里面分别配置逻辑表hotnews和mysql的主从机，注意autoIncrement=&quot;true&quot;才能使用全局唯一id&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hotnews&quot;&lt;/span&gt;&lt;span&gt; primaryKey&lt;/span&gt;&lt;span&gt;=&quot;ID&quot;&lt;/span&gt;&lt;span&gt; autoIncrement&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; dataNode&lt;/span&gt;&lt;span&gt;=&quot;dn1,dn2,dn3&quot;&lt;/span&gt;&lt;span&gt; rule&lt;/span&gt;&lt;span&gt;=&quot;mod-long&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn1&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;centos1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db1&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn2&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;centos1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataNode &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dn3&quot;&lt;/span&gt;&lt;span&gt; dataHost&lt;/span&gt;&lt;span&gt;=&quot;centos1&quot;&lt;/span&gt;&lt;span&gt; database&lt;/span&gt;&lt;span&gt;=&quot;db3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dataHost &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;centos1&quot;&lt;/span&gt;&lt;span&gt; maxCon&lt;/span&gt;&lt;span&gt;=&quot;1000&quot;&lt;/span&gt;&lt;span&gt; minCon&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; balance&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
                          writeType&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; dbType&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt; dbDriver&lt;/span&gt;&lt;span&gt;=&quot;native&quot;&lt;/span&gt;&lt;span&gt; switchType&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;  slaveThreshold&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;select user()&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;heartbeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi write hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;writeHost &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;hostM1&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;192.168.152.130:3306&quot;&lt;/span&gt;&lt;span&gt; user&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt; password&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; can have multi read hosts &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;readHost &lt;/span&gt;&lt;span&gt;host&lt;/span&gt;&lt;span&gt;=&quot;hostS2&quot;&lt;/span&gt;&lt;span&gt; url&lt;/span&gt;&lt;span&gt;=&quot;192.168.152.131:3306&quot;&lt;/span&gt;&lt;span&gt; user&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt; password&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;writeHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;writeHost host=&quot;hostS1&quot; url=&quot;localhost:3316&quot; user=&quot;root&quot;
                                   password=&quot;123456&quot; /&amp;gt;&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;writeHost host=&quot;hostM2&quot; url=&quot;localhost:3316&quot; user=&quot;root&quot; password=&quot;123456&quot;/&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dataHost&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2 在主数据库（192.168.152.130）分别创建3个数据库db1,db2,db3,然后创建hotnews表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; db1;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; db1;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; hotnews(
   id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; auto_increment,
    title &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;default&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;

);
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; db2;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; db2;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; hotnews(
   id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; auto_increment,
    title &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;default&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;

);
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; db3;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; db3;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; hotnews(
   id &lt;/span&gt;&lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; auto_increment,
    title &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;default&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;

);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3 插入数据&lt;/h3&gt;
&lt;p&gt;插入数据到hotnews前我们先来看一下使用本地文件方式的配置文件sequence_conf.properties的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cat sequence_conf.properties &lt;span&gt;|&lt;/span&gt;grep HOTNEWS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825122401493-931537396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入数据到hotnews&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_HOTNEWS, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_HOTNEWS, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_HOTNEWS, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.4 查看hotnews表的结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hotnews;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825122555057-1877566434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次查看配置文件sequence_conf.properties的内容，发现内容随着插入数据的自增id做了改变&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825122854530-1700658247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2. 数据库方式&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这种方式和本地文件的方式是一样的，只是把sequence_conf.properties的内容用数据库来管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用到的mycat源码：io.mycat.route.sequence.handler.IncrSequenceMySQLHandler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里还是以hotnews表为例&lt;/p&gt;
&lt;h3&gt;2.1 在server.xml文件中开启全局序列号的配置：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用到的配置文件：sequence_db_conf.properties&lt;/p&gt;
&lt;pre&gt;
vim sequence_db_conf.properties
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#sequence stored &lt;span&gt;in&lt;/span&gt;&lt;span&gt; datanode
GLOBAL&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;dn1
COMPANY&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;dn1
CUSTOMER&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;dn1
ORDERS&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;dn1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 选择其中的一个分片，执行如下步骤，譬如我在dn1中创建，对应的数据库名为db1（为什么这里会涉及到datanode，因为后续的sequence_db_conf.properties文件会使用到），&lt;span&gt;&lt;strong&gt;注意：是登录到数据库中创建，而不是在mycat中创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一步：创建SEQUENCE表，用来存储序列号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;use&lt;/span&gt;&lt;span&gt; db1;
&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; MYCAT_SEQUENCE;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; MYCAT_SEQUENCE (
NAME &lt;/span&gt;&lt;span&gt;VARCHAR&lt;/span&gt; (&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;全局SEQ名称&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
current_value &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;当前序列ID&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
increment &lt;/span&gt;&lt;span&gt;INT&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;, &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始序列ID&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (NAME)
) ENGINE &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; INNODB ; &lt;br/&gt;INSERT INTO MYCAT_SEQUENCE(name,current_value,increment) VALUES ('GLOBAL', 100000, 100);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：创建SEQ function&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取当前sequence的值（返回当前值,增量）&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; `mycat_seq_currval`;
DELIMITER ;;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; `mycat_seq_currval`(seq_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;&lt;span&gt;)) 
&lt;/span&gt;&lt;span&gt;RETURNS&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;) CHARSET utf8
    DETERMINISTIC
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;DECLARE&lt;/span&gt; retval &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; retval&lt;span&gt;=&lt;/span&gt;&quot;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;999999999&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;;  
        &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; concat(&lt;span&gt;CAST&lt;/span&gt;(current_value &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;CHAR&lt;/span&gt;),&quot;,&quot;,&lt;span&gt;CAST&lt;/span&gt;(increment &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;CHAR&lt;/span&gt;) ) &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; retval 
          &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; MYCAT_SEQUENCE &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt;&lt;span&gt; seq_name;  
        &lt;/span&gt;&lt;span&gt;RETURN&lt;/span&gt;&lt;span&gt; retval ; 
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;
;;
DELIMITER ;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 获取下一个sequence值&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; `mycat_seq_nextval`;
DELIMITER ;;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; `mycat_seq_nextval`(seq_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;)) &lt;span&gt;RETURNS&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;)
 CHARSET utf8
    DETERMINISTIC
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;&lt;span&gt; MYCAT_SEQUENCE  
                 &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; current_value &lt;span&gt;=&lt;/span&gt; current_value &lt;span&gt;+&lt;/span&gt;&lt;span&gt; increment 
                  &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt;&lt;span&gt; seq_name;  
         &lt;/span&gt;&lt;span&gt;RETURN&lt;/span&gt;&lt;span&gt; mycat_seq_currval(seq_name);  
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;
;;
DELIMITER ;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 设置sequence值&lt;/span&gt;
&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt;&lt;span&gt; `mycat_seq_setval`;
DELIMITER ;;
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;FUNCTION&lt;/span&gt; `mycat_seq_setval`(seq_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;), value &lt;span&gt;INTEGER&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;RETURNS&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;&lt;span&gt;) CHARSET utf8
    DETERMINISTIC
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;UPDATE&lt;/span&gt;&lt;span&gt; MYCAT_SEQUENCE  
                   &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; current_value &lt;span&gt;=&lt;/span&gt;&lt;span&gt; value  
                   &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt;&lt;span&gt; seq_name;  
         &lt;/span&gt;&lt;span&gt;RETURN&lt;/span&gt;&lt;span&gt; mycat_seq_currval(seq_name);  
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;
;;
DELIMITER ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入需要自增长的表的策略，这条数据是我们hotnews这个表所需要的。 name必须是大写的字符，不然就会报错 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; MYCAT_SEQUENCE &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOTNEWS&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：插入了一个名为HOTNEWS的sequence，当前值为101，步长为100。当插入第一条数据时id为201，后面每插入一条数据id加1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第三步：在sequence_db_conf.properties这个文件中定义hotnews这张表的序列名称，同时可以定义到哪个分片上。这里是定义在dn1上的&lt;/p&gt;
&lt;p&gt;　　　　　　名字=分片1[,分片2][,.....][,分片N]&lt;/p&gt;
&lt;p&gt;vim sequence_db_conf.properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825194422899-348026860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存：&lt;/p&gt;
&lt;p&gt;:wq&lt;/p&gt;
&lt;h3&gt;2.3 重启mycat&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;root@centos1 mycat&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;# .&lt;span&gt;/&lt;/span&gt;bin&lt;span&gt;/&lt;/span&gt;mycat restart;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825194805173-1987503943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.4 连接mycat进行数据测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql &lt;span&gt;-&lt;/span&gt;uroot &lt;span&gt;-&lt;/span&gt;p123456 &lt;span&gt;-&lt;/span&gt;P8066 &lt;span&gt;-&lt;/span&gt;h192.&lt;span&gt;168.152&lt;/span&gt;.&lt;span&gt;128&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_HOTNEWS, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test11111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_HOTNEWS, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test11112&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_HOTNEWS, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test11113&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hotnews;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825201411057-48252960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：当mycat挂掉时可能出现主键冲突。不推荐使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. 本地时间戳方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用到的mycat源码：io.mycat.route.sequence.handler.IncrSequenceTimeHandler&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;3.1 在server.xml文件中开启全局序列号的配置：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用到的配置文件：&lt;/p&gt;
&lt;p&gt;sequence_time_conf.properties&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　WORKID=01(范围01-31)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　DATAACENTERID=01（范围01-31）&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;首先清空hotnews这张表的数据，方便查看测试结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hotnews;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入测试数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test11111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test11112&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test11113&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hotnews;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825204612919-19876194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;不存在id重复的现象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;主键太长。时间可能被重置。没有特殊要求的场景可以使用&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. 自增长主键&lt;/h2&gt;
&lt;p&gt;方式1：不同自增长初始值+相同步长&lt;/p&gt;
&lt;p&gt;方式2：参考“数据库方式”&lt;/p&gt;
&lt;h2&gt;5. 分布式ZK ID生成&lt;span&gt;（推荐使用）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用到的mycat源码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;io.mycat.route.sequence.handler.IncrSequenceZKHandler&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;io.mycat.route.sequence.handler.DistributedSequenceHandler&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;环境准备：先在虚拟机192.168.152.130里面装好zookeeper，具体参考我的文章 &lt;a href=&quot;https://www.cnblogs.com/leeSmall/p/7456065.html&quot; target=&quot;_blank&quot;&gt;搭建dubbo+zookeeper+dubboadmin分布式服务框架(windows平台下)&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;5.1 在server.xml文件中开启全局序列号的配置：&lt;/h3&gt;
&lt;p&gt;vim server.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.2 修改如下配置文件：&lt;/h3&gt;
&lt;p&gt;1）myid.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim myid.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825211713815-2006806177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;配置文件说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;loadZK=true|false //&lt;span&gt;是否使用&lt;/span&gt;&lt;span&gt;zk&lt;/span&gt;&lt;span&gt;序列生成器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;zkURL=xxx.xxx.xxx.xxx:2182,xxx.xxx.xxx.xxx:2182,xxx.xxx.xxx.xxx:2182&lt;/p&gt;
&lt;p&gt;clusterId=&lt;span&gt;集群名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）sequence_distributed_conf.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim sequence_distributed_conf.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825211858254-639611471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;配置文件说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;INSTANCEID=ZK  //&lt;span&gt;改成“&lt;/span&gt;&lt;span&gt;ZK&lt;/span&gt;&lt;span&gt;”（默认是&lt;/span&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CLUSTERID=01   //集群&lt;span&gt;编号&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;5.3 重启mycat&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[&lt;/span&gt;&lt;span&gt;root@centos1 mycat&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;# .&lt;span&gt;/&lt;/span&gt;bin&lt;span&gt;/&lt;/span&gt;mycat restart;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.4 连接mycat进行数据测试&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql -uroot -p123456 -P8066 -h192.168.152.128
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test00000001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test00000002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test00000003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; hotnews;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825212254503-1062646212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6. ZK递增方式&lt;span&gt;（推荐使用）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用到的mycat源码：&lt;/strong&gt;&lt;strong&gt;io.mycat.route.sequence.handler.IncrSequenceZKHandler&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;6.1 在server.xml文件中开启全局序列号的配置：&lt;/h3&gt;
&lt;p&gt;vim server.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sequnceHandlerType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用到的配置文件：&lt;/p&gt;
&lt;p&gt;1) myid.properties 参考“5. 分布式ZK ID生成器”中的介绍。&lt;/p&gt;
&lt;p&gt;2) sequence_conf.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HOTNEWS.HISIDS=       #HOTNEWS这张表历史使用的自增id，一般不配置
HOTNEWS.MINID=1001    #zk使用的区间内最小值
HOTNEWS.MAXID=2000    #zk使用的区间内最大值
HOTNEWS.CURID=1000    #zk使用的区间内当前值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以&lt;/span&gt;hotnews&lt;span&gt;为例&lt;/span&gt;&lt;span&gt;，然后根据&lt;/span&gt;&lt;span&gt;sequence_conf.properties&lt;/span&gt;&lt;span&gt;里面的&lt;/span&gt;&lt;span&gt;hotnews&lt;/span&gt;&lt;span&gt;的配置取&lt;/span&gt;MAXID和MINID&lt;span&gt;的偏移量（这里是&lt;/span&gt;1000&lt;span&gt;）作为&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;的增量值，当插入数据时把这&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;个值用完了在继续取&lt;/span&gt;MAXID和MINID的偏移量&lt;/p&gt;
&lt;h3&gt;6.2 重启mycat&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@centos1 mycat]# ./bin/mycat restart;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.3  连接mycat进行数据测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql -uroot -p123456 -P8066 -h192.168.152.128
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test00000001&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test00000002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; hotnews(id, title) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;next&lt;/span&gt; value &lt;span&gt;for&lt;/span&gt; MYCATSEQ_GLOBAL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test00000003&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt; hotnews;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1227483/201808/1227483-20180825220209998-304987294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 26 Aug 2018 17:46:00 +0000</pubDate>
<dc:creator>小不点啊</dc:creator>
<og:description>一、前言 在前面的文章Mysql系列四：数据库分库分表基础理论中，已经说过分库分表需要应对的技术难题有如下几个： 1. 分布式全局唯一id 2. 分片规则和策略 3. 跨分片技术问题 4. 跨分片事物</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leeSmall/p/9471848.html</dc:identifier>
</item>
<item>
<title>学习方法及笔记的总结 - 3L·BoNuo·Lotus</title>
<link>http://www.cnblogs.com/BoNuo/p/9539656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BoNuo/p/9539656.html</guid>
<description>&lt;p&gt;不同类型的知识，不能只用一种视角来总结总纲，而是根据自己的世界观（随着不断的学习，世界观会不停的健全，看问题的本质会慢慢深入，导致笔记的记录方式也随之不停的更改）对该类型的知识，进行分类，找出最符合它的特性进行对应的视角来创建对应的大纲，利用大纲来规划总结整个知识点的层次结构，同时也是自己的知识体系。&lt;/p&gt;
&lt;p&gt;学习过程中的手法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用分类（或许是利用概念，或是理念等等）&lt;/li&gt;
&lt;li&gt;使用前因后果表达关联性或流程&lt;/li&gt;
&lt;li&gt;使用框架及分层描述层次结构&lt;/li&gt;
&lt;li&gt;使用主次方式，那些是必须的，那些是拓展的&lt;/li&gt;
&lt;li&gt;使用原则，顺藤摸瓜。&lt;/li&gt;
&lt;li&gt;对比（差异，相关）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;学习过程中，不可能一下就知道用什么手法及笔记去记录及学习知识，都是靠自身的不断的总结，不断思考为什么会存在？存在的目的是什么？它解决了什么？在本质上去思考，去总结。&lt;/p&gt;
&lt;p&gt;笔记的总纲结构原则，让自己回顾的时候，第一眼看到总纲的时候，就能马上有一个整体的知识结构层次，通过总纲能牵出尽可多的知识细节（那些必须的，前后知识的关联性，等等）。&lt;/p&gt;
&lt;p&gt;笔记的总纲有很多种（同样的文字，使用不同的表现形式，能得出不同的视角（包含与层次关系（如菜单，框架，树形），推导（如流程），关联（立体）等）效果，常见的如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;总纲方式&lt;/td&gt;
&lt;td&gt;方法1：菜单方式，与word的目录一样&lt;/td&gt;
&lt;td&gt;方法2：主干与菜单&lt;/td&gt;
&lt;td&gt;方法3：主干与分支与菜单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;26&quot;&gt;&lt;td&gt;
&lt;p&gt;大约示例&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;ol&gt;&lt;li&gt;数据类型&lt;br/&gt;&lt;ol&gt;&lt;li&gt;整形&lt;/li&gt;
&lt;li&gt;字符&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;函数
&lt;ol&gt;&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;嵌套
&lt;ol&gt;&lt;li&gt;尾调用&lt;/li&gt;
&lt;li&gt;拓展知识
&lt;ol&gt;&lt;li&gt;函数式&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;控制语句&lt;br/&gt;&lt;ol&gt;&lt;li&gt;判断语句&lt;/li&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;td readability=&quot;17&quot;&gt;
&lt;p&gt;数据类型  ----------&amp;gt; 函数  ----------&amp;gt; 控制语句 &lt;/p&gt;
&lt;p&gt;                                | --&amp;gt; &lt;span&gt;定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                | --&amp;gt; &lt;span&gt;嵌套&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                              &lt;span&gt;  |         | --&amp;gt;尾调用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                &lt;span&gt;| &lt;/span&gt;        &lt;span&gt;| --&amp;gt; 拓展知识&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                |                     | --&amp;gt; 函数式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                | --&amp;gt; &lt;span&gt;递归&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;数据类型 --&amp;gt; 变量--&amp;gt;整形  --&amp;gt; 字符&lt;/p&gt;
&lt;p&gt;  ↓ &lt;/p&gt;
&lt;p&gt;  ↓                       拓展知识 --&amp;gt; 函数式&lt;/p&gt;
&lt;p&gt;  ↓                         ↑  &lt;/p&gt;

&lt;p&gt;函数  --&amp;gt; 定义 --&amp;gt; 嵌套 --&amp;gt; 递归&lt;/p&gt;
&lt;p&gt;  ↓                         | --&amp;gt;尾调用&lt;/p&gt;
&lt;p&gt;  ↓&lt;/p&gt;
&lt;p&gt;控制语句  --&amp;gt; 判断语句 --&amp;gt; 控制语句&lt;/p&gt;
&lt;p&gt;  ↓&lt;/p&gt;
&lt;p&gt;.....&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;没有直观的感受&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;没有明确指出,学&lt;span&gt;嵌套&lt;span&gt;后，可以马上学习&lt;/span&gt;递归&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为看起来更像是包含与层级关系（函数知识点包含有定义，嵌套，递归）&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;方法三，能较好的解决方法一，二的缺陷&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Sun, 26 Aug 2018 16:15:00 +0000</pubDate>
<dc:creator>3L&amp;#183;BoNuo&amp;#183;Lotus</dc:creator>
<og:description>不同类型的知识，不能只用一种视角来总结总纲，而是根据自己的世界观（随着不断的学习，世界观会不停的健全，看问题的本质会慢慢深入，导致笔记的记录方式也随之不停的更改）对该类型的知识，进行分类，找出最符合它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BoNuo/p/9539656.html</dc:identifier>
</item>
<item>
<title>13.0 Excel表格写入 - 佬贰</title>
<link>http://www.cnblogs.com/pythontest/p/9539637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythontest/p/9539637.html</guid>
<description>&lt;p&gt;Excel&lt;span&gt;表格写入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装&lt;/span&gt; xlutils &lt;span&gt;和&lt;/span&gt; &lt;span&gt;xlwt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180827000023102-462166632.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;Excel&lt;span&gt;写入输入 分两种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种是向一张新表之中写入&lt;/span&gt;..&lt;span&gt;这种不多说，我几乎没怎么用，直接贴代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlwt
Excel_name&lt;/span&gt;=xlwt.Workbook() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;实例化对象&lt;/span&gt;
table=Excel_name.add_sheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;新增到个sheet页&lt;/span&gt;
table.write(0,0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入内容&lt;/span&gt;
Excel_name.save(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\ExcelFile\test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存路径&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;第二种是在已存在内容的&lt;/span&gt;Excel&lt;span&gt;表格的基础上添加数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;这里注意一点，已存在内容的&lt;/span&gt;Excel&lt;span&gt;表格据我了解是无法通过脚本直接操作的，会提示权限被拒绝，所以只能在复制的时候新增或者修改数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里演示不做名称覆盖，复制修改之后重新创建一个Excel表格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180827000128310-1443895290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; xlutils.copy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy
path&lt;/span&gt;=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\ExcelFile\test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
new_path&lt;/span&gt;=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\ExcelFile\test2.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Excel_name&lt;/span&gt;=xlrd.open_workbook(path) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开Excel表格&lt;/span&gt;
Excel_name_new=copy(Excel_name) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;复制excel表格&lt;/span&gt;
&lt;span&gt;
table&lt;/span&gt;=Excel_name_new.get_sheet(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过get_sheet获取需要修改的sheet页&lt;/span&gt;
table.write(0,0,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;haha&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入&lt;/span&gt;
Excel_name_new.save(new_path) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法封装： 直接覆盖..新的Excel名称和老的Excel名称一样！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180827000309171-1192926774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;修改前后的路径一样，&lt;/span&gt;python&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;表格之后是可以直接覆盖修改的，前提是：你不要手动把&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;表格打开，手动打开一个&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;表格之后，就不能覆盖修改了&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xlrd
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; xlutils.copy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; xieRu_Excel(sheet_name,path):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; excel 写入&lt;/span&gt;
    Excel_Name = xlrd.open_workbook(path)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开excel表格&lt;/span&gt;
    Excel_Name_new = copy(Excel_Name)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 复制一个excel&lt;/span&gt;
    table= Excel_Name_new.get_sheet(sheet_name)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到复制后的 sheet页 &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; table,Excel_Name_new
path&lt;/span&gt;=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\ExcelFile\test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
new_path&lt;/span&gt;=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\ExcelFile\test.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
table&lt;/span&gt;=xieRu_Excel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sheet1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,path)
table[0].write(0,0,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写入&lt;/span&gt;
table[0].write(0,1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再1次修改&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
table[0].write(0,&lt;/span&gt;2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;再2次修改&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
table[&lt;/span&gt;1].save(new_path)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 26 Aug 2018 16:07:00 +0000</pubDate>
<dc:creator>佬贰</dc:creator>
<og:description>Excel表格写入 安装 xlutils 和 xlwt Excel写入输入 分两种方式： 第一种是向一张新表之中写入..这种不多说，我几乎没怎么用，直接贴代码 第二种是在已存在内容的Excel表格的基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythontest/p/9539637.html</dc:identifier>
</item>
<item>
<title>关于StringBuffer的学习笔记 - 迷途的小鹿</title>
<link>http://www.cnblogs.com/mitudexiaolu/p/9539634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mitudexiaolu/p/9539634.html</guid>
<description>&lt;p&gt;StringBuffer的构造方法：&lt;/p&gt;
&lt;table class=&quot;memberSummary&quot; summary=&quot;Constructor Summary table, listing constructors, and an explanation&quot; border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;&gt;&lt;tbody readability=&quot;4.218009478673&quot;&gt;&lt;tr&gt;&lt;th class=&quot;colOne&quot; scope=&quot;col&quot;&gt;Constructor and Description&lt;/th&gt;
&lt;/tr&gt;&lt;tr class=&quot;altColor&quot; readability=&quot;2.5955056179775&quot;&gt;&lt;td class=&quot;colOne&quot; readability=&quot;4.3258426966292&quot;&gt;&lt;code&gt;&lt;span class=&quot;memberNameLink&quot;&gt;&lt;a&gt;StringBuffer&lt;/a&gt;()&lt;/span&gt;&lt;/code&gt;
&lt;p&gt;构造一个字符串缓冲区没有字符和一个初始容量16字符。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;rowColor&quot; readability=&quot;3.0857142857143&quot;&gt;&lt;td class=&quot;colOne&quot; readability=&quot;3.8571428571429&quot;&gt;&lt;code&gt;&lt;span class=&quot;memberNameLink&quot;&gt;&lt;a&gt;StringBuffer&lt;/a&gt;(&lt;a title=&quot;interface in java.lang&quot;&gt;CharSequence&lt;/a&gt; seq)&lt;/span&gt;&lt;/code&gt;
&lt;p&gt;构造一个字符串缓冲区包含 &lt;code&gt;CharSequence&lt;/code&gt;指定相同的字符。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;altColor&quot; readability=&quot;2.6288659793814&quot;&gt;&lt;td class=&quot;colOne&quot; readability=&quot;4.3814432989691&quot;&gt;&lt;code&gt;&lt;span class=&quot;memberNameLink&quot;&gt;&lt;a&gt;StringBuffer&lt;/a&gt;(int capacity)&lt;/span&gt;&lt;/code&gt;
&lt;p&gt;构造一个字符串缓冲区没有字符和指定的初始容量。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;rowColor&quot; readability=&quot;3.28&quot;&gt;&lt;td class=&quot;colOne&quot; readability=&quot;4.1&quot;&gt;&lt;code&gt;&lt;span class=&quot;memberNameLink&quot;&gt;&lt;a&gt;StringBuffer&lt;/a&gt;(&lt;a title=&quot;class in java.lang&quot;&gt;String&lt;/a&gt; str)&lt;/span&gt;&lt;/code&gt;
&lt;p&gt;构造一个字符串缓冲区的内容初始化为指定的字符串。 &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Stringbuffer类的成员构造方法有：&lt;/p&gt;
&lt;p&gt;                                                     1.添加功能&lt;/p&gt;
&lt;p&gt;                                                               （1）public StringBuffer append(String str)&lt;/p&gt;
&lt;p&gt;                                                               （2）public StringBuffer insert（int offset.String str）&lt;/p&gt;
&lt;p&gt;                                                      2. 删除功能&lt;/p&gt;
&lt;p&gt;                                                                （1）public StringBuffer deleteCharAt（int index）&lt;/p&gt;
&lt;p&gt;                                                                （2）public StringBuffer deletrCharAt（int statr.int end）&lt;/p&gt;
&lt;p&gt;                                                      3.替换功能：&lt;/p&gt;
&lt;p&gt;                                                                 public StringBuffer replace(int start.int end.String str)&lt;/p&gt;
&lt;p&gt;                                                     4.反转功能：public StringBuffer reverse（）&lt;/p&gt;

&lt;p&gt;具体实现代码如下&lt;/p&gt;
&lt;p&gt;                                                &lt;img src=&quot;https://images2018.cnblogs.com/blog/1465201/201808/1465201-20180826234423633-823511420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img id=&quot;uploading_image_5231&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;                                                           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1465201/201808/1465201-20180826233253719-870050829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运用StringBuffer的数组转换字符串的遍历功能：&lt;/p&gt;
&lt;p&gt;                                                                                                    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1465201/201808/1465201-20180826234931399-1087984563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                                                            基本思想：用StringBuffer吧数组转换成字符串，进行字符的拼接。&lt;/p&gt;
&lt;p&gt;String和StringBuffer之间的相互转换与字符串的反转：     &lt;/p&gt;
&lt;p&gt;                                                                              &lt;img src=&quot;https://images2018.cnblogs.com/blog/1465201/201808/1465201-20180826235333846-2066480318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                     基本思想：这段代码，首相用Stringbuffer把String从一个基本类型转换成一个引用类型，然后进行反转调用。&lt;/p&gt;
&lt;p&gt;   StringBuffer和StringBuild的区别：&lt;/p&gt;
&lt;ul class=&quot;blockList&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;blockList&quot; readability=&quot;2&quot;&gt;
&lt;p&gt;这个类是设计用于为 &lt;code&gt;StringBuffer&lt;/code&gt;替代的地方使用的字符串缓冲区被单个线程(通常情况下)。在可能的情况下,建议这类中使用偏好 &lt;code&gt;StringBuffer&lt;/code&gt;在大多数实现要快得多。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;一边多线程使用StringBuffer，StringBuild用于单线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;   StringBuffer和String的区别：&lt;/p&gt;
&lt;p&gt;                                                                        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1465201/201808/1465201-20180827000427168-948815396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本周所学大致上就是这么多，做个笔记，希望有大神看到我错误的地方能给予纠正。&lt;/p&gt;

</description>
<pubDate>Sun, 26 Aug 2018 16:06:00 +0000</pubDate>
<dc:creator>迷途的小鹿</dc:creator>
<og:description>StringBuffer的构造方法： 构造一个字符串缓冲区没有字符和一个初始容量16字符。 构造一个字符串缓冲区包含 CharSequence指定相同的字符。 构造一个字符串缓冲区没有字符和指定的初始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mitudexiaolu/p/9539634.html</dc:identifier>
</item>
<item>
<title>给有C或C++基础的Python入门 ：Python Crash Course 4 操作列表 4.4 -- 4.5 - mpeter</title>
<link>http://www.cnblogs.com/mpeter/p/9536586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpeter/p/9536586.html</guid>
<description>&lt;p&gt;上接前一篇文章。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.4 使用列表的一部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;一，切片&lt;/p&gt;
&lt;p&gt;　　切边，&lt;span&gt;顾名思义，就是处理列表的部分元素&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　我们可以联系一下C++的一段语句：for(int i = 0; i &amp;lt; n-2; ++i) cout &amp;lt;&amp;lt; a[i];  &lt;/p&gt;
&lt;p&gt;　　这句语句就是访问了一个有n个元素的数组的1--n-2个元素（下标为0--n-3）。&lt;/p&gt;
&lt;p&gt;　　而这个实现在Python中的实现如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; players = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;charles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;martina&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;peter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mina&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(players[:4&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(players[0:3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(players[1:3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(players[2&lt;span&gt;:])
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(players[-3:])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2到6的代码分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打印列表中&lt;span&gt;第一&lt;/span&gt;到第四个元素（下标为0到3）。&lt;span&gt;注意，“ : x”表示下标从0到x-1。“x:”表示下标从x到n-1&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;’打印列表中第一到第三个元素（下标为0到2）。&lt;/li&gt;
&lt;li&gt;打印列表中第二到第三个元素（下标为1到2）。&lt;/li&gt;
&lt;li&gt;从第三个元素开始打印列表元素直到末尾元素（下标从2到n-1）。&lt;/li&gt;
&lt;li&gt;打印列表中倒数三个元素（下标为n-3到n-1）。&lt;span&gt;注意，为负值时从后开始数。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;二，复制列表&lt;/p&gt;
&lt;p&gt;先看如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; names = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;peter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mina&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mpeter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;katherine&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; my_friends =&lt;span&gt; names[:]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I have a list of my friends:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(names)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;However mina have a same list !&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(my_friends)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;But mike just have two in my list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; mike_friends = names[0:2&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(mike_friends)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 复制列表的原理其实很简单：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;声明一个列表a -&amp;gt; 赋值 -&amp;gt; 再声明一个列表b -&amp;gt; 从头到尾遍历列表a并同时传值到列表b -&amp;gt; 结束。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.5 元祖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在python中，将不可变的列表称为元祖。&lt;/p&gt;
&lt;p&gt;　　其实，和C++中的const定义常数组一样类似，一旦定义了则不可以修改。&lt;/p&gt;
&lt;p&gt;定义规则如下：（&lt;span&gt;用划“（）”括号定义&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dimensions = (1, 20, 50, 100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dimensions[0])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dimensions[1])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而若想修改，就会报错！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; dimensions = (1, 20, 50, 100&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dimensions[0])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(dimensions[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;error!!&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;dimensions[0] = 2&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(dimensions[0])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同普通列表一样元祖亦可以遍历：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const_numbers = (1, 2, 3, 4, 5, 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt;&lt;span&gt; const_numbers:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(number)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你想改变元祖的值，你&lt;span&gt;只能重新定义&lt;/span&gt;像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const_numbers = (2, 3, 4, 5, 6, 7&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; number &lt;span&gt;in&lt;/span&gt;&lt;span&gt; const_numbers:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(number)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　&lt;strong&gt;To be continued...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如有错误，欢迎评论指正！&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 16:01:00 +0000</pubDate>
<dc:creator>mpeter</dc:creator>
<og:description>上接前一篇文章。 4.4 使用列表的一部分 一，切片 切边，顾名思义，就是处理列表的部分元素。 我们可以联系一下C++的一段语句：for(int i = 0; i &lt; n-2; ++i) cou</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mpeter/p/9536586.html</dc:identifier>
</item>
<item>
<title>升级微服务架构3：服务发现及服务相互调用 - 唐 森</title>
<link>http://www.cnblogs.com/townsend/p/9531882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/townsend/p/9531882.html</guid>
<description>&lt;p&gt;　　一个微服务架构的系统中，不同服务之间是会相互调用的，如一个订单服务需要取用户数据，则需要调用用户服务，有多个用户服务实例时，Eureka会负载均衡到其中一个服务实例，和上一章一样，我们先通过Java版的服务发现及调用服务来做例子并移植到.net core版本。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1.Java版服务调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;1.1创建订单服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;和前面一样创建一个空的Maven项目，并改造成为一个Eureka客户端，修改下配置文件，服务名为userservice,端口设置为6661&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.2使用Ribbon做客户端负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　添加ribbon的依赖，ribbon是一个客户端的负载均衡组件，服务间相互调用通过它来负载均衡　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-ribbon&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建一个OrderController,同样创建一个User实体（实际项目中如果有多处调用同一个实体可以独立出来一个实体模块），在启动类中创建一个方法restTemplate()来注入restTemplate,并加上@Bean配置注解， @LoadBalanced负载均衡注解　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
@LoadBalanced
RestTemplate restTemplate() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参考官网文档：&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_spring_resttemplate_as_a_load_balancer_client&quot; target=&quot;_blank&quot;&gt;http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_spring_resttemplate_as_a_load_balancer_client&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　搜索：Spring RestTemplate as a Load Balancer Client&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/418139/201808/418139-20180824200222566-60007548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1.3订单服务调用用户服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　创建一个Service类用来封装调用其他服务，这里创建一个UserService类，封装userservice服务的方法，创建一个restTemplate变量加上@Autowired注解来实现自动扫描注入　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.tz.orderservice;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.core.ParameterizedTypeReference;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.ResponseEntity;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.client.RestTemplate;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; getAll() {
        ParameterizedTypeReference&lt;/span&gt;&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; responseType = &lt;span&gt;new&lt;/span&gt; ParameterizedTypeReference&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;&lt;span&gt;(){};
        ResponseEntity&lt;/span&gt;&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; resp = restTemplate.exchange(&quot;http://userservice/user/getall&quot;&lt;span&gt;,
                HttpMethod.GET, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, responseType);
        List&lt;/span&gt;&amp;lt;User&amp;gt; list =&lt;span&gt; resp.getBody();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　订单Controller中创建获取用户信息的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@RequestMapping(&lt;/span&gt;&quot;/order&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;

    @RequestMapping(&lt;/span&gt;&quot;/getalluser&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt;&lt;span&gt; getAllUser(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userService.getAll();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　启动Eureka Server，启动两个userservice实例，启动orderservice，刷新服务注册中心，发现订单服务orderservice已经注册成功&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/418139/201808/418139-20180824200515439-499449096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　浏览器访问订单服务的获取用户信息方法，可以看到成功调用了用户服务的方法&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/418139/201808/418139-20180824200614281-952305460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2. .net core版服务调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;2.1创建订单服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　按照上一章的方法创建一个.net Core的微服务，端口设置为6660，创建一个IUserService的接口，这里使用异步方法 　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService
{
    Task&lt;/span&gt;&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;&lt;span&gt; getAll() ;

    Task&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; getPort();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;2.2订单服务调用用户服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　创建一个UserService类，实现IUserService接口来调用服务&lt;/p&gt;
&lt;p&gt;　　参考：&lt;a href=&quot;http://steeltoe.io/docs/steeltoe-discovery/#1-2-6-discovering-services&quot; target=&quot;_blank&quot;&gt;http://steeltoe.io/docs/steeltoe-discovery/#1-2-6-discovering-services&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　Json序列化组件：Newtonsoft.Json　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService : IUserService
{
    DiscoveryHttpClientHandler _handler;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; serviceUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://userservice/user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserService(IDiscoveryClient client)
    {
        _handler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscoveryHttpClientHandler(client);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;&lt;span&gt; getAll()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; GetClient();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json= &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(serviceUrl+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/getall&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;User&amp;gt; list= JsonConvert.DeserializeObject&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;&lt;span&gt;(json);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; getPort()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; GetClient();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(serviceUrl + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/getport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpClient GetClient()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt; HttpClient(_handler, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; client;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　在Startup类的ConfigureServices中配置UserService的依赖注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加注入配置&lt;/span&gt;
    services.AddScoped&amp;lt;Controllers.IUserService, Controllers.UserService&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否能获取Eureka配置&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eureka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).GetChildren().Any())
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Steeltoe服务发现客户端服务配置&lt;/span&gt;
&lt;span&gt;        services.AddDiscoveryClient(Configuration);
    }
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　创建一个OrderController,使用IUserService接口来调用，在构造方法中注入实例　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController : ControllerBase
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUserService userService;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法来注入实例&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrderController(IUserService userService)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userService =&lt;span&gt; userService;
    }

    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getalluser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [HttpGet]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt;&lt;span&gt; getAll()
    {
        List&lt;/span&gt;&amp;lt;User&amp;gt; list = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; userService.getAll();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getuserserviceport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [HttpGet]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; getUserServicePort()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; userService.getPort();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; port;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　启动项目，在刷新下Eureka Server，端口为6660的orderservice实例就注册到了服务中心&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/418139/201808/418139-20180824202608007-473593536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在浏览器中输入：http://localhost:6660/order/getuserserviceport，来调用userservice的获取端口的方法，多刷新几次就可以看到端口会不断的切换，说明已经实现了负载均衡。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/418139/201808/418139-20180824202640828-683731839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/418139/201808/418139-20180824202648907-100416033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　.net core版的服务调用完成。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 15:43:00 +0000</pubDate>
<dc:creator>唐 森</dc:creator>
<og:description>一个微服务架构的系统中，不同服务之间是会相互调用的，如一个订单服务需要取用户数据，则需要调用用户服务，有多个用户服务实例时，Eureka会负载均衡到其中一个服务实例，和上一章一样，我们先通过Java版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/townsend/p/9531882.html</dc:identifier>
</item>
<item>
<title>Coursera概率图模型（Probabilistic Graphical Models）第三周编程作业分析 - 小石学CS</title>
<link>http://www.cnblogs.com/polaris-shi/p/9539548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/polaris-shi/p/9539548.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Markov Networks for OCR&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;光学字符识别的马尔科夫网络&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;说到光学字符识别（OCR），此前笔者首先想到的会是卷积神经网络，而单词识别则会考虑使用递归神经网络。而本周的作业则基于马尔科夫网络构建了一个较为基础OCR系统，目的也主要是让我们对马尔科夫网络有个感性的认知。网络所需要的的所有参数题目都已经训练完毕，而一些字符识别中的核心算法如图像间的相似度计算题目也都直接提供了……&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;笔者在刚读本科的时候，有幸看过一本《科学美国人》的《数学游戏》专栏集结本，其中《变佳作为梦呓》一文就提到了将莎士比亚名著中字符出现的频率以及字符之间的连接关系进行学习，形成字符间的概率表（基本等同于我们这一周学的马尔科夫网络╮(╯▽╰)╭），再由概率表生成一段乍看上去有点意思仔细一读狗屁不通的文章……原文还提到了对Basic语言的代码进行学习，再由所得的概率表自动生产一段Basic代码……学习的效果如下图所示，大家自行体会：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201808/1441944-20180826233600575-128191527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201808/1441944-20180826233600891-1401755273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，上面的结果已经是上古时代先贤们探索时期的产物了。但这篇文章直接让笔者对马尔科夫网络有了一个最基本的印象：能够较为自然地反映事物之间的联系。而英文单词的字符之间，也正是存在着一定的联系，比如xzw这种字符组合在英文单词中基本见不到，而ing的组合出现频率则较高。我们平时在记忆英语单词的时候，也大多会采用词根词缀记忆法（我觉得能听懂这门课的同学英语都不会太差……毕竟这课程基本没有中文字幕……）。因此，马尔科夫网络在字符识别上的确有较为优秀的表现。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.构建基础光学字符识别网络&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;听过吴恩达大神的机器学习课程的同学们都知道，机器学习课程的第三次作业也是将神经网络的参数全部训练完毕，只要我们完成基本网络的构架即可，第四次作业才是构建完成的神经网络，完成参数训练的工作。鉴于Koller和吴恩达同事多年，我感觉这个套路他们是有沟通过的……&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ComputeSingletonFactors.m 计算单独因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们打开ComputeImageFactor.m文件，仔细看一下的话，不难发现这就是一个softmax分类器……这里也主要是考虑对单个字符图像的识别问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因子factors的结构及意义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;：表示字符图片的编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;card&lt;/strong&gt;：表示字符图片的总分类数，26个小写字母。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;val&lt;/strong&gt;：表示字符图片对应各分类的置信度，由ComputeImageFactor计算得出。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).var = ii;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).card = imageModel.K;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).val = ComputeImageFactor(images(ii).img, imageModel);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.扩展网络&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;只考虑对字符图像的识别的话，和马尔科夫网络其实也没有什么关系……马尔科夫网络的牛逼之处也正是在于其能够通过字符间的概率关系来提升识别的效果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ComputeEqualPairwiseFactors.m 计算相同成对因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个函数是ComputePairwiseFactors.m函数的前身，建立因子的基本结构，而将因子的val全部置1即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因子factors的结构及意义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;：表示两个字符图片的编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;card&lt;/strong&gt;：表示两个字符图片各自可能的取值数量，即[26, 26]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;val&lt;/strong&gt;：表示相应字符组合的置信度，这里直接全部取1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : n - 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).var = [ii, ii + 1];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).card = [K, K];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).val = ones(K * K, 1);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ComputePairwiseFactors.m 计算成对因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;相比上面的函数，这里的置信度由pairwiseModel给出而非直接置1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因子factors的结构及意义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;：表示两个字符图片的编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;card&lt;/strong&gt;：表示两个字符图片各自可能的取值数量，即[26, 26]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;val&lt;/strong&gt;：表示相应字符组合的置信度，由pairwiseModel直接给出。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : n - 1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).var = [ii, ii + 1];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).card = [K, K];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).val = reshape(pairwiseModel, K * K, 1);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;ComputeTripletFactors.m 计算三联因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;题目也提供了三联表tripletList，用来描述连续三个字母的出现频率。三联表中不存在的组合的val值置1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因子factors的结构及意义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;：表示三个字符图片的编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;card&lt;/strong&gt;：表示三个字符图片各自可能的取值数量，即[26, 26, 26]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;val&lt;/strong&gt;：表示相应字符组合的置信度，由tripletList直接给出。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;val = ones(K * K * K, 1);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : length(tripletList)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;indices = AssignmentToIndex(tripletList(ii).chars, [K, K, K]);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;val(indices) = tripletList(ii).factorVal;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : n - 2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).var = [ii, ii + 1, ii + 2];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).card = [K, K, K];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii).val = val;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上因子主要是描述字符标签之间的关联性，与字符图像本身还没啥关系。下面则通过对同一单词中不同字符图像之间的相似性关系，来构建因子进一步提升识别准确率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;===============================分割线================================&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ComputeSimilarityFactor.m 计算相似因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个函数的逻辑是：如果两个字符图像在之前被识别出是相同的字母，则由ImageSimilarity函数计算出它们之间的相似度，不然将它们之间的相似度置1。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因子factors的结构及意义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;var&lt;/strong&gt;：表示两个字符图片在整个单词中的位置编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;card&lt;/strong&gt;：表示两个字符图片各自可能的取值数量，即[26, 26]。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;val&lt;/strong&gt;：表示字符图片之间的相似度，由ImageSimilarity函数计算得出。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factor.var = [i, j];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factor.card = [K, K];&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;factor.val = ones(K * K, 1);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : K&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;index = AssignmentToIndex([ii, ii], [K, K]);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factor.val(index) = ImageSimilarity(images(i).img, images(j).img);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ComputeAllSimilarityFactors.m 计算全部相似因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;基于上边的ComputeSimilarityFactor函数，计算单词中所有两个字母组合的相似因子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;kk = 1;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;jj = ii + 1 : n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(kk) = ComputeSimilarityFactor(images, K, ii, jj);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;kk = kk + 1;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;ChooseTopSimilarityFactors.m 选择最优相似因子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在ComputeAllSimilarityFactors.m的基础上，选择相似度最高的F个因子。这里我们注意&lt;strong&gt;相似因子&lt;/strong&gt;中&lt;strong&gt;val&lt;/strong&gt;的任一对角元素即可反映两图片之间的相似性即可。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;% Your code here:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SimilarityScore = zeros(length(allFactors), 1);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : length(allFactors)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;SimilarityScore(ii) = allFactors(ii).val(1);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;[~, indeces] = sort(SimilarityScore, &lt;span&gt;'descend'&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;factors = repmat(struct(&lt;span&gt;'var'&lt;span&gt;, [], &lt;span&gt;'card'&lt;span&gt;, [], &lt;span&gt;'val'&lt;span&gt;, []), F, 1);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for &lt;span&gt;ii = 1 : F&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;factors(ii) = allFactors(indeces(ii));&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;由于笔者的电脑无法运行ScoreModel 函数，所以也没办法直观的判断出不同网络模块对分类正确率的贡献，反正根据题目pdf文档的说法是单词的识别正确率会从22%上升到37%，同时字符识别率也会从76.7%上升到81.62%。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;附上交作业的截图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1441944/201808/1441944-20180826233601150-1700876948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下周也要继续加油~fighting~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 15:36:00 +0000</pubDate>
<dc:creator>小石学CS</dc:creator>
<og:description>Markov Networks for OCR 光学字符识别的马尔科夫网络 说到光学字符识别（OCR），此前笔者首先想到的会是卷积神经网络，而单词识别则会考虑使用递归神经网络。而本周的作业则基于马尔科</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/polaris-shi/p/9539548.html</dc:identifier>
</item>
<item>
<title>Kubernetes的简单部署 - (|^_^|||)</title>
<link>http://www.cnblogs.com/L-dongf/p/9539464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L-dongf/p/9539464.html</guid>
<description>&lt;h3 id=&quot;一基础环境配置&quot;&gt;一、基础环境配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;操作系统：CentOS 7.5，三台节点，1台master，2台nodes&lt;/li&gt;
&lt;li&gt;关闭selinux和firewalld&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# vim /etc/selinux/config
SELINUX=disabled
# setenforce 0
# systemctl stop firewalld
# systemctl disable firewalld&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置chronyd服务，保证各node时间同步（此处使用阿里巴巴提供的ntp时间服务器）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# yum install chrony
# vim /etc/chrony.conf
server ntp.aliyun.com iburst
stratumweight 0
driftfile /var/lib/chrony/drift
rtcsync
makestep 10 3
bindcmdaddress 127.0.0.1
bindcmdaddress ::1
keyfile /etc/chrony.keys
commandkey 1
generatecommandkey
logchange 0.5
logdir /var/log/chrony
# systemctl enable chronyd 
# systemctl start chronyd&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;基于ssh秘钥认证，并且基于域名解析&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# vim /etc/hosts
192.168.0.12    master.dongfei.tech master
192.168.0.13    node01.dongfei.tech node01
192.168.0.14    node02.dongfei.tech node02
[root@master ~]# ssh-keygen
[root@master ~]# ssh-copy-id -i .ssh/id_rsa.pub node01
[root@master ~]# ssh-copy-id -i .ssh/id_rsa.pub node02
[root@master ~]# scp /etc/hosts node01:/etc/
[root@master ~]# scp /etc/hosts node02:/etc/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;网络环境规划&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;节点网络：192.168.0.0/24（需要手动配置，推荐配置静态地址）&lt;/p&gt;
&lt;p&gt;Pod网络：10.244.0.0/16&lt;/p&gt;
&lt;p&gt;Service网络：10.96.0.0/12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;配置yum源&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# cd /etc/yum.repos.d/
[root@master yum.repos.d]# vim kubernetes.repo
[kubernetes]
name=Kubernetes Repo
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
gpgcheck=0
enabled=1
[root@master yum.repos.d]# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
[root@master yum.repos.d]# sed -i 's/gpgcheck=1/gpgcheck=0/g' docker-ce.repo  #注意，将gpgcheck改为0
[root@master yum.repos.d]# scp kubernetes.repo docker-ce.repo node01:/etc/yum.repos.d/
[root@master yum.repos.d]# scp kubernetes.repo docker-ce.repo node02:/etc/yum.repos.d/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二安装docker和kubernetes&quot;&gt;二、安装docker和kubernetes&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解决docker-ce依赖包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# wget https://mirrors.aliyun.com/centos-vault/7.3.1611/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm
[root@master ~]# yum -y localinstall container-selinux-2.9-4.el7.noarch.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;安装docker并配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install docker-ce -y
[root@node01 ~]# yum install docker-ce -y
[root@node02 ~]# yum install docker-ce -y
[root@master ~]# vim /usr/lib/systemd/system/docker.service
[Service]
Environment=&quot;HTTPS_PROXY=http://www.ik8s.io:10080&quot;
Environment=&quot;NO_PROXY=127.0.0.0/8&quot;
[root@master ~]# systemctl daemon-reload
[root@master ~]# systemctl start docker
[root@master ~]# systemctl enable docker
[root@master ~]# docker info
HTTPS Proxy: http://www.ik8s.io:10080
No Proxy: 127.0.0.0/8&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;确认bridge-nf-call-iptables参数的值为1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@master ~]# cat /proc/sys/net/bridge/bridge-nf-call-iptables
1&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在master节点上安装配置kubernetes&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install kubelet kubeadm kubectl -y
[root@master ~]# systemctl enable kubelet
[root@master ~]# vim /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;初始化master&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap
[root@master ~]# mkdir -p $HOME/.kube
[root@master ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
[root@master ~]# kubectl get cs  #如果此处状态非健康，请检查之前的操作
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-0               Healthy   {&quot;health&quot;: &quot;true&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;将以下信息记录下来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubeadm join 192.168.0.12:6443 --token vlqtub.4827hc5ga73c9q8c --discovery-token-ca-cert-hash sha256:88f3a75bc1eef8077e4a97736faba1696e25fd3bc86e8347904b1db23f796556&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;部署flannel&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
[root@master ~]# kubectl get nodes  #等待数分钟，状态为Ready即成功&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;ul&gt;&lt;li&gt;将master的各配置文件同步到各nodes&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# scp container-selinux-2.9-4.el7.noarch.rpm node01:
[root@master ~]# scp container-selinux-2.9-4.el7.noarch.rpm node02:
[root@master ~]# scp /usr/lib/systemd/system/docker.service node01:/usr/lib/systemd/system/docker.service
[root@master ~]# scp /usr/lib/systemd/system/docker.service node02:/usr/lib/systemd/system/docker.service
[root@master ~]# scp /etc/sysconfig/kubelet node01:/etc/sysconfig/kubelet
[root@master ~]# scp /etc/sysconfig/kubelet node02:/etc/sysconfig/kubelet&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在node01节点中安装配置kubernetes（node02相同操作）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@node01 ~]# yum localinstall container-selinux-2.9-4.el7.noarch.rpm -y
[root@node01 ~]# yum install docker-ce kubelet kubeadm -y
[root@node01 ~]# systemctl enable docker kubelet
[root@node01 ~]# systemctl daemon-reload
[root@node01 ~]# systemctl start docker
[root@node01 ~]# systemctl enable docker
[root@node01 ~]# docker info
HTTPS Proxy: http://www.ik8s.io:10080
No Proxy: 127.0.0.0/8
[root@node01 ~]# kubeadm join 192.168.0.12:6443 --token vlqtub.4827hc5ga73c9q8c --discovery-token-ca-cert-hash sha256:88f3a75bc1eef8077e4a97736faba1696e25fd3bc86e8347904b1db23f796556  --ignore-preflight-errors=Swap&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在master节点上查看集群状态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl get nodes
NAME                  STATUS    ROLES     AGE       VERSION
master.dongfei.tech   Ready     master    28m       v1.11.2
node01.dongfei.tech   Ready     &amp;lt;none&amp;gt;    3m        v1.11.2
node02.dongfei.tech   Ready     &amp;lt;none&amp;gt;    3m        v1.11.2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三kubectl的简单使用&quot;&gt;三、kubectl的简单使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建2个nginx的pod&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl run nginx-deploy --image=nginx:1.14-alpine --port=80 --replicas=2
deployment.apps/nginx-deploy created&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl get deployment
[root@master ~]# kubectl get pods
[root@master ~]# kubectl get pods -w
[root@master ~]# kubectl get pods -o wide
[root@master ~]# kubectl get pods --show-labels&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建Service&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看svc命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl get svc
[root@master ~]# kubectl get svc -n kube-system
[root@master ~]# kubectl describe svc nginx
[root@master ~]# kubectl run client --image=busybox --replicas=1 -it --restart=Never  #创建测试client
/ # wget -O - -q http://nginx:80/  #俩个pod实现负载均衡
Welcome to nginx!&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改svc，使其可以在集群外部访问&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl edit svc nginx
  type: NodePort
[root@master ~]# kubectl get svc nginx
NAME      TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
nginx     NodePort   10.98.231.135   &amp;lt;none&amp;gt;        80:30562/TCP   6m
外部访问：http://192.168.0.12:30562&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感谢阅读，未完待续。。。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 15:13:00 +0000</pubDate>
<dc:creator>(|^_^|||)</dc:creator>
<og:description>一、基础环境配置 操作系统：CentOS 7.5，三台节点，1台master，2台nodes 关闭selinux和firewalld 配置chronyd服务，保证各node时间同步（此处使用阿里巴巴提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/L-dongf/p/9539464.html</dc:identifier>
</item>
<item>
<title>消息队列1：消息队列概述 - 养码青年</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9539422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9539422.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最近在看消息队列，找了好多资料。终于能够简单的理解了消息队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;维基百科定义&quot;&gt;维基百科定义&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说实话，我看了也是一脸懵逼。下面结合具体的案例来分析下。&lt;/p&gt;
&lt;h3 id=&quot;案例说明&quot;&gt;案例说明&lt;/h3&gt;
&lt;blockquote readability=&quot;4.1176470588235&quot;&gt;
&lt;p&gt;下面内容参考自知乎上&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24860107&quot;&gt;祁达方&lt;/a&gt;的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;小红是小明的姐姐。&lt;/p&gt;
&lt;p&gt;小红希望小明多读书，常寻找好书给小明看，之前的方式是这样：小红问小明什么时候有空，把书给小明送去，并亲眼监督小明读完书才走。久而久之，两人都觉得麻烦。&lt;/p&gt;
&lt;p&gt;后来的方式改成了：小红对小明说「我放到书架上的书你都要看」，然后小红每次发现不错的书都放到书架上，小明则看到书架上有书就拿下来看。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;书架就是一个消息队列，小红是生产者，小明是消费者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180826223448.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Producer：消息生产者，负责产生和发送消息到 Broker；&lt;/li&gt;
&lt;li&gt;Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue；&lt;/li&gt;
&lt;li&gt;Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;消息队列的好处&quot;&gt;消息队列的好处&lt;/h4&gt;
&lt;p&gt;1.小红想给小明书的时候，不必问小明什么时候有空，亲手把书交给他了，小红只把书放到书架上就行了。这样小红小明的时间都更自由。&lt;/p&gt;
&lt;p&gt;2.小红相信小明的读书自觉和读书能力，不必亲眼观察小明的读书过程，小红只要做一个放书的动作，很节省时间。&lt;/p&gt;
&lt;p&gt;3.当明天有另一个爱读书的小伙伴小强加入，小红仍旧只需要把书放到书架上，小明和小强从书架上取书即可（唔，姑且设定成多个人取一本书可以每人取走一本吧，可能是拷贝电子书或复印，暂不考虑版权问题）。&lt;/p&gt;
&lt;p&gt;4.书架上的书放在那里，小明阅读速度快就早点看完，阅读速度慢就晚点看完，没关系，比起小红把书递给小明并监督小明读完的方式，小明的压力会小一些。&lt;/p&gt;
&lt;p&gt;这就是消息队列的四大好处：&lt;/p&gt;
&lt;h5 id=&quot;解耦&quot;&gt;解耦&lt;/h5&gt;
&lt;p&gt;每个成员不必受其他成员影响，可以更独立自主，只通过一个简单的容器来联系。&lt;/p&gt;
&lt;p&gt;小红甚至可以不知道从书架上取书的是谁，小明也可以不知道往书架上放书的人是谁，在他们眼里，都只有书架，没有对方。&lt;/p&gt;
&lt;p&gt;毫无疑问，与一个简单的容器打交道，比与复杂的人打交道容易一万倍，小红小明可以自由自在地追求各自的人生。&lt;/p&gt;
&lt;h5 id=&quot;提速&quot;&gt;提速&lt;/h5&gt;
&lt;p&gt;小红选择相信「把书放到书架上，别的我不问」，为自己节省了大量时间。&lt;/p&gt;
&lt;p&gt;小红很忙，只能抽出五分钟时间，但这时间足够把书放到书架上了。&lt;/p&gt;
&lt;h5 id=&quot;广播&quot;&gt;广播&lt;/h5&gt;
&lt;p&gt;小红只需要劳动一次，就可以让多个小伙伴有书可读，这大大地节省了她的时间，也让新的小伙伴的加入成本很低。&lt;/p&gt;
&lt;h5 id=&quot;削峰&quot;&gt;削峰&lt;/h5&gt;
&lt;p&gt;假设小明读书很慢，如果采用小红每给一本书都监督小明读完的方式，小明有压力，小红也不耐烦。&lt;/p&gt;
&lt;p&gt;反正小红给书的频率也不稳定，如果今明两天连给了五本，之后隔三个月才又给一本，那小明只要在三个月内从书架上陆续取走五本书读完就行了，压力就不那么大了。&lt;/p&gt;
&lt;h4 id=&quot;消息队列的缺点&quot;&gt;消息队列的缺点&lt;/h4&gt;
&lt;h5 id=&quot;引入复杂度&quot;&gt;引入复杂度&lt;/h5&gt;
&lt;p&gt;毫无疑问，「书架」这东西是多出来的，需要地方放它，还需要防盗。&lt;/p&gt;
&lt;h5 id=&quot;暂时的不一致性&quot;&gt;暂时的不一致性&lt;/h5&gt;
&lt;p&gt;假如妈妈问小红「小明最近读了什么书」，在以前的方式里，小红因为亲眼监督小明读完书了，可以底气十足地告诉妈妈，但新的方式里，小红回答妈妈之后会心想「小明应该会很快看完吧……」&lt;/p&gt;
&lt;p&gt;这中间存在着一段「妈妈认为小明看了某书，而小明其实还没看」的时期，当然，小明最终的阅读状态与妈妈的认知会是一致的，这就是所谓的「最终一致性」。&lt;/p&gt;
&lt;h4 id=&quot;消息队列的使用场景&quot;&gt;消息队列的使用场景&lt;/h4&gt;
&lt;h5 id=&quot;生产者不需要从消费者处获得反馈&quot;&gt;生产者不需要从消费者处获得反馈&lt;/h5&gt;
&lt;p&gt;引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走——即所谓异步——成为了可能。&lt;/p&gt;
&lt;p&gt;小红放完书之后小明到底看了没有，小红根本不问，她默认他是看了，否则就只能用原来的方法监督到看完了。&lt;/p&gt;
&lt;h5 id=&quot;容许短暂的不一致性&quot;&gt;容许短暂的不一致性&lt;/h5&gt;
&lt;p&gt;妈妈可能会发现「有时候据说小明看了某书，但事实上他还没看」，只要妈妈满意于「反正他最后看了就行」，异步处理就没问题。&lt;/p&gt;
&lt;p&gt;如果妈妈对这情况不能容忍，对小红大发雷霆，小红也就不敢用书架方式了。&lt;/p&gt;
&lt;h5 id=&quot;确实是用了有效果&quot;&gt;确实是用了有效果&lt;/h5&gt;
&lt;p&gt;即解耦、提速、广播、削峰这些方面的收益，超过放置书架、监控书架这些成本。&lt;/p&gt;
&lt;p&gt;否则如果是盲目照搬，「听说老赵家买了书架，咱们家也买一个」，买回来却没什么用，只是让步骤变多了，还不如直接把书递给对方呢，那就不对了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不得不佩服大牛的解释的这么通俗易懂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;[1]-祁达方:好书一起读(149)：消息队列(&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24860107&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/24860107&lt;/a&gt;)&lt;br/&gt;[2]-jasonGeng88:一个故事告诉你什么是消息队列 (&lt;a href=&quot;https://github.com/jasonGeng88/blog/blob/master/201705/MQ.md&quot; class=&quot;uri&quot;&gt;https://github.com/jasonGeng88/blog/blob/master/201705/MQ.md&lt;/a&gt;)&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 15:02:00 +0000</pubDate>
<dc:creator>养码青年</dc:creator>
<og:description>最近在看消息队列，找了好多资料。终于能够简单的理解了消息队列。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9539422.html</dc:identifier>
</item>
</channel>
</rss>