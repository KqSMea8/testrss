<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构4 链表的面试题 - nnngu</title>
<link>http://www.cnblogs.com/nnngu/p/8264766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnngu/p/8264766.html</guid>
<description>&lt;p&gt;&lt;strong&gt;这篇文章包含的链表面试题如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、从尾到头打印单向链表&lt;/p&gt;
&lt;p&gt;2、查找单向链表中的倒数第k个节点&lt;/p&gt;
&lt;p&gt;3、反转一个单向链表【出现频率较高】&lt;/p&gt;
&lt;p&gt;4、合并两个有序的单向链表，合并之后的链表依然有序【出现频率较高】&lt;/p&gt;
&lt;p&gt;5、找出两个单向链表相交的第一个公共节点&lt;/p&gt;

&lt;h2&gt;前期代码准备：&lt;/h2&gt;
&lt;p&gt;下面这两个类的详细解析可以参考我的上一篇文章：&lt;a title=&quot;数据结构3 线性表之链表&quot; href=&quot;http://www.cnblogs.com/nnngu/p/8252589.html&quot; target=&quot;_blank&quot;&gt;数据结构3 线性表之链表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;节点类：&lt;span&gt;Node.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 节点类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    Object element; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据域&lt;/span&gt;
    Node next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 地址域

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的构造方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(Object element, Node next) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.element =&lt;span&gt; element;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Gettet and Setter&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.next;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNext(Node next) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getElement() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.element;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setElement(Object element) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.element =&lt;span&gt; element;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;链表类：&lt;span&gt;MyLinkedList.java&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 自己定义的一个链表类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyLinkedList {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node headNode;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来遍历链表的临时节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node tempNode;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Getter&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getHeadNode() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; headNode;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Setter&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setHeadNode(Node headNode) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.headNode =&lt;span&gt; headNode;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表的初始化方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyLinkedList() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化时，链表里面只有1个节点，所以这个节点的地址域为null&lt;/span&gt;
        Node node = &lt;span&gt;new&lt;/span&gt; Node(&quot;王重阳&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头节点不存储数据，它的数据域为null，它的地址域存储了第1个节点的地址&lt;/span&gt;
        headNode = &lt;span&gt;new&lt;/span&gt; Node(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, node);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 1、插入节点：时间复杂度为O(n)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newNode 需要插入的新节点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; position 这个变量的范围可以从0到链表的长度，注意不要越界。
     *                 头节点不算进链表的长度，
     *                 所以从头节点后面的节点开始算起，position为0
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insert(Node newNode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过position变量，让tempNode节点从头节点开始遍历，移动到要插入位置的前一个位置&lt;/span&gt;
        tempNode =&lt;span&gt; headNode;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; position) {
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.next;
            i&lt;/span&gt;++&lt;span&gt;;
        }
        newNode.next &lt;/span&gt;=&lt;span&gt; tempNode.next;
        tempNode.next &lt;/span&gt;=&lt;span&gt; newNode;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 2、删除节点：时间复杂度为O(n)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; position
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里同样需要用tempNode从头开始向后查找position&lt;/span&gt;
        tempNode =&lt;span&gt; headNode;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; position) {
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.next;
            i&lt;/span&gt;++&lt;span&gt;;
        }
        tempNode.next &lt;/span&gt;=&lt;span&gt; tempNode.next.next;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 3、查找节点：时间复杂度为O(n)
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; position
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回查找的节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node find(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; position) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里同样需要用tempNode从头开始向后查找position&lt;/span&gt;
        tempNode =&lt;span&gt; headNode;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; position) {
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.next;
            i&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tempNode.next;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 4、获取链表的长度：时间复杂度为O(n)
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        tempNode &lt;/span&gt;=&lt;span&gt; headNode.next;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (tempNode.next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            size &lt;/span&gt;= size + 1&lt;span&gt;;
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.next;
        }
        size &lt;/span&gt;= size + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tempNode的地址域为null时，size记得加上最后一个节点&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表，打印出所有节点的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showAll() {
        tempNode &lt;/span&gt;=&lt;span&gt; headNode.next;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (tempNode.next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(tempNode.element);
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.next;
        }
        System.out.println(tempNode.element);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;1、从尾到头打印单向链表&lt;/h2&gt;
&lt;p&gt;对于这种颠倒顺序打印的问题，我们应该就会想到栈，&lt;strong&gt;后进先出&lt;/strong&gt;。因此这一题&lt;strong&gt;要么自己新建一个栈，要么使用系统的栈&lt;/strong&gt;（系统递归调用方法时的栈）。需要把链表遍历完一次，所以它的时间复杂度为 O(n)&lt;/p&gt;
&lt;p&gt;注意：不能先把链表反转，再遍历输出，因为这样做会破坏链表节点原来的顺序。&lt;/p&gt;
&lt;h3&gt;方法1：自己新建一个栈&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;QuestionOneDemo.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Stack;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuestionOneDemo {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从尾到头打印单向链表
     * 方法1：自己新建一个栈
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; head 参数为链表的头节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reversePrint(Node head) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断链表是否为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建一个栈&lt;/span&gt;
        Stack&amp;lt;Node&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;Node&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用来遍历的临时节点，从头节点开始&lt;/span&gt;
        Node tempNode =&lt;span&gt; head;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从头节点开始遍历链表，将除了头节点之外的所有节点压栈&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (tempNode.getNext() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.getNext();
            stack.push(tempNode);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将栈中的节点打印输出即可&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (stack.size() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出栈操作&lt;/span&gt;
            Node node =&lt;span&gt; stack.pop();
            System.out.println(node.getElement());
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来测试的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        MyLinkedList myLinkedList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyLinkedList();

        Node newNode1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;欧阳锋&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;黄药师&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;洪七公&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        myLinkedList.insert(newNode1, &lt;/span&gt;1&lt;span&gt;);
        myLinkedList.insert(newNode2, &lt;/span&gt;2&lt;span&gt;);
        myLinkedList.insert(newNode3, &lt;/span&gt;3&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;----原链表 start----&quot;&lt;span&gt;);
        myLinkedList.showAll();
        System.out.println(&lt;/span&gt;&quot;----原链表 end----&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;====从尾到头打印链表 start====&quot;&lt;span&gt;);
        reversePrint(myLinkedList.getHeadNode());
        System.out.println(&lt;/span&gt;&quot;====从尾到头打印链表 end====&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;----原链表(依然保留了原来的顺序) start----&quot;&lt;span&gt;);
        myLinkedList.showAll();
        System.out.println(&lt;/span&gt;&quot;----原链表(依然保留了原来的顺序) end----&quot;&lt;span&gt;);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180110204227222-83866717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;方法2：使用系统的栈（递归）&lt;/h3&gt;
&lt;p&gt;在 &lt;span&gt;QuestionOneDemo.java&lt;/span&gt; 中添加方法2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 从尾到头打印单向链表
     * 方法2：自己新建一个栈
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; head 参数为链表的头节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reversePrint2(Node head) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断传进来的参数节点是否为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归&lt;/span&gt;
&lt;span&gt;        reversePrint2(head.next);
        System.out.println(head.getElement());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试的方法和测试结果跟方法1一样，这里不再详细列出。&lt;/p&gt;
&lt;h3&gt;总结：  &lt;/h3&gt;
&lt;p&gt;方法2是基于递归实现的，代码看起来更简洁，但有一个问题：当链表很长的时候，就会导致方法调用的层级很深，有可能造成栈溢出。而方法1是自己新建一个栈，使用循环压栈和循环出栈，代码的稳健性要更好一些。&lt;/p&gt;
&lt;h2&gt;2、查找单向链表中的倒数第k个节点&lt;/h2&gt;
&lt;h3&gt; 2-1：普通思路&lt;/h3&gt;
&lt;p&gt;先将整个链表从头到尾遍历一次，计算出链表的长度size，得到链表的长度之后，就好办了，直接输出第 size-k 个节点就可以了（注意链表为空，k为0，k大于链表中节点个数的情况）。因为需要遍历两次链表，所以时间复杂度为 T(2n) = O(n)    &lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QuestionTwoDemo.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuestionTwoDemo {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找链表中的倒数第k个节点的方法
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; myLinkedList 需要查找的链表作为参数传递进来
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; k            代表倒数第k个节点的位置
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node reciprocalFindNode(MyLinkedList myLinkedList, &lt;span&gt;int&lt;/span&gt; k) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果头节点为null，说明链表为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (myLinkedList.getHeadNode() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;链表为空&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断k，k不能为0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (k == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;k不能为0&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次遍历，计算出链表的长度size&lt;/span&gt;
        Node tempNode =&lt;span&gt; myLinkedList.getHeadNode();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (tempNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            size&lt;/span&gt;++&lt;span&gt;;
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.getNext();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断k，k不能大于链表中节点的个数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (k &amp;gt;&lt;span&gt; size) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;k不能大于链表中节点的个数&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二次遍历，找出倒数第k个节点&lt;/span&gt;
        tempNode =&lt;span&gt; myLinkedList.getHeadNode();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size - k; i++&lt;span&gt;) {
            tempNode &lt;/span&gt;=&lt;span&gt; tempNode.getNext();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tempNode;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来测试的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MyLinkedList myLinkedList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyLinkedList();

        Node newNode1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;欧阳锋&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;黄药师&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;洪七公&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        myLinkedList.insert(newNode1, &lt;/span&gt;1&lt;span&gt;);
        myLinkedList.insert(newNode2, &lt;/span&gt;2&lt;span&gt;);
        myLinkedList.insert(newNode3, &lt;/span&gt;3&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;-----完整的链表start-----&quot;&lt;span&gt;);
        myLinkedList.showAll();
        System.out.println(&lt;/span&gt;&quot;-----完整的链表end-------&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        Node node &lt;/span&gt;= reciprocalFindNode(myLinkedList, 1&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;链表的倒数第1个节点是：&quot; +&lt;span&gt; node.getElement());

        node &lt;/span&gt;= reciprocalFindNode(myLinkedList, 2&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;链表的倒数第2个节点是：&quot; +&lt;span&gt; node.getElement());

        node &lt;/span&gt;= reciprocalFindNode(myLinkedList, 3&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;链表的倒数第3个节点是：&quot; +&lt;span&gt; node.getElement());

        node &lt;/span&gt;= reciprocalFindNode(myLinkedList, 4&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;链表的倒数第4个节点是：&quot; +&lt;span&gt; node.getElement());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180110223742785-740790315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果面试官不允许你遍历链表的长度，该怎么做？接下来的改进思路就是。&lt;/p&gt;

&lt;h3&gt; 2-2：改进思路&lt;/h3&gt;
&lt;p&gt;这里需要用到两个节点型的变量：即变量 first 和 second，首先让 first 和 second 都指向第一个节点，然后让 second 节点往后挪 k-1 个位置，此时 first 和 second 就间隔了 k-1 个位置，然后整体向后移动这两个节点，&lt;strong&gt;直到 second 节点走到最后一个节点时，此时 first 节点所指向的位置就是倒数第k个节点的位置&lt;/strong&gt;。时间复杂度为O(n)  &lt;/p&gt;
&lt;p&gt;步骤一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180110230533363-1489439941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180110230925801-687768212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤三：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180110231416394-1917286810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;p&gt;在 &lt;span&gt;QuestionTwoDemo.java&lt;/span&gt; 中添加方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查找链表中的倒数第k个节点的方法2
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; myLinkedList 需要查找的链表作为参数传递进来
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; k            代表倒数第k个节点的位置
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node reciprocalFindNode2(MyLinkedList myLinkedList, &lt;span&gt;int&lt;/span&gt; k) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果头节点为null，说明链表为空&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (myLinkedList.getHeadNode() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;链表为空&quot;&lt;span&gt;);
        }

        Node first &lt;/span&gt;=&lt;span&gt; myLinkedList.getHeadNode();
        Node second &lt;/span&gt;=&lt;span&gt; myLinkedList.getHeadNode();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让second节点往后挪 k-1 个位置&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; k - 1; i++&lt;span&gt;) {
            second &lt;/span&gt;=&lt;span&gt; second.getNext();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让first节点和second节点整体向后移动，直到second节点走到最后一个节点&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (second.getNext() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            first &lt;/span&gt;=&lt;span&gt; first.getNext();
            second &lt;/span&gt;=&lt;span&gt; second.getNext();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当second节点走到最后一个节点时，first节点就是我们要找的节点&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试的方法和测试结果跟前面的一样，这里不再详细列出。&lt;/p&gt;


&lt;h2&gt;3、反转一个单向链表&lt;/h2&gt;
&lt;p&gt;例如链表：&lt;/p&gt;
&lt;p&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4&lt;/p&gt;
&lt;p&gt;反转之后：&lt;/p&gt;
&lt;p&gt;4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;从头到尾遍历原链表的节点，每遍历一个节点，将它放在新链表&lt;span&gt;（实际上并没有创建新链表，这里用新链表来描述只是为了更方便的理解）&lt;/span&gt;的最前端。 时间复杂度为O(n)   &lt;/p&gt;
&lt;p&gt;（注意链表为空和只有一个节点的情况）&lt;/p&gt;
&lt;p&gt;示意图一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180111011445769-843276363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;示意图二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180111011315051-3060918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;示意图三：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180111011114847-769974846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如此类推。。。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;QuestionThreeDemo.java&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QuestionThreeDemo {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 反转一个单向链表的方法
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; myLinkedList
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reverseList(MyLinkedList myLinkedList) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断链表是否为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (myLinkedList == &lt;span&gt;null&lt;/span&gt; || myLinkedList.getHeadNode() == &lt;span&gt;null&lt;/span&gt; || myLinkedList.getHeadNode().getNext() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&quot;链表为空&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断链表里是否只有一个节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (myLinkedList.getHeadNode().getNext().getNext() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表里只有一个节点，不用反转&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tempNode 从头节点后面的第一个节点开始往后移动&lt;/span&gt;
        Node tempNode =&lt;span&gt; myLinkedList.getHeadNode().getNext();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点的下一个节点&lt;/span&gt;
        Node nextNode = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反转后新链表的头节点&lt;/span&gt;
        Node newHeadNode = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表，每遍历到一个节点都把它放到链表的头节点位置&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (tempNode.getNext() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把tempNode在旧链表中的下一个节点暂存起来&lt;/span&gt;
            nextNode =&lt;span&gt; tempNode.getNext();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置tempNode在新链表中作为头节点的next值&lt;/span&gt;
&lt;span&gt;            tempNode.setNext(newHeadNode);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新newHeadNode的值，下一次循环需要用&lt;/span&gt;
            newHeadNode =&lt;span&gt; tempNode;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新头节点&lt;/span&gt;
&lt;span&gt;            myLinkedList.setHeadNode(newHeadNode);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tempNode往后移动一个位置&lt;/span&gt;
            tempNode =&lt;span&gt; nextNode;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旧链表的最后一个节点的next为null，要把该节点的next设置为新链表的第二个节点&lt;/span&gt;
&lt;span&gt;        tempNode.setNext(newHeadNode);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后把它放到新链表的第一个节点的位置&lt;/span&gt;
&lt;span&gt;        myLinkedList.setHeadNode(tempNode);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建一个新链表的头节点&lt;/span&gt;
        newHeadNode = &lt;span&gt;new&lt;/span&gt; Node(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, tempNode);
        myLinkedList.setHeadNode(newHeadNode);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来测试的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        MyLinkedList myLinkedList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyLinkedList();

        Node newNode1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;欧阳锋&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;黄药师&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        Node newNode3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;洪七公&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        myLinkedList.insert(newNode1, &lt;/span&gt;1&lt;span&gt;);
        myLinkedList.insert(newNode2, &lt;/span&gt;2&lt;span&gt;);
        myLinkedList.insert(newNode3, &lt;/span&gt;3&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;-----完整的链表start-----&quot;&lt;span&gt;);
        myLinkedList.showAll();
        System.out.println(&lt;/span&gt;&quot;-----完整的链表end-------&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;-----反转之后的链表start-----&quot;&lt;span&gt;);
        reverseList(myLinkedList);
        myLinkedList.showAll();
        System.out.println(&lt;/span&gt;&quot;-----反转之后的链表end-------&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1313428/201801/1313428-20180111023452863-1647802189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4、合并两个有序的单向链表，合并之后的链表依然有序&lt;/h2&gt;

&lt;h2&gt;5、找出两个单向链表相交的第一个公共节点&lt;/h2&gt;


&lt;p&gt;欢迎转载，但请保留文章原始出处&lt;/p&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;http://www.cnblogs.com/nnngu/p/8264766.html&quot;&gt;http://www.cnblogs.com/nnngu/p/8264766.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 10 Jan 2018 18:38:00 +0000</pubDate>
<dc:creator>nnngu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnngu/p/8264766.html</dc:identifier>
</item>
<item>
<title>Java学习笔记20---内部类之对成员内部类的补充说明(一) - 蝉蝉</title>
<link>http://www.cnblogs.com/chanchan/p/8254124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanchan/p/8254124.html</guid>
<description>&lt;p&gt;上篇文章--&lt;a href=&quot;http://www.cnblogs.com/chanchan/p/8235169.html%20&quot; target=&quot;_blank&quot;&gt;笔记19&lt;/a&gt;简要介绍了成员内部类、局部内部类和匿名内部类，下面对成员内部类再补充一些内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要有以下6点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.成员内部类不可以有静态成员，成员变量为static final时除外&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.外部类不可以直接访问成员内部类的成员变量或调用成员内部类的成员方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.成员内部类可以无限制的访问外部类的成员变量、调用外部类的成员方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.成员内部类的成员与外部类成员同名时，内部类成员会屏蔽外部类的同名成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.成员内部类本身可以由访问权限修饰符修饰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.成员内部类的成员变量和成员方法也可以由访问权限修饰符修饰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; （注：时间有点晚了，5、6条下篇再写吧）&lt;/p&gt;

&lt;p&gt;作者： 蝉蝉&lt;/p&gt;
&lt;p&gt;请尊重作者劳动成果，转载请在标题注明“转载”字样，并标明原文链接：&lt;/p&gt;
&lt;p&gt; &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Java学习笔记20---内部类之对成员内部类的补充说明&quot; href=&quot;http://www.cnblogs.com/chanchan/p/8254124.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/chanchan/p/8254124.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面分别展开说明：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.成员内部类不可以有静态成员，成员变量为static final除外&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记19：内部类--成员内部类--不能有静态成员，成员变量为static final时除外&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String name = &quot;li&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        String inname;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; String ingender = &quot;female&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能有静态成员，除非声明为static final&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStFi() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             System.out.println(&quot;ingender:&quot; +&lt;span&gt; ingender);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能有静态成员方法&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStFiMeth() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             System.out.println(&quot;成员内部类的静态成员方法&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         Person per = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Person.InnerClass inC = per.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记19：内部类--成员内部类--4不能有静态成员，除非声明为static final&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        inC.testStFi();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编译时会报出下面的错误：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problems: &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;The field ingender cannot be declared static in a non-static inner type, unless initialized with a constant expression&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;The method testStFiMeth cannot be declared static; static methods can only be declared in a static or top level type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;(1).根据错误提示，成员内部类不能有静态成员变量，除非该成员由常量表达式初始化；&lt;/p&gt;
&lt;p&gt;      大家知道，由static final修饰的成员变量其值不可改变，&lt;strong&gt;是编译时常量，&lt;/strong&gt;所以把&lt;/p&gt;
&lt;p&gt;　　      &lt;strong&gt;static&lt;/strong&gt; String ingender = &quot;female&quot;;&lt;/p&gt;
&lt;p&gt;      改为：&lt;/p&gt;
&lt;p&gt;　　     &lt;strong&gt; static final &lt;/strong&gt;String ingender = &quot;female&quot;;&lt;/p&gt;
&lt;p&gt;      再编译就可以通过了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2).成员内部类为什么不可以有静态成员变量呢？&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;      1).对于外部类来说，&lt;strong&gt;当类尚未加载时，访问静态成员变量或创建一个对象都可以引起类的加载&lt;/strong&gt;，而类加载时就会为静态成员变量分配空间。访问其静态成员变量时，如果类尚未加载，则会先加载类，并为静态成员变量分配空间，然后就可以访问了；如果类已经加载过了，说明静态成员变量已经分配过内存了，直接访问就可以了。所以，外部类不论什么情况下都可以正确的访问其静态成员变量。（参考&lt;a href=&quot;http://www.cnblogs.com/chanchan/p/7770010.html&quot; target=&quot;_blank&quot;&gt;笔记11&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;      2).而对于成员内部类来说，外部类加载时，并不会被自动加载；&lt;strong&gt;只有外部类的一个对象在首次创建成员内部类的对象时，才会引起成员内部类的加载。&lt;/strong&gt;假设成员内部类有静态成员变量，如果在成员内部类加载之前就需要访问其静态成员变量呢？很显然，在类加载之前，其静态成员变量是未分配内存的，这时候&lt;strong&gt;要访问的是一个并不存在的变量，就会出错。&lt;/strong&gt;所以，成员内部类是不能有静态成员变量及静态成员方法的（道理类似）。&lt;/p&gt;
&lt;p&gt;      参考图片更直观：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1234147/201801/1234147-20180111012002832-1734120062.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3).延伸：外部类与成员内部类的加载方式和父类与子类之间的加载方式是不一样的&lt;/p&gt;
&lt;p&gt;      1).成员内部类与外部类是附属与被附属的关系，必须通过外部类对象来创建成员内部类的对象，所以可以先加载外部类，等需要的时候再加载成员内部类。且一个外部类对象可以创建多个内部类对象，是一对多的关系。最近每天睡觉前小姑娘都要听“泥娃娃”，“泥娃娃，泥娃娃，一个泥娃娃，一样的眉毛，一样的眼睛，眼睛不会眨...”。泥娃娃像人一样，但又比人少了点什么，就把人看成外部类，泥娃娃就是人的成员内部类，哈哈，人创造了泥娃娃，而且可以创造多种多样的泥娃娃。&lt;/p&gt;
&lt;p&gt;      2).而子类与父类是is-a的关系，两个类相互独立，但可以看成子类对象里隐含了一个父类对象。首次使用子类时，要先加载父类并为其静态成员变量分配内存，再加载子类并为其静态成员变量分配内存，然后依次初始化成员变量，调用构造方法等等（可参考笔记11）。所以这里父类子、类都要加载。&lt;/p&gt;
&lt;p&gt;      几者的关系见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1234147/201801/1234147-20180111011918316-1646045364.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.外部类不可以直接访问成员内部类的成员变量或调用成员内部类的成员方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;类Person中定义了一个成员内部类InnerClass，Person的成员方法outerCAccessinC访问InnerClass的成员变量inname。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成员内部类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String name = &quot;li&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        String inname;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;    　　 &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printInC() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             System.out.println(&quot;inner class&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记19：内部类--成员内部类--外部类能访问内部类成员变量、调用成员方法吗？&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outerCAccessinC() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.println(&quot;inname:&quot; +&lt;span&gt; inname);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         Person per = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记19：内部类--成员内部类--外部类不能访问内部类成员变量或调用成员方法&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        per.outerCAccessinC();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        per.printInC();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果出现下述错误：&lt;/p&gt;
&lt;p&gt;  第13行提示如下的错误：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;inname cannot be resolved to a variable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  22行提示如下的错误：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;The method printInC() is undefined for the type Person&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这说明外部类是无法直接访问成员内部类的成员变量或成员方法的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;反面来看，假如外部类可以直接访问成员内部类的成员，还以上面的程序为例，创建一个Person类对象per，per调用方法outerCAccessinC，由于这时尚未创建成员内部类的对象，其成员变量当然也没有分配空间，这时per将访问一个不存在的变量inname，这是不允许的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以成员内部类的成员对外部类是不可见的，外部类是无法直接访问成员内部类的成员的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.成员内部类可以无限制访问外部类的成员变量及调用外部类的成员方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 示例：&lt;/p&gt;
&lt;p&gt;类Person定义了若干个成员变量及一个成员内部类InnerClass。成员内部类InnerClass中定义了成员方法testVarMeth，testVarMeth访问及调用了外部类Person的多个成员变量和成员方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    String name;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    String gender;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String education; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;防问权限修饰符&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String hobby;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String residence;
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; String citizenship = &quot;Chinese&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testVarMeth() {
            System.out.println(&lt;/span&gt;&quot;name:&quot; +&lt;span&gt; name);
            System.out.println(&lt;/span&gt;&quot;education:&quot; +&lt;span&gt; education);
            System.out.println(&lt;/span&gt;&quot;hobby:&quot; +&lt;span&gt; hobby);
            System.out.println(&lt;/span&gt;&quot;residence:&quot; +&lt;span&gt; residence);
            System.out.println(&lt;/span&gt;&quot;citizenship:&quot; +&lt;span&gt; citizenship);
            System.out.println(&lt;/span&gt;&quot;age:&quot; +&lt;span&gt; getAge());
            System.out.println(&lt;/span&gt;&quot;gender:&quot; +&lt;span&gt; getGender());
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        
        Person per &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
        Person.InnerClass inC &lt;/span&gt;= per.&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InnerClass();
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;笔记19：内部类--成员内部类--内部类访问外部类成员变量、调用成员方法&lt;/span&gt;
&lt;span&gt;        inC.testVarMeth();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
name:&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
education:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
hobby:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
residence:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
citizenship:Chinese
age:&lt;/span&gt;0&lt;span&gt;
gender:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从结果可以看出，&lt;strong&gt;成员内部类可以随意访问或调用外部类的成员变量或成员方法，与访问权限及类型等都没有关系。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.成员内部类的成员与外部类成员同名时，内部类成员会屏蔽外部类的同名成员&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 示例：&lt;/p&gt;
&lt;p&gt;对2中的程序稍加修改，为成员内部类InnerClass添加一个与Person同名的成员变量name：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String name = &quot;li&quot;;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;再执行程序的话，输出结果变为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;name:li
education:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
hobby:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
residence:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
citizenship:Chinese
age:&lt;/span&gt;0&lt;span&gt;
gender:&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看出，&lt;strong&gt;如果成员内部类与外部类有同名的成员的话，成员内部类内部会屏蔽掉外部类的同名成员，也即，外部类的同名成员对成员内部类是不可见的。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 17:36:00 +0000</pubDate>
<dc:creator>蝉蝉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanchan/p/8254124.html</dc:identifier>
</item>
<item>
<title>用深度学习（DNN）构建推荐系统 - Deep Neural Networks for YouTube Recommendations论文精读 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8262025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8262025.html</guid>
<description>&lt;p&gt;虽然国内必须FQ才能登录YouTube，但想必大家都知道这个网站。基本上算是世界范围内视频领域的最大的网站了，坐拥10亿量级的用户，网站内的视频推荐自然是一个非常重要的功能。本文就focus在YouTube视频推荐的DNN算法，文中不但详细介绍了Youtube推荐算法和架构细节，还给了不少practical lessons and insights，很值得精读一番。下图便是YouTube APP视频推荐的一个例子。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/50/v2-f03b9d3ac0cb6a7c5d9ababbdbaa68b7_hd.jpg&quot; alt=&quot;&quot; width=&quot;1028&quot; data-rawwidth=&quot;1028&quot; data-rawheight=&quot;878&quot; data-original=&quot;https://pic2.zhimg.com/v2-f03b9d3ac0cb6a7c5d9ababbdbaa68b7_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f03b9d3ac0cb6a7c5d9ababbdbaa68b7_b.jpg&quot;/&gt;在推荐系统领域，特别是YouTube的所在视频推荐领域，主要面临三个挑战：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;规模大：用户和视频的数量都很大，只能适应小规模数据集的算法就不考虑了。&lt;/li&gt;
&lt;li&gt;更新快：youtube视频更新频率很高，每秒有小时级别的视频上传，需要在新发布视频和已有存量视频间进行balance。更新快（实时性）的另一方面的体现是用户实时行为切换很快，模型需要很好的追踪用户的实时行为。&lt;/li&gt;
&lt;li&gt;噪音：噪音主要体现在用户的历史行为往往是稀疏的并且是不完整的，并且没有一个明确的ground truth的满意度signal，我们面对的都是noisy implicit feedback signals。噪音另一个方面就是视频本身很多数据都是非结构化的。这两点对算法的鲁棒性提出了很高的挑战。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;之所以要在推荐系统中应用DNN解决问题，一个重要原因是google内部在机器学习问题上的通用solution的趋势正转移到Deep learning，系统实际部署在基于tensorflow的Google Brain上。&lt;/p&gt;
&lt;p&gt;一、系统概览&lt;/p&gt;
&lt;p&gt;在工业界工作的同学对下图的系统划分并不陌生。整个推荐系统分为candidate generation（淘宝称为Matching，后面用Matching代替）和Ranking两个阶段。Matching阶段通过i2i/u2i/u2u/user profile等方式“粗糙”的召回候选商品，Matching阶段视频的数量是百级别了；Ranking阶段对Matching后的视频采用更精细的特征计算user-item之间的排序分，作为最终输出推荐结果的依据。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/50/v2-533f102bd97b2b8cdf25639cfb0ab3e9_hd.jpg&quot; alt=&quot;&quot; width=&quot;910&quot; data-rawwidth=&quot;910&quot; data-rawheight=&quot;686&quot; data-original=&quot;https://pic1.zhimg.com/v2-533f102bd97b2b8cdf25639cfb0ab3e9_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-533f102bd97b2b8cdf25639cfb0ab3e9_b.jpg&quot;/&gt;之所以把推荐系统划分成Matching和Ranking两个阶段，主要是从性能方面考虑的。Matching阶段面临的是百万级视频，单个视频的性能开销必须很小；而Ranking阶段的算法则非常消耗资源，不可能对所有视频都算一遍，实际上即便资源充足也完全没有必要，因为往往来说通不过Matching粗选的视频，大部分在Ranking阶段排名也很低。接下来分别从Matching和Ranking阶段展开介绍。&lt;/p&gt;

&lt;p&gt;二、Matching&lt;/p&gt;
&lt;p&gt;2.1 问题建模&lt;/p&gt;
&lt;p&gt;我们把推荐问题建模成一个“超大规模多分类”问题。即在时刻&lt;img src=&quot;http://www.zhihu.com/equation?tex=t&quot; alt=&quot;t&quot;/&gt;，为用户&lt;img src=&quot;http://www.zhihu.com/equation?tex=U&quot; alt=&quot;U&quot;/&gt;（上下文信息&lt;img src=&quot;http://www.zhihu.com/equation?tex=C&quot; alt=&quot;C&quot;/&gt;）在视频库&lt;img src=&quot;http://www.zhihu.com/equation?tex=V&quot; alt=&quot;V&quot;/&gt;中精准的预测出视频&lt;img src=&quot;http://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;的类别（每个具体的视频视为一个类别，&lt;img src=&quot;http://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;即为一个类别），用数学公式表达如下：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/50/v2-adde74b978b971e588c002038c390e0b_hd.jpg&quot; alt=&quot;&quot; width=&quot;1030&quot; data-rawwidth=&quot;1030&quot; data-rawheight=&quot;112&quot; data-original=&quot;https://pic4.zhimg.com/v2-adde74b978b971e588c002038c390e0b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-adde74b978b971e588c002038c390e0b_b.jpg&quot;/&gt;很显然上式为一个softmax多分类器的形式。向量&lt;img src=&quot;http://www.zhihu.com/equation?tex=u%5Cin+R%5EN&quot; alt=&quot;u\in R^N&quot;/&gt;是&amp;lt;user, context&amp;gt;信息的高纬“embedding”，而向量&lt;img src=&quot;http://www.zhihu.com/equation?tex=v_%7Bj%7D%5Cin+R%5EN&quot; alt=&quot;v_{j}\in R^N&quot;/&gt;则是视频 j 的embedding向量。所以DNN的目标就是在用户信息和上下文信息为输入条件下学习用户的embedding向量&lt;img src=&quot;http://www.zhihu.com/equation?tex=u&quot; alt=&quot;u&quot;/&gt;。用公式表达DNN就是在拟合函数&lt;img src=&quot;http://www.zhihu.com/equation?tex=u+%3D+f_%7BDNN%7D%28user_info%2C+context_info%29&quot; alt=&quot;u = f_{DNN}(user_info, context_info)&quot;/&gt;。&lt;/p&gt;

&lt;p&gt;而这种超大规模分类问题上，至少要有几百万个类别，实际训练采用的是Negative Sampe，类似于word2vec的Skip-Gram方法，类似我专栏的第一篇文章 &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/24339183?refer=deeplearning-surfing&quot;&gt;DNN论文分享 - Item2vec: Neural Item Embedding for Collaborative Filtering&lt;/a&gt; 的item-embedding用的方法。&lt;/p&gt;
&lt;p&gt;2.2 模型架构&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/50/v2-7f97ddd40285e08b64546e3a54a5d64a_hd.jpg&quot; alt=&quot;&quot; width=&quot;1590&quot; data-rawwidth=&quot;1590&quot; data-rawheight=&quot;998&quot; data-original=&quot;https://pic2.zhimg.com/v2-7f97ddd40285e08b64546e3a54a5d64a_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7f97ddd40285e08b64546e3a54a5d64a_b.jpg&quot;/&gt;整个模型架构是包含三个隐层的DNN结构。输入是用户浏览历史、搜索历史、人口统计学信息和其余上下文信息concat成的输入向量；输出分线上和离线训练两个部分。&lt;/p&gt;
&lt;p&gt;离线训练阶段输出层为softmax层，输出2.1公式表达的概率。而线上则直接利用user向量查询相关商品，最重要问题是在性能。我们利用类似局部敏感哈希（Locality Sensitive Hashing，不展开介绍了，感兴趣的同学可以读读这篇论文 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=http%3A//papers.nips.cc/paper/2666-an-investigation-of-practical-approximate-nearest-neighbor-algorithms.pdf&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;An Investigation of Practical Approximate Nearest Neighbor Algorithms&lt;/a&gt;）的算法为用户提供最相关的N个视频。&lt;/p&gt;
&lt;p&gt;2.3 主要特征&lt;/p&gt;
&lt;p&gt;类似于word2vec的做法，每个视频都会被embedding到固定维度的向量中。用户的观看视频历史则是通过变长的视频序列表达，最终通过加权平均（可根据重要性和时间进行加权）得到固定维度的watch vector作为DNN的输入。&lt;/p&gt;
&lt;p&gt;除历史观看视频外的其他signal：&lt;/p&gt;
&lt;p&gt;其实熟悉Skip-Gram方法的同学很容易看出来，2.1把推荐问题定义为“超大规模多分类”问题的数学公式和word2vec的Skip-Gram方法的公式基本相同，所不同的是user_vec是通过DNN学习到的，而引入DNN的好处则是任意的连续特征和离散特征可以很容易添加到模型当中。同样的，推荐系统常用的矩阵分解方法虽然也能得到user_vec和item_vec，但同样是不能嵌入更多feature。&lt;/p&gt;
&lt;p&gt;主要特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;历史搜索query：把历史搜索的query分词后的token的embedding向量进行加权平均，能够反映用户的整体搜索历史状态&lt;/li&gt;
&lt;li&gt;人口统计学信息：性别、年龄、地域等&lt;/li&gt;
&lt;li&gt;其他上下文信息：设备、登录状态等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;“Example Age” （视频上传时间）特征&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;视频网络的时效性是很重要的，每秒YouTube上都有大量新视频被上传，而对用户来讲，哪怕牺牲相关性代价，用户还是更倾向于更新的视频。当然我们不会单纯的因为一个视频新就直接推荐给用户。&lt;/p&gt;
&lt;p&gt;因为机器学习系统在训练阶段都是利用过去的行为预估未来，因此通常对过去的行为有个隐式的bias。视频网站视频的分布是高度非静态（non-stationary）的，但我们的推荐系统产生的视频集合在视频的分布，基本上反映的是训练所取时间段的平均的观看喜好的视频。因此我们我们把样本的 “age” 作为一个feature加入模型训练中。从下图可以很清楚的看出，加入“example age” feature后和经验分布更为match。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/50/v2-83f523875baab074b340b6ccea2eba02_hd.jpg&quot; alt=&quot;&quot; width=&quot;992&quot; data-rawwidth=&quot;992&quot; data-rawheight=&quot;594&quot; data-original=&quot;https://pic2.zhimg.com/v2-83f523875baab074b340b6ccea2eba02_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-83f523875baab074b340b6ccea2eba02_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.4 label and context selection&lt;/p&gt;
&lt;p&gt;在有监督学习问题中，最重要的选择是label了，因为label决定了你做什么，决定了你的上限，而feature和model都是在逼近label。我们的几个设计如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用更广的数据源：不仅仅使用推荐场景的数据进行训练，其他场景比如搜索等的数据也要用到，这样也能为推荐场景提供一些explore。&lt;/li&gt;
&lt;li&gt;为每个用户生成固定数量训练样本：我们在实际中发现的一个practical lessons，如果为每个用户固定样本数量上限，平等的对待每个用户，避免loss被少数active用户domanate，能明显提升线上效果。&lt;/li&gt;
&lt;li&gt;抛弃序列信息：我们在实现时尝试的是去掉序列信息，对过去观看视频/历史搜索query的embedding向量进行加权平均。这点其实违反直觉，可能原因是模型对负反馈没有很好的建模。&lt;/li&gt;
&lt;li&gt;不对称的共同浏览（asymmetric co-watch）问题：所谓asymmetric co-watch值的是用户在浏览视频时候，往往都是序列式的，开始看一些比较流行的，逐渐找到细分的视频。下图所示图(a)是hled-out方式，利用上下文信息预估中间的一个视频；图(b)是predicting next watch的方式，则是利用上文信息，预估下一次浏览的视频。我们发现图(b)的方式在线上A/B test中表现更佳。&lt;em&gt;而实际上，传统的协同过滤类的算法，都是隐含的采用图(a)的held-out方式，忽略了不对称的浏览模式。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/50/v2-4c34494e753fa7ad6525f3533db31147_hd.jpg&quot; alt=&quot;&quot; width=&quot;1674&quot; data-rawwidth=&quot;1674&quot; data-rawheight=&quot;482&quot; data-original=&quot;https://pic2.zhimg.com/v2-4c34494e753fa7ad6525f3533db31147_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4c34494e753fa7ad6525f3533db31147_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.4 不同网络深度和特征的实验&lt;/p&gt;
&lt;p&gt;简单介绍下我们的网络构建过程，采用的经典的“tower”模式搭建网络，基本同2.2所示的网络架构，所有的视频和search token都embedded到256维的向量中，开始input层直接全连接到256维的softmax层，依次增加网络深度（+512--&amp;gt;+1024--&amp;gt;+2048--&amp;gt; ...）。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/50/v2-1d5006249332a8c98b6731cb0f8c45a4_hd.jpg&quot; alt=&quot;&quot; width=&quot;914&quot; data-rawwidth=&quot;914&quot; data-rawheight=&quot;338&quot; data-original=&quot;https://pic3.zhimg.com/v2-1d5006249332a8c98b6731cb0f8c45a4_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1d5006249332a8c98b6731cb0f8c45a4_b.jpg&quot;/&gt;下图反映了不同网络深度（横坐标）下不同特征组合情况下的holdout-MAP（纵坐标）。可以很明显看出，增加了观看历史之外的特征很明显的提升了预测得准确率；从网络深度看，随着网络深度加大，预测准确率在提升，但继续增加第四层网络已经收益不大了。&lt;br/&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/50/v2-5b6b9563aa2e8f21518fc5cfad04c1d0_hd.jpg&quot; alt=&quot;&quot; width=&quot;896&quot; data-rawwidth=&quot;896&quot; data-rawheight=&quot;826&quot; data-original=&quot;https://pic4.zhimg.com/v2-5b6b9563aa2e8f21518fc5cfad04c1d0_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-5b6b9563aa2e8f21518fc5cfad04c1d0_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、Ranking&lt;/p&gt;
&lt;p&gt;Ranking阶段的最重要任务就是精准的预估用户对视频的喜好程度。不同于Matching阶段面临的是百万级的候选视频集，Ranking阶段面对的只是百级别的商品集，因此我们可以&lt;em&gt;使用更多更精细的feature&lt;/em&gt;来刻画视频（item）以及用户与视频（user-item）的关系。比如用户可能很喜欢某个视频，但如果list页的用的“缩略图”选择不当，用户也许不会点击，等等。&lt;/p&gt;
&lt;p&gt;此外，Matching阶段的来源往往很多，没法直接比较。Ranking阶段另一个关键的作用是能够把不同来源的数据进行有效的ensemble。&lt;/p&gt;
&lt;p&gt;在目标的设定方面，单纯CTR指标是有迷惑性的，有些靠关键词吸引用户高点击的视频未必能够被播放。因此设定的目标基本与期望的观看时长相关，具体的目标调整则根据线上的A/B进行调整。&lt;/p&gt;
&lt;p&gt;3.1 模型架构&lt;/p&gt;
&lt;p&gt;Ranking阶段的模型和Matching基本相似，不同的是training最后一层是一个weighted LR层，而serving阶段激励函数用的是&lt;img src=&quot;http://www.zhihu.com/equation?tex=e%5E%7Bx%7D+&quot; alt=&quot;e^{x} &quot;/&gt;，具体在3.3阐述。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/50/v2-33f93002d2d7f42f50e617e03ef659bd_hd.jpg&quot; alt=&quot;&quot; width=&quot;1560&quot; data-rawwidth=&quot;1560&quot; data-rawheight=&quot;804&quot; data-original=&quot;https://pic4.zhimg.com/v2-33f93002d2d7f42f50e617e03ef659bd_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-33f93002d2d7f42f50e617e03ef659bd_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2 特征表达&lt;/p&gt;
&lt;p&gt;a). Feature Engineering：&lt;/p&gt;
&lt;p&gt;尽管深度学习在图像、语音和NLP等场景都能实现end-to-end的训练，没有了人工特征工程工作。然而在搜索和推荐场景，我们的很难吧原始数据直接作为FNN的输入，&lt;em&gt;特征工程仍然很重要&lt;/em&gt;。而特征工程中最难的是如何建模用户时序行为（&lt;em&gt;temporal sequence of user actions&lt;/em&gt;），并且关联这些行为和要rank的item。&lt;/p&gt;
&lt;p&gt;我们发现最重要的Signal是描述用户与商品本身或相似商品之间交互的Signal，这与Facebook在14年提出LR+GBDT模型的paper（&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//pdfs.semanticscholar.org/daf9/ed5dc6c6bad5367d7fd8561527da30e9b8dd.pdf&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Practical Lessons from Predicting Clicks on Ads at Facebook&lt;/a&gt;）中得到的结论是一致的。比如我们要度量用户对视频的喜欢，可以考虑用户与视频所在频道间的关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数量特征：浏览该频道的次数？&lt;/li&gt;
&lt;li&gt;时间特征：比如最近一次浏览该频道距离现在的时间？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两个连续特征的最大好处是具备非常强的泛化能力。另外除了这两个偏正向的特征，用户对于视频所在频道的一些PV但不点击的行为，即负反馈Signal同样非常重要。&lt;/p&gt;
&lt;p&gt;另外，我们还发现，把Matching阶段的信息传播到Ranking阶段同样能很好的提升效果，比如推荐来源和所在来源的分数。&lt;/p&gt;
&lt;p&gt;b). Embedding Categorical Features&lt;/p&gt;
&lt;p&gt;NN更适合处理连续特征，因此稀疏的特别是高基数空间的离散特征需要embedding到稠密的向量中。每个维度（比如query/user_id）都有独立的embedding空间，一般来说空间的维度基本与log(去重后值得数量)相当。实际并非为所有的id进行embedding，比如视频id，只需要按照点击排序，选择top N视频进行embedding，其余置为0向量。而对于像“过去点击的视频”这种multivalent特征，与Matching阶段的处理相同，进行加权平均即可。&lt;/p&gt;
&lt;p&gt;另外一个值得注意的是，同维度不同feature采用的相同ID的embedding是共享的（比如“过去浏览的视频id” “seed视频id”），这样可以大大加速训练，但显然输入层仍要分别填充。&lt;/p&gt;
&lt;p&gt;c). Normalizing Continuous Features&lt;/p&gt;
&lt;p&gt;众所周知，NN对输入特征的尺度和分布都是非常敏感的，实际上基本上除了Tree-Based的模型（比如GBDT/RF），机器学习的大多算法都如此。我们发现归一化方法对收敛很关键，推荐一种排序分位归一到[0,1]区间的方法，即&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cbar%7Bx%7D%3D%5Cint_%7B-%5Cinfty+%7D%5E%7Bx%7Ddf++&quot; alt=&quot;\bar{x}=\int_{-\infty }^{x}df &quot;/&gt;，累计分位点。&lt;/p&gt;
&lt;p&gt;除此之外，我们还把归一化后的&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cbar%7Bx%7D+&quot; alt=&quot;\bar{x} &quot;/&gt;的根号&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Csqrt%7Bx%7D+&quot; alt=&quot;\sqrt{x} &quot;/&gt;和平方&lt;img src=&quot;http://www.zhihu.com/equation?tex=x%5E%7B2%7D+&quot; alt=&quot;x^{2} &quot;/&gt;作为网络输入，以期能使网络能够更容易得到特征的次线性（sub-linear）和（super-linear）超线性函数。&lt;/p&gt;
&lt;p&gt;3.3 建模期望观看时长&lt;/p&gt;
&lt;p&gt;我们的目标是预测期望观看时长。有点击的为正样本，有PV无点击的为负样本，正样本需要根据观看时长进行加权。因此，我们训练阶段网络最后一层用的是 weighted logistic regression。&lt;/p&gt;
&lt;p&gt;正样本的权重为观看时长 &lt;img src=&quot;http://www.zhihu.com/equation?tex=T_%7Bi%7D&quot; alt=&quot;T_{i}&quot;/&gt;，负样本权重为1。这样的话，LR学到的odds为：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/50/v2-4b76c3502d11f87785fb32712ec4b623_hd.jpg&quot; alt=&quot;&quot; width=&quot;1316&quot; data-rawwidth=&quot;1316&quot; data-rawheight=&quot;142&quot; data-original=&quot;https://pic3.zhimg.com/v2-4b76c3502d11f87785fb32712ec4b623_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4b76c3502d11f87785fb32712ec4b623_b.jpg&quot;/&gt;其中&lt;img src=&quot;http://www.zhihu.com/equation?tex=N&quot; alt=&quot;N&quot;/&gt;是总的样本数量，&lt;img src=&quot;http://www.zhihu.com/equation?tex=k&quot; alt=&quot;k&quot;/&gt;是正样本数量，&lt;img src=&quot;http://www.zhihu.com/equation?tex=T_%7Bi%7D&quot; alt=&quot;T_{i}&quot;/&gt;是第&lt;img src=&quot;http://www.zhihu.com/equation?tex=i&quot; alt=&quot;i&quot;/&gt;正样本的观看时长。一般来说，k相对N比较小，因此上式的odds可以转换成&lt;img src=&quot;http://www.zhihu.com/equation?tex=E%5BT%5D%2F%281%2BP%29&quot; alt=&quot;E[T]/(1+P)&quot;/&gt;，其中&lt;img src=&quot;http://www.zhihu.com/equation?tex=P&quot; alt=&quot;P&quot;/&gt;是点击率，点击率一般很小，这样odds接近于&lt;img src=&quot;http://www.zhihu.com/equation?tex=E%5BT%5D&quot; alt=&quot;E[T]&quot;/&gt;，即期望观看时长。因此在线上serving的inference阶段，我们采用&lt;img src=&quot;http://www.zhihu.com/equation?tex=e%5E%7Bx%7D&quot; alt=&quot;e^{x}&quot;/&gt;作为激励函数，就是近似的估计期望的观看时长。&lt;/p&gt;

&lt;p&gt;3.4 不同隐层的实验&lt;/p&gt;
&lt;p&gt;下图的table1是离线利用hold-out一天数据在不同NN网络结构下的结果。如果用户对模型预估高分的反而没有观看，我们认为是预测错误的观看时长。weighted, per-user loss就是预测错误观看时长占总观看时长的比例。&lt;/p&gt;
&lt;p&gt;我们对网络结构中隐层的宽度和深度方面都做了测试，从下图结果看增加隐层网络宽度和深度都能提升模型效果。而对于1024--&amp;gt;512--&amp;gt;256这个网络，测试的不包含归一化后根号和方式的版本，loss增加了0.2%。而如果把weighted LR替换成LR，效果下降达到4.1%。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/50/v2-05b935a5fba84dac4f575dd679ddd66a_hd.jpg&quot; alt=&quot;&quot; width=&quot;942&quot; data-rawwidth=&quot;942&quot; data-rawheight=&quot;472&quot; data-original=&quot;https://pic4.zhimg.com/v2-05b935a5fba84dac4f575dd679ddd66a_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-05b935a5fba84dac4f575dd679ddd66a_b.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 15:53:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8262025.html</dc:identifier>
</item>
<item>
<title>我要给团队什么样的输出 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8253822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8253822.html</guid>
<description>&lt;p&gt;&lt;strong&gt;我希望大家是什么样子的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　之前在乐视的时候我问过我们飞哥：你希望大家是什么样子的。飞哥人特别好，因为在饭桌上，他把所有的人都说了一遍，说需要你，也需要他。需要各种各样的人。我在乐视过得蛮滋润，我可以按照自己希望的样子进行发展。这是建立在我这么多年磕磕碰碰，有了很多思考和自己想做的事情的基础上。但是我也很想知道，我怎样能领导让更满意。很多刚毕业的同学，更想得到很多的引导。所以我现在就在思考这个问题。&lt;/p&gt;
&lt;p&gt;　　我希望大家有很多想法，大家一起拿出来探讨。我希望大家可以遇到事情或者有什么思路可以自己主动找我商量，我觉得这是对我的尊重和认可。我希望我有什么问题或者团队有什么问题，大家看到了或者想到了能告诉我，大家一起想办法。乐于分享，有团队精神。我希望这些是团队的共性。这和每个人的性格没有关系，更多的是一种团队合作沟通的技巧。&lt;/p&gt;
&lt;p&gt;　　性格方面，我觉得遵从天性就好。如果非说要有点共性，那么我希望是感恩之心。可能其他人有自己的生活方式，但就我自己的经验而言，这在整个人生中，工作上、生活上都是成功的关键。为什么我家娃都马上要上小学了，我家男神来我们公司附近，我可以团队聚餐不去，一定要和男神一起吃饭。关系好是因为两个都是知道感恩的人，感恩上苍，感恩彼此，愿意为对方多付出一点让对方更幸福。结果，自己收获了更多的幸福。我有很多的朋友，干什么事情都不愁没人帮忙，那是因为自己这样的气质，周围聚集的也都是一些仗义的人。仗义的基础就是感恩之心。世界上最遥远的距离是每次我需要你，都不知道你在哪里。爱情不一定会败给物质，却一定会败给我需要你的时候你都不在。工作也是一样的，背道而驰路会越走越窄。&lt;/p&gt;
&lt;p&gt;　　之前在乐视有次开会，我家微微一笑很倾城的男神老大说刚刚面试了一个女孩子特别满意。满意到什么程度呢，跟晓静似的。但是老大看了我一眼，看我听了不是特别高兴，就继续说这个女孩子什么学校的，有多么优秀。我也就是听听，不太高兴因为我觉得我家男神老大跟王子一样，特别完美的一个人。完美的人其实有很多，但是我从来没有觉得他们是一类人。在我心里，独一无二，不会觉得跟谁很像。我对自己也是一样，我觉得自己是独一无二的，听自己崇拜的人说自己只是一类人，多少有些失落。所以现在我自己带团队了，我有时间会去发掘每个人的个性，相信每个人都是优秀的、独一无二的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;沟通&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　沟通分为团队内的沟通和团队间沟通。&lt;/p&gt;
&lt;p&gt;　　团队内沟通对于重要的事情，如果不是一句话两句话能说清楚的，就算文字、消息沟通过，最好也要口头沟通一下。因为信息接受者有可能因为事情多忘了或者理解的不对。口头沟通为主，消息主要记录和留证。为什么这么做呢？程序员大多数是听觉敏感型的。心理学按照感官敏感度将一般人分为视觉敏感型和听觉敏感型。视觉敏感型的人对视觉的东西更敏感，精力更集中，记忆也更深刻。更擅长处理图像。听觉敏感型对声音更敏感，更擅长语言文字。而我们从小到大学校学的东西基本是语言文字。能来咱们公司的，都是被读书坑掉的一代，听觉敏感的居多。&lt;/p&gt;
&lt;p&gt;　　团队外，我们是一个team。团队外的人不管找谁询问任何事情，都绝对不能因为不是自己负责的模块而怠慢。自己处理不了，可以带人家去找可以处理的人。我们需要给团队外的人的感觉是：找谁都是一样的，不用有所顾忌。&lt;/p&gt;
&lt;p&gt;　　技术、沟通、态度哪个更重要。这实际上是一个很没有价值的问题，因为这三者其实是一个东西，叫能力。任何一个不好，都是能力问题。我在东软的时候，是很受欢迎的小翻译。真的因为我是一年就过日语一级的天才，所以日语好的不得了吗？怎么可能，人家都是专业学了很多年，日本留学回来的。但是其他的翻译是字面翻译者。我是技术出身的，我理解他们实际上是在说什么，所以更好沟通。其实不懂日语都可以沟通。我在日本出差的时候，我一个同事不会说日语，有个日本的“矢野”不会说中文。他两天天都不用翻译，就用手比划，纸上画，无障碍。技术是什么，比如对咱们来说JAVA是技术，好吧，但是别忘了JAVA最根本是一种语言，是用来表达实现东西的。技术很牛逼，写了一堆漂亮代码，但是做了系统边界外的事情，后患无穷，还不如不写。所以沟通要更关键一些。而有效沟通的最好方式就是态度。&lt;/p&gt;

&lt;p&gt;我自身要做的事情&lt;/p&gt;
&lt;p&gt;　　我应该是规划者和决策者，不是执行者。我更不需要是最好的执行者。比较喜欢的美剧是《神盾局特工》和《罪恶黑名单》。不管什么剧，指挥官绝对不是电影里最身手不凡，耍枪耍的最帅的。也不是任何一方面的专家。他是将整个团队凝结到一起，让大家可以成为最酷最帅的执行者的那个人。他的职责是制定靠谱的任务。&lt;/p&gt;
&lt;p&gt;　　从战略和架构上，我需要定义好系统的边界、定义好系统的核心思想。这样，系统就有了方向感，随着时间推移，系统就能形成自己的灵魂。咱们邮件的签名：我们的职责是：打造可靠、高效的交易系统。这就是系统最抽象的核心思想。&lt;/p&gt;
&lt;p&gt;　　我要帮助大家提出问题。比如每个需求的时候，大家都应该问自己5个Why：这件事情有没有超越这个系统的边界？这是根据当前模型和代码中的一组特定关系作出的权宜之计呢，还是反映了底层领域的某种轮廓？我们做这件事情的收益是什么？如果需求比较大，那么每个阶段的里程碑是什么？有没有更好的解决方法？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　相信团队里现在很多人有这种疑问。我们现在做重构，做好了，又有变化，怎么办？我的回答是：重构就是需要是一个持续改变的过程，要保持鲜活，要拥抱变化。《极限编程》的核心思想就是要拥抱变化，要迭代。持续变化不可怕，风险是可控的。可怕的是长期不维护，大家对实现细节都淡忘的代码突然要有一个改变。《领域驱动设计》里有一段话：&lt;/p&gt;
&lt;p&gt;　　通过重构得到更深层理解是一个持续不断的过程。人们可能会发现一些隐含的概念，并把它们明确地表示出来。有些设计部分变得更有柔性，或许还采用了声明式的开发风格。开发工作一下子到了突破的边缘，然后开发人员跨越这条界限，得到了一个更深层的模型，接下来又重新开始了稳步的精化过程。&lt;/p&gt;
&lt;p&gt;　　重构设计的原则说：至少要有两个步骤的前瞻性。所以，两个步骤之后还是要变。从模型到代码，都是一个精化过程，不要怕变。&lt;/p&gt;

&lt;p&gt;　　重构模块的划分。这一块确实是经过大家很多的思考得到的，一段时间内是稳定的。比如核心现在划分为正向、逆向、查询、命令。这是怎么划分的呢？正向和逆向是我们的业务。我们的业务再怎么变，抽象出来也逃离不出这个范围。业务执行操作。所有的操作都可以抽象为查询和命令。查询和命令为什么要分开呢？水平切分，避免副作用。这也是分布式服务和微服务的本质。&lt;/p&gt;

&lt;p&gt;　　今天太晚了，未完待续……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　女孩子心里想的就是：愿得一心人，白首不相离。男孩子：……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1112728/201801/1112728-20180110234226910-870966624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;略心塞&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 15:45:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8253822.html</dc:identifier>
</item>
<item>
<title>又见开始 - 柒小栈主</title>
<link>http://www.cnblogs.com/qixiaoyizhan/p/8261702.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixiaoyizhan/p/8261702.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/998608/201801/998608-20180110230749613-751557314.jpg&quot; alt=&quot;&quot; width=&quot;770&quot; height=&quot;428&quot;/&gt;&lt;/p&gt;

&lt;p&gt;又见开始，文接自“壹柒，壹柒。”&lt;/p&gt;
&lt;p&gt;今天晚间偶然间听闻了涛哥的早睡执行计划（已付诸行动），当然我是隐约能猜到该事件的导火线的，大抵是身体原因吧。听到此处，突然将我前日断断续续的规划推向了一个起点。我想，是时候将所有的规划整理一遍，以作为二〇一八的起点了罢。&lt;/p&gt;
&lt;p&gt;二〇一七是一个多人生大事的年头，在“壹柒，壹柒。”中已经有了详细的总结，此间不再赘述。我想说的是，在二〇一七的年末，自己却是有了一些良好的开端，也算作了人生的一部分规划。&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;作息时间的制定已经是迫在眉睫，随着最后一波九零后与青春年少缠绵多年后和平分手，该浪已推着我们前一批的九零后走在了直线奔三的道路上。真的感觉身体已不能再随意挥霍，我们不再有当年的血气支撑着我们去熬夜，去用整段的时间去做想做的事情，我们无可奈何地向身体妥协。这不，首当其冲的便是要对长久以来透支的作息时间动刀。&lt;/p&gt;
&lt;p&gt;23:30当做了最初的目标，我在我的手机上默默设置好了三个闹钟“23:15”、“23：30”、“7:20”。即便我晚上的效率有多高，我也将晚上熬夜的时间安排在了早上，阉割版的晚上时间，便刚好用来看看书，听听音乐，学习学习外语。&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;日常工作安排、周常计划。没有计划，就总是将临时兴起的一两次很好的活动逐渐废弃。“凡事预则立，不预则废”的古训使我不得不乖乖将曾经的良好习惯重新整理安排进计划表。&lt;/p&gt;
&lt;p&gt;二〇一七年末最让我欣慰的事情莫过于坚持了近两个月的“日常工作进度计划表”。该项计划一直坚持两个月未曾废弃，并且越来越钟爱上了它。初衷大抵为光阴流逝。内容分为了日期、事项、预计时间、实际完成时间、是否完成（未完成第二天标为红色）、完成总结等。为了长期分析自己的日常充斥着什么内容、自己的每天工作效率、对一些小事情的备忘。甚至于未来迁移到自己搭建的平台，最后将自己的生活行为做成大数据分析，了解自己的优势和痛点，对自己的未来起到指导作用也未尝不可。&lt;/p&gt;
&lt;p&gt;周常计划暂定为对本周的生活思想进行总结写一些类似于随笔的东西，这项工作放在周六较为妥当。而另一篇学习博客则放在周日，或许周六非工作日有什么大的总结，周日可以进行整理。总的来说，周末较为弹性，也是为了应对突然决定的活动，不作可以安排，至于一些非工作的计划，则随性调整。&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;对于工薪阶级，尤其是在大城市的童鞋们，一方面是生活成本较高，另一方面是生活娱乐之处较多，总的来说是更容易成为月光一族的。因此，不得不对财政作一番周密的计划，以从容应对随时可能到来的财政紧张。&lt;/p&gt;
&lt;p&gt;“家庭梦想基金”是曾经在街上踱步的时候突然想到的，当时顶着寒风立马将其记录在了OneNote里面，随后又进行了一番整理，最后终于正式提上了日程。虽说首次执行以失败告终，但是本月开始也为时未晚。暂定于每月向某一尾号为2的卡里面转一笔小额作为“家庭梦想基金”，为什么是“2”呢，因为遥相呼应了每年至少2次的旅行活动计划，以作为响应。&lt;/p&gt;
&lt;p&gt;首次失败告终的记录犹在，真得益于日常进度计划表。15是每月15号，1是计划用1天完成，实际完成时间为空，是否完成为空…&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/998608/201801/998608-20180110230813597-1825533473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至于其他的生活储蓄计划，将不在本文描述…&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;在路上。&lt;/p&gt;
&lt;p&gt;“身体与心灵总有一个要在路上！”不知是谁曰（yue）出了这么绝妙不可言的辞藻。心灵在路上通俗的做法便是多去读书，无论什么类型的书，本着开卷有益的法则。事实上，现在能静下心来读几本书的人着实不多了。&lt;/p&gt;
&lt;p&gt;不得已，还是计划好了身体在路上吧，至少除了猎奇的心外，还需要有锻炼身体的心啊。至于真正的感悟，我在“壹柒，壹柒。”已经做了详尽的叙述，too 激动 to 不再赘述。&lt;/p&gt;
&lt;p&gt;一年两次，不多不少，佛系旅行。&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;最后说一些硬性计划外的软计划。&lt;/p&gt;
&lt;p&gt;从不是个过分依赖手机的人，但是个依赖生活的人。前段时间由于异地而对手机使用时长大幅度增加，最近从津迁移到京，首先个人时间上有一部分缩短，另一部分若隐若现的原因也让我逐渐得以长时间离开手机。我终于又是个极少依赖手机的人了（可是整天还是依赖着电脑，我能怎么办？？？）。&lt;/p&gt;
&lt;p&gt;减少手机使用时间仍然在软计划中，这段时间从远离手机中度日也越来越体会到个人时间的充实。匪夷所思的事情就在于手机上看一篇文章，看一则新闻，看个段子，看个小视频。最后的结局大抵为忘掉百分之九十，甚至于感觉虚度人生，无所收获。而将每天零碎时间捡起来看看书，约人说说话，出去走走，便会顿觉收获斐然，醍醐灌顶。久后仍记，人生充实，真乃奇闻也哉。&lt;/p&gt;
&lt;p&gt;健身（骑行）仍是要提的话题，健身的需求，职业使然。骑行的目的却不仅仅是健身，更多的是充实人生，穿梭市井，看看人间百态（坐车是很难走进小巷的）。更像是一种里程碑式的记忆。虽说说到底只是一项爱好，可是爱好也需要坚持啊。&lt;/p&gt;
&lt;p&gt;最后要提的便是从去年开始，将所有的读书、电影总结成了一个表格，读书要有读书开始和结束日期，用来分析读书坚持度和读书效率；电影要有观影时间、同观人和观后感，用来沉淀生活的记忆…&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/998608/201801/998608-20180110230836066-1444673726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;生活无限好，只是近三十…&lt;/p&gt;
&lt;p&gt;7tiny 2018/1/10 22:30&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>柒小栈主</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qixiaoyizhan/p/8261702.html</dc:identifier>
</item>
<item>
<title>chrome调试工具高级不完整使用指南（优化篇） - 谢灿勇</title>
<link>http://www.cnblogs.com/st-leslie/p/8244559.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/st-leslie/p/8244559.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一篇文章我们说了chrome调试工具的一些比较基础功能的用法，接下来我们要在这一篇文章中说一说,其他一些chrome调试工具的使用方法&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.2 优化模块介绍&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;2.2.1 Network模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180108224430785-992280287.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在netWork模块中，大致上可以分成四块模块，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 这个模块相当于是一个功能菜单，左边的四个按钮&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110222744660-580691747.gif&quot; alt=&quot;&quot;/&gt;依次表示的是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-1 停止捕获请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-2 清除所有的请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-3 对请求进行快照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-4 是否开启过滤选项，也就是是否开启图中的2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除此之外里面的Disable Cache是用来请求请求缓存，Preserve log 用来保存请求记录 　offine断网，其他的具体使用与分析会在后面的课程中讲解&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2- 这个模块主要是用来过滤请求的类型的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3- 这个的功能是相当于查看各个请求的发送时间，完成时间的一个总的概况，主要是用来全局分析用的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4- 查看里面的各个请求的具体情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.2.2  Performance模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180108233917269-1806697109.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面的这样图是博客园的首页的一张图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据博主的经验我们重点要看的就是第一和第二，然后其他部分博主一般也没有使用到，具体用法不详，知道的同学请在留言中补充一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 功能菜单模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要要讲解一下前5个按钮功能，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-1 用于触发监控页面，从而输出性能分析图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-2 重新刷新请求性能分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-3 清除所有的分析信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-4 上传分析报告图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1-5 下载分析报告图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2- 这一部分主要涉及到火焰图的分析，具体可以赚到阮一峰大大的相关&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/09/flame-graph.html&quot; target=&quot;_blank&quot;&gt;博文&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.2.3 Memory模块&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个模块是用来对内存占用情况进行分析的。其中里面有3个小的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110135400394-1591405756.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 图中上面的1-3分别代表的功能是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1- 内存堆栈快照 这个功能主要是用来查看当前（没有被垃圾回收机制回收的）的各项资源的占用情况与内存的一个比例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2- 用于动态监控从start启动之后内存的一个占用情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3- 通过一个时间轴图来动态监控占用情况，这个相比于2的一个好处是可以动态的监控不需要手动控制，另外一个就是可以通过图的形式直观地显示&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2.2.4 Security 模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个模块主要是用来判断当前页面中是否使用了有效的HTTPS证书，不起到其他的作用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110173522566-1875906765.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.2.5 audits模块&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这个模块主要是chrome提供的用来自动分析页面的情况的，但是由于这个需要FQ所以推荐大家使用旧的版本Legacy audits来进行分析页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开启方式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用Ctrl+Shift+P 激活面板，激活之后就会开启里面内置的一些隐藏模块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/728493/201801/728493-20180110221015207-2141463667.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的一些性能优化提示自己看看英文的内容，不懂英文请百度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好的，所有的模块大致上面已经说了一遍了，接下来的内容就是开始说说怎样在实际应用中使用这些特性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8196493.html%20&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（基础篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/st-leslie/p/8244559.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（优化篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/st-leslie/p/8261319.html&quot; target=&quot;_blank&quot;&gt; chrome调试工具高级不完整使用指南（实战一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战二）&lt;/p&gt;
&lt;p&gt; chrome调试工具高级不完整使用指南（实战三）&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 14:35:00 +0000</pubDate>
<dc:creator>谢灿勇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/st-leslie/p/8244559.html</dc:identifier>
</item>
<item>
<title>OpenCascade Ruled Surface - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/Ruled_Surface.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/Ruled_Surface.html</guid>
<description>&lt;h2&gt;OpenCascade Ruled Surface&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract.&lt;/strong&gt; A ruled surface is formed by moving a line connecting points of equal relative arc length or equal relative parametric value on two parametric curves from a start point to a terminate point on the curves. The paper focus on the ruled surface in opencascade.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key words.&lt;/strong&gt; OpenCascade, Ruled Surface, 直纹面&lt;/p&gt;
&lt;h3&gt;1.Introduction&lt;/h3&gt;
&lt;p&gt;《解析几何》中有关于直纹面Ruled Surface的定义：一曲面S称为直纹面，如果存在一族直线使得这一族中的每一条直线全在S上。并且S上的每个点都在这一族的某一条直线上。这样一族直线称为S的一族直母线。其参数方程为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220430051-841428932.png&quot;&gt;&lt;img title=&quot;wps_clip_image-10134&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220430738-204874296.png&quot; alt=&quot;wps_clip_image-10134&quot; width=&quot;424&quot; height=&quot;89&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即可以将直纹面看作是曲面对当v=0和1时得到的两个边界曲线之间进行线性插值得到的曲面。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431254-1601684062.png&quot;&gt;&lt;img title=&quot;wps_clip_image-2878&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431613-2139221305.png&quot; alt=&quot;wps_clip_image-2878&quot; width=&quot;408&quot; height=&quot;306&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Autodesk 3DS Max中的直纹面，图片来自：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://knowledge.autodesk.com/support/3ds-max/learn-explore/caas/CloudHelp/cloudhelp/2015/ENU/3DSMax/files/GUID-364FE529-431B-448A-850B-DD9BBECAC90B-htm.html&quot;&gt;https://knowledge.autodesk.com/support/3ds-max/learn-explore/caas/CloudHelp/cloudhelp/2015/ENU/3DSMax/files/GUID-364FE529-431B-448A-850B-DD9BBECAC90B-htm.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直纹面是从两条曲线来构造曲面的方法，Coons曲面是由四边条界曲线来构造曲面，理解直纹面的构造原理，为进一步理解通用的放样Sweep造型打下基础。&lt;/p&gt;
&lt;h3&gt;2.Ruled Surface Parametric Equation&lt;/h3&gt;
&lt;p&gt;直纹面的参数方程也可以写成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431816-429924804.png&quot;&gt;&lt;img title=&quot;wps_clip_image-19769&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220431988-2034109216.png&quot; alt=&quot;wps_clip_image-19769&quot; width=&quot;286&quot; height=&quot;43&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接根据参数方程可以定义出相应的直纹面。在OpenCASCADE中话，可以从Geom_Surface派生新的类，并实现相应的虚函数。如实现计算对应参数u,v的值的虚函数D0()等。为了简单起见，用相应的函数计算直纹面上的点，并生成OpenCASCADE Draw Test Harness的命令脚本文件，方便在Draw中可视化。&lt;/p&gt;
&lt;p&gt;如有名的Mobius Strip也是个直纹面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220432410-1387573437.png&quot;&gt;&lt;img title=&quot;wps_clip_image-4834&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220432816-1725399160.png&quot; alt=&quot;wps_clip_image-4834&quot; width=&quot;553&quot; height=&quot;319&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mobius Strip的参数方程为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220433097-249218186.png&quot;&gt;&lt;img title=&quot;wps_clip_image-26570&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220433363-527722293.png&quot; alt=&quot;wps_clip_image-26570&quot; width=&quot;554&quot; height=&quot;100&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据上述参数方程在OpenCASCADE的Draw生成Mobius Strip，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; Standard_Real MOBIUS_RADIUS = &lt;span&gt;50.0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MobiusStrip(Standard_Real theU, Standard_Real theV, gp_Pnt&amp;amp;&lt;span&gt; thePoint)
{
    thePoint.SetX((MOBIUS_RADIUS &lt;/span&gt;+ theU * Cos(&lt;span&gt;0.5&lt;/span&gt; * theV)) *&lt;span&gt; Cos(theV));
    thePoint.SetY((MOBIUS_RADIUS &lt;/span&gt;+ theU * Cos(&lt;span&gt;0.5&lt;/span&gt; * theV)) *&lt;span&gt; Sin(theV));
    thePoint.SetZ(theU &lt;/span&gt;* Sin(&lt;span&gt;0.5&lt;/span&gt; *&lt;span&gt; theV));
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestMobiusStrip()
{
    std::ofstream aTclFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:/mobius.tcl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pload ALL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vinit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;

    Standard_Real aWidth &lt;/span&gt;= &lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;;
    Standard_Integer aN &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Real s = -aWidth; s &amp;lt; aWidth; s += &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;)
    {
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;polyline p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; ++&lt;span&gt;aN ;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Real t = &lt;span&gt;0.0&lt;/span&gt;; t &amp;lt; M_PI * &lt;span&gt;2.0&lt;/span&gt;; t += &lt;span&gt;0.01&lt;/span&gt;&lt;span&gt;)
        {
            gp_Pnt aPoint;
            MobiusStrip(s, t, aPoint);

            aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; aPoint.Z();
        }

        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n vdisplay p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aN &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }


    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Real t = &lt;span&gt;0.0&lt;/span&gt;; t &amp;lt; M_PI * &lt;span&gt;2.0&lt;/span&gt;; t += &lt;span&gt;0.2&lt;/span&gt;&lt;span&gt;)
    {
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;polyline p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; ++&lt;span&gt;aN;
        gp_Pnt aPoint;

        MobiusStrip(&lt;/span&gt;-&lt;span&gt;aWidth, t, aPoint);
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; aPoint.Z();

        MobiusStrip(aWidth, t, aPoint);
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; aPoint.Z();

        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n vdisplay p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aN &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    TestMobiusStrip();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在D盘生成一个mobius.tcl脚本文件，直接在Draw Test Harness中输入命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;source d:/mobius.tcl&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即可得到如下图所示的Mobius环：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220433722-591864499.gif&quot;&gt;&lt;img title=&quot;mobius&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220434129-1541157090.gif&quot; alt=&quot;mobius&quot; width=&quot;701&quot; height=&quot;448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他的直纹面只要知道参数方程，都可以采用这种方法在OpenCASCADE Draw Test Harness中进行显示。有人也用POV-Ray根据直纹面的参数方程来绘制直纹面，效果更不错。&lt;/p&gt;
&lt;p&gt;这是使用参数方程来表示直纹面的方法，如果知道直纹面的参数方程，可以从几何曲面来派生新类Geom_Surface，并实现几个相关虚函数，应该可以直接给OpenCASCADE显示了，这种方法没有测试。&lt;/p&gt;
&lt;h3&gt;3.Ruled Surface to B Spline Surface&lt;/h3&gt;
&lt;p&gt;如果已知直纹面的参数方程，如何用NURBS曲面来表示直纹面呢？在《非均匀有理B样条》一书中给出了一种将给定两条曲线C1,C2转换成直纹面的方法。他给出的限制条件是想要生成在v方向是直线的曲面，即是C1(u)和C2(u)之间的线性插值。而且还要求在两条曲线的等参数点之间进行插值。又由于曲面是张量各曲面，两条边界曲线C1和C2必须具有相同的次数，并定义在相同的节点矢量上，因此表示这样的直纹面的B样条转换过程为：&lt;/p&gt;
&lt;p&gt;l 确保两条曲线定义在相同的参数区间内；&lt;/p&gt;
&lt;p&gt;l 确保两条曲线的次数相同。如果不同，则将次数低的曲线升阶；&lt;/p&gt;
&lt;p&gt;l 确保两条曲线有相同的节点矢量。&lt;/p&gt;
&lt;p&gt;OpenCASCADE中生成直纹面的是类GeomFill的静态函数Surface()，其实现步骤与上述类似，具体实现的类是GeomFill_Profiler。GeomFill_Profiler是个更通用的类，它可以根据多条曲线来构造曲面。下面通过Draw Test Harness脚本来根据两条曲线构造直纹面。&lt;/p&gt;
&lt;h4&gt;3.1 根据两条直线构造直纹面&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ruled surface between two lines.&lt;/span&gt;
&lt;span&gt;
vertex v1 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

vertex v2 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;

vertex v3 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;8&lt;/span&gt;&lt;span&gt;

vertex v4 &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

edge e1 v1 v2

edge e2 v3 v4

pruled r1 e1 e2

vdisplay v1 v2 v3 v4 e1 e2 r1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成直纹面是一个双线性曲面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220435754-2117146722.gif&quot;&gt;&lt;img title=&quot;ruled1&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220437535-1601226836.gif&quot; alt=&quot;ruled1&quot; width=&quot;425&quot; height=&quot;448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.2 根据两个圆构造直纹面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ruled surface between circle and ellipse.&lt;/span&gt;
&lt;span&gt;
circle c1 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;

circle c2 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;

mkedge e3 c1

mkedge e4 c2

pruled r2 e3 e4

vdisplay e3 e4 r2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的直纹面是一个圆锥面，效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220437926-759759519.png&quot;&gt;&lt;img title=&quot;wps_clip_image-15852&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220438269-698101129.png&quot; alt=&quot;wps_clip_image-15852&quot; width=&quot;425&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当顶部的圆旋转时会得到如下图所示的直纹面：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220438629-1988866212.png&quot;&gt;&lt;img title=&quot;wps_clip_image-2230&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220438988-2068179871.png&quot; alt=&quot;wps_clip_image-2230&quot; width=&quot;425&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相应的Draw脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Ruled surface between circle and ellipse.&lt;/span&gt;
&lt;span&gt;
circle c1 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;

circle c2 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;

mkedge e3 c1

mkedge e4 c2

pruled r2 e3 e4

vdisplay e3 e4 r2

&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

trotate e4 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

pruled r2 e3 e4 

vdisplay r2

&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

trotate e4 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

pruled r2 e3 e4 

vdisplay r2

&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

trotate e4 &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

pruled r2 e3 e4 

vdisplay r2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的动画效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/534255/201801/534255-20180110220440488-1141527608.gif&quot;&gt;&lt;img title=&quot;ruled4&quot; src=&quot;https://images2017.cnblogs.com/blog/534255/201801/534255-20180110220441722-222089828.gif&quot; alt=&quot;ruled4&quot; width=&quot;425&quot; height=&quot;448&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4.Conclusion&lt;/h3&gt;
&lt;p&gt;根据直纹面的参数方程就可以绘制出相应的曲面，然后如何用B样条曲面来表示直纹面，需要满足一定的条件。IGES中定义的直纹面就给出了两种方式：等弧长和等参数构造。引用《非均匀有理B样条》书中对两种形式的说明如下：一般情况下，连接两条曲线上相对弧长相等的点会产生一个几何上不同的曲面，而这样的曲面不能通过NURBS来表示。因此，要在NURBS的直纹面和IGES的直纹面（Type 118 Form 0/1）之间进行数学上的精确转换是不可能的。&lt;/p&gt;
&lt;p&gt;OpenCASCADE的直纹面也是使用的NURBS表示，所以其也是等参数形式的直纹面。希望在理解根据两条曲线来构造曲面的方法来理解更一般的造型算法，即通过多条曲线来构造曲面的造型方法。&lt;/p&gt;
&lt;h3&gt;5.References&lt;/h3&gt;
&lt;p&gt;1. Weisstein Eric W. “Ruled Surface”. &lt;a href=&quot;http://mathworld.wolfram.com/RuledSurface.html&quot;&gt;http://mathworld.wolfram.com/RuledSurface.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;a href=&quot;http://www.ms.uky.edu/~lee/visual05/gallery/ruledsurfaces.doc&quot;&gt;www.ms.uky.edu/~lee/visual05/gallery/ruledsurfaces.doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3. The Initial Graphics Exchange Specification (IGES) Version 6.0&lt;/p&gt;
&lt;p&gt;4. 赵罡, 穆国旺, 王拉柱. 非均匀有理B样条. 清华大学出版社. 2010&lt;/p&gt;
&lt;p&gt;5. 丘维声. 解析几何. 北京大学出版社. 1996&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 14:05:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/Ruled_Surface.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——18. 组合优于继承 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8260992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8260992.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;继承是实现代码重用的有效方式，但并不总是最好的工具。使用不当，会导致脆弱的软件。 在包中使用继承是安全的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（条目 19），使用继承也是安全的。 然而，从普通的具体类跨越包级边界继承，是危险的。 提醒一下，本书使用“继承”一词来表示实现继承（当一个类继承另一个类时）。 在这个项目中讨论的问题不适用于接口继承（当类实现接口或当接口继承另一个接口时）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与方法调用不同，继承打破了封装&lt;/strong&gt;[Snyder86]。 换句话说，一个子类依赖于其父类的实现细节来保证其正确的功能。 父类的实现可能会从发布版本不断变化，如果是这样，子类可能会被破坏，即使它的代码没有任何改变。 因此，一个子类必须与其超类一起更新而变化，除非父类的作者为了继承的目的而专门设计它，并对应有文档的说明。&lt;/p&gt;
&lt;p&gt;为了具体说明，假设有一个使用&lt;code&gt;HashSet&lt;/code&gt;的程序。 为了调整程序的性能，需要查询&lt;code&gt;HashSe&lt;/code&gt;，从创建它之后已经添加了多少个元素（不要和当前的元素数量混淆，当元素被删除时数量也会下降）。 为了提供这个功能，编写了一个&lt;code&gt;HashSet&lt;/code&gt;变体，它保留了尝试元素插入的数量，并导出了这个插入数量的一个访问方法。 &lt;code&gt;HashSet&lt;/code&gt;类包含两个添加元素的方法，分别是&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;addAll&lt;/code&gt;，所以我们重写这两个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Broken - Inappropriate use of inheritance!
public class InstrumentedHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; {
    // The number of attempted element insertions
    private int addCount = 0;

    public InstrumentedHashSet() {
    }

    public InstrumentedHashSet(int initCap, float loadFactor) {
        super(initCap, loadFactor);
    }
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }
    @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }
    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类看起来很合理，但是不能正常工作。 假设创建一个实例并使用&lt;code&gt;addAll&lt;/code&gt;方法添加三个元素。 顺便提一句，请注意，下面代码使用在Java 9中添加的静态工厂方法&lt;code&gt;List.of&lt;/code&gt;来创建一个列表；如果使用的是早期版本，请改为使用&lt;code&gt;Arrays.asList&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InstrumentedHashSet&amp;lt;String&amp;gt; s = new InstrumentedHashSet&amp;lt;&amp;gt;();
s.addAll(List.of(&quot;Snap&quot;, &quot;Crackle&quot;, &quot;Pop&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们期望&lt;code&gt;getAddCount&lt;/code&gt;方法返回的结果是3，但实际上返回了6。哪里出来问题？在&lt;code&gt;HashSet&lt;/code&gt;内部，&lt;code&gt;addAll&lt;/code&gt;方法是基于它的&lt;code&gt;add&lt;/code&gt;方法来实现的，即使&lt;code&gt;HashSet&lt;/code&gt;文档中没有指名其实现细节，倒也是合理的。&lt;code&gt;InstrumentedHashSet&lt;/code&gt;中的&lt;code&gt;addAll&lt;/code&gt;方法首先给&lt;code&gt;addCount&lt;/code&gt;属性设置为3，然后使用&lt;code&gt;super.addAll&lt;/code&gt;方法调用了&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;实现。然后反过来又调用在&lt;code&gt;InstrumentedHashSet&lt;/code&gt;类中重写的&lt;code&gt;add&lt;/code&gt;方法，每个元素调用一次。这三次调用又分别给&lt;code&gt;addCount&lt;/code&gt;加1，所以，一共增加了6：通过&lt;code&gt;addAll&lt;/code&gt;方法每个增加的元素都被计算了两次。&lt;/p&gt;
&lt;p&gt;我们可以通过消除&lt;code&gt;addAll&lt;/code&gt;方法的重写来“修复”子类。 尽管生成的类可以正常工作，但是它依赖于它的正确方法，因为&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;方法是在其&lt;code&gt;add&lt;/code&gt;方法之上实现的。 这个“自我使用（self-use）”是一个实现细节，并不保证在Java平台的所有实现中都可以适用，并且可以随发布版本而变化。 因此，产生的&lt;code&gt;InstrumentedHashSet&lt;/code&gt;类是脆弱的。&lt;/p&gt;
&lt;p&gt;稍微好一点的做法是，重写&lt;code&gt;addAll&lt;/code&gt;方法遍历指定集合，为每个元素调用&lt;code&gt;add&lt;/code&gt;方法一次。 不管&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;方法是否在其&lt;code&gt;add&lt;/code&gt;方法上实现，都会保证正确的结果，因为&lt;code&gt;HashSet&lt;/code&gt;的&lt;code&gt;addAll&lt;/code&gt;实现将不再被调用。然而，这种技术并不能解决所有的问题。 这相当于重新实现了父类方法，这样的方法可能不能确定到底是否时自用（self-use）的，实现起来也是困难的，耗时的，容易出错的，并且可能会降低性能。 此外，这种方式并不能总是奏效，因为子类无法访问一些私有属性，所以有些方法就无法实现。&lt;/p&gt;
&lt;p&gt;导致子类脆弱的一个相关原因是，它们的父类在后续的发布版本中可以添加新的方法。假设一个程序的安全性依赖于这样一个事实：所有被插入到集中的元素都满足一个先决条件。可以通过对集合进行子类化，然后并重写所有添加元素的方法，以确保在添加每个元素之前满足这个先决条件，来确保这一问题。如果在后续的版本中，父类没有新增添加元素的方法，那么这样做没有问题。但是，一旦父类增加了这样的新方法，则很有肯能由于调用了未被重写的新方法，将非法的元素添加到子类的实例中。这不是个纯粹的理论问题。在把&lt;code&gt;Hashtable&lt;/code&gt;和&lt;code&gt;Vector&lt;/code&gt;类加入到Collections框架中的时候，就修复了几个类似性质的安全漏洞。&lt;/p&gt;
&lt;p&gt;这两个问题都源于重写方法。 如果仅仅添加新的方法并且不要重写现有的方法，可能会认为继承一个类是安全的。 虽然这种扩展更为安全，但这并非没有风险。 如果父类在后续版本中添加了一个新的方法，并且你不幸给了子类一个具有相同签名和不同返回类型的方法，那么你的子类编译失败[JLS，8.4.8.3]。 如果已经为子类提供了一个与新的父类方法具有相同签名和返回类型的方法，那么你现在正在重写它，因此将遇到前面所述的问题。 此外，你的方法是否会履行新的父类方法的约定，这是值得怀疑的，因为在你编写子类方法时，这个约定还没有写出来。&lt;/p&gt;
&lt;p&gt;幸运的是，有一种方法可以避免上述所有的问题。不要继承一个现有的类，而应该给你的新类增加一个私有属性，该属性是 现有类的实例引用，这种设计被称为组合（composition），因为现有的类成为新类的组成部分。新类中的每个实例方法调用现有类的包含实例上的相应方法并返回结果。这被称为转发（forwarding），而新类中的方法被称为转发方法。由此产生的类将坚如磐石，不依赖于现有类的实现细节。即使将新的方法添加到现有的类中，也不会对新类产生影响。为了具体说用，下面代码使用组合和转发方法替代&lt;code&gt;InstrumentedHashSet&lt;/code&gt;类。请注意，实现分为两部分，类本身和一个可重用的转发类，其中包含所有的转发方法，没有别的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Reusable forwarding class
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;

public class ForwardingSet&amp;lt;E&amp;gt; implements Set&amp;lt;E&amp;gt; {

    private final Set&amp;lt;E&amp;gt; s;

    public ForwardingSet(Set&amp;lt;E&amp;gt; s) {
        this.s = s;
    }

    public void clear() {
        s.clear();
    }

    public boolean contains(Object o) {
        return s.contains(o);
    }

    public boolean isEmpty() {
        return s.isEmpty();
    }

    public int size() {
        return s.size();
    }

    public Iterator&amp;lt;E&amp;gt; iterator() {
        return s.iterator();
    }

    public boolean add(E e) {
        return s.add(e);
    }

    public boolean remove(Object o) {
        return s.remove(o);
    }

    public boolean containsAll(Collection&amp;lt;?&amp;gt; c) {
        return s.containsAll(c);
    }

    public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        return s.addAll(c);
    }

    public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
        return s.removeAll(c);
    }

    public boolean retainAll(Collection&amp;lt;?&amp;gt; c) {
        return s.retainAll(c);
    }

    public Object[] toArray() {
        return s.toArray();
    }

    public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean equals(Object o) {
        return s.equals(o);
    }

    @Override
    public int hashCode() {
        return s.hashCode();
    }

    @Override
    public String toString() {
        return s.toString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// Wrapper class - uses composition in place of inheritance
import java.util.Collection;
import java.util.Set;

public class InstrumentedSet&amp;lt;E&amp;gt; extends ForwardingSet&amp;lt;E&amp;gt; {

    private int addCount = 0;

    public InstrumentedSet(Set&amp;lt;E&amp;gt; s) {
        super(s);
    }
    
    @Override public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override public boolean addAll(Collection&amp;lt;? extends E&amp;gt; c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InstrumentedSet&lt;/code&gt;类的设计是通过存在的Set接口来实现的，该接口包含&lt;code&gt;HashSet&lt;/code&gt;类的功能特性。除了功能强大，这个设计是非常灵活的。&lt;code&gt;InstrumentedSet&lt;/code&gt;类实现了Set接口，并有一个构造方法，其参数也是Set类型的。本质上，这个类把&lt;code&gt;Set&lt;/code&gt;转换为另一个类型&lt;code&gt;Set&lt;/code&gt;， 同时添加了计数的功能。与基于继承的方法不同，该方法仅适用于单个具体类，并且父类中每个需要支持构造方法，提供单独的构造方法，所以可以使用包装类来包装任何&lt;code&gt;Set&lt;/code&gt;实现，并且可以与任何预先存在的构造方法结合使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;Instant&amp;gt; times = new InstrumentedSet&amp;lt;&amp;gt;(new TreeSet&amp;lt;&amp;gt;(cmp));
Set&amp;lt;E&amp;gt; s = new InstrumentedSet&amp;lt;&amp;gt;(new HashSet&amp;lt;&amp;gt;(INIT_CAPACITY));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InstrumentedSet&lt;/code&gt;类甚至可以用于临时替换没有计数功能下使用的集合实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void walk(Set&amp;lt;Dog&amp;gt; dogs) {
    InstrumentedSet&amp;lt;Dog&amp;gt; iDogs = new InstrumentedSet&amp;lt;&amp;gt;(dogs);
    ... // Within this method use iDogs instead of dogs
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;InstrumentedSet&lt;/code&gt;类被称为包装类，因为每个&lt;code&gt;InstrumentedSet&lt;/code&gt;实例都包含（“包装”）另一个&lt;code&gt;Set&lt;/code&gt;实例。 这也被称为装饰器模式[Gamma95]，因为&lt;code&gt;InstrumentedSet&lt;/code&gt;类通过添加计数功能来“装饰”一个集合。 有时组合和转发的结合被不精确地地称为委托（delegation）。 从技术上讲，除非包装对象把自身传递给被包装对象，否则不是委托[Lieberman86;Gamma95]。&lt;/p&gt;
&lt;p&gt;包装类的缺点很少。 一个警告是包装类不适合在回调框架（callback frameworks）中使用，其中对象将自我引用传递给其他对象以用于后续调用（“回调”）。 因为一个被包装的对象不知道它外面的包装对象，所以它传递一个指向自身的引用（this），回调时并不记得外面的包装对象。 这被称为SELF问题[Lieberman86]。 有些人担心转发方法调用的性能影响，以及包装对象对内存占用。 两者在实践中都没有太大的影响。 编写转发方法有些繁琐，但是只需为每个接口编写一次可重用的转发类，并且提供转发类。 例如，Guava为所有的Collection接口提供转发类[Guava]。&lt;/p&gt;
&lt;p&gt;只有在子类真的是父类的子类型的情况下，继承才是合适的。 换句话说，只有在两个类之间存在“is-a”关系的情况下，B类才能继承A类。 如果你试图让B类继承A类时，问自己这个问题：每个B都是A吗？ 如果你不能如实回答这个问题，那么B就不应该继承A。如果答案是否定的，那么B通常包含一个A的私有实例，并且暴露一个不同的API：A不是B的重要部分 ，只是其实现细节。&lt;/p&gt;
&lt;p&gt;在Java平台类库中有一些明显的违反这个原则的情况。 例如，stacks实例并不是vector实例，所以&lt;code&gt;Stack&lt;/code&gt;类不应该继承&lt;code&gt;Vector&lt;/code&gt;类。 同样，一个属性列表不是一个哈希表，所以&lt;code&gt;Properties&lt;/code&gt;不应该继承&lt;code&gt;Hashtable&lt;/code&gt;类。 在这两种情况下，组合方式更可取。&lt;/p&gt;
&lt;p&gt;如果在合适组合的地方使用继承，则会不必要地公开实现细节。由此产生的API将与原始实现联系在一起，永远限制类的性能。更严重的是，通过暴露其内部，客户端可以直接访问它们。至少，它可能导致混淆语义。例如，属性p指向&lt;code&gt;Properties&lt;/code&gt;实例，那么 &lt;code&gt;p.getProperty(key)&lt;/code&gt;和&lt;code&gt;p.get(key)&lt;/code&gt;就有可能返回不同的结果：前者考虑了默认的属性表，而后者是继承&lt;code&gt;Hashtable&lt;/code&gt;的，它则没有考虑默认属性列表。最严重的是，客户端可以通过直接修改超父类来破坏子类的不变性。在&lt;code&gt;Properties&lt;/code&gt;类，设计者希望只有字符串被允许作为键和值，但直接访问底层的&lt;code&gt;Hashtable&lt;/code&gt;允许违反这个不变性。一旦违反，就不能再使用属性API的其他部分（&lt;code&gt;load&lt;/code&gt;和&lt;code&gt;store&lt;/code&gt;方法）。在发现这个问题的时候，纠正这个问题为时已晚，因为客户端依赖于使用非字符串键和值了。&lt;/p&gt;
&lt;p&gt;在决定使用继承来代替组合之前，你应该问自己最后一组问题。对于试图继承的类，它的API有没有缺陷呢？ 如果有，你是否愿意将这些缺陷传播到你的类的API中？继承传播父类的API中的任何缺陷，而组合可以让你设计一个隐藏这些缺陷的新API。&lt;/p&gt;
&lt;p&gt;总之，继承是强大的，但它是有问题的，因为它违反封装。 只有在子类和父类之间存在真正的子类型关系时才适用。 即使如此，如果子类与父类不在同一个包中，并且父类不是为继承而设计的，继承可能会导致脆弱性。 为了避免这种脆弱性，使用合成和转发代替继承，特别是如果存在一个合适的接口来实现包装类。 包装类不仅比子类更健壮，而且更强大。&lt;/p&gt;
</description>
<pubDate>Wed, 10 Jan 2018 13:55:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8260992.html</dc:identifier>
</item>
<item>
<title>【APS.NET 框架系列】您所经历的，但未必研究的那些技术 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8201129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8201129.html</guid>
<description>&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110033829004-2140333139.png&quot; alt=&quot;&quot;/&gt;   &lt;span&gt;本篇文章更适合具有一定开发经验，一定功底，且对底层代码有所研究的朋友！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章稍微偏原理且底层，有一定难度和且比较晦涩，&lt;/span&gt;&lt;span&gt;文章粒度稍微粗些，更细粒度的，会在后续的文章中，结合具体的Demo实例分析。感兴趣的朋友，可以先收藏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一 .NET框架概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110211304301-1160018928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.作用:提供了基于.NET框架开发的基础平台和模板，为.NET开发的基架;&lt;/p&gt;
&lt;p&gt;2.基本构成:可支持语言，CLS，模板框架，基本模板，基本操作，基本类库，公共需要运行时，CTS和CLS，OS等;&lt;/p&gt;
&lt;p&gt;    (1)可支持语言:.NET框架可支持vb，c++，c＃，F＃，js等语言开发;&lt;/p&gt;
&lt;p&gt;    (2)CLS:通用语言规范，使多种语言开发成为了可能，可参考：https://docs.microsoft.com/en-us/dotnet/standard/language-independence-and-language-independent-components&lt;/p&gt;
&lt;p&gt;    (3)模板框架:B/S模式开发，C/S模式开发，App开发，接口开发&lt;/p&gt;
&lt;p&gt;            B/S:WebForm和MVC，.NET Core；主要是PC运用程序；&lt;/p&gt;
&lt;p&gt;            C/S：Winform和WPF，主要是桌面运用程序；&lt;/p&gt;
&lt;p&gt;            APP：当前主流的一种开发模式；&lt;/p&gt;
&lt;p&gt;    (4)基本操作：对DB操作（ADO.NET和EF），I/O操作等；&lt;/p&gt;
&lt;p&gt;    (5)BCL:基本类库，供调用；&lt;/p&gt;
&lt;p&gt;    (6)CLR:公共语言运行时，是IL形成EXE必不可少的环节，也是JIT实现一次编译，多次且跨平台运行的必不可少的环境，在.NET框架中扮演着及其重要的角色，且技术比较难且晦涩；&lt;/p&gt;
&lt;p&gt;    (7)CTS 和 CLS：CTS，即通用类型系统，实现COM组件兼容等；&lt;/p&gt;
&lt;p&gt;    (8)OS:屏蔽底层实现，高度抽象，OS类型：Win XP（基本淘汰，微软官方都不维护了）、Win 7 ,Win 8,Win 10；&lt;/p&gt;
&lt;p&gt;3..NET两大产品：Dynamic CRM 和SharePoint;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （一）ADO.NET&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180109233318863-356650063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.作用:程序与数据交互的方式之一。.NET框架中，ADO.NET抽象化了程序与Database的交互，在进行基本的CRUD操作时，只需调用具体的类，方法即可;&lt;/p&gt;
&lt;p&gt;2.基本构成:主要由五大对象构成。Conneciton对象，DataAdapter对象，Command对象，DataSet对象，DataReader对象构成;&lt;/p&gt;
&lt;p&gt;3.五大对象的基本概述:&lt;/p&gt;
&lt;p&gt;   (1)Connection对象:连接数据库的通道，主要方法为Open()和Close()，前者负责打开数据库入口，后者负责关闭数据库入口;&lt;/p&gt;
&lt;p&gt;   (2)Command对象负责对DB的具体操作，CRUD就是通过它实现的;&lt;/p&gt;
&lt;p&gt;   (3)DataAdapter对象负责将DB与DataSet适配，使基本的CRUD得以实现;&lt;/p&gt;
&lt;p&gt;   (4)DataSet对象扮演虚拟内存的角色，也扮演缓存的角色，是实现Application与DB数据交互的必要环节之一;&lt;/p&gt;
&lt;p&gt;   (5)DataReader主要解决读取数据的问题，性能比较高;&lt;/p&gt;
&lt;p&gt;4.建议:具体详细信息，大家可以参照MSDN，其概述比较详细;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）EF框架&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110011445238-1484651185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.作用:为程序员提供更加方便快捷的数据操作，对于初级程序员来说，能很快的上手，极其方便(当然，有经验的EF开发人员可能经历过EF的各种坑);&lt;/p&gt;
&lt;p&gt;2.三种模式:DB First，Code First，Model First;&lt;/p&gt;
&lt;p&gt;3.基本构成:操作工具(Linq To Entity，Entity SQL)，ObjectServices，Entity Client，EDM，ADO.NET  Data Provider;&lt;/p&gt;
&lt;p&gt;   (1)Linq To  Entity 和Entity SQL:提供了对数据操作的两种不同方式;&lt;/p&gt;
&lt;p&gt;   (2)ObjectServices:DB访问入口，实现实体与数据的转换;&lt;/p&gt;
&lt;p&gt;   (3)Entity Client:负责将Linq To Entity和Entity SQL转化为标准的SQL;&lt;/p&gt;
&lt;p&gt;   (4)EDM:实现概念模型向存储模型的转换;&lt;/p&gt;
&lt;p&gt;    (5)ADO.NET Data Provider:实现对DB的交互;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）程序编译过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110181734941-967506451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.程序编译过程大致可概述&lt;/p&gt;
&lt;p&gt;2.在控制台中操作&lt;/p&gt;
&lt;p&gt;Code:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de829739-9214-4c2c-96d0-aee47ab43505')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_de829739-9214-4c2c-96d0-aee47ab43505&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de829739-9214-4c2c-96d0-aee47ab43505&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de829739-9214-4c2c-96d0-aee47ab43505',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de829739-9214-4c2c-96d0-aee47ab43505&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ProgramRunDemo
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sum = AddSum(&lt;span&gt;10.5&lt;/span&gt;, &lt;span&gt;9.5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sum={0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sum);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            Console.Read();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; AddSum(&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110194116535-1441406626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们将AddSum()方法编译成dll文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110200405347-614251704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过反编译工具.NET Reflector查看IL代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110205916551-2057553369.png&quot; alt=&quot;&quot; width=&quot;1313&quot; height=&quot;750&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们用NotePad++编译源代码，用VS的csc.exe编译器编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110203709832-848966578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示：当在Dos命令中中提示：‘csc’不是内部或外部命令，也不是可运行的程序或批处理文件。&lt;/p&gt;
&lt;p&gt;请将.net csc.exe 路径添加到系统环境变量中，我的csc.exe路径为&lt;/p&gt;
&lt;p&gt;C:\Windows\Microsoft.NET\Framework64\v4.0.30319&lt;/p&gt;
&lt;p&gt;不会的，可以参照 &lt;a href=&quot;http://www.cnblogs.com/wangjiming/p/8006731.html&quot;&gt;csc.exe Path路径配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者参照我的另外一篇文章&lt;a href=&quot;https://jingyan.baidu.com/article/14bd256e353139bb6d261230.html&quot;&gt;【java系列】java开发环境搭建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110204122863-1351847125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;列举几个比较常用的csc.exe命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译生成 File.exe 的 File.cs&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;csc File.cs 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译生成 File.dll 的 File.cs&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; csc /&lt;span&gt;target:library File.cs
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译 File.cs 并创建 My.exe&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; csc /&lt;span&gt;out&lt;/span&gt;&lt;span&gt;:My.exe File.cs
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译当前目录中的所有 C# 文件，对其进行优化并定义 DEBUG 符号。 输出为 File2.exe&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; csc /define:DEBUG /optimize /&lt;span&gt;out&lt;/span&gt;:File2.exe *&lt;span&gt;.cs
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;编译当前目录中的所有 C# 文件，生成 File2.dll 的调试版本。 不显示徽标和警告&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; csc /target:library /&lt;span&gt;out&lt;/span&gt;:File2.dll /warn:&lt;span&gt;0&lt;/span&gt; /nologo /debug *&lt;span&gt;.cs
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前目录中的所有 C# 文件编译为 Something.xyz (DLL)&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; csc /target:library /&lt;span&gt;out&lt;/span&gt;:Something.xyz *.cs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于csc.exe的命令，大家可以参照MSDN：&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe&lt;/p&gt;
&lt;p&gt;3.编译过程大致可分为两个阶段：&lt;/p&gt;
&lt;p&gt;第一阶段：.cs代码=&amp;gt;IL代码，这个编译时间比较慢&lt;/p&gt;
&lt;p&gt;第二阶段：IL+dll通过CRL形成目标代码，这个过程比较快&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110205600207-427482029.png&quot; alt=&quot;&quot; width=&quot;84&quot; height=&quot;103&quot;/&gt;大家想想：为什么第一阶段比较慢，第二阶段比较快呢？将在下面的IL中讲到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（四）CLR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110181416801-1033725850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.作用:内存管理，异常管理，多线程管理，GC管理等。CLR为.NET中极其重要的组成部分，也是.NET框架中比较难且晦涩技术之一。&lt;/p&gt;
&lt;p&gt;2.可以把CLR看成是Java虚拟机;&lt;/p&gt;
&lt;p&gt;3.JIT即时编译，主要由三部分构成(主编译器，PreJit和EconoJit)&lt;/p&gt;
&lt;p&gt;4.JIT+CLR实现一次编译，多次运行且可跨平台;&lt;/p&gt;
&lt;p&gt;5.CLR中比较重要的一个环节，就是管道(Pipes)(HttpModule和HttpHandler)&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （五）MSIL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180109215418207-1793616136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.IL是.cs代码经过VS编译器csc.exe编译而成的；&lt;/p&gt;
&lt;p&gt;2.IL比较接近机器代码但非机器代码（这个特点使其IL=》.exe过程比较快）；&lt;/p&gt;
&lt;p&gt;3.IL代码是指令无关的；&lt;/p&gt;
&lt;p&gt;4.可以通过反汇编工具查看IL代码；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二  基于.NET Framework框架的B/S程序运行解析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）总体流程概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110024658535-720818725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 1.IIS在处理请求时，将资源分为两大类型：静态资源和动态资源&lt;/p&gt;
&lt;p&gt;     静态资源：IMG,JS,CSS,HTML等；&lt;/p&gt;
&lt;p&gt;     动态文件：ASP,ASP.NET,.aspx,..ashx,asax等；&lt;/p&gt;
&lt;p&gt; 2.IIS处理静态资源：&lt;/p&gt;
&lt;p&gt;    当IIS收到来自浏览器的请求，识别为静态资源时，IIS直接处理，将处理结果以HTML形式返回给浏览器；&lt;/p&gt;
&lt;p&gt; 3.IIS如何处理动态资源？&lt;/p&gt;
&lt;p&gt;   当IIS收到来自浏览器的请求，识别为动态资源时，此时IIS不能处理，转交给ISAPI Extensions（ISAPI 扩展程序）扩展程序，该扩展程序根据请求资源扩展名，寻找响应的程序处理，如为.asp文件，则asp_isapi处理&lt;/p&gt;
&lt;p&gt;,若为.aspx,则aspnet_isapi处理，&lt;/p&gt;
&lt;p&gt; 4.IIS如何处理WebForm和MVC？&lt;/p&gt;
&lt;p&gt;  当IIS收到来自浏览器的请求，识别为动态资源时，此时IIS不能处理，转交给ISAPI Extensions处理，此时ASP.NET MVC HTTP处理程序识别请求资源是否为MVC，若是，则交给MVC路由，按照处理MVC方式处理，否则&lt;/p&gt;
&lt;p&gt;，按照WebForm流程处理；&lt;/p&gt;
&lt;p&gt;5.CLR里面的管道（Pipes）是怎样的呢？&lt;/p&gt;
&lt;p&gt;   管道的本质是HttpModule和HttpHandler(一般处理程序.ashx);&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （二）CLR和Pipe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110021131754-1794923343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （三）TCP/IP模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180110031440926-2096843504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 1.这个结构为当前比较标准的TCP/IP五层模型，在五层模型成为通用规范前，有七层模型和四层模型两大种类；&lt;/p&gt;
&lt;p&gt; 2.关于这五层，谢希仁编写的《计算机网络》讲得比较详细且透彻，感兴起的朋友可以去看看；&lt;/p&gt;
&lt;p&gt; 3.为什么要提到TCP/IP呢？很简单，我们在浏览器输入：http://www.google.com.hk/，发生了过程中，TCP/IP就不可或缺；&lt;/p&gt;
&lt;p&gt; 4.在这里不多讲，会在后续文章WebApi和HTTP协议中详细讲解；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三  参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【01】http://www.wrox.com/&lt;/p&gt;
&lt;p&gt;【02】&lt;img src=&quot;file:///C:/Users/Alan_beijing/AppData/Roaming/Tencent/QQ/Temp/%25W@GJ$ACOF(TYDYECOKVDYB.png&quot; alt=&quot;&quot;/&gt;http://msdn.microsoft.com/en-us/library/system.web.httpapplication(v=vs.80).aspx&lt;/p&gt;
&lt;p&gt;【03】ASP.NET MVC5 高级编程(Jon Galloway,Brad Wilson,K.Scott Allen,David Matson 著 ,孙远帅 译)&lt;/p&gt;
&lt;p&gt;【04】ASP.NET MVC5编程实战（第3版）（Dino Esposite 著，潘丽丞 译）&lt;/p&gt;
&lt;p&gt;【05】ASP.NET MVC4 开发指南   （黄保翕 作）&lt;/p&gt;
&lt;p&gt;【06】计算机网络 （第6版）（谢希仁 著）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四   版权区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2016177728@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 10 Jan 2018 13:52:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8201129.html</dc:identifier>
</item>
<item>
<title>类和对象的创建过程（元类，__new__,__init__,__call__） - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/8260151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/8260151.html</guid>
<description>&lt;h2&gt;1、创建类的两种方式&lt;/h2&gt;
&lt;h3&gt;方式一&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyClass(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(self,name):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)

myc &lt;/span&gt;=&lt;span&gt; MyClass()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(MyClass, type(MyClass))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myc, type(myc))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们创建了一个名为MyClass的类，并实例化了这个类，得到其对象myc&lt;/p&gt;
&lt;p&gt;上面代码打印的结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;    &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.MyClass object at 0x0288F8F0&amp;gt;   &amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;type()&lt;/code&gt;函数可以查看一个类型或变量的类型，&lt;code&gt;MyClass&lt;/code&gt;是一个class，它的类型就是&lt;code&gt;type&lt;/code&gt;，而&lt;code&gt;h&lt;/code&gt;是一个实例，它的类型就是class &lt;code&gt;myc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们说class的定义是运行时动态创建的，而创建class的方法就是使用&lt;code&gt;type()&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;type()&lt;/code&gt;函数既可以返回一个对象的类型，又可以创建出新的类型&lt;/span&gt;，比如，我们可以通过&lt;code&gt;type()&lt;/code&gt;函数创建出&lt;code&gt;MyClass&lt;/code&gt;类，而无需通过&lt;code&gt;Class MyClass(object)...&lt;/code&gt;的定义：&lt;/p&gt;

&lt;h3&gt;方式二&lt;/h3&gt;
&lt;p&gt;动态创建类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; fn(self, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先定义函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello, %s.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; name)

MyClass &lt;/span&gt;= type(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, (object,), {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:fn}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建MyClass类,得到一个type的类对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; MyClass = type('MyClass', (object,), {'func':lambda self,name:name}) # 创建MyClass类&lt;/span&gt;
&lt;span&gt;
myc&lt;/span&gt;=&lt;span&gt;MyClass()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(MyClass, type(MyClass))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(myc, type(myc))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt; 　　&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.MyClass object at 0x0364B830&amp;gt; 　　&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__.MyClass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要创建一个class对象，&lt;span&gt;&lt;code&gt;type()&lt;/code&gt;函数依次传入3个参数：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;class的名称；&lt;/li&gt;
&lt;li&gt;继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；&lt;/li&gt;
&lt;li&gt;class的方法名称与函数绑定，这里我们把函数&lt;code&gt;fn&lt;/code&gt;绑定到方法名&lt;code&gt;func&lt;/code&gt;上。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;通过&lt;code&gt;type()&lt;/code&gt;函数创建的类和直接写class是完全一样的&lt;/span&gt;，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用&lt;code&gt;type()&lt;/code&gt;函数创建出class。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;type就是创建类对象的类。&lt;/span&gt;&lt;/strong&gt;你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类(元类，默认为type，也可以自定制)创建而来。type也是由type创建。。&lt;/p&gt;


&lt;p&gt;除了使用&lt;code&gt;type()&lt;/code&gt;动态创建类以外，要控制类的创建行为，还可以使用metaclass。&lt;/p&gt;
&lt;p&gt;metaclass，直译为元类，简单的解释就是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义元类（不自定义时，默认用type），然后创建类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;连接起来就是：&lt;span&gt;先定义metaclass，就可以创建类，最后创建实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是元类创建出来的“实例”。&lt;/p&gt;

&lt;h2&gt;使用metaclass的两种方式&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyType(type):　　&lt;span&gt;# 自定义一个type的派生类
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self,*args,**&lt;span&gt;kwargs):&lt;br/&gt;　　　　print('xx')
       super(MyType,self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(*args,**&lt;span&gt;kwargs)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        obj &lt;/span&gt;= cls.&lt;span&gt;__new__&lt;/span&gt;(cls,*args, **&lt;span&gt;kwargs)
        cls.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(obj,*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; with_metaclass(base):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; MyType(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyType2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,(base,),{})

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式一&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Foo(metaclass=&lt;span&gt;MyType):　　&lt;span&gt;# metaclass=MyType,即指定了由MyType创建Foo类，当程序运行，用到class Foo时，即调用MyType的__init__方法，创建Foo类
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):&lt;/span&gt;&lt;span&gt;
        self.name &lt;/span&gt;=&lt;span&gt; name


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;方式二    在Flask的wtform的源码中用到过&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; class Foo(with_metaclass(object)):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     def __init__(self,name):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         self.name = name&lt;/span&gt;
&lt;span&gt;

a&lt;/span&gt;=Foo(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 方式一:即用类的形式&lt;/h3&gt;
&lt;p&gt;　　执行代码后，当遇到class Foo时即声明要创建一个Foo类，就会调用type的__init__方法创建类，由于此处（metaclass=MyType），即指定了Foo类的创建方式，所以会执行type的派生类MyType的__init__方法，创建Foo类，打印一次'xx'&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　 &lt;/strong&gt;*&lt;/span&gt;一般情况下, 如果你要用类来实现metaclass的话，该类需要继承于type，而且通常会重写type的__new__方法来控制创建过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　* 在metaclass里面定义的方法会成为类的方法，可以直接通过类名来调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;方式二：用函数的形式&lt;/h3&gt;
&lt;p&gt;　　构建一个函数，返回一个type的派生类对象，例如叫type的派生类, 需要3个参数：name, bases, attrs&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　name: 类的名字&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　bases: 基类，通常是tuple类型&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;　　attrs: dict类型，就是类的属性或者函数&lt;/p&gt;



&lt;h2 class=&quot;p1&quot;&gt; metaclass 原理&lt;/h2&gt;
&lt;h3&gt;1.基础&lt;/h3&gt;
&lt;p class=&quot;p1&quot;&gt;metaclass的原理其实是这样的：当定义好类之后，创建类的时候其实是调用了type的__new__方法为这个类分配内存空间，创建好了之后再调用type的__init__方法初始化（做一些赋值等）。所以metaclass的所有magic其实就在于这个__new__方法里面了。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;说说这个方法：__new__(cls, name, bases, attrs)&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;cls: 将要创建的类，类似与self，但是self指向的是instance，而这里cls指向的是class&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;name: 类的名字，也就是我们通常用类名.__name__获取的。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;bases: 基类&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;attrs: 属性的dict。dict的内容可以是变量(类属性），也可以是函数（类方法）。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;所以在创建类的过程，我们可以在这个函数里面修改name，bases，attrs的值来自由的达到我们的功能。这里常用的配合方法是&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;getattr和setattr（just an advice)&lt;/p&gt;

&lt;h3&gt;2.查找顺序&lt;/h3&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;0-0&quot;&gt;元类是由以下优先规则决定的:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;2-0&quot;&gt;如果“元类”存在，它就被使用了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;4-0&quot;&gt;否则，如果至少有一个基类，则使用它的元类(这首先查找类属性，如果没有找到，则使用它的类型)。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot;&gt;&lt;span class=&quot;tgt&quot; data-group=&quot;6-0&quot;&gt;否则，如果一个名为元类的全局变量存在，就会使用它。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;__new__： 对象的创建，是一个静态方法，第一个参数是cls。(想想也是，不可能是self，对象还没创建，哪来的self)&lt;/p&gt;
&lt;p&gt;　　　　　 其&lt;span&gt;必须要有返回值，返回实例化出来的实例&lt;/span&gt;，需要注意的是，可以return父类__new__()出来的实例，也可以直接将object的__new__()出来的实例返回。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;__init__ ： 对象的初始化， 是一个实例方法，第一个参数是self，该self参数就是__new__()返回的实例，__init__()在__new__()的基础上可以完成一些其它初始化的动作，__init__()不需要返回值。&lt;br/&gt;__call__ ： 对象可call，注意不是类，是对象。&lt;/p&gt;
&lt;h2&gt;1.对于__new__&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Bar()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Foo()) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Bar object at 0x0090F930&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到，输出来是一个Bar对象。&lt;/p&gt;
&lt;p&gt;　　__new__方法在类定义中不是必须写的，如果没定义，默认会调用object.__new__去创建一个对象。如果定义了，就是会覆盖,使用自定义的，这样就可以自定制创建对象的行为。&lt;/p&gt;
&lt;p&gt; 单例模式也可以通过这种方式来创建。&lt;a href=&quot;http://www.cnblogs.com/huchong/p/8244279.html#_lab2_1_2&quot; target=&quot;_blank&quot;&gt;点击查看【几种单例模式的创建方法】&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2.对于__init__&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):

  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age):
    self.name &lt;/span&gt;=&lt;span&gt; name
    self.age &lt;/span&gt;=&lt;span&gt; age
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__new__&lt;/span&gt;(cls, *args, **&lt;span&gt;kwargs):
      obj &lt;/span&gt;= object.&lt;span&gt;__new__&lt;/span&gt;(cls) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建对象&lt;/span&gt;
      &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;执行__new__方法&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj

p1 &lt;/span&gt;= Person(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 24&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(p1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;执行__new__方法
执行__init__
&lt;/span&gt;&amp;lt;&lt;span&gt;__main__&lt;/span&gt;.Person object at 0x028EB830&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　__init__ 方法通常用在初始化一个类实例的时候，但__init__其实不是实例化一个类的时候第一个被调用 的方法。当使用 Persion(name, age) 这样的表达式来实例化一个类时，最先被调用的方法 其实是 __new__ 方法。从打印结果就可以看出来&lt;/p&gt;
&lt;p&gt;　　若__new__()没有正确返回当前类cls的实例，那__init__()将不会被调用，即使是父类的实例也不行。&lt;/p&gt;

&lt;h2&gt;3.对于__call__&lt;/h2&gt;
&lt;p&gt;　　对象通过提供__call__(slef, *args ,**kwargs)方法可以模拟函数的行为，如果一个对象x提供了该方法，就可以像函数一样使用它，也就是说x(arg1, arg2...) 等同于调用x.__call__(self, arg1, arg2) 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(object): 
  &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self): 
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt; 
 
f &lt;/span&gt;= Foo()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;类()，即执行元类的__call__&lt;/span&gt;
f()    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对象()，即执行Foo的__call__ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo(Bar):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们写如这段代码时，Python做了如下的操作：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;Foo中有metaclass这个属性吗？如果是，Python会在内存中通过metaclass创建一个名字为Foo的类对象（我说的是类对象，请紧跟我的思路）。如果Python没有找到metaclass，它会继续在Bar（父类）中寻找metaclass属性，并尝试做和前面同样的操作。如果Python在任何父类中都找不到metaclass，它就会在模块层次中去寻找metaclass，并尝试做同样的操作。如果还是找不到metaclass,Python就会用内置的type来创建这个类对象。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　把上面这段话反复读几次，现在的问题就是，你可以在metaclass中放置些什么代码呢？&lt;/p&gt;
&lt;p&gt;　　答案就是：可以创建一个类的东西。&lt;/p&gt;
&lt;p&gt;　　那么什么可以用来创建一个类呢？&lt;/p&gt;
&lt;p&gt;　　type，或者任何使用到type或者子类化type的东东都可以。&lt;/p&gt;

&lt;p&gt;以上面的代码为例，我们实例化一个对象obj=Foo()时，会先执行Foo类的__new__方法，没写时，用父类的__new__方法，创建一个对象，并返回，然后执行__init__方法（自己有就用自己的，没有就用父类的），对创建的对象进行初始化。&lt;/p&gt;
&lt;p&gt;obj()会执行Foo类的__call__方法，没有则用父类的&lt;/p&gt;
&lt;p&gt;我们现在已经知道，类也是对象，是元类的对象，即我们实例化一个类时，调用其元类的__call__方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;元类处理过程：定义一个类时，使用声明或者默认的元类对该类进行创建，&lt;/strong&gt;对元类求type运算，得到父元类（该类声明的元类的父元类），调用父元类的__call__函数，在父元类的__call__函数中, 调用该类声明的元类的__new__函数来创建对象（该函数需要返回一个对象（指类）实例），然后再调用该元类的__init__初始化该对象（此处对象是指类，因为是元类创建的对象），最终返回该类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.对象是类创建，创建对象时候类的__init__方法自动执行，对象()执行类的 __call__ 方法&lt;br/&gt;2.类是type创建，创建类时候type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__方法)&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;原始type的__call__应该是参数结构应该是：

　　metaname, clsname, baseclasses, attrs

 

原始type的__new__

　　metaname, clsname, baseclasses, attrs

 

原始type的__init__

　　class_obj, clsname, baseclasses, attrs

 

元类的__new__和__init__影响的是创建类对象的行为，父元类的__call__控制对子元类的 &lt;/span&gt;&lt;span&gt;__new__&lt;/span&gt;，&lt;span&gt;__init__的调用&lt;/span&gt;&lt;span&gt;，就是说控制类对象的创建和初始化。父元类的__new__和__init__由更上层的控制，

　　　　一般来说，原始type是最初的父元类，其__new__和__init__是具有普遍意义的，即应该是分配内存、初始化相关信息等

元类__call__影响的是创建类的实例对象的行为，此时如果类自定义了__new__和__init__就可以控制类的对象实例的创建和初始化

 

&lt;/span&gt;&lt;span&gt;__new__和__init__&lt;/span&gt;&lt;span&gt; 影响的是创建对象的行为，当这些函数在元类中时，影响创建的是类；同理，当这俩个函数在普通类中时，影响创建的是普通的对象实例。

&lt;/span&gt;&lt;span&gt;__call__&lt;/span&gt; 影响()调用行为, &lt;span&gt;__call__是在创建类的时候调用&lt;/span&gt;，即: &lt;span&gt;class&lt;/span&gt; Test(object): &lt;span&gt;__metaclass__&lt;/span&gt;=&lt;span&gt;type, 定义类时就是创建类，此时会调用元类的__call__，如果元类有继承，子元类定义时执行的是父元类的__call__。

             如果是普通类实例化对象，调用的是普通类的__call__

 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 10 Jan 2018 11:18:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/8260151.html</dc:identifier>
</item>
</channel>
</rss>