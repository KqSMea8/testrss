<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>封装字体图标库 - qiu_freedom</title>
<link>http://www.cnblogs.com/qiu-freedom/p/9196792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiu-freedom/p/9196792.html</guid>
<description>&lt;p&gt;参考了以下博客:&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/Doulvme/article/details/54290450&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/qq_25479327/article/details/77167585&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/muzidigbig/article/details/80371341&lt;/p&gt;
&lt;h2&gt;查找图标并下载&lt;/h2&gt;
&lt;p&gt;1.打开阿里的矢量字体图标库(http://iconfont.cn/collections)并登陆.&lt;/p&gt;
&lt;p&gt;2.搜寻需要的图标加入购物车.&lt;/p&gt;
&lt;p&gt;3.点击购物车选择--&amp;gt;下载代码.&lt;/p&gt;
&lt;p&gt;4.解压&lt;/p&gt;
&lt;h2&gt;详细介绍&lt;/h2&gt;
&lt;p&gt;真正有用的是红色选中的,剩余的是使用的演示.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1105571/201806/1105571-20180618232951854-49733506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;图标使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.通过类名方式使用图标:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先打开iconfont.css,其中红色标记的地方时可以修改的,如果移动了文件,写上正确的url路径.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1105571/201806/1105571-20180618231314267-473434004.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中类名icon是给图标添加样式的,自己可以改&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.通过svg标签方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;script src=&quot;iconfont.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;svg &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;icon&quot;&lt;/span&gt;&lt;span&gt; aria-hidden&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;use &lt;/span&gt;&lt;span&gt;xlink:href&lt;/span&gt;&lt;span&gt;=&quot;#icon-15tianwuliyoutuihuo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;svg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一种方式我们修改了iconfont.css中的类名也不会影响svg的使用,因为第二种方式是不使用类名的,所以不会影响.&lt;/p&gt;
&lt;p&gt;第二种方式我们需要引入&lt;span&gt;&lt;strong&gt;iconfont.js文件.然后通过修改&lt;/strong&gt;&lt;/span&gt;#icon- 后面的值获得图标.图标的名称和unicode我们可以在.svg后缀的文件夹中查看.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1105571/201806/1105571-20180618230630252-765123363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.通过使用unicode编码方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要写入font-face:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        @font-face &lt;/span&gt;{&lt;span&gt;font-family&lt;/span&gt;:&lt;span&gt; &quot;&lt;span&gt;iconfont&lt;/span&gt;&quot;&lt;/span&gt;;&lt;span&gt;
          src&lt;/span&gt;:&lt;span&gt; url('iconfont.eot')&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; IE9&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          src&lt;/span&gt;:&lt;span&gt; url('iconfont.eot#iefix') format('embedded-opentype'), &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; IE6-IE8 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          url('iconfont.woff') format('woff'), &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; chrome, firefox &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          url('iconfont.ttf') format('truetype'), &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; chrome, firefox, opera, Safari, Android, iOS 4.2+&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          url('iconfont.svg#iconfont') format('svg')&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; iOS 4.1- &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        }&lt;span&gt;&lt;span&gt;
        .iconfont&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt;/*iconfont与@font-face中的font-family的字体名称保持一致*/
          font-family&lt;/span&gt;:&lt;span&gt;&quot;&lt;span&gt;iconfont&lt;/span&gt;&quot; !important&lt;/span&gt;;&lt;span&gt;
          font-size&lt;/span&gt;:&lt;span&gt;16px&lt;/span&gt;;&lt;span&gt;
          font-style&lt;/span&gt;:&lt;span&gt;normal&lt;/span&gt;;&lt;span&gt;
          -webkit-font-smoothing&lt;/span&gt;:&lt;span&gt; antialiased&lt;/span&gt;;&lt;span&gt;
          -webkit-text-stroke-width&lt;/span&gt;:&lt;span&gt; 0.2px&lt;/span&gt;;&lt;span&gt;
          -moz-osx-font-smoothing&lt;/span&gt;:&lt;span&gt; grayscale&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;main markdown&quot;&amp;gt;&lt;br/&gt;&amp;lt;h1&amp;gt;IconFont 图标&amp;lt;/h1&amp;gt;&lt;br/&gt; &amp;lt;ul class=&quot;icon_lists clear&quot;&amp;gt;&lt;br/&gt;  &amp;lt;li&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!--显示图标--&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!--与上面的css中绿色背景类名一致,icon是图标样式的类名--&amp;gt;&lt;br/&gt;   &amp;lt;i class=&quot;icon &lt;span&gt;iconfont&lt;/span&gt;&quot;&amp;gt;&amp;amp;#xe606;&amp;lt;/i&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!--显示文字--&amp;gt;&lt;br/&gt;   &amp;lt;div class=&quot;code&quot;&amp;gt;&amp;amp;amp;#xe606;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/li&amp;gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 18 Jun 2018 15:49:00 +0000</pubDate>
<dc:creator>qiu_freedom</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiu-freedom/p/9196792.html</dc:identifier>
</item>
<item>
<title>在Golang中使用Redis - zzayne</title>
<link>http://www.cnblogs.com/zzayne/p/9196790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzayne/p/9196790.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;周五上班的主要任务是在公司老平台上用redis处理一个队列问题，顺便复习了一下redis操作的基础知识，回来后就想着在自己的博客demo里，用redis来优化一些使用场景，学习一下golang开发下redis的使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;redis简单介绍&quot;&gt;Redis简单介绍&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;关于Redis的讨论，其实在现在的后台开发中已经是个老生常谈的问题，基本上也是后端开发面试的基本考察点。其中 Redis的背景介绍和细节说明在这里就不赘述。不管怎么介绍，核心在于Redis是一个基于内存的key-value的多数据结构存储，并可以提供持久化服务。基于内存的特性决定了Redis天然适合高并发的数据读写缓存优化，同时也带来了内存开销过大的问题。所以在一些特定情景下，Redis是一把无往不利的大杀器，值得深入学习。&lt;/p&gt;
&lt;p&gt;学习Redis的一个难点或者说入门点，我个人感觉在于对象存储理念的转变。刚接触&lt;code&gt;Redis&lt;/code&gt;时，我刚从大学毕业，脑子里基本都是关系型数据存储的理念，使用时总想着靠数据内的关系来建立数据之间的联系，用起来很不顺手。后来慢慢入门了才感受到了一些操作的好处。举个栗子，比如查询用户在某个文章下的评论，用&lt;code&gt;sql&lt;/code&gt;的思路就是搜索评论表里面用户ID和文章ID匹配的数据，有时还需要联合查询出其他信息，但是如果是&lt;code&gt;Redis&lt;/code&gt;操作，以'前缀:文章ID:用户ID'为key，比如'comment:666:888'就可以快速取出用户评论，十分方便。&lt;code&gt;Redis&lt;/code&gt;的强大远不仅如此，可以在实践中慢慢体会。&lt;/p&gt;
&lt;h3 id=&quot;主要数据结构&quot;&gt;主要数据结构&lt;/h3&gt;
&lt;p&gt;Redis主要有五种基本数据结构，满足了绝大多数缓存结构的需要，如果你在使用一种结构存储时感觉别扭时，很有可能是选错了存储结构，可以考虑一下其他结构的正确实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;String ，可以是字符串、整数和浮点数。如果是序列化数据，并涉及到修改操作的话，不推荐用&lt;code&gt;string&lt;/code&gt;，可以考虑用&lt;code&gt;Hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hash, key-value 对象，可以存放对象数据，比如用户信息之类。&lt;/li&gt;
&lt;li&gt;List，有序数据集合，元素可以重复，用&lt;code&gt;LPUSH&lt;/code&gt;、&lt;code&gt;LPOP&lt;/code&gt;、&lt;code&gt;RPUSH&lt;/code&gt;、&lt;code&gt;RPOP&lt;/code&gt;等指令组合可以实现栈和队列操作。&lt;/li&gt;
&lt;li&gt;Set，无序集合，元素唯一。&lt;/li&gt;
&lt;li&gt;Sorted Set，Sort的有序版，可以设定&lt;code&gt;Score&lt;/code&gt;值来决定元素排序，适合用户排名这样的业务场景。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;常见使用场景&quot;&gt;常见使用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;高并发下数据缓存。 比如在某个场景下，大量日志同时写入数据库会给服务器带来巨大压力，这时可以先将数据写入&lt;code&gt;redis&lt;/code&gt;中，再由&lt;code&gt;redis&lt;/code&gt;写入数据库，减轻同时写入压力。&lt;/li&gt;
&lt;li&gt;热点信息快速显示。假设现在有一个新闻首页，需要快速显示各栏目前20条热点新闻，如果直接查询数据库，在大量用户同时访问下，会消耗极大数量的数据库请求。这时就可以用&lt;code&gt;redis&lt;/code&gt;来优化，在新闻录入的时候将标题、时间和来源写入&lt;code&gt;redis&lt;/code&gt;中，客户端访问时，可以从内存中一次性取出当天热单新闻列表，极大地提高请求速度和节约了服务器开销。&lt;/li&gt;
&lt;li&gt;保存会话信息。可以将登录后用户信息缓存入&lt;code&gt;redis&lt;/code&gt;并同时设置&lt;code&gt;key&lt;/code&gt;过期时间,这样后台&lt;code&gt;api&lt;/code&gt;过滤请求时，就可以从内存中读取用户信息，而且&lt;code&gt;redis&lt;/code&gt;的过期机制，天然支持用户身份有效期校验，用起来十分方便。&lt;/li&gt;
&lt;li&gt;统计计数。比如系统中常见一个功能是限制同一用户固定时间段内的登录次数或者所有请求次数，这时就可以以用户id为key，次数值为value，将计数信息缓存起来，并且有&lt;code&gt;INCRBY&lt;/code&gt;命令原生支持。&lt;/li&gt;
&lt;li&gt;其他。Redis的应用场景十分广发，队列、发布订阅、统计分析等等，可以看看其他文章的介绍说明。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;golang连接redis&quot;&gt;Golang连接Redis&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;Golang&lt;/code&gt;开发的一大直观感受就是，基本上你日常遇到的开发问题，都有官方或者第三方包帮你辅助实现，同时这些包都是开源的，只要你感兴趣，都可以深入到包的内部实现去学习理解包的实现思路和方法。当然这也有利有弊，第三包的不稳定和质量参差不齐也增加了一些开发成本，目前还是感受利大于弊。研究好的包源码实现，也是目前我的一个学习方向。&lt;/p&gt;
&lt;h3 id=&quot;garyburdredigo-包简介&quot;&gt;garyburd/redigo 包简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;garyburd/redigo&lt;/code&gt; 包是网上很多博文都在推荐使用的一个高Star的&lt;code&gt;Redis&lt;/code&gt;连接包，但是当我自己去&lt;code&gt;Github&lt;/code&gt;的项目地址 &lt;a href=&quot;https://github.com/garyburd/redigo&quot;&gt;garyburd/redigo&lt;/a&gt; 上查看&lt;code&gt;API&lt;/code&gt;时，发现这个项目目前是归档状态，项目已经迁移到了&lt;a href=&quot;https://github.com/gomodule/redigo&quot;&gt;gomodule/redigo&lt;/a&gt;，同时包的获取也理所当然地改成了&lt;code&gt;go get github.com/gomodule/redigo/redis&lt;/code&gt;，这已经不是我第一次感受了第三方包的不稳定，之前用&lt;code&gt;dep&lt;/code&gt;进行包管理时，就遇到过&lt;code&gt;dep&lt;/code&gt;拉取的包版本和本地包版本&lt;code&gt;API&lt;/code&gt;冲突的问题，这个有时间单独再说。总之，暂时不管这两个包的详细区别，以下就以新包为准，介绍下&lt;code&gt;redigo&lt;/code&gt;包使用。&lt;/p&gt;
&lt;h3 id=&quot;建立连接池&quot;&gt;建立连接池&lt;/h3&gt;
&lt;p&gt;Redigo Pool 结构维护一个 Redis 连接池。应用程序调用 Get 方法从池中获取连接，并使用连接的 Close 方法将连接的资源返回到池中。一般我们在系统初始化时声明一个全局连接池，然后在需要操作&lt;code&gt;redis&lt;/code&gt;时获得连接，执行指令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pool := &amp;amp;redis.Pool{
        MaxIdle:     3, /*最大的空闲连接数*/
        MaxActive:   8, /*最大的激活连接数*/
        Dial: func() (redis.Conn, error) {
            c, err := redis.Dial(&quot;tcp&quot;, '链接地址，例如127.0.0.1:6379', redis.DialPassword('密码'))
            if err != nil {
                return nil, err
            }
            return c, nil
        }
}
c:=pool.Get()
defer c.Close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;执行指令&quot;&gt;执行指令&lt;/h3&gt;
&lt;p&gt;查看源码，发现&lt;code&gt;Conn&lt;/code&gt; 接口有一个执行 Redis 命令的通用方法：&lt;/p&gt;
&lt;p&gt;```&lt;br/&gt;//gomodule/redigo/redis/redis.go&lt;/p&gt;
&lt;p&gt;// Conn represents a connection to a Redis server.&lt;br/&gt;type Conn interface {&lt;br/&gt;// Close closes the connection.&lt;br/&gt;Close() error&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Err returns a non-nil value when the connection is not usable.
Err() error

// Do sends a command to the server and returns the received reply.
Do(commandName string, args ...interface{}) (reply interface{}, err error)

// Send writes the command to the client's output buffer.
Send(commandName string, args ...interface{}) error

// Flush flushes the output buffer to the Redis server.
Flush() error

// Receive receives a single reply from the Redis server
Receive() (reply interface{}, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://redis.io/commands&quot; class=&quot;uri&quot;&gt;http://redis.io/commands&lt;/a&gt; 中的 Redis 命令参考列出了可用的命令。&lt;code&gt;do&lt;/code&gt;的参数和&lt;code&gt;redis-cli&lt;/code&gt;命令参数格式一致，比如&lt;code&gt;SET key value EX 360&lt;/code&gt; 对应函数调用为&lt;code&gt;Do(&quot;SET&quot;, &quot;key&quot;, &quot;value&quot;，&quot;EX&quot;,360)&lt;/code&gt;，常用的命令示例有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
c:=pool.Get()
defer c.Close()
//存值,
_, err := c.Do(&quot;SET&quot;, &quot;key&quot;, &quot;value&quot;)
//设置过期时间
_, err := c.Do(&quot;SET&quot;, &quot;key&quot;, &quot;value&quot;，&quot;EX&quot;,360)
//存int
_, err := c.Do(&quot;SET&quot;, &quot;key&quot;, 2)

//取值
v,err:=redis.String(c.Do(&quot;GET&quot;,&quot;key&quot;))
bytes, err := redis.Bytes(c.Do(&quot;GET&quot;, &quot;key&quot;))

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;golang&lt;/code&gt;中连接使用&lt;code&gt;redis&lt;/code&gt;相对比较简单，所以暂时也没什么其他好说的，如果后面自己使用过程中发现有遗漏再进行补充，关键还是在于熟悉&lt;code&gt;redis-cli&lt;/code&gt;原生的指令操作。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 15:47:00 +0000</pubDate>
<dc:creator>zzayne</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzayne/p/9196790.html</dc:identifier>
</item>
<item>
<title>oracle database 9i/10g/11g 编程艺术 源代码下载 - 彭树林</title>
<link>http://www.cnblogs.com/shulin-peng/p/9196776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shulin-peng/p/9196776.html</guid>
<description>&lt;p&gt;背景&lt;/p&gt;
&lt;p&gt;在找这本书的源码，搜到提供的都是需要C币下载的。比较固执（其实是穷）。&lt;/p&gt;
&lt;p&gt;在这本书的前言中提到源代码可以在 www.appress.com 上下载。&lt;/p&gt;
&lt;p&gt;下面是该书在该网站上的链接：&lt;/p&gt;
&lt;p&gt;https://www.apress.com/us/book/9781430229469&lt;/p&gt;
&lt;p&gt;点击&lt;/p&gt;
&lt;p&gt;Download source code &lt;/p&gt;
&lt;p&gt;链接到 github，可以下载本书相关源代码。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 15:41:00 +0000</pubDate>
<dc:creator>彭树林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shulin-peng/p/9196776.html</dc:identifier>
</item>
<item>
<title>搞定C系语言的的swap - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9196762.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9196762.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cs.utsa.edu/~wagner/CS2213/swap/swap.html&quot; target=&quot;_blank&quot;&gt;http://www.cs.utsa.edu/~wagner/CS2213/swap/swap.html&lt;/a&gt; 原地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parameters, by value and by reference:&lt;/strong&gt; Both C and Java use only parameters that pass &lt;em&gt;by value&lt;/em&gt;, which means that the &lt;em&gt;value&lt;/em&gt; of the actual parameter is used to initialize the formal parameter. For simple variables C allows one to pass the &lt;em&gt;address&lt;/em&gt; of the variable &lt;em&gt;explicitly&lt;/em&gt;. (Java does not allow this.) This is sometimes called passing a parameter &lt;em&gt;by reference&lt;/em&gt;. C++ allows this also, but C++ also allows an &lt;em&gt;implicit&lt;/em&gt; pass by reference, which will be described at the end of this writeup.&lt;/p&gt;
&lt;p&gt;In C, the mechanism above is what is used for parameters in the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;scanf&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; function, which have the extra &lt;tt&gt;&lt;span&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; (the &quot;address of&quot; operator) in front of them.&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;A swapping values:&lt;/strong&gt; In C and in Java, we can always swap values with the use of three assignment statement and no function or paramters. The code on the left shows this, while the code on the right shows how the same task can be accomplished using the C &lt;em&gt;exclusive-or&lt;/em&gt; operator &lt;tt&gt;&lt;span&gt;&lt;strong&gt;^&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. (Notice that is this case you don't need the variable &lt;tt&gt;&lt;span&gt;&lt;strong&gt;t&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;.)&lt;/p&gt;

&lt;center&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; bgcolor=&quot;#F2FFF2&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr&gt;&lt;th&gt;C Simple Swap Program -- Assignments&lt;/th&gt;
&lt;th&gt;C Simple Swap Program -- Exclusive-Or&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;30&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
#include &amp;lt;stdio.h&amp;gt;

int main() {
   int a = 23, b = 47;
   int t;
   printf(&quot;Before. a: %d, b: %d\n&quot;, a, b);
   &lt;span&gt;t = a;
   a = b;
   b = t;&lt;/span&gt;
   printf(&quot;After.  a: %d, b: %d\n&quot;, a, b);
   return 0;
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
#include &amp;lt;stdio.h&amp;gt;

int main() {
   int a = 23, b = 47;
   
   printf(&quot;Before. a: %d, b: %d\n&quot;, a, b);
   &lt;span&gt;a ^= b;
   b ^= a;
   a ^= b;&lt;/span&gt;
   printf(&quot;After.  a: %d, b: %d\n&quot;, a, b);
   return 0;
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Runs of the two programs&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;strong&gt;&lt;span&gt;cc -o swap_simple0 swap_simple0.c&lt;/span&gt;&lt;/strong&gt;
% &lt;strong&gt;&lt;span&gt;swap_simple0&lt;/span&gt;&lt;/strong&gt;
Before. a: 23, b: 47
After.  a: &lt;strong&gt;&lt;span&gt;47&lt;/span&gt;&lt;/strong&gt;, b: &lt;strong&gt;&lt;span&gt;23&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;strong&gt;&lt;span&gt;cc -o swap_simple1 swap_simple1.c&lt;/span&gt;&lt;/strong&gt;
% &lt;strong&gt;&lt;span&gt;swap_simple1&lt;/span&gt;&lt;/strong&gt;
Before. a: 23, b: 47
After.  a: &lt;strong&gt;&lt;span&gt;47&lt;/span&gt;&lt;/strong&gt;, b: &lt;strong&gt;&lt;span&gt;23&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/center&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;A swapping function:&lt;/strong&gt; To understand how explicit pass by reference of parameters works in C, consider implementing a &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; function in C, that is, a function that passes in two variables and swaps their values. The code on the left below shows one failed attempt at an implementation. The code on the right uses pointers, that is, explicitly passes the address of variables, and manipulates the numbers that are at that address, using the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;*&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; operator (the &quot;dereference&quot; operator that fetches the contents of the given address).&lt;/p&gt;

&lt;center&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; bgcolor=&quot;#F2FFF2&quot;&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr&gt;&lt;th&gt;C Swap Program -- Fails&lt;/th&gt;
&lt;th&gt;C Swap Program with Pointers -- Works&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;39&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
#include &amp;lt;stdio.h&amp;gt;

void swap(int i, int j) {
   int t = i;
   i = j;
   j = t;
}

int main() {
   int a = 23, b = 47;
   printf(&quot;Before. a: %d, b: %d\n&quot;, a, b);
   swap(a,b);
   printf(&quot;After.  a: %d, b: %d\n&quot;, a, b);
   return 0;
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
#include &amp;lt;stdio.h&amp;gt;

void swap(int &lt;span&gt;*&lt;/span&gt;i, int &lt;span&gt;*&lt;/span&gt;j) {
   int t = &lt;span&gt;*&lt;/span&gt;i;
   &lt;span&gt;*&lt;/span&gt;i = &lt;span&gt;*&lt;/span&gt;j;
   &lt;span&gt;*&lt;/span&gt;j = t;
}

void main() {
   int a = 23, b = 47;
   printf(&quot;Before. a: %d, b: %d\n&quot;, a, b);
   swap(&lt;span&gt;&amp;amp;&lt;/span&gt;a, &lt;span&gt;&amp;amp;&lt;/span&gt;b);
   printf(&quot;After . a: %d, b: %d\n&quot;, a, b);
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Runs of the two programs&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;strong&gt;&lt;span&gt;cc -o swap0 swap0.c&lt;/span&gt;&lt;/strong&gt;
% &lt;strong&gt;&lt;span&gt;swap0&lt;/span&gt;&lt;/strong&gt;
Before. a: 23, b: 47
After.  a: 23, b: 47
&lt;/pre&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;strong&gt;&lt;span&gt;cc -o swap1 swap1.c&lt;/span&gt;&lt;/strong&gt;
% &lt;strong&gt;&lt;span&gt;swap1&lt;/span&gt;&lt;/strong&gt;
Before. a: 23, b: 47
After.  a: &lt;span&gt;&lt;strong&gt;47&lt;/strong&gt;&lt;/span&gt;, b: &lt;span&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/center&gt;
&lt;p&gt;With the program on the left, no swapping took place. The values of &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; are passed to &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, and the function does swap them, but when the function returns, nothing has changed in the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;main&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;To get an idea of what this code does, print it out, draw the two integers &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, and enter &lt;tt&gt;&lt;span&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;47&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; in them. Now draw the two pointers &lt;tt&gt;&lt;span&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;j&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, along with the integer &lt;tt&gt;&lt;span&gt;&lt;strong&gt;t&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. When &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is called, it is passed the addresses of &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. Thus, &lt;tt&gt;&lt;span&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; points to &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; (draw an arrow from &lt;tt&gt;&lt;span&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; to &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;) and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;j&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; points to &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; (draw another arrow from &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; to &lt;tt&gt;&lt;span&gt;&lt;strong&gt;j&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;). Once the pointers are initialized by the function call, &lt;tt&gt;&lt;span&gt;&lt;strong&gt;*i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is another name for &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;*j&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is another name for &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. Now run the code in &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. When the code uses &lt;tt&gt;&lt;span&gt;&lt;strong&gt;*i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;*j&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, it really means &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. When the function completes, &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;span&gt;&lt;strong&gt;b&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; have been swapped.&lt;/p&gt;
&lt;p&gt;Suppose you accidentally forget the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; when the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; function is called, and that the swap line accidentally looks like this: &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap(a, b);&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. This causes a segmentation fault. When you leave out the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, the value of &lt;tt&gt;&lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is passed instead of its address. Therefore, &lt;tt&gt;&lt;span&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; points to an invalid location in memory and the system crashes when &lt;tt&gt;&lt;span&gt;&lt;strong&gt;*i&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is used.&lt;/p&gt;
&lt;p&gt;This is also why &lt;tt&gt;&lt;span&gt;&lt;strong&gt;scanf&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; crashes if you forget the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; on variables passed to it. The &lt;tt&gt;&lt;span&gt;&lt;strong&gt;scanf&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; function is using pointers to put the value it reads back into the variable you have passed. Without the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, &lt;tt&gt;&lt;span&gt;&lt;strong&gt;scanf&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is passed a bad address and crashes. Reference parameters are one of the most common uses of pointers in C. Another way to say this is to say that the calling function is telling the called function where to find the variable.&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Swapping in Java:&lt;/strong&gt; The swapping just above using reference parameters in C doesn't work in Java, since Java doesn't have these kind of parameters, but often an application really only needs to swap two values in an array. In this case one can pass the array and the two indexes to swap as three parameters, and this will work in Java. The &quot;bubble sort&quot; program below illustrates this.&lt;/p&gt;

&lt;center&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; bgcolor=&quot;#F2FFF2&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;th&gt;Java BubbleSort Program&lt;/th&gt;
&lt;th&gt;Run of the Program&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;33&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;public class BubbleSort {
   &lt;span&gt;// swap: interchange inside array
   static void swap(int[] a, int i, int j) {
      int t = a[i];
      a[i] = a[j];
      a[j] = t;
   }&lt;/span&gt;

   // bubbleSort: very short code, but ineffient
   static void bubbleSort(int[] a) {
      for (;;) {
         boolean sorted = true;
         for (int i = 0; i &amp;lt; a.length - 1; i++)
            if (a[i] &amp;gt; a[i+1]) {
               sorted = false;
               &lt;span&gt;swap(a, i, i + 1);&lt;/span&gt;
            }
         if (sorted) break;
      }
   }

   static void printArray(int[] a) {
      for (int i = 0; i &amp;lt; a.length; i++) {
         if (i%4 == 0) System.out.println();
         System.out.print(a[i] + &quot; \t&quot;);
      }
      System.out.println();
   }

   public static void main(String[] args) {
      int size = Integer.parseInt(args[0]);
      System.out.println(&quot;Bubblesort, size = &quot; +
         size);
      int[] r = new int[size];
      for (int i = 0; i &amp;lt; size; i++)
         r[i] = (int)(Math.random()*size*10 + 1);
      long startTime =System.currentTimeMillis();
      bubbleSort(r);
      System.out.println(&quot;Elapsed time(millis) &quot;+
         (System.currentTimeMillis()-startTime));
      // printArray(r);
   }
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
% &lt;span&gt;&lt;strong&gt;javac BubbleSort.java&lt;/strong&gt;&lt;/span&gt;
% &lt;span&gt;&lt;strong&gt;java BubbleSort 60&lt;/strong&gt;&lt;/span&gt;
Bubblesort, size = 60
Elapsed time (millis) 1

5       7       9       18
21      27      41      44
67      104     104     109
116     118     151     151
170     175     181     182
196     196     207     220
231     240     241     242
244     247     251     274
279     290     302     325
329     339     341     363
366     369     376     380
385     411     435     440
471     484     492     504
505     547     556     559
564     583     588     591
% &lt;span&gt;&lt;strong&gt;java BubbleSort 100&lt;/strong&gt;&lt;/span&gt;
Bubblesort, size = &lt;span&gt;&lt;strong&gt;100&lt;/strong&gt;&lt;/span&gt;
Elapsed time (millis) &lt;span&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/span&gt;
% &lt;span&gt;&lt;strong&gt;java BubbleSort 1000&lt;/strong&gt;&lt;/span&gt;
Bubblesort, size = &lt;span&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/span&gt;
Elapsed time (millis) &lt;span&gt;&lt;strong&gt;394&lt;/strong&gt;&lt;/span&gt;
% &lt;span&gt;&lt;strong&gt;java BubbleSort 10000&lt;/strong&gt;&lt;/span&gt;
Bubblesort, size = &lt;span&gt;&lt;strong&gt;10000&lt;/strong&gt;&lt;/span&gt;
Elapsed time (millis) &lt;span&gt;&lt;strong&gt;39518&lt;/strong&gt;&lt;/span&gt;
% &lt;span&gt;&lt;strong&gt;java BubbleSort 20000&lt;/strong&gt;&lt;/span&gt;
Bubblesort, size = &lt;span&gt;&lt;strong&gt;20000&lt;/strong&gt;&lt;/span&gt;
Elapsed time (millis) &lt;span&gt;&lt;strong&gt;158317&lt;/strong&gt;&lt;/span&gt;
% &lt;span&gt;&lt;strong&gt;java BubbleSort 40000&lt;/strong&gt;&lt;/span&gt;
Bubblesort, size = &lt;span&gt;&lt;strong&gt;40000&lt;/strong&gt;&lt;/span&gt;
Elapsed time (millis) &lt;span&gt;&lt;strong&gt;646717&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/center&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Swapping in Java Using Wrapped Integers:&lt;/strong&gt; In Java we can get the &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; function to work if we use &lt;em&gt;wrapped&lt;/em&gt; integers and pass references to them to the function. However, the Java wrapper class for &lt;tt&gt;&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; is &lt;tt&gt;&lt;span&gt;&lt;strong&gt;Integer&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; and it doesn't allow you to alter the data field inside. Thus we need our own wrapper class, which I have called &lt;tt&gt;&lt;span&gt;&lt;strong&gt;MyInteger&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; below. The program here is only presented as what could be done, not as an example of how to do swaps. If one passes the address of an object to a function, then changes to the inside of that object will persist after returning from the function&lt;/p&gt;

&lt;center&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; bgcolor=&quot;#F2FFF2&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;th&gt;Java Swapping Using a Wrapper Class&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;16.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
// MyInteger: similar to Integer, but can change value
class MyInteger {
   private int x;                   // single data member
   public MyInteger(int xIn) { x = xIn; } // constructor
   public int getValue() { return x; }  // retrieve value
   public void insertValue(int xIn) { x = xIn;} // insert
}

public class Swapping {
   // swap: pass references to objects
   static void swap(MyInteger rWrap, MyInteger sWrap) {
      // interchange values inside objects
      int t = rWrap.getValue();
      rWrap.insertValue(sWrap.getValue());
      sWrap.insertValue(t);
   }

   public static void main(String[] args) {
      int a = 23, b = 47;
      System.out.println(&quot;Before. a:&quot; + a + &quot;, b: &quot; + b);
      MyInteger aWrap = new MyInteger(a);
      MyInteger bWrap = new MyInteger(b);
      swap(aWrap, bWrap);
      a = aWrap.getValue();
      b = bWrap.getValue();
      System.out.println(&quot;After.  a:&quot; + a + &quot;, b: &quot; + b);
   }
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;span&gt;&lt;strong&gt;javac Swapping.java&lt;/strong&gt;&lt;/span&gt;
% &lt;span&gt;&lt;strong&gt;java Swapping&lt;/strong&gt;&lt;/span&gt;
Before: a: 23, b: 47
After:  a: &lt;span&gt;&lt;strong&gt;47&lt;/strong&gt;&lt;/span&gt;, b: &lt;span&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/center&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Swapping in C++:&lt;/strong&gt; Of course the C swapping methods will work in C++ also, but C++ has the very important concept of &lt;em&gt;references&lt;/em&gt;, which we probably won't study in this course. However, below is a C++ swap program using this feature. Notice that the code for the actual swap is simple: &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap(a, b);&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;. In a similar way, the simple form of C++ input, such as &lt;tt&gt;&lt;span&gt;&lt;strong&gt;cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt; requires these kind of parameters.&lt;/p&gt;

&lt;center&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; bgcolor=&quot;#F2FFF2&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;th&gt;C++ Swap Program Using References&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
#include &amp;lt;iostream&amp;gt;
using std::cout;

void swap(int&lt;span&gt;&amp;amp;&lt;/span&gt; i, int&lt;span&gt;&amp;amp;&lt;/span&gt; j) {
    int t = i;
    i = j;
    j = t;
}

int main() {
    int a = 23, b = 47;
    cout &amp;lt;&amp;lt; &quot;Before. a: &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot;, b: &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot;\n&quot;;
    swap(a, b);
    cout &amp;lt;&amp;lt; &quot;After.  a: &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot;, b: &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot;\n&quot;;
    return 0;
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th colspan=&quot;2&quot;&gt;Run of the program&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;strong&gt;&lt;span&gt;CC -o swap_CC swap.cpp&lt;/span&gt;&lt;/strong&gt;
% &lt;strong&gt;&lt;span&gt;swap_CC&lt;/span&gt;&lt;/strong&gt;
Before: a: 23, b: 47
After:  a: &lt;span&gt;&lt;strong&gt;47&lt;/strong&gt;&lt;/span&gt;, b: &lt;span&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/center&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Swapping in C Using the Preprocessor:&lt;/strong&gt; Another very good way to swap in C (perhaps the best way) uses the C &lt;em&gt;preprocessor&lt;/em&gt;, which we will study later. For now, a preprocessor function like swap below does a &lt;em&gt;textual&lt;/em&gt; substitution, before the actual compiler is invoked. The second listing below is what is sent to the compiler. (This is why there is no semicolon at the end of &lt;tt&gt;&lt;span&gt;&lt;strong&gt;swap(int, a, b)&lt;/strong&gt;&lt;/span&gt;&lt;/tt&gt;, since in the compiled code it would become a redundant semicolon at the end of a block (although not an error).)&lt;/p&gt;

&lt;center&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot; bgcolor=&quot;#F2FFF2&quot;&gt;&lt;tbody readability=&quot;14.5&quot;&gt;&lt;tr&gt;&lt;th&gt;C Swap Program Using Preprocessor&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;22.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
&lt;span&gt;&lt;strong&gt;#define swap(type, i, j) {type t = i; i = j; j = t;}&lt;/strong&gt;&lt;/span&gt;

int main() {
    int a = 23, b = 47;
    printf(&quot;Before swap. a: %d, b: %d\n&quot;, a, b);
    &lt;span&gt;&lt;strong&gt;swap(int, a, b)&lt;/strong&gt;&lt;/span&gt;
    printf(&quot;After swap.  a: %d, b: %d\n&quot;, a, b);
    return 0;
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Preprocessed Output&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;
% cc -E swap_p.c
int main() {
    int a = 23, b = 47;
    printf(&quot;Before swap. a: %d, b: %d\n&quot;, a, b);
     &lt;span&gt;&lt;strong&gt;{ int t = a ; a = b ; b = t ; }&lt;/strong&gt;&lt;/span&gt;
    printf(&quot;After swap.  a: %d, b: %d\n&quot;, a, b);
    return 0;
}
&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;Run of the program&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
% &lt;strong&gt;&lt;span&gt;cc -o swap_p swap_p.c&lt;/span&gt;&lt;/strong&gt;
% &lt;strong&gt;&lt;span&gt; swap_p&lt;/span&gt;&lt;/strong&gt;
Before swap: a: 23, b: 47
After swap:  a: &lt;span&gt;&lt;strong&gt;47&lt;/strong&gt;&lt;/span&gt;, b: &lt;span&gt;&lt;strong&gt;23&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/center&gt;
</description>
<pubDate>Mon, 18 Jun 2018 15:37:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9196762.html</dc:identifier>
</item>
<item>
<title>领域驱动设计的必要性和模型标准——《领域驱动设计-精简版》 - geons</title>
<link>http://www.cnblogs.com/geons/p/9195619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geons/p/9195619.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、领域驱动设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;领域驱动设计早在30年前就已经为人所知，一些设计人员开始&lt;strong&gt;开始领域建模，领域通用语言的思维构造&lt;/strong&gt;，以便能够在领域专家和开发专家形成高效的沟通，Eric Evans将这种思维（思潮）定义为Domain-Driven Desigin（领域驱动设计，简称DDD）。DDD在B/S还不这么流行的年代，主要应用在软件公司，因为很多都是C端，但是现在各个互联网公司将很多业务尝试模块化、量级上规模化，业务上多样化，不再是CRUD这么简单，因此，领域驱动设计在互联网开发中也起到了一个很好的引领作用。这本书在InfoQ上有专家改写出了一本精简版，全文82页，本文主要将个人阅读笔记和思考做分享。可以通过网址直接访问或下载阅读（&lt;a href=&quot;https://files.cnblogs.com/files/anderslly/dddquickly-chinese-version.pdf&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/anderslly/dddquickly-chinese-version.pdf&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、领域驱动设计必要性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 软件开发离不开具体的业务需求，开发人员会先从理解业务开始，此时需要请教领域专家，通过了解专家口中的领域术语，对应转换成软件开发人员能够理解的计算机概念。但是，两种不同的角色身份对于同一领域有不同的理解和表达，为了让两者更加高效和准确理解，同时也提高大型软件系统的可用性，需要建立一个领域模型来向双方反映领域知识，开发人员依据领域模型来开发软件，用代码来实现模型，从而达到了通用的设计流程。实现领域模型驱动软件设计开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、建立一个领域模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;领域模型是沟通领域专家和软件专家的桥梁，也是唯一实现实例抽象成统一模型，而该模型可以被两者认同。所以，在领域驱动设计时候，建立一个领域模型是非常重要的，它一般具有以下特点：&lt;/p&gt;
&lt;p&gt;1、模型有边界，只反映具体某个领域所关注的部分。&lt;/p&gt;
&lt;p&gt;2、领域模型只反映业务，和具体编程语言、技术无关。&lt;/p&gt;
&lt;p&gt;3、领域模型确保了软件逻辑都在一个模型里，也在同一个地方，尽量实现高内聚，低耦合。&lt;/p&gt;
&lt;p&gt;4、领域模型能够帮助开发人员将领域专业知识转换为软件设计知识，方便开发人员区别和学习。&lt;/p&gt;
&lt;p&gt;5、领域模型不仅用在沟通阶段，贯穿整个开发过程，。&lt;/p&gt;
&lt;p&gt;6、领域模型在软件开发阶段，会对原有的模型完善和细化、深入，是一个多方共同维护的结果。&lt;/p&gt;
&lt;p&gt;7、图是表示领域模型最常见和最形象的方式，可以参见&lt;a href=&quot;https://tech.meituan.com/DDD%20in%20practice.html&quot; target=&quot;_blank&quot;&gt;美团技术团队-领域驱动设计在互联网业务中的应用&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;8、领域模型是整个软件的核心，后续的业务变更和扩展也是基于原有的模型进行迭代，因此模型建立非常重要。&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 14:55:00 +0000</pubDate>
<dc:creator>geons</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geons/p/9195619.html</dc:identifier>
</item>
<item>
<title>C语言使用hiredis访问redis - 飞鸿影~</title>
<link>http://www.cnblogs.com/52fhy/p/9196527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/52fhy/p/9196527.html</guid>
<description>&lt;p&gt;&lt;code&gt;Hiredis&lt;/code&gt; 是Redis数据库的简约C客户端库。它是简约的，因为它只是增加了对协议的最小支持，但是同时它使用了一个高级别的 printf-like API，所以对于习惯了 printf 风格的C编程用户来说，其非常容易使用，而且API中没有明确的绑定每个 Redis 命令。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/redis/hiredis&quot; class=&quot;uri&quot;&gt;https://github.com/redis/hiredis&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装hiredis&quot;&gt;安装hiredis&lt;/h2&gt;
&lt;p&gt;编译安装：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; clone git@github.com:redis/hiredis.git
$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; hiredis
$ &lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; 
$ &lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是&lt;code&gt;make install&lt;/code&gt;的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /usr/local/include/hiredis /usr/local/include/hiredis/adapters /usr/local/lib
cp -pPR hiredis.h async.h read.h sds.h /usr/local/include/hiredis
cp -pPR adapters/*.h /usr/local/include/hiredis/adapters
cp -pPR libhiredis.so /usr/local/lib/libhiredis.so.0.13
cd /usr/local/lib &amp;amp;&amp;amp; ln -sf libhiredis.so.0.13 libhiredis.so
cp -pPR libhiredis.a /usr/local/lib
mkdir -p /usr/local/lib/pkgconfig
cp -pPR hiredis.pc /usr/local/lib/pkgconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制动态链接库到lib：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; libhiredis.so /usr/lib64 /usr/lib &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若是32系统只需要运行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; libhiredis.so /usr/lib&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还需要更新下动态链接库缓存：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/sbin/ldconfig&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;ldconfig&lt;/code&gt; 命令的用途主要是在默认搜寻目录 &lt;code&gt;/lib&lt;/code&gt; 和 &lt;code&gt;/usr/lib&lt;/code&gt; 以及动态库配置文件 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 内所列的目录下，搜索出可共享的动态链接库（格式如&lt;code&gt;lib*.so*&lt;/code&gt;）,进而创建出动态装入程序(&lt;code&gt;ld.so&lt;/code&gt;)所需的连接和缓存文件。缓存文件默认为 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; ，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令 &lt;code&gt;ldconfig&lt;/code&gt; ，此执行程序存放在/sbin目录下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;ldconfig&lt;/code&gt;通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;客户端代码&quot;&gt;客户端代码&lt;/h2&gt;
&lt;p&gt;test.c&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;  &lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;hiredis/hiredis.h&amp;gt;  &lt;/span&gt;
  
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()  
{  
    redisContext* conn = redisConnect(&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6379&lt;/span&gt;);  
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(conn-&amp;gt;err)   printf(&lt;span class=&quot;st&quot;&gt;&quot;connection error:%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, conn-&amp;gt;errstr);  
  
    redisReply* reply = redisCommand(conn, &lt;span class=&quot;st&quot;&gt;&quot;set foo 1234&quot;&lt;/span&gt;);  
    freeReplyObject(reply);  
  
    reply = redisCommand(conn, &lt;span class=&quot;st&quot;&gt;&quot;get foo&quot;&lt;/span&gt;);  
  
    printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, reply-&amp;gt;str);  
    freeReplyObject(reply);  
  
    redisFree(conn);  
  
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;  
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;gcc&lt;/span&gt; test.c -o test -lhiredis&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译是一定要使用&lt;code&gt;-l&lt;/code&gt;连接动态库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;-lstack&lt;/code&gt; 告诉编译器要链接 &lt;code&gt;lhiredis&lt;/code&gt; 库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./test
1234&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数原型&quot;&gt;函数原型&lt;/h2&gt;
&lt;h3 id=&quot;redisconnect&quot;&gt;redisConnect&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;redisContext *redisConnect(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *ip, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; port)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：该函数用来连接redis数据库，参数为数据库的ip地址和端口，一般redis数据库的端口为6379。&lt;/p&gt;
&lt;p&gt;该函数返回一个结构体&lt;code&gt;redisContext&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;rediscommand&quot;&gt;redisCommand&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *redisCommand(redisContext *c, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：该函数执行命令，就如sql数据库中的SQL语句一样，只是执行的是&lt;code&gt;redis&lt;/code&gt;数据库中的操作命令，第一个参数为连接数据库时返回的&lt;code&gt;redisContext&lt;/code&gt;，剩下的参数为变参，就如C标准函数&lt;code&gt;printf&lt;/code&gt;函数一样的变参。&lt;/p&gt;
&lt;p&gt;返回值为&lt;code&gt;void*&lt;/code&gt;，一般强制转换成为&lt;code&gt;redisReply&lt;/code&gt;类型的进行进一步的处理。&lt;/p&gt;
&lt;h3 id=&quot;freereplyobject&quot;&gt;freeReplyObject&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; freeReplyObject(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *reply);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：释放 &lt;code&gt;redisCommand&lt;/code&gt; 执行后返回的 &lt;code&gt;redisReply&lt;/code&gt; 所占用的内存。&lt;/p&gt;
&lt;h3 id=&quot;redisfree&quot;&gt;redisFree&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; redisFree(redisContext *c);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：释放 &lt;code&gt;redisConnect()&lt;/code&gt; 所产生的连接。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、Redis：安装、配置、操作和简单代码实例(C语言Client端) - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/hj19870806/article/details/8724907&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/hj19870806/article/details/8724907&lt;/a&gt;&lt;br/&gt;2、C语言访问redis（hiredis) - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/sole_cc/article/details/38015765&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/sole_cc/article/details/38015765&lt;/a&gt;&lt;br/&gt;3、error while loading shared libraries问题解决 - CSDN博客&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qgd19931120/article/details/50971142&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qgd19931120/article/details/50971142&lt;/a&gt;&lt;br/&gt;4、ldconfig命令_Linux ldconfig 命令用法详解：动态链接库管理命令&lt;br/&gt;&lt;a href=&quot;http://man.linuxde.net/ldconfig?mstqrk=qdwrv1&quot; class=&quot;uri&quot;&gt;http://man.linuxde.net/ldconfig?mstqrk=qdwrv1&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jun 2018 14:17:00 +0000</pubDate>
<dc:creator>飞鸿影~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/52fhy/p/9196527.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day23 Java容器类详解（六）HashMap源码分析（中） - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9195465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9195465.html</guid>
<description>[unable to retrieve full-text content]上一篇中对HashMap中的基本内容做了详细的介绍，解析了其中的get和put方法，想必大家对于HashMap也有了更好的认识，本篇将从了算法的角度，来分析HashMap中的那些函数。 HashCode 先来说说HashMap中HashCode的算法，在上一篇里，我们看到了HashMap中的put方</description>
<pubDate>Mon, 18 Jun 2018 13:32:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9195465.html</dc:identifier>
</item>
<item>
<title>前端性能优化的七大手段 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/9178390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/9178390.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍前端性能优化的七大手段，包括减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化&lt;/p&gt;

&lt;h3&gt;减少请求数量&lt;/h3&gt;
&lt;p&gt;【合并】&lt;/p&gt;
&lt;p&gt;　　如果不进行文件合并，有如下3个隐患&lt;/p&gt;
&lt;p&gt;　　1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟&lt;/p&gt;
&lt;p&gt;　　2、受丢包问题影响更严重&lt;/p&gt;
&lt;p&gt;　　3、经过代理服务器时可能会被断开&lt;/p&gt;
&lt;p&gt;　　但是，文件合并本身也有自己的问题&lt;/p&gt;
&lt;p&gt;　　1、首屏渲染问题&lt;/p&gt;
&lt;p&gt;　　2、缓存失效问题&lt;/p&gt;
&lt;p&gt;　　所以，对于文件合并，有如下改进建议&lt;/p&gt;
&lt;p&gt;　　1、公共库合并&lt;/p&gt;
&lt;p&gt;　　2、不同页面单独合并&lt;/p&gt;
&lt;p&gt;【图片处理】&lt;/p&gt;
&lt;p&gt;　　1、雪碧图&lt;/p&gt;
&lt;p&gt;　　CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台&lt;/p&gt;
&lt;p&gt;　　2、Base64&lt;/p&gt;
&lt;p&gt;　　将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33%&lt;/p&gt;
&lt;p&gt;　　3、使用字体图标来代替图片&lt;/p&gt;
&lt;p&gt;【减少重定向】&lt;/p&gt;
&lt;p&gt;　　尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验&lt;/p&gt;
&lt;p&gt;　　如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面&lt;/p&gt;
&lt;p&gt;【使用缓存】&lt;/p&gt;
&lt;p&gt;　　使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应&lt;/p&gt;
&lt;p&gt;【不使用CSS @import】&lt;/p&gt;
&lt;p&gt;　　CSS的@import会造成额外的请求&lt;/p&gt;
&lt;p&gt;【避免使用空的src和href】&lt;/p&gt;
&lt;p&gt;　　a标签设置空的href，会重定向到当前的页面地址&lt;/p&gt;
&lt;p&gt;　　form设置空的method，会提交表单到当前的页面地址&lt;/p&gt;

&lt;h3&gt;减小资源大小&lt;/h3&gt;
&lt;p&gt;【压缩】&lt;/p&gt;
&lt;p&gt;　　1、HTML压缩&lt;/p&gt;
&lt;p&gt;　　HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等&lt;/p&gt;
&lt;p&gt;　　2、CSS压缩&lt;/p&gt;
&lt;p&gt;　　CSS压缩包括无效代码删除与CSS语义合并&lt;/p&gt;
&lt;p&gt;　　3、JS压缩与混乱&lt;/p&gt;
&lt;p&gt;　　JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护&lt;/p&gt;
&lt;p&gt;　　4、图片压缩&lt;/p&gt;
&lt;p&gt;　　针对真实图片情况，舍弃一些相对无关紧要的色彩信息&lt;/p&gt;
&lt;p&gt;【webp】&lt;/p&gt;
&lt;p&gt;　　在安卓下可以使用webp格式的图片，它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上，而且同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性&lt;/p&gt;
&lt;p&gt;【开启gzip】&lt;/p&gt;
&lt;p&gt;　　HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40%&lt;/p&gt;

&lt;h3&gt;优化网络连接&lt;/h3&gt;
&lt;p&gt;【使用CDN】&lt;/p&gt;
&lt;p&gt;　　CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度&lt;/p&gt;
&lt;p&gt;【使用DNS预解析】&lt;/p&gt;
&lt;p&gt;　　当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照&lt;code&gt;浏览器缓存&lt;/code&gt;、&lt;code&gt;系统缓存&lt;/code&gt;、&lt;code&gt;路由器缓存&lt;/code&gt;、&lt;code&gt;ISP(运营商)DNS缓存&lt;/code&gt;、&lt;code&gt;根域名服务器&lt;/code&gt;、&lt;code&gt;顶级域名服务器&lt;/code&gt;、&lt;code&gt;主域名服务器&lt;/code&gt;的顺序，逐步读取缓存，直到拿到IP地址&lt;/p&gt;
&lt;p&gt;　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到&lt;code&gt;系统缓存&lt;/code&gt;中，缩短DNS解析时间，来提高网站的访问速度&lt;/p&gt;
&lt;p&gt;　　方法是在 head 标签里面写上几个 link 标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dns-prefecth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.google.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dns-prefecth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.google-analytics.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间&lt;/p&gt;
&lt;p&gt;【并行连接】&lt;/p&gt;
&lt;p&gt;　　由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数&lt;/p&gt;
&lt;p&gt;【持久连接】&lt;/p&gt;
&lt;p&gt;　　使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量&lt;/p&gt;
&lt;p&gt;【管道化连接】&lt;/p&gt;
&lt;p&gt;　　在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了&lt;/p&gt;

&lt;h3&gt;优化资源加载&lt;/h3&gt;
&lt;p&gt;【资源加载位置】&lt;/p&gt;
&lt;p&gt;　　通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用&lt;/p&gt;
&lt;p&gt;　　1、CSS文件放在head中，先外链，后本页&lt;/p&gt;
&lt;p&gt;　　2、JS文件放在body底部，先外链，后本页&lt;/p&gt;
&lt;p&gt;　　3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件&lt;/p&gt;
&lt;p&gt;　　4、body中间尽量不写style标签和script标签&lt;/p&gt;
&lt;p&gt;【资源加载时机】&lt;/p&gt;
&lt;p&gt;　　1、异步script标签&lt;/p&gt;
&lt;p&gt;　　defer:  异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似&lt;/p&gt;
&lt;p&gt;　　async: 异步加载，加载完成后立即执行&lt;/p&gt;
&lt;p&gt;　　2、模块按需加载&lt;/p&gt;
&lt;p&gt;　　在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块&lt;/p&gt;
&lt;p&gt;　　按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载&lt;/p&gt;
&lt;p&gt;　　webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure&lt;/p&gt;
&lt;p&gt;　　3、使用资源预加载preload和资源预读取prefetch&lt;/p&gt;
&lt;p&gt;　　preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度&lt;/p&gt;
&lt;p&gt;　　prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度&lt;/p&gt;
&lt;p&gt;　　4、资源懒加载与资源预加载&lt;/p&gt;
&lt;p&gt;　　资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源&lt;/p&gt;
&lt;p&gt;　　资源预加载是提前加载用户所需的资源，保证良好的用户体验&lt;/p&gt;
&lt;p&gt;　　资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能&lt;/p&gt;

&lt;h3&gt;减少重绘回流&lt;/h3&gt;
&lt;p&gt;【样式设置】&lt;/p&gt;
&lt;p&gt;　　1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率&lt;/p&gt;
&lt;p&gt;　　2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次&lt;/p&gt;
&lt;p&gt;　　3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流&lt;/p&gt;
&lt;p&gt;　　4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流&lt;/p&gt;
&lt;p&gt;　　5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间&lt;/p&gt;
&lt;p&gt;　　6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现&lt;/p&gt;
&lt;p&gt;【渲染层】&lt;/p&gt;
&lt;p&gt;　　1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围&lt;/p&gt;
&lt;p&gt;　　2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流&lt;/p&gt;
&lt;p&gt;【DOM优化】&lt;/p&gt;
&lt;p&gt;　　1、缓存DOM&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; div = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM&lt;/p&gt;
&lt;p&gt;　　2、减少DOM深度及DOM数量&lt;/p&gt;
&lt;p&gt;　　HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。&lt;/p&gt;
&lt;p&gt;　　3、批量操作DOM&lt;/p&gt;
&lt;p&gt;　　由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM&lt;/p&gt;
&lt;p&gt;　　4、批量操作CSS样式&lt;/p&gt;
&lt;p&gt;　　通过切换class或者使用元素的style.csstext属性去批量操作元素样式&lt;/p&gt;
&lt;p&gt;　　5、在内存中操作DOM&lt;/p&gt;
&lt;p&gt;　　使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上&lt;/p&gt;
&lt;p&gt;　　6、DOM元素离线更新&lt;/p&gt;
&lt;p&gt;　　对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作&lt;/p&gt;
&lt;p&gt;　　7、DOM读写分离&lt;/p&gt;
&lt;p&gt;　　浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行&lt;/p&gt;
&lt;p&gt;　　8、事件代理&lt;/p&gt;
&lt;p&gt;　　事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件&lt;/p&gt;
&lt;p&gt;　　利用事件代理，可以减少内存使用，提高性能及降低代码复杂度&lt;/p&gt;
&lt;p&gt;　　9、防抖和节流&lt;/p&gt;
&lt;p&gt;　　使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发&lt;/p&gt;
&lt;p&gt;　　10、及时清理环境&lt;/p&gt;
&lt;p&gt;　　及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存&lt;/p&gt;

&lt;h3&gt;性能更好的API&lt;/h3&gt;
&lt;p&gt;　　1、用对选择器&lt;/p&gt;
&lt;p&gt;　　选择器的性能排序如下所示，尽量选择性能更好的选择器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;id选择器（#myid）
类选择器（.myclassname）
标签选择器（div,h1,p）
相邻选择器（h1&lt;/span&gt;+&lt;span&gt;p）
子选择器（ul &lt;/span&gt;&amp;gt;&lt;span&gt; li）
后代选择器（li a）
通配符选择器（&lt;/span&gt;*&lt;span&gt;）
属性选择器（a[rel&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;external&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]）
伪类选择器（a:hover,li:nth&lt;/span&gt;-child）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、使用requestAnimationFrame来替代setTimeout和setInterval&lt;/p&gt;
&lt;p&gt;　　希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧&lt;/p&gt;
&lt;p&gt;　　3、使用IntersectionObserver来实现图片可视区域的懒加载&lt;/p&gt;
&lt;p&gt;　　传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题&lt;/p&gt;
&lt;p&gt;　　4、使用web worker&lt;/p&gt;
&lt;p&gt;　　客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用&lt;/p&gt;
&lt;p&gt;　　但是，使用一些新的API的同时，也要注意其浏览器兼容性&lt;/p&gt;

&lt;h3&gt;webpack优化&lt;/h3&gt;
&lt;p&gt;【打包公共代码】&lt;/p&gt;
&lt;p&gt;　　使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件&lt;/p&gt;
&lt;p&gt;　　webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk&lt;/p&gt;
&lt;p&gt;　　通过设置 optimization.splitChunks.chunks: &quot;all&quot; 来启动默认的代码分割配置项&lt;/p&gt;
&lt;p&gt;【动态导入和按需加载】&lt;/p&gt;
&lt;p&gt;　　webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure&lt;/p&gt;
&lt;p&gt;【剔除无用代码】&lt;/p&gt;
&lt;p&gt;　　tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup&lt;/p&gt;
&lt;p&gt;　　JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的&lt;/p&gt;
&lt;p&gt;【长缓存优化】&lt;/p&gt;
&lt;p&gt;　　1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效&lt;/p&gt;
&lt;p&gt;　　2、使用Name而不是id&lt;/p&gt;
&lt;p&gt;　　每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变&lt;/p&gt;
&lt;p&gt;　　下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建&lt;/p&gt;
&lt;p&gt;【公用代码内联】&lt;/p&gt;
&lt;p&gt;　　使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中&lt;/p&gt;

</description>
<pubDate>Mon, 18 Jun 2018 12:36:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/9178390.html</dc:identifier>
</item>
<item>
<title>提供推荐——协作型过滤 - nadech</title>
<link>http://www.cnblogs.com/nadech/p/9195796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nadech/p/9195796.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;一协作型过滤&quot;&gt;一、协作型过滤&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一个协作型过滤算法通常的做法是对一大群人进行搜索，并从中找出与我们品味相近的一群人。然后对这些人的偏好内容进行考查，并将它们组合起来构造出一个经过排名的推荐列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;搜集偏好&lt;/li&gt;
&lt;li&gt;寻找相近的用户
&lt;ul&gt;&lt;li&gt;欧几里得距离评价&lt;/li&gt;
&lt;li&gt;皮尔逊相关度评价&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为相近用户打分排序&lt;/li&gt;
&lt;li&gt;推荐物品&lt;/li&gt;
&lt;li&gt;推荐结果&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;搜集偏好&quot;&gt;1.搜集偏好&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 不同用户对电影的评分字典
critics={'Lisa Rose': {'Lady in the Water': 2.5, 'Snakes on a Plane': 3.5,
 'Just My Luck': 3.0, 'Superman Returns': 3.5, 'You, Me and Dupree': 2.5,
 'The Night Listener': 3.0},
'Gene Seymour': {'Lady in the Water': 3.0, 'Snakes on a Plane': 3.5,
 'Just My Luck': 1.5, 'Superman Returns': 5.0, 'The Night Listener': 3.0,
 'You, Me and Dupree': 3.5},
'Michael Phillips': {'Lady in the Water': 2.5, 'Snakes on a Plane': 3.0,
 'Superman Returns': 3.5, 'The Night Listener': 4.0},
'Claudia Puig': {'Snakes on a Plane': 3.5, 'Just My Luck': 3.0,
 'The Night Listener': 4.5, 'Superman Returns': 4.0,
 'You, Me and Dupree': 2.5},
'Mick LaSalle': {'Lady in the Water': 3.0, 'Snakes on a Plane': 4.0,
 'Just My Luck': 2.0, 'Superman Returns': 3.0, 'The Night Listener': 3.0,
 'You, Me and Dupree': 2.0},
'Jack Matthews': {'Lady in the Water': 3.0, 'Snakes on a Plane': 4.0,
 'The Night Listener': 3.0, 'Superman Returns': 5.0, 'You, Me and Dupree': 3.5},
'Toby': {'Snakes on a Plane':4.5,'You, Me and Dupree':1.0,'Superman Returns':4.0}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;寻找相近的用户&quot;&gt;2.寻找相近的用户&lt;/h3&gt;
&lt;p&gt;寻找相近用户可以使用不同的相似度评价值体系：这里介绍两种：欧几里得距离和皮尔逊相关度。&lt;br/&gt;欧几里得距离：它是基于距离的相似度评价&lt;br/&gt;皮尔逊相关度：&lt;strong&gt;用来判断两组数据与某一直线拟合程度的一种度量&lt;/strong&gt;。它更适合于当两名用户虽然对电影有相同的爱好，但是用户1评分更严苛，而用户2更宽松，那么用欧几里得距离来计算两者相似度就会有偏差，但是皮尔逊相关度，会更关注两者的趋势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#寻找近似用户，计算两个用户的相似度（欧几里得距离）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def sim_distance(prefs,person1,person2):  #prefs是指存储所有用户评分的字典
# 得到shared_items两个用户都给出评分的电影列表
si ={}
for item in prefs[person1]:
    if item in prefs[person2]:
        si[item] =1

if len(si) == 0:
    return 0 #此时两个用户没有共同评分的影片，相似度为0
else:
    sum_of_squares =sum([pow(prefs[person1][item]-prefs[person2][item],2) for item in prefs[person1] if item in prefs[person2]])
    return 1/(1+sqrt(sum_of_squares)) #这个是转化为直接理解的相似度数值，sum_of_squares越大，相似度越小&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;# 寻找近似用户，计算两个用户的相似度（皮尔逊相关度）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def sim_pearson(prefs,p1,p2):
    # 得到shared_items两个用户都给出评分的电影列表
    si={}
    for item in prefs[p1]:
        if item in prefs[p2]:
            si[item] =1
    # 得到列表元素的个数
    n =len(si)
    # 如果两个人没有共同之处，则返回1
    if n==0:
        return 1

    # 对所有偏好求和
    sum1 =sum([prefs[p1][it] for it in si])
    sum2 =sum([prefs[p2][it] for it in si])
    #求平方和
    sum1Sq = sum([pow(prefs[p1][it],2) for it in si])
    sum2Sq = sum([pow(prefs[p2][it],2) for it in si])
    #求乘积之和
    pSum = sum([prefs[p1][it]*prefs[p2][it] for it in si])
    #计算皮尔逊评价值
    num = pSum-(sum1*sum2/n)
    den = sqrt((sum1Sq-pow(sum1,2)/n)*(sum2Sq-pow(sum2,2)/n))
    if den ==0:
        return  0
    r = num/den
    return r&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为相近用户打分排序&quot;&gt;3.为相近用户打分排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;# 计算其他用户与某名用户的相似度并根据相似度进行排序&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def topMatchers(prefs,person,n,similarity=sim_pearson): #similarity指定计算相似度的算法
    scores =[(similarity(prefs,person,other),other) for other in prefs if other!=person]
    scores.sort()
    scores.reverse()
    return scores[0:n]
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;推荐物品&quot;&gt;4.推荐物品&lt;/h3&gt;
&lt;p&gt;此时，我们可以单纯的从相近用户中没有观看过的电影列表中直接进行推荐，但是这种做法太过随意。&lt;strong&gt;我们想要针对一部电影，从其他用户与目标用户的相似度以及他们对该部的电影评分求加权平均值，这也是所预期的目标用户会对某部电影的评分值。根据评分值的大小对推荐列表进行排序。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def getRecommendations(prefs,person,similarity=sim_pearson):
totals ={} # 用来存储 相似度*每个用户评分  的和
simSums = {} # 用来存储 相似度 的和

for other in prefs:
    # 不和自己比较
    if other ==person :continue
    sim = similarity(prefs,person,other)
    # 忽略相似度为零或小于零的情况
    if sim&amp;lt;=0: continue
    for item in prefs[other]: # 对某个其他用户看过的电影进行迭代
        # 只对自己还未曾看过的影片进行评价
        if item not in prefs[person] or prefs[person][item] ==0:
            # 相似度*评价值
            totals.setdefault(item,0) # if key is in the dictionary ,return its value,if not,insert key wit a  value of default
            totals[item]+=prefs[other][item]*sim
            # 相似度之和
            simSums.setdefault(item,0)
            simSums[item]+=sim

# 建立一个归一化列表
rankings =[(total/simSums[item],item) for item,total in totals.items()]
# 返回经过排序的列表
rankings.sort()
rankings.reverse()
return rankings&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;推荐结果&quot;&gt;5.推荐结果&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;#欧几里得距离评价：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[(3.457128694491423, 'The Night Listener'), (2.7785840038149243, 'Lady in the Water'), (2.422482042361916, 'Just My Luck')]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;皮尔逊相关度评价：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[(3.3477895267131013, 'The Night Listener'), (2.832549918264162, 'Lady in the Water'), (2.5309807037655645, 'Just My Luck')]&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 18 Jun 2018 10:44:00 +0000</pubDate>
<dc:creator>nadech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nadech/p/9195796.html</dc:identifier>
</item>
<item>
<title>java-spark的各种常用算子的写法 - horseman</title>
<link>http://www.cnblogs.com/starwater/p/9195764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starwater/p/9195764.html</guid>
<description>&lt;p&gt;    通常写spark的程序用scala比较方便，毕竟spark的源码就是用scala写的。然而，目前java开发者特别多，尤其进行数据对接、上线服务的时候，这时候，就需要掌握一些spark在java中的使用方法了&lt;/p&gt;
&lt;p&gt;   一、map&lt;/p&gt;
&lt;p&gt;     map在进行数据处理、转换的时候，不能更常用了&lt;/p&gt;
&lt;p&gt;     在使用map之前 首先要定义一个转换的函数 格式如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Function&amp;lt;String, LabeledPoint&amp;gt; transForm = new Function&amp;lt;String, LabeledPoint&amp;gt;() {//String是某一行的输入类型 LabeledPoint是转换后的输出类型
            @Override
            public LabeledPoint call(String row) throws Exception {//重写call方法
                String[] rowArr = row.split(&quot;,&quot;);
                int rowSize = rowArr.length;

                double[] doubleArr = new double[rowSize-1];

                //除了第一位的lable外 其余的部分解析成double 然后放到数组中
                for (int i = 1; i &amp;lt; rowSize; i++) {
                    String each = rowArr[i];
                    doubleArr[i] = Double.parseDouble(each);
                }

                //用刚才得到的数据 转成向量
                Vector feature = Vectors.dense(doubleArr);
                double label = Double.parseDouble(rowArr[0]);
                //构造用于分类训练的数据格式 LabelPoint
                LabeledPoint point = new LabeledPoint(label, feature);
                return point;
            }
        };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要特别注意的是：&lt;/p&gt;
&lt;p&gt;      1、call方法的输入应该是转换之前的数据行的类型  返回值应是处理之后的数据行类型&lt;/p&gt;
&lt;p&gt;      2、如果转换方法中调用了自定义的类，注意该类名必须实现序列化 比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TreeEnsemble implements Serializable {
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、转换函数中如果调用了某些类的对象，比如该方法需要调用外部的一个参数，或者数值处理模型（标准化，归一化等），则该对象需要声明是final&lt;/p&gt;
&lt;p&gt;      然后就是在合适的时候调用该转换函数了&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
JavaRDD&amp;lt;LabeledPoint&amp;gt; rdd = oriData.toJavaRDD().map(transForm);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种方式是需要将普通的rdd转成javaRDD才能使用的，转成javaRDD的这一步操作不耗时，不用担心&lt;/p&gt;
&lt;p&gt;   二、filter&lt;/p&gt;
&lt;p&gt;    在避免数据出现空值、0等场景中也非常常用，可以满足sql中where的功能&lt;/p&gt;
&lt;p&gt;    这里首先也是要定义一个函数，该函数给定数据行 返回布尔值 实际效果是将返回为true的数据保留&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Function&amp;lt;String, Boolean&amp;gt; boolFilter = new Function&amp;lt;String, Boolean&amp;gt;() {//String是某一行的输入类型 Boolean是对应的输出类型 用于判断数据是否保留
            @Override
            public Boolean call(String row) throws Exception {//重写call方法
                boolean flag = row!=null;
                return flag;
            }
        };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　 通常该函数实际使用中需要修改的仅仅是row的类型 也就是数据行的输入类型，和上面的转换函数不同，此call方法的返回值应是固定为Boolean&lt;/p&gt;
&lt;p&gt;    然后是调用方式&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
JavaRDD&amp;lt;LabeledPoint&amp;gt; rdd = oriData.toJavaRDD().filter(boolFilter);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    三、mapToPair&lt;/p&gt;
&lt;p&gt;    该方法和map方法有一些类似，也是对数据进行一些转换。不过此函数输入一行 输出的是一个元组，最常用的方法是用来做交叉验证 或者统计错误率 召回率 计算AUC等等&lt;/p&gt;
&lt;p&gt;    同样，需要先定义一个转换函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Function&amp;lt;String, Boolean&amp;gt; transformer = new PairFunction&amp;lt;LabeledPoint, Object, Object&amp;gt;() {//LabeledPoint是输入类型 后面的两个Object不要改动
            @Override
            public Tuple2 call(LabeledPoint row) throws Exception {//重写call方法 通常只改动输入参数 输出不要改动
                double predicton = thismodel.predict(row.features());
                double label = row.label();
                return new Tuple2(predicton, label);
            }
        });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关于调用的类、类的对象，要求和之前的一致，类需要实现序列化，类的对象需要声明成final类型&lt;/p&gt;
&lt;p&gt;     相应的调用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
JavaPairRDD&amp;lt;Object, Object&amp;gt; predictionsAndLabels = oriData.mapToPair(transformer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后对该predictionsAndLabels的使用，计算准确率、召回率、精准率、AUC，接下来的博客中会有，敬请期待&lt;/p&gt;
&lt;p&gt;      如有补充，或者质疑，或者有相关问题，请发邮件给我，或者直接回复  邮箱:326543991@qq.com&lt;/p&gt;





</description>
<pubDate>Mon, 18 Jun 2018 10:29:00 +0000</pubDate>
<dc:creator>horseman</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/starwater/p/9195764.html</dc:identifier>
</item>
</channel>
</rss>