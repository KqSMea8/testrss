<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL 主从同步配置 - 超越自我，挑战无极限</title>
<link>http://www.cnblogs.com/hxqcom/p/8083093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hxqcom/p/8083093.html</guid>
<description>&lt;h2&gt;1.1. 基础信息&lt;/h2&gt;
&lt;p&gt;数据库主服务器IP：127.0.0.1&lt;br/&gt;数据库从服务器IP：192.168.1.31&lt;/p&gt;
&lt;h2&gt;1.2. 主服务器配置文件my.ini配置 （master）&lt;/h2&gt;
&lt;p&gt;[mysqld]&lt;br/&gt;#打开日志(主机需要打开) 表示二进制变更日值&lt;br/&gt;log-bin=mysql-bin&lt;br/&gt;#服务器唯一id&lt;br/&gt;server-id=1&lt;br/&gt;#给从机同步的数据库名称&lt;br/&gt;binlog-do-db=shenxianyun_console&lt;br/&gt;binlog-do-db=shenxianyun_portal&lt;br/&gt;binlog-do-db=test&lt;br/&gt;#自动清理1天前的log文件&lt;br/&gt;expire_logs_days=1&lt;/p&gt;
&lt;h2&gt;1.3. 重启主MYSQL服务&lt;/h2&gt;
&lt;p&gt;service mysqld restart&lt;/p&gt;
&lt;h2&gt;1.4. 主数据库授权同步数据库的用户&lt;/h2&gt;
&lt;p&gt;GRANT REPLICATION SLAVE ON *.* TO 'user'@'%' IDENTIFIED BY‘password’;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;刷新权限&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FLUSH PRIVILEGES;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看主服务状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; SHOW MASTER STATUS;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235529521-334545342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.5. 从服务器配置文件my.ini配置(slave)&lt;/h2&gt;
&lt;p&gt;[mysqld]&lt;br/&gt;#服务器id&lt;br/&gt;server-id=2&lt;br/&gt;#要从主机同步的库&lt;br/&gt;replicate-do-db=shenxianyun_console&lt;br/&gt;replicate-do-db=shenxianyun_portal&lt;br/&gt;replicate-do-db=test&lt;/p&gt;
&lt;p&gt; #&lt;em&gt;配置中继日志（一般可以不用）&lt;/em&gt;&lt;br/&gt;&lt;em&gt;#relay_log         = mysql-relay-bin&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;# slave&lt;/em&gt;&lt;em&gt;将复制事件写进自己的二进制日志(后面会看到它的用处)。&lt;br/&gt;#log_slave_updates = 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;#&lt;/em&gt;&lt;em&gt;它防止改变数据(除了特殊的线程) 慎重使用&lt;br/&gt;#read_only         = 1&lt;br/&gt;server_id是必须的，而且唯一。slave没有必要开启二进制日志，但是在一些情况下，必须设置，例如，如果slave为其它slave的master，必须设置bin_log。在这里，我们开启了二进制日志，而且显示的命名(默认名称为hostname，但是，如果hostname改变则会出现问题)。&lt;br/&gt;relay_log配置中继日志，log_slave_updates表示slave将复制事件写进自己的二进制日志(后面会看到它的用处)。&lt;br/&gt;有些人开启了slave的二进制日志，却没有设置log_slave_updates，然后查看slave的数据是否改变，这是一种错误的配置。所以，尽量使用read_only，它防止改变数据(除了特殊的线程)。但是，read_only并不很实用，特别是那些需要在slave上创建表的应用。&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;1.6. 重启从MYSQL服务&lt;/h2&gt;
&lt;p&gt;service mysqld restart&lt;/p&gt;
&lt;h2&gt;1.7.  启动slave (实现数据同步)&lt;/h2&gt;
&lt;p&gt;接下来就是让slave连接master，并开始重做master二进制日志中的事件。你不应该用配置文件进行该操作，而应该使用CHANGE MASTER TO语句，该语句可以完全取代对配置文件的修改，而且它可以为slave指定不同的master，而不需要停止服务器。如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置slave服务器用于连接master服务器的参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 【注意：MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=594是通过前面的主数据库SHOW MASTER STATUS;得到】&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CHANGE MASTER TO MASTER_HOST='1.1.1.1',MASTER_USER='root', MASTER_PASSWORD='password',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=594;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启SLAVE同步&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;start slave;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看下slave状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;show slave status;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235546959-917295585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当Slave_IO_Running和Slave_SQL_Running都为Yes，才说明主从复制成功&lt;/p&gt;
&lt;p&gt;slave的I/O和SQL线程都已经开始运行，而且Seconds_Behind_Master不再是NULL。日志的位置增加了，意味着一些事件被获取并执行了。如果你在master上进行修改，你可以在slave上看到各种日志文件的位置的变化，同样，你也可以看到数据库中数据的变化。&lt;/p&gt;
&lt;p&gt;你可查看master和slave上线程的状态。在master上，你可以看到slave的I/O线程创建的连接：&lt;/p&gt;
&lt;p&gt;在master上输入show processlist\G;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235557646-805151432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;行&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;为处理&lt;/strong&gt;&lt;strong&gt;slave&lt;/strong&gt;&lt;strong&gt;的&lt;/strong&gt;&lt;strong&gt;I/O&lt;/strong&gt;&lt;strong&gt;线程的连接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在slave服务器上运行该语句： show processlist;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235612600-1886367357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;为&lt;/strong&gt;&lt;strong&gt;I/O&lt;/strong&gt;&lt;strong&gt;线程状态，行&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;为&lt;/strong&gt;&lt;strong&gt;SQL&lt;/strong&gt;&lt;strong&gt;线程状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1.8.  添加新slave服务器&lt;/h2&gt;
&lt;p&gt;假如master已经运行很久了，想对新安装的slave进行数据同步，甚至它没有master的数据。&lt;br/&gt;此时，有几种方法可以使slave从另一个服务开始，例如，从master拷贝数据，从另一个slave克隆，从最近的备份开始一个slave。Slave与master同步时，需要三样东西：&lt;br/&gt;(1)master的某个时刻的数据快照；&lt;br/&gt;(2)master当前的日志文件、以及生成快照时的字节偏移。这两个值可以叫做日志文件坐标(log file coordinate)，因为它们确定了一个二进制日志的位置，你可以用SHOW MASTER STATUS命令找到日志文件的坐标；&lt;br/&gt;(3)master的二进制日志文件。&lt;/p&gt;&lt;p&gt;可以通过以下几中方法来克隆一个slave：&lt;br/&gt;(1)    冷拷贝(cold copy)&lt;br/&gt;停止master，将master的文件拷贝到slave；然后重启master。缺点很明显。&lt;br/&gt;(2)    热拷贝(warm copy)&lt;br/&gt;如果你仅使用MyISAM表，你可以使用mysqlhotcopy拷贝，即使服务器正在运行。&lt;br/&gt;(3)    使用mysqldump&lt;br/&gt;使用mysqldump来得到一个数据快照可分为以下几步：&lt;br/&gt;&amp;lt;1&amp;gt;锁表：如果你还没有锁表，你应该对表加锁，防止其它连接修改数据库，否则，你得到的数据可以是不一致的。如下：&lt;br/&gt;mysql&amp;gt; FLUSH TABLES WITH READ LOCK;&lt;br/&gt;&amp;lt; 2&amp;gt;在另一个连接用mysqldump创建一个你想进行复制的数据库的转储：&lt;br/&gt;shell&amp;gt; mysqldump --all-databases --lock-all-tables &amp;gt;dbdump.db&lt;br/&gt;&amp;lt; 3&amp;gt;对表释放锁。&lt;br/&gt;mysql&amp;gt; UNLOCK TABLES;&lt;/p&gt;



&lt;p&gt;复制的体系结构有以下一些基本原则：&lt;br/&gt;(1)    每个slave只能有一个master；&lt;br/&gt;(2)    每个slave只能有一个唯一的服务器ID；&lt;br/&gt;(3)    每个master可以有很多slave；&lt;br/&gt;(4)    如果你设置log_slave_updates，slave可以是其它slave的master，从而扩散master的更新。&lt;/p&gt;
&lt;p&gt;MySQL不支持多主服务器复制(Multimaster Replication)——即一个slave可以有多个master。但是，通过一些简单的组合，我们却可以建立灵活而强大的复制体系结构。&lt;/p&gt;

&lt;h2&gt;1.9.  单一master和多slave&lt;/h2&gt;
&lt;p&gt;由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235440381-1556961660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt; 如果写操作较少，而读操作很时，可以采取这种结构。你可以将读操作分布到其它的slave，从而减小master的压力。但是，当slave增加到一定数量时，slave对master的负载以及网络带宽都会成为一个严重的问题。&lt;br/&gt;这种结构虽然简单，但是，它却非常灵活，足够满足大多数应用需求。一些建议：&lt;br/&gt;(1)    不同的slave扮演不同的作用(例如使用不同的索引，或者不同的存储引擎)；&lt;br/&gt;(2)    用一个slave作为备用master，只进行复制；&lt;br/&gt;(3)    用一个远程的slave，用于灾难恢复；&lt;/p&gt;

&lt;h2&gt;1.10.    主动模式的Master-Master(Master-Master in Active-Active Mode)&lt;/h2&gt;
&lt;p&gt;Master-Master复制的两台服务器，既是master，又是另一台服务器的slave。如图：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235453803-1526222986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主动的Master-Master复制有一些特殊的用处。例如，地理上分布的两个部分都需要自己的可写的数据副本。这种结构最大的问题就是更新冲突。假设一个表只有一行(一列)的数据，其值为1，如果两个服务器分别同时执行如下语句：&lt;br/&gt;在第一个服务器上执行：&lt;br/&gt;mysql&amp;gt; UPDATE tbl SET col=col + 1;&lt;br/&gt;在第二个服务器上执行：&lt;br/&gt;mysql&amp;gt; UPDATE tbl SET col=col * 2;&lt;br/&gt;那么结果是多少呢？一台服务器是4，另一个服务器是3，但是，这并不会产生错误。&lt;br/&gt;实际上，MySQL并不支持其它一些DBMS支持的多主服务器复制(Multimaster Replication)，这是MySQL的复制功能很大的一个限制(多主服务器的难点在于解决更新冲突)，但是，如果你实在有这种需求，你可以采用MySQL Cluster，以及将Cluster和Replication结合起来，可以建立强大的高性能的数据库平台。但是，可以通过其它一些方式来模拟这种多主服务器的复制。&lt;/p&gt;

&lt;h2&gt;1.11.    主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)&lt;/h2&gt;
&lt;p&gt;这是master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/561186/201712/561186-20171221235504506-235470249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.12.     带从服务器的Master-Master结构(Master-Master with Slaves)&lt;/h2&gt;
&lt;p&gt;这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。&lt;/p&gt;

</description>
<pubDate>Thu, 21 Dec 2017 15:57:00 +0000</pubDate>
<dc:creator>超越自我，挑战无极限</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hxqcom/p/8083093.html</dc:identifier>
</item>
<item>
<title>JaveScript简单数据类型(JS知识点归纳二) - AmorR</title>
<link>http://www.cnblogs.com/AmorR/p/8083039.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AmorR/p/8083039.html</guid>
<description>&lt;p&gt;JS中的简单数据类型有五种 : &lt;/p&gt;
&lt;p&gt;　　　　--&amp;gt; string&lt;/p&gt;
&lt;p&gt;　　　　--&amp;gt; number&lt;/p&gt;
&lt;p&gt;　　　　--&amp;gt;boolean&lt;/p&gt;
&lt;p&gt;　　　　--&amp;gt; null　　　　&lt;/p&gt;
&lt;p&gt;　　　　--&amp;gt;undefined&lt;/p&gt;

&lt;p&gt;数据类型的检测 ：typeof &lt;/p&gt;
&lt;p&gt;　　语法：　　typeof 数据；&lt;/p&gt;
&lt;p&gt;　　　　　　   typeof （ 数据 ） ；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;typeof&lt;/span&gt; 100; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果为number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　使用typeof获取的数据类型名是字符串类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; num = 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;typeof&lt;/span&gt; num;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;result此时保存的是变量str中数据的类型名&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; console.log(&lt;span&gt;typeof&lt;/span&gt; result);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;string&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1　　使用成对的&quot;&quot;   ''，用于标识的引号是不会显示的，可以使用转义符（\) 显示&lt;/p&gt;
&lt;p&gt;2　　强制转换&lt;/p&gt;
&lt;p&gt;　　　　数据.toString();&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;var&lt;/span&gt; num = 100&lt;span&gt;;

    console.log(num.toString());
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; num.toString();
    console.log(num);
    console.log(result);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　问题： &lt;/p&gt;
&lt;p&gt;　　　　a，遇到数值类型的原值去进行toString等操作时，需要多加一个.符号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; num -100&lt;span&gt;；
console.log(&lt;/span&gt;100..toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;num.toString();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　b，undefined 和 null 不支持toString的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;undefined.toString();
&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;.toString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　String(数据)；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(String(100&lt;span&gt;));
console.log(String(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;));
console.log(String(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
console.log(String(undefined));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3　　隐式转换&lt;/p&gt;
&lt;p&gt;　　使用其他数据类型和字符串类型进行+操作，就可以进行字符链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(&quot;100abc&quot; + 200);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;100abc200&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　通常为了不改变数据的原始内容，会使用空字符串进行隐式转换的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; num = 100&lt;span&gt;;
console.log(num &lt;/span&gt;+ &quot;&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1　　　　整数类型&lt;br/&gt;2　　　　小数类型&lt;br/&gt;3　　　　不是数 NaN&lt;/p&gt;&lt;p&gt;4　　　　强制转换&lt;br/&gt;　　　　a, 　　Number(数据);&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　b,　　parseInt(数据);　　&lt;/p&gt;
&lt;p&gt;　　　　　　　　转换为整数&lt;/p&gt;
&lt;p&gt;　　　　　　　　从左边开始,遇到不是数停止,首字符不是数,返回NaN&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;　　　　c,　　parseFloat(数据);　　&lt;/p&gt;
&lt;p&gt;　　　　　　　　转换为小数 &lt;br/&gt;5　　　　隐式转换&lt;/p&gt;
&lt;p&gt;　　　　+　　 　　前面不能有字符&lt;/p&gt;
&lt;p&gt;　　　　-　　&lt;/p&gt;
&lt;p&gt;　　　　*&lt;/p&gt;
&lt;p&gt;　　　　/&lt;/p&gt;
&lt;p&gt;　　　　% &lt;/p&gt;

&lt;p&gt;1　　　　true&lt;/p&gt;
&lt;p&gt;2　　　　false&lt;/p&gt;
&lt;p&gt;　　　　　　只有以下六个值是false，其他的都是true；&lt;/p&gt;
&lt;p&gt;　　　　　　 0 　　&quot;&quot;　　 NaN　　 null　　 undefined  　　false&lt;/p&gt;
&lt;p&gt;3　　　　强制转换&lt;/p&gt;
&lt;p&gt;　　　　　　Boolean(数据);&lt;/p&gt;
&lt;p&gt;4　　　　隐式转换&lt;/p&gt;
&lt;p&gt;　　　　　　！！数据；&lt;/p&gt;


&lt;p&gt;出现的场景&lt;/p&gt;

&lt;p&gt;　　1)变量声明未赋值&lt;br/&gt;　　2)数组元素不存在&lt;br/&gt;　　3)函数形参没有值&lt;br/&gt;　　4)函数的返回值--默认值&lt;br/&gt;　　5)对象属性不存在&lt;/p&gt;

</description>
<pubDate>Thu, 21 Dec 2017 15:51:00 +0000</pubDate>
<dc:creator>AmorR</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AmorR/p/8083039.html</dc:identifier>
</item>
<item>
<title>springMVC(1)---获取前段数据 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8076274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8076274.html</guid>
<description>&lt;p&gt;        首先说明，如果你学过Struts2，那么在学springMVC就会简单很多，我也不最基础的开始写了，我前篇文章搭建了个ssm框架，算是springmvc入门了。&lt;/p&gt;
&lt;p&gt;        链接：&lt;a href=&quot;http://www.cnblogs.com/qdhxhz/p/8032314.html&quot; target=&quot;_blank&quot;&gt;基于maven的ssm框架整合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;&lt;strong&gt;一.&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;首先看一下都有哪些绑定数据的注解：           &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     1.&lt;strong&gt;&lt;span&gt;@RequestParam&lt;/span&gt;&lt;/strong&gt;，绑定单个请求数据，可以是URL中的数据，表单提交的数据或上传的文件； &lt;br/&gt;     2.&lt;strong&gt;&lt;span&gt;@PathVariable&lt;/span&gt;&lt;/strong&gt;，绑定URL模板变量值； &lt;br/&gt;     3.&lt;strong&gt;&lt;span&gt;@CookieValue&lt;/span&gt;&lt;/strong&gt;，绑定Cookie数据； &lt;br/&gt;     4&lt;strong&gt;&lt;span&gt;.@RequestHeader&lt;/span&gt;&lt;/strong&gt;，绑定请求头数据； &lt;br/&gt;     5&lt;span&gt;&lt;strong&gt;.@ModelAttribute&lt;/strong&gt;&lt;/span&gt;，绑定数据到Model； &lt;br/&gt;     6.&lt;strong&gt;&lt;span&gt;@SessionAttributes&lt;/span&gt;&lt;/strong&gt;，绑定数据到Session； &lt;br/&gt;     7.&lt;strong&gt;&lt;span&gt;@RequestBody&lt;/span&gt;&lt;/strong&gt;，用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等； &lt;br/&gt;     8.&lt;strong&gt;&lt;span&gt;@RequestPart&lt;/span&gt;&lt;/strong&gt;，绑定“multipart/data”数据，并可以根据数据类型进项对象转换；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;&lt;strong&gt;二.&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;@RequestParam讲解                                          &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;首先说明，项目的框架和架包我直接用的是smm框架整合的内容，我是在这个基础上进行操作,先看我jsp放置。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221205651818-226489146.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(1)先看Controller层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.ServletRequestUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.multipart.MultipartFile;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.multipart.MultipartHttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParamController {
  
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * GET请求
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(value&lt;/span&gt;=&quot;/jsp/paramdate&quot;, method =&lt;span&gt; {RequestMethod.GET})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView paramBind(){
        
        ModelAndView modelAndView &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView(); 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我这边指定是post请求，所以不会走到这里，所以haha.jsp也没有写&lt;/span&gt;
        modelAndView.setViewName(&quot;haha&quot;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * POST请求
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
    @RequestMapping(value&lt;/span&gt;=&quot;/jsp/paramdate&quot;, method =&lt;span&gt; {RequestMethod.POST})
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ModelAndView paramBind(HttpServletRequest request, @RequestParam(&quot;urlParam&quot;) String urlParam, @RequestParam(&quot;formParam&quot;) &lt;br/&gt;String formParam, @RequestParam(&quot;formFile&quot;&lt;span&gt;) MultipartFile formFile){
   
             
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过注解直接获得 &lt;/span&gt;
        ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();  
        modelAndView.addObject(&lt;/span&gt;&quot;urlParam&quot;&lt;span&gt;, urlParam);  
        modelAndView.addObject(&lt;/span&gt;&quot;formParam&quot;&lt;span&gt;, formParam);  
        modelAndView.addObject(&lt;/span&gt;&quot;formFileName&quot;&lt;span&gt;, formFile.getOriginalFilename());  
       
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不用注解获得数据，我们也可以手动获取&lt;/span&gt;
        String urlParam1 = ServletRequestUtils.getStringParameter(request, &quot;urlParam&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        String formParam1 &lt;/span&gt;= ServletRequestUtils.getStringParameter(request, &quot;formParam&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        MultipartFile formFile1 &lt;/span&gt;= ((MultipartHttpServletRequest) request).getFile(&quot;formFile&quot;&lt;span&gt;);     
 
        modelAndView.addObject(&lt;/span&gt;&quot;urlParam1&quot;&lt;span&gt;, urlParam1);  
        modelAndView.addObject(&lt;/span&gt;&quot;formParam1&quot;&lt;span&gt;, formParam1);  
        modelAndView.addObject(&lt;/span&gt;&quot;formFileName1&quot;&lt;span&gt;, formFile1.getOriginalFilename());  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setViewName代表返回界面名称&lt;/span&gt;
        modelAndView.setViewName(&quot;return&quot;&lt;span&gt;);  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
    }        
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2)开始的start.jsp&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;paramdate?urlParam=你好&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; enctype&lt;/span&gt;&lt;span&gt;=&quot;multipart/form-data&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;formParam&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;file&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;formFile&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221210607537-960581300.png&quot; alt=&quot;我输入徐小小，提交好好生活.TXT文件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(3)返回return.jsp&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    注解获取数据：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${urlParam}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formParam}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formFileName}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    手动获取数据：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${urlParam1}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formParam1}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
    ${formFileName1}&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221210934318-424477958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这个小案例，我们通过注解和非注解的方式，把前段界面的值传到后端，在从后端传到前段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;思考：&lt;/span&gt;&lt;/strong&gt;我们在实际开发中，在前段往后段传值的时候，后端一个一个获取值再放到Model实体中，还是太麻烦。别担心，我们不需要把数据绑定到一个个变量然后在对model赋值，只需要把model加入相应的action参数（这里不需要指定绑定数据的注解）Spring MVC会自动进行数据转换并绑定到model对象上，一切就是这么简单。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 三.通过实体获取前端值                                                       &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;(1)建立User实体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;提供set和get方法，toString方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2)建立Controller类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.ui.Model;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.ssm.model.User;

@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UsersController {

@RequestMapping(&lt;/span&gt;&quot;/jsp/loging&quot;&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getUser(HttpServletRequest request, Model model,User user){
    User  users&lt;/span&gt;=&lt;span&gt;user;
    System.out.println(users.getName()&lt;/span&gt;+&quot;--&quot;+&lt;span&gt;users.getPassword());
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(3)开始loging.jsp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    pageEncoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如何要使用SpringMVC标签，那么一定要添加下面这个taglib &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/tags/form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;

 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 如果你要使用model进行赋值，那就需要指明哪个model，而且id中的值要和下面值一致，不然会报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Neither BindingResult nor plain target object for bean name 'users' available as request attribute &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jsp:useBean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.ssm.model.User&quot;&lt;/span&gt;&lt;span&gt; scope&lt;/span&gt;&lt;span&gt;=&quot;request&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;loging&quot;&lt;/span&gt;&lt;span&gt; modelAttribute&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;     
        用户名：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:input &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        密 码：&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form:password &lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;Submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 还有如果你的form表单中，path中的名字，在model中没有也会报错，比如我加一个names，当加载页面时报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Invalid property 'names' of bean class [com.ssm.model.User]: Bean property 'names' is not readable &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;界面&lt;/span&gt;&lt;/strong&gt; (密码123)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221221553631-1954540612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(4)最后我们在后台看我们打印的那条数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1090617/201712/1090617-20171221221701287-1797980910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经成功，直接把属性注入到了user中。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;/strong&gt;少尉【8】&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 21 Dec 2017 14:22:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8076274.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web API下事件驱动型架构的实现（一）：一个简单的实现 - dax.net</title>
<link>http://www.cnblogs.com/daxnet/p/8082694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daxnet/p/8082694.html</guid>
<description>&lt;p&gt;很长一段时间以来，我都在思考如何在ASP.NET Core的框架下，实现一套完整的事件驱动型架构。这个问题看上去有点大，其实主要目标是为了实现一个基于ASP.NET Core的微服务，它能够非常简单地订阅来自于某个渠道的事件消息，并对接收到的消息进行处理，于此同时，它还能够向该渠道发送事件消息，以便订阅该事件消息的消费者能够对消息数据做进一步处理。让我们回顾一下微服务之间通信的几种方式，分为同步和异步两种。同步通信最常见的就是RESTful API，而且非常简单轻量，一个Request/Response回环就结束了；异步通信最常见的就是通过消息渠道，将载有特殊意义的数据的事件消息发送到消息渠道，而对某种类型消息感兴趣的消费者，就可以获取消息中所带信息并执行相应操作，这也是我们比较熟知的事件驱动架构的一种表现形式。虽然事件驱动型架构看起来非常复杂，从微服务的实现来看显得有些繁重，但它的应用范围确实很广，也为服务间通信提供了新的思路。了解DDD的朋友相信一定知道CQRS体系结构模式，它就是一种事件驱动型架构。事实上，实现一套完整的、安全的、稳定的、正确的事件驱动架构并不简单，由于异步特性带来的一致性问题会非常棘手，甚至需要借助一些基础结构层工具（比如关系型数据库，不错！只能是关系型数据库）来解决一些特殊问题。本文就打算带领大家一起探探路，基于ASP.NET Core Web API实现一个相对比较简单的事件驱动架构，然后引出一些有待深入思考的问题，留在今后的文章中继续讨论。或许，本文所引入的源代码无法直接用于生产环境，但我希望本文介绍的内容能够给到读者一些启发，并能够帮助解决实际中遇到的问题。&lt;/p&gt;

&lt;p&gt;本文会涉及一些相关的专业术语，在此先作约定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件：在某一特定时刻发生在某件事物上的一件事情，例如：在我撰写本文的时候，电话铃响了&lt;/li&gt;
&lt;li&gt;消息：承载事件数据的实体。事件的序列化/反序列化和传输都以消息的形式进行&lt;/li&gt;
&lt;li&gt;消息通信渠道：一种带有消息路由功能的数据传输机制，用以在消息的派发器和订阅器之间进行数据传输&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：为了迎合描述的需要，在下文中可能会混用事件和消息两个概念。&lt;/p&gt;

&lt;p&gt;先从简单的设计开始，基本上事件驱动型架构会有事件消息（Events）、事件订阅器（Event Subscriber）、事件派发器（Event Publisher）、事件处理器（Event Handler）以及事件总线（Event Bus）等主要组件，它们之间的关系大致如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221011475-1277958781.png&quot;&gt;&lt;img width=&quot;1234&quot; height=&quot;725&quot; title=&quot;class_diagram&quot; alt=&quot;class_diagram&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221011725-384486125.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，IEvent接口定义了事件消息（更确切地说，数据）的基本结构，几乎所有的事件都会有一个唯一标识符（Id）和一个事件发生的时间（Timestamp），这个时间通常使用UTC时间作为标准。IEventHandler定义了事件处理器接口，显而易见，它包含两个方法：CanHandle方法，用以确定传入的事件对象是否可被当前处理器所处理，以及Handle方法，它定义了事件的处理过程。IEvent和IEventHandler构成了事件处理的基本元素。&lt;/p&gt;
&lt;p&gt;然后就是IEventSubscriber与IEventPublisher接口。前者表示实现该接口的类型为事件订阅器，它负责事件处理器的注册，并侦听来自事件通信渠道上的消息，一旦所获得的消息能够被某个处理器处理，它就会指派该处理器对接收到的消息进行处理。因此，IEventSubscriber会保持着对事件处理器的引用；而对于实现了IEventPublisher接口的事件派发器而言，它的主要任务就是将事件消息发送到消息通信渠道，以便订阅端能够获得消息并进行处理。&lt;/p&gt;
&lt;p&gt;IEventBus接口表示消息通信渠道，也就是大家所熟知的消息总线的概念。它不仅具有消息订阅的功能，而且还具有消息派发的能力，因此，它会同时继承于IEventSubscriber和IEventPublisher接口。在上面的设计中，通过接口分离消息总线的订阅器和派发器的角色是很有必要的，因为两种角色的各自职责不一样，这样的设计同时满足SOLID中的SRP和ISP两个准则。&lt;/p&gt;
&lt;p&gt;基于以上基础模型，我们可以很快地将这个对象关系模型转换为C#代码：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public interface IEvent
{
    Guid Id { get; }
    DateTime Timestamp { get; }
}

public interface IEventHandler
{
    Task&amp;lt;bool&amp;gt; HandleAsync(IEvent @event, CancellationToken cancellationToken = default);
    bool CanHandle(IEvent @event);
}

public interface IEventHandler&amp;lt;in T&amp;gt; : IEventHandler
    where T : IEvent
{
    Task&amp;lt;bool&amp;gt; HandleAsync(T @event, CancellationToken cancellationToken = default);
}

public interface IEventPublisher : IDisposable
{
    Task PublishAsync&amp;lt;TEvent&amp;gt;(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IEvent;
}

public interface IEventSubscriber : IDisposable
{
    void Subscribe();
}

public interface IEventBus : IEventPublisher, IEventSubscriber { }
&lt;/pre&gt;
&lt;p&gt;短短30行代码，就把我们的基本对象关系描述清楚了。对于上面的代码我们需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这段代码使用了C# 7.1的新特性（default关键字）&lt;/li&gt;
&lt;li&gt;Publish以及Handle方法被替换为支持异步调用的PublishAsync和HandleAsync方法，它们会返回Task对象，这样可以方便使用C#中async/await的编程模型&lt;/li&gt;
&lt;li&gt;由于我们的这个模型可以作为实现消息系统的通用模型，并且会需要用到ASP.NET Core的项目中，因此，建议将这些接口的定义放在一个独立的NetStandard的Class Library中，方便今后重用和扩展&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;OK，接口定义好了。实现呢？下面，我们实现一个非常简单的消息总线：PassThroughEventBus。在今后的文章中，我还会介绍如何基于RabbitMQ和Azure Service Bus实现不一样的消息总线。&lt;/p&gt;

&lt;p&gt;顾名思义，PassThroughEventBus表示当有消息被派发到消息总线时，消息总线将不做任何处理与路由，而是直接将消息推送到订阅方。在订阅方的事件监听函数中，会通过已经注册的事件处理器对接收到的消息进行处理。整个过程并不会依赖于任何外部组件，不需要引用额外的开发库，只是利用现有的.NET数据结构来模拟消息的派发和订阅过程。因此，PassThroughEventBus不具备容错和消息重发功能，不具备消息存储和路由功能，我们先实现这样一个简单的消息总线，来体验事件驱动型架构的设计过程。&lt;/p&gt;
&lt;p&gt;我们可以使用.NET中的Queue或者ConcurrentQueue等基本数据结构来作为消息队列的实现，与这些基本的数据结构相比，消息队列本身有它自己的职责，它需要在消息被推送进队列的同时通知调用方。当然，PassThroughEventBus不需要依赖于Queue或者ConcurrentQueue，它所要做的事情就是模拟一个消息队列，当消息推送进来的时候，立刻通知订阅方进行处理。同样，为了分离职责，我们可以引入一个EventQueue的实现（如下），从而将消息推送和路由的职责（基础结构层的职责）从消息总线中分离出来。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
internal sealed class EventQueue
{
    public event System.EventHandler&amp;lt;EventProcessedEventArgs&amp;gt; EventPushed;

    public EventQueue() { }

    public void Push(IEvent @event)
    {
        OnMessagePushed(new EventProcessedEventArgs(@event));
    }

    private void OnMessagePushed(EventProcessedEventArgs e) =&amp;gt; this.EventPushed?.Invoke(this, e);
}
&lt;/pre&gt;
&lt;p&gt;EventQueue中最主要的方法就是Push方法，从上面的代码可以看到，当EventQueue的Push方法被调用时，它将立刻触发EventPushed事件，它是一个.NET事件，用以通知EventQueue对象的订阅者，消息已经被派发。整个EventQueue的实现非常简单，我们仅专注于事件的路由，完全没有考虑任何额外的事情。&lt;/p&gt;
&lt;p&gt;接下来，就是利用EventQueue来实现PassThroughEventBus。毫无悬念，PassThroughEventBus需要实现IEventBus接口，它的两个基本操作分别是Publish和Subscribe。在Publish方法中，会将传入的事件消息转发到EventQueue上，而Subscribe方法则会订阅EventQueue.EventPushed事件（.NET事件），而在EventPushed事件处理过程中，会从所有已注册的事件处理器（Event Handlers）中找到能够处理所接收到的事件，并对其进行处理。整个流程还是非常清晰的。以下便是PassThroughEventBus的实现代码：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public sealed class PassThroughEventBus : IEventBus
{
    private readonly EventQueue eventQueue = new EventQueue();
    private readonly IEnumerable&amp;lt;IEventHandler&amp;gt; eventHandlers;

    public PassThroughEventBus(IEnumerable&amp;lt;IEventHandler&amp;gt; eventHandlers)
    {
        this.eventHandlers = eventHandlers;
    }

    private void EventQueue_EventPushed(object sender, EventProcessedEventArgs e)
        =&amp;gt; (from eh in this.eventHandlers
            where eh.CanHandle(e.Event)
            select eh).ToList().ForEach(async eh =&amp;gt; await eh.HandleAsync(e.Event));

    public Task PublishAsync&amp;lt;TEvent&amp;gt;(TEvent @event, CancellationToken cancellationToken = default)
        where TEvent : IEvent
            =&amp;gt; Task.Factory.StartNew(() =&amp;gt; eventQueue.Push(@event));

    public void Subscribe()
        =&amp;gt; eventQueue.EventPushed += EventQueue_EventPushed;


    #region IDisposable Support
    private bool disposedValue = false; // To detect redundant calls
    void Dispose(bool disposing)
    {
        if (!disposedValue)
        {
            if (disposing)
            {
                this.eventQueue.EventPushed -= EventQueue_EventPushed;
            }

            disposedValue = true;
        }
    }
    public void Dispose() =&amp;gt; Dispose(true);
    #endregion
}
&lt;/pre&gt;
&lt;p&gt;实现过程非常简单，当然，从这些代码也可以更清楚地了解到，PassThroughEventBus不做任何路由处理，更不会依赖于一个基础结构设施（比如实现了AMQP的消息队列），因此，不要指望能够在生产环境中使用它。不过，目前来看，它对于我们接下来要讨论的事情还是会很有帮助的，至少在我们引入基于RabbitMQ等实现的消息总线之前。&lt;/p&gt;
&lt;p&gt;同样地，请将PassThroughEventBus实现在另一个NetStandard的Class Library中，虽然它不需要额外的依赖，但它毕竟是众多消息总线中的一种，将它从接口定义的程序集中剥离开来，好处有两点：第一，保证了定义接口的程序集的纯净度，使得该程序集不需要依赖任何外部组件，并确保了该程序集的职责单一性，即为消息系统的实现提供基础类库；第二，将PassThroughEventBus置于独立的程序集中，有利于调用方针对IEventBus进行技术选择，比如，如果开发者选择使用基于RabbitMQ的实现，那么，只需要引用基于RabbitMQ实现IEventBus接口的程序集就可以了，而无需引用包含了PassThroughEventBus的程序集。这一点我觉得可以归纳为框架设计中“隔离依赖关系（Dependency Segregation）”的准则。&lt;/p&gt;
&lt;p&gt;好了，基本组件都定义好了，接下来，让我们一起基于ASP.NET Core Web API来做一个RESTful服务，并接入上面的消息总线机制，实现消息的派发和订阅。&lt;/p&gt;

&lt;p&gt;我们仍然以客户管理的RESTful API为例子，不过，我们不会过多地讨论如何去实现管理客户信息的RESTful服务，那并不是本文的重点。作为一个案例，我使用ASP.NET Core 2.0 Web API建立了这个服务，使用Visual Studio 2017 15.5做开发，并在CustomersController中使用Dapper来对客户信息CRUD。后台基于SQL Server 2017 Express Edition，使用SQL Server Management Studio能够让我方便地查看数据库操作的结果。&lt;/p&gt;
&lt;h2&gt;RESTful API的实现&lt;/h2&gt;
&lt;p&gt;假设我们的客户信息只包含客户ID和名称，下面的CustomersController代码展示了我们的RESTful服务是如何保存并读取客户信息的。当然，我已经将本文的代码通过Github开源，开源协议为MIT，虽然商业友好，但毕竟是案例代码没有经过测试，所以请谨慎使用。本文源代码的使用我会在文末介绍。&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
[Route(&quot;api/[controller]&quot;)]
public class CustomersController : Controller
{
    private readonly IConfiguration configuration;
    private readonly string connectionString;

    public CustomersController(IConfiguration configuration)
    {
        this.configuration = configuration;
        this.connectionString = configuration[&quot;mssql:connectionString&quot;];
    }


    // 获取指定ID的客户信息
    [HttpGet(&quot;{id}&quot;)]
    public async Task&amp;lt;IActionResult&amp;gt; Get(Guid id)
    {
        const string sql = &quot;SELECT [CustomerId] AS Id, [CustomerName] AS Name FROM [dbo].[Customers] WHERE [CustomerId]=@id&quot;;
        using (var connection = new SqlConnection(connectionString))
        {
            var customer = await connection.QueryFirstOrDefaultAsync&amp;lt;Model.Customer&amp;gt;(sql, new { id });
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer);
        }
    }

    // 创建新的客户信息
    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody] dynamic model)
    {
        var name = (string)model.Name;
        if (string.IsNullOrEmpty(name))
        {
            return BadRequest();
        }

        const string sql = &quot;INSERT INTO [dbo].[Customers] ([CustomerId], [CustomerName]) VALUES (@Id, @Name)&quot;;
        using (var connection = new SqlConnection(connectionString))
        {
            var customer = new Model.Customer(name);
            await connection.ExecuteAsync(sql, customer);

            return Created(Url.Action(&quot;Get&quot;, new { id = customer.Id }), customer.Id);
        }
    }
}
&lt;/pre&gt;
&lt;p&gt;代码一如既往的简单，Web API控制器通过Dapper简单地实现了客户信息的创建和返回。我们不妨测试一下，使用下面的Invoke-RestMethod PowerShell指令，发送Post请求，通过上面的Create方法创建一个用户：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221011959-1353324131.png&quot;&gt;&lt;img width=&quot;862&quot; height=&quot;153&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012131-1565904431.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，response中已经返回了新建客户的ID号。接下来，继续使用Invoke-RestMethod来获取新建客户的详细信息：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012287-1264844047.png&quot;&gt;&lt;img width=&quot;863&quot; height=&quot;181&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012459-563335535.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OK，API调试完全没有问题。下面，我们将这个案例再扩充一下，我们希望这个API在完成客户信息创建的同时，向外界发送一条“客户信息已创建”的事件，并设置一个事件处理器，负责将该事件的详细内容保存到数据库中。&lt;/p&gt;
&lt;h2&gt;加入事件总线和消息处理机制&lt;/h2&gt;
&lt;p&gt;首先，我们在ASP.NET Core Web API项目上，添加对以上两个程序集的引用，然后，按常规做法，在ConfigureServices方法中，将PassThroughEventBus添加到IoC容器中：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3];&quot;&gt;
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();
}
&lt;/pre&gt;
&lt;p&gt;在此，将事件总线注册为单例（Singleton）服务，是因为它不保存状态。理论上讲，使用单例服务时，需要特别注意服务实例对象的生命周期管理，因为它的生命周期是整个应用程序级别，在程序运行的过程中，由其引用的对象资源将无法释放，因此，当程序结束运行时，需要合理地将这些资源dispose掉。好在ASP.NET Core的依赖注入框架中已经帮我们处理过了，因此，对于上面的PassThroughEventBus单例注册，我们不需要过多担心，程序执行结束并正常退出时，依赖注入框架会自动帮我们dispose掉PassThroughEventBus的单例实例。那么对于单例实例来说，我们是否只需要通过AddSingleton方法进行注册就可以了，而无需关注它是否真的被dispose了呢？答案是否定的，有兴趣的读者可以参考&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection#designing-your-services-for-dependency-injection&quot; target=&quot;_blank&quot;&gt;微软的官方文档&lt;/a&gt;，在下一篇文章中我会对这部分内容做些介绍。&lt;/p&gt;
&lt;p&gt;接下来，我们需要定义一个CustomerCreatedEvent对象，表示“客户信息已经创建”这一事件信息，同时，再定义一个CustomerCreatedEventHandler事件处理器，用来处理从PassThroughEventBus接收到的事件消息。代码如下，当然也很简单：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp;&quot;&gt;
public class CustomerCreatedEvent : IEvent
{
    public CustomerCreatedEvent(string customerName)
    {
        this.Id = Guid.NewGuid();
        this.Timestamp = DateTime.UtcNow;
        this.CustomerName = customerName;
    }

    public Guid Id { get; }

    public DateTime Timestamp { get; }

    public string CustomerName { get; }
}

public class CustomerCreatedEventHandler : IEventHandler&amp;lt;CustomerCreatedEvent&amp;gt;
{
    public bool CanHandle(IEvent @event)
        =&amp;gt; @event.GetType().Equals(typeof(CustomerCreatedEvent));

    public Task&amp;lt;bool&amp;gt; HandleAsync(CustomerCreatedEvent @event, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(true);
    

    public Task&amp;lt;bool&amp;gt; HandleAsync(IEvent @event, CancellationToken cancellationToken = default)
        =&amp;gt; CanHandle(@event) ? HandleAsync((CustomerCreatedEvent)@event, cancellationToken) : Task.FromResult(false);
}
&lt;/pre&gt;
&lt;p&gt;两者分别实现了我们最开始定义好的IEvent和IEventHandler接口。在CustomerCreatedEventHandler类的第一个HandleAsync重载方法中，我们暂且让它简单地返回一个true值，表示事件处理成功。下面要做的事情就是，在客户信息创建成功后，向事件总线发送CustomerCreatedEvent事件，以及在ASP.NET Core Web API程序启动的时候，注册CustomerCreatedEventHandler实例，并调用事件总线的Subscribe方法，使其开始侦听事件的派发行为。&lt;/p&gt;
&lt;p&gt;于是，CustomerController需要依赖IEventBus，并且在CustomerController.Create方法中，需要通过调用IEventBus的Publish方法将事件发送出去。现对CustomerController的实现做一些调整，调整后代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [6,9,13,32];&quot;&gt;
[Route(&quot;api/[controller]&quot;)]
public class CustomersController : Controller
{
    private readonly IConfiguration configuration;
    private readonly string connectionString;
    private readonly IEventBus eventBus;

    public CustomersController(IConfiguration configuration,
        IEventBus eventBus)
    {
        this.configuration = configuration;
        this.connectionString = configuration[&quot;mssql:connectionString&quot;];
        this.eventBus = eventBus;
    }

    // 创建新的客户信息
    [HttpPost]
    public async Task&amp;lt;IActionResult&amp;gt; Create([FromBody] dynamic model)
    {
        var name = (string)model.Name;
        if (string.IsNullOrEmpty(name))
        {
            return BadRequest();
        }

        const string sql = &quot;INSERT INTO [dbo].[Customers] ([CustomerId], [CustomerName]) VALUES (@Id, @Name)&quot;;
        using (var connection = new SqlConnection(connectionString))
        {
            var customer = new Model.Customer(name);
            await connection.ExecuteAsync(sql, customer);

            await this.eventBus.PublishAsync(new CustomerCreatedEvent(name));

            return Created(Url.Action(&quot;Get&quot;, new { id = customer.Id }), customer.Id);
        }
    }
    
    // Get方法暂且省略
}
&lt;/pre&gt;
&lt;p&gt;然后，修改Startup.cs中的ConfigureServices方法，将CustomerCreatedEventHandler注册进来：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [5];&quot;&gt;
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddTransient&amp;lt;IEventHandler, CustomerCreatedEventHandler&amp;gt;();
    services.AddSingleton&amp;lt;IEventBus, PassThroughEventBus&amp;gt;();
}
&lt;/pre&gt;
&lt;p&gt;并且调用Subscribe方法，开始侦听消息总线：&lt;/p&gt;
&lt;pre class=&quot;brush: csharp; highlight: [3,4];&quot;&gt;
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    var eventBus = app.ApplicationServices.GetRequiredService&amp;lt;IEventBus&amp;gt;();
    eventBus.Subscribe();

    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }

    app.UseMvc();
}
&lt;/pre&gt;
&lt;p&gt;OK，现在让我们在CustomerCreatedEventHandler的HandleAsync方法上设置个断点，按下F5启用Visual Studio 2017调试，然后重新使用Invoke-RestMethod命令发送一个Post请求，可以看到，HandleAsync方法上的断点被命中，同时事件已被正确派发：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012600-1791331395.png&quot;&gt;&lt;img width=&quot;1033&quot; height=&quot;359&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012787-398473329.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数据库中的数据也被正确更新：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221012943-1439451562.png&quot;&gt;&lt;img width=&quot;562&quot; height=&quot;304&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221013146-1790163733.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前还差最后一小步，就是在HandleAsync中，将CustomerCreatedEvent对象的数据序列化并保存到数据库中。当然这也不难，同样可以考虑使用Dapper，或者直接使用ADO.NET，甚至使用比较重量级的Entity Framework Core，都可以实现。那就在此将这个问题留给感兴趣的读者朋友自己搞定啦。&lt;/p&gt;

&lt;p&gt;到这里基本上本文的内容也就告一段落了，回顾一下，本文一开始就提出了一种相对简单的消息系统和事件驱动型架构的设计模型，并实现了一个最简单的事件总线：PassThroughEventBus。随后，结合一个实际的ASP.NET Core Web API案例，了解了在RESTful API中实现事件消息派发和订阅的过程，并实现了在事件处理器中，对获得的事件消息进行处理。&lt;/p&gt;
&lt;p&gt;然而，我们还有很多问题需要更深入地思考，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果事件处理器需要依赖基础结构层组件，依赖关系如何管理？组件生命周期如何管理？&lt;/li&gt;
&lt;li&gt;如何实现基于RabbitMQ或者Azure Service Bus的事件总线？&lt;/li&gt;
&lt;li&gt;如果在数据库更新成功后，事件发送失败怎么办？&lt;/li&gt;
&lt;li&gt;如何保证事件处理的顺序？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等等。。。在接下来的文章中，我会尽力做更详细的介绍。&lt;/p&gt;

&lt;p&gt;本系列文章的源代码在&lt;a href=&quot;https://github.com/daxnet/edasample&quot;&gt;https://github.com/daxnet/edasample&lt;/a&gt;这个Github Repo里，通过不同的release tag来区分针对不同章节的源代码。本文的源代码请参考chapter_1这个tag，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221013303-1527015098.png&quot;&gt;&lt;img width=&quot;671&quot; height=&quot;478&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/119825/201712/119825-20171221221013568-1526148515.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来还将会有chapter_2、chapter_3等这些tag，对应本系列文章的第二部分、第三部分等等。敬请期待。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 14:10:00 +0000</pubDate>
<dc:creator>dax.net</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daxnet/p/8082694.html</dc:identifier>
</item>
<item>
<title>数据结构(三)--栈 - xiaoyouPrince</title>
<link>http://www.cnblogs.com/xiaoyouPrince/p/8082640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyouPrince/p/8082640.html</guid>
<description>&lt;p&gt;通常程序开发中内存管理是非常重要的，而内存主要分为占内存和堆内存。那么栈和堆内存有什么区别呢？希望在这篇文章里能带你找到答案！&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;1. 栈和堆的引入&lt;/h2&gt;
&lt;p&gt;在一个简单的程序中我们定义和声明几个基本类型的变量、结构体和数组，先来直观看一下栈和堆的不同：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221214952568-2020010359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;静态变量 和 局部变量是以压栈出栈的方式分配内存的，系统会在一个代码段中分配和回收局部变量，实际上每个代码段、函数都是一个或多个嵌套的栈，我们不需要手动管理栈区内存。&lt;/li&gt;
&lt;li&gt;动态内存是一种堆排序的方式分配内存的，内存分配好后便不会自动回收，需要程序员手动回收。否则就会造成内存泄漏，内存越用越少。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单了解了一下程序中内存栈与堆的区别，下面就正式开始讲数据结构中的栈。&lt;br/&gt;(注意：数据结构栈、内存栈、函数调用栈三者在含义上略有不同，但是其核心思想和理念是相同的)&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;2. 栈的定义&lt;/h2&gt;
&lt;p&gt;栈是一种“先进后出”的一种数据结构，有压栈出栈两种操作方式。如下图：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221215006693-1385262401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_3&quot;&gt;3. 栈的分类&lt;/h2&gt;
&lt;p&gt;栈主要分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态栈&lt;/li&gt;
&lt;li&gt;动态栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;【静态栈】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【动态栈】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态栈的核心是数组，类似于一个连续内存的数组，我们只能操作其栈顶节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221215107365-1093439111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;toc_4&quot;&gt;4. 栈的算法&lt;/h2&gt;
&lt;p&gt;栈的算法主要是压栈和出栈两种操作的算法，下面我就用代码来实现一个简单的栈。&lt;/p&gt;
&lt;p&gt;首先要明白以下思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;栈操作的是一个一个节点&lt;/li&gt;
&lt;li&gt;栈本身也是一种存储的数据结构&lt;/li&gt;
&lt;li&gt;栈有&lt;code&gt;初始化&lt;/code&gt;、&lt;code&gt;压栈&lt;/code&gt;、&lt;code&gt;出栈&lt;/code&gt;、&lt;code&gt;判空&lt;/code&gt;、&lt;code&gt;遍历&lt;/code&gt;、&lt;code&gt;清空&lt;/code&gt;等主要方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_5&quot;&gt;4.1 栈的头文件定义&lt;/h3&gt;
&lt;p&gt;头文件定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct Node{    // 节点
    
    int data;
    struct Node *pNext;
    
}*PNODE,NODE;

typedef struct Stack{   // 栈
    
    PNODE pTop;
    PNODE pBottom;
    
}STACK,*PSTACK;

/**栈的初始化*/
void init(PSTACK);
/**压栈*/
void push(PSTACK,int);
/**出栈*/
int pop(PSTACK , int *);
/**遍历打印栈*/
void traverse(PSTACK);
/**是否为空栈*/
int isEmpty(PSTACK);
/**清空栈*/
void clearStack(PSTACK);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了头文件定义，基本就确定了栈的使用结构和使用方式。下面是在主函数中对这个栈的创建和使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int main(void){
    
    STACK stack;  // 声明一个栈
    init(&amp;amp;stack);   // 初始化
    
    // 压栈
    push(&amp;amp;stack, 10);
    push(&amp;amp;stack, 20);
    push(&amp;amp;stack, 30);
    push(&amp;amp;stack, 40);
    push(&amp;amp;stack, 50);
    
    traverse(&amp;amp;stack);   // 遍历打印栈
    
    int val;
    int isPopSuccess = pop(&amp;amp;stack,&amp;amp;val);
    if (isPopSuccess) {
        printf(&quot;pop 的值为 %d\n&quot;,val);
    }
    
    traverse(&amp;amp;stack);
    
    clearStack(&amp;amp;stack);   // 清空栈
    traverse(&amp;amp;stack);
    
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;4.2 栈的初始化&lt;/h3&gt;
&lt;p&gt;思路：&lt;br/&gt;拿到栈声明的指针，开辟一块内存空间给栈顶栈底，此时是一个空栈，栈顶栈底指向同一块内存，且栈底栈顶以外不再指向其他节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**栈的初始化*/
void init(PSTACK pS){
    
    pS-&amp;gt;pTop = (PNODE)malloc(sizeof(NODE));
    if (pS-&amp;gt;pTop == NULL) {
        printf(&quot;内存分配失败退出&quot;);
        return;
    }else
    {
        pS-&amp;gt;pBottom = pS-&amp;gt;pTop;
        pS-&amp;gt;pTop-&amp;gt;pNext = NULL;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;4.3 压栈 和 出栈&lt;/h3&gt;
&lt;p&gt;思路：&lt;br/&gt;压栈是把新的节点放入栈顶，且每次压栈操作只能将新的节点放到栈的顶部。&lt;br/&gt;出栈需判断是否原本为空栈，存在出栈失败的情况，把栈顶指向栈顶元素的下一个元素，并释放原来栈顶元素空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 压栈

 @param pS 执行压栈的栈指针
 @param val 被压栈的值
 */
void push(PSTACK pS,int val){
    
    // 创建新节点，放到栈顶
    
    PNODE pNew = (PNODE)malloc(sizeof(NODE));
    pNew-&amp;gt;data = val;
    pNew-&amp;gt;pNext = pS-&amp;gt;pTop;
    
    pS-&amp;gt;pTop = pNew;    // 栈顶指针指向新元素
}

/**
 出栈

 @param pS 执行出栈的栈地址
 @param val 出栈值的地址
 @return 是否出栈成功
 */
int pop(PSTACK pS , int *val){
    
    if (isEmpty(pS)) {
        printf(&quot; 空栈 ，出栈失败&quot;);
        return 0;
    }else
    {
        PNODE p = pS-&amp;gt;pTop;
        pS-&amp;gt;pTop = p-&amp;gt;pNext;
        
        if (val != NULL) {
            *val = p-&amp;gt;data;
        }
        free(p);                // 释放原来top内存
        p = NULL;
        return 1;
    }
}

/**是否为空栈*/
int isEmpty(PSTACK pS)
{
    if (pS-&amp;gt;pTop == pS-&amp;gt;pBottom) {
        return 1;
    }else
    {
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;4.4 栈的清空 和 遍历&lt;/h3&gt;
&lt;p&gt;当一个代码段执行完成之后，实际上就是这个栈所有分配的空间都被回收，栈随之被清空！&lt;/p&gt;
&lt;p&gt;思路：&lt;br/&gt;栈清空，实际就是需要循环执行出栈操作。&lt;br/&gt;栈遍历，实际就是栈元素从栈顶一个个遍历到栈底，可以打印栈中元素的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**清空栈*/
void clearStack(PSTACK pS){
    
    if (isEmpty(pS)) {
        return;
    }else{
        PNODE p = pS-&amp;gt;pTop;
        PNODE q = NULL;
        
        while (p!=pS-&amp;gt;pBottom) {
            q = p-&amp;gt;pNext;
            free(p);        // 释放原栈顶元素空间
            p = q;
        }
        pS-&amp;gt;pTop = pS-&amp;gt;pBottom;
    }

    
//    偷懒的做法
//    while (!isEmpty(pS)) {
//        pop(pS, NULL);
//    }
}


/**遍历打印栈*/
void traverse(PSTACK pS){
    
    // 只要不是空栈，就一直输出
    PNODE p = pS-&amp;gt;pTop;
    while (p != pS-&amp;gt;pBottom) {
    
        printf(&quot;%d   &quot;,p-&amp;gt;data);
        
        p = p-&amp;gt;pNext;  // 把top的下一个节点付给top，继续遍历
    }
    printf(&quot;\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_9&quot;&gt;5. 栈的应用&lt;/h2&gt;
&lt;p&gt;栈结构固有的先进后出的特性，使它成为在程序设计中非常有用的工具，这里列举几个典型的例子。&lt;/p&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;5.1 数制转换&lt;/h3&gt;
&lt;p&gt;十进制数 N 和其他 d 进制数的转换是计算机实现计算的基本问题，其解决方法有很多种，其中一个简单的方法基于如下原理：&lt;br/&gt;&lt;code&gt;N = (N div d) * d + N mod d&lt;/code&gt;(其中div是整除运算，mod 为求余运算)&lt;br/&gt;例如：1348(10进制) == 2504(8进制)运算过程如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;N div 8&lt;/th&gt;
&lt;th&gt;N mod 8&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1348&lt;/td&gt;
&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;168&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;需求:&lt;/strong&gt;输入一个任意非负十进制整数，打印输出其对应的八进制整数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路:&lt;/strong&gt;由于上述计算过程是从低到高位顺序产生八进制数的各个数位，而打印输出，一般来说应从高位到低位进行，恰好和计算过程相反。因此可利用栈先进后出特性，将计算过程中得到的八进制数各位顺序进栈，再按出栈序列打印输出既为与输入对应的八进制数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void conversion(void){
    
    // 创建栈
    STACK S;
    init(&amp;amp;S);
    
    // 用户输入十进制数
    scanf(&quot;%d&quot;,&amp;amp;N);
        
    // 放入栈中
    while (N) {
        push(&amp;amp;S, N % 8);
        N = N / 8;
    }
    
    // 打印出来
    printf(&quot;对应八进制数字为:&quot;);
    int a;
    while (!isEmpty(&amp;amp;S)) {
        pop(&amp;amp;S, &amp;amp;a);
        printf(&quot;%d&quot;,a);
    }
    printf(&quot;\n&quot;);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt; 用数组实现貌似更简单，为什么不用数组？&lt;br/&gt;从算法上分析不难看出，栈的引入简化了程序设计的问题，划分了不同的关注层次，使思考范围缩小了。而使用数组不仅掩盖了问题的本质，还要分散精力去思路数组下标增减等细节问题。&lt;br/&gt;这也是早期面向对象编程的一种思想，要把对应的功能划分关注层次，在逻辑的实现上面更加专注问题的本质。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;toc_11&quot;&gt;5.2 括号匹配的检验&lt;/h3&gt;
&lt;p&gt;编程语言中基本都允许使用 &lt;code&gt;(),[],{}&lt;/code&gt;这几种括号，假设现在让使用两种，一段完整代码中其须成对匹配，检验括号是否匹配的方法可用&quot;期待的紧迫程度&quot;这个概念来描述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/905487/201712/905487-20171221215130975-32921400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当计算机接受了第一个括号后，它期待着与其匹配的第八个括号出现，然而等来的确实第二个括号，此时第一个括号&lt;code&gt;[&lt;/code&gt;只能暂时靠边，而迫切等待与第二个括号匹配的第七个括号&lt;code&gt;)&lt;/code&gt;出现，类似地，等来的是第三个括号&lt;code&gt;[&lt;/code&gt;，其期待的匹配程度比第二个更加急迫，则第二个括号也只能靠边，让位于第三个括号，显然第二个括号的期待急迫性高于第一个括号，在接受了第四个括号之后，第三个括号的期待得到满足，消解之后，第二个括号的期待匹配变成最紧迫的任务了·····，以此类推。&lt;/p&gt;
&lt;p&gt;可见此处理过程与栈的特点相吻合，由此，在算法中设置一个栈，每读入一个括号，若是右括号则使至于栈顶的最紧迫的期待得以消解，若是不合法的情况（左括号），则作为一个新的更紧迫的期待压入栈中，自然使原来所有未消解的期待的紧迫性都降了一级。另外在算法开始和结束的时候，栈都应该是空的。&lt;/p&gt;
&lt;p&gt;算法实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 检测括号(本实例用数字代替括号)
 
 [ ]    --&amp;gt;    1 , 2
 ( )    --&amp;gt;    3 , 4
 
 */
void checkBracelet(void)
{
    // 创建栈
    STACK S;
    init(&amp;amp;S);
    
    // 用户输入括号
    int N;
    printf(&quot;请输入对应的括号(end结束):\n&quot;);
    scanf(&quot;%d&quot;,&amp;amp;N);
    
    if (isEmpty(&amp;amp;S)) {
        push(&amp;amp;S, N);
        printf(&quot;第一个括号输入\n&quot;);
        traverse(&amp;amp;S);       // 打印此时栈内容
    }
    
    while (!isEmpty(&amp;amp;S)) {

        // 用户输入括号
        int N;
        printf(&quot;请输入对应的括号(0结束):\n&quot;);
        scanf(&quot;%d&quot;,&amp;amp;N);
        
        if (N == 0) {
            break;  // 用户输入0直接退出
        }
        
        // 判断当前栈顶是否符合标准，
        if (S.pTop-&amp;gt;data == N) {
            printf(&quot;消除一对\n&quot;);
            pop(&amp;amp;S, NULL);
            traverse(&amp;amp;S);       // 打印此时栈内容
        }else
        {
            printf(&quot;未消除\n&quot;);
            push(&amp;amp;S, N);
            traverse(&amp;amp;S);       // 打印此时栈内容
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的实例我列举了两个，实际上还有很多。比如 &lt;strong&gt;行编辑程序&lt;/strong&gt;、&lt;strong&gt;迷宫求解&lt;/strong&gt;、&lt;strong&gt;表达式求值&lt;/strong&gt;等。这里我就先不做列举了。&lt;/p&gt;
&lt;h2 id=&quot;toc_12&quot;&gt;6. 小结&lt;/h2&gt;
&lt;p&gt;通过这里复习数据结构中栈的内容，感觉重新理解了很多计算机实现的底层知识，虽然不知道的更多，但是面对计算机心中又多了一层认知！&lt;/p&gt;
&lt;p&gt;文中代码地址：&lt;a href=&quot;https://github.com/xiaoyouPrince/DataStructure&quot;&gt;https://github.com/xiaoyouPrince/DataStructure&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 13:53:00 +0000</pubDate>
<dc:creator>xiaoyouPrince</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyouPrince/p/8082640.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——1. 考虑使用静态工厂方法替代构造方法 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8082510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8082510.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个类允许客户端获取其实例的传统方式是提供一个公共构造方法。 其实还有另一种技术应该成为每个程序员工具箱的一部分。 一个类可以提供一个公共静态工厂方法，它只是一个返回类实例的静态方法。 下面是一个&lt;code&gt;Boolean&lt;/code&gt;简单的例子（&lt;code&gt;boolean&lt;/code&gt;基本类型的包装类）。 此方法将&lt;code&gt;boolean&lt;/code&gt;基本类型转换为&lt;code&gt;Boolean&lt;/code&gt;对象引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，静态工厂方法与设计模式中的工厂方法模式不同[Gamma95]。本条目中描述的静态工厂方法在设计模式中没有直接的等价。&lt;/p&gt;
&lt;p&gt;类可以为其客户端提供静态工厂方法，而不是公共构造方法。提供静态工厂方法而不是公共构造方法有优点也有缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的一个优点是，不像构造方法，它们是有名字的。&lt;/strong&gt; 如果构造方法的参数本身并不描述被返回的对象，则具有精心选择名称的静态工厂更易于使用，并且生成的客户端代码更易于阅读。 例如，返回一个可能为素数的&lt;code&gt;BigInteger&lt;/code&gt;的构造方法&lt;code&gt;BigInteger(int，int，Random)&lt;/code&gt;可以更好地表示为名为&lt;code&gt;BigInteger.probablePrime&lt;/code&gt;的静态工厂方法。 （这个方法是在Java 1.4中添加的。）&lt;/p&gt;
&lt;p&gt;一个类只能有一个给定签名的构造方法。 程序员知道通过提供两个构造方法来解决这个限制，这两个构造方法的参数列表只有它们的参数类型的顺序不同。 这是一个非常糟糕的主意。 这样的API用户将永远不会记得哪个构造方法是哪个，最终会错误地调用。 阅读使用这些构造方法的代码的人只有在参考类文档的情况下才知道代码的作用。&lt;/p&gt;
&lt;p&gt;因为他们有名字，所以静态工厂方法不会受到上面讨论中的限制。在类中似乎需要具有相同签名的多个构造方法的情况下，用静态工厂方法替换构造方法，并仔细选择名称来突出它们的差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的第二个优点是，与构造方法不同，它们不需要每次调用时都创建一个新对象。&lt;/strong&gt;这允许不可变的类(条目17)使用预先构建的实例，或者在构造时缓存实例，并反复分配它们以避免创建不必要的重复对象。&lt;code&gt;boolean.valueof(boolean)&lt;/code&gt;方法说明了这种方法：它从不创建对象。这种技术类似于Flyweight模式[Gamma95]。如果经常请求等价对象，那么它可以极大地提高性能，特别是如果在创建它们非常昂贵的情况下。&lt;/p&gt;
&lt;p&gt;静态工厂方法从重复调用返回相同对象的能力允许类保持在任何时候存在的实例的严格控制。这样做的类被称为实例控制（ instance-controlled）。编写实例控制类的原因有很多。实例控制允许一个类来保证它是一个单例(3)项或不可实例化的(条目4)。同时,它允许一个不可变的值类(条目17)保证不存在两个相同的实例：当且仅当&lt;code&gt;a== b&lt;/code&gt;时&lt;code&gt;a.equals(b)&lt;/code&gt;。这是享元模式的基础[Gamma95]。&lt;code&gt;Enum&lt;/code&gt;类型(条目34)提供了这个保证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的第三个优点是，与构造方法不同，它们可以返回其返回类型的任何子类型的对象。&lt;/strong&gt; 这为你在选择返回对象的类时提供了很大的灵活性。&lt;/p&gt;
&lt;p&gt;这种灵活性的一个应用是API可以返回对象而不需要公开它的类。 以这种方式隐藏实现类会使 API非常紧凑I。 这种技术适用于基于接口的框架（条目20），其中接口为静态工厂方法提供自然返回类型。&lt;/p&gt;
&lt;p&gt;在Java 8之前，接口不能有静态方法。根据约定，一个名为&lt;code&gt;Type&lt;/code&gt;的接口的静态工厂方法被放入一个非实例化的伙伴类(companion class)(条目4)&lt;code&gt;Types&lt;/code&gt;类中。例如，Java集合框架有45个接口的实用工具实现，提供不可修改的集合、同步集合等等。几乎所有这些实现都是通过静态工厂方法在一个非实例类(&lt;code&gt;java .util. collections&lt;/code&gt;)中导出的。返回对象的类都是非公开的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Collections&lt;/code&gt;框架API的规模要比它之前输出的45个单独的公共类要小得多，每个类有个便利类的实现。不仅是API的大部分减少了，还包括概念上的权重：程序员必须掌握的概念的数量和难度，才能使用API。程序员知道返回的对象恰好有其接口指定的API，因此不需要为实现类读阅读额外的类文档。此外，使用这种静态工厂方法需要客户端通过接口而不是实现类来引用返回的对象，这通常是良好的实践(条目64)。&lt;/p&gt;
&lt;p&gt;从Java 8开始，接口不能包含静态方法的限制被取消了，所以通常没有理由为接口提供一个不可实例化的伴随类。 很多公开的静态成员应该放在这个接口本身。 但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的。 这是因为Java 8要求所有接口的静态成员都是公共的。 Java 9允许私有静态方法，但静态字段和静态成员类仍然需要公开。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂的第四个优点是返回对象的类可以根据输入参数的不同而不同。&lt;/strong&gt; 声明的返回类型的任何子类都是允许的。 返回对象的类也可以随每次发布而不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EnumSet&lt;/code&gt;类（条目 36）没有公共构造方法，只有静态工厂。 在OpenJDK实现中，它们根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有64个或更少的元素，静态工厂将返回一个&lt;code&gt;RegularEnumSet&lt;/code&gt;实例， 返回一个&lt;code&gt;long&lt;/code&gt;类型；如果枚举类型具有六十五个或更多元素，则工厂将返回一个&lt;code&gt;JumboEnumSet&lt;/code&gt;实例，返回一个&lt;code&gt;long&lt;/code&gt;类型的数组。&lt;/p&gt;
&lt;p&gt;这两个实现类的存在对于客户是不可见的。 如果&lt;code&gt;RegularEnumSet&lt;/code&gt;不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。 同样，未来的版本可能会添加&lt;code&gt;EnumSet&lt;/code&gt;的第三个或第四个实现，如果它证明有利于性能。 客户既不知道也不关心他们从工厂返回的对象的类别; 他们只关心它是&lt;code&gt;EnumSet&lt;/code&gt;的一些子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂的第5个优点是，在编写包含该方法的类时，返回的对象的类不需要存在。&lt;/strong&gt;这种灵活的静态工厂方法构成了服务提供者框架的基础，比如Java数据库连接API(JDBC)。服务提供者框架是提供者实现服务的系统，并且系统使得实现对客户端可用，从而将客户端从实现中分离出来。&lt;/p&gt;
&lt;p&gt;服务提供者框架中有三个基本组：服务接口，它表示实现；提供者注册API，提供者用来注册实现；以及服务访问API，客户端使用该API获取服务的实例。服务访问API允许客户指定选择实现的标准。在缺少这样的标准的情况下，API返回一个默认实现的实例，或者允许客户通过所有可用的实现进行遍历。服务访问API是灵活的静态工厂，它构成了服务提供者框架的基础。&lt;/p&gt;
&lt;p&gt;服务提供者框架的一个可选的第四个组件是一个服务提供者接口，它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，必须对实现进行反射实例化(条目65)。在JDBC的情况下，&lt;code&gt;Connection&lt;/code&gt;扮演服务接口的一部分，&lt;code&gt;DriverManager.registerDriver&lt;/code&gt;提供程序注册API、&lt;code&gt;DriverManager.getConnection&lt;/code&gt;是服务访问API，&lt;code&gt;Driver&lt;/code&gt;是服务提供者接口。&lt;/p&gt;
&lt;p&gt;服务提供者框架模式有许多变种。 例如，服务访问API可以向客户端返回比提供者提供的更丰富的服务接口。 这是桥接模式[Gamma95]。 依赖注入框架（条目5）可以被看作是强大的服务提供者。 从Java 6开始，平台包含一个通用的服务提供者框架&lt;code&gt;java.util.ServiceLoader&lt;/code&gt;，所以你不需要，一般也不应该自己编写（条目59）。 JDBC不使用&lt;code&gt;ServiceLoader&lt;/code&gt;，因为前者早于后者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只提供静态工厂方法的主要限制是，没有公共或受保护构造方法的类不能被子类化。&lt;/strong&gt;例如，在&lt;code&gt;Collections&lt;/code&gt;框架中不可能将任何方便实现类子类化。可以说，这可能是因祸得福，因为它鼓励程序员使用组合而不是继承(条目18)，并且是不可变类型(条目17)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态工厂方法的第二个缺点是，程序员很难找到它们。&lt;/strong&gt;它们不像构造方法那样在API文档中突出，因此很难找出如何实例化一个提供静态工厂方法而不是构造方法的类。Javadoc工具可能有一天会引起对静态工厂方法的注意。与此同时，可以通过将注意力吸引到类或接口文档中的静态工厂以及遵守通用的命名约定来减少这个问题。下面是一些静态工厂方法的常用名称。以下清单并非完整：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;from——A类型转换方法，它接受单个参数并返回此类型的相应实例，例如：&lt;code&gt;Date d = Date.from(instant)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;of——一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：&lt;code&gt;Set&amp;lt;Rank&amp;gt; faceCards = EnumSet.of(JACK, QUEEN, KING)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;valueOf——from和to更为详细的替代 方式，例如：&lt;code&gt;BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;instance或getinstance——返回一个由其参数(如果有的话)描述的实例，但不能说它具有相同的值，例如：&lt;code&gt;StackWalker luke = StackWalker.getInstance(options)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，例如：&lt;code&gt;Object newArray = Array.newInstance(classObject, arrayLen)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;getType——与getInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：&lt;code&gt;FileStore fs = Files.getFileStore(path)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;newType——与newInstance类似，但是如果在工厂方法中不同的类中使用。Type是工厂方法返回的对象类型，例如：&lt;code&gt;BufferedReader br = Files.newBufferedReader(path)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;type—— getType 和 newType简洁的替代方式，例如：&lt;code&gt;List&amp;lt;Complaint&amp;gt; litany = Collections.list(legacyLitany)&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。通常，静态工厂更可取，因此避免在没有考虑静态工厂的情况下提供公共构造方法。&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 13:12:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8082510.html</dc:identifier>
</item>
<item>
<title>C#中的Explicit和Implicit - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/8082405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/8082405.html</guid>
<description>&lt;p&gt;&lt;span&gt;今天在Review一个老项目的时候，看到一段奇怪的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;if (dto.Payment == null) continue;

var entity = entries.FirstOrDefault(e =&amp;gt; e.LedgerEntryID == dto.LedgerEntryID);

dto.Payment = entity?.Payment;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中dto.Payment是一个&lt;code&gt;PaymentDTO&lt;/code&gt;类的实例，entity?.Payment是一个&lt;code&gt;Payment&lt;/code&gt;类的实例，&lt;code&gt;PaymentDTO&lt;/code&gt;类和&lt;code&gt;Payment&lt;/code&gt;类没有子父关系，所以不存在子类和父类之间的隐式转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;奇怪的是Visual Studio的编译器没有提示任何编译错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开PaymentDTO类的定义之后，发现了以下方法签名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; PaymentDTO(Payment payment)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从方法签名上看，这就是重写PaymentDTO类型的操作符，但并不是我以前常用的+,-,*,/, ==等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询MSDN之后，才了解到implicit和explicit是一对转换操作符。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;Implicit&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Implicit关键字用于声明隐式的用户定义类型转换运算符。它可以实现2个不同类的隐式转换 ，提高代码的可读性。但是需要注意使用隐式转换操作符之后，在编译时会跳过异常检查，所以隐式转换运算符应当从不引发异常并且从不丢失信息，否则在运行时会出现一些意想不到的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如当前PaymentDTO和Payment的定义如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Payment

    {

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Amount { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }

 

&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentDTO

    {

         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AmountString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果需要将Payment隐式转换成PaymentDTO, 仅需声明PaymentDTO的隐式转换运算符&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentDTO

        {

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AmountString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

 

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&lt;span&gt; PaymentDTO(Payment payment)

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentDTO

                {

                    AmountString &lt;/span&gt;= payment.Amount.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

                };

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;调用时只需要直接赋值就可以&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program

        {

            &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)

            {

                PaymentDTO dto &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Payment { Amount = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };

 

                Console.WriteLine(dto.AmountString);

                Console.Read();

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Explicit&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Explicit关键字声明必须通过转换来调用的用户定义的类型转换运算符。不同于隐式转换，显式转换运算符必须通过转换的方式来调用，如果缺少了显式的转换，在编译时就会产生错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如现在我们将前面PaymentDTO类中定义的转换操作符从Implicit变为Explicit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentDTO

        {

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AmountString { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

 

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;explicit&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&lt;span&gt; PaymentDTO(Payment payment)

            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentDTO

                {

                    AmountString &lt;/span&gt;= payment.Amount.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

                };

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候由于Main方法中没有显式转换，所以编译器出错，提示Cannot implicitly convert type 'ExplicitImplicit.Payment' to 'ExplicitImplicit.PaymentDTO'. An explicit conversion exists (are you missing a cast?)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/65831/201712/65831-20171221210015021-1105353834.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想要编译器通过编译, 只需要做一个显示转换即可&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program

        {

            &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)

            {

                PaymentDTO dto &lt;/span&gt;= (PaymentDTO)&lt;span&gt;new&lt;/span&gt; Payment { Amount = &lt;span&gt;1&lt;/span&gt;&lt;span&gt; };

 

                Console.WriteLine(dto.AmountString);

                Console.Read();

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;Implicit提高了代码的可读性，但程序员需要自己保证转换不引发异常且不丢失信息&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Explicit可阻止编译器静默调用可能产生意外后果的转换操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;前者更易于使用，后者能向阅读代码的每个人清楚地指示您要转换类型&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 21 Dec 2017 12:57:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/8082405.html</dc:identifier>
</item>
<item>
<title>TCP的十一种状态与三次握手分析（有图） - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8082428.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8082428.html</guid>
<description>&lt;p&gt;我们知道TCP是面向连接的，我们只知道有连接断开，其实内部还有一些比较复杂的状态。去了解各个状态之间的切换有助于我们更加深入的了解TCP。下面我们就来分析各个状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如下图示（图源百度）图中显示出了10种状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221201248131-854463251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们假定断开时是client主动断开的。&lt;br/&gt;对于server来说状态有：closed -&amp;gt; listen -&amp;gt; syn_recv -&amp;gt; enstablished -&amp;gt; close_wait -&amp;gt; last_ack -&amp;gt; closed&lt;br/&gt;对于client来说状态有：closed -&amp;gt; syn_send -&amp;gt; enstablished -&amp;gt; fin_wait1 -&amp;gt; fin_wait2 -&amp;gt; time_wait&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.结合三次握手进行分析状态&lt;/span&gt;&lt;br/&gt;我们知道三次握手的这样： &lt;br/&gt;client 发送 syn x到server&lt;br/&gt;server 回复syn y和ack x+1&lt;br/&gt;client再回复 ack y+1&lt;br/&gt;下面分析上面三步与状态的关系：&lt;br/&gt;1）首先，刚创建的socket都是closed状态，server调用listen之后进入listen状态&lt;br/&gt;2）接着、客户端调用connnect。（TCP协议会完成三次握手，client发送第一个syn之后就进入syn_send状态。与此同时，server收到syn并回复syn和ack，server进入syn_recv状态）&lt;br/&gt;3）之后、client和server都进入了enstablisted状态。之后就可以互相发送数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221202912443-243227396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;关于TCP协议头中的确认号ack的理解可以参考：http://www.cnblogs.com/xcywt/p/8075623.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于Wireshark的理解可以参考：http://www.cnblogs.com/xcywt/p/8025113.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结合Wireshark抓包分析三次握手：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这里设置的过滤器，先清空当前捕获的包，在浏览器打开博客园。&lt;/p&gt;
&lt;p&gt;假设TCPa -&amp;gt; TCPb&lt;/p&gt;
&lt;p&gt;第一次：如下图，发送一个请求 syn，序号为0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221203715709-684208524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次：B回复，发送syn，ack为0+1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221203725521-1135477587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三次，A回复，ack = y + 1。其中y为之前B发送过来的序号，这里过来的序号的0，所以ack = 1；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221203736381-380871809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;3.结合断开时四次握手进行分析状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如图（图源百度，侵删）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/822287/201712/822287-20171221204951256-1675354780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们知道四次握手是这样的（假定是client先close 的）：&lt;br/&gt;client调用close。TCP协议会发送FIN x给server&lt;br/&gt;server收到FIN x之后，会回复ack x+1&lt;br/&gt;接着、server调用close，给客户端发送FIN y&lt;br/&gt;最后，客户端回复ack y+1&lt;br/&gt;分析与状态的关系：&lt;br/&gt;1）client调用close，发送了FINx。client进入&lt;span&gt;fin_wait1&lt;/span&gt;状态。server收到并回复ack，server进入&lt;span&gt;close_wait&lt;/span&gt;状态。然后client会收到ack，进入&lt;span&gt;fin_wait2&lt;/span&gt;状态&lt;br/&gt;2）server接着调用close，给client发送了fin，server则进入了了&lt;span&gt;last_ack&lt;/span&gt;状态。&lt;br/&gt;3）client收到FIN 之后，回复ack。client进入time_wait状态。server收到ack之后，进入&lt;span&gt;closed&lt;/span&gt;状态。&lt;br/&gt;（&lt;span&gt;client在保持了2个MSL&lt;/span&gt;之后就进入&lt;span&gt;closed&lt;/span&gt;状态）&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.注意事项&lt;/span&gt;&lt;br/&gt;1）&lt;span&gt;client进入time_wait状态之后，会保持在这个状态2MSL&lt;/span&gt;。目的是为了确保发送过去的ack可以被收到（因为后面已经没有数据可以发送了）。&lt;br/&gt;2）连接过程是状态的改变，促使状态的改变是用户的调用。所以切换状态不一定是用户的调用。（比如，server进入close_wait状态，纯粹是TCP协议做好的，用户并没有调用什么接口）&lt;br/&gt;3）关于退出时的分析，存在一个主动一个被动关系。上面分析的client主动，则client会出现&lt;span&gt;fin_wait1、fin_wait2、time_wai&lt;/span&gt;t状态。server会出现&lt;span&gt;close_wait、last_ack&lt;/span&gt;状态。&lt;br/&gt;如果是server主动断开的，则关系刚刚反过来了。server先进入&lt;span&gt;fin_wait1&lt;/span&gt;状态，然后是&lt;span&gt;fin_wait2&lt;/span&gt;状态。后面整个就反过来了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.关于closing状态的出现&lt;strong&gt;&lt;span&gt;（这里就是第十一种状态）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;通过上面的分析我们知道，client主动退出时，先给server发送了一个FIN。接着会收到一个ack确认这个FIN。&lt;br/&gt;&lt;span&gt;如果没收到ack，而是收到server发来的FIN y。那么这时候则进入closing状态。&lt;/span&gt;&lt;br/&gt;这种情况是怎么出现的呢：那就是双方几乎同时closer一个socket。这是双方都正在关闭socket连接。这种情况出现的几率很小&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.为什么连接需要三次握手，断开需要四次握手。&lt;/span&gt;&lt;br/&gt;首先我们知道，TCP协议是去全双工的。可以在发送的同时进行接收数据。&lt;br/&gt;假定是主机A和主机B进行通信，断开时是A主动断开的。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;1）三次握手：&lt;/span&gt;&lt;/strong&gt;第一次握手表明A可以发数据给B。但是无法保证B发给A的数据可以被收到。所以B也需要发送SYN给A，A对它进行回应，才保证了B也可以发数据给A。&lt;br/&gt;个人理解可以把三步拆分为四步理解：&lt;br/&gt;a）主机A给B发送SYN&lt;br/&gt;b）主机B回复ack --- 这时表明A可以发数据给B&lt;br/&gt;c）主机B发送SYN给A&lt;br/&gt;d）主机A回复ack --- 这时表明B也可以发送数据给A&lt;br/&gt;&lt;span&gt;只不过协议中，把中间两步放在一步进行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）四次握手，就像下面这样理解：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;a）主机A给B发送FIN，表示对B说“我要断开了”&lt;br/&gt;b）主机B回复ack进行确认，表示对A说“嗯，我知道了，你可以断开了”&lt;br/&gt;c）然后B发送FIN给A，表示对A说“A，我也要断开了”&lt;br/&gt;d）A回复ack进行确认，表示对B说：“嗯，知道了，你断开吧”&lt;br/&gt;前两步对A进行断开，后两步对B进行断开。&lt;br/&gt;&lt;span&gt;那么为什么不能把中间两步进行合并呢，因为无法保证被断开的一方的数据已经传送完毕了。&lt;/span&gt;&lt;br/&gt;就拿上面的例子来说，假如A断开了通知B，但是B还有数据没有发送完毕，如果立即断开（调用close发送FIN），就无法保证数据的可靠性。&lt;br/&gt;如果等数据发送完毕再将fin和ack一起发过去，n那么A就会长时间处于fin_wait1状态。这样就比较不好了。&lt;/p&gt;&lt;p&gt;实际情况中我们可能会在server忘记关闭客户端的socket。那么client就会一直处于fin_wait2状态，越来越多的fin_wait2状态会导致系统崩溃。所以我们需要在编程中要注意在什么情况下要关闭双方的socket。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7.其他知识&lt;/span&gt;&lt;br/&gt;什么时候会收到SIGPIPE这个信号呢？&lt;br/&gt;当server关闭一个连接之后，client接着发送数据，第一次发送会收到一个RST的响应。如果接着发送则系统会发出一个SIGPIPE信号给client。&lt;br/&gt;系统默认的处理是将应用程序退出。实际编程中，我们可以捕获这个信号，让应用程序不退出&lt;/p&gt;
&lt;p&gt; 如下（伪代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;signal.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; sig_recvpipe(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sig)
{
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    ......
    signal(SIGPIPE, sig_recvpipe);
    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 21 Dec 2017 12:55:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8082428.html</dc:identifier>
</item>
<item>
<title>【DevOps】团队敏捷开发系列--开山篇 - 千万之路刚开始</title>
<link>http://www.cnblogs.com/hyhnet/p/8082390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hyhnet/p/8082390.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;随着软件发布迭代的频率越来越高，传统的「瀑布型」（开发—测试—发布）模式已经不能满足快速交付的需求。2009 年左右 DevOps 应运而生，开发运维一体化，通过自动化工具与流程让整个软件开发构建、测试、发布更加快捷、频繁、高效和可靠。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-6958c29683b13b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本系列教程目录&quot;&gt;本系列教程目录&lt;/h2&gt;
&lt;p&gt;本系列将详细讲解Devops落地细节。将构建整个持续集成与交付的一整套体系与流程。对于未来要开篇的系列博文列表如下：&lt;/p&gt;
&lt;p&gt;【DevOps】团队敏捷开发系列(一)--开山篇&lt;br/&gt;【DevOps】团队敏捷开发系列(二)--版本控制之道Git&lt;br/&gt;【DevOps】团队敏捷开发系列(三)--代码管理之道Gitlab&lt;br/&gt;【DevOps】团队敏捷开发系列(四)--前后端分离契机Swagger&lt;br/&gt;【DevOps】团队敏捷开发系列(五)--代码编译MAVEN&lt;br/&gt;【DevOps】团队敏捷开发系列(六)--自动化CI工具Jenkins&lt;br/&gt;【DevOps】团队敏捷开发系列(七)--自动化流程编排&lt;br/&gt;【DevOps】团队敏捷开发系列(八)--自动化单元测试Junit&lt;br/&gt;【DevOps】团队敏捷开发系列(九)--自动化性能压测Jmater&lt;br/&gt;【DevOps】团队敏捷开发系列(十)--持续部署流程编排&lt;br/&gt;【DevOps】团队敏捷开发系列(番外篇)--Linux常用命令&lt;/p&gt;
&lt;h2 id=&quot;相关概念解释&quot;&gt;相关概念解释&lt;/h2&gt;
&lt;h3 id=&quot;devops-概念&quot;&gt;DevOps 概念&lt;/h3&gt;
&lt;p&gt;Ops&quot;是一个总括术语，泛指系统工程师、系统管理员、操作人员，发布工程师、DBA、网络工程师、安全专家和各种其他分支和头衔。&quot;Dev&quot;是开发人员的简称，但真正在实践中意味着更广泛的&quot;参与开发的产品&quot;的所有人，可包括产品,质量保证,和其他种类的学科。&lt;/p&gt;
&lt;h3 id=&quot;devops-发展&quot;&gt;DevOps 发展&lt;/h3&gt;
&lt;p&gt;DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作。 从2009年起，相关的工作组、专业组织和博客快速涌现。&lt;/p&gt;
&lt;h3 id=&quot;自动化概念&quot;&gt;自动化概念&lt;/h3&gt;
&lt;p&gt;自动化（Automation）是指机器设备、系统或过程（生产、管理过程）在没有人或较少人的直接参与下，按照人的要求，经过自动检测、信息处理、分析判断、操纵控制，实现预期的目标的过程。自动化技术广泛用于工业、农业、军事、科学研究、交通运输、商业、医疗、服务和家庭等方面。采用自动化技术不仅可以把人从繁重的体力劳动、部分脑力劳动以及恶劣、危险的工作环境中解放出来，而且能扩展人的器官功能，极大地提高劳动生产率，增强人类认识世界和改造世界的能力。因此，自动化是工业、农业、国防和科学技术现代化的重要条件和显著标志。&lt;/p&gt;
&lt;h3 id=&quot;devops自动化&quot;&gt;DevOps自动化&lt;/h3&gt;
&lt;p&gt;全面自动化 —— 部署、 升级、 扩展、 维护、 数据、 测试、 监测、 安全和策略管理。在自动化方面投入巨资，目标是100%的自动化，不考虑低于90%的可能性。但是，全面自动化也可能会引起自动化泛滥。集中审查和调整可以控制Chef或Puppet脚本库的无序增长。&lt;br/&gt;DevOps战略必须获取本组织自顶向下的全面支持。整个行政领导团队 ——不只是首席信息官 ——应知道它为什么重要和怎样使它取得成功。&lt;/p&gt;
&lt;h2 id=&quot;为什么devops&quot;&gt;为什么DevOps&lt;/h2&gt;
&lt;p&gt;为什么我们采用DevOps,首先来看一下传统的开发运维模式。&lt;/p&gt;
&lt;h3 id=&quot;传统开发模式&quot;&gt;传统开发模式&lt;/h3&gt;
&lt;p&gt;首先，开发人员开发完毕，并进行简单自测，和 手动 功能测试。&lt;br/&gt;其次，开发人员利用IDE 手动 打包。&lt;br/&gt;然后，将构建后的文件 手动 复制到公网服务器指定目录。&lt;br/&gt;最后，启动程序并进行手工测试。&lt;br/&gt;很明显，在这个过程中，有太多重复性的东西，会严重影响团队效率。&lt;/p&gt;
&lt;h3 id=&quot;自动化方案&quot;&gt;自动化方案&lt;/h3&gt;
&lt;p&gt;我们可以简单的来将我们的系统优化，最终形成强大的自动化敏捷体系。&lt;/p&gt;
&lt;h4 id=&quot;自动化单元测试&quot;&gt;自动化单元测试&lt;/h4&gt;
&lt;p&gt;我们可以通过一些自动化平台例如jenkins 进行自动化单元测试的集成。可以很高效的对整个开发进行系统的单元测试，简化测试流程，提升测试效率&lt;/p&gt;
&lt;h4 id=&quot;自动化打包构建&quot;&gt;自动化打包构建&lt;/h4&gt;
&lt;p&gt;通过一些列的代码与版本控制管理工具，例如Git与Gitlab可以非常有效的管理代码、版本、分支、标签等等。当然不仅于此，还有很多比较优秀的工具供我们使用。但是目前市场最流行的当属Git与Gitlab体系。&lt;/p&gt;
&lt;h4 id=&quot;自动化发布&quot;&gt;自动化发布&lt;/h4&gt;
&lt;p&gt;针对于后端服务用Java开发的应用程序，我们大可以使用MAVEN或者Gradle进行统一的依赖管理及代码编译打包控制。可以通过一些列Wiki进行配置触发器，集成到jenkins等工具上，然后进行自动化的远程节点打包。当然可以在jenkins建立多个节点去持续多点出发集成。&lt;/p&gt;
&lt;h4 id=&quot;自动化部署&quot;&gt;自动化部署&lt;/h4&gt;
&lt;p&gt;通过强大的shell命令，让我们可以在每个服务器、每一个环境当中，自由穿梭。对于自动化部署，需要按照实际需求，编写不同的shell脚本，然后将相关流程进行配置，结合jenkins等工具，可以快速实现每一个环节的发布。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-f4ebcb0dcb53af35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;devops团队需要做什么&quot;&gt;DevOps团队需要做什么&lt;/h2&gt;
&lt;p&gt;DevOps团队执行各种任务, 如:&lt;br/&gt;1. 新虚拟服务器的配置&lt;br/&gt;2. 配置网络设备&lt;br/&gt;3. 应用程序部署&lt;br/&gt;4. 收集和聚合的日志&lt;br/&gt;5. 性能监视服务&lt;br/&gt;6. 报警和自动修复的问题&lt;br/&gt;7. 服务器和服务可用性监控&lt;/p&gt;
&lt;h2 id=&quot;devops团队工具&quot;&gt;DevOps团队工具&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Docker&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;虚拟化容器技术，快速构建独立隔离服务&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Jenkins&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自动化平台，可以配置自动化测试与持续部署&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;right&quot;&gt;New Relic&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;应用性能监测&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Ansible&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;自动化(配置管理工具)平台，持续集成与编排&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;Kubernetes&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;开源的docker编排工具，可以发布与回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;right&quot;&gt;JMeter&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于Java的压力测试工具。用于对软件做压力测试&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;还有很多工具可以使用，这个具体我们后续慢慢讲来。&lt;/p&gt;
&lt;h2 id=&quot;番外篇&quot;&gt;番外篇&lt;/h2&gt;
&lt;p&gt;除了一整套DevOps的体系，我们会在整个系统当中，穿插讲解Docker容器的使用。对于我们很多时候遇到的依赖或者安装流程复杂的问题，都可以容器的方式快速解决，并且可以快速启动或销毁多个服务。&lt;/p&gt;
&lt;p&gt;未尽之处将会在系列博文中详细说道。本文只是对系列博文的概要说明，本文也参考了互联网很多资料整理所得。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;源码&lt;/h2&gt;
&lt;p&gt;本文出处：&lt;a href=&quot;http://www.hanyahong.com/&quot; class=&quot;uri&quot;&gt;http://www.hanyahong.com/&lt;/a&gt;&lt;br/&gt;（欢迎转发、请注明出处！）&lt;/p&gt;
</description>
<pubDate>Thu, 21 Dec 2017 12:45:00 +0000</pubDate>
<dc:creator>千万之路刚开始</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hyhnet/p/8082390.html</dc:identifier>
</item>
<item>
<title>零基础开发--歌曲管理系统 - 张健文</title>
<link>http://www.cnblogs.com/F6F6F6/p/8082259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/F6F6F6/p/8082259.html</guid>
<description>&lt;p&gt;   本文主要是从头开始讲如何创建一个项目，本文以创建一个歌曲管理系统为例。&lt;/p&gt;

&lt;p&gt;  首先创建数据库：MyMusic（我的音乐）&lt;/p&gt;
&lt;p&gt;  其中添加表：SongInformation（歌曲信息表）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;DB_ID&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MyMusic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; MyMusic
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt; MyMusic  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建MyMusic（我的音乐）数据库&lt;/span&gt;
&lt;span&gt;on&lt;/span&gt;&lt;span&gt;
(
name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;MyMusic,
filename&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\CS架构\学习\窗体\DB\MyMusic.mdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;打开数据库&lt;/span&gt;
&lt;span&gt;use&lt;/span&gt;&lt;span&gt; MyMusic
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;创建表歌曲&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;OBJECT_ID&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SongInformation&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; SongInformation &lt;span&gt;--&lt;/span&gt;&lt;span&gt;歌曲信息表&lt;/span&gt;
&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; SongInformation 
(
  Songid &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; &lt;span&gt;identity&lt;/span&gt;(&lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;),  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;
  SongName &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;,   &lt;span&gt;--&lt;/span&gt;&lt;span&gt;歌名&lt;/span&gt;
  Singer &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;,  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;演唱者&lt;/span&gt;
  Album &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;)  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;专辑&lt;/span&gt;
&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;查询表SongInformation&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; SongInformation
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;添加测试数据&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; SongInformation &lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;演员&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;薛之谦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;绅士&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;尽头&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;赵方倩&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;音阙诗听&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;当你&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;王心凌&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;遇上爱&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;七里香&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;周杰伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;七里香&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;微微一笑很倾城&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;杨洋&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;微微一笑很倾城&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;岁月神偷&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;金玟岐&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;金玟岐作品集&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;union&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;带你去旅行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;校长&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;带你去旅行&lt;/span&gt;&lt;span&gt;'&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建主窗口：FrmMain(歌曲信息管理系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1283290/201712/1283290-20171221193501818-1542984986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建窗口：歌曲修改（增加）窗口FrmModifySong&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1283290/201712/1283290-20171221193515381-2118990364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备工作 --建立帮助类：DBHelper&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.SqlClient;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 窗口
{
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;   &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DBHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ConStr = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=.;uid=sa;pwd=sa;database=MyMusic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; SqlConnection con = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 创建连接对象
        &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SqlConnection GetConnection()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (con == &lt;span&gt;null&lt;/span&gt; || con.ConnectionString == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                con &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(ConStr);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; con;
        } 
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; 打开连接
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OpenConnection()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (con.State ==&lt;span&gt; ConnectionState.Closed)
            {
                con.Open();
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; 关闭连接
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CloseConnection()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (con.State ==&lt;span&gt; ConnectionState.Open)
            {
                con.Close();
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; 查询多行多列的值
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SqlDataReader ExecuteReader(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; sql,
            &lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt; SqlParameter [] para)
        {
            SqlConnection con &lt;/span&gt;=&lt;span&gt; GetConnection();
            OpenConnection();
            SqlCommand com &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlCommand(sql, con);
         
            com.Parameters.AddRange(para);
            SqlDataReader dr &lt;/span&gt;=&lt;span&gt; com.ExecuteReader();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dr;
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; 动作查询
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ExecuteNonQuery(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; sql,
           &lt;/span&gt;&lt;span&gt;params&lt;/span&gt;&lt;span&gt; SqlParameter[] para)
        {
            SqlConnection con &lt;/span&gt;=&lt;span&gt; GetConnection();
            OpenConnection();
            SqlCommand com &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlCommand(sql, con);       
            com.Parameters.AddRange(para);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; com.ExecuteNonQuery();
            CloseConnection();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n;
        }

       
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立实体类：Song（对应数据库中的表SongInformation）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 窗口
{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Song
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Songid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SongName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Singer { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Album { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后实现窗体加载功能（将数据加载到DataGirdView中）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d882ca13-8a94-4ec5-a152-078406f8220e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d882ca13-8a94-4ec5-a152-078406f8220e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d882ca13-8a94-4ec5-a152-078406f8220e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;#region&lt;/span&gt; 将后台信息加载到网格
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LoadDOV(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; sql)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sql == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                sql &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select*from SongInformation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            SqlConnection con &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlConnection(DBHelper.ConStr);
            SqlDataAdapter sda &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlDataAdapter(sql, con);
            DataTable dt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
            sda.Fill(dt);
            dgvSong.DataSource &lt;/span&gt;=&lt;span&gt; dt;
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 窗体加载事件方法
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FrmMain_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            LoadDOV(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;实现查询功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#region&lt;/span&gt; 查询事件方法
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnQuery_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select*from SongInformation where 1=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txtSongName.Text != &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                sql &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and SongName like '%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + txtSongName.Text + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txtSinger.Text != &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                sql &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and Singer like '%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + txtSinger.Text + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            LoadDOV(sql);
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  最后！也是难点！传参，将DataGridView中的数据传到FrmModifySong窗口中对应的Textbox中&lt;/p&gt;
&lt;p&gt; 首先创建实体操作类SongManage&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_213ab878-f2c0-4314-afcc-ae1bfef6b7f7&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_213ab878-f2c0-4314-afcc-ae1bfef6b7f7&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_213ab878-f2c0-4314-afcc-ae1bfef6b7f7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.SqlClient;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 窗口
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SongManage
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传参&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Song&amp;gt;&lt;span&gt; SelectCarsAll()
        {
            List&lt;/span&gt;&amp;lt;Song&amp;gt; song = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Song&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select*from SongInformation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            SqlDataReader dr &lt;/span&gt;=&lt;span&gt; DBHelper.ExecuteReader(sql);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (dr.Read())
            {
                Song songs &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Song();
                songs.Songid &lt;/span&gt;= Convert.ToInt32(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Songid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                songs.SongName &lt;/span&gt;= Convert.ToString(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SongName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                songs.Singer &lt;/span&gt;= Convert.ToString(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Singer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                songs.Album &lt;/span&gt;= Convert.ToString(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Album&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                song.Add(songs);
            }
            dr.Close();
            DBHelper.CloseConnection();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; song;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Song SelectCarsByCarId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Songid)
        {
            Song song &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from SongInformation where Songid=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Songid;
            SqlDataReader dr &lt;/span&gt;=&lt;span&gt; DBHelper.ExecuteReader(sql);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (dr.Read())
            {
                song &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Song();
                song.Songid &lt;/span&gt;= Convert.ToInt32(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Songid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                song.SongName &lt;/span&gt;= Convert.ToString(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SongName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                song.Singer &lt;/span&gt;= Convert.ToString(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Singer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                song.Album &lt;/span&gt;= Convert.ToString(dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Album&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

            }
            dr.Close();
            DBHelper.CloseConnection();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; song;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; InsertSong(Song song)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insert  SongInformation (SongName,Singer,Album) values('{0}','{1}','{2}')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, song.SongName, song.Singer, song.Album);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DBHelper.ExecuteNonQuery(sql);
            
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; UpdateSong(Song song)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update SongInformation set SongName=@SongName,Singer=@Singer,Album=@Album where Songid=@Songid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DBHelper.ExecuteNonQuery(sql,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlParameter[] 
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SqlParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@SongName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,song.SongName),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SqlParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Singer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,song.Singer),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SqlParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@Album&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,song.Album),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; SqlParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@SongId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,song.Songid),
            });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;然后回到主窗口FrmMain中创建修改、添加的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;#region&lt;/span&gt; 修改
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 修改事件方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TsmModify_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dgvSong.SelectedRows.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Songid = (&lt;span&gt;int&lt;/span&gt;)dgvSong.SelectedRows[&lt;span&gt;0&lt;/span&gt;].Cells[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Songid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].Value;
                FrmModifySong frm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrmModifySong();
                frm.Songid &lt;/span&gt;=&lt;span&gt; Songid;
                frm.ShowDialog();
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

   &lt;span&gt;#region&lt;/span&gt; 添加事件方法
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tsmAdd_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            FrmModifySong frm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FrmModifySong();          
            frm.Show();
        } 
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后回到歌曲添加（删除）窗口FrmModifySong实现保存功能和取消功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a54596a7-a461-4814-80e5-89609104415c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a54596a7-a461-4814-80e5-89609104415c&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a54596a7-a461-4814-80e5-89609104415c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 窗口
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FrmModifySong : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Songid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FrmModifySong()
        {
            InitializeComponent();
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 取消按钮事件方法
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnCancel_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Close();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 保存按钮事件方法
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnSave_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            Song song &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Song
            {    
                SongName&lt;/span&gt;=&lt;span&gt;txtSongName.Text,
                Singer&lt;/span&gt;=&lt;span&gt;txtSinger.Text,
                Album&lt;/span&gt;=&lt;span&gt;txtAlbum.Text            
            };
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                n &lt;/span&gt;=&lt;span&gt; SongManage.InsertSong(song);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                song.Songid &lt;/span&gt;=&lt;span&gt; Songid;
                n &lt;/span&gt;=&lt;span&gt; SongManage.UpdateSong(song);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                MessageBox.Show(type &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                                                   
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                MessageBox.Show(type &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FrmModifySong_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Songid != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                type &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
               txtSongid.ReadOnly &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                Song song &lt;/span&gt;=&lt;span&gt; SongManage.SelectCarsByCarId(Songid);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (song != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    txtSongid.Text &lt;/span&gt;=&lt;span&gt; song.Songid.ToString();
                    txtSongName.Text &lt;/span&gt;=&lt;span&gt; song.SongName;
                    txtSinger.Text &lt;/span&gt;=&lt;span&gt; song.Singer;
                    txtAlbum.Text &lt;/span&gt;=&lt;span&gt; song.Album;
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;修改歌曲信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                txtSongid.ReadOnly &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;添加歌曲信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后实现删除功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;#region&lt;/span&gt; 删除事件方法
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除事件方法&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TsmDelete_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Songid = (&lt;span&gt;int&lt;/span&gt;)dgvSong.SelectedRows[&lt;span&gt;0&lt;/span&gt;].Cells[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].Value;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete SongInformation  where SongId=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Songid;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; DBHelper.ExecuteNonQuery(sql);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                LoadDOV(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        } 
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OK，一个简单的项目就这么完成了！&lt;/p&gt;

</description>
<pubDate>Thu, 21 Dec 2017 12:06:00 +0000</pubDate>
<dc:creator>张健文</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/F6F6F6/p/8082259.html</dc:identifier>
</item>
</channel>
</rss>