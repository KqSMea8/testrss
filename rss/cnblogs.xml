<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ReentrantLock实现原理 - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/9665718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/9665718.html</guid>
<description>&lt;h2 id=&quot;ReentrantLock实现原理-1.1synchronized的局限性&quot;&gt;1.1 synchronized的局限性&lt;/h2&gt;
&lt;p&gt;　　synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁有JVM实现，用户不需要显式的释放锁，非常方便，然而synchronized也有一定的局限性，例如：&lt;/p&gt;
&lt;p&gt;　　1、当线程尝试获取锁的时候，如果获取不到锁就会一直阻塞。&lt;/p&gt;
&lt;p&gt;　　2、如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁会一直等待。&lt;/p&gt;
&lt;p&gt;　　JDK1.5之后发布的concurrent包，提供了Lock接口，用来提供更多扩展的加锁功能。Lock弥补了synchronized的局限性，提供了更加细粒度的加锁功能。&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-1.2Lock简介&quot;&gt;1.2 Lock简介&lt;/h2&gt;
&lt;p&gt;Lock的API如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917225749197-1828692794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中最常用的就是lock和unlock操作了。因为使用lock时，需要手动的释放锁，所以需要使用try..catch来包住业务代码，并且在final中释放锁。典型使用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
    lock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        doSomeThing();
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignored&lt;/span&gt;
    }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        lock.unlock();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　AbstarctQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建的，例如ReentrantLock，Semphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时大量的细节问题。&lt;/p&gt;
&lt;p&gt;　　AQS使用一个FIFO队列表示排队等待锁的线程，队列头结点称作“哨兵节点”或者“哑结点”，它不与任何线程关联。其他的节点与等待线程关联，每个阶段维护一个等待状态waitStatus。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917230446754-176956049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　AQS中还有一个表示状态的字段state，例如ReentrantLock用它来表示线程重入锁的次数，Semphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。&lt;/p&gt;
&lt;p&gt;　　AbstractQueuedSynchronized继承了AbstractOwnableSynchronized，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。&lt;/p&gt;
&lt;p&gt;　　理解AQS可以帮助我们更好的理解JUC包中的同步容器。&lt;/p&gt;

&lt;h2 id=&quot;ReentrantLock实现原理-3.1基础知识&quot; class=&quot;diff-block-target&quot;&gt;3.1 基础知识&lt;/h2&gt;
&lt;p&gt;　　ReentrantLock是Lock的默认实现之一。那么Lock()和unlock(）是怎样实现的呢？首先我们要弄清楚几个概念&lt;/p&gt;
&lt;p&gt;　　1、可重入锁。可重入锁是指一个线程可以多次获取同一把锁。ReentrantLock和Synchronized都是可重入锁。&lt;/p&gt;
&lt;p&gt;　　2、可中断锁。可中断锁是指线程尝试获取锁的过程是否可以响应终端。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。&lt;/p&gt;
&lt;p&gt;　　3、公平锁与非公平锁。公平所指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。&lt;/p&gt;
&lt;p&gt;　　4、CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-3.2内部结构&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.2 内部结构&lt;/h2&gt;
&lt;p&gt;　　ReentrantLock提供了两个构造器，分别是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReentrantLock() {
    sync &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync();
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ReentrantLock(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; fair) {
    sync &lt;/span&gt;= fair ? &lt;span&gt;new&lt;/span&gt; FairSync() : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　默认构造器初始化为NonfairSync对象，即非公平锁，而带参数的构造器可以指定使用公平锁和非公平锁。由lock()和unlock的源码可以看到，它们只是分别调用了sync对象的lock()和release(1)方法。&lt;/p&gt;
&lt;p&gt;　　Sync是ReentrantLock的内部类，它的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917231512390-658385817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Sync扩展了AbstractQueuedSynchronizer。&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-3.3NonfairSync&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.3 NonfairSync&lt;/h2&gt;
&lt;p&gt;　　我们从源代码出发，分析非公平锁获取锁和释放锁的过程。 &lt;/p&gt;
&lt;h3 id=&quot;ReentrantLock实现原理-3.3.1lock()&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.3.1 lock() &lt;/h3&gt;
&lt;p&gt;　　lock()源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;))
        setExclusiveOwnerThread(Thread.currentThread());
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        acquire(&lt;/span&gt;1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先用一个CAS操作，判断state是否是0（表示当前锁未被占用），如果是0则把它置为1，并且设置当前线程为该锁的独占线程，表示获取锁成功。当多个线程同时尝试占用同一个锁时，CAS操作只能保证一个线程操作成功，剩下的只能乖乖的去排队啦。&lt;/p&gt;
&lt;p&gt;　　“非公平”即体现在这里，如果占用锁的线程刚释放锁，state置为0，而排队等待锁的线程还未唤醒时，新来的线程就直接抢占了该锁，那么就“插队”了。&lt;/p&gt;
&lt;p&gt;　　若当前有三个线程去竞争锁，假设线程A的CAS操作成功了，拿到了锁开开心心的返回了，那么线程B和C则设置state失败，走到了else里面。我们往下看acquire。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;acquire(arg)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1. 第一步。尝试去获取锁。如果尝试获取锁成功，方法直接返回。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tryAcquire(arg)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; nonfairTryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Thread current =&lt;span&gt; Thread.currentThread();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取state变量值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有线程占用锁&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (compareAndSetState(0&lt;span&gt;, acquires)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;占用锁成功,设置独占线程为当前线程&lt;/span&gt;
&lt;span&gt;            setExclusiveOwnerThread(current);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程已经占用该锁&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; nextc = c +&lt;span&gt; acquires;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新state值为新的重入次数&lt;/span&gt;
&lt;span&gt;        setState(nextc);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　非公平锁tryAcquire的流程是：检查state字段，若为0，表示锁未被占用，那么尝试占用，若不为0，检查当前锁是否被自己占用，若被自己占用，则更新state字段，表示重入锁的次数。如果以上两点都没有成功，则获取锁失败，返回false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;/strong&gt;第二步，入队。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;由于上文中提到线程A已经占用了锁，所以B和C执行tryAcquire失败，并且入等待队列。如果线程A拿着锁死死不放，那么B和C就会被挂起。&lt;/p&gt;
&lt;p class=&quot;diff-block-target diff-block-context&quot;&gt;先看下入队的过程。&lt;/p&gt;
&lt;p class=&quot;diff-block-target diff-block-context&quot;&gt;先看addWaiter(Node.EXCLUSIVE)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 将新节点和当前线程关联并且入队列
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mode 独占/共享
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 新节点
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化节点,设置关联线程和模式(独占 or 共享)&lt;/span&gt;
    Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取尾节点引用&lt;/span&gt;
    Node pred =&lt;span&gt; tail;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾节点不为空,说明队列已经初始化过&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        node.prev &lt;/span&gt;=&lt;span&gt; pred;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置新节点为尾节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
            pred.next &lt;/span&gt;=&lt;span&gt; node;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾节点为空,说明队列还未初始化,需要初始化head节点并入队新节点&lt;/span&gt;
&lt;span&gt;    enq(node);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B、C线程同时尝试入队列，由于队列尚未初始化，tail==null，故至少会有一个线程会走到enq(node)。我们假设同时走到了enq(node)里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 初始化队列并且入队新节点
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始自旋&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        Node t &lt;/span&gt;=&lt;span&gt; tail;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must initialize
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果tail为空,则新建一个head节点,并且tail指向head&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node()))
                tail &lt;/span&gt;=&lt;span&gt; head;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            node.prev &lt;/span&gt;=&lt;span&gt; t;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tail不为空,将新节点入队&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
                t.next &lt;/span&gt;=&lt;span&gt; node;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里体现了经典的自旋+CAS组合来实现非阻塞的原子操作。由于compareAndSetHead的实现使用了unsafe类提供的CAS操作，所以只有一个线程会创建head节点成功。假设线程B成功，之后B、C开始第二轮循环，此时tail已经不为空，两个线程都走到else里面。假设B线程compareAndSetTail成功，那么B就可以返回了，C由于入队失败还需要第三轮循环。最终所有线程都可以成功入队。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917232605000-1883174482.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3. &lt;strong&gt;第三步，挂起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;B和C相继执行acquireQueued(final Node node, int arg)。这个方法让已经入队的线程尝试获取锁，若失败则会被挂起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 已经入队的线程尝试获取锁
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记是否成功获取锁&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记线程是否被中断过&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node p = node.predecessor(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取前驱节点
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前驱是head,即该结点已成老二，那么便有资格去尝试获取锁&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
                setHead(node); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取成功,将当前节点设置为head节点&lt;/span&gt;
                p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原head节点出队,在某个时间点被GC回收&lt;/span&gt;
                failed = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取成功&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; interrupted; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回是否被中断过&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断获取失败后是否可以挂起,若可以则挂起&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程若被中断,设置interrupted为true&lt;/span&gt;
                interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
            cancelAcquire(node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　code里的注释已经很清晰的说明了acquireQueued的执行流程。假设B和C在竞争锁的过程中A一直持有锁，那么它们的tryAcquire操作都会失败，因此会走到第2个if语句中。我们再看下shouldParkAfterFailedAcquire和parkAndCheckInterrupt都做了哪些事吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判断当前线程获取锁失败之后是否需要挂起.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点的状态&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; pred.waitStatus;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱节点状态为signal,返回true&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱节点状态为CANCELLED&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从队尾向前寻找第一个状态不为CANCELLED的节点&lt;/span&gt;
        &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            node.prev &lt;/span&gt;= pred =&lt;span&gt; pred.prev;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
        pred.next &lt;/span&gt;=&lt;span&gt; node;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将前驱节点的状态设置为SIGNAL&lt;/span&gt;
&lt;span&gt;        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}
  
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 挂起当前线程,返回线程中断状态并重置
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; parkAndCheckInterrupt() {
    LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　线程入队后能够挂起的前提是，它的前驱节点的状态为SIGNAL，它的含义是“Hi，前面的兄弟，如果你获取锁并且出队后，记得把我唤醒！”。所以shouldParkAfterFailedAcquire会先判断当前节点的前驱是否状态符合要求，若符合则返回true，然后调用parkAndCheckInterrupt，将自己挂起。如果不符合，再看前驱节点是否&amp;gt;0(CANCELLED)，若是那么向前遍历直到找到第一个符合要求的前驱，若不是则将前驱节点的状态设置为SIGNAL。&lt;/p&gt;
&lt;p&gt;　　 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心挂起，需要去找个安心的挂起点，同时可以再尝试下看有没有机会去尝试竞争锁。&lt;/p&gt;
&lt;p&gt;　　最终队列可能会如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917232950037-78637699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　线程B和C都已经入队，并且都被挂起。当线程A释放锁的时候，就会去唤醒线程B去获取锁啦。&lt;/p&gt;
&lt;h3 id=&quot;ReentrantLock实现原理-3.3.2unlock()&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.3.2 unlock()&lt;/h3&gt;
&lt;p&gt;　　unlock相对于lock就简单很多。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
    sync.release(&lt;/span&gt;1&lt;span&gt;);
}
  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryRelease(arg)) {
        Node h &lt;/span&gt;=&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
            unparkSuccessor(h);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果理解了加锁的过程，那么解锁看起来就容易多了。流程大致为先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，如果释放失败那么返回false表示解锁失败。这里我们也发现了，每次都只唤起头结点的下一个节点关联的线程。&lt;/p&gt;
&lt;p&gt;　　最后我们再看下tryRelease的执行过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 释放当前线程占用的锁
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; releases
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否释放成功
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算释放后state值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c = getState() -&lt;span&gt; releases;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是当前线程占用锁,那么抛出异常&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Thread.currentThread() !=&lt;span&gt; getExclusiveOwnerThread())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; free = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁被重入次数为0,表示释放成功&lt;/span&gt;
        free = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空独占线程&lt;/span&gt;
        setExclusiveOwnerThread(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新state值&lt;/span&gt;
&lt;span&gt;    setState(c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里入参为1。tryRelease的过程为：当前释放锁的线程若不持有锁，则抛出异常。若持有锁，计算释放后的state值是否为0，若为0表示锁已经被成功释放，并且则清空独占线程，最后更新state值，返回free。 &lt;/p&gt;
&lt;h3 id=&quot;ReentrantLock实现原理-3.3.3小结&quot;&gt;3.3.3 小结&lt;/h3&gt;
&lt;p&gt;    用一张流程图总结一下非公平锁的获取锁的过程。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917233520814-2039195145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-3.4FairSync&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.4 FairSync&lt;/h2&gt;
&lt;p&gt;    公平锁和非公平锁不同之处在于，公平锁在获取锁的时候，不会先去检查state状态，而是直接执行aqcuire(1)，这里不再赘述。  &lt;/p&gt;

&lt;p&gt;　　在ReetrantLock的tryLock(long timeout, TimeUnit unit) 提供了超时获取锁的功能。它的语义是在指定的时间内如果获取到锁就返回true，获取不到则返回false。这种机制避免了线程无限期的等待锁释放。那么超时的功能是怎么实现的呢？我们还是用非公平锁为例来一探究竟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquireNanos(1&lt;span&gt;, unit.toNanos(timeout));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是调用了内部类里面的方法。我们继续向前探究：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquireNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanosTimeout)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tryAcquire(arg) ||&lt;span&gt;
        doAcquireNanos(arg, nanosTimeout);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的语义是：如果线程被中断了，那么直接抛出InterruptedException。如果未中断，先尝试获取锁，获取成功就直接返回，获取失败则进入doAcquireNanos。tryAcquire我们已经看过，这里重点看一下doAcquireNanos做了什么。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 在有限的时间内去竞争锁
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否获取成功
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; doAcquireNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanosTimeout)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 起始时间&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; lastTime =&lt;span&gt; System.nanoTime();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程入队&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.EXCLUSIVE);
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 又是自旋!&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取前驱节点&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果前驱是头节点并且占用锁成功,则将当前节点变成头结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
                setHead(node);
                p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果已经超时,返回false&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (nanosTimeout &amp;lt;= 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时时间未到,且需要挂起&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    nanosTimeout &lt;/span&gt;&amp;gt;&lt;span&gt; spinForTimeoutThreshold)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞当前线程直到超时时间到期&lt;/span&gt;
                LockSupport.parkNanos(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanosTimeout);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; System.nanoTime();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新nanosTimeout&lt;/span&gt;
            nanosTimeout -= now -&lt;span&gt; lastTime;
            lastTime &lt;/span&gt;=&lt;span&gt; now;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相应中断&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
            cancelAcquire(node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　doAcquireNanos的流程简述为：线程先入等待队列，然后开始自旋，尝试获取锁，获取成功就返回，失败则在队列里找一个安全点把自己挂起直到超时时间过期。这里为什么还需要循环呢？因为当前线程节点的前驱状态可能不是SIGNAL，那么在当前这一轮循环中线程不会被挂起，然后更新超时时间，开始新一轮的尝试。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<og:description>1 synchronized和lock 1.1 synchronized的局限性 synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/9665718.html</dc:identifier>
</item>
<item>
<title>Netty实现简单HTTP代理服务器 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/9665385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/9665385.html</guid>
<description>&lt;p&gt;自上次使用Openresty+Lua+Nginx的来加速自己的网站，用上了比较时髦的技术，感觉算是让自己的网站响应速度达到极限了，直到看到了Netty，公司就是打算用Netty来替代Openresty这一套，所以，自己也学了好久，琢磨了好一趟才知道怎么用，现在用来写一套HTTP代理服务器吧，之后再测试一下性能。&lt;/p&gt;
&lt;p&gt;之前相关的文章如下：&lt;br/&gt;&lt;a href=&quot;http://www.wenzhihuai.com/getblogdetail.html?blogid=645&quot;&gt;【网页加速】lua redis的二次升级&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/w1570631036/p/8449373.html&quot;&gt;使用Openresty加快网页速度&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一netty中的http&quot;&gt;一、Netty中的HTTP&lt;/h2&gt;
&lt;p&gt;参考自《Netty实战》&lt;/p&gt;
&lt;h4 id=&quot;一个完整的httprequest请求&quot;&gt;一个完整的HttpRequest请求&lt;/h4&gt;
&lt;p&gt;FullHttpRequest:&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20180917105954482007021.png&quot;/&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;HTTP Request 第一部分是包含的头信息&lt;/li&gt;
&lt;li&gt;HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分&lt;/li&gt;
&lt;li&gt;LastHttpContent 标记是 HTTP request 的结束，同时可能包含头的尾部信息&lt;/li&gt;
&lt;li&gt;完整的 HTTP request&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;一个完整的httpresponse请求&quot;&gt;一个完整的HttpResponse请求&lt;/h4&gt;
&lt;p&gt;FullHttpResponse:&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20180917110022386437025.png&quot;/&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;HTTP response 第一部分是包含的头信息&lt;/li&gt;
&lt;li&gt;HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分&lt;/li&gt;
&lt;li&gt;LastHttpContent 标记是 HTTP response 的结束，同时可能包含头的尾部信息&lt;/li&gt;
&lt;li&gt;完整的 HTTP response&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二netty实现http代理服务器的流程&quot;&gt;二、Netty实现HTTP代理服务器的流程&lt;/h2&gt;
&lt;p&gt;在实现Http代理服务器之前，我们先来查看一下Netty实现代理服务器的完整流程：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20180909110242297408748.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Netty的Http服务的流程是：&lt;br/&gt;1、Client向Server发送http请求，在通常的情况中，client一般指的是浏览器，也可以由自己用netty实现一个客户端。此时，客户端需要用到HttpRequestEncoder将http请求进行编码。&lt;br/&gt;2、Server端对http请求进行解析，服务端中，需要用到HttpRequestDecoder来对请求进行解码，然后实现自己的业务需求。&lt;br/&gt;3、Server端向client发送http响应，处理完业务需求后，将相应的内容，用HttpResponseEncoder进行编码，返回数据。&lt;br/&gt;4、Client对http响应进行解析，用HttpResponseDecoder进行解码。&lt;/p&gt;
&lt;p&gt;而Netty实现Http代理服务器的过程跟上面的所说无意，只不过是在自己的业务层增加了回源到tomcat服务器这一过程。结合上自己之前实现过的用OpenResty+Nginx来做代理服务器这一套，此处的Netty实现的过程也与此类似。此处粘贴一下OpenResty+Nginx实现的流程图：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201862519474.png!/scale/80&quot;/&gt;&lt;/div&gt;
&lt;p&gt;而使用了Netty之后，便是将中间的OpenResty+Nginx换成了Netty，下面我们来看一下具体的实现过程。&lt;/p&gt;
&lt;h2 id=&quot;三主要代码如下&quot;&gt;三、主要代码如下：&lt;/h2&gt;
&lt;h4 id=&quot;httpserver&quot;&gt;HttpServer&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HttpServer {
    public void start(int port) throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .handler(new LoggingHandler(LogLevel.DEBUG))
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                        @Override
                        public void initChannel(SocketChannel ch)
                                throws Exception {
                            // server端发送的是httpResponse，所以要使用HttpResponseEncoder进行编码
                            ch.pipeline().addLast(
                                    new HttpResponseEncoder());
                            // server端接收到的是httpRequest，所以要使用HttpRequestDecoder进行解码
                            ch.pipeline().addLast(
                                    new HttpRequestDecoder());
                            ch.pipeline().addLast(
                                    new HttpServerHandler());
                            //增加自定义实现的Handler
                            ch.pipeline().addLast(new HttpServerCodec());
                        }
                    }).option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(port).sync();

            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        HttpServer server = new HttpServer();
        server.start(8080);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;httpserverhandler&quot;&gt;HttpServerHandler&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class HttpServerHandler extends ChannelInboundHandlerAdapter {

    private RedisUtil redisUtil = new RedisUtil();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        if (msg instanceof HttpRequest) {
            DefaultHttpRequest request = (DefaultHttpRequest) msg;
            String uri = request.uri();
            if (&quot;/favicon.ico&quot;.equals(uri)) {
                return;
            }
            log.info(new Date().toString());
            Jedis jedis = redisUtil.getJedis();
            String s = jedis.get(uri);
            if (s == null || s.length() == 0) {
                //这里我们的处理是回源到tomcat服务器进行抓取，然后
                //将抓取的内容放回到redis里面
                try {
                    URL url = new URL(&quot;http://119.29.188.224:8080&quot; + uri);
                    log.info(url.toString());
                    URLConnection urlConnection = url.openConnection();
                    HttpURLConnection connection = (HttpURLConnection) urlConnection;
                    connection.setRequestMethod(&quot;GET&quot;);
                    //连接
                    connection.connect();
                    //得到响应码
                    int responseCode = connection.getResponseCode();
                    if (responseCode == HttpURLConnection.HTTP_OK) {
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader
                                (connection.getInputStream(), StandardCharsets.UTF_8));
                        StringBuilder bs = new StringBuilder();
                        String l;
                        while ((l = bufferedReader.readLine()) != null) {
                            bs.append(l).append(&quot;\n&quot;);
                        }
                        s = bs.toString();
                    }
                    jedis.set(uri, s);
                    connection.disconnect();
                } catch (Exception e) {
                    log.error(&quot;&quot;, e);
                    return;
                }
            }
            jedis.close();
            FullHttpResponse response = new DefaultFullHttpResponse(
                    HTTP_1_1, OK, Unpooled.wrappedBuffer(s != null ? s
                    .getBytes() : new byte[0]));
            response.headers().set(CONTENT_TYPE, &quot;text/html&quot;);
            response.headers().set(CONTENT_LENGTH,
                    response.content().readableBytes());
            response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
            ctx.write(response);
            ctx.flush();
        } else {
            //这里必须加抛出异常，要不然ab测试的时候一直卡住不动，暂未解决
            throw new Exception();
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
            throws Exception {
        ctx.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四性能测试&quot;&gt;四、性能测试&lt;/h2&gt;
&lt;p&gt;下面的是ab测试，在1GHz、2G内存的centos7机器（阿里云服务器）下进行测试，测试命令ab -c 100 -n 10000 localhost:8000/，并发数为100，总数为10000。&lt;/p&gt;
&lt;p&gt;性能：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/201809171028141608056843.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;整体响应时间的分布比（单位：ms）：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/201809171028471308532170.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;看完之后，我自己也震惊了，Netty实现的不仅稳定、吞吐率还比OpenResty的高出一倍，OpenResty的居然还有那么多的失败次数，不知是不是我的代码的问题还是测试例子不规范，至今，我还是OpenResty的脑残粉。总体的来说，Netty实现的服务器性能还是比较强的，不仅能够快速地开发高性能的面向协议的服务器和客户端，还可以在Netty上轻松实现各种自定义的协议。&lt;/p&gt;
&lt;h2 id=&quot;五源码地址&quot;&gt;五、源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Zephery/myway&quot; class=&quot;uri&quot;&gt;https://github.com/Zephery/myway&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《Netty实战》&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/wangshuang1631/article/details/73251180/&quot;&gt;基于Netty4构建HTTP服务----浏览器访问和Netty客户端访问&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 17 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<og:description>自上次使用Openresty+Lua+Nginx的来加速自己的网站，用上了比较时髦的技术，感觉算是让自己的网站响应速度达到极限了，直到看到了Netty，公司就是打算用Netty来替代Openresty</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/9665385.html</dc:identifier>
</item>
<item>
<title>Kail更新源、输入法、浏览器 - ZTZ-99</title>
<link>http://www.cnblogs.com/lwenwu/p/9665679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwenwu/p/9665679.html</guid>
<description>&lt;h3&gt;&lt;span&gt;更新源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;kali官方的更新源：图中的&lt;span lang=&quot;EN-US&quot;&gt;kali-rolling是&lt;span lang=&quot;EN-US&quot;&gt;kali目前最新的代号，&lt;span lang=&quot;EN-US&quot;&gt;kali有两个代号&lt;span lang=&quot;EN-US&quot;&gt;(codename)：&lt;span lang=&quot;EN-US&quot;&gt;sana和&lt;span lang=&quot;EN-US&quot;&gt;kali-rolling；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232800155-2028603352.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看自己的&lt;span lang=&quot;EN-US&quot;&gt;kali linux源版本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232826614-643046054.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改&lt;span lang=&quot;EN-US&quot;&gt;sources.list文件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;vim /etc/apt/sources.list&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后选择添加以下源：&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#中科大&lt;span lang=&quot;EN-US&quot;&gt;kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.ustc.edu.cn/kali kali main non-free contrib&lt;br/&gt;deb-src http://mirrors.ustc.edu.cn/kali kali main non-free contrib&lt;br/&gt;deb http://mirrors.ustc.edu.cn/kali-security kali/updates main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#新加坡&lt;span lang=&quot;EN-US&quot;&gt;kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib&lt;br/&gt;deb-src http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib&lt;br/&gt;deb http://security.kali.org/kali-security kali/updates main contrib non-free&lt;br/&gt;deb http://mirror.nus.edu.sg/kali/kali-security kali/updates main contrib non-free&lt;br/&gt;deb-src http://mirror.nus.edu.sg/kali/kali-security kali/updates main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#阿里云&lt;span lang=&quot;EN-US&quot;&gt;kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.aliyun.com/kali kali main non-free contrib&lt;br/&gt;deb-src http://mirrors.aliyun.com/kali kali main non-free contrib&lt;br/&gt;deb http://mirrors.aliyun.com/kali-security kali/updates main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#163 Kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.163.com/debian wheezy main non-free contrib&lt;br/&gt;deb-src http://mirrors.163.com/debian wheezy main non-free contrib&lt;br/&gt;deb http://mirrors.163.com/debian wheezy-proposed-updates main non-free contrib&lt;br/&gt;deb-src http://mirrors.163.com/debian wheezy-proposed-updates main non-free contrib&lt;br/&gt;deb-src http://mirrors.163.com/debian-security wheezy/updates main non-free contrib&lt;br/&gt;deb http://mirrors.163.com/debian-security wheezy/updates main non-free contrib&lt;br/&gt;#auto&lt;br/&gt;deb http://http.kali.org/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#中科大 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib&lt;br/&gt;deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#浙大 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free&lt;br/&gt;deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#东软大学 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib&lt;br/&gt;deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#重庆大学 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://http.kali.org/kali kali-rolling main non-free contrib&lt;br/&gt;deb-src http://http.kali.org/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#官方源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;#deb http://http.kali.org/kali kali-rolling main non-free contrib&lt;br/&gt;#deb-src http://http.kali.org/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;更新操作系统&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完成第一条执行的命令也是必须执行的命令，刷新系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get upgrade 升级系统上安装的所有软件包，升级不成功回滚到原状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232852344-1800511988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get dist-upgrade升级整个&lt;span lang=&quot;EN-US&quot;&gt;Kali Linux系统，跨版本升级的方式，不仅可以升级所有软件包，还可以解决升级过程中可能出现的软件冲突。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232917930-2112809638.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：提示是否？、继续执行升级过程？并显示需要升级的大小及额外需要的空间大小。直接回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：第一次更新完成再次执行更新源的命令，确保所有软件保持最新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Kali更新内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232931741-1873251415.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新完成按&lt;span lang=&quot;EN-US&quot;&gt;q键完成安装。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;安装中文输入法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get install ibus ibus-libpinyin&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后重启操作系统，点击桌面右上角的设置&lt;span lang=&quot;EN-US&quot;&gt;&amp;gt;区域和语言，在输入源中添加汉语（拼音）即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232948098-2129700382.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过快捷键&lt;span lang=&quot;EN-US&quot;&gt;Win+Space（空格）即可切换输入法进行输入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;浏览器更改语言&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;1、 打开终端，输入 &lt;span lang=&quot;EN-US&quot;&gt;apt -y install firefox-esr-l10n-zh-cn，（下载安装语言包）。&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233008439-1779589911.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;2、 打开火狐浏览器，选择右上角的菜单，选择“&lt;span lang=&quot;EN-US&quot;&gt;Preferences（首选项）”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233044892-1924452507.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;3、 选择“内容”&lt;span lang=&quot;EN-US&quot;&gt;--&amp;gt;在语言栏点击“选择”，选择“中文&lt;span lang=&quot;EN-US&quot;&gt;/中国 &lt;span lang=&quot;EN-US&quot;&gt;[zh-cn]”，点击“确定”，重启浏览器即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233107166-174192432.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233143360-768723473.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233153081-2069491343.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:34:00 +0000</pubDate>
<dc:creator>ZTZ-99</dc:creator>
<og:description>更新源 kali官方的更新源：图中的kali-rolling是kali目前最新的代号，kali有两个代号(codename)：sana和kali-rolling； 查看自己的kali linux源版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwenwu/p/9665679.html</dc:identifier>
</item>
<item>
<title>设计模式之单利模式（C#语言描述，附视频下载地址） - 猫咪闯天下</title>
<link>http://www.cnblogs.com/caoruipeng/p/9665534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caoruipeng/p/9665534.html</guid>
<description>&lt;p&gt;今天来介绍所有设计模式中结构最简单的设计模式&lt;strong&gt;单例模式&lt;/strong&gt;，它的核心结构中只包含一个被称为单例类的特殊类。&lt;/p&gt;
&lt;p&gt;要想完成单例类的设计，我们要遵循一下原则即可：&lt;/p&gt;
&lt;p&gt;1、一个类只能有一个实例&lt;/p&gt;
&lt;p&gt;2、确保该实例对外有一个访问入口（保证我们的系统可以从这个入口拿到该类的唯一实例）&lt;/p&gt;
&lt;p&gt;3、将单例类的构造函数私有化（private），当构造函数被私有化之后，外部无法通过&lt;strong&gt;new 单例类()&lt;/strong&gt;的方法来实例化该类。既然外部无法直接实例化该类，那就要求该类的实例要自己去创建了~&lt;/p&gt;
&lt;p&gt;下面我们先看一个最简单的单例类的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 单例类
    /// &amp;lt;/summary&amp;gt;
    public class Singleton
    {
        private Singleton instance = null;
        //构造函数私有化
        private Singleton()
        {
 
        }
        //外部通过该类的唯一入口（GetInstance方法）获得单例类的实例
        public Singleton GetInstance()
        {
            if (instance == null)
                instance = new Singleton();
            return instance;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实上面的代码只是简单的介绍单例类的写法，下面我们来介绍一下饿汉式单例和懒汉式单例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 饿汉式单例类
    /// &amp;lt;/summary&amp;gt;
    public class Singleton
    {
        private static Singleton instance = new Singleton();
        //构造函数私有化
        private Singleton()
        {
 
        }
        //外部通过该类的唯一入口（GetInstance方法）获得单例类的实例
        public Singleton GetInstance()
        {
            return instance;
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;饿汉式单例类在类初始化的时候，直接new了一个单例类的实例并赋值给静态私有变量，因为静态变量归类所有，所以程序自始至终只会有一个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、懒汉式单例类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的代码看上去很完美，并没有什么问题。但是大家可以想一个问题，在高并发大流量的情况下，如果多个应用程序对该类进行实例化时（并发调用GetInstance方法时），有可能会导致单例类创建多个实例。所以，为了解决并发创建多个实例的问题，我们可以对实例的创建过程加锁。这就衍生出来了懒汉式单例类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 懒汉式单例类（高并发处理）
    /// &amp;lt;/summary&amp;gt;
    public class Singleton
    {
        private static Singleton instance = null;
        private static readonly object syncRoot = new object();
        //构造函数私有化
        private Singleton()
        {
 
        }
        //外部通过该类的唯一入口（GetInstance方法）获得单例类的实例
        public static Singleton GetInstance()
        {
            if (instance == null)
            {
                lock (syncRoot)//加锁之后只允许单线程访问，但是此处可能有其他的并发现成在此处等待执行
                {
                    //因为锁外面有可能并发线程在等待执行，为了防止线程实例化类之后，后面的线程继续实例化对象，应该在加一层判断
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　视频学习下载地址：&lt;a href=&quot;http://www.seekwd.com/article/details/4072&quot; target=&quot;_blank&quot;&gt;单例模式&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 17 Sep 2018 15:22:00 +0000</pubDate>
<dc:creator>猫咪闯天下</dc:creator>
<og:description>今天来介绍所有设计模式中结构最简单的设计模式单例模式，它的核心结构中只包含一个被称为单例类的特殊类。 要想完成单例类的设计，我们要遵循一下原则即可： 1、一个类只能有一个实例 2、确保该实例对外有一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caoruipeng/p/9665534.html</dc:identifier>
</item>
<item>
<title>rbac设计 - changwoo</title>
<link>http://www.cnblogs.com/changwoo/p/9665614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changwoo/p/9665614.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.创建表关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.基于admin录入数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.校验权限（中间件的应用）&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;http://www.cnblogs.com/changwoo/p/rbac设计_files/Image.png&quot; alt=&quot;&quot; data-filename=&quot;Image.png&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1478325/201809/1478325-20180917231928049-991219289.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.创建表关系&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;41&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;django.db &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;# Create your models here.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;User(models.Model):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.CharField(max_length&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;password &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.CharField(max_length&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;roles &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.ManyToManyField(to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'Role'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;__str__(&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;.name&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Role(models.Model):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.CharField(max_length&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;permissions &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.ManyToManyField(to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'Permission'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;__str__(&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;.title&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Permission(models.Model):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.CharField(max_length&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;urls &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.CharField(max_length&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;__str__(&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;.title&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.基于admin录入数据&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;71&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;django.shortcuts &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;render, HttpResponse&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;# Create your views here.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;rbac &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;user(request):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.User.objects.&lt;/span&gt;&lt;span&gt;all&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;render(request, &lt;/span&gt;&lt;span&gt;'user.html'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;locals&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;re&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;user_add(request):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;permission_list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.session[&lt;/span&gt;&lt;span&gt;'permission_list'&lt;/span&gt;&lt;span&gt;]  &lt;/span&gt;&lt;span&gt;# ['/user/add', '/user/', '/role/', '/user/delete/(\\d+)', '/user/edit/(\\d+)']&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;current_path &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.path_info&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;flag &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;permission &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;permission_list:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;permission &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;'^{}$'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(permission)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;re.match(permission, current_path)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ret:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;flag &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;flag:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HttpResponse(&lt;/span&gt;&lt;span&gt;'没有权限'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HttpResponse(&lt;/span&gt;&lt;span&gt;'add_user'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;role(request):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HttpResponse(&lt;/span&gt;&lt;span&gt;'add_user'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;rbac.service.permission &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;login(request):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.method &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;'POST'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;user &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.POST.get(&lt;/span&gt;&lt;span&gt;'user'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;pwd &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.POST.get(&lt;/span&gt;&lt;span&gt;'pwd'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;user &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;models.User.objects.&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;user, password&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;pwd).first()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;user:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;# 在session中注册用户id&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;request.session[&lt;/span&gt;&lt;span&gt;'user_id'&lt;/span&gt;&lt;span&gt;] &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;user.pk&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;initial_session(user, request)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HttpResponse(&lt;/span&gt;&lt;span&gt;'登陆成功'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;# rbac role-based access control&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;render(request, &lt;/span&gt;&lt;span&gt;'login.html'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.校验权限（中间件的应用）&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;74&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;django.utils.deprecation &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;MiddlewareMixin&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;django.shortcuts &lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HttpResponse, redirect&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;re&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ValidPermission(MiddlewareMixin):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;process_request(&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;, request):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;current_path &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.path_info&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;# 检查是否在白名单&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;valid_url_list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'/login/'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'/reg/'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'/admin/.*'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;valid_url &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;valid_url_list:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;re.match(valid_url, current_path)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ret:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;# 校验是否登陆&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;user_id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.session.get(&lt;/span&gt;&lt;span&gt;'user_id'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;user_id:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;redirect(&lt;/span&gt;&lt;span&gt;'/login/'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;# 权限校验&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;permission_list &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.session[&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;'permission_list'&lt;/span&gt;&lt;span&gt;]  &lt;/span&gt;&lt;span&gt;# ['/user/add', '/user/', '/role/', '/user/delete/(\\d+)', '/user/edit/(\\d+)']&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;current_path &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;request.path_info&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;flag &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;permission &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;permission_list:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;permission &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;'^{}$'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;(permission)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;ret &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;re.match(permission, current_path)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;ret:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;flag &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;flag:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;HttpResponse(&lt;/span&gt;&lt;span&gt;'没有权限'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:20:00 +0000</pubDate>
<dc:creator>changwoo</dc:creator>
<og:description>1.创建表关系 2.基于admin录入数据 3.校验权限（中间件的应用） 1.创建表关系 from django.db import models # Crea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/changwoo/p/9665614.html</dc:identifier>
</item>
<item>
<title>python多任务的导包问题 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/9665606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/9665606.html</guid>
<description>&lt;p&gt;&lt;span&gt;多线程的使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;import threading&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　def func(x):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　print(x)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　t= threading.Thread(target=func,args=(12,))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 线程启动&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　t.start()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 主进程阻塞，等待子进程的退出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　t.join()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　   # 设置线程为主线程的守护线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　t.setDaemon()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;多进程的使用&lt;/span&gt;&lt;br/&gt;　　&lt;span&gt;from multiprocessing import Process&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　def func(x):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　print(x)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　p = Process(target=func,args=(12,))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　p.start()# 启动子进程实例(创建子进程)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　p.is_alive()# 判断进程子进程是否还在活着&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　p.join(timeout)# 是否等待子进程执行结束，或者等待多少秒&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　p.terminate()# 不管任务是否完成，立即终止子进程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　p.daemon = True # 设置守护进程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;线程池、进程池的使用：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# 进程池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　from multiprocessing import Pool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　# 线程池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　from multiprocessing.dummy import Pool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　pool = Pool(5) # 同时最大运行线程或者进程个数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　def _excute(x,y):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　print(x+y)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　def _callback(self, temp): # temp必有参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　print(&quot;线程或进程任务完成后的回调&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　pool.apply_async(target=_excute, callback=_callback)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　poll.close()# 关闭Pool，使其不再接受新的任务；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　poll.terminate()# 不管任务是否完成，立即终止；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　poll.join()# 主进程阻塞，等待子进程的退出,必须在close或terminate之后使用&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;进程或者线程的间通信工具--Queue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;# 线程池、多线程 使用的Queue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　from queue import Queue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　# 多进程使用的queue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　from multiprocessing import JoinableQueue as Queue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　# 进程池使用的queue&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　from multiprocessing import Manager&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　queue = Manager().Queue()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　queue = Queue()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　queue.qsize()# 返回当前队列包含的消息数量。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　queue.empty()# 如果队列为空，返回True,反之False。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　queue.full()# 如果队列满了，返回True，反之False。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　queue.put(item, block=True, timeout=None)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　将item消息写入队列，block默认值为True；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　出&quot;Queue.Full&quot;异常；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果block值为False，消息列队如果没有空间可写入，则会立刻抛出&quot;Queue.Full&quot;异常；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　queue.get(item, block=True, timeout=None)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　获取队列中的一条消息，然后将其从队列中移除，block默认值为True。如果block使用默认值，且没有设置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出&quot;Queue.Empty&quot;异常；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果block值为False，消息列队如果为空，则会立刻抛出&quot;Queue.Empty&quot;异常；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　# get方法并不能让queue的计数-1，必须调用task_done&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　queue.task_done()&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:18:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<og:description>多线程的使用： import threading def func(x): print(x) t= threading.Thread(target=func,args=(12,)) # 线程启动 t.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skaarl/p/9665606.html</dc:identifier>
</item>
<item>
<title>项目也可以学习到很多东西 - 冰魄秋雨</title>
<link>http://www.cnblogs.com/skyice/p/9665567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyice/p/9665567.html</guid>
<description>&lt;p&gt;今天分享关于最近做的一个小项目学习一些感悟。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.小项目也能学习到非常多的知识&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;最近做的是一个数据整理的一个项目，后台系统需要一些统计的数据，如果从原有的系统中查询，会大大影响到其他端的性能，而且相对于手机端去直接用户，后台系统面对的是公司人员和运营人员，用户量少，但是查询的数据确不少，需要做大量的计算，而这大量的计算就耗掉服务器的性能。为了保证线上手机和前端的性能，数据库做了优化工作，建立的索引也是根据用户来建立。后台系统搜索的条件特别多，没有建立的索引的情况下，在大量的数据中查询数据，还包括大量的计算，这就造成性能的影响，那么就需要哪空间换时间，并且后台系统要求的实时性并不高，那么就可以将关心的数据抽取出来，放到新的数据库中，然后在新的数据库中进行聚合，得到后台系统需要的数据，这里可以看关于数据仓库的概念。那么我做的这个项目就是将数据从原数据库中抽取数据到新数据库中，任务很简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，这个小项目却让我学习到很多知识：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.数据库格式的问题，开发人员创建的数据库的字段都不做统一，因为公司用了两种数据库，mysql和mongodb,从这两个数据库中抽取数据，由于我使用的mysql当数据存储，在创建表字段时，就遇到特别多的麻烦，字段长度不同一，很多数据都没有做强制性规范，mysql和mongodb数据不同一，不过这不统一也正常，但是程序中又有了规范，如果按照程序中做，但是数据库中有大量不规范的数据字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.做好数据容错处理，很多数据时增量抽取，即抽取前一天的数据，但是突然发现前两天的数据有一点问题，那么该如何做，需要在程序中启动另一个监听线程，该监听线程是每十分钟会读取数据库中的一个字段，该字段是否为true,为true则将这几天的数据删除，重新抽取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.因为跑的数据有先后顺序，例如需要先抽取用户的信息，然后对用户信息进行统计，如果用户的信息出现错误，那么后续的统计都会有问题。这里我设计了一个任务处理的小框架。在这个其中需要做到任务的顺序可配置，前一个任务没执行完，后续任务不能执行，一个队列中的任务可并行执行，不同优先级的任务串行执行。在实现这个逻辑，学习到了java中队列，树形结构，学习了多线程的知识，为了程序设计优美，学习了单例模式，观察者模式（EventBus）,为了能够极大简化代码，使用注解，学习guava包，common-lang包中类，并且在该项目中添加了异常后发送邮件功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是这个 很小的项目，我在其中学习很了特别多的知识。很多时候，在抱怨每天都在做增删改查的工作，感觉每天都做的是体力活，完全不费脑力的工作，其实不然，想要将工作做好，需要花费特别多的经历。写接口做的就是增删改查的工作，但是其中的能够操作的空间极大，使用SpringBoot做项目，是否在项目中添加了拦截工作，对请求过来做一些基础工作如日志打印，对异常是否有做统一的处理工作，后续的是否有做单元测试，对于接口是否有做压测，要将一个功能或者是一个项目做好，是需要非常多的精力的，所以小项目，如果我们肯花心思去做，发现会有特别多的事情要做，而且在这个小项目中可以学习到非常多的东西。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.敢于实践，将想法都化成代码&lt;/h3&gt;
&lt;p&gt;将自己思想都化作代码，但是能够做到完全将思想化作代码是非常困难的。&lt;/p&gt;
&lt;p&gt;很多时候，我们看别人分享，我们也记住了其中如何操作的，例如redis作为缓存，遇到缓存雪崩，缓存穿透等问题都能够说出个一二三来，但很少去亲手去实践。遇到这样的场景真的很少，比如我，开发了两年，公司的数据都很少，并发也不高，一个小的redis的集群，完全支持了线上访问，也不会遇到缓存穿透导致的查询速度慢的情况。如果没有真正遇到，动手解决过该问题，并不能很好的去理解该问题是什么一个情况，即使别人分享的很透彻，那也是他真正去解决过，形成了自己的经验。而我们看了，也是只住了有这么一个问题。而看到该问题，需要去将问题重现，并按照他人分享的方式去解决，这样才能是自己真正学到收了。&lt;/p&gt;
&lt;p&gt;业务上没有碰到这样的问题，那该怎么办呢，那么就去模拟，自己东西写程序，然后利用工具模拟大量的请求，实现高并发的情况，观察在高并发的情况下，redis和数据库的情况，然后在根据该情况解决该问题，最后再来验证该问题。当自己做完这些的时候，才能真正的说自己做过在高并发的情况下，解决reidis缓存的一些问题。&lt;/p&gt;
&lt;p&gt;再比如分库分表，网上有非常多的文章来介绍其思路。但是线上数据在并不大的情况下是不需要分库分表的，那么仅仅是看了文章，并没有深入的去了解，一个表面映像，如果是到了下一个公司，突然问分库分表的问题，虽然能够简单的说一下思路，但是真的讲操作的时候，很可能就错误百出。并且当已经是线上程序了，需要做分库分表工作时，需要该如何处理呢，线上程序停下来维护，将数据搬移到新的数据库中？是否有更好的方式呢，是否可以进行双写的操作，即数据的插入不仅写入旧数据库中，也写入分库分表中，然后将数据的更新删除操作发送到消息中间件中，当旧数据库中的数据都搬移到数据库中，然后将程序的数据库切换成分库分表数据库，消费消息中间件的消息，最后写一个程序进行数据的比对。这一系列的操作过程，只有在实际操作中能够得到检验，也只有在实践中才能将别人的知识化成自己的知识。&lt;/p&gt;
&lt;p&gt;总结：编程是一个需要花精力做的事情，不要抱怨每天干的仅仅是增删改查的工作，小的项目也可以变成一个内容很丰富的项目，在小项目中也可以学习到非常多的知识。&lt;/p&gt;

</description>
<pubDate>Mon, 17 Sep 2018 15:09:00 +0000</pubDate>
<dc:creator>冰魄秋雨</dc:creator>
<og:description>今天分享关于最近做的一个小项目学习一些感悟。 1.小项目也能学习到非常多的知识 最近做的是一个数据整理的一个项目，后台系统需要一些统计的数据，如果从原有的系统中查询，会大大影响到其他端的性能，而且相对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyice/p/9665567.html</dc:identifier>
</item>
<item>
<title>百度云面试总结 - coding-for-self</title>
<link>http://www.cnblogs.com/longjiang-uestc/p/9665545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longjiang-uestc/p/9665545.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;origin&quot;/&gt;&lt;title&gt;百度云面试总结 - coding-for-self - 博客园&lt;/title&gt;&lt;meta property=&quot;og:description&quot; content=&quot;百度云面试总结 在这个面试体验感很不舒服, 有压力面试的感觉; 总结起来人家对我的项目一点不感兴趣, 面后台的岗位都会很难; 现场笔试题 树的和为k的所有路径 树的先序遍历, 注意到条件 问我的性格,&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=giTNza-Of-PEt5UsELhFQAR7G6-bfaSa4oolcq7i9-o1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/MTTrendy/bundle-MTTrendy.css?v=OKw4CRAEvlgvi5ykObK1BKCLNINXwr3S7M6wUje-aAk1&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/MTTrendy/bundle-MTTrendy-mobile.css?v=d9LctKHRIQp9rreugMcQ1-UJuq_j1fo0GZXTXj8Bqrk1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/longjiang-uestc/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/longjiang-uestc/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/longjiang-uestc/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;



&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;post&quot;&gt;

&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
&lt;h2 id=&quot;百度云面试总结&quot;&gt;百度云面试总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在这个面试体验感很不舒服, 有压力面试的感觉;
&lt;ul&gt;&lt;li&gt;总结起来人家对我的项目一点不感兴趣, 面后台的岗位都会很难;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;现场笔试题&quot;&gt;现场笔试题&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;树的和为k的所有路径
&lt;ul&gt;&lt;li&gt;树的先序遍历, 注意到条件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;问我的性格, 优缺点&lt;/li&gt;
&lt;li&gt;Nginx, hash, 红黑树, AVL树, B+, B-树
&lt;ul&gt;&lt;li&gt;重新总结一下hash, 红黑树, AVL树, B+树, B-树;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;线程通信机制:&lt;/li&gt;
&lt;li&gt;条件变量
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/c-slmax/p/5853784.html&quot;&gt;条件变量的实现&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/yangqing99801/article/details/53184688&quot;&gt;线程条件变量原理分析&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;条件变量本质上是一个全局可访问的flag，所以，线程在调用pthread_cond_wait之前必须先调用pthread_mutex_lock对条件变量加互斥锁;&lt;/li&gt;
&lt;li&gt;pthead_cond_wait函数首先检测当前条件变量的值，如果条件变量为真，线程直接从pthread_cond_wait函数返回，继续执行下面的代码;&lt;/li&gt;
&lt;li&gt;如果为假，那么线程不具备工作的条件，必须等待，为了不浪费CPU资源，pthread_cond_wait函数让线程进入了休眠状态;&lt;/li&gt;
&lt;li&gt;为了不阻塞其他线程，让其他线程也可以访问条件变量，pthread_cond_wait函数又释放了互斥锁;&lt;/li&gt;
&lt;li&gt;但此时进入休眠状态的线程依然位于pthread_cond_wait函数内，执行过程在pthread_cond_wait函数处阻塞;&lt;/li&gt;
&lt;li&gt;当线程工作的条件具备时，pthread_cond_signal函数负责将条件变量修改为真，同时发信号通知等待的线程;&lt;/li&gt;
&lt;li&gt;因等待条件变量而进入休眠状态的线程将在pthread_cond_wait函数内被信号唤醒;&lt;/li&gt;
&lt;li&gt;在pthread_cond_wait函数中, 先释放锁, 再睡眠, 再加锁, 再对条件变量进行检验;&lt;/li&gt;
&lt;li&gt;线程被唤醒的同时重新获取了互斥锁，并再次对条件变量检测，发现条件变量为真，线程具备了工作的条件;&lt;/li&gt;
&lt;li&gt;pthread_cond_wait函数从阻塞（线程休眠）状态返回，然后线程继续执行下面的代码;&lt;/li&gt;
&lt;li&gt;线程在完成对全局资源的访问后，释放互斥锁;&lt;/li&gt;
&lt;li&gt;条件变量机子是将全局标记、线程信号、线程休眠、加锁解锁结合在一起, 主要包含在pthread_cond_wait函数内, 包括:
&lt;ul&gt;&lt;li&gt;检测条件变量, 为真从函数中返回, 继续执行下一步, 为假则:
&lt;ul&gt;&lt;li&gt;设置线程等待条件(变量变为真的)信号;&lt;/li&gt;
&lt;li&gt;让线程进入休眠状态;&lt;/li&gt;
&lt;li&gt;释放互斥锁;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;接收到条件(变量变为真的)信号后, 则:
&lt;ul&gt;&lt;li&gt;唤醒休眠的线程;&lt;/li&gt;
&lt;li&gt;重新获取互斥锁;&lt;/li&gt;
&lt;li&gt;重新检验条件变量, 为假, 则继续执行步骤1, 为真则从函数内返回;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;pthread_cond_signal函数的主要工作是负责修改条件变量的值和发送信号提醒等待线程条件变量变成了真值;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;条件变量和互斥量结合使用, 互斥锁保护的是两种资源: 条件变量和线程需要访问的全局资源；
&lt;ul&gt;&lt;li&gt;因为线程在pthread_cond_wait函数内被唤醒后，重新获取了互斥锁，然后才能检测条件变量，条件变量为真，从函数返回后，并没有申请获取其他的互斥锁，就继续对全局资源访问，并在完成访问后只释放了一次互斥锁；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;共享内存怎么加锁
&lt;ul&gt;&lt;li&gt;shm_ptr是共享内存映射得来的虚拟地址, 用映射的虚拟地址来保存互斥量&lt;/li&gt;
&lt;li&gt;用信号量来完成互斥的效果&lt;/li&gt;
&lt;li&gt;文件记录锁&lt;/li&gt;
&lt;li&gt;自己实现一个原子的自旋锁&lt;/li&gt;
&lt;li&gt;使用无所结构
&lt;ul&gt;&lt;li&gt;生产者-消费者模型中的队列，可以使用无锁队列来实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;包括共享线程锁、文件锁、使用无锁结构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;被问得怀疑人生&lt;/li&gt;
&lt;li&gt;gdb调试 core dump文件&lt;/li&gt;
&lt;li&gt;epoll机制怎么实现事件回调的
&lt;ul&gt;&lt;li&gt;通过epoll_ctl向红黑树添加要被监测的事件时, 会向内核注册回调函数, 当事件活跃的时候会触发中断函数, 调用回调函数, 然后把该活跃的事件添加到双向链表中;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C++11的四种智能指针, 有缺点
&lt;ul&gt;&lt;li&gt;auto_ptr 已经被C++11弃用了&lt;/li&gt;
&lt;li&gt;shared_ptr&lt;/li&gt;
&lt;li&gt;weak_ptr&lt;/li&gt;
&lt;li&gt;unique_ptr 是为了取代auto_ptr的产物;
&lt;ul&gt;&lt;li&gt;unique_ptr是一个独享所有权的智能指针, 它提供了严格意义上的所有权;&lt;/li&gt;
&lt;li&gt;拥有它指向的对象;&lt;/li&gt;
&lt;li&gt;无法进行复制构造, 无法进行复制赋值操作, 即无法使两个unique_ptr指向同一个对象, 但是可以进行移动构造和移动赋值操作;&lt;/li&gt;
&lt;li&gt;保存指向对象的指针, 当它本身被删除释放的时候, 会使用给定的删除器释放它指向的对象;&lt;/li&gt;
&lt;li&gt;unique_ptr 可以实现如下功能：
&lt;ol&gt;&lt;li&gt;为动态申请的内存提供异常安全&lt;/li&gt;
&lt;li&gt;讲动态申请的内存所有权传递给某函数&lt;/li&gt;
&lt;li&gt;从某个函数返回动态申请内存的所有权&lt;/li&gt;
&lt;li&gt;在容器中保存指针&lt;/li&gt;
&lt;li&gt;auto_ptr 应该具有的功能&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;迭代器什么时候才会失效
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/yangquanhui1991/article/details/52077562&quot;&gt;STL各种容器迭代器失效的时机&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;标准STL序列容器：vector、string、deque和list;&lt;/li&gt;
&lt;li&gt;标准STL关联容器：set、multiset、map和multimap。&lt;/li&gt;
&lt;li&gt;非标准序列容器slist和rope;
&lt;ul&gt;&lt;li&gt;slist是一个单向链表，rope本质上是一个重型字符串&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;非标准关联容器hash_set、hash_multiset、hash_map和hash_multimap;&lt;/li&gt;
&lt;li&gt;几种标准非STL容器，包括数组、bitset、valarray、stack、queue和priority_queue;&lt;/li&gt;
&lt;li&gt;值得注意的是，数组可以和STL算法配合，因为指针可以当作数组的迭代器使用;&lt;/li&gt;
&lt;li&gt;vector：
&lt;ol&gt;&lt;li&gt;当插入（push_back）一个元素后，end操作返回的迭代器肯定失效。&lt;/li&gt;
&lt;li&gt;当插入(push_back)一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器都会失效。&lt;/li&gt;
&lt;li&gt;当进行删除操作（erase，pop_back）后，指向删除点的迭代器全部失效；指向删除点后面的元素的迭代器也将全部失效。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;deque迭代器的失效情况：
&lt;ol&gt;&lt;li&gt;在deque容器首部或者尾部插入元素不会使得任何迭代器失效。&lt;/li&gt;
&lt;li&gt;在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。&lt;/li&gt;
&lt;li&gt;在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;List/set/map
&lt;ol&gt;&lt;li&gt;删除时，指向该删除节点的迭代器失效;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/skyroben/article/details/70877008&quot;&gt;STL中迭代器失效详解&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;vector重新申请内存迭代器就会失效;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fork(), waitfork();
&lt;ul&gt;&lt;li&gt;还有好多都忘得差不多了, (~衰~);&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;




&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;

&lt;/body&gt;</description>
<pubDate>Mon, 17 Sep 2018 15:02:00 +0000</pubDate>
<dc:creator>coding-for-self</dc:creator>
<og:description>百度云面试总结 在这个面试体验感很不舒服, 有压力面试的感觉; 总结起来人家对我的项目一点不感兴趣, 面后台的岗位都会很难; 现场笔试题 树的和为k的所有路径 树的先序遍历, 注意到条件 问我的性格,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longjiang-uestc/p/9665545.html</dc:identifier>
</item>
<item>
<title>关于线上静态页面资源更新的一些经验分享 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/9665538.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/9665538.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;最近在负责公司的后台项目，包括了后端和前端。后端直接编译完打成jar包直接上线运行没什么问题。但是前端的页面文件更新每次都要把页面给运维，然后告诉运维路径让运维挨个替换，当然也可以整包替换，&lt;br/&gt;但是如果文件比较多的情况下，整包替换就不合适了。因为现在开发的项目版本控制基本必不可少了，这时候可以利用版本控制软件来生成Patch文件，然后直接交给运维，让运维在项目根目录打补丁就行。&lt;/p&gt;
&lt;h2 id=&quot;关于linux的patch&quot;&gt;关于Linux的Patch&lt;/h2&gt;
&lt;p&gt;如果熟悉linux的话对patch命令肯定不陌生，linux很多软件代码的更新都用的是patch，相较于重新下载整份源码，patch文件体积小只需要更新改动的地方。patch本身和diff经常一起用的，具体的用法我就不详细介绍了，网上已经说明很多了。这里用来更新页面的思路其实和linux中的思想是一样的。&lt;br/&gt;常用的的格式：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;    patch -d /root/amqp -p0 -E  &amp;lt;/root/amqp/0001-.patch&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;-d 指明了patch的工作目录，此处指源码的根目录。&lt;br/&gt;-pN中的N表示忽略路径中的第几层。如patch文件中路径为a/src/main/java/spittr/chen/AlertServiceImpl.java,如果需要忽略前面的a目录就需要指明-p1&lt;br/&gt;-E表示如果文件更新之后为空则删除这个文件。&lt;br/&gt;-R表示反向，回滚更新&lt;br/&gt;-b用于备份改动的文件，用于重要的操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于git&quot;&gt;关于git&lt;/h2&gt;
&lt;p&gt;git作为最流行的版本控制软件也实现了diff和patch的功能，git导出patch有两种方式，git diff和git format-patch 。git diff用于生成通用的patch格式，而format-patch用于生成git专用的patch文件。不过我经过测试，两种生成的文件都是和linux的patch命令兼容的，也就是说两种生成的文件都可以直接使用patch命令来打补丁。不过这里有一个需要的需要注意的地方就是，git生成的patch文件中，在指明影响的文件路径时，默认原来的文件前面会加上路径a/,而改动后的文件前面会加上路径b/(我查看了git官网文档也有提及，但是不清楚为什么要默认这么写,如果有知道的希望能告知下),如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;diff --git a/src/main/java/spittr/chen/AlertServiceImpl.java b/src/main/java/spittr/chen/AlertServiceImpl.java
new file mode 100644
index 0000000..7c8ebd1
--- /dev/null
+++ b/src/main/java/spittr/chen/AlertServiceImpl.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以在linux中使用的时候需要指明参数-p1来忽略第一层路径，或者在使用git diff命令时加上参数&lt;span&gt;--no-prefix&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;其实git本身也有对应于linux patch的命令apply，还有更为强大的am。但是要求是必须是git项目。如果使用的git项目，推荐使用git的命令尤其是am命令，他必须使用format-patch生成的文件，format-patch文件携带了提交的记录包括作者，提交注释，日期等等，信息和pull差不多。关于这两个命令网上有很多的教程这里不再说明。对于我这个需求。已经因为线上的页面文件一般是文件夹的形式存在，所以使用linux的patch即可满足需求。&lt;/p&gt;
&lt;h2 id=&quot;关于idea&quot;&gt;关于Idea&lt;/h2&gt;
&lt;p&gt;如果你用的开发工具是Idea的话，idea可以很方便的生成patch文件。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pewaccq76.bkt.clouddn.com/201809172245_845.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在版本的控制的log标签页，选中自己需要生成补丁的提交记录右键即可生成patch文件。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:01:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>关于线上静态页面资源更新的一些经验分享 [TOC] 最近在负责公司的后台项目，包括了后端和前端。后端直接编译完打成jar包直接上线运行没什么问题。但是前端的页面文件更新每次都要把页面给运维，然后告诉运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/9665538.html</dc:identifier>
</item>
<item>
<title>ubuntu下安装CAJ阅读器 - hugechuanqi</title>
<link>http://www.cnblogs.com/hugechuanqi/p/9665459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hugechuanqi/p/9665459.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;ubuntu下wine的基本介绍&quot;&gt;1、ubuntu下wine的基本介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hyyq/p/9082765.html&quot;&gt;wine基本介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;wine的介绍&quot;&gt;&lt;strong&gt;（1）wine的介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Wine（“Wine Is Not an Emulator”）是一个兼容层，能够在几个POSIX兼容的操作系统上运行Windows应用程序，如Linux、MaOS、BSD。代替模拟虚拟机或仿真器的内部Windows逻辑，FILE立即将Windows API调用转换为POSIX调用，消除了其他方法的性能和内存损失，并允许您将Windows应用程序干净地集成到桌面中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单地说，就是wine能够使windows的程序在linux上运行，包括ubuntu, debain, CentOS；也能在MAOS、BSD上起作用。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;wine的安装&quot;&gt;&lt;strong&gt;（2）wine的安装&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$ sudo apt-get install wine&lt;/code&gt; 可能要求你安装时选定版本，这时改为&lt;code&gt;$ sudo apt-get install wine-stable&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;也可以参考&lt;a href=&quot;https://wiki.winehq.org/Ubuntu&quot;&gt;官方教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果速度太慢，可修改第三方源，参考&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/&quot;&gt;ubuntu清华镜像源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看是否已安装：&lt;code&gt;wine --version&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;exe文件的安装&quot;&gt;&lt;strong&gt;（3）exe文件的安装&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用命令：&lt;code&gt;$ wine exe文件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;$ wine ~/software/software_package/CAJViewer(Cloud).self(1.2.0.5).exe&lt;/code&gt;，即需要指定相应路径下的exe文件；&lt;/p&gt;
&lt;p&gt;安装的位置在&lt;code&gt;~/.wine&lt;/code&gt;中，即家目录下，其中的文件是调用windows API设置的，包含了windows下的大多数动态库，ubuntu中的盘映射为windows的C盘，然后其他挂载的盘映射为D盘、E盘、F盘等；&lt;/p&gt;
&lt;h3 id=&quot;exe程序的卸载&quot;&gt;&lt;strong&gt;（4）exe程序的卸载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使用删除文件法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;wine会在/home下的用户名目录生成三个隐藏的文件夹 .wine、.local、.config 等文件夹，快捷键 ctrl+H 可以显示出来;（在图形界面中显示）&lt;/li&gt;
&lt;li&gt;进入 .wine 文件夹可以看到 drive_c 文件夹，这是wine自动生成的虚拟windows C盘，里面有类似windows系统盘的目录结构，在里面找到需要卸载的软件文件夹删除即可；&lt;/li&gt;
&lt;li&gt;找到/home/用户名/.local/share/applications/wine/Programs，将软件对应的文件删除；&lt;/li&gt;
&lt;li&gt;找到/home/用户名/.config/menus/applications-merged，将软件对应的文件删除；&lt;/li&gt;
&lt;li&gt;这时候已经删除完毕，但是可能还会看到桌面图标或软件列表，重启系统即可。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;wine的基本使用&quot;&gt;&lt;strong&gt;（6）wine的基本使用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/oloroso/p/5070174.html&quot;&gt;ubuntu linux下wine的使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/oloroso/p/5070065.html&quot;&gt;ubuntu下wine源码编译&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34638161/article/details/81271977&quot;&gt;wine部分使用讲述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.ubuntu.org.cn/Wine%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B&quot;&gt;wine简明教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;caj阅读器的安装&quot;&gt;2、CAJ阅读器的安装&lt;/h2&gt;
&lt;h3 id=&quot;首先放上正确的安装方式三步完成&quot;&gt;（1）首先放上正确的安装方式——三步完成&lt;/h3&gt;
&lt;p&gt;注意：一切操作直接在ubuntu下运行，包括下载安装软件皆是如此；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.首先需要安装wine&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ sudo apt-get install wine-stable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.其次到官网下载相应的CAJ云阅读安装程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cajviewer.cnki.net/cajcloud/&quot;&gt;CAJ云阅读安装程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在知网的官网可以看到CAJ云阅读器是一个跨平台软件；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c.找到CAJ云阅读器下载目录（进入该终端）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此下载路径可指定，例如，我的在&lt;code&gt;~/software/softwre_package&lt;/code&gt;，执行以下命令：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ wine ~software/software_package/CAJViewer\(Cloud\).self\(1.2.0.5\).exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此处&lt;code&gt;（&lt;/code&gt;和&lt;code&gt;）&lt;/code&gt;需要用&lt;code&gt;\&lt;/code&gt;转义；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;d.类似于windows将软件安装在指定路径下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后安装完成后，会在桌面出现一个&lt;code&gt;CAJ云阅读.desktop&lt;/code&gt;，右健信任，将出现一个完整的图标。&lt;/p&gt;
&lt;p&gt;其中.desktop是一个二进制文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;e.打开CAJ云阅读器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于本人使用的是ubuntu18.04.1LTS，并且已经转为中文版，故没有出现中文乱码的错误，如果你出现中文乱码，可参考以下文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/oucbl/p/8392673.html&quot;&gt;ubuntu下使用CAJ云阅读器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改CAJ云阅读器.desktop的Commad的值，改成相应的utf-8编码格式，然后设定wine执行环境；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装其他的windows软件也可以参考这篇文章&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;然后讲述以下之前安装出问题的经验&quot;&gt;（2）然后讲述以下之前安装出问题的经验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;a.一开始参考文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/asmer-stone/p/5197307.html&quot;&gt;ubuntu下查看文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install wine&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载CAJViewer6.0_green.rar；(&lt;a href=&quot;http://pan.baidu.com/s/1jIqHxLs&quot; class=&quot;uri&quot;&gt;http://pan.baidu.com/s/1jIqHxLs&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir cajviewer6.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unrar x CAJViewer6.0_green.rar cajviewer6.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo chmod u+x CAJViewer.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wine CAJVier.exe&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这种方法相当于在windows中已经安装了CAJ，然后把安装目录放置linux下，使用wine直接运行安装之后的exe文件；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出现问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图标也能出现，而且打开相应文献时发现有的文件并不能打开；或者就直接显示错误；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b.在windows下下载安装CAJ云阅读器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载安装之后复制到ubuntu下，也出现错误，说是缺少三个动态库，MFC71U.DLL, mailu.dll, WHelperu.dll，可是不管怎么找，始终找不到这三个库；没办法，参考以下文章:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/eli3716/article/details/6083493&quot;&gt;resolve:wine cannot find MFC42.dll&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;缺少什么库就可以安装什么库，需要用到&lt;code&gt;winetricks&lt;/code&gt;;因此又下载安装了&lt;code&gt;cabextract&lt;/code&gt;和&lt;code&gt;winetricks&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget http://www.kegel.com/wine/winetricks&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chmod +x winetricks&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aptitude install cabextract&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;winetricks mfc42&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可是最后成功安装了类似的库，依然出现问题，并且把相应库添加到了相应的&lt;code&gt;~/.wine&lt;/code&gt;配置环境中，依然没有成功，很无奈；&lt;/p&gt;
&lt;p&gt;最后思考再三，既然在windows上安装后能运行，而在ubuntu上出现问题，说明很有可能是因为windows上安装时添加了某些库或者环境变量，而到linux下的wine环境映射中没有，那就直接在ubuntu中安装试试看，没想到就这么成功了，至于原因，有机会再考证；未完待续！！！&lt;/p&gt;
&lt;p&gt;如果有需要用到winetricks，可参考以下网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.winehq.org/Winetricks&quot;&gt;Winetricks&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 14:50:00 +0000</pubDate>
<dc:creator>hugechuanqi</dc:creator>
<og:description>[TOC] 1、ubuntu下wine的基本介绍</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hugechuanqi/p/9665459.html</dc:identifier>
</item>
</channel>
</rss>