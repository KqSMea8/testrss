<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kafka Producer Consumer - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/8438750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/8438750.html</guid>
<description>&lt;p&gt;&lt;span&gt;org.apache.kafka.clients.producer.KafkaProducer&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; props.put(&quot;bootstrap.servers&quot;, &quot;192.168.1.128:9092&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; props.put(&quot;acks&quot;, &quot;all&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; props.put(&quot;retries&quot;, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; props.put(&quot;batch.size&quot;, 16384&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; props.put(&quot;linger.ms&quot;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; props.put(&quot;buffer.memory&quot;, 33554432&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; Producer&amp;lt;String, String&amp;gt; producer = &lt;span&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;&lt;span&gt;(props);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     producer.send(&lt;span&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&quot;foo&quot;, Integer.toString(i), Integer.toString(i)), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Callback() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCompletion(RecordMetadata recordMetadata, Exception e) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 System.out.println(&quot;callback: &quot; + recordMetadata.topic() + &quot; &quot; +&lt;span&gt; recordMetadata.offset());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; producer.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;producer由一个缓冲池组成，这个缓冲池中维护着那些还没有被传送到服务器上的记录，而且有一个后台的I/O线程负责将这些记录转换为请求并将其传送到集群上去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;send()方法是异步的。当调用它以后就把记录放到buffer中并立即返回。这就允许生产者批量的发送记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;acks配置项控制的是完成的标准，即什么样的请求被认为是完成了的。本例中其值设置的是&quot;all&quot;表示客户端会等待直到所有记录完全被提交，这是最慢的一种方式也是持久化最好的一种方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果请求失败了，生产者可以自动重试。因为这里我们设置retries为0，所以它不重试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者对每个分区都维护了一个buffers，其中放的是未被发送的记录。这些buffers的大小是通过batch.size配置项来控制的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，即使一个buffer还有未使用的空间（PS：buffer没满）也会立即发送。如果你想要减少请求的次数，你可以设置linger.ms为一个大于0的数。这个指令将告诉生产者在发送请求之前先等待多少毫秒，以希望能有更多的记录到达好填满buffer。在本例中，我们设置的是1毫秒，表示我们的请求将会延迟1毫秒发送，这样做是为了等待更多的记录到达，1毫秒之后即使buffer没有被填满，请求也会发送。（PS：稍微解释一下这段话，producer调用send()方法只是将记录放到buffer中，然后由一个后台线程将buffer中的记录传送到服务器上。这里所说的请求指的是从buffer到服务器。默认情况下记录被放到buffer以后立即被发送到服务器，为了减少请求服务器的次数，可以通过设置linger.ms，这个配置项表示等多少毫秒以后再发送，这样做是希望每次请求可以发送更多的记录，以此减少请求次数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;buffer.memory控制的是总的buffer内存数量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;key.serializer&lt;/code&gt; 和 &lt;code&gt;value.serializer表示怎样将key和value对象转成字节&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从kafka 0.11开始，KafkaProducer支持两种模型：the idempotent producer and the transactional producer（幂等producer和事务producer）。幂等producer强调的是至少一次精确的投递。事务producer允许应用程序原子的发送消息到多个分区或者主题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了启用幂等性，必须将enable.idempotence这个配置的值设为true。如果你这样设置了，那么retries默认是Integer.MAX_VALUE，并且acks默认是all。为了利用幂等producer的优势，请避免应用程序级别的重新发送。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了使用事务producer，你必须配置transactional.id。如果transactional.id被设置，幂等性自动被启用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Properties props = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; props.put(&quot;bootstrap.servers&quot;, &quot;192.168.1.128:9092&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; props.put(&quot;transactional.id&quot;, &quot;my-transactional-id&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; Producer&amp;lt;String, String&amp;gt; producer = &lt;span&gt;new&lt;/span&gt; KafkaProducer&amp;lt;String, String&amp;gt;(props, &lt;span&gt;new&lt;/span&gt; StringSerializer(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringSerializer());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;producer.initTransactions();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    producer.beginTransaction();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 11; i &amp;lt; 20; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         producer.send(&lt;span&gt;new&lt;/span&gt; ProducerRecord&amp;lt;String, String&amp;gt;(&quot;bar&quot;&lt;span&gt;, Integer.toString(i), Integer.toString(i)));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   This method will flush any unsent records before actually committing the transaction&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    producer.commitTransaction();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt; (ProducerFencedException | OutOfOrderSequenceException |&lt;span&gt; AuthorizationException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    producer.close();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (KafkaException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  By calling producer.abortTransaction() upon receiving a KafkaException we can ensure
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  that any successful writes are marked as aborted, hence keeping the transactional guarantees.&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    producer.abortTransaction();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; producer.close();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;org.apache.kafka.clients.consumer.KafkaConsumer&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Offsets and Consumer Position&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于分区中的每条记录，kafka维护一个数值偏移量。这个偏移量是分区中一条记录的唯一标识，同时也是消费者在分区中的位置。例如，一个消费者在分区中的位置是5，表示它已经消费了偏移量从0到4的记录，并且接下来它将消费偏移量为5的记录。相对于消费者用户来说，这里实际上有两个位置的概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消费者的position表示下一条将要消费的记录的offset。每次消费者通过调用poll(long)接收消息的时候这个position会自动增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;committed position表示已经被存储的最后一个偏移量。消费者可以自动的周期性提交offsets，也可以通过调用提交API(e.g. &lt;a href=&quot;http://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#commitSync--&quot;&gt;&lt;code&gt;commitSync&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://kafka.apache.org/10/javadoc/org/apache/kafka/clients/consumer/KafkaConsumer.html#commitAsync-org.apache.kafka.clients.consumer.OffsetCommitCallback-&quot;&gt;&lt;code&gt;commitAsync&lt;/code&gt;&lt;/a&gt;)手动的提交position。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Consumer Groups and Topic Subscriptions &lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Kafka用&quot;consumer groups&quot;（消费者组）的概念来允许一组进程分开处理和消费记录。这些处理在同一个机器上进行，也可以在不同的机器上。同一个消费者组中的消费者实例有相同的group.id&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组中的每个消费者可以动态设置它们想要订阅的主题列表。Kafka给每个订阅的消费者组都投递一份消息。这归功于消费者组中所有成员之间的均衡分区，以至于每个分区都可以被指定到组中精确的一个消费者。假设一个主题有4个分区，一个组中有2个消费者，那么每个消费者将处理2个分区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;消费者组中的成员是动态维护的：如果一个消费者处理失败了，那么分配给它的分区将会被重新分给组中其它消费者。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在概念上，你可以把一个消费者组想象成一个单个的逻辑订阅者，并且每个逻辑订阅者由多个进程组成。作为一个多订阅系统，Kafka天生就支持对于给定的主题可以有任意数量的消费者组。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;Automatic Offset Committing&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Properties props = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; props.put(&quot;bootstrap.servers&quot;, &quot;192.168.1.128:9092&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; props.put(&quot;group.id&quot;, &quot;test&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; KafkaConsumer&amp;lt;String, String&amp;gt; consumer = &lt;span&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;String, String&amp;gt;&lt;span&gt;(props);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; consumer.subscribe(Arrays.asList(&quot;foo&quot;, &quot;bar&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt;&lt;span&gt; record : records) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;&lt;span&gt;, record.offset(), record.key(), record.value());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;设置enable.auto.commit意味着自动提交已消费的记录的offset&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Manual Offset Control&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;代替消费者周期性的提交已消费的offsets，用户可以控制什么时候记录被认为是已经消费并提交它们的offsets。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Properties props = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; props.put(&quot;group.id&quot;, &quot;test&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; props.put(&quot;enable.auto.commit&quot;, &quot;false&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; KafkaConsumer&amp;lt;String, String&amp;gt; consumer = &lt;span&gt;new&lt;/span&gt; KafkaConsumer&amp;lt;&amp;gt;&lt;span&gt;(props);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; consumer.subscribe(Arrays.asList(&quot;foo&quot;, &quot;bar&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minBatchSize = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; List&amp;lt;ConsumerRecord&amp;lt;String, String&amp;gt;&amp;gt; buffer = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;String, String&amp;gt;&lt;span&gt; record : records) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        buffer.add(record);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (buffer.size() &amp;gt;=&lt;span&gt; minBatchSize) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        insertIntoDb(buffer);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        consumer.commitSync();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        buffer.clear();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;代码演示&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;服务器端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180210144546123-1208240530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180210144626232-1806423633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180210144637045-736639914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180210144645482-1002229934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180210144654138-1199387439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201802/874963-20180210144706982-1503296570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://kafka.apache.org/10/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://kafka.apache.org/10/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 10 Feb 2018 06:50:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/8438750.html</dc:identifier>
</item>
<item>
<title>数据类型转换 - BluesQian</title>
<link>http://www.cnblogs.com/QianBoy/p/8438735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianBoy/p/8438735.html</guid>
<description>&lt;p&gt;JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; x = y ? 1 : 'a';
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，变量&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;到底是数值还是字符串，取决于另一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;时，&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;是一个数值；&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;时，&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;是一个字符串。这意味着，&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;的类型没法在编译阶段就知道，必须等到运行时才能知道。&lt;/p&gt;
&lt;p&gt;虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，&lt;strong&gt;&lt;span&gt;减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
'4' - '3' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中，虽然是两个字符串相减，但是依然会得到结果数值&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;，原因就在于 JavaScript 将运算子自动转为了数值。&lt;/p&gt;
&lt;p&gt;本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型。&lt;/p&gt;
&lt;h2 id=&quot;强制转换&quot;&gt;强制转换&lt;/h2&gt;
&lt;p&gt;强制转换主要指使用&lt;strong&gt;&lt;span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;和&lt;span&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。&lt;/p&gt;
&lt;h3 id=&quot;number&quot;&gt;Number()&lt;/h3&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;函数，可以将任意类型的值转化成数值。&lt;/p&gt;
&lt;p&gt;下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）原始类型值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原始类型值的转换规则如下。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数值：转换后还是原来的值&lt;/span&gt;
Number(324) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 324&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符串：如果可以被解析为数值，则转换为相应的数值&lt;/span&gt;
Number('324') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 324&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符串：如果不可以被解析为数值，返回 NaN&lt;/span&gt;
Number('324abc') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空字符串转为0&lt;/span&gt;
Number('') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 布尔值：true 转成 1，false 转成 0&lt;/span&gt;
Number(&lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
Number(&lt;span&gt;false&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined：转成 NaN&lt;/span&gt;
Number(undefined) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; null：转成0&lt;/span&gt;
Number(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;函数将字符串转为数值，要比&lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt&lt;/code&gt;函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为&lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
parseInt('42 cats') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;
Number('42 cats') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，&lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt&lt;/code&gt;逐个解析字符，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;函数整体转换字符串的类型。&lt;/p&gt;
&lt;p&gt;另外，&lt;code class=&quot;highlighter-rouge&quot;&gt;parseInt&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;函数都会自动过滤一个字符串前导和后缀的空格。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
parseInt('\t\v\r12.34\n') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;
Number('\t\v\r12.34\n') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12.34&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（2）对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的规则是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;方法的参数是&lt;span&gt;对象时，将返回&lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;&lt;/span&gt;，除非是包含单个&lt;span&gt;数值的数组&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Number({a: 1}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
Number([1, 2, 3]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
Number([5]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以会这样，是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;背后的转换规则比较复杂。&lt;/p&gt;
&lt;h3 id=&quot;string&quot;&gt;String()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;函数可以将任意类型的值转化成字符串，转换规则如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）原始类型值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    数值：转为相应的字符串。
    字符串：转换后还是原来的值。
    布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;。
    undefined：转为字符串&quot;undefined&quot;。
    null：转为字符串&quot;null&quot;。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
String(123) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;123&quot;&lt;/span&gt;
String('abc') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;abc&quot;&lt;/span&gt;
String(&lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;true&quot;&lt;/span&gt;
String(undefined) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;undefined&quot;&lt;/span&gt;
String(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;null&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（2）对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
String({a: 1}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;[object Object]&quot;&lt;/span&gt;
String([1, 2, 3]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;1,2,3&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;boolean&quot;&gt;Boolean()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;函数可以将任意类型的值转为布尔值。&lt;/p&gt;
&lt;p&gt;它的转换规则相对简单：除了以下五个值的转换结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，其他的值全部为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Boolean(undefined) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
Boolean(&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
Boolean(0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
Boolean(NaN) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
Boolean('') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，所有对象（包括空对象）的转换结果都是&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，甚至连&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;对应的布尔对象&lt;code class=&quot;highlighter-rouge&quot;&gt;new Boolean(false)&lt;/code&gt;也是&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Boolean({}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
Boolean([]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
Boolean(&lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;false&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有对象的布尔值都是&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，这是因为 JavaScript 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;obj1 &amp;amp;&amp;amp; obj2&lt;/code&gt;这样的场景，可能会需要较多的计算。为了保证性能，就统一规定，对象的布尔值为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;自动转换&quot;&gt;自动转换&lt;/h2&gt;
&lt;p&gt;下面介绍自动转换，它是以强制转换为基础的。&lt;/p&gt;
&lt;p&gt;遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一种情况，不同类型的数据互相运算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
123 + 'abc' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;123abc&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二种情况，对非布尔值类型的数据求布尔值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;div class=&quot;language-javascript highlighter-rouge&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;
&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'abc'&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;{
  &lt;span class=&quot;nx&quot;&gt;console&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;log&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;s1&quot;&gt;'hello'&lt;span class=&quot;p&quot;&gt;)
&lt;span class=&quot;p&quot;&gt;}  &lt;span class=&quot;c1&quot;&gt;// &quot;hello&quot;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三种情况，对非数值类型的值使用一元运算符（即&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
+ {foo: 'bar'} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
- [1, 2, 3] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。&lt;/p&gt;
&lt;p&gt;由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;函数进行显式转换。&lt;/p&gt;
&lt;h3 id=&quot;自动转换为布尔值&quot;&gt;自动转换为布尔值&lt;/h3&gt;
&lt;p&gt;JavaScript 遇到预期为布尔值的地方（比如&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;因此除了以下五个值，其他都是自动转为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;undefined
  &lt;/span&gt;&amp;amp;&amp;amp; !&lt;span&gt;null&lt;/span&gt;
  &amp;amp;&amp;amp; !0
  &amp;amp;&amp;amp; !&lt;span&gt;NaN
  &lt;/span&gt;&amp;amp;&amp;amp; !''&lt;span&gt;
) {
  console.log(&lt;/span&gt;'true'&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;自动转换为字符串&quot;&gt;自动转换为字符串&lt;/h3&gt;
&lt;p&gt;JavaScript 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。&lt;/p&gt;
&lt;p&gt;字符串的自动转换，&lt;span&gt;&lt;strong&gt;主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
'5' + 1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '51'&lt;/span&gt;
'5' + &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5true&quot;&lt;/span&gt;
'5' + &lt;span&gt;false&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5false&quot;&lt;/span&gt;
'5' + {} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5[object Object]&quot;&lt;/span&gt;
'5' + [] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5&quot;&lt;/span&gt;
'5' + &lt;span&gt;function&lt;/span&gt; (){} &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5function (){}&quot;&lt;/span&gt;
'5' + undefined &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5undefined&quot;&lt;/span&gt;
'5' + &lt;span&gt;null&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;5null&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种自动转换很容易出错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
  width: &lt;/span&gt;'100'&lt;span&gt;
};

obj.width &lt;/span&gt;+ 20 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;10020&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，开发者可能期望返回&lt;code class=&quot;highlighter-rouge&quot;&gt;120&lt;/code&gt;，但是由于自动转换，实际上返回了一个字符&lt;code class=&quot;highlighter-rouge&quot;&gt;10020&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自动转换为数值&quot;&gt;自动转换为数值&lt;/h3&gt;
&lt;p&gt;JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Number&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;除了加法运算符（&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
'5' - '2' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
'5' * '2' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;
&lt;span&gt;true&lt;/span&gt; - 1  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt; - 1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1&lt;/span&gt;
'1' - 1   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
'5' * []    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;span&gt;false&lt;/span&gt; / '5' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
'abc' - 1   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
&lt;span&gt;null&lt;/span&gt; + 1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
undefined + 1 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;转为数值时为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;转为数值时为&lt;code class=&quot;highlighter-rouge&quot;&gt;NaN&lt;/code&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一元运算符也会把运算子转成数值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
+'abc' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
-'abc' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; NaN&lt;/span&gt;
+&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
-&lt;span&gt;false&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 10 Feb 2018 06:44:00 +0000</pubDate>
<dc:creator>BluesQian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianBoy/p/8438735.html</dc:identifier>
</item>
<item>
<title>Python装饰器 - 小兵千睿</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/8435074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/8435074.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　Python装饰器的作用是使函数包装和方法包装变得更容易阅读和理解，最常见的就是@staticmethod和@classmethod，下面将从装饰器的表现形式和常用装饰器模式两方面进行描述和总结，若有不正确之处望大家指出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1. 函数装饰器&lt;/h2&gt;
&lt;p&gt;　　编写自定义装饰器有许多方法，但最简单的方法是编写一个函数，返回包装原始函数调用的一个子函数&lt;/p&gt;
&lt;h2&gt;　　例1：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; debug(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*agrs, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;包装函数内部文档&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt; 
        &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[DEBUG]:enter %s()--%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(func.&lt;span&gt;__name__&lt;/span&gt;, *&lt;span&gt;agrs))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*agrs, **&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper&lt;br/&gt;@debug
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_hello(parm):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt; 提供函数文档字符串&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;say_hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    say_hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原始函数名：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数文档字符串：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__doc__&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; [DEBUG]:enter say_hello()--Python&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 原始函数名：wrapper&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 函数文档字符串：包装函数内部文档&lt;/p&gt;
&lt;h2&gt;　　例2：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; wraps

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; debug(func):
    @wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*agrs, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;包装函数内部文档&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt; 
        &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[DEBUG]:enter %s()--%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(func.&lt;span&gt;__name__&lt;/span&gt;, *&lt;span&gt;agrs))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*agrs, **&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

@debug
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_hello(parm):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt; 提供函数文档字符串&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;say_hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    say_hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原始函数名：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数文档字符串：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__doc__&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; [DEBUG]:enter say_hello()--Python&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 原始函数名：say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 函数文档字符串： 提供函数文档字符串&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意例1与例2的区别，也是使用装饰器的常用错误，在使用装饰器时不保存函数元数据（文档字符串和原始函数名）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. 类装饰器&lt;/h2&gt;
&lt;p&gt;　　虽然装饰器几乎总是可以用函数来实现，但如果装饰器需要复杂的参数化或者依赖特定状态的话，使用自定义类进行封装可能会更好&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; wraps

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; debug:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, func):
        self.func &lt;/span&gt;=&lt;span&gt; func

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *argv, **&lt;span&gt;kwargv):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;包装函数内部文档&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[DEBUG]:enter %s()--%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(self.func.&lt;span&gt;__name__&lt;/span&gt;, *&lt;span&gt;argv))
        self.func(&lt;/span&gt;*argv, **&lt;span&gt;kwargv)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_hello(something):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt; 提供函数文档字符串 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;say_hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, something)
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    De &lt;/span&gt;=&lt;span&gt; debug(say_hello)
    De(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原始函数名：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数文档字符串：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__doc__&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; [DEBUG]:enter say_hello()--Python&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; say_hello Python&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 原始函数名：say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 函数文档字符串： 提供函数文档字符串&lt;/p&gt;
&lt;h2&gt;3. 参数化装饰器&lt;/h2&gt;
&lt;p&gt;　　在实际代码中通常需要使用参数化的装饰器，比如次数、类型判断等，下面是一个简单的装饰器示例，给定重复次数，每次被调用时都会重复执行被装饰函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; wraps

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;参数化装饰器&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; repeat(number=3&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; debug(func):
        @wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*argv, **&lt;span&gt;kwargv):
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;包装函数内部文档&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(number):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[DUBEG]:enter %s()--%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(func.&lt;span&gt;__name__&lt;/span&gt;, *&lt;span&gt;argv))
                result &lt;/span&gt;= func(*argv, **&lt;span&gt;kwargv)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; debug    

@repeat(&lt;/span&gt;2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; say_hello(*agrv, **&lt;span&gt;kwargv):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;提供函数文档字符串&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;say_hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:  
    say_hello(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原始函数名：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;函数文档字符串：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %(say_hello.&lt;span&gt;__doc__&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; [DUBEG]:enter say_hello()--Python&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; [DUBEG]:enter say_hello()--Python&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 原始函数名：say_hello&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 函数文档字符串：提供函数文档字符串&lt;/p&gt;

&lt;h2&gt;1. 参数检查&lt;/h2&gt;
&lt;p&gt;　　将函数注册到全局字典中，并将其参数和返回值保存在一个类型列表中，并对参数类型进行检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;将函数注册到全局字典中，并将其参数和返回值保存在一个类型列表中&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

funname &lt;/span&gt;=&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; parmcheck(in_= (type(None),), out_ =&lt;span&gt;(type(None), )):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun1(func):
        func_name &lt;/span&gt;= func.&lt;span&gt;__name__&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;funname:%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(func_name))
        funname[func.&lt;/span&gt;&lt;span&gt;__name__&lt;/span&gt;] =&lt;span&gt; (in_, out_)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; checkType(elements, types):
            &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;用来检查参数类型的子函数&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; len(elements) !=&lt;span&gt; len(types):
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Parm count is wrong!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            li &lt;/span&gt;=&lt;span&gt; zip(elements, types)
            typed &lt;/span&gt;=&lt;span&gt; enumerate(li)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; index,couple &lt;span&gt;in&lt;/span&gt;&lt;span&gt; typed:
                argv, intype &lt;/span&gt;=&lt;span&gt; couple
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(argv, intype):
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parm(%s) and type(%s)are all right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(argv, intype))
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
                &lt;span&gt;raise&lt;/span&gt; TypeError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;argv %d should be %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(argv, intype))    
                
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; decoratorfun(*&lt;span&gt;argv):
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;types = [type(i) for i in range(len(argv))]&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;checkType(argv, types)&lt;/span&gt;
&lt;span&gt;            checkType(argv, in_)
            res &lt;/span&gt;= func(*&lt;span&gt;argv)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;检查输出内容&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; type(res) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; (tuple, list):
                checkable_res &lt;/span&gt;=&lt;span&gt; (res, )
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                checkable_res &lt;/span&gt;=&lt;span&gt; res
            checkType(checkable_res, out_)    
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decoratorfun
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fun1    
             
@parmcheck((int,int)) 
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; meth1(a,b):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;received:%d,%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(a, b))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    meth1(&lt;/span&gt;1,2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (funname)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; funname:meth1&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; parm(1) and type(&amp;lt;class 'int'&amp;gt;)are all right&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; parm(2) and type(&amp;lt;class 'int'&amp;gt;)are all right&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; received:1,2&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; parm(None) and type(&amp;lt;class 'NoneType'&amp;gt;)are all right&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; {'meth1': ((&amp;lt;class 'int'&amp;gt;, &amp;lt;class 'int'&amp;gt;), (&amp;lt;class 'NoneType'&amp;gt;,))}&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意zip、enumerate、解包、isinstance方法的使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2. 缓存&lt;/h2&gt;
&lt;p&gt;　　缓存装饰器与参数检查十分相似，它的重点是关注那些内部状态不会影响输出的函数，每组参数都可以连接到唯一的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding = utf-8&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; hashlib

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;全局字典&lt;/span&gt;
cache =&lt;span&gt; {}

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; is_obsolete(entry, duration):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (time.time() - entry[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; time.time() - entry[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &amp;gt;&lt;span&gt; duration

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; compute_key(func, *argv, **&lt;span&gt;kwargv):
    key &lt;/span&gt;= pickle.dumps((func.&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;, argv, kwargv))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashlib.sha1(key).hexdigest()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; memoize(duration=10&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _memoize(func):
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__memoize&lt;/span&gt;(*argv, **&lt;span&gt;kwargv):
            key &lt;/span&gt;= compute_key(func,*argv, **&lt;span&gt;kwargv)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((key &lt;span&gt;in&lt;/span&gt; cache) &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; is_obsolete(cache[key], duration)):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;we got a winner&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cache[key][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]    
            result &lt;/span&gt;= func(*argv, **&lt;span&gt;kwargv)
            cache[key]&lt;/span&gt;={&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:result,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:time.time()}
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;__memoize&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _memoize    

@memoize(&lt;/span&gt;3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(a,b):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (a+&lt;span&gt;b)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    fun(&lt;/span&gt;2,3&lt;span&gt;)
    fun(&lt;/span&gt;2,2&lt;span&gt;)
    fun(&lt;/span&gt;2,3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; (cache)
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; 5&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 4&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 0.0&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; we got a winner&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; {'a99634a4e619a2ad129df1b51002a8c0cb9cca2b': {'value': 5, 'time': 1518243058.456&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 425}, '99683ddc4e22fd3f37e473de5d61699a5c27c2c6': {'value': 4, 'time': 151824305&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; 8.456425}}&lt;/p&gt;
&lt;h2&gt;3. 代理&lt;/h2&gt;
&lt;p&gt;　　代理装饰器使用全局机制来标记和注册函数。比如一个根据当前用户来保护代码访问的安全层可以使用集中式检查器和相关的可调用对象要求的权限来访问，这一模型常用于Python Web框架中，用于定义法布类的安全性&lt;/p&gt;
&lt;h2&gt;4. 上下文提供者&lt;/h2&gt;
&lt;p&gt; 　　上下文装饰器确保函数可以允许在正确的上下文中，比如临界资源的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; threading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RLock

lock &lt;/span&gt;=&lt;span&gt; RLock()

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; synchronized(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; _synchronized(*argv, **&lt;span&gt;kdargv):
        lock.require()
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*argv, **&lt;span&gt;kdargv)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fun error!!!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            lock.release()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _synchronized    
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上下文装饰器通常会被上下文管理器with语句代替&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 10 Feb 2018 06:35:00 +0000</pubDate>
<dc:creator>小兵千睿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobingqianrui/p/8435074.html</dc:identifier>
</item>
<item>
<title>17年年终总结——走过2017，迎来2018Flag - PC.aaron</title>
<link>http://www.cnblogs.com/aaron-pan/p/8438440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron-pan/p/8438440.html</guid>
<description>&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;　　记得大概从大学毕业到现在都没有写作啥总结性的文章了（ps：应该是没写过啥长篇大论了），所以也不知道怎么个起头。我也闲聊的方式起头吧。&lt;/p&gt;
&lt;p&gt;　　其实跨入18年就想着写篇总结，总结下自己17年的得与失，不足和需要进步的地方。但是由于各种原因，年底项目上比较忙加之广州天气忒冷等，迟迟没有着手。直到今天，哈哈哈，年前的最后一天班，所以也比较有空，于是做下总结。这篇文章也应该是年前的最后一篇了，喜欢的就给个赞吧~~~&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;p&gt;　　回顾下16年，好吧，说起自己也不想回顾，交代下背景，16年，在一家人力资源类型的公司（ps：可以说是准上市公司）任职前端开发，公司之前的流程也是走的线下业务，15年左右时逢“互联网+”时代，所以就尝试把线下业务迁移到线上，所以就新建了技术部。由于新建的技术部，然后当时前端也是刚开始火了，所以就有了我们专职前端的事了。&lt;/p&gt;
&lt;p&gt;　　也可能正如直到所认知的后台开发表现出来的吧，后台开发基本对 CSS 和 HTML 无感，所以在公司开发也比较倾向于基于DIV+CSS 实现静态页面，然后也加之自己本身从事前端工作并不久，大概也是15年九月份左右从事的前端开发，所以在技术上只能说是菜鸟，当然，现在也是菜鸟。当时在技术上的应用也是 DIV+CSS 实现静态页面，jquery实现业务逻辑，部分活动页面之类的使用原生JavaScript实现这样，可以说应用的技术栈是相当的单一。当然，可怕的不只是这样，可怕的是自己在那段时间成长得相当缓慢，也就可能由于当时的项目是从零着手的，所以在处理业务逻辑上是得到了很大的提升。感觉除了这个好像基本是没有啥成长的，对了，顺带还吐槽下，当时公司加班还挺厉害的，当然，更大的原因是当时自己对外界的了解太少了，就以为能靠 jquery行走天下。所以16年给自己没有留下点什么。&lt;/p&gt;
&lt;h2&gt;成长&lt;/h2&gt;
&lt;p&gt;　　16年年底，由于公司战略性的调整和自己对自己的反思，所以正式离职了，踏入了找工作的队列。&lt;/p&gt;
&lt;p&gt;　　正式投简历面试的时候其实已经快到过年那段时间了，前前后后也面试了几家公司，当然，由于薪资待遇等条件自己不满意和公司看不上我等原因，所以年前我也没能入职哪家公司，所以我也顺应的很早的回家放大假去了。当然，回家的那段时间我也没有松懈，总结了下面试上的问题并加紧的补充了下自己的短板。其实回想下，面试上提的问题比较常见的就是性能优化，前端常用的算法还有就是JS基础。可能也是由于之前都是“一把梭”，所以其实对于一些JS基础只记得印象而没有概念所以是有些面试被否的比较大的原因，所以年前接近两个月时间我基本都在恶补下自己的基础和实现些小demo。&lt;/p&gt;
&lt;p&gt;　　过渡到放完大假又回来找工作的现实，好吧，那就找咯。多谢了之前自己那段时间的恶补基础，所以后面的面试自己底气还是挺足的，但是还是没能很快的入职到自己期待的公司。其实印象比较深的就是面试了家偏技术的大公司（ps：应该是属于一线互联网公司了：公司前端分了几个大组并有50左右的前端开发人员（面试官描述）），也是我面试了这么久最期待进入的其中一家。回想下和面试官聊得还是很愉快的，大概就分了两轮面试：笔试+面试，最终失败的原因就是面试官说的，还是欠缺点沉淀。所以，我开始着手写技术博客的导火线也是这次深刻的面试了。&lt;/p&gt;
&lt;p&gt;　　之后没多久我就面试上了现在这家公司。公司规模还是挺大的吧，算中型，由于按照项目分组的原因，也有几个前端，但是我所在的项目组就我一个咯，所以得一个人打拼。也是由于之前比较深刻的面试历程，所以我也开始着手自己的成长：&lt;/p&gt;
&lt;p&gt;　　1.开通了自己的博客并尽量的坚持每月至少发一篇博客来总结自己的技术成长和项目上遇到的难点。&lt;/p&gt;
&lt;p&gt;　　2.通读了《JavaScript高级程序设计(第3版)》、《Vue2实践揭秘》、《深入浅出Node.js》等书籍。&lt;/p&gt;
&lt;p&gt;　　3.活跃于segmentfault，Stack Overflow，GitHub，博客园等社区和前端大佬们的博客。&lt;/p&gt;
&lt;p&gt;　　4.机缘巧合的参加了&lt;a href=&quot;https://github.com/justjavac&quot; target=&quot;_blank&quot;&gt;justjavac&lt;/a&gt;大大的一个live，并加入了大佬们的微信群和大佬“谈笑风生”。（ps：群里有&lt;a href=&quot;https://github.com/i5ting&quot; target=&quot;_blank&quot;&gt;狼叔&lt;/a&gt;，&lt;a href=&quot;https://github.com/yanhaijing&quot; target=&quot;_blank&quot;&gt;颜海镜&lt;/a&gt;等前端半壁江山，哈哈哈）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141454/201802/1141454-20180210133420326-1543740125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　5.参与掘金翻译计划并翻译校对多篇前端技术文章。&lt;/p&gt;
&lt;p&gt;　　6.受邀参与原创博客技术评选并获取奖励。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1141454/201802/1141454-20180210133722654-1466204233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7.出游放松：去惠州和珠海游玩了圈&lt;/p&gt;
&lt;p&gt;　　等等之类的技术和个人视野的成长。&lt;/p&gt;
&lt;p&gt;　　总结了下，17年相比于16年确实成长了挺多，例如进行了项目的重构，运用了bootstrap，easyui，vue，gulp等技术进行符合项目实际的构建和优化。但是就技术上个人觉得还是有许多的不足，像webpack配置，PWA等的了解也不深，还有实践node.js项目也是我17年的目标都还是没有完成到。自勉啊~~~&lt;/p&gt;
&lt;h2&gt;展望2018&lt;/h2&gt;
&lt;p&gt;　　17年已经过去了，就需要为18年定下小目标。&lt;/p&gt;
&lt;p&gt;　　在此，就为自己立个flag，也激励自己完成：&lt;/p&gt;
&lt;p&gt;　　1.坚持博客更新。&lt;/p&gt;
&lt;p&gt;　　2.把健身安排落实。毕竟身体是革命的本钱啊，坚持至少一周锻炼三四次以上。&lt;/p&gt;
&lt;p&gt;　　3.实践node.js项目。&lt;/p&gt;
&lt;p&gt;　　4.坚持阅读扎实技术。&lt;/p&gt;
&lt;p&gt;　　5.国内游三次，国外游一次。也希望自己得到放松&lt;/p&gt;
&lt;p&gt;　　......&lt;/p&gt;
&lt;p&gt;　　更多的小目标也希望能在2018年落实。fighting~~~&lt;/p&gt;





</description>
<pubDate>Sat, 10 Feb 2018 06:01:00 +0000</pubDate>
<dc:creator>PC.aaron</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron-pan/p/8438440.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——31.使用限定通配符来增加API的灵活性 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8438610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8438610.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如条目 28所述，参数化类型是不变的。换句话说，对于任何两个不同类型的&lt;code&gt;Type1&lt;/code&gt;和&lt;code&gt;Type&lt;/code&gt;，&lt;code&gt;List &amp;lt;Type1&amp;gt;&lt;/code&gt;既不是&lt;code&gt;List &amp;lt;Type2&amp;gt;&lt;/code&gt;子类型也不是其父类型。尽管&lt;code&gt;List &amp;lt;String&amp;gt;&lt;/code&gt;不是&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;的子类型是违反直觉的，但它确实是有道理的。 可以将任何对象放入&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;中，但是只能将字符串放入&lt;code&gt;List &amp;lt;String&amp;gt;&lt;/code&gt;中。 由于&lt;code&gt;List &amp;lt;String&amp;gt;&lt;/code&gt;不能做&lt;code&gt;List &amp;lt;Object&amp;gt;&lt;/code&gt;所能做的所有事情，所以它不是一个子类型（条目 10 中的里氏替代原则）。&lt;/p&gt;
&lt;p&gt;相对于提供的不可变的类型，有时你需要比此更多的灵活性。 考虑条目 29中的&lt;code&gt;Stack&lt;/code&gt;类。下面是它的公共API：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Stack&amp;lt;E&amp;gt; {

    public Stack();

    public void push(E e);

    public E pop();

    public boolean isEmpty();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们想要添加一个方法来获取一系列元素，并将它们全部推送到栈上。 以下是第一种尝试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// pushAll method without wildcard type - deficient!

public void pushAll(Iterable&amp;lt;E&amp;gt; src) {
    for (E e : src)
        push(e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法可以干净地编译，但不完全令人满意。 如果可遍历的&lt;code&gt;src&lt;/code&gt;元素类型与栈的元素类型完全匹配，那么它工作正常。 但是，假设有一个&lt;code&gt;Stack &amp;lt;Number&amp;gt;&lt;/code&gt;，并调用&lt;code&gt;push(intVal)&lt;/code&gt;，其中&lt;code&gt;intVal&lt;/code&gt;的类型是&lt;code&gt;Integer&lt;/code&gt;。 这是因为&lt;code&gt;Integer&lt;/code&gt;是&lt;code&gt;Number&lt;/code&gt;的子类型。 从逻辑上看，这似乎也应该起作用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;&amp;gt;();

Iterable&amp;lt;Integer&amp;gt; integers = ... ;

numberStack.pushAll(integers);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果你尝试了，会得到这个错误消息，因为参数化类型是不变的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;StackTest.java:7: error: incompatible types: Iterable&amp;lt;Integer&amp;gt;

cannot be converted to Iterable&amp;lt;Number&amp;gt;

        numberStack.pushAll(integers);

                            ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;幸运的是，有对应的解决方法。 该语言提供了一种特殊的参数化类型来调用一个限定通配符类型来处理这种情况。 &lt;code&gt;pushAll&lt;/code&gt;的输入参数的类型不应该是“E的Iterable接口”，而应该是“E的某个子类型的Iterable接口”，并且有一个通配符类型，这意味着：&lt;code&gt;Iterable &amp;lt;？ extends E&amp;gt;&lt;/code&gt;。 （关键字&lt;code&gt;extends&lt;/code&gt;的使用有点误导：回忆条目 29中，子类型被定义为每个类型都是它自己的子类型，即使它本身没有继承。）让我们修改&lt;code&gt;pushAll&lt;/code&gt;来使用这个类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Wildcard type for a parameter that serves as an E producer

public void pushAll(Iterable&amp;lt;? extends E&amp;gt; src) {
    for (E e : src)
        push(e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个改变，&lt;code&gt;Stack&lt;/code&gt;类不仅可以干净地编译，而且客户端代码也不会用原始的&lt;code&gt;pushAll&lt;/code&gt;声明编译。 因为&lt;code&gt;Stack&lt;/code&gt;和它的客户端干净地编译，你知道一切都是类型安全的。&lt;/p&gt;
&lt;p&gt;现在假设你想写一个&lt;code&gt;popAll&lt;/code&gt;方法，与&lt;code&gt;pushAll&lt;/code&gt;方法相对应。 &lt;code&gt;popAll&lt;/code&gt;方法从栈中弹出每个元素并将元素添加到给定的集合中。 以下是第一次尝试编写&lt;code&gt;popAll&lt;/code&gt;方法的过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// popAll method without wildcard type - deficient!

public void popAll(Collection&amp;lt;E&amp;gt; dst) {

    while (!isEmpty())

        dst.add(pop());

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，如果目标集合的元素类型与栈的元素类型完全匹配，则干净编译并且工作正常。 但是，这又不完全令人满意。 假设你有一个&lt;code&gt;Stack &amp;lt;Number&amp;gt;&lt;/code&gt;和&lt;code&gt;Object&lt;/code&gt;类型的变量。 如果从栈中弹出一个元素并将其存储在该变量中，它将编译并运行而不会出错。 所以你也不能这样做吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Stack&amp;lt;Number&amp;gt; numberStack = new Stack&amp;lt;Number&amp;gt;();

Collection&amp;lt;Object&amp;gt; objects = ... ;

numberStack.popAll(objects);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果尝试将此客户端代码与之前显示的&lt;code&gt;popAll&lt;/code&gt;版本进行编译，则会得到与我们的第一版&lt;code&gt;pushAll&lt;/code&gt;非常类似的错误：&lt;code&gt;Collection &amp;lt;Object&amp;gt;&lt;/code&gt;不是&lt;code&gt;Collection &amp;lt;Number&amp;gt;&lt;/code&gt;的子类型。 通配符类型再一次提供了一条出路。 &lt;code&gt;popAll&lt;/code&gt;的输入参数的类型不应该是“E的集合”，而应该是“E的某个父类型的集合”（其中父类型被定义为E是它自己的父类型[JLS，4.10]）。 再次，有一个通配符类型，正是这个意思：&lt;code&gt;Collection &amp;lt;？ super E&amp;gt;&lt;/code&gt;。 让我们修改&lt;code&gt;popAll&lt;/code&gt;来使用它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Wildcard type for parameter that serves as an E consumer

public void popAll(Collection&amp;lt;? super E&amp;gt; dst) {

    while (!isEmpty())

        dst.add(pop());

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个改动，Stack类和客户端代码都可以干净地编译。&lt;/p&gt;
&lt;p&gt;这个结论很清楚。 &lt;strong&gt;为了获得最大的灵活性，对代表生产者或消费者的输入参数使用通配符类型&lt;/strong&gt;。 如果一个输入参数既是一个生产者又是一个消费者，那么通配符类型对你没有好处：你需要一个精确的类型匹配，这就是没有任何通配符的情况。&lt;/p&gt;
&lt;p&gt;这里有一个助记符来帮助你记住使用哪种通配符类型：&lt;br/&gt;&lt;strong&gt;PECS代表： producer-extends，consumer-super。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话说，如果一个参数化类型代表一个&lt;code&gt;T&lt;/code&gt;生产者，使用&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;；如果它代表&lt;code&gt;T&lt;/code&gt;消费者，则使用&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;。 在我们的&lt;code&gt;Stack&lt;/code&gt;示例中，&lt;code&gt;pushAll&lt;/code&gt;方法的&lt;code&gt;src&lt;/code&gt;参数生成栈使用的&lt;code&gt;E&lt;/code&gt;实例，因此&lt;code&gt;src&lt;/code&gt;的合适类型为&lt;code&gt;Iterable&amp;lt;? extends E&amp;gt;&lt;/code&gt;；&lt;code&gt;popAll&lt;/code&gt;方法的&lt;code&gt;dst&lt;/code&gt;参数消费&lt;code&gt;Stack&lt;/code&gt;中的&lt;code&gt;E&lt;/code&gt;实例，因此&lt;code&gt;ds&lt;/code&gt;t的合适类型是&lt;code&gt;Collection &amp;lt;？ super E&amp;gt;&lt;/code&gt;。 PECS助记符抓住了使用通配符类型的基本原则。 Naftalin和Wadler称之为获取和放置原则（ Get and Put Principle ）[Naftalin07,2.4]。&lt;/p&gt;
&lt;p&gt;记住这个助记符之后，让我们来看看本章中以前项目的一些方法和构造方法声明。 条目 28中的&lt;code&gt;Chooser&lt;/code&gt;类构造方法有这样的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Chooser(Collection&amp;lt;T&amp;gt; choices)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个构造方法只使用集合选择来生产类型&lt;code&gt;T&lt;/code&gt;的值（并将它们存储起来以备后用），所以它的声明应该使用一个&lt;code&gt;extends T&lt;/code&gt;的通配符类型。下面是得到的构造方法声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Wildcard type for parameter that serves as an T producer

public Chooser(Collection&amp;lt;? extends T&amp;gt; choices)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种改变在实践中会有什么不同吗？ 是的，会有不同。 假你有一个&lt;code&gt;List &amp;lt;Integer&amp;gt;&lt;/code&gt;，并且想把它传递给&lt;code&gt;Chooser&amp;lt;Number&amp;gt;&lt;/code&gt;的构造方法。 这不会与原始声明一起编译，但是它只会将限定通配符类型添加到声明中。&lt;/p&gt;
&lt;p&gt;现在看看条目 30中的&lt;code&gt;union&lt;/code&gt;方法。下是声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;E&amp;gt; s1, Set&amp;lt;E&amp;gt; s2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个参数&lt;code&gt;s1&lt;/code&gt;和&lt;code&gt;s2&lt;/code&gt;都是&lt;code&gt;E&lt;/code&gt;的生产者，所以PECS助记符告诉我们该声明应该如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static &amp;lt;E&amp;gt; Set&amp;lt;E&amp;gt; union(Set&amp;lt;? extends E&amp;gt; s1,  Set&amp;lt;? extends E&amp;gt; s2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，返回类型仍然是&lt;code&gt;Set &amp;lt;E&amp;gt;&lt;/code&gt;。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外的灵活性，还强制他们在客户端代码中使用通配符类型。 通过修改后的声明，此代码将清晰地编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;Integer&amp;gt;  integers =  Set.of(1, 3, 5);

Set&amp;lt;Double&amp;gt;   doubles  =  Set.of(2.0, 4.0, 6.0);

Set&amp;lt;Number&amp;gt;   numbers  =  union(integers, doubles);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用得当，类的用户几乎不会看到通配符类型。 他们使方法接受他们应该接受的参数，拒绝他们应该拒绝的参数。 &lt;strong&gt;如果一个类的用户必须考虑通配符类型，那么它的API可能有问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java 8之前，类型推断规则不够聪明，无法处理先前的代码片段，这要求编译器使用上下文指定的返回类型（或目标类型）来推断&lt;code&gt;E&lt;/code&gt;的类型。&lt;code&gt;union&lt;/code&gt;方法调用的目标类型如前所示是&lt;code&gt;Set &amp;lt;Number&amp;gt;&lt;/code&gt;。 如果尝试在早期版本的Java中编译片段（以及适合的&lt;code&gt;Set.of&lt;/code&gt;工厂替代版本），将会看到如此长的错综复杂的错误消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Union.java:14: error: incompatible types

        Set&amp;lt;Number&amp;gt; numbers = union(integers, doubles);

                                   ^

  required: Set&amp;lt;Number&amp;gt;

  found:    Set&amp;lt;INT#1&amp;gt;

  where INT#1,INT#2 are intersection types:

    INT#1 extends Number,Comparable&amp;lt;? extends INT#2&amp;gt;

    INT#2 extends Number,Comparable&amp;lt;?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;幸运的是有办法来处理这种错误。 如果编译器不能推断出正确的类型，你可以随时告诉它使用什么类型的显式类型参数[JLS，15.12]。 甚至在Java 8中引入目标类型之前，这不是你必须经常做的事情，这很好，因为显式类型参数不是很漂亮。 通过添加显式类型参数，如下所示，代码片段在Java 8之前的版本中进行了干净编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Explicit type parameter - required prior to Java 8

Set&amp;lt;Number&amp;gt; numbers = Union.&amp;lt;Number&amp;gt;union(integers, doubles);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来让我们把注意力转向条目 30中的&lt;code&gt;max&lt;/code&gt;方法。这里是原始声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; T max(List&amp;lt;T&amp;gt; list)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是使用通配符类型的修改后的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static &amp;lt;T extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; T max(List&amp;lt;? extends T&amp;gt; list)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了从原来到修改后的声明，我们两次应用了PECS。首先直接的应用是参数列表。 它生成&lt;code&gt;T&lt;/code&gt;实例，所以将类型从&lt;code&gt;List &amp;lt;T&amp;gt;&lt;/code&gt;更改为&lt;code&gt;List&amp;lt;? extends T&amp;gt;&lt;/code&gt;。 棘手的应用是类型参数&lt;code&gt;T&lt;/code&gt;。这是我们第一次看到通配符应用于类型参数。 最初，&lt;code&gt;T&lt;/code&gt;被指定为继承&lt;code&gt;Comparable &amp;lt;T&amp;gt;&lt;/code&gt;，但&lt;code&gt;Comparable&lt;/code&gt;的&lt;code&gt;T&lt;/code&gt;消费&lt;code&gt;T&lt;/code&gt;实例（并生成指示顺序关系的整数）。 因此，参数化类型&lt;code&gt;Comparable &amp;lt;T&amp;gt;&lt;/code&gt;被替换为限定通配符类型&lt;code&gt;Comparable&amp;lt;? super T&amp;gt;&lt;/code&gt;。 &lt;code&gt;Comparable&lt;/code&gt;实例总是消费者，所以通常应该&lt;strong&gt;使用&lt;code&gt;Comparable&amp;lt;? super T&amp;gt;&lt;/code&gt;优于&lt;code&gt;Comparable &amp;lt;T&amp;gt;&lt;/code&gt;&lt;/strong&gt;。 &lt;code&gt;Comparator&lt;/code&gt;也是如此。因此，通常应该&lt;strong&gt;使用&lt;code&gt;Comparator&amp;lt;? super T&amp;gt;&lt;/code&gt;优于&lt;code&gt;Comparator&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;修改后的&lt;code&gt;max&lt;/code&gt;声明可能是本书中最复杂的方法声明。 增加的复杂性是否真的起作用了吗？ 同样，它的确如此。 这是一个列表的简单例子，它被原始声明排除，但在被修改后的版本里是允许的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;ScheduledFuture&amp;lt;?&amp;gt;&amp;gt; scheduledFutures = ... ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无法将原始方法声明应用于此列表的原因是&lt;code&gt;ScheduledFuture&lt;/code&gt;不实现&lt;code&gt;Comparable &amp;lt;ScheduledFuture&amp;gt;&lt;/code&gt;。 相反，它是&lt;code&gt;Delayed&lt;/code&gt;的子接口，它继承了&lt;code&gt;Comparable &amp;lt;Delayed&amp;gt;&lt;/code&gt;。 换句话说，一个&lt;code&gt;ScheduledFuture&lt;/code&gt;实例不仅仅和其他的&lt;code&gt;ScheduledFuture&lt;/code&gt;实例相比较： 它可以与任何&lt;code&gt;Delayed&lt;/code&gt;实例比较，并且足以导致原始的声明拒绝它。 更普遍地说，通配符要求来支持没有直接实现&lt;code&gt;Comparable&lt;/code&gt;（或&lt;code&gt;Comparator&lt;/code&gt;）的类型，但继承了一个类型。&lt;/p&gt;
&lt;p&gt;还有一个关于通配符相关的话题。 类型参数和通配符之间具有双重性，许多方法可以用一个或另一个声明。 例如，下面是两个可能的声明，用于交换列表中两个索引项目的静态方法。 第一个使用无限制类型参数（条目 30），第二个使用无限制通配符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Two possible declarations for the swap method

public static &amp;lt;E&amp;gt; void swap(List&amp;lt;E&amp;gt; list, int i, int j);

public static void swap(List&amp;lt;?&amp;gt; list, int i, int j);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个声明中的哪一个更可取，为什么？ 在公共API中，第二个更好，因为它更简单。 你传入一个列表（任何列表），该方法交换索引的元素。 没有类型参数需要担心。 通常，&lt;strong&gt;如果类型参数在方法声明中只出现一次，请将其替换为通配符&lt;/strong&gt;。 如果它是一个无限制的类型参数，请将其替换为无限制的通配符; 如果它是一个限定类型参数，则用限定通配符替换它。&lt;/p&gt;
&lt;p&gt;第二个&lt;code&gt;swap&lt;/code&gt;方法声明有一个问题。 这个简单的实现不会编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) {
    list.set(i, list.set(j, list.get(i)));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;试图编译它会产生这个不太有用的错误信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Swap.java:5: error: incompatible types: Object cannot be

converted to CAP#1

        list.set(i, list.set(j, list.get(i)));

                                        ^

  where CAP#1 is a fresh type-variable:

    CAP#1 extends Object from capture of ?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来我们不能把一个元素放回到我们刚刚拿出来的列表中。 问题是列表的类型是&lt;code&gt;List &amp;lt;？&amp;gt;&lt;/code&gt;，并且不能将除null外的任何值放入&lt;code&gt;List &amp;lt;？&amp;gt;&lt;/code&gt;中。 幸运的是，有一种方法可以在不使用不安全的转换或原始类型的情况下实现此方法。 这个想法是写一个私有辅助方法来捕捉通配符类型。 辅助方法必须是泛型方法才能捕获类型。 以下是它的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void swap(List&amp;lt;?&amp;gt; list, int i, int j) {

    swapHelper(list, i, j);

}

// Private helper method for wildcard capture

private static &amp;lt;E&amp;gt; void swapHelper(List&amp;lt;E&amp;gt; list, int i, int j) {

    list.set(i, list.set(j, list.get(i)));

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;swapHelper&lt;/code&gt;方法知道该列表是一个&lt;code&gt;List &amp;lt;E&amp;gt;&lt;/code&gt;。 因此，它知道从这个列表中获得的任何值都是E类型，并且可以安全地将任何类型的&lt;code&gt;E&lt;/code&gt;值放入列表中。 这个稍微复杂的&lt;code&gt;swap&lt;/code&gt;的实现可以干净地编译。 它允许我们导出基于通配符的漂亮声明，同时利用内部更复杂的泛型方法。 &lt;code&gt;swap&lt;/code&gt;方法的客户端不需要面对更复杂的&lt;code&gt;swapHelper&lt;/code&gt;声明，但他们从中受益。 辅助方法具有我们认为对公共方法来说过于复杂的签名。&lt;/p&gt;
&lt;p&gt;总之，在你的API中使用通配符类型，虽然棘手，但使得API更加灵活。 如果编写一个将被广泛使用的类库，正确使用通配符类型应该被认为是强制性的。 记住基本规则： producer-extends, consumer-super（PECS）。 还要记住，所有&lt;code&gt;Comparable&lt;/code&gt;和&lt;code&gt;Comparator&lt;/code&gt;都是消费者。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 05:49:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8438610.html</dc:identifier>
</item>
<item>
<title>GreenDao 兼容升级，保留旧数据的---全方面解决方案 - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/8438547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/8438547.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2179487179487&quot;&gt;
&lt;p&gt;腾讯云专栏： &lt;a href=&quot;https://cloud.tencent.com/developer/user/1148436/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/1148436/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;greendaocompatibleupdatehelper&quot;&gt;GreenDaoCompatibleUpdateHelper&lt;/h3&gt;
&lt;p&gt;一个能帮助你成功升级基于 greenDao 创建的数据库而不会丢失之前数据的工具&lt;br/&gt;A helper which can help you to update you database without lost your old datas, simple to use , enjoy.&lt;/p&gt;
&lt;h3 id=&quot;开源地址&quot;&gt;开源地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/af913337456/LghGreenDaoCompatibleUpdateHelper&quot;&gt;https://github.com/af913337456/LghGreenDaoCompatibleUpdateHelper&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;出问题的的情形&lt;/li&gt;
&lt;li&gt;几个事实&lt;/li&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;代码简述&lt;/li&gt;
&lt;li&gt;产品级别的可能错误&lt;/li&gt;
&lt;li&gt;你的顾虑&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;出问题的的情形&quot;&gt;出问题的的情形：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;字段添加，导致旧表格字段与新的不匹配引发 &lt;code&gt;android.database.sqlite.SQLiteException&lt;/code&gt; 类异常。&lt;/li&gt;
&lt;li&gt;服务端数据返回无法与就表格匹配，无法进行插入操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个情况会直接导致 APP 闪退掉，第二种就是数据不匹配。&lt;/p&gt;
&lt;h2 id=&quot;几个事实&quot;&gt;几个事实&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;GreenDao 目前的 3.+ 版，自动生成的代码的升级方式都是&lt;code&gt;先删除原来的表格，再创建新的&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** WARNING: Drops all table on Upgrade! Use only during development. */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DevOpenHelper &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; OpenHelper {
......
&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onUpgrade&lt;/span&gt;(Database db, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldVersion, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newVersion) {
    Log.&lt;span class=&quot;fu&quot;&gt;i&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;greenDAO&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Upgrading schema from version &quot;&lt;/span&gt; + oldVersion + &lt;span class=&quot;st&quot;&gt;&quot; to &quot;&lt;/span&gt; + newVersion + &lt;span class=&quot;st&quot;&gt;&quot; by dropping all tables&quot;&lt;/span&gt;);
    &lt;span class=&quot;fu&quot;&gt;dropAllTables&lt;/span&gt;(db, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// 删除-----①&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(db);
}
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;凡是自动生成的代码文件，例如 &lt;code&gt;xxxDao.java&lt;/code&gt; 类的，都会在每一次 build 的时候重新被生成，意味着个人的内嵌修改总是无效，因为总是覆盖你的。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据库的升级方式需求更多是需要往后兼容的，旧数据不能丢失&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;自定义升级策略。&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/13373170/greendao-schema-update-and-data-migration/30334668#30334668&quot;&gt;思路参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在上面的基础上做出如下步骤总结： (&lt;code&gt;看不懂的看下面的符号描述&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建之前旧表中不存在的新表&lt;/li&gt;
&lt;li&gt;创建中间表 &amp;amp; 把旧表的数据迁移到中间表&lt;/li&gt;
&lt;li&gt;把旧表全部删除&lt;/li&gt;
&lt;li&gt;创建所有新表&lt;/li&gt;
&lt;li&gt;把中间表的数据迁移到新表 &amp;amp; 删除中间表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应上面的步骤描述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A -&amp;gt; A + B , old: A , new: B&lt;/li&gt;
&lt;li&gt;use (A+B) -&amp;gt; create temp (A'+B') &amp;amp; insert data&lt;/li&gt;
&lt;li&gt;drop (A+B) , contain old datas&lt;/li&gt;
&lt;li&gt;create (A+B) , abs empty tables&lt;/li&gt;
&lt;li&gt;restore data to (A+B) from (A'+B') then drop (A'+B')&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代码简述&quot;&gt;代码简述&lt;/h2&gt;
&lt;p&gt;基于上面的二次修改和拓展&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;GreenDaoCompatibleUpdateHelper.java&lt;/code&gt; 顾名思义，兼容旧表性质的 greenDao 数据库升级，不会造成旧表的数据丢失&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拓展了最终的成功和失败的回调&lt;/li&gt;
&lt;li&gt;添加了错误日志的处理&lt;/li&gt;
&lt;li&gt;解决了字段名称的冲突 bug，例如 delete 之类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;MyGreenDaoDbHelper.java&lt;/code&gt; 自定义的 dbHelper，重载 onUpgrade&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;调用例子&quot;&gt;调用例子&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldVersion &amp;lt; newVersion) {
    Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;进行数据库升级&quot;&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;GreenDaoCompatibleUpdateHelper&lt;/span&gt;()
            .&lt;span class=&quot;fu&quot;&gt;setCallBack&lt;/span&gt;(
                    &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; GreenDaoCompatibleUpdateHelper.&lt;span class=&quot;fu&quot;&gt;GreenDaoCompatibleUpdateCallBack&lt;/span&gt;() {
                        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFinalSuccess&lt;/span&gt;() {
                            Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;进行数据库升级 ===&amp;gt; 成功&quot;&lt;/span&gt;);
                        }

                        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFailedLog&lt;/span&gt;(String errorMsg) {
                            Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;升级失败日志 ===&amp;gt; &quot;&lt;/span&gt;+errorMsg);
                        }
                    }
            )
            .&lt;span class=&quot;fu&quot;&gt;compatibleUpdate&lt;/span&gt;(
                    db,
                    PostBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                    MatterUserBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                    PropsBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                    ChannelChatsBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                    JoinToChannelReqBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;
            );
    Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;进行数据库升级--完成&quot;&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;greendaocompatibleupdatehelper-1&quot;&gt;GreenDaoCompatibleUpdateHelper&lt;/h5&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; GreenDaoCompatibleUpdateHelper {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; GreenDaoCompatibleUpdateCallBack{
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFinalSuccess&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFailedLog&lt;/span&gt;(String errorMsg);
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; GreenDaoCompatibleUpdateCallBack callBack;

    &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;all&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;compatibleUpdate&lt;/span&gt;(SQLiteDatabase sqliteDatabase, Class&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractDao&amp;lt;?, ?&amp;gt;&amp;gt;&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;daoClasses) {
        StandardDatabase db = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;StandardDatabase&lt;/span&gt;(sqliteDatabase);
        &lt;span class=&quot;co&quot;&gt;/** 创建之前旧表中不存在的新表 */&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;fu&quot;&gt;generateNewTablesIfNotExists_withNoExchangeData&lt;/span&gt;(db, daoClasses))    
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;/** 创建中间表 &amp;amp; 把旧表的数据迁移到中间表 */&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;fu&quot;&gt;generateTempTables_withExchangeDataFromOldTable&lt;/span&gt;(db, daoClasses))   
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;/** 把旧表全部删除 */&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;fu&quot;&gt;dropAllTables&lt;/span&gt;(db, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;, daoClasses))                         
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;/** 创建所有新表 */&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;fu&quot;&gt;createAllTables_withNoExchangeData&lt;/span&gt;(db, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;, daoClasses)) 
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;/** 把中间表的数据迁移到新表 &amp;amp; 删除中间表 */&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;restoreData_fromTempTableToNewTable&lt;/span&gt;(db, daoClasses);                     
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(callBack != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            callBack.&lt;span class=&quot;fu&quot;&gt;onFinalSuccess&lt;/span&gt;();
        callBack = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; GreenDaoCompatibleUpdateHelper &lt;span class=&quot;fu&quot;&gt;setCallBack&lt;/span&gt;(GreenDaoCompatibleUpdateCallBack callBack1){
        callBack = callBack1;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;
    }
    ...&lt;span class=&quot;kw&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 去 gitHub 下载完整代码&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;mygreendaodbhelper&quot;&gt;MyGreenDaoDbHelper&lt;/h5&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyGreenDaoDbHelper &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; DaoMaster.&lt;span class=&quot;fu&quot;&gt;DevOpenHelper&lt;/span&gt; {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyGreenDaoDbHelper&lt;/span&gt;(Context context, String name) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(context, name);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyGreenDaoDbHelper&lt;/span&gt;(Context context, String name, SQLiteDatabase.&lt;span class=&quot;fu&quot;&gt;CursorFactory&lt;/span&gt; factory) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(context, name, factory);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;all&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onUpgrade&lt;/span&gt;(SQLiteDatabase db, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldVersion, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newVersion) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onUpgrade&lt;/span&gt;(db, oldVersion, newVersion);
        Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;----&quot;&lt;/span&gt;+oldVersion + &lt;span class=&quot;st&quot;&gt;&quot;---先前和更新之后的版本---&quot;&lt;/span&gt; + newVersion+&lt;span class=&quot;st&quot;&gt;&quot;----&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (oldVersion &amp;lt; newVersion) {
            Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;进行数据库升级&quot;&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;GreenDaoCompatibleUpdateHelper&lt;/span&gt;()
                    .&lt;span class=&quot;fu&quot;&gt;setCallBack&lt;/span&gt;(
                            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; GreenDaoCompatibleUpdateHelper.&lt;span class=&quot;fu&quot;&gt;GreenDaoCompatibleUpdateCallBack&lt;/span&gt;() {
                                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFinalSuccess&lt;/span&gt;() {
                                    Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;进行数据库升级 ===&amp;gt; 成功&quot;&lt;/span&gt;);
                                }

                                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onFailedLog&lt;/span&gt;(String errorMsg) {
                                    Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;升级失败日志 ===&amp;gt; &quot;&lt;/span&gt;+errorMsg);
                                }
                            }
                    )
                    .&lt;span class=&quot;fu&quot;&gt;compatibleUpdate&lt;/span&gt;(
                            db,
                            PostBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                            MatterUserBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                            PropsBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                            ChannelChatsBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;,
                            JoinToChannelReqBeanDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;
                    );
            Log.&lt;span class=&quot;fu&quot;&gt;e&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;MyGreenDaoDbHelper&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;进行数据库升级--完成&quot;&lt;/span&gt;);
        }
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onUpgrade&lt;/span&gt;(Database db, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldVersion, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newVersion) {
        &lt;span class=&quot;co&quot;&gt;// 不要调用父类的，它默认是先删除全部表再创建&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// super.onUpgrade(db, oldVersion, newVersion);&lt;/span&gt;

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;产品级别的可能错误&quot;&gt;产品级别的可能错误&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;因为混淆了 dao 类文件，导致 createTable 方法找不到，解决方法，不要混淆 dao 文件&lt;/li&gt;
&lt;li&gt;restore 步骤中因为新加入的字段含有 int boolean 基础类型，因为不具备默认值而导致出现 &lt;code&gt;SQLiteConstraintException: NOT NULL constraint failed&lt;/code&gt; 错误，解决方法，采用 Integer Boolean 类型替换，这个你只能妥协，因为 greenDao 作者不屑于在你建表的时候提供默认值方法。详情可以去看看 issue&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;你的顾虑&quot;&gt;你的顾虑&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如果我的表太多了，升级会不会造成 ANR 或者导致读写混乱？&lt;/li&gt;
&lt;li&gt;是否实践过？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1, 答： sqlLite 的源码里面调用 &lt;code&gt;onUpdrade&lt;/code&gt;方法的入口皆加上了&lt;code&gt;同步琐&lt;/code&gt;，这样不会造成在升级中还能让你去读写的情况。&lt;br/&gt;这点设计得非常优秀！表太多的，几百张？那么就放入子线程升级。&lt;/p&gt;
&lt;p&gt;2, 答： 我已经使用到线上多个APP ， 且成功运行至今。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 05:22:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/8438547.html</dc:identifier>
</item>
<item>
<title>CentOS7 Nvidia Docker环境 - bearyin</title>
<link>http://www.cnblogs.com/yxfangcs/p/8438462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxfangcs/p/8438462.html</guid>
<description>&lt;p&gt;最近在搞tensorflow的一些东西，话说这东西是真的皮，搞不懂。但是环境还是磕磕碰碰的搭起来了&lt;/p&gt;
&lt;p&gt;其实本来是没想到用docker的，但是就一台配置较好的服务器，还要运行公司的其他环境，vmware esxi用起来太费劲，还是算了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;环境：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;系统：CentOS7 7.4 1708&lt;/p&gt;
&lt;p&gt;显卡：Nvidia 1080Ti&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;下载所有需要的东东&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、docker-ce yum repo : &lt;a href=&quot;https://download.docker.com/linux/centos/docker-ce.repo&quot; target=&quot;_blank&quot;&gt;https://download.docker.com/linux/centos/docker-ce.repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、nvidia-docker yum repo : &lt;a href=&quot;https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo&quot; target=&quot;_blank&quot;&gt;https://nvidia.github.io/nvidia-docker/centos7/x86_64/nvidia-docker.repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、nvidia cuda yum repo : &lt;a href=&quot;http://developer.download.nvidia.com/compute/cuda/repos/rhel7/x86_64/cuda-repo-rhel7-9.1.85-1.x86_64.rpm&quot; target=&quot;_blank&quot;&gt;http://developer.download.nvidia.com/compute/cuda/repos/rhel7/x86_64/cuda-repo-rhel7-9.1.85-1.x86_64.rpm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、nvidia cudnn : &lt;a href=&quot;https://developer.nvidia.com/cudnn&quot; target=&quot;_blank&quot;&gt;https://developer.nvidia.com/cudnn&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这个东西需要注册nvidia账号，就不给直接下载地址了。&lt;/p&gt;
&lt;p&gt;5、nvidia驱动 : &lt;a href=&quot;http://www.nvidia.cn/Download/index.aspx?lang=cn&quot; target=&quot;_blank&quot;&gt;http://www.nvidia.cn/Download/index.aspx?lang=cn&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;按自己的显卡型号下载&lt;/p&gt;
&lt;p&gt;6、nvidia docker file : &lt;a href=&quot;https://hub.docker.com/r/nvidia/cuda/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/nvidia/cuda/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里面可以看到很多dockerfile，选择&lt;/p&gt;
&lt;p&gt;其他的cuda9.1这些应该也可以用，另外有像devel和runtime这样的，其实就是yum安装的cuda包不太一样，没多大关系。&lt;/p&gt;
&lt;p&gt;点进去后复制下来保存为Dockerfile文件，但是之后搞的时候发现有点问题，修改了一下，可以从这儿复制&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;collapse:true;;gutter:true;&quot;&gt;
FROM centos:7
LABEL maintainer &quot;NVIDIA CORPORATION &amp;lt;cudatools@nvidia.com&amp;gt;&quot;

RUN NVIDIA_GPGKEY_SUM=d1be581509378368edeec8c1eb2958702feedf3bc3d17011adbf24efacce4ab5 &amp;amp;&amp;amp; \
    curl -fsSL https://developer.download.nvidia.com/compute/cuda/repos/rhel7/x86_64/7fa2af80.pub | sed '/^Version/d' &amp;gt; /etc/pki/rpm-gpg/RPM-GPG-KEY-NVIDIA &amp;amp;&amp;amp; \
    echo &quot;$NVIDIA_GPGKEY_SUM  /etc/pki/rpm-gpg/RPM-GPG-KEY-NVIDIA&quot; | sha256sum -c --strict -

#COPY cuda.repo /etc/yum.repos.d/cuda.repo

ENV CUDA_VERSION 9.0.176

ENV CUDA_PKG_VERSION 9-0-$CUDA_VERSION-1
#RUN yum install -y \
#        cuda-cudart-$CUDA_PKG_VERSION &amp;amp;&amp;amp; \
#    ln -s cuda-9.0 /usr/local/cuda &amp;amp;&amp;amp; \
#    rm -rf /var/cache/yum/*

# nvidia-docker 1.0
LABEL com.nvidia.volumes.needed=&quot;nvidia_driver&quot;
LABEL com.nvidia.cuda.version=&quot;${CUDA_VERSION}&quot;

RUN echo &quot;/usr/local/nvidia/lib&quot; &amp;gt;&amp;gt; /etc/ld.so.conf.d/nvidia.conf &amp;amp;&amp;amp; \
    echo &quot;/usr/local/nvidia/lib64&quot; &amp;gt;&amp;gt; /etc/ld.so.conf.d/nvidia.conf

ENV PATH /usr/local/nvidia/bin:/usr/local/cuda/bin:${PATH}
ENV LD_LIBRARY_PATH /usr/local/nvidia/lib:/usr/local/nvidia/lib64

# nvidia-container-runtime
ENV NVIDIA_VISIBLE_DEVICES all
ENV NVIDIA_DRIVER_CAPABILITIES compute,utility
ENV NVIDIA_REQUIRE_CUDA &quot;cuda&amp;gt;=9.0&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;所有的文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost nvidia]# &lt;span&gt;pwd&lt;/span&gt;
/root/&lt;span&gt;nvidia
[root@localhost nvidia]# ll
total &lt;/span&gt;&lt;span&gt;420000&lt;/span&gt;&lt;span&gt;
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;2&lt;/span&gt; root root      &lt;span&gt;4096&lt;/span&gt; Feb &lt;span&gt;10&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt; centos-&lt;span&gt;gpu
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root      &lt;span&gt;3335&lt;/span&gt; Jan &lt;span&gt;29&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; cuda-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.x86_64.rpm
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;348817823&lt;/span&gt; Feb  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; cudnn-&lt;span&gt;9.0&lt;/span&gt;-linux-x64-&lt;span&gt;v7.tgz
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root      &lt;span&gt;2424&lt;/span&gt; Feb  &lt;span&gt;9&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; docker-&lt;span&gt;ce.repo
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root       &lt;span&gt;796&lt;/span&gt; Feb  &lt;span&gt;9&lt;/span&gt; &lt;span&gt;17&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt; nvidia-&lt;span&gt;docker.repo
&lt;/span&gt;-rwxr-xr-x. &lt;span&gt;1&lt;/span&gt; root root  &lt;span&gt;81242220&lt;/span&gt; Jan &lt;span&gt;31&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt; NVIDIA-Linux-x86_64-&lt;span&gt;390.25&lt;/span&gt;.run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; centos-gpu里有Dockerfile文件&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;直接上命令，一看就明白&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
[root@localhost nvidia]# &lt;span&gt;cp&lt;/span&gt; docker-ce.repo nvidia-docker.repo /etc/&lt;span&gt;yum&lt;/span&gt;.repos.d/&lt;span&gt;
[root@localhost nvidia]# rpm &lt;/span&gt;-ivh cuda-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.x86_64.rpm
[root@localhost nvidia]# &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; epel-&lt;span&gt;release
[root@localhost nvidia]# &lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt;-c++&lt;p&gt;[root@localhost nvidia]# yum install kernel*
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;安装驱动 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost nvidia]# &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blacklist nouveau&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt;/etc/&lt;span&gt;modprobe&lt;/span&gt;.d/&lt;span&gt;blacklist.conf
[root@localhost nvidia]# &lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; /boot/initramfs-$(&lt;span&gt;uname&lt;/span&gt; -r).img /boot/initramfs-$(&lt;span&gt;uname&lt;/span&gt; -r).img.bak dracut -v /boot/initramfs-$(&lt;span&gt;uname&lt;/span&gt; -r).img $(&lt;span&gt;uname&lt;/span&gt; -&lt;span&gt;r) 
[root@localhost nvidia]# init &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; 
[root@localhost nvidia]# &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; +x NVIDIA-Linux-x86_64-&lt;span&gt;390.25&lt;/span&gt;&lt;span&gt;.run 
[root@localhost nvidia]# .&lt;/span&gt;/NVIDIA-Linux-x86_64-&lt;span&gt;390.25&lt;/span&gt;.run
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大概步骤就是这样，如果出现问题，可以直接网上找一找，应该不会太难&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;安装和启动docker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost nvidia]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; docker-ce nvidia-&lt;span&gt;docker
[root@localhost nvidia]# systemctl enable docker
[root@localhost nvidia]# systemctl start docker
[root@localhost nvidia]# systemctl enable nvidia&lt;/span&gt;-&lt;span&gt;docker
[root@localhost nvidia]# systemctl start nvidia&lt;/span&gt;-docker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记得显卡驱动一定要先装好，nvidia-docker才能正常启动&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;制作docker镜像&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost nvidia]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; cuda-cudart-&lt;span&gt;9&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;-&lt;span&gt;9.0&lt;/span&gt;.&lt;span&gt;176&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
[root@localhost nvidia]# &lt;/span&gt;&lt;span&gt;ln&lt;/span&gt; -s cuda-&lt;span&gt;9.0&lt;/span&gt; /usr/local/&lt;span&gt;cuda
[root@localhost nvidia]# nvidia&lt;/span&gt;-docker build -t centos-nvidia /root/nvidia/centos-gpu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你是用的我修改的Dockfile应该不会有什么问题，如果你是用的原版的，可能会在&lt;/p&gt;
&lt;pre class=&quot;brush:bash;collapse:true;;gutter:true;&quot;&gt;
#COPY cuda.repo /etc/yum.repos.d/cuda.repo
&lt;/pre&gt;
&lt;p&gt;出错，但是咱们已经下载cuda 的 repo，并安装了，所以这一步可以不用。&lt;/p&gt;
&lt;p&gt;镜像制作结束后，可以用命令 docker images 查看一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@localhost centos-&lt;span&gt;gpu]# docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE
centos&lt;/span&gt;-nvidia           latest              a02c8e0ad5ca        &lt;span&gt;2&lt;/span&gt; hours ago         207MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有这一行应该就算是成功了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;生成docker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost centos-gpu]# nvidia-docker run --name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;centos-gpu2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -ti a02c /bin/&lt;span&gt;bash
[root@34d532e76913 &lt;/span&gt;/]# nvidia-&lt;span&gt;smi 
Sat Feb &lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt; &lt;span&gt;2018&lt;/span&gt;       
+-----------------------------------------------------------------------------+
| NVIDIA-SMI &lt;span&gt;390.25&lt;/span&gt;                 Driver Version: &lt;span&gt;390.25&lt;/span&gt;                    |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|===============================+======================+======================|
|   &lt;span&gt;0&lt;/span&gt;  GeForce GTX &lt;span&gt;108&lt;/span&gt;...  Off  | &lt;span&gt;00000000&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt; Off |                  N/A |
| &lt;span&gt;23&lt;/span&gt;%   17C    P8     8W / 250W |     10MiB / 11178MiB |      &lt;span&gt;0&lt;/span&gt;%      Default |
+-------------------------------+----------------------+----------------------+
                                                                               
+-----------------------------------------------------------------------------+
| Processes:                                                       GPU Memory |
|  GPU       PID   Type   Process name                             Usage      |
|=============================================================================|
|  No running processes found                                                 |
+-----------------------------------------------------------------------------+&lt;span&gt;
[root@34d532e76913 &lt;/span&gt;/]# exit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果类似于上面的输出结果，差不多就可以了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用Docker&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@localhost centos-gpu]# nvidia-docker &lt;span&gt;ps&lt;/span&gt; -&lt;span&gt;a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES
34d532e76913        a02c                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;3&lt;/span&gt; minutes ago       Exited (&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;12&lt;/span&gt; seconds ago                       centos-&lt;span&gt;gpu2
d16c2db2bf2e        a02c                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;2&lt;/span&gt; hours ago         Exited (&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;19&lt;/span&gt; minutes ago                       centos-&lt;span&gt;gpu
370671db8df1        3afd                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;19&lt;/span&gt; hours ago        Exited (&lt;span&gt;137&lt;/span&gt;) &lt;span&gt;3&lt;/span&gt; hours ago                        centos-&lt;span&gt;dronemap
[root@localhost centos&lt;/span&gt;-gpu]# nvidia-&lt;span&gt;docker start 34d5
34d5
[root@localhost centos&lt;/span&gt;-gpu]# nvidia-docker &lt;span&gt;cp&lt;/span&gt; /root/nvidia/cuda-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.x86_64.rpm 34d532e76913:/&lt;span&gt;root
[root@localhost centos&lt;/span&gt;-gpu]# nvidia-docker exec -ti 34d5 /bin/&lt;span&gt;bash
[root@34d532e76913 &lt;/span&gt;/&lt;span&gt;]# cd
[root@34d532e76913 &lt;/span&gt;~]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
anaconda&lt;/span&gt;-ks.cfg  cuda-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.x86_64.rpm
[root@34d532e76913 &lt;/span&gt;~]# rpm -ivh cuda-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.x86_64.rpm 
warning: cuda&lt;/span&gt;-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.x86_64.rpm: Header V3 RSA/&lt;span&gt;SHA512 Signature, key ID 7fa2af80: NOKEY
Preparing...                          ################################# [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
Updating &lt;/span&gt;/&lt;span&gt; installing...
   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;:cuda-repo-rhel7-&lt;span&gt;9.1&lt;/span&gt;.&lt;span&gt;85&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;         ################################# [&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
[root@34d532e76913 &lt;/span&gt;~]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; cuda-*&lt;span&gt;9&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是类似于 34d532e76913 这样的编号，是docker自动生成的，运行的时候需要修改一下。&lt;/p&gt;
&lt;p&gt;到目前基本上cuda的环境就搭建好了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;TensorFlow&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把下载的cudnn包用docker cp复制到docker中，解压下来，将里面的lib64路径添加到 /etc/ld.so.conf.d/nvidia.conf 中，运行ldconfig，就ok了。&lt;/p&gt;
&lt;p&gt;上面的环境好了以后，再安装python等等软件，这就不说了。之后tensorflow的一些例子就可以在docker里运行了。当然你得安装gpu版本的，才能发挥显卡的威力。&lt;/p&gt;
&lt;p&gt;另外也可以不必要这么麻烦，有已经制作好的镜像可以拿来用，可以参考：&lt;a href=&quot;https://hub.docker.com/r/tensorflow/tensorflow/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/tensorflow/tensorflow/&lt;/a&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另外也有现成的cuda镜像可以用，参考：&lt;a href=&quot;https://hub.docker.com/r/nvidia/cuda/&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/r/nvidia/cuda/&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;直接使用命令：docker pull nvidia/cuda 就可以下载镜像了，只不过这是ubuntu版本的，和我们的生成环境不符，如果要其他版本的可以参考上面的例子。&lt;/p&gt;
&lt;p&gt;如果文中有不对之处，欢迎指正。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这一段时间没有写什么东西，另外之前的关于图形绘图的东西，一直没扔，已经有很多东西可以和大家分享了，只不过时间很少，还没来得及整理。等有空了就能听着音乐在屏幕前磨洋工了，KeKe～。&lt;/p&gt;
</description>
<pubDate>Sat, 10 Feb 2018 04:21:00 +0000</pubDate>
<dc:creator>bearyin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxfangcs/p/8438462.html</dc:identifier>
</item>
<item>
<title>python函数式编程之装饰器(一) - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/8438451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/8438451.html</guid>
<description>&lt;h3 id=&quot;开放封闭原则&quot;&gt;1.开放封闭原则&lt;/h3&gt;
&lt;p&gt;简单来说，就是&lt;code&gt;对扩展开放，对修改封闭&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在面向对象的编程方式中，经常会定义各种函数。&lt;/p&gt;
&lt;p&gt;一个函数的使用分为定义阶段和使用阶段，一个函数定义完成以后，可能会在很多位置被调用&lt;/p&gt;
&lt;p&gt;这意味着如果函数的定义阶段代码被修改，受到影响的地方就会有很多，此时很容易因为一个小地方的修改而影响整套系统的崩溃，&lt;/p&gt;
&lt;p&gt;所以对于现代程序开发行业来说，一套系统一旦上线，系统的源代码就一定不能够再改动了。&lt;/p&gt;
&lt;p&gt;然而一套系统上线以后，随着用户数量的不断增加，一定会为一套系统扩展添加新的功能。&lt;/p&gt;
&lt;p&gt;此时，又不能修改原有系统的源代码，又要为原有系统开发增加新功能，这就是程序开发行业的开放封闭原则，这时就要用到装饰器了。&lt;/p&gt;
&lt;h3 id=&quot;什么是装饰器&quot;&gt;2.什么是装饰器？？&lt;/h3&gt;
&lt;p&gt;装饰器，顾名思义，就是装饰，修饰别的对象的一种工具。&lt;/p&gt;
&lt;p&gt;所以装饰器可以是任意可调用的对象，被装饰的对象也可以是任意可调用对象&lt;/p&gt;
&lt;h3 id=&quot;装饰器的作用&quot;&gt;3.装饰器的作用&lt;/h3&gt;
&lt;p&gt;在不修改被装饰对象的源代码以及调用方式的前提下为被装饰对象添加新功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;原则：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.不修改被装饰对象的源代码
2.不修改被装饰对象的调用方式&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;目标：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;为被装饰对象添加新功能&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;装饰器的定义和使用&quot;&gt;4.装饰器的定义和使用&lt;/h3&gt;
&lt;p&gt;来看下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def index():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
    
    index()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index函数的作用是程序在随机睡眠1到5秒之后，打印一句话&lt;/p&gt;
&lt;p&gt;现在想为index函数添加一个新功能：统计index函数的运行时间，该怎么做呢？？&lt;/p&gt;
&lt;p&gt;修改index函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def index():
        start_time=time.time()
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
        end_time=time.time()
        print(&quot;cost time: %s&quot; %(end_time - start_time))
    
    index()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
cost time: 2.000999927520752    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，为index函数添加新功能确实实现了，但是却违反了开放封闭原则。&lt;/p&gt;
&lt;p&gt;在符合开放封闭原则的前提下，如果想为index函数添加新功能，此时就要使用装饰器了&lt;/p&gt;
&lt;p&gt;修改代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def index():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
    
    def timmer():
        def inner():
            start_time=time.time()
            index()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    f=timmer()
    f()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，查看执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
run time: 1.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从程序执行结果可以看出，index函数的运行时间已经被统计出来了&lt;/p&gt;
&lt;p&gt;但是查看源码可以知道，index函数的源码确实没有被修改，但是index的调用方式被修改了&lt;/p&gt;
&lt;p&gt;而且还有一个问题就是，timmer这个装饰器只能被用来装饰index这个函数，如果以后想统计别的函数的运行时间，又要重新定义别的装饰器，这样也太不灵活了。&lt;/p&gt;
&lt;p&gt;修改上面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def timmer(func):
        def inner():
            start_time=time.time()
            func()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
        
    def index():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
    
    index=timmer(index)
    index()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，查看程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
run time: 4.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，index函数的源代码没有被修改，index函数的调用方式也没有改变，但是依然为index函数添加了统计时间的功能，这里使用的就是装饰器了。&lt;/p&gt;
&lt;p&gt;来分析下上面代码的执行流程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    1.导入time和random模块，定义index函数和timmer函数
    2.把原始的index函数的内存地址作为参数传给timmer函数。
    3.timmer函数内部嵌套定义一个函数inner,然后返回inner函数的内存地址
    4.timmer函数执行完成，返回timmer函数的内部函数inner的内存地址，然后把inner的内存地址赋值给index变量
    5.index是inner函数的内存地址，index变量加括号运行，实际上就是在运行inner函数
    6.运行inner函数，定义程序开始时间。
    7.执行timmer函数的变量func,在第2步知道，func这个变量就是index的内存地址，所以这里实际上是执行被装饰过后的index函数
    8.index函数执行完成，定义程序的终止时间
    9.统计并打印整个程序的执行过程中所花费的时间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是装饰器装饰index函数的执行流程&lt;/p&gt;
&lt;h3 id=&quot;装饰器的简化使用&quot;&gt;5.装饰器的简化使用&lt;/h3&gt;
&lt;p&gt;现在我又有另外一个函数home,现在我也想统计home函数的运行时间，可以把代码修改如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def timmer(func):
        def inner():
            start_time=time.time()
            func()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    def index():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
    
    def home():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to home page&quot;)
        
    index=timmer(index)
    index()
    
    home=timmer(home)
    home()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，执行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
run time: 3.0 
welcome to home page
run time: 4.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，每次调用统计程序运行时间的装饰器timmer，都要先把被调用的函数的函数名作为参数传给timmer装饰器&lt;/p&gt;
&lt;p&gt;然后再把timmer装饰器的执行结果赋值给被调用的函数名本身，最后才能调用被装饰的函数，太麻烦了有没有？？&lt;/p&gt;
&lt;p&gt;其实python中的装饰器可以简化成下面的格式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def timmer(func):
        def inner():
            start_time=time.time()
            func()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    @timmer
    def index():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
    
    @timmer
    def home():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to home page&quot;)
    
    index()
    home()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
run time: 2.0 
welcome to home page
run time: 4.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，使用&lt;code&gt;@加装饰器名添加到被装饰对象的上方&lt;/code&gt;的方式也可以为一个函数添加装饰器中定义的功能&lt;/p&gt;
&lt;h3 id=&quot;多个装饰器的定义与调用&quot;&gt;6.多个装饰器的定义与调用&lt;/h3&gt;
&lt;p&gt;在上面的例子里，定义并调用了一个统计程序运行时间的装饰器timmer,&lt;/p&gt;
&lt;p&gt;如果现在想为index函数添加一个用户认证的功能，可以定义一个名为auth的装饰器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def auth(func):
        def wrapper():
            while True:
                user=input(&quot;Input your username&amp;gt;&amp;gt;&amp;gt;:&quot;).strip()
                pwd=input(&quot;Input your password&amp;gt;&amp;gt;&amp;gt;:&quot;).strip()
                if user== &quot;abcd&quot; and pwd == &quot;abcd1234&quot;:
                    print(&quot;login successful&quot;)
                    func()
                    break
                else:
                    print(&quot;login error&quot;)
        return wrapper
    
    @auth
    def index():
        time.sleep(random.randrange(1,5))
        print(&quot;welcome to index page&quot;)
    
    index()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Input your username&amp;gt;&amp;gt;&amp;gt;:abcd             # 先输入错误的用户名和密码
    Input your password&amp;gt;&amp;gt;&amp;gt;:1234
    login error                             # 提示用户输入错误，登录失败
    Input your username&amp;gt;&amp;gt;&amp;gt;:abcd             # 让用户再次输入用户名和密码
    Input your password&amp;gt;&amp;gt;&amp;gt;:abcd1234
    login successful                        # 登录成功
    welcome to index page                   # 执行index函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从程序执行结果可以看出，用户登录密码验证的装饰器auth已经定义并被成功调用了&lt;/p&gt;
&lt;p&gt;如果想为index函数添加用户认证的功能，又想统计index函数执行时间的功能，在使用装饰器的情况下该怎么调用呢&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def timmer(func):
        def inner():
            start_time=time.time()
            func()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    def auth(func):
        def wrapper():
            while True:
                user=input(&quot;Input your username&amp;gt;&amp;gt;&amp;gt;:&quot;).strip()
                pwd=input(&quot;Input your password&amp;gt;&amp;gt;&amp;gt;:&quot;).strip()
                if user== &quot;abcd&quot; and pwd == &quot;abcd1234&quot;:
                    print(&quot;login successful&quot;)
                    func()
                    break
                else:
                    print(&quot;login error&quot;)
        return wrapper
    
    @timmer
    @auth
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    index()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码里，为index函数添加了两个装饰器，现在有一个问题，就是这两个装饰器究竟哪个先被调用，哪个后被调用呢？？&lt;/p&gt;
&lt;p&gt;来分析一下，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果timmer装饰器先被调用，那么程序就会先执行timmer装饰器，然后再执行auth装饰器，提示输入用户名和密码，
    这样一来timmer装饰器统计的时间就会包括输入用户名和密码的时间，这个时间会远远大于index函数睡眠的2秒种；
如果auth装饰器先被调用，timmer装饰器后被调用，那么timmer装饰器统计的运行时间就应该只包括index函数的执行时间值应该在2秒多一点点的时间范围内&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，先输入错误的用户名和密码以使用程序的执行时间加长&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input your username&amp;gt;&amp;gt;&amp;gt;:abcd
Input your password&amp;gt;&amp;gt;&amp;gt;:abcd
login error
Input your username&amp;gt;&amp;gt;&amp;gt;:abcd
Input your password&amp;gt;&amp;gt;&amp;gt;:abcd1234
login successful
welcome to index page
run time: 12.759000062942505 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从程序的执行结果可以知道，程序是先运行timmer装饰器，然后才运行auth装饰器，所以timmer统计的时间就包括了用户认证的时间，所以timmer统计到的程序运行时间远远大于index睡眠的2秒钟&lt;/p&gt;
&lt;p&gt;所以这里得出一个结论：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当一个函数同时被两个装饰器装饰时，加上函数最上面的装饰器先执行,加在下面的装饰器先装饰&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把上面例子里的timmer装饰器和auth装饰器位置互换一下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    import random
    
    def timmer(func):
        def inner():
            start_time=time.time()
            func()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    def auth(func):
        def wrapper():
            while True:
                user=input(&quot;Input your username&amp;gt;&amp;gt;&amp;gt;:&quot;).strip()
                pwd=input(&quot;Input your password&amp;gt;&amp;gt;&amp;gt;:&quot;).strip()
                if user== &quot;abcd&quot; and pwd == &quot;abcd1234&quot;:
                    print(&quot;login successful&quot;)
                    func()
                    break
                else:
                    print(&quot;login error&quot;)
        return wrapper
    
    @auth
    @timmer
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    index()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行index函数，依然先输入错误的用户名和密码，增加用户认证的时间&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Input your username&amp;gt;&amp;gt;&amp;gt;:abcd
Input your password&amp;gt;&amp;gt;&amp;gt;:abcd
login error
Input your username&amp;gt;&amp;gt;&amp;gt;:abcd
Input your password&amp;gt;&amp;gt;&amp;gt;:abcd1234
login successful
welcome to index page
run time: 2.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这次timmer统计到的时间只包含index函数的运行时间，不包含用户进行认证的时间&lt;/p&gt;
&lt;p&gt;来分析一下上面例子中，index函数被timmer装饰器和auth装饰器装饰的代码装饰流程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    @auth           # index=auth(timmer(index))
    @timmer         # index=timmer(index)
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面得出结论，一个函数同时被两个装饰器时，加在下面的装饰器先装饰&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.timmer装饰器装饰原始的index，可以写成:index=timmer(index)
2.在timmer装饰器中，timmer装饰器实际上是返回inner的内存地址，所以在这里，index=inner
3.timmer装饰器装饰完成后，由auth装饰器来装饰，此时可以写成index=auth(index)，
4.这里auth括号里的index已经不再是原始index函数，而是已经被timmer装饰过后的index了，所以index=auth(timmer(index))
5.又因为timmer装饰的结果等于inner函数的内存地址，所以：index=auth(inner)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，两个装饰器的装饰过程已经知道了，来看程序的执行过程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;6.程序先执行auth装饰器，进入用户认证，请用户输入用户名和密码
7.用户输入正确的用户名和密码后，开始执行func函数，也已经上面分析的inner函数
8.timmer装饰器先定义程序的开始运行时间，然后运行func函数，也就是原生的index函数
9.index函数先睡眠2秒，然后执行print语句，再定义程序的结束时间
10.最后统计并打印程序的运行时间，至此程序运行完毕。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这里用户输入用户名和密码的时间不会被timmer装饰器统计在内&lt;/p&gt;
&lt;h3 id=&quot;被装饰函数参数的设置与定义&quot;&gt;7.被装饰函数参数的设置与定义&lt;/h3&gt;
&lt;p&gt;先来看一段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    
    def timmer(func):
        def inner():
            start_time=time.time()
            func()
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    @timmer
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    @timmer
    def home(name):
        time.sleep(3)
        print(&quot;welcome to %s home page&quot; % name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，home函数添加了一个参数，而index函数并没有参数&lt;/p&gt;
&lt;p&gt;按照正常的函数的定义与调用方式，调用index函数和home函数的方式应该是下面这种形式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;index()
home(&quot;python&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行程序就会发现，程序抛出了异常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  File &quot;E:\python_learn\py_code\test.py&quot;, line 28, in &amp;lt;module&amp;gt;
    home(&quot;python&quot;)
TypeError: inner() takes 0 positional arguments but 1 was given&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说个异常说明inner函数不需要位置参数，但是我们给了一个位置参数&lt;/p&gt;
&lt;p&gt;回到timmer装饰器定义的部分，可以看到，timmer装饰器的内部函数确实没有定义参数&lt;/p&gt;
&lt;p&gt;这样一来，timmer装饰器只能用于装饰没有参数的函数了，&lt;/p&gt;
&lt;p&gt;我们可以在timmer装饰器定义的时候为inner函数添加一个参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    
    def timmer(func):
        def inner(name):
            start_time=time.time()
            func(name)
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    @timmer
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    @timmer
    def home(name):
        time.sleep(3)
        print(&quot;welcome to %s home page&quot; % name)
    
    index()
    home(&quot;python&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样一来，timmer装饰器装饰index函数的时候又会抛出异常，因为index函数没有参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;File &quot;E:\python_learn\py_code\test.py&quot;, line 27, in &amp;lt;module&amp;gt;
index()
TypeError: inner() missing 1 required positional argument: 'name'       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在不知道被装饰函数的参数个数的情况下，即被装饰函数的参数可变长，且形式不固定的时候，&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;，把上面的代码修改&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    
    def timmer(func):
        def inner(*args,**kwargs):
            start_time=time.time()
            func(*args,**kwargs)
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    @timmer
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    @timmer
    def home(name):
        time.sleep(3)
        print(&quot;welcome to %s home page&quot; % name)
    
    index()
    home(&quot;python&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行程序，查看运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
run time: 2.0 
welcome to python home page
run time: 3.0 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上可知，在不知道被装饰函数的参数个数时，可以使用&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kwargs&lt;/code&gt;来表示任意长度任意形式的参数&lt;/p&gt;
&lt;h3 id=&quot;被装饰函数的返回值&quot;&gt;8.被装饰函数的返回值&lt;/h3&gt;
&lt;p&gt;修改上面的代码，为home函数定义一个返回值，分别打印index函数和home函数的返回值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    
    def timmer(func):
        def inner(*args,**kwargs):
            start_time=time.time()
            func(*args,**kwargs)
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
        return inner
    
    @timmer
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    @timmer
    def home(name):
        time.sleep(3)
        print(&quot;welcome to %s home page&quot; % name)
        return(&quot;home func&quot;)
    
    index_res=index()
    print(index_res)
    
    home_res=home(&quot;python&quot;)
    print(home_res)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，可以看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;welcome to index page
run time: 2.0 
None
welcome to python home page
run time: 3.0 
None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，home函数中定义的返回值并没有被打印出来，显示的值为None&lt;/p&gt;
&lt;p&gt;因为这里执行的home函数不是原始定义的home函数，而是wrapper函数的执行结果&lt;/p&gt;
&lt;p&gt;因为wrapper函数并没有定义返回值，所以执行被装饰后的home函数并没有打印出返回值&lt;/p&gt;
&lt;p&gt;修改代码，在timmer装饰器中定义并返回被装饰函数执行的返回值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    import time
    
    def timmer(func):
        def inner(*args,**kwargs):
            start_time=time.time()
            res=func(*args,**kwargs)
            end_time=time.time()
            print(&quot;run time: %s &quot; %(end_time-start_time))
            return res
        return inner
    
    @timmer
    def index():
        time.sleep(2)
        print(&quot;welcome to index page&quot;)
    
    @timmer
    def home(name):
        time.sleep(3)
        print(&quot;welcome to %s home page&quot; % name)
        return(&quot;home func&quot;)
    
    index_res=index()
    print(index_res)
    
    home_res=home(&quot;python&quot;)
    print(home_res)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次执行函数，查看执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    welcome to index page
    run time: 2.0 
    None
    
    welcome to python home page
    run time: 3.0 
    home func
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看来，原始home函数中定义的返回值被打印出来了&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;如果被装饰函数没有定义返回值，timmer装饰器装饰后的返回值为None
而如果被装饰函数定义了返回值，则timmer装饰器装饰后则返回被装饰函数的返回值&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 10 Feb 2018 04:09:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/8438451.html</dc:identifier>
</item>
<item>
<title>Jedis/JedisPool和Redis数据类型与特性 - mosterRan</title>
<link>http://www.cnblogs.com/moster/p/8436691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moster/p/8436691.html</guid>
<description>&lt;div id=&quot;rightArrow&quot;&gt;&lt;a href=&quot;https://github.com/a947000098&quot;&gt;&lt;img src=&quot;https://github-camo.global.ssl.fastly.net/652c5b9acfaddf3a9c326fa6bde407b87f7be0f4/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6f72616e67655f6666373630302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;1.介绍Jedis&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;Jedis 是 Redis 的 java 版本客户端，使用Jedis可以连接 Redis的数据库，Jedis连接方式有三种Jedis/JedisPool 连接、ShardedJedis/ShardedJedisPool 连接、JedisCluster 连接，今天主要讲解用 Java 代码连接 Jedis 连接池&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;1.1连接Jedis/JedisPool &lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;首先在Redis 中加入username 如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209143417904-1217386433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是连接Jedis的具体过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JedisTest {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过java程序访问redis数据库&lt;/span&gt;
&lt;span&gt;    
    @Test
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得单一的jedis对象操作数据库&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.获得连接对象&lt;/span&gt;
        Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(&quot;192.168.199.2&quot;, 6379);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.获取数据&lt;/span&gt;
        String username = jedis.get(&quot;username&quot;&lt;span&gt;);
        System.out.println(username);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.存储&lt;/span&gt;
        jedis.set(&quot;addr&quot;, &quot;北京&quot;&lt;span&gt;);
        System.out.println(jedis.get(&lt;/span&gt;&quot;addr&quot;&lt;span&gt;));
    }&lt;br/&gt;　　&lt;span&gt;//结果zhr&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　  北京&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过jedis的pool获得jedis连接对象&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0.创建池子的配置对象&lt;/span&gt;
        JedisPoolConfig poolconfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisPoolConfig();
        poolconfig.setMaxIdle(&lt;/span&gt;30);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大闲置个数&lt;/span&gt;
        poolconfig.setMinIdle(10);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小闲置个数&lt;/span&gt;
        poolconfig.setMaxTotal(50);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大连接数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.创建一个redis的连接池&lt;/span&gt;
        JedisPool pool = &lt;span&gt;new&lt;/span&gt; JedisPool(poolconfig,&quot;192.168.199.2&quot;, 6379&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.从池子中获取redis的连接资源&lt;/span&gt;
        Jedis jedis =&lt;span&gt; pool.getResource();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.操作数据库&lt;/span&gt;
        jedis.set(&quot;haha&quot;,&quot;123&quot;&lt;span&gt;);
        System.out.println(jedis.get(&lt;/span&gt;&quot;haha&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.关闭资源&lt;/span&gt;
&lt;span&gt;        jedis.close();
        pool.close();
    }
}&lt;br/&gt;&lt;span&gt;//123&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;1.2封装JedisPool工具&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;新建一个 redis.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis.maxIdle=30&lt;span&gt;
redis.minIdle&lt;/span&gt;=10&lt;span&gt;
redis.maxTotal&lt;/span&gt;=100&lt;span&gt;
redis.url&lt;/span&gt;=192.168.199.2&lt;span&gt;
redis.port&lt;/span&gt;=6379
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个 JedisPoolUtils 工具方便以后开发使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.zhr.jedis;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.Jedis;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisPool;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis.clients.jedis.JedisPoolConfig;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JedisPoolUtils {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; JedisPool pool;
    
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载配置文件&lt;/span&gt;
        InputStream in = JedisPoolUtils.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResourceAsStream(&quot;redis.properties&quot;&lt;span&gt;);
        Properties pro &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            pro.load(in);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得池子对象&lt;/span&gt;
        JedisPoolConfig poolconfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisPoolConfig();
        poolconfig.setMaxIdle(Integer.parseInt(pro.get(&lt;/span&gt;&quot;redis.maxIdle&quot;).toString()));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大闲置个数&lt;/span&gt;
        poolconfig.setMinIdle(Integer.parseInt(pro.get(&quot;redis.minIdle&quot;).toString()));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小闲置个数&lt;/span&gt;
        poolconfig.setMaxTotal(Integer.parseInt(pro.get(&quot;redis.maxTotal&quot;).toString()));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大连接数&lt;/span&gt;
        pool = &lt;span&gt;new&lt;/span&gt; JedisPool(poolconfig,pro.getProperty(&quot;redis.url&quot;), Integer.parseInt(pro.get(&quot;redis.port&quot;&lt;span&gt;).toString()));

    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得jedis资源的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Jedis getJedis() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pool.getResource();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Jedis jedis &lt;/span&gt;=&lt;span&gt; getJedis();
        System.out.println(jedis.get(&lt;/span&gt;&quot;haha&quot;&lt;span&gt;));
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果出现 JedisConnectionException 这个异常的小朋友问题在于没有把防火墙打开&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;值得注意的问题是要使用Jedis需要开放端口 Centos7 开放的代码是
&lt;p&gt;firewall-cmd --zone=public --add-port=6379/tcp --permanent&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;Centos7以下开放的代码是
&lt;p align=&quot;justify&quot;&gt;/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;/etc/rc.d/init.d/iptables save&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;h2&gt;2.Redis 数据结构及常用命令&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 　Redis一共有五种数据类型如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符型（String）&lt;/li&gt;
&lt;li&gt;哈希（hash）&lt;/li&gt;
&lt;li&gt;字符串列表（list）&lt;/li&gt;
&lt;li&gt;字符串集合（set）&lt;/li&gt;
&lt;li&gt;有序字符串集合（sorted set）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;   Redis 还是一种高级的 key-valu e的存储系统，所以对于key不要定义太长，不要超过1024字节，这样消耗内存而且还降低查询效率&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2.1字符型String&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 　　字符型类型在 Redis 中采用二进制，这说明该类型存入和获取的数据相同。在 Redis 中字符串类型的 Value 最多可以容纳数据长度是512M&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p align=&quot;justify&quot;&gt;赋值： set key value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;取值：get key/getset key value&lt;/li&gt;
&lt;li&gt;删除：del key&lt;/li&gt;
&lt;li&gt;数值自增和自减： incr key/decr key&lt;/li&gt;
&lt;li&gt;为key增加一个指定数值： incrby key increment&lt;/li&gt;
&lt;li&gt;为key减少一个指定数值： decrby key decrement&lt;/li&gt;
&lt;li&gt;拼凑字符串： append key value&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体操作如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209145814591-2017494573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里我们需要注意的是getset key value这个命令和get key 这两个命令的区别，前者是先获取然后在重新设置返回的结果是获取的结果也就是图片出现的“lihai”实际已经赋值为5，incr、decr一个是自增、一个是自减、append key value 这个命令是在后面追加字符串返回的是字符串的结果，最后我们删除del key因为已经没有了再次get的时候就会nil为空 &lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2.2哈希hash&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; Redis 中 Hash 类型可以看作是 map 的容器，所以该类型非常适合存储对象的信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;赋值： hset key field value 为指定的key设置field/value对&lt;/li&gt;
&lt;li&gt;赋值： hmset key field value [field2 value2...] 设置key中多个filed/value&lt;/li&gt;
&lt;li&gt;取值： hget key field&lt;/li&gt;
&lt;li&gt;取值： hmget key fileds  获取 key 中的多个filed 的值&lt;/li&gt;
&lt;li&gt;取值： hgetall key 获取 key 中所有的 filed-value&lt;/li&gt;
&lt;li&gt;删除： hdel key field[field...] 可以删除一个或多个字段，返回值是被删除的字段个数&lt;/li&gt;
&lt;li&gt;删除 del key 删除整个list&lt;/li&gt;
&lt;li&gt;增加数字： hincrby key field increment 设置key 中 filed 的值增加 increment&lt;/li&gt;
&lt;li&gt;是否存在： hexists key field 判断指定 key 中的 filed 是否存在&lt;/li&gt;
&lt;li&gt;field的数量： hlen key 获取 key 所包含的 field 的数量&lt;/li&gt;
&lt;li&gt;获得所有的key ：hkeys key&lt;/li&gt;
&lt;li&gt;获得所有的value ：hvals key&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体操作如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209160448904-629928485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是增加数字increment 可以是正数和负数&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2.3字符串列表list&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 在 Redis 中的 list 类型实际相当于双向链表结构，可以在头部（left）和尾部（right）添加新元素，在插入时，如果该键并不存在，Redis 会自动创建一个新的链表，如果链表中的元素全部被移除，那么该键也会被从数据库中删除，从元素插入和删除的效率来看，在链表的两头插入和删除元素，这样的操作效率是非常高的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;头部插入：lpush key values[value1 value2...] 在指定的key所在头部插入所有的values，如果该 key 不存在，该命令在插入之前会创建一个与该 key 关联的空链表。插入成功，返回元素的个数&lt;/li&gt;
&lt;li&gt;尾部插入：rpush key values[value1 value2...]&lt;/li&gt;
&lt;li&gt;获得链表中从start 到 end元素的值：lrange key start end    若为-1则表示链表尾部元素，-2为倒数第二个&lt;/li&gt;
&lt;li&gt;头部弹出：lpop key 返回并弹出指定的key 关联的链表中第一个元素，如果key 不存在 返回nil&lt;/li&gt;
&lt;li&gt;尾部弹出：rpop key &lt;/li&gt;
&lt;li&gt;获得列表中元素格式：llen key&lt;/li&gt;
&lt;li&gt;lpushx key value：当参数中指定的 key 存在时，向关联的list的头部插入 value。如果不存在，将不进行插入&lt;/li&gt;
&lt;li&gt;rpushx key value:在该list的尾部添加&lt;/li&gt;
&lt;li&gt;lrem key cont value ：删除 coount 个值为 value 的元素，如果count大于0，从头到尾遍历并删除，如果count 小于0，则从尾向头遍历并删除。如果 count 等于0，则删除链表中所有等于value 的元素&lt;/li&gt;
&lt;li&gt;lset key index value ：设置链表中的index 的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。角标不存在则抛异常&lt;/li&gt;
&lt;li&gt;linsert key before|after pivot value ：在 pivot 元素前或者后插入 value 这个元素&lt;/li&gt;
&lt;li&gt;rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部（循环操作）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209193823263-1605249216.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209193831560-915158402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209193859341-693291732.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;677&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180209193907248-1653259744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2.4字符串集合Set&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 　　在Redis 中，可以将 Set 类型看作为没有排序的字符集合，Set 集合中不允许出现重复的元素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sadd key values[value1 value2...]：向 set 中添加数据，如果该 key 的值已有则不会重复添加&lt;/li&gt;
&lt;li&gt;srem key members[member1 member2...]：删除 set 中指定的成员&lt;/li&gt;
&lt;li&gt;smembers key：获得 set 中所有的成员&lt;/li&gt;
&lt;li&gt;sismember key member：判断参数中指定的成员是否在该 set 中，1表示存在，0表示不存在或key本身不存在&lt;/li&gt;
&lt;li&gt;sdiff key1 key2...：返回 key1 与 key2 中相差的成员，而且与key的顺序有关。即返回差集。（A-B）&lt;/li&gt;
&lt;li&gt;sinter key1 key2 key3...：返回交集（A∩B）&lt;/li&gt;
&lt;li&gt;sunion key1 key2 key3...：返回并集（A∪B）&lt;/li&gt;
&lt;li&gt;scard key：获取 set 中成员的数量&lt;/li&gt;
&lt;li&gt;srandmember key：随机返回 set 中的一个成员&lt;/li&gt;
&lt;li&gt;sdiffsotre destination key1 key2...：将key1、key2相差的成员存储在destination 上&lt;/li&gt;
&lt;li&gt;sintersotre destination key[key...]：将返回的交集存储在 destination上&lt;/li&gt;
&lt;li&gt;sunionstore destination key[key...]：将返回的并集存储在 destination 上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180210111151841-1164003286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180210111200404-1971025222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Set 的时候要注意它的唯一性，比如用户的ID 就是唯一的可以存放在Set 当中&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2.5有序字符串集合Sorted Set&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 　　Sorted Set 和 Set极为相似，他们都是字符串集合，都不允许重复的成员出现在一个 Set中。它们之间主要的差别是 Sorted Set 中每一个成员都会有一个分数（score）与之关联我们称它为权重，Redis 也正是通过这个分数来进行从小到大的排序，要注意的是成员必须是唯一的，但分数是可以重复的。使用场景为游戏排名、微博热点话题等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;zadd key score member score2 member2...：将所有成员以及该成员的分数存放到sorted set 中，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素&lt;/li&gt;
&lt;li&gt;zscore key member：返回指定成员分数&lt;/li&gt;
&lt;li&gt;zcard key：获取集合中的成员数量&lt;/li&gt;
&lt;li&gt;zrem key member[member...]：移除集合中指定的成员，可以指定多个成员&lt;/li&gt;
&lt;li&gt;zrange key start end [withscores]：获得集合中脚标为start-end 的成员，[withscores]参数表明返回的成员包含其分数&lt;/li&gt;
&lt;li&gt;zrevrange key start stop [withscores]：照元素分数从大到小的顺序返回索引从start 到 stop之间的所有元素（包括两端的元素）&lt;/li&gt;
&lt;li&gt;zremrangebyrank key start stop：按照排名范围删除元素&lt;/li&gt;
&lt;li&gt;zremrangebyscore key min max：按照分数范围删除元素&lt;/li&gt;
&lt;li&gt;zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数：[limit offset count]：offset，表明从角标为offset的元素开始并返回count个成员&lt;/li&gt;
&lt;li&gt;zincrby key increment member：设置指定成员的增加分数。返回值是更改后的分数&lt;/li&gt;
&lt;li&gt;zcount key min max：获取分数在[min,max]之间的成员&lt;/li&gt;
&lt;li&gt;zrank key menber：返回成员在集合中的排名（从小到大）&lt;/li&gt;
&lt;li&gt;zrevrank key member：返回成员在集合中的排名（从大到小）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1074869/201802/1074869-20180210114113279-1483666374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有些不常用的到时候就来这里面查找就好了 请忽略手残打错字&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;3.keys通用操作&lt;/h2&gt;
&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; keys pattern：获取所有与pattern匹配的key，返回所有与该key匹配的。 *表示任意或一个或多个字符，？表示任意一个字符&lt;/li&gt;
&lt;li&gt;del key1 key2...：删除指定的key&lt;/li&gt;
&lt;li&gt;exists key：判断该key 是否存在，1代表存在，0代表不存在&lt;/li&gt;
&lt;li&gt;rename key newkey：为当前的key重命名&lt;/li&gt;
&lt;li&gt;expire key：设置过期时间，单位：秒&lt;/li&gt;
&lt;li&gt;ttl key：获取该key 所剩的超时时间，如果没有设置超时，返回-1.如果返回-2 表示超时不存在&lt;/li&gt;
&lt;li&gt;type key：获取指定 key 的类型。该命令将以字符串的格式返回。返回字符串为 string、list、set、hash、zshet，如果 key 不存在返回none&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;h2&gt;4.Redis特性&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt; 一、Redis有多数据库一共16个，下标从0到15，客户端默认连接第0号数据库，可以通过&lt;strong&gt;select&lt;/strong&gt;选择连接那个数据库&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;select num：切换数据库&lt;/li&gt;
&lt;li&gt;move newkey 1：将当前库的key移植到1号库中&lt;/li&gt;
&lt;li&gt;ping ：测试连接是否还存活 PONG为存活&lt;/li&gt;
&lt;li&gt;echo：在命令行打印一些内容&lt;/li&gt;
&lt;li&gt;quit：退出连接&lt;/li&gt;
&lt;li&gt;dbsize：返回当前数据库中 key 的数目&lt;/li&gt;
&lt;li&gt;info：获取服务器的信息和统计&lt;/li&gt;
&lt;li&gt;flushdb：删除当前选择数据库中的所有 key&lt;/li&gt;
&lt;li&gt;flushall：删除所有数据库中的所有 key&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二、消息订阅与发布&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;subscribe channel：订阅频道 eg:subscribe chat&lt;/li&gt;
&lt;li&gt;psubscribe channel*：批量订阅频道 eg：psubscribe z*，订阅z开头的频道&lt;/li&gt;
&lt;li&gt;publish channel content：在指定频道中发布消息，eg:publish chat 'haha'&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三、事务&lt;/p&gt;
&lt;p&gt;　　在事务执行期间，Redis 不会在为其它客户端的请求提供任何服务，从而保证了事务中的所有命令被原子的执行，和关系型数据库中的事务相比，在Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行，在Redis中有三个事务的命令如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;multi：开启事务用于标记事务的开始，其后执行的命令都将被存入命令队列，直到执行 exec 时，这些命令才会被原子的执行，类似与关系型数据库中的：begin transaction&lt;/li&gt;
&lt;li&gt;exec：提交事务，类似与关系型数据库中的：commit&lt;/li&gt;
&lt;li&gt;discard：事务回滚，类似与关系型数据库中的：rollback&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sat, 10 Feb 2018 04:06:00 +0000</pubDate>
<dc:creator>mosterRan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/moster/p/8436691.html</dc:identifier>
</item>
<item>
<title>使用xUnit为.net core程序进行单元测试(3) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8438019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8438019.html</guid>
<description>&lt;p&gt;第1部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8283610.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8283610.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第2部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8287588.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8287588.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;请使用这个项目作为练习的开始&lt;/span&gt;&lt;/strong&gt;: &lt;a href=&quot;https://pan.baidu.com/s/1ggcGkGb&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1ggcGkGb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开Game.Tests里面的BossEnemyShould.cs, 为HaveCorrectPower方法添加一个Trait属性标签:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Fact]
        &lt;span&gt;[Trait(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;Category&quot;, &quot;Enemy&quot;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HaveCorrectPower()
        {
            BossEnemy sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BossEnemy();

            Assert.Equal(&lt;/span&gt;&lt;span&gt;166.667&lt;/span&gt;, sut.SpecialAttackPower, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Trait接受两个参数, 作为测试分类的Name和Value对.&lt;/p&gt;
&lt;p&gt;Build项目, Run All Tests, 然后选择选择一下按Traits分组:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210084138279-1932223239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时, Test Explorer里面的tests将会这样显示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210084231045-1537119868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再打开EnemyFactoryShould.cs, 为CreateNormalEnemyByDefault方法添加Trait属性标签:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Fact]
        &lt;span&gt;[Trait(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;Category&quot;, &quot;Enemy&quot;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateNormalEnemyByDefault()
        {
            EnemyFactory sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnemyFactory();

            Enemy enemy &lt;/span&gt;= sut.Create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zombie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Assert.IsType&lt;/span&gt;&amp;lt;NormalEnemy&amp;gt;&lt;span&gt;(enemy);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, 然后查看Test Explorer:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210084509716-4605854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同的Category:&lt;/p&gt;
&lt;p&gt;修改一下BossEnemyShould.cs里面的HaveCorrectPower方法的Trait属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Fact]
        [Trait(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Boss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HaveCorrectPower()
        {
            BossEnemy sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BossEnemy();

            Assert.Equal(&lt;/span&gt;&lt;span&gt;166.667&lt;/span&gt;, sut.SpecialAttackPower, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build之后, 将会看见两个分类:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210084707982-1443098175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;在Class级别进行分类&lt;/strong&gt;:&lt;/h3&gt;
&lt;p&gt;只需要把Trait属性标签移到Class上面即可:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Trait(&quot;Category&quot;, &quot;Enemy&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EnemyFactoryShould
    {&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, 查看Test Explorer可以发现EnemyFactoryShould下面所有的Test方法都分类到了Enemy下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210084927263-2123409035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按分类运行测试&lt;/strong&gt;: &lt;/p&gt;
&lt;p&gt;鼠标右键点击分类, Run Selected Tests就会运行该分类下所有的测试:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210085145638-1177794367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按Trait搜索&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;在Test Explorer中把分类选择到Class:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210085354998-652168947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在旁边的Search输入框中输入关键字, 这时下方会有提示菜单:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210085558310-619253053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Trait, 然后如下图输入, 就会把Enemy分类的测试过滤显示出来:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210085619232-441577332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方式同样也可以进行Trait过滤.&lt;/p&gt;
&lt;h2&gt;使用命令行进行分类测试&lt;/h2&gt;
&lt;p&gt;使用命令行进入的Game.Tests, 首先执行命令dotnet test, 这里显示一共有27个tests:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210090121826-762010416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后, 可以使用命令: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet test --&lt;span&gt;filter&lt;/span&gt; Category=Enemy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行分类为Enemy的tests, 结果如图, 有8个tests:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210090213623-129943262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行多个分类的tests:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet test --&lt;span&gt;filter&lt;/span&gt; &quot;Category=Boss|Category=Enemy&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这句命令会运行分类为Boss或者Enemy的tests, 结果如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210100649529-1840038149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;共有9个tests.&lt;/p&gt;

&lt;p&gt;为Fact属性标签设置其Skip属性, 即可忽略该测试, Skip的值为忽略的原因:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        [Fact&lt;span&gt;(Skip = &quot;不需要跑这个测试&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateNormalEnemyByDefault_NotTypeExample()
        {
            EnemyFactory sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnemyFactory();

            Enemy enemy &lt;/span&gt;= sut.Create(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Zombie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Assert.IsNotType&lt;/span&gt;&amp;lt;DateTime&amp;gt;&lt;span&gt;(enemy);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, 查看Test Explorer, 选择按Trait分类显示, 然后选中Category[Enemy]运行选中的tests:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210101518935-1623337783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从这里可以看到, 上面Skip的test被忽略了.&lt;/p&gt;
&lt;p&gt;回到命令行, 执行dotnet test:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210101706201-65763408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以看到该测试被忽略了, 并且标明了忽略的原因.&lt;/p&gt;

&lt;p&gt;在test中打印信息需要用到ITestOutputHelper的实现类(注意: 这里使用Console.Writeline是无效的), 在BossEnemyShould.cs里面注入这个helper:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit;
&lt;/span&gt;&lt;span&gt;using Xunit.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BossEnemyShould
    {
        &lt;/span&gt;&lt;span&gt;private readonly ITestOutputHelper _output;

        public BossEnemyShould(ITestOutputHelper output)
        {
            _output =&lt;/span&gt;&lt;span&gt;&lt;span&gt; output;
        }&lt;/span&gt;&lt;br/&gt;......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在test方法里面这样写即可:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Fact]
        [Trait(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Category&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Boss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HaveCorrectPower()
        {
            &lt;span&gt;_output.WriteLine(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;正在创建 Boss Enemy&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
            BossEnemy sut &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BossEnemy();

            Assert.Equal(&lt;/span&gt;&lt;span&gt;166.667&lt;/span&gt;, sut.SpecialAttackPower, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, Run Tests, 这时查看测试结果会发现一个output链接:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210102548498-848012749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击这个链接, 就会显示测试的输出信息:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210102557716-2110936580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用命令行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet test --&lt;span&gt;filter&lt;/span&gt; Category=Boss &lt;span&gt;--logger:trx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行命令后:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210102803420-981684683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到生成了一个TestResults文件夹, 里面是测试的输出文件, 使用编辑器打开, 它是一个xml文件, 内容如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_be3135bd-e900-478b-bc32-198802ad1581&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be3135bd-e900-478b-bc32-198802ad1581&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be3135bd-e900-478b-bc32-198802ad1581&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestRun &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;9e552b73-0636-46a2-83d9-c19a5892b3ab&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;solen@DELL-RED 2018-02-10 10:27:19&quot;&lt;/span&gt;&lt;span&gt; runUser&lt;/span&gt;&lt;span&gt;=&quot;DELL-RED\solen&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://microsoft.com/schemas/VisualStudio/TeamTest/2010&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Times &lt;/span&gt;&lt;span&gt;creation&lt;/span&gt;&lt;span&gt;=&quot;2018-02-10T10:27:19.5005784+08:00&quot;&lt;/span&gt;&lt;span&gt; queuing&lt;/span&gt;&lt;span&gt;=&quot;2018-02-10T10:27:19.5005896+08:00&quot;&lt;/span&gt;&lt;span&gt; start&lt;/span&gt;&lt;span&gt;=&quot;2018-02-10T10:27:17.4990291+08:00&quot;&lt;/span&gt;&lt;span&gt; finish&lt;/span&gt;&lt;span&gt;=&quot;2018-02-10T10:27:19.5176327+08:00&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestSettings &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;610cad4c-1066-417b-a8e6-d30dce78ef4d&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Deployment &lt;/span&gt;&lt;span&gt;runDeploymentRoot&lt;/span&gt;&lt;span&gt;=&quot;solen_DELL-RED_2018-02-10_10_27_19&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TestSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Results&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UnitTestResult &lt;/span&gt;&lt;span&gt;executionId&lt;/span&gt;&lt;span&gt;=&quot;4c6ec739-ccd3-4233-b2bd-8bbde4dfa67f&quot;&lt;/span&gt;&lt;span&gt; testId&lt;/span&gt;&lt;span&gt;=&quot;9e476ed4-3cd9-4f51-aa39-b3d411369979&quot;&lt;/span&gt;&lt;span&gt; testName&lt;/span&gt;&lt;span&gt;=&quot;Game.Tests.BossEnemyShould.HaveCorrectPower&quot;&lt;/span&gt;&lt;span&gt; computerName&lt;/span&gt;&lt;span&gt;=&quot;DELL-RED&quot;&lt;/span&gt;&lt;span&gt; duration&lt;/span&gt;&lt;span&gt;=&quot;00:00:00.0160000&quot;&lt;/span&gt;&lt;span&gt; startTime&lt;/span&gt;&lt;span&gt;=&quot;2018-02-10T10:27:19.2099922+08:00&quot;&lt;/span&gt;&lt;span&gt; endTime&lt;/span&gt;&lt;span&gt;=&quot;2018-02-10T10:27:19.2113656+08:00&quot;&lt;/span&gt;&lt;span&gt; testType&lt;/span&gt;&lt;span&gt;=&quot;13cdc9d9-ddb5-4fa4-a97d-d965ccfc6d4b&quot;&lt;/span&gt;&lt;span&gt; outcome&lt;/span&gt;&lt;span&gt;=&quot;Passed&quot;&lt;/span&gt;&lt;span&gt; testListId&lt;/span&gt;&lt;span&gt;=&quot;8c84fa94-04c1-424b-9868-57a2d4851a1d&quot;&lt;/span&gt;&lt;span&gt; relativeResultsDirectory&lt;/span&gt;&lt;span&gt;=&quot;4c6ec739-ccd3-4233-b2bd-8bbde4dfa67f&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Output&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StdOut&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;正在创建 Boss Enemy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StdOut&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Output&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;UnitTestResult&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Results&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UnitTest &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Game.Tests.BossEnemyShould.HaveCorrectPower&quot;&lt;/span&gt;&lt;span&gt; storage&lt;/span&gt;&lt;span&gt;=&quot;c:\users\solen\projects\game\game.tests\bin\debug\netcoreapp2.0\game.tests.dll&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;9e476ed4-3cd9-4f51-aa39-b3d411369979&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Execution &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;4c6ec739-ccd3-4233-b2bd-8bbde4dfa67f&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestMethod &lt;/span&gt;&lt;span&gt;codeBase&lt;/span&gt;&lt;span&gt;=&quot;C:\Users\solen\projects\Game\Game.Tests\bin\Debug\netcoreapp2.0\Game.Tests.dll&quot;&lt;/span&gt;&lt;span&gt; executorUriOfAdapter&lt;/span&gt;&lt;span&gt;=&quot;executor://xunit/VsTestRunner2/netcoreapp&quot;&lt;/span&gt;&lt;span&gt; className&lt;/span&gt;&lt;span&gt;=&quot;Game.Tests.BossEnemyShould&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;Game.Tests.BossEnemyShould.HaveCorrectPower&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;UnitTest&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TestDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestEntries&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestEntry &lt;/span&gt;&lt;span&gt;testId&lt;/span&gt;&lt;span&gt;=&quot;9e476ed4-3cd9-4f51-aa39-b3d411369979&quot;&lt;/span&gt;&lt;span&gt; executionId&lt;/span&gt;&lt;span&gt;=&quot;4c6ec739-ccd3-4233-b2bd-8bbde4dfa67f&quot;&lt;/span&gt;&lt;span&gt; testListId&lt;/span&gt;&lt;span&gt;=&quot;8c84fa94-04c1-424b-9868-57a2d4851a1d&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TestEntries&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestLists&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestList &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Results Not in a List&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;8c84fa94-04c1-424b-9868-57a2d4851a1d&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TestList &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;All Loaded Results&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;19431567-8539-422a-85d7-44ee4e166bda&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TestLists&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ResultSummary &lt;/span&gt;&lt;span&gt;outcome&lt;/span&gt;&lt;span&gt;=&quot;Completed&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Counters &lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; executed&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; passed&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; failed&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; error&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; timeout&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; aborted&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; inconclusive&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; passedButRunAborted&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; notRunnable&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; notExecuted&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; disconnected&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; warning&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; completed&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; inProgress&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; pending&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Output&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StdOut&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;[xUnit.net 00:00:00.5525795]   Discovering: Game.Tests[xUnit.net 00:00:00.6567207]   Discovered:  Game.Tests[xUnit.net 00:00:00.6755272]   Starting:    Game.Tests[xUnit.net 00:00:00.8743059]   Finished:    Game.Tests&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StdOut&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Output&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ResultSummary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TestRun&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在里面某个Output标签内可以看到上面写的测试输出信息.&lt;/p&gt;

&lt;p&gt;xUnit在执行某个测试类的Fact或Theory方法的时候, 都会创建这个类新的实例, 所以有一些公用初始化的代码可以移动到constructor里面.&lt;/p&gt;
&lt;p&gt;打开PlayerCharacterShould.cs, 可以看到每个test方法都执行了new PlayerCharacter()这个动作. 我们应该把这段代码移动到constructor里面:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayerCharacterShould
    {
        &lt;/span&gt;&lt;span&gt;private readonly PlayerCharacter _playerCharacter;
        private readonly ITestOutputHelper _output;

        public PlayerCharacterShould(ITestOutputHelper output)
        {&lt;br/&gt;　　　　　　　_output = output;&lt;br/&gt;_output.WriteLine(&quot;正在创建新的玩家角色&quot;);
            _playerCharacter = new PlayerCharacter();&lt;/span&gt;&lt;span&gt;&lt;span&gt;
        }&lt;/span&gt;

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeInexperiencedWhenNew()
        {
            Assert.True(&lt;span&gt;_playerCharacter&lt;/span&gt;.IsNoob);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CalculateFullName()
        {
            &lt;span&gt;_playerCharacter&lt;/span&gt;.FirstName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sarah&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;span&gt;_playerCharacter&lt;/span&gt;.LastName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Smith&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            Assert.Equal(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sarah Smith&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;_playerCharacter&lt;/span&gt;.FullName);&lt;br/&gt;......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Build, Run Tests, 都OK, 并且都有output输出信息.&lt;/p&gt;
&lt;p&gt;除了集中编写初始化代码, 也可以&lt;strong&gt;&lt;span&gt;集中编写清理代码:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这需要该测试类实现IDisposable接口:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayerCharacterShould&lt;span&gt;: IDisposable&lt;/span&gt;
    {

......

        &lt;/span&gt;&lt;span&gt;public void Dispose()
        {
            _output.WriteLine($&quot;正在清理玩家{_playerCharacter.FullName}&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Build, Run Tests, 然后随便查看一个该类的test的output:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210104802013-403832669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Dispose()被调用了.&lt;/p&gt;

&lt;p&gt;上面降到了每个测试方法运行的时候都会创建该测试类新的实例, 可以在constructor里面进行公共的初始化动作.&lt;/p&gt;
&lt;p&gt;但是如果初始化的动作消耗资源比较大, 并且时间较长, 那么这种方法就不太好了, 所以下面介绍另外一种方法.&lt;/p&gt;
&lt;p&gt;首先在Game项目里面添加类:GameState.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b58eaebe-9af5-4fc1-a52b-d21776dbf93b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b58eaebe-9af5-4fc1-a52b-d21776dbf93b&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b58eaebe-9af5-4fc1-a52b-d21776dbf93b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameState
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EarthquakeDamage = &lt;span&gt;25&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;PlayerCharacter&amp;gt; Players { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;new&lt;/span&gt; List&amp;lt;PlayerCharacter&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; } =&lt;span&gt; Guid.NewGuid();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GameState()
        {
            CreateGameWorld();
        }        

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Earthquake()
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; player &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Players)
            {
                player.TakeDamage(EarthquakeDamage);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reset()
        {
            Players.Clear();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CreateGameWorld()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Simulate expensive creation&lt;/span&gt;
            System.Threading.Thread.Sleep(&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在Game.Tests里面添加类: GameStateShould.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_1f46ba7e-6655-47b3-b6ff-8c73764ebee6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1f46ba7e-6655-47b3-b6ff-8c73764ebee6&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1f46ba7e-6655-47b3-b6ff-8c73764ebee6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameStateShould
    {
        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DamageAllPlayersWhenEarthquake()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sut = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameState();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();

            sut.Players.Add(player1);
            sut.Players.Add(player2);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expectedHealthAfterEarthquake = player1.Health -&lt;span&gt; GameState.EarthquakeDamage;

            sut.Earthquake();

            Assert.Equal(expectedHealthAfterEarthquake, player1.Health);
            Assert.Equal(expectedHealthAfterEarthquake, player2.Health);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reset()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sut = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameState();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();

            sut.Players.Add(player1);
            sut.Players.Add(player2);

            sut.Reset();

            Assert.Empty(sut.Players);            
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;看一下上面的代码, 里面有一个Sleep 2秒的动作, 所以执行两个测试方法的话每个方法都会执行这个动作, 一共用了这些时间:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210105550920-1617696275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题, 我们首先建立一个类 GameStateFixture.cs, 它需要实现IDisposable接口:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameStateFixture : IDisposable
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GameState State { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GameStateFixture()
        {
            State &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameState();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cleanup&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在GameStateShould类实现IClassFixture接口并带有泛型的类型:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GameStateShould : &lt;span&gt;IClassFixture&amp;lt;GameStateFixture&amp;gt;&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private readonly GameStateFixture _gameStateFixture;
        private readonly ITestOutputHelper _output;

        public GameStateShould(GameStateFixture gameStateFixture, ITestOutputHelper output)
        {
            _gameStateFixture = gameStateFixture;
            _output =&lt;/span&gt;&lt;span&gt;&lt;span&gt; output;
        }&lt;/span&gt;

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DamageAllPlayersWhenEarthquake()
        {
            &lt;span&gt;_output.WriteLine($&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;GameState Id={_gameStateFixture.State.Id}&quot;);
            
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();

            &lt;span&gt;_gameStateFixture.State&lt;/span&gt;.Players.Add(player1);
            &lt;span&gt;_gameStateFixture.State&lt;/span&gt;.Players.Add(player2);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expectedHealthAfterEarthquake = player1.Health -&lt;span&gt; GameState.EarthquakeDamage;

            &lt;span&gt;_gameStateFixture.State&lt;/span&gt;.Earthquake();

            Assert.Equal(expectedHealthAfterEarthquake, player1.Health);
            Assert.Equal(expectedHealthAfterEarthquake, player2.Health);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Reset()
        {
            _output.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GameState Id={_gameStateFixture.State.Id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; player2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlayerCharacter();

            _gameStateFixture.State.Players.Add(player1);
            _gameStateFixture.State.Players.Add(player2);

            _gameStateFixture.State.Reset();

            Assert.Empty(_gameStateFixture.State.Players);            
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这个注入的_gameStateFixture在运行多个tests的时候只有一个实例. 所以把消耗资源严重的动作放在GameStateFixture里面就可以保证该段代码只运行一次, 并且被所有的test所共享调用. 要注意的是, 因为上述原因, GameStateFixture里面的代码不可以有任何副作用, 也就是说可以影响其他的测试结果&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Build, Run Tests:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210110743451-1795654741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到运行时间少了很多, 因为那段Sleep代码只需要运行一次.&lt;/p&gt;
&lt;p&gt;再查看一下这个两个tests的output是一样的, 也就是说明确实是只生成了一个GameState实例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210110922857-1742102079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面讲述了如何在一个测试类中不同的测试里共享代码的方法, 而xUnit也可以让我们在不同的测试类中共享上下文.&lt;/p&gt;
&lt;p&gt;在Tests项目里建立 GameStateCollection.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;span&gt;[CollectionDefinition(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;GameState collection&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GameStateCollection : &lt;span&gt;ICollectionFixture&amp;lt;GameStateFixture&amp;gt;&lt;/span&gt;&lt;span&gt; {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类GameStateCollection需要实现ICollectionFixture&amp;lt;T&amp;gt;接口, 但是它没有具体的实现.&lt;/p&gt;
&lt;p&gt;它上面的CollectionDefinition属性标签作用是定义了一个Collection名字叫做GameStateCollection. &lt;/p&gt;
&lt;p&gt;再建立TestClass1.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;span&gt;[Collection(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;GameState collection&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass1
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GameStateFixture _gameStateFixture;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ITestOutputHelper _output;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestClass1(GameStateFixture gameStateFixture, ITestOutputHelper output)
        {
            _gameStateFixture &lt;/span&gt;=&lt;span&gt; gameStateFixture;

            _output &lt;/span&gt;=&lt;span&gt; output;
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test1()
        {
            _output.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GameState ID={_gameStateFixture.State.Id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test2()
        {
            _output.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GameState ID={_gameStateFixture.State.Id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和TestClass2.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xunit.Abstractions;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Game.Tests
{
    &lt;span&gt;[Collection(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;GameState collection&quot;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestClass2
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; GameStateFixture _gameStateFixture;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ITestOutputHelper _output;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestClass2(GameStateFixture gameStateFixture, ITestOutputHelper output)
        {
            _gameStateFixture &lt;/span&gt;=&lt;span&gt; gameStateFixture;

            _output &lt;/span&gt;=&lt;span&gt; output;
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test3()
        {
            _output.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GameState ID={_gameStateFixture.State.Id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        [Fact]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test4()
        {
            _output.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GameState ID={_gameStateFixture.State.Id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TestClass1和TestClass2在类的上面使用Collection属性标签来调用名为GameState collection的Collection. 而不需要实现任何接口.&lt;/p&gt;
&lt;p&gt;这样, xUnit在运行测试之前会建立一个GameState实例共享与TestClass1和TestClass2.&lt;/p&gt;
&lt;p&gt;Build, 同时运行TestClass1和TestClass2的Tests:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210112056513-1658196283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行的时间为3秒多:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210112155763-684848626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看这4个test的output, 可以看到它们使用的是同一个GameState实例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201802/986268-20180210112220998-863374403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一部分先到这, 还剩下最后一部分了.&lt;/p&gt;

</description>
<pubDate>Sat, 10 Feb 2018 03:24:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8438019.html</dc:identifier>
</item>
</channel>
</rss>