<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>New Windows 10 SDK - Multi-instance UWP apps - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/8620370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/8620370.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前面一篇 About Windows 10 SDK Preview Build 17110 中，我们简单介绍了 Multi-instance UWP Apps，今天结合开发过程详细讲解一下。&lt;/p&gt;
&lt;p&gt;在 Windows 10 Version 1803 以前，UWP App 同一时间只能启动一个实例，而在 1803 开始，UWP App 可以通过开发者的配置选择来支持多实例。如果一个多实例 UWP App 正在运行，这时一个激活请求发送过来，平台不会直接激活当前的实例，而是会创建一个新的实例，运行在单独的进程中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开发过程&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置多实例支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;多实例特性需要在 Visual Studio 中安装新的项目模板：&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=AndrewWhitechapelMSFT.MultiInstanceApps&quot; target=&quot;_blank&quot;&gt;Multi-Instance App Project Templates.VSIX&lt;/a&gt;, 安装后，使用 C# 和 C++ 都可以创建项目。&lt;/p&gt;
&lt;p&gt;两个模板会被安装：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Multi-Instance UWP app -- 创建一个多实例的 App&lt;/li&gt;
&lt;li&gt;Multi-Instance Redirection UWP app -- 提供一个附加的逻辑，让用户可以选择启动新实例，或者选择目前激活的实例。可以想象一下 Office 打开或编辑文件时的场景。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180322111624904-203417930.jpg&quot; alt=&quot;&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个模板都会在 manifest 文件中添加 SupportsMultipleInstances，其中 desktop4 和 iot2 前缀标志了项目只支持传统桌面 Windows 和 IoT 系统。manifest 配置如下，我们只保留了新增的部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Package
  &lt;/span&gt;&lt;span&gt;...
  xmlns:desktop4&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/desktop/windows10/4&quot;&lt;/span&gt;&lt;span&gt;
  xmlns:iot2&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/appx/manifest/iot/windows10/2&quot;&lt;/span&gt;&lt;span&gt;  
  IgnorableNamespaces&lt;/span&gt;&lt;span&gt;=&quot;uap mp desktop4 iot2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ...
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Application &lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;=&quot;App&quot;&lt;/span&gt;&lt;span&gt;
      ...
      desktop4:SupportsMultipleInstances&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;
      iot2:SupportsMultipleInstances&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Applications&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   ...
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际运行时，每次点击 App 的磁贴，都会启动一个新的实例。如下图中，App 显示了启动的时间，在任务栏和运行窗口可以看到，两个实例同一时间在运行状态。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180322111014323-495734654.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;多实例激活重定向&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UWP App 对多实例的支持，可以让同一 App 的多个实例可以同时在运行。它运行开发者自己定义，是每次开启一个新的实例，还是重定向某个目前激活的应用。举例来说，让你想使用 App 编辑一个文件，而这个文件正在 App 中被编辑，这时就不应该再开启一个新的实例，而是应该重定向当前正在编辑文件的实例。这就会用到 Multi-Instance Redirection UWP app 模板。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Multi-Instance Redirection UWP app 模板和我们上面看到的一样，对 manifest 文件会做同样的调整。同时该模板会增加一个 Program.cs 文件，在文件中包含一个 Main() 方法，靠这个方法来实现多实例激活的重定向操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180322112053669-1147038775.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来重点看看 Program.cs 文件中的 Main() 方法&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;activatedArgs 中包含了应用启动时我们定义的参数，我们根据这些参数，比如 key 来决定多实例的重定向方式；&lt;/li&gt;
&lt;li&gt;AppInstance.RecommendedInstance 系统推荐的实例，如果有，我们可以重定向到这个实例；&lt;/li&gt;
&lt;li&gt;多实例间唯一性的标识 key 的生成方式，我们可以根据 activatedArgs 来自定义，在默认的示例代码中，采用了随机数判断单双数的方式；&lt;/li&gt;
&lt;li&gt;FindOrRegisterInstanceForKey(key) 会查询当前对应 key 的实例，如果没有则新注册一个实例；&lt;/li&gt;
&lt;li&gt;判断实例是不是新注册的，如果是则启动，如果是查询到的原有实例，则重定向到那个实例；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; First, we'll get our activation event args, which are typically richer
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; than the incoming command-line args. We can use these in our app-defined
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; logic for generating the key for this instance.&lt;/span&gt;
    IActivatedEventArgs activatedArgs =&lt;span&gt; AppInstance.GetActivatedEventArgs();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; In some scenarios, the platform might indicate a recommended instance.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If so, we can redirect this activation to that instance instead, if we wish.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (AppInstance.RecommendedInstance != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        AppInstance.RecommendedInstance.RedirectActivationTo();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Define a key for this instance, based on some app-specific logic.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the key is always unique, then the app will never redirect.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the key is always non-unique, then the app will always redirect
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; to the first instance. In practice, the app should produce a key
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; that is sometimes unique and sometimes not, depending on its own needs.&lt;/span&gt;
        &lt;span&gt;uint&lt;/span&gt; number =&lt;span&gt; CryptographicBuffer.GenerateRandomNumber();
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key = (number % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;even&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;odd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance =&lt;span&gt; AppInstance.FindOrRegisterInstanceForKey(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (instance.IsCurrentInstance)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we successfully registered this instance, we can now just
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; go ahead and do normal XAML initialization.&lt;/span&gt;
            &lt;span&gt;global&lt;/span&gt;::Windows.UI.Xaml.Application.Start((p) =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; App());
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Some other instance has registered for this key, so we'll 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; redirect this activation to that instance instead.&lt;/span&gt;
&lt;span&gt;            instance.RedirectActivationTo();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 key 的构造和判断，以及判断后的处理，是多实例重定向的关键，我们先看看 FindOrRegisterInstanceForKey(key) 和 IsCurrentInstance 的注释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     如果另一个实例已注册该密钥，使用平台注册一个应用实例，或查找现有实例。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   key:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     作为实例密钥的非空字符串。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     表示已注册密钥的第一个应用的应用实例。&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AppInstance FindOrRegisterInstanceForKey(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     应用的当前实例是否是该实例定义的特定密钥的已注册实例。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     指示当前应用是否为该应用的已注册实例的布尔值。&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsCurrentInstance { &lt;span&gt;get&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;后台任务和多实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于后台任务的多实例，官方有以下说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程外的后台任务支持多实例，通常，每个新触发的结果会独立在一个后台任务的实例中；&lt;/li&gt;
&lt;li&gt;进程内的后台任务不支持多实例；&lt;/li&gt;
&lt;li&gt;后台音乐任务不支持多实例；&lt;/li&gt;
&lt;li&gt;当应用注册一个后台任务时，它通常会首先检查这个任务是否已经注册了，如果已注册，或删除重新创建它，或维持当前的注册。这也是多实例应用的典型特点。然而，多实例应用可能会选择在每个实例的基础上注册一个不同的后台任务名。这对导致多次注册相同的触发器，并且触发器触发时将会激活多个任务实例；&lt;/li&gt;
&lt;li&gt;应用服务会为每一个应用服务后台任务的连接启动一个单独的实例，这对多实例应用保持不变，即多实例应用的每个实例都会获得自己的应用服务后台任务实例；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;其他注意事项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于多实例应用，官方文档还提示了一些额外的注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持多实例应用的 UWP 应用，只能面向传统桌面系统和 IoT；&lt;/li&gt;
&lt;li&gt;为避免竞争条件和资源争夺的问题，多实例应用需要采取措施，分区和同步权限到对访问进行设置，应用本地存储和任何其他资源（如用户文件，数据存储等），以在多个实例间完成共享。标准的同步机制包括 mutexes，semaphores，events 等都是可用的；&lt;/li&gt;
&lt;li&gt;如果应用的 Package.appxmanifest 文件中存在 SupportsMultipleInstances 字段，那么他的扩展中不需要再声明 SupportsMultipleInstances；&lt;/li&gt;
&lt;li&gt;如果你把 SupportsMultipleInstances 添加到除后台任务，应用服务之外的的任何其他扩展中，并且托管该扩展的应用没有在 Package.appxmanifest 中声明 SupportsMultipleInstances，则会发生模式错误；&lt;/li&gt;
&lt;li&gt;应用可以在 manifest 中使用 ResourceGroup 来把多个后台任务分组到同一个宿主中， 这和多实例是冲突的，每个活动都会出现在单独的宿主中。因为一个应用不能同时声明 SupportsMultipleInstances 和 ResourceGroup；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多实例应用的介绍就到这里，大家可以结合自己应用的实际场景，更加合理的设置 key 和判断条件来使用多实例，谢谢！&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 06:29:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/8620370.html</dc:identifier>
</item>
<item>
<title>Git -- 分支与合并 (命令行+可视化工具p4merge) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8623290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8623290.html</guid>
<description>&lt;p&gt;把所有的变化都放在master分支并不是最好的做法. 建议的做法是把变化放在分支里面.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322095123010-1583128250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至少应该准备一个feature分支之类的, 把变化都隔离开来, 然后等到所有的功能都稳定之后再合并到master分支.&lt;/p&gt;
&lt;p&gt;说到分支, 就得使用&lt;strong&gt;git branch&lt;/strong&gt;命令.&lt;/p&gt;
&lt;h2&gt;列出所有的分支:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;git branch&lt;/strong&gt; 会列出所有的本地分支.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git branch -a&lt;/strong&gt; 会列出本地和远程的所有分支.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git branch&lt;br/&gt;git branch -a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322093538557-1550210440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色的是本地的分支, 红色的是远程分支.&lt;/p&gt;
&lt;p&gt;星号是表示这时当前活跃的分支.&lt;/p&gt;

&lt;h2&gt;创建分支:&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;git branch 分知名&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git branch mynewbranch
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322093805050-2115069431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;切换分支.&lt;/h2&gt;
&lt;p&gt;想切换分支的话, 需要使用&lt;strong&gt;git checkout 分知名&lt;/strong&gt; 这个命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git checkout mynewbranch
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322094019517-1207039442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那再看看历史纪录: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322094200481-1754413841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我现在还没有做任何更改, 所以这些分支都指向同一个commit, 其实分支就是标签/指针而已.&lt;/p&gt;

&lt;h2&gt;修改分支名.&lt;/h2&gt;
&lt;p&gt;再切换到master分支: git checkout master.&lt;/p&gt;
&lt;p&gt;然后使用&lt;strong&gt;git branch -m 分支名 新分知名&lt;/strong&gt; 来进行改名操作.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322094520943-1606037742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322094541512-1959779903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;删除分支.&lt;/h2&gt;
&lt;p&gt;注意不能删除当前活跃的分支.&lt;/p&gt;
&lt;p&gt;使用命令&lt;strong&gt;git branch -d 分支名&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git branch -d newbranch
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322094735169-1893276011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;快捷操作: 切换并创建分支: &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git checkout -b 分支名&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git checkout -b some-change
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322095615436-572912828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我打开某个文件(index.html)修改一下标题.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322095742128-740053351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322095858617-139176825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Commit之后查看历史纪录, 可以看到再some-change分支里, 修改了index.html的title.&lt;/p&gt;
&lt;p&gt;如果我想要把这个commit合并到master分支.&lt;/p&gt;
&lt;p&gt;首先要切换回到master分支:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git checkout master
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后, 我需要知道发生了哪些变化, 也就是比较这两个分支:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git diff master some-change
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322100254146-232198862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以可视化查看: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git difftool master some-change
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我这台电脑没有配置p4merge, 所以默认的可能是使用vimdiff可视化工具:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322100904242-773966738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后按esc再按:q退出.&lt;/p&gt;
&lt;p&gt;最后就是合并变化: &lt;strong&gt;git merge 需要被合并进来的分支名&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git merge some-change
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322101051126-1783730227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到里面列出了所涉及的commits, 并且这是一个fast-forward合并, 所涉及的文件, 以及有哪些变化.&lt;/p&gt;

&lt;p&gt;因为这是一个Fast Forward合并, Git把feature分支后来所有的commits都放在了master分支上, 就像没有分开过一样:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322101702036-1991404787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是Fast-forward合并只有在满足这个条件的时候才可能执行: 合并的时候master分支没有任何变化&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;合并后的状态如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322101826518-324753598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;合并之后, 就不需要这个分支了, 删除:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git branch -d some-change
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322101946561-483241432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时, git log里面只有master了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322102026081-770686108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;添加一个分支, 并且换到该分支:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
git checkout -b add-text
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322102439551-269880426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我再index.html里面添加点文字, 并commit.&lt;/p&gt;
&lt;p&gt;然后再修改README.md, 添加文字, commit.&lt;/p&gt;
&lt;p&gt;现在在 add-text这个分支上, 有两个commit, 看下log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322102754863-2076188253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后把这个分支合并到master分支.&lt;/p&gt;
&lt;p&gt;首先切换到master分支, 然后再进行git merge, 但是这一次, 我想把我这个分支的过程留下痕迹, 所以要禁用fast-forward 合并:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git merge 要被合并进来的分支 --no-ff&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;这样做的话, 将会出现一个新的合并commit, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322103223119-1322444550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看git log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322103312456-916911210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到, 整个分支的过程被记录了下来.&lt;/p&gt;
&lt;p&gt;最后删除这个分支, 并查看log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322103438902-1542598409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到, 删除分支以后, log里面分支的名没有了, 但是分支还在.&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322103719774-751575502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个分支并切换:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git checkout -b simple-changes
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;修改一个文件然后commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322104008788-1998040878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后回到master分支:&lt;/p&gt;
&lt;p&gt;再修改某个文件, 然后commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322104150877-1185173033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322104241207-1945326788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红线里面那部分就比较有趣了, 两个分支都有变化/commits.&lt;/p&gt;
&lt;p&gt;这种情况可以这么合并:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git merge 被合并进来的分支 -m &quot;自定义信息&quot;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git merge simple-changes -m &quot;merging changes from simple-changes&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322104627162-537224953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322104718485-401582692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到分支的合并已经完成了.&lt;/p&gt;
&lt;p&gt;最后删除分支, 查看log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322104829525-2088479561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果一样, 分支名没了, 但是分支的历史还是保留着的.&lt;/p&gt;
&lt;p&gt;可以打开两个文件看看, 改变的内容都保留着了.&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322131812631-1781312181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果两个分支上都对同一个文件进行了修改, 那么就有可能发生冲突.&lt;/p&gt;

&lt;p&gt;首先创建一个分支, 并切换到该分支上:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132002571-1651781970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后修改index.html, 修改几个地方吧.&lt;/p&gt;
&lt;p&gt;然后查看状态, 并commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132247560-98286922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后切换到master, 并编辑同一个文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132346258-1419931549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这时index.html并不是realwork分支修改后的样子, 而是修改之前的样子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132437192-31591488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后修改index.html, 修改几处可能引起冲突的地方.&lt;/p&gt;
&lt;p&gt;commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132752347-1798761055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132837030-1739157038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来最应该做的就是diff:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322132933741-741263212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以使用可视化工具进行diff:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322133212934-990074546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面进行合并:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322133312737-707857169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不出所料, 冲突发生了, 自动合并失败.&lt;/p&gt;
&lt;p&gt;现在的状态, 应该叫做Merging状态.&lt;/p&gt;
&lt;p&gt;现在打开index.html是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322133505898-713116129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到两处冲突, 每处都有HEAD(master)版的和realwork分支版的.&lt;/p&gt;
&lt;p&gt;上图我使用的是Visual Studio Code, 可以点击上面的按钮来进行冲突的解决, 也可以手动修改文件进行解决.&lt;/p&gt;
&lt;p&gt;但是在这里我使用我配置好的mergetool:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git mergetool&lt;/strong&gt;. 这个命令将会打开p4merge(我本机配置的mergetool):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134240607-1324303582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按图示操作, 点击图标选择不同的版本, 最后点击保存即可.&lt;/p&gt;
&lt;p&gt;关闭p4merge:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134409689-1711980597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134515488-1962639486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;commit之后, 状态就不再是merging了, 但是会出现一个未被追踪的文件:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134611240-356832780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为在解决冲突的时候, git会保存一个带有触痛的原始版本, 以备不时之需:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134710246-529290324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是.orig文件是不应该被追踪的, 所以需要添加到.gitignore文件中:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134811919-1321835787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后查看状态:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134832932-2139288935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次只有.gitignore发生了变化.&lt;/p&gt;
&lt;p&gt;commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322134927431-1347003615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后可以删除 realwork 分支了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322135014046-2038424276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看log:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180322135106412-480647511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Ok.&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 05:57:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8623290.html</dc:identifier>
</item>
<item>
<title>java容器类4：Queue深入解读 - NeilZhang</title>
<link>http://www.cnblogs.com/NeilZhang/p/8623207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeilZhang/p/8623207.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134758958-1140397352.png&quot;&gt;&lt;img title=&quot;1594931-293dba23ebc504c2&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134759428-1795770950.png&quot; alt=&quot;1594931-293dba23ebc504c2&quot; width=&quot;640&quot; height=&quot;360&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Collection的其它两大分支：List和Set在前面已近分析过，这篇来分析一下Queue的底层实现。&lt;/p&gt;
&lt;p&gt;前三篇关于Java容器类的文章：&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/8516922.html&quot;&gt;java容器类1：Collection,List,ArrayList,LinkedList深入解读&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/8577991.html&quot;&gt;java容器类2：Map及HashMap深入解读&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/8594361.html&quot;&gt;java容器类3：set/HastSet/MapSet深入解读&lt;/a&gt;&lt;/h3&gt;
&lt;h2&gt;Queue&lt;/h2&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Queue&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; Collection&amp;lt;E&amp;gt; {
    &lt;span&gt;boolean&lt;/span&gt; add(E var1);

    &lt;span&gt;boolean&lt;/span&gt; offer(E var1);

    E remove();

    E poll();

    E element();

    E peek();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
这就是Queue接口的代码，相比于List或者Set简洁明了很多。下面介绍一下它里面接口的含义：
&lt;/pre&gt;
&lt;pre&gt;
在处理元素前用于保存元素的 collection。除了基本的 &lt;a href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Collection.html&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; 操作外，队列还提供其他的
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;插入、提取和检查&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
操作。每个方法都存在两种形式：
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;一种抛出异常（操作失败时），另一种返回一个特殊值（&lt;tt&gt;null&lt;/tt&gt; 或 &lt;tt&gt;false&lt;/tt&gt;，具体取决于操作）。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
插入操作的后一种形式是用于专门为有容量限制的 &lt;tt&gt;Queue&lt;/tt&gt; 实现设计的；在大多数实现中，插入操作不会失败。
&lt;/pre&gt;
&lt;pre&gt;
&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134759700-540366955.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134759972-63747291.png&quot; alt=&quot;image&quot; width=&quot;205&quot; height=&quot;120&quot;/&gt;&lt;/a&gt;
&lt;/pre&gt;
&lt;pre&gt;

&lt;/pre&gt;
&lt;pre&gt;
&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134800339-753951988.png&quot;&gt;&lt;img title=&quot;1182892-20171122100317930-842768608&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134800652-82039989.png&quot; alt=&quot;1182892-20171122100317930-842768608&quot; width=&quot;640&quot; height=&quot;277&quot;/&gt;&lt;/a&gt;
&lt;/pre&gt;
&lt;h2&gt;AbstractQueue&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;AbstractQueue中实现了queue和Collection中部分函数，比较简单，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractQueue&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractCollection&amp;lt;E&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; Queue&amp;lt;E&amp;gt; {
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;protected&lt;/span&gt; AbstractQueue() {
    }
&lt;/pre&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; add(E e) {
        &lt;span&gt;if&lt;/span&gt; (offer(e))
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
        &lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;&lt;span&gt;Queue full&lt;/span&gt;&quot;);
    }


    &lt;span&gt;public&lt;/span&gt; E remove() {
        E x = poll();
        &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)
            &lt;span&gt;return&lt;/span&gt; x;
        &lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();
    }

    &lt;span&gt;public&lt;/span&gt; E element() {
        E x = peek();
        &lt;span&gt;if&lt;/span&gt; (x != &lt;span&gt;null&lt;/span&gt;)
            &lt;span&gt;return&lt;/span&gt; x;
        &lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchElementException();
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clear() {
        &lt;span&gt;while&lt;/span&gt; (poll() != &lt;span&gt;null&lt;/span&gt;)
            ;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt; c) {
        &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();
        &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;this&lt;/span&gt;)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException();
        &lt;span&gt;boolean&lt;/span&gt; modified = &lt;span&gt;false&lt;/span&gt;;
        &lt;span&gt;for&lt;/span&gt; (E e : c)
            &lt;span&gt;if&lt;/span&gt; (add(e))
                modified = &lt;span&gt;true&lt;/span&gt;;
        &lt;span&gt;return&lt;/span&gt; modified;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的调用关系可以看出来，Queue的解释中哪些是会抛出异常的调用，哪些是不会抛出异常的调用接口。&lt;/p&gt;
&lt;h2&gt;Deque&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;一个线性 collection，&lt;span&gt;支持在两端插入和移除元素。名称 &lt;em&gt;deque&lt;/em&gt; 是“double ended queue（双端队列）”的缩写&lt;/span&gt;，通常读为“deck”。大多数 &lt;tt&gt;Deque&lt;/tt&gt; 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。（java 1.6版本中的家扣，1.8中接口有变动，但是大概含义相似）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134800911-1895621081.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/918077/201803/918077-20180322134801624-1240916363.png&quot; alt=&quot;image&quot; width=&quot;500&quot; height=&quot;186&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/8516922.html&quot;&gt;Java容器类1&lt;/a&gt;中介绍了LinkedList，链表类其实实现了 Deque的接口，所以链表支持从头部和尾部添加和移除元素。&lt;/p&gt;
&lt;h2&gt;ArrayDeque&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;因为链表的存储结构可能比较简单，这里介绍一下ArrayDeque，它的里面存储元素使用一个数组。 作为一个双端队列的数组，涉及到扩容和元素的拷贝的逻辑可能比较复杂些。&lt;/p&gt;
&lt;p&gt;看一下里面的几个构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; ArrayDeque() {
        elements = 
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;new&lt;/span&gt; Object[16];&lt;/span&gt;
&lt;pre&gt;
    }


&lt;span&gt;public&lt;/span&gt; ArrayDeque(&lt;span&gt;int&lt;/span&gt; numElements) {
        
&lt;/pre&gt;
&lt;span&gt;allocateElements(numElements);&lt;/span&gt;
&lt;pre&gt;
    }

&lt;span&gt;public&lt;/span&gt; ArrayDeque(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt; c) {
        allocateElements(c.size());
        addAll(c);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从构造函数可以看出默认的会分配一个长度为16的数组。同时，也支持指定大小的队列（这里的allocateElements函数之前在&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/8577991.html&quot;&gt;java容器类2：Map及HashMap深入解读&lt;/a&gt;  中已经深入分析过，是个非常精妙的函数）。下面看一下到底是如何实现插入？又是如何自动扩充数组的?&lt;/p&gt;
&lt;p&gt;ArrayQueue中维护了两个成员变量：head和tail分别代表 队列的头和尾在数组中的下标。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**
     * The index of the element at the head of the deque (which is the
     * element that would be removed by remove() or pop()); or an
     * arbitrary number equal to tail if the deque is empty.
     */&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head;

    &lt;span&gt;/**
     * The index at which the next element would be added to the tail
     * of the deque (via addLast(E), add(E), or push(E)).
     */&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在队列的首部添加元素：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addFirst(E e) {
        &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;)
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();
        
&lt;/pre&gt;
&lt;span&gt;elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e;&lt;/span&gt;
&lt;pre&gt;
        &lt;span&gt;if&lt;/span&gt; (head == tail)
            
&lt;/pre&gt;
&lt;span&gt;doubleCapacity();&lt;/span&gt;
&lt;pre&gt;
    }
&lt;/pre&gt;
&lt;span&gt;public void&lt;/span&gt;
&lt;pre&gt;
addLast(E e) {&lt;br/&gt;&lt;/pre&gt;
&lt;span&gt;if&lt;/span&gt;
&lt;pre&gt;
 (e == 
&lt;/pre&gt;
&lt;span&gt;null&lt;/span&gt;
&lt;pre&gt;
)&lt;br/&gt;&lt;/pre&gt;
&lt;span&gt;throw new&lt;/span&gt;
&lt;pre&gt;
 NullPointerException();&lt;br/&gt;elements[tail] = e;&lt;br/&gt;&lt;/pre&gt;
&lt;span&gt;if&lt;/span&gt;
&lt;pre&gt;
 ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head)&lt;br/&gt;doubleCapacity();&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由构造函数和数组分配的函数可以知道，数组的长度肯定是一个2的幂次方的一个整数。&lt;/p&gt;
&lt;p&gt;当head为大于0的整数时，在头部插入很简单，将head前一个元素赋值为e就可以了。那么当head为0时，怎么计算的？由上面可以看出会插入到数组的尾部。所以ArrayDeque相当于在一个圆环上，规定一个头一个尾作为队列的前后（将数组的首位相连）。&lt;/p&gt;
&lt;p&gt;在最后位置添加元素的原理和在首部添加相似。注意判断是否已满的 判断，这里不再分析。&lt;/p&gt;
&lt;p&gt;当队列已经满后，会将数组的长度double。由于数组是不能自由扩张的，所以doubleCapacity函数应该是分配一个更大的数组，并将原来的元素拷贝进去，这里不再分析。&lt;/p&gt;
&lt;p&gt;总的来说双端队列ArrayDeque是在数组的基础之上实现，原理和实现都不算复杂，但是很多边界调节等细节可以斟酌。&lt;/p&gt;
&lt;h2&gt;BlockingQueue&lt;/h2&gt;
&lt;hr/&gt;&lt;pre&gt;
BlockingQueue是concurrent包下面的，后续打算写一个系列文章专门分析concurrent包下面的类，及一些多线程相关的东西。
&lt;/pre&gt;
&lt;h2&gt;PriorityQueue&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;优先级队列是一个可以排序的队列。内部是一个最大堆，大部分人应该了解堆排序，所以对最大堆应该不会陌生。&lt;/p&gt;
&lt;p&gt;每次读取元素都是读取最大的元素（默认情况下）。&lt;/p&gt;
&lt;p&gt;对外的接口有如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;add(E e)&lt;/td&gt;
&lt;td&gt;添加元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;clear()&lt;/td&gt;
&lt;td&gt;清空&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;contains(Object o)&lt;/td&gt;
&lt;td&gt;检查是否包含当前参数元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;offer(E e)&lt;/td&gt;
&lt;td&gt;添加元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;peek()&lt;/td&gt;
&lt;td&gt;读取元素，（不删除）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;取出元素，（删除）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;remove(Object o)&lt;/td&gt;
&lt;td&gt;删除指定元素&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;size()&lt;/td&gt;
&lt;td&gt;返回长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;PriorityQueue 默认是一个最大堆结构，如果想构造一个最小堆：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 11;
PriorityQueue&amp;lt;Integer&amp;gt; maxHeap=&lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;Integer&amp;gt;(DEFAULT_INITIAL_CAPACITY, &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Integer&amp;gt;() {
        @Override
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compare(Integer o1, Integer o2) {
            &lt;span&gt;return&lt;/span&gt; o2-o1;
        }
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于堆的数据结构部分这里不再分析可以参考：&lt;a title=&quot;https://www.cnblogs.com/tstd/p/5125949.html&quot; href=&quot;https://www.cnblogs.com/tstd/p/5125949.html&quot;&gt;https://www.cnblogs.com/tstd/p/5125949.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;c++版的优先级队列分析：&lt;a href=&quot;http://www.cnblogs.com/NeilZhang/p/6485013.html&quot;&gt;优先级队列用法详解（priority_queue）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于是通过数组保存数据，所以优先级队列也会涉及到容量的扩充等，和HashMap/Setting/Collection的扩容原理相同，甚至更简单，不再分析。PriorityQueue内部的操作都是在最大堆的基础上展开的，阅读堆的数据结构相关资料便可了解。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html&quot; href=&quot;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html&quot;&gt;http://tool.oschina.net/uploads/apidocs/jdk-zh/java/util/Deque.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://www.cnblogs.com/NeilZhang/p/5650226.html&quot; href=&quot;http://www.cnblogs.com/NeilZhang/p/5650226.html&quot;&gt;http://www.cnblogs.com/NeilZhang/p/5650226.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 05:50:00 +0000</pubDate>
<dc:creator>NeilZhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeilZhang/p/8623207.html</dc:identifier>
</item>
<item>
<title>HyperLedger Fabric 1.1 手动部署单机单节点 - Aberic</title>
<link>http://www.cnblogs.com/aberic/p/8618556.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aberic/p/8618556.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;手动部署单机单节点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前发布过官方的e2e部署方案，由于环境或是访问权限等各种问题，还是有相当一部分码友无法成功跑起来，故此，本章将来一次纯手动操作的集群部署。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要需要的步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1：环境整理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2：环境部署&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3：源码安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4：生成证书文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5：orderer节点处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6：peer节点处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　7：channel创建加盟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　8：chaincode安装部署实例化、测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本次不再分章，一章写完。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;环境整理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一步并非必须，但鉴于docker容器的实际情况，理论上linux内核需要在3.10及以上。有朋友在3.10上跑通过，具体是什么内核版本没详细去确认，为了顺利起见，请首先升级linux内核到4.x，按照&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/aberic/articles/8618380.html&quot; target=&quot;_blank&quot;&gt;CentOS 7. × 系统及内核升级指南&lt;/a&gt;&lt;span&gt;最终通过如下命令来查询版本信息：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;结果应如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180321174427910-1609258639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;除了上述操作外，相关依赖包若无强制性要求，可全部升级到最新版，执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum upgrade
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;环境部署&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7531202.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（二）——环境构建（公网）&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7531276.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（三）——环境构建（内网/准离线）&lt;/a&gt;两篇文章中，个人感觉已经写的很详尽了，这里就不再赘述，最后给一个我新搭建的环境截图，在写这篇文章的时候，docker和go都有了版本升级，所以我都应用的最新版本，实际版本图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180321175337230-1176366779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;源码安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;截止今日Fabric已经发布了1.1release版，由于时间问题，原本打算整理的版本升级list会延后发布。这里为了顺应需求，也就拿1.1的版本来做部署，具体下载地址&lt;a href=&quot;https://github.com/hyperledger/fabric/tree/v1.1.0&quot; target=&quot;_blank&quot;&gt;hyperledger/fabric v1.1.0&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请自行通过上述地址download最新版本到本地，或按照&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7532114.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（四）——Fabric源码及镜像文件处理&lt;/a&gt;中的方案进行安装也一样。&lt;/p&gt;
&lt;p&gt;源码下载到本地后，上传至/home或/data或其它数据存储（看着顺眼）的目录中，稍后补图看结果。&lt;/p&gt;
&lt;p&gt;这里说明下，fabric的安装目录并非一定要在哪哪哪，但在yaml中的工作路径和映射路径一定不能写错，否则会导致fabric中shim的api各种调用失败（原因如下图），所以还是按照官方的习惯部署会妥当点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180321180305044-1236783063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上述，我选择/home作为根目录，所以我的fabric会安装在/home/docker/github.com/hyperledger/fabric这个路径下，这个路径中的docker目录可以无视，看上图并记住“github.com/hyperledger/fabric”这个才是关键，对于新手来说不要动了，老鸟随意。&lt;/p&gt;
&lt;p&gt;最终我的目录结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180321180537657-1046543921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你们会发现这里多了一个aberic的目录，这是我自己新建的项目目录，有javaweb开发经验的朋友应该能明白如何在tomcat的webapp中部署自己的项目，其实也类似，方便我自己管理和维护。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;生成证书文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这一步之前的文章也发过，&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7532421.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（五）——运行测试e2e&lt;/a&gt;，但总还是有码友看的不仔细或把这一整章给略过了，群里不时还会有码友问这些操作。&lt;/p&gt;
&lt;p&gt;为了确保完整性，这里就再次重复一遍操作，在上述链接章节中提到了三种获取生成证书文件必备的二进制文件方案，我们使用官网提供的&lt;a href=&quot;https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/&quot;&gt;离线下载网址&lt;/a&gt;，找到我们本章计划操作的1.1的版本信息，可以得到最终的离线&lt;a href=&quot;https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/darwin-amd64-1.1.0/&quot;&gt;下载文件地址&lt;/a&gt;，下载该&lt;a href=&quot;https://nexus.hyperledger.org/content/repositories/releases/org/hyperledger/fabric/hyperledger-fabric/darwin-amd64-1.1.0/hyperledger-fabric-darwin-amd64-1.1.0.tar.gz&quot;&gt;文件&lt;/a&gt;到本地。&lt;/p&gt;
&lt;p&gt;根据官网的介绍，解压后会得到一个bin文件夹，将其解压至/home/docker/github.com/hyperledger/fabric/aberic目录下。&lt;/p&gt;
&lt;p&gt;接下来，我们继续参考&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7542835.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（八）——Fabric多节点集群生产部署&lt;/a&gt;中写到的方案来生成必须的证书文件。&lt;/p&gt;
&lt;p&gt;这里说下，在本章操作中使用的&lt;a href=&quot;https://github.com/hyperledger/fabric/blob/v1.0.0/examples/e2e_cli/configtx.yaml&quot; target=&quot;_blank&quot;&gt;configtx.yaml&lt;/a&gt;是用的1.0版本的，虽然我们是在1.1的环境中进行部署，相对而言，个人感觉1.1的e2e demo把入门门槛进一步拉高了，导致很多人运行起来很费劲，始终无法跑通。与之配套的&lt;a href=&quot;https://github.com/hyperledger/fabric/blob/v1.0.0/examples/e2e_cli/crypto-config.yaml&quot; target=&quot;_blank&quot;&gt;crypto-config.yaml&lt;/a&gt;也采用1.0版本提供的demo。相关文件自行点入下载或copy。&lt;/p&gt;
&lt;p&gt;运行二进制文件需要在命令行中指定路径，故此我的路径安排如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322103531581-1999624468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们就可以开始生成所需证书文件了，我们执行相关命令需要指定执行文件的路径，故此，为了方便，直接进入aberic项目目录下进行操作，随后执行如下命令生成我们项目所需文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./bin/cryptogen generate --config=./crypto-config.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果示图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322103755339-881319306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能各位在执行过程中会报一些没有权限的异常，这些我在&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7542835.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（八）——Fabric多节点集群生产部署&lt;/a&gt;已经提到过了，就不赘述了。&lt;/p&gt;
&lt;p&gt;上述命令生成的证书文件在/home/docker/github.com/hyperledger/fabric/aberic/crypto-config目录下，也就是说会自动创建一个crypto-config文件夹，示图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322104235499-2052188853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，要根据&lt;a href=&quot;https://github.com/hyperledger/fabric/blob/v1.0.0/examples/e2e_cli/configtx.yaml&quot; target=&quot;_blank&quot;&gt;configtx.yaml&lt;/a&gt;来生成创世区块，具体命令及&lt;span&gt;综合&lt;/span&gt;截图效果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./bin/configtxgen -profile TwoOrgsOrdererGenesis -outputBlock ./channel-artifacts/genesis.block
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322104454793-223379916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，出现了一个小问题，提示没有该文件或文件夹，channel-artifacts是一个文件夹，故此，我们在/home/docker/github.com/hyperledger/fabric/aberic目录下手动创建一个channel-artifacts文件夹，随后再次运行上述命令，，具体命令及&lt;span&gt;综合&lt;/span&gt;截图效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322104818667-1049996135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终会在/home/docker/github.com/hyperledger/fabric/aberic/channel-artifacts目录下创建出我们&lt;span&gt;指定名称&lt;/span&gt;的创世区块，ftp结果视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322104953950-96591870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创世区块是为了orderer启动时用到的，peer在启动后需要创建的channel配置文件在这里也一并生成，执行具体命令和&lt;span&gt;综合&lt;/span&gt;结果示图如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./bin/configtxgen -profile TwoOrgsChannel -outputCreateChannelTx ./channel-artifacts/mychannel.tx -channelID mychannel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322105236652-1552336951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该命令是生成了一个channelID为mychannel的tx文件（文件名称看各位心情来取），通过该文件，peer可以执行channel的创建工作，后面会提到。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;orderer节点处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;单机多节点部署，至少本章采用的共识模式的solo，而非kafka，如果开始考虑kafka做集群的话，相信本章的内容已经不再适合你了，本章偏基础。&lt;/p&gt;
&lt;p&gt;首先需要编写一份docker-orderer.yaml文件，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_86af5f6b-6b28-4192-a995-32ced0ed06bc&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_86af5f6b-6b28-4192-a995-32ced0ed06bc&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_86af5f6b-6b28-4192-a995-32ced0ed06bc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;services:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  orderer.example.com:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    container_name: orderer.example.com
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     image: hyperledger/fabric-&lt;span&gt;orderer
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=&lt;span&gt;aberic_default
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       # - ORDERER_GENERAL_LOGLEVEL=&lt;span&gt;error
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       - ORDERER_GENERAL_LOGLEVEL=&lt;span&gt;debug
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       - ORDERER_GENERAL_LISTENADDRESS=&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;       - ORDERER_GENERAL_LISTENPORT=&lt;span&gt;7050&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;       #- ORDERER_GENERAL_GENESISPROFILE=&lt;span&gt;AntiMothOrdererGenesis
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       - ORDERER_GENERAL_GENESISMETHOD=&lt;span&gt;file&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       - ORDERER_GENERAL_GENESISFILE=/var/hyperledger/orderer/&lt;span&gt;orderer.genesis.block
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       - ORDERER_GENERAL_LOCALMSPID=&lt;span&gt;OrdererMSP
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       - ORDERER_GENERAL_LOCALMSPDIR=/var/hyperledger/orderer/&lt;span&gt;msp
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       #- ORDERER_GENERAL_LEDGERTYPE=&lt;span&gt;ram
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       #- ORDERER_GENERAL_LEDGERTYPE=&lt;span&gt;file&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      # enabled TLS
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       - ORDERER_GENERAL_TLS_ENABLED=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;       - ORDERER_GENERAL_TLS_PRIVATEKEY=/var/hyperledger/orderer/tls/&lt;span&gt;server.key
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       - ORDERER_GENERAL_TLS_CERTIFICATE=/var/hyperledger/orderer/tls/&lt;span&gt;server.crt
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       - ORDERER_GENERAL_TLS_ROOTCAS=[/var/hyperledger/orderer/tls/&lt;span&gt;ca.crt]
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     working_dir: /opt/gopath/src/github.com/hyperledger/&lt;span&gt;fabric
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    command: orderer
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    volumes:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     - ./channel-artifacts/genesis.block:/var/hyperledger/orderer/&lt;span&gt;orderer.genesis.block
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/msp:/var/hyperledger/orderer/&lt;span&gt;msp
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     - ./crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tls/:/var/hyperledger/orderer/&lt;span&gt;tls
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    networks:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;      default:
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        aliases:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;           -&lt;span&gt; aberic
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;       - &lt;span&gt;7050&lt;/span&gt;:&lt;span&gt;7050&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;docker-orderer.yaml&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;peer节点处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有了orderer启动文件，我们还需要docker-peer.yaml启动文件，orderer和peer的启动yaml文件名称随意看心情，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_3405cc9b-8678-4d6e-ba5f-9952c3707ab5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3405cc9b-8678-4d6e-ba5f-9952c3707ab5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3405cc9b-8678-4d6e-ba5f-9952c3707ab5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;services:
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;  couchdb:
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;    container_name: couchdb
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     image: hyperledger/fabric-&lt;span&gt;couchdb
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     # Comment/Uncomment the port mapping &lt;span&gt;if&lt;/span&gt; you want to hide/&lt;span&gt;expose the CouchDB service,
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     # &lt;span&gt;for&lt;/span&gt; example map it to utilize Fauxton User Interface &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dev environments.
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;       - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5984:5984&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;  ca:
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    container_name: ca
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     image: hyperledger/fabric-&lt;span&gt;ca
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;       - FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-&lt;span&gt;server
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;       - FABRIC_CA_SERVER_CA_NAME=&lt;span&gt;ca
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;       - FABRIC_CA_SERVER_TLS_ENABLED=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;       - FABRIC_CA_SERVER_TLS_CERTFILE=/etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-&lt;span&gt;cert.pem
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;       - FABRIC_CA_SERVER_TLS_KEYFILE=/etc/hyperledger/fabric-ca-server-config/&lt;span&gt;95e05e630b6fd2f16b6367823c3a1295cc86e96431dd87b1376bea1d6120eb90_sk
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;       - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7054:7054&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     command: &lt;span&gt;sh&lt;/span&gt; -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fabric-ca-server start --ca.certfile /etc/hyperledger/fabric-ca-server-config/ca.org1.example.com-cert.pem --ca.keyfile /etc/hyperledger/fabric-ca-server-config/95e05e630b6fd2f16b6367823c3a1295cc86e96431dd87b1376bea1d6120eb90_sk -b admin:adminpw -d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    volumes:
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;       - ./crypto-config/peerOrganizations/org1.example.com/ca/:/etc/hyperledger/fabric-ca-server-&lt;span&gt;config
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;  peer0.org1.example.com:
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    container_name: peer0.org1.example.com
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     image: hyperledger/fabric-&lt;span&gt;peer
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;       - CORE_LEDGER_STATE_STATEDATABASE=&lt;span&gt;CouchDB
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;       - CORE_LEDGER_STATE_COUCHDBCONFIG_COUCHDBADDRESS=couchdb:&lt;span&gt;5984&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;       - CORE_PEER_ID=&lt;span&gt;peer0.org1.example.com
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;       - CORE_PEER_NETWORKID=&lt;span&gt;aberic
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;       - CORE_PEER_ADDRESS=peer0.org1.example.com:&lt;span&gt;7051&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;       - CORE_PEER_CHAINCODELISTENADDRESS=peer0.org1.example.com:&lt;span&gt;7052&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;       - CORE_PEER_GOSSIP_EXTERNALENDPOINT=peer0.org1.example.com:&lt;span&gt;7051&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;       - CORE_PEER_LOCALMSPID=&lt;span&gt;Org1MSP
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;       - CORE_VM_ENDPOINT=unix:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;host/var/run/docker.sock&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;      # the following setting starts chaincode containers on the same
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;      # bridge network as the peers
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;       # https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;docs.docker.com/compose/networking/&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;       - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=&lt;span&gt;aberic
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;       # - CORE_LOGGING_LEVEL=&lt;span&gt;ERROR
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;       - CORE_LOGGING_LEVEL=&lt;span&gt;DEBUG
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;       - CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE=&lt;span&gt;aberic_default
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;       - CORE_PEER_GOSSIP_SKIPHANDSHAKE=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;       - CORE_PEER_GOSSIP_USELEADERELECTION=&lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;       - CORE_PEER_GOSSIP_ORGLEADER=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;       - CORE_PEER_PROFILE_ENABLED=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;       - CORE_PEER_TLS_ENABLED=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;       - CORE_PEER_TLS_CERT_FILE=/etc/hyperledger/fabric/tls/&lt;span&gt;server.crt
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;       - CORE_PEER_TLS_KEY_FILE=/etc/hyperledger/fabric/tls/&lt;span&gt;server.key
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;       - CORE_PEER_TLS_ROOTCERT_FILE=/etc/hyperledger/fabric/tls/&lt;span&gt;ca.crt
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;    volumes:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         - /var/run/:/host/var/run/
&lt;span&gt; 60&lt;/span&gt;         - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/msp:/etc/hyperledger/fabric/&lt;span&gt;msp
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         - ./crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls:/etc/hyperledger/fabric/&lt;span&gt;tls
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     working_dir: /opt/gopath/src/github.com/hyperledger/fabric/&lt;span&gt;peer
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    command: peer node start
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;       - &lt;span&gt;7051&lt;/span&gt;:&lt;span&gt;7051&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;       - &lt;span&gt;7052&lt;/span&gt;:&lt;span&gt;7052&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;       - &lt;span&gt;7053&lt;/span&gt;:&lt;span&gt;7053&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    depends_on:
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;       -&lt;span&gt; couchdb
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;    networks:
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;      default:
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        aliases:
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;           -&lt;span&gt; aberic
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    extra_hosts:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;      - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderer.example.com:x.x.x.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;  cli:
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    container_name: cli
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     image: hyperledger/fabric-&lt;span&gt;tools
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     tty: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;       - GOPATH=/opt/&lt;span&gt;gopath
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;       - CORE_VM_ENDPOINT=unix:&lt;span&gt;///&lt;/span&gt;&lt;span&gt;host/var/run/docker.sock&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;       # - CORE_LOGGING_LEVEL=&lt;span&gt;ERROR
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;       - CORE_LOGGING_LEVEL=&lt;span&gt;DEBUG
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;       - CORE_PEER_ID=&lt;span&gt;cli
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;       - CORE_PEER_ADDRESS=peer0.org1.example.com:&lt;span&gt;7051&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;       - CORE_PEER_LOCALMSPID=&lt;span&gt;Org1MSP
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;       - CORE_PEER_TLS_ENABLED=&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;       - CORE_PEER_TLS_CERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/&lt;span&gt;server.crt
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;       - CORE_PEER_TLS_KEY_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/&lt;span&gt;server.key
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;       - CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/&lt;span&gt;ca.crt
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;       - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/&lt;span&gt;msp
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     working_dir: /opt/gopath/src/github.com/hyperledger/fabric/&lt;span&gt;peer
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;    volumes:
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         - /var/run/:/host/var/run/
&lt;span&gt; 97&lt;/span&gt;         - ./chaincode/go/:/opt/gopath/src/github.com/hyperledger/fabric/aberic/chaincode/&lt;span&gt;go
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         - ./crypto-config:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
&lt;span&gt; 99&lt;/span&gt;         - ./channel-artifacts:/opt/gopath/src/github.com/hyperledger/fabric/peer/channel-&lt;span&gt;artifacts
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    depends_on:
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;       -&lt;span&gt; peer0.org1.example.com
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    extra_hosts:
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;      - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orderer.example.com:x.x.x.x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;docker-peer.yaml&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;peer的这份启动文件是目前所写的最全文件，里面有cli客户端、couchdb插件以及ca插件。&lt;/p&gt;
&lt;p&gt;有几个地方需要注意修改下，首先是ca部分有两处，一处是FABRIC_CA_SERVER_TLS_KEYFILE，另一处是command中最后一部分，这两处的_sk文件名称需要替换成之前生成的证书文件名称，其实这里的主要目的是加载ca并生成ca用户。&lt;/p&gt;
&lt;p&gt;这个peer启动文件启动的是peer0.org1.example.com节点，所以对应的ca证书文件在peer0.org1.example.com下可以找到，具体路径是/home/docker/github.com/hyperledger/fabric/aberic/crypto-config/peerOrganizations/org1.example.com/ca&lt;/p&gt;
&lt;p&gt;目标视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322111937297-1054931596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后将docker-peer.yaml中两处的d8785a9dbc94f677d3e1e6aeb3a6222ee6579fe751204ac1b70094e1d3f0fe06_sk替换成95e05e630b6fd2f16b6367823c3a1295cc86e96431dd87b1376bea1d6120eb90_sk即可。&lt;/p&gt;
&lt;p&gt;切记这里的替换是替换各位自己生成的，我在这只是一个demo说明，以免到时无法跑通！！！&lt;/p&gt;
&lt;p&gt;另外就是ip处理，ip即本机内网ip就可以了，尝试127.0.0.1，或ipv4的内网地址。&lt;/p&gt;
&lt;p&gt;在cli客户端配置中我们指定了智能合约的部署路径，故此，我们在aberic目录下创建与之对应的chaincode文件夹，并在该文件夹下创建go文件夹，表示合约目录下以go语言为基础的合约目录。&lt;/p&gt;
&lt;p&gt;最终效果截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322112439060-486033178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，我把官方demo中的chaincode_example02示例也一并上传到go目录下，稍后会以该合约为基础进行测试。&lt;/p&gt;
&lt;p&gt;接下来将编写好的docker-orderer.yaml和docker-peer.yaml文件上传至aberic目录下，最终结果示图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322112620445-1361070187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行如下命令启动orderer和peer，按照顺序应该先启动排序服务，命令及综合视图如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-compose -f docker-orderer.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-compose -f docker-peer.yaml up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322112907258-918974677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图有点问题，可能是ssh的问题，导致peer启动的命令被后续命令覆盖。&lt;/p&gt;
&lt;p&gt;当然，运行到此步可能有码友提示需要启动镜像，这个我就不赘述了，直接参考&lt;a href=&quot;http://www.cnblogs.com/aberic/p/7532114.html&quot; target=&quot;_blank&quot;&gt;Hyperledger Fabric 1.0 从零开始（四）——Fabric源码及镜像文件处理&lt;/a&gt;，所需镜像截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322113158045-1675369362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在启动完成后，我们执行如下命令查看容器是否都已启动，具体结果视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322113254753-1283444733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到所有的容器都已经成功启动，接下来就是channel和chaincode的操作了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;channel创建加盟&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对peer的操作基本都需要依赖客户端完成，这里我们没有用sdk，但安装了tools镜像，即cli客户端，可以通过如下命令进入客户端进行channel的相关操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker exec -it cli bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随后执行如下命令创建一个channel：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
peer channel create -o orderer.example.com:&lt;span&gt;7050&lt;/span&gt; -c mychannel -t &lt;span&gt;50&lt;/span&gt; -f ./channel-artifacts/mychannel.tx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，这个channel的创建并非随意，而是之前创建过一个mychannel.tx文件，在创建该文件的时候就已经指定了channelID是mychannel，这里不能随意看心情了。&lt;/p&gt;
&lt;p&gt;随后执行ls即可查看已经创建的mychannel.block文件。&lt;/p&gt;
&lt;p&gt;最终执行效果视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322122923606-1176514952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完channel后，我们需要通过mychannel.block文件来加入该channel，以便后续可以安装实例化并测试智能合约。&lt;/p&gt;
&lt;p&gt;具体命令和视图结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
peer channel &lt;span&gt;join&lt;/span&gt; -b mychannel.block
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322122933961-860201698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此，我们已经完成了channel的创建并成功加入了该channel。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;chaincode安装部署实例化、测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在之前我们上传了官方的chaincode demo到go目录下，合约目录为/home/docker/github.com/hyperledger/fabric/aberic/chaincode/go/chaincode_example02，这个目录也是我们即将安装的智能合约路径。&lt;/p&gt;
&lt;p&gt;首先安装智能合约，具体命令和执行结果如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
peer chaincode &lt;span&gt;install&lt;/span&gt; -n mychannel -p github.com/hyperledger/fabric/aberic/chaincode/go/chaincode_example02 -v &lt;span&gt;1.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322123109263-1135150246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 安装完成后需要进行实例化chaincode，执行如下命令并有如下视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
peer chaincode instantiate -o orderer.example.com:&lt;span&gt;7050&lt;/span&gt; -C mychannel -n mychannel -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;Args&quot;:[&quot;init&quot;,&quot;A&quot;,&quot;10&quot;,&quot;B&quot;,&quot;10&quot;]}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -P &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OR ('Org1MSP.member')&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -v &lt;span&gt;1.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322124313518-1308043221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图有些问题，但最终执行是成功的。&lt;/p&gt;
&lt;p&gt;我们看合约提供的方法中有个query方法，需要传入一个参数，我们执行一次查询看看实例化时候的结果是否传入，如下命令和视图：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
peer chaincode query -C mychannel -n mychannel -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;Args&quot;:[&quot;query&quot;,&quot;A&quot;]}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322124931143-424208578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们查到A有10快钱，符合初始化init时候的传参，继续执行如下命令查询B的，视图也如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
peer chaincode query -C mychannel -n mychannel -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;Args&quot;:[&quot;query&quot;,&quot;B&quot;]}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322125053486-1918204754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到B也有10快钱。&lt;/p&gt;
&lt;p&gt;我们根据合约内容，让A给B转5快钱，执行如下命令并附视图（包括最终再次查询A和B资金的结果）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322125324326-1702831835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到合约已经运行无误，A成功给B转让了5快钱。&lt;/p&gt;

&lt;p&gt;至此，先暂时告一段落，多节点部署也是在这个基础上进行的，由于章节太长，下次开接续部分的章节来完善这一块内容，且时间确实比较忙，如果能把这个跑通，后面再部署新节点就肯定能跑通了，最终开一个新节点的视图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1240530/201803/1240530-20180322130210210-1950046640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 05:05:00 +0000</pubDate>
<dc:creator>Aberic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aberic/p/8618556.html</dc:identifier>
</item>
<item>
<title>aspnetcore.webapi实践k8s健康探测机制 - kubernetes - 据说甜蜜呢</title>
<link>http://www.cnblogs.com/justmine/p/8620311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justmine/p/8620311.html</guid>
<description>&lt;p&gt;&lt;span&gt;     k8s通过liveness来探测微服务的存活性，判断什么时候该重启容器实现自愈。比如访问 Web 服务器时显示 500 内部错误，可能是系统超载，也可能是资源死锁，此时 httpd 进程并没有异常退出，在这种情况下重启容器可能是最直接最有效的解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;k8s通过reddiness来探测微服务的什么时候准备就绪（例如初始化时，连接数据库，加载缓存数据等等，可能需要一段时间），然后将容器加入到server的负载均衡池中，对外提供服务。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;    1.1、k8s默认的健康检查机制&lt;/h2&gt;
&lt;p&gt;      每个容器启动时都会执行一个进程，此进程由 Dockerfile 的 CMD 或 ENTRYPOINT 指定。如果进程退出时返回码非零，则认为容器发生故障，Kubernetes 就会根据 &lt;code&gt;restartPolicy&lt;/code&gt; 重启容器。如果不特意配置，Kubernetes 将对两种探测采取相同的默认行为。&lt;/p&gt;

&lt;p&gt;存活10分钟：如果当前时间超过服务启动时间10分钟，则探测失败，否则探测成功。Kubernetes 如果连续执行 3 次 Liveness 探测均失败，就会杀掉并重启容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322093247755-1954679589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备就绪30秒，30秒后，如果连续 3 次 Readiness 探测均失败后，&lt;code&gt;容器将被重置为不可用，不接收 Service 转发的请求&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322091915486-1685907441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到，我们可以根据自身的需求来实现这两种机制，然后，提供给k8s进行探测。&lt;/p&gt;

&lt;p&gt;k8s默认是根据命令进行探测的，由于我们需要与微服务结合，所以需要在yml文件中指定为http方式，k8s对于http方式探测成功的判断条件是请求的返回代码在 200-400 之间。&lt;/p&gt;
&lt;p&gt;health-checks-deployment.yml 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322101559387-1126436319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到，一共部署了3个pod副本，而每个pod副本里面部署一个容器，即为同一个微服务部署了3个实例进行集群。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322101721323-1908349289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到，刚开始创建时，&lt;code&gt;READY&lt;/code&gt; 状态为不可用，等待一段时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322102227202-1652285455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在全部可用了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322102032122-295225958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322102458508-1956341707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322102526303-906345268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322102546656-911021332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到，大约1分钟(dashboard统计信息有一定的延迟)左右，第一次进行 Readiness 探测并成功返回，此时准备就绪，可以对外提供服务了。在10分钟内，探测Liveness也成功返回。&lt;/p&gt;
&lt;p&gt;继续等待一段时间，查询其中一个pod详细信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322103740217-422089472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322103843592-1153576775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到，超过10分钟存活期后，liveness探测失败，容器被 killed and recreated。探测Readiness未成功返回时，整个容器处于不健康的状态，并不会被负载均衡请求。&lt;/p&gt;
&lt;p&gt;此时通过dashboard查看集群概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322104602353-838572264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;继续等待一段时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082769/201803/1082769-20180322104655094-287110965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，整个集群已经自愈完成了！！！&lt;/p&gt;

&lt;p&gt;Liveness 探测和 Readiness 探测是独立执行的，二者之间没有依赖，可以单独使用，也可以同时使用。&lt;strong&gt;用 Liveness 探测判断容器是否需要重启以实现自愈；用 Readiness 探测判断容器是否已经准备好对外提供服务&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;源码参考：&lt;a href=&quot;https://github.com/justmine66/k8s.ecoysystem.apps&quot; target=&quot;_blank&quot;&gt;https://github.com/justmine66/k8s.ecoysystem.apps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下一篇，我们将实践微服务中的环境变量和配置信息，如何与k8s进行结合。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 03:19:00 +0000</pubDate>
<dc:creator>据说甜蜜呢</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justmine/p/8620311.html</dc:identifier>
</item>
<item>
<title>学习ASP.NET Core Razor 编程系列二——添加一个实体 - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/8622439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/8622439.html</guid>
<description>&lt;p&gt;&lt;span&gt;       在本篇文章中，学习添加用于管理数据库中的书籍的实体类。通过实体框架（EF Core）使用这些类来处理数据库。EF Core是一个对象关系映射（ORM）框架，它简化了编写数据库访问的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       创建的实体类被称为POCO类（“普通的CLR对象”）因为他们没有在EF Core中有任何依赖。它们定义存储在数据库中的数据的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;        一、添加一个实体类&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在Visual Studio 2017的解决方案资源管理器中，右键单击该&lt;strong&gt;RazorMvcBooks，在弹出菜单中选择，&lt;/strong&gt;项目--&amp;gt;添加--&amp;gt;新建文件夹，修改文件夹名称为“Models”。如下图。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201803/10343-20180322110959454-1190766399.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       2. 鼠标右键单击“Models”文件夹。在弹出菜单中选择，添加--&amp;gt;类。类名为Book。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/10343/201803/10343-20180322111020463-698829921.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;       3.在book类中的代码文件中添加以下属性&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RazorMvcBooks.Models
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime ReleaseDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Author { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;              其中ID字段必须是数据库中表Book的主键。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;         二、添加数据库上下文类&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;             在Models文件夹中添加BookContext.cs类，继承自DbContext，操作方式如上第2点中的图所示，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore; 

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; RazorMvcBooks.Models
{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BookContext(DbContextOptions&amp;lt;BookContext&amp;gt;&lt;span&gt; options)

                : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {

        } 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Book&amp;gt; Book { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;          之前的代码中我们创建了一个DbSet&amp;lt;Book&amp;gt;类型的属性Book.在实体框架中，实体集合通过对应数据库中的表，实体对应表中的行。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;        三、添加数据库连接字符串&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;           在Visual Studio 2017中的资源管理器中找到appsettings.json文件，用鼠标双击打开，在文件中添加一个连接字符串,代码如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IncludeScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BookContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Server=.\\sqlexpress;Database=Books;Trusted_Connection=True;MultipleActiveResultSets=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

  } 

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;            四、注册数据库上下文&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;span&gt;          在Visual Studio 2017中的资源管理器中找到&lt;span&gt;startup.cs&lt;/span&gt;文件，&lt;span&gt;用鼠标双击打开，&lt;/span&gt;&lt;/span&gt;在startup.cs文件的&lt;span&gt;ConfigureServices&lt;/span&gt;方法中写入依赖注入容器注册数据库上下文的代码，具体代码如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.EntityFrameworkCore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RazorMvcBooks.Models; 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {

            services.AddDbContext&lt;/span&gt;&amp;lt;BookContext&amp;gt;(options =&amp;gt;options.UseSqlServer(Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BookContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
            services.AddMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;            最后，在Visual Studio 2017中的&lt;/span&gt;&lt;span&gt;菜单中选择“生成--&amp;gt;生成解决方案”对项目进行编译，以验证自己写的代码没有任何错误同。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 03:19:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/8622439.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——37. 使用EnumMap替代序数索引 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8622134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8622134.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有时可能会看到使用&lt;code&gt;ordinal&lt;/code&gt;方法（条目 35）来索引到数组或列表的代码。 例如，考虑一下这个简单的类来代表一种植物：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Plant {
    enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL }
    final String name;
    final LifeCycle lifeCycle;

    Plant(String name, LifeCycle lifeCycle) {
        [this.name](http://this.name) = name;
        this.lifeCycle = lifeCycle;
    }

    @Override public String toString() {
        return name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在假设你有一组植物代表一个花园，想要列出这些由生命周期组织的植物(一年生，多年生，或双年生)。为此，需要构建三个集合，每个生命周期作为一个，并遍历整个花园，将每个植物放置在适当的集合中。一些程序员可以通过将这些集合放入一个由生命周期序数索引的数组中来实现这一点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using ordinal() to index into an array - DON'T DO THIS!

Set&amp;lt;Plant&amp;gt;[] plantsByLifeCycle =

    (Set&amp;lt;Plant&amp;gt;[]) new Set[Plant.LifeCycle.values().length];

for (int i = 0; i &amp;lt; plantsByLifeCycle.length; i++)

    plantsByLifeCycle[i] = new HashSet&amp;lt;&amp;gt;();

for (Plant p : garden)

    plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);

// Print the results

for (int i = 0; i &amp;lt; plantsByLifeCycle.length; i++) {

    System.out.printf(&quot;%s: %s%n&quot;,

        Plant.LifeCycle.values()[i], plantsByLifeCycle[i]);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法是有效的，但充满了问题。 因为数组不兼容泛型（条目 28），程序需要一个未经检查的转换，并且不会干净地编译。 由于该数组不知道索引代表什么，因此必须手动标记索引输出。 但是这种技术最严重的问题是，当你访问一个由枚举序数索引的数组时，你有责任使用正确的int值; int不提供枚举的类型安全性。 如果你使用了错误的值，程序会默默地做错误的事情，如果你幸运的话，抛出一个&lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;异常。&lt;/p&gt;
&lt;p&gt;有一个更好的方法来达到同样的效果。 该数组有效地用作从枚举到值的映射，因此不妨使用Map。 更具体地说，有一个非常快速的Map实现，设计用于枚举键，称为&lt;code&gt;java.util.EnumMap&lt;/code&gt;。 下面是当程序重写为使用&lt;code&gt;EnumMap&lt;/code&gt;时的样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using an EnumMap to associate data with an enum

Map&amp;lt;Plant.LifeCycle, Set&amp;lt;Plant&amp;gt;&amp;gt;  plantsByLifeCycle =

    new EnumMap&amp;lt;&amp;gt;(Plant.LifeCycle.class);

for (Plant.LifeCycle lc : Plant.LifeCycle.values())

    plantsByLifeCycle.put(lc, new HashSet&amp;lt;&amp;gt;());

for (Plant p : garden)

    plantsByLifeCycle.get(p.lifeCycle).add(p);

System.out.println(plantsByLifeCycle);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段程序更简短，更清晰，更安全，运行速度与原始版本相当。 没有不安全的转换; 无需手动标记输出，因为map键是知道如何将自己转换为可打印字符串的枚举; 并且不可能在计算数组索引时出错。 EnumMap与序数索引数组的速度相当，其原因是&lt;code&gt;EnumMap&lt;/code&gt;内部使用了这样一个数组，但它对程序员的隐藏了这个实现细节，将Map的丰富性和类型安全性与数组的速度相结合。 请注意，&lt;code&gt;EnumMap&lt;/code&gt;构造方法接受键类型的Class对象：这是一个有限定的类型令牌（bounded type token），它提供运行时的泛型类型信息（条目 33）。&lt;/p&gt;
&lt;p&gt;通过使用stream（条目 45）来管理Map，可以进一步缩短以前的程序。 以下是最简单的基于stream的代码，它们在很大程度上重复了前面示例的行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Naive stream-based approach - unlikely to produce an EnumMap!

System.out.println(Arrays.stream(garden)

        .collect(groupingBy(p -&amp;gt; p.lifeCycle)));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个代码的问题在于它选择了自己的Map实现，实际上它不是&lt;code&gt;EnumMap&lt;/code&gt;，所以它不会与显式&lt;code&gt;EnumMap&lt;/code&gt;的版本的空间和时间性能相匹配。 为了解决这个问题，使用&lt;code&gt;Collectors.groupingBy&lt;/code&gt;的三个参数形式的方法，它允许调用者使用&lt;code&gt;mapFactory&lt;/code&gt;参数指定map的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using a stream and an EnumMap to associate data with an enum

System.out.println(Arrays.stream(garden)

        .collect(groupingBy(p -&amp;gt; p.lifeCycle,

() -&amp;gt; new EnumMap&amp;lt;&amp;gt;(LifeCycle.class), toSet()))); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的优化在像这样的示例程序中是不值得的，但是在大量使用Map的程序中可能是至关重要的。&lt;/p&gt;
&lt;p&gt;基于stream版本的行为与&lt;code&gt;EmumMap&lt;/code&gt;版本的行为略有不同。 EnumMap版本总是为每个工厂生命周期生成一个嵌套map类，而如果花园包含一个或多个具有该生命周期的植物时，则基于流的版本才会生成嵌套map类。 因此，例如，如果花园包含一年生和多年生植物但没有两年生的植物，&lt;code&gt;plantByLifeCycle&lt;/code&gt;的大小在&lt;code&gt;EnumMap&lt;/code&gt;版本中为三个，在两个基于流的版本中为两个。&lt;/p&gt;
&lt;p&gt;你可能会看到数组索引(两次)的数组，用序数来表示从两个枚举值的映射。例如，这个程序使用这样一个数组来映射两个阶段到一个阶段转换（phase transition）（液体到固体表示凝固，液体到气体表示沸腾等等）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using ordinal() to index array of arrays - DON'T DO THIS!

public enum Phase {

    SOLID, LIQUID, GAS;

    public enum Transition {

        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;

        // Rows indexed by from-ordinal, cols by to-ordinal

        private static final Transition[][] TRANSITIONS = {

            { null,    MELT,     SUBLIME },

            { FREEZE,  null,     BOIL    },

            { DEPOSIT, CONDENSE, null    }

        };

        // Returns the phase transition from one phase to another

        public static Transition from(Phase from, Phase to) {

            return TRANSITIONS[from.ordinal()][to.ordinal()];

        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段程序可以运行，甚至可能显得优雅，但外观可能是骗人的。 就像前面显示的简单的花园示例一样，编译器无法知道序数和数组索引之间的关系。 如果在转换表中出错或者在修改&lt;code&gt;Phase&lt;/code&gt;或&lt;code&gt;Phase.Transition&lt;/code&gt;枚举类型时忘记更新它，则程序在运行时将失败。 失败可能是&lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;，&lt;code&gt;NullPointerException&lt;/code&gt;或（更糟糕的）沉默无提示的错误行为。 即使非空条目的数量较小，表格的大小也是phase的个数的平方。&lt;/p&gt;
&lt;p&gt;同样，可以用&lt;code&gt;EnumMap&lt;/code&gt;做得更好。 因为每个阶段转换都由一对阶段枚举来索引，所以最好将关系表示为从一个枚举（from 阶段）到第二个枚举（to阶段）到结果（阶段转换）的map。 与阶段转换相关的两个阶段最好通过将它们与阶段转换枚举相关联来捕获，然后可以用它来初始化嵌套的&lt;code&gt;EnumMap&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Using a nested EnumMap to associate data with enum pairs

public enum Phase {

   SOLID, LIQUID, GAS;

   public enum Transition {

      MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),

      BOIL(LIQUID, GAS),   CONDENSE(GAS, LIQUID),

      SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);

      private final Phase from;

      private final Phase to;

      Transition(Phase from, Phase to) {

         this.from = from;

         [this.to](http://this.to) = to;

      }

      // Initialize the phase transition map

      private static final Map&amp;lt;Phase, Map&amp;lt;Phase, Transition&amp;gt;&amp;gt;

        m = Stream.of(values()).collect(groupingBy(t -&amp;gt; t.from,

         () -&amp;gt; new EnumMap&amp;lt;&amp;gt;(Phase.class),

         toMap(t -&amp;gt; [t.to](http://t.to), t -&amp;gt; t,

            (x, y) -&amp;gt; y, () -&amp;gt; new EnumMap&amp;lt;&amp;gt;(Phase.class))));

      public static Transition from(Phase from, Phase to) {

         return m.get(from).get(to);

      }

   }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化阶段转换的map的代码有点复杂。map的类型是&lt;code&gt;Map&amp;lt;Phase, Map&amp;lt;Phase, Transition&amp;gt;&amp;gt;&lt;/code&gt;，意思是“从（源）阶段映射到从（目标）阶段到阶段转换映射。”这个map的map使用两个收集器的级联序列进行初始化。 第一个收集器按源阶段对转换进行分组，第二个收集器使用从目标阶段到转换的映射创建一个&lt;code&gt;EnumMap&lt;/code&gt;。 第二个收集器&lt;code&gt;((x, y) -&amp;gt; y))&lt;/code&gt;中的合并方法未使用；仅仅因为我们需要指定一个map工厂才能获得一个EnumMap，并且&lt;code&gt;Collectors&lt;/code&gt;提供伸缩式工厂，这是必需的。 本书的前一版使用显式迭代来初始化阶段转换map。 代码更详细，但可以更容易理解。&lt;/p&gt;
&lt;p&gt;现在假设想为系统添加一个新阶段：等离子体或电离气体。 这个阶段只有两个转变：电离，将气体转化为等离子体; 和去离子，将等离子体转化为气体。 要更新基于数组的程序，必须将一个新的常量添加到Phase，将两个两次添加到Phase.Transition，并用新的十六个元素版本替换原始的九元素阵列数组。 如果向数组中添加太多或太少的元素或者将元素乱序放置，那么如果运气不佳：程序将会编译，但在运行时会失败。 要更新基于&lt;code&gt;EnumMap&lt;/code&gt;的版本，只需将&lt;code&gt;PLASMA&lt;/code&gt;添加到阶段列表中，并将&lt;code&gt;IONIZE(GAS, PLASMA)&lt;/code&gt;和&lt;code&gt;DEIONIZE(PLASMA, GAS)&lt;/code&gt;添加到阶段转换列表中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Adding a new phase using the nested EnumMap implementation

public enum Phase {

    SOLID, LIQUID, GAS, PLASMA;

    public enum Transition {

        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),

        BOIL(LIQUID, GAS),   CONDENSE(GAS, LIQUID),

        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID),

        IONIZE(GAS, PLASMA), DEIONIZE(PLASMA, GAS);

        ... // Remainder unchanged

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该程序会处理所有其他事情，并且几乎不会出现错误。 在内部，map的map是通过数组的数组实现的，因此在空间或时间上花费很少，以增加清晰度，安全性和易于维护。&lt;/p&gt;
&lt;p&gt;为了简便起见，上面的示例使用null来表示状态更改的缺失(其从目标到源都是相同的)。这不是很好的实践，很可能在运行时导致&lt;code&gt;NullPointerException&lt;/code&gt;。为这个问题设计一个干净、优雅的解决方案是非常棘手的，而且结果程序足够长，以至于它们会偏离这个条目的主要内容。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;使用序数来索引数组很不合适：改用EnumMap&lt;/strong&gt;。 如果你所代表的关系是多维的，请使用&lt;code&gt;EnumMap &amp;lt;...，EnumMap &amp;lt;... &amp;gt;&amp;gt;&lt;/code&gt;。 应用程序员应该很少使用&lt;code&gt;Enum.ordinal&lt;/code&gt;（条目 35），如果使用了，也是一般原则的特例。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 02:46:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8622134.html</dc:identifier>
</item>
<item>
<title>Shiro【授权过滤器、与ehcache整合、验证码、记住我】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8621922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8621922.html</guid>
<description>&lt;p&gt;本文主要讲解的知识点有以下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Shiro授权过滤器使用&lt;/li&gt;
&lt;li&gt;Shiro缓存
&lt;ul&gt;&lt;li&gt;与Ehcache整合&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shiro应用-&amp;gt;实现验证码功能&lt;/li&gt;
&lt;li&gt;记住我功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们的授权过滤器使用的是permissionsAuthorizationFilter来进行拦截。我们可以在application-shiro中配置filter规则&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &amp;lt;!--商品查询需要商品查询权限 --&amp;gt;
        /items/queryItems.&lt;span class=&quot;fu&quot;&gt;action&lt;/span&gt; = perms[item:query]
        /items/editItems.&lt;span class=&quot;fu&quot;&gt;action&lt;/span&gt; = perms[item:edit] &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试流程：&lt;br/&gt;1、&lt;strong&gt;在applicationContext-shiro.xml中配置filter规则&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;!--商品查询需要商品查询权限 --&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;/items/queryItems.action = perms[item:query]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、&lt;strong&gt;用户在认证通过后，请求/items/queryItems.action&lt;/strong&gt;&lt;br/&gt;3、被PermissionsAuthorizationFilter拦截，&lt;strong&gt;发现需要“item:query”权限&lt;/strong&gt;&lt;br/&gt;4、PermissionsAuthorizationFilter &lt;strong&gt;调用realm中的doGetAuthorizationInfo获取数据库中正确的权限&lt;/strong&gt;&lt;br/&gt;5、PermissionsAuthorizationFilter对item:query 和从realm中获取权限进行对比，如果“item:query”在realm返回的权限列表中，授权通过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;realm中获取认证的信息，查询出该用户对应的权限，封装到simpleAuthorizationInfo中，PermissionsAuthorizationFilter会根据对应的权限来比对。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; AuthorizationInfo &lt;span class=&quot;fu&quot;&gt;doGetAuthorizationInfo&lt;/span&gt;(
            PrincipalCollection principals) {
        
        &lt;span class=&quot;co&quot;&gt;//从 principals获取主身份信息&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//将getPrimaryPrincipal方法返回值转为真实身份类型（在上边的doGetAuthenticationInfo认证通过填充到SimpleAuthenticationInfo中身份类型），&lt;/span&gt;
        ActiveUser activeUser =  (ActiveUser) principals.&lt;span class=&quot;fu&quot;&gt;getPrimaryPrincipal&lt;/span&gt;();
        
        &lt;span class=&quot;co&quot;&gt;//根据身份信息获取权限信息&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//从数据库获取到权限数据&lt;/span&gt;
        List&amp;lt;SysPermission&amp;gt; permissionList = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            permissionList = sysService.&lt;span class=&quot;fu&quot;&gt;findPermissionListByUserId&lt;/span&gt;(activeUser.&lt;span class=&quot;fu&quot;&gt;getUserid&lt;/span&gt;());
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;co&quot;&gt;// TODO Auto-generated catch block&lt;/span&gt;
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;co&quot;&gt;//单独定一个集合对象 &lt;/span&gt;
        List&amp;lt;String&amp;gt; permissions = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(permissionList!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(SysPermission sysPermission:permissionList){
                &lt;span class=&quot;co&quot;&gt;//将数据库中的权限标签 符放入集合&lt;/span&gt;
                permissions.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(sysPermission.&lt;span class=&quot;fu&quot;&gt;getPercode&lt;/span&gt;());
            }
        }
        
        
    &lt;span class=&quot;co&quot;&gt;/*  List&amp;lt;String&amp;gt; permissions = new ArrayList&amp;lt;String&amp;gt;();&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        permissions.add(&quot;user:create&quot;);//用户的创建&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        permissions.add(&quot;item:query&quot;);//商品查询权限&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        permissions.add(&quot;item:add&quot;);//商品添加权限&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        permissions.add(&quot;item:edit&quot;);//商品修改权限&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;//....&lt;/span&gt;
        
        &lt;span class=&quot;co&quot;&gt;//查到权限数据，返回授权信息(要包括 上边的permissions)&lt;/span&gt;
        SimpleAuthorizationInfo simpleAuthorizationInfo = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SimpleAuthorizationInfo&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//将上边查询到授权信息填充到simpleAuthorizationInfo对象中&lt;/span&gt;
        simpleAuthorizationInfo.&lt;span class=&quot;fu&quot;&gt;addStringPermissions&lt;/span&gt;(permissions);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; simpleAuthorizationInfo;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在bean中我们已经配置了：如果没有权限，那么跳转到哪个JSP页面了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 通过unauthorizedUrl指定没有权限操作时跳转页面--&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;unauthorizedUrl&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/refuse.jsp&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到目前为止，现在问题又来了：&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;在applicationContext-shiro.xml中配置过虑器链接，需要将全部的url和权限对应起来进行配置，比较发麻不方便使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;每次授权都需要调用realm查询数据库，对于系统性能有很大影响，可以通过shiro缓存来解决。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上面的那种方法，还是需要我们将全部的url和权限对应起来进行配置，是比较不方便的。我们可以使用授权的另外两种方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注解式&lt;/li&gt;
&lt;li&gt;标签式&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;注解式&quot;&gt;2.1注解式&lt;/h2&gt;
&lt;p&gt;如果要使用注解式，那么就必须在Spring中&lt;strong&gt;开启controller类aop支持&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 开启aop，对类代理 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;aop:config&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; proxy-target-class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/aop:config&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 开启shiro注解支持 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;securityManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;securityManager&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Controller中使用注解来进行配置就行了，就不用在我们的application-shiro中全部集中配置了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;//商品信息方法&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/queryItems&quot;&lt;/span&gt;)
    &lt;span class=&quot;fu&quot;&gt;@RequiresPermissions&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;item:query&quot;&lt;/span&gt;)&lt;span class=&quot;co&quot;&gt;//执行queryItems需要&quot;item:query&quot;权限&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ModelAndView &lt;span class=&quot;fu&quot;&gt;queryItems&lt;/span&gt;(HttpServletRequest request) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(request.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;));
    
        &lt;span class=&quot;co&quot;&gt;//调用service查询商品列表&lt;/span&gt;
        List&amp;lt;ItemsCustom&amp;gt; itemsList = itemsService.&lt;span class=&quot;fu&quot;&gt;findItemsList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);

        ModelAndView modelAndView = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ModelAndView&lt;/span&gt;();
        modelAndView.&lt;span class=&quot;fu&quot;&gt;addObject&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;itemsList&quot;&lt;/span&gt;, itemsList);
        &lt;span class=&quot;co&quot;&gt;// 指定逻辑视图名&lt;/span&gt;
        modelAndView.&lt;span class=&quot;fu&quot;&gt;setViewName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;itemsList&quot;&lt;/span&gt;);

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; modelAndView;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;jsp标签-授权&quot;&gt;2.2jsp标签 授权&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/22/1624b81ecaa2adc7?w=797&amp;amp;h=397&amp;amp;f=png&amp;amp;s=38999&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/22/1624b81ecac940ea?w=850&amp;amp;h=116&amp;amp;f=png&amp;amp;s=13463&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当调用controller的一个方法，由于该 &lt;a href=&quot;mailto:方法加了@requirespermissions&quot;&gt;方法加了@RequiresPermissions&lt;/a&gt;(&quot;item:query&quot;) ，shiro调用realm获取数据库中的权限信息，看&quot;item:query&quot;是否在权限数据中存在，如果不存在就拒绝访问，如果存在就授权通过。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当展示一个jsp页面时，页面中如果遇到&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;针对上边授权频繁查询数据库，需要使用shiro缓存&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;缓存流程&quot;&gt;3.1缓存流程&lt;/h2&gt;
&lt;p&gt;shiro中提供了对认证信息和授权信息的缓存。shiro默认是关闭认证信息缓存的，&lt;strong&gt;对于授权信息的缓存shiro默认开启的&lt;/strong&gt;。主要研究授权信息缓存，因为&lt;strong&gt;授权的数据量大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户认证通过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;该用户第一次授权：调用realm查询数据库&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;该用户第二次授权：不调用realm查询数据库，直接从缓存中取出授权信息（权限标识符）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用ehcache和shiro整合&quot;&gt;3.2使用ehcache和Shiro整合&lt;/h2&gt;
&lt;p&gt;导入jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/22/1624b81ecab9158b?w=182&amp;amp;h=67&amp;amp;f=png&amp;amp;s=1093&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置缓存管理器，注入到安全管理器中&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 缓存管理器 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManagerConfigFile&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:shiro-ehcache.xml&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- securityManager安全管理器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;securityManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;realm&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;customRealm&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注入缓存管理器 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ehcache的配置文件&lt;strong&gt;shiro-ehcache.xml&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;ehcache&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xsi:noNamespaceSchemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;../config/ehcache.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!--diskStore：缓存数据持久化的目录 地址  --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;diskStore&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; path=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;F:\develop\ehcache&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;defaultCache&lt;/span&gt; 
&lt;span class=&quot;ot&quot;&gt;        maxElementsInMemory=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1000&quot;&lt;/span&gt; 
&lt;span class=&quot;ot&quot;&gt;        maxElementsOnDisk=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10000000&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        eternal=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; 
&lt;span class=&quot;ot&quot;&gt;        overflowToDisk=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; 
&lt;span class=&quot;ot&quot;&gt;        diskPersistent=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        timeToIdleSeconds=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;120&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        timeToLiveSeconds=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;120&quot;&lt;/span&gt; 
&lt;span class=&quot;ot&quot;&gt;        diskExpiryThreadIntervalSeconds=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;120&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;        memoryStoreEvictionPolicy=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;LRU&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/defaultCache&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/ehcache&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;缓存清空&quot;&gt;3.3缓存清空&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果用户正常退出，缓存自动清空。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;如果用户非正常退出，缓存自动清空。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当管理员修改了用户的权限，但是该用户还没有退出，在默认情况下&lt;strong&gt;，修改的权限无法立即生效&lt;/strong&gt;。需要手动进行编程实现：&lt;strong&gt;在权限修改后调用realm的clearCache方法清除缓存。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;清除缓存：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;//清除缓存&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;clearCached&lt;/span&gt;() {
        PrincipalCollection principals = SecurityUtils.&lt;span class=&quot;fu&quot;&gt;getSubject&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getPrincipals&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;clearCache&lt;/span&gt;(principals);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;sessionmanager&quot;&gt;3.4sessionManager&lt;/h2&gt;
&lt;p&gt;和shiro整合后，&lt;strong&gt;使用shiro的session管理，shiro提供sessionDao操作 会话数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置sessionManager&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 会话管理器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sessionManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- session的失效时长，单位毫秒 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;globalSessionTimeout&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;600000&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 删除失效的session --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;deleteInvalidSessions&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注入到安全管理器中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- securityManager安全管理器 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;securityManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;realm&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;customRealm&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注入缓存管理器 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注入session管理器 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sessionManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sessionManager&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;在登陆的时候，我们一般都设置有验证码，但是我们如果使用Shiro的话，那么Shiro默认的是使用FormAuthenticationFilter进行表单认证。&lt;/p&gt;
&lt;p&gt;而我们的验证校验的功能应该&lt;strong&gt;加在FormAuthenticationFilter中，在认证之前进行验证码校验&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;FormAuthenticationFilter是Shiro默认的功能，我们想要在FormAuthenticationFilter之前进行验证码校验，就&lt;strong&gt;需要继承FormAuthenticationFilter类，改写它的认证方法&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&quot;自定义form认证类&quot;&gt;4.1自定义Form认证类&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomFormAuthenticationFilter &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; FormAuthenticationFilter {

    &lt;span class=&quot;co&quot;&gt;//原FormAuthenticationFilter的认证方法&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onAccessDenied&lt;/span&gt;(ServletRequest request,
            ServletResponse response) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;co&quot;&gt;//在这里进行验证码的校验&lt;/span&gt;
        
        &lt;span class=&quot;co&quot;&gt;//从session获取正确验证码&lt;/span&gt;
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpSession session =httpServletRequest.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;//取出session的验证码（正确的验证码）&lt;/span&gt;
        String validateCode = (String) session.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;validateCode&quot;&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;//取出页面的验证码&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//输入的验证和session中的验证进行对比 &lt;/span&gt;
        String randomcode = httpServletRequest.&lt;span class=&quot;fu&quot;&gt;getParameter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;randomcode&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(randomcode!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; validateCode!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !randomcode.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(validateCode)){
            &lt;span class=&quot;co&quot;&gt;//如果校验失败，将验证码错误失败信息，通过shiroLoginFailure设置到request中&lt;/span&gt;
            httpServletRequest.&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;shiroLoginFailure&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;randomCodeError&quot;&lt;/span&gt;);
            &lt;span class=&quot;co&quot;&gt;//拒绝访问，不再校验账号和密码 &lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;; 
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onAccessDenied&lt;/span&gt;(request, response);
    }

        
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;配置自定义类&quot;&gt;4.2配置自定义类&lt;/h2&gt;
&lt;p&gt;我们编写完自定义类以后，是需要在Shiro配置文件中配置我们这个自定义类的。&lt;/p&gt;
&lt;p&gt;由于这是我们自定义的，因此&lt;strong&gt;我们并不需要用户名就使用username，密码就使用password，这个也是我们可以自定义的&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 自定义form认证过虑器 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 基于Form表单的身份验证过滤器，不配置将也会注册此过虑器，表单中的用户账号、密码及loginurl将采用默认值，建议配置 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;formAuthenticationFilter&quot;&lt;/span&gt; 
&lt;span class=&quot;ot&quot;&gt;    class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cn.itcast.ssm.shiro.CustomFormAuthenticationFilter &quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 表单中账号的input名称 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;usernameParam&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 表单中密码的input名称 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;passwordParam&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Shiro的bean中注入自定义的过滤器&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;

        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 自定义filter配置 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;filters&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;map&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 将自定义 的FormAuthenticationFilter注入shiroFilter中--&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;entry&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; key=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;authc&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value-ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;formAuthenticationFilter&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/map&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们的Controller添加验证码错误的异常判断，从我们的Controller就可以发现，为什么我们要把错误信息存放在request域对象shiroLoginFailure，因为我们得在Controller中获取获取信息，从而给用户对应的提示&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;login&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;login&lt;/span&gt;(HttpServletRequest request)&lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception{
        
        &lt;span class=&quot;co&quot;&gt;//如果登陆失败从request中获取认证异常信息，shiroLoginFailure就是shiro异常类的全限定名&lt;/span&gt;
        String exceptionClassName = (String) request.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;shiroLoginFailure&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;//根据shiro返回的异常类路径判断，抛出指定异常信息&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(exceptionClassName!=&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (UnknownAccountException.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(exceptionClassName)) {
                &lt;span class=&quot;co&quot;&gt;//最终会抛给异常处理器&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;账号不存在&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (IncorrectCredentialsException.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(
                    exceptionClassName)) {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;用户名/密码错误&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;randomCodeError&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(exceptionClassName)){
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;验证码错误 &quot;&lt;/span&gt;);
            }&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Exception();&lt;span class=&quot;co&quot;&gt;//最终在异常处理器生成未知错误&lt;/span&gt;
            }
        }
        &lt;span class=&quot;co&quot;&gt;//此方法不处理登陆成功（认证成功），shiro认证成功会自动跳转到上一个请求路径&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//登陆失败还到login页面&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;login&quot;&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/3/22/1624b81ecac279f4?w=748&amp;amp;h=793&amp;amp;f=png&amp;amp;s=91301&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;TR&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;TD&amp;gt;&lt;/span&gt;验证码：&lt;span class=&quot;kw&quot;&gt;&amp;lt;/TD&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;TD&amp;gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;randomcode&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;randomcode&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; size=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;8&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;randomcode_img&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${baseurl}validatecode.jsp&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; alt=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                width=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;56&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; height=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;20&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; align=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'absMiddle'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;a&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;                href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;javascript:randomcode_refresh()&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;刷新&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/TD&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/TR&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Shiro还提供了记住用户名和密码的功能&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户登陆选择“自动登陆”本次登陆成功会向cookie写身份信息，下次登陆从cookie中取出身份信息实现自动登陆。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要实现这个功能，我们的认证信息需要&lt;strong&gt;实现Serializable接口&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ActiveUser &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Serializable&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String userid;&lt;span class=&quot;co&quot;&gt;//用户id（主键）&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String usercode;&lt;span class=&quot;co&quot;&gt;// 用户账号&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String username;&lt;span class=&quot;co&quot;&gt;// 用户名称&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;SysPermission&amp;gt; menus;&lt;span class=&quot;co&quot;&gt;// 菜单&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; List&amp;lt;SysPermission&amp;gt; permissions;&lt;span class=&quot;co&quot;&gt;// 权限&lt;/span&gt;


}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;配置rememeber管理器&quot;&gt;5.1配置rememeber管理器&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMeManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cookie&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMeCookie&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 记住我cookie --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMeCookie&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- rememberMe是cookie的名字 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMe&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 记住我cookie生效时间30天 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxAge&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;2592000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注入到安全管理器类上&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- securityManager安全管理器 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;securityManager&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;～～～····&lt;/span&gt;
        &lt;span class=&quot;er&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cacheManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注入session管理器 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sessionManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;sessionManager&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 记住我 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMeManager&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMeManager&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;    
    &lt;span class=&quot;er&quot;&gt;&amp;lt;&lt;/span&gt;/bean&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置页面的input名称：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;TD&amp;gt;&amp;lt;/TD&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;checkbox&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;rememberMe&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;自动登陆&lt;span class=&quot;kw&quot;&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果设置了“记住我”，那么访问某些URL的时候，我们就不需要登陆了。&lt;strong&gt;将记住我即可访问的地址配置让UserFilter拦截。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置记住我或认证通过可以访问的地址 --&amp;gt;&lt;/span&gt;
        /index.jsp  = user
        /first.action = user
        /welcome.jsp = user&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;Shiro的授权过程和认证过程是类似的，在配置文件上配置需要授权的路径，当访问路径的时候，Shiro过滤器去找到reaml，reaml返回数据以后进行比对。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shiro支持注解式授权，直接在Controller方法上使用注解声明访问该方法需要授权&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Shiro还支持标签授权，但一般很少用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;由于每次都要对reaml查询数据库，性能会低。Shiro默认是支持授权缓存的。为了达到很好的效果，我们使用Ehcache来对Shiro的缓存进行管理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;配置会话管理器，对会话时间进行控制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手动清空缓存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于验证用户名和密码之前，一般需要验证验证码的。所以，我们要改写表单验证的功能，先让它去看看验证码是否有错，如果验证码有错的话，那么用户名和密码就不用验证了。&lt;/li&gt;
&lt;li&gt;将自定义的表单验证类配置起来。&lt;/li&gt;
&lt;li&gt;使用Shiro提供的记住我功能，如果用户已经认证了，那就不用再次登陆了。可以直接访问某些页面。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章，想要获取更多的Java资源的同学，可以&lt;strong&gt;关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 22 Mar 2018 02:22:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8621922.html</dc:identifier>
</item>
<item>
<title>基于I2C总线的MPU6050学习笔记 - micro虾米</title>
<link>http://www.cnblogs.com/microxiami/p/8524424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/microxiami/p/8524424.html</guid>
<description>&lt;h2 id=&quot;简述&quot;&gt;1. 简述&lt;/h2&gt;
&lt;p&gt;一直想自己做个四轴飞行器，却无从下手，终于狠下决心，拿出尘封已久的MPU6050模块，开始摸索着数据手册分析，一步一步地实现了MPU6050模块的功能，从MPU6050模块中读取出加速度值和陀螺仪采样值。&lt;/p&gt;
&lt;p&gt;模块如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613630/201803/613630-20180307180001635-1906161948.png&quot; alt=&quot;MPU6050模块&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;模块简介&quot;&gt;2. 模块简介&lt;/h2&gt;
&lt;p&gt;MPU-60X0将3轴陀螺仪，3轴加速度计和数字运动处理器（DMP）组合在一起。通过I2C总线可以接受外部3轴罗盘的输入，提供9轴输出。&lt;/p&gt;
&lt;p&gt;MPU-60X0具有三个用于数字化陀螺仪输出的16位ADC转换器和三个用于数字化加速度计输出的16位ADC转换器。&lt;br/&gt;对于快速和慢速运动的精确跟踪，这些器件具有用户可编程的满量程±250，±500，±1000和±2000°/秒（dps）的用户可编程陀螺仪和用户可编程加速度计满量程 范围为±2g，±4g，±8g和±16g。&lt;/p&gt;
&lt;p&gt;I2C通讯速率400KHz，SPI通讯速率1MHz（仅MPU-6000）。高速通讯SPI通讯速率20MHz（仅MPU-6000）。&lt;/p&gt;
&lt;p&gt;MPU-60X0电源电压范围：2.375V ~ 3.46V&lt;/p&gt;
&lt;p&gt;MPU-6000和MPU-6050相同，只是MPU-6050仅支持I2C接口，并具有单独的VLOGIC参考引脚。MPU-6000支持I2C和SPI接口，并具有单电源引脚VDD。&lt;/p&gt;
&lt;p&gt;MPU-60X0具有16位ADC和信号调理的三轴MEMS陀螺仪&lt;br/&gt;MPU-60X0由三个独立的振动MEMS速率陀螺仪组成，可检测绕X轴，Y轴和Z轴的旋转。 当陀螺仪围绕任何感应轴旋转时，科里奥利效应会引起由电容感应检测到的振动。 所得到的信号被放大，解调和滤波以产生与角速率成比例的电压。 使用单独的片内16位模数转换器（ADC）对该电压进行数字化，以对每个轴进行采样。 陀螺仪传感器的满量程范围可以数字编程为±250，±500，±1000或±2000度/秒（dps）。 ADC采样速率可以从每秒8,000个采样点编程到每秒3.9个采样点，用户可选的低通滤波器可实现宽范围的截止频率。&lt;/p&gt;
&lt;p&gt;MPU-60X0的坐标轴关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613630/201803/613630-20180307180021775-181547775.png&quot; alt=&quot;MPU6050的坐标轴关系&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;i2c通信协议&quot;&gt;3. I2C通信协议&lt;/h2&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/microxiami/p/8527464.html&quot;&gt;I2C通信协议&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;mpu6050寄存器读写&quot;&gt;4. MPU6050寄存器读写&lt;/h2&gt;
&lt;p&gt;I2C通讯中，主处理器芯片作为主设备，MPU6050作为从设备。&lt;/p&gt;
&lt;h3 id=&quot;从设备地址&quot;&gt;4.1 从设备地址&lt;/h3&gt;
&lt;p&gt;MPU6050作为从设备使用时，有一个芯片自身的7位的设备地址，该地址为：0b110100X，7位地址的LSB位由引脚AD0的值决定，这样在一个板子的同一个I2C总线上可以同时使用两个MPU6050芯片，所以MPU6050的从设备地址为：0b1101000（0x68，AD0为低）或者0b1101001（0x69，AD0为高）。&lt;/p&gt;
&lt;h3 id=&quot;写寄存器&quot;&gt;4.2 写寄存器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; 主设备发送一个起始位（S），再发送I2C的从设备地址数据（由从7bit设备地址和1bit读标志位0组成），在第9个时钟SCL为高电平时，从设备发送应答信号（ACK）。接着，主设备发送从设备的寄存器地址（RA，8bit），等待从设备应答（ACK）后，主设备再发送要在寄存器中写入的数据（8bit），等待从设备应答（ACK）后，可以发送停止位（P）结束数据传输。

如果要写多个寄存器，在上一步中可以先不发停止位（P），而是继续发送数据（8bit），这样就可以实现连续写入多个寄存器数据了。MPU6050芯片会自动增加寄存器地址，并将连续写入的数据字节，按顺序依次写入到相邻的寄存器中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种写数据的格式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613630/201803/613630-20180307180314885-2060246972.png&quot; alt=&quot;MPU6050的I2C写寄存器顺序&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;读寄存器&quot;&gt;4.3 读寄存器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; 主设备发送一个起始位（S），再发送I2C的从设备地址数据（由从7bit设备地址和1bit写标志位0组成），在第9个时钟SCL为高电平时，从设备发送应答信号（ACK）。然后发送要读取的寄存器地址，在接收到从设备发送的应答信号（ACK）后，主设备发送一个起始位（Sr），再发送从设备地址（由从7bit设备地址和1bit读标志位1组成 ）。从设备会发送一个应答信号（ACK），再发送寄存器中的数据（8bit）。主设备发送一个非应答信号（NOACK），和一个停止位（P），停止I2C传输。

如果要读取多个连续的寄存器，在上一步中不能发送非应答信号（NOACK）和停止位（P），而是要发送一个应答信号（ACK），等待下一个从设备发送的数据，直到最后一个数据接收完成后，主设备发送一个非应答信号（NOACK），和一个停止位（P），停止I2C传输。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种读寄存器数据的格式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613630/201803/613630-20180307180344445-245269570.png&quot; alt=&quot;MPU6050的I2C读寄存器顺序&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mpu6050通讯中的简写符号&quot;&gt;4.4 MPU6050通讯中的简写符号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/613630/201803/613630-20180307180726079-1101517988.png&quot; alt=&quot;I2C通讯中的简写符号&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;至此，I2C总线通讯协议及MPU6050寄存器的读写已经介绍完毕，下一步就是用程序实现I2C通讯，并通过I2C读写MPU6050的寄存器数据。具体内容，请参考下一节。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;6. 参考资料&lt;/h2&gt;
&lt;p&gt;MPU-6000 and MPU-6050 Product Specification Revision 3.4（MPU-6050_DataSheet_V3 4.pdf）&lt;br/&gt;MPU-6000 and MPU-6050 Register Map and Descriptions Revision 4.2（MPU-6000-Register-Map1.pdf）&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 02:07:00 +0000</pubDate>
<dc:creator>micro虾米</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/microxiami/p/8524424.html</dc:identifier>
</item>
<item>
<title>深度学习基础网络 ResNet - 康行天下</title>
<link>http://www.cnblogs.com/makefile/p/ResNet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makefile/p/ResNet.html</guid>
<description>&lt;h2 id=&quot;highway-networks&quot;&gt;Highway Networks&lt;/h2&gt;
&lt;p&gt;论文地址:&lt;a href=&quot;https://arxiv.org/abs/1505.00387&quot;&gt;arXiv:1505.00387&lt;/a&gt; [cs.LG] (ICML 2015),全文:Training Very Deep Networks( &lt;a href=&quot;https://arxiv.org/abs/1507.06228&quot;&gt;arXiv:1507.06228&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;基于梯度下降的算法在网络层数增加时训练越来越困难(并非是梯度消失的问题,因为batch norm解决梯度消失问题).论文受 RNN 中的 LSTM、GRU 的 gate 机制的启发,去掉每一层循环的序列输入,去掉 reset gate (不需要遗忘历史信息),仍使用 gate 控制前一次输出与当前层激活函数之后的输出的融合比例,从而提出了&lt;em&gt;highway networks&lt;/em&gt;,加入了称为 &lt;em&gt;information high-ways&lt;/em&gt;的shortcut连接,使得信息可以跨层直接原样传递.这使得网络深度理论上几乎可以是无限.&lt;/p&gt;
&lt;p&gt;传统网络做的非线性转换(通常是仿射变换+非线性激活函数)是:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y = H(x,W_H)\tag 1 \]&lt;/span&gt;&lt;br/&gt;highway network添加了两个非线性转换: transform gate &lt;span class=&quot;math inline&quot;&gt;\(T(x,W_T)\)&lt;/span&gt; ,carry gate &lt;span class=&quot;math inline&quot;&gt;\(C(x,W_C)\)&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y = H(x,W_H)\cdot T(x,W_T) +x\cdot C(x,W_C)\tag 2 \]&lt;/span&gt;&lt;br/&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(C = 1 − T\)&lt;/span&gt;,得到&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ y = H(x,W_H)\cdot T(x,W_T) +x\cdot (1-T(x,W_T))\tag 3 \]&lt;/span&gt;&lt;br/&gt;当&lt;span class=&quot;math inline&quot;&gt;\(T(x,W_T)=0\)&lt;/span&gt;时,&lt;span class=&quot;math inline&quot;&gt;\(y=x\)&lt;/span&gt;;当&lt;span class=&quot;math inline&quot;&gt;\(T(x,W_T)=1\)&lt;/span&gt;时,&lt;span class=&quot;math inline&quot;&gt;\(y=H(x,W_H)\)&lt;/span&gt;.因此这个gate可以灵活地控制网络的行为.直观的理解就是每层不完全做非线性特征变换了,将原始特征直接添加到这一层,更有弹性一些.&lt;/p&gt;
&lt;p&gt;上边的公式(3)要求$x,y, H(x,W_H),T(x,W_T) $是相同的大小.对于大小不匹配的情况,采用对x &lt;code&gt;下采样/0值填充&lt;/code&gt; 的方式,另外还可使用额外的网络改变x的维度.&lt;/p&gt;
&lt;p&gt;论文中设置&lt;span class=&quot;math inline&quot;&gt;\(T(x) = σ(W_T^Tx+b_T)∈ (0,1),∀x ∈ R\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Highway network学习之后自动学习哪些层需要哪些不需要.而ResNet是直接(等比例)相加.&lt;/p&gt;
&lt;h2 id=&quot;resnet&quot;&gt;ResNet&lt;/h2&gt;
&lt;p&gt;论文(&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot;&gt;Deep Residual Learning for Image Recognition&lt;/a&gt;,CVPR 2016)&lt;/p&gt;
&lt;p&gt;ResNet与Highway Networks的区别是Highway Networks增加了额外的参数,而ResNet不需要;Highway Networks,当carry gate接近于0时,残差功能接近关闭状态.而ResNet的残差函数总是开启.&lt;/p&gt;
&lt;p&gt;ResNet 的动机是网络degradation退化问题,即传统网络随着层数增多,准确率不升反降.原因是当模型变复杂时，SGD的优化变得更加困难.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/606386/201710/606386-20171017142250459-318795074.png&quot; alt=&quot;net-degradation&quot;/&gt;&lt;br/&gt;图 Cifar-10 上的training/testing error. 网络从20层加到56层，error却上升了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势&lt;/strong&gt;:ResNet使用Identity mapping在不额外增加参数的情况下,收敛速度更快.&lt;/p&gt;
&lt;h3 id=&quot;identity-mapping恒等映射&quot;&gt;Identity mapping（恒等映射）&lt;/h3&gt;
&lt;p&gt;在网络中某一位置添加一条 shortcut connection,将前层的特征直接传递过来,这个新连接称为Identity mapping.如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/606386/201710/606386-20171017142315615-1273272234.png&quot; alt=&quot;residual-block&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Identity mapping反向求导时正好是单位矩阵I.&lt;/p&gt;
&lt;p&gt;假设优化残差映射F(x) 比优化原来的映射 H(x)容易(实验结果证实了这一点)。F(x)+x 可以通过 shortcut connections 来实现，如下图所示：&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(\mathbb x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\mathcal F\)&lt;/span&gt;的维度相同,那么:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbb y=\mathcal F(\mathbb x,{W_i})+\mathbb x \tag 1 \]&lt;/span&gt;&lt;br/&gt;如果不相同,则需要对shortcut connection的x进行线性投射使维度相同,从而能够相加:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbb y=\mathcal F(\mathbb x,{W_i})+W_s\mathbb x \tag 2 \]&lt;/span&gt;&lt;br/&gt;加法操作作用的两个tensor具有相同的结构大小,在channel方向上将对应的feature map相加合并.&lt;/p&gt;
&lt;h3 id=&quot;plain-network&quot;&gt;Plain Network&lt;/h3&gt;
&lt;p&gt;Plain Network 主要是受 VGG 网络启发，主要采用3x3滤波器，遵循两个设计原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输出相同特征图尺寸的卷积层，有相同个数的滤波器(stride=1使得输出尺寸不变)&lt;/li&gt;
&lt;li&gt;通过stride=2降采样后特征图尺寸缩小一半，增加一倍的滤波器个数使每层卷积的计算复杂度相同(以特征图大小56-&amp;gt;28为例,56的卷积操作数为(56x56x64)x(3x3x64),而64的卷积操作数为(28x28x128)x(3x3x128),计算量相等,当然stride=2的conv层计算量减半).&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;residual-network&quot;&gt;Residual Network&lt;/h3&gt;
&lt;p&gt;在 plain network 中加入 shortcut connections 构成了ResNet.对于shortcut的连接方式，论文提出了三个选项：&lt;/p&gt;
&lt;p&gt;A. 使用恒等映射，如果residual block的输入输出维度不一致，对增加的维度用0来填充；&lt;/p&gt;
&lt;p&gt;B. 在block输入输出维度一致时使用恒等映射，不一致时使用线性投影以保证维度一致(使用一层Conv+BatchNorm即可)；&lt;/p&gt;
&lt;p&gt;C. 对于所有的block均使用线性投影。&lt;/p&gt;
&lt;p&gt;对这三个选项都进行了实验，发现虽然C的效果好于B的效果好于A的效果，但是差距很小，因此线性投影并不是必需的，而使用0填充时，可以保证模型的复杂度最低，这对于更深的网络是更加有利的。并且由于A方法不需要额外的参数,所以在层数较高时选择使用A.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Deeper Bottleneck结构&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;对于更深的网络使用三层的残差结构,如下图所示,使用两个1x1的卷积先降维再增加维度,减少了3x3卷积层的个数及其输入输出维度,这个较小维度的3x3卷积即为bottleneck.图示的两种结构设计有相近的时间复杂度.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/606386/201710/606386-20171021115433271-854290266.jpg&quot; alt=&quot;deeper-residual-func&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无参数的Identity shortcut对于bottleneck结构尤为重要,如果替换成有参数的投射,模型大小和复杂度将会增加.&lt;/p&gt;
&lt;p&gt;论文中给出的18，34，50，101，152层网络如下表所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/606386/201710/606386-20171016223757443-785220142.png&quot; alt=&quot;ResNet-arch&quot;/&gt;&lt;br/&gt;Plain Network,Residual Network与VGG-19的区别:&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/606386/201710/606386-20171017163813802-766338210.png&quot; alt=&quot;ResNet34&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于degradation&quot;&gt;关于degradation&lt;/h3&gt;
&lt;p&gt;论文指出网络的退化不太可能是梯度消失造成的,因为网络中使用了BatchNorm层来保持信号的传播.具体原因尚不明确,需要后续研究.&lt;/p&gt;
&lt;p&gt;实验发现通过更多的迭代次数(3x),仍然是degradation.&lt;/p&gt;
&lt;h3 id=&quot;resnet解读&quot;&gt;ResNet解读&lt;/h3&gt;
&lt;p&gt;参考论文作者另一篇论文&lt;a href=&quot;https://arxiv.org/abs/1603.05027&quot;&gt;Identity Mappings in Deep Residual Networks&lt;/a&gt;对ResNet的解读,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/606386/201710/606386-20171017142339443-2124573068.png&quot; alt=&quot;residual-block&quot;/&gt;&lt;/p&gt;
&lt;p&gt;残差网络单元其中可以分解成右图的形式，从图中可以看出，残差网络其实是由多种路径组合的一个网络，直白了说，残差网络其实是很多并行子网络的组合，整个残差网络其实相当于一个多人投票系统（Ensembling）。&lt;/p&gt;
&lt;p&gt;ResNet只是表面上看起来很深，事实上网络却很浅。&lt;br/&gt;所示ResNet真的解决了深度网络的梯度消失的问题了吗？似乎没有，ResNet其实就是一个多人投票系统。&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;
&lt;p&gt;caffe中实现特征的加法,用Eltwise层的SUM operation即可:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;layer {
  name: &quot;Eltwise3&quot;
  type: &quot;Eltwise&quot;
  bottom: &quot;Eltwise2&quot;
  bottom: &quot;Convolution7&quot;
  top: &quot;Eltwise3&quot;
  eltwise_param {
    operation: SUM
  }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 22 Mar 2018 01:25:00 +0000</pubDate>
<dc:creator>康行天下</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makefile/p/ResNet.html</dc:identifier>
</item>
</channel>
</rss>