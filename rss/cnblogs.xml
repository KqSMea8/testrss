<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【原创】Mysql中select的正确姿势 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9902911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9902911.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;大家在开发中，还有很多童鞋在写查询语句的时候，习惯写下面这种&lt;strong&gt;不规范&lt;/strong&gt;sql&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from table&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而不写成下面的这种&lt;strong&gt;规范&lt;/strong&gt;方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select col1,col2,...,coln from table&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我也知道，这些童鞋是图方便，毕竟再敲一堆的列名，嫌麻烦!&lt;br/&gt;你们上班可以问问自己的同事&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;你：“xx，知道select *和select所有字段的区别么？&lt;br/&gt;同事:&quot;额。。额。。额。。&quot;&lt;br/&gt;留下的只有尴尬的笑容！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我也知道，很多人至今都没有搞懂&lt;code&gt;select *&lt;/code&gt;和&lt;code&gt;selct 所有字段&lt;/code&gt;的区别&lt;br/&gt;因此，我开一文来说明一下。另外，我选的是自己最熟悉的&lt;code&gt;mysql&lt;/code&gt;数据库，此文的结论在&lt;code&gt;oralce&lt;/code&gt;,&lt;code&gt;sqlserver&lt;/code&gt;上是否成立，博主没做过测试。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;h3 id=&quot;select所有字段性能高&quot;&gt;(select所有字段)性能高?&lt;/h3&gt;
&lt;p&gt;网络上流传着一种说法说是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“*” 表示通配所有字段，在SQL的机制里，需要先识别统计所有字段再进行下一步。&lt;br/&gt;明确指定字段的话，会减少上述的操作，所以效率有所提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，实际上呢？效率是相差不大的！。&lt;br/&gt;取博客&lt;br/&gt;&lt;code&gt;http://flysnowxf.iteye.com/blog/1125032&lt;/code&gt;&lt;br/&gt;的测试结果&lt;br/&gt;mysql 5.1.37&lt;br/&gt;表记录数41,547,002，即4000w行&lt;br/&gt;使用远程客户端取1000条数据，统计时间：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM `dmsp`.`dmsp_dimension_content` LIMIT 0, 1000;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时间2.218s，网络消耗0.547s&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT `id`, `appid`, `aop`, `t`, `uid`, `sid`, `pid`, `pname`, `bid`, `bname`, `ptype`, `sm`, `sv`, `bt`, `national`, `area`, `ov` FROM `dmsp`.`dmsp_dimension_content` LIMIT 0, 1000;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取出所有字段，时间2.250s，网络消耗0.578s&lt;br/&gt;可以看出，这二者的时间差几乎可以忽略，另外还有一本书上的内容也可以佐证我的话。&lt;br/&gt;《SQL CookBook》第一章 检索记录中1.1小节（原书第十五页内容如下）：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/rjzheng/1281019/o_select01.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;此书也说明了，两种方式在性能上几乎是没有差距的。&lt;br/&gt;&lt;strong&gt;那为什么还是不推荐select * ?&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络io问题&quot;&gt;网络IO问题&lt;/h3&gt;
&lt;p&gt;很多文章里说什么，会带来额外的内存、磁盘、cpu的开销。对此，我有自己的观点。我觉得这不是主要原因。主要原因是带来了额外的网络开销。&lt;br/&gt;在一个系统中，内存、磁盘、cpu的开销，不过是微妙级。造成系统的延迟的重头戏是网络开销。网络开销可能带来秒级的延迟。当然，如果你的应用程序和数据库是在同一台机器上的，那当我没说这句话！&lt;br/&gt;&lt;code&gt;select *&lt;/code&gt;会查询出不需要的、额外的数据，那么这些额外的数据在网络上进行传输，必定会造成性能延迟。假设你的&lt;code&gt;table&lt;/code&gt;中，有一个列的类型为&lt;code&gt;binary&lt;/code&gt;。此时，你的&lt;code&gt;select *&lt;/code&gt;操作，就会十分缓慢，并且会造成额外的网络开销。&lt;/p&gt;
&lt;h3 id=&quot;索引问题&quot;&gt;索引问题&lt;/h3&gt;
&lt;p&gt;仔细看下面的两句sql&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select col1 from table;
select * from table;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果col1字段包含索引信息，那么此时，这两句的sql执行时间可能会有几十上百倍的差异。&lt;br/&gt;在col1字段有索引的情况下，mysql是可以不用读data，直接使用index里面的值就返回结果的。但是一旦用了&lt;code&gt;select *&lt;/code&gt;，就会有其他列需要读取，这时在读完index以后还需要去读data才会返回结果。这样就造成了额外的性能开销。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt;：我不想在这里扯什么覆盖索引，辅助索引的概念。其实要讲的很专业，扯一堆高大上的名词，我也可以。只是这样徒增读者的理解难度，尽量用通俗的方式来讲。&lt;/p&gt;
&lt;h3 id=&quot;扩展性问题&quot;&gt;扩展性问题&lt;/h3&gt;
&lt;p&gt;有的人会觉得&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用select * ，这样在增加列的时候，不用改sql，方便！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而实际上，你的sql是不用改了，但是对你的程序代码是有很大的影响的！&lt;br/&gt;身为一名21世纪的优良程序员，我们是不能获取自己需要的东西的！你因为一时高兴，执行了&lt;code&gt;select *&lt;/code&gt;，如果增加或删除列，会对你的代码有着极大的影响。&lt;br/&gt;反过来，如果你&lt;code&gt;select 指定列&lt;/code&gt;，只获取自己需要的几列，表结构的修改，对你代码的影响就会小很多。相比之下，风险就没有那么大了！&lt;br/&gt;另外就是，对于其他人接手你项目的人来说，看到&lt;code&gt;select 指定列&lt;/code&gt;的方式，可读性更强，对于他们来说更好上手！&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 17:39:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<og:description>讲如何正确的select</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9902911.html</dc:identifier>
</item>
<item>
<title>Springmvc借助SimpleUrlHandlerMapping实现接口开关功能 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/9902475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/9902475.html</guid>
<description>&lt;h2&gt;一、接口开关功能&lt;/h2&gt;
&lt;p&gt;　　1、可配置化，依赖配置中心&lt;/p&gt;
&lt;p&gt;　　2、接口访问权限可控&lt;/p&gt;
&lt;p&gt;　　3、springmvc不会扫描到，即不会直接的将接口暴露出去&lt;/p&gt;
&lt;h2&gt;二、接口开关使用场景&lt;/h2&gt;
&lt;p&gt;　　和业务没什么关系，主要方便查询系统中的一些状态信息。比如系统的配置信息，中间件的状态信息。这就需要写一些特定的接口，不能对外直接暴露出去（即不能被springmvc扫描到，不能被swagger扫描到）。&lt;/p&gt;
&lt;h2&gt;三、SimpleUrlHandlerMapping官方解释&lt;/h2&gt;
&lt;p&gt;　　SimpleUrlHandlerMapping实现HandlerMapping接口以从URL映射到请求处理程序bean。&lt;br/&gt;　　支持映射到bean实例和映射到bean名称;后者是非单身处理程序所必需的。&lt;br/&gt;　　“urlMap”属性适合用bean引用填充处理程序映射，例如通过XML bean定义中的map元素。&lt;br/&gt;　　可以通过“mappings”属性以java.util.Properties类接受的形式设置bean名称的映射，如下所示：/welcome.html=ticketController /show.html=ticketController语法为PATH = HANDLER_BEAN_NAME。　　&lt;br/&gt;　　如果路径不以斜杠开头，则前置一个。支持直接匹配（给定“/ test” - &amp;gt;注册“/ test”）和“*”模式匹配（给定“/ test” - &amp;gt;注册“/ t *”）。&lt;/p&gt;
&lt;h2&gt;四、接口开关实现&lt;/h2&gt;
&lt;p&gt;　　就像SimpleUrlHandlerMapping javadoc中描述的那样，其执行原理简单理解就是根据URL寻找对应的Handler。借助这种思想，我们在Handler中再借助RequestMappingHandlerMapping和RequestMappingHandlerAdapter来帮助我们完成URL的转发。这样做的好处是不需要直接暴露的接口开发规则只需要稍作修改，接下来将详细介绍一下。&lt;/p&gt;
&lt;h3&gt;　　请求转发流程如下&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201811/640632-20181103225422856-651649608.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　想法是好的，如何实现这一套流程呢？首先要解决以下问题。&lt;/p&gt;
&lt;p&gt;　　1、定义的接口不能被springmvc扫描到。&lt;/p&gt;
&lt;p&gt;　　2、接口定义还是要按照@RequestMaping规则方式编写，这样才能减少开发量并且能被RequestMappingHandlerMapping处理。&lt;/p&gt;
&lt;p&gt;　　3、如何自动注册url-&amp;gt;handler到SimpleUrlHandlerMapping中去。&lt;/p&gt;
&lt;p&gt;　　对于上面需要实现的，首先要了解一些springmvc相关源码。&lt;/p&gt;
&lt;h3&gt;　　RequestMappingHandlerMapping初始化method mapping&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Scan beans in the ApplicationContext, detect and register handler methods.
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #isHandler(Class)
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #getMappingForMethod(Method, Class)
 * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; #handlerMethodsInitialized(Map)
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initHandlerMethods() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
        logger.debug(&lt;/span&gt;&quot;Looking for request mappings in application context: &quot; +&lt;span&gt; getApplicationContext());
    }
    String[] beanNames &lt;/span&gt;= (&lt;span&gt;this&lt;/span&gt;.detectHandlerMethodsInAncestorContexts ?&lt;span&gt;
            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) :
            getApplicationContext().getBeanNamesForType(Object.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {
            Class&lt;/span&gt;&amp;lt;?&amp;gt; beanType = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                beanType &lt;/span&gt;=&lt;span&gt; getApplicationContext().getType(beanName);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; An unresolvable bean type, probably from a lazy bean - let's ignore it.&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isDebugEnabled()) {
                    logger.debug(&lt;/span&gt;&quot;Could not resolve target class for bean with name '&quot; + beanName + &quot;'&quot;&lt;span&gt;, ex);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanType != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;&lt;span&gt; isHandler(beanType)&lt;/span&gt;) {
                &lt;span&gt;detectHandlerMethods(beanName)&lt;/span&gt;;
            }
        }
    }
    handlerMethodsInitialized(getHandlerMethods());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　isHandler方法【判断方法是不是一个具体handler】逻辑如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isHandler(Class&amp;lt;?&amp;gt;&lt;span&gt; beanType) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (AnnotatedElementUtils.hasAnnotation(beanType, Controller.&lt;span&gt;class&lt;/span&gt;) ||&lt;span&gt;
            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以我们定义的开关接口为了不被springmvc扫描到，直接去掉类注释上的@Controller注解和@RequestMapping注解就好了，如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@ResponseBody
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommonsStateController {
    @GetMapping(&lt;/span&gt;&quot;/url1&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String handleUrl1()  {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　@GetMapping(&quot;/url2&quot;&lt;span&gt;)
    public&lt;span&gt; String handleUrl2()  {
      return null&lt;span&gt;;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　按照如上的定义，url  -&amp;gt; handler（/message/state/* -&amp;gt; CommonsStateController ）形式已经出来了，但是还缺少父类路径 /message/state/ 以及 如何让RequestMappingHandlerMapping识别CommonsStateController这个handler 中的所有子handler。&lt;/p&gt;
&lt;h3&gt;　　抽象Handler以及自定义RequestMappingHandlerMapping&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.InitializingBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.HandlerExecutionChain;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.AbstractController;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.method.RequestMappingInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Objects;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hujunzheng
 * @create 2018-08-10 12:53
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseController &lt;span&gt;extends&lt;/span&gt; AbstractController &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InitializingBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; RequestMappingHandlerMapping handlerMapping = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseRequestMappingHandlerMapping();

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RequestMappingHandlerAdapter handlerAdapter;

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        HandlerExecutionChain mappedHandler &lt;/span&gt;=&lt;span&gt; handlerMapping.getHandler(request);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handlerAdapter.handle(request, response, mappedHandler.getHandler());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPropertiesSet() {
        handlerMapping.afterPropertiesSet();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseRequestMappingHandlerMapping &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RequestMappingHandlerMapping {
&lt;br/&gt;　　　　  //初始化子handler mapping
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initHandlerMethods() {
            detectHandlerMethods(BaseController.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
&lt;br/&gt;//合并父路径和子handler路径
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; RequestMappingInfo getMappingForMethod(Method method, Class&amp;lt;?&amp;gt;&lt;span&gt; handlerType) {
            RequestMappingInfo info &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getMappingForMethod(method, handlerType);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Objects.isNull(info) &amp;amp;&amp;amp;&lt;span&gt; StringUtils.isNotBlank(getBasePath())) {
                info &lt;/span&gt;=&lt;span&gt; RequestMappingInfo
                        .paths(getBasePath())
                        .build()
                        .combine(info);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; info;
        }
    }
    //开关接口定义父路径
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getBasePath();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所有开关接口handler都继承这个BaseController 抽象类，在对象初始时创建所有的子handler mapping。SimpleUrlHandlerMapping最终会调用开关接口的handleRequestInternal方法，方法内部通过RequestMappingHandlerMapping和RequestMappingHandlerAdapter 将请求转发到具体的子handler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@ResponseBody
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CommonsStateController &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseController {
    @GetMapping(&lt;/span&gt;&quot;/url1&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String handleUrl1()  {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    

　 @GetMapping(&lt;/span&gt;&quot;/url2&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String handleUrl2()  {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　自动注册url-handler到SimpleUrlHandlerMapping&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.CollectionUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hujunzheng
 * @create 2018-08-10 13:57
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; EnhanceSimpleUrlHandlerMapping &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SimpleUrlHandlerMapping {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EnhanceSimpleUrlHandlerMapping(List&amp;lt;BaseController&amp;gt;&lt;span&gt; controllers) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(controllers)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NOSONAR&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        Map&lt;/span&gt;&amp;lt;String, BaseController&amp;gt; urlMappings = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        controllers.forEach(controller &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            String basePath &lt;/span&gt;=&lt;span&gt; controller.getBasePath();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isNotBlank(basePath)) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!basePath.endsWith(&quot;/*&quot;&lt;span&gt;)) {
                    basePath &lt;/span&gt;= basePath + &quot;/*&quot;&lt;span&gt;;
                }
                urlMappings.put(basePath, controller);
            }
        });
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setUrlMap(urlMappings);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取BaseController父路径，末尾加上‘/*’，然后将url -&amp;gt; handler关系注册到SimpleUrlHandlerMapping的urlMap中去。这样只要请求路径是 父路径/*的模式都会被SimpleUrlHandlerMapping处理并转发给对应的handler（BaseController），然后在转发给具体的子handler。&lt;/p&gt;
&lt;h3&gt;　　接口开关逻辑&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.cmos.wmhopenapi.service.config.LimitConstants;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.collect.Lists;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.lang3.StringUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.handler.SimpleUrlHandlerMapping;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.stream.Collectors;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; hujunzheng
 * @create 2018-08-10 15:17
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UrlHandlerInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HandlerInterceptorAdapter {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleUrlHandlerMapping mapping;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LimitConstants limitConstants;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UrlHandlerInterceptor(SimpleUrlHandlerMapping mapping, LimitConstants limitConstants) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapping =&lt;span&gt; mapping;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.limitConstants =&lt;span&gt; limitConstants;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        String lookupUrl &lt;/span&gt;=&lt;span&gt; mapping.getUrlPathHelper().getLookupPathForRequest(request);
        String urllimits &lt;/span&gt;=&lt;span&gt; limitConstants.getUrllimits();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isNotBlank(urllimits)) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String urllimit : Lists.newArrayList(urllimits.split(&quot;,&quot;&lt;span&gt;))
                    .stream()
                    .map(value &lt;/span&gt;-&amp;gt;&lt;span&gt; value.trim())
                    .collect(Collectors.toList())) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mapping.getPathMatcher().match(urllimit, lookupUrl)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　基本思路就是通过 UrlPathHelper获取到request的lookupUrl（例如 /message/state/url1） ，然后获取到配置中心配置的patter path（例如message/state/*），最后通过 AntPathMatcher进行二者之间的匹配，如果成功则禁止接口访问。&lt;/p&gt;
&lt;h2&gt; 五、接口开关配置&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Bean
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SimpleUrlHandlerMapping simpleUrlHandlerMapping(ObjectProvider&amp;lt;List&amp;lt;BaseController&amp;gt;&amp;gt;&lt;span&gt; controllers, LimitConstants limitConstants) {
    SimpleUrlHandlerMapping mapping &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnhanceSimpleUrlHandlerMapping(controllers.getIfAvailable());
    mapping.setOrder(Ordered.HIGHEST_PRECEDENCE &lt;/span&gt;+ 1&lt;span&gt;);

    mapping.setInterceptors(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UrlHandlerInterceptor(mapping, limitConstants));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapping;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建自定义的SimpleUrlHandlerMapping，然后将类型为BaseController所有handler以构造参数的形式传给SimpleUrlHandlerMapping，并设置接口开关逻辑拦截器。&lt;/p&gt;
&lt;p&gt;　　至此，接口开关能力已经实现完毕。再也不用在担心接口会直接暴露出去了，可以通过配置随时更改接口的访问权限。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 17:08:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>一、接口开关功能 1、可配置化，依赖配置中心 2、接口访问权限可控 3、springmvc不会扫描到，即不会直接的将接口暴露出去 二、接口开关使用场景 和业务没什么关系，主要方便查询系统中的一些状态信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/9902475.html</dc:identifier>
</item>
<item>
<title>IDE or Editor？ - 寻觅beyond</title>
<link>http://www.cnblogs.com/-beyond/p/9902750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-beyond/p/9902750.html</guid>
<description>&lt;h2&gt;IDE（集成开发环境）介绍&lt;/h2&gt;
&lt;p&gt;　    IDE（IDE，Integrated Development Environment ）集成开发环境：是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。（来自百度百科）&lt;/p&gt;
&lt;p&gt;　　每一种语言都有很多对应的IDE，比如C++开发的Code Blocks、Dev C++，Visual Studio；python的pycharm； php的phpstorm、zend studio；Golang有Liteide、goland；java有eclipse、myeclipse、InteliJ....很多很多，其实上面对于IDE的解释，结合工作中最常用的几个功能，也就下面这几个了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动缩进、代码格式化、语法高亮&lt;/li&gt;
&lt;li&gt;智能感知、自动补全&lt;/li&gt;
&lt;li&gt;代码片段&lt;/li&gt;
&lt;li&gt;运行、单元测试、调试&lt;/li&gt;
&lt;li&gt;lint&lt;/li&gt;
&lt;li&gt;项目结构管理（包、模块管理）&lt;/li&gt;
&lt;li&gt;定时自动保存&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　可以看到IDE的功能的确是挺强大的，这也就导致一个问题：臃肿。直观感受就是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装时间太长、启动慢&lt;/li&gt;
&lt;li&gt;运行占用内存太大，卡&lt;/li&gt;
&lt;li&gt;响应时间比较慢&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;代码编辑器（文本开发编辑器）&lt;/h2&gt;
&lt;p&gt; 　　代码编辑器，也可以说是文本编辑器，重点是：编辑器。&lt;/p&gt;
&lt;p&gt;　　常见的编辑器有：Notepad++、EditPlus、Sublime text、vs code、Vim..&lt;/p&gt;
&lt;p&gt;　　几乎所有编辑器都有自动缩进的功能，几乎所有编辑器都没有上面列出的IDE的其他功能。可以说，编辑器很纯粹，就是用来编辑文本的。同时，几乎每一种编辑器都支持插件，你可以下载自己需要的、喜欢的地插件。拥有插件的编辑器不一定比IDE差。&lt;/p&gt;


&lt;h2&gt;我的经历&lt;/h2&gt;
&lt;p&gt;　　最初学习C++，使用codeblocks，当时就知道将代码写好之后，按一下F9就可运行代码，至于为什么可以运行代码，也是之后在大三的时候才知道。&lt;/p&gt;
&lt;p&gt;　　期间学习一些脚本，用的最多的就是sublime text，因为他可以切换主题，也可以安装插件，另外打开文件速度也很快（秒杀IDE）。&lt;/p&gt;
&lt;p&gt;　　之后工作期间，按照规定，都登录到堡垒机中进行开发，于是开始使用Vim，虽然快捷键有点多，但是用熟练之后，开发效率真的特别高，从此，我的所有编辑器，都装了vim插件。&lt;/p&gt;
&lt;p&gt;　　最近接触到VS code，他的特点就是：sublime text有的，他都有。关键是免费，别给我说搜sublime text的序列号，在公司，呵呵。&lt;/p&gt;


&lt;h2&gt;个人推荐&lt;/h2&gt;
&lt;p&gt;　　我不会推荐哪一个IDE或者哪一个编辑器，我只要想说的是：如果你想稳扎稳打，那么在学习的时候，不要使用IDE；在真正的开发任务中，推荐使用IDE。&lt;/p&gt;
&lt;p&gt;　　为什么呢？其实大家都很清楚，IDE有那么多优点，可以省去很多手动编写代码的时间，在开发任务进行中，利用IDE来生成代码（甚至生成一个成型项目也是可以的），无疑可以加快开发进度，因为有各种检测和提示功能，也可以减少出错；&lt;/p&gt;
&lt;p&gt;　　但是，在学习过程中，最好不要使用IDE，除非你知道你的某个快捷键或者某个按钮在底层为你做了什么，为什么按一下快捷键就能运行，为什么点一下按钮就能导入包？底层执行了什么命令？&lt;/p&gt;
&lt;p&gt;　　另外，即使你学会了一个IDE的快捷键，如果换一个IDE，咋办呢？快捷键不一定通用呀！&lt;/p&gt;
&lt;p&gt;　　举个我学习Java过程中的一个例子：&lt;/p&gt;
&lt;p&gt;　　我一直用的是vs code，平时运行java程序，都是写的一个脚本（几十行的shell脚本），用这个脚本来执行java程序。学到Java连接数据库的时候，需要导入一个mysql的驱动，但是，惊奇的发现，书上、网上的博客、教程，全部都是使用eclipse来完成的（在eclipse项目右击“构建路径”--“配置构建路径”--“库”--“添加外部jar”--找到数据库的驱动jar包--点击确定。会在左侧包资源管理器中出现“引用的库”，在里面就能找到我们刚才导入的jar包）。&lt;/p&gt;
&lt;p&gt;　　为了学个Java连数据库，我还要去安装一个eclipse？真是搞笑，如果开发环境是纯命令行的Linux系统，那你就呵呵哒。&lt;/p&gt;
&lt;p&gt;　　当然，我不是说，用IDE就不好，IDE有他的优点，但在学习阶段，如果真的想要走的更远，那就别用IDE，虽然每一种语言有很多的API，并不需要你去记住API的每一个字母（最好能，但是不现实），但是真的需要你去 完整地、手动地敲几遍，即使日后使用IDE，那也是莫问题的；想想以后面试的时候，手写代码的时候，你好意思叫面试官给你准备电脑吗？别傻了!&lt;/p&gt;
&lt;p&gt;　　最后在说一句：学习是严谨的、需要脚踏实地。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 16:02:00 +0000</pubDate>
<dc:creator>寻觅beyond</dc:creator>
<og:description>IDE（集成开发环境）介绍 IDE（IDE，Integrated Development Environment ）集成开发环境：是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-beyond/p/9902750.html</dc:identifier>
</item>
<item>
<title>c#  弹性和瞬态故障处理库Polly 学习 - alone_alone</title>
<link>http://www.cnblogs.com/xxue/p/9902669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxue/p/9902669.html</guid>
<description>&lt;p&gt;&lt;span&gt;                                                                    &lt;img src=&quot;https://img2018.cnblogs.com/blog/943408/201811/943408-20181103224731745-507595531.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;  Polly是一个基于.NET的弹性及瞬态故障处理库,允许开发人员以顺畅及线程安全的方式执行重试(Retry)、断路(Circuit Breaker)、超时(Timeout)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     隔离(Bulkhead Isolation)和回退策略(Fallback ).&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Polly适用于 .NET 4.0, .NET 4.5 和.NET Standard 1.1。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     以上是官方文档对polly库的介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     polly的介绍中有个很关键的词是瞬态故障，这个词也很好的诠释了Polly使用的一个背景.瞬态故障,就是指我们的程序在运行当中可能会发生故障,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;     这些故障包含程序运行中的异常、返回结果不符等。弹性是指Polly在应对这些故障时具有灵活性，且其提供的策略也可以很灵活的组合在一起使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;span&gt;方式1：在Nuget中下载Polly安装包，安装成功即可使用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;                  &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;Install-Package Polly&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     方式2：在github中下载Polly源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 &lt;a href=&quot;https://github.com/App-vNext/Polly&quot; target=&quot;_blank&quot;&gt;https://github.com/App-vNext/Polly&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;   &lt;span&gt;一、重试（Retry）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       异常重试是最常使用的一个策略,其功能是当我们执行的方法体发生异常时,可以按照我们指定的次数进行重试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
          Policy
          .Handle&amp;lt;NullReferenceException&amp;gt;()   //指定需要重试的异常类型 
          .Retry(2,(ex,count,context)=&amp;gt; {     //指定发生异常重试的次数
              Console.WriteLine($&quot;重试次数{count},异常{ex.Message}&quot;);
          })                                          
          .Execute(() =&amp;gt; Console.Write(&quot;execute method!&quot;));    //要执行的方法
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　  &lt;span&gt; Polly的所有策略使用都支持链式调用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      Polly重试策略的使用分为三个步骤&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;   1、指定需要处理的异常&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;         可以指定捕获执行的任务的异常类型,若执行任务的异常类型满足指定异常,那么重试机制将会生效&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt; 2、指定重试次数和监控重试&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;        指定整个执行过程中需要重试多少次,且可以监控每次的重试信息,比如重试次数  异常以及重试的上下文信息&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;   3、指定执行的任务&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;        指定执行的任务是整个异常重试的核心和监控对象,Execute支持多种重载.。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          重试策略支持异步任务      &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_a88bcef7-d81f-4b3a-bfda-f60fce6d19b2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a88bcef7-d81f-4b3a-bfda-f60fce6d19b2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a88bcef7-d81f-4b3a-bfda-f60fce6d19b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task PollyStudy()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; num = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Policy
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 .Handle&amp;lt;Exception&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 .RetryAsync(&lt;span&gt;2&lt;/span&gt;, (ex, count, context) =&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;重试次数{count},异常{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 .ExecuteAsync&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(() =&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetNum();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; GetNum()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;  二、超时（Timeout）&lt;/span&gt; &lt;/h2&gt;
&lt;p&gt;       &lt;span&gt;超时策略主要用于对任务执行的执行时长监控,若任务执行超出指定执行时长,那么我们就认为这次任务执行是失败的,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      不会再去等待结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;超时策略最基本的设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;             Policy
            .Timeout(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, (context, timeSpan, task) =&amp;gt;&lt;span&gt;
           {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;   &lt;span&gt;三、熔断（&lt;/span&gt;Circuit-breaker&lt;span&gt;）&lt;/span&gt;    &lt;/h2&gt;
&lt;p&gt;     &lt;span&gt;熔断在这里的含义在执行某个任务时,多次重试依然出现超时或则异常,且重试的次数已经超过了系统设定上限.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     那么就中断当前的执行,快速响应失败信息给用户,等待一段时间再进行恢复,继续执行.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
var breakerPlocy = Policy.Handle&amp;lt;Exception&amp;gt;()     //指定异常
                         .CircuitBreaker(5, TimeSpan.FromSeconds(30),               //设置5次阀值,中断30秒
                         onBreak: (ex, timeSpan) =&amp;gt; { Console.WriteLine(&quot;onBreak&quot;); }, //中断回调
                         onReset: () =&amp;gt; { Console.WriteLine(&quot;onReset&quot;); });            //重置回调
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;熔断的基本策略设置如上代码所示,上面的代码可以解析为当某个任务超过5次异常时,我们进行中断处理,等待30秒后再次继续.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    我们设置了&lt;/span&gt;&lt;span&gt;中断回调和重启回调函数,可以记录当中的执行信息.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; &lt;/span&gt; &lt;span&gt;&lt;span&gt;四、&lt;/span&gt;&lt;/span&gt;&lt;span&gt;回退（Fallback）&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;   &lt;span&gt;回退策略的前置条件是当我们的操作注定会失败时,我们就需要有一个合理的返回信息来替代失败信息,也就是提供一个备用方案,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   从而能对我们的失败操作进行挽救.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Policy
        .Handle&amp;lt;Exception&amp;gt;()                 
        .Fallback(fallbackAction: () =&amp;gt; { }, onFallback: (ex) =&amp;gt; { });   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;回退策略的基本设置如上所示,我们可以定义备用的返回信息,同时可以定义回调&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;   &lt;span&gt;五、隔板隔离策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    &lt;span&gt;隔板隔离的前置条件是当进程出现故障时，多个失败一直在主机中对资源一直占用。下游系统故障也可能导致上游系统的故障,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   这些风险都可能导致系统产生严重的后果.而隔板隔离策略可以隔离有相互影响的操作,将受管制的草需哦限制在一个固定的&lt;/span&gt;&lt;span&gt;资源池中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            Policy.Bulkhead(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, (context) =&amp;gt; { });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;指定最大的线程数,和正在排队的队列数,若执行被拒绝,则执行回调.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 六、缓存策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;span&gt;缓存策略的前置条件是我们的数据更新周期较长且使用频繁,我们可以首次加载这些数据时将这些数据缓存起来,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;  如果数据已经存在那么我们直接从缓存中读取.&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
ISyncCacheProvider cacheProvider = new StubCacheProvider();
            Func&amp;lt;Context, string&amp;gt; cacheKeyStrategy = null;
            Action action = () =&amp;gt; Policy.Cache(cacheProvider, TimeSpan.MaxValue, cacheKeyStrategy);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;缓存策略在某些情况下简化我们的缓存实现是很有帮助的.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;七、策略包装策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;span&gt;策略包装策略的前置条件是不同的异常需要不同的策略,也就是需要我们弹性的使用策略来应对不同的异常信息.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 NoOpPolicy policy0 = Policy.NoOp();
            NoOpPolicy policy1 = Policy.NoOp();
            NoOpPolicy policy2 = Policy.NoOp();
            PolicyWrap policyWrap = Policy.Wrap(policy0, policy1, policy2);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;  &lt;span&gt;上面简单介绍了polly七大策略和其基本配置,Polly实际功能很强大,是一个很值得仔细学习的库.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  后面会详细介绍Polly的几大策略以及在实际项目中的一个应用&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 03 Nov 2018 15:40:00 +0000</pubDate>
<dc:creator>alone_alone</dc:creator>
<og:description>关于Polly Polly是一个基于.NET的弹性及瞬态故障处理库,允许开发人员以顺畅及线程安全的方式执行重试(Retry)、断路(Circuit Breaker)、超时(Timeout)、 隔离(B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxue/p/9902669.html</dc:identifier>
</item>
<item>
<title>解开Future的神秘面纱之任务执行 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9902340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9902340.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　此文承接之前的博文 &lt;a href=&quot;https://www.cnblogs.com/longfurcat/p/9582413.html&quot; target=&quot;_blank&quot;&gt;解开Future的神秘面纱之取消任务&lt;/a&gt; 补充一些任务执行的一些细节，并从全局介绍程序的运行情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务提交到执行的流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103202022692-1357693454.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;


&lt;p&gt;前文我们已经了解到一些Future的实现细节，这里我们来梳理一下运行流程。这里只说sumbit（提交）&lt;/p&gt;
&lt;p&gt;（1）客户端创建一个Callable或Runnable对象。&lt;/p&gt;
&lt;p&gt;（2）客户端调用ExecutorService的submit方法，将任务提交给执行器。&lt;/p&gt;
&lt;p&gt;（3）ExecutorService将调用其实现类AbstractExecutorService的submit方法。&lt;/p&gt;
&lt;p&gt;（4）submit方法将获取到的Runnable/Callable任务交由其内部方法newTaskFor进行包装。&lt;/p&gt;
&lt;p&gt;（5）newTaskFor方法将Runnable/Callable包装成FutureTask对象。&lt;/p&gt;
&lt;p&gt;（6）submit把包装好的FutureTask对象交由execute方法执行，此方法有ThreadPoolExecutor提供。&lt;/p&gt;
&lt;p&gt;（7）submit方法返回FutreTask对象给客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务提交为何能接收两种类型的接口？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上很有意思的是，&lt;span&gt;FutureTask只使用Callable对象（因为使用Future的初衷就是想要获取任务处理结果），而Executor的execute只接收Runnable对象（执行器只管执行任务）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;FutureTask接收到Runnable对象后，会利用&lt;strong&gt;适配器&lt;/strong&gt;，将其适配为Callable对象进行使用。注意，Runnable适配后，返回值基本没什么意义，都是写死的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103213157275-814083375.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;177&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而FutureTask实际上相当于Runnable对象的装饰器，FutureTask的继承结构如图所示：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103200349931-239369232.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;268&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道Runnable定义了任务该做什么，Future定义了任务的控制操作，而RunnableFuture接口兼具这两个功能。&lt;/p&gt;
&lt;p&gt;Future就是实现这组操作的实现类，它也是&lt;strong&gt;Runnable的装饰器类&lt;/strong&gt;，Runnable任务在经过其包装后，仍然还是Runnable，不影响其交给execute方法执行。而且他实现了Future接口，也就可以根据它对任务进行控制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FutureTask有哪些字段，用来做什么的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103215845347-1394758480.png&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;203&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）state =&amp;gt; 状态，用于基于状态的控制操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NEW  =&amp;gt; 新建任务&lt;/li&gt;
&lt;li&gt;COMPLETING =&amp;gt; 正在完成，即任务已经被线程启动&lt;/li&gt;
&lt;li&gt;NORMAL =&amp;gt; 正常完成任务&lt;/li&gt;
&lt;li&gt;EXCEPTIONAL =&amp;gt; 任务因为异常而终止&lt;/li&gt;
&lt;li&gt;CANCELLED =&amp;gt; 任务已被取消，注意这里并不表示任务实际状态，即任务可能还在运行。&lt;/li&gt;
&lt;li&gt;INTERRUPTING =&amp;gt; 中断任务中&lt;/li&gt;
&lt;li&gt;INTERRUPTD =&amp;gt; 任务已被中断&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）callable =&amp;gt; callable任务，实际被执行的任务&lt;/p&gt;
&lt;p&gt;（3）outcome =&amp;gt; 执行结果&lt;/p&gt;
&lt;p&gt;（4）runner =&amp;gt; 执行线程的引用，用来控制任务的执行。&lt;/p&gt;
&lt;p&gt;（5）waiters =&amp;gt; 等待线程队列，当任务还未完成时，用于保存因为获取结果的而被阻塞的线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FutureTask的状态变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL（任务正常执行到结束）&lt;/p&gt;
&lt;p&gt;（2）NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL（任务执行过程中出现异常）&lt;/p&gt;
&lt;p&gt;（3）NEW -&amp;gt; CANCELLED （任务被取消）&lt;/p&gt;
&lt;p&gt;（4）NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED (任务已经开始，尚未完成就被取消)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FutureTask如何确定其执行线程的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　任务的控制最主要的两个功能就是取消和获取结果。取消的操作，上一篇博文已经讲到了，获取结果将于下篇讲述。这里补充前篇的一些内容，也就是取消操作相关的细节，当时已经获知，要取消任务，实际上是通过中断任务的执行线程实现的，如图：&lt;/p&gt;
&lt;p&gt;FutureTask的cancel方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103204213732-2031889765.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，这个runner是何时被赋值的，我当时并不清楚，查阅源码也没发现什么setRunner之类的代码。后来突然想到，只有在任务被执行的时候才能知道，它到底被哪个线程执行。于是才注意到了这段CAS的代码，（当时不太懂，所以就算看到了这段代码，也不明白）。意思就是说，如果当前对象的runner字段值为null，就将其设置为当前的执行线程。到这里，我们就有了此线程的引用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103204948926-1611957040.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181103204840514-245903804.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FutureTask到达ThreadPoolExecutor的execute之后，是什么情形？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里简要说一下，任务到达ThreadPoolExecutor之后，线程池会根据当前线程数量的情况进行处理，可能创建一个新线程来执行，或者加入到任务队列等待执行，再或者就是被线程池抛弃等等。&lt;/p&gt;
&lt;p&gt;　　相关细节可查看，我关于ThreadPoolExecutor的相关博文。&lt;/p&gt;

</description>
<pubDate>Sat, 03 Nov 2018 14:16:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 此文承接之前的博文 解开Future的神秘面纱之取消任务 补充一些任务执行的一些细节，并从全局介绍程序的运行情况。 任务提交到执行的流程 前文我们已经了解到一些Future的实现细节，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9902340.html</dc:identifier>
</item>
<item>
<title>码农深耕 - 35岁的程序员何去何从？ - 高云鹏</title>
<link>http://www.cnblogs.com/gaoyunpeng/p/9902073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gaoyunpeng/p/9902073.html</guid>
<description>&lt;p&gt;曾经在知乎回答过类似问题，那也是我在知乎获赞最高的回答。但是发现这个问题简直成了知乎的日常问题，可见广大同行的焦虑。那么索性从新审视这个命题，谈谈我对这件事情的看法。&lt;/p&gt;
&lt;h2 id=&quot;程序员的职业生命到底有多长&quot;&gt;程序员的职业生命到底有多长？&lt;/h2&gt;
&lt;p&gt;程序员是可以做一辈子的，但单纯只会敲代码的程序员，职业生命十年左右。&lt;br/&gt;从业初期，肯定是从小工到大工的成长过程，业务逐渐熟练，技巧逐渐丰富，理解逐渐深刻，这时你成为了“技术大拿”，你成为团队的“百晓生”、“顶梁柱”；之后，势必会承担起更多的责任，这时工作内容会逐渐体现出一些管理性质，你开始带团队，培养新人，做一些设计，参与制定一些规范，进行代码审查，这时公司开始信任你，依赖你；再后来，开始直接接触客户，收集需求，技术选型，开始考虑成本与利润，开始考虑风险与回报，这时你已经成为公司不可或缺的一部分。&lt;br/&gt;我只是写出了一个程序员成长路线的一种可能性，但是可以看出来，随着时间的流逝，公司对你的期待会越来越高，所以，程序员的职业生命是和个人能力成正比的。如同逆水行舟，不进则退，只要不断成长，让自己的能力与自己的资历匹配，职业生命就可以无限延长；否则，当你的能力无法匹配你的资历，面临的最坏结果就是出局。&lt;/p&gt;
&lt;h2 id=&quot;技术重要还是管理重要&quot;&gt;技术重要还是管理重要？&lt;/h2&gt;
&lt;p&gt;作为对技术抱有热情与幻想的程序员，我一度坚持认为技术最重要，但是现在我觉得我错了。技术当然是重要的，这也是我得到认可的原因，但是“技术”只是个工具，最终我们的产出是利用“技术”实现了的那个“需求”。我不断地磨练自己的技术，不断地学习，目的是当面对“需求”，我可以给出更多种可行的方案，我可以在实现的过程中有更多的选择，解决难题时我可以想到更多的手段。&lt;br/&gt;谈到管理，曾经觉得它和技术格格不入，但现在我觉得我又错了。“管理”可不是单纯的“管人”，项目的结构、团队的协调、进度、质量都需要管理，而这些也可以理解为广义的“技术”，当技术成长到一定程度，自然而然地会思考如何让项目进行得更流畅、效率更高、质量更稳，那么这时事实上我们已经在思考“管理”了。&lt;br/&gt;所以，对技术痴迷，也不要固执地排斥管理；对管理重视，也不要愚蠢地鄙视技术。技术缺管理是一盘散沙，白费力气；管理缺技术是缘木求鱼，攻而不克。&lt;/p&gt;
&lt;h2 id=&quot;要不要赶时髦&quot;&gt;要不要“赶时髦”？&lt;/h2&gt;
&lt;p&gt;新技术、新理念，我们要积极地去了解，但是要慎重地使用。软件行业用日新月异来形容毫不为过，这个充满活力的行业，各种新鲜事物层出不穷。作为从业人员，我们需要开阔视野，前沿知识哪怕不用，也要去了解，因为这种积累，在日后会为你提供更多的思路。但是在新技术的使用上，我偏向于求“稳”，贸然引入新技术，特别是整个团队集体转向，会引入太大的风险。现在互联网公司呈现出的激进的风潮，我是持保留态度的。&lt;/p&gt;
&lt;h2 id=&quot;程序员的核心竞争力是什么&quot;&gt;程序员的核心竞争力是什么？&lt;/h2&gt;
&lt;p&gt;是学习能力。我们这个行业实在变化太快，“一招鲜，吃遍天”这种事情是不存在的，我们总会遇到从未接触过的新挑战，怎么办？学习。就如同一个优秀的企业，它最有价值的地方在于它有无限的发展前景。那么一个优秀的程序员，最有价值的地方就在于拥有无限的潜力。要知道，公司雇佣一个人，并不是因为他现在水平深浅，而是他能不能和公司一起成长，只看眼前的公司不会长久，只看眼前的员工没有未来。&lt;/p&gt;
&lt;h2 id=&quot;程序员到底何去何从&quot;&gt;程序员到底何去何从？&lt;/h2&gt;
&lt;p&gt;其实啰嗦了那么多，归根结底就是持续提升自己，就这么简单。把焦虑、嫉妒、迷茫的时间拿来充实自己，到了35岁你会发现，这真的是职业生涯的分岔路口，只不过我们的路通向美好。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 12:57:00 +0000</pubDate>
<dc:creator>高云鹏</dc:creator>
<og:description>曾经在知乎回答过类似问题，那也是我在知乎获赞最高的回答。但是发现这个问题简直成了知乎的日常问题，可见广大同行的焦虑。那么索性从新审视这个命题，谈谈我对这件事情的看法。 程序员的职业生命到底有多长？ 程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gaoyunpeng/p/9902073.html</dc:identifier>
</item>
<item>
<title>【大数据安全】基于Kerberos的大数据安全验证方案 - mantou叔叔</title>
<link>http://www.cnblogs.com/mantoudev/p/9877433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantoudev/p/9877433.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;1.背景&lt;/h2&gt;
&lt;p&gt;互联网从来就不是一个安全的地方。很多时候我们过分依赖防火墙来解决安全的问题，不幸的是，防火墙是假设“坏人”是来自外部的，而真正具有破坏性的攻击事件都是往往都是来自于内部的。&lt;/p&gt;
&lt;p&gt;近几年，在thehackernews等网站上总会时不时看到可以看到一些因为数据安全问题被大面积攻击、勒索的事件。在Hadoop1.0.0之前，Hadoop并不提供对安全的支持，默认集群内所有角色都是可靠的。用户访问时不需要进行任何验证,导致恶意用户很容易就可以伪装进入集群进行破坏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4WMu9.png&quot; alt=&quot;不安全的Hadoop集群&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要保证Hadoop集群的安全，至少要做到2个A：Authentication（认证），Authorization（授权）。常见的方案有：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Authentication：&lt;br/&gt;MIT Kerberos, Azure AD, Kerby&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Authorization：&lt;br/&gt;Apache Sentry(Cloudera), Apache Ranger(Hortonworks)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/10/30/5XI5Nu.png&quot; alt=&quot;Hadoop Cluster Secure&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;hadoop集群对kerberos的支持&quot;&gt;Hadoop集群对Kerberos的支持&lt;/h5&gt;
&lt;p&gt;2012年1.0.0版本正式发布后，Hadoop增加了对Kerberos的支持。使得集群中的节点是可信任的。Kerberos可以将认证的密钥在集群部署时事先放到可靠的节点上。集群运行时，集群内的节点使用密钥得到认证，认证通过后的节点才能提供服务。企图冒充的节点由于没有事先得到的密钥信息，无法与集群内部的节点通信。这样就防止了恶意地使用或篡改Hadoop集群的问题，确保了Hadoop集群的可靠性、安全性。&lt;/p&gt;
&lt;h2 id=&quot;kerberos介绍&quot;&gt;2.Kerberos介绍&lt;/h2&gt;
&lt;p&gt;Kerberos是种网络身份验证协议,最初设计是用来保护雅典娜工程的网络服务器。Kerberos这个名字源于希腊神话，是一只三头犬的名字，它旨在通过使用密钥加密技术为Client/Server序提供强身份验证。可以用于防止窃听、防止重放攻击、保护数据完整性等场合，是一种应用对称密钥体制进行密钥管理的系统。Kerberos的扩展产品也使用公开密钥加密方法进行认证。&lt;/p&gt;
&lt;p&gt;Kerberos目前最新版本是5，1~3版本只在MIT内部发行，因为使用DES加密，早期被美国出口管制局列为军需品禁止出口，直到瑞典皇家工学院实现了Kerberos版本4，KTH-KRB。后续也是这个团队实现了版本5: Heimdal，目前常见的Kerberos5实现之一。&lt;br/&gt;本文中讨论的Kerberos5实现版本为MIT Kerberos，MIT保持的大约半年左右一次的更新速度，目前最新版本是2018-11-01发布的1.16.2版本。&lt;/p&gt;
&lt;h3 id=&quot;名词解释&quot;&gt;2.1 名词解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;AS（Authentication Server）：认证服务器&lt;/li&gt;
&lt;li&gt;KDC（Key Distribution Center）：密钥分发中心&lt;/li&gt;
&lt;li&gt;TGT（Ticket Granting Ticket）：票据授权票据，票据的票据&lt;/li&gt;
&lt;li&gt;TGS（Ticket Granting Server）：票据授权服务器&lt;/li&gt;
&lt;li&gt;SS（Service Server）：特定服务提供端&lt;/li&gt;
&lt;li&gt;Principal：被认证的个体&lt;/li&gt;
&lt;li&gt;Ticket：票据，客户端用来证明身份真实性。包含：用户名，IP，时间戳，有效期，会话秘钥。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用Kerberos时，一个客户端需要经过三个步骤来获取服务:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;认证&lt;/code&gt;: 客户端向认证服务器发送一条报文，获取一个包含时间戳的TGT。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;授权&lt;/code&gt;: 客户端使用TGT向TGS请求指定Service的Ticket。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;服务请求&lt;/code&gt;: 客户端向指定的Service出示服务Ticket鉴权通讯。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Kerberos协议在网络通信协定中属于显示层。其通信流程简单地说，用户先用共享密钥从某认证服务器得到一个身份证明。随后，用户使用这个身份证明与SS通信，而不使用共享密钥。&lt;/p&gt;
&lt;h3 id=&quot;具体通信流程&quot;&gt;2.2 具体通信流程&lt;/h3&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;①此流程使用了对称加密; ②此流程发生在某一个Kerberos领域中； ③小写字母c,d,e,g是客户端发出的消息，大写字母A,B,E,F,H是各个服务器发回的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，用户使用客户端上的程序进行登录：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入用户ID和密码到客户端（或使用keytab登录）。&lt;/li&gt;
&lt;li&gt;客户端程序运行一个单向函数（大多数为Hash）把密码转换成密钥，这个就是客户端的“用户密钥”(user's secret key)。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;客户端认证kinit&quot;&gt;2.2.1 客户端认证（Kinit）&lt;/h4&gt;
&lt;p&gt;客户端(Client)从认证服务器(AS)获取票据的票据（TGT）。&lt;br/&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/10/30/5XIYmr.png&quot; alt=&quot;客户端认证&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Client向AS发送1条明文消息，申请基于该用户所应享有的服务，例如“用户Sunny想请求服务”（Sunny是用户ID）。（注意：用户不向AS发送“用户密钥”(user's secret key)，也不发送密码）该AS能够从本地数据库中查询到该申请用户的密码，并通过相同途径转换成相同的“用户密钥”(user's secret key)。&lt;/li&gt;
&lt;li&gt;AS检查该用户ID是否在于本地数据库中，如果用户存在则返回2条消息：
&lt;ul&gt;&lt;li&gt;【消息A】：&lt;strong&gt;Client/TGS会话密钥(Client/TGS Session Key)&lt;/strong&gt;（该Session Key用在将来Client与TGS的通信（会话）上），通过 &lt;strong&gt;用户密钥(user's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;li&gt;【消息B】：&lt;strong&gt;票据授权票据(TGT)&lt;/strong&gt;（TGT包括：消息A中的“Client/TGS会话密钥”(Client/TGS Session Key)，用户ID，用户网址，TGT有效期），通过&lt;strong&gt;TGS密钥(TGS's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一旦Client收到消息A和消息B，Client首先尝试用自己的“用户密钥”(user's secret key)解密消息A，如果用户输入的密码与AS数据库中的密码不符，则不能成功解密消息A。输入正确的密码并通过随之生成的&quot;user's secret key&quot;才能解密消息A，从而得到“Client/TGS会话密钥”(Client/TGS Session Key)。（注意：Client不能解密消息B，因为B是用TGS密钥(TGS's secret key)加密的）。拥有了“Client/TGS会话密钥”(Client/TGS Session Key)，Client就足以通过TGS进行认证了。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;服务授权&quot;&gt;2.2.2 服务授权&lt;/h4&gt;
&lt;p&gt;Client从TGS获取票据(client-to-server ticket)。&lt;br/&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/10/30/5XIziR.png&quot; alt=&quot;服务授权&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当client需要申请特定服务时，其向TGS发送以下2条消息：
&lt;ul&gt;&lt;li&gt;【消息c】：即消息B的内容（TGS's secret key加密后的TGT），和想获取的服务的服务ID（注意：不是用户ID）&lt;/li&gt;
&lt;li&gt;【消息d】：&lt;strong&gt;认证符(Authenticator)&lt;/strong&gt;（Authenticator包括：用户ID，时间戳），通过&lt;strong&gt;Client/TGS会话密钥(Client/TGS Session Key)&lt;/strong&gt;进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;收到消息c和消息d后，TGS首先检查KDC数据库中是否存在所需的服务，查找到之后，TGS用自己的“TGS密钥”(TGS's secret key)解密消息c中的消息B（也就是TGT），从而得到之前生成的“Client/TGS会话密钥”(Client/TGS Session Key)。TGS再用这个Session Key解密消息d得到包含用户ID和时间戳的Authenticator，并对TGT和Authenticator进行验证，验证通过之后返回2条消息：
&lt;ul&gt;&lt;li&gt;【消息E】：&lt;strong&gt;client-server票据(client-to-server ticket)&lt;/strong&gt;（该ticket包括：Client/SS会话密钥 (Client/Server Session Key），用户ID，用户网址，有效期），通过提供该服务的&lt;strong&gt;服务器密钥(service's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;li&gt;【消息F】：&lt;strong&gt;Client/SS会话密钥( Client/Server Session Key)&lt;/strong&gt; （该Session Key用在将来Client与Server Service的通信（会话）上），通过&lt;strong&gt;Client/TGS会话密钥(Client/TGS Session Key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Client收到这些消息后，用“Client/TGS会话密钥”(Client/TGS Session Key)解密消息F，得到“Client/SS会话密钥”(Client/Server Session Key)。（注意：Client不能解密消息E，因为E是用“服务器密钥”(service's secret key)加密的）。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;服务请求&quot;&gt;2.2.3 服务请求&lt;/h4&gt;
&lt;p&gt;Client从SS获取服务。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当获得“Client/SS会话密钥”(Client/Server Session Key)之后，Client就能够使用服务器提供的服务了。Client向指定服务器SS发出2条消息：
&lt;ul&gt;&lt;li&gt;【消息e】：即上一步中的消息E“client-server票据”(client-to-server ticket)，通过&lt;strong&gt;服务器密钥(service's secret key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;li&gt;【消息g】：新的&lt;strong&gt;Authenticator&lt;/strong&gt;（包括：用户ID，时间戳），通过&lt;strong&gt;Client/SS会话密钥(Client/Server Session Key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SS用自己的密钥(service's secret key)解密消息e从而得到TGS提供的Client/SS会话密钥(Client/Server Session Key)。再用这个会话密钥解密消息g得到Authenticator，（同TGS一样）对Ticket和Authenticator进行验证，验证通过则返回1条消息（确认函：确证身份真实，乐于提供服务）
&lt;ul&gt;&lt;li&gt;【消息H】：&lt;strong&gt;新时间戳&lt;/strong&gt;（新时间戳是：Client发送的时间戳加1，v5已经取消这一做法），通过&lt;strong&gt;Client/SS会话密钥(Client/Server Session Key)&lt;/strong&gt; 进行加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Client通过Client/SS会话密钥(Client/Server Session Key)解密消息H，得到新时间戳并验证其是否正确。验证通过的话则客户端可以信赖服务器，并向服务器（SS）发送服务请求。&lt;/li&gt;
&lt;li&gt;服务器（SS）向客户端提供相应的服务。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;kerberos-ha架构&quot;&gt;3.Kerberos HA架构&lt;/h2&gt;
&lt;p&gt;Kerberos支持两种服务器在域内冗余方式：&lt;code&gt;Master/Slave&lt;/code&gt;（MIT和Heimdal）和&lt;code&gt;Multimaster&lt;/code&gt;结构（Windows Active Directory）。在生产环境中部署Kerberos时，最好使用一主(Master)多从(Slave)的架构，以确保Kerberos服务的高可用性。&lt;/p&gt;
&lt;p&gt;Kerberos中每个KDC都包含数据库的副本。主KDC包含域（Realm）数据库的&lt;strong&gt;可写副本&lt;/strong&gt;，它以固定的时间间隔复制到从KDC中。所有数据库更改（例如密码更改）都在主KDC上进行，当主KDC不可用时，从KDC提供Kerberos票据给服务授权，但不提供数据库管理。KDC需要一个Admin来进行日常的管理操作。&lt;br/&gt;Kerberos的同步机制只复制主数据库的内容，但不传递配置文件，以下文件必须手动复制到每个Slave中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- krb5.conf
- kdc.conf
- kadm5.acl
- master key stash file&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ha方案&quot;&gt;3.1 HA方案&lt;/h3&gt;
&lt;p&gt;目前单机房HA方案使用的较多的是Keepalived + Rsync 。Keepalived可以将多个无状态的单点通过虚拟IP(以下称为VIP)漂移的方式搭建成一个高可用服务。&lt;/p&gt;
&lt;p&gt;首先，在Master KDC中创建数据库的dump文件(将当前的Kerberos和KADM5数据库转储为ASCII文件)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kdb5_util dump [-b7|-ov|-r13] [-verbose] [-mkey_convert] [-new_mkey_file mkey_file] [-rev] [-recurse] [filename [principals...]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用Rsync将目录同步到Slave机器的对应目录中，&lt;br/&gt;再导入KDC中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kdb5_util load [-b7|-ov|-r13] [-hash] [-verbose] [-update] filename [dbname]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Hadoop所有请求通过请求内网域名，解析到Keepalived绑定的VIP的方式来使用KDC:&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4TRJI.png&quot; alt=&quot;Kerberos HA&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;优化和展望&quot;&gt;4. 优化和展望&lt;/h2&gt;
&lt;h3 id=&quot;优化&quot;&gt;4.1 优化&lt;/h3&gt;
&lt;h5 id=&quot;用户principal管理&quot;&gt;（1）用户（Principal）管理&lt;/h5&gt;
&lt;p&gt;如果团队中已经有一套权限系统，要将现有的身份系统集成到Kerberos中会很困难。&lt;br/&gt;随着业务的飞速增长，服务器规模越来越大，Kerberos Principal手动操作会越来越频繁，手动的增删改查维护会非常痛苦。需要在Kerberos管理系统中规范Principal申请、维护、删除、keytab生成流程。Principal申请和权限管理自动化。&lt;/p&gt;
&lt;h5 id=&quot;数据同步优化&quot;&gt;（2）数据同步优化&lt;/h5&gt;
&lt;p&gt;Kerberos数据同步可以将生成的数据记录同步写入到MySQL中，使用MySQL双主同步方式。在跨机房环境中，KDC数据使用Rsync工具进行增量同步。以A核心机房作为主机房，Rsync Server使用了Keepalived VIP的方式，当Kerberos主机宕机后，VIP漂移到另外一台主机器上，Rsync Client会以VIP所在的KDC主机器为Rsync Server进行数据同步，以保证KDC数据同步的高可用性。&lt;/p&gt;
&lt;h5 id=&quot;运维&quot;&gt;（3）运维&lt;/h5&gt;
&lt;p&gt;使用进程管理工具对Kerberos相关进程进行存活监控，当发现有进程异常退出时，邮件/微信/钉钉报警，主动再次拉起进程。&lt;/p&gt;
&lt;h3 id=&quot;展望&quot;&gt;4.2 展望&lt;/h3&gt;
&lt;p&gt;部署过Kerberos的同学都知道，在Hadoop集群部署Kerberos实际是一项非常繁琐的工作。Kerberos本质上是一种协议或安全通道，对于大多数用户或普通用户来说，是有一定学习曲线的，是否有更好的实现能够对普通用户隐藏这些繁琐的细节。&lt;/p&gt;
&lt;p&gt;阿里和Intel合作项目Hadoop Authentication Service (HAS) 据称目前已经应用到ApsaraDB for HBase2.0中:&lt;br/&gt;&lt;img src=&quot;https://s1.ax1x.com/2018/11/03/i4H9jf.png&quot; alt=&quot;HAS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HAS方案使用Kerby替代MIT Kerberos服务，利用HAS插件式验证方式建立一套人们习惯的账户密码体系。&lt;/p&gt;
&lt;p&gt;目前HAS在Apache Kerby项目&lt;code&gt;has-project&lt;/code&gt;分支开发中，未来会作为Kerbby的新feature出现在下一次release中。&lt;/p&gt;
&lt;p&gt;Apache Kerby作为Apache Directory的一个子项目，目前关注度并不高，让我们期待它在后续的发展吧。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 12:40:00 +0000</pubDate>
<dc:creator>mantou叔叔</dc:creator>
<og:description>1.背景 互联网从来就不是一个安全的地方。很多时候我们过分依赖防火墙来解决安全的问题，不幸的是，防火墙是假设“坏人”是来自外部的，而真正具有破坏性的攻击事件都是往往都是来自于内部的。 近几年，在the</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantoudev/p/9877433.html</dc:identifier>
</item>
<item>
<title>Vuex的基本概念、项目搭建、入坑点 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/9901906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/9901906.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181103200324893-621048402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前言：Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Vuex的四大核心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.state 驱动应用的数据源&lt;br/&gt;2.mutations 基因突变 类如C# 属性get set&lt;br/&gt;3.actions 行为&lt;br/&gt;4.getters 读取器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181103200355777-828823668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中绿色虚线包裹起来的部分就是Vuex的核心, &lt;code&gt;state&lt;/code&gt;中保存的就是公共状态, 改变&lt;code&gt;state&lt;/code&gt;的唯一方式就是通过&lt;code&gt;mutations&lt;/code&gt;进行更改. 可能你现在看这张图有点不明白, 等经过本文的解释和案例演示, 再回来看这张图, 相信你会有更好的理解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何引入Vuex？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.npm install vuex&lt;/p&gt;
&lt;p&gt;2.装好了之后，在全局上去使用你的Vuex&lt;/p&gt;
&lt;p&gt;3.创建Store对象，最好在src创建一个store这样的文件夹然后创建index.js&lt;/p&gt;
&lt;p&gt;4.在main.js中注册使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import Vuex from 'vuex'

Vue.use( Vuex );

const store = new Vuex.Store({
    //待添加
})

new Vue({
    el: '#app',
    store,
    render: h =&amp;gt; h(App)
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 为了讲解Vuex，我们做了一个项目，这个项目需要连接apicloud，异步操作使用了axios以及样式bootstrap，其中包括了登录注册以及其中的父组件向子节点传值等，我们给项目安装相关的modules&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install bootstrap
npm install axios&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181103200940259-1111092346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;router.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'index',
     component:()=&amp;gt;import('../views/index.vue')
    },
    {
      path:'/detail/:id',
      name:'detail',
      component:()=&amp;gt;import ('../views/detail.vue')
    },
    {
      path:'/login',
      name:'login',
      component:()=&amp;gt;import ('../views/login.vue')
    },
    {
      path:'/register',
      name:'register',
      component:()=&amp;gt;import ('../views/register.vue')
    }
  ]
})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;store.js&lt;/p&gt;

&lt;p&gt; 我们来上述代码中来讲解其中vuex的奥秘，State就是所有组件提出来的data，用于所有组件公共数据，而其中mutations就像C#中get\set，属性赋值器，其中方法的两个参数除了state只能带一个参数。&lt;/p&gt;
&lt;p&gt;actions是操作数据的方法，说过说你的actions中需要改变state中的数据，那么必须要通过commit关键字去提交给mutations，还有一点就是actions中很多操作都是关于异步处理的，最关键就是它是操作state数据的，那getters是什么呢？它是组件访问vuex的入口，里面写好了方法去操作，它也是过滤器，就像程序中的三层架构BLL.&lt;/p&gt;
&lt;p&gt; main.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// The Vue build version to load with the `import` command
// (runtime-only or standalone) has been set in webpack.base.conf with an alias.
import Vue from 'vue'
import App from './App'
import router from './router'
import boostrap from 'bootstrap/dist/css/bootstrap.css'
import store from './store/index.js'

Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  store,//在全局对象上加载仓库
  components: { App },
  template: '&amp;lt;App/&amp;gt;'
})　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import Vue from 'vue'
import Vuex from 'vuex'
import API from '../utils/api.js'

var api = new API('goods')
var userApi = new API('userinfo');

Vue.use(Vuex);

const state = {
    user: null,
    products: []
}
const mutations = {
    //加载产品数据
    INIT_PRODUCTS(state, data) {
        state.products = data;
    },
    SET_LOGIN_USER(state, u) {
        state.user = u;
    }
}
const actions = {
    LOAD_PRODUCTS({ commit }) {
        api.Select().then(res =&amp;gt; {
            commit('INIT_PRODUCTS', res.data);
        })
    },
    LOGIN({ commit }, user) {
        return userApi.Select().then(res =&amp;gt; {
            let users = res.data;//所有的用户
            for (let u of users) {
                if (u.name == user.name &amp;amp;&amp;amp; u.password == user.password) {
                    commit('SET_LOGIN_USER', u);
                    return u;
                }
            }
        })
    },
    REGISTER({ commit }, user) {
        return userApi.Insert(user).then(res =&amp;gt; {
            console.log(res.data);
            return 'OK';
        }).catch(err =&amp;gt; {
            return err;
        })
    }

}
const getters = {
    ALL_PRODUCTS(state) {
        return state.products;
    },
    GET_PRODUCT_BYID: (state) =&amp;gt; function (id) {
        //遍历 is == id
        for (let p of state.products) {
            if (p.id == id) {
                return p;
            }
        }
        return null;
    }
}

//仓库
const store = new Vuex.Store({
    state: state,
    mutations: mutations,
    actions: actions,
    getters: getters
})
export default store;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;navbar.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
     &amp;lt;nav class=&quot;navbar navbar-expand-lg  navbar-dark bg-dark&quot;&amp;gt;
        &amp;lt;div class=&quot;container&quot;&amp;gt;
            &amp;lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&amp;gt;购物车&amp;lt;/a&amp;gt;
            &amp;lt;ul class=&quot;navbar-nav ml-auto&quot;&amp;gt;
                &amp;lt;li class=&quot;nav-item active dropdown&quot; v-if=&quot;user!==null&quot;&amp;gt;
                    &amp;lt;a class=&quot;nav-link dropdown-toggle&quot;  data-toggle=&quot;dropdown&quot; @click=&quot;showDropdown=!showDropdown&quot;&amp;gt;欢迎你:{{user.name}} &amp;lt;/a&amp;gt;
                    &amp;lt;div class=&quot;dropdown-menu show&quot;&amp;gt;
                        &amp;lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&amp;gt;我的订单&amp;lt;/a&amp;gt;
                        &amp;lt;div class=&quot;dropdown-divider&quot;&amp;gt;&amp;lt;/div&amp;gt;
                        &amp;lt;a class=&quot;dropdown-item&quot; &amp;gt;注销&amp;lt;/a&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li class=&quot;nav-item active&quot; style=&quot;margin-right:5px&quot; v-if=&quot;user===null&quot;&amp;gt;
                    &amp;lt;router-link  class=&quot;nav-link btn btn-warning btn-sm&quot; style=&quot;color:#fff&quot; to=&quot;/login&quot;&amp;gt;登录&amp;lt;/router-link&amp;gt;
                &amp;lt;/li&amp;gt;
                &amp;lt;li class=&quot;nav-item active&quot; v-if=&quot;user===null&quot;&amp;gt;
                    &amp;lt;router-link  class=&quot;nav-link btn btn-danger btn-sm&quot; style=&quot;color:#fff&quot; to=&quot;/register&quot;&amp;gt;注册&amp;lt;/router-link&amp;gt;
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/nav&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    data(){
        return{
            showDropdown:false
        }
    },
    computed:{
        user(){
            return this.$store.state.user;
        }
        
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;product.vue 该组件用于显示商品的详细信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;card&quot;&amp;gt;
        &amp;lt;img class=&quot;card-img-top&quot; src=&quot;../../assets/logo.png&quot; alt=&quot;Card image cap&quot;&amp;gt;
        &amp;lt;div class=&quot;card-body&quot;&amp;gt;
            &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;{{product.name}}&amp;lt;/h5&amp;gt;
            &amp;lt;p class=&quot;card-text&quot;&amp;gt;{{product.description===null?&quot;暂无描述&quot;:product.description}}&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;价格: {{product.price}}&amp;lt;/p&amp;gt;
            &amp;lt;a href=&quot;#&quot; class=&quot;btn btn-warning float-left&quot; @click=&quot;goDetail&quot;&amp;gt;查看详情&amp;lt;/a&amp;gt;
            &amp;lt;a href=&quot;#&quot; class=&quot;btn btn-primary float-right&quot;&amp;gt;加入购物车&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    props:['product'],
    methods:{
        goDetail(){
            console.log(this.product.id);
            this.$router.push(`/detail/${this.product.id}`);
        }
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序入口APP.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;nav-bar&amp;gt;&amp;lt;/nav-bar&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import NavBar from './views/components/navbar'
export default {
    name: 'App',
    components:{NavBar}
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册：通过&lt;span&gt;this.$store.dispatch去调用actions中的方法，其中有趣的是commit的参数竟然被方法名给..这个以后在思考。。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div class=&quot;card&quot; style=&quot;margin:50px auto;width:400px&quot;&amp;gt;
                &amp;lt;div class=&quot;card-body&quot;&amp;gt;
                    &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;注册&amp;lt;/h5&amp;gt;
                    &amp;lt;hr&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.name&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;真实姓名&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.realname&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; v-model=&quot;user.password&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;button class=&quot;btn btn-primary btn-block&quot; @click=&quot;register&quot;&amp;gt;注册&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
    data(){
        return{
            user:{
                name:'',
                realname:'',
                password:''
            }
        }
    },methods:{
        register(){
            this.$store.dispatch('REGISTER',this.user).then(res=&amp;gt;{
                if(res==&quot;OK&quot;)
                    this.$router.push('/index');
            })
        }
    }
}
&amp;lt;/script&amp;gt;　
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;　登录&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div class=&quot;card&quot; style=&quot;margin:50px auto;width:400px&quot;&amp;gt;
                &amp;lt;div class=&quot;card-body&quot;&amp;gt;
                    &amp;lt;h5 class=&quot;card-title&quot;&amp;gt;登录&amp;lt;/h5&amp;gt;
                    &amp;lt;hr&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;用户名&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user.name&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;label for=&quot;&quot;&amp;gt;密码&amp;lt;/label&amp;gt;
                        &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; v-model=&quot;user.password&quot;&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
                        &amp;lt;button class=&quot;btn btn-primary btn-block&quot; @click=&quot;login&quot;&amp;gt;登录&amp;lt;/button&amp;gt;
                    &amp;lt;/div&amp;gt; 
                &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
    data(){
        return {
            user:{
                name:'',
                password:''
            }
        }
    },
    methods:{
        login(){
            this.$store.dispatch('LOGIN',this.user).then(res=&amp;gt;{
                console.log(res);
                if (res){
                    this.$router.push('/')
                }
            })
        }
    }
}
&amp;lt;/script&amp;gt;
　主页面

&amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;container&quot;&amp;gt;
        &amp;lt;h1&amp;gt;商品列表&amp;lt;/h1&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
              &amp;lt;div class=&quot;col-md-4&quot; v-for=&quot;p in products&quot; :key=&quot;p.id&quot;&amp;gt;
                &amp;lt;!-- 传递商品信息到子组件 --&amp;gt;
                &amp;lt;product-card  :product=&quot;p&quot;&amp;gt;&amp;lt;/product-card&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import ProductCard from './components/product.vue'
export default {
    components:{ProductCard},
    computed:{
        products(){
           return this.$store.getters.ALL_PRODUCTS;
        }
    },
    created(){
        this.$store.dispatch('LOAD_PRODUCTS');
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文结语知识总结：&lt;/p&gt;
&lt;p&gt;获取url中的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
let id = this.$route.params.id;
this.details = this.$store.getters.GET_PRODUCT_BYID(id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有的小伙伴在复制我的代码运行报错，说什么未初始化；一定要在index.vue添加这个代码，LOAD_PRODUCTS给数据初始化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
    created(){
        this.$store.dispatch('LOAD_PRODUCTS');
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跳转路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
this.$router.push('/')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ApiClound万能帮助类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
import crypto from 'crypto'     // 加密
import axios from 'axios'
class API {
    constructor(classname){
        this.api = `https://d.apicloud.com/mcm/api/${classname}`;
        let ID = '';
        let KEY = '';
        let now = Date.now(); //当前时间
        let sha1 = crypto.createHash('sha1');
        sha1.update(ID + &quot;UZ&quot; + KEY + &quot;UZ&quot; + now);  
        axios.defaults.headers[&quot;X-APICloud-AppId&quot;] = ID;
        axios.defaults.headers[&quot;X-APICloud-AppKey&quot;] = sha1.digest('hex') + &quot;.&quot; + now;
    }
    
    Select(){
        return axios.get(this.api);
    }
    Insert(obj){
        return axios.post(this.api,obj);
    }
    Update(id,obj){
        // RESTFUL API 
        return axios.put(this.api+`/${id}`,obj);
    }
    Delete(id){
        return axios.delete(this.api + `/${id}`);
    }
}

export default API;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　还有同学问我父组件和子组件如何传值？&lt;/p&gt;
&lt;p&gt;在父页面引用的地方以&quot;:&quot;表示的值都可以在子页面的props获取到&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;h3&amp;gt;图书管理&amp;lt;/h3&amp;gt;&amp;lt;hr&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
        &amp;lt;div class=&quot;col-md-4 col-sm-4&quot; v-for=&quot;b in books&quot; :key=&quot;b.id&quot;&amp;gt;
            &amp;lt;book-detail @abc=&quot;xyz&quot; :Book=&quot;b&quot; :MSG=&quot;abc&quot;&amp;gt;&amp;lt;/book-detail&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
    import BookDetail from './components/BookDetails.vue'
    export default{
        components:{BookDetail},
        data(){
            return {
                abc:'heheda',
                books:[{
                    id:1,
                    name:'7天 JAVA 从入门到放弃',
                    text:'到底是人性的扭曲，还是道德的沦丧. 青年男子为何突然脱发，中年男人为何删库跑路。',
                    price:20,
                    img:'img2.jpg',
                    showHehe:true
                },{
                    id:2,
                    name:'7天 C# 从入门到自杀',
                    text:'到底是人性的扭曲啊，还是道德的沦丧啊. 祖国的花朵为何自杀。',
                    price:20,
                    img:'../../static/img2.jpg',
                    showHehe:false
                }]
            }
        },
        methods:{
            xyz(bid){
                alert(bid);
            }
        }
    }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在子页面中可以这么搞&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;script&amp;gt;
export default{
    props:[&quot;Book&quot;,&quot;MSG&quot;],
    created(){
        console.log(this.Book.name);
    },
    methods:{
        select(id){
            this.$emit('abc',id);
        },
        detail(bid){
            this.$router.push(`/admin/Details/${bid}`);
        }
    }
}
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　而其中的$emit是可以调用父页面的方法的。&lt;/p&gt;
&lt;p&gt;谢谢大家收看！！！&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 12:07:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>前言：Vuex是一个专门为Vue.js应用程序开发的状态管理模式, 它采用集中式存储管理所有组件的公共状态, 并以相应的规则保证状态以一种可预测的方式发生变化. Vuex的四大核心 1.state 驱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/9901906.html</dc:identifier>
</item>
<item>
<title>分类-MNIST - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/9901539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/9901539.html</guid>
<description>&lt;blockquote readability=&quot;6.9878345498783&quot;&gt;
&lt;p&gt;这是学习《Hands-On Machine Learning with Scikit-Learn and TensorFlow》的笔记，如果此笔记对该书有侵权内容，请联系我，将其删除。&lt;br/&gt;博客出自：&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/9901539.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/endlesscoding/p/9901539.html&lt;/a&gt;，未经博主同意，请忽转载。&lt;br/&gt;这里面的内容目前条理还不是特别清析，后面有时间会更新整理一下。&lt;br/&gt;下面的代码运行环境为jupyter + python3.6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# from sklearn.datasets import fetch_mldata
# from sklearn import datasets

# mnist = fetch_mldata('MNIST   original') 
# mnist&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好像下载不到它的数据，直接从网上找到它的数据，放到当面目录下的&lt;code&gt;dataset&lt;/code&gt;目录下。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.datasets import fetch_mldata
from sklearn import datasets
import numpy as np

mnist = fetch_mldata('mnist-original', data_home = './datasets/') 
mnist
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;{'DESCR': 'mldata.org dataset: mnist-original',
 'COL_NAMES': ['label', 'data'],
 'target': array([0., 0., 0., ..., 9., 9., 9.]),
 'data': array([[0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0],
        ...,
        [0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0],
        [0, 0, 0, ..., 0, 0, 0]], dtype=uint8)}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;p&gt;网上很多的说法是错误的，只有我这个才是正解。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X, y = mnist['data'], mnist['target']
print(X.shape)
print(y.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(70000, 784)
(70000,)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面看出来，X是一个&lt;span class=&quot;math inline&quot;&gt;\(7000\times784\)&lt;/span&gt;的一个矩阵，一般来说，7000行表示有7000个样本，784列，表示样本有784这么多个属性。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;%matplotlib inline
import matplotlib
import matplotlib.pyplot as plt

some_digit = X[36000]
some_digit_image = some_digit.reshape(28,28)

plt.imshow(some_digit_image, cmap=matplotlib.cm.binary, interpolation=&quot;nearest&quot;)
plt.axis('off')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd8658472a2.png&quot; alt=&quot;output_6_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说个数看起来像是5，我觉得更像是6，我们可查看一下它的标签。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y[36000]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;5.0&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# EXTRA
def plot_digits(instances, images_per_row=10, **options):
    size = 28
    images_per_row = min(len(instances), images_per_row)
    images = [instance.reshape(size,size) for instance in instances]
    n_rows = (len(instances) - 1) // images_per_row + 1
    row_images = []
    n_empty = n_rows * images_per_row - len(instances)
    images.append(np.zeros((size, size * n_empty)))
    for row in range(n_rows):
        rimages = images[row * images_per_row : (row + 1) * images_per_row]
        row_images.append(np.concatenate(rimages, axis=1))
    image = np.concatenate(row_images, axis=0)
    plt.imshow(image, cmap = matplotlib.cm.binary, **options)
    plt.axis(&quot;off&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.figure(figsize=(9,9))
example_images = np.r_[X[:12000:600], X[13000:30600:600], X[30600:60000:590]]
plot_digits(example_images, images_per_row=10)
# save_fig(&quot;more_digits_plot&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e72c0a4.png&quot; alt=&quot;output_10_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可能这个标签写错了都不一定，我们得新写一下这个标签，说不定可以提高模型的准确率呢。这只是我个人在这里开玩笑说的，不用当真哈。&lt;/p&gt;
&lt;p&gt;在做数据的训练前，应该找出测试集，这里MNIST已经帮我们把测试集做好了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train, X_test, y_train, y_test = X[:60000],X[60000:],y[:60000],y[60000:]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MNIST的数据是按数字大小顺序排列的，所我们先要打乱它的顺序，这样可以保证我们的交叉验证是每一次都是相似的。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np

shuffle_index = np.random.permutation(60000)
shuffle_index&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([52603, 56601, 42625, ..., 17778, 24267, 29358])&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;np.random.permutation 是随机排列一个序列。上面的例子就是从0~60000的随机序列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;X_train, y_train = X_train[shuffle_index],y_train[shuffle_index]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;先不做一个多类器，我们先不去识别里面的手写数字是0~10中的某一个数。目前做一个最简单的，判断它是否是5，即将数据分成两个类别：“5”和“非5”&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 这是一个逻辑数组，5：True, 非5：False
y_train_5 = (y_train == 5)
y_test_5 = (y_test == 5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在开始用一个分类器去训练它。用随机梯度下降分类器SGD。用Scikit-Learn的SGDClassifier类。这个分类器有一个好处是能够高效地处理非常大的数据集。部分原因是它每次只处理一条数据。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.linear_model import SGDClassifier

sgd_clf = SGDClassifier(random_state = 32)
sgd_clf.fit(X_train, y_train_5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SGDClassifier(alpha=0.0001, average=False, class_weight=None,
       early_stopping=False, epsilon=0.1, eta0=0.0, fit_intercept=True,
       l1_ratio=0.15, learning_rate='optimal', loss='hinge', max_iter=None,
       n_iter=None, n_iter_no_change=5, n_jobs=None, penalty='l2',
       power_t=0.5, random_state=32, shuffle=True, tol=None,
       validation_fraction=0.1, verbose=0, warm_start=False)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([ True])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个模型的准确度好像受随机种子的影响比较大，如果我将模型的随机种改为42，我们再来看一下它预测的结果是不是正确的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf = SGDClassifier(random_state = 42)
sgd_clf.fit(X_train, y_train_5)
sgd_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([ True])&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可以到这个时候它又预测错了。下面来整体评估一下这个分类的性能。&lt;/p&gt;
&lt;h2 id=&quot;使用交叉验证测量准确性&quot;&gt;使用交叉验证测量准确性&lt;/h2&gt;
&lt;p&gt;在交叉验证过程中，有时候我们会需要更多的控制权，相较于函数cross_val_score()或者其他相似函数所提供的功能。下面代码做了和cross_val_score()相同的事情&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import StratifiedKFold
from sklearn.base import clone

skfolds = StratifiedKFold(n_splits = 3, random_state = 42)
clone_clf = clone(sgd_clf)
for train_index, test_index in skfolds.split(X_train, y_train_5):
    X_train_folds = X_train[train_index]
    y_train_folds = (y_train_5[train_index])
    X_test_fold = X_train[test_index]
    y_test_fold = (y_train_5[test_index])
    clone_clf.fit(X_train_folds, y_train_folds)
    y_pred = clone_clf.predict(X_test_fold)
    n_correct = sum(y_pred == y_test_fold)
    print(n_correct / len(y_pred))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.9612

0.9531

0.9688&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;StratfiedKFold 类实现了分层采样，生成的折包含了各类相应比例的样例。在每一次迭代，上述代码生成分类器的一个克隆，在克隆的模型上训练，在测试折上进行预测&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面直接使用sklearn中的库进行交叉评估。使用&lt;code&gt;cross_val_score&lt;/code&gt;函数来评估SGDClassifier模型。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import cross_val_score

cross_val_score(sgd_clf, X_train, y_train_5, cv = 3, scoring = &quot;accuracy&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.9612, 0.9531, 0.9688])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这精度看起来还不错，有大于95%的精度，有点让人兴奋，感觉做个分类还是挺容易的，不难。&lt;br/&gt;我们再来看下一个非常简单的分类器去分类，看看它在“非5”这个类上的表现。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.base import BaseEstimator
# 这个模型的预测的策略就是将所有的数据都认为是'非5'
class Never5Classifier(BaseEstimator):
    def fit(self,X,y=None):
        pass
    def predict(self,X):
        return np.zeros((len(X),1), dtype=bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;np.zeros((2,1), dtype=bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[False],
       [False]])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;never_5_clf = Never5Classifier()
cross_val_score(never_5_clf, X_train, y_train_5, cv = 3, scoring = &quot;accuracy&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.90815, 0.9124 , 0.9084 ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么一个简单的分类器也有90%的精度，这是因为只有10%的样本是5，其它都是非5，所以只我们一直猜这个图像不是5，当然有90%的精度，这叫数据不平衡。就像我们如果在日本，站到大街上，见到人就猜他是一个日本人，我们几乎肯定是正确的。&lt;/p&gt;
&lt;p&gt;所以精度并不是一个好的性能度量指标，特别是在我们数据不平衡的时候。&lt;/p&gt;
&lt;h2 id=&quot;混淆矩阵&quot;&gt;混淆矩阵&lt;/h2&gt;
&lt;p&gt;对一般分类器来说，一人好得多的性能评估指标是混淆矩阵。大体思路是：输出类别A被分成类别B的次数。&lt;/p&gt;
&lt;p&gt;为了计算混淆矩阵，首先你需要有一系列的预测值，这样才能将预测值与真实值做比较。你或许想在测试集上做预测。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.model_selection import cross_val_predict

y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv = 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import confusion_matrix

confusion_matrix(y_train_5, y_train_pred)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[54306,   273],
       [ 2065,  3356]], dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;混淆矩阵中的每一行表示一个实际的类，而每一列表一个预测的类。该矩阵的第一行认为&quot;非5&quot;中的53993张被正确地归类为非5（这被称为真反例，true negatives）,而其余586被错误归类为5（这被称为假正例，false positive），其余3905正确分类为&quot;5&quot;类（真正例，true positive）。一个完美的分类器将只有真反例和真正例，所混淆矩阵的非零值仅在其主对角线（左上至右下）。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# confusion_matrix(y_train_5, y_train_perfect_predictions)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;混淆矩阵可以提供很多信息。有时候你会想要更加简明的指标。一个有趣的指标是正例预测的精度，也叫做分类器的准确率(precision)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ precision = \frac{TP}{TP + FP} \tag{3-1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(TP\)&lt;/span&gt;是&lt;code&gt;真正例&lt;/code&gt;的数目，&lt;span class=&quot;math inline&quot;&gt;\(FP\)&lt;/span&gt;是&lt;code&gt;假正例&lt;/code&gt;的数目。&lt;/p&gt;
&lt;p&gt;以准确率一般会伴随另一个指标一起使用，这个指标叫做召回率（recall），也叫做敏感度（sensitivity）或者真正例率（true positive rate, TPR）。这是正例被分类器正确探测出的比率。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ recall = \frac{TP}{TP+FN} \tag{3-2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(FN\)&lt;/span&gt;是假反例的数目。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import precision_score, recall_score

print(precision_score(y_train_5, y_train_pred))
print(recall_score(y_train_5, y_train_pred))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.924772664645908
0.6190739715919572&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样看起，这个分类器的准确率并不高，只有56.8%左右，而且只是分成两类的一个分类器，这跟我们猜差不多。&lt;/p&gt;
&lt;p&gt;通常结合准确率和召回率会更加方便，这个指标叫做&lt;code&gt;F1&lt;/code&gt;值，特别是当你需要一个简单的方法去比较两个分类器的优劣的时时候。F1值是准确率和召回率的&lt;code&gt;调和平均&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F1 = \frac{2}{\frac{1}{precision}+\frac{1}{recall}} = 2 \times \frac{precision \times recall}{precision + recall} = \frac{TP}{TP + \frac{FN+FP}{2}} \tag{3-3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;计算F1值，简单调用&lt;code&gt;f1_score()&lt;/code&gt;即可。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import f1_score

f1_score(y_train_5, y_train_pred)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.7416574585635358&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F1支持那些有着相近准确率和召回率的分类（意思是只有当准确率和召回率一样大的时个，F1值才会大）。但并不是所的时候，我们都关心F1值，有时候我们只关心准确率（precision），或者有时候我们只关心召回率（recall）。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;这里，我们再次理解一下准确率的含义：如果一个分类器的每次几乎都能把我们所要分的类别准确地分类出来，那么无疑，这个分类器的准确率是高的；什么时候准备率低呢，就是它把我们所要分的类，预测错了。比如我们这里的例子，我们要预测这张手写图片的数字是否是5，如果那张图真的是5，而我们的分类器预测它是5，那么它预测对了，当然预测对了，不是我们区分准确率与召回率的情况。如果将一张不是5的图片预测成5，那么我们会说它个分类器不是很准，它有低准确率。&lt;/p&gt;
&lt;p&gt;什么是召回率？当我们将一张是5的图片预测成不是5，说明这个分类器还是比较严格的，那和它有较低的如回率。&lt;/p&gt;
&lt;p&gt;总的来说，准确率低的原因就产将那些看起来像5（只是像，实际并不是5）的预测成了5；而召回率低的原因是把那些看起来不像5（实际上是5，只是可能那个5写得比较丑）预测成不是5。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里，我以自己的理解，举两个例子，比如公司想找个人当总经理，有一群人来应聘它。我们这时候的目标是，找到的这个人肯定是能够当总经理的，就算有的人看起来像是能当总经理，但是为了确保万无一失，我们要找一个看起来非常非常像能够当总经理的人。这个时候我们当然有着很高的准确率，因为我们找的人几乎肯定是能够当总经理的，但是此时，我们会犯另一个错误，就是有些人确实有能力当总经理，只是我们没有看出来（人不可貌像），所以我们拒绝他，因此我们有低的召回率，这在统计学上被称为犯了&lt;code&gt;第一类错误&lt;/code&gt;，即&lt;code&gt;弃真&lt;/code&gt;。这样做是合理的，因为即使&lt;code&gt;弃真&lt;/code&gt;，但我们&lt;code&gt;保真&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;另一种情况是，比如警察在一群人中想找出几个犯罪的人，这个时候我们就不能要超高的准确率了，因为有可能把真正的犯人放走。找犯人的原则一般是，只要他看起来像个犯人，都应该审查一下，即使最后真像大白后，他真的不是一个犯人。我们平时听到的&lt;code&gt;宁可错杀一千，不可放走一个&lt;/code&gt;说的就是这个道理，因此这有着比较低的准确率，但是有高的召回率，这在统计学上被称为犯了&lt;code&gt;第二类错误&lt;/code&gt;，即&lt;code&gt;取伪&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;准备率召回率之间的折中&quot;&gt;准备率/召回率之间的折中&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_scores = sgd_clf.decision_function([some_digit])
y_scores&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([15905.22111141])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;threshold = 0
y_some_digit_pred = (y_scores &amp;gt; threshold)
y_some_digit_pred&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([ True])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_scores = cross_val_predict(sgd_clf, X_train,y_train_5,cv=3,
                             method = &quot;decision_function&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import precision_recall_curve
precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):
    plt.plot(thresholds, precisions[:-1], &quot;b--&quot;, label = &quot;Precision&quot;)
    plt.plot(thresholds, recalls[:-1], &quot;g-&quot;, label = &quot;Recall&quot;)
    plt.xlabel(&quot;Threshold&quot;)
    plt.legend(loc=&quot;upper left&quot;)
    plt.ylim([0,1.1])
    
plot_precision_recall_vs_threshold(precisions,recalls,thresholds)
plt.grid()
plt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e785655.png&quot; alt=&quot;output_51_1.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;roc曲线&quot;&gt;ROC曲线&lt;/h3&gt;
&lt;p&gt;受试者工作特征(ROC)曲线是另一个二分类器常用的工具。它非常类似与准确率/召回率曲线，但不是画出准确率对召回率的曲线，，ROC曲线是真正例率（true positive rate，另一个名字叫做召回率）对假正例率（false positive rate, FPR）的曲线。FPR是反例被错误分成正例的比率。它等于1减去真反例率（true negative rate，TNR）。TNR是反例被正确分类的比率。TNR也叫做特异性。&lt;/p&gt;
&lt;p&gt;为了画出ROC曲线，你首先需要计算各种不同阈值下的TPR、FPR，使用roc_curve()函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import roc_curve
fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)

def plot_roc_curve(fpr, tpr, label = None):
    plt.plot(fpr,tpr, linewidth = 2, label = label)
    plt.plot([0,1],[0,1],'k--')
    plt.axis([0,1,0,1])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

plot_roc_curve(fpr,tpr)
plt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e7dbb35.png&quot; alt=&quot;output_53_1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个比较分类器之间优劣的方法是：测量ROC曲线下的面积（AUC）。一个完美的分类器的 ROC AUC 等于1，而一个纯随机分类器的ROC AUC等于0.5。Scikit-Learn提供了一个函数来计算ROC AUC：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.metrics import roc_auc_score
roc_auc_score(y_train_5,y_scores)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.9623990527630832&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.ensemble import RandomForestClassifier

forest_clf = RandomForestClassifier(random_state = 42)
y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3, method = &quot;predict_proba&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_scores_forest = y_probas_forest[:,1]
fpr_forest, tpr_forest, thresholds_forest=roc_curve(y_train_5,y_scores_forest)
plt.plot(fpr,tpr,&quot;b:&quot;,label=&quot;SGD&quot;) 
plot_roc_curve(fpr_forest,tpr_forest,&quot;Random Forest&quot;) 
plt.legend(loc=&quot;bottom  right&quot;) 
plt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd86e83e34e.png&quot; alt=&quot;output_57_2.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 将概率大于0.5的，置为true, 否则为false
print(precision_score(y_train_5, y_scores_forest &amp;gt; 0.5))
print(recall_score(y_train_5, y_scores_forest &amp;gt; 0.5))
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0.9844298245614035
0.8280760007378712&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，它的准确率还可，挺高的。&lt;/p&gt;
&lt;p&gt;下面我们将分类出更多的数字，而不仅仅是5。&lt;/p&gt;

&lt;p&gt;二分类器只能分出两个类，而多分类器能分出多于两个类别的类。&lt;/p&gt;
&lt;p&gt;一些算法（比如随机森林分类器或者朴素贝叶斯分类器）可以直接处理多类分类问题。其他一些算法（比如SVM分类器或者线性分类器）则是严格的二分类器，然后有许多策略可以让你用二分类器去执行多类分类。&lt;/p&gt;
&lt;p&gt;Scikit-Learn可以探测出你想使用一个二分类器去完成多分类的任务，它会自动地执行OvA（除了SVM分类器，它使用OvO）。让我们试一下&lt;code&gt;SGDClassifier&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf.fit(X_train, y_train)
sgd_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以调用decision_function()方法。不是返回每个样例的一个数值，而是返回10个数值，一个数值对应于一个类。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;some_digit_scores = sgd_clf.decision_function([some_digit])
some_digit_scores&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[-253639.46707377, -425198.63904333, -354213.80127786,
        -229676.13263264, -376404.48500382,   15905.22111141,
        -564592.12430579, -194289.65607053, -748913.30208666,
        -597652.52038338]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最高的数值对应类别5&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;np.argmax(some_digit_scores)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;5&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sgd_clf.classes_&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你想强制Scikit-Learn使用OvO策略或者OvA策略，你可以使用OneVsOneClassifier类或者OneVsRestClassifier类。创建一个样例，传递一个二分类器给它的构造函数。举例子，下面的代码会创建一个多类分类器，使用OvO策略，基于&lt;code&gt;SGDClassifier&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.multiclass import OneVsOneClassifier

ovo_clf = OneVsOneClassifier(SGDClassifier(random_state=42))
ovo_clf.fit(X_train, y_train)
ovo_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练一个RandomForestClassifier同样简单：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;forest_clf.fit(X_train,y_train)
forest_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5.])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次Scikit-Learn没有必要去运行OvO或者OvA, 因为随机森林分类器能够直接将一个样例分到多个类别。你可调用&lt;code&gt;predict_proba()&lt;/code&gt;，得到样例对应的类别的概率值的列表：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;forest_clf.predict_proba([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[0. , 0. , 0. , 0. , 0. , 0.9, 0. , 0. , 0.1, 0. ]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们当然想评估一下这些分类器。像以前一样，想便用交叉验证。让我们用&lt;code&gt;cross_val_score&lt;/code&gt;来评估&lt;code&gt;SGDClassifier&lt;/code&gt;的精度。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;cross_val_score(sgd_clf, X_train, y_train,cv = 3, scoring = &quot;accuracy&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.86002799, 0.8760438 , 0.88093214])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到这个分类器有86.3%的精度，这个精度还不错，比我们随便乱猜的精度要高出不少（如果我们随机猜，那么精度只有10%）。看起来也并不差，这里可以使输入正则化，得到更高的精度，可以将其精度提高到90%以上。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))
cross_val_score(sgd_clf, X_train_scaled, y_train, cv = 3, scoring=&quot;accuracy&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.9080184 , 0.91049552, 0.91043657])&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;分析模型产生的误差，首先，我们可以检查混淆矩阵。需要使用&lt;code&gt;cross_val_predict()&lt;/code&gt;做出预测，然后调用confusion_matrix()函数，像以前做的那样&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv = 3)
conf_mx = confusion_matrix(y_train, y_train_pred)
conf_mx&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[5739,    3,   22,    8,    9,   50,   43,    7,   38,    4],
       [   2, 6451,   50,   23,    6,   46,    5,   14,  133,   12],
       [  58,   38, 5348,   87,   76,   26,   83,   56,  169,   17],
       [  50,   40,  134, 5300,    2,  267,   37,   64,  140,   97],
       [  25,   26,   36,    7, 5356,    9,   54,   32,   83,  214],
       [  68,   37,   34,  179,   74, 4617,  106,   30,  171,  105],
       [  35,   21,   42,    2,   39,   98, 5630,    6,   44,    1],
       [  27,   18,   66,   27,   52,   10,    7, 5793,   17,  248],
       [  58,  150,   68,  140,   16,  156,   51,   29, 5050,  133],
       [  43,   29,   24,   84,  158,   36,    3,  194,   83, 5295]],
      dtype=int64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是一堆数字，使用Matplotlib的&lt;code&gt;matshow()&lt;/code&gt;函数，将混淆矩阵以图像的方式呈现，将会更加方便。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.matshow(conf_mx, cmap = plt.cm.gray)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878de76ae.png&quot; alt=&quot;output_80_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，几乎所有的图片都在对角线上，这意味着分类几乎全部正确。现我们只看看其误差的图像&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;row_sums = conf_mx.sum(axis=1, keepdims=True)
norm_conf_mx = conf_mx / row_sums

np.fill_diagonal(norm_conf_mx, 0)
plt.matshow(norm_conf_mx, cmap = plt.cm.gray)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878de8eb8.png&quot; alt=&quot;output_82_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在可以清楚看出分类器的各类误差，其中行代表实际类别，列代表预测的类别。第8、9列很亮，这说明很多图片被误分成数字8或者数字9。&lt;/p&gt;
&lt;p&gt;分析混淆矩阵通常可以提供深刻的见解去改善分类器。回顾这幅图，看样子应该努力改善分类器在数字8和数字9上的表现，和纠正3/5的混淆。举例子，你可以尝试去收集更多的数据，或者你可以构造新的、有助于分类器的特征（新的分类器的特征，我们可以在数据里面加一个新的列———这相当添加了一个新的属性，比如字数8有两个环，数字6有一个，5没有）。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;cl_a, cl_b = 3, 5
X_aa = X_train[(y_train == cl_a) &amp;amp; (y_train_pred == cl_a)]
X_ab = X_train[(y_train == cl_a) &amp;amp; (y_train_pred == cl_b)]
X_ba = X_train[(y_train == cl_b) &amp;amp; (y_train_pred == cl_a)]
X_bb = X_train[(y_train == cl_b) &amp;amp; (y_train_pred == cl_b)]

plt.figure(figsize=(8,8))
plt.subplot(221); plot_digits(X_aa[:25], images_per_row=5)
plt.subplot(222); plot_digits(X_ab[:25], images_per_row=5)
plt.subplot(223); plot_digits(X_ba[:25], images_per_row=5)
plt.subplot(224); plot_digits(X_bb[:25], images_per_row=5)
# save_fig(&quot;error_analysis_digits_plot&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878dea522.png&quot; alt=&quot;output_84_0.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，所有的样例都总是被分配到仅一个类（比如我们前面训练的分类，要么输出是1，要么是2，3，...，9，一次只能输出一个类别）。有些情况下，你也许想让你的分类器给一个样例输出多个类别。比如有时候我们想识别某个人脸，想判断它的性别，还有是否为中国人，这就有两个类别了([gender, isChinese])。。这种输出多个二值标签的分类系统被叫做多标签分类系统。&lt;/p&gt;
&lt;p&gt;目前不打算深入脸部识别。我们可以先看一个简单点的例子。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.neighbors import KNeighborsClassifier
y_train_large = (y_train &amp;gt;=7)
y_train_odd = (y_train % 2 == 1)
y_multilabel = np.c_[y_train_large, y_train_odd]

knn_clf = KNeighborsClassifier()
knn_clf.fit(X_train, y_multilabel)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',
           metric_params=None, n_jobs=None, n_neighbors=5, p=2,
           weights='uniform')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码创造了一个y_multilabel数组，里面包含两个目标标签。第一个标签指出这个数字是否为大数（即是否为7，8，9），第二个标签指示这个数字是否为奇数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;knn_clf.predict([some_digit])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([[False,  True]])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个预测器预测对，我们输入的数据代表5，5不是一个大数，但是是一个奇数。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_train, cv = 3)
# f1_score(y_train, y_train_knn_pred, average=&quot;macro&quot;)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们即将讨论最后一种分类任务，被叫做&quot;多输出-多分类&quot;（或者简称多输出分类）。在这里每一个标签可以是多类别的（比如我们前面所举的例子）&lt;/p&gt;
&lt;p&gt;为了说明这点，我们建立一个系统，它可以去除图片当中的噪音。它将一张混有噪音的图片作为输入，期待它输出一张干净的数字图片，用一个像素强度的数组表示，就像 MNIST图片那样。注意到这个分类器的输出是多标签的（一个像素一个标签）和每个标签可以有多个值 （像素强度取值范围从0到255）。所以它是一个多输出分类系统的例子。&lt;/p&gt;
&lt;p&gt;我们从MNIST的图版创建训练集和测试集开始，然后给图片的像素强度添加噪声，这里是用NumPy的&lt;code&gt;randint()&lt;/code&gt;函数。目标图像是原始图像。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;noise = np.random.randint(0, 100, (len(X_train), 784))
X_train_mod = X_train + noise
noise = np.random.randint(0, 100, (len(X_test), 784))
X_test_mod = X_test + noise
y_train_mod = X_train
y_test_mod = X_test&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def plot_digit(data):
    image = data.reshape(28, 28)
    plt.imshow(image, cmap = matplotlib.cm.binary,
               interpolation=&quot;nearest&quot;)
    plt.axis(&quot;off&quot;)
    
some_index = 5500

plt.subplot(121); plot_digit(X_test_mod[some_index])
plt.subplot(122); plot_digit(y_test_mod[some_index])
# save_fig(&quot;noisy_digit_example_plot&quot;)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878dec0d4.png&quot; alt=&quot;output_94_0.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;knn_clf.fit(X_train_mod, y_train_mod)
clean_digit = knn_clf.predict([X_test_mod[some_index]])
plot_digit(clean_digit)
# save_fig(&quot;cleaned_digit_example_plot&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/03/5bdd878df2cbe.png&quot; alt=&quot;output_95_0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的图片看起来还行，比较接近原图片，去噪的效果还可以。&lt;/p&gt;
&lt;p&gt;到这里，分类的知识学得差不多了。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 11:52:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>这是学习《Hands On Machine Learning with Scikit Learn and TensorFlow》的笔记，如果此笔记对该书有侵权内容，请联系我，将其删除。 博客出自：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/9901539.html</dc:identifier>
</item>
<item>
<title>不懂算法的程序员不是好工程师--选择排序 - 大菜</title>
<link>http://www.cnblogs.com/zhanlang/p/9901764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/9901764.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“大菜”：时刻提醒自己，技术之路修远兮，予以自勉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1541235424990&amp;amp;di=391c9d3291d6da88d0fcbd3105cef7e5&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fi3.hexun.com%2F2017-09-20%2F190942492.jpg&quot; width=&quot;100%&quot; hegiht=&quot;20%&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法主要衡量标准&quot;&gt;算法主要衡量标准&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;h5 id=&quot;时间复杂度运行时间&quot;&gt;时间复杂度（运行时间）&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在算法时间复杂度维度，我们主要对比较和交换的次数做对比，其他不交换元素的算法，主要会以访问数组的次数的维度做对比。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实有很多同学对于算法的时间复杂度有点模糊，分不清什么所谓的 O(n),O(nlogn),O(logn)...等，也许下图对一些人有一些更直观的认识。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/i/608996/201408/141025088894028.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;h5 id=&quot;空间复杂度额外的内存使用&quot;&gt;空间复杂度（额外的内存使用）&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;排序算法的额外内存开销和运行时间同等重要。 就算一个算法时间复杂度比较优秀，空间复杂度非常差，使用的额外内存非常大，菜菜认为它也算不上一个优秀的算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h5 id=&quot;结果的正确性&quot;&gt;结果的正确性&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这个指标是菜菜自己加上的，我始终认为一个优秀的算法最终得到的结果必须是正确的。就算一个算法拥有非常优秀的时间和空间复杂度，但是结果不正确，又有什么意义呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;在起始位置右侧（或左侧）找出最小的那个元素，然后和起始位置的元素交换&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;选择排序是一个不稳定的排序算法&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;具体步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;在一个数据列表中找到最小的那个元素，将它和列表的第一个元素交换位置。&lt;/li&gt;
&lt;li&gt;在第二个元素位置开始再次寻找最小的那个元素，然后和列表的第二个位置的元素交换。&lt;/li&gt;
&lt;li&gt;在第三个元素位置开始再次寻找最小的那个元素，然后和列表的第三个位置的元素交换&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如此反复，直到开始查找起始位置到达列表末尾。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果查找过程中最小的元素就是起止位置的元素，那么它就和它自己交换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;++&lt;strong&gt;&lt;em&gt;因为这种算法总是在不断的选择剩余元素中最小者，因此得名选择排序&lt;/em&gt;&lt;/strong&gt;++&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1541086017129&amp;amp;di=184f40ef04b1860987dbc48165eca243&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2FJackyTecblog%2F201209%2F201209051514258004.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;复杂度&quot;&gt;复杂度&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;时间复杂度&quot;&gt;时间复杂度&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;比较次数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于长度为N的列表，选择排序需要大约n² /2次比较.即：O（n²）平方级别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;交换次数&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对于长度为N的列表，选择排序需要大约N次交换.即：O(N) 线性级别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;性能和特点&quot;&gt;性能和特点&lt;/h2&gt;
&lt;p&gt;总体来说，选择排序是一种比较简单的排序算法，很容易理解也很好用代码实现，当然他的特点也很明显：&lt;/p&gt;
&lt;h5 id=&quot;运行时间和数据初始状态无关&quot;&gt;运行时间和数据初始状态无关&lt;/h5&gt;
&lt;p&gt;为什么这么说呢？算法进行中为了查找最小的元素而遍历列表并不能为下次遍历带来任何信息，这个特性在大部分情况下是缺点。如果一个数据列表初始状态是有序的或者部分有序的，选择排序仍然需要全部扫描一次和交换。因此和一个完全无序的列表排序所花的时间相差不大。&lt;/p&gt;
&lt;h5 id=&quot;数据移动次数是最少的&quot;&gt;数据移动次数是最少的&lt;/h5&gt;
&lt;p&gt;每次交换只会改变两个列表元素，因此长度为N的列表只会发生N次交换，交换次数和列表的长度是线性关系，其他算法都不具备这个特性。&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;由于选择排序的对比次数在平方级别，但是移动次数在线性级别，所以当N比较小的时候比较适用。&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;根据以上定义很容易可以得出这样的结论：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们举出一个实例，序列5 8 5 2 9， 这个在执行选择排序的时候，第一遍，肯定会将array[0]=5，交换到2所在的位置，也就是 2 8 5 5 9，那么很显然，之后的排序我们就会发现，array[2]中的5会出现在原先的array[0]之前，所以选择排序不是一个稳定的排序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现案例&lt;/p&gt;
&lt;h5 id=&quot;c&quot;&gt;（c#）&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        static void Main(string[] args)
        {
            List&amp;lt;int&amp;gt; data = new List&amp;lt;int&amp;gt;() ;
            for (int i = 0; i &amp;lt; 10; i++)
            {
                
                data.Add(new Random(Guid.NewGuid().GetHashCode()).Next(1, 100));
            }
            //打印原始数组值
            Console.WriteLine($&quot;原始数据： {string.Join(&quot;,&quot;, data)}&quot;);
            int n = data.Count;
            for (int i = 0; i &amp;lt; n; i++)
            {
                int minIndex = i;
                //查找最小的元素的索引
                for (int j = i+1; j &amp;lt; n; j++)
                {
                    if (data[j] &amp;lt; data[minIndex])
                    {
                        minIndex = j;
                    }
                }
                //交换最小的元素和当前位置的元素，当然这里可以加入一个最小元素是否是当前位置元素的判断来较少交换次数
                int tempItem = data[i];
                data[i] = data[minIndex];
                data[minIndex] = tempItem;

            }
            //打印排序后的数组
            Console.WriteLine($&quot;排序数据： {string.Join(&quot;,&quot;, data)}&quot;);
            Console.Read();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;原始数据：97,85,61,22,62,12,67,22,68,42&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;排序数据：12,22,22,42,61,62,67,68,85,97&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;go&quot;&gt;Go&lt;/h5&gt;
&lt;p&gt;家里没环境，还得FQ，以后再补上吧，望见谅。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;独乐不如众乐&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;老妈刚要收拾收拾卫生...老公就笑着说道：“妈，您大老远过来，哪能让你打扫家务...”然后老公就让我带我妈出去逛逛街，家务他全包了...就这样，我被老妈拉了出去，我生气的对老妈说道：“明明我都看到地毯底下的钱了，为什么不让我拿出来！”老妈淡定的说道：“要嘛，你现在回去把那钱拿出来翻脸！要嘛，现在就跟我逛街去！以后家务也不用做了！你选吧...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1541237550829&amp;amp;di=63c822203bb61954893ef516e504c21d&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fku.90sjimg.com%2Felement_origin_min_pic%2F18%2F01%2F24%2Fb59eca536c68e65a3d3f9008df348da9.jpg&quot; width=&quot;250px&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转载请标明出处 ^ ~ ^ 。部分图片来源于网络，如有侵权请及时联系。让我们一起进步吧&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个不止于IT圈内容的微信公众号，欢迎关注，交流更多的IT知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/zhanlang/1295643/o_qrcode_for_gh_4c89835a6125_344.jpg&quot; width=&quot;250px&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 03 Nov 2018 11:25:00 +0000</pubDate>
<dc:creator>大菜</dc:creator>
<og:description>“大菜”：时刻提醒自己，技术之路修远兮，予以自勉。 算法主要衡量标准 时间复杂度（运行时间） 在算法时间复杂度维度，我们主要对比较和交换的次数做对比，其他不交换元素的算法，主要会以访问数组的次数的维度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanlang/p/9901764.html</dc:identifier>
</item>
</channel>
</rss>