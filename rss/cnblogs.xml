<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[MV] - You Give REST a Bad Name - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9292571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9292571.html</guid>
<description>&lt;p&gt;本首歌改自Bon Jovi经典歌曲&quot;You Give Love a Bad Name&quot;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CgWvqlXe73HGwthicwp2Sibqx6hwWdblaADje1u6rq8KRatrrNLwyOFAibShRHJtFI788oIpm1k5fMmicCxhBpIvGQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;1.0071428571428571&quot; data-type=&quot;jpeg&quot; data-w=&quot;280&quot; data-s=&quot;300,640&quot; data-copyright=&quot;0&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CgWvqlXe73HGwthicwp2Sibqx6hwWdblaADje1u6rq8KRatrrNLwyOFAibShRHJtFI788oIpm1k5fMmicCxhBpIvGQ/640?wx_fmt=jpeg&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;改编的作者是Dylan Beattie, 他是Spotlight的系统架构师.&lt;/p&gt;
&lt;p&gt;改编后的歌曲主要描述了各种糟糕的REST API实现:&lt;/p&gt;

&lt;div&gt;视频原地址: &lt;a href=&quot;https://www.youtube.com/watch?v=nSKp2StlS6s&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=nSKp2StlS6s&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;作者的Google+:&lt;a href=&quot;https://plus.google.com/u/0/+DylanBeattie&quot; target=&quot;_blank&quot;&gt; https://plus.google.com/u/0/+DylanBeattie&lt;/a&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 10 Jul 2018 22:27:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9292571.html</dc:identifier>
</item>
<item>
<title>[编译] 3、在Linux下搭建51单片机的开发烧写环境（makefile版） - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9292449.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9292449.html</guid>
<description>&lt;p&gt;星期二, 10. 七月 2018 01:01上午 - beautifulzzzz&lt;br/&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一sdccsmall-device-c-compiler编译环境搭建&quot;&gt;一、SDCC（Small Device C Compiler）编译环境搭建&lt;/h3&gt;
&lt;p&gt;SDCC是一个小型设备的C语言编译器，该编译器是标准C语言，可以编译Intel MCS51架构的微处理器，也可以编译STM8等常见MCU。我们要在linux上搭建51开发环境，首先要搭建SDCC编译环境。&lt;/p&gt;
&lt;p&gt;其主页是：&lt;a href=&quot;http://sdcc.sourceforge.net/&quot; class=&quot;uri&quot;&gt;http://sdcc.sourceforge.net/&lt;/a&gt; ，下面是SDCC的首页简介：&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;SDCC is a retargettable, optimizing Standard C (ANSI C89, ISO C99, ISO C11) compiler suite that targets the Intel MCS51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (z80, z180, gbz80, Rabbit 2000/3000, Rabbit 3000A, TLCS-90) and STMicroelectronics STM8. Work is in progress on supporting the Microchip PIC16 and PIC18 targets. It can be retargeted for other microprocessors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;下载&quot;&gt;1.1、下载&lt;/h4&gt;
&lt;p&gt;有两个可供下载的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 对于选择拿来即用的兄弟，可以直接跳过1.2节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编译&quot;&gt;1.2、编译&lt;/h4&gt;
&lt;p&gt;如何编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./config&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能会出现下面几种错误（我也给出了解决办法）：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;错误 1&lt;/strong&gt; 、缺少bison :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  configure: error: Cannot find required program bison.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo apt-get install flex bison&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;错误 2&lt;/strong&gt; 、找不到adjacency_list.hpp&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  configure: error: boost library not found (boost/graph/adjacency_list.hpp).&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo apt-get install libboost-date-time-dev libboost-program-options-dev libboost-system-dev libboost-filesystem-dev libboost-iostreams-dev&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;错误 3&lt;/strong&gt; 、 没有PIC14、PIC16设备&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  failed for device/lib/pic14&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ./configure --disable-pic14-port --disable-pic16-port&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试&quot;&gt;1.3、测试&lt;/h4&gt;
&lt;p&gt;直接下载编译好的需要将其按照说明放入系统bin等文件中，采用编译的会自动将其放入系统bin中。而我比较喜欢不让其和系统的各种东西纠缠在一起，单独放在工程下的一个叫tool的文件里，大不了用的时候输全路径！&lt;/p&gt;
&lt;p&gt;如下，我在example目录下建一个makefile和a.c文件，将直接编译好的sdcc文件放在tool下面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  SDCC_WS  tree -L 2
.
├── example
│   ├── a.c
│   └── makefile
├── readme.md
└── tool
    └── sdcc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中a.c为51闪灯程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;8052.h&amp;gt;
 
void delay(void);
 
void main(void){
    while(1){
     P1 = 0xFF; // Turn ON all LED's connected to Port1
     delay();
     P1 = 0x00; // Turn OFF all LED's connected to Port1
     delay();
    }
}
 
void delay(void){
    int i,j;
    for(i=0;i&amp;lt;0xff;i++)
     for(j=0;j&amp;lt;0xff;j++);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;makefile为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDCC_PATH=../tool/sdcc

z_sdcc=${SDCC_PATH}/bin/sdcc
z_packihx=${SDCC_PATH}/bin/packihx


a.hex:a.c
    ${z_sdcc} a.c
    ${z_packihx} a.ihx &amp;gt; a.hex

clean:
    rm -rf *.asm *.lst *.mem *.rst *.lnk *.rel *.sym *.ihx *.hex *.map *.lk *.bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二hex2bin命令行烧写工具配置使用&quot;&gt;二、Hex2Bin+命令行烧写工具配置使用&lt;/h3&gt;
&lt;h4 id=&quot;下载工具安装配置&quot;&gt;2.1、下载工具安装配置&lt;/h4&gt;
&lt;p&gt;理论上hex也能烧写，但是hex比bin要大一些，所以我们用这里用bin烧写。hex转bin要用到一个&lt;a href=&quot;https://sourceforge.net/projects/hex2bin/files/latest/download&quot;&gt;Hex2Bin&lt;/a&gt;工具，将其下载下来解压到tool目录下；stc单片机烧写工具需要用一个github开源软件&lt;a href=&quot;https://github.com/laborer/stcflash&quot;&gt;stcflash&lt;/a&gt;，也将其下载到tool目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  SDCC_WS  tree -L 2
.
├── example
│   ├── a.c
│   └── makefile
├── readme.md
└── tool
    ├── Hex2bin-2.5
    ├── sdcc
    ├── software
    └── stcflash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将makefile改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDCC_PATH=../tool/sdcc
HEX2BIN_PATH=../tool/Hex2bin-2.5
STCFLASH=../tool/stcflash

z_sdcc=${SDCC_PATH}/bin/sdcc
z_packihx=${SDCC_PATH}/bin/packihx
z_hex2bin=${HEX2BIN_PATH}/hex2bin
z_stcflash=${STCFLASH}/stcflash.py

a.hex:a.c
    ${z_sdcc} a.c
    ${z_packihx} a.ihx &amp;gt; a.hex
    ${z_hex2bin} a.hex

clean:
    rm -rf *.asm *.lst *.mem *.rst *.lnk *.rel *.sym *.ihx *.hex *.map *.lk *.bin

flash:
    python ${z_stcflash} a.bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;编译烧写&quot;&gt;2.2、编译+烧写&lt;/h4&gt;
&lt;p&gt;进入example目录运行make，自动编译：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180711/make_sdcc.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入make flash，给51单片机重新上电（冷启动）进行烧写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180711/make_flash.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 10 Jul 2018 19:33:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9292449.html</dc:identifier>
</item>
<item>
<title>【最新】LuaJIT 32/64 位字节码，从编译到使用全纪录 - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/9292425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/9292425.html</guid>
<description>&lt;p&gt;网上关于 LuaJIT 的讨论，已经显得有些陈旧。如果你对 LuaJIT 编译 Lua 源文件为具体的 32位或64位字节码，极其具体使用感兴趣的话，不妨快速读一下这篇文章。此文章针对尝试在 iOS 或 Android 上使用 LuaJIT 的小伙伴。限于篇幅，此处假定，你可以成功在 iOS/Android App 中集成了 LuaJIT,并且已经可以执行源码形式的 Lua 文件。&lt;/p&gt;
&lt;p&gt;我忍不住在开头插一句： LuaJIT 编译后，只有约 600k,可能也就是一张图片的空间，但却可以让你的你App可以拥有一门完整的脚本语言的能力 -- 真的很酷！为许多问题，提供了许多新的思路，特别是 App 地动态性和可配置型方面。&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;操作系统： macOS 10.13.4 【Linux 系统上，应该使用；Windows 系统上，仅供参考】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;LuaJIT 版本： LuaJIT-2.1.0-beta3【官网最新版】&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;目录结构预定义&quot;&gt;目录结构预定义&lt;/h2&gt;
&lt;p&gt;为了便于下文指令的说明，此处简单约定下目录结构。实际使用时，按需设置和整理即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tools：存放各种编译脚本和工具。&lt;/li&gt;
&lt;li&gt;source：存放编译前的 Lua 源码。以后所有的 Lua 源码，都需要放在且只能放在此文件夹下。&lt;/li&gt;
&lt;li&gt;output: 用于存放编译后的 Lua 字节码文件。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编译加密工具&quot;&gt;编译加密工具&lt;/h2&gt;
&lt;p&gt;Lua 的加密工具，本质上就是 Lua 的解释器。此处使用的解释器源码是 LuaJIT。LuaJIT 执行效率最高，且编译出来的字节码无法逆向为 Lua 源码，更能保证源码安全性。LuaJIT 支持交叉编译，即可以在电脑上编译出 iOS 或 Android 手机上系统需要的字节码。如此，我们只需要编译一次 32 和 64 位的 LuaJIT 解释器各一个，备份存档，后续可直接使用。&lt;/p&gt;
&lt;p&gt;编译 LuaJIT 解释器，直接用官方的推荐指令即可。比较特殊的一点时，如果是想编译出 64 位 LuaJIT，需要加上参数 &lt;code&gt;CFLAGS=-DLUAJIT_ENABLE_GC6&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;# cd 到 LuaJIT 源码目录
cd tools/LuaJIT-2.1.0-beta3

# 编译 32 位 LuaJIT 解释器
make clean &amp;amp;&amp;amp; make &amp;amp;&amp;amp; cp src/luajit ../luajit-32 &amp;amp;&amp;amp; make clean

# 编译 64 位 LuaJIT 解释器
make clean &amp;amp;&amp;amp; make CFLAGS=-DLUAJIT_ENABLE_GC64 &amp;amp;&amp;amp; cp src/luajit ../luajit-64 &amp;amp;&amp;amp; make clean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：重新解压源码后，可能需要重新启动命令行/终端，来清除可能的系统缓存，才能正确 build 出想要的东西。&lt;/p&gt;
&lt;h2 id=&quot;加密-lua-源文件&quot;&gt;加密 Lua 源文件&lt;/h2&gt;
&lt;p&gt;所谓的加密 Lua 源文件，其实就是把 Lua 源文件，编译为 LuaJIT 字节码。相对于 Luac ，LuaJIT 字节码执行效率更高，而且无法被直接逆向为对应的 Lua 源码。&lt;/p&gt;
&lt;p&gt;编译字节码，用的是 &lt;em&gt;-b&lt;/em&gt; 命令，需要注意的是，一定要使用对应字节的 LuaJIT 解释器来编译，否则 iOS/Android App 中，可能无法加载。&lt;/p&gt;
&lt;p&gt;编译后的字节码文件的后缀，可以根据自己需要自定义。此处我使用的是 “.yan” 和 “.yan64”。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;# 编译32位字节码 ，适用于Android全部手机，部分 iOS 手机。
./tools/luajit-32 -b ./source/main.lua ./output/main.yan

# 编译64位字节码，仅用于部分 iOS 手机。
./tools/luajit-64 -b ./source/main.lua ./output/main.yan64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 敏感信息，不要直接以常量字符串的形式使用。&lt;/p&gt;
&lt;h2 id=&quot;在-ios-中根据不同的-cpu-加载不同的字节码&quot;&gt;在 iOS 中，根据不同的 CPU， 加载不同的字节码。&lt;/h2&gt;
&lt;p&gt;在 Android 手机上，一般只需要使用 32 位的 LuaJIT 字节码文件即可。iOS 上，情况比较复杂，从 iOS11 之后，iOS 要求相对的库必须有64位版本。也就意味着，如果 App 想兼容 iPhone5s 以前的 32位CPU的设备的话，就必须在项目中同时放置32位和64位的LuaJIT静态库。关于适用于手机端的 LuaJIT 静态库的编译问题，暂不进一步展开。此处只讨论，如何在 iOS 中，动态根据需要准确加载对应的 32 或 64 位的 LuaJIT 字节码文件。&lt;/p&gt;
&lt;p&gt;基于上文的讨论，此处给出一个简单的策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Lua 源文件，同时编译生成32位和64位字节码的文件。&lt;/li&gt;
&lt;li&gt;编译后的字节码文件，仅文件后缀不同，文件路径的其他部分保证是完全一致的。如 &lt;em&gt;main.yan&lt;/em&gt; 和 &lt;em&gt;main.yan64&lt;/em&gt; 是由 &lt;em&gt;main.lua&lt;/em&gt;编译得到。&lt;/li&gt;
&lt;li&gt;在 iOS App 运行时，动态根据当前真正运行的是 32 还是 64 位的 LuaJIT 解释器，来选择对应的字节码文件后缀即可。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分享一个 swift 版的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private func luaFileSuffix() -&amp;gt; String{
        #if (arch(i386) || arch(arm))
        return &quot;.yan&quot;
        #else
        return &quot;.yan64&quot;
        #endif

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Tue, 10 Jul 2018 19:04:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/9292425.html</dc:identifier>
</item>
<item>
<title>在地铁11号线上写书 - Vamei</title>
<link>http://www.cnblogs.com/vamei/p/9292419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vamei/p/9292419.html</guid>
<description>
&lt;p&gt;我是抱着玩的心态开始用电脑的。自从家里有了电脑之后，我就想方设法抓起鼠标和键盘打一会儿游戏。《金庸群侠传》《仙剑》《星际》《盟军敢死队》，这些老游戏都玩了个遍。父母担心我沉迷游戏，一度没收了我的鼠标和键盘。总之，当时的电脑只是个娱乐平台。&lt;/p&gt;
&lt;p&gt;那个时候已经在提“20世纪是计算机的世纪”。好莱坞电影开始把黑客塑造成孤胆侠客。我经常抱着《电脑报》或《大众软件》，幻想着自己成为一名侠客一般的计算机高手。但对于一个内地小城的孩子来说，深入接触计算机技术的机会很有限。我曾经很认真地找了一套计算机等级考试的书看。把二进制运算、SQL命令、QBasic语法都记得滚瓜烂熟，却因为装不好编译环境，最终没能写出一个可以使用的软件。后来读那些顶级黑客的传记，讲他们从小如何如何编程，一直很好奇他们是如何度过环境搭建这个难关的。后来发现，这些人都有机会接触一些编程高手，所以在他们的眼里，根本不认为这是太大的问题。&lt;/p&gt;
&lt;p&gt;上大学时，我选择了物理专业。物理专业做数值模拟和数据处理，C语言和Fortran语言编程也是必修课。有了大学里的资源，编程环境的搭建变成了小菜一碟。只是自己的电脑太过老迈，动不动就要死机。朋友们呼啸着打Dota时，我却在为Word触发的蓝屏头痛。相熟的朋友看不下去，扔给我一张光盘，要我重装Ubuntu系统。Ubuntu是当时最流行的一个Linux版本。死马当活马医，我安装了光盘上的Ubuntu。系统装好了，电脑死机的次数大为减少。不过Linux下的图像化界面确实和Windows有差距，办公软件也比不上Office。我戚戚然地把Linux当作低成本的二等方案。但无论如何，当时正值我做“大学生研究计划”，运行稳定的Linux还是救我于水火。事后请朋友吃饭，问朋友哪里来的光盘，才晓得Ubuntu的安装光盘可以免费领取。&lt;/p&gt;
&lt;p&gt;更让我刮目相看的是Linux下的软件分发。那个时代还没有苹果App Store这样的东西。所谓的在线软件分发，就是上网下载exe安装包。用了Ubuntu之后，我需要的软件基本都可以在软件源中找到。在终端输入一行命令，编译环境就搭建好了。我不用担心病毒，而且大部分情况下也不需要付费。再加上学校里有Ubuntu镜像，下载一个软件往往只需要几秒钟。于是，探索Linux下的软件成了我的一大业余爱好，我渐渐习惯了用ImageMagick来做图片处理，用FFmpeg来转换视频，用Wget来做网络下载。这些基于命令行的应用软件，再搭配bash的批处理功能，往往能实现强大的复合功能。&lt;/p&gt;
&lt;p&gt;我也越来越享受Linux系统提供的编程环境。在写C语言和Fortran语言作业时，我就开始用vim编写自己的作业，用GCC和GFortran来编译，再用GDB来调试。这个过程要比Windows下的IDE麻烦。但当接触其他语言时，相同的工具可以复用，不用每一次都花费大量时间来熟悉全新的IDE。后来在Linux下学习Python语言时，很容易就可以上手。如果说编程是去游乐园，那么Linux为入园玩耍提供了直通车。想起小时候为编译环境苦恼的自己，真想穿越时光送去一张Ubuntu的安装盘。&lt;/p&gt;
&lt;p&gt;我觉得对于一个电脑爱好者来说，Linux最美的地方就是开放。Linux的开放可以分为多个层面。软件层面是开放的，用户可以免费使用。文档也是开放的，你可以在终端下用man命令方便地查询。操作系统是开放的，你可以自由地调整系统，也可以深入了解其原理。代码上亦是开放的，你随时可以看到世界上顶级程序员写下的源代码。在Linux系统下，“实现”和“如何实现”是合二为一的。吃鱼的同时，钓鱼的本事也可以学到。因此，Linux提供了一个绝佳的学习平台。&lt;/p&gt;
&lt;p&gt;后来，太太送给我一部树莓派做生日礼物。我惊喜地发现，树莓派使用的操作系统正是Linux。更棒的是，树莓派的底层硬件也很开放。它可以方便地通过有线或无线的方式和硬件外设进行连接。它对使用方式没有太多限制。于是，在后来的智能硬件创业项目，我总是在研发版本中使用树莓派。无论是作为硬件的树莓派，还是作为软件的Linux，都遵循了相同的规律：开放战胜了封闭。知识的共享带来更加活跃的创造力，也给社会带来协同合作的机会。&lt;/p&gt;
&lt;p&gt;几年前，我读到印度的一个公益项目。这个项目募集旧电脑，在电脑上安装Linux系统，再发放给贫困地区的儿童使用。这个项目给孩子们带来的不止是欢乐，还改变了他们的命运。当树莓派发布的新闻出来时，我想到的就是这款微型电脑的社会意义。后来读到树莓派之父厄普顿发明这台小电脑的初衷，果然也是教育。我由此确信，有很多人和我抱着相同的见解。&lt;/p&gt;
&lt;p&gt;如今，“科技取代人类”的言论甚嚣尘上，很多人对技术霸权顶礼膜拜，对人类的未来充满绝望。其实，科技本身是中性的。科技可以取代人们的工作，也可以帮助人们更好地就业。像树莓派和Linux这样的技术，尊重了用户本身的创造力。它们用一种开放协作的态度，提高了社会的温度。我也一直抱着这样的理念，坚持在博客上分享自己的所知。我还记得自己在探索计算机时无路可循的尴尬。即使是出于简单的同理心，我也希望自己的分享能帮助任何一个在门槛上抓耳挠腮的学习者。&lt;/p&gt;
&lt;p&gt;借着这股心劲，我克服了写作的羞涩，投入到这本书的写作中。我希望这本书能以树莓派硬件为平台，全面讲解Linux原理。全靠昕梓的通力合作，我才能顺利完成这个野心勃勃的目标。杜鹃、陈思为帮我审读了全书，提出大量的修改意见，让书稿变得真正可读。安娜会在关键的时候给我们提供任何所需的帮助，全程引导了写作过程。最后，这本书还要感谢上海的地铁11号线。全靠这班地铁上的空座位，我才能坐着写出大部分文字。&lt;/p&gt;
&lt;p&gt;在设计本书内容时，昕梓和我决定尊重读者，不避讳艰深的内容。毕竟，树莓派本身只是一个入口。这个入口的背后有着丰富的操作系统知识。无论是编程，还是深入理解计算机，一定深度的操作系统知识都不可或缺。我们会从树莓派的基本使用讲起，一直深入到操作系统原理本身。在后面一部分，我还加入了基于树莓派的实践项目，希望能抛砖引玉，激发用户的创造力。当然，篇幅所限，我也不得不舍弃一些细节。但我相信，只要体验到边玩边学电脑的乐趣，那么其他技术的掌握也都可以沿着相同的轨迹重复进行。&lt;/p&gt;
&lt;p&gt;那样的话，这本书就没有遗憾了。&lt;/p&gt;

&lt;p&gt;本文为《&lt;a href=&quot;https://book.douban.com/subject/30259573/&quot; target=&quot;_blank&quot;&gt;树莓派开始，玩转Linux&lt;/a&gt;》一书前言&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 18:55:00 +0000</pubDate>
<dc:creator>Vamei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vamei/p/9292419.html</dc:identifier>
</item>
<item>
<title>我所理解的CountDownLatch和CyclicBarrier - 曦阳x</title>
<link>http://www.cnblogs.com/be-thinking/p/9292290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/be-thinking/p/9292290.html</guid>
<description>&lt;p&gt;         晚上打车回家，在车上看到一篇文章《22岁大学生获谷歌天价Offer，年薪千万！》，讲的是印度一个22岁大学生多次参加ACM大赛，开源多个项目，以非常牛逼的履历通过了谷歌的AI测试，斩获谷歌仅有的50个顶尖offer之一。于是感慨：同样是大学生，为何这哥们就这么一枝独秀呢？难道印度也有陈独秀？为啥自己都12年义务教育+4年大学教育+3年烟酒僧教育了，连人家个零头都挣不了啊？真恨不得在地上挖个洞钻进去。不行，今晚必须输出篇博客安慰下被打击的心！想到这里顿时酒也醒了（老大走了，今晚几个同事送他，喝了点酒），心也不再那么伤感了，决定把今天get的一些知识点做个梳理，知识是一点点积累起来的，比你牛逼的人比你还努力，你还有什么资格不努力？&lt;/p&gt;
&lt;p&gt;        早上看了下CountDownLatch和CyclicBarrier的用法和区别，就来讲讲这2兄弟的功能&amp;amp;&amp;amp;特点&amp;amp;&amp;amp;用法，讲的不对的地方欢迎指正。&lt;/p&gt;
&lt;p&gt;              CountDownLatch：&lt;/p&gt;
&lt;p&gt;                        功能：同步辅助类，也可以理解为倒计时锁，用于同步线程状态，允许一个或多个线程，等待其他一组线程完成操作，再继续往下执行。&lt;/p&gt;
&lt;p&gt;                        特点：不可复用！&lt;/p&gt;
&lt;p&gt;                        重要方法：countDown()方法：计数器-1，每次线程执行完后调用；await（）方法：等待方法，在需要阻塞的地方调用，当所有线程都执行完后，自动往下执行&lt;/p&gt;
&lt;p&gt;                        用法：构造的时候指定一个计数器的值，每个线程执行完后就减1，直到为0再往下走。如下：&lt;/p&gt;
&lt;p&gt;                                  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180711000203852-86624447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                 输出结果：&lt;/p&gt;
&lt;p&gt;                                 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180711000241445-351987255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                 可以看到：2个子线程分别睡眠了3s和5s，而主线的打印的“所有现场执行完毕”却是在所有子线程执行完成后才输出的，原因就是阻塞在了latch.await()方法，这个方法会等到所有线程都执行完才往下执行，阻塞的原理后面有空再研究分析&lt;/p&gt;
&lt;p&gt;          CyclicBarrier（循环栅栏）：&lt;/p&gt;
&lt;p&gt;                        功能：同步辅助类，功能和CountDownLatch类似，用于同步线程状态，允许一组线程相互之间等待，达到一个共同点，再继续执行。&lt;/p&gt;
&lt;p&gt;                        特点：可复用！当所有线程都&lt;/p&gt;
&lt;p&gt;                        重要方法：await（）方法：当某个线程到达某个点（比如执行完某个任务）后调用该方法，就会等待其他线程，直到所有线程都到达这个点，再自动往下执行。还有个重载方法await（long timeOut,TimeUnit unit），用于当某个线程执行超过指定时间后还未到达某个点时，就会抛出异常，不再等待这个线程，并往下执行&lt;/p&gt;
&lt;p&gt;                        用法：构造的时候指定一个线程数量的值和到达某个点后执行的动作，如下：&lt;/p&gt;
&lt;p&gt;                                   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180711002427148-140910166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                            执行结果如下：&lt;/p&gt;
&lt;p&gt;                                   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1038767/201807/1038767-20180711002551150-2064243757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                            可以看到：当前线程先于2个子线程打印执行结果，原因就是CyclicBarrier针对的是一组线程之间的等待，await方法会等待该组内所有线程都执行完毕再往下执行，Runnable接口里定义的动作是在所有线程执行完毕后，随机选择一个线程来执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          2者区别：&lt;/p&gt;
&lt;p&gt;                        1、CountDownLatch不可复用，当计数器减为0后，只能重新构造新的计数器，CyclicBarrier可以复用，当所有线程都到&lt;/p&gt;
&lt;p&gt;                        2、CyclicBarrier针对的是一组线程之间的等待，是组内等待关系，CountDownLatch针对的是一个线程等待别的一组线程的关系，是组间等待关系&lt;/p&gt;
&lt;p&gt;           本来还想讲讲volatile关键字的原理和特性，以及activeMQ中quene,topic和virtualTop之间的区别和用法的，以及mysql索引结构的实现原理的，时间不够了，明早还要去申请廉租房得早起，下次再讲吧。&lt;/p&gt;

</description>
<pubDate>Tue, 10 Jul 2018 16:34:00 +0000</pubDate>
<dc:creator>曦阳x</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/be-thinking/p/9292290.html</dc:identifier>
</item>
<item>
<title>SpringBoot入门之基于注解的Mybatis - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9292201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9292201.html</guid>
<description>&lt;p&gt;今天学习下SpringBoot集成mybatis,集成mybatis一般有两种方式，一个是基于注解的一个是基于xml配置的。今天先了解下基于注解的mybatis集成。&lt;/p&gt;
&lt;p&gt;一、引入依赖项&lt;/p&gt;
&lt;p&gt;因为是mybatis嘛,肯定是要有mybatis相关的,同时用的是mysql,所以也需要引入mysql相关的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/mysql/mysql-connector-java &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;8.0.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、创建model&lt;/p&gt;
&lt;p&gt;这里创建了一个User的model,这样方便与数据库的表对照，这里在mysql中创建了一个名为mybatis的数据库,里面创建了一个user的表.同时创建了枚举类UserSexEnum.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `name` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `age` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `sex` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ed6f0a97-32c4-47e3-9816-75356279b2e9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ed6f0a97-32c4-47e3-9816-75356279b2e9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ed6f0a97-32c4-47e3-9816-75356279b2e9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;  &quot;User [id=&quot; + Id + &quot;, name=&quot; + Name + &quot;, age=&quot; + Age + &quot;]&quot;&lt;span&gt;;

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        Id &lt;/span&gt;=&lt;span&gt; id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        Name &lt;/span&gt;=&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        Age &lt;/span&gt;=&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Age; 
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserSexEnum Sex;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserSexEnum getSex() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Sex;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(UserSexEnum sex) {
        Sex &lt;/span&gt;=&lt;span&gt; sex;
    }


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_67130a38-376e-48fb-bb0a-ffe49b8af35d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_67130a38-376e-48fb-bb0a-ffe49b8af35d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_67130a38-376e-48fb-bb0a-ffe49b8af35d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; UserSexEnum {
    MAN, WOMAN
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;三、创建Mapper&lt;/p&gt;
&lt;p&gt;这里需要把model与操作数据库的sql对照起来，用什么对照呢?那就需要创建一个mapper.这里有增删改查。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.mapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Delete;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Insert;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Result;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Results;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Select;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.annotations.Update;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.example.model.*&lt;span&gt;;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;  UserMapper {

    @Select(&lt;/span&gt;&quot;SELECT * FROM user&quot;&lt;span&gt;)

    @Results({

        @Result(property &lt;/span&gt;= &quot;Sex&quot;,  column = &quot;sex&quot;, javaType = UserSexEnum.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;),

        @Result(property &lt;/span&gt;= &quot;Name&quot;, column = &quot;name&quot;&lt;span&gt;)

    })

    List&lt;/span&gt;&amp;lt;User&amp;gt;&lt;span&gt; getAll();

    

    @Select(&lt;/span&gt;&quot;SELECT * FROM user WHERE id = #{id}&quot;&lt;span&gt;)

    @Results({

        @Result(property &lt;/span&gt;= &quot;Sex&quot;,  column = &quot;sex&quot;, javaType = UserSexEnum.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;),

        @Result(property &lt;/span&gt;= &quot;Name&quot;, column = &quot;name&quot;&lt;span&gt;)

    })

    User getOne(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);



    @Insert(&lt;/span&gt;&quot;INSERT INTO user(name,age,sex) VALUES(#{name}, #{age}, #{sex})&quot;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; insert(User user);



    @Update(&lt;/span&gt;&quot;UPDATE user SET name=#{userName},age=#{age} WHERE id =#{id}&quot;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(User user);



    @Delete(&lt;/span&gt;&quot;DELETE FROM user WHERE id =#{id}&quot;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、配置扫描&lt;/p&gt;
&lt;p&gt;上面配置了mapper,那怎么让系统知道mapper放在哪里呢?于是有了@MapperScan注解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.spring.annotation.MapperScan;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&lt;/span&gt;&quot;com.example.mapper&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(DemoApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;五、创建Controller&lt;/p&gt;
&lt;p&gt;这里创建了UserController,一个是显示所有用户,一个是新增一个用户之后再显示所有用户。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.ui.Model;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMethod;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.mapper.UserMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.model.User;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.example.model.UserSexEnum;

@Controller
@RequestMapping(&lt;/span&gt;&quot;/user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController {
    
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserMapper userMapper;
    
    @RequestMapping(value &lt;/span&gt;= &quot;/alluser.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getallusers(Model model) {
       List&lt;/span&gt;&amp;lt;User&amp;gt; users=&lt;span&gt;userMapper.getAll();
       model.addAttribute(&lt;/span&gt;&quot;users&quot;&lt;span&gt;, users);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;userlist&quot;&lt;span&gt;;
    }
    @RequestMapping(value &lt;/span&gt;= &quot;/insert.do&quot;,method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String adduser(Model model) {
       User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
       user.setName(&lt;/span&gt;&quot;cuiyw&quot;&lt;span&gt;);
       user.setAge(&lt;/span&gt;27&lt;span&gt;);
       user.setSex(UserSexEnum.MAN);
                
       userMapper.insert(user);
       List&lt;/span&gt;&amp;lt;User&amp;gt; users=&lt;span&gt;userMapper.getAll();
       model.addAttribute(&lt;/span&gt;&quot;users&quot;&lt;span&gt;, users);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;userlist&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;六、数据库配置&lt;/p&gt;
&lt;p&gt;上面mapper也设置了,model也设置了,那要与数据库交互，肯定要配置数据库地址这些信息吧。这里在运行的时候还报了一个错误.nested exception is java.sql.SQLException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.在mysql中设置了下时区:set global time_zone='+8:00';&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring.mvc.view.prefix=/view/

spring.mvc.view.suffix=.jsp
mybatis.type-aliases-package=com.example.model

spring.datasource.driverClassName = com.mysql.cj.jdbc.Driver
spring.datasource.url = jdbc:mysql://localhost:3306/mybatis
spring.datasource.username = root
spring.datasource.password = 123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;七、创建页面显示&lt;/p&gt;
&lt;p&gt;这里还是按照上一博客用jsp显示数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;&lt;span&gt;
    pageEncoding&lt;/span&gt;=&quot;utf-8&quot;%&amp;gt;
&amp;lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;名字&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;性别&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;c:forEach items=&quot;${users}&quot; var=&quot;item&quot;&amp;gt;
            &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;${item.name}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;${item.age}&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;${item.sex}&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
        &amp;lt;/c:forEach&amp;gt;
     &amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 八、测试&lt;/p&gt;
&lt;p&gt;这里先在浏览器打开http://localhost:8080/user/alluser.do，可以看到用户列表,然后输入http://localhost:8080/user/insert.do，就会看到列表显示多了一行数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733213/201807/733213-20180711000753024-674290465.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;九、小结&lt;/p&gt;
&lt;p&gt;使用基于注解的集成mybatis比较省事方便，但有利有弊，对于多表相连的可能就不太方便，使用基于xml配置的可能就更会好些。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 16:10:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9292201.html</dc:identifier>
</item>
<item>
<title>男程序猿和女程序猿的网恋（一） - 56899◎か</title>
<link>http://www.cnblogs.com/qy1234/p/9292178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qy1234/p/9292178.html</guid>
<description>&lt;p&gt;       &lt;span&gt;我和他2016年的相识，相知，相恋，相见……&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;      ①相识&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      我记得自己是在技术群里求助问题，他帮我解答 &lt;img src=&quot;file:///C:/Users/25339/AppData/Local/Temp/))%7D%7B%5D~4Q@X%25JX_2@ETY7JF7.png&quot; alt=&quot;&quot;/&gt;，我并不能理解，就私聊他，他热情帮我解答，这样一来二去，我们变成志同道合的朋友……&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;      ②相知 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;      我在北京，我做HIS系统，他在重庆，他做MES系统，我们都是计算机专业才出来的实习生；之后我们在交流中，知道他的爱好喜欢收藏鞋，摄影，口琴，高达模型，喜欢看书，给我塑造一个文艺小青年程序猿，让我更有兴趣了解他。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     之后我们谈论更多的话题是技术问题，大多数都是我不会，他教我，而且很有耐心。有时间他晚上用QQ分享屏幕给我讲课，给我补习我的编程知识，还有一次给我讲解凌晨2点多。那段时间我特感谢他，因工作我自己单独负责一个项目有很多不懂都是他教我。慢慢我把生活中发生事，自己的照片分享给他。&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;      ③相恋&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      我们在网上相识二个月多，平安夜前一天，他跟我说，他每次出去都是看到成双成对的情侣，很羡慕；我们俩都是单身，要不我们在一起吧，做我的女朋友吧&lt;img src=&quot;file:///C:/Users/25339/AppData/Local/Temp/2T5E)$9%7BR%5D_)R31DF0Y7OA3.png&quot; alt=&quot;&quot;/&gt;。 我当时愣一下，就在QQ消息屏幕上打一个好字，发给了他。这样我们就相恋了……&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      我们开启恋爱模式，每天晚上睡前一个电话，互道晚安&lt;img src=&quot;file:///C:/Users/25339/AppData/Local/Temp/2T5E)$9%7BR%5D_)R31DF0Y7OA3.png&quot; alt=&quot;&quot;/&gt;，我们之间爱称呼宝宝，大宝贝。在这期间，我们互赠礼物&lt;img src=&quot;file:///C:/Users/25339/AppData/Local/Temp/NHQR%25X4M9%5B$(8ZBMUW2(%25KW.png&quot; alt=&quot;&quot;/&gt;，我收到最感触最深的礼物，是他给写我一封信和一本书，信中的内容透露真诚和心意，从那次让我内心更加坚定就是他了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       从前车马很慢，书信很远，人生中只够爱一个人。&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;      ④相见&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      放年假期间，他对我说，我们见面吧，在那段时间，每天晚上电话都关于我们见面事，这意味着网恋要奔现。我们商讨结果是，过完元宵节，我们就见面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     他长什么样子呢？应该是个很可爱的男孩纸吧，我要穿什么去呢？想着看了看胖胖的自己，不行，得减肥呀.........&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:53:00 +0000</pubDate>
<dc:creator>56899◎か</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qy1234/p/9292178.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之服务间的调用方式（REST and RPC） - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/microservice_communication_rest_and_rpc_foundation.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/microservice_communication_rest_and_rpc_foundation.html</guid>
<description>&lt;h2&gt;1.1 REST &amp;amp; RPC&lt;/h2&gt;
&lt;p&gt;　　微服务之间的接口调用通常包含两个部分，序列化和通信协议。常见的序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等；通信比较流行的是http、soap、websockect，RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift。&lt;/p&gt;
&lt;p&gt;　　REST：严格意义上说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在URL上,但是不严格的说Http+json、Http+xml，常见的http api都可以称为Rest接口。&lt;/p&gt;
&lt;p&gt;　　RPC：即我们常说的远程过程调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式。&lt;/p&gt;
&lt;h2&gt;1.2 HTTP vs 高性能二进制协议&lt;/h2&gt;
&lt;p&gt;　　HTTP相对更规范，更标准，更通用，无论哪种语言都支持HTTP协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，相应的，如果采用HTTP，无疑在你实现SDK之前，支持了所有语言，所以，现在开源中间件，基本最先支持的几个协议都包含RESTful。&lt;/p&gt;
&lt;p&gt;　　RPC协议性能要高的多，例如Protobuf、Thrift、Kyro等，（如果算上序列化）吞吐量大概能达到http的二倍。响应时间也更为出色。千万不要小看这点性能损耗，公认的，微服务做的比较好的，例如，netflix、阿里，曾经都传出过为了提升性能而合并服务。如果是交付型的项目，性能更为重要，因为你卖给客户往往靠的就是性能上微弱的优势。&lt;/p&gt;
&lt;p&gt;　　所以，最佳实践一般是对外REST，对内RPC，但是追求极致的性能会消耗很多额外的成本，所以一般情况下对内一般也REST，但对于个别性能要求较高的接口使用RPC。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710224328801-157607830.png&quot; alt=&quot;&quot; width=&quot;498&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里假设有两个服务，一个ClinetService和一个PaymentService，其中PaymentService有两部分，一部分是基于REST风格的WebApi部分，它主要是负责一些对性能没有要求的查询服务，另一部分是基于TCP的RPC Server，它主要是负责一些对性能要求高的服务，比如支付和支出等涉及到钱的接口。假设User在消费ClientService时需要调用PaymentService根据客户账户获取Payment History（走REST）以及进行交易事务操作（走RPC）。&lt;/p&gt;

&lt;h2&gt;3.1 一个好用的REST Client : WebApiClient&lt;/h2&gt;
&lt;p&gt;　　使用过Java Feign Client的人都知道，一个好的声明式REST客户端可以帮我们省不少力。在.NET下，园子里的大大老九就写了一款类似于Feign Client的REST Client：WebApiClient。WebApiClient是开源在github上的一个httpClient客户端库，内部基于HttpClient开发，是一个只需要定义C#接口(interface)，并打上相关特性，即可异步调用http-api的框架 ，支持.net framework4.5+、netcoreapp2.0和netstandard2.0。它的GitHub地址是：&lt;a href=&quot;https://github.com/dotnetcore/WebApiClient&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/WebApiClient&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如何安装？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;NuGet&amp;gt;Install-Package WebApiClient-JIT　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3.2 使用实例：走API Gateway&lt;/h2&gt;
&lt;p&gt;　　Step1.定义HTTP接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [HttpHost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://yourgateway:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPaymentWebApi: IHttpApi
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/paymentservice/history/edisonzhou
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Return 原始string内容&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/paymentservice/history/{account}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        ITask&lt;/span&gt;&amp;lt;IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; GetPaymentHistoryByAccountAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; account);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里需要注意的是，由于我们要走API网关，所以这里定义的HttpHost地址是一个假的，后面具体调用时会覆盖掉，但是这里必须写上一个，不然无法使用。&lt;/p&gt;
&lt;p&gt;　　Step2.在Controller中即可异步调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; gatewayUrl;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PaymentController(IConfiguration _configuration)
        {
            gatewayUrl &lt;/span&gt;= _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Gateway:Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];&lt;/span&gt;&lt;span&gt;
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{account}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; account)
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = HttpApiClient.Create&amp;lt;IPaymentWebApi&amp;gt;&lt;span&gt;(gatewayUrl))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; historyList = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; client.GetPaymentHistoryByAccountAsync(account);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; other business logic code here
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; historyList;
            }
        }&lt;br/&gt;　　}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里PaymentService的实现很简单，就是返回了一个String集合：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/history/{account}&lt;/span&gt;
    [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{account}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; account)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; some database logic
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......&lt;/span&gt;
        IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; historyList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-10,10000RMB,Chengdu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-11,11000RMB,Chengdu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-12,12000RMB,Beijing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-13,10030RMB,Chengdu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-06-20,10400RMB,HongKong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        };

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; historyList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终调用结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710230737071-1205127120.png&quot; alt=&quot;&quot; width=&quot;636&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.3 使用实例：直接访问具体服务&lt;/h2&gt;
&lt;p&gt;　　在服务众多，且单个服务就部署了多个实例的情况下，我们可以通过API网关进行中转，但是当部分场景我们不需要通过API网关进行中转的时候，比如：性能要求较高，负载压力较小单个实例足够等，我们可以直接与要通信的服务进行联接，也就不用从API网关绕一圈。&lt;/p&gt;
&lt;p&gt;　　Step1.改一下HTTP接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [HttpHost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://paymentservice:8880&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPaymentDirectWebApi: IHttpApi
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/paymentservice/history/edisonzhou
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Return 原始string内容&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/history/{account}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        ITask&lt;/span&gt;&amp;lt;IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; GetPaymentHistoryByAccountAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; account);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同理，这里的HttpHost也是后面需要被覆盖的，原因是我们将其配置到了配置文件中。&lt;/p&gt;
&lt;p&gt;　　Step2.改一下调用代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentController : Controller
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; gatewayUrl;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; paymentServiceUrl;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PaymentController(IConfiguration _configuration)
        {
            gatewayUrl &lt;/span&gt;= _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Gateway:Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
            paymentServiceUrl &lt;/span&gt;= _configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PaymentService:Uri&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{account}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IList&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; account)
        {
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; v2 directly call PaymentService
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; client = HttpApiClient.Create&amp;lt;IPaymentDirectWebApi&amp;gt;&lt;span&gt;(paymentServiceUrl))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; historyList = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; client.GetPaymentHistoryByAccountAsync(account);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; other business logic code here
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ......&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; historyList;
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终调用结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710231405212-1563820380.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;77&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.1 Thrift简介&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710234838364-998152126.png&quot; alt=&quot;&quot; width=&quot;169&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Thrift是一个软件框架，用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在 C++, Java, Go,Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 这些编程语言间无缝结合的、高效的服务。&lt;/p&gt;
&lt;p&gt;　　当然，还有gRPC也可以选择，不过从网上的性能测试来看，Thrift性能应该优于gRPC 2倍以上，但是gRPC的文档方面要比Thrift友好很多。&lt;/p&gt;
&lt;h2&gt;4.2 Thrift的使用&lt;/h2&gt;
&lt;p&gt;　　（1）下载Thrift （这里选择Windows版）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710232718419-1766913486.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;132&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下载完成后解压，这里我将其改名为thrift.exe（去掉了版本号），一会在命令行敲起来更方便一点。&lt;/p&gt;
&lt;p&gt;　　（2）编写一个PaymentService.thrift，这是一个IDL中间语言&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; csharp Manulife.DNC.MSAD.Contracts

service PaymentService { 
    TrxnResult Save(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;:TrxnRecord trxn) 
}

&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; TrxnResult { 
    SUCCESS &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, 
    FAILED &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, 
}

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; TrxnRecord { 
    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;: required i64 TrxnId; 
    &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;: required &lt;span&gt;string&lt;/span&gt;&lt;span&gt; TrxnName; 
    &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;: required i32 TrxnAmount; 
    &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;: required &lt;span&gt;string&lt;/span&gt;&lt;span&gt; TrxnType; 
    &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;: optional &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Remark; 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）根据thrift语法规则生成C#代码&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;cmd&amp;gt;thrift.exe -gen csharp PaymentService.thrift&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710233503108-1882170811.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;91&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（4）创建一个Contracts类库项目，将生成的C#代码放进去&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710233556043-961738382.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;132&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.3 增加RPC Server&lt;/h2&gt;
&lt;p&gt;　　（1）新增一个控制台项目，作为我们的Payment Service RPC Server，并引用Contracts类库项目&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710233658171-1696240877.png&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（2）引入thrift-netcore包：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;NuGet&amp;gt;Install-Package apache-thrift-netcore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　（3）加入一个新增的PaymentService实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PaymentServiceImpl : Manulife.DNC.MSAD.Contracts.PaymentService.Iface
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TrxnResult Save(TrxnRecord trxn)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; some business logic here
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread.Sleep(1000 * 1);&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Log : TrxnName:{0}, TrxnAmount:{1}, Remark:{2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, trxn.TrxnName, trxn.TrxnAmount, trxn.Remark);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TrxnResult.SUCCESS;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里输出日志仅仅是为了测试。&lt;/p&gt;
&lt;p&gt;　　（4）编写启动RPC Server的主程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;8885&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Welcome] PaymentService RPC Server is lanuched...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            TServerTransport transport &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TServerSocket(port);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt; Manulife.DNC.MSAD.Contracts.PaymentService.Processor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentServiceImpl());
            TServer server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TThreadedServer(processor, transport);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lanuch&lt;/span&gt;
&lt;span&gt;            server.Serve();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（5）如果是多个服务实现的话，也可以如下这样启动：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Welcome] PaymentService RPC Server is lanuched...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        TServerTransport transport &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TServerSocket(port);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; processor1 = &lt;span&gt;new&lt;/span&gt; Manulife.DNC.MSAD.Contracts.PaymentService.Processor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentServiceImpl());
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; processor2 = &lt;span&gt;new&lt;/span&gt; Manulife.DNC.MSAD.Contracts.PayoutService.Processor(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PayoutServiceImpl());
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; processorMulti = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thrift.Protocol.TMultiplexedProcessor();
        processorMulti.RegisterProcessor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, processor1);
        processorMulti.RegisterProcessor(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, processor2);
        TServer server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TThreadedServer(processorMulti, transport);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lanuch&lt;/span&gt;
&lt;span&gt;        server.Serve();
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.4 调用RPC&lt;/h2&gt;
&lt;p&gt;　　在ClientService中也引入apache-thrift-netcore包，然后在调用的地方修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [HttpPost]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Post([FromBody]TrxnRecordDTO trxnRecordDto)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RPC - use Thrift&lt;/span&gt;
        &lt;span&gt;using&lt;/span&gt; (TTransport transport = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TSocket(
            configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PaymentService:RpcIP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;], 
            Convert.ToInt32(configuration[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PaymentService:RpcPort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])))
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (TProtocol protocol = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TBinaryProtocol(transport))
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; serviceClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PaymentService.Client(protocol))
                {
                    transport.Open();
                    TrxnRecord record &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrxnRecord
                    {
                        TrxnId &lt;/span&gt;=&lt;span&gt; GenerateTrxnId(), 
                        TrxnName &lt;/span&gt;=&lt;span&gt; trxnRecordDto.TrxnName,
                        TrxnAmount &lt;/span&gt;=&lt;span&gt; trxnRecordDto.TrxnAmount,
                        TrxnType &lt;/span&gt;=&lt;span&gt; trxnRecordDto.TrxnType,
                        Remark &lt;/span&gt;=&lt;span&gt; trxnRecordDto.Remark
                    };
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; serviceClient.Save(record);

                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToInt32(result) == &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trxn Success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Trxn Failed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; GenerateTrxnId()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;10000001&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终测试结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201807/381412-20180710234425667-447571778.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本篇简单的介绍了下微服务架构下服务之间调用的两种常用方式：REST与RPC，另外前面介绍的基于消息队列的发布/订阅模式也是服务通信的方式之一。本篇基于WebApiClient这个开源库介绍了如何进行声明式的REST调用，以及Thrift这个RPC框架介绍了如何进行RPC的通信，最后通过一个小例子来结尾。最后，服务调用的最佳实践一般是对外REST，对内RPC，但是追求极致的性能会消耗很多额外的成本，所以一般情况下对内一般也REST，但对于个别性能要求较高的接口使用RPC。&lt;/p&gt;

&lt;p&gt;远方的行者，《&lt;a href=&quot;https://blog.csdn.net/king866/article/details/54174665&quot; target=&quot;_blank&quot;&gt;微服务 RPC和REST&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;杨中科，《&lt;a href=&quot;https://pan.baidu.com/s/1rSJgOdNEgo3mhPNqmyXrRw&quot; target=&quot;_blank&quot;&gt;.NET Core微服务课程：Thrift高效通讯&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;醉眼识朦胧，《&lt;a href=&quot;https://www.cnblogs.com/fingerboy/p/6424248.html&quot;&gt;Thrift入门初探--thrift安装及java入门实例&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;focus-lei，《&lt;a href=&quot;https://www.cnblogs.com/focus-lei/p/8889389.html&quot;&gt;.net core下使用Thrift&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;宝哥在路上，《&lt;a href=&quot;https://blog.csdn.net/code52/article/details/21015361&quot; target=&quot;_blank&quot;&gt;Thrift性能测试与分析&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:51:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/microservice_communication_rest_and_rpc_foundation.html</dc:identifier>
</item>
<item>
<title>Go语言包管理工具dep - Summer7C</title>
<link>http://www.cnblogs.com/Summer7C/p/9292125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer7C/p/9292125.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是dep？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;dep和go，在一定程度上相当于maven之于Java，composer之于PHP，dep是go语言官方的一个包管理工具。&lt;/p&gt;
&lt;p&gt;相比较go get而言，dep可以直接给引入的第三方包一个专门的目录，并且可以专门制定一个配置文件，控制go项目所引入的包，版本以及其他依赖关系。&lt;/p&gt;
&lt;p&gt;dep这个项目放在golang官方的github中：https://github.com/golang/dep&lt;/p&gt;
&lt;p&gt;官方对于dep的解释是：&lt;code&gt;dep&lt;/code&gt; is the official &lt;em&gt;experiment&lt;/em&gt;, but not yet the official tool. 也就是说，dep目前还处于试验阶段，还并没有成为一个官方意义上的工具。毕竟go语言还很年轻，但是这也充分的证明了go语言的生态圈十分丰富。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装dep工具的方式有很多种，如果是mac电脑的话，只需要如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
brew &lt;span&gt;install&lt;/span&gt; dep
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于Linux和类Unix系统而言，我们还可以使用如下方式安装dep：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/golang/dep/master/install.sh | sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者直接使用源码安装。&lt;/p&gt;
&lt;p&gt;而对于windows电脑，可能会相对来说麻烦些，我们可以直接使用源码编译安装或者直接使用go get命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
go get -u github.com/golang/dep/cmd/dep
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;待安装完成之后，将dep.exe放在环境变量就可以使用了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来我们来看一下dep的使用方式。&lt;/p&gt;
&lt;p&gt;当安装好dep之后，我们在命令行中，输入dep就可以看到有关dep的命令了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Dep is a tool &lt;span&gt;for&lt;/span&gt; managing dependencies &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Go projects

Usage: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dep [command]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

Commands:

  init     Set up a new Go project, or migrate an existing one
  status   Report the status of the project&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s dependencies&lt;/span&gt;
  ensure   Ensure a dependency is safely vendored &lt;span&gt;in&lt;/span&gt;&lt;span&gt; the project
  version  Show the dep version information

Examples:
  dep init                               set up a new project
  dep ensure                             &lt;/span&gt;&lt;span&gt;install&lt;/span&gt; the project&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s dependencies&lt;/span&gt;
  dep ensure -&lt;span&gt;update                     update the locked versions of all dependencies
  dep ensure &lt;/span&gt;-add github.com/pkg/&lt;span&gt;errors  add a dependency to the project

Use &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dep help [command]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;more&lt;/span&gt; information about a command.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看出来，dep一般进场会使用3个命令：&lt;/p&gt;
&lt;p&gt;init-用来初始化项目&lt;/p&gt;
&lt;p&gt;status-用来查看当前项目的依赖包的状态&lt;/p&gt;
&lt;p&gt;ensure-用来同步包的配置文件和引入的包&lt;/p&gt;
&lt;p&gt;下面我们正式使用dep来创建一个项目。首先建立一个项目路径，这里我们将项目路径叫做depProject。然后在项目路径中建立src源代码目录。在src中建立一个存放dep文件和项目主文件的目录，我们暂且可以叫做depmain，并建立一个go文件。&lt;/p&gt;
&lt;p&gt;这样我们的目录结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;depProject
    &lt;/span&gt;|----&lt;span&gt;src
          &lt;/span&gt;|----&lt;span&gt;depmain
                  &lt;/span&gt;|-----main.go
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立好之后，我们在main.go中写一个简单的go程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &quot;fmt&quot;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     fmt.Println(&quot;hello)
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后我们在这个目录下运行如下命令：&lt;/p&gt;

&lt;p&gt;运行完成之后，dep就会为我们自动生成如下文件和目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/789559/201807/789559-20180710232122471-1304835388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有点像常规go项目的样子了，不过需要注意的是pkg中存放的go语言引入包的缓存文件，vendor中存放的是真正的引入的包内容。接下来是两个文件，Gopkg.lock和Gopkg.toml。Gopkg.lock文件是自动生成的，而Gopkg.toml文件是我们可以编辑的文件，通过编辑这个文件，并运行dep的命令可以达到引入包的目的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 必需包
required = [&quot;github.com/gin-gonic/gin&quot;]
# 忽略包
#ignored = []没有可以不写
# 项目元数据
#[metadata]


# 约束条件
[[constraint]]
  # name = 
  # 可选：版本
  # version =
  # 分支
  # branch
  # 修订
  # revision
  # 可选：指定来源
  # source = &quot;github.com/gin-gonic/gin&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码是一个示例，我们写好之后运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dep ensure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就可以了，我们会看到vendor下多了一些有关此包的依赖和引入。&lt;/p&gt;
&lt;p&gt;我们引入了gin框架的包，所以我们现在就可以使用gin框架了，写的时候，和我们平时的go语言项目一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; main
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; &quot;github.com/gin-gonic/gin&quot;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;func main() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     r :=&lt;span&gt; gin.Default()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     r.GET(&quot;/ping&quot;, func(c *&lt;span&gt;gin.Context) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         c.JSON(200&lt;span&gt;, gin.H{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &quot;message&quot;: &quot;pong&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        })
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     r.Run() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; listen and serve on 0.0.0.0:8080&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做完全没有问题，我们只用考虑这个包原本的路径github.com/gin-gonic/gin就好。&lt;/p&gt;
&lt;p&gt;接下来我们就可以编译运行这个项目了。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，使用dep管理包控制依赖的时候，如果我们需要新建目录，并编写自己的新的包名的时候，只需要在src下新建目录就可以了。这样做才能正确引入。&lt;/p&gt;
&lt;p&gt;比如：我们要编写一个add的函数，我们可以这样，在src下简历一个utils目录，下写个add.go文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; utils
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; func Add(a &lt;span&gt;int&lt;/span&gt;, b &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;int&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; a+&lt;span&gt;b
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在主程序中，这样写就可以import自己写的包，并使用自己的函数了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; main

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
    &lt;/span&gt;&quot;utils&quot;
    &quot;fmt&quot;&lt;span&gt;
)
func main() {
    fmt.Println(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;)
    utils.Add(&lt;/span&gt;1, 1&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 10 Jul 2018 15:36:00 +0000</pubDate>
<dc:creator>Summer7C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Summer7C/p/9292125.html</dc:identifier>
</item>
<item>
<title>函数式编程之Partial application - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9291920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9291920.html</guid>
<description>&lt;p&gt;上一篇关于Currying的介绍，我们提到F#是如何做Currying变换的：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let addWithThreeParameters x y z = x + y + z
let intermediateFn1 = addWithThreeParameters 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给定一个接受三个参数的函数&lt;code&gt;addWithThreeParameters&lt;/code&gt;，我们通过&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let intermediateFn1 = addWithThreeParameters 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的方式创建出了一个新的函数&lt;code&gt;intermediateFn1&lt;/code&gt;，其函数签名为：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;int -&amp;gt; int -&amp;gt; int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是F#用来描述函数签名的方式，它表示函数接受两个int类型的参数，返回类型为int类型。&lt;br/&gt;类似地：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;(int -&amp;gt; int) -&amp;gt; int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示参数为&lt;code&gt;(int -&amp;gt; int)&lt;/code&gt;类型的函数，返回类型为int；而&lt;code&gt;(int -&amp;gt; int)&lt;/code&gt;又是一个函数，表示接受一个int类型的参数，返回类型仍然为int。&lt;/p&gt;
&lt;p&gt;对于F#而言，函数本身需要接受三个参数，但是我们调用的时候只给一个参数，从而创建出接受两个参数的新函数，这种方式被称作是&lt;code&gt;Partial application&lt;/code&gt;。也就是说我们通过&lt;code&gt;Partial application&lt;/code&gt;的方式完成了Currying。&lt;br/&gt;&lt;code&gt;Partial application&lt;/code&gt;是常用的函数式编程风格，对于初学者而言也很重要。我们在Currying一节介绍过Curring的目的是为了生成一个只接受一个参数的新函数，从而可以将两个函数粘结在一起。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180710-214351@2x.png&quot;/&gt;&lt;br/&gt;那么&lt;code&gt;Partial application&lt;/code&gt;就是F#完成Curring的一种手段。&lt;/p&gt;
&lt;p&gt;还记得C#版本的Currying吗？我们是通纯手工方式创建了新的Currying函数。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Func&amp;lt;int, int&amp;gt; AddWithTwoParameters(int x)
{
    Func&amp;lt;int, int&amp;gt; subFunction = y =&amp;gt; x + y;

    return subFunction;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在C#里面函数式没法通过只传递一个参数的方式来生成一个新的函数，在C#中声明一个三个参数的函数，调用的时候只传入一个参数会编译出错，这是众所周知的。&lt;br/&gt;当然，非要用C#演示&lt;code&gt;Partial application&lt;/code&gt;，我们可以用一种不自然的方式来做到：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static Func&amp;lt;T2, T3, TR&amp;gt; Apply&amp;lt;T1, T2, T3, TR&amp;gt;
(Func&amp;lt;T1, T2, T3, TR&amp;gt; function, T1 arg1)
{
    return (arg2, arg3) =&amp;gt; function(arg1, arg2, arg3);
}

//调用
Func&amp;lt;int, int, int&amp;gt; add = (a, b) =&amp;gt; a + b;
var add5 = Apply(add, 5);
var add51 = add5(1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F#是这样做的：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let add5 = (+) 5    // partial application
let add51= add5 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说&lt;code&gt;Partial application&lt;/code&gt;还可以用C#来勉强实现，后面描述的函数式特性几乎不会出现在OO风格的代码里，所以后面的章节大都会以F#来演示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Partial application&lt;/code&gt;之所以在函数式编程中占有很重要的地位，他不仅仅能够完成Curring变换，还可以将函数变成一个可重用的组件，考虑下面的代码：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;[1;2;3] |&amp;gt; List.map add51 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将&lt;code&gt;add51&lt;/code&gt;这个新函数应用到了[1;2;3]这个list中的每个元素中。&lt;br/&gt;下面的这个例子更复杂一些，用来演示通过&lt;code&gt;Partial application&lt;/code&gt;来完成OO范式中的&lt;code&gt;Dependency Injection&lt;/code&gt;功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个函数(add)用来把两个数字加起来 ，除此之外，还要将运算过程记录成log&lt;/li&gt;
&lt;li&gt;Logging函数是一个接受两个参数的函数，分别为string和一个泛类型`a，返回类型为unit，所以logging函数的签名为string-&amp;gt;'a-&amp;gt;unit&lt;/li&gt;
&lt;li&gt;Logging函数有多种不同类型的实现，例如console logger，file logger&lt;br/&gt;你可以认为logging函数是拥有一个契约(string-&amp;gt;'a-&amp;gt;unit)的接口，对应的实现可以有多个&lt;/li&gt;
&lt;li&gt;如何把具体的logger 注入到add函数中？&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;//创建一个调用add函数，并且可以注入logger实现的函数
let addWithPluggableLogger logger x y =
    let result = x + y
    logger &quot;x+y&quot;  result 
    result 

// 创建一个consoleLogger
let consoleLogger argName argValue = 
    printfn &quot;%s=%A&quot; argName argValue 

//把addWithConsoleLogger做partial应用，把consoleLogger应用在上面，同时创建出一个具有添加log能力
//的add函数，他的函数签名为`int -&amp;gt; int -&amp;gt; int`，跟普通的add函数式一致的，
//但是此刻他拥有了添加log的能力: 
let addWithConsoleLogger = addWithPluggableLogger consoleLogger 
addWithConsoleLogger  1 2 
addWithConsoleLogger  42 99&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也许你已经看出来函数参数的顺序决定能否&lt;code&gt;Partial application&lt;/code&gt;, 因为在做&lt;code&gt;Partial&lt;/code&gt;应用的时候总是按照参数从左到右的顺序执行的，你无法把一个参数应用在函数的最后一个位置。&lt;br/&gt;下节将会描述如何设计函数让其能够支持&lt;code&gt;Partial application&lt;/code&gt;，以及F#中的管道符&lt;code&gt;|&amp;gt;&lt;/code&gt;的用法。想学习函数式编程的同学可以持续关注。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:32:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9291920.html</dc:identifier>
</item>
</channel>
</rss>