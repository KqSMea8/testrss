<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据结构-堆的定义描述 - IDreamo</title>
<link>http://www.cnblogs.com/idreamo/p/8545328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/idreamo/p/8545328.html</guid>
<description>&lt;h3&gt;堆是什么？&lt;/h3&gt;
&lt;p&gt;它是一种树形组织，使我们能迅速确定包含最大值（或最小值）的结点。&lt;/p&gt;
&lt;p&gt;具体来说，堆是一颗左平衡的二叉树。随着结点的增加，树会逐级从左到右增长。&lt;/p&gt;
&lt;p&gt;（左平衡是指，如果一棵平衡树的最后一层的所有叶子结点都在最靠左边的位置上，则称这棵树是左平衡的。）&lt;/p&gt;
&lt;h3&gt;顺序特点&lt;/h3&gt;
&lt;p&gt;堆状态的二叉树是“局部有序”的，任何一个结点与其兄弟结点之间都没有必然的顺序关系，但它与其父子结点有大小顺序关系。&lt;/p&gt;
&lt;h3&gt;堆的分类&lt;/h3&gt;
&lt;p&gt;最大值堆：子结点比父结点小，根结点是树中最大的结点。&lt;/p&gt;
&lt;p&gt;最小值堆：子结点比父结点大，根结点是树中最小的结点。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;表示方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于堆来讲，比较好的表示左平衡二叉树的方式是，将结点通过“层级（水平）遍历”的方式连续存储到一个数组中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设ｉ是树中的某一结点，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    其父结点位于(i-1)/2处（忽略小树部分）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    左子结点位于2i+1处；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    右子结点位于2i+2处；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样的组织结构或方式对于堆来说非常重要，通过它我们能迅速定义堆的最后一个结点，最后一个结点指处于树中最深层最右端的结点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1281268/201803/1281268-20180313061608654-1496188858.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 12 Mar 2018 22:19:00 +0000</pubDate>
<dc:creator>IDreamo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/idreamo/p/8545328.html</dc:identifier>
</item>
<item>
<title>haproxy实现会话保持(1):cookie - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8553190.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8553190.html</guid>
<description>&lt;p&gt;既然进来了，不妨点个赞鼓励下我吧！谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html#blog1&quot;&gt;&lt;span&gt;1. 反向代理为什么需要设置cookie&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html#blog2&quot;&gt;&lt;span&gt;2.haproxy设置cookie的几种方式&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html#blog2.1&quot;&gt;&lt;span&gt;2.1 cookie insert&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html#blog2.2&quot;&gt;&lt;span&gt;2.2 cookie prefix&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html#blog2.2&quot;&gt;&lt;span&gt;2.3 cookie rewrite&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html#blog3&quot;&gt;&lt;span&gt;3.haproxy如何使用cookie实现会话保持以及如何忽略会话保持&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;任何一个七层的http负载均衡器，都应该具备一个功能：会话保持。会话保持是保证客户端对动态应用程序正确请求的基本要求。&lt;/p&gt;
&lt;p&gt;还是那个被举烂了却最有说服力的例子：客户端A向服务端B请求将C商品加入它的账户购物车，加入成功后，服务端B会在某个缓存区域中记录下客户端A和它的商品C，这个缓存的内容就是session上下文环境。而识别客户端的方式一般是设置session ID(如PHPSESSID、JSESSIONID)，并将其作为cookie的内容交给客户端。客户端A再次请求的时候(比如将购物车中的商品下订单)只要携带这个cookie，服务端B就可以从中获取到session ID并找到属于客户端A的缓存内容(商品C)，也就可以继续执行下订单部分的代码。&lt;/p&gt;
&lt;p&gt;假如这时使用负载均衡软件对客户端的请求进行负载，就必须要保证能将客户端A的请求再次引导到服务端B，而不能引导到服务端X、服务端Y，因为X、Y上并没有缓存和客户端A对应的session内容，也就无法为客户端A下订单。&lt;/p&gt;
&lt;p&gt;因此，反向代理软件必须具备将客户端和服务端&quot;绑定&quot;的功能，也就是所谓的提供会话保持，让客户端A后续的请求一定转发到服务端B上。&lt;/p&gt;
&lt;p&gt;这里讨论的对象是http的动态应用请求，它要求会话保持。更通用地，只要负载均衡软件负载的不是&quot;无状态&quot;的协议或服务，就应该提供会话保持能力，除非它是四层负载软件。&lt;/p&gt;
&lt;p&gt;haproxy提供了3种实现会话保持的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).源地址hash;&lt;/li&gt;
&lt;li&gt;(2).设置cookie;&lt;/li&gt;
&lt;li&gt;(3).会话粘性表stick-table;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文只讨论haproxy在设置cookie上实现会话保持的方式，stick-table会话粘性的方式则在下一篇文章中单独讨论。而源地址hash是一种负载调度算法，没什么可讨论的，而且除非实在没办法，不建议使用这种调度算法。&lt;/p&gt;


&lt;p&gt;设置cookie的方式是通过在配置文件中使用cookie指令进行配置的。由于haproxy设置cookie的目的是为了将某客户端引导到之前为其服务过的后端服务器上，简单地说，就是和后端某服务器保持联系，因此cookie指令不能设置在frontend段落。&lt;/p&gt;
&lt;p&gt;首先看一个设置cookie的示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;backend dynamic_servers
    cookie app_cook  &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt;  nocache
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app1      &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.22:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie server1
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app2      &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.23:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie server2&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例配置中，&lt;code&gt;cookie&lt;/code&gt;指令中指定的是insert命令，表示在将响应报文交给客户端之前，先插入一个属性名为&quot;app_cook&quot;的cookie，这个cookie在响应报文的头部将独占一个&quot;Set-Cookie&quot;字段(因为是插入新cookie)，而&quot;app_cook&quot;只是cookie名称，它的值是由server指令中的cookie选项指定的，这里是&quot;server1&quot;或&quot;server2&quot;。&lt;/p&gt;
&lt;p&gt;因此，如果这个请求报文分配给后端app2时，响应给客户端的响应报文中&lt;span&gt;&lt;strong&gt;haproxy设置的&lt;/strong&gt;&lt;/span&gt;&quot;Set-Cookie&quot;字段的样式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Set&lt;/span&gt;-Cookie:app_cook=server2;&lt;/span&gt; path=/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了insert命令，cookie指令中还支持rewrite和prefix两种设置cookie的方式，这三种cookie的操作方式只能三选一。此外，还提供一些额外对cookie的功能设置。&lt;/p&gt;
&lt;p&gt;首先看看指令的语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cookie &amp;lt;name&amp;gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ rewrite | insert | prefix ]&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ indirect ]&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ nocache ]&lt;/span&gt;
              &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ postonly ]&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ preserve ]&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ httponly ]&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ secure ]&lt;/span&gt;
              &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ domain &amp;lt;domain&amp;gt; ]&lt;/span&gt;* &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ maxidle &amp;lt;idle&amp;gt; ]&lt;/span&gt; &lt;span class=&quot;hljs-attr_selector&quot;&gt;[ maxlife &amp;lt;life&amp;gt; ]&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文详细分节讨论rewrite、insert、prefix的行为，并在讨论它们的时候会穿插说明indirect、nocache和preserve的行为，如果需要了解其他选项，请自翻官方手册。&lt;/p&gt;
&lt;p&gt;下图是后文实验时使用的环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312155114398-1140876194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中在后端提供的index.php内容大致如下，主要部分是&lt;span&gt;&lt;strong&gt;设置了名为&lt;code&gt;PHPSESSID&lt;/code&gt;的cookie&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;response from webapp 192.168.100.61&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&amp;lt;?php&lt;/span&gt;
        session_start();
        &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Server IP: &quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;font color=red&amp;gt;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$_SERVER&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;'SERVER_ADDR'&lt;/span&gt;].&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;/font&amp;gt;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;Server Name: &quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;font color=red&amp;gt;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$_SERVER&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;'SERVER_NAME'&lt;/span&gt;].&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;/font&amp;gt;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;SESSIONNAME: &quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;font color=red&amp;gt;&quot;&lt;/span&gt;.session_name().&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;/font&amp;gt;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;;
        &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;SESSIONID: &quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;font color=red&amp;gt;&quot;&lt;/span&gt;.session_id().&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;/font&amp;gt;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&amp;lt;br&amp;gt;&quot;&lt;/span&gt;;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt;    This keyword indicates that the persistence cookie will have &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt;
          be inserted &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; haproxy &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; responses &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; the client did &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt;

          already have a cookie that would have permitted it &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; access this
          &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt;. &lt;span class=&quot;hljs-keyword&quot;&gt;When&lt;/span&gt; used without the &lt;span class=&quot;hljs-string&quot;&gt;&quot;preserve&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;option&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; the &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt;
          emits a cookie &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; the same name, it will be remove &lt;span class=&quot;hljs-keyword&quot;&gt;before&lt;/span&gt;
          processing.  &lt;span class=&quot;hljs-keyword&quot;&gt;For&lt;/span&gt; this reason, this &lt;span class=&quot;hljs-keyword&quot;&gt;mode&lt;/span&gt; can be used &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;upgrade&lt;/span&gt;
          existing configurations running &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; the &lt;span class=&quot;hljs-string&quot;&gt;&quot;rewrite&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;mode&lt;/span&gt;. The cookie
          will &lt;span class=&quot;hljs-keyword&quot;&gt;only&lt;/span&gt; be a &lt;span class=&quot;hljs-keyword&quot;&gt;session&lt;/span&gt; cookie &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; will &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; be stored &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; the
          client&lt;span class=&quot;hljs-string&quot;&gt;'s disk. By default, unless the &quot;indirect&quot; option is added,
          the server will see the cookies emitted by the client. Due to
          caching effects, it is generally wise to add the &quot;nocache&quot; or
          &quot;postonly&quot; keywords (see below). The &quot;insert&quot; keyword is not
          compatible with &quot;rewrite&quot; and &quot;prefix&quot;.&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中大致说明了以下几个意思：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;该关键词表示，haproxy将在客户端没有cookie时(比如第一次请求)，在响应报文中插入一个cookie。&lt;/li&gt;
&lt;li&gt;当没有使用关键词&quot;preserve&quot;选项时，如果后端服务器设置了一个和此处名称相同的cookie，则首先删除服务端设置的cookie。&lt;/li&gt;
&lt;li&gt;该cookie只能作为会话保持使用，无法持久化到客户端的磁盘上(因为haproxy设置的cookie没有maxAge属性，无法持久保存，只能保存在浏览器缓存中)。&lt;/li&gt;
&lt;li&gt;默认情况下，除非使用了&quot;indirect&quot;选项，否则服务端可以看到客户端请求时的所有cookie信息。&lt;/li&gt;
&lt;li&gt;由于缓存的影响，建议加上&quot;nocache&quot;或&quot;postonly&quot;选项。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面使用例子来解释insert的各种行为。&lt;/p&gt;
&lt;p&gt;在haproxy如下配置后端。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;backend dynamic_group
    cookie app_cook &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; nocache
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.60:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server1
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server2&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用浏览器第一次访问&lt;code&gt;http://192.168.100.59/index.php&lt;/code&gt;时，响应结果和响应首部内容如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312172631838-569026518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以知道，这次浏览器的请求分配给了app2，而且响应首部中有两个&quot;Set-Cookie&quot;字段，其中带有PHPSESSID的cookie是app2服务器自身设置的，另一个是haproxy设置的，其名和其值为&quot;app_cook=app_server2&quot;。&lt;/p&gt;
&lt;p&gt;如果客户端再次访问(不关闭浏览器，cookie缓存还在)，请求头中将携带该cookie，haproxy发现了该cookie中&quot;app_cook=app_server2&quot;部分，知道这个请求要交给app_server2这个后端。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312160806274-1583786928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就实现了会话保持，保证被处理过的客户端能被分配到同一个后端应用服务器上。&lt;/p&gt;
&lt;p&gt;注意，&lt;span&gt;&lt;strong&gt;客户端在第一次收到响应后就会把cookie缓存下来&lt;/strong&gt;&lt;/span&gt;，以后每次&lt;code&gt;http://192.168.100.59/index.php&lt;/code&gt;(根据域名进行判断)都会从缓存中取出该cookie放进请求首部。这样haproxy一定会将其分配给app_server2，除非app_server2下线了。但即使如此，客户端还是会携带该cookie，只不过haproxy判断app_server2下线后，就为客户端重新分配app_server1，并设置&quot;app_cook=app_server1&quot;，该cookie会&lt;strong&gt;&lt;span&gt;替换客户端中的&quot;app_cook=app_server2&lt;/span&gt;&quot;&lt;/strong&gt;。下图是app2下线后分配给app1的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312164613193-2072314632.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但注意，&lt;span&gt;&lt;strong&gt;即使分配给了app1，PHPSESSID也不会改变(即app1设置的PHPSESSID无效)&lt;/strong&gt;&lt;/span&gt;，因为haproxy判断出这个重名cookie，会删除app1设置的PHPSESSID。因此上图中的PHPSESSID值和之前分配给app2时的PHPSESSID是一样的。&lt;/p&gt;
&lt;p&gt;这样一来，app1不是就无法处理该客户端的请求了吗？确实如此，但没办法，除非后端设置了session共享。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果将配置文件中的cookie名称也设置为PHPSESSID，即后端应用服务器和此处设置的cookie名称相同，那么haproxy将首先将后端的PHPSESSID删除，然后使用自己的值发送给客户端。也就是说，此时将只有一个&quot;Set-Cookie&quot;字段响应给客户端。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;backend dynamic_group
    cookie PHPSESSID &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; nocache
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.60:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server1
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server2&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312160353831-1869095456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，在cookie指令中绝对不能设置cookie名称和后端的cookie名称相同，否则后端就相当于&quot;盲人&quot;。例如此处的PHPSESSID，此时后端虽然认识PHPSESSID是自己发送出去的cookie名称，但是无法获取ID为&quot;app_server1&quot;的session上下文。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果不配合&quot;indirect&quot;选项&lt;/strong&gt;&lt;/span&gt;，服务端可以看到客户端请求时的所有cookie信息。如果配合&quot;indirect&quot;选项，则haproxy在将请求转发给后端时，将删除自己设置的cookie，使得后端只能看到它自己的cookie，这样对后端来说，整个过程是完全透明的，它不知道前面有负载均衡软件。&lt;/p&gt;
&lt;p&gt;重新修改haproxy的cookie指令，并修改nginx配置文件中日志格式，在其中加上&quot;$http_cookie&quot;变量，它表示请求报文中的cookie信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&lt;span class=&quot;hljs-title&quot;&gt;cookie&lt;/span&gt; app_cook insert nocache


log_format  main  &lt;span class=&quot;hljs-string&quot;&gt;'&lt;span class=&quot;hljs-variable&quot;&gt;$http_cookie&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$remote_addr&lt;/span&gt; - &lt;span class=&quot;hljs-variable&quot;&gt;$remote_user&lt;/span&gt; [&lt;span class=&quot;hljs-variable&quot;&gt;$time_local&lt;/span&gt;] &quot;&lt;span class=&quot;hljs-variable&quot;&gt;$request&lt;/span&gt;&quot; '&lt;/span&gt;
                  &lt;span class=&quot;hljs-string&quot;&gt;'&lt;span class=&quot;hljs-variable&quot;&gt;$status&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$body_bytes_sent&lt;/span&gt; &quot;&lt;span class=&quot;hljs-variable&quot;&gt;$http_referer&lt;/span&gt;&quot; '&lt;/span&gt;
                  &lt;span class=&quot;hljs-string&quot;&gt;'&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$http_user_agent&lt;/span&gt;&quot; &quot;&lt;span class=&quot;hljs-variable&quot;&gt;$http_x_forwarded_for&lt;/span&gt;&quot;'&lt;/span&gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端再次访问时，nginx的日志中将记录以下信息(只贴出了前几个字段)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-setting&quot;&gt;PHPSESSID=&lt;span class=&quot;hljs-value&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;47&lt;/span&gt;d0ina2m14gg67ovdf1d972d1; app_cook=app_server1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.59&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上&quot;indirect&quot;选项，再测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cookie app_cook &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; indirect nocache&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-setting&quot;&gt;PHPSESSID=&lt;span class=&quot;hljs-value&quot;&gt;bge3bh6sksu2ie91lsp8ep9oi2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.59&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果insert关键字配合&quot;preserve&quot;关键字&lt;/strong&gt;&lt;/span&gt;，那么当后端设置了cookie时，haproxy将强制保留该cookie，不做任何修改。也就是说，如果将haproxy的cookie名称也设置为PHPSESSID，那么客户端第一次请求时收到的响应报文中将只有一个&quot;Set-Cookie&quot;字段，且这个字段的值是后端服务器设置的，和haproxy无关。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当客户端和HAProxy之间存在缓存时，建议将insert配合nocache一起使用&lt;/strong&gt;&lt;/span&gt;，因为nocache确保如果需要插入cookie，则可缓存页面将被标记为不可缓存。这一点很重要，因为如果所有cookie都添加到可缓存的页面上，则所有客户都将从中间的缓存层获取页面，并且将共享同一个Cookie，从而导致某台后端服务器接收的流量远远超过其他客户端。&lt;/p&gt;


&lt;pre&gt;
&lt;code&gt;prefix    This keyword indicates that instead of relying on a dedicated
          cookie &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; the persistence, an existing one will be completed.
          This may be needed &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; some specific environments where the client
          does &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; support more than one single cookie &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; the application
          already needs it. In this case, whenever the server sets a cookie
          named &amp;lt;name&amp;gt;, it will be prefixed &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; the serve&lt;span class=&quot;hljs-string&quot;&gt;r's identifier
          and a delimiter. The prefix will be removed from all client
          requests so that the server still finds the cookie it emitted.
          Since all requests and responses are subject to being modified,
          this mode doesn'&lt;/span&gt;t work &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; tunnel mode. The &lt;span class=&quot;hljs-string&quot;&gt;&quot;prefix&quot;&lt;/span&gt; keyword &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt;
          &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; compatible &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;rewrite&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;insert&quot;&lt;/span&gt;. Note: it &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; highly
          recommended &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; to use &lt;span class=&quot;hljs-string&quot;&gt;&quot;indirect&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;prefix&quot;&lt;/span&gt;, otherwise server
          cookie updates would &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; be sent to clients.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大致意思是：haproxy将在已存在的cookie(例如后端应用服务器设置的)上添加前缀cookie值，这个前缀部分是server指令中的cookie设置的，代表的是&lt;span&gt;&lt;strong&gt;服务端标识符&lt;/strong&gt;&lt;/span&gt;。在客户端再次访问时，haproxy将会自动移除这部分前缀，使得服务端只能看到它自己发出的cookie。在一些特殊环境下，客户端不支持多个&quot;Set-Cookie&quot;字段，这时可以使用prefix。&lt;/p&gt;
&lt;p&gt;使用prefix的时候，&lt;span&gt;&lt;strong&gt;cookie指令设置的cookie名必须和后端设置的cookie一样(在本文的环境中是PHPSESSID)&lt;/strong&gt;&lt;/span&gt;，否则prefix模式下的haproxy不会对响应报文做任何改变。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;backend&lt;/span&gt; dynamic_group
    cookie PHPSESSID prefix
    server app1 &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.60:80&lt;/span&gt; cookie app_server1
    server app2 &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.61:80&lt;/span&gt; cookie app_server2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312233928846-1451517090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从后端nginx上的日志上查看haproxy转发过来的请求，可以看到前缀已经被haproxy去掉了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-setting&quot;&gt;PHPSESSID=&lt;span class=&quot;hljs-value&quot;&gt;oses71hjr64dl6lputpkmdpg12 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.59&lt;/span&gt; - -&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;pre&gt;
&lt;code&gt;rewrite   This keyword indicates that the cookie will be provided by the
          server &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; that haproxy will have to modify its value to set the
          serve&lt;span class=&quot;hljs-string&quot;&gt;r's identifier in it. This mode is handy when the management
          of complex combinations of &quot;Set-cookie&quot; and &quot;Cache-control&quot;
          headers is left to the application. The application can then
          decide whether or not it is appropriate to emit a persistence
          cookie. Since all responses should be monitored, this mode
          doesn'&lt;/span&gt;t work &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; HTTP tunnel mode. Unless the application
          behaviour &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; very complex &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt;/&lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; broken, it &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; advised &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; to
          start &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; this mode &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; new deployments. This keyword &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt;
          incompatible &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;insert&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;prefix&quot;&lt;/span&gt;.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当后端服务器设置了cookie时，使用rewrite模式时，haproxy将重写该cookie的&lt;strong&gt;值&lt;/strong&gt;为后端服务器的标识符。当应用程序需要同时考虑&quot;Set-Cookie&quot;和&quot;Cache-control&quot;字段时，该模式非常方便，因为应用程序可以决定是否应该设置一个为了保持会话的cookie。除非后端应用程序的环境非常复杂，否则不建议使用该模式。&lt;/p&gt;
&lt;p&gt;同样，rewrite模式下的haproxy设置的cookie必须和后端服务器设置的cookie名称一致，否则不会做任何改变。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;backend&lt;/span&gt; dynamic_group
    cookie PHPSESSID rewrite
    server app1 &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.60:80&lt;/span&gt; cookie app_server1
    server app2 &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.61:80&lt;/span&gt; cookie app_server2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180313000958352-239554158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，当客户端持着&quot;PHPSESSID=app_server1&quot;再去请求服务器时，haproxy将其分配给app1，app1此时收到的cookie将是重写后的，但是app1根本就不认识这个cookie，后面的代码可能因此而失去逻辑无法进行正确处理。&lt;/p&gt;


&lt;p&gt;在haproxy中，haproxy会监控、修改、增加cookie，这都是通过内存中的cookie表实现的。&lt;/p&gt;
&lt;p&gt;cookie表中记录了它自己增、改的cookie记录，包括cookie名和对应server的cookie值，通过这个cookie记录，haproxy就能知道请求该交给哪个后端。&lt;/p&gt;
&lt;p&gt;例如，当haproxy插入一个cookie的时候。即在haproxy配置如下后端。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;backend dynamic_group
    cookie app_cook &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; nocache
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.60:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server1
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server2&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，从客户端第一次请求到第二次请求被处理的整个过程，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180312162519187-676816261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当haproxy成功修改了响应报文中的cookie时，将在cookie表中插入一条记录，这条记录是维持会话的依据。&lt;/p&gt;
&lt;p&gt;其实，通过cookie表保持和后端的会话只是默认情况，haproxy允许&quot;即使使用了cookie也不进行会话绑定&quot;的功能。这可以通过&lt;code&gt;ignore-persist&lt;/code&gt;指令来实现。当满足该指令的要求时，表示不将该cookie插入到cookie表中，因此无法实现会话保持，即使haproxy设置了cookie也没用。&lt;/p&gt;
&lt;p&gt;例如，在backend中指定如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;backend dynamic_group
    acl  url_dynamic   path_end  -i .php
    ignore-persist if  url_dynamic
    cookie app_cook &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;insert&lt;/span&gt; nocache
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.60:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server1
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; app2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; cookie app_server2&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表示当请求uri以&quot;.php&quot;结尾时，将忽略会话保持功能。这表示，对于php结尾的请求，app_cook这个cookie从头到尾都是摆设。&lt;/p&gt;
&lt;p&gt;当然，上面的设置是不合理的，更合理的应该是这样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;acl url_static  path_beg         /&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; /images /img /css
acl url_static  path_end         .gif .png .jpg .css .js
ignore-persist  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; url_static
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与&lt;code&gt;ignore-persist&lt;/code&gt;相对的是&lt;code&gt;force-persist&lt;/code&gt;，但不建议使用该选项，因为它和&lt;code&gt;option redispatch&lt;/code&gt;冲突。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8553190.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8553190.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 17:18:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8553190.html</dc:identifier>
</item>
<item>
<title>iOS开发——iOS国际化 APP内语言切换 - FrankieZ</title>
<link>http://www.cnblogs.com/FrankieZ/p/8552830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FrankieZ/p/8552830.html</guid>
<description>&lt;p&gt;最近一个一直在迭代的老项目收到一份新的开发需求，项目需要做国际化适配，简体中文+英文。由于项目中采用了storyboard和纯代码两种布局方式，所以国际化也要同时实现。上网查了些资料，实现了更改系统语言后，修改app内语言的问题。具体国际化方式可以参考下文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/88c1b65e3ddb&quot; target=&quot;_blank&quot;&gt;3分钟实现iOS语言本地化/国际化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章讲的比较详细，很容易实现。&lt;/p&gt;
&lt;p&gt;这个需求实现后不久，产品又给我提了一个需求，让我要在app内实现语言切换。还好之前的国际化也做了些准备，不慌不慌。&lt;/p&gt;
&lt;p&gt;接下来就是方案的选定，通过广泛查阅资料，得出两个备选方案：&lt;/p&gt;
&lt;p&gt;方案一：在原国际化版本的基础上做修改，在info.plist文件中新增key=&quot;appLanguage&quot;的键值对，保存用户设定的语言类别。通过切换语言类别来改变语言。（例子：微信）&lt;/p&gt;
&lt;p&gt;优点：之前有国际化操作的基础，执行起来并不复杂。&lt;/p&gt;
&lt;p&gt;缺点：切换完语言后，需要重新创建app keywindow的跟控制器，会有个跳转的过程，用户体验不好。&lt;/p&gt;
&lt;p&gt;方案二：切换语言后，发送通知，每个控制器收到通知后，更改语言。（例子：新浪微博）&lt;/p&gt;
&lt;p&gt;优点：很自然的切换语言，选择语言后即可切换，不需要重置根控制器，用户体验好。&lt;/p&gt;
&lt;p&gt;缺点：每个控制器都得注册接收通知，工作量太大，而且storyboard也得单独处理。&lt;/p&gt;
&lt;p&gt;综合两个方案的优缺点，我们选择方案一。&lt;/p&gt;
&lt;p&gt;中英切换，就是让App根据自身设置的语言去读取对应的国际化文件。在NSUserDefault中有一个字段：&quot;AppleLanguages&quot;，这个字段就是负责存储App语言的字段，默认这个字段会根据系统语言去变动，中文系统他就存储中文，英文系统就存储英文。&lt;/p&gt;
&lt;p&gt;废话少说，切换语言的过程上代：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NTVLocalized.h&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; NSString * &lt;span&gt;const&lt;/span&gt; AppLanguage = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;appLanguage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NTVLocalized : NSObject
&lt;/span&gt;+ (NTVLocalized *&lt;span&gt;)sharedInstance;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化多语言功能&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initLanguage;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前语言&lt;/span&gt;
- (NSString *&lt;span&gt;)currentLanguage;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置要转换的语言&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为系统语言&lt;/span&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)systemLanguage;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NTVLocalized.m&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NTVLocalized.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NTVLocalized
&lt;/span&gt;+ (NTVLocalized *&lt;span&gt;)sharedInstance {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; NTVLocalized *instance =&lt;span&gt; nil;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        instance &lt;/span&gt;=&lt;span&gt; [[NTVLocalized alloc] init];
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initLanguage{
    NSString &lt;/span&gt;*language=&lt;span&gt;[self currentLanguage];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (language.length&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;自设置语言:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,language);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        [self systemLanguage];
    }
}

&lt;/span&gt;- (NSString *&lt;span&gt;)currentLanguage{
    NSString &lt;/span&gt;*language=&lt;span&gt;[[NSUserDefaults standardUserDefaults]objectForKey:AppLanguage];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; language;
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language{
    [[NSUserDefaults standardUserDefaults] setObject:language forKey:AppLanguage];
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)systemLanguage{
    NSString &lt;/span&gt;*languageCode = [[NSUserDefaults standardUserDefaults] objectForKey:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;AppleLanguages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;系统语言:%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,languageCode);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;([languageCode hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;zh-Hans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]){
        languageCode &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;zh-Hans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;简体中文&lt;/span&gt;
    }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;([languageCode hasPrefix:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]){
        languageCode &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;英语&lt;/span&gt;
&lt;span&gt;    }
    [self setLanguage:languageCode];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当语言设置完成后，需要重新设置keywindow的rootViewController才可以实现语言的切换。&lt;br/&gt;然而这样设置后，我们发现只有NSLocalizedString(key, comment)设置的语言才能正常显示我们需要的语言，storyBoard和xib配置的页面语言不跟着切换。&lt;br/&gt;设置AppleLanguages字段的话，只会在下次启动App才会生效，在App启动后就已经生成了一个Bundle，里面识别好了对应着AppleLanguages的国际化文件，在App运行期间设置这个字段，是不生效的，所以我们去修改这个Bundle，写一个NSBundle的扩展。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NSBundle+language.h&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NSBundle (language)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置语言&lt;/span&gt;
+ (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NSBundle+language.m&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NSBundle+language.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; _bundle = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; BundleEx : NSBundle

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; BundleEx

&lt;/span&gt;- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *&lt;span&gt;)tableName {
    NSBundle &lt;/span&gt;*bundle = objc_getAssociatedObject(self, &amp;amp;&lt;span&gt;_bundle);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bundle ?&lt;span&gt; [bundle localizedStringForKey:key value:value table:tableName] : [super localizedStringForKey:key value:value table:tableName];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NSBundle (Language)

&lt;/span&gt;+ (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        object_setClass([NSBundle mainBundle], [BundleEx &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;]);
    });
    
    objc_setAssociatedObject([NSBundle mainBundle], &lt;/span&gt;&amp;amp;_bundle, language ? [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:language ofType:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;lproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]] : nil, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新写一下设置语言的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)setLanguage:(NSString *&lt;span&gt;)language{
    [NSBundle setLanguage:language];
    [[NSUserDefaults standardUserDefaults] setObject:language forKey:AppLanguage];
    [[NSUserDefaults standardUserDefaults] synchronize];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上所述，只是修改appleLanguage，在不重启应用的情况下，不能修改语言。所以我们选择修改bundle的方法。&lt;br/&gt;代码在github上可以下载到：&lt;br/&gt;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2FFrankiezZZ%2FNTVLocalized&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/FrankiezZZ/NTVLocalized&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎各位小伙伴加入iOS交流群：140147825&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 15:36:00 +0000</pubDate>
<dc:creator>FrankieZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FrankieZ/p/8552830.html</dc:identifier>
</item>
<item>
<title>.NET Core使用skiasharp文字头像生成方案（基于docker发布） - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8519980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8519980.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目前.NET Core下面针对于图像处理的库微软并没有集成，在.NET FrameWork下我们已经习惯使用System.Drawing类库做简单的图像处理，到了.NET Core下一脸懵逼的我，只能百度+谷歌看看有没啥解决方案，好在网上资料也多，.NET Core下的图像处理还是有些开源库的，我目前使用的其中一个：&lt;a href=&quot;https://github.com/mono/SkiaSharp&quot; target=&quot;_blank&quot;&gt;SkiaSharp&lt;/a&gt;，介绍反正大家自己网上找找都有，下面就用该库实现一个文字头像的小功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、简单的设计要求&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于输入的名字得解析（中文、英文）&lt;/li&gt;
&lt;li&gt;图片背景色随机会换&lt;/li&gt;
&lt;li&gt;文字要居中（废话，不居中不是丑爆了）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三、具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、解析姓名信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String ResolveName(String imageText)
        {
            imageText.Replace(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;).Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除路径不支持的信息&lt;/span&gt;
            imageText = imageText.Trim(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去除空格信息&lt;/span&gt;
            String temp2 = imageText.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据第一位的数据判断是走英文规则还是中文规则，都不是的话就是取前两位&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (RegexLib.IsChineseCharacter(temp2))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UserName = UserName.Trim(' ');&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt; &lt;span&gt;2&lt;/span&gt; &amp;amp; imageText.Length &amp;lt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= imageText.Substring(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= imageText.Substring(imageText.Length - &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (RegexLib.IsEnglishCharacter(temp2))
            {
                String[] temp1 &lt;/span&gt;= imageText.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp1.Length == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= (temp1[&lt;span&gt;0&lt;/span&gt;].Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + temp1[&lt;span&gt;1&lt;/span&gt;].Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)).ToUpper();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                    {
                        imageText &lt;/span&gt;= imageText.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;).ToUpper();
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imageText.Length &amp;gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    imageText &lt;/span&gt;= imageText.Substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
                }
            }
            imageName &lt;/span&gt;=&lt;span&gt; imageText;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; imageName;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、根据文字生成图片&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] Create()
        {
            String name &lt;/span&gt;= imageName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            SKBitmap bmp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SKBitmap(&lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;&lt;span&gt;);
            String str &lt;/span&gt;=&lt;span&gt; imageName;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (SKCanvas canvas = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SKCanvas(bmp))
            {

                Random r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = r.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
                canvas.DrawColor(colors[num]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; colors是图片背景颜色集合，这里代码就不贴出来了，随机找一个&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (SKPaint sKPaint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SKPaint())
                {
                    sKPaint.Color &lt;/span&gt;= SKColors.White;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体颜色&lt;/span&gt;
                    sKPaint.TextSize = &lt;span&gt;39&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;
                    sKPaint.IsAntialias = &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启抗锯齿&lt;/span&gt;
                    sKPaint.Typeface = SkiaSharp.SKTypeface.FromFamilyName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, SKTypefaceStyle.Bold);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字体&lt;/span&gt;
                    SKRect size = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SKRect();
                    sKPaint.MeasureText(str, &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt; size);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算文字宽度以及高度&lt;/span&gt;
                    &lt;span&gt;float&lt;/span&gt; temp = (&lt;span&gt;128&lt;/span&gt; - size.Size.Width) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; temp1 = (&lt;span&gt;128&lt;/span&gt; - size.Size.Height) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                    canvas.DrawText(str, temp, temp1 &lt;/span&gt;- size.Top, sKPaint);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画文字&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存成图片文件&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (SKImage img =&lt;span&gt; SKImage.FromBitmap(bmp))
                {
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (SKData p = img.Encode(SKEncodedImageFormat.Jpeg, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;))
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p.ToArray();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;using (var stream = File.Create(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, &quot;photoImage&quot;, name)))
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    stream.Write(p.ToArray(), 0, p.ToArray().Length);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return stream;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我这边只是得到的是byte[]数组，如果需要转成stream或者保存成文件，方法都有，找找肯定都可以找到的，我就不放出来了，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;三、docker发布的坑&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;坑1：IIS下可以，docker下报错的坑爹问题&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于skiasharp在windows跟linux下使用的依赖库是不同的，如果都按照以前的方式部署，在docker里就会出现&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;code&gt;&lt;span&gt;The type initializer for 'SkiaSharp.SKImageInfo' threw an exception&quot;&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;&lt;code&gt;,原因是linux下skiasharp依赖libSkiaSharp.so，而如果系统中没有libSkiaSharp.so，就会报这个错，目前我最简单的操作就是找到这个文件扔在skiasharp的目录下，然后就可以了&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;坑2：中文字体不识别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由于docker内部没有中文字体，SO，当要输出中文的时候就狗带了，如下图，所及解决办法那也就是把字体拷贝到docker内部中去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180312232413401-1144236284.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;下面提供我自己使用的Dockerfile，具体Dockerfile怎么用，那就只能大家自己百度百度（ps：其实真实原因是我自己这方面也是弱鸡- -，怕误导大家），我的环境是CentOS7.3的环境&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#基于 `microsoft/dotnet:latest&lt;span&gt;` 来构建我们的镜像
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; microsoft/dotnet:latest

#拷贝项目publish文件夹中的所有文件到 docker容器中的publish文件夹中  
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . /publish /publish/


#&lt;/span&gt;&lt;span&gt;ENV&lt;/span&gt; LANG C.UTF-8&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ENV&lt;/span&gt; LANGUAGE C.UTF-8&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ENV&lt;/span&gt; LC_ALL C.UTF-8
&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; MSYH.TTC /usr/share/fonts/dejavu
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; MSYHL.TTC /usr/share/fonts/dejavu
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; MSYHBD.TTC /usr/share/fonts/dejavu

#更换软件源为国内的软件源
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot;&lt;span&gt; &amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot;&lt;span&gt; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot;&lt;span&gt; &amp;gt;&amp;gt;/etc/apt/sources.list &amp;amp;&amp;amp; \
    echo &lt;/span&gt;&quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot;&lt;span&gt; &amp;gt;&amp;gt;/etc/apt/sources.list
#&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get update &amp;amp;&amp;amp; apt-get install -y libfontconfig1 &amp;amp;&amp;amp; apt-get install -y fontconfig
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get update &amp;amp;&amp;amp;  apt-get install -y fontconfig

#设置工作目录为 `/publish` 文件夹，即容器启动默认的文件夹
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /publish

#设置Docker容器对外暴露5000端口
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt; 5000&lt;span&gt;

#使用`dotnet WebApplication1.dll`来运行应用程序

&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt; [&quot;dotnet&quot;, &quot;WebApplication1.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　上张成功的图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180312232658971-1091860202.png&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;587&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　&lt;a href=&quot;https://pan.baidu.com/s/1pDEk1ToAtCtPJ83YwHKqsw&quot; target=&quot;_blank&quot;&gt;最后DEMO地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;docker是个好东西，只是我太弱鸡，大概需要花更多的时间去学习吧，程序员可能真的得&lt;strong&gt;活到老学到老！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;PS:以上的只是我自己摸索出来的，如果大家有更好的实现方式欢迎讨论，谢谢观看&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　最后熊本熊镇随笔，该死的K8S，该死的docker！！！&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180311204856835-1835894165.jpg&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;512&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docker等互联网相关（最近被互联网架构搞的死去活来- -）&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，如有问题， 可站内留言联系.&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8519980.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（五）WPF依赖属性 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8552795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8552795.html</guid>
<description>&lt;p&gt;      在.NET中有事件也有属性，WPF中加入了路由事件，也加入了依赖属性。最近在写项目时还不知道WPF依赖属性是干什么用的，在使用依赖项属性的时候我都以为是在用.NET中的属性，但是确实上不是的，通过阅读文章和看WPF的书籍已经了解了WPF的依赖属性的使用，我们今天就来看看为什么WPF中要加入依赖属性？&lt;/p&gt;

&lt;p&gt;一、什么是依赖属性&lt;/p&gt;
&lt;p&gt;       WPF中的依赖属性有别于.NET中的属性，因为在WPF中有几个很重要的特征都是需要依赖项属性的支持，例如数据绑定，动画，样式设置等。WPF绝大多数属性都是依赖项属性，只不过它是用了普通的.NET属性过程进行了包装，通过这种包装，就可以像使用属性一样使用依赖项属性了，在后面会说一下怎么通过这种方式包装的。这就使用了旧技术来包装新技术的设计理念就不会干扰.NET。WPF中的依赖属性主要有以下三个优点：&lt;/p&gt;
&lt;p&gt;    1、依赖属性加入了属性变化通知、限制、验证等功能。这样可以使我们更方便地实现应用，同时大大减少了代码量。&lt;/p&gt;
&lt;p&gt;    2、节约内存：在WinForm中，每个UI控件的属性都赋予了初始值，这样每个相同的控件在内存中都会保存一份初始值。而WPF依赖属性很好地解决了这个问题，它内部实现使用哈希表存储机制，对多个相同控件的相同属性的值都只保存一份。&lt;/p&gt;
&lt;p&gt;      3、支持多种提供对象：可以通过多种方式来设置依赖属性的值。可以配合表达式、样式和绑定来对依赖属性设置值。&lt;/p&gt;

&lt;p&gt;     刚才我们一直在说属性，先来看看属性是什么吧。先创建一个类Person，里面有name属性。&lt;/p&gt;
&lt;p&gt;public class Person&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;       public string name{set;get;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;上面就是创建好的属性，看着是不是很简单。属性的创建就是这么简单，在我们想要使用这个类的地方初始化就能用。&lt;/p&gt;
&lt;p&gt;       既然说WPF中绝大多数的属性都是依赖项属性，我看了一下依赖属性怎么进行创建。&lt;/p&gt;
&lt;p&gt;        1、依赖属性的所在类型继承自DependencyObject类。&lt;/p&gt;
&lt;p&gt;        2、使用public static 声明一个DependencyProperty的变量，该变量就是真正的依赖属性。&lt;/p&gt;
&lt;p&gt;        3、类型的静态构造函数中通过Register方法完成依赖属性的元数据注册。&lt;/p&gt;
&lt;p&gt;        4、提供依赖属性的包装属性，通过这个属性来完成对依赖属性的读写操作。&lt;/p&gt;
&lt;p&gt;创建代码如下：&lt;/p&gt;
&lt;p&gt;//依赖属性必须在依赖对象DependencyObject&lt;/p&gt;
&lt;p&gt;Public class Person : DependencyObject &lt;/p&gt;
&lt;p&gt;{ &lt;/p&gt;
&lt;p&gt;    //CLR属性包装器，使得依赖属性NameProperty在外部能够像普通属性那样使用 &lt;/p&gt;
&lt;p&gt;    public string Name &lt;/p&gt;
&lt;p&gt;    { &lt;/p&gt;
&lt;p&gt;        get { return (string)GetValue(NameProperty); } &lt;/p&gt;
&lt;p&gt;        set { SetValue(NameProperty, value); } &lt;/p&gt;
&lt;p&gt;    } &lt;/p&gt;

&lt;p&gt; //依赖属性必须为static readonly&lt;/p&gt;
&lt;p&gt;//DependencyProperty.Register 参数说明&lt;/p&gt;
&lt;p&gt;//第一个参数是string类型的，是属性名。&lt;/p&gt;
&lt;p&gt;//第二个参数是这个依赖项属性的类型。&lt;/p&gt;
&lt;p&gt;//第三个参数是这个拥有这个依赖项属性的类型。&lt;/p&gt;
&lt;p&gt;//第四个参数是具有附加属性设置的FramWorkPropertyMetadata对象。&lt;/p&gt;
&lt;p&gt;    public static readonly DependencyProperty NameProperty = &lt;/p&gt;
&lt;p&gt;        DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(Person), new PropertyMetadata(&quot;DefaultName&quot;)); &lt;/p&gt;

&lt;p&gt;} &lt;/p&gt;
&lt;p&gt;      从上面代码可以看出，依赖属性是通过调用DependencyObject的GetValue和SetValue来对依赖属性进行读写的。它使用哈希表来进行存储的，对应的Key就是属性的HashCode值，而值（Value）则是注册的DependencyPropery；而C#中的属性是类私有字段的封装，可以通过对该字段进行操作来对属性进行读写。属性是字段的包装，WPF中使用属性对依赖属性进行包装。&lt;/p&gt;

&lt;p&gt;二、依赖属性的优先级&lt;/p&gt;
&lt;p&gt;       WPF 属性系统提供一种强大的方法，使得依赖属性的值由多种因素决定，从而实现诸如实时属性验证、后期绑定以及向相关属性发出有关其他属性值发生更改的通知等功能。 用来确定依赖属性值的确切顺序和逻辑相当复杂。 了解此顺序有助于避免不必要的属性设置，并且还有可能澄清混淆，使你正确了解为何某些影响或预测依赖属性值的尝试最终却没有得出所期望的值。依赖属性可以在多个位置“设置”,界面代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232459435-767291659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       本地属性集在设置时具有最高优先级，动画值和强制除外。 如果在本地设置某个值，你可以期待该值优先得到应用，甚至期待其优先级高于任何样式或控件模板。 在上面示例中，此处Background本地设置为红色。 因此，即使它是隐式样式，否则将会应用于该作用域中的该类型的所有元素，在此作用域中定义的样式不是最高优先级给予Background属性及其值。 如果从该 Button 实例中删除本地值红色，样式将获得优先级，而按钮将从该样式中获得 Background 值。 在该样式中，触发器具有优先级，因此当鼠标位于按钮上时，按钮为蓝色，其他情况下则为绿色。&lt;/p&gt;
&lt;p&gt;       下面的图是在网上找的依赖属性优先级列表图，大家后面再使用属性时可以留意一下优先级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232508531-1425020068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;三、依赖属性的继承&lt;/p&gt;
&lt;p&gt;      依赖属性的继承是WPF属性系统的一项功能。 属性值继承使元素树中的子元素可以从父元素获取特定属性的值，并继承该值，就如同它是在最近的父元素中任意位置设置的一样。 父元素可能也已通过属性值继承获得了其值，因此系统有可能一直递归到页面根。 属性值继承不是默认属性系统行为；属性必须用特定的元数据设置来建立，以便使该属性对子元素启动属性值继承。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232520800-92459507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;        看到上面图片你可能已经发现了问题：StatusBar没有显式设置FontSize值，但它的字体大小没有继承Window.FontSize的值，而是保持了系统的默认值。导致这样的问题是因为并不是所有元素都支持属性值继承的，如StatusBar、Tooptip和Menu控件。另外，StatusBar等控件截获了从父元素继承来的属性，并且该属性也不会影响StatusBar控件的子元素。例如，如果我们在StatusBar中添加一个Button。那么这个Button的FontSize属性也不会发生改变，其值为默认值。&lt;/p&gt;
&lt;p&gt;四、自定义依赖属性    &lt;/p&gt;
&lt;p&gt;       如果想要依赖属性继承，我们可以进行自定义依赖属性继承属性值。&lt;/p&gt;
&lt;p&gt;自定义属性步骤：&lt;/p&gt;
&lt;p&gt;1、创建派生类CustomStackPanl&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232528313-993976264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;创建派生类CustomButton&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232536233-1086736460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、在window控件中引入命名空间&lt;/p&gt;
&lt;p&gt;   xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;&lt;/p&gt;
&lt;p&gt;3、在页面添加Button&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232544789-1078521248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201803/662342-20180312232551908-289486033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;五、依赖属性验证和强制功能&lt;/p&gt;
&lt;p&gt;        在写代码是都会考虑可能发生的错误。在定义属性时，也需要考虑错误设置属性的可能性。对于传统.NET属性，可以在属性的设置器中进行属性值的验证，不满足条件的值可以抛出异常。但对于依赖属性来说，这种方法不合适，因为依赖属性通过SetValue方法来直接设置其值的。然而WPF有其代替的方式，WPF中提供了两种方法来用于验证依赖属性的值。&lt;/p&gt;
&lt;p&gt;       1、ValidateValueCallback:该回调函数可以接受或拒绝新值。该值可作为DependencyProperty.Register方法的一个参数。&lt;/p&gt;
&lt;p&gt;       2、CoerceValueCallback:该回调函数可将新值强制修改为可被接受的值。例如某个依赖属性工作年龄的值范围是25到55，在该回调函数中，可以对设置的值进行强制修改，对于不满足条件的值，强制修改为满足条件的值。如当设置为负值时，可强制修改为0。该回调函数PropertyMetadata构造函数参数进行传递。&lt;/p&gt;


</description>
<pubDate>Mon, 12 Mar 2018 15:28:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8552795.html</dc:identifier>
</item>
<item>
<title>SpringMVC 注解式开发 - hoje</title>
<link>http://www.cnblogs.com/hoje/p/8542532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoje/p/8542532.html</guid>
<description>&lt;p&gt;    SpringMVC的注解式开发是指，处理器是基于注解的类的开发。对于每一个定义的处理器，无需再配置文件中逐个注册，只需在代码中通过对类与方法的注解，便可完成注册。即注解替换是配置文件中对于处理器的注册部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、第一个注解式开发程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310172921640-742590810.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3ff237b0-46b3-4a8e-b0e4-fcda60ac48df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3ff237b0-46b3-4a8e-b0e4-fcda60ac48df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ff237b0-46b3-4a8e-b0e4-fcda60ac48df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;%@page isELIgnored=&quot;false&quot; %&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 5&lt;/span&gt;   &amp;lt;head&amp;gt; 
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;title&amp;gt;welcome page&amp;lt;/title&amp;gt;
&lt;span&gt; 7&lt;/span&gt;   &amp;lt;/head&amp;gt;
&lt;span&gt; 8&lt;/span&gt;   
&lt;span&gt; 9&lt;/span&gt;   &amp;lt;body&amp;gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    ${message}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   &amp;lt;/body&amp;gt;
&lt;span&gt;12&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;welcome.xml&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_bd751ea7-c824-4b07-9350-b3043e9acd65&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bd751ea7-c824-4b07-9350-b3043e9acd65&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bd751ea7-c824-4b07-9350-b3043e9acd65&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; @Controller &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前类是一个处理器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyController  {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;      @RequestMapping(&quot;/my.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView handleRequest(HttpServletRequest request, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         ModelAndView mv= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         mv.addObject(&quot;message&quot;,&quot;hello SpringMVC World!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         mv.setViewName(&quot;/WEB-INF/jsp/welcome.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyController&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_513b9d48-8901-48a2-97d4-a204e2ec9c1a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_513b9d48-8901-48a2-97d4-a204e2ec9c1a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_513b9d48-8901-48a2-97d4-a204e2ec9c1a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt; 3&lt;/span&gt;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt;         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
&lt;span&gt; 5&lt;/span&gt;         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
&lt;span&gt; 6&lt;/span&gt;         xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
&lt;span&gt; 7&lt;/span&gt;         xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
&lt;span&gt; 8&lt;/span&gt;         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
&lt;span&gt; 9&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;  &amp;lt;!--   注册组件扫描器 --&amp;gt;
&lt;span&gt;19&lt;/span&gt;    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.jmu.handlers&quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;
&lt;span&gt;20&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;springmvc.xml&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_94067735-dcf2-4eb4-84d9-661d3801ca23&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_94067735-dcf2-4eb4-84d9-661d3801ca23&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94067735-dcf2-4eb4-84d9-661d3801ca23&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;   &amp;lt;display-name&amp;gt;01-springmvc-primary&amp;lt;/display-name&amp;gt;
&lt;span&gt; 4&lt;/span&gt;   &amp;lt;servlet&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;
&lt;span&gt; 7&lt;/span&gt;     &amp;lt;init-param&amp;gt;
&lt;span&gt; 8&lt;/span&gt;       &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
&lt;span&gt; 9&lt;/span&gt;       &amp;lt;param-value&amp;gt;classpath:springMVC.xml&amp;lt;/param-value&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;/init-param&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
&lt;span&gt;12&lt;/span&gt;   &amp;lt;/servlet&amp;gt;
&lt;span&gt;13&lt;/span&gt;   &amp;lt;servlet-mapping&amp;gt;
&lt;span&gt;14&lt;/span&gt;     &amp;lt;servlet-name&amp;gt;springMVC&amp;lt;/servlet-name&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;url-pattern&amp;gt;*.&lt;span&gt;do&lt;/span&gt;&amp;lt;/url-pattern&amp;gt;
&lt;span&gt;16&lt;/span&gt;   &amp;lt;/servlet-mapping&amp;gt;
&lt;span&gt;17&lt;/span&gt;   &amp;lt;welcome-file-list&amp;gt;
&lt;span&gt;18&lt;/span&gt;     &amp;lt;welcome-file&amp;gt;index.jsp&amp;lt;/welcome-file&amp;gt;
&lt;span&gt;19&lt;/span&gt;   &amp;lt;/welcome-file-list&amp;gt;
&lt;span&gt;20&lt;/span&gt; &amp;lt;/web-app&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;web.xml&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310173213702-1020286407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、处理器的请求映射规则的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）对请求URI的命名空间的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; A、一个处理器定义多个处理方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310173911610-1522647593.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310173918924-895773311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_61529add-4797-4de6-89f1-c221f0d77ca7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_61529add-4797-4de6-89f1-c221f0d77ca7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_61529add-4797-4de6-89f1-c221f0d77ca7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Controller &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前类是一个处理器&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyController{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;      @RequestMapping({&quot;/my.do&quot;,&quot;hello.do&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView doFirst(HttpServletRequest request, 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         ModelAndView mv= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         mv.addObject(&quot;message&quot;,&quot;执行doFirst()方法&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         mv.setViewName(&quot;/WEB-INF/jsp/welcome.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      @RequestMapping(&quot;/second.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ModelAndView Second(HttpServletRequest request, 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;              HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;          ModelAndView mv= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;          mv.addObject(&quot;message&quot;,&quot;执行doSecond()方法&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;          mv.setViewName(&quot;/WEB-INF/jsp/welcome.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;          &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mv;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MyController&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310181014647-1770111334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B、命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310182434471-489199689.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310182543886-362621368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)请求URI中通配符的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180310191858345-1859824804.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3） 对请求提交方式的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180312230811961-1083346134.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
     @RequestMapping(value={&quot;/my.do&quot;,&quot;hello.do&quot;},method=RequestMethod.POST)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4)对于请求中携带参数的定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180312232335365-218257387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1212417/201803/1212417-20180312232357843-1940473335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 15:27:00 +0000</pubDate>
<dc:creator>hoje</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoje/p/8542532.html</dc:identifier>
</item>
<item>
<title>跨域请求的常用方式及解释 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8545462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8545462.html</guid>
<description>&lt;p&gt;首先基于安全的原因，浏览器是存在&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/JavaScript%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&quot;&gt;同源策略&lt;/a&gt;这个机制的，&lt;span&gt;同源策略阻止从一个域加载的脚本去获取另一个域上的文档属性。&lt;/span&gt;也就是说，受到请求的 URL 的域必须与当前 Web 页面的域相同。这意味着浏览器隔离来自不同源的内容，以防止它们之间的操作。&lt;/p&gt;
&lt;p&gt;js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要协议、域名、端口有任何一个不同，都被当作是不同的域。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;下面介绍几种常用的跨域请求方式&lt;/h2&gt;
&lt;p&gt;默认端口为：8080&lt;/p&gt;
&lt;h4&gt;一、利用jQuery获取jsonp&lt;/h4&gt;
&lt;h4&gt;JSONP的原理与实现思路&lt;/h4&gt;
&lt;p&gt;1）Web页面调用js文件，可跨域。扩展：&lt;span&gt;但凡有src属性的标签都具有跨域能力。&lt;/span&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;
2）跨域服务器 动态生成数据 并存入js文件(通常json后缀)，供客户端调用。&lt;br data-filtered=&quot;filtered&quot;/&gt;
3）为了便于客户端使用数据，形成一个非正式传输协议，称为JSONP。&lt;span&gt;该协议重点是允许用户传递一个callback参数给服务器&lt;/span&gt;，然后服务器返回数据时 &lt;span&gt;将此callback参数作为函数名包裹住JSON数据&lt;/span&gt;，使得客户端可以随意定制自己的函数来自动处理返回数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 1.1如果我们不用跨域请求的写法的话：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312081219802-2131253364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2使用跨越请求的写法，最简单的就是设置dataType:jsonp：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jsonp指定服务器返回的数据类型为jsonp格式，可以看发起的请求路径，自动带了一个callback=xxx，xxx是jquery随机生成的一个回调函数名称。&lt;/p&gt;
&lt;p&gt;这里的success默认success()作为回调函数。数据返回到前端后，&lt;span&gt;就是success(result)的形式，因为是script脚本，所以自动调用success函数，而result就是success的参数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
       &lt;span&gt; dataType: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'jsonp'&lt;/span&gt;&lt;span&gt;&lt;span&gt;,&lt;/span&gt;
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/say&quot;, method =&lt;span&gt; RequestMethod.GET)　　　　　　//后端代码
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String say(@RequestParam(&quot;callback&quot;&lt;span&gt;) String callback){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;callback前端传过来的回调函数名称

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
        String result = &quot;{age:22}&quot;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了&lt;/span&gt;
        result = callback + &quot;(&quot; + result + &quot;)&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312082110792-150046606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1.3jsonpCallback&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用回调函数的时候，先调用了指定的showData，然后再调用了success。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        dataType: &lt;/span&gt;'jsonp'&lt;span&gt;,　　　&lt;span&gt;//指定服务器返回的数据类型&lt;/span&gt;　
        &lt;span&gt;jsonpCallback: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'showData'&lt;/span&gt;&lt;span&gt;&lt;span&gt;,　　　&lt;span&gt;　//指定回调函数名称&lt;/span&gt;&lt;/span&gt;
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showData(data) {
    console.log(&lt;/span&gt;&quot;show&quot;+&lt;span&gt;data);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1.4jsonp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分，比如{jsonp:'onJsonPLoad'}会导致将&quot;onJsonPLoad=?&quot;传给服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        dataType: &lt;/span&gt;'jsonp'&lt;span&gt;,
        jsonpCallback: &lt;/span&gt;'showData'&lt;span&gt;,
        &lt;span&gt;jsonp: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;'sendParam'&lt;/span&gt;&lt;span&gt;&lt;span&gt;,　　&lt;span&gt;//指定参数名称&lt;/span&gt;&lt;/span&gt;
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; showData(data) {
    console.log(data);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定jsonp后，后端也要改变：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/say&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String say(@RequestParam(&lt;span&gt;&quot;sendParam&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;) String sendParam&lt;/span&gt;){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sendParam前端传过来的回调函数名称

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
        String result = &quot;{age:22}&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用回调函数名称包裹返回数据，这样，返回数据就作为回调函数的参数传回去了&lt;/span&gt;
        result = sendParam + &quot;(&quot; + result + &quot;)&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312203459273-943117953.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1.5jsonp方式不支持POST方式跨域请求，就算指定成POST方式，会自动转为GET方式；而后端如果设置成POST方式了，那就请求不了了。&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;二、设置CORS头“Access-Control-Allow-Origin”&lt;/h4&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt; CORS的原理：&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;     CORS定义一种跨域访问的机制，可以让AJAX实现跨域访问。CORS 允许一个域上的网络应用向另一个域提交跨域 AJAX 请求。实现此功能非常简单，只需由服务器发送一个响应标头即可。&lt;/p&gt;

&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$('#cors1').click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    $.ajax({
        type:&lt;/span&gt;'get'&lt;span&gt;,
        url:&lt;/span&gt;'http://localhost:8081/girl/hello/say'&lt;span&gt;,
        success:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
            console.log(data);
        }
    })
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;40.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    @RequestMapping(value=&quot;/say&quot;, method =&lt;span&gt; RequestMethod.GET)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String say(HttpServletRequest request, HttpServletResponse response){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置响应头&lt;/span&gt;
        &lt;span&gt;response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);　　//当前我设置的header为“*”，任意一个请求过来之后服务端我们都可以进行处理&amp;amp;响应&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　　　// 指定特定域名可以访问
     　 &lt;span&gt;response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http:localhost:8080/&quot;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据&lt;/span&gt;
        String result = &quot;{age:22}&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180312221546665-1940436512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;三、iframe+&lt;strong&gt;&lt;strong&gt;window.postMessage&lt;/strong&gt;实现跨域&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;script、image、iframe的src都不受同源策略的影响。所以我们可以借助这一特点，实现跨域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;发送消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;postMessage(data,origin)方法接受两个参数&lt;/p&gt;
&lt;p&gt; 1.&lt;strong&gt;data&lt;/strong&gt;:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;origin&lt;/strong&gt;：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为&quot;*&quot;，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为&quot;/&quot;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;ifr&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;http://localhost:8081/girl/b.html&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ifr = document.getElementById(&quot;ifr&quot;&lt;span&gt;);
    ifr.contentWindow.postMessage(&lt;/span&gt;&quot;crsf&quot;,&quot;http://localhost:8081&quot;&lt;span&gt;);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;接收消息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;testb&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;b&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
window.addEventListener('message', function(event){&lt;br/&gt;console.log('origin: '+event.origin);　　　　//origin: http://localhost:8080&lt;br/&gt;console.log('data: '+event.data);　　　　　　//data: crsf&lt;br/&gt;console.log(event.source);&lt;br/&gt;// 回发数据&lt;br/&gt;event.source.postMessage('hello world', event.origin);&lt;br/&gt;});
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有几个重要属性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;origin&lt;/strong&gt;：发送消息窗口的源（协议+主机+端口号）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：顾名思义，是传递来的message&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;source&lt;/strong&gt;：发送消息的窗口对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样就可以接收跨域的消息了，我们还可以发送消息回去。&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Mon, 12 Mar 2018 14:57:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8545462.html</dc:identifier>
</item>
<item>
<title>打造MacOS版“XShell” - mantou叔叔</title>
<link>http://www.cnblogs.com/mantoudev/p/8552613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantoudev/p/8552613.html</guid>
<description>&lt;p&gt;XShell作为一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。作为server端开发，几乎是必备工具了。&lt;/p&gt;
&lt;p&gt;很多刚切换到MacOS环境下的萌新都会面临一个尴尬的问题：XShell并没有提供MacOS版本，在NetSarang（XShell的爸爸）&lt;a href=&quot;https://www.netsarang.com/forum/xshell/1350/Xshell_for_OS_X&quot;&gt;论坛里&lt;/a&gt;群众们也已经向官方呐喊很多年了，却迟迟不见NetSarang有MacOS版本的消息。这对于已经使用习惯Xshell的开发同学无疑是个噩梦。&lt;/p&gt;
&lt;p&gt;记得我刚切到MacOS环境的时候，也是到处查有没有XShell的替代产品，更多的却看到的都是类似的回答：&lt;/p&gt;
&lt;p&gt;现在看看简直是觉得这些误导MacOS萌新回答都应该浸猪笼啊，MacOS自带的Terminal虽然具备ssh的功能，但是也非常不好用，根本满足不了我们高效工作的日常。&lt;/p&gt;
&lt;p&gt;下面开始介绍Mac终端的应该有的正确姿势。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/logo2x.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;iTerm2作为MacOS下Terminal的替代品，支持MacOS v10.10 及以上版本。作为MacOS下最好用的终端应用，Iterm2具备以下特性：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分屏&lt;br/&gt;Iterm2可以把一个Tab分成多个窗口，每个窗口显示一个不同的会话。可以垂直、水平的创建任意数量的窗格。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;标签变色&lt;br/&gt;Iterm2的标签颜色会变化，以指示该tab当前状态。当该标签有新输出的时候，标签会变成洋红色；新的输出长时间没有查看，标签会变成红色。可在设置中关掉该功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;智能选中&lt;br/&gt;在iTerm2中，双击选中，三击选中整行，四击智能选中（规则可配置），可以识别网址，引号引起的字符串，邮箱地址等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在iTerm2中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动补齐&lt;br/&gt;iTerm2可以自动补齐命令，输入若干字符，按&lt;code&gt;⌘+;&lt;/code&gt;弹出自动补齐窗口，列出曾经使用过的命令。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/screenshots/autocomplete.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;历史记录&lt;br/&gt;iTerm2也可以查询历史记录，按&lt;code&gt;⌘+shift+h&lt;/code&gt;弹出历史记录窗口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/screenshots/pastehistory.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Tab搜索&lt;br/&gt;按&lt;code&gt;⌘+option+e&lt;/code&gt;全屏展示所有tab，并可以进行搜索。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.iterm2.com/img/screenshots/expose.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高亮当前鼠标位置&lt;br/&gt;当我们一个标签页中窗口开的太多的时候，会有找不到鼠标指针的情况，按&lt;code&gt;⌘+/&lt;/code&gt;可以高亮鼠标位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/12/ExLxH.md.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有更多特性请查看&lt;a href=&quot;http://www.iterm2.com/features.html&quot;&gt;iTerm2官网&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Xshell非常的方便好用的是因为它能保存你所有的ssh登录帐号信息。MAC下并没有xshell，有些也提供这样的功能，但效果都不好。iTerm2是很好的终端，但却不能很好的支持多profiles，当要管理的机器较多时，就比较麻烦了。好在它有profiles设置，只是不能保存ssh登录帐号及密码，它还提供了加载profiles时执行外部命令的功能，因此，这里就可以使用sshpass来帮它执行。&lt;/p&gt;
&lt;h2 id=&quot;安装sshpass&quot;&gt;3.1 安装sshpass&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://sourceforge.net/projects/sshpass/files/&quot; class=&quot;uri&quot;&gt;http://sourceforge.net/projects/sshpass/files/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压后，进入sshpass目录，执行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./configure
$ make
$ make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sshpass -h&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置密码&quot;&gt;3.2 配置密码&lt;/h2&gt;
&lt;p&gt;让sshpass使用ssh密码，需要先将密码保存在一个文件里，再通过sshpass读文件来获取密码，iTerm2就可以通过这样的命令来登录主机，密码文件很简单，取一个好名字，把密码写进去就可以了，没有别的任何东西，如，在用户目录的sshpass目录建一个名为pass的文件，里面写上主机密码：123456，文件地址为：/Users/&amp;lt;用户名&amp;gt;/sshpass/pwd/&amp;lt;密码文件&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;配置iterm2&quot;&gt;3.3 配置iTerm2&lt;/h2&gt;
&lt;p&gt;打开iTerm2 - Preferences - Profiles&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/12/Ex8rR.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加一个新的profile，其它没什么好配置的，主要是在General的command中选择使用command，命令就是sshpass的执行命令，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/local/bin/sshpass -f /Users/&amp;lt;用户名&amp;gt;/sshpass/pwd/pwd1_file ssh -p22 root@192.168.100.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;/usr/local/bin/sshpass&lt;/code&gt;是sshpass执行文件的路径，如果按默认情况安装，它肯定会出现在这个位置上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 是告诉sshpass加载文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;/Users/&amp;lt;用户名&amp;gt;/sshpass/pwd/pwd1_file&lt;/code&gt;就是要加载的文件，即前面建的密码文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ssh -p22 root@192.168.100.1&lt;/code&gt;是说用ssh链接，端口22，root帐号和IP地址&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;保存后，选择该profile，就可以实际ssh登录。只是如果是本机第一次登录，是不会成功的，因为ssh登录需要你yes确认，会写文件到hosts里，所以第一次会直接失败，再来一次或是先在终端里用ssh &lt;a href=&quot;mailto:root@ip来登录一次&quot;&gt;root@ip来登录一次&lt;/a&gt;，就可以了。&lt;/p&gt;
&lt;p&gt;这样，新建多个profile，就可以实现管理登录了。&lt;/p&gt;
&lt;p&gt;在实际使用过程中，iTerm配合oh-my-zsh能实现更加炫酷的功能，在后续博客中继续讲解oh-my-zsh的配置。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;br/&gt;[1] iTerm2 Feature：&lt;br/&gt;&lt;a href=&quot;http://www.iterm2.com/features.html&quot; class=&quot;uri&quot;&gt;http://www.iterm2.com/features.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 14:54:00 +0000</pubDate>
<dc:creator>mantou叔叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantoudev/p/8552613.html</dc:identifier>
</item>
<item>
<title>一个老王开枪案例带你一步一步领略程序开发的魅力 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8552593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8552593.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　我身边的很多同学都认为学计算机专业的人，代码写的好很正常，认为自己不是学计算机专业的，不会写代码很正常，或者这么说，觉得会写代码是一种天赋。其实不然，我们现在必须要清楚当代社会的局势，当代社会朝着信息化的方向快速的发展，AI的时代即将到来，不会写代码的大学生是不是很low了？何况新加坡总统李显龙写代码都溜得飞起来，作为一个总统都会写代码，我们又何尝不要去学呢？几乎所有专业都有开设编程课程，这是一种思维的体操，把写代码当作一种娱乐也未尝不可？&lt;/p&gt;
&lt;p&gt;　　不要认为写代码是件很难的事情，没有人一出生就什么都会，天才也是要靠勤奋的吖！&lt;/p&gt;
&lt;p&gt;　　有些同学说，代码很长很难理解，看不懂。其实不管做什么事，你只要有耐心，肯钻研，多学多做多问，一切问题都能迎刃而解。&lt;/p&gt;
&lt;p&gt;　　下面我将从实际案例出发，带你体验程序开发独有的魅力，让你爱上编程！！！&lt;/p&gt;
&lt;h2&gt;二、案例及剖析&lt;/h2&gt;
&lt;p&gt;　　老王和隔壁的老宋是对老冤家，有一天老王回家，发现隔壁老宋和他妻子在家，多年的恩怨爆发了，老王跑到柜子里拿着一把枪直奔房间，老王开枪把隔壁老宋打死了，第二天老王就去公安局自首了。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201803/1100338-20180312222003986-195317406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可能有些同学会觉得这个故事很奇葩，很扯淡，emmmmm，反正都是编的故事，就不要在意这么多细节了hhhh，我们需要做的就是用程序来描述下老王开枪打死隔壁老宋这一过程&lt;/p&gt;
&lt;p&gt;　　有同学就会有疑问，不就是老婆跟别人跑了然后拿枪打死那个第三者嘛，这有什么好稀奇的？诶诶诶，计算机应该怎么去理解呢，我们应该怎么去设计这一过程呢？&lt;/p&gt;
&lt;p&gt;　　我们把这一过程概括为以下阶段：&lt;/p&gt;
&lt;p&gt; 　　#1. 创建老王对象&lt;/p&gt;
&lt;p&gt; 　　#2. 创建一个枪对象&lt;/p&gt;
&lt;p&gt;　　 #3. 创建一个弹夹对象&lt;/p&gt;
&lt;p&gt; 　　#4. 创建一些子弹&lt;/p&gt;
&lt;p&gt; 　　#5. 创建一个隔壁老宋&lt;/p&gt;
&lt;p&gt;　　 #6. 老王把子弹安装到弹夹中&lt;/p&gt;
&lt;p&gt; 　　#7. 老王把弹夹安装到枪中&lt;/p&gt;
&lt;p&gt; 　　#8. 老王拿枪&lt;/p&gt;
&lt;p&gt;　　 #9. 老王开枪打隔壁老宋&lt;/p&gt;
&lt;p&gt;这就是程序化的设计思想，到这里，大家是不是对这种程序化的思想多少了解了些呢？&lt;/p&gt;
&lt;p&gt;我们可以继续来看，要实现这一过程，我们将用到当前的主流语言Python来实现，具体过程如下：&lt;/p&gt;
&lt;p&gt;首先，我们先写出基本的框架：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用来控制整个程序的流程&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1. 创建老王对象&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. 创建一个枪对象&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 创建一个弹夹对象&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4. 创建一些子弹&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;5. 创建一个敌人&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;6. 老王把子弹安装到弹夹中&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;7. 老王把弹夹安装到枪中&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;8. 老王拿枪&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;9. 老王开枪打敌人&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义一个main函数，用来控制整个程序的流程&lt;/p&gt;
&lt;p&gt;__name__ 是当前模块名，当模块被直接运行时模块名为 __main__ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。&lt;/p&gt;
&lt;p&gt;第一步，我们需要创建一个老王对象，我们可以这么去写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
laowang = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时需要调用到一个Person类，于是我们就需要去创建一个Person类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;人的类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Person, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们传入了一个参数为老王，于是我们需要定义一个name的形参&lt;/p&gt;
&lt;p&gt;接着第二步，我们需要创建一个枪对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ak47 = Gun(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AK47&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们用到了一个Gun的类，并且传入了一个实参AK47，于是我们需要去创建一个这样的类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gun(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Gun, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录枪的类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三步，我们需要创建一个弹夹对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dan_jia = Danjia(20)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们设置弹夹装的子弹数为20&lt;/p&gt;
&lt;p&gt;此时我们调用到了一个Danjia的类，我们继续去创建这个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Danjia(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹夹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        super(Danjia, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.max_num &lt;/span&gt;= max_num&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹的最大容量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传入的参数max_num用来记录弹夹的最大容量&lt;/p&gt;
&lt;p&gt;第四步，我们需要去创建一些子弹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zi_dan = Zidan(10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，我们设置子弹数为10&lt;/p&gt;
&lt;p&gt;并且我们还需要创建一个Zidan的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Zidan(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;子弹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, sha_shang_li):
        super(Zidan, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.sha_shang_li &lt;/span&gt;= sha_shang_li&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这颗子弹的威力&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们设置了子弹的威力参数，用sha_shang_li参数表示&lt;/p&gt;
&lt;p&gt;到现在为止，我们把所有对象都创建完了&lt;/p&gt;
&lt;p&gt;接下来我们需要对行为进行模拟&lt;/p&gt;
&lt;p&gt;我们来到第五步，我们需要设计出老王把子弹安装到弹夹中这一过程&lt;/p&gt;
&lt;p&gt;我们用中文进行模拟：&lt;/p&gt;
&lt;p&gt;老王.安装子弹到弹夹中(弹夹，子弹)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装子弹到弹夹中(弹夹，子弹)&lt;/span&gt;
    laowang.anzhuang_zidan(dan_jia, zi_dan)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了一个anzhuang_zidan这一方法，结合实际生活，安装子弹这一过程是人来完成的，所以我们在Person类中定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_zidan(self, dan_jia_temp, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把子弹装到弹夹中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.保存子弹(子弹)&lt;/span&gt;
        dan_jia_temp.baocun_zidan(zi_dan_temp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们需要弹夹去保存子弹，此时我们需要在弹夹中定义baocun_zidan这一方法，这一方法当然是在Danjia类中进行定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_zidan(self, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将这颗子弹保存&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.zidan_list.append(zi_dan_temp)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们为了能够保存子弹，我们定义了一个列表zidan_list用来记录所有的子弹的引用，所以我们在Danjia类中进行初始化操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        super(Danjia, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.max_num &lt;/span&gt;= max_num&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹的最大容量&lt;/span&gt;
        self.zidan_list = []&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录所有的子弹的引用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第五步到这里就实现完成了&lt;/p&gt;
&lt;p&gt;接着第六步老王把弹夹安装到枪中&lt;/p&gt;
&lt;p&gt;我们用更形象的语言来进行描述：&lt;/p&gt;
&lt;p&gt;老王.安装弹夹到枪中(枪，弹夹)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装弹夹到枪中(枪，弹夹)&lt;/span&gt;
    laowang.anzhuang_danjia(ak47, dan_jia)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了一个anzhuang_danjia这一方法，结合实际生活，安装弹夹这一过程也是由人来完成的，所以我们在Person类中定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_danjia(self, gun_temp, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把弹夹安装到枪中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.保存弹夹(弹夹)&lt;/span&gt;
        gun_temp.baocun_danjia(dan_jia_temp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们传入了两个参数gun_temp和dan_jia_temp，我们创建了一个gun_temp.baocun_danjia方法，用来保存弹夹，所以在Gun中，我们需要定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_danjia(self, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用一个属性来保存这个弹夹对象的引用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.danjia &lt;/span&gt;= dan_jia_temp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而对Gun类，我们需要进行初始化操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Gun, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录枪的类型&lt;/span&gt;
        self.danjia = None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹对象的引用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们需要测试弹夹信息和枪的信息&lt;/p&gt;
&lt;p&gt;我们需要在弹夹中定义如下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹的信息为:%d/%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(len(self.zidan_list), self.max_num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记录子弹的剩余数/子弹的最大容量&lt;/p&gt;
&lt;p&gt;而测试枪信息，我们在枪这一类中定义了如下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.danjia:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.danjia)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s,这把枪中没有弹夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(self.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此我们测试完成了如上所有操作&lt;/p&gt;
&lt;p&gt;第七步老王拿枪，我们可以写出如下语句：&lt;/p&gt;
&lt;p&gt;老王.拿枪(枪)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.拿枪(枪)&lt;/span&gt;
    laowang.naqiang(ak47)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了naqiang这一方法，我们知道，只有人才会拿枪啊，所以我们需要在Person类中定义一个naqiang的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; naqiang(self, gun_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;拿起一把枪&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.gun &lt;/span&gt;= gun_temp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们需要去测试一下测试老王对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(laowang)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要测试一对象，我们需要定义些人的属性，比如hp，所以我们在Person类中进行初始化的添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Person, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.gun &lt;/span&gt;= None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来保存枪对象的引用&lt;/span&gt;
        self.hp = 100
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开始进行一个测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.gun:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为:%d, 他有枪 %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.hp, self.gun)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为%d, 他没有枪&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(self.name, self.hp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此我们完成了测试阶段&lt;/p&gt;
&lt;p&gt;第八步，我们去创建一个敌人&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;8. 创建一个敌人&lt;/span&gt;
    gebi_laosong = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;隔壁老宋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(gebi_laosong)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再通过第九步，老王开枪打敌人&lt;/p&gt;
&lt;p&gt;我们可以写出如下语句：&lt;/p&gt;
&lt;p&gt;老王.扣扳机(隔壁老宋)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.扣扳机(隔壁老宋)&lt;/span&gt;
&lt;span&gt;    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(laowang)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们定义了一个kou_ban_ji的方法，通过调用这个方法，达到敌人hp减少的目的&lt;/p&gt;
&lt;p&gt;所以我们需要在Person类中定义此方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; kou_ban_ji(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让枪发射子弹去打敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.开火(敌人)&lt;/span&gt;
&lt;span&gt;
        self.gun.fire(diren)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且在此方法中又加定义了一个开枪的方法，而通过枪才能打出子弹，所以在Gun中定义了此方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fire(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先从弹夹中取子弹&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.弹出一发子弹()&lt;/span&gt;
        zidan_temp =&lt;span&gt; self.danjia.tanchu_zidan()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;让这个子弹去伤害敌人&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; zidan_temp:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子弹.打中敌人(敌人)&lt;/span&gt;
&lt;span&gt;            zidan_temp.dazhong(diren)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹中没有子弹了。。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且我们进行了子弹数测试&lt;/p&gt;
&lt;p&gt;子弹要从弹夹中弹出去，我们继续在Danjia中定义tanchu_zidan方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tanchu_zidan(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹出最上面的那颗子弹&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.zidan_list:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.zidan_list.pop()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且子弹打中人会让人掉hp，所以我们需要在子弹中定义一个dazhong方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dazhong(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让敌人掉血&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;敌人.掉血(一颗子弹的威力)&lt;/span&gt;
&lt;span&gt;        diren.xiao_xue(self.sha_shang_li)
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;人会掉hp，继续在Person类中定义xiao_xue方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; xiao_xue(self, sha_shang_li):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据杀伤力，掉相应的血量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.hp &lt;/span&gt;-= sha_shang_li
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，通过测试，我们已经完成了整个流程的设计和开发，虽然很简单的一个问题，但是在程序设计阶段，每一步骤都是紧密相连的，这就是作为一个程序狗每天需要面对的问题，看起来很冗长，其实思路并不复杂，一个不懂程序的人都能看懂的执行步骤，我希望越来越多的人能够喜欢编程，我们国家缺的就是这种人才，只要每个人多贡献出自己的一份力量，AI的到来将离我们更近一步！！！&lt;/p&gt;
&lt;p&gt;附上以上所提到的源码，我进行了汇总，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;人的类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Person, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.gun &lt;/span&gt;= None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来保存枪对象的引用&lt;/span&gt;
        self.hp = 100

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_zidan(self, dan_jia_temp, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把子弹装到弹夹中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.保存子弹(子弹)&lt;/span&gt;
&lt;span&gt;        dan_jia_temp.baocun_zidan(zi_dan_temp)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; anzhuang_danjia(self, gun_temp, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;把弹夹安装到枪中&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.保存弹夹(弹夹)&lt;/span&gt;
&lt;span&gt;        gun_temp.baocun_danjia(dan_jia_temp)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; naqiang(self, gun_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;拿起一把枪&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.gun &lt;/span&gt;=&lt;span&gt; gun_temp

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.gun:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为:%d, 他有枪 %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.hp, self.gun)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.hp&amp;gt;&lt;span&gt;0:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的血量为%d, 他没有枪&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.hp)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s 已挂....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;self.name

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; kou_ban_ji(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让枪发射子弹去打敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;枪.开火(敌人)&lt;/span&gt;
&lt;span&gt;
        self.gun.fire(diren)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; xiao_xue(self, sha_shang_li):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据杀伤力，掉相应的血量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.hp &lt;/span&gt;-=&lt;span&gt; sha_shang_li

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Gun(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name):
        super(Gun, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.name &lt;/span&gt;= name&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录枪的类型&lt;/span&gt;
        self.danjia = None&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹对象的引用&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_danjia(self, dan_jia_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用一个属性来保存这个弹夹对象的引用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.danjia &lt;/span&gt;=&lt;span&gt; dan_jia_temp

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.danjia:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name, self.danjia)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;枪的信息为:%s,这把枪中没有弹夹&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(self.name)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fire(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;枪从弹夹中获取一发子弹，然后让这发子弹去击中敌人&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先从弹夹中取子弹&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;弹夹.弹出一发子弹()&lt;/span&gt;
        zidan_temp =&lt;span&gt; self.danjia.tanchu_zidan()

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;让这个子弹去伤害敌人&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; zidan_temp:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子弹.打中敌人(敌人)&lt;/span&gt;
&lt;span&gt;            zidan_temp.dazhong(diren)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹中没有子弹了。。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)



&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Danjia(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹夹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        super(Danjia, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.max_num &lt;/span&gt;= max_num&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录弹夹的最大容量&lt;/span&gt;
        self.zidan_list = []&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用来记录所有的子弹的引用&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; baocun_zidan(self, zi_dan_temp):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将这颗子弹保存&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        self.zidan_list.append(zi_dan_temp)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;弹夹的信息为:%d/%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(len(self.zidan_list), self.max_num)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; tanchu_zidan(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;弹出最上面的那颗子弹&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.zidan_list:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.zidan_list.pop()
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Zidan(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;子弹类&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, sha_shang_li):
        super(Zidan, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.sha_shang_li &lt;/span&gt;= sha_shang_li&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这颗子弹的威力&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dazhong(self, diren):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;让敌人掉血&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;敌人.掉血(一颗子弹的威力)&lt;/span&gt;
&lt;span&gt;        diren.xiao_xue(self.sha_shang_li)
        

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用来控制整个程序的流程&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1. 创建老王对象&lt;/span&gt;
    laowang = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;老王&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;2. 创建一个枪对象&lt;/span&gt;
    ak47 = Gun(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AK47&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3. 创建一个弹夹对象&lt;/span&gt;
    dan_jia = Danjia(20&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;4. 创建一些子弹&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(15&lt;span&gt;):
        zi_dan &lt;/span&gt;= Zidan(10&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;5. 老王把子弹安装到弹夹中&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装子弹到弹夹中(弹夹，子弹)&lt;/span&gt;
&lt;span&gt;        laowang.anzhuang_zidan(dan_jia, zi_dan)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;6. 老王把弹夹安装到枪中&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.安装弹夹到枪中(枪，弹夹)&lt;/span&gt;
&lt;span&gt;    laowang.anzhuang_danjia(ak47, dan_jia)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;test:测试弹夹的信息&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(dan_jia)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;test:测试枪的信息&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ak47)&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;7. 老王拿枪&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.拿枪(枪)&lt;/span&gt;
&lt;span&gt;    laowang.naqiang(ak47)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;test:测试老王对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;8. 创建一个敌人&lt;/span&gt;
    gebi_laosong = Person(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;隔壁老宋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;9. 老王开枪打敌人&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;老王.扣扳机(隔壁老宋)&lt;/span&gt;
&lt;span&gt;    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)
    laowang.kou_ban_ji(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gebi_laosong)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(laowang)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 12 Mar 2018 14:51:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8552593.html</dc:identifier>
</item>
<item>
<title>Django使用Celery异步任务队列 - MyStitch</title>
<link>http://www.cnblogs.com/StitchSun/p/8552488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StitchSun/p/8552488.html</guid>
<description>&lt;p&gt;Celery是异步任务队列，可以独立于主进程运行，在主进程退出后，也不影响队列中的任务执行。&lt;/p&gt;
&lt;p&gt;任务执行异常退出，重新启动后，会继续执行队列中的其他任务，同时可以缓存停止期间接收的工作任务，这个功能依赖于消息队列（MQ、Redis）。&lt;/p&gt;

&lt;h2&gt;1.1  Celery原理&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312220551760-1854792439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Celery的&lt;a title=&quot;大型网站架构知识库&quot; href=&quot;http://lib.csdn.net/base/architecture&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;架构&lt;/strong&gt;&lt;/a&gt;由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消息中间件：Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，&lt;strong&gt;RabbitMQ&lt;/strong&gt;, &lt;a title=&quot;Redis知识库&quot; href=&quot;http://lib.csdn.net/base/redis&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;Redis&lt;/strong&gt;&lt;/a&gt;, &lt;a title=&quot;MongoDB知识库&quot; href=&quot;http://lib.csdn.net/base/mongodb&quot; target=&quot;_blank&quot;&gt;MongoDB&lt;/a&gt; (experimental), Amazon SQS (experimental),CouchDB (experimental), SQLAlchemy (experimental),Django ORM (experimental), IronMQ。推荐使用：RabbitMQ、Redis作为消息队列。&lt;/li&gt;
&lt;li&gt;任务执行单元：Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。&lt;/li&gt;
&lt;li&gt;任务结果存储：Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, Redis，memcached, MongoDB，SQLAlchemy, Django ORM，Apache Cassandra, IronCache&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1.2     Celery适用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;异步任务处理：例如给注册用户发送短消息或者确认邮件任务。&lt;/li&gt;
&lt;li&gt;大型任务：执行时间较长的任务，例如视频和图片处理，添加水印和转码等，需要执行任务时间长。&lt;/li&gt;
&lt;li&gt;定时执行的任务：支持任务的定时执行和设定时间执行。例如性能压测定时执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2.1     环境准备&lt;/h2&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;软件名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;版本号&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Linux&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Centos 6.5（64bit）&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;操作系统&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;3.5.2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Django&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;1.10&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Web框架&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Celery&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;4.0.2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;异步任务队列&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;Redis&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;2.4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;310&quot;&gt;
&lt;p&gt;消息队列&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;2.2     Celery安装&lt;/h2&gt;
&lt;p&gt;使用方法介绍：&lt;/p&gt;
&lt;p&gt;Celery的运行依赖消息队列，使用时需要安装redis或者rabbit。&lt;/p&gt;
&lt;p&gt;这里我们使用Redis。安装redis库:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo yum install redis
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动redis:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo service redis start
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装celery库&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo pip install celery==4.0.2
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3.1     编写任务&lt;/h2&gt;
&lt;p&gt;创建task.py文件&lt;/p&gt;
&lt;p&gt;说明：这里初始Celery实例时就加载了配置，使用的redis作为消息队列和存储任务结果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221014875-1701772480.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行celery：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ celery -A task worker --loglevel=info
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;看到下面的打印，说明celery成功运行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221155056-676879418.png&quot; alt=&quot;&quot; width=&quot;915&quot; height=&quot;414&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2     调用任务&lt;/h2&gt;
&lt;p&gt; 直接打开python交互命令行&lt;/p&gt;
&lt;p&gt; 执行下面代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221331437-644889172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以celery的窗口看到任务的执行信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221504903-2055971304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;任务执行状态监控和获取结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312221553984-2135758219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;3.3     任务调用方法总结&lt;/h2&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;p&gt;delay和apply_async ，delay方法是apply_async简化版。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
add.delay(2, 2&lt;span&gt;)
add.apply_async((&lt;/span&gt;2, 2&lt;span&gt;))
add.apply_async((&lt;/span&gt;2, 2), queue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lopri&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;delay方法是apply_async简化版本。&lt;/p&gt;
&lt;p&gt;apply_async方法是可以带非常多的配置参数，包括指定队列等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Queue 指定队列名称，可以把不同任务分配到不同的队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3.4     任务状态&lt;/h2&gt;
&lt;p&gt;每个任务有三种状态：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PENDING -&amp;gt; STARTED -&amp;gt; SUCCESS
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;任务查询状态：&lt;/p&gt;

&lt;p&gt;来查询任务的状态&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222001109-17549582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;上面简单介绍了celery异步任务的基本方法，结合我们实际的应用，我们需要与Django一起使用，下面介绍如何与Django结合。&lt;/p&gt;
&lt;h2&gt;4.1     与Django集成方法&lt;/h2&gt;
&lt;p&gt;与Django集成有两种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Django 1.8 以上版本：与Celery 4.0版本集成&lt;/li&gt;
&lt;li&gt;Django 1.8 以下版本：与Celery3.1版本集成，使用django-celery库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今天我们介绍celery4.0 和django 1.8以上版本集成方法。&lt;/p&gt;
&lt;h2&gt;4.2     创建项目文件&lt;/h2&gt;
&lt;p&gt;创建一个项目：名字叫做proj&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- proj/
  - proj/&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
  &lt;/span&gt;- proj/&lt;span&gt;settings.py
  &lt;/span&gt;- proj/&lt;span&gt;urls.py
  &lt;/span&gt;- proj/&lt;span&gt;wsgi.py
&lt;/span&gt;- manage.py
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;创建一个新的文件：&lt;cite&gt;proj/proj/mycelery.py&lt;/cite&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import, unicode_literals
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; celery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Celery
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; set the default Django settings module for the 'celery' program.&lt;/span&gt;
os.environ.setdefault(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DJANGO_SETTINGS_MODULE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;proj.settings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
app &lt;/span&gt;= Celery(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Using a string here means the worker don't have to serialize&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; the configuration object to child processes.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; - namespace='CELERY' means all celery-related configuration keys&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;   should have a `CELERY_` prefix.&lt;/span&gt;
app.config_from_object(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.conf:settings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CELERY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Load task modules from all registered Django app configs.&lt;/span&gt;
app.autodiscover_tasks()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在proj/proj/__init__.py:添加&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import, unicode_literals
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; This will make sure the app is always imported when&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Django starts so that shared_task will use this app.&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; .mycelery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; app as celery_app
 
&lt;/span&gt;&lt;span&gt;__all__&lt;/span&gt; = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;celery_app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;4.3     配置Celery&lt;/h2&gt;
&lt;p&gt;我们在mycelery.py文件中说明celery的配置文件在settings.py中，并且是以CELERY开头。&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;pre&gt;
   
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
app.config_from_object(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.conf:settings&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CELERY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;在settings.py文件中添加celery配置：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222151591-828225624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们的配置是使用redis作为消息队列，消息的代理和结果都是用redis，任务的序列化使用json格式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;重要：redis：//127.0.0.1:6379/0这个说明使用的redis的0号队列，如果有多个celery任务都使用同一个队列，则会造成任务混乱。最好是celery实例单独使用一个队列。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.4     创建APP&lt;/h2&gt;
&lt;p&gt;创建Django的App，名称为celery_task，在app目录下创建tasks.py文件。&lt;/p&gt;
&lt;p&gt;完成后目录结构为：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;├── celery_task
│   ├── admin.py
│   ├── apps.py
│   ├── &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
│   ├── migrations
│   │   └── &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
│   ├── models.py
│   ├── tasks.py
│   ├── tests.py
│   └── views.py
├── db.sqlite3
├── manage.py
├── proj
│   ├── celery.py
│   ├── &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── templates&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;4.5     编写task任务&lt;/h2&gt;
&lt;p&gt;编辑任务文件&lt;/p&gt;

&lt;p&gt;在tasks.py文件中添加下面代码&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your tasks here&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; absolute_import, unicode_literals
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; celery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; shared_task&lt;br/&gt;@shared_task
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y
 
@shared_task
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mul(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; y
 
@shared_task
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; xsum(numbers):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sum(numbers)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;启动celery:&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery -A proj.mycelery worker -l info
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;em&gt;说明：proj&lt;/em&gt;&lt;em&gt;为模块名称，mycelery&lt;/em&gt;&lt;em&gt;为celery&lt;/em&gt;&lt;em&gt;的实例所在的文件。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;启动成功打印：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222350827-358781690.png&quot; alt=&quot;&quot; width=&quot;946&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.6     在views中调用任务&lt;/h2&gt;
&lt;p&gt;在views中编写接口，实现两个功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;触发任务，然后返回任务的结果和任务ID&lt;/li&gt;
&lt;li&gt;根据任务ID查询任务状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222426345-1185482453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;启动django。&lt;/p&gt;
&lt;p&gt;新开一个会话启动celery；启动命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery –A proj.mycelery worker –l info
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;访问&lt;a href=&quot;http://127.0.0.1:8000/add&quot;&gt;http://127.0.0.1:8000/add&lt;/a&gt;，可以看到返回的结果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222906755-1720415155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在celery运行的页面，可以看到下面输出：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312222927285-298528985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.7     在views中查询任务状态&lt;/h2&gt;
&lt;p&gt;有的时候任务执行时间较长，需要查询任务是否执行完成，可以根据任务的id来查询任务状态，根据状态进行下一步操作。&lt;/p&gt;
&lt;p&gt;可以看到任务的状态为：SUCCESS&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312223045426-680539475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Celery作为异步任务队列，我们可以按照我们设置的时间，定时的执行一些任务，例如每日数据库备份，日志转存等。&lt;/p&gt;
&lt;p&gt;Celery的定时任务配置非常简单：&lt;/p&gt;
&lt;p&gt;定时任务的配置依然在setting.py文件中。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;说明：如果觉得celery&lt;/em&gt;&lt;em&gt;的数据配置文件和Django&lt;/em&gt;&lt;em&gt;的都在setting.py&lt;/em&gt;&lt;em&gt;一个文件中不方便，可以分拆出来，只需要在mycelery.py&lt;/em&gt;&lt;em&gt;的文件中指明即可。&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
app.config_from_object(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.conf:yoursettingsfile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, namespace=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CELERY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5.1     任务间隔运行&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每30秒调用task.add&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timedelta

CELERY_BEAT_SCHEDULE &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add-every-30-seconds&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tasks.add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: timedelta(seconds=30&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (16, 16&lt;span&gt;)
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.2     定时执行&lt;/h2&gt;
&lt;p&gt;定时每天早上7：30分运行。&lt;/p&gt;
&lt;p&gt;注意：设置任务时间时注意时间格式，UTC时间或者本地时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;crontab任务&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;每天7:30调用task.add&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; celery.schedules &lt;span&gt;import&lt;/span&gt;&lt;span&gt; crontab

CELERY_BEAT_SCHEDULE &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Executes every Monday morning at 7:30 A.M&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;add-every-monday-morning&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tasks.add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: crontab(hour=7, minute=30&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: (16, 16&lt;span&gt;),
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;5.3     定时任务启动&lt;/h2&gt;
&lt;p&gt;配置了定时任务，除了worker进程外，还需要启动一个beat进程。&lt;/p&gt;
&lt;p&gt;Beat进程的作用就相当于一个定时任务，根据配置来执行对应的任务。&lt;/p&gt;
&lt;h3&gt;5.3.1  启动beat进程&lt;/h3&gt;
&lt;p&gt;命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery -A proj.mycelery beat -l info
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312223328256-792553965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5.3.2  启动worker进程&lt;/h3&gt;
&lt;p&gt;Worker进程启动和前面启动命令一样。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery –A proj.mycelery worker –l info
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/471676/201803/471676-20180312223445916-928268073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Celery任务支持多样的运行模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持动态指定并发数 --autoscale=10,3 (always keep 3 processes, but grow to 10 if necessary).&lt;/li&gt;
&lt;li&gt;支持链式任务&lt;/li&gt;
&lt;li&gt;支持Group任务&lt;/li&gt;
&lt;li&gt;支持任务不同优先级&lt;/li&gt;
&lt;li&gt;支持指定任务队列&lt;/li&gt;
&lt;li&gt;支持使用eventlet模式运行worker&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：指定并发数为1000&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
celery -A proj.mycelery worker -c 1000
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这些可以根据使用的深入自行了解和学习。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p&gt;Celery官网：&lt;/p&gt;
&lt;p&gt;http://docs.celeryproject.org/en/latest/index.html&lt;/p&gt;
&lt;p&gt;Celery与Django：&lt;/p&gt;
&lt;p&gt;http://docs.celeryproject.org/en/latest/getting-started/next-steps.html#next-steps&lt;/p&gt;
&lt;p&gt;celery定时任务：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sicofield/article/details/50937338&quot;&gt;http://blog.csdn.net/sicofield/article/details/50937338&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 12 Mar 2018 14:41:00 +0000</pubDate>
<dc:creator>MyStitch</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StitchSun/p/8552488.html</dc:identifier>
</item>
</channel>
</rss>